import{_,o as r,c as n,a as t,m,t as d,C as g,M as p,U as b,f as u,F as x,p as v,e as y,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},N={class:"review-title"},L={class:"review-content"};function R(s,e,l,h,i,a){return r(),n("div",q,[t("div",T,[t("div",N,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(l.poem.solution),1)])])])}const j=_(k,[["render",R],["__scopeId","data-v-ab3ce734"]]),F=JSON.parse(`[{"question":"def subarray_sum(nums: List[int], target: int) -> bool: Determines if a continuous subarray sums to target. >>> subarray_sum([1, 2, 3, 4], 6) True >>> subarray_sum([1, 2, 3, 4], 10) True >>> subarray_sum([], 0) False >>> subarray_sum([1], 1) True >>> subarray_sum([1], -1) False >>> subarray_sum([0], 0) True >>> subarray_sum([10**6, -10**6, 1, 2, 3], 5) True >>> subarray_sum([1, 2, 3, -10**6, 10**6], 3) True >>> subarray_sum([-1, -2, -3, 1, 2, 3], 0) True >>> subarray_sum([-1, -1, -1, -1], -3) True >>> subarray_sum([1, 2, 3, 4, 5], 20) False >>> subarray_sum([-1, -2, -3, -4, -5], 1) False","solution":"def subarray_sum(nums, target): Determines if a continuous subarray sums to target. Args: nums : list of int - The input list of integers. target : int - The target integer sum. Returns: bool - True if such a subarray exists, False otherwise. current_sum = 0 sum_map = {0: -1} # Maps cumulative sum to index for quick lookup for index, num in enumerate(nums): current_sum += num if (current_sum - target) in sum_map: return True sum_map[current_sum] = index return False"},{"question":"def smallest_possible_length(s: str) -> int: Determines the length of the smallest possible string that can be obtained after applying deletions on adjacent '01' or '10' pairs any number of times. Parameters: s (str): Input string containing only the characters '0' and '1'. Returns: int: The length of the final string after performing all possible deletions. Examples: >>> smallest_possible_length(\\"1100\\") 0 >>> smallest_possible_length(\\"1001\\") 0 >>> smallest_possible_length(\\"1010\\") 0 >>> smallest_possible_length(\\"1111\\") 4 >>> smallest_possible_length(\\"0000\\") 4 >>> smallest_possible_length(\\"1101001\\") 1 >>> smallest_possible_length(\\"01010\\") 1 >>> smallest_possible_length(\\"1010101\\") 1 >>> smallest_possible_length(\\"0101\\") 0 >>> smallest_possible_length(\\"10101\\") 1 >>> smallest_possible_length(\\"0\\") 1 >>> smallest_possible_length(\\"1\\") 1","solution":"def smallest_possible_length(s): Determines the length of the smallest possible string that can be obtained after applying deletions on adjacent '01' or '10' pairs any number of times. Parameters: s (str): Input string containing only the characters '0' and '1'. Returns: int: The length of the final string after performing all possible deletions. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def min_time(tasks): Returns the minimum possible time required to finish all tasks using two processors. tasks: List of integers where tasks[i] represents the amount of time it takes to complete the ith task. Return an integer representing the minimum possible time required to finish all tasks.","solution":"def min_time(tasks): Returns the minimum possible time required to finish all tasks using two processors. tasks: List of integers where tasks[i] represents the amount of time it takes to complete the ith task. Return an integer representing the minimum possible time required to finish all tasks. tasks = sorted(tasks, reverse=True) # Sort tasks in descending order processor_1 = 0 processor_2 = 0 for task in tasks: if processor_1 <= processor_2: processor_1 += task else: processor_2 += task return max(processor_1, processor_2)"},{"question":"def min_removals_to_equalize_grid(grid: List[List[int]]) -> int: Given an m x n integer grid \`grid\`, return the minimum number of cells you need to remove to make all the remaining elements in the grid equal. You can remove a cell from the grid only if it has at least one immediate neighbor (top, bottom, left, or right). If it is impossible to make all remaining elements equal, return \`-1\`. >>> min_removals_to_equalize_grid([[1, 2, 1], [1, 1, 2], [2, 1, 1]]) == 3 >>> min_removals_to_equalize_grid([[1, 1], [2, 1]]) == 1 >>> min_removals_to_equalize_grid([[3, 3, 3], [3, 2, 3], [3, 3, 3]]) == 1 >>> min_removals_to_equalize_grid([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == -1 >>> min_removals_to_equalize_grid([[1, 2], [3, 4]]) == -1 >>> min_removals_to_equalize_grid([[1]]) == 0 >>> min_removals_to_equalize_grid([[1, 1], [1, 1]]) == 0","solution":"def min_removals_to_equalize_grid(grid): from collections import Counter import operator m, n = len(grid), len(grid[0]) # Flatten the grid into a list of elements elements = [grid[i][j] for i in range(m) for j in range(n)] # Count the frequency of each element using Counter frequency = Counter(elements) # If the most common element count covers more than the half of the cells, itâ€™s possible to make the grid equal max_count = max(frequency.items(), key=operator.itemgetter(1))[1] if max_count >= (m * n) // 2 + 1: return (m * n) - max_count else: return -1"},{"question":"def previousPermutation(n: int, k: int) -> int: Finds the lexicographically largest permutation which is smaller than the given permutation of n. If no such permutation exists, return -1. >>> previousPermutation(12354, 5) 12345 >>> previousPermutation(12345, 5) -1 >>> previousPermutation(7, 1) -1 >>> previousPermutation(21, 2) 12 >>> previousPermutation(12, 2) -1 >>> previousPermutation(11111, 5) -1 >>> previousPermutation(987654321, 9) 987654312 >>> previousPermutation(321, 3) 312 >>> previousPermutation(312, 3) 231 >>> previousPermutation(231, 3) 213 >>> previousPermutation(213, 3) 132 >>> previousPermutation(132, 3) 123 >>> previousPermutation(123, 3) -1","solution":"def previousPermutation(n: int, k: int) -> int: Finds the lexicographically largest permutation which is smaller than the given permutation of n. If no such permutation exists, return -1. # Convert the number to a list of digits digits = list(str(n)) # Start from the end of the list and find the first digit that is larger than the digit next to it i = k - 2 while i >= 0 and digits[i] <= digits[i + 1]: i -= 1 if i < 0: return -1 # Find the largest digit to the right of 'i' that is smaller than digits[i] j = k - 1 while digits[j] >= digits[i]: j -= 1 # Swap digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Reverse the suffix starting at i + 1 digits = digits[:i + 1] + digits[i + 1:][::-1] return int(''.join(digits))"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string of length k constructed from the string s. >>> lexicographically_smallest_string(\\"abacb\\", 3) 'aab' >>> lexicographically_smallest_string(\\"a\\", 1) 'a' >>> lexicographically_smallest_string(\\"aaaa\\", 2) 'aa' >>> lexicographically_smallest_string(\\"bcabc\\", 3) 'abc' >>> lexicographically_smallest_string(\\"zxyab\\", 2) 'ab' >>> lexicographically_smallest_string(\\"bac\\", 2) 'ac'","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string of length k constructed from the string s. stack = [] n = len(s) for i, char in enumerate(s): while stack and stack[-1] > char and len(stack) + n - i > k: stack.pop() if len(stack) < k: stack.append(char) return ''.join(stack)"},{"question":"def shortest_path_with_treasures(grid: List[List[int]]) -> int: Find the shortest path from the top-left room (0, 0) to the bottom-right room (m-1, n-1) such that you must collect all treasures (rooms with 999). Return the length of this path. If it is not possible to collect all treasures or reach the bottom-right room, return -1. You can move in four directions: up, down, left, and right. >>> shortest_path_with_treasures([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 4 >>> shortest_path_with_treasures([[0, 0, 999], [0, -1, 0], [0, 999, 0]]) 6 >>> shortest_path_with_treasures([[0, 0, 0], [0, -1, 0], [0, 0, 0]]) 4 >>> shortest_path_with_treasures([[0, -1, 999], [-1, -1, -1], [999, 0, 0]]) -1 >>> shortest_path_with_treasures([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 4 >>> shortest_path_with_treasures([[0, 0, 999, 0]]) 3 >>> shortest_path_with_treasures([[0], [0], [999], [0]]) 3","solution":"from collections import deque def shortest_path_with_treasures(grid): # Helper function to get valid neighbors def get_neighbors(r, c, m, n): for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n: yield nr, nc # Find all the treasures and grid dimensions m, n = len(grid), len(grid[0]) treasures = set() for r in range(m): for c in range(n): if grid[r][c] == 999: treasures.add((r, c)) # Use BFS for shortest path search with multi-source queue = deque([(0, 0, frozenset(), 0)]) visited = set([(0, 0, frozenset())]) while queue: r, c, collected_treasures, steps = queue.popleft() # If we have reached the bottom-right cell and collected all treasures if (r == m-1 and c == n-1 and collected_treasures == treasures): return steps # Explore neighbors for nr, nc in get_neighbors(r, c, m, n): if grid[nr][nc] == -1: continue # Skip obstacles new_collected = collected_treasures | frozenset([(nr, nc)]) if grid[nr][nc] == 999 else collected_treasures if (nr, nc, new_collected) not in visited: visited.add((nr, nc, new_collected)) queue.append((nr, nc, new_collected, steps + 1)) # If we exhaust the queue without finding a valid path return -1"},{"question":"class Solution: def __init__(self, tasks): Initializes the object with the list of task durations. :param tasks: List[int] - List of task durations. self.tasks = tasks def minimizeDifference(self): Returns the minimum possible absolute difference of the sums of durations between the two lists. :return: int - Minimum possible absolute difference. >>> Solution([1, 2, 3, 4, 5, 6, 7, 8, 9]).minimizeDifference() 1 >>> Solution([3, 1, 4, 2, 2]).minimizeDifference() 0 >>> Solution([5, 5, 5, 5]).minimizeDifference() 0 >>> Solution([10, 9, 8, 7, 1]).minimizeDifference() 1 >>> Solution([10]).minimizeDifference() 10 >>> Solution([10, 10]).minimizeDifference() 0 >>> Solution([10, 5]).minimizeDifference() 5","solution":"class Solution: def __init__(self, tasks): self.tasks = tasks def minimizeDifference(self): total_sum = sum(self.tasks) n = len(self.tasks) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for task in self.tasks: for j in range(target, task - 1, -1): if dp[j - task]: dp[j] = True for i in range(target, -1, -1): if dp[i]: left_sum = i break right_sum = total_sum - left_sum return abs(left_sum - right_sum)"},{"question":"def searchInsert(nums: List[int], target: int) -> int: Perform a binary search to find the target or the appropriate insertion index in a sorted array. Parameters: nums (list of int): A list of integers sorted in ascending order. target (int): The target integer to find or insert. Returns: int: The index of the target or the appropriate insertion point. >>> searchInsert([1, 3, 5, 6], 5) 2 >>> searchInsert([1, 3, 5, 6], 2) 1 >>> searchInsert([1, 3, 5, 6], 7) 4 >>> searchInsert([1, 3, 5, 6], 0) 0 >>> searchInsert([1], 1) 0 >>> searchInsert([1], 2) 1 >>> searchInsert([], 5) 0 >>> nums = list(range(0, 10001, 2)) >>> searchInsert(nums, 5000) 2500 >>> searchInsert(nums, 5001) 2501","solution":"def searchInsert(nums, target): Perform a binary search to find the target or the appropriate insertion index in a sorted array. Parameters: nums (list of int): A list of integers sorted in ascending order. target (int): The target integer to find or insert. Returns: int: The index of the target or the appropriate insertion point. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"def find_pairs_with_target(numbers: List[int], target: int) -> List[List[int]]: Returns an array of all unique pairs [a, b] from numbers such that a + b = target. Each pair is in non-descending order, and the array is sorted based on the pairs. >>> find_pairs_with_target([1, 2, 3, 4], 8) [] >>> find_pairs_with_target([1, 2, 3, 4], 5) [[1, 4], [2, 3]] >>> find_pairs_with_target([-1, -2, 4, 3, 6, -5], 1) [[-5, 6], [-2, 3]] >>> find_pairs_with_target([], 5) [] >>> find_pairs_with_target([-1, 1, 0], 0) [[-1, 1]]","solution":"def find_pairs_with_target(numbers, target): Returns an array of all unique pairs [a, b] from numbers such that a + b = target. Each pair is in non-descending order, and the array is sorted based on the pairs. pairs = [] seen = set() for num in numbers: if (target - num) in seen: pair = sorted([num, target - num]) if pair not in pairs: pairs.append(pair) seen.add(num) return sorted(pairs)"},{"question":"def longest_substring_after_removal(s: str) -> int: Returns the length of the longest substring possible such that no two consecutive characters are the same. >>> longest_substring_after_removal(\\"aabbcc\\") 3 >>> longest_substring_after_removal(\\"aabacc\\") 4 >>> longest_substring_after_removal(\\"aaaa\\") 1 >>> longest_substring_after_removal(\\"abbbc\\") 3 >>> longest_substring_after_removal(\\"\\") 0 >>> longest_substring_after_removal(\\"a\\") 1 >>> longest_substring_after_removal(\\"aa\\") 1 >>> longest_substring_after_removal(\\"ab\\") 2 >>> longest_substring_after_removal(\\"abcabc\\") 6 >>> longest_substring_after_removal(\\"aabbccddeeff\\") 6 >>> longest_substring_after_removal(\\"aabbccddee\\") 5 >>> longest_substring_after_removal(\\"a\\"*1000) 1","solution":"def longest_substring_after_removal(s): Returns the length of the longest substring possible such that no two consecutive characters are the same. if not s: return 0 n = len(s) length = 0 i = 0 while i < n: length += 1 while i + 1 < n and s[i] == s[i + 1]: i += 1 i += 1 return length"},{"question":"def stringToFloat(s: str) -> float: Converts a string representation of a floating-point number to its corresponding float value. :param s: str - a string representing a floating-point number :return: float - the converted floating-point number >>> stringToFloat(\\"123.456\\") == 123.456 >>> stringToFloat(\\"-123.456\\") == -123.456 >>> stringToFloat(\\"123\\") == 123.0 >>> stringToFloat(\\".456\\") == 0.456 >>> stringToFloat(\\"+123.456\\") == 123.456 >>> stringToFloat(\\"0\\") == 0.0 >>> stringToFloat(\\"0.0\\") == 0.0 >>> stringToFloat(\\"-0.456\\") == -0.456","solution":"def stringToFloat(s): Converts a string representation of a floating-point number to its corresponding float value. :param s: str - a string representing a floating-point number :return: float - the converted floating-point number # Check if the string represents a negative number negative = False if s[0] == '-': negative = True s = s[1:] elif s[0] == '+': s = s[1:] # Split the string into integer and fractional parts if '.' in s: integer_part, fractional_part = s.split('.') else: integer_part, fractional_part = s, '' # Convert integer part integer_value = 0 for char in integer_part: integer_value = integer_value * 10 + (ord(char) - ord('0')) # Convert fractional part fractional_value = 0 divisor = 1 for char in fractional_part: fractional_value = fractional_value * 10 + (ord(char) - ord('0')) divisor *= 10 # Combine integer and fractional parts result = integer_value + fractional_value / divisor # Apply negative sign if needed if negative: result = -result return result"},{"question":"def knapsack(prices, weights, W): Returns the maximum total value of items that can be included in the knapsack without exceeding the weight limit W. :param prices: List[int] - A list of prices (values) of items. :param weights: List[int] - A list of weights of items. :param W: int - The maximum weight limit of the knapsack. :return: int - The maximum total value achievable. >>> knapsack([60, 100, 120], [10, 20, 30], 50) == 220 >>> knapsack([100], [50], 50) == 100 >>> knapsack([], [], 50) == 0 >>> knapsack([60, 100, 120], [10, 20, 30], 0) == 0 >>> knapsack([20, 30, 40], [1, 1, 1], 3) == 90","solution":"def knapsack(prices, weights, W): Returns the maximum total value of items that can be included in the knapsack without exceeding the weight limit W. :param prices: List[int] - A list of prices (values) of items. :param weights: List[int] - A list of weights of items. :param W: int - The maximum weight limit of the knapsack. :return: int - The maximum total value achievable. n = len(prices) dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(W + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + prices[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"from typing import List def nextPermutation(nums: List[int]) -> None: Modify nums in-place to its next permutation. >>> nums = [1, 2, 3] >>> nextPermutation(nums) >>> print(nums) [1, 3, 2] >>> nums = [3, 2, 1] >>> nextPermutation(nums) >>> print(nums) [1, 2, 3] >>> nums = [1, 1, 5] >>> nextPermutation(nums) >>> print(nums) [1, 5, 1] >>> nums = [1] >>> nextPermutation(nums) >>> print(nums) [1] >>> nums = [1, 2] >>> nextPermutation(nums) >>> print(nums) [2, 1] >>> nums = [2, 2, 2] >>> nextPermutation(nums) >>> print(nums) [2, 2, 2] # Write your code here","solution":"from typing import List def nextPermutation(nums: List[int]) -> None: Modify nums in-place to its next permutation. # Step 1: Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, reverse nums. k = -1 for i in range(len(nums) - 1): if nums[i] < nums[i + 1]: k = i if k == -1: nums.reverse() return # Step 2: Find the largest index l greater than k such that nums[k] < nums[l]. l = -1 for j in range(k + 1, len(nums)): if nums[k] < nums[j]: l = j # Step 3: Swap nums[k] and nums[l]. nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] up to and including the final element. nums[k + 1:] = reversed(nums[k + 1:])"},{"question":"def decode_string(encoded: str) -> str: Decodes the given encoded string where each digit indicates the number of times the following character (which is guaranteed to be a lowercase letter) appears. Parameters: - encoded (str): Encoded string, e.g., \\"3a2b1c\\". Returns: - str: Decoded string, e.g., \\"aaabbc\\". pass # Unit tests def test_decode_string_example(): assert decode_string(\\"3a2b1c\\") == \\"aaabbc\\" def test_decode_string_single_letter(): assert decode_string(\\"5a\\") == \\"aaaaa\\" def test_decode_string_multiple_letters(): assert decode_string(\\"2a3b4c\\") == \\"aabbbcccc\\" def test_decode_string_with_multiple_digits(): assert decode_string(\\"10a2b\\") == \\"aaaaaaaaaabb\\" def test_decode_string_empty(): assert decode_string(\\"\\") == \\"\\" def test_decode_string_single_digit_single_letter(): assert decode_string(\\"0a\\") == \\"\\" def test_decode_string_no_repetition(): assert decode_string(\\"1a1b1c\\") == \\"abc\\"","solution":"def decode_string(encoded): Decodes the given encoded string where each digit indicates the number of times the following character (which is guaranteed to be a lowercase letter) appears. Parameters: - encoded (str): Encoded string, e.g., \\"3a2b1c\\". Returns: - str: Decoded string, e.g., \\"aaabbc\\". decoded = [] i = 0 length = len(encoded) while i < length: # get the count count = 0 while i < length and encoded[i].isdigit(): count = count * 10 + int(encoded[i]) i += 1 if i < length and encoded[i].isalpha(): decoded.append(encoded[i] * count) i += 1 return \\"\\".join(decoded)"},{"question":"def two_sum(arr, target): Returns the indices of the two distinct elements in the array whose sum equals the target. Parameters: arr (list of int): The list of integers. target (int): The target sum. Returns: list of int: The indices of the two elements whose sum equals the target, sorted in ascending order. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1000000, 500000, 500000], 1000000) [1, 2]","solution":"def two_sum(arr, target): Returns the indices of the two distinct elements in the array whose sum equals the target. Parameters: arr (list of int): The list of integers. target (int): The target sum. Returns: list of int: The indices of the two elements whose sum equals the target, sorted in ascending order. index_map = {} for i, num in enumerate(arr): complement = target - num if complement in index_map: return sorted([index_map[complement], i]) index_map[num] = i"},{"question":"def check_indices_with_sum(nums: List[int], k: int, d: int) -> bool: Determines if there are two distinct indices \`i\` and \`j\` in the array such that nums[i] + nums[j] == k and the absolute difference between \`i\` and \`j\` is not greater than \`d\`. Args: nums (list of int): The input list of integers. k (int): The target sum. d (int): The maximum allowed distance between indices. Returns: bool: True if such indices exist, False otherwise. >>> check_indices_with_sum([1, 2, 3, 4], 5, 2) True >>> check_indices_with_sum([1, 2, 3, 4], 8, 2) False >>> check_indices_with_sum([], 5, 2) False >>> check_indices_with_sum([1, -2, 3, 0], 1, 2) True","solution":"def check_indices_with_sum(nums, k, d): Determines if there are two distinct indices \`i\` and \`j\` in the array such that nums[i] + nums[j] == k and the absolute difference between \`i\` and \`j\` is not greater than \`d\`. Args: nums (list of int): The input list of integers. k (int): The target sum. d (int): The maximum allowed distance between indices. Returns: bool: True if such indices exist, False otherwise. for i in range(len(nums)): for j in range(i + 1, min(i + d + 1, len(nums))): if nums[i] + nums[j] == k: return True return False"},{"question":"def find_words(words: List[str]) -> List[str]: Returns a list of words that can be formed using letters of a single row of a traditional QWERTY keyboard. >>> find_words([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) == [\\"Alaska\\", \\"Dad\\"] >>> find_words([\\"Hello\\", \\"Peace\\"]) == [] >>> find_words([\\"Alaska\\", \\"Dad\\", \\"qwerty\\"]) == [\\"Alaska\\", \\"Dad\\", \\"qwerty\\"] >>> find_words([\\"QwErTy\\", \\"AsDfG\\", \\"ZXCVBNm\\"]) == [\\"QwErTy\\", \\"AsDfG\\", \\"ZXCVBNm\\"] >>> find_words([]) == [] >>> find_words([\\"Qwe!@#\\", \\"AsD#@\\"]) == []","solution":"def find_words(words): Returns a list of words that can be formed using letters of a single row of a traditional QWERTY keyboard. first_row = set(\\"qwertyuiop\\") second_row = set(\\"asdfghjkl\\") third_row = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = word.lower() if all(char in first_row for char in lower_word) or all(char in second_row for char in lower_word) or all(char in third_row for char in lower_word): result.append(word) return result"},{"question":"def canConstruct(ransomNote: str, magazine: str) -> bool: Determines if ransomNote can be constructed by using the letters from magazine. Each letter in magazine can only be used once in ransomNote. >>> canConstruct(\\"a\\", \\"a\\") True >>> canConstruct(\\"abc\\", \\"abcba\\") True >>> canConstruct(\\"aabb\\", \\"aabbddee\\") True >>> canConstruct(\\"a\\", \\"b\\") False >>> canConstruct(\\"aa\\", \\"a\\") False >>> canConstruct(\\"aabbc\\", \\"aabb\\") False >>> canConstruct(\\"\\", \\"anystring\\") True >>> canConstruct(\\"a\\", \\"\\") False >>> canConstruct(\\"\\", \\"\\") True # Your code here","solution":"def canConstruct(ransomNote, magazine): Determines if ransomNote can be constructed by using the letters from magazine. Each letter in magazine can only be used once in ransomNote. from collections import Counter ransom_note_count = Counter(ransomNote) magazine_count = Counter(magazine) for char, count in ransom_note_count.items(): if magazine_count[char] < count: return False return True"},{"question":"def num_paths(grid: List[List[int]]) -> int: Returns the number of different paths from top-left to bottom-right corner in a grid, considering blocked cells. >>> num_paths([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 6 >>> num_paths([ [1, 1, 0], [1, 1, 1], [1, 0, 1] ]) == 2 >>> num_paths([ [1, 0, 0], [1, 0, 1], [0, 1, 1] ]) == 0 >>> num_paths([ [0, 1], [1, 1] ]) == 0 >>> num_paths([ [1, 1], [1, 0] ]) == 0 >>> num_paths([[1]]) == 1 >>> num_paths([ [1, 1], [1, 1] ]) == 2 >>> num_paths([ [1, 0], [0, 1] ]) == 0","solution":"def num_paths(grid): Returns the number of different paths from top-left to bottom-right corner in a grid, considering blocked cells. n = len(grid) if n == 0 or grid[0][0] == 0 or grid[n-1][n-1] == 0: return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 0: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"def findCheapestPrice(n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int: Calculate the minimum price required to reach the destination city \`dst\` from the source city \`src\` within at most \`k\` stops. >>> findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1) 200 >>> findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 0) 500 >>> findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 3) 200 >>> findCheapestPrice(4, [[0, 1, 100], [1, 2, 100], [0, 2, 500], [2, 3, 100], [0, 3, 150]], 0, 3, 1) 150 >>> findCheapestPrice(5, [[0, 1, 100], [1, 2, 100], [2, 3, 100], [0, 3, 600], [0, 2, 500]], 0, 3, 2) 300","solution":"import heapq from collections import defaultdict, deque def findCheapestPrice(n, flights, src, dst, k): graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) # Use a priority queue to progressively explore the cheapest option pq = [(0, src, 0)] visited = defaultdict(lambda: float('inf')) while pq: cost, u, stops = heapq.heappop(pq) # If we reach the destination if u == dst: return cost # If we have more stops available if stops <= k: for v, w in graph[u]: new_cost = cost + w if new_cost < visited[(v, stops + 1)]: visited[(v, stops + 1)] = new_cost heapq.heappush(pq, (new_cost, v, stops + 1)) return -1"},{"question":"def longest_balanced_subarray(colors: List[int]) -> int: Returns the length of the longest contiguous subarray where each color appears an even number of times. >>> longest_balanced_subarray([1, 2, 1, 2, 3, 3]) 6 >>> longest_balanced_subarray([1, 1, 2, 2, 3, 3, 4, 4]) 8 >>> longest_balanced_subarray([1, 1, 2, 2, 1]) 4 >>> longest_balanced_subarray([1, 2, 2, 3, 3, 3]) 4 >>> longest_balanced_subarray([1, 2, 3, 4]) 0 >>> longest_balanced_subarray([]) 0 >>> longest_balanced_subarray([1]) 0","solution":"def longest_balanced_subarray(colors): Returns the length of the longest contiguous subarray where each color appears an even number of times. def is_balanced(subarray): color_count = {} for color in subarray: color_count[color] = color_count.get(color, 0) + 1 return all(count % 2 == 0 for count in color_count.values()) max_length = 0 n = len(colors) for start in range(n): for end in range(start + 1, n + 1): subarray = colors[start:end] if is_balanced(subarray): max_length = max(max_length, end - start) return max_length"},{"question":"def trap_water(heights: List[int]) -> int: Given a list of building heights, calculate the total amount of water that can be trapped between the buildings. :param heights: List[int], list of building heights :return: int, total amount of trapped water >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([]) 0 >>> trap_water([4]) 0 >>> trap_water([4, 3]) 0 from solution import trap_water def test_trap_water_example_case(): assert trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_water_empty_array(): assert trap_water([]) == 0 def test_trap_water_single_building(): assert trap_water([4]) == 0 def test_trap_water_two_buildings(): assert trap_water([4, 3]) == 0 def test_trap_water_flat_surface(): assert trap_water([1, 1, 1, 1, 1]) == 0 def test_trap_water_with_hills_and_valleys(): assert trap_water([0, 1, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 5 def test_trap_water_all_descending_then_all_ascending(): assert trap_water([5, 4, 3, 2, 1, 2, 3, 4, 5]) == 16 def test_trap_water_peaks_and_valleys(): assert trap_water([0, 2, 0, 2, 0, 2, 0, 2]) == 6","solution":"def trap_water(heights): Given a list of building heights, calculate the total amount of water that can be trapped between the buildings. :param heights: List[int], list of building heights :return: int, total amount of trapped water if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) total_water = 0 for i in range(n): water_level = min(left_max[i], right_max[i]) total_water += max(0, water_level - heights[i]) return total_water"},{"question":"class VideoPlatform: A video streaming platform to track viewers watching videos in real-time. * void startWatching(int userId, int videoId, int startTime) - A viewer with a unique id userId starts watching a video identified by videoId at time startTime. * void stopWatching(int userId, int videoId, int stopTime) - The same viewer with userId stops watching the video at time stopTime. The viewer must have started watching the same video without stopping it in between. * int getTotalViewTime(int videoId) - Returns the total amount of time spent by all viewers watching the video identified by videoId. * double getAverageViewTime(int videoId) - Returns the average time spent by viewers watching the video identified by videoId. import pytest from solution import VideoPlatform def test_single_viewer(): vp = VideoPlatform() vp.startWatching(1, 100, 10) vp.stopWatching(1, 100, 20) assert vp.getTotalViewTime(100) == 10 assert vp.getAverageViewTime(100) == 10.0 def test_multiple_viewers(): vp = VideoPlatform() vp.startWatching(1, 100, 10) vp.startWatching(2, 100, 15) vp.stopWatching(1, 100, 20) vp.stopWatching(2, 100, 25) assert vp.getTotalViewTime(100) == 20 assert vp.getAverageViewTime(100) == 10.0 def test_multiple_sessions_per_user(): vp = VideoPlatform() vp.startWatching(1, 100, 10) vp.stopWatching(1, 100, 20) vp.startWatching(1, 100, 30) vp.stopWatching(1, 100, 40) assert vp.getTotalViewTime(100) == 20 assert vp.getAverageViewTime(100) == 10.0 def test_no_view_time(): vp = VideoPlatform() assert vp.getTotalViewTime(100) == 0 assert vp.getAverageViewTime(100) == 0.0 def test_viewers_stopping_at_different_times(): vp = VideoPlatform() vp.startWatching(1, 100, 10) vp.startWatching(2, 100, 12) vp.stopWatching(1, 100, 20) vp.stopWatching(2, 100, 18) assert vp.getTotalViewTime(100) == 16 assert vp.getAverageViewTime(100) == 8.0","solution":"class VideoPlatform: def __init__(self): self.viewing_data = {} self.video_times = {} def startWatching(self, userId, videoId, startTime): if videoId not in self.viewing_data: self.viewing_data[videoId] = {} self.viewing_data[videoId][userId] = startTime def stopWatching(self, userId, videoId, stopTime): if videoId in self.viewing_data and userId in self.viewing_data[videoId]: startTime = self.viewing_data[videoId].pop(userId) duration = stopTime - startTime if videoId not in self.video_times: self.video_times[videoId] = [] self.video_times[videoId].append(duration) def getTotalViewTime(self, videoId): if videoId in self.video_times: return sum(self.video_times[videoId]) return 0 def getAverageViewTime(self, videoId): if videoId in self.video_times and len(self.video_times[videoId]) > 0: return sum(self.video_times[videoId]) / len(self.video_times[videoId]) return 0.0"},{"question":"def merge_intervals(intervals): Merges overlapping intervals and returns the list of merged intervals. Parameters: intervals (List[List[int]]): A list of intervals where each interval is represented as [start, end] Returns: List[List[int]]: A list of merged intervals. >>> merge_intervals([[1,3],[2,6],[8,10],[15,18]]) [[1,6],[8,10],[15,18]] >>> merge_intervals([[1,2],[3,4],[5,6]]) [[1,2],[3,4],[5,6]] >>> merge_intervals([[1,4],[2,3],[3,5]]) [[1,5]] >>> merge_intervals([[1,4]]) [[1,4]] >>> merge_intervals([[1,5],[2,6],[6,8],[7,9]]) [[1,9]] >>> merge_intervals([]) []","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns the list of merged intervals. Parameters: intervals (List[List[int]]): A list of intervals where each interval is represented as [start, end] Returns: List[List[int]]: A list of merged intervals. if not intervals: return [] # Sort the intervals based on the start times intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # if the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals"},{"question":"def form_queue(heights: List[int]) -> List[int]: Forms a queue such that each person is only taller than those behind them, and returns the lexicographically smallest 1-indexed array of indices representing the order of people in the queue. >>> form_queue([150, 160, 170]) == [1, 2, 3] >>> form_queue([170, 160, 150]) == [3, 2, 1] >>> form_queue([160, 150, 170]) == [2, 1, 3] >>> form_queue([160, 160, 150]) == [3, 1, 2] >>> form_queue([150]) == [1] >>> form_queue([150, 150, 150]) == [1, 2, 3] >>> form_queue([155, 152, 157, 151, 150]) == [5, 4, 2, 1, 3] >>> form_queue([150, 172, 165, 167, 170]) == [1, 3, 4, 5, 2]","solution":"def form_queue(heights): Forms a queue such that each person is only taller than those behind them, and returns the lexicographically smallest 1-indexed array of indices representing the order of people in the queue. indexed_heights = [(height, index + 1) for index, height in enumerate(heights)] indexed_heights.sort(key=lambda x: (x[0], x[1])) result = [index for height, index in indexed_heights] return result"},{"question":"def longest_substring_k_unique(s: str, k: int) -> int: Find the length of the longest substring that can be converted into a string with exactly k unique characters by replacing some or no characters. >>> longest_substring_k_unique(\\"aaabbcc\\", 2) == 5 # \\"aaabb\\" >>> longest_substring_k_unique(\\"aaabbcc\\", 5) == 7 # Whole string since k > unique chars >>> longest_substring_k_unique(\\"a\\", 2) == 1 # \\"a\\" >>> longest_substring_k_unique(\\"abcdef\\", 0) == 0 # No substring possible >>> longest_substring_k_unique(\\"aabbcc\\", 3) == 6 # Whole string since it has exactly 3 unique chars >>> longest_substring_k_unique(\\"aaabbbcc\\", 2) == 6 # \\"aaabbb\\" or \\"abbbcc\\" >>> longest_substring_k_unique(\\"bbbbbbb\\", 1) == 7 # Whole string since all are same >>> longest_substring_k_unique(\\"\\", 2) == 0 # Empty string","solution":"def longest_substring_k_unique(s, k): from collections import defaultdict if k == 0: return 0 n = len(s) left = 0 max_length = 0 char_count = defaultdict(int) for right in range(n): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def can_three_parts_equal_sum(nums): Given an integer array nums, return true if you can partition the array into three non-empty parts with equal sums. Otherwise, return false. >>> can_three_parts_equal_sum([0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]) == True >>> can_three_parts_equal_sum([0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1]) == False >>> can_three_parts_equal_sum([0, 0, 0, 0, 0]) == True >>> can_three_parts_equal_sum([3, 3, 6, 5, -2, 2, 5, 1, -9, 4]) == True >>> can_three_parts_equal_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == False","solution":"def can_three_parts_equal_sum(nums): Given an integer array nums, return true if you can partition the array into three non-empty parts with equal sums. Otherwise, return false. total_sum = sum(nums) if total_sum % 3 != 0: return False target = total_sum // 3 n, current_sum, count = len(nums), 0, 0 for i in range(n): current_sum += nums[i] if current_sum == target: current_sum = 0 count += 1 if count == 3: return True return False"},{"question":"from typing import List def numIslands(grid: List[List[int]]) -> int: Given a grid of size \`m x n\` consisting of only 0s and 1s, return the number of islands. An island is a group of \`1s\` (representing land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. >>> grid = [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 1, 1] ... ] >>> numIslands(grid) 2 >>> grid = [ ... [1, 0, 0, 1], ... [0, 0, 1, 1], ... [0, 1, 1, 0], ... [1, 0, 0, 1] ... ] >>> numIslands(grid) 4 >>> grid = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> numIslands(grid) 0 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> numIslands(grid) 1 >>> grid = [] >>> numIslands(grid) 0 >>> grid = [[1]] >>> numIslands(grid) 1 >>> grid = [[0]] >>> numIslands(grid) 0","solution":"from typing import List def numIslands(grid: List[List[int]]) -> int: def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # Mark the cell as visited by setting it to 0 dfs(x + 1, y) # Visit the cell below dfs(x - 1, y) # Visit the cell above dfs(x, y + 1) # Visit the cell to the right dfs(x, y - 1) # Visit the cell to the left if not grid: return 0 num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: num_islands += 1 dfs(i, j) return num_islands"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams together in nested lists. Args: words (List of str): List of words. Returns: List of List of str: List of anagram groups. Examples: >>> group_anagrams([\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\", \\"tac\\"]) [['bat', 'tab'], ['cat', 'act', 'tac']] >>> group_anagrams([\\"bat\\", \\"tab\\"]) [['bat', 'tab']] >>> group_anagrams([\\"dog\\", \\"cat\\", \\"bird\\"]) [['dog'], ['cat'], ['bird']] >>> group_anagrams([]) [] >>> group_anagrams([\\"bAt\\", \\"tab\\", \\"Act\\", \\"cat\\"]) [['bAt'], ['tab'], ['Act'], ['cat']]","solution":"def group_anagrams(words): Groups anagrams together in nested lists. Args: words (list of str): List of words. Returns: list of list of str: List of anagram groups. from collections import defaultdict anagram_dict = defaultdict(list) for word in words: # Sort the word to create a key sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values())"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(root1, root2): Merges two binary trees by performing a node-wise sum. If two nodes overlap, sum their values as the new value of the merged node. Otherwise, the non-null node will be used. :param root1: TreeNode - Root of the first binary tree. :param root2: TreeNode - Root of the second binary tree. :return: TreeNode - Root of the merged binary tree. from solution import TreeNode, merge_trees def tree_to_list(root): Helper function to convert tree to list (BFS) if not root: return [] queue, result = [root], [] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left if node.left else None) queue.append(node.right if node.right else None) else: result.append(None) while result and result[-1] is None: result.pop() return result def test_merge_trees_both_null(): assert merge_trees(None, None) is None def test_merge_trees_first_null(): tree2 = TreeNode(1, TreeNode(2), TreeNode(3)) assert tree_to_list(merge_trees(None, tree2)) == [1, 2, 3] def test_merge_trees_second_null(): tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) assert tree_to_list(merge_trees(tree1, None)) == [1, 2, 3] def test_merge_trees_overlap(): tree1 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2)) tree2 = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) # Expected merged tree: [3, 4, 5, 5, None, None, 7] assert tree_to_list(merge_trees(tree1, tree2)) == [3, 4, 5, 5, 4, None, 7] def test_merge_trees_no_overlap(): tree1 = TreeNode(1) tree2 = TreeNode(2) # Expected merged tree: [3] assert tree_to_list(merge_trees(tree1, tree2)) == [3]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(root1, root2): Merges two binary trees by performing a node-wise sum. If two nodes overlap, sum their values as the new value of the merged node. Otherwise, the non-null node will be used. :param root1: TreeNode - Root of the first binary tree. :param root2: TreeNode - Root of the second binary tree. :return: TreeNode - Root of the merged binary tree. if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged_root = TreeNode(root1.val + root2.val) merged_root.left = merge_trees(root1.left, root2.left) merged_root.right = merge_trees(root1.right, root2.right) return merged_root"},{"question":"def max_sunrise_views(heights: List[int]) -> int: Returns the index of the skyscraper from which the maximum number of sunrises can be seen. If there is a tie for the maximum views, the smallest index is returned. >>> max_sunrise_views([3, 1, 2, 4, 5]) 4 >>> max_sunrise_views([1, 2, 3, 4]) 3 >>> max_sunrise_views([4, 3, 2, 1]) 0 >>> max_sunrise_views([5]) 0 >>> max_sunrise_views([2, 2, 2, 2]) 0 >>> max_sunrise_views([1, 3, 2, 4, 2]) 3 >>> max_sunrise_views([2, 3, 7, 4, 8, 3, 9]) 6 >>> max_sunrise_views([5, 5, 5, 5, 5]) 0 >>> max_sunrise_views([1, 3, 2, 4, 4]) 3","solution":"def max_sunrise_views(heights): Returns the index of the skyscraper from which the maximum number of sunrises can be seen. If there is a tie for the maximum views, the smallest index is returned. max_views = 0 best_index = 0 for i in range(len(heights)): views = 0 current_max_height = 0 for j in range(i+1): if heights[j] > current_max_height: views += 1 current_max_height = heights[j] if views > max_views: max_views = views best_index = i return best_index"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head: ListNode, x: int) -> ListNode: Partitions the linked list such that all nodes with values less than x come before nodes with values greater than or equal to x. The relative order of the nodes in each partition is preserved. :param head: The head of the linked list. :param x: The partitioning value. :return: The head of the modified linked list. def test_partition_empty(): assert partition(None, 3) == None def test_partition_all_less(): head = list_to_linked_list([1, 2, 2]) x = 3 result = partition(head, x) assert linked_list_to_list(result) == [1, 2, 2] def test_partition_all_greater(): head = list_to_linked_list([4, 5, 6]) x = 3 result = partition(head, x) assert linked_list_to_list(result) == [4, 5, 6] def test_partition_mixed(): head = list_to_linked_list([1, 4, 3, 2, 5, 2]) x = 3 result = partition(head, x) assert linked_list_to_list(result) == [1, 2, 2, 4, 3, 5] def test_partition_values_equal_to_x(): head = list_to_linked_list([1, 4, 3, 2, 5, 2]) x = 2 result = partition(head, x) assert linked_list_to_list(result) == [1, 4, 3, 2, 5, 2] def test_partition_complex(): head = list_to_linked_list([3, 1, 2, 10, 5, 6, 2, 4]) x = 5 result = partition(head, x) assert linked_list_to_list(result) == [3, 1, 2, 2, 4, 10, 5, 6]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, x): Partitions the linked list such that all nodes with values less than x come before nodes with values greater than or equal to x. The relative order of the nodes in each partition is preserved. :param head: The head of the linked list. :param x: The partitioning value. :return: The head of the modified linked list. less_head = ListNode(0) greater_head = ListNode(0) less = less_head greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next greater.next = None less.next = greater_head.next return less_head.next"},{"question":"from typing import List def next_greater_elements(nums: List[int]) -> List[int]: Write a function \`next_greater_elements(nums)\` that takes a list of integers \`nums\` and returns a new list such that, for each element in the original list, the new list contains the next greater element that appears to the right in the original list. If there is no such greater element, the output should be \`-1\` for that element. >>> next_greater_elements([4, 2, 5, 3, 1]) [5, 5, -1, -1, -1] >>> next_greater_elements([1, 2, 3, 4, 5]) [2, 3, 4, 5, -1] >>> next_greater_elements([5, 4, 3, 2, 1]) [-1, -1, -1, -1, -1] >>> next_greater_elements([2, 1, 2, 4, 3]) [4, 2, 4, -1, -1] >>> next_greater_elements([10]) [-1] >>> next_greater_elements([]) [] >>> next_greater_elements([2, 2, 2]) [-1, -1, -1]","solution":"def next_greater_elements(nums): Returns a list of the next greater elements for each element in the input list. If no such element exists, return -1 for that position. result = [-1] * len(nums) stack = [] for i in range(len(nums)): while stack and nums[i] > nums[stack[-1]]: idx = stack.pop() result[idx] = nums[i] stack.append(i) return result"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Return a reordered string based on the given indices. Parameters: s (str): The input string. indices (List[int]): The array of indices. Returns: str: The reordered string. >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) == \\"leetcode\\" >>> restore_string(\\"a\\", [0]) == \\"a\\" >>> restore_string(\\"abc\\", [2, 1, 0]) == \\"cba\\" >>> restore_string(\\"abc\\", [0, 1, 2]) == \\"abc\\" >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) == \\"nihao\\"","solution":"def restore_string(s, indices): Return a reordered string based on the given indices. Parameters: s (str): The input string. indices (List[int]): The array of indices. Returns: str: The reordered string. # Create a list of the same length as s, filled with empty strings reordered = [''] * len(s) # Place each character at its correct position based on indices for i, index in enumerate(indices): reordered[index] = s[i] # Join the list to form the resulting string return ''.join(reordered)"},{"question":"def find_valleys(grid): Finds the number of valleys in a 2D grid of integers. Parameters: grid (List[List[int]]): A 2D grid of integers representing heights. Returns: int: The number of valleys in the grid. pass def test_no_valleys(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert find_valleys(grid) == 0 def test_single_valley(): grid = [ [2, 2, 2], [2, 1, 2], [2, 2, 2] ] assert find_valleys(grid) == 1 def test_multiple_valleys(): grid = [ [3, 3, 3, 3], [3, 1, 3, 1], [3, 3, 3, 3] ] assert find_valleys(grid) == 2 def test_large_grid_valleys(): grid = [ [5, 4, 3, 2, 1], [4, 3, 2, 1, 0], [3, 2, 1, 0, -1], [2, 1, 0, -1, -2], [1, 0, -1, -2, -3] ] assert find_valleys(grid) == 1 def test_no_adjacent_cells(): grid = [[1]] assert find_valleys(grid) == 1 def test_all_same_height(): grid = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert find_valleys(grid) == 0","solution":"def find_valleys(grid): Finds the number of valleys in a 2D grid of integers. Parameters: grid (List[List[int]]): A 2D grid of integers representing heights. Returns: int: The number of valleys in the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def is_lower_than_adjacent(r, c): \\"Checks if the cell (r, c) is lower than all its adjacent cells.\\" for delta_r, delta_c in [(-1, 0), (1, 0), (0, -1), (0, 1)]: adj_r, adj_c = r + delta_r, c + delta_c if 0 <= adj_r < rows and 0 <= adj_c < cols: if grid[r][c] >= grid[adj_r][adj_c]: return False return True def dfs(r, c, visited): Depth-first search to mark all parts of the valley starting from cell (r, c). stack = [(r, c)] while stack: curr_r, curr_c = stack.pop() visited.add((curr_r, curr_c)) for delta_r, delta_c in [(-1, 0), (1, 0), (0, -1), (0, 1)]: adj_r, adj_c = curr_r + delta_r, curr_c + delta_c if 0 <= adj_r < rows and 0 <= adj_c < cols and (adj_r, adj_c) not in visited: if grid[curr_r][curr_c] == grid[adj_r][adj_c] and is_lower_than_adjacent(adj_r, adj_c): stack.append((adj_r, adj_c)) visited = set() valley_count = 0 for r in range(rows): for c in range(cols): if (r, c) not in visited and is_lower_than_adjacent(r, c): dfs(r, c, visited) valley_count += 1 return valley_count"},{"question":"def num_islands(grid: List[List[str]]) -> int: Return the number of islands in the given 2D grid of '1's (land) and '0's (water). >>> num_islands([]) 0 >>> num_islands([['0']]) 0 >>> num_islands([['1']]) 1 >>> num_islands([ ... ['1', '0', '0', '1'], ... ['0', '0', '0', '0'], ... ['1', '0', '1', '0'], ... ['0', '0', '0', '1'] ... ]) 5 >>> num_islands([ ... ['1', '1', '0', '0'], ... ['1', '1', '0', '0'], ... ['0', '0', '1', '1'], ... ['0', '0', '1', '1'] ... ]) 2 >>> num_islands([ ... ['1', '0', '0', '0'], ... ['0', '1', '0', '0'], ... ['0', '0', '1', '0'], ... ['0', '0', '0', '1'] ... ]) 4 >>> num_islands([ ... ['1', '1', '1', '1'], ... ['1', '1', '1', '1'], ... ['1', '1', '1', '1'], ... ['1', '1', '1', '1'] ... ]) 1 pass","solution":"def num_islands(grid): def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != '1': return grid[i][j] = '0' # Mark the cell as visited dfs(grid, i + 1, j) # Visit down dfs(grid, i - 1, j) # Visit up dfs(grid, i, j + 1) # Visit right dfs(grid, i, j - 1) # Visit left if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) count += 1 return count"},{"question":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. Args: matrix (list of list of int): The n x n matrix to rotate. Returns: list of list of int: The rotated matrix (modified in-place).","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. Args: matrix (list of list of int): The n x n matrix to rotate. Returns: list of list of int: The rotated matrix (modified in-place). n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"from typing import List def generate_magic_square(m: int) -> List[List[int]]: Generates an m x m magic square for odd m. :param m: size of the magic square (must be a positive odd integer) :return: m x m list representing the magic square, or an empty list if m is not a positive odd integer >>> generate_magic_square(3) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> generate_magic_square(1) [[1]] >>> generate_magic_square(0) [] >>> generate_magic_square(-3) [] >>> generate_magic_square(4) [] >>> generate_magic_square(5) [[17, 24, 1, 8, 15], [23, 5, 7, 14, 16], [4, 6, 13, 20, 22], [10, 12, 19, 21, 3], [11, 18, 25, 2, 9]]","solution":"def is_odd_positive_integer(m): return m > 0 and m % 2 == 1 def generate_magic_square(m): Generates an m x m magic square for odd m. :param m: size of the magic square (must be a positive odd integer) :return: m x m list representing the magic square, or an empty list if m is not a positive odd integer if not is_odd_positive_integer(m): return [] magic_square = [[0]*m for _ in range(m)] n = 1 # Start filling with the first number i, j = 0, m // 2 # Start position while n <= m * m: magic_square[i][j] = n n += 1 new_i, new_j = (i - 1) % m, (j + 1) % m if magic_square[new_i][new_j]: # If this cell is already filled i += 1 else: i, j = new_i, new_j return magic_square"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner, navigating through open spaces (represented by 0) and avoiding walls (represented by 1). >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 6 >>> unique_paths_with_obstacles([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) == 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [1, 1, 1], ... [0, 0, 0] ... ]) == 0 >>> unique_paths_with_obstacles([[0]]) == 1 >>> unique_paths_with_obstacles([[1]]) == 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner, navigating through open spaces (represented by 0) and avoiding walls (represented by 1). if not grid or grid[0][0] == 1: # Start is blocked return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Fill the rest of the grid for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def count_out_of_order_pairs(heights): Returns the number of pairs of students (i, j) where i < j and heights[i] > heights[j]. Parameters: heights (list): List of integers representing the heights of students in a queue. Returns: int: Number of out of order pairs. >>> count_out_of_order_pairs([1, 2, 3, 4, 5]) == 0 >>> count_out_of_order_pairs([5, 4, 3, 2, 1]) == 10 >>> count_out_of_order_pairs([1, 5, 3, 4, 2]) == 5 >>> count_out_of_order_pairs([1]) == 0 >>> count_out_of_order_pairs([1, 2]) == 0 >>> count_out_of_order_pairs([2, 1]) == 1 >>> count_out_of_order_pairs([1, 3, 2, 3, 1]) == 4","solution":"def count_out_of_order_pairs(heights): Returns the number of pairs of students (i, j) where i < j and heights[i] > heights[j]. Parameters: heights (list): List of integers representing the heights of students in a queue. Returns: int: Number of out of order pairs. count = 0 for i in range(len(heights)): for j in range(i + 1, len(heights)): if heights[i] > heights[j]: count += 1 return count"},{"question":"def valid_parentheses_string(s: str) -> tuple: Determine if the string \`s\` is a valid parentheses string. If not, return the longest valid parentheses substring. Parameters: s (str): A string consisting of '(' and ')' Returns: tuple: (boolean, substring) - first value indicates if the string is valid, second value is the longest valid parentheses substring (or the string itself if valid) >>> valid_parentheses_string(\\"\\") == (True, \\"\\") >>> valid_parentheses_string(\\"()\\") == (True, \\"()\\") >>> valid_parentheses_string(\\"(())\\") == (True, \\"(())\\") >>> valid_parentheses_string(\\"()()\\") == (True, \\"()()\\") >>> valid_parentheses_string(\\")(\\") == (False, \\"\\") >>> valid_parentheses_string(\\"(()\\") == (False, \\"()\\") >>> valid_parentheses_string(\\"())\\") == (False, \\"()\\") >>> valid_parentheses_string(\\")()())\\") == (False, \\"()()\\") >>> valid_parentheses_string(\\"(()(((()\\") == (False, \\"()\\") >>> valid_parentheses_string(\\"(()(())\\") == (False, \\"()(())\\")","solution":"def valid_parentheses_string(s): Determine if the string \`s\` is a valid parentheses string. If not, return the longest valid parentheses substring. Parameters: s (str): A string consisting of '(' and ')' Returns: tuple: (boolean, substring) - first value indicates if the string is valid, second value is the longest valid parentheses substring (or the string itself if valid) def is_valid(s): stack = [] for char in s: if char == '(': stack.append(char) elif char == ')' and stack: stack.pop() else: return False return not stack def longest_valid_substring(s): max_len = 0 start = 0 n = len(s) stack = [-1] for i in range(n): if s[i] == '(': stack.append(i) else: stack.pop() if stack: length = i - stack[-1] if length > max_len: max_len = length start = stack[-1] + 1 else: stack.append(i) return s[start:start+max_len] valid = is_valid(s) if valid: return (True, s) else: return (False, longest_valid_substring(s))"},{"question":"def furthest_building(heights, bricks, ladders): Return the maximum index of the building that can be reached. Parameters: heights (List[int]): List of building heights. bricks (int): Number of bricks available. ladders (int): Number of ladders available. Returns: int: The maximum index of the building that can be reached. >>> furthest_building([4, 2, 7, 6, 9, 14, 12], 5, 1) 4 >>> furthest_building([4, 12, 2, 7, 3, 18, 20, 3, 19], 10, 2) 7 >>> furthest_building([14, 3, 19, 3], 17, 0) 3 >>> furthest_building([1, 2], 0, 1) 1 >>> furthest_building([1, 2, 3, 4, 5], 10, 0) 4 >>> furthest_building([3, 1, 4, 1, 5, 9, 2, 6], 5, 2) 6 >>> furthest_building([1, 2, 3], 10, 0) 2 >>> furthest_building([1, 5, 1, 1, 5, 1], 10, 1) 5","solution":"import heapq def furthest_building(heights, bricks, ladders): Return the maximum index of the building that can be reached. Parameters: heights (List[int]): List of building heights. bricks (int): Number of bricks available. ladders (int): Number of ladders available. Returns: int: The maximum index of the building that can be reached. heap = [] for i in range(len(heights) - 1): climb = heights[i + 1] - heights[i] if climb > 0: heapq.heappush(heap, climb) if len(heap) > ladders: bricks -= heapq.heappop(heap) if bricks < 0: return i return len(heights) - 1"},{"question":"def total_water_collected(heights: List[int]) -> int: Compute the total amount of water that would be collected after raining over the hills. Each integer in the list represents the height of the hill at that position. >>> total_water_collected([]) 0 >>> total_water_collected([3]) 0 >>> total_water_collected([1, 2, 3]) 0 >>> total_water_collected([3, 0, 3]) 3 >>> total_water_collected([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> total_water_collected([2, 2, 2, 2]) 0 >>> total_water_collected([4, 2, 0, 3, 2, 5]) 9 >>> total_water_collected([0, 2, 0]) 0","solution":"from typing import List def total_water_collected(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"def find_smallest_number(text: str) -> str: Returns the smallest number that can be formed by replacing every '#' in the text with a digit from '0' to '9'. >>> find_smallest_number('#') == '000' >>> find_smallest_number('123') == '123' >>> find_smallest_number('1#34#') == '10340' >>> find_smallest_number('12#') == '12000' >>> find_smallest_number('#') == '0'","solution":"def find_smallest_number(text): Returns the smallest number that can be formed by replacing every '#' in the text with a digit from '0' to '9'. result = text.replace('#', '0') return result"},{"question":"def min_cost_paint_houses(costs: List[List[int]]) -> int: Given an array of colors, where colors[i] represents the color of the ith house, determine the minimum cost to paint all the houses such that no two adjacent houses have the same color. The painting cost of each house is represented by a 2D array costs where costs[i][j] is the cost of painting the ith house with color j. >>> min_cost_paint_houses([[17, 2, 17]]) == 2 >>> min_cost_paint_houses([[17, 2, 17], [16, 16, 5], [14, 3, 19]]) == 10 >>> min_cost_paint_houses([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == 15 >>> min_cost_paint_houses([[1, 2]]) == 1 >>> min_cost_paint_houses([[1, 5, 3], [2, 9, 4]]) == 5 pass","solution":"def min_cost_paint_houses(costs): if not costs: return 0 n = len(costs) k = len(costs[0]) dp = costs[0] for i in range(1, n): prev_dp = dp[:] for j in range(k): dp[j] = costs[i][j] + min(prev_dp[m] for m in range(k) if m != j) return min(dp)"},{"question":"from typing import List def has_hamiltonian_path(num_nodes: int, edges: List[List[int]]) -> bool: Determine if there is a Hamiltonian Path in the directed graph. A Hamiltonian Path is a path in a graph that visits each vertex exactly once. Args: num_nodes (int): Number of nodes in the graph. edges (List[List[int]]): List of directed edges in the graph. Returns: bool: True if there is a Hamiltonian Path, otherwise False. Examples: >>> has_hamiltonian_path(4, [[0, 1], [1, 2], [2, 3]]) True >>> has_hamiltonian_path(4, [[0, 1], [1, 2], [1, 3]]) False >>> has_hamiltonian_path(1, []) True >>> has_hamiltonian_path(2, [[0, 1]]) True >>> has_hamiltonian_path(4, [[0, 1], [2, 3]]) False >>> has_hamiltonian_path(5, [[0, 1], [1, 2], [2, 0], [2, 3], [3, 4], [4, 1]]) True","solution":"from collections import defaultdict def has_hamiltonian_path(num_nodes, edges): def dfs(node, visited, num_visited): if num_visited == num_nodes: return True for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True if dfs(neighbor, visited, num_visited + 1): return True visited[neighbor] = False return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) for start_node in range(num_nodes): visited = [False] * num_nodes visited[start_node] = True if dfs(start_node, visited, 1): return True return False"},{"question":"import heapq from typing import List, Tuple def min_elevation_diff(matrix: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Returns the minimum elevation difference between the highest and lowest points along any path from start to end in the given matrix. pass # Unit tests def test_min_elevation_diff_case_1(): matrix = [ [1, 3, 7], [4, 2, 8], [9, 5, 6] ] start = (0, 0) end = (2, 2) assert min_elevation_diff(matrix, start, end) == 5 def test_min_elevation_diff_case_2(): matrix = [ [10, 30, 20], [50, 25, 40], [35, 15, 30] ] start = (0, 0) end = (2, 2) assert min_elevation_diff(matrix, start, end) == 20 def test_min_elevation_diff_case_3(): matrix = [ [1, 2], [3, 4] ] start = (0, 1) end = (1, 0) assert min_elevation_diff(matrix, start, end) == 2 def test_min_elevation_diff_case_4(): matrix = [ [10] ] start = (0, 0) end = (0, 0) assert min_elevation_diff(matrix, start, end) == 0 def test_min_elevation_diff_case_5(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] start = (0, 0) end = (2, 2) assert min_elevation_diff(matrix, start, end) == 8","solution":"import heapq def min_elevation_diff(matrix, start, end): Returns the minimum elevation difference between the highest and lowest points along any path from start to end in the given matrix. rows, cols = len(matrix), len(matrix[0]) directions = [(0,1), (1,0), (0,-1), (-1,0)] start_val = matrix[start[0]][start[1]] end_val = matrix[end[0]][end[1]] min_heap = [(0, start[0], start[1], start_val, start_val)] # elevation_diff, x, y, min_elevation, max_elevation visited = set() while min_heap: elevation_diff, x, y, min_elevation, max_elevation = heapq.heappop(min_heap) if (x, y) == end: return elevation_diff if (x, y) in visited: continue visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: new_min_elevation = min(min_elevation, matrix[nx][ny]) new_max_elevation = max(max_elevation, matrix[nx][ny]) new_elevation_diff = new_max_elevation - new_min_elevation heapq.heappush(min_heap, (new_elevation_diff, nx, ny, new_min_elevation, new_max_elevation)) return -1 # If no path is found"},{"question":"def max_adjacent_product(arr): Returns the maximum product of any two adjacent elements in the array. >>> max_adjacent_product([3, 6, 7, 4]) == 42 >>> max_adjacent_product([-10, -20, -30, 20]) == 600 >>> max_adjacent_product([-1, 3, -5, 2, 4]) == 8 >>> max_adjacent_product([-1, -2, -3, -4]) == 12 >>> max_adjacent_product([0, 0, 0]) == 0 >>> max_adjacent_product([5, 6]) == 30 >>> max_adjacent_product([]) raises ValueError >>> max_adjacent_product([1]) raises ValueError","solution":"def max_adjacent_product(arr): Returns the maximum product of any two adjacent elements in the array. if len(arr) < 2: raise ValueError(\\"Array must have at least two elements.\\") max_product = arr[0] * arr[1] for i in range(1, len(arr) - 1): max_product = max(max_product, arr[i] * arr[i + 1]) return max_product"},{"question":"from typing import List class MaximizeAdjPairs: def __init__(self, blocks: str): Initialize the MaximizeAdjPairs object with the string blocks. self.blocks = blocks def findMaxPairs(self) -> int: Return the maximum number of adjacent pairs of blocks which are identical that can be achieved by rearranging the blocks in any order. >>> obj = MaximizeAdjPairs(\\"\\") >>> obj.findMaxPairs() 0 >>> obj = MaximizeAdjPairs(\\"R\\") >>> obj.findMaxPairs() 0 >>> obj = MaximizeAdjPairs(\\"RR\\") >>> obj.findMaxPairs() 1 >>> obj = MaximizeAdjPairs(\\"RRWWBB\\") >>> obj.findMaxPairs() 3 >>> obj = MaximizeAdjPairs(\\"RRWBB\\") >>> obj.findMaxPairs() 2 >>> obj = MaximizeAdjPairs(\\"RRRWWBBW\\") >>> obj.findMaxPairs() 3 pass","solution":"from collections import Counter class MaximizeAdjPairs: def __init__(self, blocks): self.blocks = blocks def findMaxPairs(self): # Count the frequency of each block type counter = Counter(self.blocks) # Calculate the maximum number of pairs for each block type max_pairs = 0 for count in counter.values(): max_pairs += count // 2 return max_pairs"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root: TreeNode) -> TreeNode: Inverts a binary tree by swapping left and right children recursively. >>> def tree_to_list(root): ... if not root: ... return [] ... result, queue = [], [root] ... while any(queue): ... node = queue.pop(0) ... if node: ... result.append(node.val) ... queue.append(node.left) ... queue.append(node.right) ... else: ... result.append(None) ... while result and result[-1] is None: ... result.pop() ... return result >>> root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9))) >>> tree_to_list(invertTree(root)) [4, 7, 2, 9, 6, 3, 1] >>> root = TreeNode(1) >>> tree_to_list(invertTree(root)) [1] >>> invertTree(None) is None True >>> root = TreeNode(1, TreeNode(2, TreeNode(3), None), None) >>> tree_to_list(invertTree(root)) [1, None, 2, None, 3] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> tree_to_list(invertTree(root)) [1, 2, None, 3]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root): Inverts a binary tree by swapping left and right children recursively. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recur on left and right subtrees invertTree(root.left) invertTree(root.right) return root"},{"question":"class LongestSubstring: def __init__(self, s: str): Initializes the object with string s. self.s = s def findLength(self) -> int: Returns the length of the longest substring with at most two distinct characters. >>> LongestSubstring(\\"aaaa\\").findLength() 4 >>> LongestSubstring(\\"aabb\\").findLength() 4 >>> LongestSubstring(\\"abcabcabc\\").findLength() 2 >>> LongestSubstring(\\"eceba\\").findLength() 3 >>> LongestSubstring(\\"\\").findLength() 0 >>> LongestSubstring(\\"abcdef\\").findLength() 2 >>> LongestSubstring(\\"abaccc\\").findLength() 4","solution":"class LongestSubstring: def __init__(self, s): self.s = s def findLength(self): n = len(self.s) if n == 0: return 0 left, right = 0, 0 max_len = 0 char_map = {} while right < n: if len(char_map) < 3: char_map[self.s[right]] = right right += 1 if len(char_map) == 3: del_idx = min(char_map.values()) del char_map[self.s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"def min_cost_to_equalize_heights(heights): ''' Calculates the minimum cost to equalize the heights of all buildings. Parameters: heights (list[int]): An array of integers representing the height of each building. Returns: int: Minimum cost to equalize all building heights. ''' pass from solution import min_cost_to_equalize_heights def test_equal_heights(): assert min_cost_to_equalize_heights([5, 5, 5, 5]) == 0 def test_different_heights(): assert min_cost_to_equalize_heights([1, 2, 3]) == 3 def test_large_heights(): assert min_cost_to_equalize_heights([100, 90, 80]) == 30 def test_single_building(): assert min_cost_to_equalize_heights([10]) == 0 def test_zero_heights(): assert min_cost_to_equalize_heights([0, 0, 0, 0]) == 0","solution":"def min_cost_to_equalize_heights(heights): ''' Calculates the minimum cost to equalize the heights of all buildings. Parameters: heights (list[int]): An array of integers representing the height of each building. Returns: int: Minimum cost to equalize all building heights. ''' min_height = min(heights) return sum(height - min_height for height in heights)"},{"question":"def longest_contiguous_substring(s: str) -> int: Returns the length of the longest contiguous substring containing only one distinct letter. >>> longest_contiguous_substring(\\"\\") == 0 >>> longest_contiguous_substring(\\"a\\") == 1 >>> longest_contiguous_substring(\\"b\\") == 1 >>> longest_contiguous_substring(\\"aaaa\\") == 4 >>> longest_contiguous_substring(\\"ababab\\") == 1 >>> longest_contiguous_substring(\\"aaabbbaaa\\") == 3 >>> longest_contiguous_substring(\\"abababaaaaa\\") == 5 >>> longest_contiguous_substring(\\"aaabbbccddddddee\\") == 6 >>> longest_contiguous_substring(\\"abcdef\\") == 1","solution":"def longest_contiguous_substring(s): Returns the length of the longest contiguous substring containing only one distinct letter. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Returns a list of elements that appear more than once in the input array. This algorithm runs in O(n) time and uses constant extra space. >>> find_duplicates([1, 2, 3, 4, 5, 6]) == [] >>> find_duplicates([1, 2, 2, 3, 3, 4, 4]) == [2, 3, 4] >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) == [2, 3] >>> find_duplicates([1, 1, 2]) == [1] >>> large_input = list(range(1, 10001)) + [9999] >>> find_duplicates(large_input) == [9999]","solution":"def find_duplicates(nums): Returns a list of elements that appear more than once in the input array. This algorithm runs in O(n) time and uses constant extra space. duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(abs(num)) else: nums[index] = -nums[index] return duplicates"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: Find the k-th smallest element in the BST. >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kth_smallest(root, 1) 1 >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kth_smallest(root, 2) 2 >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kth_smallest(root, 3) 3 >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kth_smallest(root, 4) 4 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.left.left.left = TreeNode(1) >>> kth_smallest(root, 3) 3 >>> kth_smallest(root, 5) 5 >>> kth_smallest(root, 6) 6","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Find the k-th smallest element in the BST. def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Perform in-order traversal to get elements in sorted order elements = inorder_traversal(root) # Return the k-th smallest element return elements[k - 1]"},{"question":"def longest_palindromic_subsequence_length(s: str) -> int: Returns the length of the longest possible palindromic subsequence that can be made using characters from s. >>> longest_palindromic_subsequence_length('abc') == 1 >>> longest_palindromic_subsequence_length('a') == 1 >>> longest_palindromic_subsequence_length('aaaaaa') == 6 >>> longest_palindromic_subsequence_length('bbbbb') == 5 >>> longest_palindromic_subsequence_length('abccccdd') == 7 >>> longest_palindromic_subsequence_length('aabb') == 4 >>> longest_palindromic_subsequence_length('abcba') == 5 >>> longest_palindromic_subsequence_length('aabbcc') == 6 >>> longest_palindromic_subsequence_length('z') == 1 >>> longest_palindromic_subsequence_length('') == 0","solution":"def longest_palindromic_subsequence_length(s): Returns the length of the longest possible palindromic subsequence that can be made using characters from s. from collections import Counter # Count the frequency of each character freq = Counter(s) # Initialize result and flag to check for odd characters result = 0 odd_found = False for count in freq.values(): if count % 2 == 0: result += count else: result += count - 1 odd_found = True # If we found an odd frequency character, we can use it as the center of the palindrome if odd_found: result += 1 return result"},{"question":"def max_elevation_difference(grid): Returns the maximum difference in elevation between any two connected cells in the grid. >>> max_elevation_difference([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 8 >>> max_elevation_difference([ ... [1, -2, 3], ... [-4, 5, -6], ... [7, -8, 9] ... ]) == 17 >>> max_elevation_difference([ ... [1, 10, 5], ... [4, 15, 6], ... [7, 8, 9] ... ]) == 14 >>> max_elevation_difference([ ... [42] ... ]) == 0 >>> max_elevation_difference([ ... [-1, -10, -5], ... [-4, -15, -6], ... [-7, -8, -9] ... ]) == 14","solution":"def max_elevation_difference(grid): Returns the maximum difference in elevation between any two connected cells in the grid. def dfs(x, y): stack = [(x, y)] visited[x][y] = True min_val, max_val = grid[x][y], grid[x][y] while stack: cx, cy = stack.pop() for nx, ny in get_neighbors(cx, cy): if not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) min_val = min(min_val, grid[nx][ny]) max_val = max(max_val, grid[nx][ny]) return min_val, max_val def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): yield nx, ny visited = [[False] * len(grid[0]) for _ in range(len(grid))] max_diff = 0 for i in range(len(grid)): for j in range(len(grid[i])): if not visited[i][j]: min_val, max_val = dfs(i, j) max_diff = max(max_diff, max_val - min_val) return max_diff"},{"question":"from typing import List def min_total_difference(arr: List[int], k: int) -> int: You are given an integer array \`arr\` of length \`n\`, representing the heights of buildings in a straight line. Each building can either be painted or left unpainted. You must paint exactly \`k\` buildings such that the total difference in height between each pair of adjacent painted buildings is minimized. Return the minimum possible total difference in height achieved by selecting and painting these \`k\` buildings. If it is not possible to paint exactly \`k\` buildings, return \`-1\`. Parameters: arr (List[int]): List of integers representing heights of buildings. k (int): Number of buildings to be painted. Returns: int: Minimum possible total difference in height, or -1 if not possible. Examples: >>> min_total_difference([1, 3, 6, 10, 15], 3) 5 >>> min_total_difference([1, 2, 3], 4) -1 >>> min_total_difference([5], 1) 0 >>> min_total_difference([5, 6, 7, 8], 4) 3 >>> min_total_difference([2, 4, 6, 8, 10], 2) 2 >>> min_total_difference([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 5) 40 >>> min_total_difference([7, 7, 7, 7, 7], 3) 0 >>> min_total_difference([100, 95, 90, 85, 80, 75], 3) 10","solution":"def min_total_difference(arr, k): Returns the minimum possible total difference in height achieved by selecting and painting exactly k buildings. If it's not possible to paint k buildings, returns -1. Parameters: arr (list): List of integers representing heights of buildings. k (int): Number of buildings to be painted. Returns: int: Minimum possible total difference in height, or -1 if not possible. n = len(arr) if k > n: return -1 arr.sort() min_diff = float('inf') for i in range(n - k + 1): current_diff = arr[i + k - 1] - arr[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def longest_valid_parentheses(s: str) -> int: Given a string \`s\` consisting only of characters \`(\` and \`)\`, find the length of the longest valid (well-formed) substring. >>> longest_valid_parentheses(\\"(()\\") == 2 >>> longest_valid_parentheses(\\")()())\\") == 4 >>> longest_valid_parentheses(\\"\\") == 0 >>> longest_valid_parentheses(\\"()(()\\") == 2 >>> longest_valid_parentheses(\\"()()\\") == 4 >>> longest_valid_parentheses(\\"((()))\\") == 6 >>> longest_valid_parentheses(\\")()())()()(\\") == 4 >>> longest_valid_parentheses(\\"()(()))))\\") == 6 >>> longest_valid_parentheses(\\"(()())\\") == 6 >>> longest_valid_parentheses(\\"(()()())\\") == 8","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid (well-formed) substring. max_length = 0 stack = [-1] # Initialize stack with -1 to handle edge case for valid substring from the beginning for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"def is_bipartite(n: int, edges: List[List[int]]) -> bool: Determines if the given graph is bipartite. >>> is_bipartite(4, [[0, 1], [1, 2], [2, 3], [3, 0]]) True >>> is_bipartite(3, [[0, 1], [1, 2], [2, 0]]) False >>> is_bipartite(5, [[0, 1], [0, 3], [1, 2], [3, 4]]) True >>> is_bipartite(4, [[0, 1], [2, 3]]) True >>> is_bipartite(1, []) True >>> is_bipartite(0, []) True","solution":"def is_bipartite(n, edges): Determines if the given graph is bipartite. Parameters: - n: int - The number of nodes in the graph - edges: List[List[int]] - The edges of the graph Returns: - bool - True if the graph is bipartite, False otherwise from collections import deque # Create adjacency list graph = {i: [] for i in range(n)} for u, v in edges: graph[u].append(v) graph[v].append(u) # Initialize all nodes with no color (0: uncolored, 1: color1, -1: color2) color = [0] * n def bfs(start): queue = deque([start]) color[start] = 1 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == 0: # If not colored, color with opposite color color[neighbor] = -color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # If same color as current node return False return True # Check each component of the graph for i in range(n): if color[i] == 0: if not bfs(i): return False return True"},{"question":"def is_bipartite(graph): Determines if the graph can be bipartitioned such that all nodes connected by an edge have different colors. Parameters: graph (list of list of int): The adjacency list of the graph. Returns: bool: True if the graph can be bipartitioned, False otherwise. >>> is_bipartite([[1, 3], [0, 2], [1, 3], [0, 2]]) True >>> is_bipartite([[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]) False >>> is_bipartite([[], [3], [], [1]]) True >>> is_bipartite([[]]) True >>> is_bipartite([]) True >>> is_bipartite([[1], [0, 2], [1]]) True","solution":"def is_bipartite(graph): Determines if the graph can be bipartitioned such that all nodes connected by an edge have different colors. Parameters: graph (list of list of int): The adjacency list of the graph. Returns: bool: True if the graph can be bipartitioned, False otherwise. n = len(graph) color = [-1] * n # -1 means uncolored def dfs(node, c): color[node] = c for neighbor in graph[node]: if color[neighbor] == -1: if not dfs(neighbor, 1 - c): return False elif color[neighbor] == color[node]: return False return True for i in range(n): if color[i] == -1: if not dfs(i, 0): return False return True"},{"question":"def has_zero_sum_subarray(arr: List[int]) -> bool: Checks if there exists a subarray with sum zero in the given array \`arr\`. >>> has_zero_sum_subarray([4, 2, -3, 1, 6]) True >>> has_zero_sum_subarray([1, 2, 3]) False >>> has_zero_sum_subarray([]) False >>> has_zero_sum_subarray([0]) True >>> has_zero_sum_subarray([-1, 1]) True >>> has_zero_sum_subarray([3, -3, 3, -3]) True >>> has_zero_sum_subarray([1, -1, 2, -2, 3, -3]) True from solution import has_zero_sum_subarray def test_has_zero_sum_subarray_case1(): assert has_zero_sum_subarray([4, 2, -3, 1, 6]) == True def test_has_zero_sum_subarray_case2(): assert has_zero_sum_subarray([1, 2, 3]) == False def test_has_zero_sum_subarray_case3(): assert has_zero_sum_subarray([]) == False def test_has_zero_sum_subarray_case4(): assert has_zero_sum_subarray([0]) == True def test_has_zero_sum_subarray_case5(): assert has_zero_sum_subarray([-1, 1]) == True def test_has_zero_sum_subarray_case6(): assert has_zero_sum_subarray([3, -3, 3, -3]) == True def test_has_zero_sum_subarray_case7(): assert has_zero_sum_subarray([1, -1, 2, -2, 3, -3]) == True","solution":"def has_zero_sum_subarray(arr): Checks if there exists a subarray with sum zero in the given array \`arr\`. :param arr: List[int] - List of integers. :return: bool - True if there is a subarray with sum zero, otherwise False. prefix_sum = 0 prefix_set = set() for num in arr: prefix_sum += num # If prefix_sum is 0 or it is already seen, we have a zero sum subarray if prefix_sum == 0 or prefix_sum in prefix_set: return True prefix_set.add(prefix_sum) return False"},{"question":"from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def constructFromPrePost(preorder: List[int], postorder: List[int]) -> TreeNode: Construct a binary tree from pre-order and post-order traversals. :param preorder: List of integers representing the pre-order traversal of the tree. :param postorder: List of integers representing the post-order traversal of the tree. :return: The root TreeNode of the constructed binary tree. Example usage: >>> preorder = [1, 2, 4, 5, 3, 6, 7] >>> postorder = [4, 5, 2, 6, 7, 3, 1] >>> root = constructFromPrePost(preorder, postorder) def trees_are_equal(tree1: TreeNode, tree2: TreeNode) -> bool: if tree1 is tree2 is None: return True if tree1 is None or tree2 is None: return False return (tree1.val == tree2.val and trees_are_equal(tree1.left, tree2.left) and trees_are_equal(tree1.right, tree2.right)) def test_constructBinaryTree_example(): preorder = [1, 2, 4, 5, 3, 6, 7] postorder = [4, 5, 2, 6, 7, 3, 1] expected_tree = TreeNode(1) expected_tree.left = TreeNode(2) expected_tree.right = TreeNode(3) expected_tree.left.left = TreeNode(4) expected_tree.left.right = TreeNode(5) expected_tree.right.left = TreeNode(6) expected_tree.right.right = TreeNode(7) result_tree = constructFromPrePost(preorder, postorder) assert trees_are_equal(result_tree, expected_tree) def test_constructBinaryTree_single_element(): preorder = [1] postorder = [1] expected_tree = TreeNode(1) result_tree = constructFromPrePost(preorder, postorder) assert trees_are_equal(result_tree, expected_tree) def test_constructBinaryTree_complex(): preorder = [1, 2, 4, 5, 3, 6, 7, 8] postorder = [4, 5, 2, 6, 8, 7, 3, 1] expected_tree = TreeNode(1) expected_tree.left = TreeNode(2) expected_tree.right = TreeNode(3) expected_tree.left.left = TreeNode(4) expected_tree.left.right = TreeNode(5) expected_tree.right.left = TreeNode(6) expected_tree.right.right = TreeNode(7) expected_tree.right.right.left = TreeNode(8) result_tree = constructFromPrePost(preorder, postorder) assert trees_are_equal(result_tree, expected_tree)","solution":"from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def constructFromPrePost(preorder: List[int], postorder: List[int]) -> TreeNode: if not preorder or not postorder: return None root = TreeNode(preorder[0]) if len(preorder) == 1: return root # Find the index of the left child in postorder left_child_val = preorder[1] left_size = postorder.index(left_child_val) + 1 root.left = constructFromPrePost(preorder[1:left_size + 1], postorder[:left_size]) root.right = constructFromPrePost(preorder[left_size + 1:], postorder[left_size:-1]) return root"},{"question":"from typing import List def group_anagrams(strings: List[str]) -> List[List[str]]: Group the given list of strings into anagrams. Parameters: strings (List[str]): The list of strings to group. Returns: List[List[str]]: A list of lists where each sublist contains anagrams. >>> group_anagrams([\\"bat\\", \\"tab\\", \\"cat\\"]) in [[\\"bat\\", \\"tab\\"], [\\"cat\\"]] True >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) [[\\"a\\"], [\\"b\\"], [\\"c\\"], [\\"d\\"]]","solution":"def group_anagrams(strings): Groups the input strings that are anagrams of each other. Parameters: strings (List[str]): The list of strings to be grouped. Returns: List[List[str]]: A list of lists where each sublist contains strings that are anagrams of each other. from collections import defaultdict anagram_dict = defaultdict(list) for string in strings: # Sort the string characters to form key sorted_string = ''.join(sorted(string)) # Add string to the corresponding anagram group anagram_dict[sorted_string].append(string) # Convert dictionary values to list of lists return list(anagram_dict.values())"},{"question":"from functools import lru_cache def num_decodings(s: str) -> int: Returns the total number of distinct decoding combinations for a given string s of digits. >>> num_decodings(\\"23\\") 9 >>> num_decodings(\\"7\\") 4 >>> num_decodings(\\"10\\") 1 >>> num_decodings(\\"101\\") 1 >>> num_decodings(\\"58\\") 9 >>> num_decodings(\\"\\") 0 >>> num_decodings(\\"234\\") 27 digit_to_char = { '0': ' ', '1': '', '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } @lru_cache(None) def backtrack(index): if index == len(s): return 1 if s[index] == '1': return backtrack(index + 1) total_ways = 0 for char in digit_to_char[s[index]]: total_ways += backtrack(index + 1) return total_ways return backtrack(0)","solution":"from functools import lru_cache def num_decodings(s): Returns the total number of distinct decoding combinations for a given string s of digits. if not s: return 0 digit_to_char = { '0': ' ', '1': '', '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } # Caching the calculated results @lru_cache(None) def backtrack(index): if index == len(s): return 1 if s[index] == '1': return backtrack(index + 1) total_ways = 0 for char in digit_to_char[s[index]]: total_ways += backtrack(index + 1) return total_ways return backtrack(0)"},{"question":"import bisect from typing import List def process_operations_and_queries(operations: List[str], queries1: List[int], queries2: List[int]) -> List[int]: Perform a list of insertion and deletion operations on a set and respond to subsequent queries. :param operations: List of operations, where each operation is a string in the form of \\"I x\\" or \\"D x\\". :param queries1: List of integers for which we need to find the smallest integer in the set that is greater than each integer. :param queries2: List of integers for which we need to find the largest integer in the set that is less than each integer. :return: List of results for queries1 followed by results for queries2. # Unit Tests import pytest from solution import process_operations_and_queries def test_process_operations_and_queries(): operations = [\\"I 1\\", \\"I 3\\", \\"I 5\\", \\"D 3\\"] queries1 = [2, 4] queries2 = [4, 6] assert process_operations_and_queries(operations, queries1, queries2) == [5, 5, 1, 5] def test_process_operations_and_queries_with_no_deletes(): operations = [\\"I 1\\", \\"I 3\\", \\"I 5\\"] queries1 = [2, 4] queries2 = [4, 6] assert process_operations_and_queries(operations, queries1, queries2) == [3, 5, 3, 5] def test_process_operations_and_queries_with_all_deletes(): operations = [\\"I 1\\", \\"I 3\\", \\"I 5\\", \\"D 1\\", \\"D 3\\", \\"D 5\\"] queries1 = [2, 4] queries2 = [4, 6] assert process_operations_and_queries(operations, queries1, queries2) == [-1, -1, -1, -1] def test_process_operations_and_queries_with_edge_cases(): operations = [\\"I 1\\"] queries1 = [0, 1] queries2 = [1, 2] assert process_operations_and_queries(operations, queries1, queries2) == [1, -1, -1, 1] def test_process_operations_and_queries_with_empty_set(): operations = [] queries1 = [1, 2] queries2 = [3, 4] assert process_operations_and_queries(operations, queries1, queries2) == [-1, -1, -1, -1]","solution":"import bisect def process_operations_and_queries(operations, queries1, queries2): Perform a list of insertion and deletion operations on a set and respond to subsequent queries. :param operations: List of operations, where each operation is a string in the form of \\"I x\\" or \\"D x\\". :param queries1: List of integers for which we need to find the smallest integer in the set that is greater than each integer. :param queries2: List of integers for which we need to find the largest integer in the set that is less than each integer. :return: List of results for queries1 followed by results for queries2. sorted_set = [] # Process the operations for operation in operations: command, value = operation.split() value = int(value) if command == \\"I\\": if value not in sorted_set: bisect.insort(sorted_set, value) elif command == \\"D\\": if value in sorted_set: sorted_set.remove(value) results = [] # Handle queries1 for q1 in queries1: index = bisect.bisect_right(sorted_set, q1) if index < len(sorted_set): results.append(sorted_set[index]) else: results.append(-1) # Handle queries2 for q2 in queries2: index = bisect.bisect_left(sorted_set, q2) if index > 0: results.append(sorted_set[index - 1]) else: results.append(-1) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_diff_in_bst(root: TreeNode) -> int: Returns the minimum difference between the values of any two different nodes in the tree. # Implementation goes here from solution import TreeNode, min_diff_in_bst def test_min_diff_small_tree(): root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(6) root.left.left = TreeNode(1) root.left.right = TreeNode(3) assert min_diff_in_bst(root) == 1 def test_min_diff_unbalanced_tree(): root = TreeNode(1) root.right = TreeNode(3) root.right.left = TreeNode(2) assert min_diff_in_bst(root) == 1 def test_min_diff_large_differences(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.right.right = TreeNode(25) root.right.left = TreeNode(13) assert min_diff_in_bst(root) == 2 def test_min_diff_root_with_only_right(): root = TreeNode(1) root.right = TreeNode(10) assert min_diff_in_bst(root) == 9","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_diff_in_bst(root: TreeNode) -> int: Returns the minimum difference between the values of any two different nodes in the tree. prev = None min_diff = float('inf') def in_order_traverse(node): nonlocal prev, min_diff if node is None: return in_order_traverse(node.left) if prev is not None: min_diff = min(min_diff, node.val - prev) prev = node.val in_order_traverse(node.right) in_order_traverse(root) return min_diff"},{"question":"def length_of_longest_substring(s: str) -> int: Return the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"aA\\") 2 >>> length_of_longest_substring(\\"AaBbCc\\") 6 >>> length_of_longest_substring(\\"aaabbbccc\\") 2 >>> length_of_longest_substring(\\"abba\\") 2 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"b\\") 1","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): Input string containing only English letters (both lowercase and uppercase) Returns: int: Length of the longest substring without repeating characters char_map = {} start = max_length = 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def rob(nums): Given an integer array nums representing the values of a row of houses, this function returns the maximum amount of money you can rob tonight without alerting the police. You cannot rob two adjacent houses. Parameters: nums (List[int]): A list of integers representing the values of the houses. Returns: int: The maximum amount of money that can be robbed. pass # Unit tests def test_no_houses(): assert rob([]) == 0 def test_one_house(): assert rob([5]) == 5 def test_two_houses(): assert rob([5, 10]) == 10 assert rob([10, 5]) == 10 def test_multiple_houses(): assert rob([1, 2, 3, 1]) == 4 # rob house 1 and 3 assert rob([2, 7, 9, 3, 1]) == 12 # rob house 1, 3, and 4 assert rob([2, 1, 1, 2]) == 4 # rob house 1 and 4 def test_alternating_values(): assert rob([10, 2, 10, 2, 10, 2]) == 30 # rob house 1, 3, 5 assert rob([5, 10, 5, 10, 5, 10]) == 30 # rob house 2, 4, 6","solution":"def rob(nums): Given an integer array nums representing the values of a row of houses, this function returns the maximum amount of money you can rob tonight without alerting the police. You cannot rob two adjacent houses. Parameters: nums (List[int]): A list of integers representing the values of the houses. Returns: int: The maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] n = len(nums) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], nums[i] + dp[i-2]) return dp[-1]"},{"question":"def min_time_to_complete_tasks(tasks: List[int], n: int) -> int: Returns the minimum time required to complete all tasks subject to a cooldown period. :param tasks: List[int], list of tasks where each task is represented by an integer. :param n: int, cooldown period between two identical tasks. :return: int, the minimum time required to complete all tasks. >>> min_time_to_complete_tasks([1, 2, 3], 2) 3 >>> min_time_to_complete_tasks([1, 2, 3, 1], 0) 4 >>> min_time_to_complete_tasks([1, 1, 2, 2, 3, 3], 2) 6 >>> min_time_to_complete_tasks([1, 1, 1, 1], 2) 10 >>> min_time_to_complete_tasks([], 2) 0","solution":"def min_time_to_complete_tasks(tasks, n): Returns the minimum time required to complete all tasks subject to a cooldown period. :param tasks: List[int], list of tasks where each task is represented by an integer. :param n: int, cooldown period between two identical tasks. :return: int, the minimum time required to complete all tasks. if not tasks: return 0 from collections import Counter # Count the occurrence of each task task_counts = Counter(tasks) # Find the maximum frequency of any task max_count = max(task_counts.values()) # Count how many tasks have the maximum frequency max_count_tasks = sum(1 for count in task_counts.values() if count == max_count) # Calculate part length part_length = (max_count - 1) * (n + 1) + max_count_tasks return max(part_length, len(tasks))"},{"question":"from typing import List def numIslands(grid: List[List[str]]) -> int: Returns the number of islands in the binary matrix grid. >>> numIslands([ [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ]) 1 >>> numIslands([ [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ]) 3 pass def numIslands2(grid: List[List[str]], positions: List[List[int]]) -> List[int]: Returns the number of islands after each add operation >>> numIslands2([ [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"] ], [[0, 0], [0, 1], [1, 2], [2, 1], [1, 1]]) [1, 1, 2, 3, 1] >>> numIslands2([ [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"] ], [[0, 0], [0, 0], [1, 1], [1, 1], [2, 1]]) [1, 1, 2, 2, 2] >>> numIslands2([ [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"] ], []) 0 pass","solution":"def numIslands(grid): Returns the number of islands in the binary matrix grid. if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0' or visited[i][j]: return visited[i][j] = True dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) count = 0 for i in range(m): for j in range(n): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) count += 1 return count def numIslands2(grid, positions): Returns the number of islands after each add operation if not grid or not positions: return 0 m, n = len(grid), len(grid[0]) parent = [-1] * (m * n) rank = [0] * (m * n) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def index(x, y): return x * n + y result = [] num_islands = 0 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] for x, y in positions: if grid[x][y] == '1': result.append(num_islands) continue grid[x][y] = '1' idx = index(x, y) parent[idx] = idx num_islands += 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == '1': if find(index(nx, ny)) != find(idx): union(idx, index(nx, ny)) num_islands -= 1 result.append(num_islands) return result"},{"question":"def min_cost_to_paint_houses(cost: List[List[int]]) -> int: You are given a list of \`n\` houses, where each house is painted with one of \`k\` colors. The colors of the houses are represented by an \`n x k\` cost matrix, where \`cost[i][j]\` is the cost of painting the \`i-th\` house with the \`j-th\` color. You have to paint all the houses such that no two adjacent houses have the same color. Return the minimum cost to paint all the houses. If it is not possible to paint all the houses under the given conditions, return -1. >>> min_cost_to_paint_houses([ ... [1, 5, 3], ... [2, 9, 4] ... ]) == 5 >>> min_cost_to_paint_houses([ ... [7, 3, 8, 6] ... ]) == 3 >>> min_cost_to_paint_houses([ ... [1, 9], ... [9, 1] ... ]) == 2 >>> min_cost_to_paint_houses([ ... [1], ... [2], ... [3] ... ]) == -1 >>> min_cost_to_paint_houses([]) == 0 >>> min_cost_to_paint_houses([ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ]) == 15","solution":"import sys def min_cost_to_paint_houses(cost): if not cost: return 0 n = len(cost) k = len(cost[0]) if k == 1 and n > 1: return -1 for i in range(1, n): for j in range(k): cost[i][j] += min(cost[i-1][l] for l in range(k) if l != j) return min(cost[-1]) # Example cost = [ [1, 5, 3], [2, 9, 4] ] print(min_cost_to_paint_houses(cost)) # should output 5"},{"question":"def exist(grid: List[List[str]], word: str) -> bool: Determines if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells. >>> grid = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> word = \\"ABCCED\\" >>> exist(grid, word) True >>> word = \\"ABCB\\" >>> exist(grid, word) False >>> grid = [['A']] >>> word = \\"A\\" >>> exist(grid, word) True >>> grid = [ ... ['A', 'B'], ... ['C', 'D'] ... ] >>> word = \\"ABCDE\\" >>> exist(grid, word) False >>> grid = [ ... ['A', 'A', 'A', 'A'], ... ['A', 'A', 'A', 'A'], ... ['A', 'A', 'A', 'A'] ... ] >>> word = \\"AAAAAAAAA\\" >>> exist(grid, word) True >>> grid = [ ... ['A', 'B'], ... ['B', 'A'] ... ] >>> word = \\"ABC\\" >>> exist(grid, word) False","solution":"def exist(grid, word): rows, cols = len(grid), len(grid[0]) word_len = len(word) def backtrack(r, c, index): if index == word_len: return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False temp, grid[r][c] = grid[r][c], '#' found = (backtrack(r + 1, c, index + 1) or backtrack(r - 1, c, index + 1) or backtrack(r, c + 1, index + 1) or backtrack(r, c - 1, index + 1)) grid[r][c] = temp return found for i in range(rows): for j in range(cols): if backtrack(i, j, 0): return True return False"},{"question":"def min_deletions_to_subsequence(s: str, t: str) -> int: Returns the minimum number of deletions needed from t to make s a subsequence of t. If it's not possible, returns -1. >>> min_deletions_to_subsequence(\\"abc\\", \\"ahbgdc\\") 3 >>> min_deletions_to_subsequence(\\"abc\\", \\"abc\\") 0 >>> min_deletions_to_subsequence(\\"axc\\", \\"ahbgdc\\") -1 >>> min_deletions_to_subsequence(\\"abc\\", \\"aebdc\\") 2 >>> min_deletions_to_subsequence(\\"\\", \\"ahbgdc\\") 6 >>> min_deletions_to_subsequence(\\"abc\\", \\"\\") -1 >>> min_deletions_to_subsequence(\\"\\", \\"\\") 0 >>> min_deletions_to_subsequence(\\"abc\\", \\"ababbcabcabc\\") 9","solution":"def min_deletions_to_subsequence(s, t): Returns the minimum number of deletions needed from t to make s a subsequence of t. If it's not possible, returns -1. # Two pointers approach ptr_s, ptr_t = 0, 0 # Traverse through t and check if all characters of s can be found in sequence while ptr_t < len(t) and ptr_s < len(s): if s[ptr_s] == t[ptr_t]: ptr_s += 1 ptr_t += 1 # If we have traversed all characters of s, then it's a valid subsequence if ptr_s == len(s): # Minimum deletions required to make s subsequence of t return len(t) - len(s) else: # If ptr_s did not reach the end of s, s is not a valid subsequence of t return -1"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return the level order traversal of its nodes' values. :param root: TreeNode, the root of the binary tree :return: List of lists, each inner list contains the values of the nodes at that level >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> level_order_traversal(root) [[1], [2, 3]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of a binary tree's nodes' values. :param root: TreeNode, the root of the binary tree :return: List of lists, each inner list contains the values of the nodes at that level if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"from typing import List def find_words(board: List[List[str]], words: List[str]) -> List[str]: Given a 2D grid of characters and a list of words, return a list of all words that can be formed by sequentially adjacent characters of the grid, where \\"adjacent\\" characters are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word, and words can be found in any direction in the grid. The order of words in the output list does not matter. >>> board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']] >>> words = [\\"oath\\", \\"pea\\", \\"eat\\"] >>> find_words(board, words) [\\"oath\\", \\"eat\\"] >>> board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']] >>> words = [\\"hello\\", \\"world\\"] >>> find_words(board, words) [] >>> board = [['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e']] >>> words = [\\"abcced\\", \\"see\\", \\"abcf\\"] >>> find_words(board, words) [\\"abcced\\", \\"see\\"] >>> board = [['a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a']] >>> words = [\\"aaaa\\", \\"aaa\\"] >>> sorted(find_words(board, words)) [\\"aaaa\\", \\"aaa\\"]","solution":"def find_words(board, words): def dfs(board, word, i, j, k, visited): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return False if visited[i][j] or board[i][j] != word[k]: return False visited[i][j] = True if dfs(board, word, i + 1, j, k + 1, visited) or dfs(board, word, i - 1, j, k + 1, visited) or dfs(board, word, i, j + 1, k + 1, visited) or dfs(board, word, i, j - 1, k + 1, visited): return True visited[i][j] = False return False found_words = [] for word in words: found = False for i in range(len(board)): for j in range(len(board[0])): visited = [[False] * len(board[0]) for _ in range(len(board))] if dfs(board, word, i, j, 0, visited): found_words.append(word) found = True break if found: break return found_words"},{"question":"def rearrangeString(s: str, k: int) -> str: Rearrange the string such that the same characters are at least \`k\` distance apart. If it is not possible to rearrange the string according to the above rule, return an empty string. >>> rearrangeString(\\"aabb\\", 0) == \\"aabb\\" >>> rearrangeString(\\"aabbcc\\", 3) in [\\"abcabc\\", \\"acbacb\\"] >>> rearrangeString(\\"aaabc\\", 3) == \\"\\" >>> rearrangeString(\\"aaadbbcc\\", 2) == \\"abacabcd\\" >>> rearrangeString(\\"a\\", 2) == \\"a\\" >>> rearrangeString(\\"aabbcc\\", 2) in [\\"abcabc\\", \\"acbacb\\", \\"abacbc\\", \\"bacbac\\", \\"bcabca\\", \\"cababc\\", \\"bacaac\\"] >>> rearrangeString(\\"aab\\", 4) == \\"\\"","solution":"import heapq from collections import Counter, deque def rearrangeString(s: str, k: int) -> str: if k == 0: return s # Step 1: Count frequencies of each character freq = Counter(s) # Step 2: Create a max heap of characters based on their frequencies max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) result = [] queue = deque() # queue to keep track of waiting characters # Step 3: Construct the result while maintaining k distance rule while max_heap: count, char = heapq.heappop(max_heap) result.append(char) queue.append((count + 1, char)) # +1 because count is negative if len(queue) < k: continue # Step 4: Re-add the element back from the queue to the heap if there's still more of that character left ready_count, ready_char = queue.popleft() if ready_count < 0: heapq.heappush(max_heap, (ready_count, ready_char)) # If the rearranged string does not match the original length, return an empty string return ''.join(result) if len(result) == len(s) else \\"\\""},{"question":"def can_make_bouquets(flowers: List[int], k: int, m: int) -> bool: Determine if it is possible to make m bouquets each consisting of k consecutive flowers. >>> can_make_bouquets([1, 10, 3, 10, 2], 3, 1) True >>> can_make_bouquets([1, 10, 3, 10, 2], 3, 2) False >>> can_make_bouquets([7, 7, 7, 7, 12, 7, 7], 3, 2) True >>> can_make_bouquets([7, 7, 7, 7, 12, 7, 7], 4, 1) True >>> can_make_bouquets([1000000000, 1000000000], 1, 1) True >>> can_make_bouquets([1, 10, 3, 10, 2], 3, 1) True >>> can_make_bouquets([1, 2, 3], 1, 3) True >>> can_make_bouquets([1, 2, 3], 1, 4) False","solution":"def can_make_bouquets(flowers, k, m): Determine if it is possible to make m bouquets each consisting of k consecutive flowers. def can_bloom(day): count = 0 # to keep track of consecutive blooming flowers bouquets = 0 # to keep track of bouquets made for bloom_day in flowers: if bloom_day <= day: count += 1 if count == k: bouquets += 1 count = 0 else: count = 0 if bouquets >= m: return True return False low, high = min(flowers), max(flowers) while low < high: mid = (low + high) // 2 if can_bloom(mid): high = mid else: low = mid + 1 return can_bloom(low)"},{"question":"from typing import List def longest_unimodal_subsequence(arr: List[int]) -> int: Find and return the length of the longest unimodal subsequence of the input array. >>> longest_unimodal_subsequence([1, 2, 3, 4, 3, 2, 1]) 7 >>> longest_unimodal_subsequence([1, 2, 1]) 3 >>> longest_unimodal_subsequence([1, 2, 3, 4]) 0 >>> longest_unimodal_subsequence([5, 4, 3, 2, 1]) 0 >>> longest_unimodal_subsequence([1, 2, 2, 1]) 3 >>> longest_unimodal_subsequence([1, 3, 2, 4, 1]) 4 >>> longest_unimodal_subsequence([]) 0 >>> longest_unimodal_subsequence([1]) 0 >>> longest_unimodal_subsequence([1, 2, 3, 5, 3, 2, 1]) 7 >>> longest_unimodal_subsequence([2, 4, 3, 5, 3, 2, 1]) 6 >>> longest_unimodal_subsequence([1, 3, 5, 4, 2]) 5","solution":"def longest_unimodal_subsequence(arr): Finds the length of the longest unimodal subsequence of the input array. n = len(arr) if n == 0: return 0 # Arrays to store the length of the longest increasing subsequence # ending at index i and starting from index i. inc = [1] * n dec = [1] * n # Fill inc[] such that inc[i] stores the length of the longest increasing # subsequence ending at index i for i in range(1, n): for j in range(i): if arr[i] > arr[j] and inc[i] < inc[j] + 1: inc[i] = inc[j] + 1 # Fill dec[] such that dec[i] stores the length of the longest decreasing # subsequence starting from index i for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if arr[i] > arr[j] and dec[i] < dec[j] + 1: dec[i] = dec[j] + 1 # Find the maximum value of inc[i] + dec[i] - 1 (we subtract 1 because arr[i] # is counted twice) max_length = 0 for i in range(n): if inc[i] > 1 and dec[i] > 1: # both increasing and decreasing needed max_length = max(max_length, inc[i] + dec[i] - 1) return max_length"},{"question":"def rotate(nums: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. >>> rotate([1,2,3,4,5,6,7], 3) [5,6,7,1,2,3,4] >>> rotate([1,2,3,4,5,6,7], 0) [1,2,3,4,5,6,7] >>> rotate([1,2,3,4,5,6,7], 7) [1,2,3,4,5,6,7] >>> rotate([1,2,3,4,5,6,7], 10) [5,6,7,1,2,3,4] >>> rotate([1], 3) [1] >>> rotate([1,2], 1) [2,1]","solution":"def rotate(nums, k): Rotates the array to the right by k steps. n = len(nums) k = k % n # In case k is greater than array length nums[:] = nums[-k:] + nums[:-k] # Re-arrange elements in-place return nums"},{"question":"def searchMatrix(matrix, target): Returns true if target is present in the matrix, otherwise false. The matrix has the following properties: - Each row is sorted in ascending order. - Each column is sorted in ascending order. >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> searchMatrix(matrix, 5) True >>> searchMatrix(matrix, 20) False >>> searchMatrix([], 1) False >>> searchMatrix([[1]], 2) False","solution":"def searchMatrix(matrix, target): Returns true if target is present in the matrix, otherwise false. The matrix has the following properties: - Each row is sorted in ascending order. - Each column is sorted in ascending order. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = cols - 1 # Iterate until we are out of bounds while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"def smallest_positive_sum(arr: List[int]) -> int: Determine the smallest positive integer m such that arr contains a pair of integers (x, y) whose sum is equal to m. If no such pair exists, return -1. >>> smallest_positive_sum([1, 2, 3, 4]) == 3 >>> smallest_positive_sum([1, 1, 2, 2, 3, 3]) == 2 >>> smallest_positive_sum([-1, -2, -3, -4]) == -1 >>> smallest_positive_sum([-1, 1, -2, 2]) == 1 >>> smallest_positive_sum([0, -1, -2, -3]) == -1 >>> smallest_positive_sum([0, 1, 2, 3]) == 1","solution":"def smallest_positive_sum(arr): Returns the smallest positive integer m such that arr contains a pair of integers (x, y) whose sum is equal to m. If no such pair exists, returns -1. seen = set() smallest_sum = float('inf') for num in arr: for s in seen: if (num + s) > 0: smallest_sum = min(smallest_sum, num + s) seen.add(num) return smallest_sum if smallest_sum != float('inf') else -1"},{"question":"from typing import List, Union class ArraySplitter: def __init__(self, arr: List[int], x: int): Initializes the ArraySplitter with an integer array and an integer difference. self.arr = arr self.x = x def splitArray(self) -> Union[List[List[int]], str]: Splits the array into two subarrays such that the difference between their sums is equal to x, or returns 'Not Possible' if no such split is possible. >>> splitter = ArraySplitter([1, 2, 3, 4, 5], 3) >>> splitter.splitArray() [[1, 2, 5], [3, 4]] >>> splitter = ArraySplitter([1, 2, 3], 10) >>> splitter.splitArray() 'Not Possible' >>> splitter = ArraySplitter([1, 2, 3], 1) >>> splitter.splitArray() 'Not Possible' >>> splitter = ArraySplitter([1, 2, 3, 4], 0) >>> splitter.splitArray() [[1, 2, 3], [4]] >>> splitter = ArraySplitter([5, 5, 10, 20, 5, 5], 10) >>> splitter.splitArray() [[5, 10, 5], [5, 20]]","solution":"from typing import List, Union class ArraySplitter: def __init__(self, arr: List[int], x: int): self.arr = arr self.x = x def splitArray(self) -> Union[List[List[int]], str]: total_sum = sum(self.arr) n = len(self.arr) # The sum of arr1 should be (total_sum + x)/2 if (total_sum + self.x) % 2 != 0: return \\"Not Possible\\" target_sum = (total_sum + self.x) // 2 dp = [[False] * (target_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): current_value = self.arr[i - 1] for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= current_value: dp[i][j] = dp[i][j] or dp[i - 1][j - current_value] if not dp[n][target_sum]: return \\"Not Possible\\" arr1 = [] arr2 = [] remaining_sum = target_sum for i in range(n, 0, -1): if not dp[i - 1][remaining_sum]: arr1.append(self.arr[i - 1]) remaining_sum -= self.arr[i - 1] else: arr2.append(self.arr[i - 1]) arr1.reverse() arr2.reverse() return [arr1, arr2]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the values of the nodes you can see from the right side of the binary tree. >>> root = TreeNode(1) >>> rightSideView(root) [1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> rightSideView(root) [1, 3, 6] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(5) >>> root.right.right.right = TreeNode(6) >>> rightSideView(root) [1, 2, 5, 6] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> rightSideView(root) [1, 2, 3, 4] >>> root = None >>> rightSideView(root) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the values of the nodes you can see from the right side of the binary tree. if not root: return [] right_view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # If it's the rightmost element if i == level_length - 1: right_view.append(node.val) # Add child nodes in the queue if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"def min_removals_to_non_decreasing(heights: List[int]) -> int: Returns the minimum number of buildings that need to be removed to achieve a non-decreasing sequence. :param heights: List[int] : List of building heights :return: int : Minimum number of removals >>> min_removals_to_non_decreasing([1, 2, 3, 4, 5]) == 0 >>> min_removals_to_non_decreasing([3, 3, 3, 3]) == 0 >>> min_removals_to_non_decreasing([10]) == 0 >>> min_removals_to_non_decreasing([5, 1, 2, 3, 4]) == 1 >>> min_removals_to_non_decreasing([3, 1, 2, 1, 4, 3]) == 3 >>> min_removals_to_non_decreasing([]) == 0","solution":"def min_removals_to_non_decreasing(heights): Returns the minimum number of buildings that need to be removed to achieve a non-decreasing sequence. :param heights: List[int] : List of building heights :return: int : Minimum number of removals if not heights: return 0 n = len(heights) # Find the longest increasing subsequence (LIS) lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The minimum number of removals would be total buildings - length of LIS. return n - max(lis)"},{"question":"def maxWater(heights: List[int]) -> int: Returns the maximum amount of water a container can store. >>> maxWater([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 >>> maxWater([1, 1, 1, 1]) == 3 >>> maxWater([2, 2, 2, 2]) == 6 >>> maxWater([1, 2, 3, 4, 5]) == 6 >>> maxWater([5, 4, 3, 2, 1]) == 6 >>> maxWater([1]) == 0 >>> maxWater([5]) == 0 >>> maxWater([1, 2]) == 1 >>> maxWater([5, 1]) == 1 >>> maxWater([1, 5]) == 1 >>> maxWater([1, 3, 2, 5, 25, 24, 5]) == 24 pass","solution":"def maxWater(heights): Returns the maximum amount of water a container can store. max_water = 0 left, right = 0, len(heights) - 1 while left < right: # Calculate the area h = min(heights[left], heights[right]) w = right - left max_water = max(max_water, h * w) # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def sum_between_kth_elements(arr, k1, k2): Returns the sum of all elements between the k1-th smallest element and the k2-th smallest element (inclusive) in the array. Parameters: arr (List[int]): The array of integers. k1 (int): The 1-based index of the first k-th element. k2 (int): The 1-based index of the second k-th element. Returns: int: The sum of elements between k1-th smallest element and k2-th smallest element (inclusive). >>> sum_between_kth_elements([1, 2, 3, 4, 5], 2, 4) 9 >>> sum_between_kth_elements([3, 1, 5, 2, 4], 2, 4) 9 >>> sum_between_kth_elements([10, 20, 30, 40, 50], 4, 2) 90 >>> sum_between_kth_elements([1, 2, 3, 4, 5, 6], 1, 6) 21 >>> sum_between_kth_elements([5], 1, 1) 5 >>> sum_between_kth_elements([], 1, 2) 0 >>> sum_between_kth_elements([-10, -20, -30, -40, -50], 2, 4) -90 pass","solution":"def sum_between_kth_elements(arr, k1, k2): Returns the sum of all elements between the k1-th smallest element and the k2-th smallest element (inclusive) in the array. Parameters: arr (List[int]): The array of integers. k1 (int): The 1-based index of the first k-th element. k2 (int): The 1-based index of the second k-th element. Returns: int: The sum of elements between k1-th smallest element and k2-th smallest element (inclusive). # Ensure k1 is less than or equal to k2 if k1 > k2: k1, k2 = k2, k1 # Sort the array to determine the k-th smallest elements sorted_arr = sorted(arr) # Sum the elements between the k1-th and k2-th smallest (inclusive) sum_elements = sum(sorted_arr[k1-1:k2]) return sum_elements"},{"question":"from typing import List def min_cost_to_avoid_adjacent(s: str, costs: List[int]) -> int: Returns the minimum total cost of forming a string such that no two adjacent characters are the same. If it is not possible, returns -1. Args: s (str): The input string. costs (List[int]): The costs of inserting each character. Returns: int: The minimum cost to form the desired string, or -1 if it's not possible. Examples: >>> min_cost_to_avoid_adjacent(\\"aa\\", [3, 2]) == -1 True >>> min_cost_to_avoid_adjacent(\\"a\\", [5]) == 5 True >>> min_cost_to_avoid_adjacent(\\"ab\\", [3, 1]) == 4 True >>> min_cost_to_avoid_adjacent(\\"aab\\", [1, 2, 1]) == 4 True >>> min_cost_to_avoid_adjacent(\\"aabb\\", [3, 2, 1, 2]) == 8 True >>> min_cost_to_avoid_adjacent(\\"aabbcc\\", [1, 3, 2, 4, 5, 6]) == 21 True","solution":"from heapq import * from collections import Counter def min_cost_to_avoid_adjacent(l: str, costs: list) -> int: Returns the minimum total cost of forming a string such that no two adjacent characters are the same. If it's not possible, returns -1. # Edge case: empty string if not l: return 0 n = len(l) if n == 1: return costs[0] # Build frequency map freq_map = Counter(l) # If the highest frequency of any character is more than half the length of the list plus 1, return -1 max_freq = max(freq_map.values()) if max_freq > (n + 1) // 2: return -1 # Create a max-heap with character and its frequency max_heap = [(-freq, char) for char, freq in freq_map.items()] heapify(max_heap) total_cost = 0 prev_char, prev_freq = None, 0 i = 0 while max_heap or prev_freq: if max_heap: freq, char = heappop(max_heap) total_cost += costs[i] i += 1 freq = -freq if prev_freq: heappush(max_heap, (-prev_freq, prev_char)) freq -= 1 prev_char, prev_freq = char, freq else: if prev_freq: return -1 return total_cost"},{"question":"from typing import List from math import gcd from functools import reduce def minimum_final_element(nums: List[int]) -> int: Returns the minimum possible value of the final element after any number of operations of replacing two adjacent elements in nums with their GCD. >>> minimum_final_element([5]) == 5 >>> minimum_final_element([4, 4, 4, 4]) == 4 >>> minimum_final_element([6, 9]) == 3 >>> minimum_final_element([12, 15, 18]) == 3 >>> minimum_final_element([3, 5, 7, 11]) == 1 >>> minimum_final_element([2, 3, 4, 9, 27]) == 1","solution":"from math import gcd from functools import reduce def minimum_final_element(nums): Returns the minimum possible value of the final element after any number of operations of replacing two adjacent elements in nums with their GCD. return reduce(gcd, nums)"},{"question":"from typing import List, Tuple class TwoSumPairs: Class to find all unique pairs in an array that sum up to a given target. Methods ------- __init__(self, nums: List[int], target: int): Initializes the object with an integer array and the target sum. findPairs(self) -> List[Tuple[int, int]]: Returns a list of all unique pairs [a, b] such that a + b = target. Examples -------- >>> tsp = TwoSumPairs([1, 2, 3, 4], 5) >>> tsp.findPairs() [(1, 4), (2, 3)] >>> tsp = TwoSumPairs([1, 1, 2, 2, 3, 3], 4) >>> tsp.findPairs() [(1, 3), (2, 2)] def __init__(self, nums: List[int], target: int): pass def findPairs(self) -> List[Tuple[int, int]]: pass","solution":"class TwoSumPairs: def __init__(self, nums, target): self.nums = nums self.target = target def findPairs(self): seen = set() pairs = set() for num in self.nums: complement = self.target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(list(pairs))"},{"question":"from typing import List def find_subarray_with_target_sum(nums: List[int], target: int) -> List[int]: Find a contiguous subarray from nums whose sum is equal to target. If there are multiple such subarrays, return the one with the smallest starting index. If no such subarray exists, return an empty array. >>> find_subarray_with_target_sum([1, 2, 3, 4, 5], 9) == [2, 3, 4] >>> find_subarray_with_target_sum([1, 2, 3, 4, 5], 6) == [1, 2, 3] >>> find_subarray_with_target_sum([1, 2, 3, 4, 5], 12) == [3, 4, 5] >>> find_subarray_with_target_sum([1, 2, -1, 2, 3], 4) == [1, 2, -1, 2] >>> find_subarray_with_target_sum([1, 2, 3], 7) == [] >>> find_subarray_with_target_sum([1, 2, 3], 2) == [2] >>> find_subarray_with_target_sum([1, 2, 3], 6) == [1, 2, 3]","solution":"def find_subarray_with_target_sum(nums, target): Returns the first contiguous subarray summing to the target or an empty array if not found. current_sum = 0 prefix_sum_index = {0: -1} for i, num in enumerate(nums): current_sum += num if current_sum - target in prefix_sum_index: start_index = prefix_sum_index[current_sum - target] + 1 return nums[start_index:i+1] prefix_sum_index[current_sum] = i return []"},{"question":"def exists_pair_with_sum(arr: list[int], target: int) -> bool: Determines if there exist two distinct elements in the array such that their sum is equal to target. Parameters: arr (list of int): The array of integers. target (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. >>> exists_pair_with_sum([2, 7, 11, 15], 9) True >>> exists_pair_with_sum([-1, -2, -3, -4, 8, 7], 5) True >>> exists_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> exists_pair_with_sum([], 5) False >>> exists_pair_with_sum([5], 5) False >>> exists_pair_with_sum([1000000, 500000, -1500000], -1000000) True","solution":"def exists_pair_with_sum(arr, target): Determines if there exist two distinct elements in the array such that their sum is equal to target. Parameters: arr (list of int): The array of integers. target (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def canBeSortedByReversingOneSubarray(nums: List[int]) -> bool: Determine if the array can be sorted in non-decreasing order by performing exactly one reverse operation on a subarray. >>> canBeSortedByReversingOneSubarray([]) == True >>> canBeSortedByReversingOneSubarray([1]) == True >>> canBeSortedByReversingOneSubarray([1, 2, 3, 4, 5]) == True >>> canBeSortedByReversingOneSubarray([2, 2, 2]) == True >>> canBeSortedByReversingOneSubarray([5, 4, 3, 2, 1]) == True >>> canBeSortedByReversingOneSubarray([1, 3, 2, 4, 5]) == True >>> canBeSortedByReversingOneSubarray([1, 2, 4, 3, 5]) == True >>> canBeSortedByReversingOneSubarray([1, 5, 4, 3, 2, 6]) == True >>> canBeSortedByReversingOneSubarray([4, 3, 1, 2, 5]) == False >>> canBeSortedByReversingOneSubarray([1, 3, 5, 4, 2]) == False >>> canBeSortedByReversingOneSubarray([2, 4, 3, 2, 1]) == False","solution":"def canBeSortedByReversingOneSubarray(nums): n = len(nums) if n <= 1: return True sorted_nums = sorted(nums) # Find the first and last place where original array differs from sorted array i = 0 while i < n and nums[i] == sorted_nums[i]: i += 1 j = n - 1 while j >= 0 and nums[j] == sorted_nums[j]: j -= 1 if i >= j: # The array is already sorted. return True # Reverse the subarray nums[i:j+1] subarray = nums[i:j+1] subarray.reverse() return nums[:i] + subarray + nums[j+1:] == sorted_nums"},{"question":"def kth_smallest(nums: List[int], queries: List[List[int]]) -> List[int]: Given a 0-indexed integer array nums of length n, find the kth smallest element for multiple queries. Each query is represented as an array queries[i] = [li, ri, ki], where li and ri denote the subarray nums[li...ri] (inclusive) and ki denotes the kth smallest element in this subarray. Return an array answer where answer.length == queries.length and answer[i] is the answer to the ith query. >>> nums = [1, 5, 2, 6, 3, 7, 4] >>> queries = [[0, 2, 2], [0, 5, 4], [2, 4, 1]] >>> kth_smallest(nums, queries) [2, 5, 2] >>> nums = [4, 8, 6, 1, 3] >>> queries = [[2, 2, 1]] >>> kth_smallest(nums, queries) [6] >>> nums = [7, 2, 5] >>> queries = [[0, 2, 2]] >>> kth_smallest(nums, queries) [5] >>> nums = [3, 1, 4, 1, 5, 9, 2] >>> queries = [[0, 6, 4], [1, 4, 3], [2, 5, 2]] >>> kth_smallest(nums, queries) [3, 4, 4]","solution":"def kth_smallest(nums, queries): Find the kth smallest element in the specified subarrays for multiple queries. :param nums: List[int] - A list of integers. :param queries: List[List[int]] - A list of queries where each query is a list [li, ri, ki]. :return: List[int] - A list of answers for each query. results = [] for li, ri, ki in queries: subarray = nums[li:ri+1] subarray.sort() results.append(subarray[ki-1]) return results"},{"question":"def countDistinctIslands(grid: List[List[int]]) -> int: Count the number of distinct islands in the given grid. An island is a maximal vertically or horizontally connected group of 1's, and two islands are distinct if one cannot be fully represented by shifting the other. >>> countDistinctIslands([ [1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 1], [0, 1, 0, 0, 0] ]) 2 >>> countDistinctIslands([ [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ]) 0 >>> countDistinctIslands([ [1, 1], [1, 1] ]) 1 >>> countDistinctIslands([ [1, 0, 0, 1], [1, 0, 0, 1], [0, 0, 0, 0], [1, 1, 0, 1], [1, 1, 0, 1] ]) 2 >>> countDistinctIslands([ [1, 0, 0, 1], [0, 1, 1, 0] ]) 2","solution":"def countDistinctIslands(grid): def dfs(x, y, origin_x, origin_y): Perform DFS to explore the island and record the relative position. if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0): return grid[x][y] = 0 # Mark as visited shape.append((x - origin_x, y - origin_y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, origin_x, origin_y) distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, i, j) distinct_islands.add(tuple(shape)) return len(distinct_islands)"},{"question":"def length_of_longest_good_substring(s: str) -> int: Finds the length of the longest 'good' substring in a given string \`s\`. A substring is called 'good' if all its characters are distinct. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest 'good' substring. Examples: >>> length_of_longest_good_substring(\\"abcabcbb\\") 3 >>> length_of_longest_good_substring(\\"bbbbb\\") 1 >>> length_of_longest_good_substring(\\"pwwkew\\") 3 >>> length_of_longest_good_substring(\\"aab\\") 2 >>> length_of_longest_good_substring(\\"dvdf\\") 3 >>> length_of_longest_good_substring(\\"\\") 0 >>> length_of_longest_good_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> length_of_longest_good_substring(\\"abcabcdeabc\\") 5 >>> length_of_longest_good_substring(\\"aaabbbccc\\") 2 >>> length_of_longest_good_substring(\\"a\\") 1","solution":"def length_of_longest_good_substring(s: str) -> int: Finds the length of the longest 'good' substring in a given string \`s\`. A substring is called 'good' if all its characters are distinct. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest 'good' substring. n = len(s) max_length = 0 char_index_map = {} start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def smallest_subarray_with_k_distinct(arr: List[int], k: int) -> int: Find the length of the smallest subarray that contains at least \`k\` distinct integers. If no such subarray exists, return -1. >>> smallest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 2 >>> smallest_subarray_with_k_distinct([1, 2, 1, 3, 4], 3) 3 >>> smallest_subarray_with_k_distinct([1, 2, 1, 2, 3], 3) 3 >>> smallest_subarray_with_k_distinct([1, 1, 1, 1, 1], 1) 1 >>> smallest_subarray_with_k_distinct([1, 2, 3, 4, 5], 5) 5 >>> smallest_subarray_with_k_distinct([1, 2, 3, 4, 5], 6) -1","solution":"def smallest_subarray_with_k_distinct(arr, k): from collections import defaultdict n = len(arr) if k > n: return -1 left = 0 min_len = n + 1 freq_map = defaultdict(int) distinct_count = 0 for right in range(n): # Expand the window by adding arr[right] if freq_map[arr[right]] == 0: distinct_count += 1 freq_map[arr[right]] += 1 # Shrink the window from the left until it contains less than k distinct integers while distinct_count >= k: min_len = min(min_len, right - left + 1) freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: distinct_count -= 1 left += 1 return min_len if min_len <= n else -1"},{"question":"def longest_equal_positive_negative(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with an equal number of positive and negative numbers. >>> longest_equal_positive_negative([1, 2, 3, 4]) == 0 >>> longest_equal_positive_negative([-1, -2, -3, -4]) == 0 >>> longest_equal_positive_negative([1, -1, 2, -2, 3, -3]) == 6 >>> longest_equal_positive_negative([1, 2, -1, -1, 2, -2, 1, -1]) == 8 >>> longest_equal_positive_negative([1, 2, -1, -2, 3, -3, 4]) == 6 >>> longest_equal_positive_negative([1]) == 0 >>> longest_equal_positive_negative([-1]) == 0 >>> longest_equal_positive_negative([1, 1, -1, -1, 1]) == 4","solution":"def longest_equal_positive_negative(nums): Returns the length of the longest contiguous subarray with an equal number of positive and negative numbers. n = len(nums) max_len = 0 sum_map = {} sum_val = 0 for i in range(n): # Convert the array such that -1 is for negative numbers and +1 for positive numbers if nums[i] > 0: sum_val += 1 else: sum_val -= 1 if sum_val == 0: max_len = i + 1 if sum_val in sum_map: max_len = max(max_len, i - sum_map[sum_val]) else: sum_map[sum_val] = i return max_len"},{"question":"def longest_palindromic_substring_length(s: str, queries: List[List[int]]) -> List[int]: Given a string s, and an array queries where each query is a pair of indices [ai, bi], return a list of the lengths of the longest palindromic substrings for each of the specified substrings s[ai:bi+1]. >>> longest_palindromic_substring_length(\\"a\\", [[0, 0]]) == [1] >>> longest_palindromic_substring_length(\\"abc\\", [[0, 0], [1, 1], [2, 2]]) == [1, 1, 1] >>> longest_palindromic_substring_length(\\"aa\\", [[0, 1]]) == [2] >>> longest_palindromic_substring_length(\\"ab\\", [[0, 1]]) == [1] >>> longest_palindromic_substring_length(\\"racecar\\", [[0, 6]]) == [7] >>> longest_palindromic_substring_length(\\"abba\\", [[0, 3]]) == [4] >>> longest_palindromic_substring_length(\\"forgeeksskeegfor\\", [[2, 15], [1, 4], [5, 10]]) == [10, 1, 6] >>> longest_palindromic_substring_length(\\"\\", [[0, 0]]) == [0]","solution":"def longest_palindromic_substring_length(s, queries): Returns the lengths of the longest palindromic substrings for specified substrings. :param s: A string where we need to find palindromic substrings. :param queries: A list of pairs (ai, bi) specifying the substring s[ai:bi+1] :return: A list of lengths of longest palindromic substrings for each query. def longest_palindrome_length(subs): n = len(subs) if n == 0: return 0 # Table to store lengths of longest palindromes dp = [[0] * n for _ in range(n)] max_length = 1 # Each individual character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Check for sub-strings of length 2 for i in range(n-1): if subs[i] == subs[i+1]: dp[i][i+1] = 1 max_length = 2 # Check for lengths greater than 2 for k in range(3, n + 1): # k is the length of substring for i in range(n - k + 1): j = i + k - 1 if subs[i] == subs[j] and dp[i + 1][j - 1] > 0: dp[i][j] = 1 max_length = k return max_length result = [] for ai, bi in queries: substring = s[ai:bi+1] result.append(longest_palindrome_length(substring)) return result"},{"question":"def largest_even_number(s: str) -> str: Write a function that takes a string \`s\` consisting of digits and returns a string representing the largest even number that can be formed from the digits of \`s\`. If no even number can be formed, return an empty string. >>> largest_even_number(\\"1234\\") \\"4312\\" >>> largest_even_number(\\"32659\\") \\"96532\\" >>> largest_even_number(\\"135\\") \\"\\" >>> largest_even_number(\\"111111\\") \\"\\" >>> largest_even_number(\\"222\\") \\"222\\" >>> largest_even_number(\\"2\\") \\"2\\" >>> largest_even_number(\\"1\\") \\"\\" >>> largest_even_number(\\"\\") \\"\\"","solution":"def largest_even_number(s): Returns the largest even number that can be formed from the digits of the input string \`s\`. If no even number can be formed, returns an empty string. # Separate the digits of s digits = list(s) # Sort the digits in descending order to form the largest possible number digits.sort(reverse=True) # Find an even digit to place at the end for i in range(len(digits)-1, -1, -1): if int(digits[i]) % 2 == 0: # Place the found even digit at the end and break the loop digits.append(digits.pop(i)) return ''.join(digits) # If no even digit is found, return empty string return \\"\\""},{"question":"def longest_palindromic_substring_length(s: str) -> int: Given a string \`s\`, return the length of the longest contiguous substring of \`s\` that can be rearranged to form a palindrome. >>> longest_palindromic_substring_length(\\"abccccdd\\") 7 >>> longest_palindromic_substring_length(\\"\\") 0 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"abc\\") 1 >>> longest_palindromic_substring_length(\\"aaaaaa\\") 6 >>> longest_palindromic_substring_length(\\"abcdefg\\") 1 >>> longest_palindromic_substring_length(\\"racecar\\") 7 >>> longest_palindromic_substring_length(\\"abacabad\\") 7","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest contiguous substring of s that can be rearranged to form a palindrome. def can_form_palindrome(sub): counts = {} for char in sub: counts[char] = counts.get(char, 0) + 1 odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 n = len(s) max_length = 0 for start in range(n): for end in range(start, n): substring = s[start:end + 1] if can_form_palindrome(substring): max_length = max(max_length, end - start + 1) return max_length"},{"question":"def trap(height): Calculate the total amount of water that can be trapped between the buildings. :param height: List[int] - List of heights of the buildings. :return: int - Total trapped water. pass # Example test cases def test_no_buildings(): assert trap([]) == 0 def test_no_trapped_water(): assert trap([0, 1, 2, 3, 4, 5]) == 0 assert trap([5, 4, 3, 2, 1, 0]) == 0 def test_simple_case(): assert trap([0, 2, 0, 2]) == 2 def test_complex_case(): assert trap([3, 0, 1, 3, 0, 5]) == 8 def test_multiple_peaks_and_valleys(): assert trap([4, 2, 0, 3, 2, 5]) == 9 def test_uniform_height(): assert trap([2, 2, 2, 2, 2]) == 0 def test_one_building(): assert trap([4]) == 0 def test_two_buildings(): assert trap([2, 4]) == 0","solution":"def trap(height): Calculate the total amount of water that can be trapped between the buildings. :param height: List[int] - List of heights of the buildings. :return: int - Total trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"import heapq from typing import List def lastStoneWeight(stones: List[int]) -> int: Given an integer array \`stones\`, return the smallest possible weight of the remaining stone. If there are no stones left, return \`0\`. >>> lastStoneWeight([5]) 5 >>> lastStoneWeight([4, 4]) 0 >>> lastStoneWeight([2, 7, 4, 1, 8, 1]) 1 >>> lastStoneWeight([1, 1, 1, 1]) 0 >>> lastStoneWeight([10, 20, 30, 40, 50, 60, 70, 80, 90]) 10 >>> lastStoneWeight([3, 8]) 5","solution":"import heapq def lastStoneWeight(stones): Returns the smallest possible weight of the remaining stone after all possible operations. # Convert all stones to a max-heap by inverting their signs (Python has a min-heap by default) stones = [-stone for stone in stones] heapq.heapify(stones) while len(stones) > 1: y = -heapq.heappop(stones) x = -heapq.heappop(stones) if x != y: heapq.heappush(stones, -(y - x)) return -stones[0] if stones else 0"},{"question":"def max_contiguous_sum(strengths: List[int]) -> int: Returns the maximum sum of strengths for any contiguous subarray. >>> max_contiguous_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 >>> max_contiguous_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_contiguous_sum([5]) 5 >>> max_contiguous_sum([-3]) -3 >>> max_contiguous_sum([1, 2, 3, 4, 5]) 15 >>> max_contiguous_sum([-1, -2, -3, -4, -5]) -1 >>> max_contiguous_sum([3, 2, -1, -2, 1]) 5 >>> max_contiguous_sum([-1, -2, -3, 4, 2]) 6","solution":"def max_contiguous_sum(strengths): Returns the maximum sum of strengths for any contiguous subarray. max_sum = current_sum = strengths[0] for strength in strengths[1:]: current_sum = max(strength, current_sum + strength) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def cyclic_rotation(nums: List[int], k: int) -> List[int]: Perform k cyclic rotations on the list nums and return the resulting list. >>> cyclic_rotation([0, 1, 2, 3, 4], 0) [0, 1, 2, 3, 4] >>> cyclic_rotation([0, 1, 2, 3, 4], 1) [4, 0, 1, 2, 3] >>> cyclic_rotation([0, 1, 2, 3, 4], 3) [2, 3, 4, 0, 1] >>> cyclic_rotation([0, 1, 2, 3, 4], 10) [0, 1, 2, 3, 4] >>> cyclic_rotation([5, 3, 7, 1], 2) [7, 1, 5, 3] >>> cyclic_rotation([9, 6, 8, 4, 2], 4) [6, 8, 4, 2, 9]","solution":"def cyclic_rotation(nums, k): Perform k cyclic rotations on the list nums and return the resulting list. n = len(nums) k = k % n # To handle the case where k is larger than n # Perform rotation by slicing return nums[-k:] + nums[:-k]"},{"question":"from typing import List def maxRectangleArea(heights: List[int]) -> int: Calculate the maximum rectangular area in a histogram represented by heights. >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> maxRectangleArea([2]) == 2 >>> maxRectangleArea([1, 2, 3, 4, 5]) == 9 >>> maxRectangleArea([5, 4, 3, 2, 1]) == 9 >>> maxRectangleArea([2, 4, 2, 1, 10, 6, 10, 2]) == 18 >>> maxRectangleArea([3, 3, 3, 3, 3]) == 15 >>> maxRectangleArea([]) == 0","solution":"from typing import List def maxRectangleArea(heights: List[int]) -> int: Calculate the maximum rectangular area in a histogram represented by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def max_ones_after_flip(matrix): Determines the maximum number of 1's that can be obtained in any row or column after making at most one flip in an n x n binary matrix. Parameters: - matrix: List[List[int]] - A n x n binary matrix. Returns: - int: The maximum number of 1's in any row or column after at most one flip. from typing import List # Unit tests def test_max_ones_after_flip_empty_matrix(): assert max_ones_after_flip([]) == 0 def test_max_ones_after_flip_no_flip_needed(): matrix = [ [1, 1], [1, 1] ] assert max_ones_after_flip(matrix) == 2 def test_max_ones_after_flip_row_flip(): matrix = [ [0, 0], [1, 1] ] assert max_ones_after_flip(matrix) == 2 def test_max_ones_after_flip_column_flip(): matrix = [ [1, 0], [1, 0] ] assert max_ones_after_flip(matrix) == 2 def test_max_ones_after_flip_complex_case(): matrix = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] assert max_ones_after_flip(matrix) == 3 def test_max_ones_after_flip_all_zeros(): matrix = [ [0, 0], [0, 0] ] assert max_ones_after_flip(matrix) == 2 def test_max_ones_after_flip_all_ones(): matrix = [ [1, 1], [1, 1] ] assert max_ones_after_flip(matrix) == 2","solution":"def max_ones_after_flip(matrix): Determines the maximum number of 1's that can be obtained in any row or column after making at most one flip in an n x n binary matrix. Parameters: - matrix: List[List[int]] - A n x n binary matrix. Returns: - int: The maximum number of 1's in any row or column after at most one flip. n = len(matrix) max_ones = 0 # Count the maximum number of 1's in any row without any flip for row in matrix: max_ones = max(max_ones, sum(row)) # Count the maximum number of 1's in any column without any flip for col in range(n): col_sum = sum(matrix[row][col] for row in range(n)) max_ones = max(max_ones, col_sum) # Check each possible row flip for row in range(n): new_matrix = [row[:] for row in matrix] for col in range(n): new_matrix[row][col] = 1 - new_matrix[row][col] # After flipping this row, calculate the max 1's in any row or column for new_row in new_matrix: max_ones = max(max_ones, sum(new_row)) for col in range(n): col_sum = sum(new_matrix[new_row][col] for new_row in range(n)) max_ones = max(max_ones, col_sum) # Check each possible column flip for col in range(n): new_matrix = [row[:] for row in matrix] for row in range(n): new_matrix[row][col] = 1 - new_matrix[row][col] # After flipping this column, calculate the max 1's in any row or column for new_row in new_matrix: max_ones = max(max_ones, sum(new_row)) for new_col in range(n): col_sum = sum(new_matrix[new_row][new_col] for new_row in range(n)) max_ones = max(max_ones, col_sum) return max_ones"},{"question":"def leftmost_column_with_one(mat: List[List[int]]) -> int: Finds the leftmost column with at least one '1' in a sorted binary matrix. :param mat: List of lists representing the binary matrix. :return: Index of the leftmost column with at least one '1'. If no such column exists, return -1. >>> leftmost_column_with_one([[0, 0, 0, 1], [0, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 1]]) == 1 >>> leftmost_column_with_one([[0, 0], [0, 0]]) == -1 >>> leftmost_column_with_one([[0, 0, 0], [0, 0, 1], [0, 1, 1]]) == 1 >>> leftmost_column_with_one([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 0 >>> leftmost_column_with_one([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == -1 >>> leftmost_column_with_one([]) == -1 >>> leftmost_column_with_one([[0, 0, 0, 0, 1], [0, 0, 1, 1, 1], [1, 1, 1, 1, 1]]) == 0","solution":"def leftmost_column_with_one(mat): Finds the leftmost column with at least one '1' in a sorted binary matrix. :param mat: List of lists representing the binary matrix. :return: Index of the leftmost column with at least one '1'. If no such column exists, return -1. if not mat or not mat[0]: return -1 rows, cols = len(mat), len(mat[0]) current_row, current_col = 0, cols - 1 result = -1 while current_row < rows and current_col >= 0: if mat[current_row][current_col] == 1: result = current_col current_col -= 1 else: current_row += 1 return result"},{"question":"from typing import List, Tuple from collections import Counter def top_k_users(log: List[Tuple[int, str]], k: int) -> List[int]: Identify the top k users with the highest number of activities recorded in the log. If there is a tie, return all users who have the same number of activities as the k-th user. :param log: List of tuples containing user id and timestamp :param k: Number of top users to retrieve :return: List of user ids with the highest number of activities >>> top_k_users([(1, '2023-10-01 10:00:00'), (2, '2023-10-01 10:05:00'), (1, '2023-10-01 10:10:00'), (3, '2023-10-01 10:20:00'), (1, '2023-10-01 10:25:00'), (2, '2023-10-01 10:30:00')], 2) [1, 2] >>> top_k_users([(1, '2023-10-01 10:00:00'), (2, '2023-10-01 10:05:00'), (1, '2023-10-01 10:10:00'), (3, '2023-10-01 10:20:00'), (1, '2023-10-01 10:25:00'), (2, '2023-10-01 10:30:00'), (3, '2023-10-01 10:35:00')], 2) [1, 2, 3] >>> top_k_users([(1, '2023-10-01 10:00:00'), (1, '2023-10-01 10:10:00'), (1, '2023-10-01 10:20:00')], 1) [1] >>> top_k_users([(1, '2023-10-01 10:00:00'), (2, '2023-10-01 10:10:00'), (3, '2023-10-01 10:20:00')], 2) [1, 2, 3] >>> top_k_users([(1, '2023-10-01 10:00:00'), (2, '2023-10-01 10:10:00'), (3, '2023-10-01 10:20:00'), (4, '2023-10-01 10:30:00'), (5, '2023-10-01 10:40:00')], 3) [1, 2, 3, 4, 5]","solution":"from collections import Counter def top_k_users(log, k): Identify the top k users with the highest number of activities recorded in the log. If there is a tie, return all users who have the same number of activities as the k-th user. :param log: List of tuples containing user id and timestamp :param k: Number of top users to retrieve :return: List of user ids with the highest number of activities # Count activities for each user using Counter user_activity_count = Counter(user_id for user_id, _ in log) # Get the number of activities for each user, sorted in descending order sorted_counts = user_activity_count.most_common() # Collect users from sorted counts that are within the top k users or tie with the k-th user result = [] current_rank = 0 last_count = None for user_id, count in sorted_counts: if len(result) < k or count == last_count: result.append(user_id) current_rank += 1 last_count = count else: break return result"},{"question":"def is_rotation(s1: str, s2: str) -> bool: Given two strings \`s1\` and \`s2\`, determine if \`s2\` is a rotation of \`s1\` using only one call to the standard library function that checks for substrings. >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotation(\\"waterbottle\\", \\"erbottlewa\\") False >>> is_rotation(\\"waterbottle\\", \\"bottlewater\\") True >>> is_rotation(\\"\\", \\"\\") True >>> is_rotation(\\"abcde\\", \\"abced\\") False >>> is_rotation(\\"waterbottle\\", \\"waterbottle\\") True >>> is_rotation(\\"a\\", \\"a\\") True >>> is_rotation(\\"a\\", \\"b\\") False","solution":"def is_rotation(s1, s2): Returns True if s2 is a rotation of s1, otherwise False. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"def single_number(nums: List[int]) -> int: Given an array of integers where every integer appears twice except for one, find the single integer that does not have a pair. Args: nums (list of int): The input array of integers. Returns: int: The single integer that does not have a pair. >>> single_number([2, 2, 1]) == 1 >>> single_number([4, 1, 2, 1, 2]) == 4 >>> single_number([1, 1, 2, 2, 3, 3, 4, 5, 5]) == 4 >>> single_number([99]) == 99 >>> single_number([-1, -1, -2, -2, -3]) == -3 >>> single_number([0, 1, 0, 1, 99]) == 99","solution":"def single_number(nums): Given an array of integers where every integer appears twice except for one, find the single integer that does not have a pair. Args: nums (list of int): The input array of integers. Returns: int: The single integer that does not have a pair. result = 0 for num in nums: result ^= num return result"},{"question":"def length_of_LIS(nums: List[int]) -> int: Return the length of the longest strictly increasing subsequence in the array nums. :param nums: List[int] :return: int >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 >>> length_of_LIS([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> length_of_LIS([]) 0","solution":"def length_of_LIS(nums): Returns the length of the longest strictly increasing subsequence. :param nums: List[int] :return: int if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def min_difference(weights: List[int]) -> int: Distribute objects into two groups such that the absolute difference in the sum of the weights of the two groups is minimized. >>> min_difference([1, 2, 3, 4]) 0 >>> min_difference([1, 1, 1, 1, 1, 1]) 0 >>> min_difference([10, 10, 10, 10]) 0 >>> min_difference([5]) 5 >>> min_difference([1, 5, 11, 5]) 0 >>> min_difference([3, 1, 4, 2, 2]) 0 >>> min_difference([10, 20, 30, 40, 50]) 10","solution":"def min_difference(weights): n = len(weights) total_sum = sum(weights) half_sum = total_sum // 2 # Initialize a DP array with all False values dp = [False] * (half_sum + 1) dp[0] = True for weight in weights: for j in range(half_sum, weight - 1, -1): if dp[j - weight]: dp[j] = True for i in range(half_sum, -1, -1): if dp[i]: sum1 = i break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"from collections import defaultdict from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups the input list of strings into anagrams. Args: strs: List[str] - list of strings to be grouped. Returns: List[List[str]] - list of groups of anagrams. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([\\"\\"]) [['']] >>> group_anagrams([\\"a\\", \\"b\\", \\"c\\"]) [['a'], ['b'], ['c']]","solution":"from collections import defaultdict def group_anagrams(strs): Groups the input list of strings into anagrams. Args: strs: List[str] - list of strings to be grouped. Returns: List[List[str]] - list of groups of anagrams. anagram_dict = defaultdict(list) for s in strs: sorted_str = ''.join(sorted(s)) anagram_dict[sorted_str].append(s) return list(anagram_dict.values())"},{"question":"def max_consecutive_non_decreasing_days(rainfall: List[int]) -> int: Returns the maximum number of consecutive days with non-decreasing rainfall amounts. >>> max_consecutive_non_decreasing_days([]) == 0 >>> max_consecutive_non_decreasing_days([10]) == 1 >>> max_consecutive_non_decreasing_days([1, 2, 3, 4, 5]) == 5 >>> max_consecutive_non_decreasing_days([5, 4, 3, 2, 1]) == 1 >>> max_consecutive_non_decreasing_days([5, 6, 3, 3, 4, 5, 1]) == 4 # [3, 3, 4, 5] >>> max_consecutive_non_decreasing_days([3, 3, 3, 3]) == 4 >>> max_consecutive_non_decreasing_days([2, 3, 2, 3, 2, 3]) == 2 >>> max_consecutive_non_decreasing_days([7, 7, 7, 7, 7]) == 5","solution":"def max_consecutive_non_decreasing_days(rainfall): Returns the maximum number of consecutive days with non-decreasing rainfall amounts. :param rainfall: List[int] - list of daily rainfall amounts. :return: int - maximum number of consecutive non-decreasing days. if not rainfall: return 0 max_length = 1 current_length = 1 for i in range(1, len(rainfall)): if rainfall[i] >= rainfall[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def sort_strings(lst: List[str]) -> List[str]: Sorts the input list of strings such that strings with more than 5 characters are at the beginning in descending order of their lengths, followed by strings with 5 or fewer characters also in descending order of their lengths. The order of strings with the same length is preserved as they appear in the original list. Strings are compared ignoring case, but the original case of the strings is preserved in the result. >>> sort_strings([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"grape\\", \\"watermelon\\", \\"berry\\"]) \\"watermelon\\", \\"banana\\", \\"apple\\", \\"grape\\", \\"berry\\", \\"kiwi\\" >>> sort_strings([\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\"]) \\"three\\", \\"four\\", \\"five\\", \\"one\\", \\"two\\", \\"six\\" >>> sort_strings([\\"Apple\\", \\"Banana\\", \\"kiwi\\", \\"Grape\\", \\"WaTermelon\\", \\"BERRY\\"]) \\"WaTermelon\\", \\"Banana\\", \\"Apple\\", \\"Grape\\", \\"BERRY\\", \\"kiwi\\" >>> sort_strings([\\"hi\\", \\"bye\\", \\"yes\\", \\"no\\", \\"it\\"]) \\"bye\\", \\"yes\\", \\"hi\\", \\"no\\", \\"it\\" >>> sort_strings([\\"longword\\", \\"anotherlongword\\", \\"extendedword\\"]) \\"anotherlongword\\", \\"extendedword\\", \\"longword\\"","solution":"def sort_strings(lst): Sorts the input list of strings such that strings with more than 5 characters are at the beginning in descending order of their lengths, followed by strings with 5 or fewer characters also in descending order of their lengths. The order of strings with the same length is preserved as they appear in the original list. Strings are compared ignoring case, but the original case of the strings is preserved in the result. more_than_five = sorted( [s for s in lst if len(s) > 5], key=lambda x: -len(x) ) five_or_less = sorted( [s for s in lst if len(s) <= 5], key=lambda x: -len(x) ) return more_than_five + five_or_less"},{"question":"from typing import Optional from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def widthOfBinaryTree(root: Optional[TreeNode]) -> int: Given a binary tree, return the maximum width of the binary tree. The width of one level is defined as the length between the leftmost and rightmost non-null nodes (inclusive) in that level. If the answer is very large, return it modulo 1000000007. >>> widthOfBinaryTree(None) 0 >>> root = TreeNode(1) >>> widthOfBinaryTree(root) 1 >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> widthOfBinaryTree(root) 4 >>> root.left.right.left = TreeNode(6) >>> root.right.right.right = TreeNode(7) >>> widthOfBinaryTree(root) 8","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def widthOfBinaryTree(root): Returns the maximum width of the binary tree. The function uses level-order traversal with a queue and calculates the width at each level. if not root: return 0 max_width = 0 queue = deque([(root, 0)]) # (node, index) while queue: level_length = len(queue) _, first_index = queue[0] for i in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) _, last_index = queue[-1] if queue else (None, 0) max_width = max(max_width, last_index - first_index + 1) return max_width % 1000000007"},{"question":"def longest_char_substring(s: str) -> int: Given a string s containing only characters 'a' and 'b', swap any two characters at most once and return the length of the longest substring consisting of only one unique character that you can get. >>> longest_char_substring(\\"aaaa\\") == 4 >>> longest_char_substring(\\"bbbb\\") == 4 >>> longest_char_substring(\\"aab\\") == 3 >>> longest_char_substring(\\"abb\\") == 3 >>> longest_char_substring(\\"abab\\") == 3 >>> longest_char_substring(\\"baba\\") == 3 >>> longest_char_substring(\\"aabbbab\\") == 5 >>> longest_char_substring(\\"\\") == 0 >>> longest_char_substring(\\"a\\") == 1 >>> longest_char_substring(\\"b\\") == 1 >>> longest_char_substring(\\"ab\\") == 2 >>> longest_char_substring(\\"ba\\") == 2","solution":"def longest_char_substring(s): Given a string s containing only characters 'a' and 'b', swap any two characters at most once and return the length of the longest substring consisting of only one unique character that you can get. def max_len_char(c, other_char): max_length = 0 count_other_char = 0 left = 0 for right in range(len(s)): if s[right] == other_char: count_other_char += 1 while count_other_char > 1: if s[left] == other_char: count_other_char -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length return max(max_len_char('a', 'b'), max_len_char('b', 'a'))"},{"question":"def trap(height: List[int]) -> int: Compute the maximum amount of water that can be collected between buildings. >>> trap([]) == 0 >>> trap([1]) == 0 >>> trap([1, 2]) == 0 >>> trap([2, 1]) == 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([2, 2, 2, 2, 2, 2]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([5, 4, 3, 2, 1]) == 0 >>> trap([4, 2, 0, 3, 2, 5]) == 9 from typing import List","solution":"def trap(height): if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def maxSubarraySumCircular(nums: List[int]) -> int: Given an array of integers \`nums\` representing a contiguous subarray of a circular array, return the maximum possible sum of the non-empty subarray. A circular array means the end of the array connects to the beginning of the array. Formally, the next element of \`nums[nums.length - 1]\` is \`nums[0]\`, and the previous element of \`nums[0]\` is \`nums[nums.length - 1]\`. >>> maxSubarraySumCircular([1, 2, 3, 4, 5]) 15 >>> maxSubarraySumCircular([-1, -2, -3, -4, -5]) -1 >>> maxSubarraySumCircular([1, -2, 3, -2]) 3 >>> maxSubarraySumCircular([5, -3, 5]) 10 >>> maxSubarraySumCircular([3, -1, 2, -1]) 4 >>> maxSubarraySumCircular([3, -2, 2, -3]) 3 >>> maxSubarraySumCircular([8, -1, -3, 8]) 16","solution":"def maxSubarraySumCircular(nums): def kadane(gen): # Helper function to perform Kadane's algorithm # to find the maximum subarray sum for a given iterator \`gen\`. current_sum = max_sum = next(gen) for num in gen: current_sum = num + max(current_sum, 0) max_sum = max(max_sum, current_sum) return max_sum # Compute the maximum subarray sum using Kadane's algorithm max_kadane = kadane(iter(nums)) # Compute the sum of the array total_sum = sum(nums) # Compute the minimum subarray sum using modified Kadane's algorithm max_wraparound = total_sum + kadane(-num for num in nums) # Check if all numbers are negative if max_wraparound == 0: return max_kadane # The result is the maximum of the non-circular and circular sums return max(max_kadane, max_wraparound)"},{"question":"def count_demolishable_buildings(arr: List[int]) -> int: Returns the number of buildings that can be demolished. A building can be demolished if it is surrounded by buildings with greater heights on both sides. :param arr: List of positive integers representing the heights of buildings. :return: Number of demolishable buildings. from solution import count_demolishable_buildings def test_single_building(): assert count_demolishable_buildings([1]) == 0 def test_two_buildings(): assert count_demolishable_buildings([2, 1]) == 0 assert count_demolishable_buildings([1, 2]) == 0 def test_three_buildings(): assert count_demolishable_buildings([3, 2, 3]) == 1 assert count_demolishable_buildings([1, 2, 1]) == 0 assert count_demolishable_buildings([3, 3, 3]) == 0 def test_multiple_buildings(): assert count_demolishable_buildings([3, 1, 3, 1, 3]) == 2 assert count_demolishable_buildings([5, 4, 5, 4, 5, 4, 5]) == 3 assert count_demolishable_buildings([1, 2, 3, 4, 5]) == 0 assert count_demolishable_buildings([5, 4, 3, 2, 1]) == 0","solution":"def count_demolishable_buildings(arr): Returns the number of buildings that can be demolished. A building can be demolished if it is surrounded by buildings with greater heights on both sides. :param arr: List of positive integers representing the heights of buildings. :return: Number of demolishable buildings. demolishable_count = 0 for i in range(1, len(arr) - 1): if arr[i] < arr[i - 1] and arr[i] < arr[i + 1]: demolishable_count += 1 return demolishable_count"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates an arithmetic expression containing addition and subtraction, with possible parentheses. Args: expression (str): A string representing the arithmetic expression. Returns: int: The result of the evaluated arithmetic expression. >>> evaluate_expression(\\"1 + 1\\") 2 >>> evaluate_expression(\\"2 - 1 + 2\\") 3 >>> evaluate_expression(\\"(1 + (4 + 5 + 2) - 3) + (6 + 8)\\") 23 >>> evaluate_expression(\\"1 - (4 + (2 - 3)) + 3\\") 1 >>> evaluate_expression(\\"3 + 4 - (5 - 2) \\") 4 >>> evaluate_expression(\\"1 - (4 + 2) + 3\\") -2","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression containing addition and subtraction, with possible parentheses. Args: expression (str): A string representing the arithmetic expression. Returns: int: The result of the evaluated arithmetic expression. def calculate(operators, operands): Helper function to perform arithmetic operations. if operators[-1] == '+': operands[-2] += operands[-1] elif operators[-1] == '-': operands[-2] -= operands[-1] operators.pop() operands.pop() operators, operands = [], [] i, n = 0, len(expression) while i < n: if expression[i] == ' ': i += 1 continue if expression[i] in '+-': while operators and operators[-1] in \\"+-\\": calculate(operators, operands) operators.append(expression[i]) elif expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while operators[-1] != '(': calculate(operators, operands) operators.pop() else: num = 0 while i < n and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) continue i += 1 while operators: calculate(operators, operands) return operands[0]"},{"question":"def min_operations_to_equal_matrix(mat: List[List[int]]) -> int: Returns the minimum number of operations required to make all the elements of the matrix equal. >>> min_operations_to_equal_matrix([[5]]) == 0 >>> min_operations_to_equal_matrix([[1, 1, 1], [1, 1, 1]]) == 0 >>> min_operations_to_equal_matrix([[1, 2], [3, 4]]) == 4 >>> min_operations_to_equal_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 20 >>> min_operations_to_equal_matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0","solution":"def min_operations_to_equal_matrix(mat): Returns the minimum number of operations required to make all the elements of the matrix equal. :param mat: List[List[int]] - 2D non-negative integer matrix :return: int - minimum number of operations if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) # Flatten the matrix and find the median elements = [mat[i][j] for i in range(m) for j in range(n)] elements.sort() median = elements[len(elements) // 2] # Compute the minimum number of operations to make all elements equal to the median operations = sum(abs(median - mat[i][j]) for i in range(m) for j in range(n)) return operations"},{"question":"def min_operations_to_delete_string(S: str) -> int: Return the minimum number of operations required to delete all characters in the string. :param S: A string containing only lowercase letters. :return: Minimum number of operations to delete all characters. >>> min_operations_to_delete_string(\\"a\\") == 1 >>> min_operations_to_delete_string(\\"aaaa\\") == 1 >>> min_operations_to_delete_string(\\"ababab\\") == 6 >>> min_operations_to_delete_string(\\"aaabbb\\") == 2 >>> min_operations_to_delete_string(\\"aaabccc\\") == 3 >>> min_operations_to_delete_string(\\"\\") == 0 >>> min_operations_to_delete_string(\\"abcdef\\") == 6","solution":"def min_operations_to_delete_string(S): Return the minimum number of operations required to delete all characters in the string. :param S: A string containing only lowercase letters. :return: Minimum number of operations to delete all characters. if not S: return 0 count = 1 for i in range(1, len(S)): if S[i] != S[i-1]: count += 1 return count"},{"question":"def can_fill_warehouse(arr, capacity): Determine if it is possible to fill the warehouse with exactly the given capacity using the provided list of product units. Args: arr (List[int]): List of integers representing the number of units of a certain product. capacity (int): Total capacity of the warehouse in units. Returns: bool: True if it is possible to meet the warehouse capacity using the given list, otherwise False. >>> can_fill_warehouse([2, 3, 7], 10) == True >>> can_fill_warehouse([2, 3, 5, 7], 10) == True >>> can_fill_warehouse([1, 2, 3], 7) == False >>> can_fill_warehouse([3, 5, 7], 19) == False >>> can_fill_warehouse([1, 2, 3], 0) == True >>> can_fill_warehouse([], 0) == True >>> can_fill_warehouse([2, 3, 5, 7], 1) == False >>> can_fill_warehouse([1, 9, 3, 7], 14) == False >>> can_fill_warehouse([5], 5) == True >>> can_fill_warehouse([7], 5) == False","solution":"def can_fill_warehouse(arr, capacity): Function to determine if it is possible to fill the warehouse with exactly the given capacity using the provided list of product units. n = len(arr) dp = [[False] * (capacity + 1) for _ in range(n + 1)] # It's always possible to achieve 0 capacity with no elements for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, capacity + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] return dp[n][capacity]"},{"question":"def isPossible(s: str) -> bool: Given a string \`s\` consisting of only the characters 'a', 'b', and 'c' determine if it is possible to remove some characters from \`s\` such that the resulting string contains at least one 'a', one 'b', and one 'c' in any order. >>> isPossible(\\"abcabc\\") True >>> isPossible(\\"aaaa\\") False","solution":"def isPossible(s): Returns a boolean indicating whether it's possible to remove some characters from s to get at least one 'a', one 'b', and one 'c' in any order. return 'a' in s and 'b' in s and 'c' in s"},{"question":"def count_paths(grid: List[List[int]]) -> int: Given a 2D grid of size \`m x n\` where each cell represents a different terrain type, return the number of different paths from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time, and you can only traverse through cells of the same terrain type as the starting cell (top-left corner). If there is no such path, return \`0\`. >>> count_paths([[1]]) == 1 >>> count_paths([[0]]) == 1 >>> count_paths([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 6 >>> count_paths([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 2] ... ]) == 0 >>> count_paths([ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]) == 2 >>> count_paths([ ... [1, 2, 3], ... [4, 1, 6], ... [7, 8, 1] ... ]) == 0 >>> count_paths([ ... [1] * 5, ... [1] * 5, ... [1] * 5, ... [1] * 5, ... [1] * 5 ... ]) == 70","solution":"def count_paths(grid): Returns the number of different paths from the top-left corner to the bottom-right corner of the grid, moving only down or right and within cells containing the same terrain type as the starting cell. m, n = len(grid), len(grid[0]) start_terrain = grid[0][0] # If start or end cells don't have the same terrain type as the start, return 0 if grid[m-1][n-1] != start_terrain: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Starting point for i in range(m): for j in range(n): if grid[i][j] != start_terrain: dp[i][j] = 0 # Not a valid cell else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def shortest_distance(cards: List[int]) -> int: Returns the shortest distance between two repeated cards or -1 if no card is repeated. >>> shortest_distance([1, 2, 3, 4, 5]) == -1 >>> shortest_distance([1, 2, 3, 1]) == 3 >>> shortest_distance([1, 2, 3, 4, 2, 5]) == 3 >>> shortest_distance([1, 1, 2, 3, 2, 1]) == 1 >>> shortest_distance([1, 1, 1, 1]) == 1 pass","solution":"def shortest_distance(cards): Returns the shortest distance between two repeated cards or -1 if no card is repeated. card_indices = {} min_distance = float('inf') for index, card in enumerate(cards): if card in card_indices: min_distance = min(min_distance, index - card_indices[card]) card_indices[card] = index return -1 if min_distance == float('inf') else min_distance"},{"question":"from typing import List def has_permutation_in_dictionary(s: str, dictionary: List[str]) -> bool: Check if any permutation of \`s\` matches a word in \`dictionary\`. >>> has_permutation_in_dictionary(\\"abc\\", [\\"cba\\", \\"bbb\\", \\"ccc\\"]) == True >>> has_permutation_in_dictionary(\\"abcd\\", [\\"aabb\\", \\"ccdd\\", \\"dcab\\"]) == True >>> has_permutation_in_dictionary(\\"abcd\\", [\\"xyz\\", \\"wvut\\"]) == False >>> has_permutation_in_dictionary(\\"aabbcc\\", [\\"abccba\\", \\"baccba\\", \\"cab\\"]) == True >>> has_permutation_in_dictionary(\\"a\\", [\\"a\\", \\"b\\"]) == True >>> has_permutation_in_dictionary(\\"a\\", [\\"b\\", \\"c\\"]) == False >>> has_permutation_in_dictionary(\\"\\", [\\"a\\", \\"b\\"]) == False >>> has_permutation_in_dictionary(\\"\\", [\\"\\"]) == True >>> has_permutation_in_dictionary(\\"abc\\", [\\"def\\", \\"ghi\\"]) == False >>> has_permutation_in_dictionary(\\"xy\\", [\\"yx\\", \\"zz\\", \\"xx\\"]) == True","solution":"from collections import Counter def has_permutation_in_dictionary(s, dictionary): Returns True if any permutation of s matches a word in dictionary, otherwise False. s_counter = Counter(s) for word in dictionary: if Counter(word) == s_counter: return True return False"},{"question":"from typing import List # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findDuplicateSubtrees(root: TreeNode) -> List[TreeNode]: Finds all duplicate subtrees in a binary tree. :param root: The root node of the binary tree. :return: A list of TreeNode which are the roots of duplicate subtrees. Example: >>> # Tree structure: >>> # 1 >>> # / >>> # 2 3 >>> # / / >>> # 4 2 4 >>> # / >>> # 4 >>> root = TreeNode(1, ... TreeNode(2, TreeNode(4)), ... TreeNode(3, TreeNode(2, TreeNode(4)), TreeNode(4)) ... ) >>> result = findDuplicateSubtrees(root) >>> sorted([node.val for node in result]) [2, 4]","solution":"from collections import defaultdict from typing import List # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findDuplicateSubtrees(root: TreeNode) -> List[TreeNode]: Finds all duplicate subtrees in a binary tree. :param root: The root node of the binary tree. :return: A list of TreeNode which are the roots of duplicate subtrees. def serialize(node): if not node: return \\"#\\" serial = f\\"{node.val},{serialize(node.left)},{serialize(node.right)}\\" trees[serial].append(node) return serial trees = defaultdict(list) serialize(root) duplicates = [nodes[0] for nodes in trees.values() if len(nodes) > 1] return duplicates"},{"question":"from typing import List def longest_word(words: List[str], letters: str) -> str: Returns the longest word in 'words' that can be constructed using 'letters' at most once per letter. In case of ties, returns the lexicographically smaller word. >>> longest_word(['cat', 'bat', 'rat'], 'b') '' >>> longest_word(['cat', 'bat', 'rat'], 'cata') 'cat' >>> longest_word(['cat', 'bat', 'cater'], 'acterra') 'cater' >>> longest_word(['cat', 'bat'], 'tacatb') 'bat' >>> longest_word(['cat', 'bat', 'abac'], 'abcat') 'abac' >>> longest_word(['cat', 'bat'], '') '' >>> longest_word([], 'tacatb') ''","solution":"def longest_word(words, letters): Returns the longest word in 'words' that can be constructed using 'letters' at most once per letter. In case of ties, returns the lexicographically smaller word. from collections import Counter def can_form(word, letters_count): word_count = Counter(word) for char in word_count: if word_count[char] > letters_count.get(char, 0): return False return True letters_count = Counter(letters) valid_words = [word for word in words if can_form(word, letters_count)] if not valid_words: return \\"\\" valid_words.sort(key=lambda x: (-len(x), x)) return valid_words[0]"},{"question":"from typing import List def arithmetic_triplets(nums: List[int], d: int) -> int: Returns the number of unique arithmetic triplets in the array. An arithmetic triplet is a triplet (i, j, k) such that i < j < k and nums[j] - nums[i] is equal to d, and nums[k] - nums[j] is equal to d. :param nums: List[int] - a list of integers of length n :param d: int - the difference :return: int - the number of unique arithmetic triplets >>> arithmetic_triplets([0, 1, 4, 6, 7, 10], 3) 2 >>> arithmetic_triplets([1, 2, 3, 4, 5], 6) 0 >>> arithmetic_triplets([0, 0, 3, 3, 6, 6], 3) 2 >>> arithmetic_triplets([1], 1) 0 >>> arithmetic_triplets([2, 2, 2, 2], 0) 4 >>> arithmetic_triplets([10, 30, 50, 70], 20) 2 pass","solution":"def arithmetic_triplets(nums, d): Returns the number of unique arithmetic triplets in the array. :param nums: List[int] - a list of integers of length n :param d: int - the difference :return: int - the number of unique arithmetic triplets count = 0 nums_set = set(nums) for num in nums: if (num + d in nums_set) and (num + 2 * d in nums_set): count += 1 return count"},{"question":"def min_moves_to_remove_substrings(s: str) -> int: Determines the minimum number of moves required to remove all characters from the string. Parameters: s (str): The input string consisting of only lowercase English letters. Returns: int: The minimum number of moves required to remove all characters. Examples: >>> min_moves_to_remove_substrings(\\"aaabbb\\") 2 >>> min_moves_to_remove_substrings(\\"aabbcc\\") 3","solution":"def min_moves_to_remove_substrings(s): Determines the minimum number of moves required to remove all characters from the string. Parameters: s (str): The input string consisting of only lowercase English letters. Returns: int: The minimum number of moves required to remove all characters. if not s: # if the string is empty, no moves are needed return 0 moves = 1 # initialize moves to 1, since we need at least 1 move to start for i in range(1, len(s)): # if the current character is different from the previous one, then it's a new segment if s[i] != s[i - 1]: moves += 1 return moves"},{"question":"def count_subsets(nums: List[int], target: int) -> int: You are given an integer array \`nums\` and an integer \`target\`. Find the number of subsets of \`nums\` that sum up to \`target\`. Return the number of such subsets modulo 10**9 + 7. >>> count_subsets([], 0) == 1 >>> count_subsets([], 1) == 0 >>> count_subsets([1], 1) == 1 >>> count_subsets([1], 2) == 0 >>> count_subsets([1, 2, 3], 4) == 1 # Subsets: [1, 3] >>> count_subsets([1, 2, 3], 5) == 1 # Subsets: [2, 3] >>> count_subsets([1, 2, 3], 6) == 1 # Subsets: [1, 2, 3] >>> count_subsets([1, 1, 1, 1], 2) == 6 # Subsets: [1, 1] (multiple combinations) >>> count_subsets([1, 2, 3, 4, 5], 10) == 3 # Subsets: [1, 2, 3, 4], [1, 4, 5], [2, 3, 5] >>> count_subsets([2, 4, 6], 5) == 0","solution":"MOD = 10**9 + 7 def count_subsets(nums, target): from collections import defaultdict dp = defaultdict(int) dp[0] = 1 # There is one way to get sum 0: pick no elements for num in nums: for cur_sum in list(dp.keys())[::-1]: new_sum = cur_sum + num dp[new_sum] = (dp[new_sum] + dp[cur_sum]) % MOD return dp[target]"},{"question":"from typing import List def findLongestChain(pairs: List[List[int]]) -> int: Returns the length of the longest chain that can be formed with given pairs. :param pairs: List of pairs where each pair is represented as [a, b], with a < b :return: Length of the longest chain pass def test_findLongestChain_basic(): assert findLongestChain([[1,2], [2,3], [3,4]]) == 2 def test_findLongestChain_no_chains(): assert findLongestChain([[1,2], [1,3], [1,4]]) == 1 weekend day, a sail number other than 2017 can be used. Lightnings scored 2nd to 6th inspiral races will be awarded double points which will not be dropped in calculating fleet series (Season, Spring & Autumn) scoring. Results for the two formats will be combined for posting on the SLYC website, Samsara web results page and the Sailwave series file for scoring purposes. Organizing Committee reserves the right to amend the NoR. Amendments will be posted on the official notice board. Registration There is no entry fee required. Registration will take place in the SLYC clubhouse on Saturday May 8th from 9:30 am to 10:30 am. Schedule Race day: Saturday, May 8. Skippers' meeting @ 11:00 am. First Race and Subsequent starts @ 12:00 pm Equipment Each boat shall a) comply with current Class Rules (as amended by its national authority where applicable) b) be complete with sails, spars, rigging, etc., as per the gauge documents and c) have its correct sail number on all sails. Sailing Instructions The sailing instructions will be available at registration. Copies will also be posted on the Internet accessible notice(s): 1. Understand the problem: In this task, we're given \`n\` pairs of numbers where the first number in each pair is less than the second number. We need to find the maximum length of a chain that can be formed such that for each pair \`(a, b)\` in the chain, the next pair's first number \`c\` is greater than \`b\`. Given an array of pairs, we have to return the length of the longest chain that can be formed. 2. Example provided: If \`pairs = [[1, 2], [2, 3], [3, 4]]\`, the longest pair chain is 2 since \`(1, 2)\` can be followed by \`(3, 4)\`, but \`(2, 3)\` does not meet the condition. 3. Required function definition: You need to write a function \`findLongestChain()\` that receives a parameter \`pairs\` which is a list of lists, where each inner list contains two integers \`[a, b]\` with \`a\` < \`b\`. It should return an integer representing the length of the longest chain that can be formed according to the described condition. 4. Test Cases: from solution import findLongestChain def test_findLongestChain_basic(): assert findLongestChain([[1,2], [2,3], [3,4]]) == 2 def test_findLongestChain_no_chains(): assert findLongestChain([[1,2], [1,3], [1,4]]) == 1 def test_findLongestChain_all_separate(): assert findLongestChain([[1,2], [3,4], [5,6]]) == 3 def test_findLongestChain_one_pair(): assert findLongestChain([[1,10]]) == 1 def test_findLongestChain_multiple_pairs(): assert findLongestChain([[1,2], [7,8], [3,4], [5,6]]) == 4 def test_findLongestChain_unordered_pairs(): assert findLongestChain([[5,24], [15,25], [27,40], [50,60]]) == 3","solution":"def findLongestChain(pairs): Returns the length of the longest chain that can be formed with given pairs. :param pairs: List of pairs where each pair is represented as [a, b], with a < b :return: Length of the longest chain pairs.sort(key=lambda x: x[1]) # Sort pairs based on the second element of each pair current_end, count = float('-inf'), 0 for pair in pairs: if current_end < pair[0]: current_end = pair[1] count += 1 return count"},{"question":"from typing import List def topKFrequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the nums array. >>> topKFrequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> topKFrequent([1], 1) [1] >>> topKFrequent([4, 1, -1, 2, -1, 2, 3], 2) [2, -1] >>> topKFrequent([1, 2, 3, 4, 5, 6], 3) [1, 2, 3] >>> topKFrequent([5, 5, 5, 5, 5, 5], 1) [5] >>> topKFrequent([-10000, -10000, -10000, 10000, 10000, 0], 2) [-10000, 10000]","solution":"from typing import List from collections import Counter import heapq def topKFrequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the nums array. # Count frequency of each element count = Counter(nums) # Use a heap to find the k most frequent elements return [item for item, _ in heapq.nlargest(k, count.items(), key=lambda x: x[1])]"},{"question":"def rearrange_shrubs(arr: List[int], d: int) -> List[int]: Rearranges the shrubs such that the absolute difference in height between any two adjacent shrubs does not exceed d. If it is not possible, returns an empty list. >>> rearrange_shrubs([1, 3, 2], 1) != [] >>> rearrange_shrubs([1, 5, 2], 1) == [] >>> rearrange_shrubs([2, 2, 2], 0) == [2, 2, 2] >>> rearrange_shrubs([10, 1, 5], 10) != [] >>> rearrange_shrubs([1, 2, 3], 1) == [1, 2, 3] >>> rearrange_shrubs([7], 3) == [7] >>> rearrange_shrubs([-1, 0, 1, 2], 1) == [-1, 0, 1, 2]","solution":"def rearrange_shrubs(arr, d): Rearranges the shrubs such that the absolute difference in height between any two adjacent shrubs does not exceed d. If it is not possible, returns an empty list. arr_sorted = sorted(arr) for i in range(1, len(arr_sorted)): if abs(arr_sorted[i] - arr_sorted[i - 1]) > d: return [] return arr_sorted"},{"question":"def can_sort_by_one_reversal(arr: List[int]) -> bool: Determines whether the sequence can be sorted into non-decreasing order by performing at most one segment reversal. >>> can_sort_by_one_reversal([1, 2, 3, 4, 5]) True >>> can_sort_by_one_reversal([1, 5, 4, 3, 2, 6]) True >>> can_sort_by_one_reversal([5, 4, 3, 2, 1, 6]) True >>> can_sort_by_one_reversal([1, 6, 5, 4, 3, 2]) True >>> can_sort_by_one_reversal([1, 3, 5, 4, 6, 2]) False >>> can_sort_by_one_reversal([1]) True >>> can_sort_by_one_reversal([1, 2]) True >>> can_sort_by_one_reversal([2, 1]) True >>> can_sort_by_one_reversal([1, 3, 5, 4, 6, 7]) True","solution":"def can_sort_by_one_reversal(arr): Determines whether the sequence can be sorted into non-decreasing order by performing at most one segment reversal. n = len(arr) # Identify the first segment that is out of order i = 0 while i < n - 1 and arr[i] <= arr[i + 1]: i += 1 # If the whole array is already sorted if i == n - 1: return True # Identify the last segment that is out of order j = n - 1 while j > 0 and arr[j] >= arr[j - 1]: j -= 1 # Reverse the segment arr[i:j+1] arr[i:j+1] = arr[i:j+1][::-1] # Check if the array is sorted after the reversal return arr == sorted(arr)"},{"question":"def longest_equal_subarray(arr: List[int]) -> int: Returns the length of the longest subarray that contains an equal number of occurrences of the two integers 0 and 1. >>> longest_equal_subarray([0, 1, 0, 1]) 4 >>> longest_equal_subarray([0, 0, 1, 1, 0]) 4 >>> longest_equal_subarray([0, 0, 0, 0]) 0 >>> longest_equal_subarray([1, 1, 1, 1]) 0 >>> longest_equal_subarray([0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1]) 14 >>> longest_equal_subarray([0, 1, 0, 0, 1, 1, 0]) 6 >>> longest_equal_subarray([0, 1, 0, 1, 0, 1]) 6 >>> longest_equal_subarray([0, 1]) 2 >>> longest_equal_subarray([0]) 0 >>> longest_equal_subarray([1]) 0 >>> longest_equal_subarray([]) 0","solution":"def longest_equal_subarray(arr): Returns the length of the longest subarray that contains an equal number of occurrences of the two integers 0 and 1. :param arr: List[int] - input array consisting of integers 0 and 1 :return: int - length of the longest subarray with equal 0's and 1's count_map = {0: -1} count = 0 max_length = 0 for i, num in enumerate(arr): if num == 0: count -= 1 else: count += 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def increment_binary_number(nums: List[int]) -> List[int]: Given a list of integers representing a non-negative binary number where each digit is stored from the most significant bit to the least significant bit, return the next binary number as a list of integers. >>> increment_binary_number([1, 0, 1, 1]) == [1, 1, 0, 0] >>> increment_binary_number([1, 1, 1]) == [1, 0, 0, 0] >>> increment_binary_number([0]) == [1] >>> increment_binary_number([0, 0, 0]) == [0, 0, 1] >>> increment_binary_number([1]) == [1, 0] >>> increment_binary_number([1, 0, 0, 1, 1]) == [1, 0, 1, 0, 0] >>> increment_binary_number([1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1]) == [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0]","solution":"def increment_binary_number(nums): Given a list of integers representing a non-negative binary number where each digit is stored from the most significant bit to the least significant bit, return the next binary number as a list of integers. length = len(nums) # Starting from the least significant bit for i in range(length - 1, -1, -1): if nums[i] == 0: nums[i] = 1 return nums else: nums[i] = 0 # If all bits were 1, then the result will be 1 followed by all 0s return [1] + nums"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_unique_path(root: TreeNode) -> int: Find the length of the largest unique path from the root node to any leaf node in a binary tree. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(4) >>> root.left.left.left = TreeNode(2) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(7) >>> root.right.right.left = TreeNode(3) >>> root.right.right.right = TreeNode(9) >>> largest_unique_path(root) 4 >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> largest_unique_path(root) 3 >>> root = TreeNode(1) >>> largest_unique_path(root) 1 >>> largest_unique_path(None) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(2) >>> root.right.right = TreeNode(4) >>> largest_unique_path(root) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_unique_path(root): def dfs(node, path_set): if not node: return len(path_set) if node.val in path_set: return len(path_set) path_set.add(node.val) left_length = dfs(node.left, path_set) right_length = dfs(node.right, path_set) path_set.remove(node.val) return max(left_length, right_length) if not root: return 0 return dfs(root, set())"},{"question":"def kth_smallest_element(nums: List[int], k: int) -> int: Returns the k-th smallest element in the array \`nums\`. >>> kth_smallest_element([3, 2, 1, 5, 6, 4], 2) 2 >>> kth_smallest_element([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 3 >>> kth_smallest_element([1, 1, 1], 1) 1 >>> kth_smallest_element([1, 1, 1], 3) 1 >>> kth_smallest_element([1, 2, 3, 4], 4) 4 >>> kth_smallest_element([1], 1) 1","solution":"import heapq def kth_smallest_element(nums, k): Returns the k-th smallest element in the array nums. if not nums or k < 1 or k > len(nums): return None return heapq.nsmallest(k, nums)[-1]"},{"question":"from typing import List def maxValue(events: List[List[int]], k: int) -> int: Find the maximum value you can accumulate by attending up to \`k\` non-overlapping events from the given 2D integer array \`events\`. >>> maxValue([[1, 2, 4], [3, 4, 3], [2, 3, 10]], 2) == 14 >>> maxValue([[1, 3, 3], [2, 4, 4], [3, 5, 2]], 1) == 4 >>> maxValue([[1, 2, 4], [3, 4, 3], [5, 6, 2]], 3) == 9 >>> maxValue([], 1) == 0 >>> maxValue([[1, 2, 4]], 1) == 4 >>> maxValue([[1, 2, 4], [3, 4, 3]], 3) == 7 >>> maxValue([[1, 5, 5], [2, 6, 3], [4, 8, 8]], 1) == 8","solution":"from bisect import bisect_right from functools import lru_cache def maxValue(events, k): # Sort events by ending time events.sort(key=lambda x: x[1]) # Extract the end times for binary search usage end_times = [event[1] for event in events] @lru_cache(None) def dp(index, remaining): # No events left or no remaining slots to attend events if index == len(events) or remaining == 0: return 0 # Option 1: Skip the event at current index max_val = dp(index + 1, remaining) # Option 2: Attend the event at current index next_index = bisect_right(end_times, events[index][1]) max_val = max(max_val, events[index][2] + dp(next_index, remaining - 1)) return max_val return dp(0, k)"},{"question":"def shortest_subarray_with_sum(nums: List[int], k: int) -> int: Finds the length of the shortest subarray whose sum is equal to k. Returns -1 if such a subarray does not exist. >>> shortest_subarray_with_sum([1, 2, 3, 4, 5], 9) == 2 # Subarray: [4, 5] >>> shortest_subarray_with_sum([1, 1, 1, 1, 5], 6) == 2 # Subarray: [1, 5] >>> shortest_subarray_with_sum([1, -1, 5, -2, 3], 3) == 1 # Subarray: [3] >>> shortest_subarray_with_sum([1, 2, 3], 7) == -1 >>> shortest_subarray_with_sum([], 5) == -1 >>> shortest_subarray_with_sum([1, 2, 3], 6) == 3 # Subarray: [1, 2, 3] >>> shortest_subarray_with_sum([5], 5) == 1 # Subarray: [5] >>> shortest_subarray_with_sum([2], 3) == -1 >>> shortest_subarray_with_sum([1, 2, 1, 2, 1], 3) == 2 # Subarray: [1, 2] or [2, 1]","solution":"def shortest_subarray_with_sum(nums, k): Finds the length of the shortest subarray whose sum is equal to k. Returns -1 if such a subarray does not exist. n = len(nums) if n == 0: return -1 sums = {0: -1} # Dictionary to store the prefix sums current_sum = 0 min_length = float('inf') for i in range(n): current_sum += nums[i] if current_sum - k in sums: min_length = min(min_length, i - sums[current_sum - k]) # store the index only if it's not already in the map to keep the shortest subarray if current_sum not in sums: sums[current_sum] = i return min_length if min_length != float('inf') else -1"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_path_sum(root): Determine the largest sum of any path in the binary tree where starting and ending at any nodes. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> max_path_sum(root) 6 >>> root = TreeNode(-10, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> max_path_sum(root) 42","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_path_sum(root): max_sum = float('-inf') def helper(node): nonlocal max_sum if not node: return 0 # Find max path sum through the left child left = max(helper(node.left), 0) # Find max path sum through the right child right = max(helper(node.right), 0) # Max path sum through the current node (includes both children paths) current_max = node.value + left + right # Update overall maximum max_sum = max(max_sum, current_max) # Return value for parent call: return node.value + max(left, right) helper(root) return max_sum"},{"question":"def reverse_each_word(s: str) -> str: Reverses the order of characters in each word while retaining the white spaces and the initial word order. Parameters: s (str): A string representing a sentence containing words and spaces. Returns: str: The modified string with each word reversed. Examples: >>> reverse_each_word(\\"This is an example\\") 'sihT si na elpmaxe' >>> reverse_each_word(\\"Hello World\\") 'olleH dlroW' >>> reverse_each_word(\\"python\\") 'nohtyp' >>> reverse_each_word(\\"a b c\\") 'a b c' >>> reverse_each_word(\\"\\") '' >>> reverse_each_word(\\" \\") ' ' >>> reverse_each_word(\\" a \\") ' a '","solution":"def reverse_each_word(s): Reverses the order of characters in each word while retaining the white spaces and the initial word order. Parameters: s (str): A string representing a sentence containing words and spaces. Returns: str: The modified string with each word reversed. return ' '.join(word[::-1] for word in s.split(' '))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Returns all root-to-leaf paths of the binary tree rooted at 'root'. Each path is represented by a string of node values separated by arrows \\"->\\". Examples: >>> root = TreeNode(1, TreeNode(2, right=TreeNode(5)), TreeNode(3)) >>> binary_tree_paths(root) [\\"1->2->5\\", \\"1->3\\"] >>> root = TreeNode(1, right=TreeNode(2, right=TreeNode(3))) >>> binary_tree_paths(root) [\\"1->2->3\\"] >>> binary_tree_paths(None) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Returns all root-to-leaf paths of the binary tree rooted at 'root'. Each path is represented by a string of node values separated by arrows \\"->\\". if not root: return [] def dfs(node, path, paths): if not node: return # Add the current node's value to the path path += str(node.val) # If leaf node, add to paths list if not node.left and not node.right: paths.append(path) else: path += '->' # Add the separator dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"def min_deletions_to_subsequence(s: str, t: str) -> int: Determine the minimum number of deletions required to make \`s\` a subsequence of \`t\`. >>> min_deletions_to_subsequence(\\"abc\\", \\"abcdef\\") 0 >>> min_deletions_to_subsequence(\\"abc\\", \\"ac\\") 1 # delete 'b' from \\"abc\\" >>> min_deletions_to_subsequence(\\"abcde\\", \\"ace\\") 2 # delete 'b' and 'd' >>> min_deletions_to_subsequence(\\"abc\\", \\"d\\") 3 # delete 'a', 'b', and 'c' >>> min_deletions_to_subsequence(\\"abcdef\\", \\"ghj\\") 6 # delete all 'abcdef' >>> min_deletions_to_subsequence(\\"aabbcc\\", \\"abc\\") 3 # delete one 'a', one 'b' and one 'c' >>> min_deletions_to_subsequence(\\"abc\\", \\"\\") 3 # delete everything >>> min_deletions_to_subsequence(\\"\\", \\"abc\\") 0 # nothing to delete","solution":"def min_deletions_to_subsequence(s, t): Returns the minimum number of deletions required to make \`s\` a subsequence of \`t\`. n = len(s) m = len(t) # Find the length of the Longest Common Subsequence (LCS) def lcs(s, t, n, m): # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] lcs_length = lcs(s, t, n, m) # The minimum deletions needed is the length of \`s\` minus the length of LCS return n - lcs_length"},{"question":"def min_changes_to_paint_houses(nums: List[int], colors: List[int]) -> int: You are given an array of integers \`nums\` where the \`i-th\` integer represents the color of the \`i-th\` house. You need to paint all the houses such that no two adjacent houses have the same color, and each house should be painted with a color represented in the array \`colors\`. Return the minimum number of changes required to achieve this condition if changes can only be made to the houses' color in \`nums\`. If it is not possible, return \`-1\`. >>> min_changes_to_paint_houses([1, 2, 2], [1, 2, 3]) 1 >>> min_changes_to_paint_houses([1, 2, 3], [1, 2, 3]) 0 >>> min_changes_to_paint_houses([1, 1, 1], [1, 2]) 1 >>> min_changes_to_paint_houses([1, 3, 3], [2, 3]) -1 >>> min_changes_to_paint_houses([1, 2, 1, 2, 1], [1, 2, 3]) 0 >>> min_changes_to_paint_houses([1, 4, 3], [1, 2, 3]) -1 >>> min_changes_to_paint_houses([1, 2, 3, 1, 2], [1, 2, 3]) 0 >>> min_changes_to_paint_houses([1, 1, 2, 2, 1], [1, 2, 3]) 2","solution":"def min_changes_to_paint_houses(nums, colors): n = len(nums) color_set = set(colors) if not all(color in color_set for color in nums): return -1 dp = [[float('inf')] * len(color_set) for _ in range(n)] color_index = {color: idx for idx, color in enumerate(colors)} for i in range(n): for c in colors: if i == 0: dp[i][color_index[c]] = 0 if nums[i] == c else 1 else: for prev_c in colors: if c != prev_c: dp[i][color_index[c]] = min(dp[i][color_index[c]], dp[i-1][color_index[prev_c]] + (1 if nums[i] != c else 0)) min_changes = min(dp[n-1]) return min_changes if min_changes != float('inf') else -1"},{"question":"def can_permute_to_palindrome(s: str) -> bool: Determine if the input string can be permuted to form a palindrome. Only strings with at most one character having an odd count of occurrences can be permuted to form a palindrome. >>> can_permute_to_palindrome(\\"aabb\\") True >>> can_permute_to_palindrome(\\"aabbc\\") True >>> can_permute_to_palindrome(\\"aabbccde\\") False >>> can_permute_to_palindrome(\\"a\\") True >>> can_permute_to_palindrome(\\"\\") True","solution":"def can_permute_to_palindrome(s): Determines if the input string can be permuted to form a palindrome. :param s: The input string :return: True if the string can be permuted to form a palindrome, False otherwise from collections import Counter count = Counter(s) odd_count = sum(1 for x in count.values() if x % 2 != 0) return odd_count <= 1"},{"question":"def longest_good_subarray(arr: List[int], threshold: int) -> int: Returns the length of the longest \\"good\\" subarray where the sum of its elements is less than or equal to the given threshold. >>> longest_good_subarray([1], 2) 1 >>> longest_good_subarray([3], 2) 0 >>> longest_good_subarray([3, 4, 5], 2) 0 >>> longest_good_subarray([1, 2, 1], 4) 3 >>> longest_good_subarray([1, 2, 3, 4], 5) 2 >>> longest_good_subarray([1, 1, 1, 1], 5) 4 >>> longest_good_subarray([5, 1, 2, 3, 7, 1, 2, 1], 6) 3","solution":"def longest_good_subarray(arr, threshold): Returns the length of the longest \\"good\\" subarray. n = len(arr) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] # add the current element to the window # shrink the window until the current sum is within the threshold while current_sum > threshold and start <= end: current_sum -= arr[start] start += 1 # update the max length if the current window is \\"good\\" max_length = max(max_length, end - start + 1) return max_length"},{"question":"def split_string(s: str, n: int) -> list: Splits the string \`s\` into \`n\` parts such that each part has an equal number of characters. If the string cannot be evenly split, then adds the character '_' at the end of the last part until all parts have equal length. Parameters: s (str): The input string consisting of lowercase alphabets. n (int): The number of parts to split the string into. Returns: list[str]: A list of \`n\` strings having equal length. >>> split_string(\\"abcdefghij\\", 5) [\\"ab\\", \\"cd\\", \\"ef\\", \\"gh\\", \\"ij\\"] >>> split_string(\\"abcdefghij\\", 3) [\\"abcd\\", \\"efgh\\", \\"ij__\\"] >>> split_string(\\"abcdefghij\\", 1) [\\"abcdefghij\\"] >>> split_string(\\"abcd\\", 6) [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"_\\", \\"_\\"] >>> split_string(\\"\\", 3) [\\"\\", \\"\\", \\"\\"] >>> split_string(\\"abcd\\", 0) [] >>> split_string(\\"ab\\", 5) [\\"a\\", \\"b\\", \\"_\\", \\"_\\", \\"_\\"]","solution":"def split_string(s, n): Splits the string \`s\` into \`n\` parts such that each part has an equal number of characters. If the string cannot be evenly split, then adds the character '_' at the end of the last part until all parts have equal length. Parameters: s (str): The input string consisting of lowercase alphabets. n (int): The number of parts to split the string into. Returns: list[str]: A list of \`n\` strings having equal length. if n <= 0: return [] # Calculate the length of each part part_length = (len(s) + n - 1) // n parts = [] for i in range(n): start_index = i * part_length end_index = start_index + part_length part = s[start_index:end_index] # If the part is shorter than required length, pad with '_' if len(part) < part_length: part += '_' * (part_length - len(part)) parts.append(part) return parts"},{"question":"def minimumTime(nums: List[int], k: int) -> int: Returns the minimum number of days required to complete all courses given that you can study at most k courses simultaneously in a day. :param nums: List[int] - List of integers representing course completion times in days :param k: int - Maximum number of simultaneous courses one can study :return: int - Minimum number of days required to complete all courses pass def test_minimum_time_basic(): assert minimumTime([3, 2, 1], 2) == 2 def test_minimum_time_all_courses_in_one_day(): assert minimumTime([1, 1, 1, 1], 4) == 1 def test_minimum_time_partial_courses(): assert minimumTime([4, 4, 4, 4], 2) == 2 def test_minimum_time_different_lengths(): assert minimumTime([2, 3, 4, 5, 6], 3) == 2 def test_minimum_time_single_course_multiple_days(): assert minimumTime([10], 5) == 1 def test_minimum_time_uneven_distribution(): assert minimumTime([9, 7, 4, 8, 6], 2) == 3 def test_minimum_time_more_courses_than_k(): assert minimumTime([2, 3, 1, 5], 1) == 4 def test_minimum_time_edge_case_empty_list(): assert minimumTime([], 2) == 0","solution":"def minimumTime(nums, k): Returns the minimum number of days required to complete all courses given that you can study at most k courses simultaneously in a day. :param nums: List[int] - List of integers representing course completion times in days :param k: int - Maximum number of simultaneous courses one can study :return: int - Minimum number of days required to complete all courses nums.sort(reverse=True) days = 0 while nums: days += 1 for _ in range(k): if nums: nums.pop(0) return days"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binaryTreePaths(root): Given a binary tree, return all root-to-leaf paths as a list of strings. Each path should be represented as a string formed by joining the node values with a '->' character. >>> tree = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3)) >>> binaryTreePaths(tree) [\\"1->2->5\\", \\"1->3\\"] >>> tree = TreeNode(1) >>> binaryTreePaths(tree) [\\"1\\"] >>> tree = None >>> binaryTreePaths(tree) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binaryTreePaths(root): Returns a list of all root-to-leaf paths in the binary tree. Each path is represented as a string formed by joining the node values with \\"->\\". if not root: return [] def dfs(node, path, paths): if not node: return path += str(node.val) if not node.left and not node.right: paths.append(path) else: path += \\"->\\" dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"def simplify_path(path: str) -> str: Simplifies a given Unix-style path to its canonical form. >>> simplify_path(\\"/home/\\") == \\"/home\\" >>> simplify_path(\\"/../\\") == \\"/\\" >>> simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" >>> simplify_path(\\"/home//foo/../bar/./baz/..\\") == \\"/home/bar\\" >>> simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" >>> simplify_path(\\"/home//foo//bar///\\") == \\"/home/foo/bar\\" >>> simplify_path(\\"////\\") == \\"/\\" >>> simplify_path(\\"/a/b/c/./././d/\\") == \\"/a/b/c/d\\" >>> simplify_path(\\"/./././\\") == \\"/\\" >>> simplify_path(\\"/\\") == \\"/\\" >>> simplify_path(\\"\\") == \\"/\\"","solution":"def simplify_path(path): Simplifies a given Unix-style path to its canonical form. stack = [] parts = path.split('/') for part in parts: if part == \\"..\\": if stack: stack.pop() elif part and part != \\".\\": stack.append(part) return \\"/\\" + \\"/\\".join(stack)"},{"question":"def max_depth(tree): Calculates the maximum depth of the tree represented as array. Args: tree: List[int] - A list where each element represents the parent node of the corresponding node. Returns: int - The maximum depth of the tree. >>> max_depth([-1, 0, 0, 1, 1, 2, 2]) 2 >>> max_depth([-1]) 0 >>> max_depth([-1, 0, 0, 1, 1]) 2 >>> max_depth([-1, 0, 1, 2, 3]) 4 >>> max_depth([-1, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6]) 3","solution":"def max_depth(tree): Calculates the maximum depth of the tree represented as array. Args: tree: List[int] - A list where each element represents the parent node of the corresponding node. Returns: int - The maximum depth of the tree. depths = [-1] * len(tree) def get_depth(node): if tree[node] == -1: return 0 if depths[node] != -1: return depths[node] depths[node] = 1 + get_depth(tree[node]) return depths[node] max_depth = 0 for node in range(len(tree)): max_depth = max(max_depth, get_depth(node)) return max_depth"},{"question":"def first_non_repeating_character(s: str) -> int: Find the first non-repeating character in a string and return its index. If it does not exist, return -1. Args: s (str): the input string consisting of lowercase English letters. Returns: int: the index of the first non-repeating character or -1 if no such character exists. >>> first_non_repeating_character(\\"leetcode\\") 0 >>> first_non_repeating_character(\\"loveleetcode\\") 2 >>> first_non_repeating_character(\\"aabb\\") -1","solution":"def first_non_repeating_character(s): Find the first non-repeating character in a string and return its index. If no such character exists, return -1. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"def evaluate_expression(s: str) -> int: Evaluate a mathematical expression containing only non-negative integers and the operators +, -, *, and /. The integer division should truncate toward zero. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3-2*2\\") -1 >>> evaluate_expression(\\"3+5/2\\") 5 >>> evaluate_expression(\\"3+6/2*3\\") 12 >>> evaluate_expression(\\"1000000*1000+5\\") 1000000005 >>> evaluate_expression(\\"1000000/3\\") 333333 >>> evaluate_expression(\\"6/4\\") 1 >>> evaluate_expression(\\"7-10/2\\") 2","solution":"def evaluate_expression(s): Evaluate a mathematical expression containing only non-negative integers and the operators +, -, *, and /. The integer division should truncate toward zero. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(int(a / b)) # int() truncates toward zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operands = [] operators = [] i = 0 while i < len(s): if s[i].isdigit(): num = 0 while i < len(s) and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 operands.append(num) i -= 1 else: while (operators and precedence(operators[-1]) >= precedence(s[i])): apply_operator(operands, operators.pop()) operators.append(s[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[-1]"},{"question":"def reverse_words(s: str) -> str: Reverses the order of characters in each word while maintaining the order of words and spaces. Parameters: s (str): The input sentence consisting of words and spaces. Returns: str: The sentence with each word's characters reversed. Examples: >>> reverse_words(\\"hello world\\") 'olleh dlrow' >>> reverse_words(\\"OpenAI is awesome\\") 'IAnepO si emosewa'","solution":"def reverse_words(s): Reverses the order of characters in each word while maintaining the order of words and spaces. Parameters: s (str): The input sentence consisting of words and spaces. Returns: str: The sentence with each word's characters reversed. return ' '.join([word[::-1] for word in s.split(' ')])"},{"question":"def min_absolute_difference(ages: List[int]) -> int: Given an array of integers \`ages\` representing the ages of attendees in a room, split the attendees into two groups based on their ages to minimize the absolute difference in the total sums of the ages in the two groups. Return the minimum absolute difference achievable. >>> min_absolute_difference([5]) 5 >>> min_absolute_difference([1, 2, 3, 4]) 0 >>> min_absolute_difference([10, 20, 30, 40, 50]) 10 >>> min_absolute_difference([]) 0 >>> min_absolute_difference([1, 2, 3]) 0 >>> min_absolute_difference([5, 5, 5, 5]) 0 from typing import List def test_min_absolute_difference_single_age(): assert min_absolute_difference([5]) == 5 def test_min_absolute_difference_equal_split(): assert min_absolute_difference([1, 2, 3, 4]) == 0 def test_min_absolute_difference_large_range(): assert min_absolute_difference([10, 20, 30, 40, 50]) == 10 def test_min_absolute_difference_empty(): assert min_absolute_difference([]) == 0 def test_min_absolute_difference_odd_number_of_ages(): assert min_absolute_difference([1, 2, 3]) == 0 def test_min_absolute_difference_duplicate_ages(): assert min_absolute_difference([5, 5, 5, 5]) == 0","solution":"def min_absolute_difference(ages): Splits ages into two groups to minimize the absolute difference in the total sums of the ages in the two groups. total_sum = sum(ages) n = len(ages) dp = [0] * (total_sum // 2 + 1) for age in ages: for j in range(total_sum // 2, age - 1, -1): dp[j] = max(dp[j], dp[j - age] + age) group1_sum = dp[total_sum // 2] group2_sum = total_sum - group1_sum return abs(group1_sum - group2_sum)"},{"question":"def longestSubstring(s: str, k: int) -> int: Returns the length of the longest substring where each character appears at least k times. >>> longestSubstring(\\"aaabb\\", 3) == 3 >>> longestSubstring(\\"ababbc\\", 2) == 5 >>> longestSubstring(\\"aaabbb\\", 3) == 6 >>> longestSubstring(\\"abcde\\", 2) == 0 >>> longestSubstring(\\"\\", 1) == 0 >>> longestSubstring(\\"a\\", 2) == 0 >>> longestSubstring(\\"aa\\", 3) == 0 >>> longestSubstring(\\"aaa\\", 1) == 3 >>> longestSubstring(\\"aaabbbccc\\", 3) == 9 >>> longestSubstring(\\"aaaaaa\\", 2) == 6 >>> longestSubstring(\\"aaaaab\\", 2) == 5","solution":"def longestSubstring(s, k): Returns the length of the longest substring where each character appears at least k times. def longest_substring_util(s, k, start, end): if end - start < k: return 0 char_count = {} for i in range(start, end): char_count[s[i]] = char_count.get(s[i], 0) + 1 for mid in range(start, end): if char_count[s[mid]] < k: next_mid = mid + 1 while next_mid < end and char_count[s[next_mid]] < k: next_mid += 1 return max(longest_substring_util(s, k, start, mid), longest_substring_util(s, k, next_mid, end)) return end - start return longest_substring_util(s, k, 0, len(s))"},{"question":"def rearrange_string(s: str) -> str: Given a string \`s\` consisting of printable ASCII characters, determine if it is possible to rearrange the characters in \`s\` such that every two adjacent characters are different. If possible, return one possible rearrangement. Otherwise, return an empty string. >>> rearrange_string(\\"ab\\") == \\"ab\\" >>> rearrange_string(\\"aab\\") in [\\"aba\\"] >>> rearrange_string(\\"aaab\\") == \\"\\" >>> rearrange_string(\\"\\") == \\"\\" >>> rearrange_string(\\"a\\") == \\"a\\" >>> rearrange_string(\\"aaaa\\") == \\"\\" >>> rearrange_string(\\"a a a b b\\") # Example with spaces","solution":"from collections import Counter import heapq def rearrange_string(s): if not s: return \\"\\" # Count the frequency of each character counter = Counter(s) # Use a max heap to store the characters based on their frequency (as -ve because heapq is min-heap) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) # Previous element initialized to something that isn't any character in s prev_freq, prev_char = 0, '' result = [] # Process the heap while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If previous character can still be used, add it back to the heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update previous element to the current one prev_freq, prev_char = freq + 1, char # Increment freq because we use one occurrence of char # If the rearranged string length is not equal to the original string, it means it wasn't possible if len(result) != len(s): return \\"\\" return ''.join(result)"},{"question":"def findMaxLength(nums: List[int]) -> int: Given an array of integers nums, return the maximum length of a subarray that contains an equal number of 0's and 1's. >>> findMaxLength([0, 1]) == 2 >>> findMaxLength([0, 1, 0, 1]) == 4 >>> findMaxLength([0, 0, 0, 0, 0]) == 0 >>> findMaxLength([1, 1, 1, 1, 1]) == 0 >>> findMaxLength([0, 1, 0]) == 2 >>> findMaxLength([0, 1, 1, 0, 1, 1, 1, 0]) == 4 >>> findMaxLength([0, 1, 1, 0, 0, 1, 0]) == 6","solution":"def findMaxLength(nums): count = 0 count_map = {0: -1} max_length = 0 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def longest_binary_gap(n: int) -> int: Returns the length of the longest binary gap within a positive integer n. >>> longest_binary_gap(9) == 2 # 1001 >>> longest_binary_gap(529) == 4 # 1000010001 >>> longest_binary_gap(15) == 0 # 1111 >>> longest_binary_gap(32) == 0 # 100000 >>> longest_binary_gap(1041) == 5 # 10000010001","solution":"def longest_binary_gap(n): Returns the length of the longest binary gap within a positive integer n. # Convert the number to its binary representation binary_representation = bin(n)[2:] # Split the binary representation by '1' to find the gaps gaps = binary_representation.strip('0').split('1') # The length of each gap is the length of each element in \`gaps\` gap_lengths = [len(gap) for gap in gaps] # Return the maximum gap length or 0 if no gaps are found return max(gap_lengths) if gap_lengths else 0"},{"question":"from typing import List def findRedundantConnection(edges: List[List[int]]) -> List[int]: Find an edge in an undirected graph that can be removed so that the resulting graph is still connected and has no cycles. >>> findRedundantConnection([[1, 2], [1, 3], [2, 3]]) [2, 3] >>> findRedundantConnection([[1, 2], [2, 3], [3, 4], [1, 4], [1, 5]]) [1, 4] >>> findRedundantConnection([[1, 2], [1, 3], [2, 3], [4, 1], [5, 1], [6, 2]]) [2, 3] >>> findRedundantConnection([[1, 2], [1, 3], [1, 4], [4, 5], [2, 5]]) [2, 5] >>> findRedundantConnection([[1, 4], [3, 4], [1, 3], [1, 2], [4, 5]]) [1, 3] pass","solution":"def findRedundantConnection(edges): Find the redundant connection in the graph that can be removed so that the resulting graph is still connected and has no cycles. :param edges: List of edges in the graph. :return: The edge that is redundant. parent = list(range(len(edges) + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX == rootY: return False parent[rootX] = rootY return True for edge in edges: if not union(edge[0], edge[1]): return edge"},{"question":"def shortest_palindrome_length(s: str) -> int: Returns the length of the shortest palindrome that can be done by adding characters in front of the string s. >>> shortest_palindrome_length(\\"level\\") # 5 >>> shortest_palindrome_length(\\"racecar\\") # 7 >>> shortest_palindrome_length(\\"race\\") # 7 >>> shortest_palindrome_length(\\"abc\\") # 5 >>> shortest_palindrome_length(\\"abca\\") # 7 >>> shortest_palindrome_length(\\"a\\") # 1 >>> shortest_palindrome_length(\\"\\") # 0","solution":"def shortest_palindrome_length(s): Returns the length of the shortest palindrome that can be done by adding characters in front of the string s. if s == s[::-1]: return len(s) # Find the longest palindromic prefix for i in range(len(s), -1, -1): if s[:i] == s[:i][::-1]: break # Number of characters that need to be added in the front to make it a palindrome return 2 * len(s) - i"},{"question":"def maxProfit(k: int, prices: List[int]) -> int: You are given a 0-indexed integer array prices where prices[i] represents the price of a ticket on day i. There is also a positive integer k. You want to buy and sell tickets in such a way that you maximize your profit, given the following conditions: - You can complete at most k transactions. - A transaction is defined as buying a ticket on one day and selling it on a later day. - You cannot engage in multiple transactions simultaneously (i.e., you must sell the ticket before you buy another one). Return the maximum profit you can achieve under these conditions. >>> maxProfit(2, [3, 3]) 0 >>> maxProfit(2, []) 0 >>> maxProfit(1, [1, 2, 3, 4, 5]) 4 >>> maxProfit(2, [3, 2, 6, 5, 0, 3]) 7 >>> maxProfit(100, [1, 2, 3, 4, 5]) 4 >>> maxProfit(100, [3, 2, 6, 5, 0, 3]) 7 >>> maxProfit(2, [5, 2, 4, 0, 1]) 3 >>> maxProfit(3, [7, 1, 5, 3, 6, 4]) 7 >>> maxProfit(2, [1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) 13","solution":"def maxProfit(k, prices): n = len(prices) if n == 0: return 0 if k >= n // 2: return sum(x - y for x, y in zip(prices[1:], prices[:-1]) if x > y) profits = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_profit_so_far = -prices[0] for j in range(1, n): profits[i][j] = max(profits[i][j - 1], prices[j] + max_profit_so_far) max_profit_so_far = max(max_profit_so_far, profits[i - 1][j] - prices[j]) return profits[k][n - 1]"},{"question":"from typing import List def is_palindrome(s: str) -> bool: Helper function to check if a given string is a palindrome. return s == s[::-1] def longest_valid_prefix_palindrome(words: List[str]) -> List[int]: For each string in the list, identify the length of the longest \\"valid prefix palindrome\\". >>> longest_valid_prefix_palindrome([\\"abba\\"]) == [4] >>> longest_valid_prefix_palindrome([\\"abc\\"]) == [1] >>> longest_valid_prefix_palindrome([\\"\\"]) == [0] >>> longest_valid_prefix_palindrome([\\"a\\", \\"racecar\\", \\"banana\\"]) == [1, 7, 1] >>> longest_valid_prefix_palindrome([\\"rotor\\", \\"wow\\", \\"live\\"]) == [5, 3, 1] >>> longest_valid_prefix_palindrome([\\"abcdef\\", \\"ghijkl\\"]) == [1, 1]","solution":"def is_palindrome(s): Helper function to check if a given string is a palindrome. return s == s[::-1] def longest_valid_prefix_palindrome(words): For each word in the list, find the length of the longest valid prefix palindrome. result = [] for word in words: max_length = 0 for i in range(len(word) + 1): if is_palindrome(word[:i]): max_length = i result.append(max_length) return result"},{"question":"def minimize_max_distance(nums: List[int], k: int) -> float: Determine the optimal location for a new store such that the maximum distance any store has to travel to reach the nearest store is minimized. Parameters: nums (list of int): Locations of existing stores on the street. k (int): Number of new stores to be built. Returns: float: The minimum possible maximum distance to the nearest store. >>> minimize_max_distance([1, 10], 1) 4.5 >>> minimize_max_distance([1, 3, 8, 12], 1) 2.5 >>> minimize_max_distance([1, 2, 3, 4, 5], 1) 0.5 >>> minimize_max_distance([1, 10, 20], 1) 5.0 >>> minimize_max_distance([5], 1) 0.0","solution":"def minimize_max_distance(nums, k): Determine the optimal location for a new store such that the maximum distance any store has to travel to reach the nearest store is minimized. Parameters: nums (list of int): Locations of existing stores on the street. k (int): Number of new stores to be built, k is assumed to be 1. Returns: float: The minimum possible maximum distance to the nearest store. sorted_nums = sorted(nums) max_distance = 0 for i in range(len(sorted_nums) - 1): distance = (sorted_nums[i + 1] - sorted_nums[i]) / 2.0 max_distance = max(max_distance, distance) return max_distance"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"bbbbbb\\") 1 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"aabaab!bb\\") 3 >>> length_of_longest_substring(\\"!@#%\\") 5 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\" * 10) 26","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_index_map: left = max(char_index_map[s[right]] + 1, left) char_index_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"import re from typing import List def is_palindrome(s: str) -> bool: Checks if the given string is a valid palindrome, ignoring cases, punctuation, and spaces. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"A\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"A Santa at NASA\\") True >>> is_palindrome(\\"Hello, World!\\") False","solution":"import re def is_palindrome(s): Checks if the given string is a valid palindrome, ignoring cases, punctuation, and spaces. # Remove all non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_str == cleaned_str[::-1]"},{"question":"from typing import List def min_chocolates(ratings: List[int]) -> int: Calculate the minimum number of chocolates to distribute to employees based on their ratings to ensure that each employee gets at least one chocolate and employees with a higher rating get more chocolates than their neighbors. :param ratings: List[int], list of positive integers representing employee ratings :return: int, the minimum number of chocolates to distribute >>> min_chocolates([1, 2, 3, 4, 5]) == 15 >>> min_chocolates([5, 4, 3, 2, 1]) == 15 >>> min_chocolates([1, 2, 2]) == 4 >>> min_chocolates([1, 0, 2]) == 5","solution":"def min_chocolates(ratings): Calculate the minimum number of chocolates to distribute to employees based on their ratings to ensure that each employee gets at least one chocolate and employees with a higher rating get more chocolates than their neighbors. :param ratings: List[int], list of positive integers representing employee ratings :return: int, the minimum number of chocolates to distribute n = len(ratings) chocolates = [1] * n # Left to right pass, ensuring ratings[i] > ratings[i-1] => chocolates[i] > chocolates[i-1] for i in range(1, n): if ratings[i] > ratings[i - 1]: chocolates[i] = chocolates[i - 1] + 1 # Right to left pass, ensuring ratings[i] > ratings[i + 1] => chocolates[i] > chocolates[i + 1] for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: chocolates[i] = max(chocolates[i], chocolates[i + 1] + 1) return sum(chocolates)"},{"question":"def is_path_possible(grid, start_row, start_col, target_row, target_col): Determines if there is a path for a robot to move from the start position to the target position in a 2D grid. The robot can move one step at a time in four directions (up, down, left, right) but cannot move diagonally or off the grid. Some cells in the grid are blocked (represented by 0) and cannot be traversed, while others are open (represented by 1). Return true if there is a path from the start to the target, otherwise, return false. :param grid: 2D list of integers (0 = blocked, 1 = open) :param start_row: Starting row coordinate :param start_col: Starting column coordinate :param target_row: Target row coordinate :param target_col: Target column coordinate :return: True if there is a path from start to target, otherwise False import pytest def test_start_is_target(): grid = [[1, 1], [1, 1]] assert is_path_possible(grid, 0, 0, 0, 0) == True def test_simple_path(): grid = [[1, 0], [1, 1]] assert is_path_possible(grid, 0, 0, 1, 1) == True def test_blocked_path(): grid = [[1, 0], [0, 1]] assert is_path_possible(grid, 0, 0, 1, 1) == False def test_edge_case_no_grid(): grid = [] assert is_path_possible(grid, 0, 0, 0, 0) == False def test_edge_case_invalid_start(): grid = [[1, 1], [1, 1]] assert is_path_possible(grid, -1, 0, 1, 1) == False assert is_path_possible(grid, 0, -1, 1, 1) == False def test_edge_case_invalid_target(): grid = [[1, 1], [1, 1]] assert is_path_possible(grid, 0, 0, 2, 0) == False assert is_path_possible(grid, 0, 0, 0, 2) == False def test_start_or_target_blocked(): grid = [[0, 1], [1, 1]] assert is_path_possible(grid, 0, 0, 1, 1) == False grid = [[1, 1], [1, 0]] assert is_path_possible(grid, 0, 0, 1, 1) == False def test_complex_path(): grid = [ [1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 1, 1], [0, 0, 1, 1] ] assert is_path_possible(grid, 0, 0, 3, 3) == True def test_no_possible_path(): grid = [ [1, 0, 0], [0, 1, 0], [0, 0, 1], ] assert is_path_possible(grid, 0, 0, 2, 2) == False","solution":"def is_path_possible(grid, start_row, start_col, target_row, target_col): Determines if there is a path for a robot to move from the start position to the target position in a 2D grid. :param grid: 2D list of integers (0 = blocked, 1 = open) :param start_row: Starting row coordinate :param start_col: Starting column coordinate :param target_row: Target row coordinate :param target_col: Target column coordinate :return: True if there is a path from start to target, otherwise False if not grid or not grid[0]: return False m, n = len(grid), len(grid[0]) if not (0 <= start_row < m and 0 <= start_col < n): return False if not (0 <= target_row < m and 0 <= target_col < n): return False if grid[start_row][start_col] == 0 or grid[target_row][target_col] == 0: return False directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * n for _ in range(m)] def dfs(r, c): if r == target_row and c == target_col: return True visited[r][c] = True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and grid[nr][nc] == 1: if dfs(nr, nc): return True visited[r][c] = False return False return dfs(start_row, start_col)"},{"question":"def min_trips(weights: List[int], maxLoad: int) -> int: Returns the minimum number of trips required to transport all the packages. :param weights: List[int] - A list of weights of the packages. :param maxLoad: int - The maximum load the truck can carry in each trip. :return: int - The minimum number of trips required. >>> min_trips([1, 2, 3, 4, 5], 5) == 3 >>> min_trips([1, 1, 2, 2, 3], 3) == 3 >>> min_trips([5, 5, 5, 5, 5], 5) == 5 >>> min_trips([4, 4, 4, 6, 6, 6], 10) == 3 >>> min_trips([3, 2, 2, 1], 4) == 2","solution":"def min_trips(weights, maxLoad): Returns the minimum number of trips required to transport all the packages. :param weights: List[int] - A list of weights of the packages. :param maxLoad: int - The maximum load the truck can carry in each trip. :return: int - The minimum number of trips required. # Sort the weights in descending order to try and optimize the number of trips weights.sort(reverse=True) trips = 0 # While there are weights left to transport while weights: remaining_load = maxLoad i = 0 # Pick as many packages as possible for the current trip while i < len(weights): if weights[i] <= remaining_load: remaining_load -= weights.pop(i) else: i += 1 trips += 1 return trips"},{"question":"def evaluate_expression(exp: str) -> int: Evaluates a mathematical expression containing non-negative integers, parentheses, and operators + and *. It respects the usual rules of arithmetic precedence. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"2*3\\") == 6 >>> evaluate_expression(\\"2+3*2\\") == 8 >>> evaluate_expression(\\"(2+3)*2\\") == 10 >>> evaluate_expression(\\"((2+3)*2)*2\\") == 20 >>> evaluate_expression(\\"2+((3*4)+5)*2\\") == 36 >>> evaluate_expression(\\"\\") == 0","solution":"def evaluate_expression(exp): Evaluates a mathematical expression containing non-negative integers, parentheses, and operators + and *. It respects the usual rules of arithmetic precedence. def helper(tokens): stack = [] num = 0 op = \\"+\\" while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == \\"(\\": num = helper(tokens) if token in \\"+*)\\" or len(tokens) == 0: if op == \\"+\\": stack.append(num) elif op == \\"*\\": stack[-1] *= num op = token num = 0 if token == \\")\\": break return sum(stack) tokens = [] i = 0 while i < len(exp): if exp[i].isdigit(): j = i while j < len(exp) and exp[j].isdigit(): j += 1 tokens.append(exp[i:j]) i = j else: tokens.append(exp[i]) i += 1 return helper(tokens)"},{"question":"def shortest_prefix_palindrome_length(s: str) -> int: Return the length of the shortest prefix palindrome that can be obtained by adding characters to the end of the string \`s\`. >>> shortest_prefix_palindrome_length(\\"aacecaaa\\") 9 >>> shortest_prefix_palindrome_length(\\"abcd\\") 7 >>> shortest_prefix_palindrome_length(\\"racecar\\") 7 >>> shortest_prefix_palindrome_length(\\"a\\") 1 >>> shortest_prefix_palindrome_length(\\"\\") 0 >>> shortest_prefix_palindrome_length(\\"aa\\") 2 >>> shortest_prefix_palindrome_length(\\"ab\\") 3","solution":"def shortest_prefix_palindrome_length(s): Returns the length of the shortest prefix palindrome that can be obtained by adding characters to the end of the string s. n = len(s) reverse_s = s[::-1] # Check for the longest prefix palindrome that we can keep for i in range(n): if s[:n-i] == reverse_s[i:]: return 2 * n - (n - i) return 2 * n"},{"question":"def smallest_largest_element(arr, n): Returns the smallest possible value of the largest element in the array after performing exactly n operations of removing the smaller one of any two adjacent elements. pass # Unit tests def test_basic_cases(): assert smallest_largest_element([8, 9, 4, 5, 6], 3) == 9 assert smallest_largest_element([1, 2, 3, 4, 5], 2) == 5 assert smallest_largest_element([10, 3, 5, 8, 6], 1) == 10 def test_all_elements_equal(): assert smallest_largest_element([4, 4, 4, 4, 4], 3) == 4 def test_small_array(): assert smallest_largest_element([2, 1], 1) == 2 def test_no_operations(): assert smallest_largest_element([3, 1, 2, 4], 0) == 4 def test_large_n_value(): assert smallest_largest_element([5, 10, 5, 3, 8], 4) == 10 def test_invalid_n_value(): assert smallest_largest_element([5, 1, 2], 5) == -1","solution":"def smallest_largest_element(arr, n): Returns the smallest possible value of the largest element in the array after performing exactly n operations of removing the smaller one of any two adjacent elements. if n >= len(arr): return -1 # In case n is greater or equal to the array length (which is invalid input) for _ in range(n): temp_max = float('inf') index_to_remove = -1 for i in range(len(arr) - 1): if max(arr[i], arr[i + 1]) < temp_max: temp_max = max(arr[i], arr[i + 1]) index_to_remove = i if arr[i] <= arr[i + 1] else i + 1 if index_to_remove != -1: arr.pop(index_to_remove) return max(arr)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root: TreeNode) -> str: Serializes a BST to a string. pass def deserialize(data: str) -> TreeNode: Deserializes a string to a BST. pass def test_serialize_deserialize(): root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) serialized = serialize(root) assert serialized == \\"2 1 # # 3 # #\\" deserialized = deserialize(serialized) assert deserialized.val == 2 assert deserialized.left.val == 1 assert deserialized.right.val == 3 assert deserialized.left.left == None assert deserialized.left.right == None assert deserialized.right.left == None assert deserialized.right.right == None def test_serialize_deserialize_empty_tree(): root = None serialized = serialize(root) assert serialized == \\"#\\" deserialized = deserialize(serialized) assert deserialized == None def test_serialize_deserialize_single_node(): root = TreeNode(1) serialized = serialize(root) assert serialized == \\"1 # #\\" deserialized = deserialize(serialized) assert deserialized.val == 1 assert deserialized.left == None assert deserialized.right == None def test_serialize_deserialize_complex_tree(): root = TreeNode(5) root.left = TreeNode(3) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right = TreeNode(7) root.right.left = TreeNode(6) root.right.right = TreeNode(8) serialized = serialize(root) assert serialized == \\"5 3 2 # # 4 # # 7 6 # # 8 # #\\" deserialized = deserialize(serialized) assert deserialized.val == 5 assert deserialized.left.val == 3 assert deserialized.left.left.val == 2 assert deserialized.left.right.val == 4 assert deserialized.right.val == 7 assert deserialized.right.left.val == 6 assert deserialized.right.right.val == 8","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Serializes a BST to a string. values = [] def preorder(node): if node: values.append(str(node.val)) preorder(node.left) preorder(node.right) else: values.append('#') preorder(root) return ' '.join(values) def deserialize(data): Deserializes a string to a BST. values = iter(data.split()) def build(): val = next(values) if val == '#': return None node = TreeNode(int(val)) node.left = build() node.right = build() return node return build()"},{"question":"def min_cost_to_make_equal(s: str) -> int: Returns the minimum cost to make all characters in the string \`s\` equal. >>> min_cost_to_make_equal('a') 0 >>> min_cost_to_make_equal('ab') 1 >>> min_cost_to_make_equal('abc') 2 >>> min_cost_to_make_equal('a' * 1000 + 'b' * 1000) 1000","solution":"def min_cost_to_make_equal(s): Returns the minimum cost to make all characters in the string \`s\` equal. def char_to_index(c): return ord(c) - ord('a') + 1 # Create a list of indexes of characters in the string indices = [char_to_index(c) for c in s] min_cost = float('inf') # Try to make all characters equal to each character from 'a' to 'z' for target in range(1, 27): cost = sum(abs(target - idx) for idx in indices) min_cost = min(min_cost, cost) return min_cost"},{"question":"def min_lex_rotation(s: str) -> str: Returns the lexicographically smallest string obtained by rotating string s. >>> min_lex_rotation(\\"a\\") == \\"a\\" >>> min_lex_rotation(\\"bbb\\") == \\"bbb\\" >>> min_lex_rotation(\\"abc\\") == \\"abc\\" >>> min_lex_rotation(\\"cba\\") == \\"acb\\" >>> min_lex_rotation(\\"cabcab\\") == \\"abcabc\\" >>> min_lex_rotation(\\"racecar\\") == \\"acecarr\\"","solution":"def min_lex_rotation(s): Returns the lexicographically smallest string obtained by rotating string s. n = len(s) rotations = [s[i:] + s[:i] for i in range(n)] return min(rotations)"},{"question":"from typing import List def largestSimilarWordsGroup(words: List[str]) -> int: You are given a \`words\` array containing strings of equal length \`n\`. Two words are considered **similar** if they differ by at most two characters. Find the largest group of similar words in the array. Return the size of this largest group. Note that for a pair of words to be considered similar, their difference in characters is measured position-wise (i.e., the number of positions at which the corresponding characters of the two words are different). >>> largestSimilarWordsGroup([]) 0 >>> largestSimilarWordsGroup([\\"hello\\"]) 1 >>> largestSimilarWordsGroup([\\"abcd\\", \\"abcf\\", \\"abff\\", \\"abce\\"]) 4 >>> largestSimilarWordsGroup([\\"abcd\\", \\"abcf\\", \\"mnop\\", \\"mnpp\\"]) 2 >>> largestSimilarWordsGroup([\\"abcd\\", \\"abcf\\", \\"mnop\\", \\"mnpp\\", \\"aecd\\"]) 3 >>> largestSimilarWordsGroup([\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) 1 >>> largestSimilarWordsGroup([\\"aaaa\\", \\"aaab\\", \\"aabb\\", \\"abbb\\", \\"baaa\\", \\"bbaa\\", \\"bbab\\", \\"bbbb\\", \\"cccc\\", \\"cccd\\", \\"ccdd\\", \\"cddd\\"]) 8","solution":"from collections import deque def differByAtMostTwo(word1, word2): Return True if words differ by at most 2 characters. diff_count = 0 for c1, c2 in zip(word1, word2): if c1 != c2: diff_count += 1 if diff_count > 2: return False return True def bfs(words, start, visited): Perform BFS to find the size of the connected component of similar words. Args: - words: list of words - start: starting index - visited: list to keep track of visited nodes Return the size of the connected component. queue = deque([start]) visited[start] = True component_size = 0 while queue: current = queue.popleft() component_size += 1 for i, word in enumerate(words): if not visited[i] and differByAtMostTwo(words[current], word): queue.append(i) visited[i] = True return component_size def largestSimilarWordsGroup(words): Find the size of the largest group of similar words. n = len(words) visited = [False] * n max_group_size = 0 for i in range(n): if not visited[i]: max_group_size = max(max_group_size, bfs(words, i, visited)) return max_group_size"},{"question":"def four_sum_exists(arr: List[int], target: int) -> bool: Determine if there exist four distinct elements in \`arr\` that sum up to \`target\`. Args: arr (List[int]): The list of integers. target (int): The target sum for the quadruplet. Returns: bool: True if there is a quadruplet that sums up to the target, False otherwise. >>> four_sum_exists([1, 0, -1, 0, -2, 2], 0) True >>> four_sum_exists([1, 2, 3, 4, 5], 100) False >>> four_sum_exists([1, 2, 2, 2, -1], 5) True >>> four_sum_exists([-1, -2, -3, -4, -5], -10) True >>> four_sum_exists([1, 3, 5, 7, 9], 8) False >>> four_sum_exists([0, 0, 0, 0, 1], 0) True >>> four_sum_exists(list(range(1000)), 1996) True","solution":"def four_sum_exists(arr, target): arr.sort() n = len(arr) for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[j] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def reduce_string_length(s: str) -> int: Given a string \`s\` containing only the characters \`'a'\`, \`'b'\`, and \`'c'\`, delete any two adjacent characters in the string that are different and return the length of the shortest string possible after performing any number of deletions. >>> reduce_string_length(\\"\\") 0 >>> reduce_string_length(\\"a\\") 1 >>> reduce_string_length(\\"ab\\") 0 >>> reduce_string_length(\\"abbacca\\") 1","solution":"def reduce_string_length(s): Returns the length of the shortest string possible by performing any number of deletions of two adjacent characters that are different. Parameters: s (str): input string containing only 'a', 'b' and 'c' Returns: int: shortest possible length of the string stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def minimize_unique_events(timeIntervals, k): Returns the minimum number of unique events after merging events which differ in duration by no more than k minutes. Parameters: timeIntervals (list of int): List of event durations. k (int): Maximum allowed difference to merge two events. Returns: int: Minimum number of unique events after merging. from minimize_unique_events import minimize_unique_events def test_example_case(): assert minimize_unique_events([30, 40, 20, 90, 10], 15) == 3 def test_all_events_mergable(): assert minimize_unique_events([5, 10, 15], 10) == 1 def test_no_merge_possible(): assert minimize_unique_events([5, 15, 30], 5) == 3 def test_empty_list(): assert minimize_unique_events([], 10) == 0 def test_single_element(): assert minimize_unique_events([10], 5) == 1 def test_adjacent_merging(): assert minimize_unique_events([1, 2, 3, 10, 11, 12], 2) == 2 def test_large_k(): assert minimize_unique_events([1, 100, 200, 300, 400], 500) == 1","solution":"def minimize_unique_events(timeIntervals, k): Returns the minimum number of unique events after merging events which differ in duration by no more than k minutes. Parameters: timeIntervals (list of int): List of event durations. k (int): Maximum allowed difference to merge two events. Returns: int: Minimum number of unique events after merging. if not timeIntervals: return 0 # Sort the intervals to try merging adjacent events first timeIntervals.sort() unique_events = 1 # There is at least one event # Keep the duration of the last merged event last_merged = timeIntervals[0] for i in range(1, len(timeIntervals)): if timeIntervals[i] - last_merged > k: unique_events += 1 last_merged = timeIntervals[i] return unique_events"},{"question":"def get_viewpoints(heights: List[int]) -> List[int]: Returns a list of indices of viewpoint buildings in ascending order. A building at index i is considered a viewpoint if it has an unobstructed view of the skyline to its right. >>> get_viewpoints([4, 2, 3, 1]) [0, 2, 3] >>> get_viewpoints([2, 2, 2, 2]) [3] >>> get_viewpoints([1, 2, 3, 4]) [3] >>> get_viewpoints([4, 3, 2, 1]) [0, 1, 2, 3] >>> get_viewpoints([5]) [0] >>> get_viewpoints([]) []","solution":"def get_viewpoints(heights): Returns a list of indices of viewpoint buildings in ascending order. A building at index i is considered a viewpoint if it has an unobstructed view of the skyline to its right. viewpoints = [] max_height_to_the_right = 0 # Iterate from the end of the list to the beginning for i in reversed(range(len(heights))): if heights[i] > max_height_to_the_right: viewpoints.append(i) max_height_to_the_right = heights[i] # Return the indices in ascending order return sorted(viewpoints)"},{"question":"from collections import deque from typing import List def shortestPathToTreasure(grid: List[List[int]]) -> int: Returns the shortest path length to the nearest treasure in a given 2D grid. If there's no path to any treasure, returns -1. >>> shortestPathToTreasure([[1, 1, 1], [0, 0, 1], [1, 1, 1]]) == -1 >>> shortestPathToTreasure([[2, 0, 1], [0, 1, 1], [1, 1, 1]]) == 0 >>> shortestPathToTreasure([[1, 0, 1], [1, 1, 1], [1, 2, 1]]) == 3 >>> shortestPathToTreasure([[1, 1, 1, 2], [1, 0, 1, 0], [1, 1, 1, 1]]) == 3 >>> shortestPathToTreasure([[0, 0, 0], [0, 2, 1], [1, 1, 1]]) == -1","solution":"from collections import deque def shortestPathToTreasure(grid): Returns the shortest path length to the nearest treasure in a given 2D grid. If there's no path to any treasure, returns -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if grid[x][y] == 2: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != 0: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def get_pascals_triangle_row(n: int) -> List[int]: Returns the nth row of Pascal's triangle (0-indexed). >>> get_pascals_triangle_row(0) [1] >>> get_pascals_triangle_row(1) [1, 1] >>> get_pascals_triangle_row(2) [1, 2, 1] >>> get_pascals_triangle_row(3) [1, 3, 3, 1] >>> get_pascals_triangle_row(4) [1, 4, 6, 4, 1] >>> get_pascals_triangle_row(5) [1, 5, 10, 10, 5, 1] >>> get_pascals_triangle_row(10) [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1]","solution":"def get_pascals_triangle_row(n): Returns the nth row of Pascal's triangle (0-indexed). if n == 0: return [1] row = [1] for k in range(1, n + 1): row.append(row[-1] * (n - k + 1) // k) return row"},{"question":"import random class RandomizedSet: Implement a data structure that supports the following operations: insert, delete, getRandomElement, and each of these operations should be O(1) on average. The data structure will store integers. - \`insert(int val)\`: Inserts a value into the data structure. - \`delete(int val)\`: Deletes a value from the data structure. - \`getRandomElement()\`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Example usage: >>> rs = RandomizedSet() >>> rs.insert(1) # True >>> rs.insert(1) # False >>> rs.insert(2) # True >>> rs.delete(1) # True >>> rs.delete(1) # False >>> rs.getRandomElement() # 2 (or another number in the set if it was inserted) def __init__(self): pass def insert(self, val: int) -> bool: pass def delete(self, val: int) -> bool: pass def getRandomElement(self) -> int: pass def test_insert(): rs = RandomizedSet() assert rs.insert(1) assert not rs.insert(1) assert rs.insert(2) def test_delete(): rs = RandomizedSet() assert not rs.delete(1) rs.insert(1) assert rs.delete(1) assert not rs.delete(1) def test_getRandomElement(): rs = RandomizedSet() rs.insert(1) rs.insert(2) rs.insert(3) result = rs.getRandomElement() assert result in {1, 2, 3} def test_mix_operations(): rs = RandomizedSet() assert rs.insert(1) assert rs.insert(2) assert rs.insert(3) assert rs.delete(2) assert rs.insert(4) assert rs.getRandomElement() in {1, 3, 4} assert not rs.insert(1) assert rs.delete(1) assert rs.getRandomElement() in {3, 4}","solution":"import random class RandomizedSet: def __init__(self): self.data = [] self.val_to_index = {} def insert(self, val: int) -> bool: if val in self.val_to_index: return False self.val_to_index[val] = len(self.data) self.data.append(val) return True def delete(self, val: int) -> bool: if val not in self.val_to_index: return False index = self.val_to_index[val] last_val = self.data[-1] self.data[index] = last_val self.val_to_index[last_val] = index self.data.pop() del self.val_to_index[val] return True def getRandomElement(self) -> int: return random.choice(self.data)"},{"question":"def find_fixed_point(arr: List[int]) -> int: Given a sorted array of distinct integers \`arr\`, find a fixed point in the array, if one exists. A fixed point is an index \`i\` where \`arr[i] == i\`. Return the index if a fixed point is found, otherwise return -1. The function must solve it in \`O(log n)\` time complexity. Parameters: arr (list): A sorted array of distinct integers. Returns: int: The index where arr[i] == i, or -1 if no such index exists. >>> find_fixed_point([-10, -5, 0, 3, 7]) 3 >>> find_fixed_point([-10, -5, 2, 3, 7]) 2 >>> find_fixed_point([-10, -5, 1, 4, 7]) -1 >>> find_fixed_point([0]) 0 >>> find_fixed_point([1]) -1","solution":"def find_fixed_point(arr): Function to find a fixed point in a sorted array of distinct integers. Parameters: arr (list): A sorted array of distinct integers. Returns: int: The index where arr[i] == i, or -1 if no such index exists. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == mid: return mid elif arr[mid] < mid: left = mid + 1 else: right = mid - 1 return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_path(root): Determine the length of the longest path in the binary tree such that the values along the path form an increasing sequence. The path does not necessarily need to start from the root. Args: root (TreeNode): The root of the binary tree. Returns: int: The length of the longest increasing path. Examples: >>> root = TreeNode(3) >>> root.left = TreeNode(2) >>> root.right = TreeNode(4) >>> root.right.left = TreeNode(5) >>> root.right.right = TreeNode(1) >>> longest_increasing_path(root) 3 >>> root = TreeNode(1) >>> longest_increasing_path(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> longest_increasing_path(root) 1 pass def test_example_tree(): root = TreeNode(3) root.left = TreeNode(2) root.right = TreeNode(4) root.right.left = TreeNode(5) root.right.right = TreeNode(1) assert longest_increasing_path(root) == 3 # Path: 3 -> 4 -> 5 def test_single_node_tree(): root = TreeNode(1) assert longest_increasing_path(root) == 1 # Only one node def test_all_nodes_same_value(): root = TreeNode(1) root.left = TreeNode(1) root.right = TreeNode(1) assert longest_increasing_path(root) == 1 # Path: Any single node def test_decreasing_values(): root = TreeNode(4) root.left = TreeNode(3) root.left.left = TreeNode(1) root.right = TreeNode(2) assert longest_increasing_path(root) == 1 # No increasing path def test_complex_tree(): root = TreeNode(5) root.left = TreeNode(4) root.left.left = TreeNode(3) root.right = TreeNode(8) root.right.left = TreeNode(7) root.right.right = TreeNode(9) root.right.right.right = TreeNode(10) assert longest_increasing_path(root) == 4 # Path: 5 -> 8 -> 9 -> 10","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_path(root): def dfs(node, prev_val): if not node: return 0 left = dfs(node.left, node.val) right = dfs(node.right, node.val) return max(left, right) + 1 if node.val > prev_val else 0 def traverse_and_find(node): if not node: return 0 left_length = traverse_and_find(node.left) right_length = traverse_and_find(node.right) current_length = dfs(node, float('-inf')) return max(left_length, right_length, current_length) return traverse_and_find(root)"},{"question":"from typing import List def shortestBridge(grid: List[List[int]]) -> int: Given a 2D grid grid of size m x n composed of characters '0' and '1', where '1' represents land and '0' represents water, find the length of the shortest bridge between two islands of land. The length of the bridge is the number of '0's you must flip to connect the two islands. >>> shortestBridge([[0, 1], [1, 0]]) 1 >>> shortestBridge([[0, 1, 0], [0, 0, 0], [0, 0, 1]]) 2 >>> shortestBridge([[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]) 1 >>> shortestBridge([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0]]) 2 >>> shortestBridge([[1, 0, 0, 1, 0], [0, 0, 0, 0, 0], [1, 0, 0, 1, 0]]) 1","solution":"from collections import deque def shortestBridge(grid): m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def bfs(queue): while queue: x, y, d = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: if grid[nx][ny] == 1: return d queue.append((nx, ny, d + 1)) visited[nx][ny] = True return -1 def dfs(x, y, queue): if 0 <= x < m and 0 <= y < n and grid[x][y] == 1 and not visited[x][y]: visited[x][y] = True queue.append((x, y, 0)) for dx, dy in directions: dfs(x + dx, y + dy, queue) visited = [[False] * n for _ in range(m)] queue = deque() found = False for i in range(m): for j in range(n): if grid[i][j] == 1: dfs(i, j, queue) found = True break if found: break return bfs(queue)"},{"question":"def kthSmallest(mat: List[List[int]], k: int) -> int: Returns the kth smallest element in the n x n matrix mat where each of the rows and columns is sorted in ascending order. >>> matrix1 = [[1, 5, 9], [10, 11, 13], [12, 13, 15]] >>> kthSmallest(matrix1, 8) 13 >>> matrix2 = [[1, 2], [1, 3]] >>> kthSmallest(matrix2, 2) 1 >>> matrix3 = [[1, 2], [3, 4]] >>> kthSmallest(matrix3, 3) 3 >>> matrix4 = [[10, 20, 30, 40], [15, 25, 35, 45], [24, 29, 37, 48], [32, 33, 39, 50]] >>> kthSmallest(matrix4, 7) 30 >>> matrix5 = [[1, 3, 5], [6, 7, 12], [11, 14, 14]] >>> kthSmallest(matrix5, 6) 11","solution":"import heapq def kthSmallest(mat, k): Returns the kth smallest element in the n x n matrix mat where each of the rows and columns is sorted in ascending order. n = len(mat) min_heap = [(mat[0][0], 0, 0)] visited = set((0, 0)) for _ in range(k - 1): val, x, y = heapq.heappop(min_heap) if x + 1 < n and (x + 1, y) not in visited: visited.add((x + 1, y)) heapq.heappush(min_heap, (mat[x + 1][y], x + 1, y)) if y + 1 < n and (x, y + 1) not in visited: visited.add((x, y + 1)) heapq.heappush(min_heap, (mat[x][y + 1], x, y + 1)) return heapq.heappop(min_heap)[0]"},{"question":"def count_anagrams(words: List[str], target: str) -> int: Returns the number of strings in words that can be rearranged to match target. >>> count_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\") == 0 >>> count_anagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"yzx\\"], \\"cab\\") == 3 >>> count_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"tinsel\\"], \\"inlets\\") == 4 >>> count_anagrams([\\"aabbcc\\", \\"bbaacc\\", \\"ccccbb\\"], \\"ccbbaa\\") == 2 >>> count_anagrams([], \\"abc\\") == 0 >>> count_anagrams([\\"abc\\", \\"def\\"], \\"\\") == 0 >>> count_anagrams([\\"\\", \\"abc\\", \\"\\"], \\"\\") == 2 >>> count_anagrams([\\"abc\\"], \\"cab\\") == 1","solution":"def count_anagrams(words, target): Returns the number of strings in words that can be rearranged to match target. from collections import Counter target_counter = Counter(target) # Count the frequency of each character in the target count = 0 for word in words: word_counter = Counter(word) if word_counter == target_counter: count += 1 return count"},{"question":"def trap(height: List[int]) -> int: Given an array of integers \`height\` representing a terrain, compute the maximum amount of water that can be trapped after raining. :param height: List[int] - An array representing the height of the terrain at each point. :return: int - The maximum amount of water that can be trapped. >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([1, 3, 2, 4, 1, 3, 1, 4, 5]) == 8 >>> trap([5, 2, 1, 2, 1, 5]) == 14 >>> trap([100000, 0, 100000]) == 100000 >>> trap([1, 2]) == 0 >>> trap([3, 3, 3, 3, 3]) == 0 >>> trap([3, 0, 2, 0, 4]) == 7 >>> trap([4, 2, 3]) == 1 >>> trap([5, 4, 3, 2, 1, 2, 3, 4, 5]) == 16 >>> trap([1] + [0]*998 + [1]) == 998","solution":"def trap(height): Given an array of integers \`height\` representing a terrain, compute the maximum amount of water that can be trapped after raining. :param height: List[int] - An array representing the height of the terrain at each point. :return: int - The maximum amount of water that can be trapped. if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"from typing import List def find_substrings(s: str, words: List[str]) -> List[int]: Find all starting indices of substrings in \`s\` that are concatenations of each word in \`words\` exactly once. >>> find_substrings(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> find_substrings(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) [] >>> find_substrings(\\"barfoofoobarthefoobarman\\", [\\"bar\\", \\"foo\\", \\"the\\"]) [6, 9, 12] >>> find_substrings(\\"abcabcabc\\", [\\"abc\\"]) [0, 3, 6] >>> find_substrings(\\"abcdef\\", [\\"ghijk\\"]) [] # Your code here","solution":"def find_substrings(s, words): from collections import defaultdict, Counter word_len = len(words[0]) total_len = word_len * len(words) words_count = Counter(words) results = [] for i in range(word_len): left, count = i, 0 current_count = defaultdict(int) for j in range(i, len(s) - word_len + 1, word_len): word = s[j:j+word_len] if word in words_count: current_count[word] += 1 count += 1 while current_count[word] > words_count[word]: current_count[s[left:left+word_len]] -= 1 left += word_len count -= 1 if count == len(words): results.append(left) else: current_count = defaultdict(int) count = 0 left = j + word_len return results"},{"question":"def min_steps_to_equal_height(trees: List[int]) -> int: Returns the minimum number of steps required to make all trees have the same height. :param trees: List[int] heights of the trees. :return: int minimum number of steps required. >>> min_steps_to_equal_height([4, 4, 4]) == 0 >>> min_steps_to_equal_height([1, 2, 3]) == 3 >>> min_steps_to_equal_height([0, 0, 0]) == 0 >>> min_steps_to_equal_height([]) == 0 >>> min_steps_to_equal_height([5]) == 0 >>> min_steps_to_equal_height([-1, -2, -3]) == 3","solution":"def min_steps_to_equal_height(trees): Returns the minimum number of steps required to make all trees have the same height. :param trees: List[int] heights of the trees. :return: int minimum number of steps required. if not trees: return 0 max_height = max(trees) steps = sum(max_height - height for height in trees) return steps"},{"question":"def subarray_average_exists(arr: List[int], k: int) -> bool: Given a 0-indexed integer array arr of length n, determine if there exists a subarray of length k such that the average of the subarray is equal to an element in arr. Return true if such a subarray exists, otherwise return false. >>> subarray_average_exists([1, 2, 3, 4, 5], 3) True >>> subarray_average_exists([1, 2, 3, 4, 5], 6) False >>> subarray_average_exists([3, 3, 3, 3, 3], 5) True >>> subarray_average_exists([1, 1, 1, 1, 2], 2) True >>> subarray_average_exists([5, 8, 13, 21, 34], 3) False >>> subarray_average_exists([3, 14, 5, 7, 9], 1) True >>> subarray_average_exists([3], 1) True >>> subarray_average_exists([1, 2, 3, 4, 5], 2) False","solution":"def subarray_average_exists(arr, k): Checks if there exists a subarray of length k such that the average of the subarray is equal to an element in arr. n = len(arr) if k > n: return False # We can use a sliding window approach to find the sum of all subarrays of length k subarray_sum = sum(arr[:k]) subarray_avg_set = {subarray_sum / k} for i in range(1, n - k + 1): subarray_sum = subarray_sum - arr[i - 1] + arr[i + k - 1] subarray_avg_set.add(subarray_sum / k) for a in arr: if a in subarray_avg_set: return True return False"},{"question":"def runningSum(arr: List[int]) -> List[int]: Computes the running sum of the input array. Args: arr (list of int): The input list of integers. Returns: list of int: The running sum list. >>> runningSum([1, 2, 3, 4]) [1, 3, 6, 10] >>> runningSum([1, 1, 1, 1, 1]) [1, 2, 3, 4, 5] >>> runningSum([3, 1, 4, 1, 5]) [3, 4, 8, 9, 14] >>> runningSum([42]) [42] >>> runningSum([]) [] >>> runningSum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> runningSum([3, -1, 2, -2, 5]) [3, 2, 4, 2, 7] # Implement the function here","solution":"def runningSum(arr): Computes the running sum of the input array. Args: arr (list of int): The input list of integers. Returns: list of int: The running sum list. result = [] cumulative_sum = 0 for num in arr: cumulative_sum += num result.append(cumulative_sum) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: Determines if a binary tree is a binary search tree (BST). >>> root = TreeNode(2, TreeNode(1), TreeNode(3)) >>> is_valid_bst(root) True >>> root = TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6))) >>> is_valid_bst(root) False >>> root = TreeNode(1) >>> is_valid_bst(root) True >>> root = TreeNode(2, TreeNode(1)) >>> is_valid_bst(root) True >>> root = TreeNode(2, None, TreeNode(3)) >>> is_valid_bst(root) True >>> root = TreeNode(2, TreeNode(2), TreeNode(2)) >>> is_valid_bst(root) False >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(7) >>> root.right.right = TreeNode(18) >>> is_valid_bst(root) True >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(7) >>> root.right.right = TreeNode(12) >>> is_valid_bst(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root): Determines if a binary tree is a binary search tree. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is a BST, otherwise False def validate(node, low=float('-inf'), high=float('inf')): if not node: return True if not (low < node.val < high): return False return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"def max_length_subarray_two_distinct(nums: List[int]) -> int: Given a 0-indexed integer array nums, return the maximum length of a contiguous subarray that contains at most two distinct integers. You must write an algorithm that runs in O(n) time complexity where n is the length of the array. >>> max_length_subarray_two_distinct([]) == 0 >>> max_length_subarray_two_distinct([1]) == 1 >>> max_length_subarray_two_distinct([1, 2]) == 2 >>> max_length_subarray_two_distinct([1, 1, 2]) == 3 >>> max_length_subarray_two_distinct([1, 2, 1, 2, 3]) == 4 >>> max_length_subarray_two_distinct([1, 1, 1, 1]) == 4 >>> max_length_subarray_two_distinct([1, 2, 3, 2, 2]) == 4 >>> max_length_subarray_two_distinct([1, 2, 3, 4, 5]) == 2 >>> max_length_subarray_two_distinct([1, 2] * 100000) == 200000 pass","solution":"def max_length_subarray_two_distinct(nums): Returns the maximum length of a contiguous subarray that contains at most two distinct integers. :param nums: List[int] - a list of integers :return: int - the maximum length of such subarray if not nums: return 0 left = 0 right = 0 max_length = 0 count_map = {} while right < len(nums): if nums[right] in count_map: count_map[nums[right]] += 1 else: count_map[nums[right]] = 1 while len(count_map) > 2: count_map[nums[left]] -= 1 if count_map[nums[left]] == 0: del count_map[nums[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"from typing import List def minimumTimeRequired(jobs: List[int], n: int) -> int: You are given a **0-indexed** integer array \`jobs\` representing the amount of time it takes to complete each job. There are \`n\` workers, each worker can only work on **one** job and can only start a new job after the current one is finished. You want to assign jobs to the workers such that the total time to complete all jobs is minimized. Return the minimum time required to complete all jobs. >>> minimumTimeRequired([3, 2, 3], 3) 3 >>> minimumTimeRequired([1, 2, 4, 7, 8], 2) 11 >>> minimumTimeRequired([5, 4, 1, 3], 1) 13 >>> minimumTimeRequired([1, 2, 3, 4, 5], 5) 5 >>> minimumTimeRequired([10, 10, 10], 4) 10 >>> minimumTimeRequired([3, 2, 3, 2, 4], 1) 14 pass","solution":"def minimumTimeRequired(jobs, n): Returns the minimum time required to complete all jobs with n workers. Greedy approach to balance the workloads among workers. # Early exit for trivial cases if n >= len(jobs): return max(jobs) def can_finish(jobs, n, max_time): workloads = [0] * n def backtrack(idx): if idx == len(jobs): return True for i in range(n): if workloads[i] + jobs[idx] <= max_time: workloads[i] += jobs[idx] if backtrack(idx + 1): return True workloads[i] -= jobs[idx] if workloads[i] == 0: # Skip this worker as it is redundant break return False return backtrack(0) left, right = max(jobs), sum(jobs) while left < right: mid = (left + right) // 2 if can_finish(jobs, n, mid): right = mid else: left = mid + 1 return left"},{"question":"def increasing_triplet(arr): Determines if there exist three indices i, j, k such that 0 <= i < j < k < len(arr) and arr[i] < arr[j] < arr[k]. :param arr: List[int] - list of integers :return: bool - True if such indices exist, otherwise False pass def test_no_triplet(): assert not increasing_triplet([5, 4, 3, 2, 1]) def test_triplet_exists(): assert increasing_triplet([1, 2, 3, 4, 5]) def test_triplet_at_end(): assert increasing_triplet([2, 1, 5, 0, 4, 6]) def test_single_element(): assert not increasing_triplet([1]) def test_two_elements(): assert not increasing_triplet([1, 2]) def test_edge_case(): assert increasing_triplet([1, 1, 1, 1, 1, 2, 1, 3]) assert not increasing_triplet([2, 1, 5, 0, 3]) def test_triplet_with_duplicates(): assert increasing_triplet([1, 2, 2, 3])","solution":"def increasing_triplet(arr): Determines if there exist three indices i, j, k such that 0 <= i < j < k < len(arr) and arr[i] < arr[j] < arr[k]. :param arr: List[int] - list of integers :return: bool - True if such indices exist, otherwise False if len(arr) < 3: return False first = second = float('inf') for num in arr: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"from typing import List, Tuple, Optional def collinear(p1: Tuple[int, int], p2: Tuple[int, int], p3: Tuple[int, int]) -> bool: Check if points p1, p2, and p3 are collinear. Points are collinear if the area of the triangle they form is zero. >>> collinear((0, 0), (1, 1), (2, 2)) True >>> collinear((0, 0), (1, 1), (2, 3)) False pass def find_triplet(points: List[Tuple[int, int]]) -> Optional[Tuple[int, int, int]]: Given a list of points, return indices of three collinear points if they exist. >>> find_triplet([(0, 0), (1, 1), (2, 2), (-1, -1)]) in [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)] >>> find_triplet([(0, 0), (1, 1), (2, 3), (4, 5)]) None pass","solution":"from itertools import combinations def collinear(p1, p2, p3): Check if points p1, p2, and p3 are collinear. Points are collinear if the area of the triangle they form is zero. The area can be calculated using the determinant of a 3x3 matrix formed by the points. (x1, y1), (x2, y2), (x3, y3) = p1, p2, p3 return (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1) def find_triplet(points): Given a list of points, return indices of three collinear points if they exist. n = len(points) # Iterate over all combinations of three points for i, j, k in combinations(range(n), 3): if collinear(points[i], points[j], points[k]): return (i, j, k) return None"},{"question":"class BST: def __init__(self): Initializes the empty BST. def insert(self, key): Inserts a node with the value \`key\` into the BST. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.inorderTraversal() [3, 5] def search(self, key): Returns \`true\` if a node with the value \`key\` exists in the BST, otherwise returns \`false\`. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.search(5) True >>> bst.search(10) False def delete(self, key): Removes a node with the value \`key\` from the BST if it exists. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.delete(3) >>> bst.search(3) False def inorderTraversal(self): Returns an array of the node values in the BST sorted in ascending order. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.inorderTraversal() [3, 5] import pytest def test_bst_insert_and_search(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(1) assert bst.search(5) == True assert bst.search(3) == True assert bst.search(7) == True assert bst.search(1) == True assert bst.search(10) == False def test_bst_delete(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(1) bst.delete(3) assert bst.search(3) == False bst.delete(5) assert bst.search(5) == False bst.delete(10) # Deleting a non-existing node should do nothing assert bst.search(7) == True def test_bst_inorder_traversal(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(1) assert bst.inorderTraversal() == [1, 3, 5, 7] bst.delete(3) assert bst.inorderTraversal() == [1, 5, 7] def test_empty_bst(): bst = BST() assert bst.inorderTraversal() == [] bst.delete(5) assert bst.inorderTraversal() == [] assert bst.search(5) == False def test_single_element(): bst = BST() bst.insert(42) assert bst.inorderTraversal() == [42] assert bst.search(42) == True bst.delete(42) assert bst.inorderTraversal() == [] assert bst.search(42) == False if __name__ == \\"__main__\\": pytest.main()","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): def insert_rec(node, key): if not node: return TreeNode(key) if key < node.val: node.left = insert_rec(node.left, key) else: node.right = insert_rec(node.right, key) return node self.root = insert_rec(self.root, key) def search(self, key): def search_rec(node, key): if not node or node.val == key: return node is not None if key < node.val: return search_rec(node.left, key) return search_rec(node.right, key) return search_rec(self.root, key) def delete(self, key): def delete_rec(node, key): if not node: return node if key < node.val: node.left = delete_rec(node.left, key) elif key > node.val: node.right = delete_rec(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = min_value_node(node.right) node.val = temp.val node.right = delete_rec(node.right, temp.val) return node def min_value_node(node): current = node while current.left is not None: current = current.left return current self.root = delete_rec(self.root, key) def inorderTraversal(self): def inorder_rec(node): return inorder_rec(node.left) + [node.val] + inorder_rec(node.right) if node else [] return inorder_rec(self.root)"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values_per_level(root: Optional[TreeNode]) -> List[int]: Returns a list containing the largest value at each level of the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> largest_values_per_level(root) [1, 3, 9] import pytest def test_largest_values_per_level_single_node(): root = TreeNode(1) assert largest_values_per_level(root) == [1] def test_largest_values_per_level_multiple_levels(): # Construct the binary tree # 1 # / # 3 2 # / # 5 3 9 root = TreeNode(1) root.left = TreeNode(3) root.right = TreeNode(2) root.left.left = TreeNode(5) root.left.right = TreeNode(3) root.right.right = TreeNode(9) assert largest_values_per_level(root) == [1, 3, 9] def test_largest_values_per_level_all_equal(): # Construct the binary tree # 1 # / # 1 1 # / / # 1 1 1 root = TreeNode(1) root.left = TreeNode(1) root.right = TreeNode(1) root.left.left = TreeNode(1) root.right.left = TreeNode(1) root.right.right = TreeNode(1) assert largest_values_per_level(root) == [1, 1, 1] def test_largest_values_per_level_empty_tree(): assert largest_values_per_level(None) == [] def test_largest_values_per_level_mixed_values(): # Construct the binary tree # -1 # / # -2 3 # / / # 4 -5 -6 root = TreeNode(-1) root.left = TreeNode(-2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(-5) root.right.left = TreeNode(-6) assert largest_values_per_level(root) == [-1, 3, 4]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values_per_level(root): Returns a list containing the largest value at each level of the binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float('-inf') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"def count_inversions(nums): Returns the number of inversions in the array \`nums\`. An inversion is a pair of indices (i, j) such that 0 <= i < j < nums.length and nums[i] > nums[j]. Args: nums : List[int] Returns: int >>> count_inversions([2, 4, 1, 3, 5]) == 3 >>> count_inversions([5, 4, 3, 2, 1]) == 10 >>> count_inversions([1, 3, 5, 2, 4, 6]) == 3 >>> count_inversions([5, 5, 5, 5]) == 0 >>> count_inversions([]) == 0 >>> count_inversions([1]) == 0 >>> count_inversions([2, 1]) == 1","solution":"def count_inversions(nums): Returns the number of inversions in the array \`nums\`. An inversion is a pair of indices (i, j) such that 0 <= i < j < nums.length and nums[i] > nums[j]. Args: nums : List[int] Returns: int def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count n = len(nums) temp_arr = [0]*n return merge_sort_and_count(nums, temp_arr, 0, n-1)"},{"question":"def is_rotation(s1: str, s2: str) -> bool: Determine if s2 is a rotation of s1 by using a substring checking method. :param s1: Original string :param s2: String to check as rotation :return: True if s2 is a rotation of s1, False otherwise >>> is_rotation('waterbottle', 'erbottlewat') True >>> is_rotation('hello', 'lohelx') False >>> is_rotation('abc', 'abcd') False >>> is_rotation('', '') True >>> is_rotation('a', '') False >>> is_rotation('', 'a') False","solution":"def is_rotation(s1, s2): Determine if s2 is a rotation of s1 by using a substring checking method. :param s1: Original string :param s2: String to check as rotation :return: True if s2 is a rotation of s1, False otherwise if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"from typing import List def min_operations_to_one(n: int) -> int: Returns the minimum number of operations needed to reduce n to 1. The operations you can use are: - Subtract \`1\` from \`n\` - If \`n\` is even, divide \`n\` by \`2\` - If \`n\` is divisible by \`3\`, divide \`n\` by \`3\` >>> min_operations_to_one(10) == 3 >>> min_operations_to_one(1) == 0 >>> min_operations_to_one(2) == 1 >>> min_operations_to_one(3) == 1 >>> min_operations_to_one(6) == 2 >>> min_operations_to_one(15) == 4 >>> min_operations_to_one(27) == 3 >>> min_operations_to_one(100) == 7","solution":"def min_operations_to_one(n): Returns the minimum number of operations needed to reduce n to 1. dp = [0] * (n + 1) for i in range(2, n + 1): dp[i] = dp[i - 1] + 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[n]"},{"question":"def validMountainArray(A: List[int]) -> bool: Determine whether the list forms a valid mountain array. A valid mountain array must satisfy the following conditions: the list must have at least 3 elements, there exists some index \`i\` (0 < i < len(A) - 1) such that: - \`A[0] < A[1] < ... < A[i]\` - \`A[i] > A[i+1] > ... > A[len(A) - 1]\` Args: A (List[int]): The list of integers to check. Returns: bool: True if the list forms a valid mountain array, otherwise False. Examples: >>> validMountainArray([0, 3, 2, 1]) True >>> validMountainArray([1, 3, 2]) True >>> validMountainArray([2, 1]) False >>> validMountainArray([3, 5, 5]) False >>> validMountainArray([0, 1, 3, 2, 2]) False >>> validMountainArray([1, 2, 3, 2, 2]) False >>> validMountainArray([5, 4, 3, 2, 1]) False >>> validMountainArray([1, 2, 3, 4, 5]) False >>> validMountainArray([]) False >>> validMountainArray([1]) False >>> validMountainArray([1, 2]) False >>> validMountainArray([3, 0, 3, 2, 1]) False >>> validMountainArray([0, 3, 3, 2, 1]) False >>> validMountainArray([1, 3, 2, 1, 2]) False","solution":"def validMountainArray(A): n = len(A) if n < 3: return False # Find the peak of the mountain peak = 0 for i in range(1, n - 1): if A[i] > A[i - 1] and A[i] > A[i + 1]: peak = i break else: return False # Check if the elements before the peak are strictly increasing for i in range(1, peak): if A[i] <= A[i - 1]: return False # Check if the elements after the peak are strictly decreasing for i in range(peak + 1, n): if A[i] >= A[i - 1]: return False return True"},{"question":"def min_reorder(heights: List[int]) -> int: Determines the minimum number of students that should be moved so that the students are standing in non-decreasing order of their heights. >>> min_reorder([1, 2, 3, 4]) == 0 >>> min_reorder([4, 3, 2, 1]) == 4 >>> min_reorder([1, 3, 2, 4]) == 2 >>> min_reorder([5, 3, 1, 2, 4]) == 5 >>> min_reorder([1, 1, 1, 1]) == 0 >>> min_reorder([2, 2, 2, 1]) == 2 >>> min_reorder([]) == 0","solution":"def min_reorder(heights): Returns the minimum number of students that should be moved so that the students are standing in non-decreasing order of their heights. # Create a sorted version of the heights list sorted_heights = sorted(heights) # Count the number of positions where the current height in the original list # does not match the height in the sorted list moves = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: moves += 1 # Since we are counting the wrong positions, each move corrects a position return moves"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Finds the length of the longest consecutive elements sequence in a list of integers. >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([1]) 1 >>> longest_consecutive_sequence([1, 2]) 2 >>> longest_consecutive_sequence([1, 3]) 1 >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) 4 >>> longest_consecutive_sequence([5, 4, 3, 2, 1]) 5 >>> longest_consecutive_sequence([10, 5, 12, 3, 55, 4, 13, 2]) 4 >>> longest_consecutive_sequence([100, 101, 102, 1000, 1001, 999]) 3","solution":"def longest_consecutive_sequence(nums): Finds the length of the longest consecutive elements sequence in a list of integers. if not nums: return 0 num_set = set(nums) # Use a set to allow O(1) lookups max_length = 0 for num in nums: if num - 1 not in num_set: # Start of a new sequence current_length = 1 current_num = num while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"from collections import OrderedDict class CacheSystem: Design a CacheSystem class with the following functionalities: 1. put(key, value): Insert the key-value pair into the cache. If the key is already present, update its value. 2. get(key): Retrieve the value associated with the key from the cache. If the key is not present, return -1. 3. evict(): Remove the least recently used (LRU) key-value pair from the cache. 4. size(): Return the current number of key-value pairs in the cache. The cache should hold a maximum of n key-value pairs; once the size exceeds this limit, an eviction should occur automatically to maintain the size limit. def __init__(self, capacity: int): Initialize the cache with a given capacity. pass def put(self, key, value): Insert or update the key-value pair in the cache. pass def get(self, key): Retrieve the value associated with the key from the cache. If the key isn't present, return -1. pass def evict(self): Remove the least recently used (LRU) key-value pair from the cache. pass def size(self): Return the current number of key-value pairs in the cache. pass # Unit tests def test_cache_initially_empty(): cache = CacheSystem(2) assert cache.size() == 0 def test_put_and_get(): cache = CacheSystem(2) cache.put('a', 1) assert cache.get('a') == 1 assert cache.size() == 1 def test_get_non_existing_key(): cache = CacheSystem(2) assert cache.get('non_existing') == -1 def test_eviction_when_capacity_exceeded(): cache = CacheSystem(2) cache.put('a', 1) cache.put('b', 2) cache.put('c', 3) assert cache.size() == 2 assert cache.get('a') == -1 # 'a' should have been evicted def test_update_existing_key(): cache = CacheSystem(2) cache.put('a', 1) cache.put('a', 2) assert cache.get('a') == 2 assert cache.size() == 1 def test_cache_size(): cache = CacheSystem(2) cache.put('a', 1) cache.put('b', 2) assert cache.size() == 2 cache.evict() assert cache.size() == 1 def test_lru_eviction_order(): cache = CacheSystem(2) cache.put('a', 1) cache.put('b', 2) cache.get('a') # access 'a', now 'b' is LRU cache.put('c', 3) assert cache.get('b') == -1 # 'b' should have been evicted assert cache.get('a') == 1 assert cache.get('c') == 3","solution":"from collections import OrderedDict class CacheSystem: def __init__(self, capacity: int): Initialize the cache with a given capacity. self.cache = OrderedDict() self.capacity = capacity def put(self, key, value): Insert or update the key-value pair in the cache. if key in self.cache: self.cache.move_to_end(key) # move key to the end to mark it as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.evict() def get(self, key): Retrieve the value associated with the key from the cache. If the key isn't present, return -1. if key in self.cache: self.cache.move_to_end(key) # move key to the end to mark it as recently used return self.cache[key] return -1 def evict(self): Remove the least recently used (LRU) key-value pair from the cache. self.cache.popitem(last=False) def size(self): Return the current number of key-value pairs in the cache. return len(self.cache)"},{"question":"def buildings_with_sunset_view(arr: List[int]) -> List[int]: Returns the indices of buildings that have an unobstructed view of the sunset. >>> buildings_with_sunset_view([1, 2, 3, 4, 5]) [0, 1, 2, 3, 4] >>> buildings_with_sunset_view([5, 4, 3, 2, 1]) [0] >>> buildings_with_sunset_view([2, 3, 4, 1, 5, 1, 6]) [0, 1, 2, 4, 6] >>> buildings_with_sunset_view([3, 3, 3, 3]) [0] >>> buildings_with_sunset_view([]) [] >>> buildings_with_sunset_view([10]) [0] >>> buildings_with_sunset_view([1, 2, 3, 10, 5, 6, 2, 1, 11]) [0, 1, 2, 3, 8]","solution":"def buildings_with_sunset_view(arr): Returns the indices of buildings that have an unobstructed view of the sunset. unobstructed_view_indices = [] max_height_so_far = -1 for i in range(len(arr)): if arr[i] > max_height_so_far: unobstructed_view_indices.append(i) max_height_so_far = arr[i] return unobstructed_view_indices"},{"question":"from typing import List def min_groups(file_sizes: List[int], limit: int) -> int: Determines the minimum number of groups required to store all the files without exceeding the given limit for any group. Parameters: file_sizes (list of int): The sizes of the files. limit (int): The maximum allowed total size for a group of files. Returns: int: The minimum number of groups needed. >>> min_groups([1, 2, 3, 4, 5], 5) 3 >>> min_groups([10], 10) 1 >>> min_groups([1, 1, 1, 1], 2) 2 >>> min_groups([10, 10, 10], 10) 3 >>> min_groups([1, 2, 3, 10], 10) 2 >>> min_groups([1, 2, 3, 4], 10) 1 >>> min_groups([], 10) 0 >>> min_groups([1, 2, 3, 4, 5, 6, 7], 100) 1","solution":"def min_groups(file_sizes, limit): Determines the minimum number of groups required to store all the files without exceeding the given limit for any group. Parameters: file_sizes (list of int): The sizes of the files. limit (int): The maximum allowed total size for a group of files. Returns: int: The minimum number of groups needed. file_sizes.sort(reverse=True) groups = [] for file in file_sizes: found_group = False for group in groups: if sum(group) + file <= limit: group.append(file) found_group = True break if not found_group: groups.append([file]) return len(groups)"},{"question":"def decode_run_length(encoded: str) -> str: Decodes the run-length encoded string. :param encoded: The run-length encoded string :return: The original decoded string >>> decode_run_length(\\"a3b2c1\\") 'aaabbc' >>> decode_run_length(\\"a1b1c1d1\\") 'abcd' >>> decode_run_length(\\"a10b5c2\\") 'aaaaaaaaaabbbbbcc' >>> decode_run_length(\\"z20\\") 'zzzzzzzzzzzzzzzzzzzz' >>> decode_run_length(\\"a3b12\\") 'aaabbbbbbbbbbb' # Your code here","solution":"def decode_run_length(encoded: str) -> str: Decodes the run-length encoded string. :param encoded: The run-length encoded string :return: The original decoded string decoded_str = \\"\\" i = 0 while i < len(encoded): char = encoded[i] count = \\"\\" i += 1 # Collect all digits that represent the count while i < len(encoded) and encoded[i].isdigit(): count += encoded[i] i += 1 # Append the character count times to the decoded string decoded_str += char * int(count) return decoded_str"},{"question":"from typing import List def subset_mean_is_integer(n: int, k: int, nums: List[int]) -> bool: Determines if there exists a subset of size k from a set of n unique integers such that the mean of the subset is an integer. >>> subset_mean_is_integer(5, 3, [1, 2, 3, 4, 5]) True >>> subset_mean_is_integer(4, 3, [1, 2, 4, 5]) False # Unit Tests def test_example_case(): n = 5 k = 3 nums = [1, 2, 3, 4, 5] assert subset_mean_is_integer(n, k, nums) == True def test_no_valid_subset(): n = 4 k = 3 nums = [1, 2, 4, 5] assert subset_mean_is_integer(n, k, nums) == False def test_subset_size_equals_set_size(): n = 3 k = 3 nums = [1, 2, 3] assert subset_mean_is_integer(n, k, nums) == True def test_single_element_subset(): n = 5 k = 1 nums = [1, 2, 3, 4, 5] assert subset_mean_is_integer(n, k, nums) == True def test_large_numbers(): n = 5 k = 3 nums = [100000, 200000, 300000, 400000, 500000] assert subset_mean_is_integer(n, k, nums) == True def test_subset_mean_is_integer(): n = 6 k = 3 nums = [3, 6, 9, 12, 15, 18] assert subset_mean_is_integer(n, k, nums) == True def test_k_greater_than_n(): n = 3 k = 4 nums = [1, 2, 3] assert subset_mean_is_integer(n, k, nums) == False def test_large_input(): import random nums = random.sample(range(1, 10000), 100) n = 100 k = 5 assert isinstance(subset_mean_is_integer(n, k, nums), bool)","solution":"from itertools import combinations def subset_mean_is_integer(n, k, nums): Determines if there exists a subset of size k such that the mean is an integer. if k > n: return False for comb in combinations(nums, k): if sum(comb) % k == 0: return True return False"},{"question":"def cherryPickup(grid: List[List[int]]) -> int: Collect the maximum cherries possible in the grid. You can move only down or to the right and have to return back to the start point. >>> cherryPickup([[0, 1, -1], [1, 0, -1], [1, 1, 1]]) == 5 >>> cherryPickup([[1, 1, -1], [1, -1, 1], [-1, 1, 1]]) == 0 >>> cherryPickup([[1]]) == 1 >>> cherryPickup([[1, 1, 1], [-1, -1, 1], [1, 1, 1]]) == 5","solution":"def cherryPickup(grid): def memoize(f): memo = {} def helper(*args): if args not in memo: memo[args] = f(*args) return memo[args] return helper @memoize def dfs(r1, c1, r2, c2): # If out of bounds or impassable if r1 >= N or r2 >= N or c1 >= N or c2 >= N or grid[r1][c1] == -1 or grid[r2][c2] == -1: return -float('inf') # If both persons have reached the bottom-right corner if r1 == N-1 and c1 == N-1: return grid[r1][c1] # Collect cherries with both persons if r1 == r2 and c1 == c2: cherries = grid[r1][c1] else: cherries = grid[r1][c1] + grid[r2][c2] # Move to the next step cherries += max(dfs(r1+1, c1, r2+1, c2), dfs(r1+1, c1, r2, c2+1), dfs(r1, c1+1, r2+1, c2), dfs(r1, c1+1, r2, c2+1)) return cherries N = len(grid) result = dfs(0, 0, 0, 0) return max(0, result)"},{"question":"def max_sum_subgrid(grid): Returns the maximum sum of any subgrid in the given 2D grid. Args: grid (list of list of int): 2D list representing the grid. Returns: int: The maximum sum of any rectangular subgrid within the given grid. pass def kadane(array): Helper function to calculate the maximum sum of a contiguous subarray. pass # Test cases def test_example_grid(): grid = [ [1, -2, 3], [-1, 2, -1], [3, -2, 1] ] assert max_sum_subgrid(grid) == 4 # [1, -2, 3] def test_all_positive_grid(): grid = [ [1, 2], [3, 4] ] assert max_sum_subgrid(grid) == 10 # entire grid def test_all_negative_grid(): grid = [ [-1, -2], [-3, -4] ] assert max_sum_subgrid(grid) == -1 # single element subgrid [-1] def test_mixed_grid(): grid = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] assert max_sum_subgrid(grid) == 29 # subgrid [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] def test_single_element_grid(): grid = [ [7] ] assert max_sum_subgrid(grid) == 7 # single element def test_empty_grid(): grid = [] assert max_sum_subgrid(grid) == 0 # empty grid def test_single_row_grid(): grid = [ [1, 2, 3, -2, 5] ] assert max_sum_subgrid(grid) == 9 # entire row def test_single_column_grid(): grid = [ [1], [2], [3], [-2], [5] ] assert max_sum_subgrid(grid) == 9 # entire column","solution":"def max_sum_subgrid(grid): Returns the maximum sum of any subgrid in the given 2D grid. Args: grid (list of list of int): 2D list representing the grid. Returns: int: The maximum sum of any rectangular subgrid within the given grid. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += grid[i][right] current_max = kadane(temp) max_sum = max(max_sum, current_max) return max_sum def kadane(array): Helper function to calculate the maximum sum of a contiguous subarray. max_end_here = max_so_far = array[0] for x in array[1:]: max_end_here = max(x, max_end_here + x) max_so_far = max(max_so_far, max_end_here) return max_so_far"},{"question":"from typing import List, Dict def has_cycle(graph: Dict[int, List[int]]) -> bool: Determine if a directed graph contains a cycle. Args: graph (Dict[int, List[int]]): The directed graph represented as an adjacency list. Returns: bool: True if the graph contains a cycle, False otherwise. >>> has_cycle({ ... 0: [1], ... 1: [2], ... 2: [3], ... 3: [] ... }) False >>> has_cycle({ ... 0: [1], ... 1: [2], ... 2: [0], # cycle here ... 3: [2] ... }) True >>> has_cycle({ ... 0: [1], ... 1: [], ... 2: [3], ... 3: [] ... }) False >>> has_cycle({ ... 0: [1], ... 1: [2], ... 2: [2], # self-loop here ... 3: [] ... }) True >>> has_cycle({ ... 0: [1, 2], ... 1: [3, 4], ... 2: [5], ... 3: [5], ... 4: [], ... 5: [] ... }) False >>> has_cycle({ ... 0: [1, 2], ... 1: [3, 4], ... 2: [5], ... 3: [5], ... 4: [1], # cycle here ... 5: [] ... }) True >>> has_cycle({}) False","solution":"from typing import List, Dict def has_cycle(graph: Dict[int, List[int]]) -> bool: def dfs(node): if visiting[node]: return True # found a back edge indicating a cycle if visited[node]: return False # already processed this node visiting[node] = True for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting[node] = False visited[node] = True return False visited = {node: False for node in graph} visiting = {node: False for node in graph} for node in graph: if not visited[node]: # Don't visit already processed nodes if dfs(node): return True return False"},{"question":"from typing import List def orangesRotting(grid: List[List[int]]) -> int: Given a 2D grid where: - 0 represents an empty cell, - 1 represents a fresh orange, - 2 represents a rotten orange. Returns the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, returns -1. >>> orangesRotting([[2, 1, 1], [1, 1, 0], [0, 1, 1]]) 4 >>> orangesRotting([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) 0 >>> orangesRotting([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) -1","solution":"from collections import deque def orangesRotting(grid): Given a 2D grid where: - 0 represents an empty cell, - 1 represents a fresh orange, - 2 represents a rotten orange. Returns the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, returns -1. rows, cols = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Add all initially rotten oranges to the queue and count fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh_oranges += 1 # Directions array for up, down, left, right adjacent cells directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] minutes = 0 # Perform BFS to rot all adjacent fresh oranges while queue and fresh_oranges > 0: minutes += 1 for _ in range(len(queue)): x, y = queue.popleft() for dr, dc in directions: nx, ny = x + dr, y + dc if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: # This fresh orange now becomes rotten grid[nx][ny] = 2 queue.append((nx, ny)) fresh_oranges -= 1 return minutes if fresh_oranges == 0 else -1"},{"question":"from collections import deque def min_jumps(heights: List[int], k: int) -> int: Returns the minimum number of jumps needed to reach the last block in the array. Returns -1 if it is not possible to reach the last block. >>> min_jumps([1, 2, 3, 4, 5], 2) == 2 >>> min_jumps([1, 5, 3, 4, 2], 1) == -1 >>> min_jumps([1], 2) == 0 >>> min_jumps([1, 10, 1, 10, 1], 2) == 2 >>> min_jumps([1, 2, 3, 1, 2, 3, 1, 2, 3], 3) == 3","solution":"from collections import deque def min_jumps(heights, k): Returns the minimum number of jumps needed to reach the last block in the array. Returns -1 if it is not possible to reach the last block. n = len(heights) if n == 1: return 0 jumps = [-1] * n queue = deque([0]) jumps[0] = 0 while queue: current = queue.popleft() for step in range(1, k + 1): next_block = current + step if next_block < n and jumps[next_block] == -1 and abs(heights[next_block] - heights[current]) <= k: jumps[next_block] = jumps[current] + 1 if next_block == n - 1: return jumps[next_block] queue.append(next_block) return -1"},{"question":"def reverse_words(s: str) -> str: Reverse every word in the string s while preserving the whitespaces. >>> reverse_words(\\"hello\\") 'olleh' >>> reverse_words(\\"hello world\\") 'olleh dlrow' >>> reverse_words(\\" hello world \\") ' olleh dlrow ' >>> reverse_words(\\"hi bye\\") 'ih eyb' >>> reverse_words(\\"\\") '' >>> reverse_words(\\" \\") ' '","solution":"def reverse_words(s): Reverses every word in the string s. Each word is separated by a single space. # Split the string by spaces words = s.split(' ') # Reverse each word and join them with a space reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def longest_subarray_length(arr, d): Given an array of integers \`arr\` and an integer \`d\`, returns the length of the longest subset such that the difference between the maximum and minimum elements in the chosen subset is at most \`d\`. All elements in the subset must not necessarily be contiguous in the original array. >>> longest_subarray_length([1, 3, 6, 10, 15], 4) == 2 >>> longest_subarray_length([1, 2, 3, 4, 5], 1) == 2 >>> longest_subarray_length([10, 20, 30, 40], 5) == 1 >>> longest_subarray_length([7, 7, 7, 7], 0) == 4 >>> longest_subarray_length([1, 3, 6, 10, 15], 20) == len([1, 3, 6, 10, 15]) >>> longest_subarray_length([], 5) == 0 >>> longest_subarray_length([-3, -2, -1, 0, 1, 2, 3], 3) == 4","solution":"def longest_subarray_length(arr, d): Returns the length of the longest subset such that the difference between the maximum and minimum elements is at most d. if not arr: return 0 # Sort the array arr.sort() left = 0 max_length = 0 for right in range(len(arr)): # If the difference exceeds d, move the left pointer to the right while arr[right] - arr[left] > d: left += 1 # Calculate the length of the current subarray max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def partition_disjoint(nums: List[int]) -> int: Returns the minimum possible length of \`left\` after the partition such that every element in \`left\` is less than or equal to every element in \`right\` and both \`left\` and \`right\` are non-empty. >>> partition_disjoint([5,0,3,8,6]) == 3 >>> partition_disjoint([1,1,1,1]) == 1 >>> partition_disjoint([1,1,1,0,6,12]) == 4 >>> partition_disjoint([1,2]) == 1 >>> partition_disjoint([5,4,3,2,1]) == -1 pass","solution":"def partition_disjoint(nums): Returns the minimum possible length of \`left\` after the partition such that every element in \`left\` is less than or equal to every element in \`right\` and both \`left\` and \`right\` are non-empty. # Initialize variables n = len(nums) max_left = [0] * n min_right = [0] * n # Fill the max_left array max_left[0] = nums[0] for i in range(1, n): max_left[i] = max(max_left[i-1], nums[i]) # Fill the min_right array min_right[-1] = nums[-1] for i in range(n-2, -1, -1): min_right[i] = min(min_right[i+1], nums[i]) # Find the partition index for i in range(1, n): if max_left[i-1] <= min_right[i]: return i return -1"},{"question":"def maxRectangleArea(heights): Calculate the maximum area of a rectangle formed by any combination of contiguous buildings. :param heights: List[int] - a list of integer heights for the buildings. :return: int - the maximum rectangle area. pass from solution import maxRectangleArea def test_single_building(): assert maxRectangleArea([5]) == 5 def test_two_buildings_same_height(): assert maxRectangleArea([2, 2]) == 4 def test_two_buildings_different_heights(): assert maxRectangleArea([2, 1]) == 2 def test_three_buildings_increasing_height(): assert maxRectangleArea([1, 2, 3]) == 4 def test_three_buildings_decreasing_height(): assert maxRectangleArea([3, 2, 1]) == 4 def test_varied_heights(): assert maxRectangleArea([2, 1, 5, 6, 2, 3]) == 10 def test_all_same_height(): assert maxRectangleArea([5, 5, 5, 5]) == 20 def test_multiple_peaks(): assert maxRectangleArea([2, 1, 4, 5, 1, 3, 3]) == 8","solution":"def maxRectangleArea(heights): Calculate the maximum area of a rectangle formed by any combination of contiguous buildings. :param heights: List[int] - a list of integer heights for the buildings. :return: int - the maximum rectangle area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def does_path_with_sum_exist(n: int, edges: List[List[int]], values: List[int], sum_target: int) -> bool: Determine if there exists a path in the graph such that the sum of the values of the nodes in that path equals sum_target. >>> does_path_with_sum_exist(1, [], [5], 5) True >>> does_path_with_sum_exist(1, [], [5], 10) False >>> does_path_with_sum_exist(2, [[0, 1]], [5, 5], 10) True >>> does_path_with_sum_exist(2, [[0, 1]], [5, 3], 10) False >>> does_path_with_sum_exist(3, [[0, 1], [1, 2]], [5, 3, 2], 10) True >>> does_path_with_sum_exist(3, [[0, 1], [1, 2]], [1, 1, 1], 5) False >>> does_path_with_sum_exist(3, [[0, 1], [1, 2], [2, 0]], [1, 2, 5], 8) True >>> does_path_with_sum_exist(5, [[0, 1], [1, 2], [2, 3], [3, 4]], [1, 2, 3, 4, 5], 15) True","solution":"from collections import defaultdict, deque def does_path_with_sum_exist(n, edges, values, sum_target): # Create the graph as an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Function to perform BFS to find paths with the target sum def bfs(start_node): queue = deque([(start_node, values[start_node], {start_node})]) while queue: current_node, current_sum, visited = queue.popleft() if current_sum == sum_target: return True for neighbor in graph[current_node]: if neighbor not in visited: new_visited = set(visited) new_visited.add(neighbor) queue.append((neighbor, current_sum + values[neighbor], new_visited)) return False # Check each node as a start node for node in range(n): if bfs(node): return True return False"},{"question":"def evaluate_expression(expr: str) -> int: Evaluate a mathematical expression and return the result as an integer. The expression can contain integers, +, -, *, / operators, and parentheses. >>> evaluate_expression(\\"2 + 3\\") 5 >>> evaluate_expression(\\"5 - 2\\") 3 >>> evaluate_expression(\\"2 * 3\\") 6 >>> evaluate_expression(\\"6 / 2\\") 3 >>> evaluate_expression(\\"2 + 3 * 4\\") 14 >>> evaluate_expression(\\"7 / 2\\") 3 >>> evaluate_expression(\\"-7 / 2\\") -3 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20 >>> evaluate_expression(\\"((2 + 3) * (4 - 2)) / 2\\") 5 >>> evaluate_expression(\\"3 + 4 * 2 / ( 1 - 5 )\\") 1 >>> evaluate_expression(\\" 3 + 4 * 2 / ( 1 - 5 ) \\") 1","solution":"def evaluate_expression(expr): Evaluate a mathematical expression and return the result as an integer. The expression can contain integers, +, -, *, / operators, and parentheses. import re def parse_expression(tokens): Parse and evaluate the tokens using a recursive approach to handle parentheses. stack = [] num = 0 sign = '+' def apply_operation(stack, sign, num): if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': top = stack.pop() stack.append(int(top / num)) # Truncate towards zero while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) elif token in \\"+-*/\\": apply_operation(stack, sign, num) num = 0 sign = token elif token == '(': num = parse_expression(tokens) elif token == ')': break apply_operation(stack, sign, num) return sum(stack) # Tokenize the expression tokens = re.findall(r'd+|[+*/()-]', expr.replace(' ', '')) return parse_expression(tokens)"},{"question":"from typing import List def remove_duplicate_letters(s: str) -> str: Remove duplicate letters from s to ensure every letter appears once and only once, and the result is the smallest in lexicographical order among all possible results. >>> remove_duplicate_letters(\\"bcabc\\") \\"abc\\" >>> remove_duplicate_letters(\\"aaaaa\\") \\"a\\" >>> remove_duplicate_letters(\\"abcdef\\") \\"abcdef\\" >>> remove_duplicate_letters(\\"cbacdcbc\\") \\"acdb\\" >>> remove_duplicate_letters(\\"abacb\\") \\"abc\\" pass","solution":"def remove_duplicate_letters(s): Remove duplicate letters from s to ensure every letter appears once and only once, and the result is the smallest in lexicographical order among all possible results. stack = [] seen = set() last_occurrence = {char: idx for idx, char in enumerate(s)} for idx, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and idx < last_occurrence[stack[-1]]: seen.discard(stack.pop()) seen.add(char) stack.append(char) return ''.join(stack)"},{"question":"def has_pair_with_product(nums: List[int], x: int) -> bool: Determine if there exist two elements in the list nums whose product is equal to x. >>> has_pair_with_product([1, 2, 3, 4], 12) True >>> has_pair_with_product([1, 2, 3, 4], 10) False >>> has_pair_with_product([0, 0, 1, 2], 0) True >>> has_pair_with_product([1, 2, 3, 4], 0) False >>> has_pair_with_product([4], 16) False >>> has_pair_with_product([10**5, 10**5], 10**10) True >>> has_pair_with_product([], 5) False","solution":"def has_pair_with_product(nums, x): Determine if there exist two elements in the list nums whose product is equal to x. if x == 0 and nums.count(0) > 1: return True seen = set() for number in nums: if number != 0 and x % number == 0: if (x // number) in seen: return True seen.add(number) return False"},{"question":"def minimum_subarrays(heights: List[int], k: int) -> int: Partition the array into the minimum number of contiguous subarrays so that in each subarray, the difference between the maximum and minimum height does not exceed \`k\`. >>> minimum_subarrays([], 3) 0 >>> minimum_subarrays([5], 3) 1 >>> minimum_subarrays([1, 2, 3, 4], 3) 1 >>> minimum_subarrays([1, 5, 3], 2) 2 >>> minimum_subarrays([10, 14, 18, 22], 3) 4 >>> minimum_subarrays([1, 2, 3, 4, 5, 6, 7, 8], 10) 1 >>> minimum_subarrays([1, 2, 3, 4, 5], 0) 5 >>> minimum_subarrays([1, 2, 1, 2, 1], 1) 1","solution":"def minimum_subarrays(heights, k): if not heights: return 0 subarrays = 1 start = 0 for i in range(1, len(heights)): if max(heights[start:i + 1]) - min(heights[start:i + 1]) > k: subarrays += 1 start = i return subarrays"},{"question":"def rotate(matrix: List[List[int]]) -> None: Rotates an n x n 2D matrix by 90 degrees clockwise in-place. >>> matrix = [[1]] >>> rotate(matrix) >>> matrix [[1]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> rotate(matrix) >>> matrix [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]","solution":"def rotate(matrix): Rotates an n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]] - the n x n 2D matrix n = len(matrix) # Transpose the matrix (swap rows with columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row to get the rotated matrix for i in range(n): matrix[i].reverse()"},{"question":"def merge_intervals(existing_intervals: List[List[int]], new_intervals: List[List[int]]) -> List[List[int]]: Merges any subintervals that overlap with the elements of an additional list of intervals. Return the resulting list of non-overlapping intervals after merging. :param existing_intervals: List of existing non-overlapping intervals :param new_intervals: Additional list of intervals to merge :return: List of non-overlapping intervals after merging >>> merge_intervals([[1, 3], [6, 9]], [[2, 5]]) [[1, 5], [6, 9]] >>> merge_intervals([[1, 3], [6, 9]], [[2, 5], [8, 10]]) [[1, 5], [6, 10]] >>> merge_intervals([[1, 5], [6, 9]], [[2, 3], [7, 8]]) [[1, 5], [6, 9]] >>> merge_intervals([[1, 2], [4, 5]], [[6, 7]]) [[1, 2], [4, 5], [6, 7]] >>> merge_intervals([[1, 2], [4, 5]], [[2, 4]]) [[1, 5]] >>> merge_intervals([[2, 6], [8, 10]], [[1, 11]]) [[1, 11]]","solution":"def merge_intervals(existing_intervals, new_intervals): Merges any subintervals that overlap with the elements of an additional list of intervals. Return the resulting list of non-overlapping intervals after merging. :param existing_intervals: List of existing non-overlapping intervals :param new_intervals: Additional list of intervals to merge :return: List of non-overlapping intervals after merging intervals = existing_intervals + new_intervals intervals.sort(key=lambda x: x[0]) # sort by starting point merged = [] for interval in intervals: if not merged or merged[-1][1] < interval[0]: # no overlap merged.append(interval) else: # merge the intervals merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def max_possible_difference(arr: List[int], k: int) -> int: Calculate the maximum possible difference between the heights of the tallest and shortest tree in the forest after performing at most \`k\` operations. Parameters: arr (List[int]): List of integers representing the heights of the trees. k (int): Maximum number of operations allowed. Returns: int: The maximum possible difference between the tallest and shortest tree after performing up to \`k\` operations. >>> max_possible_difference([1, 3, 5, 7], 2) == 6 >>> max_possible_difference([5], 1) == 0 >>> max_possible_difference([2, 2, 2, 2], 2) == 0 >>> max_possible_difference([1, 6, 11, 16], 10) == 15 >>> max_possible_difference([1, 3, 7, 10], 0) == 9","solution":"def max_possible_difference(arr, k): arr.sort() return arr[-1] - arr[0]"},{"question":"def length_of_non_decreasing_subsequence(students: List[int]) -> int: Returns the length of the longest non-decreasing subsequence that can be obtained from the given list 'students'. >>> length_of_non_decreasing_subsequence([1, 3, 2, 4, 3, 5]) == 4 >>> length_of_non_decreasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 >>> length_of_non_decreasing_subsequence([3, 10, 2, 1, 20]) == 3 >>> length_of_non_decreasing_subsequence([3, 2]) == 1 from solution import length_of_non_decreasing_subsequence def test_empty_list(): assert length_of_non_decreasing_subsequence([]) == 0 def test_single_element_list(): assert length_of_non_decreasing_subsequence([1]) == 1 assert length_of_non_decreasing_subsequence([5]) == 1 def test_all_equal_elements(): assert length_of_non_decreasing_subsequence([2, 2, 2, 2]) == 4 def test_already_sorted(): assert length_of_non_decreasing_subsequence([1, 2, 3, 4, 5]) == 5 def test_reverse_sorted(): assert length_of_non_decreasing_subsequence([5, 4, 3, 2, 1]) == 1 def test_general_case(): assert length_of_non_decreasing_subsequence([1, 3, 2, 4, 3, 5]) == 4 assert length_of_non_decreasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 assert length_of_non_decreasing_subsequence([3, 10, 2, 1, 20]) == 3 assert length_of_non_decreasing_subsequence([3, 2]) == 1","solution":"def length_of_non_decreasing_subsequence(students): Returns the length of the longest non-decreasing subsequence that can be obtained from the given list 'students'. if not students: return 0 n = len(students) # dp[i] will be the length of longest non-decreasing subsequence ending at index i dp = [1] * n for i in range(1, n): for j in range(0, i): if students[i] >= students[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def can_make_all_characters_same(s: str) -> bool: Determines if it's possible to make all characters in the string \`s\` the same by changing each character at most once. Parameters: s (str): The input string consisting of lowercase English letters. Returns: bool: True if all characters can be made the same, False otherwise. >>> can_make_all_characters_same(\\"a\\") True >>> can_make_all_characters_same(\\"ab\\") True >>> can_make_all_characters_same(\\"aaaa\\") True >>> can_make_all_characters_same(\\"abc\\") False >>> can_make_all_characters_same(\\"a\\"*50 + \\"b\\"*50) True >>> can_make_all_characters_same(\\"a\\"*50 + \\"b\\"*49 + \\"c\\") False","solution":"def can_make_all_characters_same(s): Determines if it's possible to make all characters in the string \`s\` the same by changing each character at most once. Parameters: s (str): The input string consisting of lowercase English letters. Returns: bool: True if all characters can be made the same, False otherwise. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # If the string length is 1, we can trivially change the only character to itself if len(s) == 1: return True # If there are only 2 unique characters with frequency sum equals to length of string minus one or not if len(freq) > 2: return False return True"},{"question":"class MaxStack: MaxStack is a stack data structure that supports push, pop, top, peekMax, and popMax operations. - push(x): Pushes an element x onto the stack. - pop(): Removes the element on top of the stack and returns it. - top(): Gets the element on the top. - peekMax(): Retrieves the maximum element in the stack without removing it. - popMax(): Retrieves the maximum element in the stack and removes it. If there is more than one maximum element, only removes the most recently added one. Example: stack = MaxStack() stack.push(5) stack.push(1) stack.push(5) assert stack.top() == 5 assert stack.popMax() == 5 assert stack.top() == 1 assert stack.peekMax() == 5 assert stack.pop() == 1 assert stack.top() == 5 def __init__(self): pass def push(self, x: int) -> None: pass def pop(self) -> int: pass def top(self) -> int: pass def peekMax(self) -> int: pass def popMax(self) -> int: pass","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x): self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self): val = self.stack.pop() if val == self.max_stack[-1]: self.max_stack.pop() return val def top(self): return self.stack[-1] def peekMax(self): return self.max_stack[-1] def popMax(self): max_val = self.peekMax() buffer_stack = [] while self.top() != max_val: buffer_stack.append(self.pop()) self.pop() # Remove the max value while buffer_stack: self.push(buffer_stack.pop()) return max_val"},{"question":"def hasCycle(n: int, edges: List[List[int]]) -> bool: Determines if the graph contains a cycle. Parameters: n (int): The number of vertices. edges (list of list of int): The edges of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. >>> hasCycle(3, []) == False >>> hasCycle(2, [[0, 1]]) == False >>> hasCycle(3, [[0, 1], [1, 2], [2, 0]]) == True >>> hasCycle(4, [[0, 1], [1, 2], [2, 3]]) == False >>> hasCycle(4, [[0, 1], [1, 2], [2, 3], [3, 1]]) == True >>> hasCycle(5, [[0, 1], [1, 2], [3, 4], [4, 3]]) == True >>> hasCycle(6, [[0, 1], [2, 3], [4, 5]]) == False >>> hasCycle(5, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0]]) == True pass","solution":"def hasCycle(n, edges): Determines if the graph contains a cycle. Parameters: n (int): The number of vertices. edges (list of list of int): The edges of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. # Helper function to perform DFS def dfs(v, visited, parent): visited[v] = True for neighbor in adj_list[v]: if not visited[neighbor]: if dfs(neighbor, visited, v): return True elif neighbor != parent: return True return False # Create an adjacency list adj_list = [[] for _ in range(n)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Initialize visited array visited = [False] * n # Perform DFS from each vertex for i in range(n): if not visited[i]: if dfs(i, visited, -1): return True return False"},{"question":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_good_nodes(root: TreeNode) -> int: Return the number of \\"good\\" nodes in the binary tree. A node X in this binary tree is named \\"good\\" if, in the path from the root to X, there are no nodes with a value greater than X. Test cases: >>> def build_tree(nodes, index=0): ... if index >= len(nodes) or nodes[index] is None: ... return None ... node = TreeNode(nodes[index]) ... node.left = build_tree(nodes, 2 * index + 1) ... node.right = build_tree(nodes, 2 * index + 2) ... return node ... >>> tree1 = build_tree([3, 1, 4, 3, None, 1, 5]) >>> count_good_nodes(tree1) == 4 True >>> tree2 = build_tree([2, 2, 2]) >>> count_good_nodes(tree2) == 3 True >>> tree3 = build_tree([3, 1, 2]) >>> count_good_nodes(tree3) == 1 True >>> tree4 = build_tree([1, 2, 3]) >>> count_good_nodes(tree4) == 3 True >>> tree5 = build_tree([]) >>> count_good_nodes(tree5) == 0 True >>> tree6 = build_tree([10]) >>> count_good_nodes(tree6) == 1 True","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_good_nodes(root: TreeNode) -> int: def dfs(node, max_val): if not node: return 0 # Check if the current node is a good node is_good = node.val >= max_val count = 1 if is_good else 0 # Update the max value to be passed down new_max_val = max(max_val, node.val) # Traverse the left and right subtrees count += dfs(node.left, new_max_val) count += dfs(node.right, new_max_val) return count return dfs(root, float('-inf'))"},{"question":"from collections import deque from typing import List def shortest_path_with_one_wall_break(grid: List[List[int]]) -> int: Calculate the length of the shortest path from the top-left corner to the bottom-right corner in a maze represented by a grid where 1 represents a wall and 0 represents an open path. Break at most one wall if needed. If no such path exists, return -1. Args: grid (List[List[int]]): The maze represented as an m x n grid. Returns: int: The length of the shortest path or -1 if no path exists. >>> grid = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path_with_one_wall_break(grid) 5 >>> grid = [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path_with_one_wall_break(grid) 5 >>> grid = [ ... [0, 1, 1], ... [1, 1, 0], ... [1, 1, 0] ... ] >>> shortest_path_with_one_wall_break(grid) -1 >>> grid = [ ... [0, 0, 0], ... [0, 1, 1], ... [1, 1, 0] ... ] >>> shortest_path_with_one_wall_break(grid) 5 >>> grid = [ ... [0, 1, 0, 0] ... ] >>> shortest_path_with_one_wall_break(grid) 4 >>> grid = [ ... [0], ... [1], ... [0], ... [0] ... ] >>> shortest_path_with_one_wall_break(grid) 4","solution":"from collections import deque def shortest_path_with_one_wall_break(grid): Calculate the length of the shortest path from the top-left corner to the bottom-right corner in a maze represented by a grid where 1 represents a wall and 0 represents an open path. Break at most one wall if needed. If no such path exists, return -1. Args: grid (List[List[int]]): The maze represented as an m x n grid. Returns: int: The length of the shortest path or -1 if no path exists. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS queue containing tuples of the form (row, col, steps, wall_break_used) queue = deque([(0, 0, 1, 0)]) visited = set() visited.add((0, 0, 0)) while queue: row, col, steps, wall_break_used = queue.popleft() # If the bottom-right corner is reached if row == m - 1 and col == n - 1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc # Check if new position is within bounds if 0 <= new_row < m and 0 <= new_col < n: new_wall_break_used = wall_break_used + grid[new_row][new_col] if new_wall_break_used <= 1 and (new_row, new_col, new_wall_break_used) not in visited: visited.add((new_row, new_col, new_wall_break_used)) queue.append((new_row, new_col, steps + 1, new_wall_break_used)) return -1"},{"question":"def maximal_square(matrix: List[List[int]]) -> int: Given a 2D list of integers representing a rectangular grid where each element is either 0 or 1, finds the size of the largest square containing only 1's. >>> maximal_square([]) == 0 >>> maximal_square([ >>> [0, 0, 0], >>> [0, 0, 0], >>> [0, 0, 0] >>> ]) == 0 >>> maximal_square([[1]]) == 1 >>> maximal_square([[0]]) == 0 >>> maximal_square([ >>> [1, 1, 1], >>> [1, 1, 1], >>> [1, 1, 1] >>> ]) == 3 >>> maximal_square([ >>> [1, 0, 1, 0, 0], >>> [1, 0, 1, 1, 1], >>> [1, 1, 1, 1, 1], >>> [1, 0, 0, 1, 0] >>> ]) == 2 >>> maximal_square([ >>> [0, 1, 1, 0, 1], >>> [1, 1, 1, 1, 0], >>> [1, 1, 1, 1, 0], >>> [0, 1, 1, 1, 1], >>> [0, 0, 1, 1, 1] >>> ]) == 3","solution":"def maximal_square(matrix): Given a 2D list of integers representing a rectangular grid where each element is either 0 or 1, finds the size of the largest square containing only 1's. Args: matrix (list of list of int): 2D list representing the grid. Returns: int: size of the largest square containing only 1's. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_square_length = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_square_length = max(max_square_length, dp[i][j]) return max_square_length"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Given a grid of size \`m x n\` consisting of \`0\`s (empty cells) and \`1\`s (walls), find the shortest path from the top-left cell to the bottom-right cell. You can move up, down, left, or right through empty cells, and you cannot move through walls. If there is no possible path, return -1. Return the length of the shortest path in terms of the number of steps. >>> shortest_path([[0, 1], [0, 0]]) == 2 >>> shortest_path([[0, 1], [1, 0]]) == -1 >>> shortest_path([]) == -1 >>> shortest_path([[0]]) == 0 >>> shortest_path([[0, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0], [1, 0, 0, 0]]) == 7 >>> shortest_path([[1, 0, 0], [0, 0, 1], [0, 0, 0]]) == -1","solution":"from collections import deque def shortest_path(grid): Find the shortest path in a grid from top-left to bottom-right moving only through empty cells (0s). If no path exists, return -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_product(nums: List[int]) -> int: Given a list of integers nums, return the maximum product you can obtain by reordering the list. >>> max_product([1, 2]) == 2 >>> max_product([2, 2]) == 4 >>> max_product([1, 5, 4, 3]) == 20 >>> max_product([10, 20, 30]) == 600 >>> max_product([-10, -20, 3, 4, 5]) == 200 # -10 * -20 >>> max_product([-1, -2, -3, 4, 5]) == 20 # 4 * 5","solution":"def max_product(nums): Returns the maximum product of any two numbers in the list. if len(nums) < 2: raise ValueError(\\"The input list must have at least two elements.\\") nums.sort() return nums[-1] * nums[-2]"},{"question":"def two_sum(nums, target): Find two distinct numbers in nums whose sum is equal to the target. Return the indices of the two numbers in a tuple (index1, index2). Args: nums (List[int]): List of integers. target (int): Target sum. Returns: Tuple[int, int]: Indices of the two numbers such that index1 < index2. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([3, 3], 6) (0, 1) >>> two_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> two_sum([1, -2, 3, 10], 1) (1, 2) >>> two_sum([1, 2, 3], 7) None","solution":"def two_sum(nums, target): Find two distinct numbers in nums whose sum is equal to the target. Return the indices of the two numbers in a tuple (index1, index2). Args: nums (List[int]): List of integers. target (int): Target sum. Returns: Tuple[int, int]: Indices of the two numbers such that index1 < index2. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode: Adds two numbers represented by two linked lists in reverse order and returns the sum as a linked list in reverse order. >>> list_to_linkedlist([2, 4, 3]) >>> list_to_linkedlist([5, 6, 4]) [7, 0, 8] >>> list_to_linkedlist([9, 9, 9]) >>> list_to_linkedlist([1]) [0, 0, 0, 1] >>> list_to_linkedlist([2, 4]) >>> list_to_linkedlist([5, 6, 4]) [7, 0, 5] >>> list_to_linkedlist([0]) >>> list_to_linkedlist([0]) [0] >>> None >>> list_to_linkedlist([1, 2, 3]) [1, 2, 3]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Adds two numbers represented by two linked lists in reverse order and returns the sum as a linked list in reverse order. dummy_head = ListNode() current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next"},{"question":"def count_distinct_arrays(nums: List[int]) -> int: You are given an integer array \`nums\` consisting of positive integers. You can apply the following operation on the array **any** number of times: Swap elements at any two indices \`i\` and \`j\` (\`i != j\`), such that the product of the swapped elements is an odd number. Return the number of **distinct** arrays you can obtain. Since the answer may be too large, return it **modulo** \`10^9 + 7\`. >>> count_distinct_arrays([1, 3, 5]) == 6 >>> count_distinct_arrays([2, 4, 6]) == 6 >>> count_distinct_arrays([1, 2, 3, 4]) == 4 >>> count_distinct_arrays([1]) == 1 >>> count_distinct_arrays([]) == 1 # Your code here","solution":"def count_distinct_arrays(nums): Returns the number of distinct arrays obtainable by swapping elements such that the product of swapped elements is odd. MOD = 10**9 + 7 # Count the number of odd and even numbers odd_count = sum(1 for num in nums if num % 2 == 1) even_count = len(nums) - odd_count # All odd numbers can be freely swapped with any other odd numbers. # All even numbers can be freely swapped with any other even numbers. # Therefore, the total number of distinct arrays is given by the factorials. def factorial(n): if n == 0 or n == 1: return 1 fact = 1 for i in range(2, n + 1): fact = (fact * i) % MOD return fact # Calculate the number of distinct arrays odd_fact = factorial(odd_count) even_fact = factorial(even_count) return (odd_fact * even_fact) % MOD"},{"question":"from typing import List def is_concatenation_of_permutation(words: List[str], s: str) -> bool: Checks if the string s is a concatenation of a permutation of words. Each word in words must be used exactly once in the concatenation. pass def test_is_concatenation_of_permutation(): from solution import is_concatenation_of_permutation # Tests where the function should return True assert is_concatenation_of_permutation([\\"one\\", \\"two\\", \\"three\\"], \\"onetwothree\\") == True assert is_concatenation_of_permutation([\\"abc\\", \\"def\\"], \\"defabc\\") == True assert is_concatenation_of_permutation([\\"a\\", \\"b\\", \\"c\\"], \\"cba\\") == True assert is_concatenation_of_permutation([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"cherryapplebanana\\") == True assert is_concatenation_of_permutation([\\"hi\\", \\"there\\"], \\"therehi\\") == True # Tests where the function should return False assert is_concatenation_of_permutation([\\"one\\", \\"two\\", \\"three\\"], \\"onetwothre\\") == False assert is_concatenation_of_permutation([\\"one\\"], \\"oneone\\") == False assert is_concatenation_of_permutation([\\"hello\\", \\"world\\"], \\"helloworlds\\") == False assert is_concatenation_of_permutation([\\"a\\", \\"b\\", \\"cd\\"], \\"abcde\\") == False assert is_concatenation_of_permutation([\\"apple\\", \\"banana\\"], \\"Bananaapple\\") == False # Edge cases assert is_concatenation_of_permutation([\\"a\\"], \\"a\\") == True assert is_concatenation_of_permutation([], \\"\\") == True assert is_concatenation_of_permutation([], \\"a\\") == False assert is_concatenation_of_permutation([\\"a\\"], \\"\\") == False","solution":"def is_concatenation_of_permutation(words, s): Checks if the string s is a concatenation of a permutation of words. Each word in words must be used exactly once in the concatenation. from collections import Counter concatenated_words = ''.join(words) if len(concatenated_words) != len(s): return False return Counter(concatenated_words) == Counter(s)"},{"question":"from typing import List, Tuple def longest_increasing_subsequence(numbers: List[int]) -> Tuple[int, List[int]]: Given a 0-indexed integer array numbers, find the longest subsequence from numbers that forms an increasing sequence. Returns a tuple containing the length of this subsequence and the subsequence itself. If there are multiple increasing subsequences with the same length, the lexicographically smallest one is returned. >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) (5, [1, 2, 3, 4, 5]) >>> longest_increasing_subsequence([5, 1, 6, 2, 7, 3, 8, 4, 9]) (5, [1, 2, 3, 4, 9]) >>> longest_increasing_subsequence([2, 2, 2, 2, 2]) (1, [2]) >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) (4, [2, 3, 7, 18]) >>> longest_increasing_subsequence([10]) (1, [10]) >>> longest_increasing_subsequence([]) (0, [])","solution":"from bisect import bisect_left from typing import List, Tuple def longest_increasing_subsequence(numbers: List[int]) -> Tuple[int, List[int]]: Finds the longest increasing subsequence in a given list of numbers. Returns a tuple containing the length of this subsequence and the subsequence itself. If there are multiple increasing subsequences with the same length, the lexicographically smallest one is returned. if not numbers: return 0, [] # Array to store the indexes where the increasing subsequences end sub = [] # Array to keep track of the previous element in the subsequence prev_index = [-1] * len(numbers) lis_indices = [] for i, num in enumerate(numbers): pos = bisect_left(sub, num) if pos == len(sub): sub.append(num) lis_indices.append(i) else: sub[pos] = num lis_indices[pos] = i if pos > 0: prev_index[i] = lis_indices[pos - 1] # Reconstruct the longest increasing subsequence lis_length = len(sub) lis = [] k = lis_indices[-1] while k >= 0: lis.append(numbers[k]) k = prev_index[k] lis.reverse() return lis_length, lis"},{"question":"from typing import List def findOrder(n: int, dependencies: List[List[int]]) -> List[int]: Determine the order to process books given dependencies. Parameters: n (int): Number of books. dependencies (List[List[int]]): List of dependencies [x, y] meaning book x must be processed before book y. Returns: List[int]: The order in which books should be processed, or an empty list if not possible. # Example Test Cases def test_no_dependencies(): n = 3 dependencies = [] order = findOrder(n, dependencies) assert set(order) == set([1, 2, 3]) def test_linear_dependencies(): n = 4 dependencies = [[1, 2], [2, 3], [3, 4]] order = findOrder(n, dependencies) assert order == [1, 2, 3, 4] def test_multiple_valid_orders(): n = 4 dependencies = [[1, 2], [1, 3], [2, 4], [3, 4]] order = findOrder(n, dependencies) assert order in [[1, 2, 3, 4], [1, 3, 2, 4]] def test_circular_dependency(): n = 3 dependencies = [[1, 2], [2, 3], [3, 1]] order = findOrder(n, dependencies) assert order == [] def test_no_books(): n = 0 dependencies = [] order = findOrder(n, dependencies) assert order == [] def test_unconnected_graph(): n = 6 dependencies = [[1, 2], [3, 4], [5, 6]] order = findOrder(n, dependencies) assert set(order) == set([1, 2, 3, 4, 5, 6]) def test_book_with_multiple_dependencies(): n = 5 dependencies = [[1, 5], [2, 5], [3, 5], [4, 5]] order = findOrder(n, dependencies) assert order[-1] == 5","solution":"from collections import defaultdict, deque def findOrder(n, dependencies): Determine the order to process books given dependencies. Parameters: n (int): Number of books. dependencies (List[List[int]]): List of dependencies [x, y] meaning book x must be processed before book y. Returns: List[int]: The order in which books should be processed, or an empty list if not possible. # Create adjacency list and in-degree array adj_list = defaultdict(list) in_degree = [0] * (n + 1) # Populate adjacency list and in-degree array based on dependencies for x, y in dependencies: adj_list[x].append(y) in_degree[y] += 1 # Use a queue to process nodes with 0 in-degree queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we processed all nodes, return the order, else return empty list return order if len(order) == n else []"},{"question":"from typing import List def findTaskOrder(n: int, dependency: List[List[int]]) -> List[int]: Finds the order of task completion given the dependencies. :param n: int - Number of tasks. :param dependency: List[List[int]] - List of dependencies where each sublist [a, b] means task a must be done before task b. :return: List[int] - List representing the order of task completion or an empty list if it is impossible to complete all tasks. >>> findTaskOrder(4, []) [0, 1, 2, 3] >>> findTaskOrder(2, [[0, 1]]) [0, 1] >>> findTaskOrder(4, [[1, 2], [2, 3], [1, 3]]) [0, 1, 2, 3] or [1, 0, 2, 3] or [1, 2, 0, 3] or [0, 1, 3, 2] >>> findTaskOrder(2, [[0, 1], [1, 0]]) [] >>> order = findTaskOrder(6, [[0, 1], [0, 2], [1, 3], [3, 4], [2, 4], [4, 5]]) ... assert order in [ ... [0, 2, 1, 3, 4, 5], ... [0, 1, 2, 3, 4, 5], ... [0, 1, 3, 2, 4, 5], ... [0, 1, 3, 4, 2, 5] ... ]","solution":"from collections import defaultdict, deque def findTaskOrder(n, dependency): Finds the order of task completion. :param n: int - Number of tasks. :param dependency: List[List[int]] - List of dependencies where each sublist [a, b] means task a must be done before task b. :return: List[int] - List representing the order of task completion or an empty list if it is impossible to complete all tasks. # Create the adjacency list and indegree list adj_list = defaultdict(list) indegree = [0] * n for a, b in dependency: adj_list[a].append(b) indegree[b] += 1 # Queue for nodes with no incoming edges queue = deque([i for i in range(n) if indegree[i] == 0]) order = [] # BFS or Kahn's algorithm while queue: node = queue.popleft() order.append(node) for neighbor in adj_list[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If all tasks are not in the result order, there is a cycle if len(order) != n: return [] return order"},{"question":"import heapq from typing import List def min_cost_to_combine_stones(arr: List[int]) -> int: Returns the minimum cost required to combine all piles into one pile. Parameters: arr (List[int]): An array where each element represents the number of stones in a pile. Returns: int: The minimum cost required to combine all piles into one pile. >>> min_cost_to_combine_stones([5]) 0 >>> min_cost_to_combine_stones([4, 3]) 7 >>> min_cost_to_combine_stones([4, 3, 6, 2]) 29 >>> min_cost_to_combine_stones([1, 2, 3, 4, 5]) 33 >>> min_cost_to_combine_stones([1, 1, 1, 1]) 8 >>> min_cost_to_combine_stones([1000, 2000, 3000]) 9000","solution":"import heapq def min_cost_to_combine_stones(arr): Returns the minimum cost required to combine all piles into one pile. Parameters: arr (List[int]): An array where each element represents the number of stones in a pile. Returns: int: The minimum cost required to combine all piles into one pile. if len(arr) <= 1: return 0 heapq.heapify(arr) total_cost = 0 while len(arr) > 1: first_min = heapq.heappop(arr) second_min = heapq.heappop(arr) cost = first_min + second_min total_cost += cost heapq.heappush(arr, cost) return total_cost"},{"question":"def is_k_palindrome(s: str, k: int) -> bool: Returns if the string is a k-palindrome string, else returns False. A k-palindrome string is a string that becomes a palindrome when at most k letters are deleted from it. >>> is_k_palindrome(\\"abca\\", 1) == True >>> is_k_palindrome(\\"racecar\\", 1) == True >>> is_k_palindrome(\\"deeee\\", 1) == True >>> is_k_palindrome(\\"abcde\\", 1) == False >>> is_k_palindrome(\\"abcdef\\", 2) == False >>> is_k_palindrome(\\"abcdefghijkl\\", 5) == False >>> is_k_palindrome(\\"\\", 0) == True >>> is_k_palindrome(\\"a\\", 0) == True >>> is_k_palindrome(\\"ab\\", 1) == True >>> is_k_palindrome(\\"bb\\", 0) == True","solution":"def is_k_palindrome(s, k): Returns True if the string is a k-palindrome string, else returns False. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] lps_length = longest_palindromic_subsequence(s) min_deletions = len(s) - lps_length return min_deletions <= k"},{"question":"def countPairs(nums: List[int], target: int) -> int: Returns the number of pairs (i, j) such that i < j and nums[i] + nums[j] == target. >>> countPairs([], 5) == 0 >>> countPairs([1, 2, 3], 10) == 0 >>> countPairs([1, 2, 3, 4], 5) == 2 >>> countPairs([1, 1, 2, 2, 3, 3, 4], 5) == 6 >>> countPairs([-1, -2, -3, 4], 2) == 1 >>> countPairs([0, 0, 0], 0) == 3","solution":"def countPairs(nums, target): Returns the number of pairs (i, j) such that i < j and nums[i] + nums[j] == target. count = 0 for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: count += 1 return count"},{"question":"def count_divisibles(start: int, end: int, divisor: int) -> int: Returns the count of numbers within the range [start, end] that are divisible by divisor. >>> count_divisibles(1, 10, 2) 5 >>> count_divisibles(5, 15, 3) 4 >>> count_divisibles(0, 0, 1) 1 >>> count_divisibles(-5, 5, 5) 3 if divisor == 0: raise ValueError(\\"Divisor cannot be zero\\")","solution":"def count_divisibles(start, end, divisor): Returns the count of numbers within the range [start, end] that are divisible by divisor. if divisor == 0: raise ValueError(\\"Divisor cannot be zero\\") count = 0 for num in range(start, end + 1): if num % divisor == 0: count += 1 return count"},{"question":"def search_rotated_array(nums: List[int], target: int) -> int: Searches for target in a rotated sorted array and returns its index or -1 if not present. :param nums: List[int] - Rotated sorted array of unique integers :param target: int - Target value to search for :return: int - Index of target if present, otherwise -1 pass def test_found_in_left_half(): nums = [4, 5, 6, 7, 0, 1, 2] target = 5 assert search_rotated_array(nums, target) == 1 def test_found_in_right_half(): nums = [4, 5, 6, 7, 0, 1, 2] target = 1 assert search_rotated_array(nums, target) == 5 def test_not_found(): nums = [4, 5, 6, 7, 0, 1, 2] target = 3 assert search_rotated_array(nums, target) == -1 def test_single_element_present(): nums = [1] target = 1 assert search_rotated_array(nums, target) == 0 def test_single_element_not_present(): nums = [1] target = 2 assert search_rotated_array(nums, target) == -1 def test_large_input(): nums = [15, 18, 2, 3, 6, 12] target = 3 assert search_rotated_array(nums, target) == 3 def test_element_at_start(): nums = [5, 1, 2, 3, 4] target = 5 assert search_rotated_array(nums, target) == 0 def test_element_at_end(): nums = [5, 6, 7, 1, 2, 3, 4] target = 4 assert search_rotated_array(nums, target) == 6","solution":"def search_rotated_array(nums, target): Searches for target in a rotated sorted array and returns its index or -1 if not present. :param nums: List[int] - Rotated sorted array of unique integers :param target: int - Target value to search for :return: int - Index of target if present, otherwise -1 left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid # Determine which half is properly sorted if nums[left] <= nums[mid]: # Left half is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def min_duplications_to_palindrome(s: str) -> int: Returns the minimum number of duplications required to make the string 's' a palindrome. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Minimum number of duplications required to make the string a palindrome. >>> min_duplications_to_palindrome('ab') == 1 >>> min_duplications_to_palindrome('race') == 3 >>> min_duplications_to_palindrome('racecar') == 0 >>> min_duplications_to_palindrome('a') == 0 >>> min_duplications_to_palindrome('aab') == 1 >>> min_duplications_to_palindrome('aaaa') == 0 >>> min_duplications_to_palindrome('abcba') == 0 >>> min_duplications_to_palindrome('google') == 2","solution":"def min_duplications_to_palindrome(s): Returns the minimum number of duplications required to make the string 's' a palindrome. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Minimum number of duplications required to make the string a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"from typing import List def min_cost_removal(nums: List[int]) -> int: Given an array of integers, you are allowed to choose one element at a time and remove it, but you must remove all occurrences of that element from the array in one go. After removing all instances of that element, the cost of this operation is the sum of the removed elements multiplied by their quantity. Your goal is to minimize the total cost to remove all elements from the array. Return the minimum cost. >>> min_cost_removal([5]) 5 >>> min_cost_removal([1, 2]) 3 >>> min_cost_removal([2, 2, 3, 3, 3]) 31 >>> min_cost_removal([-1, -1, -2, -2, -2]) -19 >>> min_cost_removal([1, 1, -1, -1]) -8 >>> min_cost_removal([]) 0 >>> min_cost_removal([2, 2, 2, 2]) 32","solution":"from collections import Counter def min_cost_removal(nums): Given an array of integers, the function returns the minimum cost to remove all elements according to the specified rules. counter = Counter(nums) elements = sorted(counter.items(), key=lambda x: x[0]) total_cost = 0 for num, count in elements: total_cost += num * count**2 return total_cost"},{"question":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges all overlapping intervals and returns the list of merged intervals in ascending order based on their start times. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([]) [] >>> merge_intervals([[1, 2], [3, 4]]) [[1, 2], [3, 4]] >>> merge_intervals([[1, 4], [2, 5], [3, 6]]) [[1, 6]] >>> merge_intervals([[1, 2], [2, 3], [3, 4]]) [[1, 4]] >>> merge_intervals([[1, 4], [0, 2], [3, 5]]) [[0, 5]] # Your code goes here","solution":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges all overlapping intervals and returns the list of merged intervals in ascending order based on their start times. if not intervals: return [] # Sort the intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: # Otherwise, add the current interval as is merged_intervals.append(current) return merged_intervals"},{"question":"def max_stacks(books: List[int]) -> int: Given an integer array \`books\` where each element represents the height of a book, return the maximum number of stacks Emma can form following the rules: 1. Each stack is in non-decreasing order. 2. No two stacks have the same book height on the top. >>> max_stacks([4, 3, 2, 1, 4, 3, 2, 1]) 4 >>> max_stacks([5, 5, 5, 5, 5]) 1 >>> max_stacks([1, 2, 3, 4, 5]) 5 >>> max_stacks([5, 4, 3, 2, 1]) 5 >>> max_stacks([3, 1, 2, 2, 4, 3, 5, 1]) 5 >>> max_stacks([]) 0 >>> max_stacks([1]) 1 >>> max_stacks(list(range(1000, 0, -1))) 1000","solution":"def max_stacks(books): # Sort the books to ensure we can form non-decreasing stacks books.sort() # Initialize an array to store the top book height of each stack stacks = [] for book in books: # Try to find a stack where we can place the current book # Binary search for the location to replace (acts as a stack top update) left, right = 0, len(stacks) - 1 while left <= right: mid = (left + right) // 2 if stacks[mid] < book: left = mid + 1 else: right = mid - 1 if left < len(stacks): stacks[left] = book else: stacks.append(book) return len(stacks)"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Find the length of the longest common subsequence between two strings. A subsequence is a sequence that can be derived from another sequence by deleting some elements (possibly zero) without changing the order of the remaining elements. Args: s1 (str): The first string. s2 (str): The second string. Returns: int: The length of the longest common subsequence. Examples: >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0","solution":"def longest_common_subsequence(s1, s2): Finds the length of the longest common subsequence between two strings s1 and s2. m = len(s1) n = len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"from typing import List def max_distinct_elements(arr: List[int], k: int) -> int: Returns the maximum number of distinct elements that can appear in any subarray of size k. >>> max_distinct_elements([1, 2, 1, 3, 4, 2, 3], 3) 3 >>> max_distinct_elements([1, 1, 2, 2, 3, 3], 5) 3 >>> max_distinct_elements([1], 1) 1 >>> max_distinct_elements([5, 5, 5, 5], 2) 1 >>> max_distinct_elements([1, 2, 3, 4], 10) 4 >>> max_distinct_elements([6, 5, 8, 9, 4, 7, 5, 8], 4) 4 pass","solution":"def max_distinct_elements(arr, k): Returns the maximum number of distinct elements that can appear in any subarray of size k. if k > len(arr): return len(set(arr)) max_distinct = 0 current_window = {} distinct_count = 0 for i in range(len(arr)): if arr[i] not in current_window or current_window[arr[i]] == 0: distinct_count += 1 current_window[arr[i]] = current_window.get(arr[i], 0) + 1 if i >= k - 1: max_distinct = max(max_distinct, distinct_count) outgoing_element = arr[i - k + 1] current_window[outgoing_element] -= 1 if current_window[outgoing_element] == 0: distinct_count -= 1 return max_distinct"},{"question":"def count_substrings(s: str) -> int: Given a binary string \`s\`, return the number of substrings that start and end with '1'. >>> count_substrings(\\"111\\") 6 >>> count_substrings(\\"1\\") 1 >>> count_substrings(\\"000\\") 0 >>> count_substrings(\\"10101\\") 6 >>> count_substrings(\\"001001\\") 3 >>> count_substrings(\\"100100\\") 3 >>> count_substrings(\\"\\") 0","solution":"def count_substrings(s): Counts the number of substrings in binary string s that start and end with '1'. count_of_ones = s.count('1') # Calculate the number of substrings using the formula for combinations of the 1's chosen 2 at a time + the count of 1's itself return (count_of_ones * (count_of_ones - 1)) // 2 + count_of_ones"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Search target in a matrix where each row and column is sorted in non-decreasing order. Args: matrix (list of list of int): 2D integer array target (int): The target number to find Returns: bool: True if target is found, False otherwise >>> search_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 5) True >>> search_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 20) False >>> search_matrix([], 1) False >>> search_matrix([[1]], 1) True >>> search_matrix([[1]], 2) False >>> search_matrix([ [1, 4, 7], [2, 5, 8], [3, 6, 10**6] ], 10**6) True","solution":"def search_matrix(matrix, target): Search target in a matrix where each row and column is sorted in non-decreasing order. Args: matrix (list of list of int): 2D integer array target (int): The target number to find Returns: bool: True if target is found, False otherwise if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"def num_islands(grid: List[List[str]]) -> int: Returns the number of distinct islands in the grid. >>> num_islands([ ... ['1', '1', '1', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['1', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'] ... ]) == 1 >>> num_islands([ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '1', '1'] ... ]) == 3 >>> num_islands([ ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'] ... ]) == 0 >>> num_islands([]) == 0 >>> num_islands([ ... ['1', '0', '1', '0', '1'], ... ['0', '1', '0', '1', '0'], ... ['1', '0', '1', '0', '1'], ... ['0', '1', '0', '1', '0'], ... ['1', '0', '1', '0', '1'] ... ]) == 13","solution":"def num_islands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): stack = [(r, c)] direction = [(0, 1), (1, 0), (0, -1), (-1, 0)] while stack: r, c = stack.pop() for dr, dc in direction: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == '1': visited[nr][nc] = True stack.append((nr, nc)) count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == '1' and not visited[r][c]: count += 1 visited[r][c] = True dfs(r, c) return count"},{"question":"def count_subarrays(arr, threshold, size): Counts the number of contiguous subarrays of length \`size\` with sum >= \`threshold\`. Parameters: arr (list of int): The list of integers. threshold (int): The threshold value. size (int): The size of the subarray. Returns: int: The number of contiguous subarrays of length \`size\` with sum >= \`threshold\`. Examples: >>> count_subarrays([1, 2, 3, 4, 5], 9, 3) 2 >>> count_subarrays([1, 2, 3, 4, 5], 0, 3) 3 >>> count_subarrays([2, 4, 6, 8, 10], 15, 5) 1 >>> count_subarrays([2, 4, 6], 10, 4) 0 >>> count_subarrays([1, 2, 3, 4], 3, 0) 0 >>> count_subarrays([1, 1, 1, 1, 1, 1], 3, 3) 4","solution":"def count_subarrays(arr, threshold, size): Counts the number of contiguous subarrays of length \`size\` with sum >= \`threshold\`. Parameters: arr (list of int): The list of integers. threshold (int): The threshold value. size (int): The size of the subarray. Returns: int: The number of contiguous subarrays of length \`size\` with sum >= \`threshold\`. n = len(arr) if size > n: return 0 window_sum = sum(arr[:size]) count = 0 if window_sum >= threshold: count += 1 for i in range(size, n): window_sum += arr[i] - arr[i - size] if window_sum >= threshold: count += 1 return count"},{"question":"def common_elements_in_rows(matrix): Returns a list of common elements present in all rows of the matrix. :param matrix: List of List of integers :return: List of integers >>> common_elements_in_rows([[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [0, 3, 4, 5, 7]]) == [3, 4, 5] >>> common_elements_in_rows([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [] >>> common_elements_in_rows([[1, 2, 3, 4, 5]]) == [1, 2, 3, 4, 5] >>> common_elements_in_rows([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) == [1, 2, 3] >>> common_elements_in_rows([]) == [] >>> common_elements_in_rows([[1, 2, 3], [3, 4, 5], [3, 6, 7]]) == [3]","solution":"def common_elements_in_rows(matrix): Returns a list of common elements present in all rows of the matrix. :param matrix: List of List of integers :return: List of integers if not matrix: return [] common_elements = set(matrix[0]) for row in matrix[1:]: common_elements &= set(row) return sorted(common_elements)"},{"question":"class ActivityLogger: A class to track and manage user activities in a system, which logs activities with timestamps and provides functionalities to query those activities based on time intervals. ActivityLogger() Initializes the ActivityLogger object. void logActivity(String userId, String activity, int timestamp) Stores the user's activity at the given timestamp (in seconds). List<String> getActivitiesForUser(String userId, int startTimestamp, int endTimestamp) Returns a list of activities for the user with the ID userId that were logged between startTimestamp and endTimestamp (both inclusive). The activities should be returned in the order they were logged. List<String> getAllActivities(int startTimestamp, int endTimestamp) Returns a list of all activities logged in the system between startTimestamp and endTimestamp (both inclusive). The activities should be returned in the order they were logged. List<String> getUsersWithActivity(String activity, int startTimestamp, int endTimestamp) Returns a list of user IDs that logged the specified activity between startTimestamp and endTimestamp (both inclusive). Each user ID should be unique and the list should be sorted in ascending order. def __init__(self): pass def logActivity(self, userId, activity, timestamp): pass def getActivitiesForUser(self, userId, startTimestamp, endTimestamp): pass def getAllActivities(self, startTimestamp, endTimestamp): pass def getUsersWithActivity(self, activity, startTimestamp, endTimestamp): pass from solution import ActivityLogger def test_log_activity_and_get_activities_for_user(): logger = ActivityLogger() logger.logActivity(\\"user1\\", \\"Login\\", 1) logger.logActivity(\\"user1\\", \\"Upload\\", 2) logger.logActivity(\\"user2\\", \\"Login\\", 3) assert logger.getActivitiesForUser(\\"user1\\", 1, 2) == [\\"Login\\", \\"Upload\\"] def test_get_activities_for_user_no_activities(): logger = ActivityLogger() assert logger.getActivitiesForUser(\\"user1\\", 1, 2) == [] def test_get_all_activities(): logger = ActivityLogger() logger.logActivity(\\"user1\\", \\"Login\\", 1) logger.logActivity(\\"user2\\", \\"Login\\", 2) assert logger.getAllActivities(1, 2) == [\\"Login\\", \\"Login\\"] def test_get_all_activities_particular_timeframe(): logger = ActivityLogger() logger.logActivity(\\"user1\\", \\"Login\\", 1) logger.logActivity(\\"user2\\", \\"Login\\", 2) assert logger.getAllActivities(1, 1) == [\\"Login\\"] def test_get_users_with_activity(): logger = ActivityLogger() logger.logActivity(\\"user1\\", \\"Login\\", 1) logger.logActivity(\\"user2\\", \\"Login\\", 2) logger.logActivity(\\"user3\\", \\"Logout\\", 3) logger.logActivity(\\"user1\\", \\"Login\\", 4) assert logger.getUsersWithActivity(\\"Login\\", 1, 4) == [\\"user1\\", \\"user2\\"] def test_get_users_with_activity_no_users(): logger = ActivityLogger() assert logger.getUsersWithActivity(\\"Upload\\", 1, 4) == []","solution":"class ActivityLogger: def __init__(self): self.logs = [] def logActivity(self, userId, activity, timestamp): self.logs.append((timestamp, userId, activity)) self.logs.sort() def getActivitiesForUser(self, userId, startTimestamp, endTimestamp): return [ activity for timestamp, uid, activity in self.logs if uid == userId and startTimestamp <= timestamp <= endTimestamp ] def getAllActivities(self, startTimestamp, endTimestamp): return [ activity for timestamp, _, activity in self.logs if startTimestamp <= timestamp <= endTimestamp ] def getUsersWithActivity(self, activity, startTimestamp, endTimestamp): users_set = { uid for timestamp, uid, act in self.logs if act == activity and startTimestamp <= timestamp <= endTimestamp } return sorted(users_set)"},{"question":"def longest_balanced_substring(s: str) -> int: Finds the length of the longest balanced substring where the count of 'a' equals the count of 'b'. Parameters: s (str): The input string containing only 'a' and 'b' characters. Returns: int: The length of the longest balanced substring. If no balanced substring exists, returns 0. >>> longest_balanced_substring(\\"ababab\\") == 6 >>> longest_balanced_substring(\\"abba\\") == 4 >>> longest_balanced_substring(\\"aabb\\") == 4 >>> longest_balanced_substring(\\"aabba\\") == 4 >>> longest_balanced_substring(\\"abbaa\\") == 4 >>> longest_balanced_substring(\\"aaaa\\") == 0 >>> longest_balanced_substring(\\"b\\") == 0 >>> longest_balanced_substring(\\"ab\\") == 2 >>> longest_balanced_substring(\\"ba\\") == 2 >>> longest_balanced_substring(\\"aaabbb\\") == 6 >>> longest_balanced_substring(\\"abbbaa\\") == 6 >>> longest_balanced_substring(\\"aababbab\\") == 8 >>> longest_balanced_substring(\\"aaaabbbb\\") == 8 >>> longest_balanced_substring(\\"aaaaa\\") == 0 >>> longest_balanced_substring(\\"bbbbb\\") == 0","solution":"def longest_balanced_substring(s): Finds the length of the longest balanced substring where the count of 'a' equals the count of 'b'. Parameters: s (str): The input string containing only 'a' and 'b' characters. Returns: int: The length of the longest balanced substring. If no balanced substring exists, returns 0. max_len = 0 count_dict = {0: -1} count = 0 for i, char in enumerate(s): if char == 'a': count += 1 elif char == 'b': count -= 1 if count in count_dict: max_len = max(max_len, i - count_dict[count]) else: count_dict[count] = i return max_len"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTree: def __init__(self, root): self.root = root def find(self, node, value): Finds the node containing the given value in the binary tree. Args: node (TreeNode): The root node of the binary tree. value (int): The value to search for. Returns: TreeNode: The node containing the value, or None if not found. def lowestCommonAncestor(self, root, p, q): Finds the lowest common ancestor of nodes with values p and q in the binary tree. Args: root (TreeNode): The root node of the binary tree. p (int): The value of the first node. q (int): The value of the second node. Returns: TreeNode: The lowest common ancestor of the nodes with values p and q. >>> tree = build_tree() >>> tree.lowestCommonAncestor(tree.root, 5, 1).val 3 >>> tree.lowestCommonAncestor(tree.root, 5, 4).val 5 def build_tree(): root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.right.left = TreeNode(0) root.right.right = TreeNode(8) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) return BinaryTree(root) def test_lca(): tree = build_tree() assert tree.lowestCommonAncestor(tree.root, 5, 1).val == 3 assert tree.lowestCommonAncestor(tree.root, 5, 4).val == 5 assert tree.lowestCommonAncestor(tree.root, 6, 4).val == 5 assert tree.lowestCommonAncestor(tree.root, 7, 8).val == 3 assert tree.lowestCommonAncestor(tree.root, 1, 0).val == 1 def test_find(): tree = build_tree() assert tree.find(tree.root, 5).val == 5 assert tree.find(tree.root, 9) == None assert tree.find(tree.root, 2).val == 2","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTree: def __init__(self, root): self.root = root def find(self, node, value): if not node: return None if node.val == value: return node left = self.find(node.left, value) if left: return left return self.find(node.right, value) def lowestCommonAncestor(self, root, p, q): if not root: return None if root.val == p or root.val == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right"},{"question":"def encode_string(text: str) -> str: Returns a new string where each character from \`text\` is followed by the number of times it appears consecutively in \`text\`. If a character appears only once consecutively, it is followed by the number \`1\`. >>> encode_string(\\"aaabbcdda\\") == \\"a3b2c1d2a1\\" >>> encode_string(\\"a\\") == \\"a1\\" >>> encode_string(\\"abcd\\") == \\"a1b1c1d1\\" >>> encode_string(\\"aaa\\") == \\"a3\\" >>> encode_string(\\"\\") == \\"\\" >>> encode_string(\\"aabbccddeeff\\") == \\"a2b2c2d2e2f2\\" >>> encode_string(\\"!!**\\") == \\"#2!2*2\\"","solution":"def encode_string(text): Returns a new string where each character from \`text\` is followed by the number of times it appears consecutively in \`text\`. If a character appears only once consecutively, it is followed by the number \`1\`. if not text: return \\"\\" encoded = [] count = 1 prev_char = text[0] for char in text[1:]: if char == prev_char: count += 1 else: encoded.append(f'{prev_char}{count}') prev_char = char count = 1 # Add the last character sequence encoded.append(f'{prev_char}{count}') return ''.join(encoded)"},{"question":"def findPoisonedDuration(timeSeries, damageDuration): Calculate the total time for which the target suffers from the poisonous spell. Parameters: timeSeries (list): A list of integers representing the time at which the spells are cast. damageDuration (int): The duration of the damage caused by each spell. Returns: int: The total time of suffering. Examples: >>> findPoisonedDuration([2], 4) 4 >>> findPoisonedDuration([1, 5], 4) 8 >>> findPoisonedDuration([2, 3, 4], 5) 7 >>> findPoisonedDuration([1, 4, 5], 4) 8 >>> findPoisonedDuration([], 4) 0 >>> findPoisonedDuration([1, 6, 11], 4) 12","solution":"def findPoisonedDuration(timeSeries, damageDuration): Calculate the total time for which the target suffers from the poisonous spell. Parameters: timeSeries (list): A list of integers representing the time at which the spells are cast. damageDuration (int): The duration of the damage caused by each spell. Returns: int: The total time of suffering. if not timeSeries: return 0 total_time = 0 for i in range(len(timeSeries) - 1): total_time += min(timeSeries[i + 1] - timeSeries[i], damageDuration) return total_time + damageDuration"},{"question":"class TreeNode: def __init__(self, val: int): self.val = val self.parent = None def build_tree(parents): nodes = [TreeNode(i + 1) for i in range(len(parents))] root = None for i, parent_index in enumerate(parents): if parent_index == -1: root = nodes[i] else: nodes[i].parent = nodes[parent_index - 1] return root, nodes def find_path_to_root(node): path = [] while node: path.append(node.val) node = node.parent return path def lca(parents, p, q): Find the lowest common ancestor (LCA) of two nodes in a binary tree. The tree is represented as an array where parents[i] is the parent of node i+1. The root of the tree has parents[i] equal to -1. >>> lca([-1, 1, 1, 2, 2, 3, 3], 4, 5) 2 >>> lca([-1, 1, 1, 2, 3], 4, 5) 1 >>> lca([-1, 1, 1, 2, 2, 3, 3], 2, 4) 2 >>> lca([-1, 1, 1], 2, 3) 1 >>> lca([-1], 1, 1) 1","solution":"class TreeNode: def __init__(self, val: int): self.val = val self.parent = None def build_tree(parents): nodes = [TreeNode(i + 1) for i in range(len(parents))] root = None for i, parent_index in enumerate(parents): if parent_index == -1: root = nodes[i] else: nodes[i].parent = nodes[parent_index - 1] return root, nodes def find_path_to_root(node): path = [] while node: path.append(node.val) node = node.parent return path def lca(parents, p, q): _, nodes = build_tree(parents) node_p = nodes[p - 1] node_q = nodes[q - 1] path_p = find_path_to_root(node_p) path_q = find_path_to_root(node_q) path_p.reverse() path_q.reverse() i = 0 while i < len(path_p) and i < len(path_q) and path_p[i] == path_q[i]: i += 1 return path_p[i - 1]"},{"question":"def longest_good_substring(s: str) -> str: Return the longest \\"good\\" substring of s. A substring is considered \\"good\\" if it contains both the lowercase and uppercase versions of each letter in the substring. >>> longest_good_substring(\\"abc\\") '' >>> longest_good_substring(\\"aA\\") 'aA' >>> longest_good_substring(\\"aAbBcC\\") 'aAbBcC' >>> longest_good_substring(\\"aAbBcCdefF\\") 'aAbBcC' >>> longest_good_substring(\\"xyzAaBbCcdef\\") 'AaBbCc' >>> longest_good_substring(\\"aAbBcCaDcdfF\\") in ['aAbBcC', 'aAbBcCaDcdfF']","solution":"def longest_good_substring(s): Returns the longest \\"good\\" substring of s. A substring is considered \\"good\\" if it contains both the lowercase and uppercase versions of each letter in the substring. def is_good(sub): return all(c.lower() in sub and c.upper() in sub for c in sub) max_len = 0 good_substring = \\"\\" n = len(s) for i in range(n): for j in range(i+1, n+1): sub = s[i:j] if is_good(sub) and (j - i) > max_len: max_len = j - i good_substring = sub return good_substring"},{"question":"def longest_common_subsequence(s: str, t: str) -> int: Returns the length of the longest common subsequence that is a substring in both s and t. >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abcd\\", \\"abxyz\\") 2 >>> longest_common_subsequence(\\"xyzabcd\\", \\"wtabcd\\") 4 >>> longest_common_subsequence(\\"abc\\", \\"axbyc\\") 1 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence(\\"abcbdab\\", \\"bdcaba\\") 2","solution":"def longest_common_subsequence(s, t): Returns the length of the longest common subsequence that is a substring in both s and t. m, n = len(s), len(t) # Create a 2D array to store lengths of longest common suffixes of substrings. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build dp array and keep track of the maximum length. result = 0 for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 result = max(result, dp[i][j]) else: dp[i][j] = 0 return result"},{"question":"def max_pairs(nums1: List[int], nums2: List[int]) -> int: Finds the maximum number of pairs such that an element from nums1 is less than an element from nums2. >>> max_pairs([1, 2, 3], [2, 3, 4]) 3 >>> max_pairs([1, 2, 3], [0, 0, 0]) 0 >>> max_pairs([1, 4, 7], [2, 5, 8]) 3 >>> max_pairs([1, 4, 7], [6, 6, 6]) 2 >>> max_pairs([1, 1, 1], [2, 2, 2]) 3 >>> nums1 = list(range(1000)) >>> nums2 = list(range(1, 1001)) >>> max_pairs(nums1, nums2) 1000 pass","solution":"def max_pairs(nums1, nums2): Finds the maximum number of pairs such that an element from nums1 is less than an element from nums2. nums1.sort() nums2.sort() i, j = 0, 0 pairs = 0 while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: pairs += 1 i += 1 j += 1 else: j += 1 return pairs"},{"question":"def max_task_difficulty_sum(tasks: List[int], workers: List[int], p: int) -> int: Maximizes the sum of difficulties of the tasks assigned to workers such that up to p pairs are formed and each worker can be assigned to at most one task, and each task can be assigned to at most one worker. :param tasks: List[int], difficulties of the tasks :param workers: List[int], abilities of the workers :param p: int, number of pairs :return: int, maximum sum of difficulties of assigned tasks, or -1 if p pairs can't be formed >>> max_task_difficulty_sum([4, 3, 2], [3, 5, 5], 2) 7 >>> max_task_difficulty_sum([5, 4, 3], [2, 2, 2], 2) -1","solution":"def max_task_difficulty_sum(tasks, workers, p): Maximizes the sum of difficulties of the tasks assigned to workers such that up to p pairs are formed and each worker can be assigned to at most one task, and each task can be assigned to at most one worker. :param tasks: List[int], difficulties of the tasks :param workers: List[int], abilities of the workers :param p: int, number of pairs :return: int, maximum sum of difficulties of assigned tasks, or -1 if p pairs can't be formed if len(tasks) != len(workers) or p > len(tasks): return -1 tasks.sort(reverse=True) workers.sort(reverse=True) max_sum = 0 task_index, worker_index = 0, 0 pairs_formed = 0 while task_index < len(tasks) and worker_index < len(workers) and pairs_formed < p: if workers[worker_index] >= tasks[task_index]: max_sum += tasks[task_index] pairs_formed += 1 worker_index += 1 task_index += 1 return max_sum if pairs_formed == p else -1"},{"question":"def findLongestCycle(edges): Given a list of directed edges representing a graph, find the length of the longest cycle in the graph. If there is no cycle, return -1. >>> findLongestCycle([1, 2, -1]) -1 >>> findLongestCycle([1, 2, 0]) 3 >>> findLongestCycle([1, 2, 0, 4, 5, 3]) 3 >>> findLongestCycle([1, 2, 0, -1, 3, 4, -1]) 3 >>> findLongestCycle([-1, -1, -1, -1]) -1","solution":"def findLongestCycle(edges): Given a list of directed edges representing a graph, find the length of the longest cycle in the graph. If there is no cycle, return -1. def dfs(node, seen_time, stack, current_time): if seen_time[node] != -1: # If node is already in stack, detect cycle if node in stack: return current_time - seen_time[node] return -1 # Mark the node as visited with the current timestamp seen_time[node] = current_time stack.append(node) # Recur for the next node next_node = edges[node] result = -1 if next_node != -1: result = dfs(next_node, seen_time, stack, current_time + 1) # Backtrack stack.pop() return result n = len(edges) seen_time = [-1] * n longest_cycle = -1 for i in range(n): if seen_time[i] == -1: # Perform DFS if the node has not been seen longest_cycle = max(longest_cycle, dfs(i, seen_time, [], 0)) return longest_cycle"},{"question":"def longest_common_prefix(words: List[str]) -> str: Returns the longest common prefix among the words in the list. :param words: List of strings :return: Longest common prefix string >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"dogma\\", \\"dogged\\"]) == \\"dog\\" >>> longest_common_prefix([\\"\\"] ) == \\"\\" >>> longest_common_prefix([\\"a\\"]) == \\"a\\" if not words: return \\"\\" # Start by assuming the entire first word is the common prefix prefix = words[0] # Compare the prefix with each word in the list for word in words[1:]: while word[:len(prefix)] != prefix: # Shorten the prefix by one character from the end prefix = prefix[:-1] if not prefix: return \\"\\" return prefix","solution":"def longest_common_prefix(words): Returns the longest common prefix among the words in the list. :param words: List of strings :return: Longest common prefix string if not words: return \\"\\" # Start by assuming the entire first word is the common prefix prefix = words[0] # Compare the prefix with each word in the list for word in words[1:]: while word[:len(prefix)] != prefix: # Shorten the prefix by one character from the end prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"def trap(height): Calculate the total amount of water that can be trapped between the terrain units. :param height: List of integers representing the elevation of terrains. :return: Integer representing the total volume of trapped water. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([0,1,2,3,4]) 0 >>> trap([4,3,2,1,0]) 0 >>> trap([1,1,1,1]) 0 >>> trap([3,0,2]) 2 >>> trap([2,0,2]) 2 >>> trap([]) 0 >>> trap([1]) 0","solution":"def trap(height): Calculate the total amount of water that can be trapped between the terrain units. :param height: List of integers representing the elevation of terrains. :return: Integer representing the total volume of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] right_max[-1] = height[-1] # Fill left max array for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right max array for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"from typing import List def check_inclusion(s1: str, s2: str) -> bool: Determine if the characters of s2 can be rearranged to form a substring of s1. >>> check_inclusion(\\"eidbaooo\\", \\"ab\\") == True >>> check_inclusion(\\"eidboaoo\\", \\"ab\\") == False >>> check_inclusion(\\"abcdefg\\", \\"e\\") == True >>> check_inclusion(\\"abc\\", \\"abcd\\") == False >>> check_inclusion(\\"abc\\", \\"cba\\") == True >>> check_inclusion(\\"aaaabbbb\\", \\"abab\\") == True","solution":"def check_inclusion(s1, s2): Determine if s2 can be rearranged to form a substring of s1. from collections import Counter len_s2 = len(s2) counter_s2 = Counter(s2) for i in range(len(s1) - len_s2 + 1): if Counter(s1[i:i+len_s2]) == counter_s2: return True return False"},{"question":"from typing import List def largest_island(grid: List[List[int]]) -> int: Given an n x n grid containing only values 0 and 1, where 0 represents water and 1 represents land, find the largest island. An island is defined as a group of connected 1s (horizontally or vertically) surrounded by water (0s) or the edges of the grid. You may flip up to one 0 to a 1 to form a larger island. Return the size of the largest possible island. >>> largest_island([[1]]) 1 >>> largest_island([[0]]) 1 >>> largest_island([[1, 1], [1, 1]]) 4 >>> largest_island([[0, 0], [0, 0]]) 1 >>> largest_island([[1, 0], [0, 1]]) 3 >>> largest_island([[1, 1], [0, 1]]) 4 >>> largest_island([[1, 0, 0], [1, 1, 0], [0, 0, 1]]) 5 >>> largest_island([ ... [1, 0, 1, 0], ... [0, 1, 0, 1], ... [1, 0, 0, 1], ... [0, 0, 1, 0] ... ]) 5","solution":"def largest_island(grid): Returns the size of the largest possible island after flipping one 0 to a 1. def dfs(x, y, index): if 0 <= x < n and 0 <= y < n and grid[x][y] == 1: grid[x][y] = index size = 1 for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)): size += dfs(x + dx, y + dy, index) return size return 0 n = len(grid) index = 2 sizes = {0: 0} # Step 1: Use DFS to find all islands and their sizes for i in range(n): for j in range(n): if grid[i][j] == 1: sizes[index] = dfs(i, j, index) index += 1 # Step 2: Check all 0s to see the largest potential island if we flip one 0 result = max(sizes.values(), default=0) for i in range(n): for j in range(n): if grid[i][j] == 0: seen = set() possible_size = 1 # the new 1 we just flipped for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)): ni, nj = i + dx, j + dy if 0 <= ni < n and 0 <= nj < n: island_index = grid[ni][nj] if island_index > 1 and island_index not in seen: seen.add(island_index) possible_size += sizes[island_index] result = max(result, possible_size) return result"},{"question":"def can_visit_all_nodes(n: int, startNode: int, connections: List[List[int]]) -> bool: A company is implementing a network of connected nodes for monitoring purposes. The network is represented as an undirected graph with \`n\` nodes and \`m\` edges, where each node has a unique ID from \`0\` to \`n-1\`. You are given an integer \`startNode\`, representing the initial node, and the graph's connections as an array of edges \`connections\`, where \`connections[i] = [u, v]\` indicates an edge between nodes \`u\` and \`v\`. Your task is to determine if it's possible to visit all the nodes starting from the \`startNode\`. You can return to a node if necessary to visit all the nodes. Return \`true\` if it is possible to visit all nodes from the \`startNode\`, otherwise return \`false\`. >>> can_visit_all_nodes(4, 0, [[0, 1], [1, 2], [2, 0], [1, 3]]) True >>> can_visit_all_nodes(5, 0, [[0, 1], [1, 2], [2, 3], [3, 4]]) True >>> can_visit_all_nodes(5, 0, [[0, 1], [1, 2], [2, 0], [3, 4]]) False >>> can_visit_all_nodes(1, 0, []) True >>> can_visit_all_nodes(2, 0, []) False","solution":"def can_visit_all_nodes(n, startNode, connections): from collections import defaultdict, deque # Create an adjacency list to represent the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Use BFS to traverse the graph visited = set() queue = deque([startNode]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbour in graph[node]: if neighbour not in visited: queue.append(neighbour) # Check if all nodes were visited return len(visited) == n"},{"question":"def text_editor(operations: List[str]) -> List[str]: Processes a series of text editor operations and returns the results of \\"PRINTKth\\" operations. Args: operations: List of strings, each string represents an operation (\\"INSERT c\\", \\"DELETE\\", \\"PRINTKth k\\"). Returns: List of results from \\"PRINTKth\\" operations. >>> text_editor([\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\", \\"DELETE\\", \\"PRINTKth 2\\", \\"INSERT d\\", \\"PRINTKth 3\\"]) ['b', 'c']","solution":"def text_editor(operations): Processes a series of text editor operations and returns the results of \\"PRINTKth\\" operations. Args: operations: List of strings, each string represents an operation (\\"INSERT c\\", \\"DELETE\\", \\"PRINTKth k\\"). Returns: List of results from \\"PRINTKth\\" operations. document = [] results = [] for operation in operations: if operation.startswith(\\"INSERT\\"): _, char = operation.split() document.append(char) elif operation == \\"DELETE\\": if document: document.pop() elif operation.startswith(\\"PRINTKth\\"): _, k = operation.split() k = int(k) if k > len(document): results.append(\\"\\") else: results.append(document[k-1]) return results"},{"question":"def min_time_to_complete_jobs(jobs, workers): Returns the minimum amount of time required to complete all jobs given the number of workers. This is found by distributing the jobs optimally among the workers. :param jobs: List[int] - List of job times :param workers: int - Number of workers :return: int - Minimum time to complete all jobs >>> min_time_to_complete_jobs([1, 2, 3, 4, 5], 1) 15 >>> min_time_to_complete_jobs([1, 2, 3, 4, 5], 5) 5 >>> min_time_to_complete_jobs([1, 2, 3, 4, 5], 2) 9 >>> min_time_to_complete_jobs([1, 2, 3, 4, 5], 3) 6 >>> min_time_to_complete_jobs([], 3) 0 >>> min_time_to_complete_jobs([1, 2, 3, 4, 5], 0) 0 >>> min_time_to_complete_jobs([10], 3) 10 >>> min_time_to_complete_jobs([5, 5, 5, 5, 5, 5], 3) 10 >>> min_time_to_complete_jobs([1, 2, 2, 1, 2, 1], 2) 5","solution":"def min_time_to_complete_jobs(jobs, workers): Returns the minimum amount of time required to complete all jobs given the number of workers. This is found by distributing the jobs optimally among the workers. :param jobs: List[int] - List of job times :param workers: int - Number of workers :return: int - Minimum time to complete all jobs if not jobs or workers <= 0: return 0 left, right = max(jobs), sum(jobs) def can_complete_jobs_in_time(time): total_workers = 1 current_sum = 0 for job in jobs: if current_sum + job > time: total_workers += 1 current_sum = 0 if total_workers > workers: return False current_sum += job return total_workers <= workers while left < right: middle = (left + right) // 2 if can_complete_jobs_in_time(middle): right = middle else: left = middle + 1 return left"},{"question":"from typing import List def longest_subarray_with_zero_sum(arr: List[int]) -> int: Given an integer array \`arr\`, write a function to find the length of the longest subarray with a sum that equals zero. >>> longest_subarray_with_zero_sum([]) == 0 >>> longest_subarray_with_zero_sum([1, 2, 3]) == 0 >>> longest_subarray_with_zero_sum([1, -1, 1, -1]) == 4 >>> longest_subarray_with_zero_sum([4, -4, 2, 3]) == 2 >>> longest_subarray_with_zero_sum([3, 4, -7, 5, -6, 6]) == 3 >>> longest_subarray_with_zero_sum([1, 2, -2, 4, -4, 3, -3]) == 6 >>> longest_subarray_with_zero_sum([3, 5, 2, -5, -3, 1]) == 5 >>> longest_subarray_with_zero_sum([0]) == 1 >>> longest_subarray_with_zero_sum([1]) == 0","solution":"def longest_subarray_with_zero_sum(arr): Finds the length of the longest subarray with a sum that equals zero. :param arr: List[int] - An array of integers :return: int - The length of the longest subarray with sum zero sum_map = {} max_len = 0 curr_sum = 0 for i, num in enumerate(arr): curr_sum += num if curr_sum == 0: max_len = i + 1 elif curr_sum in sum_map: max_len = max(max_len, i - sum_map[curr_sum]) else: sum_map[curr_sum] = i return max_len"},{"question":"def three_sum(nums, target): Given an array of integers and a target integer, determine if there are three distinct indices such that the sum of the elements at these indices equals the target. >>> three_sum([1, 2, 3, 4, 5], 12) True >>> three_sum([1, 2, 3, 4, 5], 20) False >>> three_sum([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum([1, 2], 3) False >>> three_sum([1, 4, 45, 6, 10, 8], 22) True >>> three_sum([1, 3, 5, 7, 9], 15) True","solution":"def three_sum(nums, target): Given an array of integers and a target integer, determine if there are three distinct indices such that the sum of the elements at these indices equals the target. nums.sort() n = len(nums) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: sum_ = nums[i] + nums[left] + nums[right] if sum_ == target: return True elif sum_ < target: left += 1 else: right -= 1 return False"},{"question":"class RangeSum: Given a 0-indexed integer array \`arr\` of length \`n\`, implement the \`RangeSum\` class to handle multiple queries related to range sum and updates. - RangeSum(int[] arr): Initializes the object with the integer array \`arr\`. - void update(int index, int val): Updates the value of \`arr\` at the specified index to \`val\`. - int rangeSum(int i, int j): Returns the sum of the elements in \`arr\` within the range \`[i, j]\` (inclusive). Example: >>> arr = [1, 2, 3, 4, 5] >>> obj = RangeSum(arr) >>> obj.rangeSum(0, 4) 15 >>> obj.update(2, 10) >>> obj.rangeSum(0, 4) 22 >>> obj.rangeSum(2, 2) 10 def __init__(self, arr): pass def update(self, index, val): pass def rangeSum(self, i, j): pass def test_initial_sum(): arr = [1, 2, 3, 4, 5] obj = RangeSum(arr) assert obj.rangeSum(0, 4) == 15 assert obj.rangeSum(1, 3) == 9 def test_update_and_sum(): arr = [1, 2, 3, 4, 5] obj = RangeSum(arr) obj.update(2, 10) assert obj.rangeSum(0, 4) == 22 assert obj.rangeSum(2, 2) == 10 def test_updates_and_sum(): arr = [1, 2, 3, 4, 5] obj = RangeSum(arr) obj.update(2, 10) assert obj.rangeSum(0, 4) == 22 obj.update(4, 7) assert obj.rangeSum(0, 4) == 24 assert obj.rangeSum(0, 1) == 3 assert obj.rangeSum(3, 4) == 11 assert obj.rangeSum(0, 2) == 13 def test_edge_case(): arr = [0] obj = RangeSum(arr) assert obj.rangeSum(0, 0) == 0 obj.update(0, 5) assert obj.rangeSum(0, 0) == 5","solution":"class RangeSum: def __init__(self, arr): self.n = len(arr) self.arr = arr[:] self.prefix_sum = self._build_prefix_sum(arr) def _build_prefix_sum(self, arr): prefix_sum = [0] * (self.n + 1) for i in range(1, self.n + 1): prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1] return prefix_sum def update(self, index, val): difference = val - self.arr[index] self.arr[index] = val for i in range(index + 1, self.n + 1): self.prefix_sum[i] += difference def rangeSum(self, i, j): return self.prefix_sum[j + 1] - self.prefix_sum[i]"},{"question":"def smallestMissingPositive(arr: List[int]) -> int: Find the smallest missing positive integer from the sorted unique integer list 'arr'. >>> smallestMissingPositive([1, 2, 3, 5]) == 4 >>> smallestMissingPositive([2, 3, 4, 7]) == 1","solution":"def smallestMissingPositive(arr): Returns the smallest missing positive integer from the sorted unique integer list 'arr'. # Initialize the smallest missing positive integer to 1 missing = 1 # Iterate through the array to find the smallest missing positive integer for num in arr: if num == missing: missing += 1 elif num > missing: break return missing"},{"question":"def shift_string(s: str, k: int) -> str: Shifts each letter in the string s k times to the right in the alphabet. >>> shift_string(\\"abc\\", 2) \\"cde\\" >>> shift_string(\\"xyz\\", 1) \\"yza\\" >>> shift_string(\\"abc\\", 27) \\"bcd\\" >>> shift_string(\\"xyz\\", 52) \\"xyz\\" >>> shift_string(\\"abcdefghijklmnopqrstuvwxyz\\", 1) \\"bcdefghijklmnopqrstuvwxyza\\" >>> shift_string(\\"\\", 5) \\"\\" >>> shift_string(\\"aaa\\", 3) \\"ddd\\"","solution":"def shift_string(s, k): Shifts each letter in the string s k times to the right in the alphabet. shifted_string = [] for char in s: new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) shifted_string.append(new_char) return \\"\\".join(shifted_string)"},{"question":"from typing import List def sort_odd_even(nums: List[int]) -> List[int]: Given a list of integers, sort the list such that all the odd numbers appear before all the even numbers while maintaining their relative order within their respective groups. >>> sort_odd_even([3, 1, 2, 4]) == [3, 1, 2, 4] >>> sort_odd_even([5, 2, 3, 4, 7]) == [5, 3, 7, 2, 4] >>> sort_odd_even([]) == [] >>> sort_odd_even([1]) == [1] >>> sort_odd_even([2]) == [2] >>> sort_odd_even([4, 2, 6, 8]) == [4, 2, 6, 8] pass","solution":"def sort_odd_even(nums): Sort the list such that all the odd numbers appear before all the even numbers while maintaining their relative order within their respective groups. odds = [num for num in nums if num % 2 != 0] evens = [num for num in nums if num % 2 == 0] return odds + evens"},{"question":"def shift_string(s: str, k: int) -> str: Shifts the string s to the right by k positions. Parameters: - s (str): The input string to be shifted. - k (int): The number of positions to shift the string. Returns: - str: The shifted string. >>> shift_string(\\"abcdefg\\", 0) == \\"abcdefg\\" >>> shift_string(\\"abcdefg\\", 1) == \\"gabcdef\\" >>> shift_string(\\"abcdefg\\", 7) == \\"abcdefg\\" >>> shift_string(\\"abcdefg\\", 3) == \\"efgabcd\\" >>> shift_string(\\"abcdefg\\", 10) == \\"efgabcd\\" >>> shift_string(\\"\\", 3) == \\"\\" >>> shift_string(\\"abcdefg\\", 14) == \\"abcdefg\\" >>> shift_string(\\"abcdefg\\", 16) == \\"fgabcde\\"","solution":"def shift_string(s, k): Shifts the string s to the right by k positions. Parameters: - s (str): The input string to be shifted. - k (int): The number of positions to shift the string. Returns: - str: The shifted string. if not s: return s # Empty string case n = len(s) # In case k is greater than the length of the string, reduce k k = k % n # Shift the string if k == 0: return s return s[-k:] + s[:-k]"},{"question":"def trap_rain_water(elevation): Calculates the amount of water that can be trapped after a rainstorm. :param elevation: List[int]. A list of integers representing the elevation map. :return: int. The total amount of trapped water. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([]) 0 >>> trap_rain_water([1, 2, 3, 4, 5]) 0 >>> trap_rain_water([5, 4, 3, 2, 1]) 0 >>> trap_rain_water([3, 0, 2, 0, 4]) 7 >>> trap_rain_water([1,1,1,1,1,1]) 0","solution":"def trap_rain_water(elevation): Calculates the amount of water that can be trapped after a rainstorm. :param elevation: List[int]. A list of integers representing the elevation map. :return: int. The total amount of trapped water. if not elevation: return 0 n = len(elevation) left_max = [0] * n right_max = [0] * n left_max[0] = elevation[0] for i in range(1, n): left_max[i] = max(left_max[i-1], elevation[i]) right_max[n-1] = elevation[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], elevation[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - elevation[i] return trapped_water"},{"question":"from typing import List def max_sum_subsequence(arr: List[int], k: int) -> List[int]: Given an integer array \`arr\` and an integer \`k\`, find the maximum possible sum of elements in a subsequence of \`arr\` such that the subsequence has a length of exactly \`k\`. Maintain the smallest lexicographical order when multiple subsequences have the same sum. >>> max_sum_subsequence([3, 4, 3, 3, 4], 2) [4, 4] >>> max_sum_subsequence([1], 1) [1] >>> max_sum_subsequence([1, 2, 3, 4], 4) [1, 2, 3, 4] >>> max_sum_subsequence([5, 1, 3, 7], 3) [5, 3, 7] >>> max_sum_subsequence([3, 3, 3, 4, 4], 2) [4, 4] >>> max_sum_subsequence([1, 2, 3], 4) [] pass","solution":"def max_sum_subsequence(arr, k): Returns the maximum sum subsequence of length k with the smallest lexicographical order when multiple subsequences have the same sum. if len(arr) < k: return [] n = len(arr) max_sum = float('-inf') result = [] def helper(idx, current_subsequence): nonlocal max_sum, result if len(current_subsequence) == k: current_sum = sum(current_subsequence) if (current_sum > max_sum) or (current_sum == max_sum and current_subsequence < result): max_sum = current_sum result = current_subsequence[:] return if idx >= n: return # Include current element current_subsequence.append(arr[idx]) helper(idx + 1, current_subsequence) current_subsequence.pop() # Exclude current element helper(idx + 1, current_subsequence) helper(0, []) return result"},{"question":"from typing import List def sum_with_wraparound(nums: List[int], k: int) -> List[int]: Returns a new list where each element at index i is the sum of nums[i] and the k next elements in nums, wrapping around if necessary. >>> sum_with_wraparound([1, 2, 3, 4], 2) [6, 9, 8, 7] >>> sum_with_wraparound([1, 2, 3, 4], 1) [3, 5, 7, 5] >>> sum_with_wraparound([1, 2, 3, 4], 0) [1, 2, 3, 4] >>> sum_with_wraparound([5], 3) [20] >>> sum_with_wraparound([10, 20, 30], 2) [60, 60, 60] >>> sum_with_wraparound([0, 0, 0, 0], 2) [0, 0, 0, 0]","solution":"def sum_with_wraparound(nums, k): Returns a new list where each element at index i is the sum of nums[i] and the k next elements in nums, wrapping around if necessary. n = len(nums) result = [] for i in range(n): current_sum = sum(nums[(i + j) % n] for j in range(k + 1)) result.append(current_sum) return result"},{"question":"def minDistance(word1: str, word2: str) -> int: Given two strings \`word1\` and \`word2\`, return the minimum number of operations required to convert \`word1\` to \`word2\`. You have the following three operations permitted on a word: 1. Insert a character 2. Delete a character 3. Replace a character >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"\\", \\"\\") 0 >>> minDistance(\\"a\\", \\"b\\") 1 >>> minDistance(\\"kitten\\", \\"sitting\\") 3 >>> minDistance(\\"flaw\\", \\"lawn\\") 2 >>> minDistance(\\"abc\\", \\"yabd\\") 2 >>> minDistance(\\"\\", \\"abc\\") 3 >>> minDistance(\\"abc\\", \\"\\") 3 >>> minDistance(\\"abc\\", \\"abc\\") 0","solution":"def minDistance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. Operations allowed: 1. Insert a character 2. Delete a character 3. Replace a character m, n = len(word1), len(word2) # Create a 2D array to store the number of operations dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If word1 is empty, insert all characters of word2 elif j == 0: dp[i][j] = i # If word2 is empty, delete all characters of word1 elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are the same, ignore and recur for the remaining strings else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete from word1 dp[i][j - 1], # Insert into word1 dp[i - 1][j - 1]) # Replace in word1 return dp[m][n]"},{"question":"from typing import List def isAlienSorted(words: List[str], order: str) -> bool: Determine if the given list of words is sorted lexicographically in an alien language. Args: words (List[str]): A list of words consisting only of lowercase English letters. order (str): A string representing the order of characters in an alien language. Returns: bool: True if words are sorted according to the given order, False otherwise. >>> isAlienSorted([\\"hello\\",\\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") True >>> isAlienSorted([\\"word\\",\\"world\\",\\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") False >>> isAlienSorted([\\"apple\\",\\"app\\"], \\"abcdefghijklmnopqrstuvwxyz\\") False >>> isAlienSorted([\\"apple\\",\\"apple\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> isAlienSorted([\\"single\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> isAlienSorted([], \\"abcdefghijklmnopqrstuvwxyz\\") True from solution import isAlienSorted def test_alien_sorted(): assert isAlienSorted([\\"hello\\",\\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") == True assert isAlienSorted([\\"word\\",\\"world\\",\\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") == False assert isAlienSorted([\\"apple\\",\\"app\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == False assert isAlienSorted([\\"app\\",\\"apple\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == True assert isAlienSorted([\\"app\\",\\"apple\\",\\"banana\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == True def test_same_words(): assert isAlienSorted([\\"apple\\",\\"apple\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == True assert isAlienSorted([\\"banana\\",\\"banana\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") == True def test_single_word(): assert isAlienSorted([\\"single\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == True def test_empty_list(): assert isAlienSorted([], \\"abcdefghijklmnopqrstuvwxyz\\") == True def test_reverse_alphabet(): assert isAlienSorted([\\"zebra\\", \\"apple\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") == True assert isAlienSorted([\\"apple\\", \\"zebra\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") == False","solution":"def isAlienSorted(words, order): Returns True if the list of words is sorted according to the given order. Otherwise, returns False. order_index = {char: index for index, char in enumerate(order)} def is_sorted(word1, word2): for c1, c2 in zip(word1, word2): if c1 != c2: return order_index[c1] < order_index[c2] return len(word1) <= len(word2) for i in range(len(words) - 1): if not is_sorted(words[i], words[i + 1]): return False return True"},{"question":"def max_tasks_on_time(tasks: List[List[int]]) -> int: Returns the maximum number of tasks that can be completed on time. Parameters: tasks (List[List[int]]): A list of tasks where each task is represented as [taskTime, deadline]. Returns: int: The maximum number of tasks that can be completed before their respective deadlines. Examples: >>> max_tasks_on_time([[3, 3], [2, 5], [1, 2]]) == 2 >>> max_tasks_on_time([[1, 3], [2, 5], [3, 6]]) == 3","solution":"def max_tasks_on_time(tasks): Returns the maximum number of tasks that can be completed on time. Parameters: tasks (List[List[int]]): A list of tasks where each task is represented as [taskTime, deadline]. Returns: int: The maximum number of tasks that can be completed before their respective deadlines. tasks.sort(key=lambda x: x[1]) # Sort tasks by their deadlines current_time = 0 count = 0 for task in tasks: task_time, deadline = task if current_time + task_time <= deadline: # If the task can be finished before its deadline current_time += task_time count += 1 return count"},{"question":"from typing import List def max_sliding_window(arr: List[int], k: int) -> List[int]: Returns the maximum values of each subarray of length \`k\`. >>> max_sliding_window([1,3,-1,-3,5,3,6,7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([1,2,3,4,5], 1) [1, 2, 3, 4, 5] >>> max_sliding_window([1,2,3,4,5], 5) [5] >>> max_sliding_window([], 3) [] >>> max_sliding_window([1,2,3], 4) [] >>> max_sliding_window([1,2,3], 0) [] >>> max_sliding_window([1,2,3], -1) [] >>> max_sliding_window([10], 1) [10] >>> max_sliding_window([10], 2) [] >>> max_sliding_window([4, 4, 4, 4, 4], 3) [4, 4, 4]","solution":"from collections import deque from typing import List def max_sliding_window(arr: List[int], k: int) -> List[int]: Returns the maximum values of each subarray of length \`k\`. Args: arr: List of integers. k: Integer, length of the sliding window. Returns: List of integers representing the maximum values of each subarray of length \`k\`. # Return an empty array if length of array is less than k if len(arr) < k or k <= 0: return [] deq = deque() result = [] for i in range(len(arr)): # Remove elements from deque that are out of this window if deq and deq[0] == i - k: deq.popleft() # Remove elements smaller than current element as they are of no use while deq and arr[deq[-1]] < arr[i]: deq.pop() deq.append(i) # Append the current max to result list (starts only when we have a full window) if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"def find_palindrome_pairs(text: str) -> List[List[int]]: Given a string \`text\`, return an array of index pairs \`[start, end]\` such that the substring between the start and end indices (inclusive) forms a palindrome. The returned list of index pairs should be in the order they appear in the input string. In case of overlapping palindromes, include all possible pairs. >>> find_palindrome_pairs(\\"ababa\\") [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [0, 2], [1, 3], [2, 4], [0, 4]] >>> find_palindrome_pairs(\\"a\\") [[0, 0]]","solution":"def find_palindrome_pairs(text): Returns all index pairs [start, end] where the substring text[start:end] is a palindrome. palindromes = [] n = len(text) for i in range(n): # Find all odd length palindromes centered at i start, end = i, i while start >= 0 and end < n and text[start] == text[end]: palindromes.append([start, end]) start -= 1 end += 1 # Find all even length palindromes centered between i and i+1 start, end = i, i + 1 while start >= 0 and end < n and text[start] == text[end]: palindromes.append([start, end]) start -= 1 end += 1 return palindromes"},{"question":"def to_wave_array(arr: List[int]) -> List[int]: Modifies the given list in-place into a wave array. A wave array satisfies the condition: - arr[i] >= arr[i+1] if i is even - arr[i] <= arr[i+1] if i is odd >>> to_wave_array([3, 6, 5, 10, 7, 20]) [6, 3, 10, 5, 20, 7] >>> to_wave_array([10, 90, 49, 2, 1, 5, 23]) [10, 49, 2, 90, 1, 23, 5] >>> to_wave_array([1]) [1] >>> to_wave_array([4, 3]) [4, 3] or [3, 4] >>> to_wave_array([5, 5, 5, 5, 5]) [5, 5, 5, 5, 5]","solution":"def to_wave_array(arr): Modifies the given list in-place into a wave array. A wave array satisfies the condition: - arr[i] >= arr[i+1] if i is even - arr[i] <= arr[i+1] if i is odd for i in range(len(arr) - 1): if i % 2 == 0: if arr[i] < arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] else: if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] return arr"},{"question":"def can_segment(s: str, dictionary: List[str]) -> bool: Determines if string \`s\` can be segmented into a sequence of one or more dictionary words. Args: s (str): The string to be segmented. dictionary (list): A list of dictionary words. Returns: bool: True if \`s\` can be segmented, otherwise False. Examples: >>> can_segment(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> can_segment(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> can_segment(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False","solution":"def can_segment(s, dictionary): Determines if string \`s\` can be segmented into a sequence of one or more dictionary words. Args: s (str): The string to be segmented. dictionary (list): A list of dictionary words. Returns: bool: True if \`s\` can be segmented, otherwise False. word_set = set(dictionary) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_trees(n): Generate all binary search trees (BST) that have exactly \`n\` nodes of unique values from \`1\` to \`n\`. >>> serialize(generate_trees(0)) == [] True >>> serialize(generate_trees(1)) == [(1, None, None)] True >>> serialize(generate_trees(2)) == [ (1, None, (2, None, None)), (2, (1, None, None), None) ] True >>> serialize(generate_trees(3)) == [ (1, None, (2, None, (3, None, None))), (1, None, (3, (2, None, None), None)), (2, (1, None, None), (3, None, None)), (3, (1, None, (2, None, None)), None), (3, (2, (1, None, None), None), None) ] True def serialize(root): Helper function to serialize the BST to a tuple. if not root: return None return (root.val, serialize(root.left), serialize(root.right))","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_trees(n): if n == 0: return [] def generate(start, end): if start > end: return [None] all_trees = [] for root_val in range(start, end + 1): left_trees = generate(start, root_val - 1) right_trees = generate(root_val + 1, end) for l in left_trees: for r in right_trees: root = TreeNode(root_val) root.left = l root.right = r all_trees.append(root) return all_trees return generate(1, n) def serialize(root): Helper function to serialize the BST to a tuple. if not root: return None return (root.val, serialize(root.left), serialize(root.right))"},{"question":"from typing import List def good_view_buildings(heights: List[int]) -> int: Returns the number of buildings that have a good view. >>> good_view_buildings([5]) 1 >>> good_view_buildings([1, 2, 3, 4, 5]) 1 >>> good_view_buildings([5, 4, 3, 2, 1]) 5 >>> good_view_buildings([4, 2, 3, 1]) 3 >>> good_view_buildings([4, 4, 4, 4]) 1 >>> good_view_buildings([4, 1, 2, 1, 2]) 2","solution":"def good_view_buildings(heights): Returns the number of buildings that have a good view. n = len(heights) good_view_count = 0 max_right_height = float('-inf') # Initialize to minus infinity # Traverse the buildings from right to left for i in range(n-1, -1, -1): if heights[i] > max_right_height: good_view_count += 1 max_right_height = heights[i] return good_view_count"},{"question":"def min_operations_to_all_ones(arr: List[int], k: int) -> int: Returns the minimum number of operations required to make all elements in the array equal to 1, or -1 if it is not possible. Parameters: arr (List[int]): A list of integers containing only 0's and 1's. k (int): The length of the subarray to flip. Returns: int: The minimum number of operations required or -1 if it's not possible. Example: >>> min_operations_to_all_ones([0,1,0], 1) 2 >>> min_operations_to_all_ones([1,1,1], 2) 0","solution":"def min_operations_to_all_ones(arr, k): Returns the minimum number of operations required to make all elements in the array equal to 1, or -1 if it is not possible. n = len(arr) flips = [0] * n # flips[i] will store the number of flips needed up to index i flip_count = 0 operations = 0 for i in range(n): if i >= k: flip_count -= flips[i - k] if (arr[i] + flip_count) % 2 == 0: if i + k > n: return -1 operations += 1 flip_count += 1 flips[i] = 1 return operations"},{"question":"def min_conference_rooms(tasks): Determine the minimum number of conference rooms required to schedule all the given tasks without conflicts. Tasks: list of tuples (start time, duration) Returns: minimum number of rooms required >>> min_conference_rooms([]) == 0 >>> min_conference_rooms([(0, 1)]) == 1 >>> min_conference_rooms([(1, 3), (5, 2), (8, 4)]) == 1 >>> min_conference_rooms([(1, 3), (2, 4), (3, 2)]) == 3 >>> min_conference_rooms([(1, 4), (2, 5), (5, 2), (7, 3)]) == 2 >>> min_conference_rooms([(1, 3), (1, 3), (1, 3)]) == 3 >>> min_conference_rooms([(1, 1), (10, 2), (20, 3)]) == 1","solution":"import heapq def min_conference_rooms(tasks): Determine the minimum number of conference rooms required to schedule all the given tasks without conflicts. Tasks: list of tuples (start time, duration) Returns: minimum number of rooms required if not tasks: return 0 # Create a list of (start, end) times for each task events = [(s, s + d) for s, d in tasks] # Sort the events by start time events.sort(key=lambda x: x[0]) # Use a min-heap to track the end time of tasks min_heap = [] for start, end in events: # If the room with the earliest end time is free, remove it from the heap if min_heap and min_heap[0] <= start: heapq.heappop(min_heap) # Add the current task's end time to the heap heapq.heappush(min_heap, end) # The number of rooms needed is the size of the heap return len(min_heap)"},{"question":"from typing import List def minFloodlights(heights: List[int], k: int) -> int: Determines the minimum number of floodlights needed to cover all buildings in the list. :param heights: A list of integers representing the heights of buildings. :param k: An integer representing the maximum distance a floodlight can illuminate in both directions. :return: The minimum number of floodlights needed. def test_minFloodlights_one_building(): assert minFloodlights([5], 1) == 1 def test_minFloodlights_all_adjacent_coverage(): assert minFloodlights([4, 2, 6, 3, 5], 1) == 3 def test_minFloodlights_larger_gap(): assert minFloodlights([3, 8, 4, 7, 3, 2], 2) == 2 def test_minFloodlights_equal_coverage(): assert minFloodlights([2, 4, 3, 5, 2, 6, 7], 3) == 2 def test_minFloodlights_edge_case_no_buildings(): assert minFloodlights([], 2) == 0 def test_minFloodlights_one_floodlight_needed(): assert minFloodlights([1, 3, 5, 7, 9], 5) == 1 def test_minFloodlights_more_floodlights_needed(): assert minFloodlights([1, 3, 5, 7, 9], 1) == 3","solution":"from typing import List def minFloodlights(heights: List[int], k: int) -> int: Determines the minimum number of floodlights needed to cover all buildings in the list. :param heights: A list of integers representing the heights of buildings. :param k: An integer representing the maximum distance a floodlight can illuminate in both directions. :return: The minimum number of floodlights needed. n = len(heights) floodlights = 0 i = 0 while i < n: # Find the farthest building to place a floodlight that can cover the current building farthest = min(i + k, n - 1) while farthest > i and farthest - k <= i: farthest -= 1 # Place the floodlight here floodlights += 1 # Move to the next building that is not covered by this floodlight i = farthest + k + 1 return floodlights"},{"question":"def find_good_indices(nums, k, target): Finds the number of good indices in the array where the median of the contiguous subarray of length k starting from that index is >= target. Parameters: nums (list of int): The array of integers. k (int): The length of the contiguous subarray. target (int): The target for the median to compare against. Returns: int: The number of good indices. def find_median(subarray): Finds the median of a subarray. Parameters: subarray (list of int): The subarray of integers. Returns: float: The median of the subarray. pass # This is where you implement the median finding logic pass # This is where you implement the logic to count the good indices # Test cases def test_no_good_indices(): assert find_good_indices([1, 2, 3], 2, 5) == 0 def test_all_good_indices(): assert find_good_indices([5, 5, 5, 5], 2, 4.5) == 3 def test_mixed_good_and_bad_indices(): assert find_good_indices([1, 3, 2, 6, 7, 1], 3, 3) == 3 def test_good_indices_with_average_median(): assert find_good_indices([4, 2, 1, 7, 5, 3], 4, 3) == 3 def test_single_element_subarray(): assert find_good_indices([3, 1, 2], 1, 1) == 3 def test_no_indices(): assert find_good_indices([], 1, 1) == 0","solution":"def find_good_indices(nums, k, target): Finds the number of good indices in the array. Parameters: nums (list of int): The array of integers k (int): The length of the contiguous subarray target (int): The target for the median to compare against Returns: int: The number of good indices def find_median(subarray): Finds the median of a subarray. Parameters: subarray (list of int): The subarray of integers Returns: float: The median of the subarray subarray.sort() mid = len(subarray) // 2 if len(subarray) % 2 == 0: return (subarray[mid - 1] + subarray[mid]) / 2 else: return subarray[mid] good_indices_count = 0 for i in range(len(nums) - k + 1): subarray = nums[i:i+k] if find_median(subarray) >= target: good_indices_count += 1 return good_indices_count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find(root, val): Helper function to find a node with given value in BST. # Your code here def lowest_common_ancestor(root, p, q): Returns the lowest common ancestor of nodes with values p and q. # Your code here def test_example(): # Construct the BST root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) root.right.left = TreeNode(7) root.right.right = TreeNode(9) # Test LCA assert lowest_common_ancestor(root, 2, 8).val == 6 assert lowest_common_ancestor(root, 2, 4).val == 2 assert lowest_common_ancestor(root, 7, 9).val == 8 assert lowest_common_ancestor(root, 0, 9).val == 6 assert lowest_common_ancestor(root, 3, 5).val == 4 def test_nonexistent_node(): # Construct the BST root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) root.right.left = TreeNode(7) root.right.right = TreeNode(9) # Test LCA when one or both nodes do not exist assert lowest_common_ancestor(root, 2, 10) is None assert lowest_common_ancestor(root, 10, 8) is None assert lowest_common_ancestor(root, 10, 11) is None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find(root, val): Helper function to find a node with given value in BST. if root is None: return None if val == root.val: return root elif val < root.val: return find(root.left, val) else: return find(root.right, val) def lowest_common_ancestor(root, p, q): Returns the lowest common ancestor of nodes with values p and q. if find(root, p) is None or find(root, q) is None: return None def lca_helper(node, p, q): if node is None: return None if p < node.val and q < node.val: return lca_helper(node.left, p, q) elif p > node.val and q > node.val: return lca_helper(node.right, p, q) else: return node return lca_helper(root, p, q)"},{"question":"def max_profit(prices: List[int], queries: List[List[int]]) -> List[int]: Returns an array containing the maximum profit for each query. :param prices: List of prices where prices[i] is the price of the stock on the i-th day. :param queries: List of queries where queries[i] is a list of two integers [a, b]. :return: List of integers where each integer is the maximum profit for the corresponding query. pass def test_max_profit_no_profit(): assert max_profit([3, 2, 1], [[0, 2], [1, 2]]) == [0, 0] def test_max_profit_partial_profit(): assert max_profit([10, 7, 5, 8, 11, 9], [[1, 4], [0, 5]]) == [6, 6] def test_max_profit_full_profits(): assert max_profit([1, 2, 3, 4, 5], [[0, 4], [0, 2]]) == [4, 2] def test_max_profit_multiple_same_day(): assert max_profit([1, 2, 3, 4, 5], [[0, 0], [3, 3]]) == [0, 0] def test_max_profit_edge_cases(): assert max_profit([7, 1, 5, 3, 6, 4], [[0, 5], [4, 4], [1, 4]]) == [5, 0, 5]","solution":"def max_profit(prices, queries): Returns an array containing the maximum profit for each query. :param prices: List of prices where prices[i] is the price of the stock on the i-th day. :param queries: List of queries where queries[i] is a list of two integers [a, b]. :return: List of integers where each integer is the maximum profit for the corresponding query. results = [] for a, b in queries: if a >= len(prices) or b >= len(prices) or b <= a: results.append(0) continue max_profit = 0 min_price = prices[a] for i in range(a + 1, b + 1): max_profit = max(max_profit, prices[i] - min_price) min_price = min(min_price, prices[i]) results.append(max_profit) return results"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Rearranges the elements of nums to form the largest possible integer and returns it as a string. >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([1]) '1' >>> largest_number([0]) '0' >>> largest_number([10, 2]) '210' >>> largest_number([111, 12]) '12111' >>> largest_number([0, 0]) '0' >>> largest_number([0, 0, 0, 0]) '0' >>> largest_number([432, 43243]) '43243432' >>> largest_number([128, 12]) '12812' >>> largest_number([0, 0, 0, 1]) '1000'","solution":"from functools import cmp_to_key def largest_number(nums): Rearranges the elements of nums to form the largest possible integer and returns it as a string. # Convert all the integers in the list to strings for easier comparison nums_str = list(map(str, nums)) # Define a custom comparator function def compare(x, y): # Compare based on concatenated results if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort the numbers using the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Concatenate the sorted list into a single string result = ''.join(nums_str) # Edge case: check if the result is all zeros if result[0] == '0': return '0' return result"},{"question":"from typing import List, Tuple def unique_users_in_time_window(interactions: List[Tuple[str, int]], start: int, end: int) -> int: Returns the number of unique users that interacted with a post within a given time window. Args: interactions (List[Tuple[str, int]]): A list of tuples representing user interactions. start (int): The start timestamp of the time window. end (int): The end timestamp of the time window. Returns: int: The count of unique users interacting within the time window. >>> interactions = [(\\"user1\\", 1001), (\\"user2\\", 1004), (\\"user1\\", 1006), (\\"user3\\", 1007)] >>> unique_users_in_time_window(interactions, 1002, 1006) 2 >>> interactions = [(\\"user1\\", 1002), (\\"user2\\", 1003), (\\"user1\\", 1004), (\\"user3\\", 1005)] >>> unique_users_in_time_window(interactions, 1002, 1005) 3 >>> interactions = [(\\"user1\\", 1001), (\\"user2\\", 1004), (\\"user1\\", 1006), (\\"user3\\", 1007)] >>> unique_users_in_time_window(interactions, 1008, 1010) 0","solution":"from typing import List, Tuple def unique_users_in_time_window(interactions: List[Tuple[str, int]], start: int, end: int) -> int: Returns the number of unique users that interacted within the given time window. Args: interactions (List[Tuple[str, int]]): A list of tuples with user ID and timestamp. start (int): The start timestamp of the time window. end (int): The end timestamp of the time window. Returns: int: The count of unique users interacting within the time window. unique_users = set() for user_id, timestamp in interactions: if start <= timestamp <= end: unique_users.add(user_id) return len(unique_users)"},{"question":"from typing import List from collections import Counter import heapq from collections import deque def rearrangeString(s: str, k: int) -> str: Rearrange the characters in the string \`s\` such that the same characters are at least \`k\` distance apart. If it is not possible to rearrange the string in this way, return an empty string. If there are multiple valid arrangements, return any of them. Args: s (str): The input string consisting of lowercase English letters. k (int): The minimum distance that the same characters should have. Returns: str: The rearranged string or an empty string if it's not possible. Examples: >>> rearrangeString(\\"aabbcc\\", 2) in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\"] True >>> rearrangeString(\\"aaabc\\", 3) \\"\\" >>> rearrangeString(\\"aaadbbcc\\", 2) in [\\"abacabcd\\", \\"abcabcd\\", \\"abacabc\\"] True >>> rearrangeString(\\"a\\", 0) \\"a\\" >>> rearrangeString(\\"a\\", 1) \\"a\\" >>> rearrangeString(\\"aaaaa\\", 2) \\"\\" >>> rearrangeString(\\"aabb\\", 2) in [\\"abab\\", \\"baba\\"] True","solution":"import heapq from collections import Counter, deque def rearrangeString(s: str, k: int) -> str: if k == 0: return s # Frequency map of characters char_count = Counter(s) # Max heap (negative count because Python's heapq is a min-heap) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) queue = deque() # Queue to keep track of characters and their next valid positions result = [] while max_heap: current_count, current_char = heapq.heappop(max_heap) result.append(current_char) queue.append((current_char, current_count + 1)) if len(queue) >= k: release_char, release_count = queue.popleft() if -release_count > 0: heapq.heappush(max_heap, (release_count, release_char)) if len(result) == len(s): return ''.join(result) else: return \\"\\""},{"question":"from typing import Tuple, List def min_knight_moves(n: int, start: Tuple[int, int], target: Tuple[int, int]) -> int: Returns the minimum number of moves required for a knight to reach from start to target on an n x n chessboard, or -1 if the knight can't reach the target. >>> min_knight_moves(3, (0, 0), (2, 2)) 4 >>> min_knight_moves(3, (0, 0), (0, 0)) 0 >>> min_knight_moves(8, (0, 0), (7, 7)) 6 >>> min_knight_moves(8, (0, 0), (1, 2)) 1 >>> min_knight_moves(1, (0, 0), (0, 0)) 0 >>> min_knight_moves(2, (0, 0), (1, 1)) -1 >>> min_knight_moves(3, (0, 0), (1, 1)) -1 >>> min_knight_moves(5, (0, 0), (4, 4)) 4 pass","solution":"from collections import deque def min_knight_moves(n, start, target): Returns the minimum number of moves required for a knight to reach from start to target on an n x n chessboard, or -1 if the knight can't reach the target. def is_inside_board(x, y): return 0 <= x < n and 0 <= y < n directions = [ (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1) ] if start == target: return 0 queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, moves = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) == target: return moves + 1 if is_inside_board(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"def is_one_swap_away(s1: str, s2: str) -> bool: Check if two strings s1 and s2 can be made equal by at most one swap. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings can be made equal by at most one swap, False otherwise. Examples: >>> is_one_swap_away(\\"bank\\", \\"kanb\\") True >>> is_one_swap_away(\\"attack\\", \\"defend\\") False","solution":"def is_one_swap_away(s1, s2): Check if two strings s1 and s2 can be made equal by at most one swap. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings can be made equal by at most one swap, False otherwise. if s1 == s2: return True diff = [(c1, c2) for c1, c2 in zip(s1, s2) if c1 != c2] if len(diff) == 2 and diff[0] == diff[1][::-1]: return True return False"},{"question":"def find_pairs(nums, target): Finds all unique pairs of integers in nums that add up to the target. Args: nums (list of int): List of integers. target (int): The target sum. Returns: list of list of int: List of unique pairs that sum to the target. >>> find_pairs([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> find_pairs([1, 2, 2, 3, 4, 4, 5], 6) [[1, 5], [2, 4]] >>> find_pairs([1, 2, 3], 7) [] >>> find_pairs([-1, 1, 2, -2, 0], 0) [[-2, 2], [-1, 1]] >>> find_pairs([], 5) [] >>> find_pairs([2, 3, 7, 4, -1], 3) [[-1, 4]] >>> find_pairs([2, 2, 2, 2], 4) [[2, 2]]","solution":"def find_pairs(nums, target): Finds all unique pairs of integers in nums that add up to the target. Args: nums (list of int): List of integers. target (int): The target sum. Returns: list of list of int: List of unique pairs that sum to the target. nums.sort() left, right = 0, len(nums) - 1 result = [] seen = set() while left < right: current_sum = nums[left] + nums[right] if current_sum == target: if (nums[left], nums[right]) not in seen: result.append([nums[left], nums[right]]) seen.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return result"},{"question":"def is_bouncy_number(num: int) -> bool: Determines if the given number is a bouncy number. A bouncy number is a positive number that is neither increasing nor decreasing. >>> is_bouncy_number(123) == False >>> is_bouncy_number(321) == False >>> is_bouncy_number(132) == True >>> is_bouncy_number(120) == True >>> is_bouncy_number(122) == False >>> is_bouncy_number(987) == False >>> is_bouncy_number(155349) == True >>> is_bouncy_number(101) == True >>> is_bouncy_number(1010) == True >>> is_bouncy_number(989) == True >>> is_bouncy_number(99) == False >>> is_bouncy_number(111) == False >>> is_bouncy_number(221) == False","solution":"def is_bouncy_number(num): Determines if the given number is a bouncy number. A bouncy number is a positive number that is neither increasing nor decreasing. if num < 100: return False # By definition, numbers less than 100 are not considered bouncy num_str = str(num) increasing = True decreasing = True for i in range(len(num_str) - 1): if num_str[i] < num_str[i + 1]: decreasing = False elif num_str[i] > num_str[i + 1]: increasing = False return not (increasing or decreasing)"},{"question":"def minimize_max_element(arr: list[int], k: int) -> int: Minimizes the maximum element in the array after performing at most k increments. >>> minimize_max_element([1, 3, 4], 2) 4 >>> minimize_max_element([5], 3) 8 >>> minimize_max_element([1, 2, 3, 4, 5], 0) 5 >>> minimize_max_element([5, 5, 5, 5], 4) 6 >>> minimize_max_element([1, 2, 3], 10) 6 >>> minimize_max_element([1, 2, 3, 4], 0) 4","solution":"def minimize_max_element(arr, k): Minimizes the maximum element in the array after performing at most k increments. Parameters: arr (list of int): The input array. k (int): The maximum number of increments allowed. Returns: int: The minimum possible value of the maximum element after increments. import heapq # Convert array into a min heap heapq.heapify(arr) while k > 0: # Pop the smallest element min_elem = heapq.heappop(arr) # Increment that element min_elem += 1 # Push it back to heap heapq.heappush(arr, min_elem) # Decrease the number of remaining increments k -= 1 # The largest element in heap is the minimum possible value of the maximum element in the array return max(arr)"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Returns a new string where the character at the i-th position moves to indices[i] in the new string. >>> restore_string(\\"abc\\", [2, 1, 0]) 'cba' >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) 'nihao' >>> restore_string(\\"art\\", [1, 0, 2]) 'rat' >>> restore_string(\\"codeleet\\", [4, 5, 6, 7, 0, 2, 1, 3]) 'leetcode' >>> restore_string(\\"abc\\", [2, 1]) Traceback (most recent call last): ... ValueError: The length of the string and the indices array must be the same. >>> restore_string(\\"abc\\", [1, 1, 0]) Traceback (most recent call last): ... ValueError: Indices array contains duplicate values. >>> restore_string(\\"abc\\", [2, 1, 3]) Traceback (most recent call last): ... ValueError: Indices array contains invalid positions. >>> restore_string(\\"abc\\", [-1, 1, 0]) Traceback (most recent call last): ... ValueError: Indices array contains invalid positions.","solution":"def restore_string(s, indices): Returns a new string where the character at the i-th position moves to indices[i] in the new string. if len(s) != len(indices): raise ValueError(\\"The length of the string and the indices array must be the same.\\") if len(set(indices)) != len(indices): raise ValueError(\\"Indices array contains duplicate values.\\") if any(i >= len(s) or i < 0 for i in indices): raise ValueError(\\"Indices array contains invalid positions.\\") result = [''] * len(s) for i, index in enumerate(indices): result[index] = s[i] return ''.join(result)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverses a singly linked list and returns the new head. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed list. Examples: >>> head = ListNode(1, ListNode(2, ListNode(3))) >>> new_head = reverse_list(head) >>> linked_list_to_list(new_head) [3, 2, 1] def list_to_linked_list(elements): Helper function to convert a list to a linked list. head = ListNode(elements[0]) current = head for element in elements[1:]: current.next = ListNode(element) current = current.next return head def linked_list_to_list(head): Helper function to convert a linked list to a list. elements = [] current = head while current: elements.append(current.val) current = current.next return elements","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_monotonic_path(root: TreeNode) -> int: Finds the length of the longest path in the binary tree such that each node in the path is either strictly greater than or strictly less than its parent node's value. >>> tree = TreeNode(1) >>> longest_monotonic_path(tree) 1 >>> tree = TreeNode(1, TreeNode(2, TreeNode(3))) >>> longest_monotonic_path(tree) 3 >>> tree = TreeNode(3, TreeNode(2, TreeNode(1))) >>> longest_monotonic_path(tree) 3 >>> tree = TreeNode(1, TreeNode(3, TreeNode(5), TreeNode(2)), TreeNode(4, None, TreeNode(3))) >>> longest_monotonic_path(tree) 3 >>> tree = TreeNode(2, TreeNode(2), TreeNode(2)) >>> longest_monotonic_path(tree) 1 >>> tree = TreeNode(5, ... TreeNode(3, ... TreeNode(2), ... TreeNode(4)), ... TreeNode(6, ... right=TreeNode(8, ... TreeNode(7), ... TreeNode(9)))) >>> longest_monotonic_path(tree) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_monotonic_path(root): Finds the longest path in the binary tree such that each node in the path is either strictly greater than or strictly less than its parent node's value. def dfs(node): if not node: return 0, 0 # increasing, decreasing left_inc, left_dec = dfs(node.left) right_inc, right_dec = dfs(node.right) inc = dec = 1 # start with current node if node.left: if node.left.val > node.val: inc = max(inc, left_inc + 1) elif node.left.val < node.val: dec = max(dec, left_dec + 1) if node.right: if node.right.val > node.val: inc = max(inc, right_inc + 1) elif node.right.val < node.val: dec = max(dec, right_dec + 1) # update the longest path longest_path[0] = max(longest_path[0], inc, dec) return inc, dec longest_path = [0] dfs(root) return longest_path[0]"},{"question":"def rearrange_balls(nums): Rearranges the balls so that no two adjacent balls have the same color. If it is not possible to rearrange the balls in such a way, returns an empty string. If it is possible, returns any rearrangement that satisfies the condition. Parameters: nums (List[int]): Array of integers representing the number of different colored balls in a line. Returns: str: A rearranged string where no two adjacent balls have the same color, or an empty string if not possible. Examples: >>> rearrange_balls([2, 2]) in [\\"0101\\", \\"1010\\"] True >>> rearrange_balls([1]) == \\"0\\" True >>> rearranged = rearrange_balls([1, 2, 2]) >>> valid_rearrangement(rearranged, [1, 2, 2]) True >>> rearrange_balls([3, 1]) == \\"\\" True >>> rearrange_balls([]) == \\"\\" True","solution":"def rearrange_balls(nums): from collections import Counter import heapq # Convert the list of integers to a string of characters representing different colors balls = ''.join(str(i) for i in range(len(nums)) for _ in range(nums[i])) n = len(balls) if not balls: return \\"\\" # Use a max heap to store the balls with their frequency counts = Counter(balls) max_heap = [(-freq, ball) for ball, freq in counts.items()] heapq.heapify(max_heap) # Previous ball that was added, initialized to be an impossible value prev_freq, prev_ball = 0, '' result = [] while max_heap: # Pop the most frequent ball freq, ball = heapq.heappop(max_heap) # Append the current ball to the result result.append(ball) # If previous ball count is not ready to be pushed again, push it back to heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_ball)) # Update previous ball with the current one prev_freq, prev_ball = freq + 1, ball rearranged = ''.join(result) # If the rearranged length is equal to original, it means successful rearrangement if len(rearranged) == n: return rearranged return \\"\\""},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1: ListNode, l2: ListNode) -> ListNode: Given two linked lists representing two numbers in reverse order, adds the numbers and returns the sum as a new linked list. >>> def list_to_linked(lst): ... dummy = ListNode() ... current = dummy ... for val in lst: ... current.next = ListNode(val) ... current = current.next ... return dummy.next ... >>> def linked_to_list(node): ... lst = [] ... while node: ... lst.append(node.val) ... node = node.next ... return lst ... >>> l1 = list_to_linked([2, 4, 3]) >>> l2 = list_to_linked([5, 6, 4]) >>> linked_to_list(add_two_numbers(l1, l2)) [7, 0, 8] >>> l1 = list_to_linked([0]) >>> l2 = list_to_linked([0]) >>> linked_to_list(add_two_numbers(l1, l2)) [0] >>> l1 = list_to_linked([9, 9, 9, 9, 9, 9, 9]) >>> l2 = list_to_linked([9, 9, 9, 9]) >>> linked_to_list(add_two_numbers(l1, l2)) [8, 9, 9, 9, 0, 0, 0, 1] >>> l1 = list_to_linked([1, 8]) >>> l2 = list_to_linked([0]) >>> linked_to_list(add_two_numbers(l1, l2)) [1, 8] >>> l1 = list_to_linked([5]) >>> l2 = list_to_linked([5]) >>> linked_to_list(add_two_numbers(l1, l2)) [0, 1] >>> l1 = list_to_linked([9, 9, 9]) >>> l2 = list_to_linked([1]) >>> linked_to_list(add_two_numbers(l1, l2)) [0, 0, 0, 1] >>> l1 = list_to_linked([0]) >>> l2 = list_to_linked([0]) >>> linked_to_list(add_two_numbers(l1, l2)) [0]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): Given two linked lists representing two numbers in reverse order, adds the numbers and returns the sum as a new linked list. dummy = ListNode() current = dummy carry = 0 while l1 or l2 or carry: val1 = (l1.val if l1 else 0) val2 = (l2.val if l2 else 0) total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy.next"},{"question":"def max_pairs(nums: List[int]) -> int: Returns the maximum number of pairs that can be formed from the array, where a pair (a, b) satisfies |a - b| <= 1. >>> max_pairs([5, 10, 15]) == 0 >>> max_pairs([1, 2, 2, 3, 3, 4]) == 3 >>> max_pairs([1, 2, 4, 5]) == 2 >>> max_pairs([1, 1, 1, 1]) == 2 >>> max_pairs([1, 3, 2, 4, 5]) == 2 >>> max_pairs([-1, -2, 1, 2, 0]) == 2","solution":"def max_pairs(nums): Returns the maximum number of pairs that can be formed from the array, where a pair (a, b) satisfies |a - b| <= 1. nums.sort() i, pairs = 0, 0 while i < len(nums) - 1: if abs(nums[i] - nums[i + 1]) <= 1: pairs += 1 i += 2 # skip the next number as it forms a pair with the current number else: i += 1 # move to next number return pairs"},{"question":"def insert_and_merge_intervals(intervals, new_interval): Inserts a new interval into a list of intervals and merges all overlapping intervals. :param intervals: List of intervals represented as [start, end] pairs :param new_interval: New interval to insert represented as [start, end] :return: List of merged intervals after inserting the new interval >>> insert_and_merge_intervals([[1, 3], [6, 9]], [2, 5]) [[1, 5], [6, 9]] >>> insert_and_merge_intervals([[1, 5], [10, 15]], [5, 10]) [[1, 15]] >>> insert_and_merge_intervals([[3, 5], [7, 9]], [1, 2]) [[1, 2], [3, 5], [7, 9]] >>> insert_and_merge_intervals([[1, 3], [4, 6]], [7, 8]) [[1, 3], [4, 6], [7, 8]] >>> insert_and_merge_intervals([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], [4, 9]) [[1, 2], [3, 10], [12, 16]]","solution":"def insert_and_merge_intervals(intervals, new_interval): Inserts a new interval into a list of intervals and merges all overlapping intervals. :param intervals: List of intervals represented as [start, end] pairs :param new_interval: New interval to insert represented as [start, end] :return: List of merged intervals after inserting the new interval intervals.append(new_interval) intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last = merged_intervals[-1] if current[0] <= last[1]: # overlapping intervals merged_intervals[-1] = [last[0], max(last[1], current[1])] else: merged_intervals.append(current) return merged_intervals"},{"question":"def find_leaf_nodes(edges): Given a list of tuples representing edges in a binary tree, returns the list of all leaf nodes (nodes with no children). :param edges: List of tuples where each tuple represents a parent-child connection. :return: List of leaf nodes. >>> find_leaf_nodes([(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) == [4, 5, 6] >>> find_leaf_nodes([(1, 2), (2, 3), (3, 4), (4, 5)]) == [5] >>> find_leaf_nodes([(1, 2), (1, 3), (1, 4)]) == [2, 3, 4] >>> find_leaf_nodes([(1, 2), (2, 3), (2, 4), (4, 5), (4, 6)]) == [3, 5, 6] >>> find_leaf_nodes([]) == []","solution":"def find_leaf_nodes(edges): Given a list of tuples representing edges in a binary tree, returns the list of all leaf nodes (nodes with no children). :param edges: List of tuples where each tuple represents a parent-child connection. :return: List of leaf nodes. from collections import defaultdict # Set to store all nodes that appear in the child position children = set() # Set to store all nodes that appear in the parent position parents = set() for parent, child in edges: parents.add(parent) children.add(child) # Leaf nodes are those which are in children set but not in parent set leaf_nodes = list(children - parents) return leaf_nodes"},{"question":"import heapq from typing import List, Tuple def k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[Tuple[int, int]]: Find the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums. Parameters: nums1 (List[int]): First sorted integer array. nums2 (List[int]): Second sorted integer array. k (int): The required number of pairs. Returns: List[Tuple[int, int]]: The k pairs with the smallest sums.","solution":"import heapq def k_smallest_pairs(nums1, nums2, k): Find the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums. Parameters: nums1 (List[int]): First sorted integer array. nums2 (List[int]): Second sorted integer array. k (int): The required number of pairs. Returns: List[Tuple[int, int]]: The k pairs with the smallest sums. if not nums1 or not nums2 or k <= 0: return [] min_heap = [] for i in range(min(k, len(nums1))): heapq.heappush(min_heap, (nums1[i]+nums2[0], i, 0)) res = [] while min_heap and len(res) < k: sum_val, i, j = heapq.heappop(min_heap) res.append((nums1[i], nums2[j])) if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i]+nums2[j+1], i, j+1)) return res"},{"question":"from typing import List def maxNumberOfPeople(seats: List[List[int]]) -> int: Given a 2D integer array \`seats\` where \`seats[i][j]\` is \`0\` (empty) or \`1\` (reserved), return the maximum number of people that can be seated such that no two seated people are adjacent (horizontally or vertically). >>> maxNumberOfPeople([[0]]) 1 >>> maxNumberOfPeople([[0, 0]]) 1 >>> maxNumberOfPeople([[0, 0, 0]]) 2 >>> maxNumberOfPeople([[0], [0]]) 1 >>> maxNumberOfPeople([[0], [0], [0]]) 2 >>> maxNumberOfPeople([]) 0 >>> maxNumberOfPeople([[]]) 0 >>> maxNumberOfPeople([[0, 0], [0, 0]]) 2 >>> maxNumberOfPeople([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 5 >>> maxNumberOfPeople([[0, 0, 0], [0, 0, 0]]) 3 >>> maxNumberOfPeople([[0, 0], [0, 0], [0, 0]]) 3 >>> maxNumberOfPeople([[1, 1], [1, 1]]) 0","solution":"def maxNumberOfPeople(seats): Returns the maximum number of people that can be seated such that no two people are adjacent either horizontally or vertically. # Number of rows and columns rows = len(seats) if rows == 0: return 0 cols = len(seats[0]) if cols == 0: return 0 # Count maximum number of people count = 0 # Traverse each seat and attempt to sit people ensuring comfort rule for i in range(rows): for j in range(cols): if seats[i][j] == 0: # Check if any adjacent seat is taken if (i == 0 or seats[i-1][j] == 0) and (i == rows-1 or seats[i+1][j] == 0) and (j == 0 or seats[i][j-1] == 0) and (j == cols-1 or seats[i][j+1] == 0): # Place a person here seats[i][j] = 1 count += 1 return count"},{"question":"def longest_common_substring(s1: str, s2: str) -> int: Returns the length of the longest common substring between s1 and s2. >>> longest_common_substring(\\"substringfinder\\", \\"stringstart\\") == 6 >>> longest_common_substring(\\"abcdef\\", \\"abc\\") == 3 >>> longest_common_substring(\\"abcdxyz\\", \\"xyzabcd\\") == 4 >>> longest_common_substring(\\"abc\\", \\"def\\") == 0 >>> longest_common_substring(\\"\\", \\"string\\") == 0 >>> longest_common_substring(\\"same\\", \\"same\\") == 4 >>> longest_common_substring(\\"a\\", \\"a\\") == 1 >>> longest_common_substring(\\"a\\", \\"b\\") == 0 >>> longest_common_substring(\\"a\\", \\"\\") == 0 >>> longest_common_substring(\\"\\", \\"\\") == 0","solution":"def longest_common_substring(s1, s2): Returns the length of the longest common substring between s1 and s2. m, n = len(s1), len(s2) # Create a 2D list to store lengths of longest common suffixes of substrings lc_suffix = [[0] * (n + 1) for _ in range(m + 1)] longest_length = 0 # Length of the longest common substring # Building the lc_suffix array in bottom-up fashion for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: lc_suffix[i][j] = lc_suffix[i - 1][j - 1] + 1 longest_length = max(longest_length, lc_suffix[i][j]) else: lc_suffix[i][j] = 0 return longest_length"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an array of integers nums, return an array result where result[i] is the product of all elements of nums except nums[i]. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([10]) == [1] >>> product_except_self([0, 0, 0]) == [0, 0, 0] >>> product_except_self([]) == [] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] >>> product_except_self([-1, -2, -3, -4]) == [-24, -12, -8, -6] >>> product_except_self([2, 2, 2, 2]) == [8, 8, 8, 8]","solution":"def product_except_self(nums): Given an array of integers nums, return an array result where result[i] is the product of all elements of nums except nums[i]. length = len(nums) result = [1] * length prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] suffix = 1 for i in range(length - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"def longest_subconsecutive_sequence(nums: List[int]) -> int: Given an array \`nums\` consisting of \`n\` integers, return the length of the longest subconsecutive sequence of integers. A subsequence is defined as a possible sequence derived from the array \`nums\` where each successive element in the subsequence is exactly \`1\` greater than the previous element. The elements in the subsequence need not be contiguous in the original array. >>> longest_subconsecutive_sequence([]) == 0 >>> longest_subconsecutive_sequence([5]) == 1 >>> longest_subconsecutive_sequence([5, 10, 15]) == 1 >>> longest_subconsecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_subconsecutive_sequence([1, 2, 2, 3, 4, 4, 5]) == 5 >>> longest_subconsecutive_sequence([-1, -2, -3, 1, 2, 3]) == 3 >>> longest_subconsecutive_sequence([-1, 0, 1, 2, -2, 3, 4, 5]) == 8","solution":"def longest_subconsecutive_sequence(nums): Return the length of the longest subconsecutive sequence of integers in nums. if not nums: return 0 nums = list(set(nums)) # Remove duplicates nums.sort() longest_streak = 1 current_streak = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1] + 1: current_streak += 1 else: longest_streak = max(longest_streak, current_streak) current_streak = 1 return max(longest_streak, current_streak)"},{"question":"def unique_substrings_of_length_k(s: str, k: int) -> list: Returns a list of all unique substrings of length k that occur in the string s. Parameters: - s (str): The input string. - k (int): The length of substrings to find. Returns: - list: A list of unique substrings of length k in the order they appear in s. >>> unique_substrings_of_length_k(\\"abcabc\\", 3) [\\"abc\\", \\"bca\\", \\"cab\\"] >>> unique_substrings_of_length_k(\\"abcdef\\", 3) [\\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\"] >>> unique_substrings_of_length_k(\\"aaaaa\\", 2) [\\"aa\\"] >>> unique_substrings_of_length_k(\\"a\\", 1) [\\"a\\"] >>> unique_substrings_of_length_k(\\"short\\", 10) [] >>> unique_substrings_of_length_k(\\"exact\\", 5) [\\"exact\\"]","solution":"def unique_substrings_of_length_k(s, k): Returns a list of all unique substrings of length k that occur in the string s. Parameters: - s (str): The input string. - k (int): The length of substrings to find. Returns: - list: A list of unique substrings of length k in the order they appear in s. if k > len(s): return [] seen = set() unique_substrings = [] for i in range(len(s) - k + 1): substring = s[i:i+k] if substring not in seen: seen.add(substring) unique_substrings.append(substring) return unique_substrings"},{"question":"def roman_to_int(s: str) -> int: Convert a string representing a Roman numeral to an integer. Args: s (str): A string representing a Roman numeral. Returns: int: The integer representation of the Roman numeral. Examples: >>> roman_to_int('III') 3 >>> roman_to_int('IV') 4 >>> roman_to_int('IX') 9 >>> roman_to_int('LVIII') 58 >>> roman_to_int('MCMXCIV') 1994 from solution import roman_to_int def test_single_characters(): assert roman_to_int('I') == 1 assert roman_to_int('V') == 5 assert roman_to_int('X') == 10 assert roman_to_int('L') == 50 assert roman_to_int('C') == 100 assert roman_to_int('D') == 500 assert roman_to_int('M') == 1000 def test_combinations(): assert roman_to_int('II') == 2 assert roman_to_int('III') == 3 assert roman_to_int('IV') == 4 assert roman_to_int('VI') == 6 assert roman_to_int('VIII') == 8 assert roman_to_int('IX') == 9 assert roman_to_int('XL') == 40 assert roman_to_int('XC') == 90 assert roman_to_int('CD') == 400 assert roman_to_int('CM') == 900 def test_complex_combinations(): assert roman_to_int('XIII') == 13 assert roman_to_int('XXIX') == 29 assert roman_to_int('XLIV') == 44 assert roman_to_int('LXVIII') == 68 assert roman_to_int('XCIV') == 94 assert roman_to_int('CDXXI') == 421 assert roman_to_int('CMXCIX') == 999 def test_large_numbers(): assert roman_to_int('MMXIV') == 2014 assert roman_to_int('MMMCMXCIX') == 3999","solution":"def roman_to_int(s): Converts a string representing a Roman numeral to an integer. roman_to_integer_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 previous_value = 0 for char in reversed(s): current_value = roman_to_integer_map[char] if current_value >= previous_value: total += current_value else: total -= current_value previous_value = current_value return total"},{"question":"def maxWaterArea(heights: List[int]) -> int: Given a list of non-negative integers representing the heights of buildings, find the maximum area of water that can be trapped between the buildings after a rainstorm. The width of each building is 1. Parameters: heights (List[int]): List of non-negative integers representing the heights of buildings. Returns: int: Maximum area of water that can be trapped. Examples: >>> maxWaterArea([4]) 0 >>> maxWaterArea([1, 1]) 1 >>> maxWaterArea([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> maxWaterArea([1, 1, 1, 1, 1, 1]) 5 # Your code here","solution":"def maxWaterArea(heights): Calculate the maximum area of water that can be trapped between buildings after a rainstorm. :param heights: List[int], list of non-negative integers representing the heights of buildings. :return: int, maximum area of water that can be trapped. left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left current_height = min(heights[left], heights[right]) current_area = width * current_height max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def numTrees(n): Returns the number of structurally unique BSTs that can be formed with \`n\` nodes. >>> numTrees(0) 1 >>> numTrees(1) 1 >>> numTrees(2) 2 >>> numTrees(3) 5 >>> numTrees(4) 14 >>> numTrees(5) 42","solution":"def numTrees(n): Returns the number of structurally unique BSTs that can be formed with \`n\` nodes. # Base case if n == 0 or n == 1: return 1 # Create a list to store results of subproblems dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Fill the dp array using the recursive formula for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - j - 1] return dp[n]"},{"question":"def merge_sort(nums): Given an integer array \`nums\`, sorts the array in ascending order using the Merge Sort algorithm and returns the sorted array. >>> merge_sort([]) [] >>> merge_sort([1]) [1] >>> merge_sort([3, 1, 2]) [1, 2, 3] >>> merge_sort([-1, -3, 2, 1]) [-3, -1, 1, 2] >>> merge_sort([3, -1, 0, -2, 2]) [-2, -1, 0, 2, 3] >>> merge_sort([3, 3, 2, 1, 1]) [1, 1, 2, 3, 3] >>> merge_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> merge_sort([100000000, 999999999, -1000000000, 123456789]) [-1000000000, 100000000, 123456789, 999999999]","solution":"def merge_sort(nums): Sorts the array in ascending order using the Merge Sort algorithm. if len(nums) <= 1: return nums mid = len(nums) // 2 left_half = merge_sort(nums[:mid]) right_half = merge_sort(nums[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list. sorted_array = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_array.append(left[left_index]) left_index += 1 else: sorted_array.append(right[right_index]) right_index += 1 sorted_array.extend(left[left_index:]) sorted_array.extend(right[right_index:]) return sorted_array"},{"question":"from typing import List, Dict def shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: Finds the shortest path from start to end node in a directed graph represented as an adjacency list using BFS. Returns the path as a list of nodes. :param graph: Dict[int, List[int]] - the graph adjacency list :param start: int - the start node :param end: int - the end node :return: List[int] - the shortest path from start to end node, otherwise empty list. >>> shortest_path({0: [1, 2], 1: [2], 2: [0, 3], 3: []}, 2, 3) [2, 3] >>> shortest_path({0: [1, 2], 1: [2], 2: [0, 3], 3: []}, 2, 1) [2, 0, 1] >>> shortest_path({0: [1], 1: [0], 2: [3], 3: [2]}, 0, 3) [] >>> shortest_path({0: [1, 2], 1: [2], 2: [0, 3], 3: []}, 1, 1) [1] >>> shortest_path({}, 0, 1) [] >>> shortest_path({0: [], 1: [], 2: [], 3: []}, 0, 3) [] >>> shortest_path({0: [1], 1: [2], 2: [3], 3: [0]}, 0, 3) [0, 1, 2, 3] >>> shortest_path({0: [1], 1: [2], 2: [3], 3: [0]}, 3, 2) [3, 0, 1, 2]","solution":"from collections import deque def shortest_path(graph, start, end): Finds the shortest path from start to end node in a directed graph represented as an adjacency list using BFS. Returns the path as a list of nodes. :param graph: Dict[int, List[int]] - the graph adjacency list :param start: int - the start node :param end: int - the end node :return: List[int] - the shortest path from start to end node, otherwise empty list. if start == end: return [start] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return path + [neighbor] else: queue.append((neighbor, path + [neighbor])) return []"},{"question":"def num_cells_in_smallest_island(grid: List[List[int]]) -> int: Given a binary matrix \`grid\` of size \`m x n\`, where \`0\` represents water and \`1\` represents land, find the smallest island in the grid, and return the number of cells in this island. If there is no island, return \`0\`. >>> num_cells_in_smallest_island([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> num_cells_in_smallest_island([[0, 1, 0], [0, 0, 0], [0, 0, 0]]) == 1 >>> num_cells_in_smallest_island([ ... [0, 1, 0, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 1], ... [0, 1, 0, 1] ... ]) == 1 >>> num_cells_in_smallest_island([ ... [1, 0, 0, 1], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [1, 0, 0, 1] ... ]) == 1 >>> num_cells_in_smallest_island([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 >>> num_cells_in_smallest_island([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) == 1","solution":"def num_cells_in_smallest_island(grid): def dfs(grid, x, y, visited): stack = [(x, y)] island_size = 0 while stack: i, j = stack.pop() if (i, j) not in visited: visited.add((i, j)) island_size += 1 for ni, nj in neighbors(i, j, len(grid), len(grid[0])): if grid[ni][nj] == 1 and (ni, nj) not in visited: stack.append((ni, nj)) return island_size def neighbors(i, j, m, n): for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0 <= ni < m and 0 <= nj < n: yield ni, nj if not grid: return 0 m, n = len(grid), len(grid[0]) visited = set() min_island_size = float('inf') found_island = False for i in range(m): for j in range(n): if grid[i][j] == 1 and (i, j) not in visited: found_island = True size = dfs(grid, i, j, visited) if size < min_island_size: min_island_size = size return min_island_size if found_island else 0"},{"question":"from typing import List def max_water_trapped(arr: List[int]) -> int: Given a list of non-negative integers \`arr\` representing the height of each building in a row, find the two buildings that together with the line connecting them can trap the most water. Args: arr (list): List of non-negative integers representing building heights. Returns: int: Maximum water that can be trapped. >>> max_water_trapped([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_water_trapped([1, 1]) 1 >>> max_water_trapped([4, 3, 2, 1, 4]) 16 >>> max_water_trapped([1, 2, 1]) 2 >>> max_water_trapped([0, 0, 2, 0, 0]) 0 >>> max_water_trapped([]) 0 >>> max_water_trapped([4]) 0 >>> max_water_trapped([4, 6]) 4","solution":"def max_water_trapped(arr): Given a list of non-negative integers \`arr\` representing the height of each building in a row, find the two buildings that together with the line connecting them can trap the most water. Args: arr (list): List of non-negative integers representing building heights. Returns: int: Maximum water that can be trapped. max_water = 0 left, right = 0, len(arr) - 1 while left < right: # Calculate the amount of water that can be trapped height = min(arr[left], arr[right]) width = right - left current_water = height * width # Update maximum water max_water = max(max_water, current_water) # Move the pointer that points to the shorter building if arr[left] < arr[right]: left += 1 else: right -= 1 return max_water"},{"question":"def can_form_strictly_increasing_sequence(nums: List[int]) -> bool: Determines if it is possible to rearrange the elements of \`nums\` such that any three consecutive elements form a strictly increasing sequence. >>> can_form_strictly_increasing_sequence([1]) == True >>> can_form_strictly_increasing_sequence([1, 2]) == True >>> can_form_strictly_increasing_sequence([3, 1, 2]) == True >>> can_form_strictly_increasing_sequence([1, 2, 3, 4]) == True >>> can_form_strictly_increasing_sequence([4, 2, 3, 1]) == True >>> can_form_strictly_increasing_sequence([1, 2, 3, 3]) == False >>> can_form_strictly_increasing_sequence([1, 1, 2, 3]) == False >>> can_form_strictly_increasing_sequence([2, 2, 2]) == False >>> can_form_strictly_increasing_sequence([5, 5, 5, 5]) == False >>> can_form_strictly_increasing_sequence([1, 3, 3, 3]) == False >>> can_form_strictly_increasing_sequence([1, 2, 2, 3, 4, 4]) == False >>> can_form_strictly_increasing_sequence([1000000, 999999, 1000001, 1000002]) == True >>> can_form_strictly_increasing_sequence([1, 3, 5, 2, 4, 6]) == True","solution":"def can_form_strictly_increasing_sequence(nums): Determines if it is possible to rearrange the elements of \`nums\` such that any three consecutive elements form a strictly increasing sequence. if len(nums) < 3: return True nums.sort() for i in range(len(nums) - 2): if nums[i + 1] <= nums[i] or nums[i + 2] <= nums[i + 1]: return False return True"},{"question":"from typing import List class FreqStack: A class to implement a frequency stack that supports push and pop operations. Methods: - push(self, x: int) -> None: Adds an integer x onto the frequency stack. - pop(self) -> int: Removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element which was pushed most recently will be returned. >>> freqStack = FreqStack() >>> freqStack.push(5) >>> freqStack.push(7) >>> freqStack.push(5) >>> freqStack.push(7) >>> freqStack.push(4) >>> freqStack.push(5) >>> freqStack.pop() 5 >>> freqStack.pop() 7 >>> freqStack.pop() 5 >>> freqStack.pop() 4 >>> freqStack = FreqStack() >>> freqStack.push(10) >>> freqStack.pop() 10 >>> freqStack.push(10) >>> freqStack.push(20) >>> freqStack.push(20) >>> freqStack.pop() 20 >>> freqStack.push(10) >>> freqStack.pop() 10 def push(self, x: int) -> None: pass def pop(self) -> int: pass","solution":"import collections class FreqStack: def __init__(self): self.freq = collections.Counter() self.group = collections.defaultdict(list) self.maxfreq = 0 def push(self, x: int) -> None: freq = self.freq[x] + 1 self.freq[x] = freq if freq > self.maxfreq: self.maxfreq = freq self.group[freq].append(x) def pop(self) -> int: x = self.group[self.maxfreq].pop() self.freq[x] -= 1 if not self.group[self.maxfreq]: self.maxfreq -= 1 return x"},{"question":"def word_pattern(pattern: str, str: str) -> bool: Write a function that takes a string \`pattern\` and a string \`str\`, and returns \`true\` if \`str\` follows the same pattern. In other words, there's a one-to-one correspondence between each character in \`pattern\` and each word in \`str\`. >>> word_pattern(\\"abba\\", \\"dog cat cat dog\\") True >>> word_pattern(\\"abba\\", \\"dog cat cat fish\\") False >>> word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") False >>> word_pattern(\\"abba\\", \\"dog dog dog dog\\") False >>> word_pattern(\\"a\\", \\"dog\\") True >>> word_pattern(\\"a\\", \\"dog cat\\") False >>> word_pattern(\\"\\", \\"\\") True","solution":"def word_pattern(pattern, str): Returns True if str follows the same pattern as given in pattern. words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char not in char_to_word: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char elif char_to_word[char] != word: return False return True"},{"question":"from typing import List def min_insertions_to_anagram(s: str, t: str) -> int: Returns the minimum number of insertions needed to make s an anagram of t. If it is impossible, returns -1. >>> min_insertions_to_anagram(\\"a\\", \\"aa\\") 1 >>> min_insertions_to_anagram(\\"abc\\", \\"cba\\") 0 >>> min_insertions_to_anagram(\\"abc\\", \\"abcd\\") 1 >>> min_insertions_to_anagram(\\"cat\\", \\"taco\\") 1 >>> min_insertions_to_anagram(\\"abc\\", \\"def\\") -1 >>> min_insertions_to_anagram(\\"abcd\\", \\"abc\\") -1 >>> min_insertions_to_anagram(\\"hello\\", \\"world\\") -1 >>> min_insertions_to_anagram(\\"\\", \\"\\") 0 >>> min_insertions_to_anagram(\\"\\", \\"a\\") 1 >>> min_insertions_to_anagram(\\"a\\", \\"\\") -1 >>> min_insertions_to_anagram(\\"a\\", \\"a\\") 0","solution":"from collections import Counter def min_insertions_to_anagram(s, t): Returns the minimum number of insertions needed to make s an anagram of t. If it is impossible, returns -1. if len(s) > len(t): return -1 # It is impossible if s is longer than t count_s = Counter(s) count_t = Counter(t) # If there's any character in s that is not in t, it is impossible to form an anagram for char in count_s: if char not in count_t: return -1 insertions_needed = 0 for char in count_t: if char in count_s: insertions_needed += max(0, count_t[char] - count_s[char]) else: insertions_needed += count_t[char] return insertions_needed"},{"question":"from typing import List def can_reach_last_pillar(heights: List[int], k: int) -> bool: Determines if it's possible to reach the last pillar starting from the first. :param heights: List of integers representing the heights of the pillars. :param k: Integer representing the length of the ladder. :return: Boolean value indicating whether it's possible to reach the last pillar or not. >>> can_reach_last_pillar([1, 2, 3, 4, 5], 3) == True >>> can_reach_last_pillar([10], 5) == True >>> can_reach_last_pillar([], 5) == False >>> can_reach_last_pillar([5, 10, 20, 30], 4) == False >>> can_reach_last_pillar([1, 2, 3, 4, 5], 1) == True >>> can_reach_last_pillar([5, 15, 1, 10], 10) == True >>> can_reach_last_pillar([1, 10, 1, 10, 1], 10) == True >>> can_reach_last_pillar([1, 1, 1, 1, 1], 2) == True >>> can_reach_last_pillar([1, 1, 3, 1, 1], 1) == False >>> can_reach_last_pillar([1, 1, 1, 5, 5], 2) == False","solution":"def can_reach_last_pillar(heights, k): Determines if it's possible to reach the last pillar starting from the first. :param heights: List of integers representing the heights of the pillars. :param k: Integer representing the length of the ladder. :return: Boolean value indicating whether it's possible to reach the last pillar or not. n = len(heights) if n == 0: return False reachable = [False] * n reachable[0] = True for i in range(n): if reachable[i]: for j in range(1, k+1): if i + j < n and heights[i + j] <= heights[i] + k: reachable[i + j] = True return reachable[-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: Returns the k-th smallest element in a binary search tree (BST). >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.left.right = TreeNode(2) >>> kth_smallest(root, 1) 1 >>> kth_smallest(root, 2) 2 >>> kth_smallest(root, 3) 3 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.left.left.left = TreeNode(1) >>> kth_smallest(root, 1) 1 >>> kth_smallest(root, 2) 2 >>> kth_smallest(root, 3) 3 >>> kth_smallest(root, 4) 4 >>> kth_smallest(root, 5) 5 >>> kth_smallest(root, 6) 6","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the k-th smallest element in a binary search tree (BST). def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Perform inorder traversal to get elements in sorted order sorted_elements = inorder_traversal(root) # Return the k-th smallest element (1-indexed) return sorted_elements[k - 1]"},{"question":"from typing import List def find_k_closest_elements(arr: List[int], k: int, x: int) -> List[int]: Returns k closest integers to x in the array arr sorted in ascending order. Parameters: arr (List[int]): List of integers. k (int): The number of closest integers to find. x (int): The target integer. Returns: List[int]: The list of k closest integers to x sorted in ascending order. Examples: >>> find_k_closest_elements([1, 2, 3, 4, 5], 4, 3) [1, 2, 3, 4] >>> find_k_closest_elements([1, 2, 3, 4, 5], 4, -1) [1, 2, 3, 4] >>> find_k_closest_elements([2, 4, 5, 6, 7], 3, 5) [4, 5, 6] >>> find_k_closest_elements([1, 3, 4, 7, 8], 3, 0) [1, 3, 4] >>> find_k_closest_elements([-10, -50, 2, 0, 15], 3, -3) [-10, 0, 2]","solution":"def find_k_closest_elements(arr, k, x): Returns k closest integers to x in the array arr sorted in ascending order. Parameters: arr (List[int]): List of integers. k (int): The number of closest integers to find. x (int): The target integer. Returns: List[int]: The list of k closest integers to x sorted in ascending order. # Sort the array based on two keys: # 1. The absolute difference between the elements and x. # 2. The values themselves to break ties. sorted_arr = sorted(arr, key=lambda num: (abs(num - x), num)) # Take the first k elements from the sorted array result = sorted(sorted_arr[:k]) return result"},{"question":"def longestSubsequence(arr: List[int], difference: int) -> int: Find the length of the longest subsequence where the difference between consecutive elements is exactly equal to \`difference\`. >>> longestSubsequence([1,2,3,4], 1) == 4 >>> longestSubsequence([1,3,5,7], 2) == 4 >>> longestSubsequence([1,5,7,8,5,3,4,2,1], -2) == 4 >>> longestSubsequence([1,3,5,7], 10) == 1 >>> longestSubsequence([], 2) == 0 >>> longestSubsequence([5], 0) == 1","solution":"def longestSubsequence(arr, difference): Find the length of the longest subsequence where the difference between consecutive elements is exactly equal to \`difference\`. if not arr: return 0 dp = {} max_len = 1 for num in arr: if num - difference in dp: dp[num] = dp[num - difference] + 1 else: dp[num] = 1 max_len = max(max_len, dp[num]) return max_len"},{"question":"from typing import List def can_form_target(words: List[str], target: str) -> bool: Determines if the \`target\` string can be formed using characters from \`words\`. Args: words (list of str): List of strings containing lowercase alphabets. target (str): The target string to be formed. Returns: bool: True if target can be formed, False otherwise. pass # Unit tests def test_can_form_target_all_characters_present(): assert can_form_target([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], \\"abcd\\") == True def test_can_form_target_single_string(): assert can_form_target([\\"abcd\\"], \\"abcd\\") == True def test_can_form_target_not_enough_characters(): assert can_form_target([\\"a\\", \\"b\\", \\"c\\"], \\"abcd\\") == False def test_can_form_target_duplicate_characters(): assert can_form_target([\\"a\\", \\"a\\", \\"b\\"], \\"aa\\") == True def test_can_form_target_not_enough_duplicate_characters(): assert can_form_target([\\"a\\", \\"b\\"], \\"aa\\") == False def test_can_form_target_partial_match(): assert can_form_target([\\"a\\", \\"b\\", \\"c\\"], \\"ab\\") == True def test_can_form_target_empty_target(): assert can_form_target([\\"a\\", \\"b\\", \\"c\\"], \\"\\") == True def test_can_form_target_empty_words(): assert can_form_target([], \\"a\\") == False def test_can_form_target_empty_words_empty_target(): assert can_form_target([], \\"\\") == True","solution":"def can_form_target(words, target): Determines if the \`target\` string can be formed using characters from \`words\`. Args: words (list of str): List of strings containing lowercase alphabets. target (str): The target string to be formed. Returns: bool: True if target can be formed, False otherwise. from collections import Counter words_counter = Counter(''.join(words)) target_counter = Counter(target) for char, count in target_counter.items(): if words_counter[char] < count: return False return True"},{"question":"[Completion Task in Python] def can_form_palindrome(s: str) -> bool: Determine if it is possible to delete some characters (possibly none) from the given string \`s\` such that the resulting string is a palindrome while maintaining the relative order of the remaining characters. A string is a palindrome if it reads the same forward and backward. >>> can_form_palindrome(\\"aAbBc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"aaaaaa\\") True >>> can_form_palindrome(\\"AaBbAa\\") True","solution":"def can_form_palindrome(s): from collections import Counter # Count the frequency of each character in the string freq = Counter(s.lower()) # At most one character can have an odd count in a palindromic string odd_count = sum(1 for count in freq.values() if count % 2 == 1) return odd_count <= 1"},{"question":"def maxRob(nums, k): Returns the maximum amount of money you can rob given the constraints: - You cannot rob two adjacent houses. - You cannot rob more than k houses. :param nums: List of non-negative integers representing the amount of money in each house. :param k: Max number of houses that can be robbed. :return: Maximum amount of money that can be robbed. >>> maxRob([], 3) 0 >>> maxRob([5, 1, 1, 5], 0) 0 >>> maxRob([2, 3, 2], 2) 4 >>> maxRob([1, 2, 3, 1], 2) 4 >>> maxRob([2, 7, 9, 3, 1], 3) 12 >>> maxRob([2, 7, 9, 3, 1, 5], 3) 16 >>> maxRob([1, 2, 3, 4, 5, 6, 7], 3) 15","solution":"def maxRob(nums, k): Returns the maximum amount of money you can rob given the constraints: - You cannot rob two adjacent houses. - You cannot rob more than k houses. :param nums: List of non-negative integers representing the amount of money in each house. :param k: Max number of houses that can be robbed. :return: Maximum amount of money that can be robbed. n = len(nums) if k == 0 or n == 0: return 0 # Initialize dp array with two rows dp = [[0] * (k + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, k + 1): # If we rob the current house, we add its value to the best solution for the previous houses excluding the adjacent one dp[i][j] = max(dp[i - 1][j], dp[i - 2][j - 1] + nums[i - 1]) return dp[n][k]"},{"question":"def first_non_repeating_character(s: str) -> str: Find and return the first non-repeating character in the string s. If there is no such character, return an underscore ('_'). Parameters: s (str): The input string consisting of lowercase letters. Returns: str: The first non-repeating character or '_' if none exists. # Your code here # Unit Test def test_first_non_repeating_character(): assert first_non_repeating_character(\\"abacabad\\") == 'c' assert first_non_repeating_character(\\"abacabaabacaba\\") == '_' assert first_non_repeating_character(\\"a\\") == 'a' assert first_non_repeating_character(\\"aa\\") == '_' assert first_non_repeating_character(\\"abcdefghijklmnopqrstuvwxyz\\") == 'a' assert first_non_repeating_character(\\"swiss\\") == 'w' assert first_non_repeating_character(\\"\\") == '_' def test_edge_cases(): assert first_non_repeating_character(\\"xyx\\") == 'y' assert first_non_repeating_character(\\"aabbccdd\\") == '_' assert first_non_repeating_character(\\"racecars\\") == 'e'","solution":"def first_non_repeating_character(s): Find and return the first non-repeating character in the string s. If there is no such character, return an underscore ('_'). Parameters: s (str): The input string consisting of lowercase letters. Returns: str: The first non-repeating character or '_' if none exists. char_count = {} # Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char return '_'"},{"question":"def min_replacements_to_transform(s: str, dict: List[str]) -> int: Returns the minimum number of characters that need to be replaced in the string \`s\` in order to transform it into any of the words in the list \`dict\`. If it's not possible to transform \`s\` into any word in \`dict\`, return -1. >>> min_replacements_to_transform(\\"hello\\", [\\"hello\\", \\"world\\"]) == 0 >>> min_replacements_to_transform(\\"hello\\", [\\"hella\\", \\"world\\"]) == 1 >>> min_replacements_to_transform(\\"abcde\\", [\\"axcye\\", \\"wvxyz\\"]) == 2 >>> min_replacements_to_transform(\\"abcde\\", [\\"abcdef\\", \\"abc\\"]) == -1 >>> min_replacements_to_transform(\\"abcdef\\", []) == -1 >>> min_replacements_to_transform(\\"abcde\\", [\\"fghij\\", \\"klmno\\"]) == 5","solution":"def min_replacements_to_transform(s, dict): Returns the minimum number of characters that need to be replaced in the string \`s\` in order to transform it into any of the words in the list \`dict\`. If it's not possible to transform \`s\` into any word in \`dict\`, return -1. if not dict: return -1 min_replacements = float('inf') for word in dict: if len(word) != len(s): return -1 differences = sum(1 for i in range(len(s)) if s[i] != word[i]) min_replacements = min(min_replacements, differences) return min_replacements if min_replacements != float('inf') else -1"},{"question":"def longest_divisible_subsequence(numbers: List[int]) -> int: Returns the length of the longest subsequence where each number is divisible by the previous one. Examples: >>> longest_divisible_subsequence([1, 2, 4, 8, 3]) 4 >>> longest_divisible_subsequence([]) 0 >>> longest_divisible_subsequence([7]) 1 >>> longest_divisible_subsequence([5, 7, 11]) 1 >>> longest_divisible_subsequence([8, 4, 2, 16, 32]) 5 >>> longest_divisible_subsequence([3, 6, 12, 24, 5, 10]) 4 >>> longest_divisible_subsequence([1, 8, 64, 512]) 4","solution":"def longest_divisible_subsequence(numbers): Returns the length of the longest subsequence where each number is divisible by the previous one. if not numbers: return 0 n = len(numbers) dp = [1] * n numbers.sort() for i in range(n): for j in range(i): if numbers[i] % numbers[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage: # numbers = [1, 2, 4, 8, 3] # print(longest_divisible_subsequence(numbers)) # Output: 4"},{"question":"def longest_substring_with_repeats(s: str, repeatChar: str, k: int) -> int: Given a string \`s\`, a character \`repeatChar\`, and an integer \`k\`, return the length of the longest substring containing the same character that can be obtained by repeating \`repeatChar\` at most \`k\` times in \`s\`. >>> longest_substring_with_repeats(\\"aabccbb\\", 'b', 2) == 5 # aabccc[bb] >>> longest_substring_with_repeats(\\"abbcb\\", 'c', 1) == 4 # ab[cc]cb >>> longest_substring_with_repeats(\\"abcd\\", 'x', 3) == 4 # abcd >>> longest_substring_with_repeats(\\"aaaa\\", 'a', 2) == 4 # aaaa >>> longest_substring_with_repeats(\\"\\", 'a', 2) == 0 # \\"\\" >>> longest_substring_with_repeats(\\"axbxcxdx\\", 'x', 2) == 5 # [a][xbxcx]d >>> longest_substring_with_repeats(\\"aaabbacccc\\", 'a', 0) == 4 # cccc >>> longest_substring_with_repeats(\\"aaabbacccc\\", 'c', 1) == 5 # cccca >>> longest_substring_with_repeats(\\"a\\", 'a', 1) == 1 # a >>> longest_substring_with_repeats(\\"aaa\\", 'a', 2) == 3 # aaa >>> longest_substring_with_repeats(\\"aaabbb\\", 'c', 3) == 6 # aaabbb","solution":"def longest_substring_with_repeats(s, repeatChar, k): Returns the length of the longest substring containing the same character that can be obtained by repeating \`repeatChar\` at most \`k\` times in \`s\`. Parameters: s (str): The original string. repeatChar (str): The character that can be repeated. k (int): The maximum number of times \`repeatChar\` can be repeated. Returns: int: The length of the longest substring. if not s: return 0 max_len = start = count = 0 counts = {c: 0 for c in set(s)} for end, char in enumerate(s): counts[char] += 1 # Count occurrences of repeatChar in current window if char == repeatChar: count += 1 # Maintain a valid window while (end - start + 1) - max(counts.values()) > k: if s[start] == repeatChar: count -= 1 counts[s[start]] -= 1 start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def can_partition_into_k_subsets(arr: List[int], k: int) -> bool: Determine whether it is possible to partition the array into k non-empty subsets with equal sum. >>> can_partition_into_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> can_partition_into_k_subsets([1, 2, 3, 4], 3) False","solution":"def can_partition_into_k_subsets(arr, k): Determine whether it is possible to partition the array into k non-empty subsets with equal sum. :param arr: List[int] - An array of integers :param k: int - The number of subsets :return: bool - True if it is possible to partition, otherwise False total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k arr.sort(reverse=True) used = [False] * len(arr) def can_partition(start_index, k, current_sum, target_sum): if k == 0: return True if current_sum == target_sum: return can_partition(0, k - 1, 0, target_sum) for i in range(start_index, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if can_partition(i + 1, k, current_sum + arr[i], target_sum): return True used[i] = False return False return can_partition(0, k, 0, target_sum)"},{"question":"def count_rectangles(points): Given a list of points represented as pairs of coordinates points[i] = (xi, yi), return the total number of rectangles that can be formed using pairs of these points. A rectangle is formed when four points (x1, y1), (x1, y2), (x2, y1), and (x2, y2) coexist in the list of points, where x1 != x2 and y1 != y2. All coordinates are assumed to be distinct integers. The points are given in no particular order. >>> count_rectangles([(1, 2), (2, 1), (1, 1), (2, 2)]) 1 >>> count_rectangles([(0, 0), (0, 1), (1, 0), (1, 1), (2, 2)]) 1 >>> count_rectangles([(0, 0), (1, 1), (2, 2)]) 0 >>> count_rectangles([(0, 0), (0, 1), (1, 0), (1, 1), (0, 2), (1, 2)]) 3 >>> count_rectangles([(1, 1), (1, 2), (2, 1), (2, 2), (1, 0), (2, 0)]) 3","solution":"def count_rectangles(points): Returns the total number of rectangles that can be formed using pairs of points. point_set = set(points) rectangle_count = 0 # Iterate over pairs of points for i in range(len(points)): for j in range(i + 1, len(points)): (x1, y1), (x2, y2) = points[i], points[j] # Check for diagonally opposite corners of a rectangle if x1 != x2 and y1 != y2: if (x1, y2) in point_set and (x2, y1) in point_set: rectangle_count += 1 # Each rectangle is counted twice, so divide the result by 2 return rectangle_count // 2"},{"question":"def generate_result_array(nums1: List[int], nums2: List[int]) -> List[int]: Generate a result array based on the given conditions: - If nums1[i] is even, result[i] = nums1[i] + nums2[i] - If nums1[i] is odd, result[i] = abs(nums2[i] - nums1[i]) Args: nums1 (list of int): The first input list of integers. nums2 (list of int): The second input list of integers. Returns: list of int: The resulting list of integers as per the conditions. >>> generate_result_array([2, 3, 4, 5], [1, 2, 3, 4]) [3, 1, 7, 1] >>> generate_result_array([2, 4, 6, 8], [1, 3, 5, 7]) [3, 7, 11, 15] >>> generate_result_array([1, 3, 5, 7], [2, 4, 6, 8]) [1, 1, 1, 1] >>> generate_result_array([0, 0, 0, 0], [1, 2, 3, 4]) [1, 2, 3, 4] >>> generate_result_array([1000000000, 2000000000, 3000000000, 4000000000], [1000000000, 1000000000, 1000000000, 1000000000]) [2000000000, 3000000000, 4000000000, 5000000000] result = [] for i in range(len(nums1)): if nums1[i] % 2 == 0: result.append(nums1[i] + nums2[i]) else: result.append(abs(nums2[i] - nums1[i])) return result","solution":"def generate_result_array(nums1, nums2): Generate a result array based on the given conditions: - If nums1[i] is even, result[i] = nums1[i] + nums2[i] - If nums1[i] is odd, result[i] = abs(nums2[i] - nums1[i]) Args: nums1 (list of int): The first input list of integers. nums2 (list of int): The second input list of integers. Returns: list of int: The resulting list of integers as per the conditions. result = [] for i in range(len(nums1)): if nums1[i] % 2 == 0: result.append(nums1[i] + nums2[i]) else: result.append(abs(nums2[i] - nums1[i])) return result"},{"question":"def even_depth_nodes(tree): Returns a list of values of all nodes that are at an even distance from the root. Parameters: tree (dict): A dictionary representing the tree, with \\"val\\" representing the value of a node and \\"children\\" representing a list of its child nodes. Returns: List: A list of values of nodes at an even distance from the root. >>> even_depth_nodes({\\"val\\": 1, \\"children\\": []}) [1] >>> even_depth_nodes({ \\"val\\": 1, \\"children\\": [ {\\"val\\": 2, \\"children\\": [ {\\"val\\": 4, \\"children\\": []}, {\\"val\\": 5, \\"children\\": []} ]}, {\\"val\\": 3, \\"children\\": [ {\\"val\\": 6, \\"children\\": []}, {\\"val\\": 7, \\"children\\": []} ]} ] }) [1, 4, 5, 6, 7] >>> even_depth_nodes({ \\"val\\": 1, \\"children\\": [ {\\"val\\": 2, \\"children\\": [ {\\"val\\": 3, \\"children\\": [ {\\"val\\": 4, \\"children\\": []} ]} ]} ]} ) [1, 3] >>> even_depth_nodes(None) []","solution":"def even_depth_nodes(tree): Returns a list of values of all nodes that are at an even distance from the root. Parameters: tree (dict): A dictionary representing the tree, with \\"val\\" representing the value of a node and \\"children\\" representing a list of its child nodes. Returns: List: A list of values of nodes at an even distance from the root. result = [] def traverse(node, depth): if node is None: return if depth % 2 == 0: result.append(node[\\"val\\"]) for child in node[\\"children\\"]: traverse(child, depth + 1) traverse(tree, 0) return result"},{"question":"def check_subarray_sum(nums: List[int], k: int) -> bool: Determines if there exists a continuous subarray whose sum is exactly k. >>> check_subarray_sum([1, 2, 3, 4, 5], 9) True >>> check_subarray_sum([1, 2, 3, 4, 5], 20) False >>> check_subarray_sum([5], 5) True >>> check_subarray_sum([2], 5) False >>> check_subarray_sum([], 0) False >>> check_subarray_sum([-1, -2, -3, -4, -5], -9) True >>> check_subarray_sum([-1, 2, 3, -4, 5], 3) True >>> check_subarray_sum([-1, -1, 1, 1], 0) True >>> check_subarray_sum([1000000, 1000000, -1000000, -1000000], 0) True","solution":"def check_subarray_sum(nums, k): Determines if there exists a continuous subarray whose sum is exactly k. Parameters: - nums: List[int], array of integers - k: int, target sum Returns: - bool: True if such a subarray exists, otherwise False cumulative_sum = 0 sum_dict = {0: -1} # To handle the case when subarray starts from index 0 for i, num in enumerate(nums): cumulative_sum += num if cumulative_sum - k in sum_dict: return True sum_dict[cumulative_sum] = i return False"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"dvdf\\") == 3 >>> length_of_longest_substring(\\"anviaj\\") == 5 >>> length_of_longest_substring(\\"tmmzuxt\\") == 5","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. start = 0 max_length = 0 used_char = {} for index, char in enumerate(s): if char in used_char and start <= used_char[char]: start = used_char[char] + 1 else: max_length = max(max_length, index - start + 1) used_char[char] = index return max_length"},{"question":"def can_jump(nums: List[int]) -> bool: Determine if you can reach the last index starting from the first index. Args: nums (list of int): List of non-negative integers representing the maximum jump length at each position. Returns: bool: True if you can reach the last index, False otherwise. >>> can_jump([2, 3, 1, 1, 4]) True >>> can_jump([3, 2, 1, 0, 4]) False >>> can_jump([0]) True >>> can_jump([2, 0]) True >>> can_jump([0, 2]) False >>> can_jump([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) True >>> can_jump([1, 1, 1, 1, 0, 0, 1, 1, 1, 1]) False >>> can_jump([10, 0, 0, 0, 0, 0, 0, 0, 0, 1]) True","solution":"def can_jump(nums): Determine if you can reach the last index starting from the first index. Args: nums (list of int): List of non-negative integers representing the maximum jump length at each position. Returns: bool: True if you can reach the last index, False otherwise. max_reach = 0 for i, num in enumerate(nums): if i > max_reach: return False max_reach = max(max_reach, i + num) return max_reach >= len(nums) - 1"},{"question":"def min_time_units(tasks: list[list[int]]) -> int: Given a list of tasks with their start and end times, determines the minimum number of time units needed to execute all tasks without any overlaps. Args: tasks (list of list of int): List of tasks where each task is represented by [start, end]. Returns: int: Minimum number of time units required to execute all tasks without overlaps. >>> min_time_units([[0, 2]]) 2 >>> min_time_units([[5, 10]]) 5 >>> min_time_units([]) 0","solution":"def min_time_units(tasks): Given a list of tasks with their start and end times, returns the minimum number of time units needed to execute all tasks without any overlaps. Args: tasks (list of list of int): List of tasks where each task is represented by [start, end]. Returns: int: Minimum number of time units required to execute all tasks without overlaps. if not tasks: return 0 # Sort tasks based on end time tasks.sort(key=lambda x: x[1]) # Initialize variables end_time = tasks[0][1] time_units = end_time - tasks[0][0] for task in tasks[1:]: # If task starts after or when the previous task ended, add its duration to time_units if task[0] >= end_time: end_time = task[1] time_units += task[1] - task[0] return time_units"},{"question":"from typing import List def min_cost_path(matrix: List[List[int]]) -> int: Finds the minimum cost to travel from the top-left corner to the bottom-right corner of the matrix moving only down or right. >>> min_cost_path([[5]]) 5 >>> min_cost_path([[1, 2, 3]]) 6 >>> min_cost_path([[1], [2], [3]]) 6 >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2, 5], [3, 2, 1]]) 6 >>> min_cost_path([]) 0 >>> min_cost_path([[1000, 2000], [3000, 4000]]) 7000 pass","solution":"def min_cost_path(matrix): Finds the minimum cost to travel from top-left corner to bottom-right corner of the matrix moving only down or right. :param matrix: List[List[int]] :return: int if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 # If the tree is empty, its height is -1 else: left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1 def bst_height(nums): Given an integer array \`nums\` of unique elements, construct a binary search tree (BST) from \`nums\` where elements are inserted into the BST in the order they appear in \`nums\`. Return the height of the BST. The height of a BST is the number of edges in the longest path from the root to a leaf node. >>> bst_height([10]) 0 >>> bst_height([10, 5]) 1 >>> bst_height([10, 5, 15, 3, 7, 12, 18]) 2 bst = BST() for num in nums: bst.insert(num) return bst.height()","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 # If the tree is empty, its height is -1 else: left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1 def bst_height(nums): bst = BST() for num in nums: bst.insert(num) return bst.height()"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head: ListNode, m: int, n: int) -> ListNode: Reverses the nodes of a singly linked list between positions m and n. Parameters: head (ListNode): The head of the singly linked list. m (int): The starting position (1-indexed) of the reversal. n (int): The ending position (1-indexed) of the reversal. Returns: ListNode: The head of the modified linked list. >>> list_to_array(reverse_between(array_to_list([1, 2, 3, 4, 5]), 2, 4)) [1, 4, 3, 2, 5] >>> list_to_array(reverse_between(array_to_list([1, 2, 3, 4, 5]), 1, 5)) [5, 4, 3, 2, 1] >>> list_to_array(reverse_between(array_to_list([1, 2, 3, 4, 5]), 1, 3)) [3, 2, 1, 4, 5] >>> list_to_array(reverse_between(array_to_list([1]), 1, 1)) [1] >>> list_to_array(reverse_between(array_to_list([1, 2]), 1, 2)) [2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head, m, n): Reverses the nodes of a singly linked list between positions m and n. Parameters: head (ListNode): The head of the singly linked list. m (int): The starting position (1-indexed) of the reversal. n (int): The ending position (1-indexed) of the reversal. Returns: ListNode: The head of the modified linked list. if not head or m == n: return head dummy = ListNode(0) dummy.next = head prev = dummy # Move \`prev\` to the node before position \`m\` for _ in range(m - 1): prev = prev.next current = prev.next next_node = current.next # Reverse the nodes between m and n for _ in range(n - m): current.next = next_node.next next_node.next = prev.next prev.next = next_node next_node = current.next return dummy.next"},{"question":"def add_binary(a: str, b: str) -> str: Adds two binary strings and returns the result as a binary string. >>> add_binary(\\"1010\\", \\"0101\\") \\"1111\\" >>> add_binary(\\"1101\\", \\"1011\\") \\"11000\\" >>> add_binary(\\"1111\\", \\"1111\\") \\"11110\\" >>> add_binary(\\"1\\", \\"1\\") \\"10\\" >>> add_binary(\\"101\\", \\"10\\") \\"111\\" >>> add_binary(\\"0\\", \\"0\\") \\"0\\" >>> add_binary(\\"000\\", \\"000\\") \\"000\\"","solution":"def add_binary(a, b): Adds two binary strings and returns the result as a binary string. max_len = max(len(a), len(b)) # Padding the shorter string with '0' a = a.zfill(max_len) b = b.zfill(max_len) result = \\"\\" carry = 0 # Iterate from the last character to the first character for i in range(max_len - 1, -1, -1): bit_a = int(a[i]) bit_b = int(b[i]) # Sum of two bits and the carry total = bit_a + bit_b + carry # Resultant bit result = str(total % 2) + result # Calculate the new carry carry = total // 2 # If there is a carry left, we add it to the result if carry > 0: result = str(carry) + result return result"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: List[List[int]]: Zigzag level order traversal of the tree. >>> root = TreeNode(1) >>> zigzagLevelOrder(root) [[1]] >>> zigzagLevelOrder(None) [] >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[3], [20, 9], [15, 7]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> zigzagLevelOrder(root) [[1], [3, 2]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[1], [3, 2], [4, 5, 6, 7]]","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. if not root: return [] results = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) level = deque() for _ in range(level_size): node = node_queue.popleft() if left_to_right: level.append(node.val) else: level.appendleft(node.val) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) results.append(list(level)) left_to_right = not left_to_right return results"},{"question":"def rearrange_heights(heights: List[int], positions: List[int]) -> List[int]: Rearrange the heights of students based on the given new positions. Parameters: - heights: A list of integers where each integer represents the height of a student. - positions: A list of integers where each integer represents the new position of the corresponding student in the heights list. Returns: - A list of integers representing the rearranged heights. >>> rearrange_heights([150, 160, 170, 180], [2, 0, 3, 1]) [160, 180, 150, 170] >>> rearrange_heights([150, 160, 170, 180], [0, 1, 2, 3]) [150, 160, 170, 180] >>> rearrange_heights([150], [0]) [150] >>> rearrange_heights([150, 160, 170, 180], [3, 2, 1, 0]) [180, 170, 160, 150] >>> rearrange_heights([150, 150, 150, 150], [1, 3, 0, 2]) [150, 150, 150, 150]","solution":"def rearrange_heights(heights, positions): Rearrange the heights of students based on the given new positions. Parameters: - heights: A list of integers where each integer represents the height of a student. - positions: A list of integers where each integer represents the new position of the corresponding student in the heights list. Returns: - A list of integers representing the rearranged heights. # Creating a new list of the same length as heights initialized with None values rearranged = [None] * len(heights) # Placing each height at the new position for i in range(len(heights)): rearranged[positions[i]] = heights[i] return rearranged"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Given a string s consisting of only characters 'a' and 'b', return the length of the longest valid palindromic subsequence that can be obtained from s. >>> longest_palindromic_subsequence('') == 0 >>> longest_palindromic_subsequence('a') == 1 >>> longest_palindromic_subsequence('b') == 1 >>> longest_palindromic_subsequence('aaaa') == 4 >>> longest_palindromic_subsequence('bbbb') == 4 >>> longest_palindromic_subsequence('ab') == 1 >>> longest_palindromic_subsequence('aab') == 2 >>> longest_palindromic_subsequence('abb') == 2 >>> longest_palindromic_subsequence('aabb') == 2 >>> longest_palindromic_subsequence('aaabbb') == 3 >>> longest_palindromic_subsequence('abababab') == 4","solution":"def longest_palindromic_subsequence(s): Given a string s consisting of only characters 'a' and 'b', return the length of the longest valid palindromic subsequence that can be obtained from s. count_a = s.count('a') count_b = s.count('b') # The longest palindromic subsequence can be made by picking all occurrences of 'a' # and/or all occurrences of 'b' (whichever is higher), as each single character is # a palindrome and removing others still keeps the subsequence a palindrome. return max(count_a, count_b)"},{"question":"from typing import List def longestCommonPrefix(strs: List[str]) -> str: Write a function that takes a list of strings as input and returns the longest common prefix among all the strings. If there is no common prefix, return an empty string. >>> longestCommonPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longestCommonPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longestCommonPrefix([\\"test\\", \\"test\\", \\"test\\"]) 'test' >>> longestCommonPrefix([\\"single\\"]) 'single' >>> longestCommonPrefix([]) '' >>> longestCommonPrefix([\\"\\", \\"\\", \\"\\"]) '' >>> longestCommonPrefix([\\"prefix\\", \\"prefixation\\", \\"prefixable\\"]) 'prefix' >>> longestCommonPrefix([\\"ab\\", \\"abc\\", \\"abcd\\"]) 'ab'","solution":"from typing import List def longestCommonPrefix(strs: List[str]) -> str: if not strs: return \\"\\" # Sort the list, the common prefix of the whole list # would be the common prefix of the first and last elements strs.sort() first = strs[0] last = strs[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s, t): Check whether t is a subtree of s. >>> s = TreeNode(3, left=TreeNode(4, left=TreeNode(1), right=TreeNode(2)), right=TreeNode(5)) >>> t = TreeNode(4, left=TreeNode(1), right=TreeNode(2)) >>> is_subtree(s, t) True >>> s = TreeNode(3, left=TreeNode(4, left=TreeNode(1), right=TreeNode(2)), right=TreeNode(5)) >>> t = TreeNode(4, left=TreeNode(1)) >>> is_subtree(s, t) False >>> s = TreeNode(1) >>> t = None >>> is_subtree(s, t) True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s, t): if not t: return True if not s: return False if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t) def is_same_tree(s, t): if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right)"},{"question":"from typing import List def check_subarray_sum(arr: List[int], k: int) -> bool: Returns True if there is a continuous subarray of size at least k that sums up to a multiple of k, otherwise False. >>> check_subarray_sum([1, 2, 3], 4) == False >>> check_subarray_sum([1, 2, 3], 3) == True >>> check_subarray_sum([1, 2, 4], 3) == False >>> check_subarray_sum([1, 2, 3, 4, 5], 3) == True >>> check_subarray_sum([5, 0, 0, 0, 5], 2) == True >>> check_subarray_sum([-1, 2, 9], 2) == True >>> check_subarray_sum([-1, -2, -3], 5) == False >>> check_subarray_sum([0, 0, 0], 2) == True >>> check_subarray_sum([0, 1, 0], 2) == False","solution":"def check_subarray_sum(arr, k): Returns True if there is a continuous subarray of size at least k that sums up to a multiple of k, otherwise False. if len(arr) < k: return False cum_sum = 0 mod_dict = {0: -1} for i, num in enumerate(arr): cum_sum += num mod = cum_sum % k if mod in mod_dict: if i - mod_dict[mod] >= k: return True else: mod_dict[mod] = i return False"},{"question":"def smallest_subsequence(s: str, k: int) -> str: Construct the lexicographically smallest subsequence of string \`s\` with exactly \`k\` distinct characters. If there is no such subsequence, return an empty string. >>> smallest_subsequence(\\"abcde\\", 3) \\"abc\\" >>> smallest_subsequence(\\"abcde\\", 2) \\"ab\\" >>> smallest_subsequence(\\"abc\\", 4) \\"\\" >>> smallest_subsequence(\\"\\", 1) \\"\\" >>> smallest_subsequence(\\"a\\", 1) \\"a\\" >>> smallest_subsequence(\\"aabbcc\\", 3) \\"abc\\" >>> smallest_subsequence(\\"bcabc\\", 3) \\"abc\\" >>> smallest_subsequence(\\"abcdefghij\\", 10) \\"abcdefghij\\" >>> smallest_subsequence(\\"abcdefghij\\", 9) \\"abcdefghi\\" >>> smallest_subsequence(\\"cbacdcbc\\", 4) \\"acdb\\"","solution":"def smallest_subsequence(s, k): from collections import Counter count = Counter(s) stack = [] seen = set() for char in s: if char not in seen: while stack and stack[-1] > char and count[stack[-1]] > 0 and len(seen) + 1 <= k: removed_char = stack.pop() seen.remove(removed_char) if len(seen) < k: stack.append(char) seen.add(char) count[char] -= 1 if len(seen) != k: return \\"\\" return \\"\\".join(stack)"},{"question":"class NumArray: Class to represent an integer array and support update and sum range operations. Methods: - __init__(self, n: int): Initializes an array of size n with zeros. - update(self, index: int, value: int): Updates the value at index in the array to value. - sumRange(self, left: int, right: int): Returns the sum of elements in range [left, right]. def __init__(self, n: int): Initializes an array of size n with zeros. def update(self, index: int, value: int): Updates the value at index in the array to value. def sumRange(self, left: int, right: int): Returns the sum of elements in range [left, right]. def test_initial_sum_range(): num_array = NumArray(5) assert num_array.sumRange(0, 4) == 0 def test_update_and_sum_range(): num_array = NumArray(5) num_array.update(1, 3) num_array.update(3, 5) assert num_array.sumRange(0, 4) == 8 assert num_array.sumRange(1, 3) == 8 assert num_array.sumRange(0, 1) == 3 assert num_array.sumRange(2, 4) == 5 def test_multiple_updates(): num_array = NumArray(5) num_array.update(1, 3) num_array.update(1, 2) assert num_array.sumRange(0, 4) == 2 num_array.update(4, 10) assert num_array.sumRange(3, 4) == 10 assert num_array.sumRange(0, 4) == 12 def test_edge_cases(): num_array = NumArray(1) assert num_array.sumRange(0, 0) == 0 num_array.update(0, 42) assert num_array.sumRange(0, 0) == 42","solution":"class NumArray: def __init__(self, n): Initializes an array of size n with zeros. self.n = n self.arr = [0] * n self.tree = [0] * (n + 1) def update(self, index, value): Updates the value at index in the array to value. diff = value - self.arr[index] self.arr[index] = value index += 1 while index <= self.n: self.tree[index] += diff index += (index & -index) def sumRange(self, left, right): Returns the sum of elements in range [left, right]. return self._prefix_sum(right + 1) - self._prefix_sum(left) def _prefix_sum(self, idx): total = 0 while idx > 0: total += self.tree[idx] idx -= (idx & -idx) return total"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_path_with_ones(root: TreeNode) -> int: Determine the length of the longest path in a binary tree where each node in the path has a value of \`1\`. >>> # Construct the tree >>> # 1 >>> # / >>> # 1 1 >>> # / >>> # 1 1 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(1) >>> longest_path_with_ones(root) 3 >>> root = TreeNode(0) >>> root.left = TreeNode(0) >>> root.right = TreeNode(0) >>> longest_path_with_ones(root) 0 >>> root = TreeNode(1) >>> longest_path_with_ones(root) 0 >>> # Construct the tree >>> # 1 >>> # / >>> # 1 >>> # / >>> # 1 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.left.left = TreeNode(1) >>> longest_path_with_ones(root) 2 >>> # Construct the tree >>> # 1 >>> # >>> # 1 >>> # >>> # 1 >>> root = TreeNode(1) >>> root.right = TreeNode(1) >>> root.right.right = TreeNode(1) >>> longest_path_with_ones(root) 2 >>> # Construct the tree >>> # 0 >>> # / >>> # 1 1 >>> # / >>> # 0 1 >>> # / >>> # 1 >>> root = TreeNode(0) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(1) >>> root.right.right.left = TreeNode(1) >>> longest_path_with_ones(root) 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_path_with_ones(root): def helper(node): if not node: return 0, 0 left_len, left_max = helper(node.left) right_len, right_max = helper(node.right) if node.val == 1: current_len = 1 + max(left_len, right_len) current_max = max(left_max, right_max, left_len + right_len + 1) else: current_len = 0 current_max = max(left_max, right_max) return current_len, current_max return max(helper(root)[1] - 1, 0)"},{"question":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreePaths: def __init__(self, root: TreeNode): self.root = root def getAllPaths(self) -> List[str]: Returns all root-to-leaf paths as a list of strings. Each path should be presented as a string of the integers separated by \\"->\\". >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> btp = BinaryTreePaths(root) >>> btp.getAllPaths() ['1->2->5', '1->3'] >>> root = TreeNode(1) >>> btp = BinaryTreePaths(root) >>> btp.getAllPaths() ['1'] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> btp = BinaryTreePaths(root) >>> btp.getAllPaths() ['1->2->3->4'] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> btp = BinaryTreePaths(root) >>> btp.getAllPaths() ['1->2->3->4'] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.left.right.left = TreeNode(7) >>> root.right.right.right = TreeNode(8) >>> btp = BinaryTreePaths(root) >>> btp.getAllPaths() ['1->2->4', '1->2->5->7', '1->3->6->8']","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreePaths: def __init__(self, root: TreeNode): self.root = root def getAllPaths(self) -> List[str]: def dfs(node, path): if node: # Append the current node's value to the path path += str(node.val) if not node.left and not node.right: # If it's a leaf node paths.append(path) # Append the current path to the paths list else: path += \\"->\\" # Add the arrow for the next child nodes dfs(node.left, path) dfs(node.right, path) paths = [] dfs(self.root, \\"\\") return paths"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest substring with equal numbers of '0's and '1's. >>> longest_balanced_substring(\\"01\\") 2 >>> longest_balanced_substring(\\"0011\\") 4 >>> longest_balanced_substring(\\"11001\\") 4 >>> longest_balanced_substring(\\"001101\\") 6 >>> longest_balanced_substring(\\"010101\\") 6 >>> longest_balanced_substring(\\"110100110\\") 8 >>> longest_balanced_substring(\\"1010110010\\") 10 >>> longest_balanced_substring(\\"10\\") 2","solution":"def longest_balanced_substring(s): Returns the length of the longest substring with equal numbers of '0's and '1's. count = 0 max_len = 0 index_map = {0: -1} for i, char in enumerate(s): count += 1 if char == '1' else -1 if count in index_map: max_len = max(max_len, i - index_map[count]) else: index_map[count] = i return max_len"},{"question":"def findLongestConsecutiveSequence(nums: list[int]) -> int: Write a function \`findLongestConsecutiveSequence\` that takes an unsorted array of integers \`nums\` and returns the length of the longest consecutive elements sequence. Example: >>> findLongestConsecutiveSequence([100, 4, 200, 1, 3, 2]) 4 >>> findLongestConsecutiveSequence([]) 0","solution":"def findLongestConsecutiveSequence(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def max_buildings_walkable(heights: List[int]) -> int: Returns the maximum number of buildings that can be walked on consecutively starting from the first building. The walk is possible only if the height of the next building is less than or equal to the current building's height. :param heights: List[int], heights of the buildings. :return: int, maximum number of buildings walkable consecutively. >>> max_buildings_walkable([5, 4, 3, 2, 1]) 5 >>> max_buildings_walkable([3, 3, 3, 3, 3]) 5 >>> max_buildings_walkable([1, 2, 3, 4, 5]) 1 >>> max_buildings_walkable([5, 4, 3, 3, 2, 1, 4, 2]) 6 >>> max_buildings_walkable([10]) 1 >>> max_buildings_walkable([]) 0 >>> max_buildings_walkable([5, 4, 2, 3, 1]) 3","solution":"def max_buildings_walkable(heights): Returns the maximum number of buildings that can be walked on consecutively starting from the first building. The walk is possible only if the height of the next building is less than or equal to the current building's height. :param heights: List[int], heights of the buildings. :return: int, maximum number of buildings walkable consecutively. if not heights: return 0 count = 1 for i in range(1, len(heights)): if heights[i] <= heights[i-1]: count += 1 else: break return count"},{"question":"def remove_duplicates(nums: List[int]) -> int: Removes duplicates from the sorted list nums in-place, fills remaining slots with -1 and returns the new length. >>> remove_duplicates([1, 1, 2, 2, 3, 4, 4]) 4 >>> remove_duplicates([1, 2, 3, 4, 5]) 5 >>> remove_duplicates([1, 1, 1, 1, 1]) 1 >>> remove_duplicates([]) 0 >>> remove_duplicates([7]) 1 pass","solution":"def remove_duplicates(nums): Removes duplicates from the sorted list nums in-place, fills remaining slots with -1 and returns the new length. if not nums: return 0 # If the list is empty, return 0 write_index = 1 for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[write_index] = nums[i] write_index += 1 # Fill the remaining slots with -1 for i in range(write_index, len(nums)): nums[i] = -1 return write_index"},{"question":"def min_operations_to_uniform_substring(s: str, k: int) -> int: Returns the minimum number of operations needed to make the string contain a substring of length k that consists of the same character repeated k times. >>> min_operations_to_uniform_substring(\\"aabaa\\", 3) 1 >>> min_operations_to_uniform_substring(\\"abcde\\", 1) 0 >>> min_operations_to_uniform_substring(\\"abcde\\", 2) 1 >>> min_operations_to_uniform_substring(\\"aaabbb\\", 3) 0 >>> min_operations_to_uniform_substring(\\"zyxwvu\\", 6) 5 >>> min_operations_to_uniform_substring(\\"abacabadabacaba\\", 2) 1 >>> min_operations_to_uniform_substring(\\"abababab\\", 3) 1","solution":"def min_operations_to_uniform_substring(s, k): Returns the minimum number of operations needed to make the string s contain a substring of length k that consists of the same character repeated k times. n = len(s) min_operations = float('inf') for i in range(n - k + 1): substring = s[i:i+k] count = [0] * 26 # Count frequency of each character in the substring for char in substring: count[ord(char) - ord('a')] += 1 # Find the most frequent character frequency max_freq = max(count) # Calculate the number of operations needed to make all characters the same operations = k - max_freq # Track the minimum operations encountered min_operations = min(min_operations, operations) return min_operations"},{"question":"def can_select_team(skills: List[int], x: int, k: int) -> bool: Returns true if it's possible to select exactly x members from skills array such that all have skill level of at least k. :param skills: List[int] - skill levels of team members. :param x: int - number of team members to select. :param k: int - minimum skill level required for selection. :return: bool - True if possible to select x members with skill level â‰¥ k, False otherwise. >>> can_select_team([5, 3, 7, 4, 8, 2, 10, 1], 3, 5) True >>> can_select_team([5, 3, 7, 4, 8, 2, 10, 1], 5, 5) False >>> can_select_team([5, 5, 5, 5, 5], 5, 5) True >>> can_select_team([6, 6, 6, 6, 6], 3, 6) True >>> can_select_team([3, 4, 5], 2, 6) False >>> can_select_team([], 1, 5) False >>> can_select_team([1, 2, 3], 0, 1) True # implementation here","solution":"def can_select_team(skills, x, k): Returns true if it's possible to select exactly x members from skills array such that all have skill level of at least k. :param skills: List[int] - skill levels of team members. :param x: int - number of team members to select. :param k: int - minimum skill level required for selection. :return: bool - True if possible to select x members with skill level â‰¥ k, False otherwise. # Filter out members that meet the skill level requirement suitable_members = [skill for skill in skills if skill >= k] # Check if there are at least x suitable members return len(suitable_members) >= x"},{"question":"def count_characters(words: List[str], chars: str) -> int: Returns the total length of all strings in \`words\` that can be formed by using the letters in \`chars\` exactly once. >>> count_characters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> count_characters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"welldonehoneyr\\") 10 >>> count_characters([\\"cat\\", \\"dog\\", \\"dad\\", \\"good\\"], \\"aatachogdo\\") 10 >>> count_characters([], \\"abc\\") 0 >>> count_characters([\\"a\\", \\"b\\", \\"c\\"], \\"\\") 0 >>> count_characters([\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaa\\") 6 >>> count_characters([\\"abcd\\"], \\"abc\\") 0","solution":"from collections import Counter def count_characters(words, chars): Returns the total length of all strings in \`words\` that can be formed by using the letters in \`chars\` exactly once. chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) for char in word_count: if word_count[char] > chars_count.get(char, 0): break else: total_length += len(word) return total_length"},{"question":"def count_unique_pairs(arr: List[int], k: int) -> int: Returns the count of unique pairs (arr[i], arr[j]) such that i != j and arr[i] + arr[j] = k. >>> count_unique_pairs([1, 2, 3, 4, 5], 5) 2 # (1,4), (2,3) >>> count_unique_pairs([1, 2, 2, 3, 4, 4, 5], 6) 2 # (2,4), (1,5) >>> count_unique_pairs([-3, -2, -1, 0, 1, 2, 3], 0) 3 # (-3,3), (-2,2), (-1,1) >>> count_unique_pairs([-4, -2, 0, 2, 4], 0) 2 # (-4,4), (-2,2) >>> count_unique_pairs([1, 3, 5, 7], 2) 0 # No pairs sum to 2","solution":"def count_unique_pairs(arr, k): Returns the count of unique pairs (arr[i], arr[j]) such that i != j and arr[i] + arr[j] = k. unique_pairs = set() seen = set() for num in arr: complement = k - num if complement in seen: unique_pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(unique_pairs)"},{"question":"def maximal_square(matrix: List[List[int]]) -> int: Find the largest square composed of 1's in a given m x n grid and return its area. >>> maximal_square([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 4 >>> maximal_square([ ... [0, 1], ... [1, 1] ... ]) 1 >>> maximal_square([ ... [1] ... ]) 1 >>> maximal_square([]) 0 >>> maximal_square([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> maximal_square([ ... [1, 1, 1, 0, 1], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 1], ... [0, 1, 1, 1, 1] ... ]) 9 >>> maximal_square([ ... [1, 0, 1, 0], ... [0, 1, 0, 1], ... [1, 1, 1, 1], ... [0, 0, 0, 0] ... ]) 1","solution":"def maximal_square(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] max_side = 0 for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i-1][j-1] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def num_rescue_boats(weights: List[int], limit: int) -> int: Returns the minimum number of boats required to carry all items within the weight limit. Each boat can carry at most two items. >>> num_rescue_boats([1, 2], 3) == 1 >>> num_rescue_boats([3, 2, 2, 1], 3) == 3 >>> num_rescue_boats([3, 5, 3, 4], 5) == 4 >>> num_rescue_boats([1], 3) == 1 >>> num_rescue_boats([4], 4) == 1 >>> num_rescue_boats([], 10) == 0 >>> num_rescue_boats([1, 2, 3, 4, 5], 10) == 3","solution":"def num_rescue_boats(weights, limit): Returns the minimum number of boats required to carry all items within the weight limit. Each boat can carry at most two items. weights.sort() left, right = 0, len(weights) - 1 boats = 0 while left <= right: if weights[left] + weights[right] <= limit: left += 1 right -= 1 boats += 1 return boats"},{"question":"def minCostConnectAllComputers(n: int, connections: List[List[int]]) -> int: Calculates the minimum cost to connect all computers in a network with the minimum total length of cable. If it's impossible to connect all computers, returns -1. Args: n (int): The number of computers. connections (List[List[int]]): A 2D list where connections[i] = [computer1, computer2, length]. Returns: int: The minimum cost to connect all computers, or -1 if it's impossible. Examples: >>> minCostConnectAllComputers(4, [[1, 2, 5], [1, 3, 8], [2, 4, 1], [3, 4, 10]]) 14 >>> minCostConnectAllComputers(4, []) -1 # Implementation here... from typing import List def test_example_case(): assert minCostConnectAllComputers(4, [[1, 2, 5], [1, 3, 8], [2, 4, 1], [3, 4, 10]]) == 14 def test_no_connections(): assert minCostConnectAllComputers(4, []) == -1 def test_all_computers_connected(): assert minCostConnectAllComputers(3, [[1, 2, 1], [2, 3, 1]]) == 2 def test_impossible_to_connect(): assert minCostConnectAllComputers(4, [[1, 2, 1], [2, 3, 2]]) == -1 def test_multiple_equal_minimum_cost(): assert minCostConnectAllComputers(4, [[1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 1, 1]]) == 3 def test_large_number_of_computers(): connections = [[i, i+1, i] for i in range(1, 1000)] assert minCostConnectAllComputers(1000, connections) == 499500","solution":"def minCostConnectAllComputers(n, connections): Calculates the minimum cost to connect all computers in a network algorithm using Kruskal's algorithm. Returns -1 if it is impossible to connect all computers. # Kruskal's algorithm requires sorting edges by weight and union-find to detect and avoid cycles def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 # Sort connections based on the cable length connections.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n + 1): parent.append(node) rank.append(0) result = 0 num_edges = 0 i = 0 while num_edges < n - 1 and i < len(connections): u, v, w = connections[i] i += 1 x = find(parent, u) y = find(parent, v) if x != y: num_edges += 1 result += w union(parent, rank, x, y) return result if num_edges == n - 1 else -1"},{"question":"from typing import List def max_subarray_sum_circular(nums: List[int]) -> int: Returns the maximum sum of a subarray in the circular track represented by nums. >>> max_subarray_sum_circular([5, -3, 5]) 10 >>> max_subarray_sum_circular([1, -2, 3, -2]) 3 >>> max_subarray_sum_circular([3, -1, 2, -1]) 4 >>> max_subarray_sum_circular([3, -2, 2, -3]) 3 >>> max_subarray_sum_circular([-2, -3, -1]) -1 >>> max_subarray_sum_circular([8, -1, -2, -3, -4, -5, 7]) 15","solution":"def max_subarray_sum_circular(nums): Returns the maximum sum of a subarray in the circular track represented by nums. def kadane(arr): current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum # Step 1: Find the maximum subarray sum using standard Kadane's algorithm max_kadane = kadane(nums) # Step 2: Find the maximum subarray sum that includes the wrapping around elements total_sum = sum(nums) inverted_nums = [-num for num in nums] max_wraparound = total_sum + kadane(inverted_nums) # max_wrap = total_sum - min_subarray_sum if max_wraparound == 0: return max_kadane return max(max_kadane, max_wraparound)"},{"question":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid that contains obstacles. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) 0 >>> unique_paths_with_obstacles([[0]]) 1 >>> unique_paths_with_obstacles([[1]]) 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid that contains obstacles. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Start point for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"from typing import List def tree_diameter(n: int, edges: List[List[int]]) -> int: You are given a binary tree with \`n\` nodes where each node has a unique value between \`1\` and \`n\`. The root of the tree has a value of \`1\`. You are tasked with finding the **diameter** of the tree, which is defined as the length of the longest path between any two nodes in the tree. The length of a path is represented by the number of edges between the corresponding nodes. Write a function that takes in an integer \`n\` and a list of edges, where each edge is represented as \`[u, v]\`, indicating that there is an edge between nodes \`u\` and \`v\`. Return the length of the diameter of the tree. >>> tree_diameter(1, []) 0 >>> tree_diameter(4, [[1, 2], [2, 3], [3, 4]]) 3 >>> tree_diameter(5, [[1, 2], [1, 3], [1, 4], [1, 5]]) 2 >>> tree_diameter(7, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7]]) 4 >>> tree_diameter(6, [[1, 2], [1, 3], [3, 4], [3, 5], [4, 6]]) 4","solution":"def tree_diameter(n, edges): from collections import defaultdict, deque if n == 1: return 0 # Create an adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Helper function to do BFS and return the farthest node and its distance def bfs(start): visited = [-1] * (n + 1) queue = deque([(start, 0)]) visited[start] = 0 farthest_node = start max_distance = 0 while queue: node, dist = queue.popleft() for neighbor in adj_list[node]: if visited[neighbor] == -1: visited[neighbor] = dist + 1 queue.append((neighbor, dist + 1)) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance # Start BFS from an arbitrary node (root in this case, which is 1) farthest_node_from_root, _ = bfs(1) # Perform BFS again from the farthest node found to get the diameter _, diameter_length = bfs(farthest_node_from_root) return diameter_length"},{"question":"def count_special_substrings(s: str) -> int: Return the number of different special substrings in the given string \`s\`. A special substring is defined as a substring that starts and ends with the same character, and all the characters in this substring should be the same. >>> count_special_substrings(\\"1111\\") == 10 >>> count_special_substrings(\\"22222\\") == 15 >>> count_special_substrings(\\"123\\") == 3 >>> count_special_substrings(\\"122333\\") == 10 >>> count_special_substrings(\\"123456\\") == 6 >>> count_special_substrings(\\"1212121\\") == 7 >>> count_special_substrings(\\"\\") == 0 >>> count_special_substrings(\\"1\\") == 1","solution":"def count_special_substrings(s): Return the number of different special substrings in the given string \`s\`. A special substring is defined as a substring that starts and ends with the same character, and all the characters in this substring should be the same. count = 0 n = len(s) # Iterate over each character in the string for i in range(n): # Expand around the character to count all special substrings for j in range(i, n): if s[i] == s[j] and (s[i:j+1] == s[i] * (j - i + 1)): count += 1 else: break # if we found a non-special substring, break the inner loop return count"},{"question":"def double_characters_to_lexico_smallest(s: str, k: int) -> str: Returns the lexicographically smallest string by doubling characters in the string \`s\` exactly \`k\` times. >>> double_characters_to_lexico_smallest(\\"abc\\", 2) \\"aaabc\\" >>> double_characters_to_lexico_smallest(\\"a\\", 1) \\"aa\\" >>> double_characters_to_lexico_smallest(\\"a\\", 3) \\"aaaa\\" >>> double_characters_to_lexico_smallest(\\"abac\\", 1) \\"aabac\\" >>> double_characters_to_lexico_smallest(\\"abac\\", 2) \\"aaabac\\" >>> double_characters_to_lexico_smallest(\\"bbbb\\", 2) \\"bbbbbb\\" >>> double_characters_to_lexico_smallest(\\"abcdefghijklmnopqrstuvwxyz\\", 1) \\"aabcdefghijklmnopqrstuvwxyz\\"","solution":"def double_characters_to_lexico_smallest(s, k): Returns the lexicographically smallest string by doubling characters in the string \`s\` exactly \`k\` times. # Convert the string to a list of characters to facilitate character insertion s = list(s) # Perform \`k\` operations for _ in range(k): # Find the first character that when doubled results in the smaller lexicographical string smallest_char = min(s) smallest_char_pos = s.index(smallest_char) # Double the smallest character by inserting one at its position s.insert(smallest_char_pos, smallest_char) # Join the list back to a string and return return \\"\\".join(s)"},{"question":"from typing import List def can_jump(nums: List[int]) -> bool: Determines if you can reach the last index starting from the first index in an array of non-negative integers. :param nums: List[int], a list of non-negative integers where each element represents the maximum number of steps forward. :return: bool, True if you can reach the last index, False otherwise. # Implementation goes here def test_can_jump_true_cases(): assert can_jump([2,3,1,1,4]) == True assert can_jump([0]) == True assert can_jump([2,5,0,0]) == True assert can_jump([1,1,1,1,1,1]) == True def test_can_jump_false_cases(): assert can_jump([3,2,1,0,4]) == False assert can_jump([1,0,0,0,0]) == False assert can_jump([2,0,1,0,0]) == False assert can_jump([1,1,0,0,1]) == False def test_can_jump_edge_cases(): assert can_jump([0,1]) == False assert can_jump([1,2,3]) == True assert can_jump([10,9,8,7,6,5,4,3,2,1,0]) == True","solution":"def can_jump(nums): Determines if you can reach the last index starting from the first index in an array of non-negative integers. :param nums: List[int], a list of non-negative integers where each element represents the maximum number of steps forward. :return: bool, True if you can reach the last index, False otherwise. max_reachable = 0 for i in range(len(nums)): if i > max_reachable: return False max_reachable = max(max_reachable, i + nums[i]) return max_reachable >= len(nums) - 1"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced substring in the binary string \`s\`. A balanced substring contains an equal number of '0's and '1's. >>> longest_balanced_substring(\\"\\") == 0 >>> longest_balanced_substring(\\"0000\\") == 0 >>> longest_balanced_substring(\\"1111\\") == 0 >>> longest_balanced_substring(\\"01\\") == 2 >>> longest_balanced_substring(\\"1100\\") == 4 >>> longest_balanced_substring(\\"110100\\") == 6 >>> longest_balanced_substring(\\"10101\\") == 4 >>> longest_balanced_substring(\\"00110011\\") == 8 >>> longest_balanced_substring(\\"110011001100\\") == 12","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring in the binary string \`s\`. A balanced substring contains an equal number of '0's and '1's. longest_length = 0 balance = 0 balance_dict = {0:-1} for i, char in enumerate(s): if char == '0': balance -= 1 else: balance += 1 if balance in balance_dict: longest_length = max(longest_length, i - balance_dict[balance]) else: balance_dict[balance] = i return longest_length"},{"question":"def min_height_difference(crates: List[int], n: int) -> int: Determines the minimum possible height difference between the tallest and the shortest stacks after all crates have been stacked. :param crates: List[int] where crates[i] represents the height of the i-th crate :param n: int representing the number of stacks required :return: int - minimum possible height difference >>> min_height_difference([1, 5, 9, 13], 2) 4 >>> min_height_difference([1, 2, 3, 4, 5, 6], 6) 0 >>> min_height_difference([10, 20, 30, 40, 50, 60, 70], 3) 20 >>> min_height_difference([3, 3, 3, 3, 3], 2) 0 >>> min_height_difference([4, 5, 6], 2) 1 pass","solution":"def min_height_difference(crates, n): Determines the minimum possible height difference between the tallest and the shortest stacks after all crates have been stacked. :param crates: List[int] where crates[i] represents the height of the i-th crate :param n: int representing the number of stacks required :return: int - minimum possible height difference if len(crates) == n: return 0 # Each crate will be in its own stack crates.sort() min_diff = float('inf') for i in range(len(crates) - n + 1): current_diff = crates[i + n - 1] - crates[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def uniqueFrequencies(nums: List[int]) -> bool: Returns True if no two letters have the same frequency, otherwise False >>> uniqueFrequencies([1, 2, 3, 4]) == True >>> uniqueFrequencies([1, 2, 2, 3]) == False >>> uniqueFrequencies([1]) == True >>> uniqueFrequencies([]) == True >>> uniqueFrequencies([2, 2, 2, 2]) == False >>> uniqueFrequencies([4, 5, 6, 2, 7, 8, 9, 10]) == True","solution":"def uniqueFrequencies(nums): Returns True if no two letters have the same frequency, otherwise False frequencies_set = set(nums) # Convert the list to a set to remove duplicates return len(frequencies_set) == len(nums)"},{"question":"def longestValidParentheses(s: str) -> int: Returns the length of the longest valid (well-formed) parentheses substring. Parameters: s (str): The input string containing only '(' and ')'. Returns: int: The length of the longest valid parentheses substring. >>> longestValidParentheses(\\"()()\\") == 4 >>> longestValidParentheses(\\"(()\\") == 2 >>> longestValidParentheses(\\")()())\\") == 4 >>> longestValidParentheses(\\"()(()\\") == 2","solution":"def longestValidParentheses(s): Returns the length of the longest valid (well-formed) parentheses substring. Parameters: s (str): The input string containing only '(' and ')'. Returns: int: The length of the longest valid parentheses substring. max_length = 0 stack = [-1] for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root, x): Remove all nodes from the binary tree whose value is greater than \`x\`. Args: root (TreeNode): The root of the binary tree. x (int): The threshold value for pruning. Returns: TreeNode: The root of the modified tree. >>> tree = TreeNode(3, TreeNode(2), TreeNode(4)) >>> result = pruneTree(tree, 5) >>> tree_to_list(result) [3, 2, 4] >>> tree = TreeNode(3, TreeNode(2), TreeNode(4)) >>> result = pruneTree(tree, 3) >>> tree_to_list(result) [3, 2] >>> tree = TreeNode(3, TreeNode(5), TreeNode(6)) >>> result = pruneTree(tree, 0) >>> tree_to_list(result) [] >>> tree = TreeNode(4, TreeNode(5), TreeNode(3, TreeNode(2), TreeNode(6))) >>> result = pruneTree(tree, 4) >>> tree_to_list(result) [4, None, 3, 2] >>> tree = TreeNode(4, TreeNode(5)) >>> result = pruneTree(tree, 4) >>> tree_to_list(result) [4] def tree_to_list(root): Helper function to convert tree to list for easier validation if not root: return [] result, queue = [], [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) # Remove trailing None values while result and result[-1] is None: result.pop() return result","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root, x): if root is None: return None # Recursively prune the left and right subtrees root.left = pruneTree(root.left, x) root.right = pruneTree(root.right, x) # If the current node's value is greater than x, remove this node if root.val > x: return None # Otherwise return the current node return root"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns the level order traversal of a binary tree. >>> levelOrder(TreeNode(1)) == [[1]] >>> levelOrder(None) == [] >>> levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == [[3], [9, 20], [15, 7]] >>> levelOrder(TreeNode(1, TreeNode(2, TreeNode(3), None), None)) == [[1], [2], [3]] >>> levelOrder(TreeNode(1, None, TreeNode(2, None, TreeNode(3)))) == [[1], [2], [3]] >>> levelOrder(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))) == [[1], [2, 3], [4, 5, 6, 7]] pass","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns the level order traversal of a binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def max_subarray_sum(nums): Finds the contiguous subarray with the largest sum and returns that sum. Args: nums (List[int]): A list of integers. Returns: int: The largest sum of a contiguous subarray. Examples: >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-2, -3, -1, -4]) -1 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([-1, -3, 4, -1, 2, 1, -5, 4]) 6","solution":"def max_subarray_sum(nums): Finds the contiguous subarray with the largest sum and returns that sum. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def is_palindrome(s: str) -> bool: Check if a given string is a palindrome. >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"aa\\") True >>> is_palindrome(\\"abc\\") False def count_palindromic_substrings(s: str) -> int: Given a string \`s\`, count the number of times a non-overlapping substring, which is a palindrome, appears in \`s\`. A palindrome is a sequence of characters that reads the same backward as forward. Two occurrences of the same substring are counted as different if they start at different positions in the string. Return the number of non-overlapping palindromic substrings in \`s\`. >>> count_palindromic_substrings(\\"aaaa\\") 10 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aba\\") 4 >>> count_palindromic_substrings(\\"\\") 0","solution":"def is_palindrome(s): return s == s[::-1] def count_palindromic_substrings(s): n = len(s) count = 0 # Iterate over all possible substring lengths for length in range(1, n + 1): i = 0 # Iterate over all possible substrings of length \`length\` while i + length <= n: substring = s[i:i + length] if is_palindrome(substring): count += 1 i += 1 return count"},{"question":"def max_apples(grid: List[List[int]]) -> int: Given a 2D grid where each cell contains a certain number of apples, find the maximum number of apples you can collect starting from the top-left corner and moving only to the right or down. >>> max_apples([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 >>> max_apples([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 >>> max_apples([ ... [1, 2, 5], ... [3, 2, 1] ... ]) == 9 >>> max_apples([ ... [1] ... ]) == 1 >>> max_apples([ ... [5, 3, 2, 1] ... ]) == 11 >>> max_apples([ ... [1], ... [1], ... [1] ... ]) == 3 >>> max_apples([]) == 0 >>> max_apples([[0]]) == 0","solution":"def max_apples(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) return dp[n-1][m-1]"},{"question":"def generate_zigzag_matrix(n): Generate a zigzag pattern in an n x n matrix by filling it with consecutive integers starting from 1. The pattern starts from the top-left corner and zigzags through the rows. Parameters: n (int): The dimension of the n x n matrix. Returns: matrix (list of list of int): The n x n matrix with the zigzag pattern. Example: >>> generate_zigzag_matrix(1) [[1]] >>> generate_zigzag_matrix(2) [[1, 2], [4, 3]] >>> generate_zigzag_matrix(3) [[1, 2, 3], [6, 5, 4], [7, 8, 9]] >>> generate_zigzag_matrix(4) [[1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12], [16, 15, 14, 13]] >>> generate_zigzag_matrix(5) [[1, 2, 3, 4, 5], [10, 9, 8, 7, 6], [11, 12, 13, 14, 15], [20, 19, 18, 17, 16], [21, 22, 23, 24, 25]]","solution":"def generate_zigzag_matrix(n): Generate a zigzag pattern in an n x n matrix by filling it with consecutive integers starting from 1. The pattern starts from the top-left corner and zigzags through the rows. Parameters: n (int): The dimension of the n x n matrix. Returns: matrix (list of list of int): The n x n matrix with the zigzag pattern. matrix = [[0] * n for _ in range(n)] current_number = 1 for i in range(n): if i % 2 == 0: # Fill left to right for j in range(n): matrix[i][j] = current_number current_number += 1 else: # Fill right to left for j in range(n-1, -1, -1): matrix[i][j] = current_number current_number += 1 return matrix"},{"question":"def min_operations(nums, x): Find the minimum number of operations required to reduce the sum of the elements in nums to be less than or equal to x by removing elements from either end of the array. >>> min_operations([1, 1, 4, 2, 3], 5) 2 >>> min_operations([5, 6, 7, 8, 9], 4) -1 >>> min_operations([3, 2, 20, 1, 1, 3], 10) 5 >>> min_operations([], 0) 0 >>> min_operations([], 10) -1 >>> min_operations([10], 10) 1 >>> min_operations([10], 5) -1 >>> min_operations([1, 2, 3, 4, 5], 15) 5","solution":"def min_operations(nums, x): total_sum = sum(nums) target = total_sum - x if target < 0: return -1 if target == 0: return len(nums) max_length = -1 current_sum = 0 left = 0 for right in range(len(nums)): current_sum += nums[right] while current_sum > target and left <= right: current_sum -= nums[left] left += 1 if current_sum == target: max_length = max(max_length, right - left + 1) return len(nums) - max_length if max_length != -1 else -1"},{"question":"def evaluate_postfix(expression: str) -> int: Evaluates a mathematical expression in postfix notation. >>> evaluate_postfix(\\"3 4 +\\") 7 >>> evaluate_postfix(\\"3 4 *\\") 12 >>> evaluate_postfix(\\"8 4 /\\") 2 >>> evaluate_postfix(\\"3 4 + 2 * 7 /\\") 2 >>> evaluate_postfix(\\"8 5 -\\") 3 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14","solution":"def evaluate_postfix(expression): Evaluates a mathematical expression in postfix notation. Parameters: expression (str): A string containing the postfix notation expression. Returns: int: The result of the evaluated postfix expression. stack = [] for token in expression.split(): if token.isdigit(): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(a // b) # Integer division return stack.pop()"},{"question":"def can_form_rounds(nums: List[int]) -> bool: Check if you can rearrange the elements of nums to form rounds where each element nums[i] plus its subsequent unique element equals to a constant sum s, and all elements must be used. >>> can_form_rounds([2, 3, 6, 5, 1, 4]) == True >>> can_form_rounds([1, 2, 3, 5]) == False >>> can_form_rounds([1, 1]) == True >>> can_form_rounds([1, 2, 3, 4, 5, 6, 7, 9, 16, 8]) == False >>> can_form_rounds([1, 5, 3, 3, 5, 1]) == True >>> can_form_rounds([2, 2, 2, 2]) == True >>> can_form_rounds([0, 0, 0, 0]) == True","solution":"def can_form_rounds(nums): Check if the array can be rearranged into rounds where each pair sums up to a constant value. total_sum = sum(nums) n = len(nums) if total_sum % (n // 2) != 0: return False target_sum = total_sum // (n // 2) nums.sort() used = [False] * n for i in range(n): if used[i]: continue found_pair = False for j in range(i + 1, n): if not used[j] and nums[i] + nums[j] == target_sum: used[i] = used[j] = True found_pair = True break if not found_pair: return False return True"},{"question":"def merge_alternate(word1: str, word2: str) -> str: Constructs a string by alternating characters from \`word1\` and \`word2\`. If one string is shorter, append the rest of the longer string at the end. >>> merge_alternate(\\"abc\\", \\"123\\") \\"a1b2c3\\" >>> merge_alternate(\\"abcde\\", \\"12\\") \\"a1b2cde\\" >>> merge_alternate(\\"ab\\", \\"12345\\") \\"a1b2345\\" >>> merge_alternate(\\"\\", \\"123\\") \\"123\\" >>> merge_alternate(\\"abc\\", \\"\\") \\"abc\\" >>> merge_alternate(\\"\\", \\"\\") \\"\\"","solution":"def merge_alternate(word1, word2): Constructs a string by alternating characters from \`word1\` and \`word2\`. If one string is shorter, append the rest of the longer string at the end. Parameters: word1 (str): The first string. word2 (str): The second string. Returns: str: The resulting merged string. target = [] len1, len2 = len(word1), len(word2) for i in range(max(len1, len2)): if i < len1: target.append(word1[i]) if i < len2: target.append(word2[i]) return ''.join(target)"},{"question":"from typing import List def findNumberOfGroups(coordinates: List[List[int]]) -> int: Determine the number of distinct connected groups formed by the points. Args: coordinates (List[List[int]]): List of coordinates where each coordinate is a pair of integers [x, y] Returns: int: Number of distinct connected groups >>> findNumberOfGroups([[0, 0]]) 1 >>> findNumberOfGroups([[0, 0], [0, 1]]) 1 >>> findNumberOfGroups([[0, 0], [1, 1]]) 2 >>> findNumberOfGroups([[0, 0], [0, 1], [0, 2]]) 1 >>> findNumberOfGroups([[0, 0], [0, 1], [1, 1]]) 1 >>> findNumberOfGroups([[0, 0], [0, 1], [1, 1], [2, 2], [3, 2]]) 2 >>> findNumberOfGroups([[1, 2], [2, 2], [3, 2], [4, 4], [5, 4], [6, 6], [7, 6]]) 3 >>> findNumberOfGroups([[0, 0], [1, 1], [2, 2], [3, 3]]) 4","solution":"def findNumberOfGroups(coordinates): Finds the number of distinct connected groups formed by the points. from collections import defaultdict def dfs(point, visited, graph): stack = [point] while stack: current = stack.pop() visited.add(current) for neighbor in graph[current]: if neighbor not in visited: stack.append(neighbor) graph = defaultdict(list) for i, (x1, y1) in enumerate(coordinates): for j, (x2, y2) in enumerate(coordinates): if i != j and (x1 == x2 or y1 == y2): graph[(x1, y1)].append((x2, y2)) graph[(x2, y2)].append((x1, y1)) visited = set() count = 0 for point in coordinates: if tuple(point) not in visited: dfs(tuple(point), visited, graph) count += 1 return count"},{"question":"def containsPrefix(s: str, substring: str) -> bool: Returns True if any word in the string \`s\` starts with the given \`substring\`, otherwise returns False. >>> containsPrefix(\\"hello world\\", \\"he\\") True >>> containsPrefix(\\"hello world\\", \\"wo\\") True >>> containsPrefix(\\"hello world\\", \\"no\\") False >>> containsPrefix(\\"\\", \\"he\\") False >>> containsPrefix(\\"hello world\\", \\"\\") True >>> containsPrefix(\\"hello world\\", \\"hello\\") True >>> containsPrefix(\\"\\", \\"\\") False","solution":"def containsPrefix(s, substring): Returns True if any word in the string \`s\` starts with the given \`substring\`, otherwise returns False. words = s.split() for word in words: if word.startswith(substring): return True return False"},{"question":"def min_students_to_move(heights: List[int]) -> int: Calculate the minimum number of students to move to make the heights non-decreasing. :param heights: List of heights of the students :type heights: List[int] :return: Minimum number of students that need to be moved :rtype: int >>> min_students_to_move([1, 2, 3, 4, 5]) 0 >>> min_students_to_move([1, 3, 2, 4, 5]) 2 >>> min_students_to_move([5, 1, 3, 2, 4]) 4 >>> min_students_to_move([3, 3, 2, 2, 1]) 4 >>> min_students_to_move([]) 0 >>> min_students_to_move([5]) 0 >>> min_students_to_move([3, 3, 3, 3, 3]) 0 >>> min_students_to_move([1, 2, 2, 3, 4]) 0","solution":"def min_students_to_move(heights): Calculate the minimum number of students to move to make the heights non-decreasing. :param heights: List[int], list of heights of the students :return: int, minimum number of students that need to be moved sorted_heights = sorted(heights) moves = sum(1 for i in range(len(heights)) if heights[i] != sorted_heights[i]) return moves"},{"question":"def min_additional_markers(nums, k): Given a list of integers \`nums\` representing the positions of markers on a number line, and an integer \`k\`, determine the minimum number of additional markers needed such that every pair of consecutive markers has a gap of at most \`k\` units. Markers can only be placed at integer positions. Return the minimum number of additional markers required. >>> min_additional_markers([1, 3, 5], 2) 0 >>> min_additional_markers([1, 4], 2) 1 >>> min_additional_markers([1, 10], 2) 4 >>> min_additional_markers([1, 20], 5) 3 >>> min_additional_markers([], 3) 0 >>> min_additional_markers([5], 2) 0 >>> min_additional_markers([1, 10, 20, 30], 10) 0","solution":"def min_additional_markers(nums, k): Given a list of integers \`nums\` representing the positions of markers on a number line, and an integer \`k\`, determine the minimum number of additional markers needed such that every pair of consecutive markers has a gap of at most \`k\` units. Markers can only be placed at integer positions. Return the minimum number of additional markers required. # Sort the list to ensure the markers are in increasing order nums.sort() additional_markers_needed = 0 # Iterate through the pairs of consecutive markers for i in range(1, len(nums)): gap = nums[i] - nums[i-1] if gap > k: # Calculate the number of markers needed in between additional_markers_needed += (gap - 1) // k return additional_markers_needed"},{"question":"def binary_to_decimal(binary_list): This function converts a binary number represented as a list of non-negative integers to its decimal equivalent. :param binary_list: List[int] - A list of 0s and 1s representing a binary number, with the most significant bit at the start. :return: int - The decimal equivalent of the binary number. >>> binary_to_decimal([0]) 0 >>> binary_to_decimal([1]) 1 >>> binary_to_decimal([0, 0, 0, 0]) 0 >>> binary_to_decimal([1, 1, 1, 1]) 15 >>> binary_to_decimal([1, 0, 1]) 5 >>> binary_to_decimal([1, 0, 0, 1]) 9 >>> binary_to_decimal([1, 0, 1, 0, 1, 1, 1, 0]) 174","solution":"def binary_to_decimal(binary_list): This function converts a binary number represented as a list of non-negative integers to its decimal equivalent. :param binary_list: List[int] - A list of 0s and 1s representing a binary number, with the most significant bit at the start. :return: int - The decimal equivalent of the binary number. decimal_number = 0 length = len(binary_list) for i in range(length): decimal_number += binary_list[i] * (2 ** (length - i - 1)) return decimal_number"},{"question":"def longest_unique_subarray(nums: List[int]) -> List[int]: Returns the longest contiguous subarray with all unique elements. >>> longest_unique_subarray([]) == [] >>> longest_unique_subarray([1]) == [1] >>> longest_unique_subarray([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> longest_unique_subarray([1, 2, 2, 1, 3]) == [2, 1, 3] >>> longest_unique_subarray([1, 2, 3, 2, 5, 2, 3, 4, 1, 5, 6]) == [2, 3, 4, 1, 5, 6] >>> longest_unique_subarray([1, 2, 3, 1, 2, 3, 4]) == [1, 2, 3, 4]","solution":"def longest_unique_subarray(nums): Returns the longest contiguous subarray with all unique elements. if not nums: return [] element_index = {} start = 0 maxLength = 0 maxStart = 0 for i in range(len(nums)): if nums[i] in element_index and element_index[nums[i]] >= start: start = element_index[nums[i]] + 1 element_index[nums[i]] = i if i - start + 1 > maxLength: maxLength = i - start + 1 maxStart = start return nums[maxStart:maxStart + maxLength]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root: TreeNode) -> int: Given a binary tree where each node has a value \`0\` or \`1\`, calculate the longest path consisting of nodes with the same value. The path does not need to go through the root and can be either from one node to any of its descendants or across the tree horizontally. Return the length of the longest path that consists of nodes with the same value. Args: root (TreeNode): The root of the binary tree. Returns: int: The length of the longest path with the same value. >>> longestUnivaluePath(None) == 0 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> longestUnivaluePath(root) == 1 >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> longestUnivaluePath(root) == 0 >>> root = TreeNode(1) >>> root.left = TreeNode(4) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(5) >>> longestUnivaluePath(root) == 2 >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.right = TreeNode(5) >>> longestUnivaluePath(root) == 2 # Your code here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root): Function to calculate the longest path in a binary tree where each node has value 0 or 1 and all nodes in the path have the same value. Args: root (TreeNode): The root of the binary tree. Returns: int: The length of the longest path with the same value. def helper(node): if not node: return 0, 0 left_length, left_max = helper(node.left) right_length, right_max = helper(node.right) left_path = right_path = 0 if node.left and node.left.val == node.val: left_path = left_length + 1 if node.right and node.right.val == node.val: right_path = right_length + 1 max_path = max(left_max, right_max, left_path + right_path) return max(left_path, right_path), max_path _, result = helper(root) return result"},{"question":"from typing import List def top_k_frequent_words(s: str, k: int) -> List[str]: Identify the k most frequent words in the document. Args: s (str): the input string/document. k (int): the number of top frequent words to return. Returns: list: a list of the top k most frequent words. >>> top_k_frequent_words(\\"hello world hello\\", 1) [\\"hello\\"] >>> top_k_frequent_words(\\"a b c a b c a\\", 2) [\\"a\\", \\"b\\"] >>> top_k_frequent_words(\\"this is a test all words unique\\", 3) [\\"a\\", \\"all\\", \\"is\\"] >>> top_k_frequent_words(\\"hello, world! hello.\\", 1) [\\"hello\\"] >>> top_k_frequent_words(\\"one two three four\\", 4) [\\"four\\", \\"one\\", \\"three\\", \\"two\\"]","solution":"from collections import Counter import re def top_k_frequent_words(s, k): Identify the k most frequent words in the document. Args: s (str): the input string/document. k (int): the number of top frequent words to return. Returns: list: a list of the top k most frequent words. # Using regex to find all words words = re.findall(r'b[a-z]+b', s) # Count the frequency of each word word_count = Counter(words) # Sort words by frequency and then lexicographically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Get the top k frequent words top_k_words = [word for word, count in sorted_words[:k]] return top_k_words"},{"question":"from typing import List def maxProfit(startTime: List[int], endTime: List[int], profit: List[int], maxJobs: int) -> int: Return the maximum profit achieved by selecting at most \`maxJobs\` non-overlapping jobs. >>> maxProfit([1], [2], [50], 1) 50 >>> maxProfit([1, 2], [2, 3], [50, 100], 1) 100 >>> maxProfit([1, 2], [2, 3], [50, 60], 2) 110 >>> maxProfit([], [], [], 3) 0 >>> maxProfit([1, 3, 6, 2], [2, 5, 7, 8], [50, 100, 200, 150], 2) 300 >>> maxProfit([1, 2, 3, 3], [3, 4, 5, 6], [50, 10, 40, 70], 2) 120 >>> maxProfit([1, 2, 3, 3], [3, 4, 5, 6], [50, 10, 40, 70], 3) 120 >>> maxProfit([1, 2, 3, 3], [3, 4, 5, 6], [50, 10, 40, 70], 1) 70 >>> maxProfit([1, 3, 5], [2, 6, 7], [50, 10, 40], 2) 90","solution":"from typing import List from functools import lru_cache def maxProfit(startTime: List[int], endTime: List[int], profit: List[int], maxJobs: int) -> int: jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1]) @lru_cache(None) def dp(n: int, k: int) -> int: if k == 0 or n == 0: return 0 start, end, prof = jobs[n-1] idx = next((j for j in range(n-1, -1, -1) if jobs[j][1] <= start), -1) return max(dp(n-1, k), prof + dp(idx + 1, k - 1)) return dp(len(jobs), maxJobs)"},{"question":"def max_non_overlapping_substrings(s: str) -> int: Returns the maximum number of non-overlapping substrings such that each substring has an equal number of '0's and '1's. Examples: >>> max_non_overlapping_substrings(\\"010101\\") 3 >>> max_non_overlapping_substrings(\\"00110011\\") 2 >>> max_non_overlapping_substrings(\\"0000\\") 0 >>> max_non_overlapping_substrings(\\"1111\\") 0 >>> max_non_overlapping_substrings(\\"0011\\") 1 >>> max_non_overlapping_substrings(\\"1101001100\\") 2 >>> max_non_overlapping_substrings(\\"\\") 0 >>> max_non_overlapping_substrings(\\"01\\") 1 >>> max_non_overlapping_substrings(\\"10\\") 1","solution":"def max_non_overlapping_substrings(s): Returns the maximum number of non-overlapping substrings such that each substring has an equal number of '0's and '1's. count_0 = count_1 = 0 max_substrings = 0 for char in s: if char == '0': count_0 += 1 elif char == '1': count_1 += 1 if count_0 == count_1: max_substrings += 1 count_0 = count_1 = 0 return max_substrings"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minCameraCover(root: TreeNode) -> int: Determine the minimum number of cameras needed to monitor all nodes in the tree. >>> root = TreeNode(0) >>> root.left = TreeNode(0) >>> root.right = TreeNode(0) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(0) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(0) >>> minCameraCover(root) 2 >>> root = TreeNode(0) >>> root.left = TreeNode(0) >>> root.left.left = TreeNode(0) >>> root.left.left.left = TreeNode(0) >>> minCameraCover(root) 2 >>> root = TreeNode(0) >>> root.right = TreeNode(0) >>> root.right.right = TreeNode(0) >>> root.right.right.right = TreeNode(0) >>> minCameraCover(root) 2 >>> root = TreeNode(0) >>> root.left = TreeNode(0) >>> root.right = TreeNode(0) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(0) >>> root.left.left.right = TreeNode(0) >>> root.right.right = TreeNode(0) >>> root.right.right.left = TreeNode(0) >>> root.right.right.right = TreeNode(0) >>> minCameraCover(root) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minCameraCover(root: TreeNode) -> int: def dfs(node): if not node: return 0, 0, float('inf') la, lb, lc = dfs(node.left) ra, rb, rc = dfs(node.right) a = lb + rb b = min(lc + min(rb, rc), rc + min(lb, lc)) c = 1 + min(la, lb, lc) + min(ra, rb, rc) return a, b, c return min(dfs(root)[1:])"},{"question":"def array_strings_are_equal(word1: List[str], word2: List[str]) -> bool: Check if the concatenation of two string arrays are equivalent. >>> array_strings_are_equal([\\"ab\\", \\"c\\"], [\\"a\\", \\"bc\\"]) True >>> array_strings_are_equal([\\"ab\\", \\"c\\"], [\\"abc\\", \\"d\\"]) False >>> array_strings_are_equal([], [\\"\\"]) True >>> array_strings_are_equal([], [\\"a\\"]) False >>> array_strings_are_equal([\\"a\\", \\"bc\\"], [\\"abc\\"]) True >>> array_strings_are_equal([\\"\\"], [\\"\\"]) True >>> array_strings_are_equal([\\"a\\", \\"\\"], [\\"a\\"]) True >>> array_strings_are_equal([\\"a\\", \\"\\"], [\\"\\", \\"a\\"]) True >>> array_strings_are_equal([\\"hello\\"], [\\"world\\"]) False >>> array_strings_are_equal([\\"ab\\", \\"c\\"], [\\"a\\", \\"b\\", \\"c\\"]) True >>> array_strings_are_equal([\\"a\\", \\"bc\\"], [\\"ab\\", \\"c\\"]) True >>> array_strings_are_equal([\\"abc\\"], [\\"a\\", \\"b\\", \\"c\\"]) True","solution":"def array_strings_are_equal(word1, word2): Returns True if the concatenation of the words in word1 is equal to the concatenation of the words in word2. return ''.join(word1) == ''.join(word2)"},{"question":"def mergeSortedArrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: Merged sorted array. Examples: >>> mergeSortedArrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeSortedArrays([0, 1], [2, 3]) [0, 1, 2, 3]","solution":"def mergeSortedArrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: Merged sorted array. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def can_be_equal_with_one_swap(s1: str, s2: str) -> bool: Determines if s1 can be made equal to s2 with exactly one swap. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 can be made equal to s2 with exactly one swap, False otherwise. >>> can_be_equal_with_one_swap(\\"abcd\\", \\"abcd\\") False >>> can_be_equal_with_one_swap(\\"abcd\\", \\"abcf\\") False >>> can_be_equal_with_one_swap(\\"abdc\\", \\"abcd\\") True >>> can_be_equal_with_one_swap(\\"abcd\\", \\"abef\\") False >>> can_be_equal_with_one_swap(\\"abcde\\", \\"aedcb\\") False >>> can_be_equal_with_one_swap(\\"a\\", \\"b\\") False >>> can_be_equal_with_one_swap(\\"abcdefgh\\", \\"abcedfgh\\") True >>> can_be_equal_with_one_swap(\\"abcdefgh\\", \\"abcdffgh\\") False","solution":"def can_be_equal_with_one_swap(s1, s2): Determines if s1 can be made equal to s2 with exactly one swap. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 can be made equal to s2 with exactly one swap, False otherwise. if s1 == s2: return False # Find the indices with different characters diff_indices = [i for i in range(len(s1)) if s1[i] != s2[i]] # If there are not exactly two differences, return False if len(diff_indices) != 2: return False i, j = diff_indices # Check if swapping the differing characters in s1 makes it equal to s2 return s1[i] == s2[j] and s1[j] == s2[i]"},{"question":"from typing import List def splitArray(nums: List[int], m: int) -> int: Divide the list of n integers into m consecutive subarrays such that the sum of each subarray is balanced as possible. The goal is to minimize the difference between the sum of the largest subarray and the sum of the smallest subarray. >>> splitArray([7, 2, 5, 10, 8], 2) 18 >>> splitArray([1], 1) 1 >>> splitArray([5, 5, 5, 5], 2) 10 >>> splitArray([1, 2, 3, 1000], 2) 1000 >>> splitArray([1, 2, 3], 3) 3 >>> splitArray([2, 3, 5, 2, 5, 10, 1], 3) 11","solution":"def splitArray(nums, m): def can_split(nums, m, mid): count = 1 total = 0 for num in nums: total += num if total > mid: total = num count += 1 if count > m: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Returns whether the word exists in the given 2D grid. >>> exist([ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ], \\"ABCCED\\") == True >>> exist([ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ], \\"SEE\\") == True >>> exist([ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ], \\"ABCB\\") == False","solution":"def exist(board, word): Returns whether the word exists in the given 2D grid. if not board or not board[0] or not word: return False rows, cols = len(board), len(board[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[index]: return False temp, board[r][c] = board[r][c], '#' found = (dfs(r+1, c, index+1) or dfs(r-1, c, index+1) or dfs(r, c+1, index+1) or dfs(r, c-1, index+1)) board[r][c] = temp return found for i in range(rows): for j in range(cols): if board[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"def removeKdigits(s: str, k: int) -> str: Returns the minimum possible number by removing exactly k digits from the string s. >>> removeKdigits(\\"1432219\\", 3) == \\"1219\\" >>> removeKdigits(\\"10200\\", 1) == \\"200\\" >>> removeKdigits(\\"10\\", 2) == \\"0\\" >>> removeKdigits(\\"9\\", 1) == \\"0\\" >>> removeKdigits(\\"112\\", 1) == \\"11\\" >>> removeKdigits(\\"1111111\\", 3) == \\"1111\\" >>> removeKdigits(\\"1234567890\\", 9) == \\"0\\" >>> removeKdigits(\\"100001\\", 1) == \\"1\\" >>> removeKdigits(\\"1173\\", 2) == \\"11\\" >>> removeKdigits(\\"5337\\", 2) == \\"33\\"","solution":"def removeKdigits(s, k): Returns the minimum possible number by removing exactly k digits from the string s. stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If k is still greater than 0, remove the remaining digits from the end while k > 0: stack.pop() k -= 1 # Convert to string and remove leading zeros result = ''.join(stack).lstrip('0') return result if result else \\"0\\""},{"question":"def first_missing_positive(nums): Returns the smallest positive integer that does not exist in the given array. The algorithm runs in O(n) time and uses constant extra space. from solution import first_missing_positive def test_first_missing_positive_basic(): assert first_missing_positive([1, 2, 0]) == 3 assert first_missing_positive([3, 4, -1, 1]) == 2 assert first_missing_positive([7, 8, 9, 11, 12]) == 1 def test_first_missing_positive_with_missing_one(): assert first_missing_positive([2, 3, 4]) == 1 def test_first_missing_positive_all_one(): assert first_missing_positive([1, 1, 1, 1]) == 2 def test_first_missing_positive_single_element(): assert first_missing_positive([1]) == 2 assert first_missing_positive([2]) == 1 def test_first_missing_positive_no_missing(): assert first_missing_positive([1, 2, 3, 4, 5]) == 6 assert first_missing_positive([2, 3, 4, 5]) == 1","solution":"def first_missing_positive(nums): Returns the smallest positive integer that does not exist in the given array. The algorithm runs in O(n) time and uses constant extra space. n = len(nums) # Place each number in its right place for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first number not in the correct place for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def sum_except_largest(nums: List[int]) -> int: Returns the sum of all elements in the array except the largest one. If the array contains only one element, return 0. >>> sum_except_largest([5]) 0 >>> sum_except_largest([3, 3, 3]) 6 >>> sum_except_largest([1, 2, 3, 4]) 6 >>> sum_except_largest([-3, -2, -1]) -5 >>> sum_except_largest([-1, 0, 1, 2]) 0 >>> sum_except_largest(list(range(1000))) 498500","solution":"def sum_except_largest(nums): Returns the sum of all elements in the array except the largest one. If the array contains only one element, return 0. if len(nums) == 1: return 0 largest = max(nums) return sum(nums) - largest"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root): Returns the postorder traversal of a binary tree's nodes' values using an iterative approach. >>> root = TreeNode(1) >>> postorder_traversal(root) [1] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> postorder_traversal(root) [4, 5, 2, 6, 7, 3, 1] >>> root = TreeNode(1, TreeNode(2, TreeNode(3))) >>> postorder_traversal(root) [3, 2, 1] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> postorder_traversal(root) [3, 2, 1] >>> postorder_traversal(None) [] pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root): Returns the postorder traversal of a binary tree's nodes' values using an iterative approach. if not root: return [] stack, result = [root], [] while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1] # reverse the result to get correct postorder"},{"question":"def count_unique_pairs(arr, target_sum): Given an integer array \`arr\` and an integer \`sum\`, determine the number of unique pairs of elements in the array that add up to \`sum\`. A pair is considered unique if no elements are reused. >>> count_unique_pairs([1, 2, 3, 4], 5) 2 >>> count_unique_pairs([1, 2, 3, 4], 8) 0 >>> count_unique_pairs([1, 2, 3, 4, 3, 2, 1], 5) 2 >>> count_unique_pairs([-1, -2, -3, -4, 1, 2, 3, 4], 0) 4 >>> count_unique_pairs([1, 1, 1, 1], 2) 1 >>> count_unique_pairs([1000000, 2000000, -1000000, -2000000, 0], 0) 2","solution":"def count_unique_pairs(arr, target_sum): Returns the number of unique pairs of elements in the array that add up to target_sum. seen = set() pairs = set() for num in arr: complement = target_sum - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def middleNode(head: ListNode) -> ListNode: Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> middleNode(head).val 3 >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6)))))) >>> middleNode(head).val 4 from solution import ListNode, middleNode def test_middleNode_single_node(): head = ListNode(1) assert middleNode(head).val == 1 def test_middleNode_two_nodes(): head = ListNode(1) head.next = ListNode(2) assert middleNode(head).val == 2 # The second middle node def test_middleNode_odd_number_of_nodes(): head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) assert middleNode(head).val == 2 def test_middleNode_even_number_of_nodes(): head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) assert middleNode(head).val == 3 # The second middle node def test_middleNode_long_list(): head = ListNode(1) current = head for i in range(2, 11): # Creating a linked list of 10 nodes current.next = ListNode(i) current = current.next assert middleNode(head).val == 6 # The second middle node when list length is 10","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def middleNode(head: ListNode) -> ListNode: Returns the middle node of the linked list. If there are two middle nodes, return the second middle node. Uses the fast and slow pointer technique. slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Compute the maximum rectangular area that can be formed by choosing any subset of consecutive buildings. Args: heights (List[int]): List of integers representing the height of buildings. Returns: int: The area of the largest rectangle that can be formed. Examples: >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([4]) 4 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([4, 2, 0, 3, 2, 5]) 6 >>> largest_rectangle_area([3, 3, 3, 3, 3]) 15 pass","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed using consecutive buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of trapped rainwater given the elevation map. Parameters: height (list of int): A list of non-negative integers representing the elevation map. Returns: int: The total units of trapped water. Examples: >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([3, 3, 3, 3]) 0 >>> trap([0, 0, 0, 0]) 0","solution":"def trap(height): Calculate the total amount of trapped rainwater given the elevation map. Parameters: height (list of int): A list of non-negative integers representing the elevation map. Returns: int: The total units of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate total trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"def min_add_to_make_valid(s: str) -> int: Given a string s that represents a sequence of parentheses, return the minimum number of parentheses that need to be added to make the string valid. A string is a valid parenthesis string if it consists of: - An empty string - A string written as AB (where A and B are valid strings) - A string written as (A) (where A is a valid string) Examples: >>> min_add_to_make_valid(\\"\\") 0 >>> min_add_to_make_valid(\\"()\\") 0 >>> min_add_to_make_valid(\\"(())\\") 0 >>> min_add_to_make_valid(\\"()()\\") 0 >>> min_add_to_make_valid(\\"(\\") 1 >>> min_add_to_make_valid(\\"(((\\") 3 >>> min_add_to_make_valid(\\")\\") 1 >>> min_add_to_make_valid(\\")))\\") 3 >>> min_add_to_make_valid(\\"(()\\") 1 >>> min_add_to_make_valid(\\"())\\") 1 >>> min_add_to_make_valid(\\"(()())(\\") 1 >>> min_add_to_make_valid(\\"())(()\\") 2","solution":"def min_add_to_make_valid(s): Returns the minimum number of parentheses that need to be added to make 's' a valid parenthesis string. left_unbalanced = 0 right_unbalanced = 0 for char in s: if char == '(': left_unbalanced += 1 elif char == ')': if left_unbalanced > 0: left_unbalanced -= 1 else: right_unbalanced += 1 return left_unbalanced + right_unbalanced"},{"question":"def isValidParentheses(s: str) -> bool: Checks if the given string is a valid parentheses string. Args: s: A string consisting only of characters '(' and ')'. Returns: bool: True if the input string is valid, otherwise False. Examples: >>> isValidParentheses(\\"\\") True >>> isValidParentheses(\\"()\\") True >>> isValidParentheses(\\"(())\\") True >>> isValidParentheses(\\"()()\\") True >>> isValidParentheses(\\"(()\\") False >>> isValidParentheses(\\"())\\") False >>> isValidParentheses(\\"(()())\\") True >>> isValidParentheses(\\")()(\\") False >>> isValidParentheses(\\"(((())))\\") True >>> isValidParentheses(\\"(()()()(()))\\") True >>> isValidParentheses(\\"(()()()))(()\\") False","solution":"def isValidParentheses(s: str) -> bool: Checks if the given string is a valid parentheses string. Args: s: A string consisting only of characters '(' and ')'. Returns: bool: True if the input string is valid, otherwise False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"from typing import List def uniquePathsWithObstacles(grid: List[List[int]]) -> int: Returns the number of possible unique paths for a robot to reach the bottom-right corner of the grid from the top-left corner. The robot can only move down or right at any point in time. \`1\` denotes an obstacle, and \`0\` denotes a free cell. >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 6 >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> uniquePathsWithObstacles([ ... [0, 1], ... [1, 0] ... ]) == 0 >>> uniquePathsWithObstacles([ ... [1] ... ]) == 0 >>> uniquePathsWithObstacles([ ... [0] ... ]) == 1 >>> uniquePathsWithObstacles([ ... [1, 0], ... [0, 0] ... ]) == 0 >>> uniquePathsWithObstacles([ ... [0, 0], ... [0, 1] ... ]) == 0 pass","solution":"def uniquePathsWithObstacles(grid): m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"class HotelBookingSystem: A class to manage hotel room bookings. Attributes: room_bookings (dict): A dictionary mapping room IDs to their booked times. def __init__(self, numberOfRooms): Initializes the HotelBookingSystem with the specified number of rooms. Args: numberOfRooms (int): The number of rooms in the hotel. pass def book(self, room_id, start_time, end_time): Books the room with the specified room_id from start_time to end_time. Args: room_id (int): The ID of the room to be booked. start_time (int): The start time of the booking. end_time (int): The end time of the booking. Returns: bool: True if the booking is successful, False otherwise. pass def cancel(self, room_id, start_time, end_time): Cancels the booking of the room with the specified room_id from start_time to end_time. Args: room_id (int): The ID of the room booking to be cancelled. start_time (int): The start time of the booking to be cancelled. end_time (int): The end time of the booking to be cancelled. pass def getAvailableRooms(self, start_time, end_time): Returns a list of room_ids that are available for booking from start_time to end_time. Args: start_time (int): The start time of the desired booking period. end_time (int): The end time of the desired booking period. Returns: List[int]: A list of room_ids that are available for the specified period. pass # Unit tests def test_initial_state(): system = HotelBookingSystem(3) assert len(system.getAvailableRooms(0, 24)) == 3 def test_successful_booking(): system = HotelBookingSystem(2) assert system.book(0, 10, 12) assert len(system.getAvailableRooms(10, 12)) == 1 def test_failed_booking_due_to_overlap(): system = HotelBookingSystem(1) assert system.book(0, 10, 12) assert not system.book(0, 11, 13) assert len(system.getAvailableRooms(11, 13)) == 0 def test_cancel_booking(): system = HotelBookingSystem(1) system.book(0, 10, 12) system.cancel(0, 10, 12) assert len(system.getAvailableRooms(10, 12)) == 1 def test_get_available_rooms_no_overlap(): system = HotelBookingSystem(2) system.book(0, 10, 12) system.book(1, 12, 14) available_rooms = system.getAvailableRooms(10, 12) assert available_rooms == [1] def test_get_available_rooms_no_rooms(): system = HotelBookingSystem(1) system.book(0, 10, 12) available_rooms = system.getAvailableRooms(10, 12) assert available_rooms == [] def test_edge_times(): system = HotelBookingSystem(1) assert system.book(0, 23, 24) assert system.book(0, 0, 1) available_rooms = system.getAvailableRooms(23, 24) assert available_rooms == []","solution":"class HotelBookingSystem: def __init__(self, numberOfRooms): Initializes the HotelBookingSystem with the specified number of rooms. Each room's booking schedule is stored in a dictionary with room_id as key and list of booked times as value. self.room_bookings = {i: [] for i in range(numberOfRooms)} def book(self, room_id, start_time, end_time): Books the room with the specified room_id from start_time to end_time. Args: room_id (int): The ID of the room to be booked. start_time (int): The start time of the booking. end_time (int): The end time of the booking. Returns: bool: True if the booking is successful, False otherwise. for (start, end) in self.room_bookings[room_id]: if start_time < end and end_time > start: # Overlaps with existing booking return False # No overlap, safe to book self.room_bookings[room_id].append((start_time, end_time)) return True def cancel(self, room_id, start_time, end_time): Cancels the booking of the room with the specified room_id from start_time to end_time. Args: room_id (int): The ID of the room booking to be cancelled. start_time (int): The start time of the booking to be cancelled. end_time (int): The end time of the booking to be cancelled. if (start_time, end_time) in self.room_bookings[room_id]: self.room_bookings[room_id].remove((start_time, end_time)) def getAvailableRooms(self, start_time, end_time): Returns a list of room_ids that are available for booking from start_time to end_time. Args: start_time (int): The start time of the desired booking period. end_time (int): The end time of the desired booking period. Returns: List[int]: A list of room_ids that are available for the specified period. available_rooms = [] for room_id, bookings in self.room_bookings.items(): if all(start_time >= end or end_time <= start for start, end in bookings): available_rooms.append(room_id) return available_rooms"},{"question":"def smallestString(s: str, pairs: List[List[int]]) -> str: Returns the lexicographically smallest string that can be obtained by performing swaps allowed by pairs. :param s: str - The input string consisting of lowercase English letters. :param pairs: List[List[int]] - List of pairs of indices in the string where swaps can be performed. :return: str - The lexicographically smallest string after performing swaps. >>> smallestString(\\"dcab\\", [[0, 3], [1, 2]]) == \\"bacd\\" >>> smallestString(\\"dcab\\", [[0, 1]]) == \\"cdab\\" >>> smallestString(\\"dcab\\", [[0, 3], [1, 2], [0, 2]]) == \\"abcd\\" >>> smallestString(\\"abdc\\", []) == \\"abdc\\" >>> smallestString(\\"cba\\", [[0, 1], [1, 2]]) == \\"abc\\" >>> smallestString(\\"edcba\\", [[0, 1], [1, 2], [2, 3], [3, 4]]) == \\"abcde\\"","solution":"def smallestString(s, pairs): Returns the lexicographically smallest string that can be obtained by performing swaps allowed by pairs. :param s: str - The input string :param pairs: List[List[int]] - List of pairs of indices in the string where swaps can be performed :return: str - The lexicographically smallest string after performing swaps import collections # Union-Find (Disjoint Set Union) Helper Functions def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX n = len(s) parent = list(range(n)) # Perform union operations for each pair for a, b in pairs: union(a, b) # Group all characters by their connected component components = collections.defaultdict(list) for i in range(n): root = find(i) components[root].append(i) # For each component, sort the indices and corresponding characters sorted_s = list(s) for indices in components.values(): sorted_chars = sorted(s[i] for i in indices) for i, char in zip(sorted(indices), sorted_chars): sorted_s[i] = char return ''.join(sorted_s)"},{"question":"def distribute_cookies(cookies, children): Distribute cookies to children to achieve minimum unfairness. :param cookies: List of integers representing number of cookies in each jar :param children: Integer representing number of children :return: Integer, minimum possible unfairness or specific edge case values Examples: >>> distribute_cookies([], 3) -1 >>> distribute_cookies([1, 2], 3) 0 >>> distribute_cookies([3, 3, 3, 3], 4) 0 >>> distribute_cookies([7, 4, 9, 2, 5], 3) 3 >>> distribute_cookies([10], 1) 0 >>> distribute_cookies([10, 22, 15, 8], 2) 2","solution":"def distribute_cookies(cookies, children): Distribute cookies to children to achieve minimum unfairness. :param cookies: List of integers representing number of cookies in each jar :param children: Integer representing number of children :return: Integer, minimum possible unfairness or specific edge case values if not cookies: return -1 if children > len(cookies): return 0 cookies.sort() # sort the jars by number of cookies min_unfairness = float('inf') for i in range(len(cookies) - children + 1): unfairness = cookies[i + children - 1] - cookies[i] min_unfairness = min(min_unfairness, unfairness) return min_unfairness"},{"question":"from typing import List def shortest_transformation_length(s: str, wordList: List[str]) -> int: Returns the length of the shortest transformation sequence from s to a word in wordList. If no transformation sequence exists, return 0. Args: s (str): The starting string. wordList (List[str]): The list of words to transform into. Returns: int: The length of the shortest transformation sequence. Examples: >>> shortest_transformation_length(\\"hit\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 2 >>> shortest_transformation_length(\\"hit\\", [\\"dog\\", \\"cog\\", \\"log\\"]) 0 >>> shortest_transformation_length(\\"start\\", [\\"stark\\", \\"stack\\", \\"slack\\", \\"black\\", \\"blank\\", \\"flank\\", \\"flame\\"]) 2","solution":"from collections import deque def shortest_transformation_length(s, wordList): Returns the length of the shortest transformation sequence from s to a word in wordList. If no transformation sequence exists, returns 0. wordSet = set(wordList) if not wordSet or s in wordSet: return 0 queue = deque([(s, 1)]) # (current_word, current_sequence_length) while queue: current_word, current_length = queue.popleft() for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': if c != current_word[i]: next_word = current_word[:i] + c + current_word[i + 1:] if next_word in wordSet: return current_length + 1 if next_word not in wordSet: continue queue.append((next_word, current_length + 1)) wordSet.remove(next_word) return 0"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Returns True if there are two numbers in the list that add up to target, otherwise returns False. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 5) False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([-1, 2, 4, -5, 8], 3) True","solution":"def has_pair_with_sum(arr, target): Returns True if there are two numbers in arr that add up to target, otherwise False. seen_numbers = set() for number in arr: complement = target - number if complement in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"def max_visible_buildings(heights: List[int]) -> int: Given a list of integers representing the heights of a series of buildings standing in a row, return the maximum number of buildings you can see looking from left to right. A building is visible if there are no taller buildings in between. >>> max_visible_buildings([2, 4, 3, 1, 5]) 3 >>> max_visible_buildings([1, 2, 3, 4, 5]) 5","solution":"def max_visible_buildings(heights): Returns the maximum number of buildings visible from left to right. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The maximum number of buildings visible from left to right. max_height = 0 visible_count = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"from typing import List def min_moves(nums: List[int]) -> int: Given a list of integers \`nums\`, return an integer representing the minimum number of moves required to make all elements equal. In each move, you can increment \`n-1\` elements by 1 (where \`n\` is the length of the list). >>> min_moves([1, 1, 1]) 0 >>> min_moves([5, 5, 5, 5, 5]) 0 >>> min_moves([1, 2, 3]) 3 >>> min_moves([1, 1000]) 999 >>> min_moves([3, 3, 3, 10, 10]) 14 >>> min_moves([42]) 0 >>> min_moves([1]*1000) 0 >>> min_moves([i for i in range(1000)]) 499500","solution":"def min_moves(nums): Returns the minimum number of moves required to make all list elements equal. In one move, you can increment n-1 elements by 1. min_num = min(nums) return sum(num - min_num for num in nums)"},{"question":"from typing import List def num_special_subarrays(arr: List[int], k: int) -> int: Returns the number of special subarrays where the product of all the elements is less than \`k\`. >>> num_special_subarrays([10, 5, 2, 6], 100) 8 >>> num_special_subarrays([1, 2, 3, 4], 10) 7 >>> num_special_subarrays([10, 5, 2, 6], 1) 0 >>> num_special_subarrays([10, 11, 12], 2) 0","solution":"def num_special_subarrays(arr, k): Returns the number of special subarrays where the product of all the elements is less than \`k\`. if k <= 1: return 0 product = 1 result = 0 left = 0 for right, value in enumerate(arr): product *= value while product >= k: product //= arr[left] left += 1 result += right - left + 1 return result"},{"question":"from datetime import datetime, timedelta from typing import List def detect_fraudulent_shipments(shipmentID: List[str], shipmentTime: List[str]) -> List[str]: Detect possible fraudulent activities based on shipment IDs appearing two or more times within a two-hour window. Parameters: shipmentID (List[str]): List of shipment IDs. shipmentTime (List[str]): List of shipment times in \\"HH:MM\\" format. Returns: List[str]: Sorted list of unique shipment IDs flagged for potential fraud. pass # Example test cases def test_no_fraudulent_activity(): assert detect_fraudulent_shipments( [\\"abc123\\", \\"def456\\", \\"ghi789\\"], [\\"10:00\\", \\"12:00\\", \\"14:00\\"] ) == [] def test_single_fraudulent_id(): assert detect_fraudulent_shipments( [\\"abc123\\", \\"def456\\", \\"abc123\\"], [\\"10:00\\", \\"12:00\\", \\"11:00\\"] ) == [\\"abc123\\"] def test_multiple_fraudulent_ids(): assert detect_fraudulent_shipments( [\\"abc123\\", \\"def456\\", \\"abc123\\", \\"def456\\"], [\\"10:00\\", \\"11:59\\", \\"12:00\\", \\"13:00\\"] ) == [\\"abc123\\", \\"def456\\"] def test_fraudulent_and_non_fraudulent(): assert detect_fraudulent_shipments( [\\"abc123\\", \\"def456\\", \\"ghi789\\", \\"abc123\\", \\"def456\\"], [\\"10:00\\", \\"11:59\\", \\"13:30\\", \\"12:00\\", \\"14:00\\"] ) == [\\"abc123\\"] def test_fraudulent_id_outside_two_hour_window(): assert detect_fraudulent_shipments( [\\"abc123\\", \\"def456\\", \\"abc123\\"], [\\"10:00\\", \\"12:00\\", \\"13:01\\"] ) == []","solution":"from datetime import datetime, timedelta from collections import defaultdict def detect_fraudulent_shipments(shipmentID, shipmentTime): Detect possible fraudulent activities based on shipment IDs appearing two or more times within a two-hour window. Parameters: shipmentID (List[str]): List of shipment IDs. shipmentTime (List[str]): List of shipment times in \\"HH:MM\\" format. Returns: List[str]: Sorted list of unique shipment IDs flagged for potential fraud. log = defaultdict(list) fraudulent_ids = set() # Convert shipment times to datetime objects for easy comparison shipment_times = [datetime.strptime(time, \\"%H:%M\\") for time in shipmentTime] for i in range(len(shipmentID)): current_id = shipmentID[i] current_time = shipment_times[i] if current_id in log: for previous_time in log[current_id]: # Check if time difference is within 2 hours if abs(current_time - previous_time) <= timedelta(hours=2): fraudulent_ids.add(current_id) break log[current_id].append(current_time) return sorted(list(fraudulent_ids))"},{"question":"def count_subsequences(words: List[str], s: str) -> int: You are given a list of strings \`words\` and a string \`s\`. Each string in \`words\` represents a pattern of dots and dashes (\`.\` and \`-\` respectively), and the string \`s\` contains only dots and dashes as well. The task is to find how many of the strings in \`words\` can be formed as subsequences of the string \`s\`. A subsequence of a string is obtained by deleting some (or none) of the characters without disturbing the relative positions of the remaining characters. Return the number of \`words\` from the list that can be formed as subsequences of the string \`s\`. >>> count_subsequences([\\"..\\", \\".\\", \\"-.\\"], \\"..-.\\") 3 >>> count_subsequences([\\"..-\\", \\"--.\\"], \\"..\\") 0 >>> count_subsequences([\\".\\", \\".\\", \\".\\", \\".\\"], \\"....\\") 4 >>> count_subsequences([\\".\\", \\"-\\"], \\".\\") 1 >>> count_subsequences([\\"..\\", \\".-\\", \\"-.\\"], \\"...-.\\") 3","solution":"def is_subsequence(pattern, s): Helper function to check if a pattern is a subsequence of string \`s\`. it = iter(s) return all(char in it for char in pattern) def count_subsequences(words, s): Returns the count of words that are subsequences of string \`s\`. count = 0 for word in words: if is_subsequence(word, s): count += 1 return count"},{"question":"def max_possible_height(heights: List[int], k: int) -> int: Returns the maximum possible height for the new building. >>> max_possible_height([5, 7, 9], 2) 11 >>> max_possible_height([1, 3, 5], 1) 6 >>> max_possible_height([2, 2, 2], 3) 5 >>> max_possible_height([10, 20, 30, 40], 5) 45 >>> max_possible_height([8, 14], 4) 18","solution":"def max_possible_height(heights, k): Returns the maximum possible height for the new building. max_height = float('-inf') for i in range(1, len(heights)): max_height = max(max_height, heights[i-1] + k, heights[i] + k) return max_height"},{"question":"from typing import List def move_all_x_to_end(arr: List[int], x: int) -> List[int]: Moves all occurrences of \`x\` to the end of the array \`arr\` while maintaining the relative order of the other elements. :param arr: List of integers :param x: Integer to move to the end :return: Modified array with all \`x\` moved to the end >>> move_all_x_to_end([1, 2, 3, 4, 5, 3, 3], 3) == [1, 2, 4, 5, 3, 3, 3] >>> move_all_x_to_end([1, 2, 3, 3, 5, 1, 4], 1) == [2, 3, 3, 5, 4, 1, 1] >>> move_all_x_to_end([1, 1, 1, 1, 1], 1) == [1, 1, 1, 1, 1] >>> move_all_x_to_end([5, 4, 3, 2, 1], 6) == [5, 4, 3, 2, 1] >>> move_all_x_to_end([], 1) == [] >>> move_all_x_to_end([4, 5, 6, 4, 4, 4, 3, 4], 4) == [5, 6, 3, 4, 4, 4, 4, 4] >>> move_all_x_to_end([2, 2, 2, 2, 2, 2], 2) == [2, 2, 2, 2, 2, 2]","solution":"def move_all_x_to_end(arr, x): Moves all occurrences of \`x\` to the end of the array \`arr\` while maintaining the relative order of the other elements. :param arr: List of integers :param x: Integer to move to the end :return: Modified array with all \`x\` moved to the end result = [element for element in arr if element != x] count_x = arr.count(x) result.extend([x] * count_x) return result"},{"question":"from typing import List def maxAreaUnderModifiedHistogram(heights: List[int]) -> int: You are given a 0-indexed integer array heights of length n representing the heights of columns in a histogram. Each column's width is 1. Find the largest rectangle that can be formed under the histogram. You can choose to either: - Leave the array unchanged - Modify heights of at most one column to any positive integer value, including making it 0 Return the maximum area of the largest rectangle that can be formed after changing at most one column's height. >>> maxAreaUnderModifiedHistogram([2, 1, 5, 6, 2, 3]) 10 >>> maxAreaUnderModifiedHistogram([2, 4]) 4 >>> maxAreaUnderModifiedHistogram([2, 1, 2]) 3 >>> maxAreaUnderModifiedHistogram([1, 2, 3, 4, 5]) 9 >>> maxAreaUnderModifiedHistogram([5, 4, 3, 2, 1]) 9","solution":"def largestRectangleArea(heights): Returns the maximum area of the largest rectangle in the histogram. stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) heights.pop() # Restore the list return max_area def maxAreaUnderModifiedHistogram(heights): Returns the maximum rectangle area that can be obtained by changing at most one column's height. # Calculate the max area without any modification original_max_area = largestRectangleArea(heights) # Get all the original heights original_heights = heights[:] # Try changing each column to zero and calculate the potential new maximum area modified_max_area = 0 for i in range(len(heights)): original_height = heights[i] # Set the height to zero and calculate the largest rectangle area heights[i] = 0 modified_max_area = max(modified_max_area, largestRectangleArea(heights)) # Restore the original height heights[i] = original_height return max(original_max_area, modified_max_area)"},{"question":"from typing import List def findAllAnagrams(s: str, p: str) -> List[int]: Finds all start indices of p's anagrams in s. >>> findAllAnagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> findAllAnagrams(\\"abcdefg\\", \\"hij\\") [] >>> findAllAnagrams(\\"aaaaaaaaaa\\", \\"a\\") [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> findAllAnagrams(\\"abc\\", \\"cab\\") [0] >>> findAllAnagrams(\\"\\", \\"a\\") [] >>> findAllAnagrams(\\"a\\", \\"ab\\") []","solution":"from collections import Counter from typing import List def findAllAnagrams(s: str, p: str) -> List[int]: Finds all start indices of p's anagrams in s. result = [] len_s, len_p = len(s), len(p) if len_s < len_p: return result # Create frequency counter for pattern p p_counter = Counter(p) # Initial window counter for the first window in s with the same length as p window_counter = Counter(s[:len_p]) if p_counter == window_counter: result.append(0) # Sliding window for i in range(len_p, len_s): # Include next character into the window window_counter[s[i]] += 1 # Exclude the oldest character from the window window_counter[s[i - len_p]] -= 1 # Remove the count from the counter if it turns to zero if window_counter[s[i - len_p]] == 0: del window_counter[s[i - len_p]] # Check if current window_counter matches p_counter if p_counter == window_counter: result.append(i - len_p + 1) return result"},{"question":"def max_non_overlapping_meetings(start, end): Returns the maximum number of non-overlapping meetings that can be scheduled. :param start: List of integers, start times of the meetings :param end: List of integers, end times of the meetings :return: Integer, maximum number of non-overlapping meetings >>> max_non_overlapping_meetings([], []) == 0 >>> max_non_overlapping_meetings([1], [2]) == 1 >>> max_non_overlapping_meetings([1, 3], [2, 4]) == 2 >>> max_non_overlapping_meetings([1, 2, 3], [2, 4, 5]) == 2 >>> max_non_overlapping_meetings([1, 1, 1], [2, 2, 2]) == 1 >>> max_non_overlapping_meetings([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == 4","solution":"def max_non_overlapping_meetings(start, end): Returns the maximum number of non-overlapping meetings that can be scheduled. :param start: List of integers, start times of the meetings :param end: List of integers, end times of the meetings :return: Integer, maximum number of non-overlapping meetings n = len(start) if n == 0: return 0 # Create pairs of (end[i], start[i]) meetings = list(zip(end, start)) # Sort the meetings by their end times meetings.sort() # The count of non-overlapping meetings and the end time of the last selected meeting count = 0 last_end_time = float('-inf') for meeting in meetings: end_time, start_time = meeting if start_time >= last_end_time: count += 1 last_end_time = end_time return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Determines if the linked list has a cycle. :param head: ListNode, the head of the linked list :return: bool, True if the list has a cycle, otherwise False >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node1.next = node2 >>> node2.next = node3 >>> hasCycle(node1) False >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node1 >>> hasCycle(node1) True >>> node1 = ListNode(1) >>> hasCycle(node1) False >>> node1 = ListNode(1) >>> node1.next = node1 >>> hasCycle(node1) True >>> hasCycle(None) False","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Determines if the linked list has a cycle. :param head: ListNode, the head of the linked list :return: bool, True if the list has a cycle, otherwise False if not head: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def buildings_with_ocean_view(heights: List[int]) -> List[int]: Returns an array of indices representing the buildings that can see the ocean. >>> buildings_with_ocean_view([]) [] >>> buildings_with_ocean_view([5]) [0] >>> buildings_with_ocean_view([1, 2, 3, 4, 5]) [4] >>> buildings_with_ocean_view([5, 4, 3, 2, 1]) [0, 1, 2, 3, 4] >>> buildings_with_ocean_view([4, 2, 3, 1]) [0, 2, 3] >>> buildings_with_ocean_view([3, 3, 3]) [2]","solution":"def buildings_with_ocean_view(heights): Returns an array of indices representing the buildings that can see the ocean. if not heights: return [] n = len(heights) result = [] max_height = float('-inf') for i in reversed(range(n)): if heights[i] > max_height: result.append(i) max_height = heights[i] return sorted(result)"},{"question":"def remove_duplicates(s: str) -> str: Remove adjacent duplicates in the string \`s\`. Each duplicate removal operation selects two adjacent and equal letters and removes them. The process is repeated until no adjacent equal letters remain. >>> remove_duplicates(\\"abc\\") == \\"abc\\" >>> remove_duplicates(\\"aabbcc\\") == \\"\\" >>> remove_duplicates(\\"abbaca\\") == \\"ca\\" >>> remove_duplicates(\\"abccba\\") == \\"\\" >>> remove_duplicates(\\"a\\") == \\"a\\" >>> remove_duplicates(\\"\\") == \\"\\"","solution":"def remove_duplicates(s): Function to remove adjacent duplicates in the string \`s\`. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def can_sort_linked_list(head) -> bool: Determine if a linked list can be sorted in non-decreasing order by reversing sublists that start and end with odd values. >>> node3 = ListNode(3) >>> node2 = ListNode(2, node3) >>> node1 = ListNode(1, node2) >>> can_sort_linked_list(node1) True >>> node3 = ListNode(1) >>> node2 = ListNode(3, node3) >>> node1 = ListNode(2, node2) >>> can_sort_linked_list(node1) False >>> node3 = ListNode(4) >>> node2 = ListNode(2, node3) >>> node1 = ListNode(2, node2) >>> can_sort_linked_list(node1) True >>> node3 = ListNode(2) >>> node2 = ListNode(4, node3) >>> node1 = ListNode(3, node2) >>> can_sort_linked_list(node1) False >>> can_sort_linked_list(None) True","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def can_sort_linked_list(head): if not head: return True values = [] current = head while current: values.append(current.value) current = current.next sorted_values = sorted(values) return sorted_values == values or all(v % 2 == 0 for v in values)"},{"question":"def count_substrings_same_start_end(s: str) -> int: Returns the number of substrings that start and end with the same character. Parameters: s (str): The input string consisting of only lowercase English letters. Returns: int: The number of substrings that start and end with the same character. Examples: >>> count_substrings_same_start_end(\\"a\\") 1 >>> count_substrings_same_start_end(\\"abc\\") 3 >>> count_substrings_same_start_end(\\"aa\\") 3 >>> count_substrings_same_start_end(\\"ababa\\") 9 >>> count_substrings_same_start_end(\\"abcdef\\") 6 >>> count_substrings_same_start_end(\\"aaaa\\") 10","solution":"def count_substrings_same_start_end(s): Returns the number of substrings that start and end with the same character. Parameters: s (str): The input string consisting of only lowercase English letters. Returns: int: The number of substrings that start and end with the same character. # Dictionary to count occurrences of each character count_dict = {} # Fill the dictionary with the frequency of each character in s for char in s: if char not in count_dict: count_dict[char] = 0 count_dict[char] += 1 # Calculate the number of substrings that start and end with the same character # For each character with frequency \`f\`, number of such substrings is f * (f + 1) // 2 result = 0 for char in count_dict: f = count_dict[char] result += (f * (f + 1)) // 2 return result"},{"question":"def has_permutation_of_first_k_naturals(arr, k): Determines if there exists a subarray of length k that is a permutation of the first k natural numbers. :param arr: List of integers :param k: Integer representing the length and the first k natural numbers :return: Boolean, True if such subarray exists, False otherwise >>> has_permutation_of_first_k_naturals([1, 2, 3, 4, 5], 3) == True >>> has_permutation_of_first_k_naturals([1, 2, 4, 5, 6], 3) == False >>> has_permutation_of_first_k_naturals([1, 2, 3], 3) == True >>> has_permutation_of_first_k_naturals([1, 2, 3, 6, 7, 8], 3) == True >>> has_permutation_of_first_k_naturals([1, 2], 3) == False >>> has_permutation_of_first_k_naturals([], 1) == False >>> has_permutation_of_first_k_naturals([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == True >>> has_permutation_of_first_k_naturals([3, 1, 2, 5, 4], 3) == True","solution":"def has_permutation_of_first_k_naturals(arr, k): Determines if there exists a subarray of length k that is a permutation of the first k natural numbers. :param arr: List of integers :param k: Integer representing the length and the first k natural numbers :return: Boolean, True if such subarray exists, False otherwise from collections import Counter if k > len(arr): return False target_counter = Counter(range(1, k + 1)) for i in range(len(arr) - k + 1): subarray = arr[i:i + k] if Counter(subarray) == target_counter: return True return False"},{"question":"def min_time_to_finish_tasks(task_times: List[int]) -> int: Returns the minimum amount of time required to finish all tasks with unlimited workers. :param task_times: List of non-negative integers representing task times. :return: Minimum time required to complete all tasks. >>> min_time_to_finish_tasks([5]) 5 >>> min_time_to_finish_tasks([]) 0 >>> min_time_to_finish_tasks([1, 2, 3, 4, 5]) 5 >>> min_time_to_finish_tasks([10, 20, 30]) 30 >>> min_time_to_finish_tasks([5, 5, 5, 5, 5]) 5 >>> min_time_to_finish_tasks([2, 8, 3, 5, 7]) 8","solution":"def min_time_to_finish_tasks(task_times): Returns the minimum amount of time required to finish all tasks with unlimited workers. :param task_times: List of non-negative integers representing task times. :return: Minimum time required to complete all tasks. if not task_times: return 0 return max(task_times)"},{"question":"def shortest_palindrome(s: str) -> str: Given a string \`s\`, construct and return the shortest palindrome that you can form by adding characters in front of \`s\`. >>> shortest_palindrome(\\"aacecaaa\\") \\"aaacecaaa\\" >>> shortest_palindrome(\\"abcd\\") \\"dcbabcd\\" >>> shortest_palindrome(\\"a\\") \\"a\\" >>> shortest_palindrome(\\"racecar\\") \\"racecar\\" >>> shortest_palindrome(\\"xyz\\") \\"zyxyz\\"","solution":"def shortest_palindrome(s): Returns the shortest palindrome that can be formed by adding characters to the front of s. if not s: return s reverse_s = s[::-1] # Create a new string which is s + \\"#\\" + reversed s new_s = s + \\"#\\" + reverse_s # Create a temporary array for the KMP algorithm kmp_table = [0] * len(new_s) # KMP preprocessing to fill KMP table for i in range(1, len(new_s)): j = kmp_table[i - 1] while j > 0 and new_s[i] != new_s[j]: j = kmp_table[j - 1] if new_s[i] == new_s[j]: j += 1 kmp_table[i] = j # The length of the longest palindromic suffix longest_palindromic_suffix_length = kmp_table[-1] # Characters needed to be added in front to make the palindrome appended_part = reverse_s[:len(s) - longest_palindromic_suffix_length] return appended_part + s"},{"question":"from typing import List def maximalRectangle(mat: List[List[int]]) -> int: Given an m x n binary matrix 'mat', return the largest rectangle containing only 1's and its area. The function should efficiently handle a potentially large size of the matrix. >>> maximalRectangle([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]) == 6 >>> maximalRectangle([]) == 0 >>> maximalRectangle([ [0, 0, 0], [0, 0, 0], ]) == 0 >>> maximalRectangle([ [1, 1], [1, 1], ]) == 4 >>> maximalRectangle([ [1, 0, 1, 1, 1], ]) == 3 >>> maximalRectangle([ [1], [1], [0], [1], ]) == 2","solution":"def maximalRectangle(mat): if not mat: return 0 max_area = 0 n = len(mat[0]) heights = [0] * n for row in mat: for i in range(n): if row[i] == 0: heights[i] = 0 else: heights[i] += 1 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): heights.append(0) stack = [-1] max_area = 0 for i in range(len(heights)): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxZigZag(root: TreeNode) -> int: Find the length of the longest ZigZag path in the binary tree where each node alternates between left and right. >>> root = TreeNode(1) >>> maxZigZag(root) 0 >>> root = TreeNode(1, TreeNode(2), None) >>> maxZigZag(root) 1 >>> root = TreeNode(1, None, TreeNode(2)) >>> maxZigZag(root) 1 >>> root = TreeNode(1, TreeNode(2, None, TreeNode(3)), None) >>> maxZigZag(root) 2 >>> root = TreeNode(1, None, TreeNode(2, TreeNode(3), None)) >>> maxZigZag(root) 2 >>> root = TreeNode(1, TreeNode(2, None, TreeNode(4, TreeNode(5), None)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> maxZigZag(root) 3 >>> root = TreeNode(1, TreeNode(2, None, TreeNode(3, TreeNode(4, None, TreeNode(5)), None)), None) >>> maxZigZag(root) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxZigZag(root): def dfs(node, direction, length): nonlocal max_length if not node: return max_length = max(max_length, length) if direction == 'left': dfs(node.left, 'right', length + 1) dfs(node.right, 'left', 1) else: dfs(node.right, 'left', length + 1) dfs(node.left, 'right', 1) max_length = 0 dfs(root, 'left', 0) dfs(root, 'right', 0) return max_length"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid with m rows and n columns. >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(3, 2) 3 >>> unique_paths(4, 4) 20 >>> unique_paths(1, 10) 1 >>> unique_paths(10, 1) 1 >>> unique_paths(10, 10) 48620 >>> unique_paths(15, 15) 40116600","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid with m rows and n columns. # Create a 2D array to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # Initialize the first row and first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def min_operations_to_make_unique(s: str) -> int: Returns the minimum number of operations needed to make all characters in the string unique. :param s: The input string consisting of lowercase English letters :type s: str :return: The minimum number of operations needed :rtype: int >>> min_operations_to_make_unique(\\"abcdefghijklmnopqrstuvwxyz\\") 0 >>> min_operations_to_make_unique(\\"aaaa\\") 3 >>> min_operations_to_make_unique(\\"aabbcc\\") 3 >>> min_operations_to_make_unique(\\"abc\\") 0 >>> min_operations_to_make_unique(\\"a\\") 0 >>> min_operations_to_make_unique(\\"abcdeabcdeabcdeabcde\\") 15","solution":"def min_operations_to_make_unique(s): Returns the minimum number of operations needed to make all characters in the string unique. :param s: The input string consisting of lowercase English letters :type s: str :return: The minimum number of operations needed :rtype: int from collections import Counter char_count = Counter(s) operations = 0 for count in char_count.values(): if count > 1: operations += count - 1 return operations"},{"question":"class ListNode: def __init__(self, x=0, next=None): self.val = x self.next = next def splitListToParts(head, k): Split the linked list into k consecutive linked list parts. >>> linked_list = list_to_linkedlist([1, 2, 3, 4, 5]) >>> parts = splitListToParts(linked_list, 3) >>> result = [linkedlist_to_list(part) for part in parts] >>> expected = [[1, 2], [3, 4], [5]] >>> result == expected True >>> linked_list = list_to_linkedlist([1, 2]) >>> parts = splitListToParts(linked_list, 5) >>> result = [linkedlist_to_list(part) for part in parts] >>> expected = [[1], [2], [], [], []] >>> result == expected True >>> linked_list = list_to_linkedlist([1, 2, 3, 4]) >>> parts = splitListToParts(linked_list, 2) >>> result = [linkedlist_to_list(part) for part in parts] >>> expected = [[1, 2], [3, 4]] >>> result == expected True def list_to_linkedlist(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linkedlist_to_list(node): result = [] while node: result.append(node.val) node = node.next return result","solution":"class ListNode: def __init__(self, x=0, next=None): self.val = x self.next = next def splitListToParts(head, k): # First, find the length of the linked list length = 0 current = head while current is not None: length += 1 current = current.next # Determine the size of each part and the remainder part_size = length // k remainder = length % k result = [] current = head for i in range(k): part_head = current prev = None for j in range(part_size + (i < remainder)): prev = current current = current.next if current else None if prev: prev.next = None result.append(part_head) return result"},{"question":"def find_closest_elements(nums, k, x): Given a list of integers nums, a target integer k, and an integer x, return the k closest integers to x in the list nums. The result should be sorted in ascending order. If there is a tie, prefer the smaller element. >>> find_closest_elements([1, 2, 3, 4, 5], 2, 3) [2, 3] >>> find_closest_elements([1, 2, 3, 4, 5], 3, 3) [2, 3, 4] >>> find_closest_elements([4, 1, 2, 3, 5], 3, 3) [2, 3, 4] >>> find_closest_elements([1], 1, 3) [1] >>> find_closest_elements([1, 2, 3, 4, 5], 3, 0) [1, 2, 3] >>> find_closest_elements([10, 20, 30, 40, 50], 5, 25) [10, 20, 30, 40, 50] >>> find_closest_elements([5, 1, 2, 4, 3], 3, 3) [2, 3, 4] pass","solution":"def find_closest_elements(nums, k, x): Finds the k closest integers to x in the list nums. Parameters: nums (list of int): List of integers. k (int): Number of closest integers to find. x (int): Target integer. Returns: list of int: k closest integers to x, sorted in ascending order. nums.sort() # First, sort the list of numbers in ascending order. # Use a lambda function to sort nums by absolute difference from x, and in case of a tie, by the number itself. sorted_nums = sorted(nums, key=lambda num: (abs(num - x), num)) # Return the first k elements of the sorted list of closest elements. return sorted(sorted_nums[:k])"},{"question":"from typing import List def longest_subarray_with_diff(arr: List[int], k: int) -> int: Given a 0-indexed integer array \`arr\` representing the heights of buildings, and an integer \`k\`, return the length of the longest subarray where the difference between the maximum and minimum heights is less than or equal to \`k\`. A subarray is a contiguous non-empty sequence of elements within an array. >>> longest_subarray_with_diff([1, 3, 6, 10, 15], 4) == 2 >>> longest_subarray_with_diff([1, 2, 3, 4, 5], 2) == 3 >>> longest_subarray_with_diff([1, 3, 6, 10, 15], 0) == 1 >>> longest_subarray_with_diff([], 5) == 0 >>> longest_subarray_with_diff([10], 10) == 1 >>> longest_subarray_with_diff([1, 5, 9, 2, 4], 3) == 2 >>> longest_subarray_with_diff([4, 8, 5, 1, 7, 9], 5) == 3 >>> longest_subarray_with_diff([0, 100, 200], 1) == 1 >>> longest_subarray_with_diff([10, 20, 30, 40, 50], 5) == 1","solution":"from collections import deque def longest_subarray_with_diff(arr, k): if not arr: return 0 max_len = 0 min_queue = deque() max_queue = deque() left = 0 for right in range(len(arr)): while min_queue and arr[min_queue[-1]] >= arr[right]: min_queue.pop() while max_queue and arr[max_queue[-1]] <= arr[right]: max_queue.pop() min_queue.append(right) max_queue.append(right) while arr[max_queue[0]] - arr[min_queue[0]] > k: left += 1 if min_queue[0] < left: min_queue.popleft() if max_queue[0] < left: max_queue.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"def longest_subarray_less_than_threshold(nums, threshold): Finds the length of the longest subarray such that the sum of its elements is less than or equal to threshold, and counts how many such subarrays exist. :param nums: List of integers. :param threshold: Integer threshold. :return: List of two integers. The first is the length of the longest subarray, and the second is the count of such subarrays. pass # Test cases def test_single_element_less_than_threshold(): assert longest_subarray_less_than_threshold([1], 2) == [1, 1] def test_single_element_equal_to_threshold(): assert longest_subarray_less_than_threshold([2], 2) == [1, 1] def test_single_element_greater_than_threshold(): assert longest_subarray_less_than_threshold([3], 2) == [0, 0] def test_multiple_elements_with_valid_subarray(): assert longest_subarray_less_than_threshold([1, 2, 3, 4, 5], 10) == [4, 1] def test_multiple_elements_without_valid_subarray(): assert longest_subarray_less_than_threshold([10, 9, 8, 7, 6], 5) == [0, 0] def test_multiple_elements_with_multiple_longest_subarrays(): assert longest_subarray_less_than_threshold([1, 1, 1, 1, 1], 3) == [3, 3] def test_all_elements_sum_greater_than_threshold(): assert longest_subarray_less_than_threshold([1, 2, 3, 4, 5], 1) == [1, 1] def test_threshold_zero(): assert longest_subarray_less_than_threshold([1, 2, 3, 4, 5], 0) == [0, 0]","solution":"def longest_subarray_less_than_threshold(nums, threshold): Finds the length of the longest subarray such that the sum of its elements is less than or equal to threshold, and counts how many such subarrays exist. :param nums: List of integers. :param threshold: Integer threshold. :return: List of two integers. The first is the length of the longest subarray, and the second is the count of such subarrays. n = len(nums) max_len = 0 count = 0 for start in range(n): current_sum = 0 for end in range(start, n): current_sum += nums[end] if current_sum > threshold: break subarray_len = end - start + 1 if subarray_len > max_len: max_len = subarray_len count = 1 elif subarray_len == max_len: count += 1 return [max_len, count]"},{"question":"def has_cycle(graph): Check if the undirected graph contains a cycle. Args: - graph (List[List[int]]): A list of lists representing an adjacency list of the graph. Returns: - bool: True if there is a cycle in the graph, otherwise False. pass # Unit Test from solution import has_cycle def test_has_cycle(): assert has_cycle([[1, 2], [0, 2], [0, 1, 3], [2]]) == True assert has_cycle([[1], [0, 2], [1, 3], [2]]) == False","solution":"def has_cycle(graph): Check if the undirected graph contains a cycle. Parameters: graph (dict): A dictionary where keys are node ids and values are lists of adjacent nodes. Returns: bool: True if the graph contains a cycle, False otherwise. def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: # Found a back edge (cycle) return True return False n = len(graph) visited = [False] * n for v in range(n): if not visited[v]: if dfs(v, -1): return True return False"},{"question":"from typing import List from collections import Counter, deque import heapq def rearrange_string(s: str, k: int) -> str: Rearrange the string s such that any two adjacent characters are not the same and no character repeats within any span of k positions. >>> rearrange_string(\\"aabbcc\\", 0) 'aabbcc' >>> rearrange_string(\\"aaabc\\", 3) '' >>> rearrange_string(\\"aabbcc\\", 3) in {'abcabc', 'acbacb', ...} True >>> rearrange_string(\\"aabbcc\\", 2) in {'abacbc', 'abcabc', ...} True >>> rearrange_string(\\"a\\", 2) 'a' >>> rearrange_string(\\"aaaa\\", 2) ''","solution":"from collections import Counter, deque import heapq def rearrange_string(s, k): if k == 0: return s count = Counter(s) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((char, freq + 1)) if len(queue) >= k: front_char, front_freq = queue.popleft() if front_freq < 0: heapq.heappush(max_heap, (front_freq, front_char)) if len(result) == len(s): return ''.join(result) else: return \\"\\""},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTreeDiameter: def __init__(self, root: TreeNode): Initializes the class with the root of the binary tree. pass def getDiameter(self) -> int: Returns the diameter of the binary tree. pass def test_single_node(): root = TreeNode(1) btd = BinaryTreeDiameter(root) assert btd.getDiameter() == 0 def test_tree_with_diameter_through_root(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) btd = BinaryTreeDiameter(root) assert btd.getDiameter() == 3 def test_tree_with_diameter_not_through_root(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) root.left.left.right = TreeNode(5) btd = BinaryTreeDiameter(root) assert btd.getDiameter() == 3 def test_complex_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.right.left = TreeNode(6) root.left.right.right = TreeNode(7) btd = BinaryTreeDiameter(root) assert btd.getDiameter() == 4","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTreeDiameter: def __init__(self, root): self.root = root self.diameter = 0 def getDiameter(self): self.calculateDiameter(self.root) return self.diameter def calculateDiameter(self, node): if not node: return 0 left_height = self.calculateDiameter(node.left) right_height = self.calculateDiameter(node.right) # The diameter at the current node will be the sum of the heights of its left and right subtrees self.diameter = max(self.diameter, left_height + right_height) # The height of the current node will be the max height of its left or right subtree plus 1 (for the current node) return max(left_height, right_height) + 1"},{"question":"def max_non_overlapping_tasks(tasks: List[List[int]]) -> int: Returns the maximum number of non-overlapping tasks. >>> max_non_overlapping_tasks([]) == 0 >>> max_non_overlapping_tasks([[1, 2]]) == 1 >>> max_non_overlapping_tasks([[1, 2], [3, 4], [5, 6]]) == 3 >>> max_non_overlapping_tasks([[1, 3], [2, 4], [3, 5], [6, 8], [7, 9]]) == 3 >>> max_non_overlapping_tasks([[1, 5], [2, 6], [3, 7]]) == 1 >>> max_non_overlapping_tasks([[1, 3], [3, 5], [4, 6], [6, 8], [8, 10]]) == 4 >>> max_non_overlapping_tasks([[1, 2], [2, 3], [3, 4], [1, 4]]) == 3","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks. if not tasks: return 0 # Sort tasks based on their end time tasks.sort(key=lambda x: x[1]) count = 0 end_time = float('-inf') for start, end in tasks: if start >= end_time: # If the current task starts after or when the last task ends count += 1 end_time = end return count"},{"question":"def reverse_words(s: str, positions: List[int]) -> str: Reverses the order of words in the string s as specified by the positions list without changing the order of characters within each word. Args: s (str): The input string. positions (list): A list of start positions of each word in the input string. Returns: str: The string with the words reversed. >>> reverse_words(\\"hello\\", [0]) \\"hello\\" >>> reverse_words(\\"hello world\\", [0, 6]) \\"world hello\\" >>> reverse_words(\\"one two three four\\", [0, 4, 8, 14]) \\"four three two one\\" >>> reverse_words(\\"hello world \\", [0, 6]) \\"world hello\\" >>> reverse_words(\\" hello world\\", [1, 7]) \\"world hello\\" >>> reverse_words(\\"a b c d\\", [0, 3, 7, 12]) \\"d c b a\\" >>> reverse_words(\\"abc123 456!@#\\", [0, 7]) \\"456!@# abc123\\"","solution":"def reverse_words(s, positions): Reverses the order of words in the string s as specified by the positions list. Args: s (str): The input string. positions (list): A list of start positions of each word in the input string. Returns: str: The string with the words reversed. words = [] for i, pos in enumerate(positions): if i + 1 < len(positions): words.append(s[pos:positions[i + 1] - 1].strip()) else: words.append(s[pos:].strip()) words.reverse() return ' '.join(words)"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_path(root, target): Finds the path from the root to the target node in a binary tree. Args: root (TreeNode): The root of the binary tree. target (int): The target value to find in the binary tree. Returns: list[int]: The path from the root to the target node as a list of node values. If the target does not exist in the tree, returns an empty list. Examples: >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(9) >>> find_path(root, 9) [5, 8, 9] >>> find_path(root, 2) [5, 3, 2] >>> find_path(root, 6) [] # Test cases for the function def test_find_path_existing_value(): root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(8) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(9) assert find_path(root, 9) == [5, 8, 9] assert find_path(root, 2) == [5, 3, 2] assert find_path(root, 5) == [5] assert find_path(root, 8) == [5, 8] def test_find_path_non_existing_value(): root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(8) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(9) assert find_path(root, 6) == [] assert find_path(root, 1) == [] assert find_path(root, 10) == [] def test_find_path_empty_tree(): assert find_path(None, 5) == []","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_path(root, target): Finds the path from the root to the target node in a binary tree. Args: root (TreeNode): The root of the binary tree. target (int): The target value to find in the binary tree. Returns: list[int]: The path from the root to the target node as a list of node values. If the target does not exist in the tree, returns an empty list. def helper(node, target, path): if not node: return False path.append(node.val) if node.val == target: return True if (node.left and helper(node.left, target, path)) or (node.right and helper(node.right, target, path)): return True path.pop() return False path = [] if helper(root, target, path): return path else: return [] # Example usage # Construct a sample binary tree: # 5 # / # 3 8 # / # 2 4 9 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(8) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(9) print(find_path(root, 9)) # Output: [5, 8, 9] print(find_path(root, 2)) # Output: [5, 3, 2] print(find_path(root, 6)) # Output: []"},{"question":"import heapq class KthLargest: def __init__(self, k, arr): Initializes the object with the integer array \`arr\` and the integer \`k\`. >>> kth_largest = KthLargest(3, [4, 5, 8, 2]) >>> kth_largest.add(0) # [2, 4, 5, 8] -> add 0 -> [0, 2, 4, 5, 8] 4 pass def add(self, val): Appends the integer \`val\` to the array and returns the \`k\`th largest element in the array. >>> kth_largest = KthLargest(3, [4, 5, 8, 2]) >>> kth_largest.add(3) # [2, 3, 4, 5, 8] 4 >>> kth_largest.add(5) # [3, 4, 5, 5, 8] 5 >>> kth_largest.add(10) # [4, 5, 5, 8, 10] 5 >>> kth_largest.add(9) # [5, 5, 8, 9, 10] 8 >>> kth_largest.add(4) # [5, 5, 8, 9, 10] -> no change as 4 is less than the kth largest 8 pass","solution":"import heapq class KthLargest: def __init__(self, k, arr): self.k = k self.min_heap = [] # Initialize min heap with the kth largest elements for num in arr: self.add(num) def add(self, val): heapq.heappush(self.min_heap, val) if len(self.min_heap) > self.k: heapq.heappop(self.min_heap) return self.min_heap[0]"},{"question":"def next_permutation(nums: List[int]) -> List[int]: Rearrange the integers into the lexicographically next greater permutation. If such arrangement is not possible, it rearranges it to the lowest possible order (i.e., sorted in ascending order). The replacement modifies the list in-place and uses only constant extra memory. >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] from solution import next_permutation def test_next_permutation_middle_change(): arr = [1, 2, 3] assert next_permutation(arr) == [1, 3, 2] def test_next_permutation_rotate(): arr = [3, 2, 1] assert next_permutation(arr) == [1, 2, 3] def test_next_permutation_small_array(): arr = [1, 1, 5] assert next_permutation(arr) == [1, 5, 1] def test_next_permutation_no_change_needed(): arr = [1, 5, 1] assert next_permutation(arr) == [5, 1, 1] def test_next_permutation_single_element(): arr = [1] assert next_permutation(arr) == [1] def test_next_permutation_two_elements(): arr = [1, 2] assert next_permutation(arr) == [2, 1] arr = [2, 1] assert next_permutation(arr) == [1, 2] def test_next_permutation_large_numbers(): arr = [100, 300, 200] assert next_permutation(arr) == [200, 100, 300]","solution":"def next_permutation(nums): Modifies nums in-place to the next permutation or the smallest permutation if the next permutation is not possible. # Find the first descending element from the end i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Find the larger number to swap with nums[i] j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap nums[i], nums[j] = nums[j], nums[i] # Reverse the numbers after the i-th position nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"def min_square_tiles(nums, target): Returns the minimum number of square tiles that sum up to the target. Uses dynamic programming to solve the problem. >>> min_square_tiles([1, 4, 9], 12) 3 >>> min_square_tiles([1, 2, 3], 6) 2 >>> min_square_tiles([2, 4], 7) -1 >>> min_square_tiles([1, 5, 10], 20) 2","solution":"def min_square_tiles(nums, target): Returns the minimum number of square tiles that sum up to the target. Uses dynamic programming to solve the problem. # Initialize the DP array with a large value dp = [float('inf')] * (target + 1) # Base case: zero square tiles are needed to reach target 0 dp[0] = 0 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] = min(dp[i], dp[i - num] + 1) return dp[target] if dp[target] != float('inf') else -1"},{"question":"def rotate_queue(nums, k): Rotates the queue (nums) to the right by k steps in-place. Args: nums (List[int]): List of integers representing the circular queue. k (int): Number of steps to rotate the queue. Returns: None: Rotates the queue in-place. Examples: >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate_queue(nums, 3) >>> nums [5, 6, 7, 1, 2, 3, 4] >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate_queue(nums, 0) >>> nums [1, 2, 3, 4, 5, 6, 7] >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate_queue(nums, 7) >>> nums [1, 2, 3, 4, 5, 6, 7] >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate_queue(nums, 10) >>> nums [5, 6, 7, 1, 2, 3, 4] >>> nums = [1] >>> rotate_queue(nums, 5) >>> nums [1] >>> nums = [2, 2, 2, 2] >>> rotate_queue(nums, 2) >>> nums [2, 2, 2, 2]","solution":"def rotate_queue(nums, k): Rotates the queue (nums) to the right by k steps in-place. n = len(nums) k = k % n # To handle if k > n nums[:] = nums[-k:] + nums[:-k]"},{"question":"def longest_alphabetical_subsequence(s: str) -> int: Given a string \`s\` that consists of only uppercase English letters, find and return the length of the longest subsequence in \`s\` such that every letter in the subsequence appears in alphabetical order. >>> longest_alphabetical_subsequence('') == 0 >>> longest_alphabetical_subsequence('A') == 1 >>> longest_alphabetical_subsequence('ABCDE') == 5 >>> longest_alphabetical_subsequence('ZYXWV') == 1 >>> longest_alphabetical_subsequence('CBADE') == 3 >>> longest_alphabetical_subsequence('ABCDEFGH') == 8","solution":"def longest_alphabetical_subsequence(s): Returns the length of the longest subsequence in s such that every letter in the subsequence appears in alphabetical order. if not s: return 0 dp = [1] * len(s) for i in range(1, len(s)): for j in range(i): if s[i] >= s[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def calculateMinimumHP(dungeon: List[List[int]]) -> int: Determine the minimum initial health point the player needs to start at cell (0, 0) to reach cell (m-1, n-1) successfully without health dropping to 0 or below. >>> calculateMinimumHP([ ... [-2, -3, 3], ... [-5, -10, 1], ... [10, 30, -5] ... ]) 7 >>> calculateMinimumHP([ ... [0, 0, 0], ... [1, 1, -1] ... ]) 1 >>> calculateMinimumHP([ ... [0, -3], ... [-10, 1] ... ]) 4 >>> calculateMinimumHP([ ... [-3, 5] ... ]) 4 >>> calculateMinimumHP([ ... [-3] ... ]) 4","solution":"def calculateMinimumHP(dungeon): Calculate the minimum initial health required for a player to survive in a dungeon grid. :param dungeon: List[List[int]]: a 2D grid where each cell contains an integer (positive or negative) representing health points gained or lost :return: int: the minimum initial health points needed to start at (0,0) and reach (m-1,n-1) if not dungeon or not dungeon[0]: return 1 m, n = len(dungeon), len(dungeon[0]) # dp[i][j] represents the minimum health points needed to reach the bottom-right corner from cell (i, j) dp = [[0] * n for _ in range(m)] # Bottom-right corner (base case) dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1]) # Fill the last column for i in range(m-2, -1, -1): dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1]) # Fill the last row for j in range(n-2, -1, -1): dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j]) # Fill the rest of the dp table for i in range(m-2, -1, -1): for j in range(n-2, -1, -1): min_health_on_exit = min(dp[i+1][j], dp[i][j+1]) dp[i][j] = max(1, min_health_on_exit - dungeon[i][j]) return dp[0][0]"},{"question":"def find_unique_pairs(nums: List[int], k: int) -> int: Given a sorted array of integers \`nums\` and an integer \`k\`, return the number of unique pairs \`(i, j)\` where \`i < j\` and \`nums[j] - nums[i] == k\`. >>> find_unique_pairs([1, 2, 3, 4, 5], 0) == 0 >>> find_unique_pairs([1, 2, 3, 4, 5], 10) == 0 >>> find_unique_pairs([1, 2, 3, 4, 5], 1) == 4 >>> find_unique_pairs([1, 3, 5, 7], 2) == 3 >>> find_unique_pairs([1, 2, 3, 4, 5, 6], 2) == 4 >>> find_unique_pairs([1, 2, 3, 4], 3) == 1 >>> find_unique_pairs([-3, -1, 1, 3, 5], 4) == 3 >>> find_unique_pairs([-3, -2, -1, 0], 1) == 3 >>> find_unique_pairs([], 1) == 0 >>> find_unique_pairs([1, 2, 3], -1) == 0","solution":"def find_unique_pairs(nums, k): Returns the number of unique pairs (i, j) where i < j and nums[j] - nums[i] == k. if not nums or k < 0: return 0 left, right = 0, 1 unique_pairs = set() nums_len = len(nums) while right < nums_len: diff = nums[right] - nums[left] if diff == k: unique_pairs.add((nums[left], nums[right])) left += 1 right += 1 elif diff < k: right += 1 else: left += 1 if left == right: right += 1 return len(unique_pairs)"},{"question":"def max_contiguous_subarray_sum(arr: List[int], k: int) -> int: Returns the maximum sum of any contiguous subarray of length k in arr. If no such subarray exists, return 0. >>> max_contiguous_subarray_sum([1, 2, 3, 4, 5], 2) == 9 >>> max_contiguous_subarray_sum([1, 2, 3, 4, 5, 6, 7], 3) == 18 >>> max_contiguous_subarray_sum([-1, -2, -3, -4, -5], 2) == -3 >>> max_contiguous_subarray_sum([1, -2, 3, 4, -5, 6], 3) == 5 >>> max_contiguous_subarray_sum([], 1) == 0 >>> max_contiguous_subarray_sum([1, 2, 3], 4) == 0 >>> max_contiguous_subarray_sum([5], 1) == 5 >>> max_contiguous_subarray_sum([100000, 200000, 300000], 2) == 500000 >>> max_contiguous_subarray_sum([1000000, -1000000, 1000000], 2) == 0","solution":"def max_contiguous_subarray_sum(arr, k): Returns the maximum sum of any contiguous subarray of length k in arr. If no such subarray exists, return 0. n = len(arr) # If the length of array is less than k, no such subarray exists. if n < k: return 0 # Compute the sum of the first 'k' elements max_sum = sum(arr[:k]) current_sum = max_sum # Traverse the array from the 'k'th element to the end for i in range(k, n): current_sum = current_sum + arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def find_max_average(nums: List[int], k: int) -> float: Finds a contiguous subarray of length k that has the highest average. Returns the highest average as a floating-point number. >>> find_max_average([1, 12, -5, -6, 50, 3], 4) 12.75 >>> find_max_average([5, 5, 5, 5], 2) 5.0 >>> find_max_average([1, 12, 10, 1, 1, 1, 1], 2) 11.0 >>> find_max_average([1, 2, 3, 4, 5], 5) 3.0 >>> find_max_average([2, 2, 2, 2, 2], 3) 2.0 >>> find_max_average([], 1) None >>> find_max_average([10, 20, 30], 4) None >>> find_max_average([1], 1) 1.0","solution":"def find_max_average(nums, k): Finds a contiguous subarray of length k that has the highest average. Returns the highest average as a floating-point number. n = len(nums) if k > n: return None # Not possible to have a subarray of length greater than array length # Compute the sum of the first window window_sum = sum(nums[:k]) max_sum = window_sum # Slide the window across the array for i in range(k, n): window_sum += nums[i] - nums[i - k] max_sum = max(max_sum, window_sum) # Compute the maximum average max_average = max_sum / k return max_average"},{"question":"def class_representative(n: int, votes: List[int]) -> int: Given the number of students \`n\` and a list of votes \`votes\`, returns the ID number of the elected class representative. >>> class_representative(5, [1, 1, 1, 1, 1]) == 1 >>> class_representative(5, [2, 3, 2, 2, 4]) == 2 >>> class_representative(3, [2, 3, 1]) == 1 >>> class_representative(4, [3, 3, 2, 2]) == 2 >>> class_representative(4, [1, 2, 3, 4]) == 1 >>> class_representative(100, [i % 10 + 1 for i in range(500)]) == 1","solution":"def class_representative(n, votes): Given the number of students \`n\` and a list of votes \`votes\`, returns the ID number of the elected class representative. from collections import Counter vote_count = Counter(votes) # Get the maximum number of votes received max_votes = max(vote_count.values()) # Find all students who received the maximum number of votes max_voters = [student for student, count in vote_count.items() if count == max_votes] # Return the student with the smallest ID among those who tied return min(max_voters)"},{"question":"def num_trees(n: int) -> int: Given an integer n, return the number of unique binary search trees (BSTs) that can be constructed using values from 1 to n inclusive. >>> num_trees(1) 1 >>> num_trees(2) 2 >>> num_trees(3) 5 >>> num_trees(4) 14 >>> num_trees(5) 42 >>> num_trees(0) 1 >>> num_trees(6) 132","solution":"def num_trees(n): Returns the number of unique binary search trees (BSTs) that can be constructed using values from 1 to n inclusive. if n == 0 or n == 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for nodes in range(2, n + 1): total_trees = 0 for root in range(1, nodes + 1): left_trees = dp[root - 1] right_trees = dp[nodes - root] total_trees += left_trees * right_trees dp[nodes] = total_trees return dp[n]"},{"question":"def calculate(expression: str) -> int: Evaluate the given mathematical expression and return the result as an integer. >>> calculate(\\"3+2*2\\") 7 >>> calculate(\\" 3/2 \\") 1 >>> calculate(\\" 3+5 / 2 \\") 5 >>> calculate(\\" 3+ 5 / 2 \\") 5 >>> calculate(\\" 3 * 4 /2 \\") 6 >>> calculate(\\"3-2+2*2\\") 5 >>> calculate(\\"3-3/2\\") 2 >>> calculate(\\"1+2*3-6/2\\") 4 >>> calculate(\\"2*3+5/2-8\\") 0","solution":"def calculate(expression): Evaluate the given mathematical expression and return the result as an integer. if not expression: return 0 stack = [] num = 0 sign = \\"+\\" # The initial sign is positive n = len(expression) for i in range(n): char = expression[i] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or i == n - 1: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) # Python 2 division ensures truncation towards zero sign = char num = 0 return sum(stack)"},{"question":"def find_triplet(nums, target): Determines if there are three numbers in the list nums that add up to the target. Args: nums (list): List of n positive integers. target (int): Target sum. Returns: bool: True if there exists a triplet such that their sum equals target, otherwise False. >>> find_triplet([1, 4, 45, 6, 10, 8], 22) True >>> find_triplet([1, 2, 4, 6, 8], 21) False >>> find_triplet([3, 7, 1], 11) True >>> find_triplet([1, 1, 1, 1], 3) True >>> find_triplet([1, 1, 1, 1], 4) False >>> find_triplet([], 1) False >>> find_triplet([10], 10) False >>> find_triplet([5, 10], 15) False","solution":"def find_triplet(nums, target): Determines if there are three numbers in the list nums that add up to the target. Args: nums (list): List of n positive integers. target (int): Target sum. Returns: bool: True if there exists a triplet such that their sum equals target, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters, given a string \`s\` consisting solely of characters 'a', 'b', and 'c'. >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") == 2 >>> length_of_longest_substring_two_distinct(\\"aaabbbccc\\") == 6 >>> length_of_longest_substring_two_distinct(\\"abacccccc\\") == 7 >>> length_of_longest_substring_two_distinct(\\"aabbcca\\") == 4 >>> length_of_longest_substring_two_distinct(\\"\\") == 0 >>> length_of_longest_substring_two_distinct(\\"a\\") == 1 >>> length_of_longest_substring_two_distinct(\\"aa\\") == 2 >>> length_of_longest_substring_two_distinct(\\"ab\\") == 2 >>> length_of_longest_substring_two_distinct(\\"abc\\") == 2 >>> length_of_longest_substring_two_distinct(\\"aabbcc\\") == 4 >>> length_of_longest_substring_two_distinct(\\"ababab\\") == 6","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. Parameters: s (str): Input string consisting of 'a', 'b', and 'c' Returns: int: Length of the longest substring with at most two distinct characters if len(s) == 0: return 0 window_start = 0 max_length = 0 char_frequency = {} for window_end in range(len(s)): right_char = s[window_end] if right_char in char_frequency: char_frequency[right_char] += 1 else: char_frequency[right_char] = 1 while len(char_frequency) > 2: left_char = s[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"def row_with_most_filled_seats(seats: List[List[int]]) -> int: Function to find the row with the most number of filled seats. Parameters: seats (list of list of ints): 2D array representing the seating arrangement Returns: int: Index of the row with the most filled seats pass from solution import row_with_most_filled_seats def test_all_zeros(): seats = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert row_with_most_filled_seats(seats) == 0 def test_single_row(): seats = [ [1, 1, 1] ] assert row_with_most_filled_seats(seats) == 0 def test_multiple_rows(): seats = [ [1, 0, 0], [0, 1, 1], [0, 0, 1], [1, 1, 1] ] assert row_with_most_filled_seats(seats) == 3 def test_tie_in_row_counts(): seats = [ [1, 0, 1], [0, 1, 0], [1, 0, 1], [0, 1, 1] ] assert row_with_most_filled_seats(seats) == 0 def test_empty_seats(): seats = [] assert row_with_most_filled_seats(seats) == -1 def test_all_rows_empty(): seats = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert row_with_most_filled_seats(seats) == 0","solution":"def row_with_most_filled_seats(seats): Function to find the row with the most number of filled seats. Parameters: seats (list of list of ints): 2D array representing the seating arrangement Returns: int: Index of the row with the most filled seats max_filled = -1 row_index = -1 for i, row in enumerate(seats): filled_count = sum(row) if filled_count > max_filled: max_filled = filled_count row_index = i return row_index"},{"question":"def guess_number(n: int, guess): Find the hidden target number between 1 and n using the least number of guesses. :param n: The upper limit of the range. :param guess: Function that returns -1, 1, or 0 based on the guessed number. :return: The target number. >>> guess_function_factory(42) >>> guess = guess_function_factory(42) >>> guess_number(100, guess) == 42 >>> guess_function_factory(1) >>> guess = guess_function_factory(1) >>> guess_number(100, guess) == 1 >>> guess_function_factory(100) >>> guess = guess_function_factory(100) >>> guess_number(100, guess) == 100 >>> guess_function_factory(57) >>> guess = guess_function_factory(57) >>> guess_number(100, guess) == 57 >>> guess_function_factory(1) >>> guess = guess_function_factory(1) >>> guess_number(1, guess) == 1","solution":"def guess_number(n, guess): Function to find the hidden target number between 1 and n using binary search. :param n: The upper limit of the range. :param guess: Function that returns -1, 1, or 0 based on the guessed number. :return: The target number. left, right = 1, n while left <= right: mid = (left + right) // 2 result = guess(mid) if result == 0: return mid elif result == -1: right = mid - 1 else: left = mid + 1"},{"question":"from typing import List def maxSideLength(grid: List[List[int]], threshold: int) -> int: Returns the maximum side length of a square sub-matrix such that the sum of all the elements within this square is less than or equal to the given threshold. >>> grid = [ [1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2] ] >>> threshold = 4 >>> maxSideLength(grid, threshold) 2 >>> grid = [ [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2] ] >>> threshold = 1 >>> maxSideLength(grid, threshold) 0 >>> grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] >>> threshold = 8 >>> maxSideLength(grid, threshold) 2 >>> grid = [ [5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5] ] >>> threshold = 20 >>> maxSideLength(grid, threshold) 2 >>> grid = [ [10, 20], [30, 40] ] >>> threshold = 60 >>> maxSideLength(grid, threshold) 1 >>> grid = [[]] >>> threshold = 1 >>> maxSideLength(grid, threshold) 0","solution":"def maxSideLength(grid, threshold): Returns the maximum side length of a square sub-matrix such that the sum of all the elements within this square is less than or equal to the given threshold. m, n = len(grid), len(grid[0]) # Compute prefix sums prefix = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): prefix[i+1][j+1] = grid[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j] def square_sum(x1, y1, x2, y2): return prefix[x2][y2] - prefix[x1][y2] - prefix[x2][y1] + prefix[x1][y1] # Binary search on the side length of the square sub-matrix left, right, max_side = 1, min(m, n), 0 while left <= right: mid = (left + right) // 2 found = False for i in range(m - mid + 1): for j in range(n - mid + 1): if square_sum(i, j, i + mid, j + mid) <= threshold: found = True break if found: break if found: max_side = mid left = mid + 1 else: right = mid - 1 return max_side"},{"question":"def count_buildings_to_reduce(heights: List[int], requirements: List[int]) -> int: Returns the number of buildings that need to have their heights reduced to comply with the requirements. Parameters: heights (list of int): List of heights of buildings. requirements (list of int): List of maximum allowed heights for the corresponding buildings. Returns: int: Number of buildings that need their heights reduced. >>> count_buildings_to_reduce([3, 4, 5], [5, 6, 7]) 0 >>> count_buildings_to_reduce([3, 7, 5], [4, 6, 6]) 1 >>> count_buildings_to_reduce([6, 8, 5], [5, 7, 4]) 3 >>> count_buildings_to_reduce([], []) 0 >>> count_buildings_to_reduce([5, 10, 15], [5, 10, 15]) 0 >>> count_buildings_to_reduce([5], [6]) 0 >>> count_buildings_to_reduce([7], [6]) 1","solution":"def count_buildings_to_reduce(heights, requirements): Returns the number of buildings that need to have their heights reduced to comply with the requirements. Parameters: heights (list of int): List of heights of buildings. requirements (list of int): List of maximum allowed heights for the corresponding buildings. Returns: int: Number of buildings that need their heights reduced. count = 0 for height, requirement in zip(heights, requirements): if height > requirement: count += 1 return count"},{"question":"def max_energy_accumulated(energies: List[int]) -> int: Returns the maximum amount of energy that can be accumulated by optimally pairing people based on their energies. :param energies: List of non-negative integers representing energies :return: Maximum total accumulated energy >>> max_energy_accumulated([3, 6, 1, 10]) 6 >>> max_energy_accumulated([5, 5, 5, 5]) 0 >>> max_energy_accumulated([1, 100]) 99 >>> max_energy_accumulated([4, 2, 1]) 1 >>> max_energy_accumulated([]) 0 >>> max_energy_accumulated([5]) 0 >>> max_energy_accumulated([10, 20, 30, 40, 50, 60, 70, 80, 90]) 40 pass","solution":"def max_energy_accumulated(energies): Returns the maximum amount of energy that can be accumulated by optimally pairing people based on their energies. :param energies: List of non-negative integers representing energies :return: Maximum total accumulated energy energies.sort() total_energy = 0 for i in range(1, len(energies), 2): total_energy += energies[i] - energies[i - 1] return total_energy"},{"question":"def longestBitonicSequence(nums: List[int]) -> int: Find the length of the longest bitonic subsequence. A bitonic sequence is a sequence of numbers which is first increasing and then decreasing. Example usage: >>> longestBitonicSequence([1, 2, 3, 4, 5, 3, 2, 1]) 8 >>> longestBitonicSequence([1, 11, 2, 10, 4, 5, 2, 1]) 6 >>> longestBitonicSequence([12, 11, 40, 5, 3, 1]) 5 >>> longestBitonicSequence([1, 5, 3]) 3 >>> longestBitonicSequence([1, 2, 3, 4, 5]) 5 >>> longestBitonicSequence([5, 4, 3, 2, 1]) 5 >>> longestBitonicSequence([]) 0","solution":"def longestBitonicSequence(nums): if not nums: return 0 n = len(nums) inc = [1] * n dec = [1] * n # Compute LIS for every element for i in range(1, n): for j in range(i): if nums[i] > nums[j]: inc[i] = max(inc[i], inc[j] + 1) # Compute LDS for every element for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if nums[i] > nums[j]: dec[i] = max(dec[i], dec[j] + 1) # Compute the maximum length of bitonic subsequence max_len = 0 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"from typing import List def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: Perform flood fill algorithm starting from (sr, sc) and fill the connected area with newColor. Args: image: List of List of integers representing the image. sr: Row index of the starting pixel. sc: Column index of the starting pixel. newColor: New color to fill the connected area. Returns: The modified image after performing the flood fill algorithm. >>> floodFill([[1, 1, 1], [1, 1, 0], [1, 0, 1]], 1, 1, 2) [[2, 2, 2], [2, 2, 0], [2, 0, 1]] >>> floodFill([[0, 0, 0], [0, 1, 0]], 1, 1, 2) [[0, 0, 0], [0, 2, 0]] >>> floodFill([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 0, 0, 2) [[2, 2, 2], [2, 2, 2], [2, 2, 2]] >>> floodFill([[2, 2, 2], [2, 2, 2], [2, 2, 2]], 0, 0, 2) [[2, 2, 2], [2, 2, 2], [2, 2, 2]] pass # Your implementation here","solution":"from typing import List def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: rows, cols = len(image), len(image[0]) originalColor = image[sr][sc] def dfs(r, c): if (r < 0 or r >= rows or c < 0 or c >= cols or image[r][c] != originalColor or image[r][c] == newColor): return image[r][c] = newColor dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) if originalColor != newColor: dfs(sr, sc) return image"},{"question":"from typing import List def combination_sum(arr: List[int], target: int) -> List[List[int]]: Given an array of integers \`arr\` and an integer \`target\`, return an array of arrays where each subarray contains distinct integers from \`arr\` that add up to \`target\`. >>> combination_sum([2, 3, 6, 7], 7) [[7]] >>> combination_sum([2, 3, 5], 8) [[3, 5]] >>> combination_sum([10,1,2,7,6,1,5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combination_sum([], 7) [] >>> combination_sum([2, 4, 6], 5) [] >>> combination_sum([3], 3) [[3]] >>> combination_sum([3], 4) []","solution":"from typing import List def combination_sum(arr: List[int], target: int) -> List[List[int]]: def backtrack(start, path, target): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(arr)): if i > start and arr[i] == arr[i - 1]: continue backtrack(i + 1, path + [arr[i]], target - arr[i]) arr.sort() # Sort to handle duplicates and make it easier to skip them result = [] backtrack(0, [], target) return result"},{"question":"def generate_phone_numbers(num: int) -> list: Returns all possible combinations of \`num\` digits such that no consecutive digits are the same. The digits can be from 0 to 9. Return the list of combinations sorted in lexicographical order. >>> generate_phone_numbers(1) ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] >>> generate_phone_numbers(2) ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '89', '90', '91', '92', '93', '94', '95', '96', '97', '98'] >>> generate_phone_numbers(0) []","solution":"def generate_phone_numbers(num): Returns all possible combinations of \`num\` digits such that no consecutive digits are the same. Sorted in lexicographical order. if num <= 0: return [] def dfs(path): if len(path) == num: result.append(\\"\\".join(path)) return for digit in map(str, range(10)): if not path or path[-1] != digit: dfs(path + [digit]) result = [] for start_digit in map(str, range(10)): dfs([start_digit]) result.sort() return result"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"dvdf\\") == 3 >>> length_of_longest_substring(\\"abcbdeac\\") == 5 >>> length_of_longest_substring(\\"123!@#123\\") == 6","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def minDistance(s1: str, s2: str) -> int: Returns the minimum number of operations required to convert s1 into s2 using insert, delete, and replace operations. Args: - s1: first string - s2: second string Returns: - int: minimum number of operations >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"\\", \\"abc\\") 3 >>> minDistance(\\"abc\\", \\"\\") 3 >>> minDistance(\\"abc\\", \\"abc\\") 0 >>> minDistance(\\"abc\\", \\"yabc\\") 1 >>> minDistance(\\"a\\", \\"b\\") 1 >>> minDistance(\\"abcd\\", \\"abce\\") 1","solution":"def minDistance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. m, n = len(s1), len(s2) # Create a DP table with (m+1) x (n+1) dimensions dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, remove all characters of first string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If characters are same, no new operation is needed else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def rotate(matrix: List[List[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in-place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> rotate(matrix) >>> matrix [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [[1]] >>> rotate(matrix) >>> matrix [[1]] >>> matrix = [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ] >>> rotate(matrix) >>> matrix [[21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5]] # Your code here","solution":"def rotate(matrix): Rotates the given n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"from typing import List class WordBreak: def __init__(self): Initializes the WordBreak object with an empty state. pass def wordBreak(self, s: str, wordDict: List[str]) -> List[str]: Finds and returns all possible sentences that can be formed by adding spaces in \`s\`, ensuring that each word is a valid dictionary word from \`wordDict\`. Args: s (str): The input string to add spaces to. wordDict (List[str]): A dictionary of valid words. Returns: List[str]: All possible sentences formed by adding spaces in \`s\`. Examples: >>> wb = WordBreak() >>> set(wb.wordBreak(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"])) == set([\\"cats and dog\\", \\"cat sand dog\\"]) True >>> set(wb.wordBreak(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"])) == set([\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"]) True >>> set(wb.wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"])) == set([]) True # Your implementation here","solution":"from typing import List class WordBreak: def __init__(self): pass def wordBreak(self, s: str, wordDict: List[str]) -> List[str]: memo = {} def helper(s): if s in memo: return memo[s] if not s: return [''] res = [] for word in wordDict: if s.startswith(word): sublist = helper(s[len(word):]) for sub in sublist: if sub: res.append(word + ' ' + sub) else: res.append(word) memo[s] = res return res return helper(s)"},{"question":"def maximum_beauty(nums): Returns the maximum beauty out of all possible contiguous subarrays of nums. Beauty is defined as the absolute difference between the minimum and maximum values of the subarray. >>> maximum_beauty([5]) == 0 >>> maximum_beauty([3, 3, 3, 3]) == 0 >>> maximum_beauty([1, 2, 3, 4, 5]) == 4 >>> maximum_beauty([5, 4, 3, 2, 1]) == 4 >>> maximum_beauty([1, 3, 2, 4, 5]) == 4 >>> maximum_beauty([-1, -3, 2, 4, 5]) == 8 >>> maximum_beauty([]) == 0 >>> maximum_beauty([1, 100, 50, 20, 30]) == 99","solution":"def maximum_beauty(nums): Returns the maximum beauty out of all possible contiguous subarrays of nums. Beauty is defined as the absolute difference between the minimum and maximum values of the subarray. n = len(nums) if n == 0: return 0 max_beauty = 0 for i in range(n): min_val = max_val = nums[i] for j in range(i, n): min_val = min(min_val, nums[j]) max_val = max(max_val, nums[j]) max_beauty = max(max_beauty, max_val - min_val) return max_beauty"},{"question":"def longest_prefix_lengths(text: str, words: List[str]) -> List[int]: For each word in words, find the longest prefix that matches any prefix of text. Return the array of lengths of these longest prefixes. >>> longest_prefix_lengths(\\"abcdef\\", [\\"abc\\", \\"abcd\\", \\"abz\\", \\"abcdefg\\"]) [3, 4, 2, 6] >>> longest_prefix_lengths(\\"abcdef\\", [\\"a\\", \\"ab\\", \\"abcde\\", \\"abcdef\\"]) [1, 2, 5, 6]","solution":"def longest_prefix_lengths(text, words): For each word in words, find the longest prefix that matches any prefix of text. Return the array of lengths of these longest prefixes. result = [] for word in words: max_len = min(len(text), len(word)) i = 0 while i < max_len and word[i] == text[i]: i += 1 result.append(i) return result"},{"question":"def longest_palindromic_length(s: str) -> int: Find the length of the longest substring of a binary number string that can be rearranged to form a palindrome. >>> longest_palindromic_length(\\"0000\\") == 4 >>> longest_palindromic_length(\\"1111\\") == 4 >>> longest_palindromic_length(\\"110110\\") == 6 >>> longest_palindromic_length(\\"10101\\") == 5","solution":"def longest_palindromic_length(s): from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can have at most one character with an odd count to be able to rearrange into a palindrome if odd_count > 1: return len(s) - (odd_count - 1) else: return len(s)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_decimal_value(head: ListNode) -> int: Given the head of a singly linked list with nodes containing binary values (0 and 1), return the integer value of the binary number represented by the list. >>> head = ListNode(1) >>> get_decimal_value(head) 1 >>> head = ListNode(1, ListNode(0)) >>> get_decimal_value(head) 2 >>> head = ListNode(1, ListNode(0, ListNode(1))) >>> get_decimal_value(head) 5","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_decimal_value(head): Given the head of a singly linked list with nodes containing binary values (0 and 1), return the integer value of the binary number represented by the list. binary_num = 0 current = head while current: binary_num = binary_num * 2 + current.val current = current.next return binary_num"},{"question":"def sorted_elements(matrix: List[List[int]]) -> List[int]: Given an \`m x n\` matrix where each row is sorted in non-decreasing order, return all elements of the matrix in a sorted, non-decreasing order. :param matrix: List[List[int]] - 2D list of integers sorted in each row :return: List[int] - Sorted elements of the matrix in non-decreasing order >>> sorted_elements([[3, 1, 2]]) [1, 2, 3] >>> sorted_elements([[1, 3, 5], [2, 4, 6]]) [1, 2, 3, 4, 5, 6] >>> sorted_elements([]) [] >>> sorted_elements([[1, 2, 3]]) [1, 2, 3] >>> sorted_elements([[1, 5, 9], [10, 11, 13], [12, 13, 15]]) [1, 5, 9, 10, 11, 12, 13, 13, 15]","solution":"def sorted_elements(matrix): Given an \`m x n\` matrix where each row is sorted in non-decreasing order, returns all elements of the matrix in a sorted, non-decreasing order. A new list is created to store and then sort the elements. :param matrix: List[List[int]] - 2D list of integers sorted in each row :return: List[int] - Sorted elements of the matrix in non-decreasing order # Extract all elements from the matrix elements = [element for row in matrix for element in row] # Sort the elements elements.sort() return elements"},{"question":"from typing import List def mergeIntervals(intervals: List[List[int]]) -> List[List[int]]: Merge all overlapping intervals from the input list of intervals. >>> mergeIntervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> mergeIntervals([[1, 2], [3, 4], [5, 6]]) [[1, 2], [3, 4], [5, 6]] >>> mergeIntervals([[1, 4], [2, 3], [3, 5]]) [[1, 5]] >>> mergeIntervals([[1, 5], [2, 3], [4, 6], [8, 10], [9, 11]]) [[1, 6], [8, 11]] >>> mergeIntervals([[1, 3]]) [[1, 3]] >>> mergeIntervals([]) []","solution":"from typing import List def mergeIntervals(intervals: List[List[int]]) -> List[List[int]]: if not intervals: return [] # Sort intervals by starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval if current[0] <= last_merged[1]: # Merge the two intervals last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head: ListNode, x: int) -> ListNode: Partitions a linked list around a value x such that all nodes less than x come before nodes greater than or equal to x. The relative order of nodes in each partition should remain the same as in the original linked list. Parameters: - head: ListNode, the head of the linked list - x: int, the partition value Returns: - ListNode, the head of the modified linked list. >>> head = ListNode(1, ListNode(4, ListNode(3, ListNode(2, ListNode(5, ListNode(2)))))) >>> x = 3 >>> res = partition(head, x) >>> list_result = [] >>> while res: >>> list_result.append(res.val) >>> res = res.next >>> list_result [1, 2, 2, 4, 3, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, x): Partitions a linked list around a value x such that all nodes less than x come before nodes greater than or equal to x. The relative order of nodes in each partition should remain the same as in the original linked list. Parameters: - head: ListNode, the head of the linked list - x: int, the partition value Returns: - ListNode, the head of the modified linked list. if not head: return head # Two dummy nodes for the heads of the two lists before_head = ListNode(0) after_head = ListNode(0) # Two pointers to build the two lists before = before_head after = after_head current = head while current: if current.val < x: before.next = current before = before.next else: after.next = current after = after.next current = current.next # Combine the two lists after.next = None # End of the 'after' list before.next = after_head.next # Combine before list with after list return before_head.next"},{"question":"def max_sum_with_k_elements(nums: List[int], k: int) -> int: Returns the maximum sum of a subarray of length k that can be obtained by rearranging the elements of nums. >>> max_sum_with_k_elements([1, 2, 5, 1, 3, 4], 3) == 12 >>> max_sum_with_k_elements([-1, -2, -3, -4, -5], 2) == -3 >>> max_sum_with_k_elements([-1, 4, -2, 3, 5], 2) == 9 >>> max_sum_with_k_elements([1, 2, 3, 4, 5], 5) == 15 >>> max_sum_with_k_elements([5], 1) == 5 >>> max_sum_with_k_elements([1, 2, 3, 4, 5], 0) == 0 pass","solution":"def max_sum_with_k_elements(nums, k): Returns the maximum sum of a subarray of length k that can be obtained by rearranging the elements of nums. # Sort the array in descending order nums.sort(reverse=True) # Calculate the sum of the first 'k' elements after sorting max_sum = sum(nums[:k]) return max_sum"},{"question":"def maxVisibleStudents(heights: List[int]) -> int: Returns the maximum number of students visible from the front of the class. >>> maxVisibleStudents([]) == 0 >>> maxVisibleStudents([150]) == 1 >>> maxVisibleStudents([160, 160, 160, 160]) == 1 >>> maxVisibleStudents([150, 160, 170, 180]) == 4 >>> maxVisibleStudents([180, 170, 160, 150]) == 1 >>> maxVisibleStudents([150, 160, 150, 170, 160, 180]) == 4 >>> maxVisibleStudents([170, 160, 180, 150, 190, 140]) == 3 pass","solution":"def maxVisibleStudents(heights): Returns the maximum number of students visible from the front. if not heights: return 0 visible_count = 1 # The first student is always visible max_height = heights[0] for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def min_increments_to_make_unique(nums: List[int]) -> int: Returns the minimum number of increments needed to make all elements of the array pairwise distinct. >>> min_increments_to_make_unique([1, 2, 2]) == 1 >>> min_increments_to_make_unique([3, 2, 1, 2, 1, 7]) == 6 >>> min_increments_to_make_unique([1, 1, 1]) == 3 >>> min_increments_to_make_unique([1, 2, 3]) == 0 >>> min_increments_to_make_unique([5, 5, 5, 5]) == 6 >>> min_increments_to_make_unique([]) == 0 >>> min_increments_to_make_unique([100]) == 0","solution":"def min_increments_to_make_unique(nums): Returns the minimum number of increments needed to make all elements of the array pairwise distinct. nums.sort() increments = 0 for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: needed = nums[i - 1] - nums[i] + 1 nums[i] += needed increments += needed return increments"},{"question":"def max_points(nums): Return the maximum points the archer can accumulate without hitting consecutive targets. :param nums: List[int] - List of points each target has. :return: int - Maximum points. Examples: >>> max_points([10]) 10 >>> max_points([5, 10]) 10 >>> max_points([]) 0 >>> max_points([3, 2, 5, 10, 7]) 15 >>> max_points([2, 1, 1, 2]) 4 >>> max_points([3, 7, 4, 6, 5]) 13 >>> max_points([1, 2, 3, 1]) 4 >>> max_points([-1, -2, -3]) -1 >>> max_points([-2, -3, -4, -5]) -2 >>> max_points([2, 7, 9, 3, 1]) 12 >>> max_points([-2, 5, -1, 8]) 13 pass # Implement the function here","solution":"def max_points(nums): Returns the maximum points the archer can accumulate without hitting consecutive targets. :param nums: List[int] - List of points each target has. :return: int - Maximum points. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize two variables to store the maximum points without hitting consecutive targets prev1 = nums[0] prev2 = max(nums[0], nums[1]) for i in range(2, n): # Calculate maximum points at current target current = max(prev2, prev1 + nums[i]) # Update the variables for the next iteration prev1, prev2 = prev2, current return prev2"},{"question":"from typing import List def maxPoints(grid: List[List[int]]) -> int: Returns the maximum points the robot can collect while moving from top-left to bottom-right of the grid. >>> maxPoints([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> maxPoints([[1, 2], [4, 5]]) 10 >>> maxPoints([[5]]) 5 >>> maxPoints([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> maxPoints([[1, 2, 5], [3, 2, 1]]) 9 >>> maxPoints([]) 0 >>> maxPoints([[]]) 0 >>> maxPoints([[1, 2, 3, 4]]) 10 >>> maxPoints([[10], [20], [30], [40]]) 100","solution":"def maxPoints(grid): Returns the maximum points the robot can collect while moving from top-left to bottom-right of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp table with the same size as the grid dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = grid[0][0] # Initialize the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Initialize the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the dp table for the rest of the grid for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The last cell contains the maximum points that can be collected return dp[m - 1][n - 1]"},{"question":"def get_employees_in_department(employees: List[int], d: int) -> List[int]: Returns a sorted list of all the employee numbers who belong to the department \`d\`. Parameters: employees (list): A list where employees[i] denotes the department number that the i-th employee belongs to. d (int): The department number to query. Returns: list: Sorted list of employee numbers who belong to department \`d\`. >>> get_employees_in_department([2, 2, 2], 2) [0, 1, 2] >>> get_employees_in_department([1, 2, 1, 2, 3], 2) [1, 3] >>> get_employees_in_department([0, 1, 2, 3], 4) [] >>> get_employees_in_department([0, 1, 2, 1], 2) [2] >>> get_employees_in_department([], 1) [] >>> get_employees_in_department([0, 1, 2, 3, 4], 3) [3] >>> get_employees_in_department([0, 1, 2, 3, 4], 1) [1]","solution":"def get_employees_in_department(employees, d): Returns a sorted list of all the employee numbers who belong to the department \`d\`. Parameters: employees (list): A list where employees[i] denotes the department number that the i-th employee belongs to. d (int): The department number to query. Returns: list: Sorted list of employee numbers who belong to department \`d\`. employees_in_department = [i for i, dept in enumerate(employees) if dept == d] return sorted(employees_in_department)"},{"question":"from typing import List def common_intervals(intervals: List[List[int]]) -> List[List[int]]: Returns a list of intervals during which all employees are simultaneously available. Args: intervals (List[List[int]]): A list of intervals representing the working hours of employees. Returns: List[List[int]]: A list of common intervals when all employees are simultaneously available. >>> common_intervals([[1, 3], [2, 4], [2, 5]]) == [[2, 3]] >>> common_intervals([[1, 2], [2, 3], [3, 4]]) == [] >>> common_intervals([[1, 5], [2, 6], [3, 7]]) == [[3, 5]] >>> common_intervals([[0, 10], [2, 4], [5, 9]]) == [] >>> common_intervals([[1, 3], [2, 3], [2, 5], [1, 2]]) == [[2, 2]] >>> common_intervals([[1, 5], [5, 10]]) == [[5, 5]] >>> common_intervals([]) == [] >>> common_intervals([[1, 2]]) == [[1, 2]] >>> common_intervals([[1, 2], [1, 2], [1, 2]]) == [[1, 2]] >>> common_intervals([[1, 10], [2, 9], [3, 8], [4, 7], [6, 9]]) == [[6, 7]] >>> common_intervals([[3, 6], [4, 7], [5, 8]]) == [[5, 6]]","solution":"def common_intervals(intervals): Returns a list of intervals during which all employees are simultaneously available. Args: intervals (List[List[int]]): A list of intervals representing the working hours of employees. Returns: List[List[int]]: A list of common intervals when all employees are simultaneously available. if not intervals: return [] # Sort intervals by the start time intervals.sort(key=lambda x: x[0]) # Initialize the common availability window as the first employee's interval common_avail = intervals[0] for interval in intervals[1:]: if interval[0] > common_avail[1] or interval[1] < common_avail[0]: # No overlap return [] else: common_avail[0] = max(common_avail[0], interval[0]) common_avail[1] = min(common_avail[1], interval[1]) return [common_avail]"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Determine if the word can be constructed from a sequence of adjacent cells in the grid. The word can be constructed by moving horizontally or vertically from one cell to another, but the same cell cannot be used more than once in the construction of the word. :param board: List[List[str]] - 2D grid of characters :param word: str - The word to search for :return: bool - True if the word can be formed, otherwise False >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"ABCCED\\") True >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"ABCB\\") False >>> exist([], \\"A\\") False >>> exist([['A','B',], ['C','D']], \\"ABCDABCD\\") False >>> exist([['A']], \\"A\\") True >>> exist([['A','B','C','D']], \\"BCD\\") True >>> exist([['A','B','B','B'], ['A','B','A','A'], ['A','A','A','B']], \\"ABB\\") True","solution":"def exist(board, word): Determine if the word can be constructed from the grid by moving horizontally or vertically. :param board: List[List[str]] - 2D grid of characters :param word: str - The word to search for :return: bool - True if the word can be formed, otherwise False if not board or not word: return False rows, cols = len(board), len(board[0]) def dfs(x, y, index): if index == len(word): return True if x < 0 or y < 0 or x >= rows or y >= cols or board[x][y] != word[index]: return False # Temporarily mark the cell as visited temp, board[x][y] = board[x][y], '#' found = (dfs(x+1, y, index+1) or dfs(x-1, y, index+1) or dfs(x, y+1, index+1) or dfs(x, y-1, index+1)) # Unmark the cell board[x][y] = temp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"class BinaryTree: This class implements a binary tree with the following methods: - __init__() initializes the binary tree with an empty root. - insert(value) inserts a node with the given value into the binary tree maintaining the binary search tree property. - find(value) returns true if there exists a node in the binary tree with the given value, otherwise returns false. - getMaxDepth() returns the maximum depth of the binary tree. def __init__(self): Initialize the binary tree with an empty root. def insert(self, value: int): Insert a node with the given value into the binary tree maintaining the binary search tree property. def find(self, value: int) -> bool: Return True if there exists a node in the binary tree with the given value, otherwise return False. :param value: The value to find in the binary tree. :return: True if the value is found, else False. def getMaxDepth(self) -> int: Return the maximum depth of the binary tree. :return: An integer representing the maximum depth of the binary tree. # Unit tests def test_insert_and_find(): bt = BinaryTree() bt.insert(5) bt.insert(3) bt.insert(7) bt.insert(2) bt.insert(4) bt.insert(6) bt.insert(8) assert bt.find(5) == True assert bt.find(3) == True assert bt.find(7) == True assert bt.find(2) == True assert bt.find(4) == True assert bt.find(6) == True assert bt.find(8) == True assert bt.find(10) == False assert bt.find(0) == False def test_getMaxDepth(): bt = BinaryTree() assert bt.getMaxDepth() == 0 bt.insert(5) assert bt.getMaxDepth() == 1 bt.insert(3) bt.insert(7) assert bt.getMaxDepth() == 2 bt.insert(2) bt.insert(4) bt.insert(6) bt.insert(8) assert bt.getMaxDepth() == 3","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left: self._insert_recursive(node.left, value) else: node.left = Node(value) elif value > node.value: if node.right: self._insert_recursive(node.right, value) else: node.right = Node(value) def find(self, value): return self._find_recursive(self.root, value) def _find_recursive(self, node, value): if node is None: return False if node.value == value: return True elif value < node.value: return self._find_recursive(node.left, value) else: return self._find_recursive(node.right, value) def getMaxDepth(self): return self._get_max_depth(self.root) def _get_max_depth(self, node): if not node: return 0 left_depth = self._get_max_depth(node.left) right_depth = self._get_max_depth(node.right) return max(left_depth, right_depth) + 1"},{"question":"from typing import List def perform_operations(operations: List[str]) -> List[int]: Perform a sequence of stack operations and return the final state of the stack. Each element in the 'operations' array is one of the following strings: - \\"PUSH x\\": Pushes integer 'x' onto the stack - \\"POP\\": Removes the top element of the stack if it is not empty - \\"PUSH_WITH_MIN\\": Pushes the minimum element currently in the stack onto the stack If an operation attempts to \\"POP\\" from an empty stack or \\"PUSH_WITH_MIN\\" when the stack is empty, ignore that operation. >>> perform_operations([\\"PUSH 5\\", \\"PUSH 3\\", \\"PUSH 8\\"]) [5, 3, 8] >>> perform_operations([\\"PUSH 5\\", \\"PUSH 3\\", \\"POP\\"]) [5] >>> perform_operations([\\"PUSH 5\\", \\"PUSH 3\\", \\"PUSH_WITH_MIN\\"]) [5, 3, 3] >>> perform_operations([\\"PUSH 5\\", \\"POP\\", \\"PUSH 3\\", \\"PUSH_WITH_MIN\\", \\"PUSH 8\\"]) [3, 3, 8] >>> perform_operations([\\"POP\\", \\"PUSH_WITH_MIN\\"]) []","solution":"def perform_operations(operations): stack = [] for operation in operations: if operation.startswith(\\"PUSH \\"): _, x = operation.split() stack.append(int(x)) elif operation == \\"POP\\" and stack: stack.pop() elif operation == \\"PUSH_WITH_MIN\\" and stack: stack.append(min(stack)) return stack"},{"question":"def exist(grid: List[List[str]], word: str) -> bool: Given a 2D grid of characters \`grid\` and a string \`word\`, return true if \`word\` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in the word. >>> grid = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']] >>> word = \\"ABCCED\\" >>> exist(grid, word) True >>> word = \\"SEE\\" >>> exist(grid, word) True >>> word = \\"ABCB\\" >>> exist(grid, word) False >>> word = \\"\\" >>> exist(grid, word) True >>> word = \\"A\\" >>> exist(grid, word) True >>> word = \\"XYZ\\" >>> exist(grid, word) False >>> word = \\"ABCCEDABC\\" >>> exist(grid, word) False >>> grid = [['A','B'], ['C','D']] >>> word = \\"ABCD\\" >>> exist(grid, word) False","solution":"def exist(grid, word): rows, cols = len(grid), len(grid[0]) def dfs(r, c, idx): if idx == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[idx]: return False temp = grid[r][c] grid[r][c] = '#' found = (dfs(r + 1, c, idx + 1) or dfs(r - 1, c, idx + 1) or dfs(r, c + 1, idx + 1) or dfs(r, c - 1, idx + 1)) grid[r][c] = temp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"from datetime import datetime from typing import List class EventManager: EventManager to manage events with functionalities to add, remove, check overlaps, and retrieve events by date. >>> em = EventManager() >>> em.addEvent(1, \\"2023-01-01\\", \\"2023-01-05\\") >>> em.isOverlapping(1, 2) False >>> em.getEvents(\\"2023-01-02\\") [1] def __init__(self): Initializes the EventManager object. pass def addEvent(self, eventId: int, startDate: str, endDate: str): Adds an event with the given eventId, startDate, and endDate to the system. pass def removeEvent(self, eventId: int): Removes the event with the given eventId from the system. pass def isOverlapping(self, eventId1: int, eventId2: int) -> bool: Checks if the event with eventId1 overlaps with the event with eventId2. Returns true if they overlap. pass def getEvents(self, date: str) -> List[int]: Returns a list of event IDs that are happening on the given date. If no events are found, returns an empty list. pass import pytest def test_add_and_remove_event(): em = EventManager() em.addEvent(1, \\"2023-01-01\\", \\"2023-01-05\\") assert 1 in em.events em.removeEvent(1) assert 1 not in em.events def test_is_overlapping_true(): em = EventManager() em.addEvent(1, \\"2023-01-01\\", \\"2023-01-05\\") em.addEvent(2, \\"2023-01-03\\", \\"2023-01-07\\") assert em.isOverlapping(1, 2) == True def test_is_overlapping_false(): em = EventManager() em.addEvent(1, \\"2023-01-01\\", \\"2023-01-05\\") em.addEvent(2, \\"2023-01-06\\", \\"2023-01-10\\") assert em.isOverlapping(1, 2) == False def test_get_events(): em = EventManager() em.addEvent(1, \\"2023-01-01\\", \\"2023-01-05\\") em.addEvent(2, \\"2023-01-03\\", \\"2023-01-07\\") em.addEvent(3, \\"2023-01-08\\", \\"2023-01-10\\") assert em.getEvents(\\"2023-01-02\\") == [1] assert em.getEvents(\\"2023-01-04\\") == [1, 2] assert em.getEvents(\\"2023-01-09\\") == [3] assert em.getEvents(\\"2023-01-11\\") == []","solution":"from datetime import datetime class EventManager: def __init__(self): self.events = {} def addEvent(self, eventId, startDate, endDate): start = datetime.strptime(startDate, \\"%Y-%m-%d\\") end = datetime.strptime(endDate, \\"%Y-%m-%d\\") self.events[eventId] = (start, end) def removeEvent(self, eventId): if eventId in self.events: del self.events[eventId] def isOverlapping(self, eventId1, eventId2): if eventId1 not in self.events or eventId2 not in self.events: return False start1, end1 = self.events[eventId1] start2, end2 = self.events[eventId2] return not (end1 < start2 or end2 < start1) def getEvents(self, date): check_date = datetime.strptime(date, \\"%Y-%m-%d\\") return [eventId for eventId, (start, end) in self.events.items() if start <= check_date <= end]"},{"question":"def subarray_sum(nums: List[int], k: int) -> int: Returns the number of unique continuous subarrays that sum to k. :param nums: List[int] - The input array of integers. :param k: int - The target sum. :return: int - The number of unique continuous subarrays that sum to k. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([1, 2, 1, 2, 1], 3) 4 >>> subarray_sum([], 0) 0 >>> subarray_sum([], 1) 0 >>> subarray_sum([1, 2, 3], 7) 0 >>> subarray_sum([1, -1, 1], 2) 0 >>> subarray_sum([-1, -1, 1], -2) 1 >>> subarray_sum([-1, -1, 1, 1], 0) 2 >>> subarray_sum([0, 0, 0, 0], 0) 10 >>> subarray_sum([1, 0, -1, 1], 0) 4","solution":"def subarray_sum(nums, k): Returns the number of unique continuous subarrays that sum to k. :param nums: List[int] - The input array of integers. :param k: int - The target sum. :return: int - The number of unique continuous subarrays that sum to k. count = 0 sum_count = {0: 1} current_sum = 0 for num in nums: current_sum += num if current_sum - k in sum_count: count += sum_count[current_sum - k] if current_sum in sum_count: sum_count[current_sum] += 1 else: sum_count[current_sum] = 1 return count"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, values): Constructs the binary tree from an array of integers (values in level order). Args: values (List[int]): A list of integers representing the values of the tree nodes in level order. Raises: ValueError: If the values list is empty. pass def findMaxDepth(self): Returns the maximum depth of the binary tree. Returns: int: The maximum depth of the tree. >>> tree = BinaryTree([1]) >>> tree.findMaxDepth() 1 >>> tree = BinaryTree([1, 2, 3, 4, 5, None, 7]) >>> tree.findMaxDepth() 3 pass def checkPathSum(self, sum): Returns whether there is a path from the root to a leaf such that the sum of values along the path equals the given sum. Args: sum (int): The target sum to check against. Returns: bool: True if such a path exists, False otherwise. >>> tree = BinaryTree([1, 2, 3, 4, 5, None, 7]) >>> tree.checkPathSum(8) True >>> tree.checkPathSum(5) False pass","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, values): if not values: raise ValueError(\\"Values array must not be empty\\") self.root = self.construct_tree(values) def construct_tree(self, values): nodes = [None if val is None else TreeNode(val) for val in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root def findMaxDepth(self): def max_depth(node): if not node: return 0 left_depth = max_depth(node.left) right_depth = max_depth(node.right) return max(left_depth, right_depth) + 1 return max_depth(self.root) def checkPathSum(self, sum): def has_path_sum(node, current_sum): if not node: return False current_sum += node.value if not node.left and not node.right: return current_sum == sum return has_path_sum(node.left, current_sum) or has_path_sum(node.right, current_sum) return has_path_sum(self.root, 0)"},{"question":"from typing import List def min_workers(tasks: List[List[int]]) -> int: Returns the minimum number of workers required to complete all tasks without any overlap. >>> min_workers([]) 0 >>> min_workers([[1, 2]]) 1 >>> min_workers([[1, 2], [3, 4], [5, 6]]) 1 >>> min_workers([[1, 3], [2, 4], [3, 5]]) 2 >>> min_workers([[1, 4], [2, 5], [3, 6]]) 3 >>> min_workers([[1, 4], [2, 3], [3, 5]]) 2 >>> min_workers([[0, 30], [5, 10], [15, 20]]) 2","solution":"def min_workers(tasks): Returns the minimum number of workers required to complete all tasks without any overlap. if not tasks: return 0 # Sort tasks based on start time tasks.sort(key=lambda x: x[0]) # Use a min heap to track the end time of tasks import heapq end_times = [] # Go through each task for task in tasks: start, end = task # If the earliest ending task ends before the current task start, # they can be assigned to the same worker. if end_times and end_times[0] <= start: heapq.heappop(end_times) # Assign the current task (add its end time to the heap) heapq.heappush(end_times, end) # The heap size will be the number of workers needed return len(end_times)"},{"question":"def min_subarray_xor_odd(nums: List[int]) -> int: Given a 0-indexed integer array nums of length n, divide the array into one or more contiguous subarrays. Each subarray should contain at least one element. For each subarray, if the sum of its elements is even, assign it the value 0. If the sum is odd, assign it the value 1. Return the minimum number of subarrays required such that the XOR of all assigned values is 1. >>> min_subarray_xor_odd([1]) == 1 >>> min_subarray_xor_odd([1, 3, 5]) == 1 >>> min_subarray_xor_odd([2, 4, 6]) == -1 >>> min_subarray_xor_odd([1, 2, 3, 4]) == 1 >>> min_subarray_xor_odd([2]) == -1 >>> min_subarray_xor_odd([]) == -1 >>> min_subarray_xor_odd([2, 2, 3, 2, 2]) == 1","solution":"def min_subarray_xor_odd(nums): Determines the minimum number of subarrays such that the XOR of the sums' parities is 1. Args: nums (list): The list of integers. Returns: int: The minimum number of subarrays. # XOR of parity indicates that we need at least one subarray with odd sum. odd_count = 0 for num in nums: if num % 2 != 0: odd_count += 1 # If there are no odd elements, we cannot achieve an XOR of 1. if odd_count == 0: return -1 # Not possible to have an XOR of 1. # Minimum number of subarrays required is 1 if there is at least one odd element return 1"},{"question":"def count_overflowing_containers(nums: List[int], d: int, threshold: int) -> int: Returns the number of containers that overflow after d days. Parameters: nums (list): List of integer units of water in each container. d (int): Number of days of rain. threshold (int): The threshold units of water for a container to overflow. Returns: int: Number of containers that overflow. >>> count_overflowing_containers([1, 2, 3], 1, 5) 0 >>> count_overflowing_containers([4, 5, 6], 1, 5) 3 >>> count_overflowing_containers([3, 5, 7], 2, 8) 1 >>> count_overflowing_containers([2, 3, 4], 3, 6) 2 >>> count_overflowing_containers([2, 3, 4], 0, 3) 2 >>> count_overflowing_containers([], 5, 7) 0","solution":"def count_overflowing_containers(nums, d, threshold): Returns the number of containers that overflow after d days. Parameters: nums (list): List of integer units of water in each container. d (int): Number of days of rain. threshold (int): The threshold units of water for a container to overflow. Returns: int: Number of containers that overflow. overflow_count = 0 for water in nums: if water + d >= threshold: overflow_count += 1 return overflow_count"},{"question":"def rotateMatrix(matrix): Rotates an n x n 2D matrix by 90 degrees clockwise in-place. Args: matrix: List[List[int]], the 2D matrix to be rotated. Returns: List[List[int]]: The rotated 2D matrix. Examples: >>> rotateMatrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotateMatrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotateMatrix([[1]]) [[1]]","solution":"def rotateMatrix(matrix): Rotates an n x n 2D matrix by 90 degrees clockwise in-place. Args: matrix: List[List[int]], the 2D matrix to be rotated. Returns: List[List[int]]: The rotated 2D matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given a list of integers nums and an integer target, find two distinct indices i and j such that nums[i] and nums[j] add up to target. Return the indices as a list [i, j] in any order. If no such indices exist, return an empty list. >>> two_sum([2, 7, 11, 15], 9) == [0, 1] >>> two_sum([1, 2, 3, 4, 5], 10) == [] >>> two_sum([1, 3, 3, 3, 3], 6) in [[1, 2], [2, 3], [3, 4]]","solution":"def two_sum(nums, target): Finds two distinct indices i and j such that nums[i] + nums[j] == target. :param nums: List of integers. :param target: The target integer. :return: List containing the indices [i, j] or an empty list if no such indices exist. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def palindrome_pairs(words: List[str]) -> List[List[int]]: Given a list of words, find all the pairs of indices (i, j) such that the concatenation of words[i] and words[j] is a palindrome. Return the list of pairs sorted in lexicographical order according to the pair values. >>> palindrome_pairs([\\"bat\\", \\"tab\\", \\"cat\\"]) [[0, 1], [1, 0]] >>> palindrome_pairs([\\"abc\\", \\"def\\", \\"ghi\\"]) [] from typing import List def test_example_case(): words = [\\"bat\\", \\"tab\\", \\"cat\\"] assert palindrome_pairs(words) == [[0, 1], [1, 0]] def test_no_pairs(): words = [\\"abc\\", \\"def\\", \\"ghi\\"] assert palindrome_pairs(words) == [] def test_single_letter_words(): words = [\\"a\\", \\"b\\", \\"c\\"] assert palindrome_pairs(words) == [] def test_multiple_palindrome_pairs(): words = [\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"] assert palindrome_pairs(words) == [[0, 1], [1, 0], [2, 4], [3, 2]] def test_empty_and_single_word(): words = [\\"\\"] assert palindrome_pairs(words) == [] def test_palindrome_and_empty(): words = [\\"\\", \\"a\\"] assert palindrome_pairs(words) == [[0, 1], [1, 0]] def test_all_palindromes(): words = [\\"a\\", \\"b\\", \\"c\\"] assert palindrome_pairs(words) == []","solution":"def is_palindrome(word): Checks if a given word is a palindrome. return word == word[::-1] def palindrome_pairs(words): Finds all pairs of indices (i, j) such that the concatenation of words[i] and words[j] is a palindrome. Returns the list of pairs sorted in lexicographical order according to the pair values. pairs = [] for i in range(len(words)): for j in range(len(words)): if i != j: combined = words[i] + words[j] if is_palindrome(combined): pairs.append([i, j]) pairs.sort() return pairs"},{"question":"def k_sum(nums: List[int], k: int) -> int: Returns the k-sum of the array \`nums\`. >>> k_sum([1, 2, 3, 4, 5], 1) # 15 Sum all elements >>> k_sum([1, 2, 3, 4, 5], 2) # 9 Sum = 1+3+5 >>> k_sum([1, 2, 3, 4, 5], 3) # 5 Sum = 1+4","solution":"def k_sum(nums, k): Returns the k-sum of the array \`nums\`. Parameters: nums (list): A list of non-negative integers. k (int): The step value. Returns: int: The k-sum value. if k <= 0: return 0 n = len(nums) k_sum_value = 0 for i in range(0, n, k): k_sum_value += nums[i] return k_sum_value"},{"question":"def count_distinct_subarrays(nums: List[int], k: int) -> int: Returns the number of distinct subarrays of length exactly k in nums. Each element in the subarray must appear exactly once. >>> count_distinct_subarrays([1, 2], 3) 0 >>> count_distinct_subarrays([1, 2, 3, 4], 3) 2 >>> count_distinct_subarrays([1, 1, 1, 1], 2) 0 >>> count_distinct_subarrays([1, 2, 2, 3, 4], 2) 3 >>> count_distinct_subarrays([1, 2, 3, 4], 1) 4","solution":"def count_distinct_subarrays(nums, k): Returns the number of distinct subarrays of length exactly k in nums. Each element in the subarray must appear exactly once. if k > len(nums): return 0 distinct_subarray_count = 0 for i in range(len(nums) - k + 1): subarray = nums[i:i + k] if len(subarray) == len(set(subarray)): distinct_subarray_count += 1 return distinct_subarray_count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n: int) -> List[TreeNode]: Given an integer \`n\`, return a list of all possible unique binary trees with exactly \`n\` nodes where each node has a unique value from \`1\` to \`n\`. Each binary tree is represented by a root node of type \`TreeNode\`. >>> def tree_to_str(root): ... if not root: ... return \\"null\\" ... return f\\"{root.val}({tree_to_str(root.left)},{tree_to_str(root.right)})\\" >>> tree_to_str(generateTrees(1)[0]) == \\"1(null,null)\\" True >>> expected = [ ... \\"1(null,2(null,3(null,null)))\\", ... \\"1(null,3(2(null,null),null))\\", ... \\"2(1(null,null),3(null,null))\\", ... \\"3(1(null,2(null,null)),null)\\", ... \\"3(2(1(null,null),null),null)\\" ... ] >>> result = [tree_to_str(tree) for tree in generateTrees(3)] >>> len(result) == 5 True >>> all(tree in result for tree in expected) True","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n: int) -> List[TreeNode]: if n == 0: return [] def generate_trees(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): # Generate all left and right subtrees recursively left_trees = generate_trees(start, i - 1) right_trees = generate_trees(i + 1, end) # Connect left and right subtrees to the root \`i\` for left in left_trees: for right in right_trees: current_tree = TreeNode(i) current_tree.left = left current_tree.right = right all_trees.append(current_tree) return all_trees return generate_trees(1, n)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\\") == 62 >>> length_of_longest_substring(\\"abcabcabcd\\") == 4 >>> length_of_longest_substring(\\"!@#%^&*()\\") == 7","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def isRotation(s1: str, s2: str) -> bool: Check if one string is a rotation of another. >>> isRotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> isRotation(\\"hello\\", \\"lohel\\") True >>> isRotation(\\"hello\\", \\"world\\") False from solution import isRotation def test_is_rotation_positive(): assert isRotation(\\"waterbottle\\", \\"erbottlewat\\") == True assert isRotation(\\"hello\\", \\"lohel\\") == True def test_is_rotation_negative(): assert isRotation(\\"hello\\", \\"world\\") == False assert isRotation(\\"abcd\\", \\"dabc\\") == True assert isRotation(\\"abc\\", \\"cab\\") == True def test_is_rotation_different_lengths(): assert isRotation(\\"hello\\", \\"hellohello\\") == False assert isRotation(\\"test\\", \\"tests\\") == False def test_is_rotation_empty_strings(): assert isRotation(\\"\\", \\"\\") == True assert isRotation(\\"a\\", \\"\\") == False assert isRotation(\\"\\", \\"a\\") == False","solution":"def isRotation(s1, s2): Returns true if s2 is a rotation of s1, false otherwise. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"class NumMatrix: def __init__(self, matrix): Initializes the NumMatrix object with the matrix, and preprocesses it to compute the prefix sum for efficient submatrix sum queries. # Your code here def sumRegion(self, row1, col1, row2, col2): Returns the sum of the elements within the rectangle defined by (row1, col1) and (row2, col2), inclusive. # Your code here # Unit Tests def test_num_matrix_1(): matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] numMatrix = NumMatrix(matrix) assert numMatrix.sumRegion(2, 1, 4, 3) == 8 # Elements are [2, 0, 1, 0, 1, 0] assert numMatrix.sumRegion(1, 1, 2, 2) == 11 # Elements are [6, 3, 2, 0] assert numMatrix.sumRegion(1, 2, 2, 4) == 12 # Elements are [3, 2, 1, 0, 1, 5] def test_num_matrix_2(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] numMatrix = NumMatrix(matrix) assert numMatrix.sumRegion(0, 0, 1, 1) == 12 # Elements are [1, 2, 4, 5] assert numMatrix.sumRegion(1, 1, 2, 2) == 28 # Elements are [5, 6, 8, 9] assert numMatrix.sumRegion(0, 0, 2, 2) == 45 # Elements are [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_num_matrix_empty(): matrix = [] numMatrix = NumMatrix(matrix) assert numMatrix.prefixSum == []","solution":"class NumMatrix: def __init__(self, matrix): Initializes the NumMatrix object with the matrix, and preprocesses it to compute the prefix sum for efficient submatrix sum queries. if not matrix or not matrix[0]: self.prefixSum = [] return m, n = len(matrix), len(matrix[0]) self.prefixSum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): self.prefixSum[i + 1][j + 1] = matrix[i][j] + self.prefixSum[i + 1][j] + self.prefixSum[i][j + 1] - self.prefixSum[i][j] def sumRegion(self, row1, col1, row2, col2): Returns the sum of the elements within the rectangle defined by (row1, col1) and (row2, col2), inclusive. return self.prefixSum[row2 + 1][col2 + 1] - self.prefixSum[row1][col2 + 1] - self.prefixSum[row2 + 1][col1] + self.prefixSum[row1][col1]"},{"question":"from typing import List, Tuple def find_word(grid: List[List[str]], word: str) -> List[Tuple[int, int]]: Find all occurrences of the word in the grid where the word can be constructed from letters of sequentially adjacent cells, horizontally or vertically. The same letter cell may not be used more than once in constructing the word. >>> find_word([ ... ['C', 'A', 'T'], ... ['A', 'G', 'T'], ... ['T', 'G', 'A'] ... ], \\"CAT\\") [(0, 0)] >>> find_word([ ... ['C', 'A', 'T'], ... ['A', 'C', 'A'], ... ['T', 'A', 'T'] ... ], \\"CAT\\") [(0, 0), (1, 1)] >>> find_word([ ... ['C', 'A', 'T'], ... ['A', 'G', 'T'], ... ['T', 'G', 'A'] ... ], \\"DOG\\") [] >>> find_word([ ... ['C', 'A', 'T'], ... ['A', 'C', 'A'], ... ['T', 'A', 'T'] ... ], \\"CAA\\") [] >>> find_word([ ... ['C', 'A', 'A', 'A'], ... ['C', 'A', 'T', 'A'], ... ['T', 'G', 'A', 'A'], ... ['C', 'A', 'T', 'A'] ... ], \\"CAT\\") [(1, 0), (3, 0)]","solution":"def find_word(grid, word): def dfs(x, y, word_index): if word_index == len(word): return True if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != word[word_index]: return False temp, grid[x][y] = grid[x][y], \\"#\\" found = dfs(x+1, y, word_index+1) or dfs(x-1, y, word_index+1) or dfs(x, y+1, word_index+1) or dfs(x, y-1, word_index+1) grid[x][y] = temp return found rows, cols = len(grid), len(grid[0]) starting_positions = [] for i in range(rows): for j in range(cols): if grid[i][j] == word[0] and dfs(i, j, 0): starting_positions.append((i, j)) return starting_positions"},{"question":"from typing import List def maximum_score(s: str) -> int: Returns the maximum score that can be achieved by deleting characters from \`s\`. The score is defined as the total number of substrings that contain only the character 'a'. >>> maximum_score(\\"bbbbc\\") 0 >>> maximum_score(\\"aaa\\") 6 >>> maximum_score(\\"abcabcabc\\") 6 >>> maximum_score(\\"bcbcbcbca\\") 1 >>> maximum_score(\\"abcbcbc\\") 1 >>> maximum_score(\\"bcbcbca\\") 1 >>> maximum_score(\\"aaaaaaaa\\") 36","solution":"def maximum_score(s): Returns the maximum score that can be achieved by deleting characters from s. The score is defined as the total number of substrings that contain only the character 'a'. # The maximum score is achieved by retaining all 'a's in the string # as every substring with 'a' adds to the score. # The score for 'a's is the sum of the first k natural numbers where k is the count of 'a's in the substring. # This is calculated by k*(k+1)//2. a_count = s.count('a') return a_count * (a_count + 1) // 2"},{"question":"def largestRectangleArea(rectangles: List[int]) -> int: Find the largest rectangle that can be formed by combining consecutive rectangles. :param rectangles: List[int] - A list of integers where rectangles[i] represents the width of a rectangle with height 1. :return: int - The area of the largest rectangle that can be formed. >>> largestRectangleArea([2]) 2 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([4, 4, 4, 4]) 16 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> largestRectangleArea([]) 0","solution":"def largestRectangleArea(rectangles): Find the largest rectangle that can be formed by combining consecutive rectangles. :param rectangles: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(rectangles): if not stack or rectangles[index] >= rectangles[stack[-1]]: stack.append(index) index += 1 else: height = rectangles[stack.pop()] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) while stack: height = rectangles[stack.pop()] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"def replace_words(text: str, substitutions: List[List[str]]) -> str: Replaces words in the given text according to the substitutions list. :param text: The input string where words need to be replaced. :param substitutions: A 2D list containing lists of two strings [old_word, new_word]. :return: The modified text after all replacements. >>> replace_words(\\"the quick brown fox jumps over the lazy dog\\", [[\\"quick\\", \\"slow\\"], [\\"fox\\", \\"cat\\"], [\\"lazy\\", \\"energetic\\"]]) 'the slow brown cat jumps over the energetic dog' >>> replace_words(\\"the quick brown fox jumps over the lazy dog\\", []) 'the quick brown fox jumps over the lazy dog' >>> replace_words(\\"the quick brown fox jumps quickly over the quick lazy fox\\", [[\\"quick\\", \\"slow\\"], [\\"fox\\", \\"cat\\"], [\\"lazy\\", \\"energetic\\"]]) 'the slow brown cat jumps slowly over the slow energetic cat' >>> replace_words(\\"quickquick brown fox jumps over the lazyquick dog\\", [[\\"quick\\", \\"slow\\"]]) 'slowslow brown fox jumps over the lazyslow dog' >>> replace_words(\\"Quick brown fox jumps over the quick Lazy dog\\", [[\\"quick\\", \\"slow\\"], [\\"Lazy\\", \\"Active\\"]]) 'Quick brown fox jumps over the slow Active dog'","solution":"def replace_words(text, substitutions): Replaces words in the given text according to the substitutions list. :param text: The input string where words need to be replaced. :param substitutions: A 2D list containing lists of two strings [old_word, new_word]. :return: The modified text after all replacements. for old_word, new_word in substitutions: text = text.replace(old_word, new_word) return text"},{"question":"def buildings_with_view(heights): Returns a list of indices of buildings that have an excellent view of the ocean. The ocean is to the east, meaning to the right of all buildings. A building has an excellent view if there are no taller buildings between it and the ocean. Args: heights (list of int): List of building heights Returns: list of int: List of indices of buildings with an excellent view pass # Unit Tests def test_buildings_with_view_single_building(): assert buildings_with_view([5]) == [0] def test_buildings_with_view_increasing_heights(): assert buildings_with_view([1, 2, 3, 4, 5]) == [4] def test_buildings_with_view_decreasing_heights(): assert buildings_with_view([5, 4, 3, 2, 1]) == [0, 1, 2, 3, 4] def test_buildings_with_view_mixed_heights(): assert buildings_with_view([4, 2, 3, 1]) == [0, 2, 3] def test_buildings_with_view_same_heights(): assert buildings_with_view([3, 3, 3, 3]) == [3] def test_buildings_with_view_empty_list(): assert buildings_with_view([]) == [] def test_buildings_with_view_peak_in_middle(): assert buildings_with_view([1, 3, 2, 4, 2]) == [3, 4]","solution":"def buildings_with_view(heights): Returns a list of indices of buildings that have an excellent view of the ocean. The ocean is to the east, meaning to the right of all buildings. A building has an excellent view if there are no taller buildings between it and the ocean. Args: heights (list of int): List of building heights Returns: list of int: List of indices of buildings with an excellent view n = len(heights) result = [] if n == 0: return result max_height = -1 for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1] # reverse to get ascending order of indices"},{"question":"def merge_arrays(nums1: List[int], nums2: List[int]) -> List[int]: Merges two arrays, maintaining their original order and ensuring unique elements. If an element appears in both arrays, it is included once in the result based on its first occurrence in nums1 followed by nums2. >>> merge_arrays([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_arrays([1, 3, 2], [3, 4, 5]) == [1, 3, 2, 4, 5] >>> merge_arrays([1, 2, 3], [1, 2, 3]) == [1, 2, 3] >>> merge_arrays([], [1, 2, 3]) == [1, 2, 3] >>> merge_arrays([1, 2, 3], []) == [1, 2, 3] >>> merge_arrays([], []) == [] >>> merge_arrays([1, 3, 2, 4], [3, 5, 6]) == [1, 3, 2, 4, 5, 6]","solution":"def merge_arrays(nums1, nums2): Merges two arrays, maintaining their original order and ensuring unique elements. If an element appears in both arrays, it is included once in the result based on its first occurrence in nums1 followed by nums2. merged = [] seen = set() for num in nums1 + nums2: if num not in seen: merged.append(num) seen.add(num) return merged"},{"question":"from typing import List def min_trips(weights: List[int], limit: int) -> int: Returns the minimum number of trips required to deliver parcels given weight limit per trip. >>> min_trips([4], 5) 1 >>> min_trips([5, 5, 5, 5], 5) 4 >>> min_trips([2, 2, 3], 5) 2 >>> min_trips([1, 2, 3, 4, 5], 5) 3 >>> min_trips([3, 8, 2, 1, 7], 10) 3 >>> min_trips([], 10) 0 >>> min_trips([2, 2, 2, 2, 2], 4) 3","solution":"def min_trips(weights, limit): Returns the minimum number of trips required to deliver parcels given weight limit per trip. weights.sort() i, j = 0, len(weights) - 1 trips = 0 while i <= j: if weights[j] + (weights[i] if i != j else 0) <= limit: i += 1 j -= 1 trips += 1 return trips"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Determines if there is a path in the board that spells out the given word. >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"ABCCED\\") True >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"SEE\\") True >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"ABCB\\") False >>> exist([], \\"ANY\\") False >>> exist([['A']], \\"A\\") True >>> exist([['A']], \\"B\\") False >>> exist([['A', 'B'], ['C', 'D']], \\"ABCDE\\") False","solution":"def exist(board, word): Determines if there is a path in the board that spells out the given word. :param board: List[List[str]], the board of characters :param word: str, the word to look for in the board :return: bool, True if there is a path that spells out the word, False otherwise if not board or not board[0]: return False rows, cols = len(board), len(board[0]) def dfs(x, y, index): if index == len(word): return True if x < 0 or x >= rows or y < 0 or y >= cols or board[x][y] != word[index]: return False temp = board[x][y] board[x][y] = '#' found = (dfs(x + 1, y, index + 1) or dfs(x - 1, y, index + 1) or dfs(x, y + 1, index + 1) or dfs(x, y - 1, index + 1)) board[x][y] = temp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"def min_operations_to_equal_height(nums: List[int]) -> int: Returns the minimum number of operations needed to make all heights of the trees equal. The operation allowed is incrementing the height of a tree by 1. :param nums: List[int] - Heights of the trees :return: int - Minimum number of operations >>> min_operations_to_equal_height([3, 3, 3]) 0 >>> min_operations_to_equal_height([1, 2, 3]) 3 >>> min_operations_to_equal_height([4, 1, 4]) 3 >>> min_operations_to_equal_height([1, 2, 2, 1]) 2 >>> min_operations_to_equal_height([0, -1, -2]) 3 >>> min_operations_to_equal_height([1000000, 999999, 1000000]) 1","solution":"def min_operations_to_equal_height(nums): Returns the minimum number of operations needed to make all heights of the trees equal. The operation allowed is incrementing the height of a tree by 1. :param nums: List[int] - Heights of the trees :return: int - Minimum number of operations max_height = max(nums) operations = 0 for height in nums: operations += max_height - height return operations"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class SumRangeTree: def __init__(self, root: TreeNode): Initializes the SumRangeTree object with the binary tree's root node. def update(self, index: int, value: int) -> None: Updates the value of the node at the given index to the new value. Each node is indexed using a level-order traversal. def sumRange(self, left: int, right: int) -> int: Returns the sum of values of all nodes between the indices left and right inclusive, based on a level-order traversal. # Test the SumRangeTree class from solution import TreeNode, SumRangeTree def test_sum_range_tree(): # Create the binary tree [1, 2, 3, 4, 5, 6, 7] root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) # Initialize SumRangeTree srt = SumRangeTree(root) # Test sumRange assert srt.sumRange(0, 3) == 10 # Node values: 1 + 2 + 3 + 4 = 10 assert srt.sumRange(2, 5) == 18 # Node values: 3 + 4 + 5 + 6 = 18 # Test update srt.update(4, 10) # Change node value from 5 to 10 # Test sumRange after update assert srt.sumRange(2, 5) == 23 # Node values: 3 + 4 + 10 + 6 = 23 # Test invalid index range with pytest.raises(IndexError): srt.sumRange(-1, 2) with pytest.raises(IndexError): srt.sumRange(1, 8) with pytest.raises(IndexError): srt.update(10, 5) def test_empty_tree(): # Test an empty tree root = TreeNode() srt = SumRangeTree(root) assert srt.sumRange(0, 0) == 0 # Only one node with value 0 srt.update(0, 5) assert srt.sumRange(0, 0) == 5 # Updated node value to 5","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class SumRangeTree: def __init__(self, root): self.root = root self.nodes = [] self.level_order_traversal() def level_order_traversal(self): from collections import deque queue = deque([self.root]) self.nodes = [] while queue: curr = queue.popleft() self.nodes.append(curr) if curr.left: queue.append(curr.left) if curr.right: queue.append(curr.right) def update(self, index, value): if index < 0 or index >= len(self.nodes): raise IndexError(\\"Index out of range\\") self.nodes[index].val = value def sumRange(self, left, right): if left < 0 or right >= len(self.nodes) or left > right: raise IndexError(\\"Index range invalid\\") total = 0 for i in range(left, right + 1): total += self.nodes[i].val return total"},{"question":"class Node: def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None): self.val = val self.left = left self.right = right self.next = next def connect(root: 'Optional[Node]') -> 'Optional[Node]': Connect the nodes of a perfect binary tree such that each node's next pointer points to its next right node. Return the root of the updated tree. >>> node4 = Node(4) >>> node5 = Node(5) >>> node6 = Node(6) >>> node7 = Node(7) >>> node2 = Node(2, node4, node5) >>> node3 = Node(3, node6, node7) >>> root = Node(1, node2, node3) >>> connect(root) >>> root.left.next == root.right True >>> node2.next == node3 True >>> node4.next == node5 True >>> node5.next == node6 True >>> node6.next == node7 True","solution":"class Node: def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None): self.val = val self.left = left self.right = right self.next = next def connect(root: 'Node') -> 'Node': if not root: return root current_level_start = root while current_level_start: current = current_level_start next_level_start = None previous = None while current: if current.left: if previous: previous.next = current.left else: next_level_start = current.left previous = current.left if current.right: if previous: previous.next = current.right else: next_level_start = current.right previous = current.right current = current.next current_level_start = next_level_start return root"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_odd_level_node_depth(root: TreeNode) -> int: Returns the depth of the deepest odd-level node in the binary tree. The root is considered level 1. If there are no odd-level nodes, return -1. >>> deepest_odd_level_node_depth(TreeNode(1)) == 1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> deepest_odd_level_node_depth(root) == 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> root.left.left.left.left = TreeNode(5) >>> deepest_odd_level_node_depth(root) == 5 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> root.right.right.right.right = TreeNode(5) >>> deepest_odd_level_node_depth(root) == 5 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> root.left.left.left = TreeNode(8) >>> deepest_odd_level_node_depth(root) == 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_odd_level_node_depth(root): if not root: return -1 queue = [(root, 1)] # (node, level) max_depth = -1 while queue: node, level = queue.pop(0) if level % 2 != 0: max_depth = max(max_depth, level) if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return max_depth"},{"question":"def min_deletions_to_palindrome(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, determine the minimum number of deletions required to make \`s\` a palindrome. >>> min_deletions_to_palindrome(\\"aebcbda\\") 2 >>> min_deletions_to_palindrome(\\"racecar\\") 0 >>> min_deletions_to_palindrome(\\"ab\\") 1 >>> min_deletions_to_palindrome(\\"abcdef\\") 5 >>> min_deletions_to_palindrome(\\"aaa\\") 0","solution":"def min_deletions_to_palindrome(s): Returns the minimum number of deletions required to make the input string a palindrome. def longest_palindromic_subsequence(seq): n = len(seq) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if seq[i] == seq[j] and cl == 2: dp[i][j] = 2 elif seq[i] == seq[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] lps_length = longest_palindromic_subsequence(s) return len(s) - lps_length"},{"question":"def min_distance(s: str, t: str) -> int: Returns the minimum number of operations required to convert string s into string t. Allowed operations are insert, delete, or replace a character. >>> min_distance(\\"abc\\", \\"abc\\") == 0 >>> min_distance(\\"abc\\", \\"abcd\\") == 1 >>> min_distance(\\"abcd\\", \\"abc\\") == 1 >>> min_distance(\\"abc\\", \\"abd\\") == 1 >>> min_distance(\\"intention\\", \\"execution\\") == 5 >>> min_distance(\\"\\", \\"\\") == 0 >>> min_distance(\\"\\", \\"abc\\") == 3 >>> min_distance(\\"abc\\", \\"\\") == 3","solution":"def min_distance(s, t): Returns the minimum number of operations required to convert string s into string t. Allowed operations are insert, delete, or replace a character. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s is empty, you need to insert all characters of t elif j == 0: dp[i][j] = i # If t is empty, you need to delete all characters of s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def max_ratings_under_budget(t: int, test_cases: List[Tuple[int, List[int], List[int], int]]) -> List[int]: For each test case, determine the maximum sum of ratings achievable while keeping the sum of the prices under a given budget. :param t: Number of test cases. :param test_cases: List of test case tuples. Each tuple contains (n, ratings, prices, k). n - Number of books. ratings - List of integer ratings for the books. prices - List of integer prices for the books. k - Budget. :return: List of maximum sum of ratings for each test case. from solution import max_ratings_under_budget def test_single_case_exact_budget(): assert max_ratings_under_budget(1, [(3, [60, 100, 120], [10, 20, 30], 50)]) == [220] def test_single_case_insufficient_budget(): assert max_ratings_under_budget(1, [(3, [60, 100, 120], [10, 20, 30], 5)]) == [0] def test_single_case_large_budget(): assert max_ratings_under_budget(1, [(3, [60, 100, 120], [10, 20, 30], 60)]) == [280] def test_multiple_cases(): assert max_ratings_under_budget(2, [ (3, [60, 100, 120], [10, 20, 30], 50), (4, [20, 40, 60, 80], [5, 10, 15, 20], 35) ]) == [220, 140] def test_case_no_books(): assert max_ratings_under_budget(1, [(0, [], [], 50)]) == [0] def test_case_budget_zero(): assert max_ratings_under_budget(1, [(3, [60, 100, 120], [10, 20, 30], 0)]) == [0] def test_case_with_single_book(): assert max_ratings_under_budget(1, [(1, [60], [10], 15)]) == [60] def test_case_with_books_exceeding_budget(): assert max_ratings_under_budget(1, [(2, [30, 40], [40, 50], 35)]) == [0] def test_case_with_edge_values(): assert max_ratings_under_budget(1, [(2, [1, 2], [1, 2], 1)]) == [1]","solution":"def max_ratings_under_budget(t, test_cases): For each test case, determine the maximum sum of ratings achievable while keeping the sum of the prices under a given budget. :param t: Number of test cases. :param test_cases: List of test case tuples. Each tuple contains (n, ratings, prices, k). n - Number of books. ratings - List of integer ratings for the books. prices - List of integer prices for the books. k - Budget. :return: List of maximum sum of ratings for each test case. results = [] for case in test_cases: n, ratings, prices, k = case dp = [0] * (k + 1) for i in range(n): for j in range(k, prices[i] - 1, -1): dp[j] = max(dp[j], dp[j - prices[i]] + ratings[i]) results.append(dp[k]) return results"},{"question":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string containing digits from '2' to '9', return all possible letter combinations that the numbers could represent on a telephone keypad. >>> letter_combinations(\\"\\") == [] >>> sorted(letter_combinations(\\"2\\")) == sorted([\\"a\\", \\"b\\", \\"c\\"]) >>> sorted(letter_combinations(\\"23\\")) == sorted([\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"]) >>> sorted(letter_combinations(\\"234\\")) == sorted([ \\"adg\\", \\"adh\\", \\"adi\\", \\"aeg\\", \\"aeh\\", \\"aei\\", \\"afg\\", \\"afh\\", \\"afi\\", \\"bdg\\", \\"bdh\\", \\"bdi\\", \\"beg\\", \\"beh\\", \\"bei\\", \\"bfg\\", \\"bfh\\", \\"bfi\\", \\"cdg\\", \\"cdh\\", \\"cdi\\", \\"ceg\\", \\"ceh\\", \\"cei\\", \\"cfg\\", \\"cfh\\", \\"cfi\\" ]) >>> sorted(letter_combinations(\\"79\\")) == sorted([ \\"pw\\", \\"px\\", \\"py\\", \\"pz\\", \\"qw\\", \\"qx\\", \\"qy\\", \\"qz\\", \\"rw\\", \\"rx\\", \\"ry\\", \\"rz\\", \\"sw\\", \\"sx\\", \\"sy\\", \\"sz\\" ])","solution":"def letter_combinations(digits): Given a string containing digits from '2' to '9', return all possible letter combinations that the numbers could represent on a telephone keypad. if not digits: return [] phone_mapping = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } # Helper function to perform backtracking def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_mapping[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def max_sum_divisible_subarray(arr, d): Returns the maximum sum of any non-empty subarray of \`arr\` such that the sum of every pair of consecutive elements in the subarray is divisible by \`d\`. If no such subarray exists, returns 0. Parameters: arr (list): List of integers. d (int): Integer divisor. Returns: int: Maximum possible sum of the subarray. >>> max_sum_divisible_subarray([2, -3, 1, 2, -1, 6], 2) == 8 >>> max_sum_divisible_subarray([4, 8, 6, 2], 2) == 20 >>> max_sum_divisible_subarray([1, 3, 5, 7], 2) == 0 >>> max_sum_divisible_subarray([5, 10, 15, -5, 10], 5) == 35 >>> max_sum_divisible_subarray([4], 2) == 4 >>> max_sum_divisible_subarray([-3, -6, -9], 3) == -3","solution":"def max_sum_divisible_subarray(arr, d): Returns the maximum sum of any non-empty subarray of \`arr\` such that the sum of every pair of consecutive elements in the subarray is divisible by \`d\`. If no such subarray exists, returns 0. Parameters: arr (list): List of integers. d (int): Integer divisor. Returns: int: Maximum possible sum of the subarray. max_sum = float('-inf') current_sum = 0 found_valid_subarray = False for i in range(len(arr)): current_sum = arr[i] potential_max_sum = current_sum if current_sum % d == 0: max_sum = max(max_sum, current_sum) found_valid_subarray = True for j in range(i + 1, len(arr)): current_sum += arr[j] if arr[j] % d == 0: potential_max_sum = max(potential_max_sum, current_sum) max_sum = max(max_sum, potential_max_sum) found_valid_subarray = True if potential_max_sum % d == 0: max_sum = max(max_sum, potential_max_sum) found_valid_subarray = True return max_sum if found_valid_subarray else 0"},{"question":"def generate_spiral_matrix(m: int, n: int) -> List[List[int]]: Generate an m x n matrix filled with elements from 1 to m * n in spiral order. >>> generate_spiral_matrix(3, 3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4, 4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(4, 3) [[1, 2, 3], [10, 11, 17, where Delta^i_n :=f(x_i )-f(xi_i ){x_{i+1} -x_i +x_i -xi_i}, âˆ‘Ni i=1 fi (x)+hO h as well as -sum_{i=1}^n f_i-1(x_{i})(arctan(frac{zx_j- h}{2L_i})-frac{pi}{2}) By applying the definitions we get f(k)(x). In some rare situations, you'll run into problem with the roots around Re(z)=1, where the reflection fails by a factor of Ï€ *Practical* Euler's Formula: e^{ix} = cos(x) + i * sin(x) is the polar form of exponential family of complex numbers. According to <https://www.mathinary.com/even>, You may need to scale some factors as strait_i Finally the output is in the polar form. Test Cases: def test_generate_spiral_matrix(): assert generate_spiral_matrix(3, 3) == [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] assert generate_spiral_matrix(4, 4) == [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] assert generate_spiral_matrix(4, 3) == [ [1, 2, 3], [10, 11, 4], [9, 12, 5], [8, 7, 6] ] assert generate_spiral_matrix(1, 1) == [[1]] assert generate_spiral_matrix(2, 2) == [ [1, 2], [4, 3] ]","solution":"def generate_spiral_matrix(m, n): Generate an m x n matrix filled with elements from 1 to m*n in spiral order. :param m: Number of rows (1 â‰¤ m â‰¤ 9) :param n: Number of columns (1 â‰¤ n â‰¤ 9) :return: The generated spiral matrix matrix = [[0] * n for _ in range(m)] left, right, top, bottom = 0, n - 1, 0, m - 1 num = 1 while left <= right and top <= bottom: # Traverse from left to right for j in range(left, right + 1): matrix[top][j] = num num += 1 top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Traverse from right to left if top <= bottom: for j in range(right, left - 1, -1): matrix[bottom][j] = num num += 1 bottom -= 1 # Traverse from bottom to top if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. Args: s : str : input string Returns: int : length of the longest substring with only unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"\\") == 0","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. Args: s : str : input string Returns: int : length of the longest substring with only unique characters char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def can_make_arithmetic_progression(arr: List[int]) -> bool: Determines if the array can be rearranged to form an arithmetic progression. >>> can_make_arithmetic_progression([3, 5, 1]) True >>> can_make_arithmetic_progression([1, 2, 4]) False >>> can_make_arithmetic_progression([1]) True >>> can_make_arithmetic_progression([]) True >>> can_make_arithmetic_progression([10, 0, 5, 15]) True","solution":"def can_make_arithmetic_progression(arr): Determines if the array can be rearranged to form an arithmetic progression. Parameters: arr (list of int): The input array of integers. Returns: bool: True if the array can be rearranged to form an arithmetic progression, False otherwise. if len(arr) < 2: return True arr.sort() diff = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i - 1] != diff: return False return True"},{"question":"def first_repeated_letter(s: str) -> str: Given a string \`s\` consisting of lowercase English letters, find the first letter that appears twice. Return the letter as a string. If no letter appears twice, return an empty string. >>> first_repeated_letter(\\"abca\\") == \\"a\\" >>> first_repeated_letter(\\"abcdefg\\") == \\"\\" >>> first_repeated_letter(\\"aabbcc\\") == \\"a\\" >>> first_repeated_letter(\\"abcdeabcde\\") == \\"a\\" >>> first_repeated_letter(\\"xxyyzz\\") == \\"x\\" >>> first_repeated_letter(\\"xyzxy\\") == \\"x\\" >>> first_repeated_letter(\\"\\") == \\"\\" >>> first_repeated_letter(\\"a\\") == \\"\\" >>> first_repeated_letter(\\"aa\\") == \\"a\\"","solution":"def first_repeated_letter(s): Returns the first letter that appears twice in the string, or an empty string if no letter appears twice. :param s: str - The input string with lowercase English letters. :return: str - The first letter that appears twice or an empty string. seen = set() for char in s: if char in seen: return char seen.add(char) return \\"\\""},{"question":"def has_sublist_with_sum(nums: List[int], k: int, target: int) -> bool: Determine if there exists a sublist of exactly k distinct integers where the sum of that sublist is equal to a given integer target. >>> has_sublist_with_sum([1, 2, 3, 4, 5], 3, 9) True >>> has_sublist_with_sum([1, 2, 3, 4, 5], 3, 10) False >>> has_sublist_with_sum([1, 2], 2, 3) True >>> has_sublist_with_sum([1, 1, 1, 1, 1], 2, 2) False >>> has_sublist_with_sum([0, 0, 0, 0, 0], 3, 0) False >>> has_sublist_with_sum([1000, -1000, 2000, -1000, 1000], 3, 2000) True >>> has_sublist_with_sum([1, 2, 3], 3, 6) True","solution":"def has_sublist_with_sum(nums, k, target): from itertools import combinations n = len(nums) for i in range(n - k + 1): sublist = nums[i:i + k] if len(set(sublist)) == k and sum(sublist) == target: return True return False"},{"question":"def zigzag_heights(heights: List[int]) -> List[int]: Rearranges the given list of heights into a zigzag pattern. Heights are adjusted so each person's height is greater than or equal to the height of the next person if their position is even, and less than or equal to the height of the next person if their position is odd. >>> zigzag_heights([1, 2, 3]) [2, 1, 3] >>> zigzag_heights([4, 3, 2, 1]) [4, 2, 3, 1] >>> zigzag_heights([7, 6, 5, 4, 3]) [7, 5, 6, 3, 4] >>> zigzag_heights([1, 2, 3, 4, 5]) [2, 1, 4, 3, 5] >>> zigzag_heights([5, 4, 3, 2, 1]) [5, 3, 4, 1, 2]","solution":"def zigzag_heights(heights): Rearranges the given list of heights into a zigzag pattern. Heights are adjusted so each person's height is greater than or equal to the height of the next person if their position is even, and less than or equal to the height of the next person if their position is odd. n = len(heights) for i in range(n-1): if i % 2 == 0: if heights[i] < heights[i+1]: heights[i], heights[i+1] = heights[i+1], heights[i] else: if heights[i] > heights[i+1]: heights[i], heights[i+1] = heights[i+1], heights[i] return heights"},{"question":"def split_array_minimize_mean_difference(A: List[int]) -> List[List[int]]: Given an integer array A of size n, split this array into two groups, B and C, such that the sum of the absolute differences of the means of the groups is minimized. Args: A (List[int]): An array of integers to be split. Returns: List[List[int]]: A pair of arrays [B, C] that minimize the absolute difference of their means. Example: >>> split_array_minimize_mean_difference([1, 2, 3, 4, 5]) [[1, 2, 3], [4, 5]] or [[1, 2], [3, 4, 5]] >>> split_array_minimize_mean_difference([10, 20, 30, 40, 50, 60]) [[10, 20, 30], [40, 50, 60]] or [[10, 20, 30, 40], [50, 60]]","solution":"def split_array_minimize_mean_difference(A): # Sort the array to facilitate splitting into balanced groups A.sort() n = len(A) # Splitting the array into two roughly equal parts mid = n // 2 # Initial groups B = A[:mid] C = A[mid:] return [B, C]"},{"question":"def first_missing_positive(arr: List[int]) -> int: Find the first missing positive integer in linear time and constant space. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([1, 2, 3, 4, 5]) 6 >>> first_missing_positive([-1, -2, 0]) 1 >>> first_missing_positive([1]) 2 >>> first_missing_positive([2]) 1 >>> first_missing_positive([10, 11, 12, 13]) 1","solution":"def first_missing_positive(arr): n = len(arr) # Mark numbers (num < 0) and (num > n) with a special marker number (n+1) for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Utilize the index as a hash key and place negative marker in corresponding position for i in range(n): val = abs(arr[i]) if val <= n: arr[val - 1] = -abs(arr[val - 1]) # The first index which has a positive value will be the answer for i in range(n): if arr[i] > 0: return i + 1 return n + 1"},{"question":"def count_pairs_with_sum(arr: List[int], k: int) -> int: Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] == k. >>> count_pairs_with_sum([1, 2, 3, 4, 3], 6) 2 >>> count_pairs_with_sum([1, 2, 3, 4], 8) 0 >>> count_pairs_with_sum([1, -2, 3, -4, 2], -1) 2 >>> count_pairs_with_sum([0, 0, 0, 0], 0) 6 >>> count_pairs_with_sum([1000000000, 1000000000, -1000000000, -1000000000], 0) 4 >>> count_pairs_with_sum([1, 1, 1, 1], 2) 6 >>> count_pairs_with_sum([10, 10, 10, 10], 20) 6","solution":"def count_pairs_with_sum(arr, k): Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] == k. pair_count = 0 seen = {} for num in arr: target = k - num if target in seen: pair_count += seen[target] if num in seen: seen[num] += 1 else: seen[num] = 1 return pair_count"},{"question":"class SortedArray: Class representing a sorted array that supports insert, delete, and search operations. Methods: __init__(self, nums: List[int]): Initializes the array with the 'nums' integers sorted in ascending order. insert(self, val: int): Inserts 'val' into the array, maintaining the sorted order. delete(self, val: int): Deletes 'val' from the array if it exists. search(self, val: int) -> int: Returns the index of 'val' in the array if it exists, otherwise returns -1. def __init__(self, nums): Initializes the array with the 'nums' integers sorted in ascending order. pass # Implement your code here def insert(self, val): Inserts 'val' into the array, maintaining the sorted order. pass # Implement your code here def delete(self, val): Deletes 'val' from the array if it exists. pass # Implement your code here def search(self, val): Returns the index of 'val' in the array if it exists, otherwise returns -1. pass # Implement your code here # Example usage and test cases arr = SortedArray([4, 2, 1, 3]) print(arr.nums) # Output: [1, 2, 3, 4] arr.insert(0) print(arr.nums) # Output: [0, 1, 2, 3, 4] arr.delete(3) print(arr.nums) # Output: [0, 1, 2, 4] print(arr.search(2)) # Output: 2 print(arr.search(5)) # Output: -1","solution":"class SortedArray: def __init__(self, nums): Initializes the array with the 'nums' integers sorted in ascending order. self.nums = sorted(nums) def insert(self, val): Inserts 'val' into the array, maintaining the sorted order. left, right = 0, len(self.nums) while left < right: mid = (left + right) // 2 if self.nums[mid] < val: left = mid + 1 else: right = mid self.nums.insert(left, val) def delete(self, val): Deletes 'val' from the array if it exists. idx = self.search(val) if idx != -1: self.nums.pop(idx) def search(self, val): Returns the index of 'val' in the array if it exists, otherwise returns -1. left, right = 0, len(self.nums) - 1 while left <= right: mid = (left + right) // 2 if self.nums[mid] == val: return mid elif self.nums[mid] < val: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def max_hourglass_sum(grid): Returns the maximum sum of an hourglass shape in the 2D grid. >>> grid = [ ... [1, 1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0], ... [0, 0, 2, 4, 4, 0], ... [0, 0, 0, 2, 0, 0], ... [0, 0, 1, 2, 4, 0] ... ] >>> max_hourglass_sum(grid) 19 >>> grid = [ ... [-1, -1, 0, -9, -2, -2], ... [-2, -1, -6, -8, -2, -5], ... [-1, -1, -1, -2, -3, -4], ... [-1, -9, -2, -4, -4, -5], ... [-7, -3, -3, -2, -9, -9], ... [-1, -3, -1, -2, -4, -5] ... ] >>> max_hourglass_sum(grid) -6 >>> grid = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> max_hourglass_sum(grid) 0 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_hourglass_sum(grid) 35 >>> grid = [ ... [100, 100, 100, 100, 100, 100], ... [100, 100, 100, 100, 100, 100], ... [100, 100, 100, 100, 100, 100], ... [100, 100, 100, 100, 100, 100], ... [100, 100, 100, 100, 100, 100], ... [100, 100, 100, 100, 100, 100] ... ] >>> max_hourglass_sum(grid) 700","solution":"def max_hourglass_sum(grid): Returns the maximum sum of an hourglass shape in the 2D grid. max_sum = float('-inf') rows, cols = len(grid), len(grid[0]) for i in range(rows - 2): for j in range(cols - 2): top = sum(grid[i][j:j+3]) middle = grid[i+1][j+1] bottom = sum(grid[i+2][j:j+3]) hourglass_sum = top + middle + bottom max_sum = max(max_sum, hourglass_sum) return max_sum"},{"question":"def can_knight_reach(board, r, c, k): Determines if a knight can reach an empty square within k moves. :param board: List of List of int: 2D matrix representing the chessboard. :param r: int: Starting row of the knight. :param c: int: Starting column of the knight. :param k: int: Maximum number of moves. :return: bool: True if a knight can reach an empty square, False otherwise. from collections import deque def test_can_knight_reach(): board1 = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert can_knight_reach(board1, 0, 0, 1) == True # The knight can reach (2, 1) in one move board2 = [ [0, 0, 1], [0, 1, 0], [1, 0, 0] ] assert can_knight_reach(board2, 1, 0, 2) == True # The knight can reach (2, 2) in two moves board3 = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] assert can_knight_reach(board3, 1, 1, 1) == False # No valid moves within 1 move board4 = [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ] assert can_knight_reach(board4, 1, 1, 2) == False # Surrounded by obstacles board5 = [[0]*8 for _ in range(8)] assert can_knight_reach(board5, 0, 0, 2) == True # On an empty board, the knight can move to at least one other empty square within 2 moves board6 = [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0] ] assert can_knight_reach(board6, 2, 2, 1) == True # The knight can reach (0, 1) in one move","solution":"def can_knight_reach(board, r, c, k): Determines if a knight can reach an empty square within k moves. :param board: List of List of int: 2D matrix representing the chessboard. :param r: int: Starting row of the knight. :param c: int: Starting column of the knight. :param k: int: Maximum number of moves. :return: bool: True if a knight can reach an empty square, False otherwise. from collections import deque def is_valid_move(x, y): return 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] == 0 # All possible moves for a knight in chess directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] queue = deque([(r, c, 0)]) visited = set((r, c)) while queue: x, y, moves = queue.popleft() if moves > k: break for direction in directions: new_x, new_y = x + direction[0], y + direction[1] if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited: return True if (new_x, new_y) not in visited and 0 <= new_x < len(board) and 0 <= new_y < len(board[0]): visited.add((new_x, new_y)) queue.append((new_x, new_y, moves + 1)) return False"},{"question":"def intersection(nums1: List[int], nums2: List[int]) -> List[int]: Given two integer lists nums1 and nums2, return a list of their intersection. Each element in the result must be unique and you may return the result in any order. >>> set(intersection([4, 9, 5], [9, 4, 9, 8, 4])) == {4, 9} >>> intersection([1, 2, 3], [4, 5, 6]) == [] >>> set(intersection([1, 2, 3], [3, 2, 1])) == {1, 2, 3} >>> set(intersection([4, 9, 5, 4, 4], [9, 4, 9, 8, 4])) == {4, 9} >>> intersection([], []) == [] >>> intersection([1, 2, 3], []) == [] >>> intersection([], [1, 2, 3]) == []","solution":"def intersection(nums1, nums2): Returns a list of unique elements that are present in both nums1 and nums2. set1 = set(nums1) set2 = set(nums2) return list(set1.intersection(set2))"},{"question":"def rank_transform(lst: List[int]) -> List[int]: Transforms the list such that each element is replaced by its rank. Args: lst (List[int]): The input list of integers. Returns: List[int]: The list with each element replaced by its rank. Example: >>> rank_transform([40, 10, 20, 30]) [4, 1, 2, 3] >>> rank_transform([5, 5, 5, 5]) [1, 1, 1, 1] >>> rank_transform([100, 100, 50, 50, 200, 200, 25, 25]) [3, 3, 2, 2, 4, 4, 1, 1] >>> rank_transform([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rank_transform([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> rank_transform([-5, -10, 0, 5, 10]) [2, 1, 3, 4, 5] >>> rank_transform([-1, 1, -1, 1, 0, 0]) [1, 3, 1, 3, 2, 2] pass","solution":"def rank_transform(lst): Transforms the list such that each element is replaced by its rank. Parameters: lst (list): The input list of integers. Returns: list: The list with each element replaced by its rank. # Create a sorted list of unique elements sorted_unique_elements = sorted(set(lst)) # Create a rank dictionary rank_dict = {value: index + 1 for index, value in enumerate(sorted_unique_elements)} # Replace each element with its rank transformed_list = [rank_dict[element] for element in lst] return transformed_list"},{"question":"import math def is_perfect_square(n): Checks if the given number n is a perfect square. sqrt_n = int(math.sqrt(n)) return sqrt_n * sqrt_n == n def subarray_has_perfect_square(arr, k): Determine if there exists a subarray of length exactly k that forms a number which is a perfect square. Args: arr: List of integers k: Length of subarray Returns: bool: True if such a subarray exists, False otherwise >>> subarray_has_perfect_square([1, 4, 1, 5, 9], 1) == True >>> subarray_has_perfect_square([1, 4, 1, 6], 2) == True >>> subarray_has_perfect_square([4, 0, 1, 6, 1, 4], 2) == True >>> subarray_has_perfect_square([1, 2, 3, 4], 2) == False >>> subarray_has_perfect_square([9], 1) == True >>> subarray_has_perfect_square([0, 1, 6], 2) == True","solution":"import math def is_perfect_square(n): Checks if the given number n is a perfect square. sqrt_n = int(math.sqrt(n)) return sqrt_n * sqrt_n == n def subarray_has_perfect_square(arr, k): Determines if there exists a subarray of length exactly k that forms a number which is a perfect square. n = len(arr) for i in range(n - k + 1): # Form the number from the subarray arr[i:i+k] number_as_str = ''.join(map(str, arr[i:i+k])) number_as_int = int(number_as_str) # Check if this number is a perfect square if is_perfect_square(number_as_int): return True return False"},{"question":"def findKthLargest(nums, k): Returns the k-th largest element in the array nums. >>> findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5 >>> findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 >>> findKthLargest([1], 1) == 1 >>> findKthLargest([7, 6, 5, 4, 3, 2, 1], 3) == 5 >>> findKthLargest([2, 1], 1) == 2 >>> findKthLargest([1, 1, 1, 1, 1, 1], 1) == 1 >>> findKthLargest([4, 4, 4, 4, 4], 2) == 4 >>> findKthLargest([5, 2, 2, 3, 5, 3, 5], 3) == 5 >>> findKthLargest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 1 >>> findKthLargest([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 10) == 1 >>> findKthLargest([1, 1, 1, 1, 1], 5) == 1 >>> findKthLargest([10], 1) == 10","solution":"import heapq def findKthLargest(nums, k): Returns the k-th largest element in the array nums. # Use a min heap to maintain the k largest elements seen so far min_heap = [] for num in nums: heapq.heappush(min_heap, num) # If the heap size exceeds k, pop the smallest element if len(min_heap) > k: heapq.heappop(min_heap) return heapq.heappop(min_heap)"},{"question":"def can_visit_all_rooms(rooms): Determine if all rooms can be visited starting from room 0. Args: rooms (List[List[int]]): A 2D list where the i-th element is a list of keys found in the i-th room. Returns: bool: True if all rooms can be visited, otherwise False. from solution import can_visit_all_rooms def test_all_rooms_visited(): assert can_visit_all_rooms([[1], [2], [3], []]) == True def test_not_all_rooms_visited(): assert can_visit_all_rooms([[1,3], [3,0,1], [2], [0]]) == False def test_all_rooms_visited_simpler(): assert can_visit_all_rooms([[1, 2], [2, 3], [], []]) == True def test_single_room(): assert can_visit_all_rooms([[]]) == True def test_unreachable_room(): assert can_visit_all_rooms([[1], [1,2], [], [1]]) == False","solution":"def can_visit_all_rooms(rooms): Determine if all rooms can be visited starting from room 0. Args: rooms (List[List[int]]): A 2D list where the i-th element is a list of keys found in the i-th room. Returns: bool: True if all rooms can be visited, otherwise False. def dfs(room, visited): visited.add(room) for key in rooms[room]: if key not in visited: dfs(key, visited) visited = set() dfs(0, visited) return len(visited) == len(rooms)"},{"question":"from typing import List, Optional from collections import defaultdict class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def diagonalTraversal(root: Optional[TreeNode]) -> List[List[int]]: Returns the diagonal traversal of a binary tree rooted at \`root\`. # Unit Tests def test_diagonal_traversal_example_case(): # Constructing the tree from the example root = TreeNode(8) root.left = TreeNode(3) root.right = TreeNode(10) root.left.left = TreeNode(1) root.left.right = TreeNode(6) root.right.right = TreeNode(14) root.left.right.left = TreeNode(4) root.left.right.right = TreeNode(7) root.right.right.left = TreeNode(13) # Expected Output expected_output = [ [8, 10, 14], [3, 6, 7, 13], [1, 4] ] assert diagonalTraversal(root) == expected_output def test_diagonal_traversal_single_node(): root = TreeNode(1) expected_output = [[1]] assert diagonalTraversal(root) == expected_output def test_diagonal_traversal_empty_tree(): root = None expected_output = [] assert diagonalTraversal(root) == expected_output def test_diagonal_traversal_only_left_children(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) expected_output = [[1], [2], [3]] assert diagonalTraversal(root) == expected_output def test_diagonal_traversal_only_right_children(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) expected_output = [[1, 2, 3]] assert diagonalTraversal(root) == expected_output","solution":"from collections import defaultdict from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def diagonalTraversal(root: Optional[TreeNode]) -> List[List[int]]: Returns the diagonal traversal of a binary tree rooted at \`root\`. if not root: return [] # Dictionary to hold the nodes at each level diagonal_dict = defaultdict(list) # Helper function to traverse the tree def diagonal_traversal_util(node, d): if not node: return diagonal_dict[d].append(node.val) # For left child, increase diagonal distance diagonal_traversal_util(node.left, d + 1) # For right child, keep diagonal distance the same diagonal_traversal_util(node.right, d) # Start the traversal from root with distance 0 diagonal_traversal_util(root, 0) # Extract the results from dictionary and sort it based on keys result = [diagonal_dict[i] for i in sorted(diagonal_dict.keys())] return result"},{"question":"def has_cycle_with_k_edges(N: int, edges: List[List[int]], k: int) -> bool: Determine if there is a simple cycle in the graph with exactly \`k\` edges. >>> has_cycle_with_k_edges(3, [[0, 1], [1, 2]], 2) == False >>> has_cycle_with_k_edges(3, [[0, 1], [1, 2], [2, 0]], 3) == True >>> has_cycle_with_k_edges(4, [[0, 1], [1, 2], [2, 3], [3, 0], [3, 1]], 4) == True >>> has_cycle_with_k_edges(4, [[0, 1], [1, 2], [2, 0]], 10) == False >>> has_cycle_with_k_edges(1, [[0, 0]], 1) == True >>> has_cycle_with_k_edges(2, [[0, 1], [1, 0]], 2) == True >>> has_cycle_with_k_edges(4, [[0, 1], [1, 2], [2, 3]], 2) == False","solution":"from collections import defaultdict from functools import lru_cache def has_cycle_with_k_edges(N, edges, k): # Helper function using memoization @lru_cache(None) def dfs(node, edges_left, start_node): if edges_left == 0: return node == start_node for neighbor in graph[node]: if dfs(neighbor, edges_left - 1, start_node): return True return False # Build the adjacency list representation of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Try to find a cycle with exactly 'k' edges starting from any node for node in range(N): if dfs(node, k, node): return True dfs.cache_clear() # clear the cache for the next starting node return False"},{"question":"from typing import List def shortest_distance_from_building_to_land(grid: List[List[int]]) -> int: Returns the shortest distance from any building to the nearest land cell in the given grid. grid is an m x n 2D array where grid[i][j] can be: - 0 (water) - 1 (land) - 2 (building) In one move, you can move from one cell to an adjacent cell (up, down, left, right). >>> shortest_distance_from_building_to_land([[0, 1, 0], [1, 2, 1], [0, 1, 0]]) == 1 >>> shortest_distance_from_building_to_land([[2, 1, 1], [1, 1, 1], [2, 1, 0]]) == 1 >>> shortest_distance_from_building_to_land([[0, 0, 2], [0, 1, 1], [0, 0, 0]]) == 1 >>> shortest_distance_from_building_to_land([[2, 0, 1], [0, 0, 0], [1, 2, 1]]) == 1 >>> shortest_distance_from_building_to_land([[0, 0, 0], [0, 2, 0], [0, 0, 0]]) == -1 >>> shortest_distance_from_building_to_land([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) == -1 >>> shortest_distance_from_building_to_land([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) == -1 Returns: int: Shortest distance from any building to the nearest land cell, or -1 if no such distance exists.","solution":"from collections import deque def shortest_distance_from_building_to_land(grid): Returns the shortest distance from any building to the nearest land cell in the given grid. grid is an m x n 2D array where grid[i][j] can be 0 (water), 1 (land), or 2 (building). if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs_from_buildings(): queue = deque() visited = [[False] * n for _ in range(m)] for i in range(m): for j in range(n): if grid[i][j] == 2: queue.append((i, j, 0)) visited[i][j] = True while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True if grid[nx][ny] == 1: return dist + 1 if grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) return -1 return bfs_from_buildings()"},{"question":"def is_growth_stable(nums): Determine if the given array is growth-stable. An array is growth-stable if the difference between any two adjacent elements is equal. :param nums: List of integers. :return: Boolean indicating if the array is growth-stable. >>> is_growth_stable([]) True >>> is_growth_stable([1]) True >>> is_growth_stable([1, 2, 3, 4, 5]) True >>> is_growth_stable([5, 3, 1, -1, -3]) True >>> is_growth_stable([1, 2, 4, 8, 16]) False >>> is_growth_stable([1, 3, 6, 10, 15]) False >>> is_growth_stable([0, 0, 0, 0]) True","solution":"def is_growth_stable(nums): Determine if the given array is growth-stable. An array is growth-stable if the difference between any two adjacent elements is equal. :param nums: List of integers. :return: Boolean indicating if the array is growth-stable. if len(nums) < 2: return True difference = nums[1] - nums[0] for i in range(2, len(nums)): if nums[i] - nums[i - 1] != difference: return False return True"},{"question":"from typing import List, Tuple def can_attend_all_events(events: List[Tuple[str, str]]) -> bool: Determines if it is possible to attend all events without overlap. >>> can_attend_all_events([(\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:30\\")]) True >>> can_attend_all_events([(\\"09:00\\", \\"10:00\\"), (\\"09:30\\", \\"11:00\\")]) False >>> can_attend_all_events([(\\"09:00\\", \\"09:30\\"), (\\"09:30\\", \\"10:00\\")]) True >>> can_attend_all_events([(\\"09:00\\", \\"09:31\\"), (\\"09:30\\", \\"10:00\\")]) False >>> can_attend_all_events([(\\"10:00\\", \\"11:00\\")]) True >>> can_attend_all_events([(\\"08:00\\", \\"08:30\\"), (\\"08:45\\", \\"09:15\\"), (\\"09:30\\", \\"10:00\\")]) True","solution":"def can_attend_all_events(events): Determines if it is possible to attend all events without overlap. :param events: List of tuples, where each tuple contains start and end times in \\"HH:MM\\" format :return: True if it is possible to attend all events without overlap, else False # Convert the time strings to minutes from midnight for easier comparison events_in_minutes = [] for event in events: start_time = event[0] end_time = event[1] start_minutes = int(start_time.split(':')[0]) * 60 + int(start_time.split(':')[1]) end_minutes = int(end_time.split(':')[0]) * 60 + int(end_time.split(':')[1]) events_in_minutes.append((start_minutes, end_minutes)) # Sort the events by their starting times events_in_minutes.sort() # Check for any overlaps for i in range(len(events_in_minutes) - 1): if events_in_minutes[i][1] > events_in_minutes[i + 1][0]: return False return True"},{"question":"def minimize_max_sum(arr: List[int], k: int, x: int) -> int: Divide the list into x contiguous subarrays such that the maximum sum of the subarrays is minimized. Each subarray must contain between k and (n - k*x + k) elements. >>> minimize_max_sum([7, 2, 5, 10, 8], 1, 2) 18 >>> minimize_max_sum([1, 2, 3, 4, 5], 1, 2) 9 >>> minimize_max_sum([1, 2, 3, 4, 5], 1, 3) 6 >>> minimize_max_sum([1, 4, 4], 1, 3) 4 >>> minimize_max_sum([1], 1, 1) 1 >>> minimize_max_sum([5, 5, 5, 5, 5], 1, 5) 5","solution":"def is_valid_division(arr, k, x, max_sum): current_sum = 0 count_subarrays = 1 for num in arr: if current_sum + num > max_sum: count_subarrays += 1 current_sum = num if count_subarrays > x: return False else: current_sum += num return True def minimize_max_sum(arr, k, x): n = len(arr) left = max(arr) right = sum(arr) result = right while left <= right: mid = (left + right) // 2 if is_valid_division(arr, k, x, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def first_non_repeating_character(input_str: str) -> int: Given an input string \`input_str\`, returns the index of the first non-repeating character in the string. If all characters are repeating or the string is empty, returns \`-1\`. Note that all characters in the string are lowercase English letters. >>> first_non_repeating_character('') == -1 >>> first_non_repeating_character('aabbcc') == -1 >>> first_non_repeating_character('z') == 0 >>> first_non_repeating_character('abcd') == 0 >>> first_non_repeating_character('aabbcd') == 4 >>> first_non_repeating_character('aabbccde') == 6 >>> first_non_repeating_character('aabbdea') == 4","solution":"def first_non_repeating_character(input_str): Returns the index of the first non-repeating character in the input string. If all characters are repeating or the string is empty, returns -1. # Dictionary to hold character counts char_count = {} # Fill the dictionary with character counts for char in input_str: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for index, char in enumerate(input_str): if char_count[char] == 1: return index return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def boundaryOfBinaryTree(root: TreeNode) -> list[int]: Given a binary tree, return the boundary values of the binary tree in an anti-clockwise direction starting from the root. The boundary includes the left boundary, leaves, and the right boundary. The left boundary is defined as the path from the root to the left-most node. The right boundary is defined as the path from the root to the right-most node. If the root has no left or right subtree, the left or the right boundary will be an empty list respectively. Leaves are defined as nodes without children. Note that the boundary should not contain duplicate nodes. >>> root = TreeNode(1) >>> boundaryOfBinaryTree(root) [1] >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> boundaryOfBinaryTree(root) [1, 2, 3, 4] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) >>> boundaryOfBinaryTree(root) [1, 4, 3, 2] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> boundaryOfBinaryTree(root) [1, 2, 4, 5, 6, 7, 3] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.left.right.left = TreeNode(8) >>> root.left.right.right = TreeNode(9) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> boundaryOfBinaryTree(root) [1, 2, 4, 8, 9, 6, 7, 3] pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def boundaryOfBinaryTree(root): if not root: return [] def is_leaf(node): return not node.left and not node.right def add_left_boundary(node, res): while node: if not is_leaf(node): res.append(node.val) if node.left: node = node.left else: node = node.right def add_leaves(node, res): if is_leaf(node): res.append(node.val) return if node.left: add_leaves(node.left, res) if node.right: add_leaves(node.right, res) def add_right_boundary(node, res): tmp = [] while node: if not is_leaf(node): tmp.append(node.val) if node.right: node = node.right else: node = node.left res.extend(tmp[::-1]) boundary = [] if not is_leaf(root): boundary.append(root.val) if root.left: add_left_boundary(root.left, boundary) add_leaves(root, boundary) if root.right: add_right_boundary(root.right, boundary) return boundary"},{"question":"def smallest_string_with_swaps(s: str, pairs: List[List[int]]) -> str: Returns the lexicographically smallest string that can be formed by repeatedly swapping the characters at the given indices in pairs. >>> smallest_string_with_swaps(\\"dcab\\", [[0,3],[1,2]]) 'bacd' >>> smallest_string_with_swaps(\\"dcab\\", [[0,3],[1,2],[0,2]]) 'abcd' >>> smallest_string_with_swaps(\\"dcab\\", []) 'dcab' >>> smallest_string_with_swaps(\\"cba\\", [[0,1], [1,2]]) 'abc' >>> s = \\"zxywvuts\\" >>> pairs = [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7]] >>> smallest_string_with_swaps(s, pairs) 'stuvwxyz'","solution":"def smallest_string_with_swaps(s, pairs): Returns the lexicographically smallest string that can be formed by repeatedly swapping the characters at the given indices in pairs. from collections import defaultdict, deque def bfs(start, visited, adj): queue = deque([start]) component = [] while queue: node = queue.popleft() if not visited[node]: visited[node] = True component.append(node) for neighbor in adj[node]: if not visited[neighbor]: queue.append(neighbor) return component n = len(s) adj = defaultdict(list) visited = [False] * n # Build adjacency list for x, y in pairs: adj[x].append(y) adj[y].append(x) # Find connected components using BFS components = [] for i in range(n): if not visited[i]: component = bfs(i, visited, adj) components.append(component) # Create the smallest string by sorting the characters in each component s_list = list(s) for component in components: component.sort() chars = sorted(s[i] for i in component) for i, idx in enumerate(component): s_list[idx] = chars[i] return ''.join(s_list)"},{"question":"def max_rectangle_area(heights): Determines the maximum area of a rectangle formed by any two windows where the width of the rectangle is the distance between the two windows, and the height is the minimum height of the two windows. Parameters: heights (list of int): List of non-negative integers representing the heights of buildings. Returns: int: Maximum area of the rectangle. >>> max_rectangle_area([1, 2, 1]) 2 >>> max_rectangle_area([4, 4, 4, 4]) 12 >>> max_rectangle_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_rectangle_area([1, 2, 3, 4, 5, 6]) 9 >>> max_rectangle_area([5]) 0 >>> max_rectangle_area([]) 0 >>> max_rectangle_area([1, 1]) 1 >>> max_rectangle_area([1, 3]) 1 >>> max_rectangle_area([7, 1, 2, 3, 9]) 28 # Write your code here","solution":"def max_rectangle_area(heights): Determines the maximum area of a rectangle formed by any two windows where the width of the rectangle is the distance between the two windows, and the height is the minimum height of the two windows. Parameters: heights (list of int): List of non-negative integers representing the heights of buildings. Returns: int: Maximum area of the rectangle. if not heights or len(heights) < 2: return 0 max_area = 0 left = 0 right = len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def evalRPN(tokens: List[str]) -> int: Evaluate an arithmetic expression in Reverse Polish Notation. Args: tokens (list): A list of strings representing the arithmetic expression in RPN. Returns: int: The result of the expression. >>> evalRPN([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> evalRPN([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6","solution":"def evalRPN(tokens): Evaluate an arithmetic expression in Reverse Polish Notation. Args: tokens (list): A list of strings representing the arithmetic expression in RPN. Returns: int: The result of the expression. stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': # Truncate towards zero stack.append(int(a / b)) else: stack.append(int(token)) return stack[0]"},{"question":"from collections import Counter class WordFinder: def __init__(self, words): Initializes the object with the string array \`words\`. self.words = words def shortestContainingWord(self, target: str) -> int: Returns the length of the shortest word in the array \`words\` that contains all the characters of the \`target\` string. If no such word exists, return -1. >>> finder = WordFinder([\\"step\\", \\"steps\\", \\"strip\\", \\"stripe\\", \\"stepple\\"]) >>> finder.shortestContainingWord(\\"ste\\") == 4 >>> finder.shortestContainingWord(\\"xyz\\") == -1 >>> finder.shortestContainingWord(\\"stripe\\") == 6 >>> finder.shortestContainingWord(\\"abc\\") == 3 >>> finder.shortestContainingWord(\\"\\") == 4 >>> finder.shortestContainingWord(\\"a\\") == 1 >>> finder.shortestContainingWord(\\"ab\\") == 3 >>> finder.shortestContainingWord(\\"aab\\") == 3 >>> finder.shortestContainingWord(\\"a\\") == -1","solution":"from collections import Counter class WordFinder: def __init__(self, words): self.words = words def shortestContainingWord(self, target): target_count = Counter(target) shortest_length = float('inf') found = False for word in self.words: word_count = Counter(word) if all(target_count[char] <= word_count[char] for char in target_count): found = True shortest_length = min(shortest_length, len(word)) return shortest_length if found else -1"},{"question":"def find_pairs(n: int) -> List[List[int]]: Given a positive integer n, determine the number of distinct non-negative integer pairs (a, b) such that a * b = n. Returns the list of pairs in any order. Each pair consists of two non-negative integers [a, b]. Example: >>> find_pairs(12) [[1, 12], [2, 6], [3, 4], [4, 3], [6, 2], [12, 1]] from solution import find_pairs def test_find_pairs_with_prime(): # Prime number 13 should only have pairs with 1 and 13 assert sorted(find_pairs(13)) == sorted([[1, 13], [13, 1]]) def test_find_pairs_with_square_number(): # Square number 25 should include the pair (5,5) only once assert sorted(find_pairs(25)) == sorted([[1, 25], [5, 5], [25, 1]]) def test_find_pairs_with_composite_number(): # Composite number 12 should have multiple pairs assert sorted(find_pairs(12)) == sorted([[1, 12], [2, 6], [3, 4], [4, 3], [6, 2], [12, 1]]) def test_find_pairs_with_one(): # Special case for 1 which should return only one pair [1,1] assert find_pairs(1) == [[1, 1]] def test_find_pairs_with_large_number(): # Testing with a larger number assert sorted(find_pairs(100)) == sorted([[1, 100], [2, 50], [4, 25], [5, 20], [10, 10], [20, 5], [25, 4], [50, 2], [100, 1]])","solution":"def find_pairs(n): Given a positive integer n, returns the list of distinct non-negative integer pairs (a, b) such that a * b = n. Each pair is represented as a list [a, b]. pairs = [] for a in range(1, int(n**0.5) + 1): if n % a == 0: b = n // a pairs.append([a, b]) if a != b: pairs.append([b, a]) return pairs"},{"question":"from typing import List def shortest_distance(n: int, graph: List[List[int]], start: int) -> List[int]: Returns the shortest distances from the starting node to all other nodes in an unweighted graph. Parameters: n (int): Number of nodes graph (list): Adjacency list of the graph start (int): Starting node Returns: list: A list of shortest distances >>> shortest_distance(1, [[]], 0) [0] >>> shortest_distance(3, [[], [], []], 0) [0, -1, -1] >>> shortest_distance(4, [[1], [0, 2], [1, 3], [2]], 0) [0, 1, 2, 3] >>> shortest_distance(4, [[1, 3], [0, 2], [1, 3], [0, 2]], 0) [0, 1, 2, 1] >>> shortest_distance(4, [[1, 2, 3], [0], [0], [0]], 0) [0, 1, 1, 1] >>> shortest_distance(4, [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]], 0) [0, 1, 1, 1] >>> shortest_distance(5, [[1], [0], [], [4], [3]], 0) [0, 1, -1, -1, -1]","solution":"from collections import deque def shortest_distance(n, graph, start): Returns the shortest distances from the starting node to all other nodes in an unweighted graph. Parameters: n (int): Number of nodes graph (list): Adjacency list of the graph start (int): Starting node Returns: list: A list of shortest distances distances = [-1] * n distances[start] = 0 queue = deque([start]) while queue: current_node = queue.popleft() current_distance = distances[current_node] for neighbor in graph[current_node]: if distances[neighbor] == -1: # neighbor not visited yet distances[neighbor] = current_distance + 1 queue.append(neighbor) return distances"},{"question":"def contains_duplicate(nums: List[int]) -> bool: Determines if the array contains any duplicates. Args: nums (list): A list of integers. Returns: bool: True if any value appears at least twice in the array, False if every element is distinct. >>> contains_duplicate([1, 2, 3, 4, 5, 6]) == False >>> contains_duplicate([1, 2, 2, 3, 4, 5]) == True >>> contains_duplicate([1]) == False >>> contains_duplicate([1, 1, 1, 1]) == True >>> contains_duplicate([]) == False >>> contains_duplicate([10, 20, 30, 40, 50, 30]) == True","solution":"def contains_duplicate(nums): Determines if the array contains any duplicates. Args: nums (list): A list of integers. Returns: bool: True if any value appears at least twice in the array, False if every element is distinct. return len(set(nums)) != len(nums)"},{"question":"def number_of_paths(grid): Calculate the number of distinct paths from the top left cell to the bottom right cell in a 2D grid, avoiding blocked cells. Args: grid (list of list of int): The m x n grid where 0 represents an open cell and 1 represents a blocked cell. Returns: int: Number of distinct paths from top left to bottom right cell. Example: >>> grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]] >>> number_of_paths(grid) 2 from solution import number_of_paths def test_no_obstacle(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert number_of_paths(grid) == 6 # 6 paths def test_with_obstacles(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert number_of_paths(grid) == 2 # 2 paths def test_all_blocked_start(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert number_of_paths(grid) == 0 # No paths since start is blocked def test_all_blocked_end(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] assert number_of_paths(grid) == 0 # No paths since end is blocked def test_grid_with_all_ones_except_start_end(): grid = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert number_of_paths(grid) == 0 # No unblocked path def test_large_grid_with_path(): grid = [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0] ] assert number_of_paths(grid) == 3 # 3 paths","solution":"def number_of_paths(grid): Calculate the number of distinct paths from the top left cell to the bottom right cell in a 2D grid, avoiding blocked cells. Args: grid (list of list of int): The m x n grid where 0 represents an open cell and 1 represents a blocked cell. Returns: int: Number of distinct paths from top left to bottom right cell. m = len(grid) n = len(grid[0]) # Initialize a DP table with 0s dp = [[0]*n for _ in range(m)] # If the start or end cell is blocked, return 0 as no path is possible. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize the start position dp[0][0] = 1 # Fill out the DP table for i in range(m): for j in range(n): if grid[i][j] == 1: # Blocked cell dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] # paths from the top if j > 0: dp[i][j] += dp[i][j-1] # paths from the left return dp[m-1][n-1]"},{"question":"from typing import List def rob(nums: List[int]) -> int: Determine the maximum amount of money you can rob tonight without alerting the police, given a list of non-negative integers representing the amount of money of each house, arranged in a circle. You cannot rob two adjacent houses. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([2, 3]) == 3 >>> rob([2, 3, 2]) == 3 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 3, 2, 3, 2]) == 6 >>> rob([2, 7, 9, 3, 1]) == 11","solution":"def rob(nums): Returns the maximum amount of money one can rob from houses arranged in a circle. :param nums: List of non-negative integers representing the amount of money in each house. :return: Maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) # Helper function to rob a line of houses (non-circular) def rob_line(nums): prev, curr = 0, 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr # Rob houses from 0 to n-2 and from 1 to n-1, then take the maximum of both scenarios return max(rob_line(nums[:-1]), rob_line(nums[1:]))"},{"question":"def find_path(grid): Determine if there exists a path from the top-left corner to the bottom-right corner of a grid, moving only through cells containing \`0\`. Return a list of coordinates representing the path taken, or an empty list if no such path exists. Args: grid (List[List[int]]): 2D list representing the grid Returns: List[Tuple[int, int]]: List of coordinates representing the path, or an empty list if no path >>> find_path([ ... [0, 1], ... [1, 0] ... ]) [] >>> find_path([ ... [0, 0], ... [1, 0] ... ]) [(0, 0), (0, 1), (1, 1)] >>> find_path([ ... [0, 0, 1], ... [1, 0, 1], ... [1, 0, 0] ... ]) [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]","solution":"def find_path(grid): def dfs(x, y, path): if x == len(grid) - 1 and y == len(grid[0]) - 1: path.append((x, y)) return True if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 1: return False grid[x][y] = 1 # Mark cell as visited to prevent revisiting path.append((x, y)) # Explore the four possible directions if (dfs(x + 1, y, path) or dfs(x - 1, y, path) or dfs(x, y + 1, path) or dfs(x, y - 1, path)): return True path.pop() return False if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return [] path = [] if dfs(0, 0, path): return path else: return []"},{"question":"def detect_capital_use(word: str) -> bool: Returns True if the word follows the capital usage rules, False otherwise. The capital usage rules are: 1. All letters in the word are capital letters. 2. All letters in the word are not capital letters. 3. Only the first letter in the word is a capital letter. >>> detect_capital_use(\\"WORD\\") == True >>> detect_capital_use(\\"word\\") == True >>> detect_capital_use(\\"Word\\") == True >>> detect_capital_use(\\"wOrD\\") == False >>> detect_capital_use(\\"W\\") == True >>> detect_capital_use(\\"w\\") == True","solution":"def detect_capital_use(word): Returns True if the word follows the capital usage rules, False otherwise. The capital usage rules are: 1. All letters in the word are capital letters. 2. All letters in the word are not capital letters. 3. Only the first letter in the word is a capital letter. if word.isupper(): return True if word.islower(): return True if word[0].isupper() and word[1:].islower(): return True return False"},{"question":"def remove_lexicographically_smallest(s: str) -> List[int]: Removes the lexicographically smallest character from the string s until it's empty. Returns a list where each element represents the number of occurrences of each character removed in each step. >>> remove_lexicographically_smallest(\\"banana\\") [3, 1, 2] >>> remove_lexicographically_smallest(\\"abc\\") [1, 1, 1] >>> remove_lexicographically_smallest(\\"aaaaa\\") [5] >>> remove_lexicographically_smallest(\\"abbbcdddd\\") [1, 3, 1, 4] >>> remove_lexicographically_smallest(\\"\\") [] >>> remove_lexicographically_smallest(\\"abcdefgh\\") [1, 1, 1, 1, 1, 1, 1, 1] >>> remove_lexicographically_smallest(\\"hgfedcba\\") [1, 1, 1, 1, 1, 1, 1, 1] >>> remove_lexicographically_smallest(\\"zzzyyyyxxxxwwww\\") [4, 4, 4, 3]","solution":"def remove_lexicographically_smallest(s): Removes the lexicographically smallest character from the string s until it's empty. Returns a list of counts of the smallest character removed in each step. frequency_counts = [] while s: smallest_char = min(s) count = s.count(smallest_char) frequency_counts.append(count) s = s.replace(smallest_char, '') # Remove all occurrences of the smallest character return frequency_counts"},{"question":"from typing import List def closestSum(arr: List[int], target: int) -> int: Finds two integers in arr such that their sum is closest to the target. Returns the sum of the two integers. pass def test_closestSum_exact_match(): assert closestSum([1, 2, 3, 4, 5], 9) == 9 def test_closestSum_one_off(): assert closestSum([1, 2, 3, 4, 5], 10) == 9 def test_closestSum_negative_target(): assert closestSum([-1, -2, -3, -4, -5], -6) == -6 def test_closestSum_mixed_numbers(): assert closestSum([-1, 2, 3, -4, 5], 4) == 4 def test_closestSum_large_numbers(): assert closestSum([100, 200, 300, 400, 500], 700) == 700 def test_closestSum_with_negatives(): assert closestSum([-10, -20, 30, 40], -45) == -30 def test_closestSum_duplicates(): assert closestSum([1, 2, 2, 3, 4], 5) == 5","solution":"def closestSum(arr, target): Finds two integers in arr such that their sum is closest to the target. Returns the sum of the two integers. arr.sort() closest_sum = float('inf') left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"def max_sum_subgrid(grid, k): Returns the maximum sum of a k x k subgrid within the given grid. Parameters: grid (list of list of int): 2D list representing the grid. k (int): size of the subgrid. Returns: int: maximum sum of any k x k subgrid. pass from solution import max_sum_subgrid def test_max_sum_subgrid_basic(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 2 assert max_sum_subgrid(grid, k) == 28 # The 2x2 subgrid [5, 6, 8, 9] has the max sum 28 def test_max_sum_subgrid_single_row(): grid = [ [1, 2, 3, 4, 5] ] k = 1 assert max_sum_subgrid(grid, k) == 5 # The largest single element is 5 def test_max_sum_subgrid_single_column(): grid = [ [1], [2], [3], [4], [5] ] k = 1 assert max_sum_subgrid(grid, k) == 5 # The largest single element is 5 def test_max_sum_subgrid_entire_grid(): grid = [ [1, 2], [3, 4] ] k = 2 assert max_sum_subgrid(grid, k) == 10 # The entire grid is the subgrid def test_max_sum_subgrid_larger_k(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 3 assert max_sum_subgrid(grid, k) == 45 # The entire grid has the sum 45","solution":"def max_sum_subgrid(grid, k): Returns the maximum sum of a k x k subgrid within the given grid. Parameters: grid (list of list of int): 2D list representing the grid. k (int): size of the subgrid. Returns: int: maximum sum of any k x k subgrid. m, n = len(grid), len(grid[0]) out = float('-inf') for i in range(m - k + 1): for j in range(n - k + 1): current_sum = sum( grid[x][y] for x in range(i, i + k) for y in range(j, j + k) ) out = max(out, current_sum) return out"},{"question":"from typing import List def can_form_by_deleting(text: str, word: str) -> bool: Check if \`word\` can be formed by deleting some characters of \`text\` without reordering. def check_words_by_deleting(text: str, queries: List[str]) -> List[bool]: Check for each word in \`queries\` if it can be formed by deleting some characters of \`text\` without reordering the remaining characters. >>> check_words_by_deleting(\\"abpcplea\\", [\\"apple\\", \\"monkey\\", \\"plea\\", \\"ale\\"]) [True, False, True, True] >>> check_words_by_deleting(\\"abpcplea\\", []) [] >>> check_words_by_deleting(\\"abpcplea\\", [\\"xyz\\", \\"mnop\\", \\"qrst\\"]) [False, False, False] >>> check_words_by_deleting(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\", \\"p\\", \\"abc\\"]) [True, True, True, True, True] >>> check_words_by_deleting(\\"abpcplea\\", [\\"pla\\", \\"abc\\", \\"aec\\", \\"pcple\\"]) [True, True, False, True]","solution":"def can_form_by_deleting(text, word): Check if \`word\` can be formed by deleting some characters of \`text\` without reordering. it = iter(text) return all(char in it for char in word) def check_words_by_deleting(text, queries): Check for each word in \`queries\` if it can be formed by deleting some characters of \`text\` without reordering the remaining characters. return [can_form_by_deleting(text, word) for word in queries]"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in s. If there is no non-repeating character, returns a single dot ('.'). >>> first_non_repeating_character(\\"leetcode\\") # 'l' >>> first_non_repeating_character(\\"loveleetcode\\") # 'v' >>> first_non_repeating_character(\\"aabb\\") # '.'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in s. If there is no non-repeating character, returns a single dot ('.'). from collections import Counter # First, count the frequency of each character in the string char_count = Counter(s) # Iterate through the string to find the first non-repeating character for char in s: if char_count[char] == 1: return char # If no non-repeating character was found, return '.' return '.'"},{"question":"def can_become_goal(s: str, goal: str) -> bool: Given two strings \`s\` and \`goal\`, return \`true\` if and only if \`s\` can become \`goal\` after one or more swaps of any two characters in \`s\`. Otherwise, return \`false\`. >>> can_become_goal(\\"ab\\", \\"ba\\") == True >>> can_become_goal(\\"ab\\", \\"ab\\") == True >>> can_become_goal(\\"abc\\", \\"bca\\") == True >>> can_become_goal(\\"abcd\\", \\"dcba\\") == True >>> can_become_goal(\\"a\\", \\"a\\") == True >>> can_become_goal(\\"aaaa\\", \\"aaaa\\") == True >>> can_become_goal(\\"ab\\", \\"cd\\") == False >>> can_become_goal(\\"abc\\", \\"def\\") == False >>> can_become_goal(\\"abcd\\", \\"abc\\") == False >>> can_become_goal(\\"abcd\\", \\"abce\\") == False >>> can_become_goal(\\"\\", \\"\\") == True >>> can_become_goal(\\"aabbcc\\", \\"abccba\\") == True","solution":"def can_become_goal(s, goal): Returns true if s can become goal after one or more swaps of any two characters in s. if len(s) != len(goal): return False # Check if the sorted characters of both strings are the same return sorted(s) == sorted(goal)"},{"question":"from typing import List def count_quadruples(arr: List[int], target: int) -> int: Returns the number of tuples (i, j, k, l) such that i < j < k < l and arr[i] + arr[j] + arr[k] + arr[l] == target. >>> count_quadruples([], 0) 0 >>> count_quadruples([1, 2, 3, 4], 10) 1 >>> count_quadruples([1, 2, 2, 3, 4], 10) 2 >>> count_quadruples([1, 1, 1, 1, 1], 10) 0 >>> count_quadruples([-1, 2, 3, 4, -2], 3) 1 >>> count_quadruples([1, 2, 3, 4, 5, 6, 7, 8], 26) 1","solution":"def count_quadruples(arr, target): Returns the number of tuples (i, j, k, l) such that i < j < k < l and arr[i] + arr[j] + arr[k] + arr[l] == target. n = len(arr) count = 0 for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): for l in range(k + 1, n): if arr[i] + arr[j] + arr[k] + arr[l] == target: count += 1 return count"},{"question":"from typing import List, Tuple def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Returns the diameter of the binary tree. Args: n (int): number of nodes in the tree. edges (List[Tuple[int, int]]): edges of the tree. Returns: int: the diameter of the tree. >>> tree_diameter(5, [(0, 1), (1, 2), (1, 3), (3, 4)]) 3 >>> tree_diameter(1, []) 0 >>> tree_diameter(2, [(0, 1)]) 1 >>> tree_diameter(7, [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)]) 4 >>> tree_diameter(6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) 5 >>> tree_diameter(0, []) 0","solution":"from collections import defaultdict, deque def tree_diameter(n, edges): Returns the diameter of the binary tree. if n == 0: return 0 if n == 1: return 0 # Create an adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Function to perform BFS and return the farthest node and distance def bfs(start_node): visited = [False] * n distance = [-1] * n queue = deque([start_node]) visited[start_node] = True distance[start_node] = 0 farthest_node = start_node farthest_distance = 0 while queue: node = queue.popleft() for neighbor in tree[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) distance[neighbor] = distance[node] + 1 if distance[neighbor] > farthest_distance: farthest_distance = distance[neighbor] farthest_node = neighbor return farthest_node, farthest_distance # Perform BFS twice to find the diameter # First BFS to find the farthest node from an arbitrary start node farthest_node, _ = bfs(0) # Second BFS from the farthest node found to find the maximum distance _, diameter = bfs(farthest_node) return diameter"},{"question":"import heapq from collections import Counter from typing import List def rearrange_string(s: str) -> str: Write a function to determine if a given string \`s\` can be rearranged to form a string such that every adjacent character is different. If it is possible, return one such rearrangement. If it is not possible, return an empty string. >>> rearrange_string(\\"aab\\") in (\\"aba\\",) True >>> rearrange_string(\\"aaab\\") == \\"\\" True >>> rearrange_string(\\"\\") == \\"\\" True >>> rearrange_string(\\"a\\") == \\"a\\" True >>> rearrange_string(\\"aaaa\\") == \\"\\" True >>> rearrange_string(\\"aaabbc\\") in (\\"ababac\\", \\"ababca\\", \\"abcaba\\") True >>> rearrange_string(\\"aaaaaaab\\") in (\\"\\",) True >>> rearrange_string(\\"aabbcc\\") in (\\"abcabc\\", \\"abccba\\", \\"acbacb\\", \\"acbabc\\", \\"acbbca\\") True","solution":"import heapq from collections import Counter def rearrange_string(s): The function to determine if a given string \`s\` can be rearranged to form a string such that every adjacent character is different. If it is possible, return one such rearrangement. If it is not possible, return an empty string. # Counter for frequencies of each character counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) result = [] prev_char, prev_freq = None, 0 while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char, prev_freq = char, freq + 1 rearranged = ''.join(result) if len(rearranged) != len(s): return \\"\\" return rearranged"},{"question":"def possible_groups(n: int, relations: List[str]) -> bool: Determine if it's possible to assign a group to each node such that friends are in the same group and enemies are in different groups. >>> possible_groups(3, [\\"1 2 friend\\", \\"2 3 friend\\"]) True >>> possible_groups(2, [\\"1 2 enemy\\"]) True >>> possible_groups(4, [\\"1 2 friend\\", \\"2 3 enemy\\", \\"3 4 friend\\"]) True >>> possible_groups(3, [\\"1 2 friend\\", \\"2 3 friend\\", \\"1 3 enemy\\"]) False >>> possible_groups(4, [\\"1 2 friend\\", \\"3 4 friend\\"]) True >>> relations = [ ... \\"1 2 friend\\", \\"2 3 friend\\", \\"3 4 friend\\", \\"4 5 friend\\", ... \\"1 3 enemy\\", \\"2 4 enemy\\", \\"3 5 enemy\\" ... ] >>> possible_groups(5, relations) False","solution":"def possible_groups(n, relations): from collections import defaultdict graph = defaultdict(list) for relation in relations: A, B, R = relation.split() A, B = int(A), int(B) if R == \\"friend\\": graph[A].append((B, True)) graph[B].append((A, True)) elif R == \\"enemy\\": graph[A].append((B, False)) graph[B].append((A, False)) color = {} def dfs(node, c): if node in color: return color[node] == c color[node] = c for neighbor, is_friend in graph[node]: if is_friend: # friends in the same group if not dfs(neighbor, c): return False else: # enemies in different groups if not dfs(neighbor, not c): return False return True for node in range(1, n + 1): if node not in color: if not dfs(node, True): return False return True"},{"question":"def min_additional_candies(nums: List[int]) -> int: Determine the minimum number of additional candies needed to make each count unique. Args: nums (list of int): List of integers representing candies each child has. Returns: int: Minimum additional candies needed. Examples: >>> min_additional_candies([1, 2, 2, 4]) 1 >>> min_additional_candies([1, 1, 1, 1]) 6","solution":"def min_additional_candies(nums): Determine the minimum number of additional candies needed to make each count unique. Args: nums (list of int): List of integers representing candies each child has. Returns: int: Minimum additional candies needed. nums.sort() additional_candies = 0 for i in range(1, len(nums)): if nums[i] <= nums[i-1]: additional_candies += nums[i-1] - nums[i] + 1 nums[i] = nums[i-1] + 1 return additional_candies"},{"question":"def can_form_palindrome_by_deleting_one_char(s: str) -> bool: You have a string \`s\` consisting of only lowercase English letters. You want to construct a new string by deleting exactly one character from \`s\` and moving the remaining characters freely such that the new string is a palindrome. Return \`true\` if it's possible to create such a palindrome through this process, or \`false\` otherwise. >>> can_form_palindrome_by_deleting_one_char(\\"abca\\") True >>> can_form_palindrome_by_deleting_one_char(\\"abc\\") False >>> can_form_palindrome_by_deleting_one_char(\\"aba\\") True >>> can_form_palindrome_by_deleting_one_char(\\"abcdedcba\\") True >>> can_form_palindrome_by_deleting_one_char(\\"a\\") True >>> can_form_palindrome_by_deleting_one_char(\\"aa\\") True >>> can_form_palindrome_by_deleting_one_char(\\"ab\\") True >>> can_form_palindrome_by_deleting_one_char(\\"racecar\\") True >>> can_form_palindrome_by_deleting_one_char(\\"racedar\\") False","solution":"def can_form_palindrome_by_deleting_one_char(s): def is_palindrome(sub_s): return sub_s == sub_s[::-1] for i in range(len(s)): if is_palindrome(s[:i] + s[i+1:]): return True return False"},{"question":"def min_length_after_removals(s: str) -> int: Given a string \`s\` containing only the characters \`'a'\` and \`'b'\`, you can perform an unlimited number of moves. In each move, you can remove one occurrence of the substring \`\\"ab\\"\` or \`\\"ba\\"\` from the string \`s\`. Return the minimum possible length of the resulting string after performing any number of moves. >>> min_length_after_removals(\\"abab\\") == 0 >>> min_length_after_removals(\\"aa\\") == 2 >>> min_length_after_removals(\\"bb\\") == 2 >>> min_length_after_removals(\\"aabb\\") == 0 >>> min_length_after_removals(\\"abba\\") == 0 >>> min_length_after_removals(\\"a\\") == 1 >>> min_length_after_removals(\\"b\\") == 1 >>> min_length_after_removals(\\"aaab\\") == 2 >>> min_length_after_removals(\\"aabbb\\") == 1 >>> min_length_after_removals(\\"\\") == 0","solution":"def min_length_after_removals(s): Returns the minimum possible length of the resulting string after performing moves to remove \\"ab\\" or \\"ba\\" substrings any number of times. # Count the number of 'a's and 'b's in the string a_count = s.count('a') b_count = s.count('b') # The resulting length will be the absolute difference between counts of 'a' and 'b' return abs(a_count - b_count)"},{"question":"from typing import List def shortest_path(grid: List[List[str]]) -> int: Given a 2D grid of \`m\` rows and \`n\` columns, each cell can be empty ('.'), blocked ('#'), a start point ('S') or a destination point ('D'), find the length of the shortest path from the start point to the destination point, passing through empty cells only. If there is no such path, return -1. The robot can move up, down, left, or right to an adjacent empty cell. >>> shortest_path([ ... ['S', '.', '.', '.'], ... ['#', '#', '.', '#'], ... ['#', 'D', '.', '#'] ... ]) == 5 >>> shortest_path([ ... ['S', '#', '#'], ... ['#', '#', '#'], ... ['#', '#', 'D'] ... ]) == -1 >>> shortest_path([ ... ['S', '.', 'D'] ... ]) == 2 >>> shortest_path([ ... ['S', '.', '.', '#', '#', '.', '.', 'D'], ... ['#', '#', '.', '#', '#', '.', '#', '.'], ... ['.', '.', '.', '.', '.', '.', '#', '.'], ... ['#', '#', '#', '#', '#', '.', '#', '.'], ... ['.', '.', '.', '.', '#', '.', '.', '.'], ... ['.', '#', '#', '.', '.', '#', '#', '#'] ... ]) == 11 >>> shortest_path([ ... ['.', '.', '.', '.'], ... ['#', '#', '.', '#'], ... ['#', 'D', '.', '#'] ... ]) == -1 >>> shortest_path([ ... ['S', '.', '.', '.'], ... ['#', '#', '.', '#'], ... ['#', '.', '.', '#'] ... ]) == -1","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from start 'S' to destination 'D' in the grid. The robot can move in 4 directions: up, down, left, right. If there is no path, returns -1. def bfs(start): q = deque([start]) visited = set() visited.add(start) steps = 0 while q: for _ in range(len(q)): x, y = q.popleft() if grid[x][y] == 'D': return steps for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) q.append((nx, ny)) steps += 1 return -1 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 'S': return bfs((i, j)) return -1"},{"question":"def smallest_string_after_removal(s: str) -> str: Returns the lexicographically smallest string that can be obtained by removing one character from the string s. >>> smallest_string_after_removal(\\"abc\\") \\"ab\\" >>> smallest_string_after_removal(\\"a\\") \\"\\" >>> smallest_string_after_removal(\\"aaaa\\") \\"aaa\\" >>> smallest_string_after_removal(\\"cab\\") \\"ab\\" >>> smallest_string_after_removal(\\"cbaa\\") \\"baa\\"","solution":"def smallest_string_after_removal(s): Returns the lexicographically smallest string that can be obtained by removing one character from the string s. smallest = None for i in range(len(s)): candidate = s[:i] + s[i+1:] if smallest is None or candidate < smallest: smallest = candidate return smallest"},{"question":"import pytest class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(root1, root2): Merges two binary trees by summing the values of overlapping nodes. If a node is non-null in only one tree, it is used as the node of the new tree. Parameters: root1 (TreeNode): Root node of the first binary tree. root2 (TreeNode): Root node of the second binary tree. Returns: TreeNode: Root node of the merged binary tree. pass def tree_to_list(root): Convert a binary tree to a list representation for easier comparison in tests. if not root: return [] result = [] queue = [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) # Remove trailing None elements for more concise representation while result and result[-1] is None: result.pop() return result def test_merge_trees_both_non_empty(): root1 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2)) root2 = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) merged_tree = merge_trees(root1, root2) assert tree_to_list(merged_tree) == [3, 4, 5, 5, 4, None, 7] def test_merge_trees_first_tree_empty(): root1 = None root2 = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) merged_tree = merge_trees(root1, root2) assert tree_to_list(merged_tree) == [2, 1, 3, None, 4, None, 7] def test_merge_trees_second_tree_empty(): root1 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2)) root2 = None merged_tree = merge_trees(root1, root2) assert tree_to_list(merged_tree) == [1, 3, 2, 5] def test_merge_trees_both_single_node_trees(): root1 = TreeNode(1) root2 = TreeNode(2) merged_tree = merge_trees(root1, root2) assert tree_to_list(merged_tree) == [3] if __name__ == \\"__main__\\": pytest.main()","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(root1, root2): Merges two binary trees by summing the values of overlapping nodes. If a node is non-null in only one tree, it is used as the node of the new tree. Parameters: root1 (TreeNode): Root node of the first binary tree. root2 (TreeNode): Root node of the second binary tree. Returns: TreeNode: Root node of the merged binary tree. if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged_val = root1.val + root2.val merged_tree = TreeNode(merged_val) merged_tree.left = merge_trees(root1.left, root2.left) merged_tree.right = merge_trees(root1.right, root2.right) return merged_tree"},{"question":"def decode_run_length(encodedString: str) -> str: Decodes a run-length encoded string. Parameters: encodedString (str): The run-length encoded string. Returns: str: The decoded string. Examples: >>> decode_run_length(\\"a1b1c1\\") == \\"abc\\" >>> decode_run_length(\\"a2b1c5a3\\") == \\"aabcccccaaa\\" >>> decode_run_length(\\"a1\\") == \\"a\\" >>> decode_run_length(\\"z5\\") == \\"zzzzz\\" >>> decode_run_length(\\"a10\\") == \\"aaaaaaaaaa\\" >>> decode_run_length(\\"a2b2c3d4\\") == \\"aabbcccdddd\\" >>> decode_run_length(\\"\\") == \\"\\" >>> decode_run_length(\\"z1x1c1\\") == \\"zxc\\"","solution":"def decode_run_length(encodedString): Decodes a run-length encoded string. Parameters: encodedString (str): The run-length encoded string. Returns: str: The decoded string. decoded_string = [] i = 0 while i < len(encodedString): char = encodedString[i] i += 1 count = 0 while i < len(encodedString) and encodedString[i].isdigit(): count = count * 10 + int(encodedString[i]) i += 1 decoded_string.append(char * count) return ''.join(decoded_string)"},{"question":"def three_sum(arr: List[int], target: int) -> bool: Determines if there are three distinct elements in the array that sum up to the target. :param arr: List of positive integers :param target: Target sum :return: Boolean value indicating if such elements exist >>> three_sum([1, 2, 4, 5, 6], 10) True >>> three_sum([1, 2, 4, 5, 6], 20) False >>> three_sum([1, 1, 1, 2, 2, 4, 5], 7) True >>> three_sum([1, 1, 1], 3) True >>> three_sum([1, 2, 3, 8], 16) False >>> three_sum([3, 5, 7, 9, 12], 30) False >>> three_sum([1, 5, 6, 3, 2, 0, 4], 9) True","solution":"def three_sum(arr, target): Determines if there are three distinct elements in the array that sum up to the target. :param arr: List of positive integers :param target: Target sum :return: Boolean value indicating if such elements exist arr.sort() n = len(arr) for i in range(n-2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def max_customers(customers): Given an array of \`customers\`, where \`customers[i] = [arrival_i, departure_i]\`, representing the arrival and departure times of the ith customer at a restaurant, determine the maximum number of customers that are in the restaurant simultaneously at any time. The \`arrival_i\` and \`departure_i\` times are given in 24-hour format. Return the maximum number of customers that are in the restaurant at the same time. >>> max_customers([[1, 4], [2, 5], [9, 12], [5, 9], [5, 12]]) 3 >>> max_customers([[5, 10]]) 1 >>> max_customers([[1, 2], [3, 4], [5, 6]]) 1 >>> max_customers([[1, 10], [2, 9], [3, 8], [4, 7]]) 4 >>> max_customers([[1, 3], [2, 4], [3, 5], [4, 6]]) 3 >>> max_customers([[1, 5], [2, 3], [4, 8]]) 2 >>> max_customers([[1, 2], [2, 3], [2, 4], [2, 5]]) 4 >>> max_customers([]) 0","solution":"def max_customers(customers): This function takes a list of customers, where each customer is represented by a list containing their arrival and departure times. It returns the maximum number of customers that are in the restaurant simultaneously. events = [] for arrival, departure in customers: events.append((arrival, 'arrival')) events.append((departure, 'departure')) events.sort() max_count = 0 current_count = 0 for event in events: if event[1] == 'arrival': current_count += 1 max_count = max(max_count, current_count) else: # event[1] == 'departure' current_count -= 1 return max_count"},{"question":"def multiplyStrings(s: str, t: str) -> str: Multiplies two large integers represented as strings and returns the result as a string. :param s: String representing the first large integer without leading zeros :param t: String representing the second large integer without leading zeros :return: String representing the product of the two large integers >>> multiplyStrings(\\"0\\", \\"12345\\") '0' >>> multiplyStrings(\\"6789\\", \\"0\\") '0' >>> multiplyStrings(\\"3\\", \\"7\\") '21' >>> multiplyStrings(\\"8\\", \\"9\\") '72' >>> multiplyStrings(\\"12\\", \\"34\\") '408' >>> multiplyStrings(\\"56\\", \\"78\\") '4368' >>> multiplyStrings(\\"123456789\\", \\"987654321\\") '121932631112635269' >>> multiplyStrings(\\"999999999\\", \\"999999999\\") '999999998000000001' >>> multiplyStrings(\\"123\\", \\"4567\\") '561741' >>> multiplyStrings(\\"1234\\", \\"567\\") '699678'","solution":"def multiplyStrings(s: str, t: str) -> str: Multiplies two large integers represented as strings and returns the result as a string. # Edge case when one of the inputs is \\"0\\" if s == \\"0\\" or t == \\"0\\": return \\"0\\" # Initialize array to store the intermediate results product = [0] * (len(s) + len(t)) # Reverse both strings to facilitate multiplication from least significant digit s = s[::-1] t = t[::-1] # Perform multiplication digit by digit for i in range(len(s)): for j in range(len(t)): product[i + j] += int(s[i]) * int(t[j]) # Handle carry over product[i + j + 1] += product[i + j] // 10 product[i + j] %= 10 # Convert product array back to string and remove leading zeros while len(product) > 1 and product[-1] == 0: product.pop() return ''.join(map(str, product[::-1]))"},{"question":"from typing import List import heapq def min_cost_to_merge_files(arr: List[int]) -> int: Returns the minimum cost to merge all files into one single file. :param arr: List[int] - List of integers representing file sizes. :return: int - Minimum cost to merge all files. >>> min_cost_to_merge_files([]) 0 >>> min_cost_to_merge_files([5]) 0 >>> min_cost_to_merge_files([4, 6, 8]) 28 >>> min_cost_to_merge_files([5, 7]) 12 >>> min_cost_to_merge_files([1, 2, 3, 4]) 19 >>> min_cost_to_merge_files([4, 4, 4, 4]) 32 >>> min_cost_to_merge_files([10, 20, 30, 40, 50]) 330","solution":"import heapq def min_cost_to_merge_files(arr): Returns the minimum cost to merge all files into one single file. :param arr: List[int] - List of integers representing file sizes. :return: int - Minimum cost to merge all files. if not arr or len(arr) == 1: return 0 heapq.heapify(arr) total_cost = 0 while len(arr) > 1: first = heapq.heappop(arr) second = heapq.heappop(arr) cost = first + second total_cost += cost heapq.heappush(arr, cost) return total_cost"},{"question":"def minimum_operations_to_connect_network(n: int, connections: List[List[int]]) -> int: Returns the minimum number of operations needed to make the entire network connected, or -1 if it is not possible. >>> minimum_operations_to_connect_network(4, [[0, 1], [1, 2], [2, 3]]) == 0 >>> minimum_operations_to_connect_network(4, [[0, 1], [1, 2], [2, 3], [3, 0]]) == 0 >>> minimum_operations_to_connect_network(4, [[0, 1], [2, 3]]) == -1 >>> minimum_operations_to_connect_network(3, [[0, 1]]) == -1 >>> minimum_operations_to_connect_network(1, []) == 0 >>> minimum_operations_to_connect_network(4, [[0, 1], [2, 3], [1, 2]]) == 0","solution":"def minimum_operations_to_connect_network(n, connections): Returns the minimum number of operations needed to make the entire network connected, or -1 if it is not possible. if len(connections) < n - 1: return -1 parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return True return False operations = 0 for city1, city2 in connections: if union(city1, city2): operations += 1 components = len({find(x) for x in range(n)}) return components - 1 if components == 1 else operations + (components - 1) if operations >= n - 1 else -1"},{"question":"def is_valid_parenthesis(s: str) -> bool: Determines if the given string s is a valid parenthesis string. Args: s (str): A string containing only characters '(' and ')'. Returns: bool: True if the string is a valid parenthesis string, False otherwise. >>> is_valid_parenthesis(\\"()\\") True >>> is_valid_parenthesis(\\"(())\\") True >>> is_valid_parenthesis(\\"()()()\\") True >>> is_valid_parenthesis(\\"(())()\\") True >>> is_valid_parenthesis(\\"(()\\") False >>> is_valid_parenthesis(\\")(\\") False >>> is_valid_parenthesis(\\"())\\") False >>> is_valid_parenthesis(\\"((()\\") False >>> is_valid_parenthesis(\\"\\") True >>> is_valid_parenthesis(\\"(\\") False >>> is_valid_parenthesis(\\")\\") False","solution":"def is_valid_parenthesis(s): Determines if the given string s is a valid parenthesis string. Args: s (str): A string containing only characters '(' and ')'. Returns: bool: True if the string is a valid parenthesis string, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"class InventorySystem: A class to manage an inventory system for a store, which tracks the quantity of various items. Methods: addItem(itemName: str, quantity: int): Adds quantity amount of the item itemName into the inventory. If the item already exists, increment its quantity by the provided amount. removeItem(itemName: str, quantity: int): Removes quantity amount of the item itemName from the inventory. If the quantity to be removed exceeds the current quantity, set the item's quantity to 0. getQuantity(itemName: str) -> int: Returns the current quantity of the item itemName in the inventory. If the item does not exist, returns 0. getItemsBelowThreshold(threshold: int) -> list: Returns a list of item names whose quantities are below the specified threshold. Example Usage: >>> inventory = InventorySystem() >>> inventory.addItem(\\"apple\\", 10) >>> inventory.getQuantity(\\"apple\\") 10 >>> inventory.addItem(\\"apple\\", 5) >>> inventory.getQuantity(\\"apple\\") 15 >>> inventory.removeItem(\\"apple\\", 5) >>> inventory.getQuantity(\\"apple\\") 10 >>> inventory.removeItem(\\"apple\\", 15) >>> inventory.getQuantity(\\"apple\\") 0 >>> inventory.getQuantity(\\"banana\\") 0 >>> inventory.addItem(\\"banana\\", 3) >>> inventory.addItem(\\"orange\\", 20) >>> inventory.getItemsBelowThreshold(5) ['banana'] >>> inventory.addItem(\\"apple\\", 10) >>> inventory.addItem(\\"banana\\", 8) >>> inventory.getItemsBelowThreshold(5) []","solution":"class InventorySystem: def __init__(self): self.inventory = {} def addItem(self, itemName, quantity): if itemName in self.inventory: self.inventory[itemName] += quantity else: self.inventory[itemName] = quantity def removeItem(self, itemName, quantity): if itemName in self.inventory: self.inventory[itemName] = max(0, self.inventory[itemName] - quantity) def getQuantity(self, itemName): return self.inventory.get(itemName, 0) def getItemsBelowThreshold(self, threshold): return [item for item, quantity in self.inventory.items() if quantity < threshold]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(edges): Builds a binary tree from edges where each edges[i] contains [u, v, d]. def has_path_sum(root, k): Checks if there is a path from root to any leaf with the sum of all node values along the path equal to k. def is_path_sum(edges, k): Given a binary tree represented by edges and a target integer k, determines if there is a path from the root to any leaf such that the sum of all node values along the path equals k. >>> is_path_sum([], 1) == False >>> edges = [[1, 2, 0], [2, 3, 0], [3, 4, 0]] is_path_sum(edges, 10) == True >>> edges = [[1, 2, 0], [1, 3, 1], [2, 4, 0], [2, 5, 1], [3, 6, 0], [3, 7, 1]] is_path_sum(edges, 8) == True >>> edges = [[1, 2, 0], [1, 3, 1], [2, 4, 0], [2, 5, 1], [3, 6, 0], [3, 7, 1]] is_path_sum(edges, 20) == False >>> edges = [[1, 2, 0], [2, 3, 0], [1, 4, 1]] is_path_sum(edges, 5) == True","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(edges): if not edges: return None tree_nodes = {} for u, v, d in edges: if u not in tree_nodes: tree_nodes[u] = TreeNode(u) if v not in tree_nodes: tree_nodes[v] = TreeNode(v) if d == 0: tree_nodes[u].left = tree_nodes[v] else: tree_nodes[u].right = tree_nodes[v] return tree_nodes[1] def has_path_sum(root, k): if not root: return False if not root.left and not root.right: return root.val == k k -= root.val return has_path_sum(root.left, k) or has_path_sum(root.right, k) def is_path_sum(edges, k): root = build_tree(edges) return has_path_sum(root, k)"},{"question":"def connect(root: 'Node') -> 'Node': Given a binary tree, populates each node's next pointer to point to its next right node. The next right node is the node at the same level and immediately to the right of the current node. If there is no next right node, the next pointer should be set to None. :param root: Node - the root of the binary tree :return: Node - the root of the modified tree with next pointers connected >>> root = Node(1, Node(2), Node(3)) >>> connect(root) >>> root.next is None True >>> root.left.next == root.right True >>> root.right.next is None True >>> root = Node(1, Node(2, Node(4), None), Node(3, None, Node(5))) >>> connect(root) >>> root.left.next == root.right True >>> root.left.left.next == root.right.right True # Implement the function here class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): if not root: return None # Initialize the current node as the root current = root # Use dummy node technique to establish the 'next' pointers while current: dummy = Node(0) tail = dummy # Iterate over the current level while current: if current.left: tail.next = current.left tail = tail.next if current.right: tail.next = current.right tail = tail.next current = current.next # Move to the next level current = dummy.next return root"},{"question":"def max_jumps(arr: List[int], d: int) -> int: You are given a 0-indexed integer array \`arr\` and an integer \`d\`. You can jump at most \`d\` steps to the left or to the right from each index \`i\` (i.e., from index \`i\`, you can jump to any index in the range \`[i-d, i+d]\` inclusive if that index exists within the bounds of the array). You can only jump if the target index has a strictly smaller value than the current index. Return the maximum number of indices you can visit using the described jump strategy starting from any index. >>> max_jumps([6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2) == 4 >>> max_jumps([3, 3, 3, 3, 3], 3) == 1 >>> max_jumps([7, 6, 5, 4, 3, 2, 1], 1) == 7 >>> max_jumps([7, 1, 7, 1, 7, 1], 2) == 2 >>> max_jumps([66], 1) == 1","solution":"def max_jumps(arr, d): def dfs(i): if dp[i] != -1: return dp[i] max_count = 1 for direction in [-1, 1]: for j in range(1, d + 1): new_index = i + direction * j if 0 <= new_index < len(arr) and arr[new_index] < arr[i]: max_count = max(max_count, 1 + dfs(new_index)) else: break dp[i] = max_count return dp[i] dp = [-1] * len(arr) return max(dfs(i) for i in range(len(arr)))"},{"question":"from typing import List def canPartition(arr: List[int], k: int, m: int) -> bool: Partition an array into exactly \`k\` non-empty subsets such that the sum of elements in each subset is less than or equal to \`m\`. >>> canPartition([4, 3, 2, 3, 5, 2, 1], 4, 5) True >>> canPartition([4, 3, 2, 3, 5, 2, 1], 4, 4) False >>> canPartition([1, 2, 3, 4], 3, 5) False >>> canPartition([1, 2, 3, 4], 2, 10) True >>> canPartition([10], 1, 10) True >>> canPartition([10], 1, 5) False >>> canPartition([3, 3, 3, 3], 2, 6) True >>> canPartition([3, 3, 3, 3], 4, 3) True >>> canPartition([3, 3, 3, 3], 4, 2) False >>> canPartition([3, 3, 3, 3], 2, 5) False","solution":"from typing import List def canPartition(arr: List[int], k: int, m: int) -> bool: def canPartitionKSubsets(nums, k, target, start, cur_sum, visited): if k == 1: return True if cur_sum > target: return False if cur_sum == target: return canPartitionKSubsets(nums, k - 1, target, 0, 0, visited) for i in range(start, len(nums)): if not visited[i]: visited[i] = True if canPartitionKSubsets(nums, k, target, i + 1, cur_sum + nums[i], visited): return True visited[i] = False return False if sum(arr) % k != 0: return False target = sum(arr) // k if target > m: return False visited = [False] * len(arr) arr.sort(reverse=True) return canPartitionKSubsets(arr, k, target, 0, 0, visited)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: TreeNode) -> List[List[int]]: Return the zigzag level order traversal of a binary tree. >>> zigzagLevelOrder(None) [] >>> zigzagLevelOrder(TreeNode(1)) [[1]] >>> zigzagLevelOrder(TreeNode(1, TreeNode(2), TreeNode(3))) [[1], [3, 2]] >>> zigzagLevelOrder(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))) [[1], [3, 2], [4, 5, 6, 7]] >>> zigzagLevelOrder(TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, right=TreeNode(5)))) [[1], [3, 2], [4, 5]]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. if not root: return [] results = [] current_level = [root] left_to_right = True while current_level: level_values = [node.val for node in current_level] if not left_to_right: level_values.reverse() results.append(level_values) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level left_to_right = not left_to_right return results"},{"question":"def minAbsoluteSumDiff(nums1, nums2, k1, k2): Perform exactly \`k1\` increments on the elements of \`nums1\` and \`k2\` increments on the elements of \`nums2\` to minimize the sum of absolute differences between corresponding elements of the two arrays. Args: nums1: List[int] - First list of integers sorted in non-decreasing order. nums2: List[int] - Second list of integers sorted in non-decreasing order. k1: int - Number of increments to be performed on elements of \`nums1\`. k2: int - Number of increments to be performed on elements of \`nums2\`. Returns: int - Minimum possible sum of absolute differences after all increment operations. Examples: >>> minAbsoluteSumDiff([1, 3, 5, 7], [1, 4, 6, 8], 2, 2) 0 >>> minAbsoluteSumDiff([1, 1, 1, 1], [1, 1, 1, 1], 3, 3) 0 >>> minAbsoluteSumDiff([1], [2], 0, 1) 0 >>> minAbsoluteSumDiff([1, 10, 100, 1000], [2, 9, 101, 999], 10, 8) return value < 15 >>> minAbsoluteSumDiff([1, 2, 3, 4], [5, 6, 7, 8], 5, 5) 6","solution":"def minAbsoluteSumDiff(nums1, nums2, k1, k2): total_operations = k1 + k2 if not total_operations: return sum(abs(a - b) for a, b in zip(nums1, nums2)) diffs = [abs(a - b) for a, b in zip(nums1, nums2)] i = 0 while total_operations: max_diff_index = diffs.index(max(diffs)) if nums1[max_diff_index] > nums2[max_diff_index]: diff = nums1[max_diff_index] - nums2[max_diff_index] nums1[max_diff_index] -= 1 new_diff = abs(nums1[max_diff_index] - nums2[max_diff_index]) elif nums2[max_diff_index] > nums1[max_diff_index]: diff = nums2[max_diff_index] - nums1[max_diff_index] nums2[max_diff_index] -= 1 new_diff = abs(nums2[max_diff_index] - nums1[max_diff_index]) else: total_operations -= 1 continue diffs[max_diff_index] = new_diff total_operations -= 1 return sum(diffs)"},{"question":"def find_number_of_groups(n: int, connections: List[List[int]]) -> int: Determine the minimum number of groups the employees need to form so that every employee in each group can communicate with every other employee in the same group. :param n: Total number of employees :param connections: List of direct connections between employees :return: Minimum number of groups >>> find_number_of_groups(5, []) == 5 >>> find_number_of_groups(4, [[0, 1]]) == 3 >>> find_number_of_groups(3, [[0, 1], [1, 2]]) == 1 >>> find_number_of_groups(5, [[0, 1], [2, 3]]) == 3 >>> find_number_of_groups(6, [[0, 1], [1, 2], [3, 4], [4, 5]]) == 2","solution":"def find_number_of_groups(n, connections): Determine the minimum number of groups the employees need to form so that every employee in each group can communicate with every other employee in the same group. :param n: Total number of employees :param connections: List of direct connections between employees :return: Minimum number of groups # Utility DFS function to explore the graph def dfs(employee, visited, adjacency_list): visited.add(employee) for neighbor in adjacency_list[employee]: if neighbor not in visited: dfs(neighbor, visited, adjacency_list) # Build the adjacency list adjacency_list = {i: [] for i in range(n)} for e1, e2 in connections: adjacency_list[e1].append(e2) adjacency_list[e2].append(e1) # Find all connected components (groups) visited = set() groups = 0 for employee in range(n): if employee not in visited: groups += 1 dfs(employee, visited, adjacency_list) return groups"},{"question":"from typing import List def topKFrequent(nums: List[int], k: int) -> List[int]: Given a list of integers nums and an integer k, return the k most frequent elements in the list. The order of the output does not matter, but each element in the result must appear exactly k times. >>> topKFrequent([1, 1, 1, 2, 2, 3], 2) == [1, 2] >>> topKFrequent([1], 1) == [1] >>> topKFrequent([1, 2, 3, 4], 2) == [1, 2] >>> topKFrequent([1, 1, 2, 2, 3, 4, 4, 4, 5, 5, 5, 5], 3) == [5, 4, 1] >>> topKFrequent([4, 4, 4, 5, 5, 5, 5], 1) == [5]","solution":"from collections import Counter from typing import List def topKFrequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the list nums. count = Counter(nums) return [item for item, _ in count.most_common(k)]"},{"question":"def longest_inc_dec_subarray(arr: List[int]) -> int: Given an integer array \`arr\`, return the length of the longest subarray that is either strictly increasing or strictly decreasing. >>> longest_inc_dec_subarray([1, 3, 5, 4, 2, 1, 2, 3]) == 4 >>> longest_inc_dec_subarray([5]) == 1 >>> longest_inc_dec_subarray([1, 2, 3, 4, 5, 6, 7]) == 7 >>> longest_inc_dec_subarray([7, 6, 5, 4, 3, 2, 1]) == 7 >>> longest_inc_dec_subarray([5, 1, 2, 3, 4]) == 4 >>> longest_inc_dec_subarray([4, 3, 4, 1, 5, 6]) == 3 >>> longest_inc_dec_subarray([2, 2, 2, 2, 2, 2]) == 1 >>> longest_inc_dec_subarray([]) == 0","solution":"def longest_inc_dec_subarray(arr): n = len(arr) if n == 0: return 0 longest = 1 length_inc = 1 length_dec = 1 for i in range(1, n): if arr[i] > arr[i - 1]: length_inc += 1 length_dec = 1 elif arr[i] < arr[i - 1]: length_dec += 1 length_inc = 1 else: length_inc = 1 length_dec = 1 longest = max(longest, length_inc, length_dec) return longest"},{"question":"def insert(intervals, newInterval): Inserts a new interval into a list of existing intervals, merging overlapping intervals if necessary. :param intervals: List[List[int]] - A list of intervals [start, end] :param newInterval: List[int] - The interval that needs to be inserted [start, end] :return: List[List[int]] - The list of updated intervals after merging, if necessary. >>> insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]) == [[1, 2], [3, 10], [12, 16]] >>> insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [2,7]) == [[1, 7], [8, 10], [12, 16]] >>> insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [17,20]) == [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16], [17, 20]] >>> insert([[1,2],[3,4],[5,6]], [2, 5]) == [[1, 6]] >>> insert([], [4,8]) == [[4, 8]] >>> insert([[1,3]], [2,6]) == [[1, 6]] >>> insert([[3,5],[6,7],[8,10],[12,16]], [1,2]) == [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]] >>> insert([[1,2],[3,5],[6,7],[8,10]], [11,12]) == [[1, 2], [3, 5], [6, 7], [8, 10], [11, 12]]","solution":"def insert(intervals, newInterval): Inserts a new interval into a list of existing intervals, merging overlapping intervals if necessary. :param intervals: List[List[int]] - A list of intervals [start, end] :param newInterval: List[int] - The interval that needs to be inserted [start, end] :return: List[List[int]] - The list of updated intervals after merging, if necessary. merged = [] i, n = 0, len(intervals) # Add all intervals ending before the new interval starts. while i < n and intervals[i][1] < newInterval[0]: merged.append(intervals[i]) i += 1 # Merge all overlapping intervals to the new interval. while i < n and intervals[i][0] <= newInterval[1]: newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i += 1 merged.append(newInterval) # Add all the remaining intervals. while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"def kth_smallest_pair_distance(arr: List[int], k: int) -> int: Given an array of distinct integers \`arr\` and an integer \`k\`, return the \`kth\` smallest pair distance in the array. The distance of a pair (\`arr[i]\`, \`arr[j]\`) is defined as the absolute difference between \`arr[i]\` and \`arr[j]\`. >>> kth_smallest_pair_distance([1, 3, 1], 1) == 0 >>> kth_smallest_pair_distance([1, 6, 1], 3) == 5 >>> kth_smallest_pair_distance([9, 8, 7, 5], 3) == 2 >>> kth_smallest_pair_distance([-10, -20, -30], 2) == 10 >>> kth_smallest_pair_distance([1, 2, 3, 4], 6) == 3 >>> kth_smallest_pair_distance([2, 4, 6, 8, 10], 10) == 8","solution":"def kth_smallest_pair_distance(arr, k): Returns the kth smallest pair distance in the array. arr.sort() n = len(arr) pair_distances = [] for i in range(n): for j in range(i + 1, n): pair_distances.append(abs(arr[i] - arr[j])) pair_distances.sort() return pair_distances[k - 1]"},{"question":"def intersection(arr1, arr2): Given two integer arrays \`arr1\` and \`arr2\` sorted in non-decreasing order, return an array of the intersection of these two arrays. Each element in the result must be unique and you may return the result in any order. An integer \`a\` is in the intersection if it appears in both \`arr1\` and \`arr2\`. >>> intersection([1, 2, 2, 3], [2, 2, 3, 4]) == [2, 3] >>> intersection([1, 2, 3], [4, 5, 6]) == [] >>> intersection([], [1, 2, 3]) == [] >>> intersection([1, 2, 3], []) == [] >>> intersection([], []) == [] >>> intersection([1, 2, 2, 3, 3], [1, 2, 2, 3, 3]) == [1, 2, 3] >>> intersection([1], [1]) == [1] >>> intersection([1], [2]) == []","solution":"def intersection(arr1, arr2): Returns an array of the intersection of two arrays with unique elements. Args: arr1 (List[int]): First sorted array. arr2 (List[int]): Second sorted array. Returns: List[int]: Array of the unique intersection elements. set1 = set(arr1) set2 = set(arr2) return list(set1.intersection(set2))"},{"question":"def longestCommonSubsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between text1 and text2. >>> longestCommonSubsequence(\\"abcde\\", \\"ace\\") 3 >>> longestCommonSubsequence(\\"abc\\", \\"abc\\") 3 >>> longestCommonSubsequence(\\"abc\\", \\"def\\") 0 >>> longestCommonSubsequence(\\"abc\\", \\"\\") 0 >>> longestCommonSubsequence(\\"\\", \\"abc\\") 0 >>> longestCommonSubsequence(\\"bl\\", \\"yby\\") 1 >>> longestCommonSubsequence(\\"ezupkr\\", \\"ubmrapg\\") 2 >>> longestCommonSubsequence(\\"\\", \\"\\") 0 >>> longestCommonSubsequence(\\"a\\", \\"a\\") 1 >>> longestCommonSubsequence(\\"a\\", \\"b\\") 0 >>> longestCommonSubsequence(\\"abcdefgh\\", \\"hgfedcba\\") 1","solution":"def longestCommonSubsequence(text1, text2): Returns the length of the longest common subsequence between text1 and text2. m, n = len(text1), len(text2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The last cell of dp array contains the length of longest common subsequence return dp[m][n]"},{"question":"def is_palindromic_number(x: int) -> bool: Helper function to check if a number is palindromic. >>> is_palindromic_number(121) True >>> is_palindromic_number(123) False def palindromic_numbers(n: int) -> list: Returns a list of all palindromic numbers less than or equal to n. >>> palindromic_numbers(10) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> palindromic_numbers(15) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11]","solution":"def is_palindromic_number(x): Helper function to check if a number is palindromic. return str(x) == str(x)[::-1] def palindromic_numbers(n): Returns a list of all palindromic numbers less than or equal to n. return [i for i in range(n + 1) if is_palindromic_number(i)]"},{"question":"def min_sort_operations(heights): Returns the minimum number of sort operations required such that any pair of adjacent heights differ by at most 1 unit. >>> min_sort_operations([1, 1, 1, 1]) 0 >>> min_sort_operations([1, 2, 3, 4, 5]) 0 >>> min_sort_operations([4, 2, 3, 5]) 0 >>> min_sort_operations([1, 5]) 3 >>> min_sort_operations([10, 1]) 8 >>> min_sort_operations([3, 7, 5, 8, 2]) 5 >>> min_sort_operations([1]) 0","solution":"def min_sort_operations(heights): Returns the minimum number of sort operations required such that any pair of adjacent heights differ by at most 1 unit. heights.sort() # First sort the heights operations = 0 for i in range(1, len(heights)): if heights[i] - heights[i - 1] > 1: diff = heights[i] - (heights[i - 1] + 1) operations += diff heights[i] = heights[i - 1] + 1 # Adjust the current height to be max 1 unit more than previous one return operations"},{"question":"def max_flip_length(s: str) -> int: Returns the length of the largest substring containing continuous '1's that can be turned into all '0's or vice versa by a single flipping of a contiguous segment. >>> max_flip_length('1111111') 7 >>> max_flip_length('0000000') 7 >>> max_flip_length('110011') 2 >>> max_flip_length('000111000') 3 >>> max_flip_length('1010101') 1 >>> max_flip_length('') 0","solution":"def max_flip_length(s): Returns the length of the largest substring containing continuous '1's that can be turned into all '0's or vice versa by a single flipping of a contiguous segment. max_len = 0 count = 0 prev_char = '' for char in s: if char == prev_char: count += 1 else: max_len = max(max_len, count) count = 1 prev_char = char max_len = max(max_len, count) return max_len"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers in nums that add up to target. Parameters: nums (list of int): The list of integers to search. target (int): The target sum. Returns: list of int: A list containing the two indices. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1, 2, 3, 4, 5], 6) [1, 3] >>> two_sum([123456789, 987654321], 1111111110) [0, 1] >>> two_sum([1, 2, 3, 4], 8) []","solution":"def two_sum(nums, target): Returns the indices of the two numbers in nums that add up to target. Parameters: nums (list of int): The list of integers to search. target (int): The target sum. Returns: list of int: A list containing the two indices. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"from typing import List def longest_increasing_subsequence_length(arr: List[int]) -> int: Given an unsorted array of integers, return the length of the longest subsequence which is strictly increasing. >>> longest_increasing_subsequence_length([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence_length([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence_length([7, 7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence_length([1, 3, 5, 4, 7]) 4 >>> longest_increasing_subsequence_length([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence_length([]) 0 def test_longest_increasing_subsequence_length(): assert longest_increasing_subsequence_length([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert longest_increasing_subsequence_length([0, 1, 0, 3, 2, 3]) == 4 assert longest_increasing_subsequence_length([7, 7, 7, 7, 7, 7, 7]) == 1 assert longest_increasing_subsequence_length([1, 3, 5, 4, 7]) == 4 assert longest_increasing_subsequence_length([2, 2, 2, 2, 2]) == 1 assert longest_increasing_subsequence_length([]) == 0 if __name__ == \\"__main__\\": test_longest_increasing_subsequence_length() print(\\"All tests passed.\\")","solution":"from typing import List def longest_increasing_subsequence_length(arr: List[int]) -> int: if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"def count_substrings_with_3_unique_chars(s: str) -> int: Returns the number of substrings that contain exactly 3 unique characters. >>> count_substrings_with_3_unique_chars(\\"abcabc\\") 4 >>> count_substrings_with_3_unique_chars(\\"a\\") 0 >>> count_substrings_with_3_unique_chars(\\"ab\\") 0 >>> count_substrings_with_3_unique_chars(\\"abc\\") 1 >>> count_substrings_with_3_unique_chars(\\"aaaa\\") 0 >>> count_substrings_with_3_unique_chars(\\"aabbcc\\") 0 >>> count_substrings_with_3_unique_chars(\\"abcabxyz\\") 6 >>> count_substrings_with_3_unique_chars(\\"abcabcab\\") 6","solution":"def count_substrings_with_3_unique_chars(s): Returns the number of substrings that contain exactly 3 unique characters. n = len(s) if n < 3: return 0 count = 0 for i in range(n - 2): unique_chars = set() for j in range(i, min(i + 3, n)): unique_chars.add(s[j]) if len(unique_chars) == 3 and j == i + 2: count += 1 break return count"},{"question":"def subarrays_divisible_by_n(numbers: List[int], n: int) -> int: Given a 0-indexed integer array \`numbers\` and an integer \`n\`, return the number of subarrays of \`numbers\` such that the sum of the elements in each subarray is divisible by \`n\`. >>> subarrays_divisible_by_n([1, 2, 3, 4, 5], 5) 4 >>> subarrays_divisible_by_n([1, 2, 3], 10) 0 >>> subarrays_divisible_by_n([5, 10, 15], 5) 6 >>> subarrays_divisible_by_n([7, -5, 1, 3], 6) 1 >>> subarrays_divisible_by_n([12], 6) 1 >>> subarrays_divisible_by_n([7], 6) 0 >>> subarrays_divisible_by_n([4, 5, 0, -2, -3, 1], 5) 7 >>> subarrays_divisible_by_n([], 5) 0 >>> subarrays_divisible_by_n([0], 1) 1 >>> subarrays_divisible_by_n([0, 0, 0], 1) 6 pass","solution":"def subarrays_divisible_by_n(numbers, n): Returns the number of subarrays of \`numbers\` such that the sum of the elements in each subarray is divisible by \`n\`. count_map = {0: 1} prefix_sum = 0 count = 0 for num in numbers: prefix_sum += num remainder = prefix_sum % n # In case remainder is negative, make it positive if remainder < 0: remainder += n if remainder in count_map: count += count_map[remainder] count_map[remainder] += 1 else: count_map[remainder] = 1 return count"},{"question":"def min_sub_array_len(nums: List[int], target: int) -> int: Find the minimum length of a contiguous subarray of which the sum â‰¥ target. Return the length of the smallest subarray or 0 if no such subarray exists. >>> min_sub_array_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_sub_array_len([1, 4, 4], 8) 2 >>> min_sub_array_len([1, 1, 1, 1, 1, 1, 1, 1], 11) 0 >>> min_sub_array_len([7], 7) 1 >>> min_sub_array_len([1, 2, 3, 4, 5], 11) 3 >>> min_sub_array_len([1, 2, 3], 10) 0 >>> min_sub_array_len([1] * 100000, 10001) 10001","solution":"def min_sub_array_len(nums, target): Find the minimum length of a contiguous subarray of which the sum â‰¥ target. n = len(nums) min_length = float('inf') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def can_make_equal(A: str, B: str, K: int) -> bool: Determine if you can make the two strings equal by performing at most K operations. >>> can_make_equal(\\"abc\\", \\"abc\\", 0) == True >>> can_make_equal(\\"abc\\", \\"abc\\", 1) == True >>> can_make_equal(\\"abc\\", \\"abcd\\", 1) == False >>> can_make_equal(\\"abc\\", \\"abd\\", 1) == True >>> can_make_equal(\\"abc\\", \\"xyz\\", 3) == True >>> can_make_equal(\\"abc\\", \\"xyz\\", 2) == False >>> can_make_equal(\\"\\", \\"\\", 0) == True >>> can_make_equal(\\"a\\", \\"b\\", 1) == True >>> can_make_equal(\\"a\\", \\"b\\", 0) == False","solution":"def can_make_equal(A, B, K): Returns whether it's possible to make strings A and B equal with at most K operations. Arguments: A -- first string B -- second string K -- the maximum number of allowed operations Returns: True if A and B can be made equal with at most K operations, False otherwise. # If the strings are of different lengths, it's not possible to make them equal if len(A) != len(B): return False # Calculate the number of different characters between the two strings differences = sum(1 for a, b in zip(A, B) if a != b) # If the number of differences is less than or equal to the allowed operations (K), return True return differences <= K"},{"question":"def flip_surrounded_regions(grid: List[List[str]]) -> None: Modify the given 2D grid of characters containing 'X' and 'O' such that all completely surrounded regions of 'O' are flipped to 'X'. This function modifies the grid in-place and returns nothing. Example: >>> grid = [ ... ['X', 'X', 'X', 'X'], ... ['X', 'O', 'O', 'X'], ... ['X', 'X', 'O', 'X'], ... ['X', 'O', 'X', 'X'] ... ] >>> flip_surrounded_regions(grid) >>> grid [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X']]","solution":"def flip_surrounded_regions(grid): if not grid: return rows = len(grid) cols = len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != 'O': return grid[r][c] = 'T' directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc) # Start from the borders and mark all connected 'O's to 'T' for row in range(rows): if grid[row][0] == 'O': dfs(row, 0) if grid[row][cols - 1] == 'O': dfs(row, cols - 1) for col in range(cols): if grid[0][col] == 'O': dfs(0, col) if grid[rows - 1][col] == 'O': dfs(rows - 1, col) for r in range(rows): for c in range(cols): if grid[r][c] == 'O': grid[r][c] = 'X' elif grid[r][c] == 'T': grid[r][c] = 'O'"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string \\" \\". >>> first_non_repeating_character(\\"a\\") == \\"a\\" >>> first_non_repeating_character(\\"abcd\\") == \\"a\\" >>> first_non_repeating_character(\\"aabbccd\\") == \\"d\\" >>> first_non_repeating_character(\\"aabbcc\\") == \\" \\" >>> first_non_repeating_character(\\"aaabcccdeeef\\") == \\"b\\" >>> first_non_repeating_character(\\"\\") == \\" \\" >>> first_non_repeating_character(\\"aaaaa\\") == \\" \\" # implement the function","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string \\" \\". frequency = {} # Calculate frequency of each character for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the first non-repeating character for char in s: if frequency[char] == 1: return char return \\" \\""},{"question":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: Rearranges the elements of arr such that no element remains in its original position. Returns an empty array if no such rearrangement is possible. >>> rearrange_array([1]) [] >>> rearrange_array([1, 2, 3, 4]) [2, 3, 4, 1] # or any other valid rearrangement","solution":"def rearrange_array(arr): Rearranges the elements of arr such that no element remains in its original position. Returns an empty array if no such rearrangement is possible. n = len(arr) if n == 1: return [] # Create a simple derangement using a cyclic shift new_arr = arr[:] new_arr = new_arr[1:] + new_arr[:1] return new_arr"},{"question":"def get_happy_string(n: int, k: int) -> str: Return the k-th lexicographical happy string of length n. If there are less than k happy strings of length n, return an empty string. >>> get_happy_string(1, 1) == 'a' >>> get_happy_string(1, 4) == '' >>> get_happy_string(2, 1) == 'ab' >>> get_happy_string(2, 2) == 'ac' >>> get_happy_string(2, 3) == 'ba' >>> get_happy_string(3, 9) == 'cab' >>> get_happy_string(3, 15) == '' >>> get_happy_string(3, 1) == 'aba' >>> get_happy_string(0, 1) == '' >>> get_happy_string(5, 200) == '' >>> get_happy_string(5, 1) == 'ababa'","solution":"def get_happy_string(n, k): Return the k-th lexicographical happy string of length n. If there are less than k happy strings of length n, return an empty string. def generate_happy_strings(n, prefix=''): if n == 0: return [prefix] last_char = prefix[-1] if prefix else '' happy_strings = [] for char in 'abc': if char != last_char: happy_strings.extend(generate_happy_strings(n - 1, prefix + char)) return happy_strings happy_strings = generate_happy_strings(n) if k > len(happy_strings): return '' return happy_strings[k - 1]"},{"question":"def count_unique_substrings(s: str, k: int) -> int: Counts the number of substrings of length k in string s that contain no repeated characters. >>> count_unique_substrings(\\"havefunonleetcode\\", 5) == 6 >>> count_unique_substrings(\\"abcde\\", 3) == 3 >>> count_unique_substrings(\\"aaaaa\\", 2) == 0 >>> count_unique_substrings(\\"abc\\", 4) == 0 >>> count_unique_substrings(\\"abcd\\", 1) == 4 >>> count_unique_substrings(\\"\\", 3) == 0 >>> count_unique_substrings(\\"abcde\\", 5) == 1","solution":"def count_unique_substrings(s, k): Counts the number of substrings of length k in string s that contain no repeated characters. :param s: A string comprising lowercase English letters. :param k: An integer denoting the length of the substrings to consider. :return: An integer representing the number of substrings with no repeated characters. if k > len(s): return 0 count = 0 for i in range(len(s) - k + 1): window = s[i:i + k] if len(set(window)) == k: count += 1 return count"},{"question":"def num_server_clusters(grid): Returns the number of distinct clusters of online servers (1s) in the given 2D grid. A server cluster is defined as a group of connected online servers (1s). >>> num_server_clusters([]) == 0 >>> num_server_clusters([[1]]) == 1 >>> num_server_clusters([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 3 >>> num_server_clusters([ ... [1, 1, 0], ... [1, 0, 0], ... [0, 0, 1] ... ]) == 2 >>> num_server_clusters([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 1 >>> num_server_clusters([ ... [1, 0, 1, 0], ... [0, 1, 0, 1], ... [1, 0, 1, 0], ... [0, 1, 0, 1] ... ]) == 8","solution":"def num_server_clusters(grid): Returns the number of distinct clusters of online servers (1s) in the given 2D grid. A server cluster is defined as a group of connected online servers (1s). if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): Perform Depth-First Search to mark all reachable online servers as visited. if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0 or visited[r][c]: return visited[r][c] = True # Explore neighbors vertically and horizontally dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) clusters = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1 and not visited[i][j]: dfs(i, j) clusters += 1 return clusters"},{"question":"def min_length_after_operations(s: str) -> int: Given a string consisting only of characters 'a', 'b', and 'c', this function returns the minimum possible length of the string after performing the described operations any number of times. >>> min_length_after_operations(\\"abac\\") 0 >>> min_length_after_operations(\\"abcabc\\") 0 >>> min_length_after_operations(\\"a\\") 1 >>> min_length_after_operations(\\"aa\\") 0 >>> min_length_after_operations(\\"baab\\") 0 >>> min_length_after_operations(\\"abc\\") 1 >>> min_length_after_operations(\\"\\") 0 >>> min_length_after_operations(\\"aabac\\") 1 >>> min_length_after_operations(\\"aaaa\\") 0 >>> min_length_after_operations(\\"b\\") 1 >>> min_length_after_operations(\\"c\\") 1 >>> min_length_after_operations(\\"aaa\\") 1 >>> min_length_after_operations(\\"bb\\") 0","solution":"def min_length_after_operations(s): Given a string consisting only of characters 'a', 'b', and 'c', this function returns the minimum possible length of the string after performing the described operations any number of times. :param s: str :return: int return len(s) % 2"},{"question":"def longest_substring_with_k_unique(s: str, k: int) -> int: Given a string \`s\` consisting of lowercase English letters, find the longest contiguous substring of \`s\` that contains duplicate letters in exactly \`k\` unique characters. Return the length of this substring. If no such substring exists, return 0. >>> longest_substring_with_k_unique(\\"araaci\\", 2) == 4 # \\"araa\\" >>> longest_substring_with_k_unique(\\"araaci\\", 1) == 2 # \\"aa\\" >>> longest_substring_with_k_unique(\\"cbbebi\\", 3) == 5 # \\"cbbeb\\" or \\"bbebi\\" >>> longest_substring_with_k_unique(\\"aaaaaaaaaaa\\", 1) == 11 # entire string >>> longest_substring_with_k_unique(\\"abaccc\\", 2) == 4 # \\"abac\\"","solution":"def longest_substring_with_k_unique(s, k): from collections import defaultdict n = len(s) if n == 0 or k == 0: return 0 # Sliding window start and end pointers start = 0 maxlen = 0 # Dictionary to store the frequency of characters in the current window char_freq = defaultdict(int) unique_count = 0 for end in range(n): # Include the character at the end in the current window char_freq[s[end]] += 1 # If this character count becomes 1, then we have one more unique character in the window if char_freq[s[end]] == 1: unique_count += 1 # If unique character count exceeds k, shrink the window from the start while unique_count > k: char_freq[s[start]] -= 1 if char_freq[s[start]] == 0: unique_count -= 1 start += 1 # Check if the current window size is larger than the maxlen if unique_count == k: maxlen = max(maxlen, end - start + 1) return maxlen"},{"question":"from typing import List def smallest_equivalent_uuids(uuids: List[str], relations: List[List[str]]) -> List[str]: Given an array of UUIDs and a set of relations indicating which UUIDs are equivalent, return the UUIDs array with each element replaced by its smallest equivalent UUID (lexicographically). Example: >>> smallest_equivalent_uuids([\\"uuid1\\", \\"uuid2\\", \\"uuid3\\", \\"uuid4\\"], [[\\"uuid1\\", \\"uuid2\\"], [\\"uuid3\\", \\"uuid4\\"], [\\"uuid2\\", \\"uuid3\\"]]) [\\"uuid1\\", \\"uuid1\\", \\"uuid1\\", \\"uuid1\\"] >>> smallest_equivalent_uuids([\\"uuid1\\", \\"uuid2\\", \\"uuid3\\", \\"uuid4\\"], []) [\\"uuid1\\", \\"uuid2\\", \\"uuid3\\", \\"uuid4\\"] pass # Your implementation here def test_example_case(): uuids = [\\"uuid1\\", \\"uuid2\\", \\"uuid3\\", \\"uuid4\\"] relations = [[\\"uuid1\\", \\"uuid2\\"], [\\"uuid3\\", \\"uuid4\\"], [\\"uuid2\\", \\"uuid3\\"]] assert smallest_equivalent_uuids(uuids, relations) == [\\"uuid1\\", \\"uuid1\\", \\"uuid1\\", \\"uuid1\\"] def test_no_relations(): uuids = [\\"uuid1\\", \\"uuid2\\", \\"uuid3\\", \\"uuid4\\"] relations = [] assert smallest_equivalent_uuids(uuids, relations) == [\\"uuid1\\", \\"uuid2\\", \\"uuid3\\", \\"uuid4\\"] def test_all_equivalent(): uuids = [\\"uuid3\\", \\"uuid2\\", \\"uuid1\\", \\"uuid4\\"] relations = [[\\"uuid1\\", \\"uuid2\\"], [\\"uuid3\\", \\"uuid4\\"], [\\"uuid2\\", \\"uuid3\\"]] assert smallest_equivalent_uuids(uuids, relations) == [\\"uuid1\\", \\"uuid1\\", \\"uuid1\\", \\"uuid1\\"] def test_partial_equivalence(): uuids = [\\"uuid5\\", \\"uuid1\\", \\"uuid3\\", \\"uuid2\\"] relations = [[\\"uuid1\\", \\"uuid2\\"], [\\"uuid3\\", \\"uuid1\\"]] assert smallest_equivalent_uuids(uuids, relations) == [\\"uuid5\\", \\"uuid1\\", \\"uuid1\\", \\"uuid1\\"] def test_self_relation(): uuids = [\\"uuid9\\", \\"uuid8\\", \\"uuid7\\", \\"uuid6\\"] relations = [[\\"uuid7\\", \\"uuid7\\"], [\\"uuid8\\", \\"uuid8\\"]] assert smallest_equivalent_uuids(uuids, relations) == [\\"uuid9\\", \\"uuid8\\", \\"uuid7\\", \\"uuid6\\"] def test_large_case(): uuids = [\\"uuid\\" + str(i) for i in range(1000)] relations = [[\\"uuid0\\", \\"uuid1\\"]] + [[\\"uuid\\" + str(i), \\"uuid\\" + str(i + 1)] for i in range(1, 999)] expected_output = [\\"uuid0\\"] * 1000 assert smallest_equivalent_uuids(uuids, relations) == expected_output","solution":"def find_parent(parent, u): if parent[u] != u: parent[u] = find_parent(parent, parent[u]) return parent[u] def union(parent, rank, u, v): root_u = find_parent(parent, u) root_v = find_parent(parent, v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 def smallest_equivalent_uuids(uuids, relations): parent = {uuid: uuid for uuid in uuids} rank = {uuid: 0 for uuid in uuids} for u, v in relations: union(parent, rank, u, v) for uuid in uuids: find_parent(parent, uuid) group_to_smallest = {} for uuid in uuids: root = parent[uuid] if root not in group_to_smallest: group_to_smallest[root] = uuid else: group_to_smallest[root] = min(group_to_smallest[root], uuid) for uuid in uuids: uuids[uuids.index(uuid)] = group_to_smallest[parent[uuid]] return uuids"},{"question":"def can_be_rotated(s1: str, s2: str) -> bool: Returns True if s1 can be rotated to become s2, False otherwise. >>> can_be_rotated(\\"abcde\\", \\"cdeab\\") True >>> can_be_rotated(\\"abcde\\", \\"abced\\") False","solution":"def can_be_rotated(s1, s2): Returns True if s1 can be rotated to become s2, False otherwise. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"def eventual_safe_nodes(n: int, edges: List[List[int]]) -> List[int]: Given a list of nodes and directed edges, return a list of all safe nodes in ascending order. >>> eventual_safe_nodes(3, []) == [0, 1, 2] >>> eventual_safe_nodes(4, [[0, 1], [1, 2], [2, 3]]) == [0, 1, 2, 3] >>> eventual_safe_nodes(3, [[0, 1], [1, 2], [2, 0]]) == [] >>> eventual_safe_nodes(5, [[0, 1], [1, 2], [2, 3], [3, 0], [2, 4]]) == [4] >>> eventual_safe_nodes(6, [[0, 1], [1, 2], [2, 5], [3, 4], [4, 5]]) == [0, 1, 2, 3, 4, 5]","solution":"def eventual_safe_nodes(n, edges): from collections import defaultdict, deque graph = defaultdict(list) reverse_graph = defaultdict(list) in_degree = [0] * n for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) in_degree[u] += 1 queue = deque() for i in range(n): if in_degree[i] == 0: queue.append(i) safe_nodes = [] while queue: node = queue.popleft() safe_nodes.append(node) for prev_node in reverse_graph[node]: in_degree[prev_node] -= 1 if in_degree[prev_node] == 0: queue.append(prev_node) return sorted(safe_nodes)"},{"question":"from typing import List def longest_concatenated_length(words: List[str], k: int) -> int: Returns the length of the longest resulting string by concatenating exactly k strings from the words array. >>> longest_concatenated_length([\\"a\\", \\"b\\", \\"c\\"], 2) == 2 >>> longest_concatenated_length([\\"abc\\", \\"de\\", \\"fghi\\"], 2) == 7 >>> longest_concatenated_length([\\"hello\\", \\"world\\"], 1) == 5 >>> longest_concatenated_length([\\"a\\", \\"bc\\", \\"def\\"], 3) == 6 >>> longest_concatenated_length([], 1) == 0 >>> longest_concatenated_length([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], 2) == 2","solution":"from itertools import combinations def longest_concatenated_length(words, k): Returns the length of the longest resulting string by concatenating exactly k strings from the words array. max_length = 0 for combo in combinations(words, k): concatenated = ''.join(combo) max_length = max(max_length, len(concatenated)) return max_length"},{"question":"def max_candies(types: List[int]) -> int: Returns the maximum number of different types of candies you can eat if you can only eat n / 2 candies in total, where n is the length of the array. >>> max_candies([1, 2, 3, 4, 5, 6]) 3 >>> max_candies([1, 1, 2, 2, 3, 3]) 3 >>> max_candies([1, 1, 1, 1, 1, 1]) 1 >>> max_candies([1, 1, 2, 3, 3, 3, 4, 4]) 4 >>> max_candies([1]) 0 >>> max_candies([1, 2]) 1 >>> max_candies([]) 0","solution":"def max_candies(types): Returns the maximum number of different types of candies you can eat if you can only eat n / 2 candies in total, where n is the length of the array. # Total number of candies n = len(types) # Total candies you can eat max_candies_to_eat = n // 2 # Unique types of candies unique_types = len(set(types)) # Maximum number of different types of candies you can eat return min(max_candies_to_eat, unique_types)"},{"question":"def sum_beauties(arr: List[int], k: int) -> int: Find the sum of the beauties of all subsequences of length \`k\` in the array \`arr\`. The beauty of a subsequence is defined as the product of the maximum value and the minimum value in the subsequence. Since the sum may be too large, return it modulo \`10^9 + 7\`. >>> sum_beauties([1, 3, 2], 2) # Subsequences: [(1, 3), (1, 2), (3, 2)] -> Beauties: [3*1, 2*1, 3*2] -> Sum: 3+2+6=11 11 >>> sum_beauties([5], 1) # Subsequence: [(5)] -> Beauty: 5*5=25 25 >>> sum_beauties([1, 2, 3], 3) # Subsequence: [(1, 2, 3)] -> Beauty: 3*1=3 3 >>> sum_beauties([1, 2], 3) # No subsequence of length 3 0 >>> sum_beauties([], 1) # No subsequences 0 >>> sum_beauties([1, 2, 3], 0) # No subsequences of zero-length 0","solution":"MOD = 10**9 + 7 def sum_beauties(arr, k): from itertools import combinations if k < 1 or k > len(arr): return 0 sum_beauty = 0 for subseq in combinations(arr, k): max_val = max(subseq) min_val = min(subseq) sum_beauty = (sum_beauty + max_val * min_val) % MOD return sum_beauty"},{"question":"class Solution: def characterReplacement(self, s: str, k: int) -> int: You are given a string \`s\` and an integer \`k\`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most \`k\` times. Return the length of the longest substring containing the same letter you can get after performing the above operations. Args: s (str): The given string consisting of uppercase English letters. k (int): The maximum number of characters you can change. Returns: int: The length of the longest substring containing the same letter after making at most \`k\` changes. Examples: >>> sol = Solution() >>> sol.characterReplacement(\\"ABAB\\", 2) 4 >>> sol.characterReplacement(\\"AABABBA\\", 1) 4 from solution import Solution def test_character_replacement(): sol = Solution() assert sol.characterReplacement(\\"ABAB\\", 2) == 4 assert sol.characterReplacement(\\"AABABBA\\", 1) == 4 assert sol.characterReplacement(\\"ABBB\\", 2) == 4 def test_character_replacement_with_edge_cases(): sol = Solution() assert sol.characterReplacement(\\"\\", 0) == 0 assert sol.characterReplacement(\\"A\\", 0) == 1 assert sol.characterReplacement(\\"A\\", 1) == 1 assert sol.characterReplacement(\\"AB\\", 0) == 1 assert sol.characterReplacement(\\"AB\\", 1) == 2 def test_character_replacement_with_large_k(): sol = Solution() assert sol.characterReplacement(\\"AABABBA\\", 5) == 7 assert sol.characterReplacement(\\"ABCDE\\", 5) == 5","solution":"class Solution: def characterReplacement(self, s: str, k: int) -> int: max_count = 0 start = 0 char_count = {} for end in range(len(s)): # Increment the count of the current character char_count[s[end]] = char_count.get(s[end], 0) + 1 max_count = max(max_count, char_count[s[end]]) # If the current window size minus the most frequent character count is greater than k # Then shrink the window from the start if (end - start + 1) - max_count > k: char_count[s[start]] -= 1 start += 1 return len(s) - start"},{"question":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees clockwise. Parameters: matrix (list of list of int): The square matrix to be rotated Returns: list of list of int: The matrix rotated 90 degrees clockwise Examples: >>> rotate_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ [1, 2], [3, 4] ]) [[3, 1], [4, 2]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] pass","solution":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees clockwise. Parameters: matrix (list of list of int): The square matrix to be rotated Returns: list of list of int: The matrix rotated 90 degrees clockwise n = len(matrix) rotated_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. >>> rob([]) 0 >>> rob([5]) 5 >>> rob([10]) 10 >>> rob([5, 3]) 5 >>> rob([7, 8]) 8 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([1, 2, 3, 1]) 4 >>> rob([5, 5, 10, 100, 10, 5]) 110 >>> rob([10, 20, 30, 40, 50, 60, 70]) 160 >>> rob([6, 7, 1, 30, 8, 2, 4]) 41 >>> rob([0, 0, 0, 0]) 0 >>> rob([10, 1, 10, 1, 10]) 30","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize two variables to keep track of the maximum money robbed so far prev1 = 0 prev2 = 0 for num in nums: # Calculate the maximum money robbed if current house is included temp = max(prev1, prev2 + num) # Update prev2 to the previous result prev2 = prev1 # Update prev1 to the current maximum prev1 = temp return prev1"},{"question":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_duplicate_subtrees(root: TreeNode) -> List[TreeNode]: Identify duplicate subtrees in a binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(4)) >>> root.right = TreeNode(3, TreeNode(2, TreeNode(4)), TreeNode(4)) >>> duplicates = find_duplicate_subtrees(root) >>> len(duplicates) 2 >>> sorted([node.val for node in duplicates]) [2, 4] >>> root = TreeNode(1) >>> assert find_duplicate_subtrees(root) == [] pass","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_duplicate_subtrees(root): def serialize_subtree(node): if node is None: return \\"#\\" left_serialized = serialize_subtree(node.left) right_serialized = serialize_subtree(node.right) subtree_key = f\\"{node.val},{left_serialized},{right_serialized}\\" subtree_count[subtree_key] += 1 if subtree_count[subtree_key] == 2: # Only add once duplicates.append(node) return subtree_key subtree_count = defaultdict(int) duplicates = [] serialize_subtree(root) return duplicates"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Given an m x n matrix board representing the current state of a crossword puzzle, return true if the given word can be found in the matrix and false otherwise. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"ABCCED\\") True >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"ABCB\\") False >>> exist([], \\"A\\") False >>> exist([['A']], \\"A\\") True >>> exist([['A']], \\"B\\") False >>> exist([['A', 'B', 'C', 'E'], ['X', 'X', 'X', 'X'], ['A', 'D', 'E', 'E']], \\"ABE\\") False","solution":"def exist(board, word): def dfs(board, word, i, j, k): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False temp = board[i][j] board[i][j] = '#' found = (dfs(board, word, i + 1, j, k + 1) or dfs(board, word, i - 1, j, k + 1) or dfs(board, word, i, j + 1, k + 1) or dfs(board, word, i, j - 1, k + 1)) board[i][j] = temp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"def search_matrix(grid: List[List[int]], target: int) -> Tuple[int, int]: Returns the position of target in the matrix in the form of a tuple (i, j). If target is not present in the matrix, returns (-1, -1). >>> grid = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> search_matrix(grid, 5) (1, 1) >>> search_matrix(grid, 21) (4, 1) >>> search_matrix(grid, 20) (-1, -1) >>> search_matrix([], 10) (-1, -1) >>> search_matrix([[5]], 5) (0, 0) >>> search_matrix([[5]], 1) (-1, -1) pass","solution":"def search_matrix(grid, target): Returns the position of target in the matrix in the form of a tuple (i, j). If target is not present in the matrix, returns (-1, -1) if not grid: return (-1, -1) rows = len(grid) cols = len(grid[0]) # Start from top-right corner of the matrix i = 0 j = cols - 1 while i < rows and j >= 0: if grid[i][j] == target: return (i, j) elif grid[i][j] > target: j -= 1 else: i += 1 return (-1, -1)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_deepest_leaves(root: TreeNode) -> int: Write a function that returns the sum of values of all nodes at the deepest level of the tree. >>> sum_deepest_leaves(TreeNode(1, TreeNode(2), TreeNode(3))) 5 >>> sum_deepest_leaves(TreeNode(1)) 1 >>> sum_deepest_leaves(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_deepest_leaves(root): if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"def trap(height): Given a list of heights representing a terrain, calculate the total amount of water that can be trapped after raining. :param height: List of integers representing the heights. :return: Integer representing the total amount of trapped water.","solution":"def trap(height): Given a list of heights representing a terrain, calculate the total amount of water that can be trapped after raining. :param height: List of integers representing the heights. :return: Integer representing the total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def reverse_words_characters(s: str) -> str: Given a string s representing a list of words separated by a single space, reverse the order of characters in each word while preserving the original word order. :param s: str - input string :return: str - transformed string >>> reverse_words_characters(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words_characters(\\"The quick brown fox\\") \\"ehT kciuq nworb xof\\" >>> reverse_words_characters(\\"a b c d\\") \\"a b c d\\" >>> reverse_words_characters(\\"racecar\\") \\"racecar\\" >>> reverse_words_characters(\\"\\") \\"\\"","solution":"def reverse_words_characters(s): Given a string s representing a list of words separated by a single space, reverse the order of characters in each word while preserving the original word order. :param s: str - input string :return: str - transformed string words = s.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"from typing import List def highest_frequency_element(arr: List[int]) -> int: Determine the element with the maximum frequency in the array. If there is a tie for the maximum frequency, return the smallest element among them. >>> highest_frequency_element([1]) 1 >>> highest_frequency_element([1, 1, 2, 3, 2, 1]) 1 >>> highest_frequency_element([1, 2, 2, 3, 3]) 2 >>> highest_frequency_element([3, 3, 3]) 3 >>> highest_frequency_element([4, -1, -1, 2, 4, 4, -1, -1]) -1 >>> highest_frequency_element([]) None","solution":"from collections import Counter def highest_frequency_element(arr): Returns the element with the highest frequency in the array. If there is a tie, returns the smallest element among them. if not arr: return None counter = Counter(arr) highest_frequency = max(counter.values()) candidates = [k for k, v in counter.items() if v == highest_frequency] return min(candidates)"},{"question":"def min_moves_to_make_palindrome(s: str) -> int: Returns the minimum number of moves needed to make the string a palindrome, or -1 if it is impossible. >>> min_moves_to_make_palindrome(\\"\\") == 0 >>> min_moves_to_make_palindrome(\\"a\\") == 0 >>> min_moves_to_make_palindrome(\\"abba\\") == 0 >>> min_moves_to_make_palindrome(\\"racecar\\") == 0 >>> min_moves_to_make_palindrome(\\"abcba\\") == 0 >>> min_moves_to_make_palindrome(\\"aabb\\") == 2 >>> min_moves_to_make_palindrome(\\"mamad\\") == 3 >>> min_moves_to_make_palindrome(\\"abcdef\\") == -1 >>> min_moves_to_make_palindrome(\\"abcda\\") == -1 pass from solution import min_moves_to_make_palindrome def test_empty_string(): assert min_moves_to_make_palindrome(\\"\\") == 0 def test_single_char_string(): assert min_moves_to_make_palindrome(\\"a\\") == 0 def test_already_palindrome(): assert min_moves_to_make_palindrome(\\"abba\\") == 0 assert min_moves_to_make_palindrome(\\"racecar\\") == 0 def test_simple_cases(): assert min_moves_to_make_palindrome(\\"abcba\\") == 0 assert min_moves_to_make_palindrome(\\"aabb\\") == 2 def test_complex_case(): assert min_moves_to_make_palindrome(\\"mamad\\") == 3 def test_impossible_cases(): assert min_moves_to_make_palindrome(\\"abcdef\\") == -1 assert min_moves_to_make_palindrome(\\"abcda\\") == -1","solution":"def min_moves_to_make_palindrome(s: str) -> int: Returns the minimum number of moves needed to make the string a palindrome, or -1 if it is impossible. def count_freq(s): return {char: s.count(char) for char in set(s)} freq = count_freq(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) if odd_count > 1: return -1 def min_swaps(s1): s1 = list(s1) n = len(s1) count = 0 for i in range(n // 2): left = i right = n - left - 1 while left < right: if s1[left] == s1[right]: break else: right -= 1 if left == right: s1[left], s1[left + 1] = s1[left + 1], s1[left] count += 1 left -= 1 else: for j in range(right, n - left - 1): s1[j], s1[j + 1] = s1[j + 1], s1[j] count += 1 return count return min_swaps(s)"},{"question":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. Parameters: grid (List[List[int]]): The grid with obstacles (0 - empty cell, 1 - obstacle) Returns: int: The number of unique paths Examples: >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths_with_obstacles([[1, 0]]) 0 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0], [0, 0], [0, 0]]) 3","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. :param grid: List[List[int]] The grid with obstacles (0 - empty cell, 1 - obstacle) :return: int The number of unique paths if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) # Initialize the dp array dp = [[0] * n for _ in range(m)] # Starting point dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"from typing import List def reorganize_string(s: str) -> str: Re-arranges a string such that no two identical letters are adjacent. If it's not possible, returns an empty string. >>> reorganize_string(\\"aab\\") in [\\"aba\\"] >>> reorganize_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] >>> reorganize_string(\\"aaabb\\") in [\\"ababa\\", \\"babab\\"] >>> reorganize_string(\\"aaab\\") == \\"\\" >>> reorganize_string(\\"aaaaaa\\") == \\"\\" >>> reorganize_string(\\"a\\") == \\"a\\" >>> reorganize_string(\\"aa\\") == \\"\\" >>> reorganize_string(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> reorganize_string(\\"\\") == \\"\\"","solution":"from collections import Counter import heapq def reorganize_string(s): Re-arranges a string such that no two identical letters are adjacent. If it's not possible, returns an empty string. # Create a count of each character count = Counter(s) max_heap = [(-v, k) for k, v in count.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] # Process the heap while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) count += 1 # Decrease the count (remember it's a max-heap) prev_count, prev_char = count, char result = ''.join(result) if len(result) != len(s): return \\"\\" return result"},{"question":"def min_window(s: str, t: str) -> str: Returns the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\"\\". >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" >>> min_window(\\"a\\", \\"a\\") == \\"a\\" >>> min_window(\\"a\\", \\"b\\") == \\"\\" >>> min_window(\\"AAABBBCCC\\", \\"ABC\\") == \\"ABBBC\\" >>> min_window(\\"\\", \\"A\\") == \\"\\" >>> min_window(\\"A\\", \\"\\") == \\"\\" >>> min_window(\\"a\\", \\"aa\\") == \\"\\" >>> min_window(\\"ab\\", \\"b\\") == \\"b\\" >>> min_window(\\"ab\\", \\"a\\") == \\"a\\" >>> min_window(\\"ab\\", \\"ab\\") == \\"ab\\" >>> min_window(\\"aa\\", \\"aa\\") == \\"aa\\"","solution":"from collections import Counter def min_window(s, t): Returns the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\"\\". if not s or not t: return \\"\\" t_count = Counter(t) current_count = Counter() left = 0 min_len = float(\\"inf\\") min_window = \\"\\" have, need = 0, len(t_count) for right in range(len(s)): character = s[right] current_count[character] += 1 if character in t_count and current_count[character] == t_count[character]: have += 1 while have == need: window_length = right - left + 1 if window_length < min_len: min_len = window_length min_window = s[left:right+1] current_count[s[left]] -= 1 if s[left] in t_count and current_count[s[left]] < t_count[s[left]]: have -= 1 left += 1 return min_window"},{"question":"def trap_rainwater(heights: List[int]) -> int: Compute the total amount of trapped rainwater given the heights of walls. :param heights: List of integers representing the height of walls. :return: Total amount of trapped rainwater. >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9 >>> trap_rainwater([]) 0 >>> trap_rainwater([1, 2]) 0 >>> trap_rainwater([1, 2, 1]) 0 >>> trap_rainwater([1, 1, 1, 1]) 0 >>> trap_rainwater([0, 1, 0, 2]) 1 >>> trap_rainwater([3, 0, 2]) 2 >>> trap_rainwater([3, 1, 2, 1, 2, 1, 3]) 8 >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6","solution":"def trap_rainwater(heights): Compute the total amount of trapped rainwater given the heights of walls. :param heights: List of integers representing the height of walls. :return: Total amount of trapped rainwater. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] total_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) total_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) total_water += max(0, right_max - heights[right]) return total_water"},{"question":"def find_duplicate(arr): Returns the duplicate number in the given array. Note: You must solve the problem without modifying the input array \`arr\` and use only constant extra space. >>> find_duplicate([1, 3, 4, 2, 2]) == 2 >>> find_duplicate([3, 1, 3, 4, 2]) == 3 >>> find_duplicate([1, 3, 4, 2, 2, 2]) == 2 >>> find_duplicate([3, 1, 3, 3, 4, 2]) == 3 >>> find_duplicate([6, 1, 5, 3, 4, 2, 6]) == 6 >>> find_duplicate([8, 7, 1, 2, 3, 4, 5, 6, 8]) == 8 >>> find_duplicate([1, 1]) == 1 >>> find_duplicate([2, 2, 2, 2, 2]) == 2","solution":"def find_duplicate(arr): Returns the duplicate number in the given array. # Using Floyd's Tortoise and Hare (Cycle Detection) tortoise = hare = arr[0] while True: tortoise = arr[tortoise] hare = arr[arr[hare]] if tortoise == hare: break tortoise = arr[0] while tortoise != hare: tortoise = arr[tortoise] hare = arr[hare] return hare"},{"question":"def longest_valid_parentheses(s: str) -> int: Returns the length of the longest valid (well-formed) parentheses substring in the given string \`s\`. >>> longest_valid_parentheses(\\"\\") == 0 >>> longest_valid_parentheses(\\"((((\\") == 0 >>> longest_valid_parentheses(\\"))))\\") == 0 >>> longest_valid_parentheses(\\")(\\") == 0 >>> longest_valid_parentheses(\\"()()\\") == 4 >>> longest_valid_parentheses(\\"(()())\\") == 6 >>> longest_valid_parentheses(\\")()())\\") == 4 >>> longest_valid_parentheses(\\"((())\\") == 4 >>> longest_valid_parentheses(\\"(()())()))\\") == 8 >>> longest_valid_parentheses(\\"((()))\\") == 6 >>> longest_valid_parentheses(\\"()(()()\\") == 4","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid (well-formed) parentheses substring in the given string \`s\`. stack = [] max_len = 0 last_invalid_index = -1 for i, char in enumerate(s): if char == '(': stack.append(i) else: # char == ')' if not stack: last_invalid_index = i else: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: max_len = max(max_len, i - last_invalid_index) return max_len"},{"question":"def countPairs(nums: List[int], target: int) -> int: Return the number of unique pairs (i, j) such that nums[i] + nums[j] == target. >>> countPairs([1, 2, 3, 4, 5], 10) 0 >>> countPairs([1, 2, 3, 4, 5], 6) 2 >>> countPairs([1, 5, 7, -1, 5], 6) 2 >>> countPairs([1, 1, 1, 1], 2) 1 >>> countPairs([-1, -2, 3, 4, 1, 0], 1) 2 >>> countPairs([], 3) 0","solution":"def countPairs(nums, target): Return the number of unique pairs (i, j) such that nums[i] + nums[j] == target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"def find_farmland(grid): Given a 2D grid of size \`m x n\` with cells representing land (1) and water (0), identify all farmlands and return their top-left and bottom-right coordinates. >>> find_farmland([ [1, 1, 0], [1, 1, 0], [0, 0, 0] ]) [[0, 0, 1, 1]] >>> find_farmland([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ]) [[0, 0, 1, 1], [2, 2, 3, 3]] >>> find_farmland([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) [[0, 0, 2, 2]] >>> find_farmland([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) [] >>> find_farmland([ [1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1] ]) [[0, 0, 1, 1], [0, 3, 1, 4], [3, 0, 4, 1], [3, 3, 4, 4]]","solution":"def find_farmland(grid): Given a 2D grid of size \`m x n\` with cells representing land (1) and water (0), identify all farmlands and return their top-left and bottom-right coordinates. def dfs(i, j): stack = [(i, j)] top, left = i, j bottom, right = i, j while stack: x, y = stack.pop() bottom = max(bottom, x) right = max(right, y) grid[x][y] = 0 for dx, dy in [(0, 1), (1, 0)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: stack.append((nx, ny)) return [top, left, bottom, right] m, n = len(grid), len(grid[0]) farmlands = [] for i in range(m): for j in range(n): if grid[i][j] == 1: farmland = dfs(i, j) farmlands.append(farmland) return farmlands"},{"question":"from typing import List from collections import defaultdict def group_anagrams(strs: List[str]) -> List[List[str]]: Groups the strings that are anagrams of each other. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"yxz\\"]) == [['abc', 'bca', 'cab'], ['xyz', 'yxz']] >>> group_anagrams([]) == [] >>> group_anagrams([\\"a\\", \\"b\\", \\"c\\"]) == [['a'], ['b'], ['c']] >>> group_anagrams([\\"a\\", \\"a\\", \\"b\\", \\"b\\", \\"c\\"]) == [['a', 'a'], ['b', 'b'], ['c']]","solution":"from collections import defaultdict from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams from the given list of strings. Args: strs (List[str]): A list of strings. Returns: List[List[str]]: A list of lists where each sub-list contains anagrams. anagram_map = defaultdict(list) for s in strs: # The sorted tuple of the string will be the key sorted_str = tuple(sorted(s)) anagram_map[sorted_str].append(s) return list(anagram_map.values())"},{"question":"from typing import List class WordChain: def __init__(self, words: List[str]): Initializes the object with the given array of words. Example: >>> wc = WordChain([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"]) pass def longestChain(self) -> List[str]: Returns a list of strings representing the longest chain of words. If there are multiple chains of the same length, returns any one of them. Example: >>> wc = WordChain([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"]) >>> wc.longestChain() [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"] pass def test_empty_list(): wc = WordChain([]) assert wc.longestChain() == [] def test_single_word(): wc = WordChain([\\"a\\"]) assert wc.longestChain() == [\\"a\\"] def test_two_words(): wc = WordChain([\\"ab\\", \\"b\\"]) assert wc.longestChain() == [\\"b\\", \\"ab\\"] def test_multiple_words(): wc = WordChain([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abfd\\", \\"abcde\\"]) chain = wc.longestChain() assert len(chain) == 5 # The longest chain is [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"] def test_multiple_longest_chains(): wc = WordChain([\\"a\\", \\"ba\\", \\"bca\\", \\"b\\", \\"bda\\", \\"bdca\\"]) chain = wc.longestChain() assert len(chain) == 4 # One possible chain is [\\"a\\", \\"ba\\", \\"bca\\", \\"bdca\\"] assert set(chain) == set([\\"a\\", \\"ba\\", \\"bca\\", \\"bdca\\"]) or set(chain) == set([\\"b\\", \\"ba\\", \\"bda\\", \\"bdca\\"])","solution":"class WordChain: def __init__(self, words): self.words = words def is_predecessor(self, w1, w2): if len(w2) != len(w1) + 1: return False i, j = 0, 0 # Pointers for w1 and w2 while i < len(w1) and j < len(w2): if w1[i] == w2[j]: i += 1 j += 1 return i == len(w1) def longestChain(self): if not self.words: return [] self.words.sort(key=len) # Sort words by their lengths chains = {word: [word] for word in self.words} for i in range(len(self.words)): for j in range(i): if self.is_predecessor(self.words[j], self.words[i]): if len(chains[self.words[j]]) + 1 > len(chains[self.words[i]]): chains[self.words[i]] = chains[self.words[j]] + [self.words[i]] longest = [] for chain in chains.values(): if len(chain) > len(longest): longest = chain return longest"},{"question":"def evaluate_expression(s: str) -> int: Evaluates a mathematical expression string containing non-negative integers and the operators +, -, *, and /. The expression may also contain parentheses to specify the order of operations. Note that the division operator should truncate the result towards zero. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5 >>> evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") 21 >>> evaluate_expression(\\"(2+6* 3+5- (3*14/7+2)*5)+3\\") -12 >>> evaluate_expression(\\"3*(2+1)-(2*(2+2))\\") 1","solution":"def evaluate_expression(s): Evaluates a mathematical expression string containing non-negative integers and the operators +, -, *, and /. The expression may also contain parentheses to specify the order of operations. def operate(op, second, first): if op == '+': return first + second elif op == '-': return first - second elif op == '*': return first * second elif op == '/': return int(first / second) # truncate towards zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def calculate(tokens): num_stack = [] op_stack = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i].isdigit(): num = 0 while i < len(tokens) and tokens[i].isdigit(): num = num * 10 + int(tokens[i]) i += 1 num_stack.append(num) i -= 1 elif tokens[i] == '(': op_stack.append(tokens[i]) elif tokens[i] == ')': while op_stack and op_stack[-1] != '(': num_stack.append(operate(op_stack.pop(), num_stack.pop(), num_stack.pop())) op_stack.pop() else: while op_stack and precedence(op_stack[-1]) >= precedence(tokens[i]): num_stack.append(operate(op_stack.pop(), num_stack.pop(), num_stack.pop())) op_stack.append(tokens[i]) i += 1 while op_stack: num_stack.append(operate(op_stack.pop(), num_stack.pop(), num_stack.pop())) return num_stack[0] return calculate(list(s))"},{"question":"def is_peak(grid, i, j): Check if the cell (i, j) is a peak considering all valid neighbors. def count_peaks(grid): Count the number of peaks in the given 2D grid. >>> count_peaks([ [1, 2, 1], [2, 3, 2], [1, 2, 1] ]) == 1 >>> count_peaks([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 9 >>> count_peaks([ [1, 2, 1], [1, 1, 1], [1, 2, 1] ]) == 2 >>> count_peaks([ [3, 3, 3], [3, 4, 3], [3, 3, 3] ]) == 1 >>> count_peaks([ [5] ]) == 1 >>> count_peaks([]) == 0 >>> count_peaks([ [1, 3, 2, 4, 2] ]) == 2 >>> count_peaks([ [1], [3], [2], [4], [2] ]) == 2","solution":"def is_peak(grid, i, j): Check if the cell (i, j) is a peak considering all valid neighbors. directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] > grid[i][j]: return False return True def count_peaks(grid): Count the number of peaks in the given 2D grid. if not grid: return 0 peaks_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if is_peak(grid, i, j): peaks_count += 1 return peaks_count"},{"question":"def shift_right(nums: List[int], k: int) -> List[int]: Shift the elements of nums to the right by k positions. Args: nums : List[int] - List of integers to be shifted. k : int - Number of positions to shift. Returns: List[int] - The modified list after shifting. >>> shift_right([1, 2, 3], 0) == [1, 2, 3] >>> shift_right([1], 5) == [1] >>> shift_right([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> shift_right([1, 2, 3], 3) == [1, 2, 3] >>> shift_right([1, 2, 3], 5) == [2, 3, 1] >>> shift_right([7, 7, 7, 7], 3) == [7, 7, 7, 7] >>> nums = list(range(1, 101)) >>> shifted = list(range(91, 101)) + list(range(1, 91)) >>> shift_right(nums, 10) == shifted","solution":"def shift_right(nums, k): Shifts the elements of nums to the right by k positions. Args: nums : List[int] - List of integers to be shifted. k : int - Number of positions to shift. Returns: List[int] - The modified list after shifting. n = len(nums) if n == 0 or k % n == 0: return nums k = k % n # reduces unnecessary complete rotations return nums[-k:] + nums[:-k]"},{"question":"def reverseWords(sentence): Reverses the order of the words in a sentence, ensuring only a single space separates words and leading/trailing whitespace is removed. Parameters: sentence (str): The input sentence. Returns: str: The modified sentence with words in reverse order. >>> reverseWords(\\" the sky is blue \\") \\"blue is sky the\\" >>> reverseWords(\\"hello\\") \\"hello\\" >>> reverseWords(\\" hello \\") \\"hello\\" >>> reverseWords(\\"a b c\\") \\"c b a\\" >>> reverseWords(\\" a b c \\") \\"c b a\\" >>> reverseWords(\\"\\") \\"\\" >>> reverseWords(\\" \\") \\"\\" >>> reverseWords(\\"hello, world!\\") \\"world! hello,\\" >>> reverseWords(\\" this is a test. \\") \\"test. a is this\\"","solution":"def reverseWords(sentence): Reverses the order of the words in a sentence, ensuring only a single space separates words and leading/trailing whitespace is removed. Parameters: sentence (str): The input sentence. Returns: str: The modified sentence with words in reverse order. # Split the sentence by spaces, filtering out empty strings. words = [word for word in sentence.split(' ') if word] # Reverse the order of words. reversed_words = words[::-1] # Join the reversed words with a single space. reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"class BinarySearch: Given an integer array nums sorted in non-decreasing order, determine if a target value exists in the array or not by implementing a binary search algorithm. BinarySearch() initializes an instance of the BinarySearch object. boolean search(int[] nums, int target) returns true if the target is found in the array and false otherwise. Ensure to follow the properties of the binary search algorithm by dividing the search interval in half after each iteration, adjusting the interval based on the comparison between the target and the current middle element of the array. >>> bs = BinarySearch() >>> bs.search([1, 2, 3, 4, 5], 3) True >>> bs.search([1, 2, 3, 4, 5], 0) False >>> bs.search([1, 2, 3, 4, 5], 6) False >>> bs.search([], 1) False >>> bs.search([2], 2) True >>> bs.search([2], 1) False def __init__(self): pass def search(self, nums, target): pass def test_binary_search_found(): bs = BinarySearch() assert bs.search([1, 2, 3, 4, 5], 3) == True assert bs.search([1, 2, 3, 4, 5], 1) == True assert bs.search([1, 2, 3, 4, 5], 5) == True def test_binary_search_not_found(): bs = BinarySearch() assert bs.search([1, 2, 3, 4, 5], 0) == False assert bs.search([1, 2, 3, 4, 5], 6) == False assert bs.search([1, 2, 3, 4, 5], -1) == False def test_binary_search_empty_array(): bs = BinarySearch() assert bs.search([], 1) == False def test_binary_search_one_element_array(): bs = BinarySearch() assert bs.search([2], 2) == True assert bs.search([2], 1) == False def test_binary_search_multiple_occurrences(): bs = BinarySearch() assert bs.search([2, 2, 2, 2, 2], 2) == True assert bs.search([2, 2, 2, 2, 2], 3) == False def test_binary_search_large_input(): bs = BinarySearch() large_array = list(range(1, 100001)) assert bs.search(large_array, 50000) == True assert bs.search(large_array, 100001) == False","solution":"class BinarySearch: def __init__(self): pass def search(self, nums, target): Returns True if the target exists in the array nums, otherwise False. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return True elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"def has_path(n: int, edges: List[Tuple[int, int]], start: int, end: int) -> bool: Determines if there is a path from start to end in the directed graph. :param n: Number of nodes in the graph :param edges: List of directed edges in the graph :param start: Starting node :param end: Ending node :return: Boolean indicating if there is a path from start to end >>> has_path(5, [(0, 1), (1, 2), (2, 3), (3, 4)], 0, 4) True >>> has_path(5, [(0, 1), (1, 2), (2, 3)], 0, 4) False >>> has_path(3, [(0, 1), (1, 2)], 1, 1) True >>> has_path(4, [(0, 1), (1, 2), (2, 3)], 0, 3) True >>> has_path(4, [(0, 1), (2, 3)], 0, 3) False >>> has_path(5, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4)], 0, 4) True","solution":"def has_path(n, edges, start, end): Determines if there is a path from start to end in the directed graph. :param n: Number of nodes in the graph :param edges: List of directed edges in the graph :param start: Starting node :param end: Ending node :return: Boolean indicating if there is a path from start to end from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Perform BFS to find if path exists from start to end queue = deque([start]) visited = set() while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: queue.append(neighbor) return False"},{"question":"def findUnsortedSubarray(nums: List[int]) -> int: Returns the length of the shortest subarray that, when sorted, makes the whole array sorted in non-decreasing order. Args: nums (List[int]): The input list of integers. Returns: int: The length of the shortest subarray. >>> findUnsortedSubarray([1, 2, 3, 4, 5]) == 0 >>> findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5 >>> findUnsortedSubarray([4,class test1: roll_no=0 name=\\"\\" t1=0 t2=0 def getMarks(self,roll_no,name,t1,t2): self.roll_no=roll_no self.name=name self.t1=t1 self.t2=t2 def printDetails(self): print(\\"Roll No:\\",self.rol l_no,\\"Name:\\",self.name,\\"test1\\",self.t1,\\"test2\\",self.t2) class test2(test1): t3=0 def getMark(self,t3): self.t3=t3 def display(self): print(\\"Roll No:\\",self.roll_no,\\"Name:\\",self.name,\\"test1:\\",self.t1,\\"test2:\\",self.t2,\\"test3:\\",self.t3) obj=test2() obj.getMarks(123,\\"efg\\",77,67) obj.getMark(80) obj.display()","solution":"def findUnsortedSubarray(nums): Returns the length of the shortest subarray that, when sorted, makes the whole array sorted in non-decreasing order. n = len(nums) start, end = -1, -1 max_seen, min_seen = float('-inf'), float('inf') for i in range(n): max_seen = max(max_seen, nums[i]) if nums[i] < max_seen: end = i for i in range(n - 1, -1, -1): min_seen = min(min_seen, nums[i]) if nums[i] > min_seen: start = i # if the array is already sorted if start == -1: return 0 return end - start + 1"},{"question":"def min_chunks(sections: List[int]) -> int: Returns the minimum number of contiguous chunks needed such that each chunk has at least one accessible route (1 or 2). Args: sections (list[int]): A list of integers representing road sections. Returns: int: The minimum number of chunks. >>> min_chunks([1, 1, 2, 2, 1, 2]) 1 >>> min_chunks([0, 0, 0, 0, 0, 0]) 0 >>> min_chunks([1, 0, 0, 2, 0, 1, 0]) 3 >>> min_chunks([0, 1, 0, 2, 0, 0, 1, 0, 2, 0]) 4 >>> min_chunks([0, 0, 1, 0, 0, 0, 0, 0]) 1 >>> min_chunks([0, 0, 0, 0, 0]) 0 >>> min_chunks([]) 0","solution":"def min_chunks(sections): Returns the minimum number of contiguous chunks needed such that each chunk has at least one accessible route (1 or 2). Args: sections (list[int]): A list of integers representing road sections. Returns: int: The minimum number of chunks. n = len(sections) chunks = 0 i = 0 while i < n: chunk_has_access = False while i < n and sections[i] == 0: i += 1 while i < n and sections[i] != 0: chunk_has_access = True i += 1 if chunk_has_access: chunks += 1 return chunks"},{"question":"class Character: def __init__(self, name, level, hp, mp, abilities): self.name = name self.level = level self.hp = hp self.mp = mp self.abilities = abilities def get_character_description(characters, name): Returns a description of the character with the given name. Parameters: characters (list): List of Character objects. name (str): The name of the character to look for. Returns: str: Description of the character or \\"Character not found\\" if no character with the given name exists. >>> characters = [ ... Character(\\"Archer\\", 5, 100, 50, [\\"Shoot\\", \\"Dodge\\"]), ... Character(\\"Mage\\", 6, 80, 100, [\\"Fireball\\", \\"Teleport\\"]), ... Character(\\"Warrior\\", 7, 150, 30, [\\"Slash\\", \\"Block\\"]) ... ] >>> get_character_description(characters, \\"Mage\\") 'Character Mage, Level 6, HP: 80, MP: 100, Abilities: Fireball, Teleport' >>> get_character_description(characters, \\"Rogue\\") 'Character not found' >>> characters = [Character(\\"Healer\\", 4, 90, 70, [])] >>> get_character_description(characters, \\"Healer\\") 'Character Healer, Level 4, HP: 90, MP: 70, Abilities: ' >>> characters = [Character(\\"Rogue\\", 3, 95, 60, [\\"Stealth\\"])] >>> get_character_description(characters, \\"Rogue\\") 'Character Rogue, Level 3, HP: 95, MP: 60, Abilities: Stealth'","solution":"class Character: def __init__(self, name, level, hp, mp, abilities): self.name = name self.level = level self.hp = hp self.mp = mp self.abilities = abilities def get_character_description(characters, name): Returns a description of the character with the given name. Parameters: characters (list): List of Character objects. name (str): The name of the character to look for. Returns: str: Description of the character or \\"Character not found\\" if no character with the given name exists. for character in characters: if character.name == name: abilities_list = \\", \\".join(character.abilities) return f\\"Character {character.name}, Level {character.level}, HP: {character.hp}, MP: {character.mp}, Abilities: {abilities_list}\\" return \\"Character not found\\""},{"question":"from typing import List def minimum_absolute_difference(nums: List[int]) -> int: Consider a 0-indexed integer array \`nums\` which may contain both positive and negative integers. Partition the array into two subarrays such that the absolute difference between their sums is minimized. >>> minimum_absolute_difference([3, 1, 4, 2, 2]) 0 >>> minimum_absolute_difference([1, 2, 3, 4, 5, 6, 7, 8, 9]) 1 >>> minimum_absolute_difference([1, 1, 1, 1, 1, 1]) 0 >>> minimum_absolute_difference([-1, 2, -3, 4, -5, 6]) 1 >>> minimum_absolute_difference([10, -10, 20, -20, 30, -30]) 0","solution":"def minimum_absolute_difference(nums): total_sum = sum(nums) n = len(nums) # dp[i] will be a set of all possible sums we can get using any subset of the first i elements dp = [set() for _ in range(n+1)] dp[0].add(0) for i in range(1, n+1): for s in dp[i-1]: dp[i].add(s + nums[i-1]) dp[i].add(s) min_diff = float('inf') for s in dp[n]: min_diff = min(min_diff, abs(total_sum - 2 * s)) return min_diff"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Given a list of integers nums and an integer target, determine if there exist two distinct indices i and j in the array such that nums[i] + nums[j] = target. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([3, 5, 7, 2], 8) True >>> has_pair_with_sum([-1, -2, -3, -4], -5) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([3, 3, 3], 10) False >>> has_pair_with_sum([1], 1) False >>> has_pair_with_sum([], 0) False >>> has_pair_with_sum([1, 1, 1, 1], 2) True >>> has_pair_with_sum([1, 1, 1, 1], 3) False >>> has_pair_with_sum([1, 2, 3, 1, 2, 3], 6) True >>> has_pair_with_sum([1, -1, 2, -2], 0) True","solution":"def has_pair_with_sum(nums, target): Given a list of integers nums and an integer target, determine if there exist two distinct indices i and j in the array such that nums[i] + nums[j] = target. Parameters: nums (list): A list of integers. target (int): The target sum to find in the list. Returns: bool: True if there is a pair with the given sum, otherwise False. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def find_buildings_with_ocean_view(buildings): Returns the indices of buildings with an ocean view. :param buildings: List of integers representing the height of buildings. :return: List of integers representing indices of buildings with an ocean view. >>> find_buildings_with_ocean_view([4, 3, 2, 1]) [0, 1, 2, 3] >>> find_buildings_with_ocean_view([1, 2, 3, 4]) [3] >>> find_buildings_with_ocean_view([4, 2, 3, 1]) [0, 2, 3] >>> find_buildings_with_ocean_view([1]) [0] >>> find_buildings_with_ocean_view([]) [] >>> find_buildings_with_ocean_view([2, 2, 2, 2]) [3]","solution":"def find_buildings_with_ocean_view(buildings): Returns the indices of buildings with an ocean view. :param buildings: List of integers representing the height of buildings. :return: List of integers representing indices of buildings with an ocean view. n = len(buildings) if n == 0: return [] result = [n - 1] # The last building always has an ocean view. max_height = buildings[n - 1] for i in range(n - 2, -1, -1): if buildings[i] > max_height: result.append(i) max_height = buildings[i] return result[::-1]"},{"question":"def min_replacements(s: str) -> int: Returns the minimum number of replacements needed so that no two adjacent characters are the same. >>> min_replacements(\\"abc\\") 0 >>> min_replacements(\\"abac\\") 0 >>> min_replacements(\\"aaa\\") 1 >>> min_replacements(\\"aaaa\\") 2 >>> min_replacements(\\"abab\\") 0 >>> min_replacements(\\"bcbc\\") 0 >>> min_replacements(\\"aab\\") 1 >>> min_replacements(\\"abcaabb\\") 2 >>> min_replacements(\\"\\") 0 >>> min_replacements(\\"a\\") 0 >>> min_replacements(\\"aa\\") 1","solution":"def min_replacements(s): Returns the minimum number of replacements needed so that no two adjacent characters are the same. n = len(s) if n <= 1: return 0 replacements = 0 for i in range(1, n): if s[i] == s[i - 1]: # Increment replacements replacements += 1 # Replace adjacent character # Choose a character different from both the current and the next (if exists) s = s[:i] + (set('abc') - {s[i], s[i-1], s[i+1] if i + 1 < n else ''}).pop() + s[i+1:] return replacements"},{"question":"def is_subsequence(s: str, words: List[str]) -> bool: Determine if \`s\` is a subsequence of any string in \`words\`. A string \`s\` is a subsequence of a string \`t\` if deleting some (can be none) characters from \`t\` results in the string \`s\` without changing the relative order of the remaining characters. Args: s (str): The string to check as a subsequence. words (List[str]): List of strings to check against. Returns: bool: True if \`s\` is a subsequence of any string in \`words\`, otherwise False. >>> is_subsequence(\\"abc\\", [\\"ahbgdc\\", \\"axyz\\"]) == True >>> is_subsequence(\\"axc\\", [\\"ahbgdc\\", \\"axyz\\"]) == False >>> is_subsequence(\\"\\", [\\"ahbgdc\\", \\"axyz\\"]) == True >>> is_subsequence(\\"\\", [\\"\\"]) == True >>> is_subsequence(\\"abc\\", [\\"\\"]) == False >>> is_subsequence(\\"abc\\", [\\"ahbgdc\\", \\"abcde\\", \\"xyz\\"]) == True >>> is_subsequence(\\"abc\\", []) == False","solution":"def is_subsequence(s, words): Returns True if \`s\` is a subsequence of any string in \`words\`, otherwise returns False. Args: s (str): The string to check as a subsequence. words (List[str]): List of strings to check against. Returns: bool: True if \`s\` is a subsequence of any string in \`words\`, otherwise False. def check_subsequence(s, word): it = iter(word) return all(char in it for char in s) for word in words: if check_subsequence(s, word): return True return False"},{"question":"def longest_non_repeating_substring(s: str) -> int: Returns the length of the longest possible remaining string after deleting characters to ensure no consecutive characters are the same. >>> longest_non_repeating_substring(\\"ABCDEFG\\") == 7 >>> longest_non_repeating_substring(\\"AAAAAA\\") == 1 >>> longest_non_repeating_substring(\\"AABBCC\\") == 3 >>> longest_non_repeating_substring(\\"AABACB\\") == 5 >>> longest_non_repeating_substring(\\"A\\") == 1 >>> longest_non_repeating_substring(\\"\\") == 0 >>> longest_non_repeating_substring(\\"AB\\") == 2 >>> longest_non_repeating_substring(\\"ABCDAB\\") == 6 >>> longest_non_repeating_substring(\\"ABABABAB\\") == 8 >>> longest_non_repeating_substring(\\"AABBCCDDEE\\") == 5","solution":"def longest_non_repeating_substring(s): Returns the length of the longest possible remaining string after deleting characters to ensure no consecutive characters are the same. if not s: return 0 max_length = 1 # A single character is always non-repeating for i in range(1, len(s)): if s[i] != s[i - 1]: max_length += 1 return max_length"},{"question":"from typing import List def numRegions(matrix: List[List[int]]) -> int: Returns the number of regions of 1's in the given matrix. A region is defined as a block of 1's connected horizontally or vertically. >>> numRegions([ ... [1, 1, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 1], ... [0, 0, 1, 1] ... ]) 2 >>> numRegions([ ... [1, 0, 0, 1], ... [0, 1, 1, 0], ... [0, 0, 0, 1], ... [1, 0, 1, 1] ... ]) 5 >>> numRegions([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> numRegions([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 1 >>> numRegions([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 5","solution":"def numRegions(matrix): Returns the number of regions of 1's in the given matrix. A region is defined as a block of 1's connected horizontally or vertically. def dfs(matrix, i, j, visited): if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or visited[i][j] or matrix[i][j] == 0: return visited[i][j] = True # Explore neighbors for direction in [(1, 0), (-1, 0), (0, 1), (0, -1)]: ni, nj = i + direction[0], j + direction[1] dfs(matrix, ni, nj, visited) visited = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))] num_regions = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1 and not visited[i][j]: dfs(matrix, i, j, visited) num_regions += 1 return num_regions"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root: TreeNode, targetSum: int): Find all root-to-leaf paths where the sum of the node values in the path equals targetSum. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> pathSum(root, 22) [[5, 4, 11, 2], [5, 8, 4, 5]]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root: TreeNode, targetSum: int): def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val # Check if it's a leaf node and sums up to targetSum if not node.left and not node.right and current_sum == targetSum: result.append(list(current_path)) # Continue searching in the left and right subtree dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) # Backtrack to explore other paths current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"from typing import List def max_length_of_unique_concat(words: List[str]) -> int: Given a list of strings \`words\`, return the maximum length of a concatenated string that can be formed by any subset of the strings in \`words\` such that no character appears more than once in the concatenated string. >>> max_length_of_unique_concat([\\"un\\", \\"iq\\", \\"ue\\"]) == 4 # \\"uniq\\" or \\"ique\\" >>> max_length_of_unique_concat([\\"aa\\", \\"bb\\", \\"cc\\"]) == 0 # No valid combination >>> max_length_of_unique_concat([\\"abcd\\"]) == 4 # \\"abcd\\" >>> max_length_of_unique_concat([\\"a\\", \\"abc\\", \\"d\\", \\"de\\", \\"def\\"]) == 6 # \\"abcdef\\" >>> max_length_of_unique_concat([\\"cha\\", \\"r\\", \\"act\\", \\"ers\\", \\"ha\\"]) == 6 # \\"chaers\\" or \\"acters\\" >>> max_length_of_unique_concat([\\"aa\\", \\"abc\\", \\"deef\\", \\"ghi\\"]) == 6 # \\"abcdef\\" or \\"abchi\\" >>> max_length_of_unique_concat([]) == 0 # Empty list pass","solution":"from itertools import combinations def max_length_of_unique_concat(words): Returns the maximum length of a concatenated string that can be formed by any subset of the strings in words such that no character appears more than once in the concatenated string. def all_unique(word): return len(set(word)) == len(word) # Filter out words containing duplicate characters words = [word for word in words if all_unique(word)] max_length = 0 # Iterate over all possible combinations of words for r in range(1, len(words) + 1): for combo in combinations(words, r): concat = ''.join(combo) if all_unique(concat): max_length = max(max_length, len(concat)) return max_length"},{"question":"def coin_change(nums: List[int], total: int) -> int: Returns the minimum number of coins needed to make the exact amount total, or -1 if it is impossible. >>> coin_change([1, 2, 5], 11) 3 >>> coin_change([2], 3) -1 >>> coin_change([1, 2, 5], 0) 0 >>> coin_change([1, 2, 5], 7) 2 >>> coin_change([1], 7) 7 >>> coin_change([1, 2, 5], 100) 20 >>> coin_change([], 7) -1","solution":"def coin_change(nums, total): Returns the minimum number of coins needed to make the exact amount total, or -1 if it is impossible. # Initialize the dp array with a large value (total + 1 is beyond any possible number of coins needed) dp = [total + 1] * (total + 1) dp[0] = 0 # zero coins are needed for zero total for i in range(1, total + 1): for coin in nums: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[total] if dp[total] != total + 1 else -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target_sum): Returns the number of paths where the sum of the values along the path equals target_sum. :param root: TreeNode, the root of the binary tree :param target_sum: int, target sum for the paths :return: int, number of valid paths # Test cases def test_single_node_equals_sum(): root = TreeNode(5) assert path_sum(root, 5) == 1 def test_single_node_not_equals_sum(): root = TreeNode(5) assert path_sum(root, 10) == 0 def test_multiple_paths_single_child(): root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) assert path_sum(root, 22) == 2 # Paths: 5->4->11->2 and 5->8->9 def test_multiple_paths(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(-3) root.left.left = TreeNode(3) root.left.right = TreeNode(2) root.right.right = TreeNode(11) root.left.left.left = TreeNode(3) root.left.left.right = TreeNode(-2) root.left.right.right = TreeNode(1) assert path_sum(root, 8) == 3 # Paths: 5->3, 10->-3->11, 5->2->1 def test_no_paths(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert path_sum(root, 100) == 0 def test_null_tree(): assert path_sum(None, 1) == 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target_sum): Returns the number of paths where the sum of the values along the path equals target_sum. :param root: TreeNode, the root of the binary tree :param target_sum: int, target sum for the paths :return: int, number of valid paths def _path_sum_from(node, current_sum): if not node: return 0 current_sum += node.val return (current_sum == target_sum) + _path_sum_from(node.left, current_sum) + _path_sum_from(node.right, current_sum) if not root: return 0 return _path_sum_from(root, 0) + path_sum(root.left, target_sum) + path_sum(root.right, target_sum)"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Return a list of all the words that match the given pattern. >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([], \\"abb\\") [] >>> find_and_replace_pattern([\\"abc\\", \\"bca\\", \\"cab\\"], \\"abc\\") [\\"abc\\", \\"bca\\", \\"cab\\"] >>> find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\"], \\"aa\\") [] >>> find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\", \\"aa\\", \\"bb\\", \\"cc\\"], \\"a\\") [\\"a\\", \\"b\\", \\"c\\"] >>> find_and_replace_pattern([\\"abab\\", \\"baba\\", \\"aabb\\", \\"bbaa\\"], \\"xyxy\\") [\\"abab\\", \\"baba\\"]","solution":"def find_and_replace_pattern(words, pattern): def matches(word): if len(word) != len(pattern): return False w2p = {} p2w = {} for w, p in zip(word, pattern): if w in w2p and w2p[w] != p: return False if p in p2w and p2w[p] != w: return False w2p[w] = p p2w[p] = w return True return [word for word in words if matches(word)]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: Reverse every k nodes of the linked list. >>> linked_list_to_list(reverseKGroup(list_to_linked_list([1, 2, 3, 4, 5]), 2)) == [2, 1, 4, 3, 5] >>> linked_list_to_list(reverseKGroup(list_to_linked_list([1, 2, 3, 4, 5, 6, 7, 8]), 3)) == [3, 2, 1, 6, 5, 4, 7, 8] >>> linked_list_to_list(reverseKGroup(list_to_linked_list([1, 2, 3]), 4)) == [1, 2, 3] >>> linked_list_to_list(reverseKGroup(list_to_linked_list([1, 2, 3, 4]), 2)) == [2, 1, 4, 3] >>> linked_list_to_list(reverseKGroup(list_to_linked_list([1, 2]), 2)) == [2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: def reverse(node, k): prev, curr = None, node while k: curr.next, prev, curr = prev, curr, curr.next k -= 1 return prev # Check if we have at least k nodes to reverse count, node = 0, head while count < k and node: node = node.next count += 1 if count == k: new_head = reverse(head, k) head.next = reverseKGroup(node, k) return new_head return head"},{"question":"from typing import List, Dict def highest_salary_employees(employees: List[Dict[str, any]]) -> List[str]: Find the names of employees who earn the highest salary in each department. If multiple employees share the highest salary in a department, include all of their names. >>> employees = [ ... {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"salary\\": 90000, \\"department\\": \\"Engineering\\"}, ... {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"salary\\": 85000, \\"department\\": \\"Engineering\\"}, ... {\\"id\\": 3, \\"name\\": \\"Carol\\", \\"salary\\": 92000, \\"department\\": \\"Marketing\\"}, ... {\\"id\\": 4, \\"name\\": \\"Dave\\", \\"salary\\": 92000, \\"department\\": \\"Marketing\\"}, ... {\\"id\\": 5, \\"name\\": \\"Eve\\", \\"salary\\": 75000, \\"department\\": \\"HR\\"}, ... ] >>> sorted(highest_salary_employees(employees)) ['Alice', 'Carol', 'Dave', 'Eve'] >>> employees_tie = [ ... {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"salary\\": 90000, \\"department\\": \\"Engineering\\"}, ... {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"salary\\": 90000, \\"department\\": \\"Engineering\\"}, ... {\\"id\\": 3, \\"name\\": \\"Carol\\", \\"salary\\": 92000, \\"department\\": \\"Marketing\\"}, ... {\\"id\\": 4, \\"name\\": \\"Dave\\", \\"salary\\": 92000, \\"department\\": \\"Marketing\\"}, ... {\\"id\\": 5, \\"name\\": \\"Eve\\", \\"salary\\": 75000, \\"department\\": \\"HR\\"}, ... ] >>> sorted(highest_salary_employees(employees_tie)) ['Alice', 'Bob', 'Carol', 'Dave', 'Eve'] >>> highest_salary_employees([]) [] >>> employees_single_department = [ ... {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"salary\\": 90000, \\"department\\": \\"Engineering\\"}, ... {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"salary\\": 85000, \\"department\\": \\"Engineering\\"}, ... {\\"id\\": 3, \\"name\\": \\"Carol\\", \\"salary\\": 85000, \\"department\\": \\"Engineering\\"}, ... ] >>> highest_salary_employees(employees_single_department) ['Alice']","solution":"def highest_salary_employees(employees): from collections import defaultdict max_salary = defaultdict(int) result = [] # Determine the maximum salary in each department for employee in employees: department = employee['department'] salary = employee['salary'] if salary > max_salary[department]: max_salary[department] = salary # Find employees with the maximum salary in their department for employee in employees: department = employee['department'] salary = employee['salary'] if salary == max_salary[department]: result.append(employee['name']) return result # Sample data employees = [ {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"salary\\": 90000, \\"department\\": \\"Engineering\\"}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"salary\\": 85000, \\"department\\": \\"Engineering\\"}, {\\"id\\": 3, \\"name\\": \\"Carol\\", \\"salary\\": 92000, \\"department\\": \\"Marketing\\"}, {\\"id\\": 4, \\"name\\": \\"Dave\\", \\"salary\\": 92000, \\"department\\": \\"Marketing\\"}, {\\"id\\": 5, \\"name\\": \\"Eve\\", \\"salary\\": 75000, \\"department\\": \\"HR\\"}, ]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_elements(head: ListNode, val: int) -> ListNode: Remove all nodes with the given value from the linked list. >>> head = list_to_linkedlist([1, 2, 6, 3, 4, 5, 6]) >>> new_head = remove_elements(head, 6) >>> linkedlist_to_list(new_head) [1, 2, 3, 4, 5] >>> head = list_to_linkedlist([7, 7, 7, 7]) >>> new_head = remove_elements(head, 7) >>> linkedlist_to_list(new_head) [] >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> new_head = remove_elements(head, 6) >>> linkedlist_to_list(new_head) [1, 2, 3, 4, 5] >>> head = list_to_linkedlist([1, 1, 2, 3]) >>> new_head = remove_elements(head, 1) >>> linkedlist_to_list(new_head) [2, 3] >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> new_head = remove_elements(head, 5) >>> linkedlist_to_list(new_head) [1, 2, 3, 4]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_elements(head, val): dummy = ListNode(next=head) current = dummy while current.next: if current.next.val == val: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"def count_repeating_substrings(s: str, k: int) -> int: Returns the number of distinct substrings of length k that occur more than once in the string s. :param s: Input string consisting of lowercase alphabets :param k: Length of substrings to be considered :return: Number of distinct substrings of length k that occur more than once >>> count_repeating_substrings(\\"abcd\\", 2) 0 >>> count_repeating_substrings(\\"aaaa\\", 2) 1 >>> count_repeating_substrings(\\"abcabcabc\\", 3) 3 >>> count_repeating_substrings(\\"abc\\", 4) 0 >>> count_repeating_substrings(\\"aa\\", 1) 1 >>> count_repeating_substrings(\\"abc\\", 1) 0","solution":"def count_repeating_substrings(s, k): Returns the number of distinct substrings of length k that occur more than once in the string s. :param s: Input string consisting of lowercase alphabets :param k: Length of substrings to be considered :return: Number of distinct substrings of length k that occur more than once substring_count = {} for i in range(len(s) - k + 1): substr = s[i:i+k] if substr in substring_count: substring_count[substr] += 1 else: substring_count[substr] = 1 return len([substr for substr, count in substring_count.items() if count > 1])"},{"question":"def append_to_make_palindrome(s: str) -> int: Returns the minimum number of characters that must be appended to make the string a palindrome. >>> append_to_make_palindrome(\\"racecar\\") 0 >>> append_to_make_palindrome(\\"raceca\\") 1 >>> append_to_make_palindrome(\\"ab\\") 1 >>> append_to_make_palindrome(\\"abc\\") 2","solution":"def append_to_make_palindrome(s): Returns the minimum number of characters to be appended to make the string a palindrome. def is_palindrome(sub): return sub == sub[::-1] if is_palindrome(s): return 0 for i in range(len(s)): if is_palindrome(s[i:]): return i return len(s) - 1"},{"question":"def isValidSudoku(board: List[List[str]]) -> bool: Determines if a 9x9 Sudoku board is valid according to Sudoku rules. :param board: List[List[str]], a 9x9 2D list representing the Sudoku board :return: bool, True if the Sudoku board is valid, False otherwise >>> isValidSudoku([ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ]) == True >>> isValidSudoku([ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\"5\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ]) == False >>> isValidSudoku([ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\"5\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ]) == False >>> isValidSudoku([ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\"9\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ]) == False pass","solution":"def isValidSudoku(board): Determines if a 9x9 Sudoku board is valid. :param board: List[List[str]], a 9x9 2D list representing the Sudoku board :return: bool, True if the Sudoku board is valid, False otherwise rows = [{} for _ in range(9)] cols = [{} for _ in range(9)] boxes = [{} for _ in range(9)] for r in range(9): for c in range(9): num = board[r][c] if num != '.': num = int(num) box_index = (r // 3) * 3 + c // 3 if num in rows[r] or num in cols[c] or num in boxes[box_index]: return False rows[r][num] = rows[r].get(num, 0) + 1 cols[c][num] = cols[c].get(num, 0) + 1 boxes[box_index][num] = boxes[box_index].get(num, 0) + 1 return True"},{"question":"def increment_large_number(arr): Increment a large number represented as an array of digits by one. Args: arr (list of int): The array representing the large number. Returns: list of int: The array representing the incremented large number. >>> increment_large_number([1, 2, 3]) [1, 2, 4] >>> increment_large_number([1, 2, 9]) [1, 3, 0] >>> increment_large_number([9, 9, 9]) [1, 0, 0, 0] >>> increment_large_number([0]) [1] >>> increment_large_number([]) [1] >>> increment_large_number([2, 3, 5, 7, 9]) [2, 3, 5, 8, 0]","solution":"def increment_large_number(arr): Increment a large number represented as an array of digits by one. Args: arr (list of int): The array representing the large number. Returns: list of int: The array representing the incremented large number. n = len(arr) for i in range(n - 1, -1, -1): if arr[i] < 9: arr[i] += 1 return arr arr[i] = 0 return [1] + arr"},{"question":"def sum_even_nums_or_even_index(nums): Returns the sum of all elements in nums that are either even or appear at an even index. Args: nums (List[int]): A list of integers. Returns: int: The sum of all elements that are either even or appear at an even index. >>> sum_even_nums_or_even_index([2, 4, 6, 8, 10]) 30 >>> sum_even_nums_or_even_index([1, 3, 5, 7, 9]) 15 >>> sum_even_nums_or_even_index([1, 2, 3, 4, 5, 6]) 21 >>> sum_even_nums_or_even_index([2]) 2 >>> sum_even_nums_or_even_index([1]) 1 >>> sum_even_nums_or_even_index([]) 0","solution":"def sum_even_nums_or_even_index(nums): Returns the sum of all elements in nums that are either even or appear at an even index. Args: nums (List[int]): A list of integers. Returns: int: The sum of all elements that are either even or appear at an even index. return sum(num for i, num in enumerate(nums) if num % 2 == 0 or i % 2 == 0) # Example usage nums = [1, 2, 3, 4, 5, 6] result = sum_even_nums_or_even_index(nums) print(result) # Output will be 12 (1 + 3 + 4 + 6 because 1, 3 are at even indices, and 4, 6 are even numbers)"},{"question":"def round_grades(grades): Rounds grades according to the specified rules: 1. If the difference between the grade and the next multiple of 5 is less than 3, round the grade up to the next multiple of 5. 2. If the value of the grade is less than 38, no rounding occurs as the grade is failing. Parameters: grades (list of int): List of student grades Returns: list of int: List of rounded grades >>> round_grades([33, 37]) [33, 37] >>> round_grades([38, 39, 40, 45, 47, 49]) [40, 40, 40, 45, 47, 50] >>> round_grades([62, 63, 64]) [62, 65, 65] >>> round_grades([33, 39, 60, 82, 37, 89, 99]) [33, 40, 60, 82, 37, 90, 100] >>> round_grades([73, 67, 38, 33]) [75, 67, 40, 33]","solution":"def round_grades(grades): Rounds grades according to the specified rules: 1. If the difference between the grade and the next multiple of 5 is less than 3, round the grade up to the next multiple of 5. 2. If the value of the grade is less than 38, no rounding occurs as the grade is failing. Parameters: grades (list of int): List of student grades Returns: list of int: List of rounded grades rounded_grades = [] for grade in grades: if grade < 38: # Do not round failing grades rounded_grades.append(grade) else: # Calculate the difference to the next multiple of 5 diff = 5 - (grade % 5) # Round up if the difference is less than 3 if diff < 3: rounded_grades.append(grade + diff) else: rounded_grades.append(grade) return rounded_grades"},{"question":"def find_and_replace_pattern(words, pattern): Given a list of words and a pattern, returns a list of words that match the given pattern. :param words: List of words (strings). :param pattern: Pattern to match (string). :return: List of words that match the given pattern. >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"abc\\", \\"def\\", \\"xyz\\"], \\"aab\\") [] >>> find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\"], \\"a\\") [\\"a\\", \\"b\\", \\"c\\"] >>> find_and_replace_pattern([\\"abc\\", \\"xyz\\", \\"def\\"], \\"abc\\") [\\"abc\\", \\"xyz\\", \\"def\\"] >>> find_and_replace_pattern([\\"abab\\", \\"baba\\", \\"cdef\\", \\"fgfg\\"], \\"xyxy\\") [\\"abab\\", \\"baba\\", \\"fgfg\\"]","solution":"def find_and_replace_pattern(words, pattern): Given a list of words and a pattern, returns a list of words that match the given pattern. :param words: List of words (strings). :param pattern: Pattern to match (string). :return: List of words that match the given pattern. def matches(word, pattern): if len(word) != len(pattern): return False char_map = {} mapped_chars = set() for w_char, p_char in zip(word, pattern): if p_char in char_map: if char_map[p_char] != w_char: return False else: if w_char in mapped_chars: return False char_map[p_char] = w_char mapped_chars.add(w_char) return True return [word for word in words if matches(word, pattern)]"},{"question":"def max_distinct_chars(s: str, k: int) -> int: Returns the maximum number of distinct characters possible after changing at most k characters in the string s. >>> max_distinct_chars(\\"abcd\\", 0) == 4 >>> max_distinct_chars(\\"aaaa\\", 0) == 1 >>> max_distinct_chars(\\"abcd\\", 2) == 4 >>> max_distinct_chars(\\"abac\\", 1) == 4 >>> max_distinct_chars(\\"aabc\\", 2) == 4 >>> max_distinct_chars(\\"aabb\\", 2) == 4 >>> max_distinct_chars(\\"abab\\", 10) == 4 >>> max_distinct_chars(\\"abc\\", 5) == 3 >>> max_distinct_chars(\\"a\\", 10) == 1","solution":"def max_distinct_chars(s, k): Returns the maximum number of distinct characters possible after changing at most k characters in the string s. from collections import Counter char_count = Counter(s) distinct_count = len(char_count) most_freq_char_count = max(char_count.values()) # If the number of allowed changes k plus the number of distinct characters is greater than the length of the string, we cap k to this limit k = min(k, len(s) - most_freq_char_count) return min(len(s), distinct_count + k)"},{"question":"def is_robot_return_to_origin(s: str) -> bool: Determines if the robot returns to the original starting point. >>> is_robot_return_to_origin('') == True >>> is_robot_return_to_origin('U') == False >>> is_robot_return_to_origin('D') == False >>> is_robot_return_to_origin('L') == False >>> is_robot_return_to_origin('R') == False >>> is_robot_return_to_origin('UD') == True >>> is_robot_return_to_origin('DU') == True >>> is_robot_return_to_origin('LR') == True >>> is_robot_return_to_origin('RL') == True >>> is_robot_return_to_origin('UDLR') == True >>> is_robot_return_to_origin('UUDDLL') == False >>> is_robot_return_to_origin('UULDDRU') == False >>> is_robot_return_to_origin('ULDR') == True","solution":"def is_robot_return_to_origin(s): Determines if the robot returns to the original starting point. Parameters: s (str): A string representing the path of the robot's movement. Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for char in s: if char == 'U': y += 1 elif char == 'D': y -= 1 elif char == 'L': x -= 1 elif char == 'R': x += 1 return x == 0 and y == 0"},{"question":"import heapq from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in the list nums. :param nums: List of integers :param k: The rank of the largest element to find :return: The k-th largest element >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 1, 5, 6, 4], 1) 6 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([2, 1], 2) 1 >>> find_kth_largest([-1, -2, -3, -4, -5, -6], 2) -2 >>> find_kth_largest([3, -2, 1, 5, 6, 4], 3) 4 >>> find_kth_largest([-3, -2, -1, -5, -6, -4], 1) -1 >>> find_kth_largest([1, -1, 0], 3) -1 >>> find_kth_largest([1, 1, 1, 1, 1], 3) 1 >>> find_kth_largest([5, 5, 5, 5, 5, 6], 2) 5 >>> find_kth_largest([3, 3, 3, 3, 4], 1) 4 >>> find_kth_largest([3, 3, 3, 3, 4], 5) 3","solution":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the list nums. :param nums: List of integers :param k: The rank of the largest element to find :return: The k-th largest element # Using a min-heap to keep track of the k largest elements min_heap = nums[:k] heapq.heapify(min_heap) for num in nums[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"def min_window_substring(s: str, t: str) -> int: Given two strings \`s\` and \`t\`, return the length of the longest substring of \`s\` such that it contains all characters from \`t\`. If no such substring exists, return -1. >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") 4 >>> min_window_substring(\\"a\\", \\"a\\") 1 >>> min_window_substring(\\"a\\", \\"aa\\") -1","solution":"def min_window_substring(s, t): Returns the length of the smallest substring of \`s\` which contains all characters of \`t\`. If no such substring exists, returns -1. from collections import Counter if len(t) > len(s): return -1 required = Counter(t) window_counts = Counter() have, need = 0, len(required) left, right = 0, 0 min_length = float(\\"inf\\") while right < len(s): char = s[right] window_counts[char] += 1 if char in required and window_counts[char] == required[char]: have += 1 while have == need: min_length = min(min_length, right - left + 1) window_counts[s[left]] -= 1 if s[left] in required and window_counts[s[left]] < required[s[left]]: have -= 1 left += 1 right += 1 return min_length if min_length != float(\\"inf\\") else -1"},{"question":"def min_operations_to_make_palindrome(s: str) -> int: Returns the minimum number of operations needed to make the string \`s\` a palindrome. >>> min_operations_to_make_palindrome(\\"abba\\") 0 >>> min_operations_to_make_palindrome(\\"aba\\") 0 >>> min_operations_to_make_palindrome(\\"ab\\") 1 >>> min_operations_to_make_palindrome(\\"abc\\") 2 >>> min_operations_to_make_palindrome(\\"aabb\\") 2 >>> min_operations_to_make_palindrome(\\"abab\\") 1","solution":"def min_operations_to_make_palindrome(s): Returns the minimum number of operations needed to make string s a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1]"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Restore the string \`s\` using the given \`indices\`. Args: s (str): The jumbled string. indices (list): The list of indices indicating the correct order. Returns: str: The restored string. >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) 'leetcode' >>> restore_string(\\"a\\", [0]) 'a' >>> restore_string(\\"abcd\\", [0, 1, 2, 3]) 'abcd' >>> restore_string(\\"abcd\\", [3, 2, 1, 0]) 'dcba' >>> restore_string(\\"abcde\\", [4, 3, 2, 1, 0]) 'edcba'","solution":"def restore_string(s, indices): Restore the string \`s\` using the given \`indices\`. Args: s (str): The jumbled string. indices (list): The list of indices indicating the correct order. Returns: str: The restored string. restored = [''] * len(s) for i, index in enumerate(indices): restored[index] = s[i] return \\"\\".join(restored)"},{"question":"def minimize_difference(height: List[int], k: int) -> int: Returns the minimum possible difference between the highest and the lowest building heights after adding exactly k buildings. >>> minimize_difference([1, 3, 6, 10, 15], 0) 14 >>> minimize_difference([5], 3) 0 >>> minimize_difference([5, 5, 5, 5], 2) 0 >>> minimize_difference([1, 3, 6, 7], 2) 6 >>> minimize_difference([3, 9, 12, 16, 20], 3) 17 >>> minimize_difference([10, 20, 30], 5) 20 >>> minimize_difference([-10, -5, 0, 5, 10], 3) 20","solution":"def minimize_difference(height, k): Returns the minimum possible difference between the highest and the lowest building heights after adding exactly k buildings. height.sort() n = len(height) # The initial minimum difference when no new buildings are added. min_diff = height[-1] - height[0] for i in range(k+1): new_min = height[0] - i new_max = height[-1] + (k - i) min_diff = min(min_diff, new_max - new_min) return min_diff"},{"question":"def find_duplicates(arr: List[int]) -> List[int]: Given an unsorted array of integers, find and return an array containing all the integers that appear more than once. The output array should be sorted in ascending order and should not contain any duplicates from the input array. >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([2, 2, 2, 2, 2]) [2] >>> find_duplicates([1]) [] >>> find_duplicates([]) [] >>> find_duplicates([-1, 1, -1, 2, 2, 3]) [-1, 2] >>> find_duplicates([1000000, 1000000, 999999, 999999, 5]) [999999, 1000000]","solution":"def find_duplicates(arr): Returns a sorted list of integers that appear more than once in the input array. from collections import Counter # Count occurrences of each element in the array count = Counter(arr) # Filter elements that appear more than once and return them sorted duplicates = sorted([num for num, freq in count.items() if freq > 1]) return duplicates"},{"question":"def max_min_candies(candies: List[int], k: int) -> int: Returns the maximum minimum candies that can be distributed to any child, or -1 if it is impossible to distribute candies to every child. :param candies: List[int] -- The candy counts in each box :param k: int -- The number of children :return: int -- The maximum minimum number of candies a child can receive >>> max_min_candies([5, 8, 6], 3) 5 >>> max_min_candies([12, 7, 9, 10], 3) 9 >>> max_min_candies([1, 2], 3) -1 >>> max_min_candies([0], 1) 0 >>> max_min_candies([2, 3, 5, 7, 11, 13], 3) 7","solution":"def max_min_candies(candies, k): Returns the maximum minimum candies that can be distributed to any child, or -1 if it is impossible to distribute candies to every child. :param candies: List[int] -- The candy counts in each box :param k: int -- The number of children :return: int -- The maximum minimum number of candies a child can receive # If we have fewer boxes than children, it is impossible to distribute if len(candies) < k: return -1 low, high = 0, max(candies) def canDistribute(mid): count = 0 for candy in candies: if candy >= mid: count += 1 if count >= k: return True return False result = 0 while low <= high: mid = (low + high) // 2 if canDistribute(mid): result = mid low = mid + 1 else: high = mid - 1 return result"},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Finds the maximum sum of a subarray of length k. Parameters: arr (List[int]): The list of integers. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k. Example: >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray([2, 3, 4, 1, 5], 2) 7 >>> max_sum_subarray([1, 1, 1, 1, 1, 1], 3) 3 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray([10, -10, 10, -10, 10], 1) 10","solution":"def max_sum_subarray(arr, k): Finds the maximum sum of a subarray of length k. Parameters: arr (list of int): The list of integers. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k. # Initial sum of the first 'k' elements current_max = sum(arr[:k]) global_max = current_max # Use the sliding window technique to find the maximum sum for i in range(k, len(arr)): current_max += arr[i] - arr[i - k] if current_max > global_max: global_max = current_max return global_max"},{"question":"def find_peak(matrix): Finds any one peak element in the given matrix and returns its coordinates [x, y]. A peak is defined as a cell that has a higher elevation than all its 8 neighbors (including diagonals). Args: matrix (List[List[int]]): A 2D list representing the elevations at each cell. Returns: List[int]: The coordinates [x, y] of a peak element. Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> find_peak(matrix) [2, 2] >>> matrix = [ ... [10, 20, 10], ... [20, 30, 20], ... [10, 20, 10] ... ] >>> find_peak(matrix) [1, 1] from solution import find_peak def test_single_peak(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] peak = find_peak(matrix) assert matrix[peak[0]][peak[1]] == 9 def test_multiple_peaks(): matrix = [ [10, 20, 10], [20, 30, 20], [10, 20, 10] ] peak = find_peak(matrix) assert matrix[peak[0]][peak[1]] == 30 def test_large_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] peak = find_peak(matrix) assert matrix[peak[0]][peak[1]] == 16 def test_edge_peak(): matrix = [ [10, 8, 6], [7, 5, 4], [2, 1, 3] ] peak = find_peak(matrix) assert matrix[peak[0]][peak[1]] == 10","solution":"def find_peak(matrix): Finds any one peak element in the given matrix and returns its coordinates [x, y]. def is_peak(x, y): # check if matrix[x][y] is greater than all its neighbors neighbors = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for dx, dy in neighbors: nx, ny = x + dx, y + dy if 0 <= nx < len(matrix) and 0 <= ny < len(matrix[0]) and matrix[nx][ny] >= matrix[x][y]: return False return True from collections import deque m, n = len(matrix), len(matrix[0]) queue = deque([(x, y) for x in range(m) for y in (0, n-1)]) queue.extend([(x, y) for y in range(n) for x in (0, m-1)]) visited = set(queue) while queue: x, y = queue.popleft() if is_peak(x, y): return [x, y] # check all its unvisited neighbors for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return []"},{"question":"def max_meetings(meetings: list[tuple[int, int]]) -> int: Determines the maximum number of meetings that can be attended without overlapping. >>> max_meetings([]) == 0 >>> max_meetings([(1, 2), (3, 4), (5, 6)]) == 3 >>> max_meetings([(1, 3), (2, 4), (3, 5)]) == 2 >>> max_meetings([(1, 2), (2, 3), (3, 4)]) == 3 >>> max_meetings([(1, 4), (2, 5), (3, 6)]) == 1 >>> max_meetings([(1, 4), (5, 6), (4, 5), (7, 8), (8, 9)]) == 5 >>> max_meetings([(1, 4), (2, 4), (3, 4), (4, 5)]) == 2","solution":"def max_meetings(meetings): Determines the maximum number of meetings that can be attended without overlapping. :param meetings: List of tuples [(start_time, end_time), ...] :return: Maximum number of meetings that can be attended. if not meetings: return 0 # Sort meetings primarily by end time, secondarily by start time meetings.sort(key=lambda x: (x[1], x[0])) count = 0 end_time = 0 for start, end in meetings: # If the meeting starts after or when the last meeting ended if start >= end_time: count += 1 end_time = end return count"},{"question":"def process_operations(operations: List[str]) -> List[int]: Process a list of operations on a stack and return its final state. - \\"push x\\": Push x onto the stack - \\"pop\\": Pop the top element from the stack - \\"inc k x\\": Increment the bottom k elements of the stack by x Args: operations (List[str]): List of operations to perform on the stack Returns: List[int]: Final state of the stack Examples: >>> process_operations([\\"push 1\\", \\"push 2\\"]) [1, 2] >>> process_operations([\\"push 1\\", \\"push 2\\", \\"pop\\"]) [1] >>> process_operations([\\"push 1\\", \\"push 2\\", \\"push 3\\", \\"inc 2 1\\"]) [2, 3, 3] >>> process_operations([\\"push 1\\", \\"push 2\\", \\"push 3\\", \\"pop\\", \\"inc 2 1\\"]) [2, 3] >>> process_operations([\\"push 1\\", \\"push 2\\", \\"pop\\", \\"pop\\", \\"inc 1 1\\"]) [] >>> process_operations([]) []","solution":"def process_operations(operations): stack = [] for operation in operations: if operation.startswith(\\"push\\"): _, val = operation.split() stack.append(int(val)) elif operation == \\"pop\\": if stack: stack.pop() elif operation.startswith(\\"inc\\"): _, k, x = operation.split() k = int(k) x = int(x) for i in range(min(k, len(stack))): stack[i] += x return stack"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_duplicates(head): Removes all nodes that have duplicate numbers, leaving only distinct numbers from the original list. >>> head = list_to_linkedlist([1, 2, 3, 3, 4, 4, 5]) >>> linkedlist_to_list(delete_duplicates(head)) == [1, 2, 5] >>> head = list_to_linkedlist([1, 1, 1, 2, 3, 3]) >>> linkedlist_to_list(delete_duplicates(head)) == [2] >>> head = list_to_linkedlist([1, 2, 3, 4]) >>> linkedlist_to_list(delete_duplicates(head)) == [1, 2, 3, 4] >>> head = list_to_linkedlist([]) >>> linkedlist_to_list(delete_duplicates(head)) == [] >>> head = list_to_linkedlist([1]) >>> linkedlist_to_list(delete_duplicates(head)) == [1] >>> head = list_to_linkedlist([1, 1, 1, 1]) >>> linkedlist_to_list(delete_duplicates(head)) == []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_duplicates(head): Removes all nodes that have duplicate numbers, leaving only distinct numbers from the original list. dummy = ListNode(0) dummy.next = head prev = dummy current = head while current: has_duplicates = False # Check for duplicates while current.next and current.val == current.next.val: current = current.next has_duplicates = True if has_duplicates: # Skip all duplicates prev.next = current.next else: prev = prev.next # no duplicates current = current.next return dummy.next"},{"question":"def merge_strings(word1: str, word2: str) -> str: You are given two strings \`word1\` and \`word2\`. You want to construct a string \`merged\` by merging the characters of \`word1\` and \`word2\` in such a way that maintains the character order of both strings. Return the lexicographically smallest string \`merged\` that can be formed by merging the characters of \`word1\` and \`word2\`. >>> merge_strings(\\"abc\\", \\"def\\") 'abcdef' >>> merge_strings(\\"ace\\", \\"bdf\\") 'abcdef' >>> merge_strings(\\"abc\\", \\"xy\\") 'abcxy' >>> merge_strings(\\"ab\\", \\"xyz\\") 'abxyz' >>> merge_strings(\\"ca\\", \\"bc\\") 'bcca' >>> merge_strings(\\"\\", \\"abc\\") 'abc' >>> merge_strings(\\"xyz\\", \\"\\") 'xyz' >>> merge_strings(\\"abc\\", \\"ab\\") 'aabbc' >>> merge_strings(\\"ab\\", \\"abc\\") 'aabbc' >>> merge_strings(\\"a\\", \\"b\\") 'ab' >>> merge_strings(\\"b\\", \\"a\\") 'ab'","solution":"def merge_strings(word1, word2): Merges two strings word1 and word2 into a lexicographically smallest merged string while maintaining the character order of both strings. # Convert words into arrays for ease of use with pop() operations. word1 = list(word1) word2 = list(word2) merged = [] while word1 and word2: if word1 < word2: merged.append(word1.pop(0)) else: merged.append(word2.pop(0)) # Append remaining characters from word1 or word2 merged.extend(word1) merged.extend(word2) return ''.join(merged)"},{"question":"def can_traverse(grid: List[List[int]]) -> bool: Determines if there is a path from top-left to bottom-right on the grid where you can only move to cells with an equal or higher altitude. :param grid: List[List[int]] The 2D grid of altitudes :return: bool True if the path exists, False otherwise >>> can_traverse([ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ]) == True >>> can_traverse([ ... [1, 2, 1], ... [2, 1, 2], ... [1, 2, 3] ... ]) == False >>> can_traverse([ ... [1] ... ]) == True >>> can_traverse([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == True >>> can_traverse([ ... [i + j for j in range(100)] for i in range(100) ... ]) == True >>> can_traverse([]) == False >>> can_traverse([ ... [1, 2, 3], ... [1, 1, 3], ... [3, 3, 3] ... ]) == True","solution":"def can_traverse(grid): Determines if there is a path from top-left to bottom-right on the grid where you can only move to cells with an equal or higher altitude. :param grid: List[List[int]] The 2D grid of altitudes :return: bool True if the path exists, False otherwise if not grid or not grid[0]: return False m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(x, y): if x == m-1 and y == n-1: return True visited[x][y] = True # Define possible movements: up, down, left, right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] >= grid[x][y]: if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"def canFormSquare(sticks): Determines if 4 sticks from the given list can form a square. Args: sticks: List[int] - A list containing lengths of sticks. Returns: bool - True if it's possible to form a square using 4 sticks, False otherwise. >>> canFormSquare([1, 1, 2, 2, 2, 3, 3, 3, 3]) True >>> canFormSquare([1, 1, 2, 2, 2, 3, 3, 3]) False >>> canFormSquare([1, 1, 2]) False >>> canFormSquare([4, 4, 4, 4]) True >>> canFormSquare([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) False >>> canFormSquare([2, 2, 2, 2, 3, 3]) True","solution":"from itertools import combinations def canFormSquare(sticks): Determines if 4 sticks from the given list can form a square. Args: sticks: List[int] - A list containing lengths of sticks. Returns: bool - True if it's possible to form a square using 4 sticks, False otherwise. if len(sticks) < 4: return False stick_combinations = combinations(sticks, 4) for comb in stick_combinations: if len(set(comb)) == 1: # All elements in the combination must be the same return True return False"},{"question":"def max_satisfaction(satisfaction: List[int]) -> int: Returns the maximum sum of like-time coefficient that can be obtained by preparing dishes in the optimal order. >>> max_satisfaction([-1, -2, -3, -4]) == 0 >>> max_satisfaction([-1, -8, 0, 5, -9]) == 14 >>> max_satisfaction([4, 3, 2]) == 20 >>> max_satisfaction([0, 1, 2, 3]) == 20 >>> max_satisfaction([]) == 0","solution":"def max_satisfaction(satisfaction): Returns the maximum sum of like-time coefficient that can be obtained by preparing dishes in the optimal order. satisfaction.sort(reverse=True) max_sum = 0 current_sum = 0 for i in range(len(satisfaction)): current_sum += satisfaction[i] if current_sum > 0: max_sum += current_sum else: break return max_sum"},{"question":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence of text1 and text2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"xyz\\", \\"xyz\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"aebdc\\") 3 >>> longest_common_subsequence(\\"ABC\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"12345\\", \\"135\\") 3 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"def\\") 0 >>> longest_common_subsequence(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence(\\"a\\", \\"b\\") 0 >>> longest_common_subsequence(\\"a\\", \\"A\\") 0","solution":"def longest_common_subsequence(text1, text2): Returns the length of the longest common subsequence of text1 and text2. # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)] # Populate the dp array. for i in range(1, len(text1) + 1): for j in range(1, len(text2) + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[len(text1)][len(text2)]"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if it's possible to remove some characters from s to form a palindrome. :param s: str, input string containing only lowercase English letters :return: bool, True if it's possible to create a palindrome, False otherwise >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"level\\") True >>> can_form_palindrome(\\"abcba\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"aa\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"aabbhijxzyyy\\") False >>> can_form_palindrome(\\"aaaaaa\\") True pass # You can write your own test cases to validate your solution","solution":"def can_form_palindrome(s): Determines if it's possible to remove some characters from s to form a palindrome. :param s: str, input string containing only lowercase English letters :return: bool, True if it's possible to create a palindrome, False otherwise from collections import Counter char_counts = Counter(s) # Count the number of characters that appear an odd number of times odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # For a string to be rearrangeable into a palindrome: # - If its length is even, no characters should have an odd frequency. # - If its length is odd, exactly one character should have an odd frequency. return odd_count <= 1"},{"question":"from typing import List def three_sum(nums: List[int], T: int) -> bool: Determines if there are three distinct numbers in the list that add up to the target sum T. Args: nums: List of integers. T: Target sum. Returns: A boolean indicating whether there are three numbers that add up to T. >>> three_sum([1, 2, 4, 5, 6], 10) True >>> three_sum([1, 2, 4, 5, 6], 20) False >>> three_sum([-3, -2, -1, -4, -5], -6) True >>> three_sum([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum([0, 0, 0, 0], 0) True >>> three_sum([1, 2], 3) False >>> three_sum([1, 1, 1, 1], 6) False","solution":"def three_sum(nums, T): Determines if there are three distinct numbers in the list that add up to the target sum T. Args: nums: List of integers. T: Target sum. Returns: A boolean indicating whether there are three numbers that add up to T. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left = i + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == T: return True elif current_sum < T: left += 1 else: right -= 1 return False"},{"question":"def score_of_parentheses(s: str) -> int: Calculate the score of a valid parentheses string. >>> score_of_parentheses(\\"\\") == 0 >>> score_of_parentheses(\\"()\\") == 1 >>> score_of_parentheses(\\"(())\\") == 2 >>> score_of_parentheses(\\"()()\\") == 2 >>> score_of_parentheses(\\"(()(()))\\") == 6 >>> score_of_parentheses(\\"(()(()))()\\") == 7","solution":"def score_of_parentheses(s): Calculate the score of a valid parentheses string. stack = [0] # Start with a base score of zero for char in s: if char == '(': stack.append(0) else: v = stack.pop() stack[-1] += max(2 * v, 1) return stack.pop()"},{"question":"class SnapshotArray: SnapshotArray is a class to support incremental snapshots of an array. Your implementation should support the following methods: * \`SnapshotArray(int length)\` Initializes an array-like data structure of the given length. Initially, each element equals \`0\`. * \`void set(int index, int val)\` Sets the element at the given index to be equal to \`val\`. * \`int snap()\` Takes a snapshot of the array and returns the \`snap_id\`: the total number of times \`snap()\` has been called minus \`1\`. * \`int get(int index, int snap_id)\` Returns the value at the given index at the time of the given \`snap_id\`. Use the methods below to implement this class. >>> sa = SnapshotArray(5) >>> sa.set(0, 5) >>> assert sa.snap() == 0 >>> assert sa.get(0, 0) == 5 def __init__(self, length: int): pass def set(self, index: int, val: int): pass def snap(self) -> int: pass def get(self, index: int, snap_id: int) -> int: pass","solution":"class SnapshotArray: def __init__(self, length: int): self.length = length self.snap_id = 0 self.array = [0] * length self.snapshots = [] def set(self, index: int, val: int): self.array[index] = val def snap(self) -> int: self.snapshots.append(self.array[:]) self.snap_id += 1 return self.snap_id - 1 def get(self, index: int, snap_id: int) -> int: return self.snapshots[snap_id][index]"},{"question":"from typing import List def word_break(s: str, wordDict: List[str]) -> bool: Determine if the string s can be segmented into a sequence of one or more dictionary words. Args: s (str): The input string to be segmented. wordDict (List[str]): The list of dictionary words. Returns: bool: True if s can be segmented into one or more dictionary words, otherwise False. Examples: >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> word_break(\\"aaaaaaa\\", [\\"aaaa\\", \\"aaa\\"]) True >>> word_break(\\"a\\", [\\"a\\"]) True >>> word_break(\\"\\", [\\"a\\", \\"b\\"]) True >>> word_break(\\"abcdef\\", [\\"abc\\", \\"defg\\"]) False >>> word_break(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) True","solution":"def word_break(s, wordDict): Returns True if s can be segmented into one or more dictionary words, otherwise False. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # Base case: an empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"def custom_sort_string(order: str, string: str) -> str: Sorts \`string\` according to the custom order defined in \`order\`. Characters not in \`order\` are appended to the end in their original order. >>> custom_sort_string(\\"cba\\", \\"abcd\\") \\"cbad\\" >>> custom_sort_string(\\"cbf\\", \\"abcd\\") \\"cbad\\" >>> custom_sort_string(\\"xyz\\", \\"abcd\\") \\"abcd\\" >>> custom_sort_string(\\"cb\\", \\"abcd\\") \\"cbad\\" >>> custom_sort_string(\\"\\", \\"abcd\\") \\"abcd\\" >>> custom_sort_string(\\"abcd\\", \\"\\") \\"\\" >>> custom_sort_string(\\"\\", \\"\\") \\"\\" >>> custom_sort_string(\\"abcd\\", \\"abcd\\") \\"abcd\\" >>> custom_sort_string(\\"cbad\\", \\"aabbccdd\\") \\"ccbbaadd\\" >>> custom_sort_string(\\"cdefghijklmnopqrstuvwxyzab\\", \\"abcdefghijklmnopqrstuvwxyz\\") \\"cdefghijklmnopqrstuvwxyzab\\"","solution":"def custom_sort_string(order, string): Sorts \`string\` according to the custom order defined in \`order\`. Characters not in \`order\` are appended to the end in their original order. order_index = {char: i for i, char in enumerate(order)} # Sort the string based on custom order sorted_string = sorted(string, key=lambda char: order_index.get(char, len(order))) return ''.join(sorted_string)"},{"question":"def max_balls_collected(grid): Returns the maximum number of balls that can be collected by placing one pipe on the grid, either horizontally on a row or vertically on a column. >>> max_balls_collected([[5]]) == 5 >>> max_balls_collected([[1, 2, 3, 4]]) == 10 >>> max_balls_collected([[1], [2], [3], [4]]) == 10 >>> max_balls_collected([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 24 >>> max_balls_collected([]) == 0 >>> max_balls_collected([ [0, 1, 2], [3, 4, 5], [6, 7, 8] ]) == 21 >>> max_balls_collected([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) == 58","solution":"def max_balls_collected(grid): Returns the maximum number of balls that can be collected by placing one pipe on the grid, either horizontally on a row or vertically on a column. if not grid: return 0 m, n = len(grid), len(grid[0]) # Check max balls collected by placing the pipe in each row max_row_sum = 0 for row in grid: max_row_sum = max(max_row_sum, sum(row)) # Check max balls collected by placing the pipe in each column max_col_sum = 0 for col in range(n): col_sum = sum(grid[row][col] for row in range(m)) max_col_sum = max(max_col_sum, col_sum) return max(max_row_sum, max_col_sum)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, targetSum): Given the root of a binary tree and an integer targetSum, return the number of valid paths where the sum of the values along the path equals targetSum. >>> root = TreeNode(5) >>> pathSum(root, 5) 1 >>> pathSum(root, 4) 0 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(-3) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(2) >>> root.right.right = TreeNode(11) >>> root.left.left.left = TreeNode(3) >>> root.left.left.right = TreeNode(-2) >>> root.left.right.right = TreeNode(1) >>> pathSum(root, 8) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, targetSum): def dfs(node, currentPath): if not node: return 0 currentPath.append(node.val) path_count, current_sum = 0, 0 for i in range(len(currentPath) - 1, -1, -1): current_sum += currentPath[i] if current_sum == targetSum: path_count += 1 path_count += dfs(node.left, currentPath) path_count += dfs(node.right, currentPath) currentPath.pop() return path_count return dfs(root, [])"},{"question":"def longest_horizontal_bridge(grid): Returns the length of the longest horizontal bridge in the grid. >>> longest_horizontal_bridge([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 3 >>> longest_horizontal_bridge([ ... [1, 0, 1], ... [1, 1, 1], ... [0, 1, 0] ... ]) == 3 >>> longest_horizontal_bridge([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> longest_horizontal_bridge([ ... [1, 0, 1, 0, 1], ... [0, 0, 0, 0, 0], ... [1, 1, 0, 0, 1] ... ]) == 2 >>> longest_horizontal_bridge([ ... [1, 0, 1, 0, 1], ... [1, 1, 1, 0, 1], ... [1, 1, 0, 0, 1] ... ]) == 3 >>> longest_horizontal_bridge([ ... [1, 1, 1, 0, 1], ... [0, 1, 1, 1, 0], ... [1, 1, 1, 1, 1] ... ]) == 5","solution":"def longest_horizontal_bridge(grid): Returns the length of the longest horizontal bridge in the grid. max_length = 0 for row in grid: current_length = 0 for cell in row: if cell == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"from typing import List import math def min_deletions_to_target_gcd(nums: List[int], target: int) -> int: Given a list of non-negative integers \`nums\`, return the minimum number of elements to remove from \`nums\` so that the greatest common divisor (GCD) of the remaining elements is equal to \`target\`. If it is not possible to achieve the \`target\` GCD, return \`-1\`. Args: nums (List[int]): A list of non-negative integers. target (int): The target GCD. Returns: int: The minimum number of elements to remove, or \`-1\` if not possible. >>> min_deletions_to_target_gcd([10, 20, 30, 40], 10) 0 >>> min_deletions_to_target_gcd([7, 11, 13], 5) -1 >>> min_deletions_to_target_gcd([10, 20, 30, 7], 10) 1 >>> min_deletions_to_target_gcd([3, 5, 7, 9], 9) 3 >>> min_deletions_to_target_gcd([24, 12, 18, 36, 6], 6) 0 >>> min_deletions_to_target_gcd([50, 25, 20, 14], 5) 1","solution":"import math def min_deletions_to_target_gcd(nums, target): Returns the minimum number of elements to remove from the list \`nums\` so that the GCD of the remaining elements is equal to \`target\`. If it's not possible, returns -1. def gcd(a, b): A helper function to calculate the GCD of two numbers. return math.gcd(a, b) # Removing elements that are not multiples of the target filtered_nums = [num for num in nums if num % target == 0] # If there are no elements that are multiples of the target, return -1 if not filtered_nums: return -1 deletions = len(nums) - len(filtered_nums) current_gcd = target for num in filtered_nums: current_gcd = gcd(current_gcd, num) if current_gcd == target: return deletions return -1 if current_gcd != target else deletions"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in a given string while maintaining the order of characters within each word. Args: s (str): A string representing a sequence of words separated by single spaces. Returns: str: The modified string with the words in reverse order. >>> reverse_words(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"\\") \\"\\"","solution":"def reverse_words(s): Reverses the order of words in a given string while maintaining the order of characters within each word. Args: s (str): A string representing a sequence of words separated by single spaces. Returns: str: The modified string with the words in reverse order. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"from typing import List from collections import Counter import heapq def rearrange_string(s: str) -> str: Rearranges the characters in a string such that the difference between the number of occurrences of any two adjacent characters is at most 1. If it is not possible to rearrange the string in this way, return an empty string. Otherwise, return the rearranged string. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"aa\\") '' >>> result = rearrange_string(\\"aabb\\") >>> result in [\\"abab\\", \\"baba\\", \\"abba\\", \\"baab\\"] True >>> result = rearrange_string(\\"aabbcc\\") >>> expected_patterns = [ ... \\"abcabc\\", \\"acbacb\\", \\"bacbac\\", \\"babcac\\", \\"cabacb\\", \\"cbabac\\", ... \\"acbabc\\", \\"bacabc\\", \\"cabcba\\", \\"cabcab\\", \\"bcaacb\\", \\"cababc\\", ... \\"ababcc\\", \\"ababcb\\", \\"babccb\\", \\"babcbc\\", \\"cabacb\\", \\"cbacab\\" ... ] >>> result in expected_patterns True","solution":"from collections import Counter import heapq def rearrange_string(s): char_count = Counter(s) max_heap = [] for char, count in char_count.items(): # Push negative count because heapq is a min-heap heapq.heappush(max_heap, (-count, char)) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char is not None: # reinsert the previous character in the heap heapq.heappush(max_heap, (prev_count, prev_char)) # Update the count of the current character because we used it once prev_count = count + 1 # Increment since it was negative prev_char = char if prev_count == 0: prev_char = None rearranged_str = ''.join(result) if len(rearranged_str) != len(s): return \\"\\" return rearranged_str"},{"question":"def group_anagrams(words: List[str]) -> List[List[str]]: Groups words that are anagrams of each other. :param words: List of words to be grouped :return: List of grouped anagrams, each group and the whole list sorted lexicographically >>> group_anagrams([\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\", \\"ant\\"]) [['ant', 'nat', 'tan'], ['bat', 'tab'], ['eat', 'tea']] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> group_anagrams([]) [] >>> group_anagrams([\\"word\\"]) [['word']] >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\"]) [['enlist', 'listen', 'silent']]","solution":"def group_anagrams(words): Groups words that are anagrams of each other. :param words: List of words to be grouped :return: List of grouped anagrams, each group and the whole list sorted lexicographically from collections import defaultdict anagram_dict = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) grouped_anagrams = [sorted(group) for group in anagram_dict.values()] return sorted(grouped_anagrams, key=lambda x: x[0])"},{"question":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def largest_values_each_level(root): Returns the largest value in each level of the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> largest_values_each_level(root) [1, 3, 9] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> largest_values_each_level(root) [1, 2, 3, 4] >>> largest_values_each_level(None) [] >>> root = TreeNode(2) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(2) >>> root.right.left = TreeNode(2) >>> root.right.right = TreeNode(2) >>> largest_values_each_level(root) [2, 2, 2] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> largest_values_each_level(root) [1, 2, 3, 4] >>> root = TreeNode(5) >>> largest_values_each_level(root) [5]","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def largest_values_each_level(root): Returns the largest value in each level of the binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float('-inf') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"def generate_all_permutations(s: str) -> List[str]: Generates all unique permutations of string \`s\` after replacing \`*\` with any lowercase English letter. The returned permutations are sorted in lexicographical order. from itertools import permutations def test_no_wildcards(): assert generate_all_permutations(\\"abc\\") == [\\"abc\\"] def test_single_wildcard(): assert generate_all_permutations(\\"a*c\\") == [ \\"aac\\", \\"abc\\", \\"acc\\", \\"adc\\", \\"aec\\", \\"afc\\", \\"agc\\", \\"ahc\\", \\"aic\\", \\"ajc\\", \\"akc\\", \\"alc\\", \\"amc\\", \\"anc\\", \\"aoc\\", \\"apc\\", \\"aqc\\", \\"arc\\", \\"asc\\", \\"atc\\", \\"auc\\", \\"avc\\", \\"awc\\", \\"axc\\", \\"ayc\\", \\"azc\\" ] def test_multiple_wildcards(): result = generate_all_permutations(\\"a*c*\\") assert len(result) == 26 * 26 # 26*26 permutations should be there assert \\"aaca\\" in result assert \\"azcz\\" in result def test_all_wildcards(): result = generate_all_permutations(\\"****\\") assert len(result) == 26**4 # 26^4 permutations should be there assert \\"aaaa\\" in result assert \\"zzzz\\" in result","solution":"from itertools import permutations def generate_all_permutations(s): Generates all unique permutations of string \`s\` after replacing \`*\` with any lowercase English letter. The returned permutations are sorted in lexicographical order. import string def replace_wildcards(s): # If there's no '*', return the string itself in a list if '*' not in s: return [s] result = set() # For each replacement character, replace first occurrence of '*' and recursively call replace_wildcards for ch in string.ascii_lowercase: replaced_string = s.replace('*', ch, 1) for perm in replace_wildcards(replaced_string): result.add(perm) return result unique_results = replace_wildcards(s) sorted_results = sorted(unique_results) return sorted_results"},{"question":"def find_local_minimum(nums: List[int]) -> int: Finds an index of any one local minimum in the array nums. If there are multiple local minima, it returns the index of any one of them. If there is no local minimum, it returns -1. A local minimum is defined as: - If at the beginning of the array, nums[0] must be less than nums[1] - If at the end of the array, nums[n-1] must be less than nums[n-2] - For all other positions, nums[i] must be less than both nums[i-1] and nums[i+1] Args: nums (list): List of integers. Returns: int: Index of any one local minimum or -1 if none exists. pass # Unit Tests def test_single_element(): assert find_local_minimum([1]) == 0 def test_no_local_minimum(): assert find_local_minimum([3, 3, 3]) == -1 def test_local_minimum_at_start(): assert find_local_minimum([1, 2, 3]) == 0 def test_local_minimum_at_end(): assert find_local_minimum([3, 2, 1]) == 2 def test_local_minimum_in_middle(): assert find_local_minimum([5, 1, 5]) == 1 assert find_local_minimum([10, 5, 20]) == 1 def test_multiple_local_minima(): result = find_local_minimum([4, 1, 5, 3, 2]) assert result in [1, 4] def test_no_local_minimum_complex(): assert find_local_minimum([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 0 def test_empty_array(): assert find_local_minimum([]) == -1","solution":"def find_local_minimum(nums): Finds an index of any one local minimum in the array nums. If there are multiple local minima, it returns the index of any one of them. If there is no local minimum, it returns -1. A local minimum is defined as: - If at the beginning of the array, nums[0] must be less than nums[1] - If at the end of the array, nums[n-1] must be less than nums[n-2] - For all other positions, nums[i] must be less than both nums[i-1] and nums[i+1] Args: nums (list): List of integers. Returns: int: Index of any one local minimum or -1 if none exists. n = len(nums) # list is empty or single element can't have a local minimum if n == 0: return -1 if n == 1: return 0 # check the first element if nums[0] < nums[1]: return 0 # check the last element if nums[n - 1] < nums[n - 2]: return n - 1 # check for remaining elements for i in range(1, n - 1): if nums[i] < nums[i - 1] and nums[i] < nums[i + 1]: return i # if no local minimum found return -1"},{"question":"def makesquare(nums): You are given a list of non-negative integers \`nums\` representing the number of sticks of various lengths. Your task is to form a square using all the sticks. Each stick must be used exactly once. Return _true_ if you can form a square, or _false_ otherwise. >>> makesquare([1,1,2,2,2]) == True >>> makesquare([3,3,3,3,4,4,4,4]) == True >>> makesquare([3,3,3,3,4]) == False >>> makesquare([1,2,2,2,2,2,2,2]) == False >>> makesquare([]) == False >>> makesquare([4]) == False >>> makesquare([0, 0, 0, 0]) == True","solution":"def makesquare(nums): if not nums: return False total_length = sum(nums) if total_length % 4 != 0: return False side_length = total_length // 4 nums.sort(reverse=True) sides = [0] * 4 def dfs(index): if index == len(nums): return sides[0] == sides[1] == sides[2] == sides[3] for i in range(4): if sides[i] + nums[index] <= side_length: sides[i] += nums[index] if dfs(index + 1): return True sides[i] -= nums[index] if sides[i] == 0: break return False return dfs(0)"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a string can be rearranged to form a palindrome. A palindrome reads the same forwards and backwards. A string can be rearranged to form a palindrome if and only if no more than one character has an odd count. >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"aabbc\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"aabbccddeeffg\\") True >>> can_form_palindrome(\\"aabbccddeeffgh\\") False","solution":"def can_form_palindrome(s): Returns True if the string can be rearranged to form a palindrome, otherwise False. from collections import Counter count = Counter(s) odd_count = sum(1 for val in count.values() if val % 2 != 0) return odd_count <= 1"},{"question":"def length_of_longest_subarray(nums: List[int]) -> int: Given an integer array nums, return the length of the longest subarray that contains at most two distinct elements. >>> length_of_longest_subarray([1, 2, 1, 3, 4, 3, 5, 3]) == 3 >>> length_of_longest_subarray([1, 2, 1, 3, 3, 5, 3]) == 4 >>> length_of_longest_subarray([1, 2, 1, 2, 1, 2, 1, 2]) == 8 >>> length_of_longest_subarray([1, 2, 3, 4, 5, 6]) == 2 >>> length_of_longest_subarray([]) == 0 >>> length_of_longest_subarray([1, 1, 1, 1]) == 4 >>> length_of_longest_subarray([1, 1, 2, 1, 1, 2, 2, 2]) == 8","solution":"def length_of_longest_subarray(nums): Returns the length of the longest subarray that contains at most two distinct elements. if not nums: return 0 left = 0 max_length = 0 freq_map = {} for right in range(len(nums)): if nums[right] not in freq_map: freq_map[nums[right]] = 0 freq_map[nums[right]] += 1 while len(freq_map) > 2: freq_map[nums[left]] -= 1 if freq_map[nums[left]] == 0: del freq_map[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def longest_substring_with_exactly_k_repeats(s: str, k: int) -> int: Returns the length of the longest substring of s such that the count of each character in that substring is exactly k. >>> longest_substring_with_exactly_k_repeats(\\"abcd\\", 2) == -1 >>> longest_substring_with_exactly_k_repeats(\\"aa\\", 2) == 2 >>> longest_substring_with_exactly_k_repeats(\\"aabb\\", 2) == 4 >>> longest_substring_with_exactly_k_repeats(\\"aabbcc\\", 2) == 6 >>> longest_substring_with_exactly_k_repeats(\\"aaa\\", 4) == -1 >>> longest_substring_with_exactly_k_repeats(\\"aabbccddeeff\\", 2) == 12 >>> longest_substring_with_exactly_k_repeats(\\"a\\", 1) == 1 >>> longest_substring_with_exactly_k_repeats(\\"\\", 1) == -1","solution":"def longest_substring_with_exactly_k_repeats(s, k): Returns the length of the longest substring of s such that the count of each character in that substring is exactly k. if k == 0: return -1 max_len = -1 n = len(s) for l in range(n): freq = {} for r in range(l, n): if s[r] in freq: freq[s[r]] += 1 else: freq[s[r]] = 1 if all(value == k for value in freq.values()): max_len = max(max_len, r - l + 1) return max_len"},{"question":"def minCostClimbingStairs(cost): Returns the minimum cost to reach the top of the stairs. Parameters: cost (List[int]): List of non-negative integers representing the energy cost of each step. Returns: int: Minimum energy required to reach the top of the stairs. pass # Unit tests def test_minCost_normal_case(): assert minCostClimbingStairs([10, 15, 20]) == 15 def test_minCost_mixed_values(): assert minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) == 6 def test_minCost_single_step(): assert minCostClimbingStairs([10]) == 10 def test_minCost_empty_steps(): assert minCostClimbingStairs([]) == 0 def test_minCost_two_steps(): assert minCostClimbingStairs([10, 15]) == 10 def test_minCost_with_zero_cost(): assert minCostClimbingStairs([0, 0, 0, 0]) == 0","solution":"def minCostClimbingStairs(cost): Returns the minimum cost to reach the top of the stairs. Parameters: cost (List[int]): List of non-negative integers representing the energy cost of each step. Returns: int: Minimum energy required to reach the top of the stairs. n = len(cost) if n == 0: return 0 elif n == 1: return cost[0] # Initialize the first two steps first = cost[0] second = cost[1] # Iterate through the cost list starting from the third step for i in range(2, n): current = cost[i] + min(first, second) first = second second = current # The minimum cost to reach the top would be the minimum of the last two steps return min(first, second)"},{"question":"from typing import List def has_cycle(graph: List[List[int]], n: int) -> bool: Determines if the directed graph has a cycle. :param graph: List of edges where each edge is represented as a pair of nodes [u, v] :param n: Number of nodes in the graph :return: True if the graph contains a cycle, False otherwise >>> has_cycle([[0, 1], [1, 2], [2, 0]], 3) True >>> has_cycle([[0, 1], [1, 2], [2, 3]], 4) False >>> has_cycle([[0, 1], [2, 3]], 4) False >>> has_cycle([[0, 1], [1, 2], [2, 2]], 3) True >>> has_cycle([[0, 1], [1, 2], [2, 0], [2, 3], [3, 4], [4, 2]], 5) True >>> has_cycle([], 0) False >>> has_cycle([], 1) False >>> has_cycle([], 4) False","solution":"def has_cycle(graph, n): Determines if the directed graph has a cycle. :param graph: List of edges where each edge is represented as a pair of nodes [u, v] :param n: Number of nodes in the graph :return: True if the graph contains a cycle, False otherwise def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in adj_list[node]: if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False from collections import defaultdict adj_list = defaultdict(list) for u, v in graph: adj_list[u].append(v) visited = set() visiting = set() for node in range(n): if dfs(node): return True return False"},{"question":"def max_area_of_island(grid: List[List[int]]) -> int: Returns the maximum area of an island in the grid. >>> max_area_of_island([ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ]) == 4 >>> max_area_of_island([ ... [0, 0, 1, 0, 0], ... [0, 1, 1, 0, 1], ... [0, 1, 0, 0, 1], ... [0, 0, 0, 1, 1] ... ]) == 4 >>> max_area_of_island([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> max_area_of_island([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 >>> max_area_of_island([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 pass","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the grid. def dfs(x, y): # Leave grid boundaries or find a water cell if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark this cell as visited grid[x][y] = 0 area = 1 # Visit all neighboring cells (left, down, right, up) area += dfs(x-1, y) area += dfs(x+1, y) area += dfs(x, y-1) area += dfs(x, y+1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"def sliding_window_sums(arr: List[int], k: int) -> List[int]: Given an array of \`n\` integers, perform a sliding window operation on the array. The sliding window has a fixed size \`k\` and moves from the start to the end of the array. For each position of the window, determine the sum of the elements inside it. Return an array of these sums. If \`k\` is greater than \`n\`, return an empty array. >>> sliding_window_sums([1, 2, 3, 4, 5], 3) [6, 9, 12] >>> sliding_window_sums([1, 2, 3, 4, 5], 5) [15] >>> sliding_window_sums([1, 2, 3], 4) [] >>> sliding_window_sums([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> sliding_window_sums([10], 1) [10] >>> sliding_window_sums([], 3) []","solution":"def sliding_window_sums(arr, k): Returns an array of sums of the sliding window of size k over the input array arr. If k is greater than the length of the array, return an empty array. n = len(arr) if k > n: return [] result = [] window_sum = sum(arr[:k]) result.append(window_sum) for i in range(k, n): window_sum += arr[i] - arr[i-k] result.append(window_sum) return result"},{"question":"def three_sum(nums, target): Determines if there are three distinct elements in \`nums\` that add up to the \`target\`. >>> three_sum([1, 2, 3, 4, 5], 9) == True >>> three_sum([1, 2, 4, 8], 15) == False >>> three_sum([-1, 0, 1, 2], 1) == True >>> three_sum([0, -1, 1, -2, 2], 0) == True >>> three_sum([1, 2, 3, 3, 4, 5], 12) == True >>> three_sum(list(range(100000, 101005)), 300003) == True # implementation here","solution":"def three_sum(nums, target): Determines if there are three distinct elements in \`nums\` that add up to the \`target\`. Parameters: nums (list of int): A list of integers. target (int): The target sum. Returns: bool: True if there exists three distinct elements in nums that add up to the target, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"class MinStack: Implement a stack data structure that allows retrieval of the minimum element in constant time. - push(val): Pushes the element onto the stack. - pop(): Removes the element on the top of the stack. - top(): Retrieves the top element of the stack. - getMin(): Retrieves the minimum element in the stack. >>> min_stack = MinStack() >>> min_stack.push(3) >>> min_stack.top() == 3 True >>> min_stack.push(5) >>> min_stack.top() == 5 True >>> min_stack.pop() >>> min_stack.top() == 3 True >>> min_stack.push(2) >>> min_stack.getMin() == 2 True >>> min_stack.pop() >>> min_stack.getMin() == 3 True >>> min_stack.push(2) >>> min_stack.push(0) >>> min_stack.push(3) >>> min_stack.push(0) >>> min_stack.getMin() == 0 True >>> min_stack.pop() >>> min_stack.getMin() == 0 True >>> min_stack.pop() >>> min_stack.getMin() == 0 True >>> min_stack.pop() >>> min_stack.getMin() == 2 True >>> min_stack.pop() >>> min_stack.getMin() == None True >>> min_stack.top() == None True def __init__(self): pass def push(self, val: int) -> None: pass def pop(self) -> None: pass def top(self) -> int: pass def getMin(self) -> int: pass","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def getMin(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"from typing import List def largestPerimeter(nums: List[int]) -> int: Given an integer array \`nums\` of size \`n\`, return the largest perimeter of a triangle that can be formed with three different elements from \`nums\`. If it is impossible to form a triangle, return 0. The perimeter of a triangle with sides \`a\`, \`b\`, and \`c\` is \`a + b + c\`. The conditions for forming a valid triangle are: - The sum of any two sides must be greater than the third side. - All side lengths must be positive. >>> largestPerimeter([2, 1, 2]) == 5 >>> largestPerimeter([1, 2, 1, 10]) == 0 >>> largestPerimeter([3, 2, 3, 4]) == 10 >>> largestPerimeter([1, 2, 3]) == 0 >>> largestPerimeter([100, 200, 300, 400]) == 900 >>> largestPerimeter([0, 0, 10, 15, 20]) == 45","solution":"from typing import List def largestPerimeter(nums: List[int]) -> int: Returns the largest perimeter of a triangle that can be formed with three different elements from nums. If no triangle can be formed, returns 0. nums.sort(reverse=True) # Sort the numbers in descending order for i in range(len(nums) - 2): if nums[i] < nums[i + 1] + nums[i + 2]: # Check the triangle inequality return nums[i] + nums[i + 1] + nums[i + 2] # Return the perimeter return 0 # If no triangle can be formed, return 0"},{"question":"def maxTasks(tasks: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping tasks that can be performed. Args: tasks (list of tuples): A list of (start, end) tuples representing the start and end times of the tasks. Returns: int: The maximum number of non-overlapping tasks. >>> maxTasks([(1, 2), (2, 3), (3, 4)]) 3 >>> maxTasks([(1, 4), (2, 6), (5, 7)]) 2 >>> maxTasks([(1, 4), (1, 4), (1, 4)]) 1","solution":"def maxTasks(tasks): Determines the maximum number of non-overlapping tasks that can be performed. Args: tasks (list of tuples): A list of (start, end) tuples representing the start and end times of the tasks. Returns: int: The maximum number of non-overlapping tasks. if not tasks: return 0 # Sort tasks by their end times tasks.sort(key=lambda x: x[1]) max_task_count = 0 current_end_time = -1 for start, end in tasks: if start >= current_end_time: max_task_count += 1 current_end_time = end return max_task_count"},{"question":"from typing import List def min_cost_to_travel(grid: List[List[int]]) -> int: Determine the minimum cost required to move the ball from the top-left corner to the bottom-right corner of the grid. >>> min_cost_to_travel([[0]]) 0 >>> min_cost_to_travel([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 4 >>> min_cost_to_travel([ ... [1, 1000], ... [1, 1000] ... ]) 999 >>> min_cost_to_travel([]) 0 >>> min_cost_to_travel([[1, 2, 3, 4, 5]]) 4 >>> min_cost_to_travel([[1], [2], [3], [4], [5]]) 4","solution":"import heapq def min_cost_to_travel(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] cost = [[float('inf')] * n for _ in range(m)] cost[0][0] = 0 heap = [(0, 0, 0)] # (cost, x, y) while heap: current_cost, x, y = heapq.heappop(heap) if x == m - 1 and y == n - 1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_cost = current_cost + abs(grid[nx][ny] - grid[x][y]) if new_cost < cost[nx][ny]: cost[nx][ny] = new_cost heapq.heappush(heap, (new_cost, nx, ny)) return cost[m - 1][n - 1]"},{"question":"def letter_combinations(s: str) -> List[str]: Returns all possible letter combinations that the number string could represent. >>> letter_combinations(\\"2\\") ['a', 'b', 'c'] >>> letter_combinations(\\"23\\") ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"7\\") ['p', 'q', 'r', 's'] >>> letter_combinations(\\"567\\") ['jmp', 'jmq', 'jmr', 'jms', 'jnp', 'jnq', 'jnr', 'jns', 'jop', 'joq', 'jor', 'jos', 'kmp', 'kmq', 'kmr', 'kms', 'knp', 'knq', 'knr', 'kns', 'kop', 'koq', 'kor', 'kos', 'lmp', 'lmq', 'lmr', 'lms', 'lnp', 'lnq', 'lnr', 'lns', 'lop', 'loq', 'lor', 'los']","solution":"def letter_combinations(s): Returns all possible letter combinations that the number string could represent. if not s: return [] phone_mapping = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): if index == len(s): combinations.append(\\"\\".join(path)) return possible_letters = phone_mapping[s[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"from typing import List def find_max_sum_subarrays(arr: List[int], k: int) -> List[List[int]]: Given an array of integers \`arr\`, find all contiguous subarrays of length \`k\` that have the maximum sum. Return all the subarrays. If there are multiple subarrays with the same maximum sum, return the subarray that appears first. You must solve this using a sliding window algorithm in \`O(n)\` time complexity. >>> find_max_sum_subarrays([1, 2, 3, 4, 5], 2) [[4, 5]] >>> find_max_sum_subarrays([1, 2, 3, 4, 3], 2) [[3, 4], [4, 3]] >>> find_max_sum_subarrays([1, 2, 3, 4, 5], 5) [[1, 2, 3, 4, 5]] >>> find_max_sum_subarrays([1, 2, 3, 4, 5], 6) [] >>> find_max_sum_subarrays([1, 3, 5, 2], 1) [[5]] >>> find_max_sum_subarrays([0, -1, -2, -3, 5, 6], 2) [[5, 6]] >>> find_max_sum_subarrays([5], 1) [[5]] >>> find_max_sum_subarrays([5], 0) [] >>> find_max_sum_subarrays([5], 2) []","solution":"from typing import List def find_max_sum_subarrays(arr: List[int], k: int) -> List[List[int]]: n = len(arr) if n < k or k <= 0: return [] max_sum = float('-inf') current_sum = sum(arr[:k]) max_subarrays = [arr[:k]] max_sum = current_sum for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum max_subarrays = [arr[i - k + 1:i + 1]] elif current_sum == max_sum: max_subarrays.append(arr[i - k + 1:i + 1]) return max_subarrays"},{"question":"def min_boxes_needed(order, box_size): Determine the minimum number of boxes required to pack all the pastries in the order. Parameters: order (list of int): An array where order[i] denotes the number of each type i pastry. box_size (int): The exact number of pastries a single box can hold. Returns: int: The minimum number of boxes required to pack all the pastries, or -1 if the order contains negative numbers. >>> min_boxes_needed([10, 15, 25], 10) == 5 >>> min_boxes_needed([24], 10) == 3 >>> min_boxes_needed([9], 10) == 1 >>> min_boxes_needed([], 10) == 0 >>> min_boxes_needed([10, -1, 20], 10) == -1 >>> min_boxes_needed([5, 3, 7], 20) == 1 >>> min_boxes_needed([10, 20, 30, 4, 6], 10) == 7 >>> min_boxes_needed([10, 20, 30, 0, 6], 10) == 7 >>> min_boxes_needed([0, 0, 0], 10) == 0","solution":"import math def min_boxes_needed(order, box_size): Returns the minimum number of boxes required to pack all pastries, or -1 if any number in the order is negative. Parameters: order (list): list of integers where each value represents the number of a type of pastry ordered. box_size (int): the size of the box that can hold a fixed number of pastries. Returns: int: minimum number of boxes required or -1 if order is invalid. if any(pastries < 0 for pastries in order): return -1 total_pastries = sum(order) return math.ceil(total_pastries / box_size)"},{"question":"def next_palindrome(n: int) -> int: Given an integer n, return the smallest number that is both a palindrome and greater than n. >>> next_palindrome(8) 9 >>> next_palindrome(10) 11 >>> next_palindrome(123) 131","solution":"def next_palindrome(n): Returns the smallest palindrome greater than n. def is_palindrome(x): s = str(x) return s == s[::-1] candidate = n + 1 while not is_palindrome(candidate): candidate += 1 return candidate"},{"question":"def apply_queries_and_prefix_sum(n: int, queries: List[List[int]]) -> List[int]: Applies queries to increment array elements and computes prefix sum. Parameters: n (int): The size of the original array. queries (List[List[int]]): A 2D list where each sublist is a query [l, r, x]. Returns: List[int]: The prefix sum array after applying the queries. >>> apply_queries_and_prefix_sum(5, [[1, 3, 2]]) == [2, 2, 2, 0, 0] >>> apply_queries_and_prefix_sum(5, [[1, 3, 2], [2, 4, 3], [1, 5, 1]]) == [3, 6, 6, 4, 1] >>> apply_queries_and_prefix_sum(5, []) == [0, 0, 0, 0, 0] >>> apply_queries_and_prefix_sum(1, [[1, 1, 5]]) == [5] >>> apply_queries_and_prefix_sum(5, [[1, 2, 1], [2, 5, 2], [3, 4, 3]]) == [1, 3, 5, 5, 2]","solution":"def apply_queries_and_prefix_sum(n, queries): Applies queries to increment array elements and computes prefix sum. Parameters: n (int): The size of the original array. queries (List[List[int]]): A 2D list where each sublist is a query [l, r, x]. Returns: List[int]: The prefix sum array after applying the queries. # Initialize the array with zeros arr = [0] * (n + 1) # Apply each query for l, r, x in queries: arr[l-1] += x if r < n: arr[r] -= x # Compute the prefix sum array prefix_sum = [0] * n current_sum = 0 for i in range(n): current_sum += arr[i] prefix_sum[i] = current_sum return prefix_sum"},{"question":"def max_products(products, discount, budget): Calculate the maximum number of distinct products that can be bought within the budget considering the discount can be applied to only one product. Parameters: - products: List[int], list of prices of the products. - discount: int, the discount percentage (assumed to be 50% in this problem) - budget: int, available budget. Returns: int, maximum number of distinct products that can be bought. >>> max_products([1, 2, 3], 50, 10) 3 >>> max_products([4, 5, 6], 50, 8) 2 >>> max_products([10, 20, 30], 50, 5) 1 >>> max_products([6, 10, 15], 50, 17) 2 >>> max_products([1, 2, 3], 50, 6) 3 >>> max_products([], 50, 5) 0 >>> max_products([5], 50, 2) 1 >>> max_products([8, 9, 10], 50, 5) 1 >>> max_products([5, 10, 20], 50, 15) 2","solution":"def max_products(products, discount, budget): Calculate the maximum number of distinct products that can be bought within the budget considering the discount can be applied to only one product. Parameters: - products: List[int], list of prices of the products. - discount: int, the discount percentage (assumed to be 50% in this problem) - budget: int, available budget. Returns: int, maximum number of distinct products that can be bought. n = len(products) products.sort() # Sort the products by their price max_products_without_discount = 0 current_budget = budget for price in products: if current_budget >= price: current_budget -= price max_products_without_discount += 1 else: break max_products_with_discount = max_products_without_discount for i in range(n): discounted_price = products[i] // 2 temp_budget = budget - discounted_price count = 1 for j in range(n): if j != i and temp_budget >= products[j]: temp_budget -= products[j] count += 1 elif j != i: break max_products_with_discount = max(max_products_with_discount, count) return max(max_products_without_discount, max_products_with_discount)"},{"question":"def length_of_lis(nums: List[int]) -> int: Returns the length of the longest increasing subsequence (LIS) in the given integer array \`nums\`. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_lis([]) == 0 >>> length_of_lis([10]) == 1 >>> length_of_lis([1, 2, 3, 4, 5]) == 5 >>> length_of_lis([5, 4, 3, 2, 1]) == 1 >>> length_of_lis([1, 3, 2, 3, 5, 4, 7, 0]) == 5 pass","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence (LIS) in the given integer array \`nums\`. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def min_unused_space(books, shelf_width): Returns the minimum unused space on the shelf after arranging all the books. Parameters: books (list of int): an array where books[i] represents the width of the i-th book. shelf_width (int): the width of the single shelf. Returns: int: the minimum unused space on the shelf. Examples: >>> min_unused_space([1, 2, 3, 4], 10) 0 >>> min_unused_space([1, 3, 6], 10) 0 >>> min_unused_space([2, 2, 2], 10) 4 >>> min_unused_space([4, 4, 4], 10) -1 >>> min_unused_space([5], 10) 5 def test_min_unused_space_perfect_match(): books = [1, 2, 3, 4] shelf_width = 10 assert min_unused_space(books, shelf_width) == 0 def test_min_unused_space_no_perfect_match(): books = [1, 3, 6] shelf_width = 10 assert min_unused_space(books, shelf_width) == 0 def test_min_unused_space_less_than_shelf_width(): books = [2, 2, 2] shelf_width = 10 assert min_unused_space(books, shelf_width) == 4 def test_min_unused_space_more_than_shelf_width(): books = [4, 4, 4] shelf_width = 10 assert min_unused_space(books, shelf_width) == -1 def test_min_unused_space_single_book(): books = [5] shelf_width = 10 assert min_unused_space(books, shelf_width) == 5","solution":"def min_unused_space(books, shelf_width): Returns the minimum unused space on the shelf after arranging all the books. Parameters: books (list of int): an array where books[i] represents the width of the i-th book. shelf_width (int): the width of the single shelf. Returns: int: the minimum unused space on the shelf. total_width = sum(books) if total_width <= shelf_width: return shelf_width - total_width else: return -1 # indicates that it is not possible to fit all books on the shelf"},{"question":"def max_items_with_budget(costs: List[int], k: int) -> int: Returns the maximum number of different items you can buy with the given budget k. Parameters: costs (list): List of integers representing the cost of each item. k (int): Budget available to buy items. Returns: int: Maximum number of different items that can be bought with the budget. >>> max_items_with_budget([1, 3, 2, 5, 4], 10) 4 >>> max_items_with_budget([1, 3, 2, 5, 4], 5) 2 >>> max_items_with_budget([1, 3, 2, 5, 4], 15) 5 >>> max_items_with_budget([10], 10) 1 >>> max_items_with_budget([10], 5) 0 >>> max_items_with_budget([], 10) 0 >>> max_items_with_budget([2, 2, 2, 2], 6) 3 >>> max_items_with_budget([2, 2, 2, 2], 8) 4 >>> max_items_with_budget([10, 20, 30, 40], 25) 1 >>> max_items_with_budget([10, 20, 30, 40], 55) 2","solution":"def max_items_with_budget(costs, k): Returns the maximum number of different items you can buy with the given budget k. Parameters: costs (list): List of integers representing the cost of each item. k (int): Budget available to buy items. Returns: int: Maximum number of different items that can be bought with the budget. costs.sort() count = 0 total_cost = 0 for cost in costs: if total_cost + cost <= k: total_cost += cost count += 1 else: break return count"},{"question":"def max_subarray_sum(nums): Given an integer array \`nums\`, find the subarray with the largest sum and return its sum. A subarray is a contiguous non-empty sequence of elements within an array. This algorithm runs in O(n) time complexity. >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([42]) 42 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([0, 0, 0, 0]) 0 >>> max_subarray_sum([1, -2, 0, 3, -1, 2]) 4","solution":"def max_subarray_sum(nums): Returns the sum of the subarray with the largest sum. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_next(target, root): Finds the node with the smallest value greater than the given target. Args: target (int): Target value to find the next greater node. root (TreeNode): Root of the binary search tree. Returns: TreeNode: The node with the smallest value greater than target or None if no such node exists. pass def test_find_next(): root = TreeNode(5, TreeNode(3, TreeNode(2, TreeNode(1), None), TreeNode(4)), TreeNode(8, TreeNode(7, TreeNode(6), None), TreeNode(9))) # tests for target within node values assert find_next(3, root).val == 4 assert find_next(5, root).val == 6 assert find_next(7, root).val == 8 assert find_next(6, root).val == 7 assert find_next(4, root).val == 5 # test for target less than all node values assert find_next(0, root).val == 1 # test for target greater than all node values assert find_next(10, root) is None # test for target equal to largest node value assert find_next(9, root) is None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_next(target, root): Finds the node with the smallest value greater than the given target. Args: target (int): Target value to find the next greater node. root (TreeNode): Root of the binary search tree. Returns: TreeNode: The node with the smallest value greater than target or None if no such node exists. succ = None while root: if root.val > target: succ = root root = root.left else: root = root.right return succ"},{"question":"def max_subarray_sum_modulo(nums: List[int], x: int) -> int: Returns the maximum sum of any contiguous subarray modulo x. :param nums: List[int], List of integers in the circular array. :param x: int, the divisor for the modulo operation. :return: int, Maximum sum of any contiguous subarray modulo x. >>> max_subarray_sum_modulo([3, 3, 9, 9, 5], 7) == 6 >>> max_subarray_sum_modulo([1, 2, 3], 3) == 2 >>> max_subarray_sum_modulo([-1, -2, -3], 4) == 3 >>> max_subarray_sum_modulo([4, 5, -1, 2, -7, 2], 5) == 4 >>> max_subarray_sum_modulo([10, 4, -1, -6, 3, 2, 1], 5) == 4","solution":"def max_subarray_sum_modulo(nums, x): Returns the maximum sum of any contiguous subarray modulo x. :param nums: List[int], List of integers in the circular array. :param x: int, the divisor for the modulo operation. :return: int, Maximum sum of any contiguous subarray modulo x. n = len(nums) max_sum = 0 for i in range(n): current_sum = 0 for j in range(n): current_sum += nums[(i + j) % n] max_sum = max(max_sum, current_sum % x) return max_sum"},{"question":"def is_valid_ipv4_address(s: str) -> bool: Validate if a given string \`s\` is a valid IPv4 address. An IPv4 address is a string in the form \\"A.B.C.D\\", where the four segments \`A\`, \`B\`, \`C\`, and \`D\` are integers in the range [0, 255]. Additionally, leading zeros are not allowed (e.g., \\"192.168.01.1\\" is invalid). Args: s (str): The input string. Returns: bool: \`True\` if \`s\` is a valid IPv4 address, \`False\` otherwise. >>> is_valid_ipv4_address(\\"192.168.1.1\\") True >>> is_valid_ipv4_address(\\"192.168.1.256\\") False >>> is_valid_ipv4_address(\\"255.255.255.255\\") True >>> is_valid_ipv4_address(\\"0.0.0.0\\") True >>> is_valid_ipv4_address(\\"192.168.01.1\\") False >>> is_valid_ipv4_address(\\"192.168.1.1.1\\") False >>> is_valid_ipv4_address(\\"192.168.-1.1\\") False >>> is_valid_ipv4_address(\\"192.168.1.a\\") False","solution":"def is_valid_ipv4_address(s): Validate if a given string \`s\` is a valid IPv4 address. Args: s (str): The input string. Returns: bool: \`True\` if \`s\` is a valid IPv4 address, \`False\` otherwise. parts = s.split('.') # There should be exactly 4 parts if len(parts) != 4: return False for part in parts: # Each part should be an integer if not part.isdigit(): return False num = int(part) # Each integer should be in the range [0, 255] if num < 0 or num > 255: return False # No leading zeros are allowed if part[0] == '0' and len(part) > 1: return False return True"},{"question":"def rearrange_array(arr): Rearranges the elements in arr such that positive elements appear at even indices and negative elements appear at odd indices. If there are more elements than needed for one type (either positive or negative) just place them in the array after arranging required elements. >>> rearrange_array([1, 2, 3, 4]) == [1, 2, 3, 4] >>> rearrange_array([-1, -2, -3, -4]) == [-1, -2, -3, -4] >>> rearrange_array([1, -1, 2, -2, 3, -3]) == [1, -1, 2, -2, 3, -3] >>> rearrange_array([1, 2, 3, 4, -1, -2]) == [1, -1, 2, -2, 3, 4] >>> rearrange_array([-1, -2, -3, -4, 1, 2]) == [1, -1, 2, -2, -3, -4] >>> rearrange_array([]) == [] >>> rearrange_array([1]) == [1] >>> rearrange_array([-1]) == [-1] >>> rearrange_array([1, 2]) == [1, 2] >>> rearrange_array([-1, -2]) == [-1, -2] >>> rearrange_array([1, -1]) == [1, -1]","solution":"def rearrange_array(arr): Rearranges the elements in arr such that positive elements appear at even indices and negative elements appear at odd indices. pos = [element for element in arr if element >= 0] neg = [element for element in arr if element < 0] result = [] i = j = 0 for k in range(len(arr)): if k % 2 == 0 and i < len(pos): result.append(pos[i]) i += 1 elif k % 2 == 1 and j < len(neg): result.append(neg[j]) j += 1 else: break # Append remaining elements result.extend(pos[i:]) result.extend(neg[j:]) return result"},{"question":"def count_constructible_words(words: List[str], target: str) -> int: Determine the number of unique words that can be formed from the characters of 'target' with unlimited copies of each character. >>> count_constructible_words([\\"abc\\", \\"a\\", \\"ab\\", \\"bc\\"], \\"abcabc\\") 4 >>> count_constructible_words([\\"abc\\", \\"abcd\\", \\"abcde\\", \\"a\\"], \\"abcabc\\") 2 >>> count_constructible_words([\\"xyz\\", \\"mnop\\", \\"qrs\\"], \\"abc\\") 0 >>> count_constructible_words([\\"a\\", \\"a\\", \\"a\\", \\"a\\"], \\"abc\\") 1 >>> count_constructible_words([\\"abc\\", \\"def\\"], \\"\\") 0 >>> count_constructible_words([], \\"abcabc\\") 0 >>> count_constructible_words([\\"a\\", \\"B\\", \\"ab\\", \\"Ab\\"], \\"abAB\\") 4","solution":"def count_constructible_words(words, target): from collections import Counter target_counter = Counter(target) unique_constructible_words = set() for word in words: word_counter = Counter(word) if all(word_counter[char] <= target_counter[char] for char in word_counter): unique_constructible_words.add(word) return len(unique_constructible_words)"},{"question":"def count_best_friends(nums: List[int], k: int) -> List[int]: Returns a list where each element at index \`i\` corresponds to the total number of best friends for \`nums[i]\`. >>> count_best_friends([1, 5, 9, 14], 3) [0, 0, 0, 0] >>> count_best_friends([1, 4, 7, 10], 3) [1, 2, 2, 1] >>> count_best_friends([5, 5, 5, 5], 0) [0, 0, 0, 0] >>> count_best_friends([1], 1) [0] >>> count_best_friends([1, 5, 9, 14], 20) [3, 3, 3, 3]","solution":"def count_best_friends(nums, k): Returns a list where each element at index \`i\` corresponds to the total number of best friends for \`nums[i]\`. result = [] for i, num in enumerate(nums): count = sum(1 for other_num in nums if num != other_num and abs(num - other_num) <= k) result.append(count) return result"},{"question":"def can_transform(s1: str, s2: str) -> bool: Check if s1 can become s2 by replacing characters. Args: s1 (str): The original string. s2 (str): The target string. Returns: bool: True if s1 can be transformed into s2, False otherwise. >>> can_transform(\\"abc\\", \\"def\\") True >>> can_transform(\\"abc\\", \\"abc\\") True >>> can_transform(\\"abcd\\", \\"efgh\\") True >>> can_transform(\\"abc\\", \\"de\\") False >>> can_transform(\\"abcd\\", \\"efg\\") False >>> can_transform(\\"a\\", \\"\\") False >>> can_transform(\\"\\", \\"a\\") False >>> can_transform(\\"\\", \\"\\") True","solution":"def can_transform(s1, s2): Check if s1 can become s2 by replacing characters. Args: s1 (str): The original string. s2 (str): The target string. Returns: bool: True if s1 can be transformed into s2, False otherwise. return len(s1) == len(s2)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: Return the sum of all the binary numbers represented by paths from the root to the leaf nodes. >>> root = TreeNode(1) >>> sumRootToLeaf(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.right = TreeNode(1) >>> sumRootToLeaf(root) 5 # 10 + 11 in binary >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(1) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(1) >>> sumRootToLeaf(root) 22 # 100 + 101 + 110 + 111 in binary >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.left.left = TreeNode(0) >>> root.left.left.left = TreeNode(1) >>> sumRootToLeaf(root) 9 # 1001 in binary >>> root = None >>> sumRootToLeaf(root) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): def dfs(node, current_number): if not node: return 0 current_number = (current_number << 1) | node.val if not node.left and not node.right: return current_number left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"def find_most_severe_unresolved_bug(bug_reports, start_time, end_time): Returns the ID of the most severe unresolved bug within the specified time range. If there are multiple bugs with the same severity, return the one with the lowest ID. If no such bug exists, return \`-1\`. :param bug_reports: List of tuples (id, timestamp, severity, resolved) :param start_time: Start of the time range (inclusive) :param end_time: End of the time range (inclusive) :return: ID of the most severe unresolved bug or -1 if no such bug exists. >>> bug_reports = [(1, 10, 5, True), (2, 15, 3, True)] >>> find_most_severe_unresolved_bug(bug_reports, 5, 20) == -1 >>> bug_reports = [(1, 10, 5, False)] >>> find_most_severe_unresolved_bug(bug_reports, 5, 20) == 1 >>> bug_reports = [(1, 10, 5, False), (2, 15, 7, False), (3, 20, 6, False)] >>> find_most_severe_unresolved_bug(bug_reports, 5, 20) == 2 >>> bug_reports = [(1, 10, 5, False), (2, 15, 5, False), (3, 20, 5, False)] >>> find_most_severe_unresolved_bug(bug_reports, 5, 20) == 1 >>> bug_reports = [(1, 5, 5, False), (2, 15, 6, False)] >>> find_most_severe_unresolved_bug(bug_reports, 5, 20) == 2 >>> bug_reports = [(1, 10, 5, False), (2, 15, 6, False), (3, 20, 7, False)] >>> find_most_severe_unresolved_bug(bug_reports, 5, 20) == 3 >>> bug_reports = [(1, 10, 5, False), (2, 15, 6, True), (3, 20, 7, False), (4, 25, 4, True)] >>> find_most_severe_unresolved_bug(bug_reports, 5, 20) == 3 >>> bug_reports = [(1, 1, 5, False), (2, 2, 6, False), (3, 3, 7, False)] >>> find_most_severe_unresolved_bug(bug_reports, 4, 20) == -1","solution":"def find_most_severe_unresolved_bug(bug_reports, start_time, end_time): Returns the ID of the most severe unresolved bug within the specified time range. If there are multiple bugs with the same severity, return the one with the lowest ID. If no such bug exists, return \`-1\`. :param bug_reports: List of tuples (id, timestamp, severity, resolved) :param start_time: Start of the time range (inclusive) :param end_time: End of the time range (inclusive) :return: ID of the most severe unresolved bug or -1 if no such bug exists. unresolved_bugs = [ (bug_id, timestamp, severity) for bug_id, timestamp, severity, resolved in bug_reports if not resolved and start_time <= timestamp <= end_time ] if not unresolved_bugs: return -1 # Sort by severity in descending order, and by id in ascending order if severity equal unresolved_bugs.sort(key=lambda x: (-x[2], x[0])) return unresolved_bugs[0][0]"},{"question":"def two_sum(nums, target): Find indices i, j such that nums[i] + nums[j] = target, where i and j are distinct. Args: nums: List of integers target: Integer target sum Returns: Tuple of integers (i, j) from solution import two_sum def test_two_sum_basic(): assert two_sum([2, 7, 11, 15], 9) == (0, 1) def test_two_sum_multiple_pairs(): assert two_sum([3, 2, 4], 6) == (1, 2) def test_two_sum_larger_list(): assert two_sum([1, 2, 3, 4, 5, 6], 11) == (4, 5) def test_two_sum_negative_numbers(): assert two_sum([-1, -2, -3, -4, -5], -8) == (2, 4) def test_two_sum_mixed_numbers(): assert two_sum([-1, 2, 1, -4], -5) == (0, 3)","solution":"def two_sum(nums, target): Find indices i, j such that nums[i] + nums[j] = target, where i and j are distinct. Args: nums: List of integers target: Integer target sum Returns: Tuple of integers (i, j) index_map = {} for i, num in enumerate(nums): complement = target - num if complement in index_map: return (index_map[complement], i) index_map[num] = i"},{"question":"from typing import List def maxProfit(startTime: List[int], endTime: List[int], profit: List[int]) -> int: Returns the maximum profit by scheduling non-overlapping activities. >>> maxProfit([1], [2], [5]) 5 >>> maxProfit([1, 3, 5], [2, 4, 6], [5, 10, 15]) 30 >>> maxProfit([1, 2, 3], [3, 4, 5], [50, 10, 40]) 90 >>> maxProfit([1, 3, 2, 4], [3, 5, 4, 6], [50, 10, 40, 70]) 120 >>> maxProfit([1, 2, 3, 4], [10, 10, 10, 10], [20, 30, 50, 10]) 50 >>> maxProfit([1, 5, 9], [4, 8, 12], [20, 30, 50]) 100","solution":"from typing import List import bisect def maxProfit(startTime: List[int], endTime: List[int], profit: List[int]) -> int: Returns the maximum profit by scheduling non-overlapping activities. activities = sorted(zip(startTime, endTime, profit), key=lambda x: x[1]) dp = [(0, 0)] # (ending time, cumulative profit) for start, end, prof in activities: idx = bisect.bisect_right(dp, (start, float('inf'))) if dp[idx - 1][1] + prof > dp[-1][1]: dp.append((end, dp[idx - 1][1] + prof)) return dp[-1][1]"},{"question":"def consistently_performing_employees(employeeName: List[str], employeeScore: List[int]) -> List[str]: Return a list of unique employee names who are consistently performing within certain thresholds. Consistently performing means having at least three scores within the range [60, 80] inclusive. The names should be sorted in ascending order alphabetically. >>> consistently_performing_employees( ... [\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\"], ... [75, 70, 62, 65, 78, 72] ... ) == [\\"Alice\\", \\"Bob\\"] >>> consistently_performing_employees( ... [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Charlie\\", \\"Bob\\", \\"Charlie\\"], ... [75, 70, 85, 62, 65, 78, 60, 72, 77] ... ) == [\\"Alice\\", \\"Bob\\"] >>> consistently_performing_employees( ... [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Alice\\", \\"Bob\\", \\"Alice\\", \\"David\\", \\"Charlie\\", \\"Bob\\", \\"Charlie\\", \\"David\\"], ... [50, 85, 90, 59, 40, 95, 45, 58, 82, 92, 78, 79] ... ) == [] >>> consistently_performing_employees( ... [\\"Alice\\", \\"Alice\\", \\"Alice\\"], ... [60, 80, 70] ... ) == [\\"Alice\\"] >>> consistently_performing_employees( ... [\\"Alice\\", \\"Alice\\", \\"Alice\\", \\"Alice\\", \\"Alice\\"], ... [60, 72, 78, 83, 79] ... ) == [\\"Alice\\"] >>> consistently_performing_employees( ... [\\"Alice\\", \\"Bob\\", \\"Bob\\", \\"Bob\\", \\"Charlie\\", \\"Charlie\\", \\"David\\"], ... [60, 60, 70, 80, 61, 65, 80] ... ) == [\\"Bob\\"]","solution":"def consistently_performing_employees(employeeName, employeeScore): from collections import defaultdict score_dict = defaultdict(list) # Populate the dictionary with employee scores for name, score in zip(employeeName, employeeScore): score_dict[name].append(int(score)) consistent_employees = [] # Check each employee's scores and filter those consistently performing for name, scores in score_dict.items(): count = sum(60 <= score <= 80 for score in scores) if count >= 3: consistent_employees.append(name) # Return the sorted list of employee names return sorted(consistent_employees)"},{"question":"def max_stock_prices(heights, d): Returns an array where for each day, the maximum stock price within the next d days (inclusive). If there are fewer than d days left, consider only the available days. return [] # Unit Tests def test_max_stock_prices_short_range(): assert max_stock_prices([1, 2, 3, 5, 1, 2], 2) == [2, 3, 5, 5, 2, 2] assert max_stock_prices([1, 2, 3, 5, 1, 2], 3) == [3, 5, 5, 5, 2, 2] def test_max_stock_prices_exact_range(): assert max_stock_prices([5, 4, 3, 8, 7, 6], 6) == [8, 8, 8, 8, 7, 6] def test_max_stock_prices_more_than_length(): assert max_stock_prices([5, 4, 3, 8, 7, 6], 10) == [8, 8, 8, 8, 7, 6] def test_max_stock_prices_all_same(): assert max_stock_prices([3, 3, 3, 3, 3], 3) == [3, 3, 3, 3, 3] def test_max_stock_prices_single_day(): assert max_stock_prices([6, 1, 4, 2], 1) == [6, 1, 4, 2]","solution":"def max_stock_prices(heights, d): Returns an array where for each day, the maximum stock price within the next d days (inclusive). If there are fewer than d days left, consider only the available days. n = len(heights) result = [] for i in range(n): max_price = max(heights[i:i+d]) # Consider the range from i to i+d (inclusive) result.append(max_price) return result"},{"question":"def rearrange_array(nums): Rearranges the array so that even numbers are at even indices and odd numbers are at odd indices. Args: nums: List[int] - an array containing n/2 even numbers and n/2 odd numbers. Returns: List[int] - the rearranged array. pass # Example test cases def test_example_case(): assert rearrange_array([4, 2, 5, 7]) == [4, 5, 2, 7] def test_all_odds_and_evens(): assert rearrange_array([1, 2, 3, 4, 5, 6, 7, 8]) == [2, 1, 4, 3, 6, 5, 8, 7] def test_mixed_array(): assert rearrange_array([6, 3, 2, 5, 8, 7]) == [6, 3, 2, 5, 8, 7] def test_minimal_case(): assert rearrange_array([2, 1]) == [2, 1] def test_already_arranged(): assert rearrange_array([0, 1, 4, 3, 6, 5, 8, 7]) == [0, 1, 4, 3, 6, 5, 8, 7]","solution":"def rearrange_array(nums): Rearranges the array so that even numbers are at even indices and odd numbers are at odd indices. Args: nums: List[int] - an array containing n/2 even numbers and n/2 odd numbers. Returns: List[int] - the rearranged array. even_idx, odd_idx = 0, 1 result = [0] * len(nums) for num in nums: if num % 2 == 0: result[even_idx] = num even_idx += 2 else: result[odd_idx] = num odd_idx += 2 return result"},{"question":"def four_sum(nums: List[int], target: int) -> bool: Determines if there exist four distinct elements in the list that add up to the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) True >>> four_sum([1, 2, 3, 4, 5], 100) False >>> four_sum([], 0) False >>> four_sum([2, 2, 2, 2, 2], 8) True >>> four_sum([1000, 2000, 3000, 4000, 5000, -1000, -2000, -3000, -4000], 0) True >>> four_sum([4, 7, 11, 15, -2, -3, 2, 1], 26) True >>> four_sum([1, 1, 1, 1, 1, 1, 1, 1], 10) False >>> four_sum([2, 2, 2], 8) False","solution":"def four_sum(nums, target): Determines if there exist four distinct elements in the list that add up to the target. :param nums: List of integers. :param target: Target integer. :return: True if there exist four distinct elements that add up to the target, otherwise False. nums.sort() n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"def maximum_sum(arr: List[int]) -> int: Given an array of integers \`arr\`, find the maximum sum of any non-empty subarray of \`arr\` with at most one deletion of an element allowed. A subarray is a contiguous part of an array. Return an integer representing the maximum sum possible after at most one deletion. >>> maximum_sum([1, -2, 0, 3]) 4 >>> maximum_sum([1, -2, -3, 4]) 4","solution":"def maximum_sum(arr): if not arr: return 0 n = len(arr) if n == 1: return arr[0] dp_no_deletion = [0] * n dp_one_deletion = [0] * n dp_no_deletion[0] = arr[0] dp_one_deletion[0] = float('-inf') max_sum = arr[0] for i in range(1, n): dp_no_deletion[i] = max(arr[i], dp_no_deletion[i-1] + arr[i]) dp_one_deletion[i] = max(dp_no_deletion[i-1], dp_one_deletion[i-1] + arr[i]) max_sum = max(max_sum, dp_no_deletion[i], dp_one_deletion[i]) return max_sum"},{"question":"import heapq from typing import List, Tuple def scheduleCourses(courses: List[Tuple[int, int]]) -> int: Returns the maximum number of courses that can be taken. Each course is represented as a tuple (duration, last_day). Parameters: courses (list of tuples): List of courses where each course is represented by its duration and the last day to finish. Returns: int: Maximum number of courses that can be taken. >>> scheduleCourses([(5, 5), (4, 6), (2, 8)]) 2 >>> scheduleCourses([(10, 10), (5, 6)]) 1 >>> scheduleCourses([(2, 5), (2, 8)]) 2 >>> scheduleCourses([]) 0 >>> scheduleCourses([(1, 2)]) 1 >>> scheduleCourses([(1, 2), (2, 5), (3, 6), (4, 8)]) 3","solution":"import heapq def scheduleCourses(courses): Returns the maximum number of courses that can be taken. Each course is represented as a tuple (duration, last_day). Parameters: courses (list of tuples): List of courses where each course is represented by its duration and the last day to finish. Returns: int: Maximum number of courses that can be taken. # Sort the courses by their last day courses.sort(key=lambda x: x[1]) total_time = 0 max_courses = [] for duration, end_day in courses: heapq.heappush(max_courses, -duration) total_time += duration # If total time exceeds the end day, remove the course with the longest duration if total_time > end_day: total_time += heapq.heappop(max_courses) return len(max_courses)"},{"question":"def smallest_string_with_sorted_substring(s: str, k: int) -> str: Returns the lexicographically smallest string by sorting a substring of length k. Parameters: s (str): the original string consisting of lowercase English letters k (int): the length of the substring to sort Returns: str: the lexicographically smallest string after sorting a substring of length k Examples: >>> smallest_string_with_sorted_substring(\\"abc\\", 5) 'abc' >>> smallest_string_with_sorted_substring(\\"cba\\", 3) 'abc' >>> smallest_string_with_sorted_substring(\\"dcba\\", 2) 'cdba' >>> smallest_string_with_sorted_substring(\\"abcd\\", 2) 'abcd' >>> smallest_string_with_sorted_substring(\\"dbca\\", 2) 'bdca' >>> smallest_string_with_sorted_substring(\\"acbde\\", 3) 'abcde'","solution":"def smallest_string_with_sorted_substring(s, k): Returns the lexicographically smallest string by sorting a substring of length k. Parameters: s (str): the original string consisting of lowercase English letters k (int): the length of the substring to sort Returns: str: the lexicographically smallest string after sorting a substring of length k if len(s) < k: return s result = s for i in range(len(s) - k + 1): new_s = s[:i] + ''.join(sorted(s[i:i+k])) + s[i+k:] if new_s < result: result = new_s return result"},{"question":"def num_decodings(s: str) -> int: Given a string representing an encoded message, determine the total number of ways to decode it. The mapping is 'A'->1, 'B'->2, ..., 'Z'->26. The encoded message may contain leading zeros. >>> num_decodings(\\"12\\") == 2 >>> num_decodings(\\"226\\") == 3 >>> num_decodings(\\"0\\") == 0 >>> num_decodings(\\"06\\") == 0 >>> num_decodings(\\"10\\") == 1 >>> num_decodings(\\"\\") == 0 >>> num_decodings(\\"1\\") == 1 >>> num_decodings(\\"27\\") == 1 >>> num_decodings(\\"123456789\\") == 3 >>> num_decodings(\\"11106\\") == 2","solution":"def num_decodings(s): if not s: return 0 n = len(s) # dp[i] means the number of ways to decode the substring s[0:i] dp = [0] * (n + 1) dp[0] = 1 # Base case: An empty string has one way to be decoded for i in range(1, n + 1): # If the single digit is valid (i.e. from 1 to 9), add the number of ways to decode the substring s[0:i-1] if s[i - 1] != '0': dp[i] += dp[i - 1] # If the two digit number is valid (i.e. from 10 to 26), add the number of ways to decode the substring s[0:i-2] if i > 1 and '10' <= s[i-2:i] <= '26': dp[i] += dp[i - 2] return dp[n]"},{"question":"from typing import List def most_frequent_substring(s: str, k: int) -> str: Returns the most frequent substring of length k in the given string s. If there are multiple substrings with the same highest frequency, returns the lexicographically smallest one. If k is larger than the length of s, returns an empty string. >>> most_frequent_substring(\\"ababcabc\\", 2) 'ab' >>> most_frequent_substring(\\"aaaaaa\\", 2) 'aa' >>> most_frequent_substring(\\"abcabcabc\\", 3) 'abc' >>> most_frequent_substring(\\"abc\\", 4) '' >>> most_frequent_substring(\\"abcdef\\", 1) 'a' >>> most_frequent_substring(\\"\\", 1) '' >>> most_frequent_substring(\\"a\\"*10000, 1) 'a' >>> most_frequent_substring(\\"abcdef\\", 6) 'abcdef'","solution":"def most_frequent_substring(s, k): Returns the most frequent substring of length k in the given string s. If there are multiple substrings with the same highest frequency, returns the lexicographically smallest one. If k is larger than the length of s, returns an empty string. if k > len(s): return \\"\\" from collections import defaultdict freq_map = defaultdict(int) # Generate all substrings of length k and count their frequencies for i in range(len(s) - k + 1): substr = s[i:i+k] freq_map[substr] += 1 # Determine the maximum frequency max_freq = max(freq_map.values()) # Collect all substrings with the maximum frequency max_freq_substrings = [substr for substr, freq in freq_map.items() if freq == max_freq] # Return the lexicographically smallest substring among those with maximum frequency return min(max_freq_substrings) # Example usage: # s = \\"ababcabc\\" # k = 2 # Output should be \\"ab\\" as \\"ab\\" and \\"bc\\" both appear twice, but \\"ab\\" is lexicographically smaller."},{"question":"from typing import List def rearrange_nums(nums: List[int]) -> List[int]: Rearranges the elements of the array \`nums\` such that the sum of any two adjacent elements is not zero. If it is not possible, returns an empty list. >>> rearrange_nums([1, -1, 1, -1]) in [[1, -1, 1, -1], [-1, 1, -1, 1]] True >>> rearrange_nums([1, 1, 1, -1]) [] >>> rearrange_nums([1, 1, -1]) [1, -1, 1] >>> rearrange_nums([-1, -1, 1]) [-1, 1, -1] >>> rearrange_nums([1]) [1] >>> rearrange_nums([-1]) [-1] >>> rearrange_nums([]) []","solution":"def rearrange_nums(nums): Rearranges the elements of the array \`nums\` such that the sum of any two adjacent elements is not zero. If it is not possible, returns an empty array. count_1 = nums.count(1) count_neg1 = nums.count(-1) if abs(count_1 - count_neg1) > 1: return [] if count_1 >= count_neg1: result = [1, -1] * count_neg1 + ([1] if count_1 > count_neg1 else []) else: result = [-1, 1] * count_1 + ([-1] if count_neg1 > count_1 else []) return result"},{"question":"def longest_equal_subarray(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with an equal number of positive and negative numbers. If no such subarray exists, returns 0. >>> longest_equal_subarray([1, -1, 1, -1, 1]) == 4 >>> longest_equal_subarray([1, 1, -1, -1, 1, -1]) == 6 >>> longest_equal_subarray([1, -1, -1, 1, 1]) == 4 >>> longest_equal_subarray([1, 1, 1]) == 0 >>> longest_equal_subarray([-1, -1, -1]) == 0 >>> longest_equal_subarray([1, 1, 1, 1, 1, 1]) == 0 >>> longest_equal_subarray([-1, 1, 1, -1, 1, -1, -1]) == 6 >>> longest_equal_subarray([-1, -1, 1, 1, 1, -1, 1, -1, 1, -1]) == 10 >>> longest_equal_subarray([1, -1, -1, 1, -1, 1, 1, -1, 1, -1]) == 10 >>> longest_equal_subarray([1]) == 0 >>> longest_equal_subarray([-1]) == 0 >>> longest_equal_subarray([1, -1]) == 2","solution":"def longest_equal_subarray(nums): Returns the length of the longest contiguous subarray with an equal number of positive and negative numbers. If no such subarray exists, returns 0. n = len(nums) balance = {0: -1} prefix_balance = 0 max_length = 0 for i in range(n): if nums[i] > 0: prefix_balance += 1 elif nums[i] < 0: prefix_balance -= 1 if prefix_balance in balance: max_length = max(max_length, i - balance[prefix_balance]) else: balance[prefix_balance] = i return max_length"},{"question":"from typing import List def longest_word(words: List[str], letters: str) -> str: Finds the longest word in \`words\` that can be formed using the letters in \`letters\`. Each letter in \`letters\` can only be used once per word. If there are multiple words of the same length, return the one that appears first in the input list. If no word can be formed, return an empty string. >>> longest_word([\\"apple\\", \\"plea\\", \\"banana\\", \\"ple\\", \\"a\\"], \\"aeppl\\") 'apple' >>> longest_word([\\"cat\\", \\"bat\\", \\"rat\\"], \\"tca\\") 'cat' >>> longest_word([\\"dog\\", \\"elephant\\", \\"tiger\\"], \\"abc\\") '' >>> longest_word([\\"abc\\", \\"de\\", \\"fg\\"], \\"bcadefg\\") 'abc' >>> longest_word([], \\"abc\\") '' >>> longest_word([\\"one\\", \\"two\\", \\"three\\"], \\"\\") '' pass","solution":"from collections import Counter def longest_word(words, letters): Finds the longest word in \`words\` that can be formed using the letters in \`letters\`. Each letter in \`letters\` can only be used once per word. If there are multiple words of the same length, return the one that appears first in the input list. If no word can be formed, return an empty string. Parameters: words (list of str): List of words to check. letters (str): String of available letters. Returns: str: The longest word formed with the letters, or an empty string. letters_count = Counter(letters) longest = \\"\\" for word in words: word_count = Counter(word) if all(word_count[char] <= letters_count[char] for char in word_count): if len(word) > len(longest): longest = word return longest"},{"question":"def has_cycle(graph: dict) -> bool: Determines if the directed graph contains a cycle. :param graph: Dictionary representing the adjacency list of the graph. Keys are node labels and values are lists of neighboring node labels. :return: True if there is a cycle in the graph, otherwise False. >>> has_cycle({0: [1], 1: [2], 2: []}) False >>> has_cycle({0: [0]}) True >>> has_cycle({0: [1], 1: [2], 2: [0]}) True >>> has_cycle({0: [1], 1: [2], 2: [0], 3: [4], 4: []}) True >>> has_cycle({0: [1], 1: [2], 2: [], 3: [4], 4: []}) False >>> has_cycle({0: [1, 2], 1: [2], 2: [3], 3: [1]}) True >>> has_cycle({0: [1, 2], 1: [3], 2: [3], 3: [4], 4: []}) False","solution":"def has_cycle(graph): Determines if the directed graph contains a cycle. :param graph: Dictionary representing the adjacency list of the graph. Keys are node labels and values are lists of neighboring node labels. :return: True if there is a cycle in the graph, otherwise False. # Initialize visited and recursion stack visited = set() rec_stack = set() # Helper function for DFS def dfs(node): if node in rec_stack: return True # Found a cycle if node in visited: return False # Mark the current node as visited and add to recursion stack visited.add(node) rec_stack.add(node) # Recur for all neighbours for neighbor in graph.get(node, []): if dfs(neighbor): return True # Remove the node from recursion stack rec_stack.remove(node) return False # Check for cycle in different disconnected components for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"def max_painted_buildings(heights: List[int], k: int) -> int: You are given an integer array \`heights\` representing the heights of a set of buildings, where each building's width is \`1\`. The array is sorted in non-decreasing order. You want to paint some of the buildings such that no two adjacent painted buildings have a height difference greater than \`1\`. You can paint at most \`k\` buildings. Return the maximum number of buildings you can paint. >>> max_painted_buildings([1, 2, 2, 3, 4, 5], 3) 3 >>> max_painted_buildings([], 3) 0 >>> max_painted_buildings([2, 2, 2, 2, 2], 4) 4 >>> max_painted_buildings([1, 1, 2, 2], 3) 3 >>> max_painted_buildings([1, 2, 4, 5, 6], 2) 2","solution":"def max_painted_buildings(heights, k): n = len(heights) max_count = 0 left = 0 for right in range(n): while heights[right] - heights[left] > 1: left += 1 max_count = max(max_count, right - left + 1) if right - left + 1 > k: left += 1 return min(max_count, k)"},{"question":"def collectable_heights(heights: List[int]) -> int: Returns the sum of the heights of the buildings the bird can arrive at without descending to a lower or equal height building first. >>> collectable_heights([1, 2, 3, 4, 5]) == 15 >>> collectable_heights([1, 3, 7, 4, 2]) == 11 >>> collectable_heights([2, 4, 6, 6, 5, 2]) == 18 >>> collectable_heights([5, 4, 3, 2, 1]) == 5 >>> collectable_heights([7]) == 7 >>> collectable_heights([]) == 0","solution":"def collectable_heights(heights): Returns the sum of the heights of the buildings the bird can arrive at without descending to a lower or equal height building first. if not heights: return 0 total_height = 0 current_max_height = heights[0] # Moving from left to right for height in heights: if height >= current_max_height: current_max_height = height total_height += height else: break return total_height"},{"question":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists): Merges k sorted linked lists and returns it as one sorted linked list. >>> lists = [linked_list_from_array([1, 4, 5]), linked_list_from_array([1, 3, 4]), linked_list_from_array([2, 6])] >>> print_linked_list(mergeKLists(lists)) [1, 1, 2, 3, 4, 4, 5, 6] >>> lists = [linked_list_from_array([-10, -5, 0]), linked_list_from_array([-3, -2, -1, 1]), linked_list_from_array([-6, 6])] >>> print_linked_list(mergeKLists(lists)) [-10, -6, -5, -3, -2, -1, 0, 1, 6]","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists): Merges k sorted linked lists and returns it as one sorted linked list. min_heap = [] for idx, l in enumerate(lists): if l: heapq.heappush(min_heap, (l.val, idx, l)) dummy = ListNode(None) current = dummy while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next def print_linked_list(head): Helper function to print linked list. result = [] while head: result.append(head.val) head = head.next return result"},{"question":"def max_length_subarray_with_k_distinct(arr, k): Given an array of integers \`arr\` and an integer \`k\`, find the maximum length of a contiguous subarray that contains exactly \`k\` distinct integers. If there is no such subarray, return 0. >>> max_length_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> max_length_subarray_with_k_distinct([1, 2, 3], 4) 0 >>> max_length_subarray_with_k_distinct([1, 1, 1, 1], 1) 4 >>> max_length_subarray_with_k_distinct([], 1) 0 >>> max_length_subarray_with_k_distinct([1, 2, 3], 5) 0 >>> max_length_subarray_with_k_distinct([1, 2, 3, 1, 2, 3, 4, 5], 3) 6 >>> max_length_subarray_with_k_distinct([1, 2, 1, 2, 3], 0) 0","solution":"def max_length_subarray_with_k_distinct(arr, k): from collections import defaultdict n = len(arr) if n == 0 or k == 0: return 0 left = 0 right = 0 max_length = 0 unique_count = 0 freq_map = defaultdict(int) while right < n: if freq_map[arr[right]] == 0: unique_count += 1 freq_map[arr[right]] += 1 right += 1 while unique_count > k: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: unique_count -= 1 left += 1 if unique_count == k: max_length = max(max_length, right - left) return max_length"},{"question":"def minCostToPaintHouses(costs: List[List[int]]) -> int: Given an array of costs to paint neighborhoods, calculate the minimum cost to paint all neighborhoods ensuring no two adjacent neighborhoods have the same color. >>> minCostToPaintHouses([]) 0 >>> minCostToPaintHouses([[7, 3, 8]]) 3 >>> minCostToPaintHouses([[17, 2, 17], [16, 16, 5], [14, 3, 19]]) 10 >>> minCostToPaintHouses([[5, 8, 6], [13, 15, 5]]) 10 >>> minCostToPaintHouses([[7, 6, 2], [3, 10, 1], [5, 1, 8]]) 6","solution":"def minCostToPaintHouses(costs): if not costs: return 0 n = len(costs) for i in range(1, n): costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]) costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]) costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]) return min(costs[-1])"},{"question":"def count_unique_values(arr: List[int]) -> int: Replace negative numbers in the list with their absolute values and return the count of unique values. >>> count_unique_values([1, 2, 3, 4, 5]) == 5 >>> count_unique_values([-1, -2, -3, -4, -5]) == 5 >>> count_unique_values([-1, 2, 2, -3, 3, 0]) == 4 >>> count_unique_values([-1, 1, -1, 1, 0]) == 2 >>> count_unique_values([0, 0, 0, -1, -2]) == 3 >>> count_unique_values([0, 0, 0, 0]) == 1 >>> count_unique_values([]) == 0","solution":"def count_unique_values(arr): Replace negative numbers in the list with their absolute values and return the count of unique values. modified_list = [abs(x) for x in arr] unique_values_count = len(set(modified_list)) return unique_values_count"},{"question":"def kth_smallest_element(arr1: List[int], arr2: List[int], k: int) -> int: Returns the k-th smallest element in the union of the two sorted arrays. :param arr1: List[int] - First sorted array :param arr2: List[int] - Second sorted array :param k: int - The k-th position (1-indexed) to find the smallest element :return: int - The k-th smallest element in the union of the two arrays >>> kth_smallest_element([1, 3, 5], [2, 4, 6], 1) 1 >>> kth_smallest_element([1, 3, 5], [2, 4, 6], 4) 4 >>> kth_smallest_element([], [2, 4, 6], 2) 4 >>> kth_smallest_element([1], [2, 3], 3) 3 from typing import List","solution":"def kth_smallest_element(arr1, arr2, k): Returns the k-th smallest element in the union of the two sorted arrays. len1, len2 = len(arr1), len(arr2) if len1 > len2: return kth_smallest_element(arr2, arr1, k) if len1 == 0: return arr2[k-1] if k == 1: return min(arr1[0], arr2[0]) i = min(len1, k//2) j = min(len2, k//2) if arr1[i-1] > arr2[j-1]: return kth_smallest_element(arr1, arr2[j:], k-j) else: return kth_smallest_element(arr1[i:], arr2, k-i)"},{"question":"def maxSubArraySum(nums: List[int]) -> int: Finds the sub-array with the maximum sum. Args: nums (List[int]): List of integers Returns: int: The sum of the sub-array with the maximum sum >>> maxSubArraySum([1, 2, 3, 4, 5]) 15 >>> maxSubArraySum([-1, -2, -3, -4, -5]) -1 >>> maxSubArraySum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> maxSubArraySum([5]) 5 >>> maxSubArraySum([]) 0 >>> maxSubArraySum([1000, -100, 2000, -50, 3000]) 5850 >>> maxSubArraySum([-2, 1, 2, 3, -4, 5, 6]) 13 >>> maxSubArraySum([1, 2, 3, 4, -10]) 10","solution":"def maxSubArraySum(nums): Finds the sub-array with the maximum sum. Args: nums (List[int]): List of integers Returns: int: The sum of the sub-array with the maximum sum if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_operations_to_remove_palindromic_substrings(s: str, k: int) -> int: Finds the minimum number of operations needed to remove all palindromic substrings of length k from s. Parameters: s (str): The string from which palindromic substrings are to be removed. k (int): The length of palindromic substrings to be removed. Returns: int: The minimum number of operations needed or -1 if not possible. >>> min_operations_to_remove_palindromic_substrings(\\"abacadd\\", 3) == 2 >>> min_operations_to_remove_palindromic_substrings(\\"abcdef\\", 2) == -1 >>> min_operations_to_remove_palindromic_substrings(\\"a\\", 1) == 1 >>> min_operations_to_remove_palindromic_substrings(\\"abc\\", 1) == 3 >>> min_operations_to_remove_palindromic_substrings(\\"aaaa\\", 2) == 3 >>> min_operations_to_remove_palindromic_substrings(\\"\\", 1) == 0 >>> min_operations_to_remove_palindromic_substrings(\\"abc\\", 4) == -1","solution":"def min_operations_to_remove_palindromic_substrings(s, k): Finds the minimum number of operations needed to remove all palindromic substrings of length k from s. Parameters: s (str): The string from which palindromic substrings are to be removed. k (int): The length of palindromic substrings to be removed. Returns: int: The minimum number of operations needed or -1 if not possible. if k == 1: # Each single character is a palindrome, removing 1 character at a time return len(s) def is_palindrome(sub): return sub == sub[::-1] # Count the palindromic substrings of length k palindromic_count = 0 for i in range(len(s) - k + 1): if is_palindrome(s[i:i+k]): palindromic_count += 1 return palindromic_count if palindromic_count > 0 else -1"},{"question":"from typing import List def can_make_palindrome(s: str, queries: List[List[int]]) -> List[bool]: Determines if it is possible to rearrange the substring s[left_j...right_j] such that it becomes a palindrome, with at most k_j changes to the characters in the substring. Parameters: s (str): The input string queries (List[List[int]]): Array of queries where each query is [left, right, k] Returns: List[bool]: Boolean array indicating if the substrings can be rearranged into palindromes with given changes >>> can_make_palindrome(\\"abcda\\", [[0, 4, 1]]) [True] >>> can_make_palindrome(\\"abcda\\", [[0, 4, 0]]) [False] >>> can_make_palindrome(\\"aabbcc\\", [[0, 5, 1], [0, 1, 0], [2, 3, 0], [4, 5, 0]]) [True, True, True, True] >>> can_make_palindrome(\\"abcdef\\", [[0, 5, 3], [0, 5, 2], [0, 2, 1], [1, 4, 0]]) [True, False, True, False]","solution":"def can_make_palindrome(s, queries): Determines if it's possible to rearrange substrings into a palindrome with at most k changes. Parameters: s (str): The input string queries (List[List[int]]): Array of queries where each query is [left, right, k] Returns: List[bool]: Boolean array indicating if the substrings can be rearranged into palindromes with given changes def is_possible(subs, k): # Count frequency of each character freq = [0] * 26 for char in subs: freq[ord(char) - ord('a')] += 1 # Count odd occurrences of characters odd_count = sum(1 for count in freq if count % 2 != 0) # To make a substring a palindrome, we can allow at most one character to have an odd count # For any additional odd occurrences, we need at least (odd_count // 2) changes to make pairs return odd_count // 2 <= k result = [] for left, right, k in queries: substring = s[left:right + 1] result.append(is_possible(substring, k)) return result"},{"question":"def min_possible_length(s: str) -> int: Determines the minimum possible length of the string after performing the given operations any number of times. >>> min_possible_length(\\"aaaa\\") == 4 >>> min_possible_length(\\"ababab\\") == 2 >>> min_possible_length(\\"abc\\") == 1","solution":"def min_possible_length(s): Determines the minimum possible length of the string after performing the given operations any number of times. # If all characters are same in the string, the minimum possible length is the length of the string itself. if len(set(s)) == 1: return len(s) # If there are exactly two unique characters in the string, the only way we can simplify is into a single character. if len(set(s)) == 2: return 2 # If there are three unique characters, we can reduce the string to a single character. return 1"},{"question":"def min_removals_to_make_valid(s: str) -> int: Returns the minimum number of characters to remove to make the string a **valid string** (where no two adjacent characters are the same). >>> min_removals_to_make_valid(\\"aaaa\\") 3 >>> min_removals_to_make_valid(\\"aab\\") 1 >>> min_removals_to_make_valid(\\"abc\\") 0 >>> min_removals_to_make_valid(\\"abab\\") 0 >>> min_removals_to_make_valid(\\"\\") 0 >>> min_removals_to_make_valid(\\"aaaaaa\\") 5 >>> min_removals_to_make_valid(\\"aabbcc\\") 3 >>> min_removals_to_make_valid(\\"abacadae\\") 0 >>> min_removals_to_make_valid(\\"aabbaabbaa\\") 5","solution":"def min_removals_to_make_valid(s): Returns the minimum number of characters to remove to make the string a valid string (where no two adjacent characters are the same). if not s: return 0 removals = 0 for i in range(1, len(s)): if s[i] == s[i-1]: removals += 1 return removals"},{"question":"def maximalSquare(matrix): Given a 2D matrix containing 0s and 1s, find the largest square containing only 1s and return its area. >>> grid1 = [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ] >>> maximalSquare(grid1) 4 >>> grid2 = [ ... [0, 1], ... [1, 0] ... ] >>> maximalSquare(grid2) 1 >>> grid3 = [ ... [0] ... ] >>> maximalSquare(grid3) 0 >>> grid4 = [ ... [1] ... ] >>> maximalSquare(grid4) 1 >>> grid5 = [ ... [1, 1, 0, 1], ... [1, 1, 1, 1], ... [0, 1, 1, 1], ... [1, 1, 1, 0] ... ] >>> maximalSquare(grid5) 4 >>> test_empty_grid = [ ... ] >>> maximalSquare(test_empty_grid) 0 >>> test_all_zeros = [ ... [0, 0, 0], ... [0, 0, 0] ... ] >>> maximalSquare(test_all_zeros) 0 >>> test_all_ones = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> maximalSquare(test_all_ones) 9 >>> test_single_column = [ ... [1], ... [1], ... [1], ... [1] ... ] >>> maximalSquare(test_single_column) 1","solution":"def maximalSquare(matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) max_side = 0 dp = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: # first row or first column dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"from typing import List def intersect(nums1: List[int], nums2: List[int]) -> List[int]: You are given two integer arrays \`nums1\` and \`nums2\`, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays, and you may return the result in any order. >>> sorted(intersect([1, 2, 2, 1], [2, 2])) [2, 2] >>> intersect([1, 2, 3], [4, 5, 6]) [] >>> sorted(intersect([1, 2, 3], [1, 2, 3])) [1, 2, 3] >>> intersect([], [1, 2, 3]) [] >>> intersect([1, 2, 3], []) [] >>> intersect([], []) [] >>> sorted(intersect([4, 9, 5], [9, 4, 9, 8, 4])) [4, 9] >>> intersect([1], [1]) [1] >>> intersect([1], [2]) [] >>> sorted(intersect([1, 2, 2, 1, 3, 4], [2, 2, 3])) [2, 2, 3]","solution":"from collections import Counter def intersect(nums1, nums2): Returns the intersection of two arrays where each element appears as many times as it shows in both arrays. counter1 = Counter(nums1) counter2 = Counter(nums2) intersection = [] for num in counter1: if num in counter2: intersection.extend([num]*min(counter1[num], counter2[num])) return intersection"},{"question":"def can_be_empty(s: str) -> bool: Determines if the string can be made empty by repeatedly deleting adjacent pairs of the same character. >>> can_be_empty(\\"aabccb\\") True >>> can_be_empty(\\"abccba\\") True >>> can_be_empty(\\"\\") True >>> can_be_empty(\\"aa\\") True >>> can_be_empty(\\"abc\\") False >>> can_be_empty(\\"abab\\") False >>> can_be_empty(\\"abca\\") False >>> can_be_empty(\\"aabbaabbaa\\") True >>> can_be_empty(\\"aabbccd\\") False >>> can_be_empty(\\"a\\") False >>> can_be_empty(\\"abcdefg\\") False","solution":"def can_be_empty(s): Determines if the string can be made empty by repeatedly deleting adjacent pairs of the same character. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the top element because it matches the current char else: stack.append(char) # Add the current char to stack return not stack # If stack is empty, return True; otherwise, return False"},{"question":"def topKStudents(scores: List[int], k: int) -> List[int]: Organize a competition among students and return the list of top k students based on the number of matches they've won. If there is a tie in the number of matches won, sort the students based on their original index in ascending order. >>> topKStudents([4, 3, 7, 9, 5], 2) [3, 2] >>> topKStudents([1, 2, 3, 4, 5], 3) [4, 3, 2] >>> topKStudents([5, 5, 5, 5], 2) [0, 1] >>> topKStudents([10, 20, 20, 10], 1) [1] >>> topKStudents([7, 7, 1, 7], 2) [0, 1] >>> topKStudents([1], 1) [0]","solution":"def topKStudents(scores, k): n = len(scores) wins = [0] * n # Count wins for each student for i in range(n): for j in range(i + 1, n): if scores[i] > scores[j]: wins[i] += 1 elif scores[j] > scores[i]: wins[j] += 1 # Create a list of (index, wins) tuples indexed_wins = [(i, wins[i]) for i in range(n)] # Sort the list based on the number of wins (desc) and index (asc) in case of tie indexed_wins.sort(key=lambda x: (-x[1], x[0])) # Get the top k students' indices result = [indexed_wins[i][0] for i in range(k)] return result"},{"question":"def threeSum(nums: List[int], target: int) -> bool: Determine if there exist three distinct elements in \`nums\` such that their sum is equal to \`target\`. >>> threeSum([1, 2, 3, 4, 5], 9) True >>> threeSum([1, 2, 3, 4, 5], 50) False >>> threeSum([-1, 0, 1, 2, -1, -4], 0) True >>> threeSum([1, 1, 1, 2, 2], 6) False >>> threeSum([], 0) False >>> threeSum([1], 1) False >>> threeSum([1, 2], 3) False >>> threeSum([1000000, 2000000, 3000000, -1000000, -2000000, -3000000], 0) True","solution":"def threeSum(nums, target): nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def shortest_common_supersequence_length(s1: str, s2: str) -> int: Returns the length of the shortest common supersequence of s1 and s2. >>> shortest_common_supersequence_length(\\"abc\\", \\"ac\\") 3 >>> shortest_common_supersequence_length(\\"abc\\", \\"def\\") 6 >>> shortest_common_supersequence_length(\\"\\", \\"abc\\") 3 >>> shortest_common_supersequence_length(\\"abc\\", \\"\\") 3 >>> shortest_common_supersequence_length(\\"\\", \\"\\") 0 >>> shortest_common_supersequence_length(\\"abc\\", \\"abc\\") 3 >>> shortest_common_supersequence_length(\\"geek\\", \\"eke\\") 5 >>> shortest_common_supersequence_length(\\"AGGTAB\\", \\"GXTXAYB\\") 9","solution":"def shortest_common_supersequence_length(s1, s2): Returns the length of the shortest common supersequence of s1 and s2. def lcs_length(x, y): m, n = len(x), len(y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if x[i - 1] == y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] lcs_len = lcs_length(s1, s2) return len(s1) + len(s2) - lcs_len"},{"question":"def max_difference(arr): Given an integer array \`arr\` of size \`n\`, find the maximum difference between the elements in the array such that the larger element comes after the smaller one in the array. If no such elements are present, return -1. >>> max_difference([2, 3, 10, 6, 4, 8, 1]) == 8 >>> max_difference([9, 8, 7, 6, 5, 4, 3]) == -1 >>> max_difference([1, 2]) == 1 >>> max_difference([2, 1]) == -1 >>> max_difference([1, 2, 2, 2, 2, 3]) == 2 >>> max_difference([1]) == -1 >>> max_difference([]) == -1","solution":"def max_difference(arr): Returns the maximum difference between the elements in the array such that the larger element comes after the smaller one in the array. If no such elements are present, return -1. if not arr or len(arr) < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) else: min_element = arr[i] return max_diff"},{"question":"def max_subarray_size(arr, threshold): Finds the maximum size of a contiguous subarray such that the sum of the subarray is strictly less than \`threshold\`. Returns 0 if no such subarray exists. Parameters: arr (list of int): The input array. threshold (int): The threshold value. Returns: int: The maximum size of the contiguous subarray. Examples: >>> max_subarray_size([10, 20, 30], 5) 0 >>> max_subarray_size([1,2,3,4], 3) 1 >>> max_subarray_size([1,2,3], 10) 3 >>> max_subarray_size([1, 1, 1, 1, 1], 3) 2 >>> max_subarray_size([2, 2, 2, 2], 5) 2 >>> max_subarray_size([1, -1, 2, -1, 3], 5) 5 >>> max_subarray_size([10, 20, -15, 5, 10], 10) 3 >>> max_subarray_size([], 10) 0 pass","solution":"def max_subarray_size(arr, threshold): Finds the maximum size of a contiguous subarray such that the sum of the subarray is strictly less than \`threshold\`. Returns 0 if no such subarray exists. Parameters: arr (list of int): The input array. threshold (int): The threshold value. Returns: int: The maximum size of the contiguous subarray. n = len(arr) max_size = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= threshold and start <= end: current_sum -= arr[start] start += 1 max_size = max(max_size, end - start + 1) return max_size if max_size > 0 else 0"},{"question":"def longest_ordered_unique_subsequence(s: str) -> int: Returns the length of the longest possible subsequence from \`s\` that adheres to the given rules: 1. Each character from \`s\` can appear at most once. 2. The characters must appear in non-decreasing order according to their ASCII values. >>> longest_ordered_unique_subsequence(\\"abcabc\\") 3 >>> longest_ordered_unique_subsequence(\\"aaa\\") 1 >>> longest_ordered_unique_subsequence(\\"abcd\\") 4 >>> longest_ordered_unique_subsequence(\\"badc\\") 4 >>> longest_ordered_unique_subsequence(\\"\\") 0 >>> longest_ordered_unique_subsequence(\\"a\\") 1 >>> longest_ordered_unique_subsequence(\\"bca\\") 3","solution":"def longest_ordered_unique_subsequence(s): Returns the length of the longest possible subsequence from s that adheres to the given rules: 1. Each character from \`s\` can appear at most once. 2. The characters must appear in non-decreasing order according to their ASCII values. # Create a set to keep track of added characters added_chars = set() longest_subseq_length = 0 for char in s: # Add the character to set if it has not been added before and maintain the order if char not in added_chars: longest_subseq_length += 1 added_chars.add(char) return longest_subseq_length"},{"question":"def evaluate(expression: str) -> int: Evaluate a Lisp-like expression. >>> evaluate(\\"5\\") 5 >>> evaluate(\\"(add 1 2)\\") 3 >>> evaluate(\\"(mult 3 4)\\") 12 >>> evaluate(\\"(add 1 (mult 2 3))\\") 7 >>> evaluate(\\"(let x 2 (mult x 5))\\") 10 >>> evaluate(\\"(let x 2 (add (let x 3 x) x))\\") 5 >>> evaluate(\\"(let x 2 (mult (let y 3 y) x))\\") 6 >>> evaluate(\\"(add (let x 2 (mult x 3)) (let y 4 y))\\") 10 >>> evaluate(\\"(let x 2 (let y 3 (let z (add x y) (mult z 2))))\\") 10","solution":"def evaluate(expression): def parse(tokens): token = tokens.pop(0) if token == '(': sub_expr = [] while tokens[0] != ')': sub_expr.append(parse(tokens)) tokens.pop(0) # Remove the closing ')' return sub_expr elif token.isdigit() or (token[0] == '-' and token[1:].isdigit()): return int(token) else: return token def evaluate_expression(tokens, env): if type(tokens) == int: return tokens if type(tokens) == str: return env[tokens] if tokens[0] == 'add': return sum(evaluate_expression(arg, env) for arg in tokens[1:]) elif tokens[0] == 'mult': result = 1 for arg in tokens[1:]: result *= evaluate_expression(arg, env) return result elif tokens[0] == 'let': new_env = env.copy() i = 1 while True: if type(tokens[i]) == str and i + 1 < len(tokens) and not type(tokens[i+1]) == str: new_env[tokens[i]] = evaluate_expression(tokens[i+1], new_env) i += 2 else: return evaluate_expression(tokens[i], new_env) tokens = expression.replace('(', ' ( ').replace(')', ' ) ').split() parsed_expression = parse(tokens) return evaluate_expression(parsed_expression, {}) # Example usage: # print(evaluate(\\"(add 1 2)\\")) # Output: 3 # print(evaluate(\\"(mult 3 (add 2 3))\\")) # Output: 15 # print(evaluate(\\"(let x 2 (mult x 5))\\")) # Output: 10"},{"question":"def longest_subsequence_with_target(arr: List[int], target: int) -> int: Returns the length of the longest possible subsequence such that the sum of the elements is less than or equal to target. >>> longest_subsequence_with_target([1, 2, 3, 4, 5], 10) == 4 >>> longest_subsequence_with_target([5, 5, 5, 5], 20) == 4 >>> longest_subsequence_with_target([1, 2, 3, 4, 5], 7) == 3 >>> longest_subsequence_with_target([5, 4, 3, 2, 1], 7) == 3 >>> longest_subsequence_with_target([10, 20, 30], 5) == 0 >>> longest_subsequence_with_target([8, 9, 10], 7) == 0 >>> longest_subsequence_with_target([1], 1) == 1 >>> longest_subsequence_with_target([1], 0) == 0 >>> longest_subsequence_with_target([10], 5) == 0 >>> longest_subsequence_with_target([], 10) == 0 >>> longest_subsequence_with_target([], 0) == 0","solution":"def longest_subsequence_with_target(arr, target): Returns the length of the longest possible subsequence such that the sum of the elements is less than or equal to target. arr.sort() subsequence_sum = 0 length = 0 for num in arr: if subsequence_sum + num <= target: subsequence_sum += num length += 1 else: break return length"},{"question":"def can_partition(arr: List[int], k: int) -> bool: You are given an array of integers \`arr\` and an integer \`k\`. You need to partition the array into exactly \`k\` subsets such that the sum of elements in each subset is unique. Return \`True\` if such a partition exists, otherwise return \`False\`. >>> can_partition([4, 3, 2, 3, 5, 2, 1], 4) True >>> can_partition([1, 2, 3, 4], 3) False >>> can_partition([2, 2, 2, 2], 2) True >>> can_partition([5], 1) True >>> can_partition([], 1) False >>> can_partition([100, 1000, 10000], 3) False","solution":"from itertools import combinations def subsets_with_sum(arr, k, target_sum, used): Helper function to check if there exists a subset of \`arr\` (excluding used elements) that sums up to target_sum. for i in range(len(arr)): if not used[i] and arr[i] <= target_sum: used[i] = True if target_sum - arr[i] == 0 or subsets_with_sum(arr, k, target_sum - arr[i], used): return True used[i] = False return False def can_partition(arr, k): Main function to partition the array into k subsets with unique sums. total_sum = sum(arr) if total_sum % k != 0: return False # If not divisible, cannot partition into equal subsets subset_sum = total_sum // k used = [False] * len(arr) for _ in range(k): if not subsets_with_sum(arr, k, subset_sum, used): return False return True"},{"question":"from typing import List def canSeeTeacher(heights: List[int]) -> int: Returns the number of students who can see the teacher. >>> canSeeTeacher([1, 2, 3, 4, 5]) == 5 >>> canSeeTeacher([5, 4, 3, 2, 1]) == 1 >>> canSeeTeacher([1, 3, 2, 4, 2]) == 3 >>> canSeeTeacher([5]) == 1 >>> canSeeTeacher([5, 5, 5, 5, 5]) == 1 >>> canSeeTeacher([]) == 0","solution":"def canSeeTeacher(heights): Returns the number of students who can see the teacher. count = 0 max_height = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"def reorganizeString(s: str) -> str: Reformat the string such that no two adjacent characters are the same. >>> reorganizeString(\\"aab\\") in [\\"aba\\", \\"baa\\"] True >>> reorganizeString(\\"aaab\\") '' >>> reorganizeString(\\"aaaaa\\") '' >>> reorganizeString(\\"aaabbb\\") in [\\"ababab\\", \\"bababa\\"] True >>> reorganizeString(\\"a\\") 'a' >>> reorganizeString(\\"\\") ''","solution":"from collections import Counter import heapq def reorganizeString(s): Reformats the string such that no two adjacent characters are the same. If not possible, returns an empty string. :param s: Input string :type s: str :return: Reformatted string or empty string if reformatting is not possible :rtype: str # Count frequency of each character char_counts = Counter(s) # Create a max-heap based on the frequencies max_heap = [(-count, char) for char, count in char_counts.items()] heapq.heapify(max_heap) # Previous character and its remaining count prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) # Append the current character to the result result.append(char) # If prev_count is less than 0, push the previous character back into max-heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update prev_count and prev_char for the next iteration prev_count, prev_char = count + 1, char reorganized_str = ''.join(result) # If the reorganized string is of the same length as the original string, return it if len(reorganized_str) == len(s): return reorganized_str else: return \\"\\""},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def diameter_of_binary_tree(root): This function computes the diameter of the binary tree. :param root: TreeNode root of the binary tree. :return: integer representing the diameter of the binary tree. pass Unit tests for the diameter_of_binary_tree function: def test_single_node(): root = TreeNode(1) assert diameter_of_binary_tree(root) == 0 def test_two_nodes(): root = TreeNode(1) root.left = TreeNode(2) assert diameter_of_binary_tree(root) == 1 def test_three_nodes_line(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) assert diameter_of_binary_tree(root) == 2 def test_balanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert diameter_of_binary_tree(root) == 3 def test_complex_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.right.left = TreeNode(6) root.left.right.right = TreeNode(7) assert diameter_of_binary_tree(root) == 4","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def diameter_of_binary_tree(root): This function computes the diameter of the binary tree. :param root: TreeNode root of the binary tree. :return: integer representing the diameter of the binary tree. def depth(node): nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 diameter = 0 depth(root) return diameter"},{"question":"from typing import List def longestSubsequenceWithOneDistinctCharacter(s: str, k: int) -> int: Returns the length of the longest subsequence that contains no more than one distinct character when at most k characters are removed from the string s. >>> longestSubsequenceWithOneDistinctCharacter(\\"aaaa\\", 0) 4 >>> longestSubsequenceWithOneDistinctCharacter(\\"abcd\\", 0) 1 >>> longestSubsequenceWithOneDistinctCharacter(\\"aaabbb\\", 2) 5 >>> longestSubsequenceWithOneDistinctCharacter(\\"abcde\\", 2) 3 >>> longestSubsequenceWithOneDistinctCharacter(\\"abcdef\\", 5) 6 >>> longestSubsequenceWithOneDistinctCharacter(\\"\\", 0) 0 >>> longestSubsequenceWithOneDistinctCharacter(\\"a\\", 1) 1 >>> longestSubsequenceWithOneDistinctCharacter(\\"b\\", 0) 1 pass","solution":"def longestSubsequenceWithOneDistinctCharacter(s, k): Returns the length of the longest subsequence that contains no more than one distinct character when at most k characters are removed from the string s. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Find the character with the maximum frequency after any k removals max_length = 0 for char, count in freq.items(): max_length = max(max_length, min(len(s) - k, count) + k) return max_length"},{"question":"from typing import List def find_all_reachable_start_nodes(n: int, edges: List[List[int]]) -> List[int]: Returns a list of all possible starting nodes from which all nodes in the graph are reachable. Parameters: - n (int): The number of nodes in the graph, labeled from 0 to n-1. - edges (List[List[int]]): A list of directed edges where each edge is represented as [u, v]. Returns: - List[int]: A sorted list of all possible starting nodes. Example: >>> find_all_reachable_start_nodes(6, [[0,1],[0,2],[2,3],[3,4],[3,5]]) == [0] >>> find_all_reachable_start_nodes(3, [[0,1],[2,1]]) == [] >>> find_all_reachable_start_nodes(4, [[0,1],[1,2],[1,3],[2,3],[3,0],[3,2]]) == [0, 1, 2, 3] >>> find_all_reachable_start_nodes(1, []) == [0] >>> find_all_reachable_start_nodes(5, [[0,1], [3,4]]) == []","solution":"from collections import defaultdict, deque def find_all_reachable_start_nodes(n, edges): Returns a list of all possible starting nodes from which all nodes in the graph are reachable. Parameters: - n (int): The number of nodes in the graph, labeled from 0 to n-1. - edges (List[List[int]]): A list of directed edges where each edge is represented as [u, v]. Returns: - List[int]: A sorted list of all possible starting nodes. graph = defaultdict(list) reverse_graph = defaultdict(list) # Build the graph and its reverse. for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) def bfs(start, graph): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited # Find nodes that can reach all other nodes all_reachable = set(range(n)) for node in range(n): if len(bfs(node, graph)) != n: all_reachable.discard(node) return sorted(list(all_reachable))"},{"question":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_complete_binary_tree(root): Determine if a binary tree is a complete binary tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. :param root: TreeNode, the root of the binary tree :return: boolean, True if the tree is complete, False otherwise pass # Unit Tests def test_complete_binary_tree(): # Creating a complete binary tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) assert is_complete_binary_tree(root) == True def test_non_complete_binary_tree(): # Creating a non-complete binary tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.right.left = TreeNode(5) assert is_complete_binary_tree(root) == False def test_single_node_tree(): # Creating a tree with a single node root = TreeNode(1) assert is_complete_binary_tree(root) == True def test_empty_tree(): # Empty tree assert is_complete_binary_tree(None) == True def test_with_missing_right_child(): # Creating a tree with a missing right child in the bottom-most level root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) assert is_complete_binary_tree(root) == True def test_with_non_leftmost_missing(): # Creating a tree with a non-leftmost missing node (valid complete tree) root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(7) # Left child on this level not filled first assert is_complete_binary_tree(root) == False","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_complete_binary_tree(root): This function checks if a given binary tree is a complete binary tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. :param root: TreeNode, the root of the binary tree :return: boolean, True if the tree is complete, False otherwise if not root: return True queue = deque([root]) found_null = False while queue: node = queue.popleft() if node: if found_null: return False queue.append(node.left) queue.append(node.right) else: found_null = True return True"},{"question":"def move_target_to_end(nums: List[int], target: int) -> List[int]: Move all instances of \`target\` to the end of the list in-place. The relative order of the non-target elements should be maintained. >>> move_target_to_end([1, 2, 3, 4, 2, 2, 5], 2) [1, 3, 4, 5, 2, 2, 2] >>> move_target_to_end([3, 3, 3], 3) [3, 3, 3] >>> move_target_to_end([1, 2, 3, 4], 5) [1, 2, 3, 4] >>> move_target_to_end([2, 2, 1, 3, 4], 2) [1, 3, 4, 2, 2] >>> move_target_to_end([1, 3, 4, 2, 2], 2) [1, 3, 4, 2, 2] >>> move_target_to_end([], 2) []","solution":"def move_target_to_end(nums, target): Moves all instances of target to the end of the list in-place, while maintaining the relative order of the non-target elements. i = 0 for j in range(len(nums)): if nums[j] != target: nums[i], nums[j] = nums[j], nums[i] i += 1 return nums"},{"question":"from typing import List def maxProfit(k: int, prices: List[int]) -> int: Calculates the maximum profit with at most k transactions. :param k: int, maximum number of allowed transactions :param prices: List[int], list of prices where prices[i] is the price of a item on day i :return: int, maximum profit >>> maxProfit(2, []) == 0 >>> maxProfit(0, [1, 2, 3, 4, 5]) == 0 >>> maxProfit(1, [3, 2, 6, 5, 0, 3]) == 4 >>> maxProfit(2, [3, 2, 6, 5, 0, 3]) == 7 >>> maxProfit(100, [3, 2, 6, 5, 0, 3]) == 7 >>> maxProfit(2, [5, 4, 3, 2, 1]) == 0 >>> maxProfit(2, [1, 2, 1, 2, 1]) == 2","solution":"def maxProfit(k, prices): Calculates the maximum profit with at most k transactions. :param k: int, maximum number of allowed transactions :param prices: List[int], list of prices where prices[i] is the price of a item on day i :return: int, maximum profit if not prices or k == 0: return 0 n = len(prices) if k >= n // 2: return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n)) dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[k][n - 1]"},{"question":"def remove_adjacent_duplicates(S: str) -> str: Removes all adjacent duplicates from the string S iteratively until no more adjacent duplicates exist. Parameters: S (str): The input string consisting of lowercase English letters. Returns: str: The string after removing all possible adjacent duplicates. Examples: >>> remove_adjacent_duplicates(\\"abba\\") == \\"\\" >>> remove_adjacent_duplicates(\\"abbaca\\") == \\"ca\\" >>> remove_adjacent_duplicates(\\"abc\\") == \\"abc\\" >>> remove_adjacent_duplicates(\\"aaaaaa\\") == \\"\\" >>> remove_adjacent_duplicates(\\"abccba\\") == \\"\\" >>> remove_adjacent_duplicates(\\"abcdef\\") == \\"abcdef\\" >>> remove_adjacent_duplicates(\\"\\") == \\"\\"","solution":"def remove_adjacent_duplicates(S): Removes all adjacent duplicates from the string S iteratively until no more adjacent duplicates exist. Parameters: S (str): The input string consisting of lowercase English letters. Returns: str: The string after removing all possible adjacent duplicates. stack = [] for char in S: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def character_replacement(s: str, k: int) -> int: Returns the length of the longest substring with all identical characters after exactly k replacements. >>> character_replacement(\\"ABAB\\", 2) 4 >>> character_replacement(\\"AAAA\\", 2) 4 >>> character_replacement(\\"AABABBA\\", 1) 4 >>> character_replacement(\\"ABCDE\\", 0) 1 >>> character_replacement(\\"ABCDE\\", 5) 5 >>> character_replacement(\\"\\", 2) 0 >>> character_replacement(\\"A\\", 1) 1 >>> character_replacement(\\"AAAB\\", 10) 4","solution":"def character_replacement(s, k): Returns the length of the longest substring with all identical characters after exactly k replacements. from collections import defaultdict max_len = 0 max_count = 0 left = 0 count = defaultdict(int) for right in range(len(s)): count[s[right]] += 1 max_count = max(max_count, count[s[right]]) if right - left + 1 - max_count > k: count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def findMaxConsecutiveOnes(nums: List[int]) -> int: Returns the maximum number of consecutive 1s in the array if at most one 0 can be flipped to 1. :param nums: List[int] :return: int >>> findMaxConsecutiveOnes([1, 1, 1, 1]) == 4 >>> findMaxConsecutiveOnes([1, 0, 1, 1, 0, 1, 1]) == 5 >>> findMaxConsecutiveOnes([0]) == 1 >>> findMaxConsecutiveOnes([1]) == 1 >>> findMaxConsecutiveOnes([0, 0, 0, 0]) == 1 >>> findMaxConsecutiveOnes([1, 1, 0, 1, 1]) == 5 >>> findMaxConsecutiveOnes([1, 1, 1, 0]) == 4 >>> findMaxConsecutiveOnes([0, 1, 1, 1]) == 4","solution":"def findMaxConsecutiveOnes(nums): Returns the maximum number of consecutive 1s in the array if at most one 0 can be flipped to 1. :param nums: List[int] :return: int max_count = 0 zero_flipped_index = -1 left = 0 for right in range(len(nums)): if nums[right] == 0: if zero_flipped_index != -1: left = zero_flipped_index + 1 zero_flipped_index = right max_count = max(max_count, right - left + 1) return max_count"},{"question":"def trap(heights: List[int]) -> int: Given a list of \`n\` integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. >>> trap([]) == 0 >>> trap([4]) == 0 >>> trap([1, 2]) == 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([3, 3, 3]) == 0 >>> trap([3, 0, 3]) == 3 >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([5, 4, 3, 2, 1]) == 0 >>> trap([2, 1, 2]) == 1","solution":"def trap(heights): if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"def maxRectangleArea(heights: List[int]) -> int: Calculates the maximum area of a rectangle formed by consecutive buildings. Args: heights: List[int] - A list of integers representing the heights of buildings. Returns: int - The maximum rectangular area. Examples: >>> maxRectangleArea([1, 2, 3, 4, 5]) 9 >>> maxRectangleArea([3, 3, 3, 3, 3]) 15 >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> maxRectangleArea([5]) 5 >>> maxRectangleArea([]) 0 >>> maxRectangleArea([5, 4, 3, 2, 1]) 9 >>> maxRectangleArea([2, 4, 6, 4, 2]) 12","solution":"def maxRectangleArea(heights): Calculates the maximum area of a rectangle formed by consecutive buildings. Args: heights: List[int] - A list of integers representing the heights of buildings. Returns: int - The maximum rectangular area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def shortest_length_after_operations(s: str) -> int: Returns the shortest length of the string \`s\` after performing the specified operations. >>> shortest_length_after_operations(\\"aaaaa\\") 1 >>> shortest_length_after_operations(\\"abcdef\\") 6 >>> shortest_length_after_operations(\\"abacabad\\") 4 >>> shortest_length_after_operations(\\"aabbccabca\\") 3 >>> shortest_length_after_operations(\\"\\") 0","solution":"def shortest_length_after_operations(s): Returns the shortest length of the string after performing the specified operations. The only possible substring that can be removed any number of times to potentially reduce the string to the shortest length is by removing all occurrences of the same character. Because removing any substring that has different characters will not have an optimal or single minimal effect. So the length of the shortest possible length after removing substrings will be the number of unique characters in the string. return len(set(s))"},{"question":"def num_lakes(grid): Returns the number of lakes in the given 2D grid.","solution":"def num_lakes(grid): Returns the number of lakes in the given 2D grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False]*cols for _ in range(rows)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols def dfs(x, y): if not is_valid(x, y) or visited[x][y] or grid[x][y] == 1: return visited[x][y] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: dfs(x + dx, y + dy) def is_surrounded_by_land(x, y): queue = [(x, y)] surrounded = True while queue: cx, cy = queue.pop(0) if not is_valid(cx, cy): surrounded = False continue if grid[cx][cy] == 1 or visited[cx][cy]: continue visited[cx][cy] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: queue.append((cx + dx, cy + dy)) return surrounded lakes_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 0 and not visited[i][j]: if is_surrounded_by_land(i, j): lakes_count += 1 return lakes_count"},{"question":"def calculate_average_scores(students): Calculates the overall average score for each student across three subjects and returns a list of dictionaries containing the student's name and average score, sorted in descending order of the average score. >>> students = [ >>> {\\"name\\": \\"Alice\\", \\"math\\": 90, \\"science\\": 80, \\"english\\": 85}, >>> {\\"name\\": \\"Bob\\", \\"math\\": 85, \\"science\\": 85, \\"english\\": 80}, >>> {\\"name\\": \\"Charlie\\", \\"math\\": 80, \\"science\\": 70, \\"english\\": 80}, >>> ] >>> calculate_average_scores(students) [ {\\"name\\": \\"Alice\\", \\"average\\": 85.0}, {\\"name\\": \\"Bob\\", \\"average\\": 83.33}, {\\"name\\": \\"Charlie\\", \\"average\\": 76.67} ]","solution":"def calculate_average_scores(students): Calculates the overall average score for each student across three subjects and returns a list of dictionaries containing the student's name and average score, sorted in descending order of the average score. result = [] for student in students: average_score = (student['math'] + student['science'] + student['english']) / 3 result.append({ \\"name\\": student['name'], \\"average\\": round(average_score, 2) }) result.sort(key=lambda x: (-x['average'], x['name'])) return result"},{"question":"def restore_string(s: List[str], indices: List[int]) -> str: Restores a string \`s\` according to the positions specified in the \`indices\` array. The \`indices[i]\` element represents the position where the character at the \`i\`-th position of the original string should be after the rearrangement. Parameters: s (str): The original string. indices (list of int): The positions where each character of \`s\` should go. Returns: str: The rearranged string. Examples: >>> restore_string(\\"abc\\", [2, 1, 0]) 'cba' >>> restore_string(\\"aabc\\", [3, 1, 0, 2]) 'baca' >>> restore_string(\\"abcde\\", [4, 3, 2, 1, 0]) 'edcba' >>> restore_string(\\"a\\", [0]) 'a' >>> restore_string(\\"\\", []) ''","solution":"def restore_string(s, indices): Restores a string \`s\` according to the positions specified in the \`indices\` array. Parameters: s (str): The original string. indices (list of int): The positions where each character of \`s\` should go. Returns: str: The rearranged string. result = [''] * len(s) for i, index in enumerate(indices): result[index] = s[i] return ''.join(result)"},{"question":"def min_moves_to_palindrome(s: str) -> int: Returns the minimum number of moves required to make the string a palindrome. A palindrome is a word that reads the same forward and backward. >>> min_moves_to_palindrome(\\"a\\") 0 >>> min_moves_to_palindrome(\\"aa\\") 0 >>> min_moves_to_palindrome(\\"ab\\") 1 >>> min_moves_to_palindrome(\\"aba\\") 0 >>> min_moves_to_palindrome(\\"abc\\") 1 >>> min_moves_to_palindrome(\\"abccba\\") 0 >>> min_moves_to_palindrome(\\"abcdba\\") 1 >>> min_moves_to_palindrome(\\"abcde\\") 2 >>> min_moves_to_palindrome(\\"abccba\\") 0 >>> min_moves_to_palindrome(\\"axbxcxd\\") 2","solution":"def min_moves_to_palindrome(s): Returns the minimum number of moves required to make the string a palindrome. left = 0 right = len(s) - 1 moves = 0 while left < right: if s[left] != s[right]: moves += 1 left += 1 right -= 1 return moves"},{"question":"def max_total_profit(profits, k): Returns the maximum total profit from selecting exactly k items. If it is not possible to select k items, returns 0. >>> max_total_profit([5, 1, 3, 2, 4], 3) 12 >>> max_total_profit([10, 2, 8, 6, 4], 2) 18 >>> max_total_profit([1, 2, 3, 4, 5], 5) 15 >>> max_total_profit([1, 2, 3], 5) 0 >>> max_total_profit([7], 1) 7 >>> max_total_profit([0, -1, -2, 4, 3], 3) 7 >>> max_total_profit([-1, -2, -3, -4], 2) -3 >>> max_total_profit([5, 3, 2], 0) 0","solution":"def max_total_profit(profits, k): Returns the maximum total profit from selecting exactly k items. If it is not possible to select k items, returns 0. if k > len(profits): return 0 return sum(sorted(profits, reverse=True)[:k])"},{"question":"import math from typing import List, Tuple def min_total_cable_length(points: List[Tuple[int, int]]) -> float: Returns the minimum total cable length required to connect all cities using the given points. points: List of tuples [(xi, yi), (xj, yj), ..., (xn, yn)] representing the positions of the cities. >>> min_total_cable_length([(0, 0)]) == 0 >>> min_total_cable_length([(0, 0), (3, 4)]) == 5 >>> min_total_cable_length([(0, 0), (0, 3), (4, 0)]) == 7 >>> min_total_cable_length([(0, 0), (0, 1), (1, 0), (1, 1)]) == 3 >>> math.isclose(min_total_cable_length([(0, 0), (1, 1), (2, 2)]), 2 * math.sqrt(2))","solution":"import math def min_total_cable_length(points): Returns the minimum total cable length required to connect all cities using Prim's algorithm. points: List of tuples [(xi, yi), (xj, yj), ..., (xn, yn)] representing the positions of the cities. n = len(points) if n == 0: return 0 # Initializing all distances to infinity min_edge = [float('inf')] * n visited = [False] * n min_edge[0] = 0 total_length = 0 for _ in range(n): # Find the minimum edge min_distance = float('inf') min_idx = -1 for i in range(n): if not visited[i] and min_edge[i] < min_distance: min_distance = min_edge[i] min_idx = i # Add the cost of this minimum edge to the total length total_length += min_distance visited[min_idx] = True # Update the cost of connecting the current point to the remaining points for j in range(n): if not visited[j]: distance = math.sqrt((points[min_idx][0] - points[j][0])**2 + (points[min_idx][1] - points[j][1])**2) if distance < min_edge[j]: min_edge[j] = distance return total_length"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: Reverse the nodes of the list \`k\` at a time and return the modified list. >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> result = reverseKGroup(head, 2) >>> linkedlist_to_list(result) [2, 1, 4, 3, 5] >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> result = reverseKGroup(head, 3) >>> linkedlist_to_list(result) [3, 2, 1, 4, 5] >>> head = list_to_linkedlist([1, 2]) >>> result = reverseKGroup(head, 2) >>> linkedlist_to_list(result) [2, 1] >>> head = list_to_linkedlist([1, 2, 3]) >>> result = reverseKGroup(head, 1) >>> linkedlist_to_list(result) [1, 2, 3] >>> head = list_to_linkedlist([1]) >>> result = reverseKGroup(head, 2) >>> linkedlist_to_list(result) [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head ptr = head count = 0 while ptr and count < k: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"def longest_k_alternating_subarray(arr, k): Returns the length of the longest k-alternating subarray. >>> longest_k_alternating_subarray([1, 1, 1, 1, 1], 1) 1 >>> longest_k_alternating_subarray([1, 2, 3, 4, 5], 6) 0 >>> longest_k_alternating_subarray([1, 2, 1, 2, 1], 5) 5 >>> longest_k_alternating_subarray([1, 2, 2, 1, 1, 2, 2], 2) 2 >>> longest_k_alternating_subarray([], 1) 0 >>> longest_k_alternating_subarray([1, 1, 1, 1], 2) 0","solution":"def longest_k_alternating_subarray(arr, k): Returns the length of the longest k-alternating subarray. if not arr or k <= 0: return 0 max_length = 0 current_length = 1 n = len(arr) for i in range(1, n): if arr[i] != arr[i - 1]: current_length += 1 else: current_length = 1 if current_length > max_length: max_length = current_length return max_length if max_length >= k else 0"},{"question":"def is_water_reachable(grid: List[List[int]], K: int) -> bool: Determines if there exists at least one water cell (0) that is reachable from a land cell (1) within K steps. :param grid: List[List[int]] - 2D grid representing the map of the city :param K: int - Maximum number of steps a person can traverse from land to water :return: bool - True if there exists at least one reachable water cell within K steps, otherwise False >>> is_water_reachable([ [1, 1], [1, 1] ], 1) == False >>> is_water_reachable([ [0, 0], [0, 0] ], 1) == False >>> is_water_reachable([ [1, 0], [0, 0], [0, 1] ], 1) == True >>> is_water_reachable([ [1, 0], [0, 0], [0, 1] ], 0) == False >>> is_water_reachable([ [1, 1, 1, 1], [1, 0, 1, 1] ], 3) == True >>> is_water_reachable([ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ], 1) == False","solution":"def is_water_reachable(grid, K): Determines if there exists at least one water cell (0) that is reachable from a land cell (1) within K steps. :param grid: List[List[int]] - 2D grid representing the map of the city :param K: int - Maximum number of steps a person can traverse from land to water :return: bool - True if there exists at least one reachable water cell within K steps, otherwise False m, n = len(grid), len(grid[0]) # Direction vectors for moving in four possible directions (up, down, left, right) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] from collections import deque queue = deque() # Finding all land cells to start BFS from for i in range(m): for j in range(n): if grid[i][j] == 1: queue.append((i, j, 0)) # Starting point with initial distance 0 while queue: x, y, dist = queue.popleft() if dist > K: continue for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == 0 and dist + 1 <= K: return True if grid[nx][ny] == 1: queue.append((nx, ny, dist + 1)) return False"},{"question":"def count_elements_with_greater_right(arr): Count elements in the array that have at least one strictly greater element on their right side. Parameters: arr (list): A list of integers. Returns: int: The count of such elements. >>> count_elements_with_greater_right([5, 2, 6, 1, 4]) == 3 >>> count_elements_with_greater_right([2, 2, 2, 2, 2]) == 0 >>> count_elements_with_greater_right([1, 2, 3, 4, 5]) == 4 >>> count_elements_with_greater_right([5]) == 0 >>> count_elements_with_greater_right([5, 4, 3, 2, 1]) == 0 >>> count_elements_with_greater_right([4, 1, 2, 3, 5]) == 4 >>> count_elements_with_greater_right([]) == 0","solution":"def count_elements_with_greater_right(arr): Count elements in the array that have at least one strictly greater element on their right side. Parameters: arr (list): A list of integers. Returns: int: The count of such elements. n = len(arr) if n == 0: return 0 max_right = arr[-1] count = 0 # Traverse the array from the second last element to the first. for i in range(n-2, -1, -1): if arr[i] < max_right: count += 1 else: max_right = arr[i] return count"},{"question":"def min_penalty(heights: List[int]) -> int: Determine the minimum penalty possible after painting all the buildings. Each building can either be painted with one of two colors: Red or Blue. If two neighboring buildings are painted with the same color, there is a penalty equal to the absolute difference of their heights. :param heights: List of integers representing the heights of the buildings. :return: Integer, the minimum penalty possible. >>> min_penalty([]) == 0 >>> min_penalty([10]) == 0 >>> min_penalty([5, 10]) == 0 >>> min_penalty([10, 10]) == 0 >>> min_penalty([5, 1, 6, 8]) == 0 >>> min_penalty([1, 2, 1, 2, 1]) == 0","solution":"def min_penalty(heights): This function calculates the minimum penalty possible for painting buildings represented by their heights. :param heights: A list of integers representing the heights of the buildings. :return: An integer, the minimum penalty possible. n = len(heights) if n == 0: return 0 # Initialize the penalties for the last building - no penalty if it's the only one red_penalty = 0 blue_penalty = 0 for i in range(1, n): # Calculate new penalties if the current building is painted red or blue new_red_penalty = min( # Paint previous building blue, current building red blue_penalty, # Paint previous building red, current building red (add the penalty) red_penalty + abs(heights[i] - heights[i - 1]) ) new_blue_penalty = min( # Paint previous building red, current building blue red_penalty, # Paint previous building blue, current building blue (add the penalty) blue_penalty + abs(heights[i] - heights[i - 1]) ) # Update penalties for the next iteration red_penalty = new_red_penalty blue_penalty = new_blue_penalty # Return the minimum penalty of the last building being painted either color return min(red_penalty, blue_penalty)"},{"question":"def maximize_sum(nums: List[int], k: int) -> int: Maximizes the sum of the array after performing k operations where each operation decreases any element's value by 1. >>> maximize_sum([4, 3, 2], 1) 8 >>> maximize_sum([5, 5, 5], 3) 12 >>> maximize_sum([10], 5) 5 >>> maximize_sum([1, 2, 3], 10) -4 >>> maximize_sum([7, 8, 9], 0) 24","solution":"def maximize_sum(nums, k): Maximizes the sum of the array after performing k operations where each operation decreases any element's value by 1. # Finding the smallest element in the array min_num = min(nums) # Calculating the maximum sum after k operations max_sum = sum(nums) - k return max_sum"},{"question":"def count_divisibles(arr, queries): For each query in queries, return the number of elements in the subarray arr[l:r+1] that are divisible by k. Parameters: arr (list of int): The main array of integers. queries (list of list of int): A list of queries where each query is a list [l, r, k]. Returns: list of int: The results for each query. >>> count_divisibles([1, 2, 3, 4, 5, 6], [[0, 5, 2]]) [3] >>> count_divisibles([1, 2, 3, 4, 5, 6], [[0, 2, 1], [1, 4, 2], [3, 5, 3]]) [3, 2, 1] >>> count_divisibles([1, 3, 5, 7], [[0, 3, 2]]) [0] >>> count_divisibles([6, 12, 18, 24, 30], [[0, 4, 6]]) [5] >>> count_divisibles([8], [[0, 0, 4]]) [1] >>> count_divisibles([7], [[0, 0, 2]]) [0] >>> count_divisibles([], [[0, 0, 1]]) [0]","solution":"def count_divisibles(arr, queries): For each query in queries, return the number of elements in the subarray arr[l:r+1] that are divisible by k. Parameters: arr (list of int): The main array of integers. queries (list of list of int): A list of queries where each query is a list [l, r, k]. Returns: list of int: The results for each query. results = [] for l, r, k in queries: count = sum(1 for x in arr[l:r+1] if x % k == 0) results.append(count) return results"},{"question":"def min_palindrome_groups(s: str) -> int: Returns the minimum number of groups needed to partition \`s\` such that each group is a palindrome. >>> min_palindrome_groups(\\"aab\\") 2 >>> min_palindrome_groups(\\"abcba\\") 1 >>> min_palindrome_groups(\\"aa\\") 1 >>> min_palindrome_groups(\\"abccba\\") 1 >>> min_palindrome_groups(\\"abcdef\\") 6 >>> min_palindrome_groups(\\"abba\\") 1 >>> min_palindrome_groups(\\"\\") 0 >>> min_palindrome_groups(\\"a\\") 1 >>> min_palindrome_groups(\\"aaaaaa\\") 1 >>> min_palindrome_groups(\\"abcdefgh\\") 8","solution":"def min_palindrome_groups(s): Returns the minimum number of groups needed to partition \`s\` such that each group is a palindrome. n = len(s) if n == 0: return 0 # Create a table to store results of subproblems dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Fill the table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1] cuts = [0] * n for i in range(n): if dp[0][i]: cuts[i] = 0 else: cuts[i] = float('inf') for j in range(i): if dp[j + 1][i] and (1 + cuts[j] < cuts[i]): cuts[i] = 1 + cuts[j] return cuts[-1] + 1"},{"question":"def reverse_words(s: str) -> str: Takes a string \`s\` consisting of words and returns the string with the words reversed. Leading and trailing spaces are removed, and words are separated by a single space. >>> reverse_words(\\"hello\\") == \\"hello\\" >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\" hello world \\") == \\"world hello\\" >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\" \\") == \\"\\" >>> reverse_words(\\"hello, world!\\") == \\"world! hello,\\" >>> reverse_words(\\"Hello World\\") == \\"World Hello\\" >>> reverse_words(\\"the quick brown fox jumps over the lazy dog\\") == \\"dog lazy the over jumps fox brown quick the\\"","solution":"def reverse_words(s): Takes a string \`s\` consisting of words and returns the string with the words reversed. Leading and trailing spaces are removed, and words are separated by a single space. # Split the string into words while removing extra spaces words_list = s.split() # Reverse the list of words reversed_words_list = words_list[::-1] # Join the reversed words list into a single string with single spaces in between reversed_string = ' '.join(reversed_words_list) return reversed_string"},{"question":"def can_form(word, words_set, memo): Helper function to check if a word can be formed by concatenating other words. pass def longest_concatenated_word(words): Write a function that takes an array of strings \`words\`, and returns the longest word in \`words\` that can be constructed by concatenating other words from the array. If there is a tie for the longest word, return the word that came first in the original array. If no such word exists, return an empty string. * The given array \`words\` will not contain duplicates. * Each string in \`words\` can be composed of lowercase English letters only. >>> longest_concatenated_word([\\"cat\\", \\"dog\\", \\"catdog\\"]) == \\"catdog\\" >>> longest_concatenated_word([\\"cat\\", \\"dog\\", \\"catdog\\", \\"catdogcat\\"]) == \\"catdogcat\\" >>> longest_concatenated_word([\\"cat\\", \\"dog\\", \\"mouse\\"]) == \\"\\" >>> longest_concatenated_word([\\"cat\\", \\"dog\\", \\"catdog\\", \\"dogcat\\"]) == \\"catdog\\" >>> longest_concatenated_word([]) == \\"\\" >>> longest_concatenated_word([\\"word\\"]) == \\"\\" >>> longest_concatenated_word([\\"rat\\", \\"cat\\", \\"cats\\", \\"dog\\", \\"catsdog\\", \\"dogcats\\", \\"ratcatdog\\"]) == \\"ratcatdog\\" pass","solution":"def can_form(word, words_set, memo): if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in words_set and (suffix in words_set or can_form(suffix, words_set, memo)): memo[word] = True return True memo[word] = False return False def longest_concatenated_word(words): words_set = set(words) memo = {} longest_word = \\"\\" for word in words: if can_form(word, words_set, memo) and len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"import math import itertools from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False pass def has_prime_pair(arr: List[int]) -> bool: Determine if there exists a pair of indices (i, j) such that arr[i] + arr[j] is a prime number. >>> has_prime_pair([1, 4, 6, 7]) True >>> has_prime_pair([8, 11, 13, 17]) True >>> has_prime_pair([4, 6, 8, 10]) False >>> has_prime_pair([12, 14, 16, 18]) False >>> has_prime_pair([5]) False >>> has_prime_pair([]) False pass def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(18) == False def test_has_prime_pair_exists(): assert has_prime_pair([1, 4, 6, 7]) == True # (1, 6) = 7 which is prime assert has_prime_pair([8, 11, 13, 17]) == True # (8, 11) = 19 which is prime def test_has_prime_pair_not_exists(): assert has_prime_pair([4, 6, 8, 10]) == False # No pair sums up to a prime number assert has_prime_pair([12, 14, 16, 18]) == False # No pair sums up to a prime number def test_has_prime_pair_single_element(): assert has_prime_pair([5]) == False # Only one element, no pairs def test_has_prime_pair_empty(): assert has_prime_pair([]) == False # Empty list, no pairs","solution":"import itertools import math def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False for i in range(2, int(math.sqrt(n)) + 1): if n % i == 0: return False return True def has_prime_pair(arr): Determine if there exists a pair of indices (i, j) such that arr[i] + arr[j] is a prime number. for i, j in itertools.combinations(range(len(arr)), 2): if is_prime(arr[i] + arr[j]): return True return False"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring contained in s. >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"abba\\") == \\"abba\\" >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"abcde\\") == \\"a\\" >>> longest_palindromic_substring(\\"babad\\") == \\"bab\\" or longest_palindromic_substring(\\"babad\\") == \\"aba\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") == \\"aba\\" >>> longest_palindromic_substring(\\"madam\\") == \\"madam\\" >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") == \\"geeksskeeg\\" >>> longest_palindromic_substring(\\"\\") == \\"\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring contained in s. n = len(s) if n == 0: return \\"\\" # Initialize to check for single character palindromes longest_start = 0 longest_length = 1 # Create a n x n table to store palindrome status dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for a pair of consecutive characters for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True longest_start = i longest_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True longest_start = i longest_length = length return s[longest_start:longest_start + longest_length]"},{"question":"from typing import List def max_jumps(arr: List[int], d: int) -> int: You are given an integer array \`arr\` and an integer \`d\`. A game starts at index \`i\` and ends when you cannot move any further. From index \`i\`, you can jump to any index \`j\` where \`i < j <= i + d\` if \`arr[i] > arr[j]\`, or you can jump to any index \`j\` where \`i > j >= i - d\` if \`arr[i] > arr[j]\`. You cannot jump outside the boundaries of the array. Your goal is to determine the maximum number of indices you can visit starting from any index in the \`arr\`. Return the maximum number of jumps you can achieve in the game. >>> max_jumps([6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2) 4 >>> max_jumps([3, 3, 3, 3, 3], 3) 1 >>> max_jumps([7, 6, 5, 4, 3, 2, 1], 1) 7 >>> max_jumps([7, 1, 7, 1, 7, 1], 2) 2 >>> max_jumps([66], 1) 1","solution":"def max_jumps(arr, d): n = len(arr) memo = [-1] * n def dfs(i): if memo[i] != -1: return memo[i] max_step = 1 # We can always stay at the current index for j in range(i + 1, min(n, i + d + 1)): if arr[i] > arr[j]: max_step = max(max_step, 1 + dfs(j)) else: break # As soon as we find a j where arr[i] <= arr[j], no need to continue right for j in range(i - 1, max(-1, i - d - 1), -1): if arr[i] > arr[j]: max_step = max(max_step, 1 + dfs(j)) else: break # As soon as we find a j where arr[i] <= arr[j], no need to continue left memo[i] = max_step return max_step return max(dfs(i) for i in range(n))"},{"question":"class Person: def __init__(self, id, height): self.id = id self.height = height def rearrange_people(people): Rearranges the list of \`Person\` objects such that each person is standing in front of people shorter than themselves. If multiple people have the same height, they should be ordered by their \`id\` in ascending order. Args: - people (list of Person): List of \`Person\` objects to be rearranged. Returns: - list of Person: The rearranged list of \`Person\` objects. from solution import Person, rearrange_people def test_rearrange_simple_case(): p1 = Person(1, 160) p2 = Person(2, 165) p3 = Person(3, 158) people = [p1, p2, p3] result = rearrange_people(people) assert result == [p2, p1, p3] def test_rearrange_with_tie_in_height(): p1 = Person(2, 160) p2 = Person(1, 160) p3 = Person(3, 158) people = [p1, p2, p3] result = rearrange_people(people) assert result == [p2, p1, p3] # p1 and p2 have the same height, but p2 < p1 in id def test_rearrange_with_multiple_people_same_height(): p1 = Person(2, 160) p2 = Person(1, 160) p3 = Person(4, 160) p4 = Person(3, 158) people = [p1, p2, p3, p4] result = rearrange_people(people) assert result == [p2, p1, p3, p4] # All 160 people are sorted by id def test_rearrange_all_same_height(): p1 = Person(3, 160) p2 = Person(1, 160) p3 = Person(2, 160) people = [p1, p2, p3] result = rearrange_people(people) assert result == [p2, p3, p1] # All people are the same height, order by id def test_rearrange_empty_list(): people = [] result = rearrange_people(people) assert result == []","solution":"class Person: def __init__(self, id, height): self.id = id self.height = height def rearrange_people(people): Rearranges the list of \`Person\` objects such that each person is standing in front of people shorter than themselves. If multiple people have the same height, they should be ordered by their \`id\` in ascending order. Args: - people (list of Person): List of \`Person\` objects to be rearranged. Returns: - list of Person: The rearranged list of \`Person\` objects. # Sort by height in descending order, and by id in ascending order if heights are equal return sorted(people, key=lambda x: (-x.height, x.id))"},{"question":"from typing import List def maxBuildingsSeen(buildings: List[int]) -> int: Returns the maximum number of buildings that can be seen when looking from the left side. >>> maxBuildingsSeen([1, 3, 2, 5, 4, 6]) 4 >>> maxBuildingsSeen([3, 3, 3, 3, 3]) 1 >>> maxBuildingsSeen([0, 3, 0, 4, 0, 5]) 3 >>> maxBuildingsSeen([]) 0 >>> maxBuildingsSeen([5, 4, 3, 2, 1]) 1 >>> maxBuildingsSeen([1, 2, 3, 4, 5]) 5 >>> maxBuildingsSeen([10]) 1 >>> maxBuildingsSeen([1, 2, 0, 3, 0, 4, 0, 5]) 5","solution":"def maxBuildingsSeen(buildings): Returns the maximum number of buildings that can be seen when looking from the left side. max_seen = 0 current_max_height = 0 for height in buildings: if height > current_max_height: max_seen += 1 current_max_height = height return max_seen"},{"question":"def largest_island(grid: List[List[int]]) -> int: You are given a \`m x n\` binary grid \`grid\` representing a map of \`1\`s (land) and \`0\`s (water). An **island** is a maximal 4-directionally connected group of \`1\`s. You may remove up to one \`1\` from the grid to form exactly one larger island. Return the size of the largest possible island in the grid after removing one \`1\`. If no such removal can make a larger island, return the size of the original largest island. >>> largest_island([ ... [1, 0], ... [0, 1] ... ]) == 3 >>> largest_island([ ... [1, 1], ... [1, 0] ... ]) == 4 >>> largest_island([ ... [1, 1], ... [1, 1] ... ]) == 4 >>> largest_island([ ... [0, 0], ... [0, 0] ... ]) == 0 >>> largest_island([ ... [0, 1], ... [1, 1] ... ]) == 4","solution":"def largest_island(grid): from collections import deque def bfs(x, y, index): queue = deque([(x, y)]) grid[x][y] = index size = 0 while queue: cx, cy = queue.popleft() size += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: grid[nx][ny] = index queue.append((nx, ny)) return size def get_neighbors(x, y): neighbors = set() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): neighbors.add(grid[nx][ny]) return neighbors index = 2 island_sizes = {} for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: size = bfs(i, j, index) island_sizes[index] = size index += 1 max_island = max(island_sizes.values(), default=0) result = max_island for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0: neighbors = get_neighbors(i, j) combined_size = 1 for n in neighbors: if n > 1: combined_size += island_sizes[n] result = max(result, combined_size) if result == 1: return max_island return result"},{"question":"def find_max_length_equal_subarray(nums: List[int]) -> int: Given an integer array nums representing a list of integers, return the maximum length of a subarray which has all elements equal. >>> find_max_length_equal_subarray([1, 1, 1, 1, 1]) 5 >>> find_max_length_equal_subarray([3, 1, 2, 3, 4]) 1 >>> find_max_length_equal_subarray([7]) 1 >>> find_max_length_equal_subarray([4, 4, 5, 5, 5, 2, 2, 3, 3, 3, 3]) 4 >>> find_max_length_equal_subarray([]) 0","solution":"def find_max_length_equal_subarray(nums): if not nums: return 0 max_length = current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def smallest_string_after_reversals(s: str, n: int) -> str: Returns the lexicographically smallest string obtainable by applying the reverse operation exactly n times. >>> smallest_string_after_reversals(\\"abc\\", 0) 'abc' >>> smallest_string_after_reversals(\\"cbade\\", 1) 'abcde' >>> smallest_string_after_reversals(\\"edcba\\", 1) 'abcde' >>> smallest_string_after_reversals(\\"a\\", 1) 'a' >>> smallest_string_after_reversals(\\"cab\\", 2) 'abc' >>> smallest_string_after_reversals(\\"dcba\\", 2) 'abcd' >>> smallest_string_after_reversals(\\"abcd\\", 2) 'abcd' >>> smallest_string_after_reversals(\\"\\", 1) '' >>> smallest_string_after_reversals(\\"z\\", 3) 'z' >>> smallest_string_after_reversals(\\"ba\\", 2) 'ab' >>> smallest_string_after_reversals(\\"azbxcy\\", 5) 'abcxyz'","solution":"def smallest_string_after_reversals(s, n): Returns the lexicographically smallest string obtainable by applying the reverse operation exactly n times. if n == 0: return s elif n == 1: # Find the smallest lexicographical order by reversing substrings result = s for k in range(len(s)): reversed_substring = s[:k+1][::-1] + s[k+1:] if reversed_substring < result: result = reversed_substring return result else: # When n >= 2, we can always achieve the fully sorted string return \\"\\".join(sorted(s))"},{"question":"def count_pairs(nums, target): Count the number of pairs (i, j) such that nums[i] + nums[j] == target and i < j. >>> count_pairs([1, 2, 3, 4, 3], 6) 2 >>> count_pairs([1, 2, 3, 4], 10) 0 >>> count_pairs([1, 1, 1, 1], 2) 6 >>> count_pairs([1], 1) 0 >>> count_pairs([], 0) 0 >>> count_pairs([-1, -2, -3, 0, 1, 2], 0) 2 >>> count_pairs([-2, -2, 2, 2], 0) 4","solution":"def count_pairs(nums, target): Count the number of pairs (i, j) such that nums[i] + nums[j] == target and i < j. count = 0 num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: count += num_dict[complement] if num in num_dict: num_dict[num] += 1 else: num_dict[num] = 1 return count"},{"question":"def can_transform(s1: str, s2: str) -> bool: Determines if s2 can be transformed into s1 by rearranging its characters. >>> can_transform(\\"listen\\", \\"silent\\") True >>> can_transform(\\"hello\\", \\"billion\\") False >>> can_transform(\\"\\", \\"\\") True >>> can_transform(\\"abc\\", \\"abc\\") True >>> can_transform(\\"abcd\\", \\"abc\\") False >>> can_transform(\\"@# !\\", \\"!@ #\\") True >>> can_transform(\\"12345\\", \\"54321\\") True","solution":"def can_transform(s1, s2): Determines if s2 can be transformed into s1 by rearranging its characters. return sorted(s1) == sorted(s2)"},{"question":"def count_sub_islands(grid1: List[List[int]], grid2: List[List[int]]) -> int: Returns the number of sub-islands in grid2 that are also islands in grid1. >>> grid1 = [ ... [1, 1, 1, 0], ... [0, 1, 1, 1], ... [0, 0, 0, 1] ... ] >>> grid2 = [ ... [1, 1, 1, 0], ... [0, 1, 0, 1], ... [1, 0, 0, 1] ... ] >>> count_sub_islands(grid1, grid2) 2 >>> grid1 = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> grid2 = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> count_sub_islands(grid1, grid2) 0 >>> grid1 = [ ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> grid2 = [ ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> count_sub_islands(grid1, grid2) 1 >>> grid1 = [ ... [1, 1, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 0] ... ] >>> grid2 = [ ... [1, 1, 1, 0], ... [0, 1, 1, 0], ... [1, 1, 0, 0] ... ] >>> count_sub_islands(grid1, grid2) 0 >>> grid1 = [ ... [1, 1, 1, 1], ... [1, 1, 0, 0], ... [1, 1, 0, 0], ... [0, 0, 0, 0] ... ] >>> grid2 = [ ... [1, 1, 1, 1], ... [1, 1, 0, 0], ... [1, 0, 0, 0], ... [0, 0, 1, 1] ... ] >>> count_sub_islands(grid1, grid2) 1","solution":"def count_sub_islands(grid1, grid2): Returns the number of sub-islands in grid2 that are also islands in grid1. def dfs(grid, x, y, visited): stack = [(x, y)] cells = [] while stack: cx, cy = stack.pop() if (cx, cy) in visited: continue visited.add((cx, cy)) cells.append((cx, cy)) for nx, ny in [(cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)]: if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1 and (nx, ny) not in visited: stack.append((nx, ny)) return cells m, n = len(grid1), len(grid1[0]) visited2 = set() sub_islands_count = 0 for i in range(m): for j in range(n): if grid2[i][j] == 1 and (i, j) not in visited2: sub_island_cells = dfs(grid2, i, j, visited2) if all(grid1[x][y] == 1 for x, y in sub_island_cells): sub_islands_count += 1 return sub_islands_count"},{"question":"def remove_k_length_substring(s: str, k: int) -> str: Removes the first k-length substring where all characters are the same. Parameters: s (str): The input string consisting of lower case English letters. k (int): The length of the substring to remove. Returns: str: The modified string after the removal of the first valid k-length substring. >>> remove_k_length_substring(\\"aaabbbcccc\\", 3) 'bbbcccc' >>> remove_k_length_substring(\\"abcd\\", 2) 'abcd' >>> remove_k_length_substring(\\"aaaaa\\", 3) 'aa' >>> remove_k_length_substring(\\"aabbaa\\", 2) 'bbaa' >>> remove_k_length_substring(\\"abcdefg\\", 1) 'bcdefg' >>> remove_k_length_substring(\\"abcdef\\", 3) 'abcdef' >>> remove_k_length_substring(\\"aaabaaa\\", 3) 'baaa'","solution":"def remove_k_length_substring(s, k): Removes the first k-length substring where all characters are the same. Parameters: s (str): The input string consisting of lower case English letters. k (int): The length of the substring to remove. Returns: str: The modified string after the removal of the first valid k-length substring. n = len(s) for i in range(n - k + 1): if s[i:i+k] == s[i] * k: return s[:i] + s[i+k:] return s"},{"question":"from typing import List def min_path_length(grid: List[List[int]]) -> int: Returns the minimum path length to reach the bottom-right corner of the grid from the top-left corner. If no such path exists, returns -1. >>> min_path_length([[1, 1, 1], [2, 2, 1], [3, 3, 1]]) 5 >>> min_path_length([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -1 >>> min_path_length([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> min_path_length([[9, 3, 7], [5, 8, 4], [6, 2, 1]]) -1 >>> min_path_length([[3]]) 1 >>> min_path_length([[4, 3, 2, 1], [5, 6, 7, 0], [6, 7, 8, 9]]) -1 >>> min_path_length([[1, 1, 1, 1]]) 4 >>> min_path_length([[1], [1], [1], [1]]) 4","solution":"from collections import deque def min_path_length(grid): Returns the minimum path length to reach the bottom-right corner of the grid from the top-left corner. If no such path exists, returns -1. if not grid or not grid[0]: return -1 n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == m - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] <= grid[x][y]: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def heightMovement(heights: List[int]) -> int: Returns the minimum number of movements needed to achieve a non-decreasing height arrangement. >>> heightMovement([1, 2, 3, 4]) == 0 >>> heightMovement([4, 3, 2, 1]) == 2 >>> heightMovement([1, 3, 2, 4]) == 1 >>> heightMovement([2, 2, 2, 2]) == 0 >>> heightMovement([1]) == 0 >>> heightMovement([3, 1]) == 1","solution":"def heightMovement(heights): Returns the minimum number of movements needed to achieve a non-decreasing height arrangement. sorted_heights = sorted(heights) movements = 0 for original, sorted_h in zip(heights, sorted_heights): if original != sorted_h: movements += 1 return movements // 2 # Each mismatch involves two students, so divide by 2"},{"question":"def longest_consecutive_ones(nums: List[int]) -> int: Returns the length of the longest consecutive 1s in the array that can be achieved by performing at most one operation to flip one 0 to 1. Examples: >>> longest_consecutive_ones([1, 1, 0, 1, 1, 1]) 6 >>> longest_consecutive_ones([0, 1, 0, 1]) 3 >>> longest_consecutive_ones([1, 0, 1, 0, 1]) 3 >>> longest_consecutive_ones([1, 1, 1, 1, 1, 1]) 6 >>> longest_consecutive_ones([0, 0, 0, 0, 0]) 1 >>> longest_consecutive_ones([1, 0, 1]) 3 >>> longest_consecutive_ones([]) 0 >>> longest_consecutive_ones([0]) 1 >>> longest_consecutive_ones([1]) 1 >>> longest_consecutive_ones([1, 0, 1, 1, 0, 1, 1, 1, 0, 1]) 6","solution":"def longest_consecutive_ones(nums): Returns the length of the longest consecutive 1s in the array that can be achieved by performing at most one operation to flip one 0 to 1. max_consecutive = 0 num_zeros = 0 left = 0 for right in range(len(nums)): if nums[right] == 0: num_zeros += 1 while num_zeros > 1: if nums[left] == 0: num_zeros -= 1 left += 1 max_consecutive = max(max_consecutive, right - left + 1) return max_consecutive"},{"question":"def min_operations_to_k_repeated_substrings(s: str, k: int) -> int: Returns the minimum number of operations needed to make the string s contain exactly k identical consecutive substrings of itself. >>> min_operations_to_k_repeated_substrings(\\"a\\", 1) == 0 >>> min_operations_to_k_repeated_substrings(\\"abc\\", 3) == 6 >>> min_operations_to_k_repeated_substrings(\\"abab\\", 2) == 2 >>> min_operations_to_k_repeated_substrings(\\"abcabc\\", 2) == 3 >>> min_operations_to_k_repeated_substrings(\\"xyz\\", 1) == 0","solution":"def min_operations_to_k_repeated_substrings(s, k): Returns the minimum number of operations needed to make the string s contain exactly k identical consecutive substrings of itself. n = len(s) max_len = 0 # Find the length of the longest prefix of s which is also a suffix for i in range(1, n): if s[:i] == s[-i:]: max_len = i # Calculate the length of additional string required additional_length = n - max_len # Number of operations required is the additional_length multiplied by (k-1) since we already have the first substring return additional_length * (k - 1)"},{"question":"def find_radius(nums: List[int]) -> int: Returns the minimum heating radius needed to cover all houses. Parameters: nums (list of int): The positions of houses along a street. Returns: int: The minimum heating radius. >>> find_radius([1, 2, 3, 4, 5]) 1 >>> find_radius([1, 5, 10]) 3 >>> find_radius([1, 2, 3, 5, 9]) 2 >>> find_radius([5]) 0 >>> find_radius([2, 2, 2, 2]) 0 >>> find_radius([3, 3, 3]) 0 >>> find_radius([]) 0 >>> find_radius([1, 100]) 50 >>> find_radius([1, 100, 200]) 50","solution":"def find_radius(nums): Returns the minimum heating radius needed to cover all houses. Parameters: nums (list of int): The positions of houses along a street. Returns: int: The minimum heating radius. if not nums: return 0 nums.sort() max_gap = 0 for i in range(1, len(nums)): max_gap = max(max_gap, nums[i] - nums[i-1]) return (max_gap + 1) // 2"},{"question":"from collections import deque def split_network(n: int, connections: List[List[int]]) -> int: Determines the number of ways to split the network into two groups such that nodes in the same group do not have the same level. >>> split_network(4, [[0, 1], [1, 2], [1, 3]]) == 2 >>> split_network(1, []) == 2 >>> split_network(3, [[0, 1], [1, 2], [2, 0]]) == -1 >>> split_network(5, [[0, 1], [1, 2], [2, 3], [3, 4]]) == 2 >>> split_network(6, [[0, 1], [0, 2], [3, 4], [3, 5]]) == 2 >>> split_network(2, [[0, 1]]) == 2 >>> split_network(4, [[0, 1], [1, 2], [2, 3], [3, 0]]) == 2 >>> split_network(7, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]) == 2","solution":"from collections import deque def split_network(n, connections): Determines the number of ways to split the network into two groups such that nodes in the same group do not have the same level. Returns: - An integer representing the number of ways to split the network into two groups or -1 if impossible. # Create the adjacency list for the graph graph = {i: [] for i in range(n)} for u, v in connections: graph[u].append(v) graph[v].append(u) # BFS to calculate the levels of each node from node 0 levels = [-1] * n levels[0] = 0 queue = deque([0]) while queue: node = queue.popleft() current_level = levels[node] for neighbor in graph[node]: if levels[neighbor] == -1: levels[neighbor] = current_level + 1 queue.append(neighbor) elif levels[neighbor] == current_level: return -1 # Count levels and nodes in even/odd level sets even_count = sum(1 for level in levels if level % 2 == 0) odd_count = n - even_count # There are two ways to split the groups (even/odd or odd/even) return 2"},{"question":"def is_connected_subset_sum(matrix: List[List[int]], target: int) -> bool: Given an \`m x n\` matrix \`matrix\` filled with non-negative integers, find a non-empty subset of elements such that the sum of the elements in the subset is equal to a given integer \`target\`. The subset must be connected in the sense of vertical and horizontal neighbors within the matrix. Return \`true\` if such a subset exists, and \`false\` otherwise. >>> is_connected_subset_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 15) True >>> is_connected_subset_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 50) False >>> is_connected_subset_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) True >>> is_connected_subset_sum([[1, 1000, 2000], [1, 1, 1], [1, 1, 1]], 1002) True >>> is_connected_subset_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0) False","solution":"def is_connected_subset_sum(matrix, target): Determines if there is a connected subset in the matrix whose sum is equal to the target sum. # Directions for moving horizontally and vertically directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y, current_sum, visited): if current_sum == target: return True if current_sum > target: return False for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < len(matrix) and 0 <= ny < len(matrix[0]) and not visited[nx][ny]: visited[nx][ny] = True if dfs(nx, ny, current_sum + matrix[nx][ny], visited): return True visited[nx][ny] = False return False for i in range(len(matrix)): for j in range(len(matrix[0])): visited = [[False]*len(matrix[0]) for _ in range(len(matrix))] visited[i][j] = True if dfs(i, j, matrix[i][j], visited): return True return False"},{"question":"def isSubsequence(s: str, words: List[str]) -> List[bool]: Determines if each word in words is a subsequence of s. Parameters: - s (str): The original string. - words (list of str): List of words to check if they are subsequences of s. Returns: - list of bool: List where each element is True if words[i] is a subsequence of s, False otherwise. >>> isSubsequence(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) [True, False, True, True] >>> isSubsequence(\\"abcde\\", [\\"f\\", \\"gh\\", \\"xyz\\"]) [False, False, False] >>> isSubsequence(\\"abcde\\", [\\"a\\", \\"b\\", \\"cde\\", \\"bd\\"]) [True, True, True, True] >>> isSubsequence(\\"\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) [False, False, False, False] >>> isSubsequence(\\"abcde\\", []) [] >>> isSubsequence(\\"ab\\", [\\"abc\\", \\"aab\\"]) [False, False] # Implement the function here","solution":"def isSubsequence(s, words): Determines if each word in words is a subsequence of s. Parameters: - s (str): The original string. - words (list of str): List of words to check if they are subsequences of s. Returns: - list of bool: List where each element is True if words[i] is a subsequence of s, False otherwise. def check_subsequence(word, s): it = iter(s) return all(char in it for char in word) return [check_subsequence(word, s) for word in words]"},{"question":"class SearchMatrix: def __init__(self, matrix): Initializes the object with the input matrix. :param matrix: List of List of integers self.matrix = matrix def search(self, target): Returns true if target is present in the matrix, and false otherwise. :param target: int :return: bool # Unit Tests def test_search_matrix_found(): matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] sm = SearchMatrix(matrix) assert sm.search(5) == True assert sm.search(14) == True assert sm.search(1) == True assert sm.search(16) == True def test_search_matrix_not_found(): matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] sm = SearchMatrix(matrix) assert sm.search(0) == False assert sm.search(18) == False assert sm.search(15) == False assert sm.search(20) == False def test_search_empty_matrix(): matrix = [] sm = SearchMatrix(matrix) assert sm.search(5) == False def test_search_single_element_found(): matrix = [[5]] sm = SearchMatrix(matrix) assert sm.search(5) == True def test_search_single_element_not_found(): matrix = [[5]] sm = SearchMatrix(matrix) assert sm.search(1) == False","solution":"class SearchMatrix: def __init__(self, matrix): Initializes the object with the input matrix. :param matrix: List of List of integers self.matrix = matrix def search(self, target): Returns true if target is present in the matrix, and false otherwise. :param target: int :return: bool # Start from the top-right corner of the matrix if not self.matrix: return False rows = len(self.matrix) cols = len(self.matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if self.matrix[row][col] == target: return True elif self.matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"from typing import List def longest_equal_pos_neg_subarray(arr: List[int]) -> int: Returns the length of the longest subarray with an equal number of positive and negative integers. >>> longest_equal_pos_neg_subarray([1, -1, 3, -2, -3, 1, -1]) 6 >>> longest_equal_pos_neg_subarray([1, 2, 3, 4]) 0 >>> longest_equal_pos_neg_subarray([1, -1, 2, -2, 3, -3]) 6 >>> longest_equal_pos_neg_subarray([-1]) 0 >>> longest_equal_pos_neg_subarray([1]) 0 >>> longest_equal_pos_neg_subarray([1, 2, -2, -1, 1, -1, 2, 2, -2, -2, 1, -1]) 12 >>> longest_equal_pos_neg_subarray([1, -1] * 100000) 200000 pass","solution":"def longest_equal_pos_neg_subarray(arr): Returns the length of the longest subarray with an equal number of positive and negative integers. max_length = 0 count_map = {0: -1} count = 0 for i, num in enumerate(arr): if num > 0: count += 1 elif num < 0: count -= 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length # Example usage: # arr = [1, -1, 3, -2, -3, 1, -1] # print(longest_equal_pos_neg_subarray(arr)) # Output: 6"},{"question":"def nextGreaterElements(nums: List[int]) -> List[int]: Returns the next greater number for every element in a circular array. >>> nextGreaterElements([1, 2, 1]) [2, -1, 2] >>> nextGreaterElements([10]) [-1] >>> nextGreaterElements([3, 3, 3, 3]) [-1, -1, -1, -1] >>> nextGreaterElements([1, 2, 3, 4]) [2, 3, 4, -1] >>> nextGreaterElements([4, 3, 2, 1]) [-1, 4, 4, 4] >>> nextGreaterElements([1, 3, 2, 5, 4]) [3, 5, 5, -1, 5] >>> nextGreaterElements([4, 2, 1, 2, 4]) [-1, 4, 2, 4, -1]","solution":"def nextGreaterElements(nums): Returns the next greater numbers for each element in the circular array nums. n = len(nums) result = [-1] * n stack = [] for i in range(2 * n): while stack and nums[stack[-1]] < nums[i % n]: result[stack.pop()] = nums[i % n] if i < n: stack.append(i % n) return result"},{"question":"from typing import List def islandPerimeter(grid: List[List[int]]) -> int: Returns the perimeter of the island in the given grid. :param grid: List[List[int]] - A 2D grid of 0s and 1s :return: int - The perimeter of the island >>> islandPerimeter([[1]]) 4 >>> islandPerimeter([[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]) 16 >>> islandPerimeter([[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) 12 >>> islandPerimeter([[1, 1, 1, 1, 1]]) 12 >>> islandPerimeter([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 4","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the given grid. :param grid: List[List[int]] - A 2D grid of 0s and 1s :return: int - The perimeter of the island if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) perimeter = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: # Check all four directions for water or grid boundaries if i == 0 or grid[i-1][j] == 0: # top perimeter += 1 if i == m-1 or grid[i+1][j] == 0: # bottom perimeter += 1 if j == 0 or grid[i][j-1] == 0: # left perimeter += 1 if j == n-1 or grid[i][j+1] == 0: # right perimeter += 1 return perimeter"},{"question":"def numDistinctIslands(grid: List[List[int]]) -> int: Find the number of distinct islands in the grid. An island is defined as a group of cells connected 4-directionally (horizontal or vertical) that have the same height. An island is considered distinct if it does not have the same shape as any other island, even if rotated or mirrored. >>> numDistinctIslands([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1] ]) 2 >>> numDistinctIslands([ [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1] ]) 1 visited = set() distinct_islands = set() # Helper functions (dfs, normalize) would be defined here for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: shape = [] # DFS to explore the shape # Normalize the shape distinct_islands.add(normalized_shape) return len(distinct_islands)","solution":"def numDistinctIslands(grid): def dfs(x, y, origin_x, origin_y): if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != 1 or (x, y) in visited): return [] visited.add((x, y)) shape.append((x - origin_x, y - origin_y)) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: dfs(x + dx, y + dy, origin_x, origin_y) return shape def normalize(shape): transformations = [] for x, y in shape: transformations.extend([(x, y), (x, -y), (-x, y), (-x, -y), (y, x), (y, -x), (-y, x), (-y, -x)]) distinct_shape = set(transformations) return tuple(sorted(distinct_shape)) visited = set() distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: shape = [] dfs(i, j, i, j) if shape: normalized_shape = normalize(shape) distinct_islands.add(normalized_shape) return len(distinct_islands)"},{"question":"from typing import List def has_groups_size_x(nums: List[int]) -> bool: Determine whether the deck can be divided into groups of size g where each group has exactly the same integer composition and g >= 2. >>> has_groups_size_x([1,2,3,4,4,3,2,1]) True >>> has_groups_size_x([1,1,1,2,2,2,3,3,3,3,3,3]) True >>> has_groups_size_x([1,1,1,2,2,2,3,3,4,4]) False >>> has_groups_size_x([1,2,3,4,5]) False >>> has_groups_size_x([1,1]) True","solution":"from collections import Counter from math import gcd from functools import reduce def has_groups_size_x(nums): Determine whether the deck can be divided into groups of size g where each group has exactly the same integer composition and g >= 2. if not nums or len(nums) < 2: return False count = Counter(nums) gcd_value = reduce(gcd, count.values()) return gcd_value >= 2"},{"question":"def min_swaps_to_alternate(s: str) -> int: Calculate the minimum number of swaps required to make the string alternate between 'a' and 'b'. >>> min_swaps_to_alternate(\\"abab\\") == 0 >>> min_swaps_to_alternate(\\"baba\\") == 0 >>> min_swaps_to_alternate(\\"aaaa\\") == -1 >>> min_swaps_to_alternate(\\"bbbb\\") == -1 >>> min_swaps_to_alternate(\\"aabb\\") == 1 >>> min_swaps_to_alternate(\\"bbaa\\") == 1 >>> min_swaps_to_alternate(\\"aaa\\") == -1 >>> min_swaps_to_alternate(\\"bb\\") == -1 >>> min_swaps_to_alternate(\\"a\\") == 0 >>> min_swaps_to_alternate(\\"b\\") == 0 >>> min_swaps_to_alternate(\\"aaabb\\") == 1 >>> min_swaps_to_alternate(\\"ababa\\") == 0 >>> min_swaps_to_alternate(\\"babab\\") == 0 >>> min_swaps_to_alternate(\\"\\") == 0 >>> min_swaps_to_alternate(\\"ab\\") == 0 >>> min_swaps_to_alternate(\\"ba\\") == 0","solution":"def min_swaps_to_alternate(s): Calculate the minimum number of swaps required to make the string alternate between 'a' and 'b'. Parameters: s (str): input string containing only characters 'a' and 'b'. Returns: int: The minimum number of swaps needed or -1 if it is not possible. n = len(s) if n < 2: return 0 count_a = s.count(\\"a\\") count_b = s.count(\\"b\\") # If the difference between the count of a's and b's is more than 1, it's not possible if abs(count_a - count_b) > 1: return -1 # Calculate swaps needed to make \\"abab...\\" (starts with 'a') pattern1 = 'ab' * (n//2) + 'a' * (n%2) pattern2 = 'ba' * (n//2) + 'b' * (n%2) def count_swaps(s, pattern): Count swaps needed to transform s to a given alternating pattern. mismatches = sum(1 for i in range(n) if s[i] != pattern[i]) return mismatches // 2 swaps1 = count_swaps(s, pattern1) swaps2 = count_swaps(s, pattern2) if count_a == count_b: return min(swaps1, swaps2) elif count_a > count_b: return swaps1 # More 'a's, must start with 'a' pattern else: return swaps2 # More 'b's, must start with 'b' pattern"},{"question":"def find_sunlit_buildings(heights: List[int]) -> List[int]: Returns the indices of the buildings that are sunlit. Args: heights: List of integers representing the heights of the buildings Returns: List of integers representing the indices of sunlit buildings >>> find_sunlit_buildings([1, 2, 3, 4, 5]) == [0, 1, 2, 3, 4] >>> find_sunlit_buildings([5, 4, 3, 2, 1]) == [0] >>> find_sunlit_buildings([2, 1, 4, 3, 5]) == [0, 2, 4] >>> find_sunlit_buildings([10]) == [0] >>> find_sunlit_buildings([3, 3, 3, 3, 3]) == [0] >>> find_sunlit_buildings([1, 3, 2, 4, 2, 5]) == [0, 1, 3, 5] >>> find_sunlit_buildings([]) == []","solution":"def find_sunlit_buildings(heights): Returns the indices of the buildings that are sunlit. Args: heights: List of integers representing the heights of the buildings Returns: List of integers representing the indices of sunlit buildings sunlit_indices = [] max_height_so_far = 0 for i, height in enumerate(heights): if height > max_height_so_far: sunlit_indices.append(i) max_height_so_far = height return sunlit_indices"},{"question":"import heapq from collections import Counter from typing import List def rearrange_string(s: str) -> str: Rearranges the string such that no two adjacent characters are the same. If it's not possible, returns an empty string. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"aaabbc\\") in [\\"ababac\\", \\"ababca\\", \\"abacba\\"] True >>> rearrange_string(\\"aaabbcc\\") in [\\"abababc\\", \\"abacabc\\", \\"abcabac\\"] True >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"aaaabbc\\") 'ababaca' >>> rearrange_string(\\"\\") '' >>> rearrange_string(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] True >>> rearrange_string(\\"aa\\") ''","solution":"import heapq from collections import Counter def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. If it's not possible, returns an empty string. # Count the frequency of each character counter = Counter(s) # Max heap based on the count of characters max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # If previous character count is not zero, add it back to heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count = count + 1 # decrement count (since it's negative, we add 1) prev_char = char rearranged_string = ''.join(result) if len(rearranged_string) != len(s): return \\"\\" else: return rearranged_string"},{"question":"def largest_divisible_subset_size(nums: List[int]) -> int: Given a list of numbers, find the size of the largest subset such that every pair (num1, num2) in the subset satisfies either num1 % num2 == 0 or num2 % num1 == 0. >>> largest_divisible_subset_size([1]) 1 >>> largest_divisible_subset_size([1, 2, 4, 8]) 4 >>> largest_divisible_subset_size([2, 3, 5, 7]) 1 >>> largest_divisible_subset_size([3, 5, 10, 20, 25]) 3 >>> largest_divisible_subset_size([1, 2, 4, 8, 16, 32, 64, 128]) 8 >>> largest_divisible_subset_size([]) 0 >>> largest_divisible_subset_size([1, 2, 3, 6]) 3 >>> largest_divisible_subset_size([6, 2, 3, 1]) 3","solution":"def largest_divisible_subset_size(nums): Finds the size of the largest subset such that for every pair (num1, num2) in the subset, either num1 % num2 == 0 or num2 % num1 == 0 if not nums: return 0 # Sort the list nums.sort() # DP array to store the largest subset ending at each element dp = [1] * len(nums) # Populate the DP array for i in range(len(nums)): for j in range(i): if nums[i] % nums[j] == 0: dp[i] = max(dp[i], dp[j] + 1) # Return the largest subset size found return max(dp)"},{"question":"def longest_valid_parentheses(s: str) -> int: Returns the length of the longest valid parentheses substring. >>> longest_valid_parentheses(\\"(()\\") 2 >>> longest_valid_parentheses(\\")()())\\") 4 >>> longest_valid_parentheses(\\"\\") 0 >>> longest_valid_parentheses(\\"()(()\\") 2 >>> longest_valid_parentheses(\\"(()))())(\\") 4 >>> longest_valid_parentheses(\\"))((()\\") 2 >>> longest_valid_parentheses(\\"()()()\\") 6 >>> longest_valid_parentheses(\\")(((((()())()()))()(()))(\\") 22","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid parentheses substring. max_length = 0 stack = [-1] # Initialize stack with a base for the next valid substring for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"def max_vehicles_crossing(weights: List[int], w: int) -> int: Determines the maximum number of vehicles that can cross the bridge without collapsing. Parameters: weights (list): A list of integers representing the weights of the vehicles. w (int): The maximum weight capacity of the bridge. Returns: int: The maximum number of vehicles that can cross the bridge without collapsing. >>> max_vehicles_crossing([], 10) 0 >>> max_vehicles_crossing([1, 2, 3], 10) 3 >>> max_vehicles_crossing([2, 3, 5], 7) 2 >>> max_vehicles_crossing([10], 5) 0 >>> max_vehicles_crossing([8, 1, 1], 7) 0 >>> max_vehicles_crossing([4, 4, 3], 7) 1 >>> max_vehicles_crossing([3, 4, 3], 7) 2","solution":"def max_vehicles_crossing(weights, w): Determines the maximum number of vehicles that can cross the bridge without collapsing. Parameters: weights (list): A list of integers representing the weights of the vehicles. w (int): The maximum weight capacity of the bridge. Returns: int: The maximum number of vehicles that can cross the bridge without collapsing. total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= w: total_weight += weight count += 1 else: break return count"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Returns the length of the longest substring with unique characters. >>> length_of_longest_unique_substring(\\"abcdef\\") 6 >>> length_of_longest_unique_substring(\\"abcabcbb\\") 3 >>> length_of_longest_unique_substring(\\"aaaaaaa\\") 1 >>> length_of_longest_unique_substring(\\"pwwkew\\") 3 >>> length_of_longest_unique_substring(\\"\\") 0 >>> length_of_longest_unique_substring(\\"a\\") 1 >>> length_of_longest_unique_substring(\\"dvdf\\") 3","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring with unique characters. char_index_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_index_map: left = max(left, char_index_map[s[right]] + 1) char_index_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Return the level order traversal of a binary tree's nodes' values. >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> level_order_traversal(root) [[1], [2, 3]] >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) >>> level_order_traversal(root) [[1], [2, 3], [4]] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) >>> level_order_traversal(root) [[1], [2, 3], [4, 5, 6]] >>> level_order_traversal(None) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Return the level order traversal of a binary tree's nodes' values. if not root: return [] result = [] queue = deque([root]) while queue: level = [] for i in range(len(queue)): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def command_handler(commands: List[str]) -> List[str]: Simulate a terminal command handler. >>> command_handler([\\"pwd\\"]) [\\"/\\"] >>> command_handler([\\"cd folder1\\", \\"pwd\\"]) [\\"/folder1\\"] >>> command_handler([\\"cd folder1\\", \\"cd folder2\\", \\"pwd\\"]) [\\"/folder1/folder2\\"] >>> command_handler([\\"cd folder1\\", \\"cd folder2\\", \\"cd ..\\", \\"pwd\\"]) [\\"/folder1\\"] >>> command_handler([\\"cd folder1\\", \\"cd folder2\\", \\"cd ..\\", \\"cd ..\\", \\"pwd\\"]) [\\"/\\"] >>> command_handler([\\"cd ..\\", \\"pwd\\"]) [\\"/\\"] >>> command_handler([ \\"cd folder1\\", \\"pwd\\", \\"cd ..\\", \\"cd folder2\\", \\"cd subfolder\\", \\"pwd\\", \\"cd ..\\", \\"cd ..\\", \\"cd folder3\\", \\"cd subfolder1\\", \\"cd subfolder2\\", \\"pwd\\" ]) [\\"/folder1\\", \\"/folder2/subfolder\\", \\"/folder3/subfolder1/subfolder2\\"]","solution":"def command_handler(commands): current_path = [\\"/\\"] output = [] def get_path(): if len(current_path) == 1: return \\"/\\" return \\"/\\" + \\"/\\".join(current_path[1:]) for cmd in commands: if cmd.startswith(\\"cd \\"): folder = cmd.split(\\" \\", 1)[1] if folder == \\"..\\": if len(current_path) > 1: current_path.pop() else: current_path.append(folder) elif cmd == \\"pwd\\": output.append(get_path()) return output"},{"question":"def min_jumps(nums: List[int]) -> int: Returns the minimum number of jumps required to reach the end of the list. If it is not possible, returns -1. >>> min_jumps([0]) 0 >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([2, 3, 0, 1, 4]) 2 >>> min_jumps([0, 0, 0, 0]) -1 >>> min_jumps([10, 3, 0, 1, 4]) 1 >>> min_jumps([1, 0, 2]) -1 >>> min_jumps([1, 2, 1, 1, 1]) 3 >>> min_jumps([1]) 0","solution":"def min_jumps(nums): Returns the minimum number of jumps required to reach the end of the list. If it is not possible, returns -1. if len(nums) <= 1: return 0 if nums[0] == 0: return -1 n = len(nums) jumps = 1 max_reach = nums[0] steps = nums[0] for i in range(1, n): if i == n-1: return jumps max_reach = max(max_reach, i + nums[i]) steps -= 1 if steps == 0: jumps += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLonelyNode(root: Optional[TreeNode]) -> List[int]: Write a function \`findLonelyNode\` to identify the nodes in a binary tree that are \\"lonely\\". A node is considered lonely if it does not have any siblings. You should return the list of values of all lonely nodes in the tree sorted in ascending order. Each node in the binary tree has the following structure: class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right The function signature should be: def findLonelyNode(root: Optional[TreeNode]) -> List[int]: Examples: >>> findLonelyNode(TreeNode(1, TreeNode(2), TreeNode(3))) [] >>> findLonelyNode(TreeNode(1, TreeNode(2), None)) [2] >>> findLonelyNode(TreeNode(1, TreeNode(2, None, TreeNode(4)), TreeNode(3))) [4]","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLonelyNode(root: Optional[TreeNode]) -> List[int]: if not root: return [] lonely_nodes = [] def dfs(node): if not node: return # Check if a node is lonely and add its value to the list. if node.left and not node.right: lonely_nodes.append(node.left.val) if node.right and not node.left: lonely_nodes.append(node.right.val) dfs(node.left) dfs(node.right) dfs(root) return sorted(lonely_nodes)"},{"question":"def rearrange_string(s: str, k: int) -> str: Given a string 's' consisting of lowercase letters, rearrange the letters such that each character appears at least 'k' distance apart. If it is not possible to rearrange the string in such a way, return an empty string \\"\\". Otherwise, return the rearranged string. >>> rearrange_string(\\"aabbcc\\", 3) in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\", \\"bcbacb\\", \\"cabacb\\"] True >>> rearrange_string(\\"aaabc\\", 3) \\"\\" >>> rearrange_string(\\"aaa\\", 2) \\"\\" >>> rearrange_string(\\"aaabc\\", 1) \\"aaabc\\" >>> rearrange_string(\\"\\", 3) \\"\\" >>> rearrange_string(\\"a\\", 3) \\"a\\" >>> rearrange_string(\\"a\\", 1) \\"a\\"","solution":"import heapq from collections import Counter, deque def rearrange_string(s, k): if k <= 1: return s char_count = Counter(s) max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((char, freq + 1)) if len(queue) < k: continue prev_char, prev_freq = queue.popleft() if -prev_freq > 0: heapq.heappush(max_heap, (prev_freq, prev_char)) if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"def diagonalSum(mat): Returns the sum of all the elements on the primary and secondary diagonals of an n x n 2D matrix mat. Parameters: mat (List[List[int]]): The n x n 2D matrix Returns: int: The sum of the elements on the diagonals >>> diagonalSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # 1+5+9+3+7 = 25 (5 counted once) 25 >>> diagonalSum([[5]]) # Single element matrix 5 >>> diagonalSum([[1, 2], [3, 4]]) # 1+4+2+3 = 10 10 >>> diagonalSum([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) # All zeros 0 >>> diagonalSum([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) # Negative values -25 >>> diagonalSum([[100, 200, 300], [400, 500, 600], [700, 800, 900]]) # Large numbers 2500","solution":"def diagonalSum(mat): Returns the sum of all the elements on the primary and secondary diagonals of an n x n 2D matrix mat. Parameters: mat (List[List[int]]): The n x n 2D matrix Returns: int: The sum of the elements on the diagonals n = len(mat) total_sum = 0 for i in range(n): total_sum += mat[i][i] # Primary diagonal total_sum += mat[i][n - i - 1] # Secondary diagonal # if n is odd, subtract the center element, which is counted twice if n % 2 == 1: total_sum -= mat[n // 2][n // 2] return total_sum"},{"question":"def min_trucks_required(routes: List[List[int]]) -> int: Determine the minimum number of trucks required to cover all the routes. Each route is represented as a 2D integer array \`routes\` where \`routes[i] = [starti, endi]\` indicating that a truck travels from \`starti\` to \`endi\`. Args: routes: List of lists where each inner list represents a route with start and end points. Returns: The minimum number of trucks required. >>> min_trucks_required([]) 0 >>> min_trucks_required([[1, 5]]) 1 >>> min_trucks_required([[1, 3], [3, 5], [5, 7]]) 1 >>> min_trucks_required([[1, 5], [2, 6], [3, 7]]) 3 >>> min_trucks_required([[1, 4], [2, 5], [6, 8]]) 2 >>> min_trucks_required([[1, 10], [2, 6], [3, 8], [9, 12], [11, 15]]) 3 >>> min_trucks_required([[0, 30], [5, 10], [15, 20], [12, 25], [28, 35]]) 3","solution":"def min_trucks_required(routes): # First, sort the routes by their start time routes.sort(key=lambda x: x[0]) # Use a heap to keep track of end times of trucks' current routes import heapq heap = [] for route in routes: start, end = route # If heap is not empty and the earliest ending route ends before the current route starts if heap and heap[0] <= start: heapq.heapreplace(heap, end) else: heapq.heappush(heap, end) # The number of trucks needed is the size of the heap return len(heap)"},{"question":"def search_insert(nums: List[int], target: int) -> int: Given a sorted array of integers and a target value, find the index if the target is found, if not return the index where it would be if inserted in order. Args: nums (list[int]): The sorted array of integers. target (int): The target value. Returns: int: The index of the target or the insertion index. Examples: >>> search_insert([1, 3, 5, 6], 5) == 2 >>> search_insert([1, 3, 5, 6], 2) == 1 >>> search_insert([1, 3, 5, 6], 7) == 4 >>> search_insert([1, 3, 5, 6], 0) == 0 >>> search_insert([1, 3, 5, 6], 1) == 0 >>> search_insert([1], 0) == 0 >>> search_insert([1], 2) == 1 >>> search_insert([1], 1) == 0 pass # Implement this function","solution":"def search_insert(nums, target): Given a sorted array of integers and a target value, find the index if the target is found, if not return the index where it would be if inserted in order. Args: nums (list[int]): The sorted array of integers. target (int): The target value. Returns: int: The index of the target or the insertion index. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"from typing import List def check_collinear(points: List[List[int]]) -> bool: Return True if there exists at least one set of 3 or more points in points that are all on the same straight line. Otherwise, return False. >>> check_collinear([[1, 2], [2, 4], [3, 6]]) True >>> check_collinear([[1, 2], [3, 4], [5, 1]]) False","solution":"def check_collinear(points): Returns True if there exist at least one set of 3 or more points that are collinear, False otherwise. if len(points) < 3: return False def slope(p1, p2): if p1[0] == p2[0]: return float('inf') return (p1[1] - p2[1]) / (p1[0] - p2[0]) n = len(points) for i in range(n): slopes = {} for j in range(n): if i != j: m = slope(points[i], points[j]) if m in slopes: slopes[m] += 1 else: slopes[m] = 1 for count in slopes.values(): if count >= 2: # count >= 2 means at least 3 points including the original point return True return False"},{"question":"import heapq from typing import List def trapRainWater(heightMap: List[List[int]]) -> int: Given a 2D grid of size m x n, where each cell in the grid contains a non-negative integer representing the height of a terrain, find the maximum amount of water that can be trapped between the terrains after raining. The terrain cannot overflow the edges of the grid, and water can only be trapped between columns of varying heights. Return the total amount of water trapped. >>> trapRainWater([]) 0 >>> trapRainWater([[]]) 0 >>> trapRainWater([[1]]) 0 >>> trapRainWater([ ... [1, 1, 1], ... [1, 2, 1], ... [1, 1, 1] ... ]) 0 >>> trapRainWater([ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 4], ... [2, 3, 3, 2, 3, 1] ... ]) 4 >>> trapRainWater([ ... [12, 13, 1, 12], ... [13, 4, 13, 12], ... [13, 8, 10, 12], ... [12, 13, 12, 12], ... [13, 13, 13, 13] ... ]) 14 # Implementation goes here","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Initialize the heap with the boundary cells for i in range(m): for j in range(n): if i == 0 or i == m - 1 or j == 0 or j == n - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True result = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: result += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) visited[nx][ny] = True return result"},{"question":"class MinStack: Implement a class MinStack that supports the following operations: 1. MinStack() - Initializes an empty stack. 2. void push(int val) - Pushes the integer val onto the stack. 3. void pop() - Removes the element on the top of the stack. 4. int top() - Gets the top element of the stack. 5. int getMin() - Retrieves the minimum element in the stack. Example: minStack = MinStack() minStack.push(-2) minStack.push(0) minStack.push(-3) minStack.getMin() # Returns -3 minStack.pop() minStack.top() # Returns 0 minStack.getMin() # Returns -2 def __init__(self): pass def push(self, val: int) -> None: pass def pop(self) -> None: pass def top(self) -> int: pass def getMin(self) -> int: pass from solution import MinStack def test_min_stack_operations(): min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) assert min_stack.getMin() == -3 # retrieves -3 min_stack.pop() assert min_stack.top() == 0 # top element is now 0 assert min_stack.getMin() == -2 # retrieves -2 def test_min_stack_single_element(): min_stack = MinStack() min_stack.push(1) assert min_stack.top() == 1 assert min_stack.getMin() == 1 min_stack.pop() # After popping all elements, the behavior for top and getMin would be undefined try: assert min_stack.top() is None except Exception: assert True try: assert min_stack.getMin() is None except Exception: assert True def test_min_stack_duplicate_minimum(): min_stack = MinStack() min_stack.push(2) min_stack.push(0) min_stack.push(2) min_stack.push(0) assert min_stack.getMin() == 0 # retrieves 0 min_stack.pop() assert min_stack.getMin() == 0 # retrieves 0 min_stack.pop() assert min_stack.getMin() == 0 # retrieves 0 min_stack.pop() assert min_stack.getMin() == 2 # retrieves 2","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] def getMin(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"def four_sum(arr, target): Determines if there are four distinct elements in arr that sum up to target. :param arr: List[int], the input integer array. :param target: int, the target sum. :return: bool, True if there exist four distinct elements that sum up to target, otherwise False. >>> four_sum([1, 0, -1, 0, -2, 2], 0) True >>> four_sum([1, 2, 3, 4, 5], 10) True >>> four_sum([1, 2, 3, 4, 5], 100) False >>> four_sum([-1, 0, 1, 2, -1, -4], 10) False >>> four_sum([1, 2, 3, 4, 5, 6, 7, 8], 26) True >>> four_sum([1, 2, 3, 4, 5, 6, 7, 8], 2) False >>> four_sum([-5, 3, 1, 0, -1, 2, -2, 4], 0) True >>> four_sum([-5, -4, -3, -2, -1], 0) False","solution":"def four_sum(arr, target): Determines if there are four distinct elements in arr that sum up to target. :param arr: List[int], the input integer array. :param target: int, the target sum. :return: bool, True if there exist four distinct elements that sum up to target, otherwise False. arr.sort() n = len(arr) for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[j] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def longest_sentence_length(paragraph: str) -> int: Returns the length of the longest sentence within the paragraph. A sentence is defined as a sequence of words separated by spaces, and a sentence terminates at a period (.), exclamation mark (!), or question mark (?). Args: paragraph (str): The input string representing the paragraph. Returns: int: The length of the longest sentence within the paragraph. >>> longest_sentence_length(\\"This is a test.\\") 4 >>> longest_sentence_length(\\"This is the first sentence. This is the second!\\") 5 >>> longest_sentence_length(\\"How are you? I'm good. Let's go!\\") 3 >>> longest_sentence_length(\\"Hello. how are you doing? I am fine.\\") 4 >>> longest_sentence_length(\\" Hello there! How are you ? I am good. \\") 3 >>> longest_sentence_length(\\"\\") 0 >>> longest_sentence_length(\\"This is a test without a delimiter\\") 7 >>> longest_sentence_length(\\".!?\\") 0","solution":"def longest_sentence_length(paragraph): Returns the length of the longest sentence within the paragraph. A sentence is defined as a sequence of words separated by spaces, and a sentence terminates at a period (.), exclamation mark (!), or question mark (?). Args: paragraph (str): The input string representing the paragraph. Returns: int: The length of the longest sentence within the paragraph. import re # Split the paragraph into sentences based on the sentence-ending punctuations sentences = re.split(r'[.!?]', paragraph) # Find the length of each sentence by counting the words sentence_lengths = [len(sentence.split()) for sentence in sentences] # Return the maximum length among the sentences return max(sentence_lengths)"},{"question":"from collections import Counter def minOperationsToRearrange(s: str) -> int: Returns the minimum number of operations required to rearrange the characters of the string so that no two adjacent characters are the same. If it is not possible, return -1. >>> minOperationsToRearrange(\\"aabb\\") == 0 >>> minOperationsToRearrange(\\"aaab\\") == -1 >>> minOperationsToRearrange(\\"a\\") == 0 >>> minOperationsToRearrange(\\"aaaa\\") == -1 >>> minOperationsToRearrange(\\"abab\\") == 0","solution":"from collections import Counter def minOperationsToRearrange(s): Returns the minimum number of operations required to rearrange the characters of the string so that no two adjacent characters are the same. If it is not possible, return -1. n = len(s) count = Counter(s) max_freq = max(count.values()) if max_freq > (n + 1) // 2: return -1 return 0"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root): Perform inorder traversal on a binary tree. :param root: TreeNode, the root of the binary tree. :return: List[int], the inorder traversal of the node values. >>> inorderTraversal(None) [] >>> root = TreeNode(1) >>> inorderTraversal(root) [1] >>> root = TreeNode(1, TreeNode(2, TreeNode(3))) >>> inorderTraversal(root) [3, 2, 1] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> inorderTraversal(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> inorderTraversal(root) [2, 1, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> inorderTraversal(root) [4, 2, 5, 1, 6, 3, 7]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root): Perform inorder traversal on a binary tree. :param root: TreeNode, the root of the binary tree. :return: List[int], the inorder traversal of the node values. result = [] def inorder(node): if node: inorder(node.left) # Visit left subtree result.append(node.val) # Visit node itself inorder(node.right) # Visit right subtree inorder(root) return result"},{"question":"from typing import List def min_difference(nums: List[int]) -> int: Divides the array \`nums\` into two subsets of equal size such that the difference between the sum of elements in the first subset and the sum of elements in the second subset is minimized. Parameters: nums (list): List of unique integers of even length. Returns: int: Minimum possible difference between the sum of the two subsets. >>> min_difference([1, 2, 3, 4]) == 0 >>> min_difference([1, 6, 5, 11]) == 1 >>> min_difference([7, 8, 3, 1, 2, 4]) == 1 >>> min_difference([1, 2, 9, 12, 6, 3, 8, 14]) == 1 >>> min_difference([5, 10, 15, 20, 25, 30, 35, 40]) == 0 >>> min_difference([1, 2]) == 1","solution":"from itertools import combinations def min_difference(nums): Divides the array \`nums\` into two subsets of equal size such that the difference between the sum of elements in the first subset and the sum of elements in the second subset is minimized. Parameters: nums (list): List of unique integers of even length. Returns: int: Minimum possible difference between the sum of the two subsets. total_sum = sum(nums) n = len(nums) // 2 all_combinations = combinations(nums, n) min_diff = float('inf') for comb in all_combinations: subset_sum = sum(comb) diff = abs((total_sum - subset_sum) - subset_sum) min_diff = min(min_diff, diff) return min_diff"},{"question":"def find_kth_occurrence(s: str, queries: List[List[Union[str, int]]]) -> List[int]: Given a string s and a list of queries, each containing a substring and an integer k, return the starting index of the k-th occurrence of the substring in s, or -1 if it does not occur at least k times. :param s: Input string :param queries: List of queries, each a list containing a substring and an integer k :return: List of starting indices of k-th occurrences for each query >>> find_kth_occurrence(\\"this is a test string\\", [[\\"test\\", 1]]) [10] >>> find_kth_occurrence(\\"banana\\", [[\\"ana\\", 1], [\\"ana\\", 2]]) [1, 3] >>> find_kth_occurrence(\\"hello world\\", [[\\"world\\", 2]]) [-1] >>> find_kth_occurrence(\\"aaaaa\\", [[\\"aa\\", 1], [\\"aa\\", 2], [\\"aa\\", 3]]) [0, 1, 2] >>> find_kth_occurrence(\\"test\\", [[\\"test\\", 0]]) [-1] >>> find_kth_occurrence(\\"abcdefg\\", [[\\"hij\\", 1]]) [-1] >>> find_kth_occurrence(\\"\\", [[\\"test\\", 1]]) [-1] >>> find_kth_occurrence(\\"abracadabra\\", [[\\"abra\\", 1], [\\"abra\\", 2], [\\"cad\\", 1]]) [0, 7, 4]","solution":"def find_kth_occurrence(s, queries): Given a string s and a list of queries, each containing a substring and an integer k, return the starting index of the k-th occurrence of the substring in s, or -1 if it does not occur at least k times. :param s: Input string :param queries: List of queries, each a list containing a substring and an integer k :return: List of starting indices of k-th occurrences for each query results = [] for sub, k in queries: count = 0 start = 0 found = -1 while start <= len(s) - len(sub): pos = s.find(sub, start) if pos == -1: break count += 1 if count == k: found = pos break start = pos + 1 results.append(found) return results"},{"question":"def three_sum(arr, target): Determine if there are three distinct elements in the array that add up to the target. :param arr: List of integers :param target: Integer target value :return: Boolean indicating if such elements exist. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum([12, 3, 4, 1, 6, 9], 24) True >>> three_sum([1, 2, 3, 4, 5], 50) False >>> three_sum([1, 2, 3], 1) False >>> three_sum([12, 3, 4, 1, 6, 9], 50) False >>> three_sum([], 0) False >>> three_sum([1], 1) False >>> three_sum([1, 2], 3) False >>> three_sum([1, 1, 1, 2, 2, 3, 3], 6) True >>> three_sum([1, 2, 2, 3, 4], 7) True >>> three_sum([1, 2, 2, 1, 3, 4], 12) False","solution":"def three_sum(arr, target): Determine if there are three distinct elements in arr that add up to target. :param arr: List of integers :param target: Integer target value :return: Boolean indicating if such elements exist arr.sort() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"from typing import List def numMatchingSubseq(s: str, words: List[str]) -> int: Returns the number of strings in words which are subsequences of s. >>> numMatchingSubseq(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) 3 >>> numMatchingSubseq(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\"]) 6 >>> numMatchingSubseq(\\"xyz\\", [\\"x\\", \\"y\\", \\"z\\", \\"xy\\", \\"yz\\", \\"xyz\\", \\"xzy\\"]) 6 >>> numMatchingSubseq(\\"test\\", [\\"t\\", \\"te\\", \\"st\\", \\"es\\", \\"tes\\", \\"test\\", \\"tset\\"]) 6 >>> numMatchingSubseq(\\"abcdefg\\", [\\"a\\", \\"b\\", \\"c\\", \\"abc\\", \\"def\\", \\"g\\", \\"fg\\", \\"dc\\"]) 7 pass","solution":"from typing import List import collections def numMatchingSubseq(s: str, words: List[str]) -> int: Returns the number of strings in words which are subsequences of s. def is_subsequence(word, s): it = iter(s) return all(char in it for char in word) count = 0 for word in words: if is_subsequence(word, s): count += 1 return count"},{"question":"def find_customers_exceeding_threshold(transactions: List[List[int]], threshold: int) -> List[int]: Returns a list of customer ids whose balance exceeds the given threshold after processing all transactions. Parameters: transactions (list of lists): A 2D integer list where each inner list represents a transaction [customer_id, amount]. threshold (int): The maximum allowed balance for any customer. Returns: list: A sorted list of customer ids whose balance exceeds the threshold. >>> find_customers_exceeding_threshold([[1, 100], [2, 200], [1, -50], [2, -100]], 200) [] >>> find_customers_exceeding_threshold([[1, 300], [2, 150], [1, 100], [2, 100]], 250) [1] >>> find_customers_exceeding_threshold([[1, 500], [2, 600], [3, 700]], 400) [1, 2, 3] >>> find_customers_exceeding_threshold([[1, -100], [2, -200], [3, -300]], 0) [] >>> find_customers_exceeding_threshold([], 100) [] >>> find_customers_exceeding_threshold([[1, 50], [2, 200], [1, -10], [3, 400], [1, 60], [3, -100]], 100) [2, 3] # your code here","solution":"def find_customers_exceeding_threshold(transactions, threshold): Returns a list of customer ids whose balance exceeds the given threshold after processing all transactions. Parameters: transactions (list of lists): A 2D integer list where each inner list represents a transaction [customer_id, amount]. threshold (int): The maximum allowed balance for any customer. Returns: list: A sorted list of customer ids whose balance exceeds the threshold. balances = {} for customer_id, amount in transactions: if customer_id in balances: balances[customer_id] += amount else: balances[customer_id] = amount exceeding_customers = [customer_id for customer_id, balance in balances.items() if balance > threshold] return sorted(exceeding_customers)"},{"question":"def min_deletions_to_form(word1: str, word2: str) -> int: Determine if word2 can be formed from word1 and calculate the minimum number of deletions required in word1 to form word2. Return -1 if it is not possible to form word2 from word1. >>> min_deletions_to_form(\\"abcde\\", \\"ace\\") 2 >>> min_deletions_to_form(\\"abcde\\", \\"aec\\") -1 >>> min_deletions_to_form(\\"abc\\", \\"abc\\") 0 >>> min_deletions_to_form(\\"abc\\", \\"d\\") -1 >>> min_deletions_to_form(\\"abc\\", \\"\\") 3 >>> min_deletions_to_form(\\"aabbcc\\", \\"abc\\") 3","solution":"def min_deletions_to_form(word1, word2): Determine if word2 can be formed from word1 and calculate the minimum number of deletions required in word1 to form word2. m, n = len(word1), len(word2) # Step 1: Use Dynamic Programming to find the Longest Common Subsequence (LCS) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[m][n] # Step 2: Check if the LCS length is equal to the length of word2 if lcs_length != n: return -1 else: # Minimum deletions to transform word1 into word2 return m - lcs_length"},{"question":"def has_subarray_with_zero_sum(arr: List[int]) -> bool: Determines if there exists a non-empty subarray whose sum is equal to 0. Parameters: arr (List[int]): The input array of integers. Returns: bool: True if there exists a non-empty subarray whose sum is equal to 0, otherwise False. >>> has_subarray_with_zero_sum([1, 2, -3, 4]) == True >>> has_subarray_with_zero_sum([1, 2, 3, -3, 6]) == True >>> has_subarray_with_zero_sum([1, -1]) == True >>> has_subarray_with_zero_sum([-1, 1, -1, 1]) == True >>> has_subarray_with_zero_sum([3, 4, 5, 6]) == False >>> has_subarray_with_zero_sum([1, 2, 3]) == False >>> has_subarray_with_zero_sum([5, 6, 7, 8]) == False >>> has_subarray_with_zero_sum([]) == False >>> has_subarray_with_zero_sum([0]) == True >>> has_subarray_with_zero_sum([5]) == False >>> has_subarray_with_zero_sum([-5]) == False","solution":"def has_subarray_with_zero_sum(arr): Determines if there exists a non-empty subarray whose sum is equal to 0. Parameters: arr (list): The input array of integers. Returns: bool: True if there exists a non-empty subarray whose sum is equal to 0, otherwise False. prefix_sum_set = set() prefix_sum = 0 for num in arr: prefix_sum += num if prefix_sum == 0 or prefix_sum in prefix_sum_set: return True prefix_sum_set.add(prefix_sum) return False"},{"question":"def max_subarray_sum(arr): Returns the sum of the subarray with the maximum sum in a given array using Kadane's Algorithm. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-5]) == -5 >>> max_subarray_sum([0, 0, 0, 0]) == 0 >>> max_subarray_sum([]) == 0","solution":"def max_subarray_sum(arr): Returns the sum of the subarray with the maximum sum in a given array using Kadane's Algorithm. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def min_insertions_to_make_subsequences(s: str, dict: List[str]) -> int: Returns the minimum number of characters that need to be inserted into the string \`s\` so that every word in \`dict\` can be formed as a subsequence. >>> min_insertions_to_make_subsequences(\\"abc\\", [\\"ab\\", \\"bc\\", \\"ac\\"]) 0 >>> min_insertions_to_make_subsequences(\\"abc\\", [\\"abcd\\", \\"abcf\\"]) 2 >>> min_insertions_to_make_subsequences(\\"\\", [\\"a\\", \\"b\\"]) 2 >>> min_insertions_to_make_subsequences(\\"abc\\", []) 0 >>> min_insertions_to_make_subsequences(\\"axc\\", [\\"abc\\", \\"cba\\"]) 4 >>> min_insertions_to_make_subsequences(\\"x\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) 4","solution":"def min_insertions_to_make_subsequences(s, dict): Returns the minimum number of characters that need to be inserted into string s so that every word in dict can be formed as a subsequence. def need_to_insert(s, word): m, n = len(s), len(word) i, j = 0, 0 # Iterate over the string \`s\` and the word simultaneously while i < m and j < n: if s[i] == word[j]: j += 1 i += 1 # Characters remaining to be matched in word return n - j # Calculate the total number of insertions needed total_insertions = 0 for word in dict: total_insertions += need_to_insert(s, word) return total_insertions"},{"question":"def longest_happy_subsequence(nums, k): Returns the length of the longest happy subsequence where the difference between the maximum and minimum elements is at most k. Args: nums: List[int] - List of integers. k: int - Maximum allowed difference between the maximum and minimum elements in the subsequence. Returns: int - Length of the longest happy subsequence. >>> longest_happy_subsequence([1, 3, 6, 8], 2) == 2 >>> longest_happy_subsequence([1, 2, 3], 2) == 3 >>> longest_happy_subsequence([4, 10], 3) == 1 >>> longest_happy_subsequence([9], 5) == 1 >>> longest_happy_subsequence([1, 1, 1], 0) == 3 >>> longest_happy_subsequence([1, 7, 3, 5, 6], 10) == 5 >>> longest_happy_subsequence([10, 5, 2, 8, 7], 3) == 3","solution":"def longest_happy_subsequence(nums, k): Returns the length of the longest happy subsequence where the difference between the maximum and minimum elements is at most k. Args: nums: List[int] - List of integers. k: int - Maximum allowed difference between the maximum and minimum elements in the subsequence. Returns: int - Length of the longest happy subsequence. nums.sort() max_len = 0 n = len(nums) for i in range(n): for j in range(i, n): if nums[j] - nums[i] > k: break max_len = max(max_len, j - i + 1) return max_len"},{"question":"from typing import List, Tuple def assign_badges(ratings: List[int]) -> Tuple[int, List[int]]: Assigns the minimum number of badges needed based on the given rating rules. Parameters: ratings (List[int]): A list of ratings of ice cream shops. Returns: (int, List[int]): A tuple where the first element is the minimum number of badges needed, and the second element is a list of badge values for each shop. >>> assign_badges([1, 2, 2]) (4, [1, 2, 1]) >>> assign_badges([1, 0, 2]) (5, [2, 1, 2]) >>> assign_badges([3, 3, 3, 3]) (4, [1, 1, 1, 1]) >>> assign_badges([1, 2, 3, 4]) (10, [1, 2, 3, 4]) >>> assign_badges([4, 3, 2, 1]) (10, [4, 3, 2, 1]) >>> assign_badges([1, 2, 1, 2, 1]) (7, [1, 2, 1, 2, 1]) >>> assign_badges([1, 3, 2, 1]) (7, [1, 3, 2, 1]) >>> assign_badges([1]) (1, [1]) >>> assign_badges([5]) (1, [1]) >>> assign_badges([1, 2]) (3, [1, 2]) >>> assign_badges([2, 1]) (3, [2, 1])","solution":"def assign_badges(ratings): Assigns the minimum number of badges needed based on the given rating rules. Parameters: ratings (List[int]): A list of ratings of ice cream shops. Returns: (int, List[int]): A tuple where the first element is the minimum number of badges needed, and the second element is a list of badge values for each shop. n = len(ratings) if n == 0: return 0, [] badges = [1] * n # First pass: Ensure each shop has more badges than its left neighbor if it has a higher rating. for i in range(1, n): if ratings[i] > ratings[i - 1]: badges[i] = badges[i - 1] + 1 # Second pass: Ensure each shop has more badges than its right neighbor if it has a higher rating. for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: badges[i] = max(badges[i], badges[i + 1] + 1) return sum(badges), badges"},{"question":"def count_smaller_elements(arr: List[int]) -> List[int]: Given a list of integers \`arr\` which contains the integers from 1 to \`n\` in a shuffled order, create a new array \`result\` where \`result[i]\` is equal to the number of elements to the right of \`arr[i]\` that are smaller than \`arr[i]\`. >>> count_smaller_elements([1, 1, 1, 1]) == [0, 0, 0, 0] >>> count_smaller_elements([10]) == [0] >>> count_smaller_elements([1, 2, 3, 4, 5]) == [0, 0, 0, 0, 0] >>> count_smaller_elements([5, 4, 3, 2, 1]) == [4, 3, 2, 1, 0] >>> count_smaller_elements([3, 1, 2, 5, 4]) == [2, 0, 0, 1, 0] >>> count_smaller_elements([4, 1, 3, 2, 5]) == [3, 0, 1, 0, 0] >>> count_smaller_elements([10, 4, 3, 7, 1]) == [4, 2, 1, 1, 0]","solution":"def count_smaller_elements(arr): Given a list of integers \`arr\` which contains the integers from 1 to \`n\` in a shuffled order, the function creates a new array \`result\` where \`result[i]\` is equal to the number of elements to the right of \`arr[i]\` that are smaller than \`arr[i]\`. :param arr: List[int] :return: List[int] n = len(arr) result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if arr[j] < arr[i]: count += 1 result[i] = count return result"},{"question":"def evaluate(expression: str) -> int: Evaluates the mathematical expression where * has higher precedence than +. >>> evaluate(\\"2 + 3\\") == 5 >>> evaluate(\\"2 * 3\\") == 6 >>> evaluate(\\"2 + 3 * 4\\") == 14 >>> evaluate(\\"2 * 3 + 4\\") == 10 >>> evaluate(\\"2 * 3 * 4\\") == 24 >>> evaluate(\\"2 + 3 + 4\\") == 9 >>> evaluate(\\"2 * 3 + 4 * 5\\") == 26 >>> evaluate(\\" 2 * 3 + 4 * 5 \\") == 26 >>> evaluate(\\"2+ 3* 4\\") == 14 >>> evaluate(\\"2 * 3 + 4 + 5 * 6 + 7\\") == 47","solution":"def evaluate(expression): Evaluates the mathematical expression where * has higher precedence than +. # Remove any spaces from the expression expression = expression.replace(\\" \\", \\"\\") def apply_operation(operands, operator): right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '*': operands.append(left * right) # Stack for operands and operators operands = [] operators = [] i = 0 while i < len(expression): char = expression[i] if char.isdigit(): # Read the entire number start = i while i < len(expression) and expression[i].isdigit(): i += 1 operands.append(int(expression[start:i])) continue if char == '*': while operators and operators[-1] == '*': apply_operation(operands, operators.pop()) operators.append(char) elif char == '+': while operators and operators[-1] in {'*', '+'}: apply_operation(operands, operators.pop()) operators.append(char) i += 1 while operators: apply_operation(operands, operators.pop()) return operands[0]"},{"question":"class Solution: def __init__(self, words, target): Initializes the object with the list of strings \`words\` and the string \`target\`. def countConcatenations(self) -> int: Returns the number of strings in \`words\` that are a concatenation of \`target\`. >>> solution = Solution([\\"abcabc\\", \\"abcdabc\\", \\"abcabcabc\\"], \\"abc\\") >>> solution.countConcatenations() 2 >>> solution = Solution([\\"abcd\\", \\"def\\", \\"ghijk\\"], \\"abc\\") >>> solution.countConcatenations() 0 >>> solution = Solution([\\"aaa\\", \\"aaaaaa\\", \\"aaaa\\"], \\"a\\") >>> solution.countConcatenations() 3 >>> solution = Solution([], \\"abc\\") >>> solution.countConcatenations() 0 >>> solution = Solution([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"], \\"a\\") >>> solution.countConcatenations() 4","solution":"class Solution: def __init__(self, words, target): self.words = words self.target = target def countConcatenations(self): count = 0 target_len = len(self.target) for word in self.words: if len(word) % target_len == 0 and word == self.target * (len(word) // target_len): count += 1 return count"},{"question":"from typing import List import math def count_subarrays_with_gcd_at_least_k(arr: List[int], k: int) -> int: Compute the number of continuous subarrays where the greatest common divisor (GCD) of all the elements in the subarray is greater than or equal to \`k\`. >>> count_subarrays_with_gcd_at_least_k([4, 6, 8, 2], 2) 10 >>> count_subarrays_with_gcd_at_least_k([7], 2) 1 >>> count_subarrays_with_gcd_at_least_k([1, 1, 1], 2) 0 >>> count_subarrays_with_gcd_at_least_k([6, 8, 10], 2) 6 >>> count_subarrays_with_gcd_at_least_k([3, 6, 9, 12], 3) 10","solution":"import math from typing import List def gcd_of_list(numbers: List[int]) -> int: return math.gcd(*numbers) def count_subarrays_with_gcd_at_least_k(arr: List[int], k: int) -> int: n = len(arr) count = 0 for i in range(n): current_gcd = 0 for j in range(i, n): current_gcd = math.gcd(current_gcd, arr[j]) if current_gcd < k: break count += 1 return count"},{"question":"def remove_digit_to_maximize(s: str) -> str: Remove exactly one digit from the string s so that the resulting string represents the largest possible integer. Parameters: s (str): A string representing a positive integer. Returns: str: The resulting string after removing one digit to form the largest possible integer. >>> remove_digit_to_maximize(\\"123\\") '23' >>> remove_digit_to_maximize(\\"100\\") '10' >>> remove_digit_to_maximize(\\"4321\\") '432' >>> remove_digit_to_maximize(\\"10001\\") '1001' >>> remove_digit_to_maximize(\\"981\\") '98' >>> remove_digit_to_maximize(\\"9\\") '' >>> remove_digit_to_maximize(\\"21\\") '2' >>> remove_digit_to_maximize(\\"123456789\\") '23456789'","solution":"def remove_digit_to_maximize(s): Remove exactly one digit from the string s so that the resulting string represents the largest possible integer. Parameters: s (str): A string representing a positive integer. Returns: str: The resulting string after removing one digit to form the largest possible integer. n = len(s) for i in range(n-1): if s[i] < s[i+1]: # Remove the digit at index i return s[:i] + s[i+1:] # If no such condition found, remove the last digit return s[:-1]"},{"question":"def minSubArrayLen(target: int, arr: List[int]) -> int: Finds the length of the smallest contiguous subarray whose sum is greater than or equal to \`target\`. Args: target (int): The target sum the subarray should meet or exceed. arr (List[int]): The list of integers. Returns: int: The length of the smallest contiguous subarray whose sum is greater than or equal to \`target\`, or 0 if no such subarray exists. Examples: >>> minSubArrayLen(7, [2, 3, 1, 2, 4, 3]) 2 >>> minSubArrayLen(5, [1, 1, 1, 1]) 0 >>> minSubArrayLen(10, [1, 2, 3, 4]) 4 >>> minSubArrayLen(3, [1, 2, 3, 4]) 1 >>> minSubArrayLen(15, [1, 2, 3, 4, 5, 6]) 3 >>> minSubArrayLen(9, [2, 1, 6, 5, 4]) 2","solution":"def minSubArrayLen(target, arr): Finds the length of the smallest contiguous subarray whose sum is greater than or equal to \`target\`. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right self.prev = None self.next = None def tree_to_doubly_list(root: 'Node') -> 'Node': Given the root of a binary search tree (BST), convert it to a sorted doubly linked list in-place. The nodes in the double linked list should follow the same order as an in-order traversal of the BST. Return the head node of the doubly linked list. from solution import Node, tree_to_doubly_list def test_tree_to_doubly_list_one_node(): root = Node(1) head = tree_to_doubly_list(root) assert head.val == 1 assert head.next == head assert head.prev == head def test_tree_to_doubly_list_simple_tree(): root = Node(2) root.left = Node(1) root.right = Node(3) head = tree_to_doubly_list(root) assert head.val == 1 assert head.next.val == 2 assert head.next.next.val == 3 assert head.next.next.next == head assert head.prev.val == 3 assert head.prev.prev.val == 2 def test_tree_to_doubly_list_complex_tree(): root = Node(4) root.left = Node(2) root.right = Node(5) root.left.left = Node(1) root.left.right = Node(3) head = tree_to_doubly_list(root) values = [] current = head for _ in range(5): values.append(current.val) current = current.next assert values == [1, 2, 3, 4, 5] def test_tree_to_doubly_list_empty_tree(): head = tree_to_doubly_list(None) assert head is None","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right self.prev = None self.next = None def tree_to_doubly_list(root): Converts a BST to a sorted doubly linked list in-place. if not root: return None head = None prev = None def inorder(node): nonlocal head, prev if not node: return inorder(node.left) if prev: prev.next = node node.prev = prev else: head = node prev = node inorder(node.right) inorder(root) head.prev = prev prev.next = head return head"},{"question":"def min_sum_of_diffs(coins): Returns the minimum sum of differences between consecutive elements after rearranging the coins in non-decreasing order. >>> min_sum_of_diffs([10]) 0 >>> min_sum_of_diffs([10, 20]) 10 >>> min_sum_of_diffs([30, 10, 20]) 20 >>> min_sum_of_diffs([1, 2, 3, 4, 5]) 4 >>> min_sum_of_diffs([9, 7, 5, 3]) 6 >>> min_sum_of_diffs([5, 1, 3, 2, 4]) 4","solution":"def min_sum_of_diffs(coins): Returns the minimum sum of differences between consecutive elements after rearranging the coins in non-decreasing order. coins.sort() min_sum_diff = sum(coins[i + 1] - coins[i] for i in range(len(coins) - 1)) return min_sum_diff"},{"question":"def longest_subarray_with_one_flip(s: str) -> int: Returns the length of the longest contiguous subarray of '1's that can be achieved by performing at most one flip from '0' to '1'. >>> longest_subarray_with_one_flip('11111') == 5 >>> longest_subarray_with_one_flip('110111') == 6 >>> longest_subarray_with_one_flip('110110111') == 6 >>> longest_subarray_with_one_flip('011110') == 5 >>> longest_subarray_with_one_flip('1010101') == 3 >>> longest_subarray_with_one_flip('0000') == 1 >>> longest_subarray_with_one_flip('') == 0","solution":"def longest_subarray_with_one_flip(s): Returns the length of the longest contiguous subarray of '1's that can be achieved by performing at most one flip from '0' to '1'. # Split the string around '0' to get lengths of contiguous '1's segments segments = s.split('0') # Maximum length of contiguous '1's without any flip max_len = max(map(len, segments), default=0) # Iterate to find the maximum length with one flip for i in range(1, len(segments)): flip_length = len(segments[i - 1]) + len(segments[i]) + 1 if flip_length > max_len: max_len = flip_length return max_len"},{"question":"def full_justify(words: List[str], maxWidth: int) -> List[str]: Arrange a list of words into a fully justified text format. Each line must be exactly maxWidth characters long, with the exception of the last line which should be left-justified. Args: words : List[str] : List of words to be justified maxWidth : int : Maximum width of each line Returns: List[str] : List of fully justified lines Examples: >>> full_justify([\\"example\\"], 10) [\\"example \\"] >>> full_justify([\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], 16) [\\"This is an\\", \\"example of text\\", \\"justification. \\"] >>> full_justify([\\"What\\", \\"must\\", \\"be\\", \\"acknowledgment\\", \\"shall\\", \\"be\\"], 16) [\\"What must be\\", \\"acknowledgment \\", \\"shall be \\"] >>> full_justify([\\"Science\\", \\"is\\", \\"what\\", \\"we\\", \\"understand\\", \\"well\\", \\"enough\\", \\"to\\", \\"explain\\", \\"to\\", \\"a\\", \\"computer.\\", \\"Art\\", \\"is\\", \\"everything\\", \\"else\\", \\"we\\", \\"do\\"], 20) [\\"Science is what we\\", \\"understand well\\", \\"enough to explain to\\", \\"a computer. Art is\\", \\"everything else we\\", \\"do \\"]","solution":"def fullJustify(words, maxWidth): def justifyLine(line, lineLength, maxWidth, isLastLine=False): if len(line) == 1 or isLastLine: return ' '.join(line).ljust(maxWidth) totalSpaces = maxWidth - lineLength minSpaces = totalSpaces // (len(line) - 1) extraSpaces = totalSpaces % (len(line) - 1) for i in range(extraSpaces): line[i] += ' ' return (' ' * minSpaces).join(line) result = [] currentLine = [] currentLineLength = 0 for word in words: if currentLineLength + len(word) + len(currentLine) > maxWidth: result.append(justifyLine(currentLine, currentLineLength, maxWidth)) currentLine = [] currentLineLength = 0 currentLine.append(word) currentLineLength += len(word) result.append(justifyLine(currentLine, currentLineLength, maxWidth, isLastLine=True)) return result"},{"question":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def zigzagLevelOrder(root): You are given a binary tree with \`n\` nodes. Each node in the tree has a unique value. You need to find the level order traversal of the tree but with a twist. For each level of the tree, return the values of the nodes in zigzag order (i.e., left to right, then right to left for the next level and alternate between). Return a list of lists where each list contains the values of nodes at that level in the required order. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[3], [20, 9], [15, 7]] >>> root = TreeNode(1) >>> zigzagLevelOrder(root) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[1], [3, 2], [4, 5, 6, 7]] >>> root = None >>> zigzagLevelOrder(root) [] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> zigzagLevelOrder(root) [[1], [2], [3]] >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(1) >>> root.right.left = TreeNode(7) >>> root.right.right = TreeNode(9) >>> zigzagLevelOrder(root) [[5], [8, 3], [1, 7, 9]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> zigzagLevelOrder(root) [[1], [2]]","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def zigzagLevelOrder(root): if not root: return [] results = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) current_level = deque() for _ in range(level_size): node = node_queue.popleft() if left_to_right: current_level.append(node.value) else: current_level.appendleft(node.value) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) results.append(list(current_level)) left_to_right = not left_to_right return results"},{"question":"def minimizeMaxWorkload(tasks: List[int], k: int) -> int: Returns the minimum possible value of the maximum workload of any worker after all tasks have been assigned. >>> minimizeMaxWorkload([10, 20, 30, 40], 2) 60 >>> minimizeMaxWorkload([1, 2, 3, 4, 5], 2) 9 >>> minimizeMaxWorkload([10, 20, 30, 40], 3) 40 >>> minimizeMaxWorkload([15], 1) 15 >>> minimizeMaxWorkload([10, 20, 30, 40], 5) 40 >>> minimizeMaxWorkload([10, 10, 10, 10], 2) 20 >>> minimizeMaxWorkload([4, 8, 15, 16, 23, 42], 3) 42 pass","solution":"def canDistributeWithinMax(tasks, k, maxWorkload): Helper function to determine if it's possible to distribute all tasks among k workers without any worker exceeding the specified max workload. currentSum = 0 requiredWorkers = 1 for task in tasks: if currentSum + task > maxWorkload: requiredWorkers += 1 currentSum = task if requiredWorkers > k: return False else: currentSum += task return True def minimizeMaxWorkload(tasks, k): Returns the minimum possible value of the maximum workload of any worker after all tasks have been assigned. if len(tasks) <= k: return max(tasks) left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if canDistributeWithinMax(tasks, k, mid): right = mid else: left = mid + 1 return left"},{"question":"def longest_valid_subarray(arr: List[int], d: int) -> int: Returns the length of the longest valid subarray where the absolute difference between any two elements is at most d. >>> longest_valid_subarray([1, 1, 1, 1], 0) == 4 >>> longest_valid_subarray([1, 2, 3, 4], 1) == 4 >>> longest_valid_subarray([1, 3, 5, 7], 2) == 4 >>> longest_valid_subarray([1, 5, 9, 13], 2) == 1 >>> longest_valid_subarray([4, 2, 2, 2, 4, 5, 5, 5], 3) == 8 >>> longest_valid_subarray([1, 2, 3, 8, 9, 10], 1) == 3 >>> longest_valid_subarray([], 1) == 0 >>> longest_valid_subarray([1], 1) == 1","solution":"def longest_valid_subarray(arr, d): Returns the length of the longest valid subarray where the absolute difference between any two elements is at most d. n = len(arr) if n == 0: return 0 start = 0 max_len = 1 for end in range(1, n): if abs(arr[end] - arr[end - 1]) <= d: max_len = max(max_len, end - start + 1) else: start = end return max_len"},{"question":"def num_surrounded_lakes(grid: List[List[int]]) -> int: Count the number of surrounded lakes in the grid. >>> num_surrounded_lakes([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0 >>> num_surrounded_lakes([[1, 0, 1], [1, 1, 1], [1, 0, 1]]) == 0 >>> num_surrounded_lakes([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) == 1 >>> num_surrounded_lakes([[1, 1, 1, 1], [1, 0, 1, 0], [1, 1, 1, 1], [1, 0, 1, 1]]) == 1 >>> num_surrounded_lakes([[1, 1, 1, 1, 1], [1, 0, 0, 1, 1], [1, 1, 1, 0, 1], [0, 1, 1, 0, 1], [1, 1, 1, 1, 1]]) == 2","solution":"def num_surrounded_lakes(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Function to perform a DFS to mark all connected 0s starting from (i, j) def dfs(i, j): stack = [(i, j)] while stack: x, y = stack.pop() if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == 0: grid[x][y] = '#' stack.append((x + 1, y)) stack.append((x - 1, y)) stack.append((x, y + 1)) stack.append((x, y - 1)) # First, mark all lakes connected to the boundary for i in range(m): if grid[i][0] == 0: dfs(i, 0) if grid[i][n - 1] == 0: dfs(i, n - 1) for j in range(n): if grid[0][j] == 0: dfs(0, j) if grid[m - 1][j] == 0: dfs(m - 1, j) # Now, count the remaining surrounded lakes surrounded_lakes_count = 0 for i in range(1, m - 1): for j in range(1, n - 1): if grid[i][j] == 0: surrounded_lakes_count += 1 dfs(i, j) return surrounded_lakes_count"},{"question":"def max_subset_sum(nums: List[int], k: int) -> int: Returns the maximum possible sum of a subset whose length is at least k. Parameters: nums (List[int]): List of integers. k (int): Minimum length of the subset. Returns: int: Maximum possible sum of a subset with length at least k. >>> max_subset_sum([1, 2, 3, 4, 5], 2) 15 >>> max_subset_sum([10, -1, 2, 3, -4, 5], 6) 15 >>> max_subset_sum([5, -2, 7, 1, -3], 3) 11 >>> max_subset_sum([1, 2, 3], 3) 6 >>> max_subset_sum([-5, -1, -8, -9], 1) -1 >>> max_subset_sum([1, -2, 3, -1, 2, 1], 3) 5 >>> max_subset_sum([5], 1) 5 >>> max_subset_sum([2, 3, 5, 7], 2) 17","solution":"def max_subset_sum(nums, k): Returns the maximum possible sum of a subset whose length is at least k. Parameters: nums (List[int]): List of integers. k (int): Minimum length of the subset. Returns: int: Maximum possible sum of a subset with length at least k. n = len(nums) # We will use a prefix sum array to store sums of subarrays. prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + nums[i] # Initialize a variable for the maximum possible sum with float negative infinite. max_sum = float('-inf') # Calculate the maximum sum of subsets with length at least k. for length in range(k, n + 1): for start in range(n - length + 1): subset_sum = prefix_sums[start + length] - prefix_sums[start] if subset_sum > max_sum: max_sum = subset_sum return max_sum"},{"question":"def max_subarray_sum_circular(nums: List[int]) -> int: Returns the maximum possible sum of a non-empty subarray in a circular integer array. >>> max_subarray_sum_circular([1, -2, 3, -2]) 3 >>> max_subarray_sum_circular([5, -3, 5]) 10 >>> max_subarray_sum_circular([3, -1, 2, -1]) 4 >>> max_subarray_sum_circular([3, -2, 2, -3]) 3 >>> max_subarray_sum_circular([-2, -3, -1]) -1 >>> max_subarray_sum_circular([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 55 >>> max_subarray_sum_circular([10, -3, -4, 7, 6, 5, -4, -1]) 23","solution":"def max_subarray_sum_circular(nums): Returns the maximum possible sum of a non-empty subarray in a circular integer array. # Helper function to find the maximum sum of a non-circular subarray def kadane(nums): max_ending_here = max_so_far = nums[0] for x in nums[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far total = sum(nums) max_kadane = kadane(nums) # Find the minimum sum of a non-circular subarray for i in range(len(nums)): nums[i] = -nums[i] max_kadane_negated = kadane(nums) max_wrap = total + max_kadane_negated # max subarray sum for the wrapped array if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"from typing import List def smallest_subarray_with_sum(nums: List[int], target: int) -> int: Given an array of integers \`nums\` and an integer \`target\`, return the smallest window (subarray) in which the sum of its elements is greater than or equal to \`target\`. If there is no such subarray, return \`0\`. Note that the elements in the window should be contiguous. >>> smallest_subarray_with_sum([2, 3, 1, 2, 4, 3], 7) 2 >>> smallest_subarray_with_sum([1, 1, 1, 1, 1, 1, 1], 10) 0 >>> smallest_subarray_with_sum([5, 1, 2, 3, 5], 5) 1 >>> smallest_subarray_with_sum([1]*10000 + [5], 5) 1 >>> smallest_subarray_with_sum([1, 2, 3, 4], 10) 4 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 9) 2 >>> smallest_subarray_with_sum([4], 4) 1 >>> smallest_subarray_with_sum([3], 4) 0 >>> smallest_subarray_with_sum([5, 4, 3, 2, 1], 11) 3 >>> smallest_subarray_with_sum([], 1) 0","solution":"def smallest_subarray_with_sum(nums, target): Returns the length of the smallest contiguous subarray of which the sum >= target. If no such subarray exists, return 0. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 if min_length == float('inf'): return 0 return min_length"},{"question":"def make_shortest_palindrome(s: str) -> int: Given a string \`s\`, return the length of the shortest palindrome you can create by appending characters to the end of the string. A palindrome is defined as a string that reads the same forwards and backwards. >>> make_shortest_palindrome(\\"\\") 0 >>> make_shortest_palindrome(\\"a\\") 1 >>> make_shortest_palindrome(\\"racecar\\") 7 >>> make_shortest_palindrome(\\"race\\") 7 >>> make_shortest_palindrome(\\"ab\\") 3 >>> make_shortest_palindrome(\\"aacecaaa\\") 9 >>> make_shortest_palindrome(\\"abcd\\") 7","solution":"def shortest_palindrome_length(s): Returns the length of the shortest palindrome that can be created by appending characters to the end of the string. # Find the longest palindromic prefix n = len(s) rev_s = s[::-1] for i in range(n): if s.startswith(rev_s[i:]): # If s starts with the suffix of the reversed string, # then the remaining part needs to be appended to make it a palindrome return 2 * n - len(rev_s[i:]) return n # For an empty input # Adding function to get the length of the shortest palindrome def make_shortest_palindrome(s): Returns the length of the shortest palindrome that can be created by appending characters to the end of the string. return shortest_palindrome_length(s)"},{"question":"class TreeNode: Definition for a binary tree node. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root): Find the length of the diameter of the binary tree. from solution import TreeNode, diameter_of_binary_tree def test_empty_tree(): assert diameter_of_binary_tree(None) == 0 def test_single_node_tree(): root = TreeNode(1) assert diameter_of_binary_tree(root) == 0 def test_balanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert diameter_of_binary_tree(root) == 4 def test_right_heavy_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert diameter_of_binary_tree(root) == 3 def test_left_heavy_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert diameter_of_binary_tree(root) == 3 def test_unbalanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) root.right = TreeNode(5) root.right.right = TreeNode(6) assert diameter_of_binary_tree(root) == 5","solution":"class TreeNode: Definition for a binary tree node. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root): Find the length of the diameter of the binary tree. diameter = [0] def depth(node): if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter[0] = max(diameter[0], left_depth + right_depth) return max(left_depth, right_depth) + 1 depth(root) return diameter[0]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def isSameTree(self, p, q): Write a function to check if two binary trees are identical or not. Args: p (TreeNode): The root node of the first binary tree. q (TreeNode): The root node of the second binary tree. Returns: bool: True if the trees are identical, False otherwise. Examples: >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> tree1.right = TreeNode(3) >>> tree2 = TreeNode(1) >>> tree2.left = TreeNode(2) >>> tree2.right = TreeNode(3) >>> solution = Solution() >>> solution.isSameTree(tree1, tree2) True >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> tree2 = TreeNode(1) >>> tree2.right = TreeNode(2) >>> solution = Solution() >>> solution.isSameTree(tree1, tree2) False >>> tree1 = TreeNode(1) >>> tree2 = None >>> solution = Solution() >>> solution.isSameTree(tree1, tree2) False >>> tree1 = None >>> tree2 = None >>> solution = Solution() >>> solution.isSameTree(tree1, tree2) True","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def isSameTree(self, p, q): if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"},{"question":"def count_viewable_buildings(arr): Returns the number of buildings that can be viewed. Args: arr: List[int] - List of building heights observed on each day. Returns: int - Number of viewable buildings. >>> count_viewable_buildings([]) 0 >>> count_viewable_buildings([10]) 1 >>> count_viewable_buildings([1, 2, 3, 4]) 4 >>> count_viewable_buildings([4, 3, 2, 1]) 1 >>> count_viewable_buildings([3, 1, 4, 2, 5]) 3 >>> count_viewable_buildings([4, 4, 4, 4]) 1","solution":"def count_viewable_buildings(arr): Returns the number of buildings that can be viewed. Args: arr: List[int] - List of building heights observed on each day. Returns: int - Number of viewable buildings. if not arr: return 0 viewable_count = 1 # The first building is always viewable max_height = arr[0] for height in arr[1:]: if height > max_height: viewable_count += 1 max_height = height return viewable_count"},{"question":"def find_height_of_binary_tree(parent: List[int]) -> int: Finds the height of a binary tree given a list of parent-child relationships. :param parent: List of integers where the index represents the node and value represents the parent node. :return: Integer, height of the binary tree >>> find_height_of_binary_tree([-1, 0, 0, 1, 1, 2, 2]) 2 >>> find_height_of_binary_tree([-1]) 0 >>> find_height_of_binary_tree([-1, 0, 0, 0, 0]) 1 >>> find_height_of_binary_tree([-1, 0, 0, 1, 1, 2, 2, 3, 3, 6, 6]) 3 >>> find_height_of_binary_tree([]) 0 >>> find_height_of_binary_tree([-1, 0, 1, 2, 3, 4]) 5","solution":"def find_height_of_binary_tree(parent): Finds the height of a binary tree given a list of parent-child relationships. :param parent: List of integers where the index represents the node and value represents the parent node. :return: Integer, height of the binary tree if not parent: return 0 def get_depth(node): depth = 0 while parent[node] != -1: node = parent[node] depth += 1 return depth max_height = 0 for i in range(len(parent)): max_height = max(max_height, get_depth(i)) return max_height"},{"question":"def rob(nums): Returns the maximum amount of money that can be robbed, considering the houses are arranged in a circle. >>> rob([50]) == 50 >>> rob([20, 30]) == 30 >>> rob([2, 3, 2]) == 3 >>> rob([2, 7, 9, 3, 1]) == 11 >>> rob([100, 200, 300, 100, 200]) == 500 >>> rob([]) == 0 >>> rob([0, 0, 0, 0]) == 0","solution":"def rob(nums): Returns the maximum amount of money that can be robbed, considering the houses are arranged in a circle. if len(nums) == 1: return nums[0] def rob_linear(houses): Helper function to calculate the maximum amount that can be robbed from a linear arrangement of houses. prev = curr = 0 for amount in houses: prev, curr = curr, max(curr, prev + amount) return curr return max(rob_linear(nums[1:]), rob_linear(nums[:-1]))"},{"question":"def min_bridges_needed(arr: List[int]) -> int: Returns the minimum number of bridges needed to connect all the separate land masses. Each 1 represents land and each 0 represents water. >>> min_bridges_needed([0, 0, 0, 0]) == 0 >>> min_bridges_needed([1, 1, 1, 1]) == 0 >>> min_bridges_needed([1]) == 0 >>> min_bridges_needed([1, 0, 1]) == 1 >>> min_bridges_needed([1, 0, 1, 0, 1, 0, 1]) == 3 >>> min_bridges_needed([1, 0, 0, 1, 0, 1, 0, 0, 1]) == 3 >>> min_bridges_needed([0, 0, 1, 0, 1, 0, 0]) == 1 >>> min_bridges_needed([0]) == 0 >>> min_bridges_needed([0, 1, 0]) == 0","solution":"def min_bridges_needed(arr): Returns the minimum number of bridges needed to connect all the separate land masses. Each 1 represents land and each 0 represents water. if arr.count(1) == 0: return 0 land_groups = 0 length = len(arr) i = 0 while i < length: if arr[i] == 1: land_groups += 1 while i < length and arr[i] == 1: i += 1 i += 1 if land_groups <= 1: return 0 else: return land_groups - 1"},{"question":"def count_pairs(arr, k): Count the number of pairs (i, j) where i < j such that arr[i] * arr[j] == k. Parameters: arr (list): A list of integers. k (int): The product threshold. Returns: int: The count of pairs (i, j) where i < j and arr[i] * arr[j] == k. >>> count_pairs([1, 2, 3], 10) == 0 >>> count_pairs([1, 2, 3, 4], 8) == 1 >>> count_pairs([1, 2, 3, 2, 4], 8) == 2 >>> count_pairs([0, 1, 2, 3], 0) == 3 >>> count_pairs([10, 5, 2], 50) == 1 >>> count_pairs([-1, -2, 1, 2], 2) == 2 >>> count_pairs([-1, 2, -3, 6], -6) == 2","solution":"def count_pairs(arr, k): Count the number of pairs (i, j) where i < j such that arr[i] * arr[j] == k. Parameters: arr (list): A list of integers. k (int): The product threshold. Returns: int: The count of pairs (i, j) where i < j and arr[i] * arr[j] == k. count = 0 n = len(arr) for i in range(n): for j in range(i+1, n): if arr[i] * arr[j] == k: count += 1 return count"},{"question":"def find_peaks(heights: List[int]) -> int: Returns the number of indices \`i\` such that \`heights[i]\` is strictly greater than all the heights to its left and right. >>> find_peaks([1, 3, 2]) == 1 >>> find_peaks([1, 2, 3, 1, 5, 6, 4]) == 2 >>> find_peaks([1, 2, 3, 4, 5]) == 0 >>> find_peaks([1, 2, 2, 1]) == 0 >>> find_peaks([3, 2, 1, 2, 3, 2]) == 1","solution":"def find_peaks(heights): Returns the number of indices \`i\` such that \`heights[i]\` is strictly greater than all the heights to its left and right. :param heights: List of integers representing the heights of people. :return: Integer count of peaks if len(heights) < 3: return 0 peak_count = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peak_count += 1 return peak_count"},{"question":"from typing import List def find_indices(nums: List[int], target: int) -> List[int]: You are given an integer array \`nums\` and an integer \`target\`. You need to find two distinct indices \`i\` and \`j\` in the array such that \`nums[i] + nums[j] == target\`. Return a list containing the two indices [i, j]. The returned list should be sorted in ascending order. If no such pair exists, return an empty list. >>> find_indices([2, 7, 11, 15], 9) [0, 1] >>> find_indices([1, 2, 3, 4], 8) [] >>> find_indices([1, 2, 3, 4, 4], 8) [3, 4] >>> find_indices([-3, 4, 3, 90], 0) [0, 2] >>> find_indices([-1, -2, -3, -4], -6) [1, 3] >>> find_indices([0, 4, 3, 0], 0) [0, 3]","solution":"from typing import List def find_indices(nums: List[int], target: int) -> List[int]: Finds two distinct indices i and j such that nums[i] + nums[j] == target. Returns a list of the indices sorted in ascending order. If no such pair exists, returns an empty list. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return sorted([seen[complement], i]) seen[num] = i return []"},{"question":"from typing import List, Tuple def valid_permutation(n: int, triplets: List[Tuple[int, int, int]]) -> bool: Determines if there exists a permutation of the array 1 to n such that for each triplet (a, b, c), the value at position a is less than the value at position b and the value at position b is less than the value at position c. Parameters: n (int): The integer n triplets (list of tuple): List of triplets where each triplet is a tuple (a, b, c) Returns: bool: True if such a permutation exists, otherwise false >>> valid_permutation(4, [(1, 2, 3), (2, 3, 4)]) True >>> valid_permutation(3, [(1, 2, 3), (1, 3, 2)]) False >>> valid_permutation(4, [(1, 2, 3), (3, 4, 2)]) False >>> valid_permutation(5, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) True >>> valid_permutation(2, [(1, 2, 1)]) False pass","solution":"from itertools import permutations def valid_permutation(n, triplets): Determines if there exists a permutation of the array 1 to n such that for each triplet (a, b, c), the value at position a is less than the value at position b and the value at position b is less than the value at position c. Parameters: n (int): The integer n triplets (list of tuple): List of triplets where each triplet is a tuple (a, b, c) Returns: bool: True if such a permutation exists, otherwise false # Generate all possible permutations of the array 1 to n for perm in permutations(range(1, n + 1)): # For each permutation, check if it satisfies all triplets if all(perm[a - 1] < perm[b - 1] < perm[c - 1] for a, b, c in triplets): return True # If no permutation satisfies all triplets, return False return False"},{"question":"def max_subarray_with_k_distinct(nums: List[int], k: int) -> int: Return the maximum value of a subarray with at most \`k\` distinct elements. >>> max_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 6 >>> max_subarray_with_k_distinct([1], 1) 1 >>> max_subarray_with_k_distinct([2, 2, 2, 2], 1) 8 >>> max_subarray_with_k_distinct([1, 2, 3, 4], 4) 10 >>> max_subarray_with_k_distinct([5, 3, 9, 7], 0) 0","solution":"def max_subarray_with_k_distinct(nums, k): from collections import defaultdict n = len(nums) if k == 0: return 0 char_map = defaultdict(int) left = 0 right = 0 max_sum, current_sum = 0, 0 while right < n: char_map[nums[right]] += 1 current_sum += nums[right] while len(char_map) > k: char_map[nums[left]] -= 1 if char_map[nums[left]] == 0: del char_map[nums[left]] current_sum -= nums[left] left += 1 max_sum = max(max_sum, current_sum) right += 1 return max_sum"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_good_nodes(root: TreeNode) -> int: Counts the number of good nodes (nodes with value 1) in the binary tree. >>> root = TreeNode(1) >>> count_good_nodes(root) 1 >>> root = TreeNode(0) >>> count_good_nodes(root) 0 >>> root = TreeNode(1, TreeNode(0), TreeNode(1)) >>> count_good_nodes(root) 2 >>> root = TreeNode(1, TreeNode(1), TreeNode(1)) >>> count_good_nodes(root) 3 >>> root = TreeNode(0, TreeNode(0), TreeNode(0)) >>> count_good_nodes(root) 0 >>> root = TreeNode(1, ... TreeNode(0, TreeNode(1), TreeNode(0)), ... TreeNode(1, TreeNode(0), TreeNode(1))) >>> count_good_nodes(root) 4","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_good_nodes(root): Counts the number of good nodes (nodes with value 1) in the binary tree. if not root: return 0 count = 1 if root.value == 1 else 0 return count + count_good_nodes(root.left) + count_good_nodes(root.right)"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Calculate the largest rectangular area in a histogram. :param heights: List[int] - list of integers representing the heights of buildings :return: int - the maximum rectangular area in the histogram pass # Unit tests def test_single_bar(): assert largestRectangleArea([5]) == 5 def test_all_equal_heights(): assert largestRectangleArea([2, 2, 2, 2, 2]) == 10 def test_varying_heights(): assert largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 def test_increasing_heights(): assert largestRectangleArea([1, 2, 3, 4, 5]) == 9 def test_decreasing_heights(): assert largestRectangleArea([5, 4, 3, 2, 1]) == 9 def test_empty_array(): assert largestRectangleArea([]) == 0 def test_two_heights(): assert largestRectangleArea([2, 4]) == 4","solution":"def largestRectangleArea(heights): Calculate the largest rectangular area in a histogram. :param heights: List[int] - list of integers representing the heights of buildings :return: int - the maximum rectangular area in the histogram stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top = stack.pop() area = (heights[top] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top = stack.pop() area = (heights[top] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rotate_right(head, k): Rotate the linked list to the right by k places. :param head: ListNode, the head of the linked list :param k: int, number of places to rotate :return: ListNode, the rotated linked list pass # Example unit test def list_to_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(head): lst = [] while head: lst.append(head.value) head = head.next return lst def test_rotate_right(): # Test case 1: Rotating a list [1, 2, 3, 4, 5] by 2 places head = list_to_linked_list([1, 2, 3, 4, 5]) rotated_head = rotate_right(head, 2) result = linked_list_to_list(rotated_head) assert result == [4, 5, 1, 2, 3] # Test case 2: Rotating a list [1, 2, 3, 4, 5] by 0 places head = list_to_linked_list([1, 2, 3, 4, 5]) rotated_head = rotate_right(head, 0) result = linked_list_to_list(rotated_head) assert result == [1, 2, 3, 4, 5] # Test case 3: Rotating a list [1, 2, 3, 4, 5] by 5 places (full length) head = list_to_linked_list([1, 2, 3, 4, 5]) rotated_head = rotate_right(head, 5) result = linked_list_to_list(rotated_head) assert result == [1, 2, 3, 4, 5] # Test case 4: Rotating a list [0, 1, 2] by 4 places head = list_to_linked_list([0, 1, 2]) rotated_head = rotate_right(head, 4) result = linked_list_to_list(rotated_head) assert result == [2, 0, 1] # Test case 5: Rotating a list [1] by 1 place head = list_to_linked_list([1]) rotated_head = rotate_right(head, 1) result = linked_list_to_list(rotated_head) assert result == [1]","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rotate_right(head, k): Rotate the linked list to the right by k places. :param head: ListNode, the head of the linked list :param k: int, number of places to rotate :return: ListNode, the rotated linked list if not head or not head.next or k == 0: return head # First, let's determine the length of the linked list length = 1 old_tail = head while old_tail.next: old_tail = old_tail.next length += 1 # Form a circular linked list old_tail.next = head # Find the new tail: (length - k % length - 1)th node # and the new head: (length - k % length)th node k = k % length new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"def min_subarray_len(arr, n, m): Returns the minimal length of any contiguous subarray that sums to at least m. If there exists no such subarray, return -1. arr: list of integers n: length of the array m: integer, the target sum >>> min_subarray_len([2, 3, 1, 2, 4, 3], 6, 7) == 2 >>> min_subarray_len([1, 4, 4], 3, 4) == 1 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 8, 11) == -1 >>> min_subarray_len([7], 1, 7) == 1 >>> min_subarray_len([7], 1, 8) == -1 >>> min_subarray_len([1, 2, 3, 4], 4, 10) == 4 >>> min_subarray_len([5, 1, 3, 5, 10, 7, 4, 9, 2, 8], 10, 15) == 2","solution":"def min_subarray_len(arr, n, m): Returns the minimal length of any contiguous subarray that sums to at least m. If there exists no such subarray, return -1. arr: list of integers n: length of the array m: integer, the target sum min_length = float('inf') current_sum = 0 start_index = 0 for end_index in range(n): current_sum += arr[end_index] while current_sum >= m: min_length = min(min_length, end_index - start_index + 1) current_sum -= arr[start_index] start_index += 1 return min_length if min_length != float('inf') else -1"},{"question":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in a sorted matrix. :param matrix: List of List of integers, the sorted matrix. :param k: Integer, the k-th position (1-indexed) to find the smallest element. :return: Integer, the k-th smallest element in the matrix. pass # Unit tests def test_single_element(): matrix = [[5]] assert kth_smallest(matrix, 1) == 5 def test_two_by_two_matrix(): matrix = [ [1, 5], [2, 6] ] assert kth_smallest(matrix, 1) == 1 assert kth_smallest(matrix, 2) == 2 assert kth_smallest(matrix, 3) == 5 assert kth_smallest(matrix, 4) == 6 def test_three_by_three_matrix(): matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] assert kth_smallest(matrix, 8) == 13 def test_large_k(): matrix = [ [1, 2], [1, 3] ] assert kth_smallest(matrix, 4) == 3","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in a sorted matrix. :param matrix: List of List of integers, the sorted matrix. :param k: Integer, the k-th position (1-indexed) to find the smallest element. :return: Integer, the k-th smallest element in the matrix. n = len(matrix) min_heap = [] for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) count = 0 result = 0 while min_heap: result, r, c = heapq.heappop(min_heap) count += 1 if count == k: break if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return result"},{"question":"from typing import List def num_clusters(grid: List[List[str]]) -> int: Given a 2D grid of size \`m x n\` where each cell represents a plot of land that can either be a farm (denoted by '1') or water (denoted by '0'), find the number of clusters of farms. A cluster is defined as a group of adjacent farms connected horizontally or vertically (not diagonally). Return the number of such clusters in the given grid. >>> num_clusters([[\\"1\\", \\"1\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"]]) 1 >>> num_clusters([[\\"1\\", \\"0\\", \\"0\\", \\"1\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\"], [\\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\"]]) 3 >>> num_clusters([[\\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"]]) 0 def test_single_cluster(): grid = [ [\\"1\\", \\"1\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"] ] assert num_clusters(grid) == 1 def test_multiple_clusters(): grid = [ [\\"1\\", \\"0\\", \\"0\\", \\"1\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\"], [\\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\"] ] assert num_clusters(grid) == 3 def test_no_clusters(): grid = [ [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"] ] assert num_clusters(grid) == 0 def test_all_clusters(): grid = [ [\\"1\\", \\"0\\"], [\\"0\\", \\"1\\"] ] assert num_clusters(grid) == 2 def test_empty_grid(): grid = [] assert num_clusters(grid) == 0 def test_single_element_grid(): grid = [[\\"1\\"]] assert num_clusters(grid) == 1 def test_single_row_grid(): grid = [[\\"1\\", \\"0\\", \\"1\\"]] assert num_clusters(grid) == 2 def test_single_column_grid(): grid = [[\\"1\\"], [\\"0\\"], [\\"1\\"]] assert num_clusters(grid) == 2","solution":"def num_clusters(grid): Returns the number of clusters of farms in the given 2D grid. A cluster is a group of horizontally or vertically adjacent '1's. if not grid: return 0 m, n = len(grid), len(grid[0]) visit = set() def dfs(x, y): Depth-first search to visit all parts of a cluster. if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '0' or (x, y) in visit: return visit.add((x, y)) dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) clusters = 0 for i in range(m): for j in range(n): if grid[i][j] == '1' and (i, j) not in visit: clusters += 1 dfs(i, j) return clusters"},{"question":"def count_incorrect_pairs(pairs): This function counts the number of incorrectly ordered pairs in the given list of pairs. A pair (a_i, b_i) is incorrectly ordered if a_i >= b_i. :param pairs: List of pairs (2D integer array) :return: Integer count of incorrectly ordered pairs pass def test_no_incorrect_pairs(): assert count_incorrect_pairs([[1, 2], [3, 4], [5, 6]]) == 0 def test_all_incorrect_pairs(): assert count_incorrect_pairs([[2, 2], [4, 3], [6, 5]]) == 3 def test_some_incorrect_pairs(): assert count_incorrect_pairs([[1, 2], [4, 3], [6, 5], [5, 5]]) == 3 def test_empty_list(): assert count_incorrect_pairs([]) == 0 def test_incorrect_order_pairs_with_duplicates(): assert count_incorrect_pairs([[3, 3], [2, 2], [1, 1], [4, 4], [5, 6]]) == 4","solution":"def count_incorrect_pairs(pairs): This function counts the number of incorrectly ordered pairs in the given list of pairs. A pair (a_i, b_i) is incorrectly ordered if a_i >= b_i. :param pairs: List of pairs (2D integer array) :return: Integer count of incorrectly ordered pairs incorrect_count = 0 for a_i, b_i in pairs: if a_i >= b_i: incorrect_count += 1 return incorrect_count"},{"question":"def max_unique_elements(nums: List[int], k: int) -> int: Given an integer array \`nums\` and an integer \`k\`, return the maximum number of unique elements in the array after performing exactly \`k\` operations. In one operation, you can remove an element from the array, or add a new element to the array. >>> max_unique_elements([1, 2, 3, 4], 0) 4 >>> max_unique_elements([1, 1, 1, 1], 3) 4 >>> max_unique_elements([1, 2, 3, 3, 3], 2) 5 >>> max_unique_elements([1, 2], 4) 6 >>> max_unique_elements([], 3) 3","solution":"def max_unique_elements(nums, k): Returns the maximum number of unique elements in the array after performing exactly k operations. :param nums: List[int], the input array of integers :param k: int, the number of operations :return: int, the maximum number of unique elements # Count the frequency of elements in nums frequency = {} for num in nums: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Determine the number of unique elements initial_unique = len(frequency) # Find out how many elements are repeated repeated_elements = len(nums) - initial_unique if repeated_elements >= k: # If the repeated elements are more than or equal to k, we can convert k repeated elements to unique return initial_unique + k # Otherwise, we can convert all the repeated elements to unique # and use remaining operations to add new unique elements remaining_k = k - repeated_elements # The initial unique elements + all the repeated elements made unique + remaining additions return initial_unique + repeated_elements + remaining_k"},{"question":"def trap_water(arr): Returns the total amount of water trapped given the heights of the bars. >>> trap_water([]) == 0 >>> trap_water([1, 1, 1, 1]) == 0 >>> trap_water([4, 1, 1, 1, 4]) == 9 >>> trap_water([2, 0, 2]) == 2 >>> trap_water([3, 0, 1, 2, 1, 2]) == 4 >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_water([1, 2, 3, 4, 5]) == 0 >>> trap_water([5, 4, 3, 2, 1]) == 0","solution":"def trap_water(arr): Returns the total amount of water trapped given the heights of the bars. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n # Fill left_max left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) # Fill right_max right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - arr[i] return trapped_water"},{"question":"def even_odd_index_difference(nums: List[int]) -> int: Returns the sum of the elements at even indices minus the sum of the elements at odd indices. Parameters: nums (list): A list of integers. Returns: int: The difference as described. >>> even_odd_index_difference([1, 2, 3, 4, 5]) == 3 >>> even_odd_index_difference([2, 4, 6, 8]) == -4 >>> even_odd_index_difference([3, 3, 3]) == 3 >>> even_odd_index_difference([10, 20, 30, 40, 50, 60]) == -30 >>> even_odd_index_difference([7]) == 7 >>> even_odd_index_difference([]) == 0 >>> even_odd_index_difference([1000, 2000, 3000, 4000, 5000]) == 3000","solution":"def even_odd_index_difference(nums): Returns the sum of the elements at even indices minus the sum of the elements at odd indices. Parameters: nums (list): A list of integers. Returns: int: The difference as described. even_sum = 0 odd_sum = 0 for i in range(len(nums)): if i % 2 == 0: even_sum += nums[i] else: odd_sum += nums[i] return even_sum - odd_sum"},{"question":"class User: A class to represent a user in a simple social media platform which tracks followers. Attributes: name (str): the name of the user followers (set): a set to store followers of the user following (set): a set to store users this user is following def __init__(self, name: str): Initializes a user with the given name and zero followers and following users. pass def follow(self, other_user): Adds a follower to the current user, where \`other_user\` is an instance of User. pass def unfollow(self, other_user): Removes a follower from the current user if \`other_user\` is currently a follower. pass def count_followers(self) -> int: Returns the number of followers the user has. pass def check_if_following(self, other_user) -> bool: Returns \`True\` if the current user is following \`other_user\`, otherwise \`False\`. pass def test_user_initialization(): user = User(\\"Alice\\") assert user.name == \\"Alice\\" assert user.count_followers() == 0 assert len(user.following) == 0 def test_follow_user(): user1 = User(\\"Alice\\") user2 = User(\\"Bob\\") user1.follow(user2) assert user2.count_followers() == 1 assert user1.check_if_following(user2) assert user2.check_if_following(user1) == False def test_unfollow_user(): user1 = User(\\"Alice\\") user2 = User(\\"Bob\\") user1.follow(user2) user1.unfollow(user2) assert user2.count_followers() == 0 assert user1.check_if_following(user2) == False def test_count_followers(): user1 = User(\\"Alice\\") user2 = User(\\"Bob\\") user3 = User(\\"Charlie\\") user2.follow(user1) user3.follow(user1) assert user1.count_followers() == 2 def test_check_if_following(): user1 = User(\\"Alice\\") user2 = User(\\"Bob\\") user1.follow(user2) assert user1.check_if_following(user2) == True assert user2.check_if_following(user1) == False user1.unfollow(user2) assert user1.check_if_following(user2) == False","solution":"class User: def __init__(self, name): Initializes a user with the given name and zero followers. self.name = name self.followers = set() self.following = set() def follow(self, other_user): Adds a follower to the current user, where \`other_user\` is an instance of User. if other_user not in self.following: self.following.add(other_user) other_user.followers.add(self) def unfollow(self, other_user): Removes a follower from the current user if \`other_user\` is currently a follower. if other_user in self.following: self.following.remove(other_user) other_user.followers.remove(self) def count_followers(self): Returns the number of followers the user has. return len(self.followers) def check_if_following(self, other_user): Returns \`True\` if the current user is following \`other_user\`, otherwise \`False\`. return other_user in self.following"},{"question":"def shortest_path(n: int, obstacles: List[List[int]]) -> int: Returns the length of the shortest path for the robot to reach the bottom-right corner. If there is no possible path, return -1. >>> shortest_path(3, []) == 4 >>> shortest_path(2, []) == 2 >>> shortest_path(3, [[1, 1]]) == 4 >>> shortest_path(3, [[1, 0], [0, 1]]) == -1 >>> shortest_path(5, [[1, 2], [2, 2], [3, 2]]) == 8 >>> shortest_path(3, [[0, 1], [1, 0]]) == -1 >>> shortest_path(3, [[0, 0]]) == -1 >>> shortest_path(3, [[1, 0], [1, 1], [1, 2], [2, 1]]) == -1 >>> shortest_path(1, []) == 0 >>> shortest_path(1, [[0, 0]]) == -1 pass","solution":"from collections import deque def shortest_path(n, obstacles): Returns the length of the shortest path for the robot to reach the bottom-right corner. If there is no possible path, return -1. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] obstacles_set = set(map(tuple, obstacles)) visited = set([(0, 0)]) if (0, 0) in obstacles_set: return -1 queue = deque([(0, 0, 0)]) # (x, y, distance) while queue: x, y, dist = queue.popleft() if (x, y) == (n - 1, n - 1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and (nx, ny) not in obstacles_set: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def min_timespan_to_complete_tasks(nums: [int], r: int) -> int: Calculate the minimum timespan required to complete all tasks including rest periods between them. However, the rest period is skipped after the last task. Args: nums (list of int): List of integers representing the number of hours each task takes to complete. r (int): The fixed rest period in hours between two tasks. Returns: int: The total number of hours required to complete all tasks. >>> min_timespan_to_complete_tasks([], 2) 0 >>> min_timespan_to_complete_tasks([3], 2) 3 >>> min_timespan_to_complete_tasks([1, 2, 3], 2) 10 >>> min_timespan_to_complete_tasks([1, 2, 3], 0) 6 >>> min_timespan_to_complete_tasks([1, 1, 1, 1], 1) 7 >>> min_timespan_to_complete_tasks([1, 1, 1], 5) 13 pass","solution":"def min_timespan_to_complete_tasks(nums, r): Calculates the minimum timespan required to complete all tasks including rest periods. Args: nums (list of int): List of integers representing the number of hours each task takes to complete. r (int): The fixed rest period in hours between two tasks. Returns: int: The total number of hours required to complete all tasks. if not nums: return 0 total_time = sum(nums) rest_time = r * (len(nums) - 1) return total_time + rest_time"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: Removes the n-th node from the end of the list and returns its head. >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> result = remove_nth_from_end(head, 2) >>> current = result >>> result_list = [] >>> while current: >>> result_list.append(current.val) >>> current = current.next >>> result_list [1, 2, 3, 5] >>> head = ListNode(1) >>> result = remove_nth_from_end(head, 1) >>> result is None True >>> head = ListNode(1, ListNode(2)) >>> result = remove_nth_from_end(head, 1) >>> current = result >>> result_list = [] >>> while current: >>> result_list.append(current.val) >>> current = current.next >>> result_list [1] >>> head = ListNode(1, ListNode(2)) >>> result = remove_nth_from_end(head, 2) >>> current = result >>> result_list = [] >>> while current: >>> result_list.append(current.val) >>> current = current.next >>> result_list [2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the n-th node from the end of the list and returns its head. # Create a dummy node that points to head dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Move first n+1 steps ahead for _ in range(n + 1): first = first.next # Move both nodes until first reaches the end while first: first = first.next second = second.next # Skip the desired node second.next = second.next.next return dummy.next"},{"question":"def is_valid_bracket_sequence(brackets: str) -> bool: Determine if the sequence of brackets is valid. A bracket sequence is valid if: - Open brackets must be closed by the same type of brackets. - Open brackets must be closed in the correct order. >>> is_valid_bracket_sequence(\\"()\\") == True >>> is_valid_bracket_sequence(\\"()[]{}\\") == True >>> is_valid_bracket_sequence(\\"{[()]}\\") == True >>> is_valid_bracket_sequence(\\"(]\\") == False >>> is_valid_bracket_sequence(\\"([)]\\") == False >>> is_valid_bracket_sequence(\\"{[]}(\\") == False >>> is_valid_bracket_sequence(\\"\\") == True >>> is_valid_bracket_sequence(\\"(\\") == False >>> is_valid_bracket_sequence(\\"[\\") == False >>> is_valid_bracket_sequence(\\"{\\") == False >>> is_valid_bracket_sequence(\\"(((((((((\\") == False >>> is_valid_bracket_sequence(\\")\\") == False >>> is_valid_bracket_sequence(\\"]\\") == False >>> is_valid_bracket_sequence(\\"}\\") == False >>> is_valid_bracket_sequence(\\")))))))))\\") == False","solution":"def is_valid_bracket_sequence(brackets): Determines if the sequence of brackets is valid. # Dictionary to hold the matching pairs of brackets matching_bracket = {')': '(', '}': '{', ']': '['} # Stack to hold the opening brackets stack = [] for char in brackets: # If it's a closing bracket if char in matching_bracket: # Pop the top of the stack if it's not empty, otherwise use a dummy value top_element = stack.pop() if stack else '#' # If the popped element doesn't match the expected opening bracket if matching_bracket[char] != top_element: return False else: # It's an opening bracket, push it to the stack stack.append(char) # If the stack is empty, all brackets are closed properly, hence valid return not stack"},{"question":"def find_min_abs_difference_indices(nums: List[int]) -> List[int]: Given an integer array \`nums\`, find and return two unique indices \`i\` and \`j\` such that the absolute difference between nums[i] and nums[j] is minimized. Return the pair with the smallest indices if there are multiple such pairs. If no such pairs exist, return [-1, -1]. >>> find_min_abs_difference_indices([1, 3, 6, 10, 15]) [0, 1] >>> find_min_abs_difference_indices([10, 20, 10, 15, 10]) [0, 2] >>> find_min_abs_difference_indices([5, 6]) [0, 1] >>> find_min_abs_difference_indices([5]) [-1, -1] >>> find_min_abs_difference_indices([7, 7, 7, 7]) [0, 1] >>> find_min_abs_difference_indices([-10, -4, -2, -7, -8]) [3, 4] >>> find_min_abs_difference_indices([1, 2, 1]) [0, 2]","solution":"def find_min_abs_difference_indices(nums): Finds two unique indices i and j (i != j) such that the absolute difference between nums[i] and nums[j] is minimized. If multiple such pairs exist, returns the pair with the smallest indices. If no such pairs exist, returns [-1, -1]. if len(nums) < 2: return [-1, -1] # Prepare to find the smallest difference min_diff = float('inf') min_indices = [-1, -1] # Sort the array while keeping track of original indices sorted_nums_with_indices = sorted((num, idx) for idx, num in enumerate(nums)) # Compare each pair in the sorted array for k in range(len(sorted_nums_with_indices) - 1): num1, i = sorted_nums_with_indices[k] num2, j = sorted_nums_with_indices[k + 1] current_diff = abs(num1 - num2) if current_diff < min_diff: min_diff = current_diff min_indices = [i, j] elif current_diff == min_diff: min_indices = min(min_indices, [i, j]) return sorted(min_indices)"},{"question":"from typing import List, Tuple def find_special_pairs(nums: List[int]) -> List[Tuple[int, int]]: Returns a list of tuples representing special pairs (i, j) such that: * 0 <= i, j < nums.length * i < j * nums[i] + nums[j] is an even number >>> find_special_pairs([2, 4, 6, 8]) [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)] >>> find_special_pairs([1, 3, 5, 7]) [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)] >>> find_special_pairs([1, 2, 3, 4]) [(0, 2), (1, 3)] >>> find_special_pairs([1, 3, 5, 7, 9]) [(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] >>> find_special_pairs([]) [] >>> find_special_pairs([1]) []","solution":"def find_special_pairs(nums): Returns a list of tuples representing special pairs (i, j) such that: * 0 <= i, j < nums.length * i < j * nums[i] + nums[j] is an even number special_pairs = [] n = len(nums) for i in range(n): for j in range(i+1, n): if (nums[i] + nums[j]) % 2 == 0: special_pairs.append((i, j)) return special_pairs"},{"question":"from typing import List def min_bridges_to_connect_islands(matrix: List[List[int]]) -> int: Return the minimum number of \`0\`s to convert to \`1\`s to connect all separate islands into one single large island. An island is a group of connected \`1\`s (connected vertically or horizontally). >>> min_bridges_to_connect_islands([ [1, 1, 0], [1, 1, 0], [0, 0, 0] ]) 0 >>> min_bridges_to_connect_islands([ [1, 0, 1], [0, 0, 1], [1, 0, 1] ]) 1 >>> min_bridges_to_connect_islands([ [1, 0, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 0, 1] ]) 1 >>> min_bridges_to_connect_islands([ [1, 0, 0, 0, 1], [0, 0, 1, 0, 0], [1, 0, 0, 0, 1] ]) 1 >>> min_bridges_to_connect_islands([ [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ]) 1","solution":"def min_bridges_to_connect_islands(matrix): from collections import deque from itertools import product rows = len(matrix) cols = len(matrix[0]) def bfs(start): queue = deque([start]) visited = set([start]) while queue: r, c = queue.popleft() for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and matrix[nr][nc] == 1: queue.append((nr, nc)) visited.add((nr, nc)) return visited def get_all_islands(): islands = [] visited = set() for r, c in product(range(rows), range(cols)): if matrix[r][c] == 1 and (r,c) not in visited: island = bfs((r, c)) visited.update(island) islands.append(island) return islands islands = get_all_islands() if len(islands) == 1: return 0 def shortest_distance(set1, set2): min_distance = float('inf') for r1, c1 in set1: for r2, c2 in set2: distance = abs(r1 - r2) + abs(c1 - c2) min_distance = min(min_distance, distance) return min_distance - 1 # minus 1 because one step already counts for a conversion min_conversion = float('inf') for i in range(len(islands)): for j in range(i + 1, len(islands)): distance = shortest_distance(islands[i], islands[j]) min_conversion = min(min_conversion, distance) return min_conversion"},{"question":"def count_rectangles(cake: List[List[int]]) -> int: Returns the maximum number of rectangular pieces that can be achieved without cutting through any chocolate chips. >>> count_rectangles([[0]]) 1 >>> count_rectangles([[1, 1], [1, 1]]) 0 >>> count_rectangles([[0, 1], [1, 0]]) 2 >>> count_rectangles([ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) 1 >>> count_rectangles([ [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0] ]) 4 >>> count_rectangles([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 1","solution":"def count_rectangles(cake): Returns the maximum number of rectangular pieces that can be achieved without cutting through any chocolate chips. def count_islands(grid): Helper function to count the rectangles of zeros (islands) in the cake. def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != 0: return grid[x][y] = -1 # mark visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) count = 0 rows = len(grid) cols = len(grid[0]) if rows > 0 else 0 for x in range(rows): for y in range(cols): if grid[x][y] == 0: dfs(x, y) count += 1 return count return count_islands([row[:] for row in cake]) # clone grid to avoid modifying original"},{"question":"from typing import List def exist(board: List[List[str]], word: str) -> bool: Check if the target word can be constructed by picking characters sequentially from adjacent cells in the grid. Each cell may only be used once in the path that constructs the target. >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCCED\\") True >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCB\\") False >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"A\\") True >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"Z\\") False >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"\\") True >>> exist([], \\"ABC\\") False # Implement the function","solution":"def exist(board, word): if not board: return False rows, cols = len(board), len(board[0]) def backtrack(i, j, suffix): if not suffix: return True if i < 0 or i >= rows or j < 0 or j >= cols or board[i][j] != suffix[0]: return False ret = False # Make a choice before exploring further. board[i][j], tmp = '#', board[i][j] for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]: if backtrack(i + di, j + dj, suffix[1:]): ret = True break # Undo the choice. board[i][j] = tmp return ret for i in range(rows): for j in range(cols): if backtrack(i, j, word): return True return False"},{"question":"def smallest_substring_length(s: str) -> int: Given a string \`s\` consisting of lowercase alphabetic characters, determine the size of the smallest substring that contains all the unique characters present in \`s\`. >>> smallest_substring_length(\\"abac\\") 3 >>> smallest_substring_length(\\"aaaa\\") 1 >>> smallest_substring_length(\\"abcdef\\") 6 >>> smallest_substring_length(\\"abacbabc\\") 3 >>> smallest_substring_length(\\"\\") 0 >>> smallest_substring_length(\\"bbbbbb\\") 1 >>> smallest_substring_length(\\"xyyzyzyx\\") 3","solution":"def smallest_substring_length(s): # Set of all unique characters in the input string unique_chars = set(s) required_char_count = len(unique_chars) if required_char_count == 0: return 0 # Dictionary to count the characters in the current window window_char_count = {} min_length = float('inf') left = 0 # Number of unique characters in the current window that match the requirement num_chars_matched = 0 for right, char in enumerate(s): if char in window_char_count: window_char_count[char] += 1 else: window_char_count[char] = 1 if window_char_count[char] == 1: num_chars_matched += 1 while num_chars_matched == required_char_count: # Calculate the current window length current_length = right - left + 1 min_length = min(min_length, current_length) # Try to shrink the window from the left left_char = s[left] window_char_count[left_char] -= 1 if window_char_count[left_char] == 0: num_chars_matched -= 1 left += 1 return min_length"},{"question":"def repeat_characters(s: str, n: int) -> str: Returns a string constructed by repeating each character in the input string s exactly n times. >>> repeat_characters(\\"abc\\", 2) == \\"aabbcc\\" >>> repeat_characters(\\"xyz\\", 3) == \\"xxxyyyzzz\\" >>> repeat_characters(\\"a\\", 5) == \\"aaaaa\\" >>> repeat_characters(\\"\\", 3) == \\"\\" >>> repeat_characters(\\"a\\", 0) == \\"\\" >>> repeat_characters(\\"test\\", 1) == \\"test\\" >>> repeat_characters(\\"hello\\", 0) == \\"\\" >>> repeat_characters(\\"repeat\\", -1) == \\"\\"","solution":"def repeat_characters(s, n): Returns a string constructed by repeating each character in the input string s exactly n times. :param s: A string consisting of lowercase characters :param n: An integer indicating the number of repetitions for each character :return: A new string with each character in s repeated n times return ''.join([char * n for char in s])"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrange_even_odd(head: ListNode) -> ListNode: Given a linked list, arrange the elements in such a way that all the nodes with even values come before the nodes with odd values while preserving their relative order. Return the rearranged linked list. >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([1, 2, 3, 4, 5, 6]))) == [2, 4, 6, 1, 3, 5] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([1, 3, 5, 7]))) == [1, 3, 5, 7] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([2, 4, 6, 8]))) == [2, 4, 6, 8] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([]))) == [] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([2]))) == [2] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([1]))) == [1] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([1, 2, 3, 4]))) == [2, 4, 1, 3] pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrange_even_odd(head): if not head: return None even_dummy = ListNode(0) odd_dummy = ListNode(0) evens = even_dummy odds = odd_dummy current = head while current: if current.val % 2 == 0: evens.next = current evens = evens.next else: odds.next = current odds = odds.next current = current.next evens.next = odd_dummy.next odds.next = None return even_dummy.next"},{"question":"def largest_square_submatrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: Given a matrix of \`m x n\` dimensions where each cell contains an integer value representing its height, find the size of the largest square submatrix whose height matches a given target height. The size of a matrix is defined by the number of rows multiplied by the number of columns. Return the dimensions of the largest square submatrix as a tuple (row_count, col_count), or (0, 0) if no such submatrix exists. >>> largest_square_submatrix([], 1) (0, 0) >>> matrix = [ ... [1, 2, 3], ... [2, 1, 2], ... [3, 2, 1] ... ] >>> largest_square_submatrix(matrix, 4) (0, 0) >>> matrix = [[2]] >>> largest_square_submatrix(matrix, 2) (1, 1) >>> matrix = [[2]] >>> largest_square_submatrix(matrix, 1) (0, 0) >>> matrix = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> largest_square_submatrix(matrix, 1) (3, 3) >>> matrix = [ ... [1, 1, 0], ... [1, 1, 1], ... [0, 1, 1] ... ] >>> largest_square_submatrix(matrix, 1) (2, 2) >>> matrix = [ ... [1, 2, 3], ... [1, 2, 2], ... [3, 2, 2] ... ] >>> largest_square_submatrix(matrix, 2) (2, 2) >>> matrix = [ ... [0, 0, 0], ... [0, 0, 1], ... [0, 0, 0] ... ] >>> largest_square_submatrix(matrix, 0) (2, 2)","solution":"def largest_square_submatrix(matrix, target): if not matrix or not matrix[0]: return (0, 0) m, n = len(matrix), len(matrix[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if matrix[i - 1][j - 1] == target: dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return (max_side, max_side) if max_side > 0 else (0, 0)"},{"question":"def shortestPath(grid): Returns the minimum number of steps required to get from the top-left corner to the bottom-right corner in a grid, or -1 if it is not possible. Args: grid (List[List[int]]): A 2D list representing the grid, where 0 represents a passable street and 1 represents an impassable obstacle. Returns: int: The minimum number of steps to reach the bottom-right corner, or -1 if it is not possible. >>> shortestPath([ ... [0, 1], ... [0, 0] ... ]) 3 >>> shortestPath([ ... [0, 1], ... [1, 0] ... ]) -1 >>> shortestPath([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) 5 >>> shortestPath([[0]]) 1 >>> shortestPath([ ... [0, 0, 0, 0], ... [1, 1, 1, 0], ... [1, 0, 0, 0], ... [1, 1, 0, 0] ... ]) 7 >>> shortestPath([ ... [1, 0], ... [0, 0] ... ]) -1 >>> shortestPath([ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0] ... ]) -1 pass","solution":"from collections import deque def shortestPath(grid): Returns the minimum number of steps required to get from the top-left corner to the bottom-right corner in a grid, or -1 if it is not possible. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"def number_of_steps(num: int) -> int: Returns the number of steps required to reduce \`num\` to 1. >>> number_of_steps(8) 3 >>> number_of_steps(7) 4 >>> number_of_steps(16) 4 >>> number_of_steps(15) 6 >>> number_of_steps(1) 0","solution":"def number_of_steps(num): Returns the number of steps required to reduce \`num\` to 1. steps = 0 while num != 1: if num % 2 == 0: num //= 2 else: num -= 1 steps += 1 return steps"},{"question":"def longestCommonSubsequence(nums1, nums2): You are given two integer arrays \`nums1\` and \`nums2\`, where each array represents a set of distinct integers. A common subsequence is a sequence that appears in both arrays in the same order. Your task is to find the longest common subsequence (LCS) present in both arrays. If there is more than one LCS, any of them can be returned. Args: nums1: List[int] - first array of distinct integers. nums2: List[int] - second array of distinct integers. Returns: List[int] - the longest common subsequence in both arrays. If there is no common subsequence, return an empty array. >>> longestCommonSubsequence([1, 3, 4, 1, 2, 8], [3, 4, 1, 2, 8, 7]) [3, 4, 1, 2, 8] >>> longestCommonSubsequence([1, 2, 3], [4, 5, 6]) [] >>> longestCommonSubsequence([1], [1]) [1] >>> longestCommonSubsequence([], [1, 2, 3]) [] >>> longestCommonSubsequence([1, 2, 3, 4], [2, 4]) [2, 4]","solution":"def longestCommonSubsequence(nums1, nums2): Returns the longest common subsequence present in both nums1 and nums2. If there is no common subsequence, returns an empty array. # Find lengths of both the integer arrays m, n = len(nums1), len(nums2) # Create a 2D table to store lengths of longest common subsequence. dp = [[0 for j in range(n + 1)] for i in range(m + 1)] # Following steps build the dp table in bottom-up fashion for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Following the table, construct the solution of longest common subsequence index = dp[m][n] # Create a list to store the lcs string lcs = [0] * index # Length of lcs # Start from the right-bottom corner and # trace the subsequence i, j = m, n while i > 0 and j > 0: # If current character in nums1 and nums2 are same, then # current character is part of LCS if nums1[i - 1] == nums2[j - 1]: lcs[index - 1] = nums1[i - 1] i -= 1 j -= 1 index -= 1 # If not same, then find the larger of two and # go in the direction of the larger value elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 return lcs"},{"question":"from collections import Counter def max_beauty(s: str) -> int: Returns the maximum beauty of the string after performing at most one operation. The beauty of a string is defined as the difference between the frequency of the most frequent letter and the frequency of the least frequent letter among all letters present in the string after the operation (if the string is not empty). >>> max_beauty(\\"aabbcc\\") 0 >>> max_beauty(\\"abccc\\") 2 >>> max_beauty(\\"a\\") 0 >>> max_beauty(\\"abcdef\\") 0 >>> max_beauty(\\"\\") 0 >>> max_beauty(\\"aaabb\\") 1 >>> max_beauty(\\"aabbbccccddddd\\") 3","solution":"from collections import Counter def max_beauty(s): Returns the maximum beauty of the string after performing at most one operation. if not s: return 0 # Count the frequency of each character in s freq = Counter(s) # Get all unique characters in s unique_chars = list(freq.keys()) # Initialize the maximum beauty max_beauty = 0 # Try removing each unique character once (including the no-removal case) for char in unique_chars + [None]: if char: # Create a new frequency counter without \`char\` modified_freq = freq.copy() del modified_freq[char] else: modified_freq = freq # Get the frequencies of remaining characters remaining_freq = list(modified_freq.values()) if not remaining_freq: continue # Calculate the beauty for the current modification current_beauty = max(remaining_freq) - min(remaining_freq) # Update the maximum beauty max_beauty = max(max_beauty, current_beauty) return max_beauty"},{"question":"class PhotoManager: A class that manages photo tagging and retrieval system. Methods ------- addPhoto(photoId: int, tags: List[str]) -> None Adds a photo with a unique photoId and a list of tags. searchPhotos(queryTags: List[str]) -> List[int] Returns a list of photoIds of photos that include all the queryTags. def __init__(self): Initializes the photo manager object. pass def addPhoto(self, photoId: int, tags: List[str]) -> None: Add a photo with a unique photoId and a list of tags. Parameters ---------- photoId : int A unique identifier for the photo. tags : List[str] A list of tags to associate with the photo. pass def searchPhotos(self, queryTags: List[str]) -> List[int]: Search for photos that include all the queryTags. Parameters ---------- queryTags : List[str] A list of tags to search for. Returns ------- List[int] A list of photoIds that match all the query tags. pass def test_add_and_search_photo_single_tag_match(): pm = PhotoManager() pm.addPhoto(1, [\\"nature\\", \\"sunrise\\"]) pm.addPhoto(2, [\\"nature\\", \\"sunset\\"]) result = pm.searchPhotos([\\"nature\\"]) assert set(result) == {1, 2}, f\\"Expected [1, 2], but got {result}\\" def test_search_photo_full_tag_match(): pm = PhotoManager() pm.addPhoto(1, [\\"nature\\", \\"sunrise\\", \\"beach\\"]) pm.addPhoto(2, [\\"nature\\", \\"sunset\\", \\"mountain\\"]) result = pm.searchPhotos([\\"nature\\", \\"sunrise\\"]) assert result == [1], f\\"Expected [1], but got {result}\\" def test_search_photos_with_no_results(): pm = PhotoManager() pm.addPhoto(1, [\\"nature\\", \\"sunrise\\", \\"beach\\"]) pm.addPhoto(2, [\\"nature\\", \\"sunset\\", \\"mountain\\"]) result = pm.searchPhotos([\\"city\\"]) assert result == [], f\\"Expected [], but got {result}\\" def test_search_photos_with_multiple_tags(): pm = PhotoManager() pm.addPhoto(1, [\\"nature\\", \\"sunrise\\", \\"beach\\", \\"vacation\\"]) pm.addPhoto(2, [\\"nature\\", \\"sunset\\", \\"mountain\\", \\"hike\\"]) pm.addPhoto(3, [\\"nature\\", \\"sunrise\\", \\"hike\\", \\"adventure\\"]) result = pm.searchPhotos([\\"nature\\", \\"sunrise\\", \\"hike\\"]) assert result == [3], f\\"Expected [3], but got {result}\\" def test_search_photos_with_addtional_tags(): pm = PhotoManager() pm.addPhoto(1, [\\"nature\\", \\"sunrise\\", \\"beach\\"]) pm.addPhoto(2, [\\"nature\\", \\"sunset\\", \\"mountain\\"]) pm.addPhoto(3, [\\"nature\\", \\"sunrise\\", \\"mountain\\"]) result = pm.searchPhotos([\\"nature\\", \\"sunrise\\"]) assert set(result) == {1, 3}, f\\"Expected [1, 3], but got {result}\\"","solution":"class PhotoManager: def __init__(self): Initializes the photo manager object with an empty dictionary to store photos and their tags. self.photos = {} def addPhoto(self, photoId, tags): Adds a photo with a unique photoId and a list of tags. :param photoId: int :param tags: List[str] self.photos[photoId] = set(tags) def searchPhotos(self, queryTags): Returns a list of photoIds of photos that include all the queryTags. :param queryTags: List[str] :return: List[int] queryTagSet = set(queryTags) result = [] for photoId, tags in self.photos.items(): if queryTagSet.issubset(tags): result.append(photoId) return result"},{"question":"def compute_shortest_path(graph: dict, start_node: int) -> dict: Calculate the shortest path from the start_node to all other nodes in the given graph using Dijkstra's algorithm. Args: graph (dict): Adjacency list representing the graph. start_node (int/str): Starting node for the shortest path calculation. Returns: dict: Shortest paths from the start_node to all other nodes. >>> graph = { >>> 'A': [('B', 1), ('C', 4)], >>> 'B': [('A', 1), ('C', 2), ('D', 5)], >>> 'C': [('A', 4), ('B', 2), ('D', 1)], >>> 'D': [('B', 5), ('C', 1)] >>> } >>> start_node = 'A' >>> compute_shortest_path(graph, start_node) {'A': 0, 'B': 1, 'C': 3, 'D': 4} pass # Unit tests def test_small_graph(): graph = { 'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 2), ('D', 5)], 'C': [('A', 4), ('B', 2), ('D', 1)], 'D': [('B', 5), ('C', 1)] } start_node = 'A' expected = {'A': 0, 'B': 1, 'C': 3, 'D': 4} assert compute_shortest_path(graph, start_node) == expected def test_large_graph(): graph = { 0: [(1, 10), (2, 3)], 1: [(2, 1), (3, 2)], 2: [(1, 4), (3, 8), (4, 2)], 3: [(4, 7)], 4: [(3, 9)] } start_node = 0 expected = {0: 0, 1: 7, 2: 3, 3: 9, 4: 5} assert compute_shortest_path(graph, start_node) == expected def test_disjoint_graph(): graph = { 'X': [('Y', 2)], 'Y': [('Z', 3)], 'Z': [] } start_node = 'X' expected = {'X': 0, 'Y': 2, 'Z': 5} assert compute_shortest_path(graph, start_node) == expected def test_no_edges_graph(): graph = { 'A': [] } start_node = 'A' expected = {'A': 0} assert compute_shortest_path(graph, start_node) == expected def test_complex_graph(): graph = { 1: [(2, 2), (4, 1)], 2: [(1, 2), (3, 4)], 3: [(2, 4), (4, 5), (5, 1)], 4: [(1, 1), (3, 5), (5, 8)], 5: [(3, 1), (4, 8)] } start_node = 1 expected = {1: 0, 2: 2, 3: 6, 4: 1, 5: 7} assert compute_shortest_path(graph, start_node) == expected","solution":"import heapq def compute_shortest_path(graph, start_node): Calculate the shortest path from the start_node to all other nodes in the given graph using Dijkstra's algorithm. Args: graph (dict): Adjacency list representing the graph. start_node (int/str): Starting node for the shortest path calculation. Returns: dict: Shortest paths from the start_node to all other nodes. # Initialize the priority queue priority_queue = [(0, start_node)] # Initialize the shortest path dictionary with infinite distances shortest_paths = {node: float('inf') for node in graph} # Distance to the start node from itself is zero shortest_paths[start_node] = 0 while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the popped node distance is greater than the shortest known distance, skip processing if current_distance > shortest_paths[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it's better if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_paths"},{"question":"from typing import List, Tuple, Optional def astar(grid: List[List[int]]) -> Optional[List[Tuple[int, int]]]: Implement the A* search algorithm to find the shortest path in the given grid. The heuristic used should be the Manhattan distance. The function should return the shortest path from the top-left corner to the bottom-right corner if one exists, or \`None\` if no path exists. Args: grid (List[List[int]]): 2D list of integers representing the maze, where 0 represents a free cell and 1 represents a blocked cell. Returns: Optional[List[Tuple[int, int]]]: A list of tuples representing the path from start to end, including both endpoints. If no path is found, return \`None\`. >>> grid = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 1, 0] ... ] >>> astar(grid) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 1), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)]","solution":"import heapq def astar(grid): n, m = len(grid), len(grid[0]) def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(node): neighbors = [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for d in directions: nx, ny = node[0] + d[0], node[1] + d[1] if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0: neighbors.append((nx, ny)) return neighbors start = (0, 0) goal = (n - 1, m - 1) if grid[start[0]][start[1]] == 1 or grid[goal[0]][goal[1]] == 1: return None open_set = [] heapq.heappush(open_set, (0 + heuristic(start, goal), 0, start)) came_from = {} g_score = {node: float('inf') for row in grid for node in [(i, j) for i, row in enumerate(grid) for j, col in enumerate(row)]} g_score[start] = 0 while open_set: _, current_g, current = heapq.heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for neighbor in get_neighbors(current): tentative_g_score = current_g + 1 if tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score, tentative_g_score, neighbor)) return None"},{"question":"class Node: def __init__(self, name, is_file=False): self.name = name self.is_file = is_file self.children = {} self.parent = None class FileSystem: def __init__(self): self.root = Node(name=\\"/\\") self.current = self.root def initialize_root(self): Initializes the root directory of the file system. pass def create_directory(self, name): Creates a new directory with the specified name in the current directory. Args: name (str): The name of the new directory. pass def create_file(self, name): Creates a new file with the specified name in the current directory. Args: name (str): The name of the new file. pass def navigate_to_directory(self, name): Navigates into the specified directory if it exists; otherwise, raises an error. Args: name (str): The name of the directory to navigate into. pass def navigate_up(self): Navigates up to the parent directory; if already at the root directory, stays at the root. pass def display_tree(self): Prints the tree-like structure of the current directory and all its subdirectories and files. pass import pytest @pytest.fixture def fs(): filesystem = FileSystem() filesystem.initialize_root() return filesystem def test_initialize_root(fs): assert fs.root.name == \\"/\\" assert fs.current == fs.root def test_create_directory(fs): fs.create_directory(\\"Documents\\") assert \\"Documents\\" in fs.current.children with pytest.raises(ValueError): fs.create_directory(\\"Documents\\") with pytest.raises(ValueError): fs.create_directory(\\"\\") def test_create_file(fs): fs.create_file(\\"README.txt\\") assert \\"README.txt\\" in fs.current.children with pytest.raises(ValueError): fs.create_file(\\"README.txt\\") with pytest.raises(ValueError): fs.create_file(\\"\\") def test_navigate_to_directory(fs): fs.create_directory(\\"Documents\\") fs.navigate_to_directory(\\"Documents\\") assert fs.current.name == \\"Documents\\" with pytest.raises(ValueError): fs.navigate_to_directory(\\"NonExistent\\") def test_navigate_up(fs): fs.create_directory(\\"Documents\\") fs.navigate_to_directory(\\"Documents\\") fs.navigate_up() assert fs.current.name == \\"/\\" fs.navigate_up() assert fs.current.name == \\"/\\" def test_display_tree_empty(fs, capsys): fs.display_tree() captured = capsys.readouterr() assert captured.out == \\"/n\\" def test_display_tree_with_content(fs, capsys): fs.create_directory(\\"Documents\\") fs.create_directory(\\"Photos\\") fs.create_file(\\"README.txt\\") fs.navigate_to_directory(\\"Documents\\") fs.create_file(\\"Resume.docx\\") fs.navigate_up() fs.display_tree() captured = capsys.readouterr() expected_output = \\"/n Documentsn Resume.docxn Photosn README.txtn\\" assert captured.out == expected_output","solution":"class Node: def __init__(self, name, is_file=False): self.name = name self.is_file = is_file self.children = {} self.parent = None class FileSystem: def __init__(self): self.root = Node(name=\\"/\\") self.current = self.root def initialize_root(self): self.__init__() def create_directory(self, name): if not name or name in self.current.children: raise ValueError(\\"Invalid directory name or directory already exists\\") new_dir = Node(name) new_dir.parent = self.current self.current.children[name] = new_dir def create_file(self, name): if not name or name in self.current.children: raise ValueError(\\"Invalid file name or file already exists\\") new_file = Node(name, is_file=True) new_file.parent = self.current self.current.children[name] = new_file def navigate_to_directory(self, name): if name not in self.current.children or self.current.children[name].is_file: raise ValueError(\\"Directory not found\\") self.current = self.current.children[name] def navigate_up(self): if self.current.parent is not None: self.current = self.current.parent def display_tree(self): self._display_tree_helper(self.current, \\"\\") def _display_tree_helper(self, node, indent): print(indent + node.name) indent += \\" \\" for child in node.children.values(): self._display_tree_helper(child, indent)"},{"question":"from typing import List def is_phrase_possible(words: List[str], sentence: List[str]) -> bool: Determines whether it's possible to form the exact sentence using each word from the given list exactly once. >>> is_phrase_possible([\\"you\\", \\"have\\", \\"been\\", \\"programmed\\", \\"you\\", \\"have\\"], [\\"you\\", \\"have\\", \\"been\\", \\"programmed\\"]) True >>> is_phrase_possible([\\"an\\", \\"apple\\", \\"a\\", \\"day\\"], [\\"an\\", \\"apple\\", \\"a\\", \\"day\\", \\"keeps\\", \\"the\\", \\"doctor\\", \\"away\\"]) False","solution":"from typing import List from collections import Counter def is_phrase_possible(words: List[str], sentence: List[str]) -> bool: Determines whether it's possible to form the exact sentence using each word from the given list exactly once. words_counter = Counter(words) sentence_counter = Counter(sentence) for word, count in sentence_counter.items(): if words_counter[word] < count: return False return True"},{"question":"from typing import List def longest_constructible_word(words: List[str], chars: List[str]) -> str: Find the longest word in the list that can be constructed using the characters from the given characters list. >>> longest_constructible_word([\\"apple\\", \\"plea\\", \\"tan\\", \\"tree\\"], ['e', 't', 'a', 'e', 'p', 'l', 'r']) \\"plea\\" >>> longest_constructible_word([\\"rat\\", \\"bat\\", \\"cat\\"], ['t', 'a', 'c']) \\"cat\\" >>> longest_constructible_word([\\"house\\", \\"sun\\", \\"moon\\"], ['o', 'n', 'm']) \\"\\" pass # Unit tests def test_longest_constructible_word_example1(): words = [\\"apple\\", \\"plea\\", \\"tan\\", \\"tree\\"] chars = ['e', 't', 'a', 'e', 'p', 'l', 'r'] assert longest_constructible_word(words, chars) == \\"plea\\" def test_longest_constructible_word_example2(): words = [\\"rat\\", \\"bat\\", \\"cat\\"] chars = ['t', 'a', 'c'] assert longest_constructible_word(words, chars) == \\"cat\\" def test_longest_constructible_word_example3(): words = [\\"house\\", \\"sun\\", \\"moon\\"] chars = ['o', 'n', 'm'] assert longest_constructible_word(words, chars) == \\"\\" def test_longest_constructible_word_no_constructible_words(): words = [\\"apple\\", \\"banana\\", \\"cherry\\"] chars = ['x', 'y', 'z'] assert longest_constructible_word(words, chars) == \\"\\" def test_longest_constructible_word_all_constructible_words(): words = [\\"apple\\", \\"plea\\", \\"app\\", \\"bat\\"] chars = ['p', 'p', 'l', 'e', 'a', 'a', 't', 'b'] assert longest_constructible_word(words, chars) == \\"apple\\" def test_longest_constructible_word_multiple_same_length_words(): words = [\\"apple\\", \\"plea\\", \\"appl\\", \\"bat\\"] chars = ['p', 'p', 'l', 'e', 'a', 'a', 't', 'b'] assert longest_constructible_word(words, chars) == \\"apple\\"","solution":"def longest_constructible_word(words: list, chars: list) -> str: from collections import Counter def can_construct(word, char_count): word_count = Counter(word) for char, count in word_count.items(): if char_count[char] < count: return False return True char_count = Counter(chars) longest_word = \\"\\" for word in words: if can_construct(word, char_count): if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"def filter_and_reverse(input_list: list) -> list: Filters out negative integers and returns the non-negative integers in reverse order. >>> filter_and_reverse([1, -2, 3, -4, 5]) [5, 3, 1] >>> filter_and_reverse([-1, -2, -3, -4]) [] >>> filter_and_reverse([0, 1, 2, 3]) [3, 2, 1, 0] >>> filter_and_reverse([]) []","solution":"def filter_and_reverse(input_list: list) -> list: Filters out negative integers and returns the non-negative integers in reverse order. Args: input_list (list): A list of integers. Returns: list: A list of non-negative integers in reverse order. # Filter out negative integers filtered_list = [num for num in input_list if num >= 0] # Reverse the filtered list reversed_list = filtered_list[::-1] return reversed_list"},{"question":"def rotate_array(arr, steps): Rotates the array to the right by the given number of steps. Handles negative steps by rotating to the left. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([], 3) [] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] pass def remove_duplicates(arr): Removes duplicates from the array while maintaining the order of the first occurrences. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([]) [] pass","solution":"def rotate_array(arr, steps): Rotates the array to the right by the given number of steps. Handles negative steps by rotating to the left. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"arr must be a list of integers.\\") if not isinstance(steps, int): raise TypeError(\\"steps must be an integer.\\") n = len(arr) if n == 0: return arr steps = steps % n # Normalize steps to prevent full rotations return arr[-steps:] + arr[:-steps] def remove_duplicates(arr): Removes duplicates from the array while maintaining the order of the first occurrences. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"arr must be a list of integers.\\") seen = set() result = [] for item in arr: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"from datetime import datetime from typing import List def get_response_times(start: datetime, end: datetime) -> List[float]: Mock function to simulate fetching of response times. In an actual implementation, this function would fetch data from a database or monitoring system. # Sample data for demonstration: sample_data = { (datetime(2023, 1, 1, 0, 0, 0), datetime(2023, 1, 1, 23, 59, 59)): [200, 210, 190, 220], (datetime(2023, 1, 2, 0, 0, 0), datetime(2023, 1, 2, 23, 59, 59)): [230, 250, 240, 210], } return sample_data.get((start, end), []) def average_response_time(start: datetime, end: datetime) -> float: Calculate the average response time of the system over the given period. Parameters: start (datetime): The start of the time period. end (datetime): The end of the time period. Returns: float: The average response time over the specified period. pass from datetime import datetime def test_average_response_time_valid_period_1(): start_time = datetime(2023, 1, 1, 0, 0, 0) end_time = datetime(2023, 1, 1, 23, 59, 59) assert average_response_time(start_time, end_time) == 205.0 def test_average_response_time_valid_period_2(): start_time = datetime(2023, 1, 2, 0, 0, 0) end_time = datetime(2023, 1, 2, 23, 59, 59) assert average_response_time(start_time, end_time) == 232.5 def test_average_response_time_no_data_period(): start_time = datetime(2023, 1, 3, 0, 0, 0) end_time = datetime(2023, 1, 3, 23, 59, 59) assert average_response_time(start_time, end_time) == 0.0 def test_average_response_time_start_equals_end(): start_time = datetime(2023, 1, 1, 0, 0, 0) end_time = datetime(2023, 1, 1, 0, 0, 0) assert average_response_time(start_time, end_time) == 0.0 # No data expected for this period def test_average_response_time_invalid_period(): start_time = datetime(2023, 1, 2, 0, 0, 0) end_time = datetime(2023, 1, 1, 23, 59, 59) assert average_response_time(start_time, end_time) == 0.0 # No data expected for invalid period","solution":"from datetime import datetime from typing import List def get_response_times(start: datetime, end: datetime) -> List[float]: Mock function to simulate fetching of response times. In an actual implementation, this function would fetch data from a database or monitoring system. # Sample data for demonstration: sample_data = { (datetime(2023, 1, 1, 0, 0, 0), datetime(2023, 1, 1, 23, 59, 59)): [200, 210, 190, 220], (datetime(2023, 1, 2, 0, 0, 0), datetime(2023, 1, 2, 23, 59, 59)): [230, 250, 240, 210], } return sample_data.get((start, end), []) def average_response_time(start: datetime, end: datetime) -> float: Calculate the average response time of the system over the given period. Parameters: start (datetime): The start of the time period. end (datetime): The end of the time period. Returns: float: The average response time over the specified period. response_times = get_response_times(start, end) if not response_times: # Handle the case with no data return 0.0 return sum(response_times) / len(response_times)"},{"question":"class Graph: def __init__(self) -> None: Initializes an empty graph. def add_edge(self, v: int, w: int) -> None: Adds an undirected edge between vertices v and w. If vertices v or w do not exist, they should be added to the graph. def is_connected(self, start: int, end: int) -> bool: Checks if there is a path between vertices start and end using Depth-First Search (DFS). If any of the vertices do not exist in the graph, it should return False. >>> graph = Graph() >>> graph.add_edge(0, 1) >>> graph.add_edge(1, 2) >>> graph.is_connected(0, 2) True >>> graph.is_connected(0, 3) False","solution":"class Graph: def __init__(self) -> None: self.graph = {} def add_edge(self, v: int, w: int) -> None: if v not in self.graph: self.graph[v] = [] if w not in self.graph: self.graph[w] = [] self.graph[v].append(w) self.graph[w].append(v) def is_connected(self, start: int, end: int) -> bool: if start not in self.graph or end not in self.graph: return False visited = set() def dfs(v: int) -> bool: if v == end: return True visited.add(v) for neighbor in self.graph[v]: if neighbor not in visited: if dfs(neighbor): return True return False return dfs(start)"},{"question":"class KthSmallestSet: A class to maintain a set of integers and retrieve the k-th smallest integer. Methods: add(self, value: int) -> None: Adds an integer to the set. kth_smallest(self, k: int) -> int: Returns the k-th smallest integer in the set. >>> kth_set = KthSmallestSet() >>> kth_set.add(5) >>> kth_set.add(3) >>> kth_set.add(10) >>> kth_set.kth_smallest(1) == 3 >>> kth_set.kth_smallest(2) == 5 >>> kth_set.kth_smallest(3) == 10 def __init__(self): pass def add(self, value: int) -> None: pass def kth_smallest(self, k: int) -> int: pass","solution":"import bisect class KthSmallestSet: def __init__(self): self.arr = [] def add(self, value: int) -> None: # Use binary search to maintain a sorted array if value not in self.arr: bisect.insort(self.arr, value) def kth_smallest(self, k: int) -> int: if k < 1 or k > len(self.arr): raise ValueError(\\"k is out of range\\") return self.arr[k - 1]"},{"question":"import heapq from typing import Dict, List, Tuple class DynamicTrafficDijkstra: def __init__(self, city_graph: Dict[str, List[Tuple[str, int]]], traffic_updates: Dict[int, Dict[Tuple[str, str], int]]): Initialize the route planner with the given city graph and traffic updates :param city_graph: A dictionary representing the city graph where keys are intersecting names and values are lists of tuples (neighbor, base_weight) representing adjacent intersections and base travel times :param traffic_updates: A dictionary representing the traffic updates where keys are time slots and values are dictionaries with intersection pairs as keys and updated travel times as values self.city_graph = city_graph self.traffic_updates = traffic_updates def get_dynamic_weight(self, u: str, v: str, base_weight: int, current_time: int) -> int: Retrieve the updated travel time between intersections considering traffic updates :param u: The starting intersection :param v: The destination intersection :param base_weight: The base travel time between the intersections :param current_time: The current time slot for which to check traffic updates :return: The travel time between the intersections considering traffic updates if (u, v) in self.traffic_updates.get(current_time, {}): return self.traffic_updates[current_time][(u, v)] return base_weight def shortest_path(self, start: str, goal: str, current_time: int) -> List[str]: Calculate the shortest path from the start intersection to the goal intersection considering dynamic traffic conditions :param start: The starting intersection :param goal: The goal intersection :param current_time: The current time slot for travel :return: A list of intersection names representing the optimal path from start to goal, inclusive. An empty list if no path exists","solution":"import heapq class DynamicTrafficDijkstra: def __init__(self, city_graph, traffic_updates): self.city_graph = city_graph self.traffic_updates = traffic_updates def get_dynamic_weight(self, u, v, base_weight, current_time): if (u, v) in self.traffic_updates.get(current_time, {}): return self.traffic_updates[current_time][(u, v)] return base_weight def shortest_path(self, start, goal, current_time): pq = [(0, start, [])] # Priority queue for min-heap (distance, node, path) distances = {node: float('inf') for node in self.city_graph} distances[start] = 0 visited = set() while pq: current_distance, current_node, path = heapq.heappop(pq) if current_node in visited: continue path = path + [current_node] if current_node == goal: return path visited.add(current_node) for neighbor, base_weight in self.city_graph.get(current_node, []): weight = self.get_dynamic_weight(current_node, neighbor, base_weight, current_time) distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor, path)) return [] # Example usage: city_graph = { 'A': [('B', 5), ('C', 10)], 'B': [('C', 3), ('D', 2)], 'C': [('D', 1)], 'D': [] } traffic_updates = { 8: {('A', 'B'): 7, ('B', 'C'): 5}, 17: {('A', 'C'): 15, ('B', 'D'): 3}, } start_intersection = 'A' goal_intersection = 'D' current_time_slot = 8 planner = DynamicTrafficDijkstra(city_graph, traffic_updates) print(planner.shortest_path(start_intersection, goal_intersection, current_time_slot))"},{"question":"def is_network_connected(connections: List[Tuple[str, str]]) -> bool: Analyze a given network of computers and identify whether there exists at least one path connecting every pair of computers directly or indirectly. >>> is_network_connected([(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"A\\")]) True >>> is_network_connected([(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"D\\", \\"E\\")]) False >>> is_network_connected([]) False >>> is_network_connected([(\\"A\\", \\"B\\")]) True from typing import List, Tuple def test_all_nodes_connected(): connections = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"A\\")] assert is_network_connected(connections) == True def test_disjoint_connection(): disjoint_connections = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"D\\", \\"E\\")] assert is_network_connected(disjoint_connections) == False def test_empty_connections(): empty_connections = [] assert is_network_connected(empty_connections) == False def test_single_connection(): single_connection = [(\\"A\\", \\"B\\")] assert is_network_connected(single_connection) == True def test_larger_connected_network(): larger_connections = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"E\\"), (\\"E\\", \\"A\\")] assert is_network_connected(larger_connections) == True def test_larger_disconnected_network(): larger_disconnected = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"D\\", \\"E\\"), (\\"E\\", \\"F\\")] assert is_network_connected(larger_disconnected) == False def test_all_singleton_nodes(): singleton_connections = [(\\"A\\", \\"B\\"), (\\"C\\", \\"D\\")] assert is_network_connected(singleton_connections) == False","solution":"def is_network_connected(connections): if not connections: return False # Create an adjacency list from collections import defaultdict, deque graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Use a set to track visited nodes visited = set() # Perform DFS/BFS from any node (let's use the first node from connections) def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Start traversal from the first node in the connections list start_node = connections[0][0] visited.add(start_node) bfs(start_node) # All nodes in the graph should be visited if the network is connected return len(visited) == len(graph)"},{"question":"def find_word_in_grid(grid: list[list[str]], word: str) -> bool: Pattern Matching in a Grid You are given a 2D grid of characters, and you need to find whether a given word can be constructed from the grid. The word can be formed by moving sequentially in any of the eight possible directions (horizontally, vertically, or diagonally) starting from any cell. Args: grid (list[list[str]]): The 2D grid of characters. word (str): The word to be found in the grid. Returns: bool: True if the word exists in the grid, False otherwise. Example: >>> grid = [ ... ['a', 'b', 'c', 'e'], ... ['s', 'f', 'c', 's'], ... ['a', 'd', 'e', 'e'] ... ] >>> find_word_in_grid(grid, 'abcced') True >>> find_word_in_grid(grid, 'see') True >>> find_word_in_grid(grid, 'abcb') False >>> grid = [ ... ['h', 'e', 'l', 'l', 'o'], ... ['w', 'o', 'r', 'l', 'd'], ... ['a', 'm', 'a', 'z', 'e'], ... ['c', 'o', 'd', 'e', 'r'] ... ] >>> find_word_in_grid(grid, 'hello') True >>> find_word_in_grid(grid, 'amazes') False >>> find_word_in_grid(grid, 'coder') True >>> grid = [ ... ['x', 'y', 'z'], ... ['a', 'b', 'c'], ... ['d', 'e', 'f'] ... ] >>> find_word_in_grid(grid, 'abcdef') False Note: Implement a Depth First Search (DFS) to explore all possible paths from every cell in the grid, and ensure each cell is visited only once per search instance. pass","solution":"def find_word_in_grid(grid, word): rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False temp, grid[r][c] = grid[r][c], \\"#\\" found = any(dfs(r + dr, c + dc, index + 1) for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]) grid[r][c] = temp return found for r in range(rows): for c in range(cols): if grid[r][c] == word[0] and dfs(r, c, 0): return True return False"},{"question":"def longest_palindrome_length(s: str) -> int: Given a string 's' consisting of lowercase English letters, find and return the length of the longest palindrome that can be built with those letters. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"a\\") 1 >>> longest_palindrome_length(\\"abc\\") 1 >>> longest_palindrome_length(\\"aabbcc\\") 6 >>> longest_palindrome_length(\\"bb\\") 2 from solution import longest_palindrome_length def test_example_cases(): assert longest_palindrome_length(\\"abccccdd\\") == 7 assert longest_palindrome_length(\\"a\\") == 1 assert longest_palindrome_length(\\"abc\\") == 1 assert longest_palindrome_length(\\"aabbcc\\") == 6 assert longest_palindrome_length(\\"bb\\") == 2 def test_edge_cases(): assert longest_palindrome_length(\\"\\") == 0 # empty string assert longest_palindrome_length(\\"b\\") == 1 # single character assert longest_palindrome_length(\\"bbbbb\\") == 5 # odd number of the same character assert longest_palindrome_length(\\"ab\\") == 1 # two different characters def test_mixed_cases(): assert longest_palindrome_length(\\"aabbccc\\") == 7 assert longest_palindrome_length(\\"aaabbbccc\\") == 7 assert longest_palindrome_length(\\"abcabcabc\\") == 7 assert longest_palindrome_length(\\"aaaabbbbcccc\\") == 12 def test_large_input(): s = \\"a\\" * 50000 + \\"b\\" * 50000 assert longest_palindrome_length(s) == 100000 def test_no_repeating_characters(): assert longest_palindrome_length(\\"abcdefgh\\") == 1 assert longest_palindrome_length(\\"xyz\\") == 1","solution":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindrome that can be formed using the characters in the given string. from collections import Counter char_count = Counter(s) length = 0 odd_count_present = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_count_present = True if odd_count_present: length += 1 return length"},{"question":"from datetime import datetime from collections import defaultdict def most_active_employee(messages: list[tuple[int, int, str]], start_time: str, end_time: str) -> int: Returns the ID of the employee who sent the most messages in the given time period. >>> messages = [ ... (1, 2, \\"2022-10-01 10:00:00\\"), ... (2, 1, \\"2022-10-01 10:05:00\\"), ... (1, 3, \\"2022-10-01 11:00:00\\"), ... (3, 1, \\"2022-10-01 12:00:00\\"), ... (1, 4, \\"2022-10-01 13:00:00\\"), ... (2, 1, \\"2022-10-01 14:00:00\\") ... ] >>> start_time = \\"2022-10-01 10:00:00\\" >>> end_time = \\"2022-10-01 12:00:00\\" >>> most_active_employee(messages, start_time, end_time) 1","solution":"from datetime import datetime from collections import defaultdict def most_active_employee(messages: list[tuple[int, int, str]], start_time: str, end_time: str) -> int: Returns the ID of the employee who sent the most messages in the given time period. start_time_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_time_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") if start_time_dt > end_time_dt: raise ValueError(\\"Start time must be earlier than end time\\") active_count = defaultdict(int) for sender_id, _, timestamp in messages: timestamp_dt = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") if start_time_dt <= timestamp_dt <= end_time_dt: active_count[sender_id] += 1 if not active_count: raise ValueError(\\"No messages sent in the given time period\\") most_active = max(sorted(active_count.items()), key=lambda x: (x[1], -x[0])) return most_active[0]"},{"question":"def check_balanced_unary(s: str) -> bool: Checks if the given string with parentheses and unary operators is balanced. Ignores spaces in the string. >>> check_balanced_unary(\\"( + ( - ) )\\") True >>> check_balanced_unary(\\"( + ( - ( + )\\") False >>> check_balanced_unary(\\"( + ( - ) ) ( )\\") True >>> check_balanced_unary(\\"( + ( - ( + ) )\\") False >>> check_balanced_unary(\\"\\") True >>> check_balanced_unary(\\"(((())))\\") True >>> check_balanced_unary(\\"+-\\") True >>> check_balanced_unary(\\"()\\") True >>> check_balanced_unary(\\"(\\") False >>> check_balanced_unary(\\")\\") False >>> check_balanced_unary(\\"(+(-)(+))(-)\\") True >>> check_balanced_unary(\\") + ( - )\\") False","solution":"def check_balanced_unary(s: str) -> bool: Checks if the given string with parentheses and unary operators is balanced. Ignores spaces in the string. # Ignore spaces in the string s = s.replace(\\" \\", \\"\\") stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack or stack[-1] != '(': return False stack.pop() return len(stack) == 0"},{"question":"class CircularBuffer: Implements a circular buffer (ring buffer) with methods to manage buffer overflow seamlessly. >>> cb = CircularBuffer(3) >>> cb.enqueue(10) >>> cb.enqueue(20) >>> cb.enqueue(30) >>> cb.buffer_length() 3 >>> cb.is_full() True >>> cb.dequeue() 10 >>> cb.is_empty() False >>> cb.enqueue(40) >>> cb.dequeue() 20 >>> cb.dequeue() 30 >>> cb.dequeue() 40 >>> cb.is_empty() True def __init__(self, size): pass def buffer_length(self): pass def is_full(self): pass def is_empty(self): pass def enqueue(self, value): pass def dequeue(self): pass","solution":"class CircularBuffer: def __init__(self, size): self.size = size self.buffer = [None] * size self.head = 0 self.tail = 0 self.count = 0 def buffer_length(self): return self.count def is_full(self): return self.count == self.size def is_empty(self): return self.count == 0 def enqueue(self, value): self.buffer[self.tail] = value if self.is_full(): self.head = (self.head + 1) % self.size else: self.count += 1 self.tail = (self.tail + 1) % self.size def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from an empty buffer\\") value = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.count -= 1 return value"},{"question":"from typing import List, Any def generate_subsets(elements: List[Any], length: int) -> List[List[Any]]: Generate all subsets of the given list of elements with the specified length. Parameters: elements (List[Any]): The input list of elements. length (int): The length of each subset. Returns: List[List[Any]]: A list of all subsets of the specified length. Raises: ValueError: If length is negative or greater than the number of elements. Examples: >>> generate_subsets([1, 2, 3, 4], 2) [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] >>> generate_subsets(['a', 'b', 'c'], 1) [['a'], ['b'], ['c']] >>> generate_subsets([1, 2, 3], 3) [[1, 2, 3]] >>> generate_subsets([1, 2, 3], 0) [[]]","solution":"from itertools import combinations from typing import List, Any def generate_subsets(elements: List[Any], length: int) -> List[List[Any]]: Generate all subsets of the given list of elements with the specified length. Parameters: elements (List[Any]): The input list of elements. length (int): The length of each subset. Returns: List[List[Any]]: A list of all subsets of the specified length. Raises: ValueError: If length is negative or greater than the number of elements. if length < 0 or length > len(elements): raise ValueError(\\"length must be non-negative and less than or equal to the number of elements\\") return [list(subset) for subset in combinations(elements, length)]"},{"question":"def can_rotate_string(s: str, goal: str) -> bool: Determines if string 's' can be rotated to become string 'goal'. >>> can_rotate_string(\\"abcde\\", \\"cdeab\\") True >>> can_rotate_string(\\"abcde\\", \\"abced\\") False >>> can_rotate_string(\\"rotation\\", \\"ationrot\\") True >>> can_rotate_string(\\"aabbcc\\", \\"abbcca\\") True >>> can_rotate_string(\\"aabbcc\\", \\"abcabc\\") False >>> can_rotate_string(\\"aaaa\\", \\"aaaa\\") True >>> can_rotate_string(\\"a\\", \\"a\\") True >>> can_rotate_string(\\"a\\", \\"b\\") False >>> can_rotate_string(\\"abc\\", \\"cab\\") True >>> can_rotate_string(\\"abcd\\", \\"acbd\\") False >>> can_rotate_string(\\"abcde\\", \\"bcda\\") False","solution":"def can_rotate_string(s: str, goal: str) -> bool: Determines if string 's' can be rotated to become string 'goal'. if len(s) != len(goal): return False # Concatenate s with itself to handle rotations and check if goal is a substring double_s = s + s return goal in double_s"},{"question":"def compress_text(text: str) -> str: Compress a string using Run-Length Encoding (RLE) >>> compress_text(\\"aaabbc\\") # \\"a3b2c\\" >>> compress_text(\\"abcd\\") # \\"abcd\\" >>> compress_text(\\"aabbcc\\") # \\"a2b2c2\\" >>> compress_text(\\"a\\") # \\"a\\" >>> compress_text(\\"aaa\\") # \\"a3\\" >>> compress_text(\\"aabbaa\\") # \\"a2b2a2\\" pass def decompress_text(compressed_text: str) -> str: Decompress a string using Run-Length Encoding (RLE) >>> decompress_text(\\"a3b2c\\") # \\"aaabbc\\" >>> decompress_text(\\"abcd\\") # \\"abcd\\" >>> decompress_text(\\"a2b2c2\\") # \\"aabbcc\\" >>> decompress_text(\\"a\\") # \\"a\\" >>> decompress_text(\\"a3\\") # \\"aaa\\" >>> decompress_text(\\"a2b2a2\\") # \\"aabbaa\\" pass","solution":"def compress_text(text: str) -> str: if not text or not isinstance(text, str): raise ValueError(\\"Invalid input: text must be a non-empty string\\") compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: compressed.append(text[i-1] + (str(count) if count > 1 else '')) count = 1 compressed.append(text[-1] + (str(count) if count > 1 else '')) return ''.join(compressed) def decompress_text(compressed_text: str) -> str: if not compressed_text or not isinstance(compressed_text, str): raise ValueError(\\"Invalid input: compressed_text must be a non-empty string\\") decompressed = [] i = 0 while i < len(compressed_text): char = compressed_text[i] i += 1 count = 0 while i < len(compressed_text) and compressed_text[i].isdigit(): count = count * 10 + int(compressed_text[i]) i += 1 decompressed.append(char * (count if count != 0 else 1)) return ''.join(decompressed)"},{"question":"from typing import List def find_mode(numbers: List[int]) -> int: Determine the mode of a list of integers. The mode is the number that appears most frequently. If there are multiple numbers with the same highest frequency, return the smallest one. Args: numbers (List[int]): A list of integers containing at least one and at most 10^5 integers. Returns: int: The mode of the list. Example: >>> find_mode([4, 2, 2, 4, 3, 3, 1, 2]) 2 >>> find_mode([1, 1, 2, 2, 3]) 1 >>> find_mode([5]) 5 >>> find_mode([1, 1, 2, 2, 3, 3]) 1 >>> find_mode([7, 3, 7, 3, 7, 4, 4]) 7","solution":"from typing import List from collections import defaultdict def find_mode(numbers: List[int]) -> int: Returns the mode of the list of numbers. In case of a tie, returns the smallest number among the modes. frequency = defaultdict(int) # Calculating frequencies of each number for number in numbers: frequency[number] += 1 # Finding the highest frequency and the corresponding mode max_freq = 0 mode = float('inf') for number, freq in frequency.items(): if freq > max_freq or (freq == max_freq and number < mode): max_freq = freq mode = number return mode"},{"question":"def sort_letters_and_numbers(string: str) -> str: Sorts the letters and numbers in the given string separately while preserving their original positions. Parameters: string (str): The alphanumeric input string. Returns: str: The sorted string with letters and numbers sorted separately. >>> sort_letters_and_numbers(\\"d4a3c2b1\\") == \\"a1b2c3d4\\" >>> sort_letters_and_numbers(\\"h6e3f7g2\\") == \\"e2f3g6h7\\" >>> sort_letters_and_numbers(\\"z3y2x1\\") == \\"x1y2z3\\" >>> sort_letters_and_numbers(\\"a1b2c3\\") == \\"a1b2c3\\" >>> sort_letters_and_numbers(\\"9z8y7x\\") == \\"7x8y9z\\" >>> sort_letters_and_numbers(\\"1b2a\\") == \\"1a2b\\" >>> sort_letters_and_numbers(\\"a1\\") == \\"a1\\" >>> sort_letters_and_numbers(\\"1a\\") == \\"1a\\" >>> sort_letters_and_numbers(\\"4231\\") == \\"1234\\" >>> sort_letters_and_numbers(\\"dcba\\") == \\"abcd\\"","solution":"def sort_letters_and_numbers(string): Sorts the letters and numbers in the given string separately while preserving their original positions. Parameters: string (str): The alphanumeric input string. Returns: str: The sorted string with letters and numbers sorted separately. letters = sorted([c for c in string if c.isalpha()]) numbers = sorted([c for c in string if c.isdigit()]) result = [] l_idx = 0 n_idx = 0 for char in string: if char.isalpha(): result.append(letters[l_idx]) l_idx += 1 else: result.append(numbers[n_idx]) n_idx += 1 return ''.join(result)"},{"question":"import re from collections import defaultdict def find_anagram_sentences(sentences: list) -> dict: Identify anagrams within the list of sentences. >>> find_anagram_sentences([\\"listen\\", \\"silent\\", \\"enlist\\", \\"Rat!\\", \\"Tar\\", \\"Elvis\\", \\"Lives\\", \\"Dog?\\", \\"God!\\"]) {'eilnst': ['listen', 'silent', 'enlist'], 'art': ['Rat!', 'Tar'], 'eilsv': ['Elvis', 'Lives'], 'dgo': ['Dog?', 'God!']} >>> find_anagram_sentences([\\"one\\", \\"two\\", \\"three\\", \\"four\\"]) {'eno': ['one'], 'otw': ['two'], 'eehrt': ['three'], 'foru': ['four']} >>> find_anagram_sentences([\\"Listen\\", \\"Silent\\", \\"EnList\\", \\"Rats!\\", \\"Star\\"]) {'eilnst': ['Listen', 'Silent', 'EnList'], 'arst': ['Rats!', 'Star']} >>> find_anagram_sentences([\\"D!og\\", \\"Go!d\\", \\"d!og\\", \\"God!\\"]) {'dgo': ['D!og', 'Go!d', 'd!og', 'God!']} >>> find_anagram_sentences([]) {}","solution":"import re from collections import defaultdict def find_anagram_sentences(sentences): def clean_sentence(sentence): # Remove spaces and punctuation, convert to lowercase, then sort the characters return ''.join(sorted(re.sub(r'[^a-zA-Z]', '', sentence).lower())) anagram_dict = defaultdict(list) for sentence in sentences: cleaned_sentence = clean_sentence(sentence) anagram_dict[cleaned_sentence].append(sentence) return dict(anagram_dict)"},{"question":"def simplify_path(path: str) -> str: Simplify a given file system path by resolving relative elements and removing redundancy. >>> simplify_path(\\"/home/\\") == \\"/home\\" >>> simplify_path(\\"/../\\") == \\"/\\" >>> simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" >>> simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" >>> simplify_path(\\"/a/b/c/.\\") == \\"/a/b/c\\" >>> simplify_path(\\"/a//b///c/./d\\") == \\"/a/b/c/d\\" >>> simplify_path(\\"/a/../../b/../c//.//\\") == \\"/c\\" >>> simplify_path(\\"/.././foo/./bar/../baz\\") == \\"/foo/baz\\"","solution":"def simplify_path(path: str) -> str: stack = [] components = path.split('/') for component in components: if component == \\"..\\": if stack: stack.pop() elif component and component != \\".\\": stack.append(component) return \\"/\\" + \\"/\\".join(stack)"},{"question":"import heapq def kth_largest_transaction(transactions: list[float], k: int) -> float: Find the k-th largest monetary transaction from the list :param transactions: List of transaction amounts (list of floats) :param k: Integer representing the k-th position to find the largest transaction :return: The k-th largest transaction amount Example: >>> kth_largest_transaction([100.5, 83.1, 99.9, 120.0, 200.75], 2) 120.0 >>> kth_largest_transaction([55.5, 33.3, 77.7, 5.5, 150.6], 4) 33.3 >>> kth_largest_transaction([1.1, -2.3, 3.4, -4.5, 0.0], 3) 0.0 :raises ValueError: If k is not positive or exceeds the number of transactions pass # TODO: Implement this function import pytest def test_kth_largest_transaction_basic_case(): assert kth_largest_transaction([100.5, 83.1, 99.9, 120.0, 200.75], 2) == 120.0 def test_kth_largest_transaction_case2(): assert kth_largest_transaction([55.5, 33.3, 77.7, 5.5, 150.6], 4) == 33.3 def test_kth_largest_transaction_with_negative_values(): assert kth_largest_transaction([1.1, -2.3, 3.4, -4.5, 0.0], 3) == 0.0 def test_kth_largest_transaction_equal_elements(): assert kth_largest_transaction([3.3, 3.3, 3.3, 3.3], 2) == 3.3 def test_kth_largest_transaction_large_k(): assert kth_largest_transaction([50, 12, 65, 22, 100, 33, 5], 7) == 5 def test_kth_largest_transaction_invalid_k_zero(): with pytest.raises(ValueError): kth_largest_transaction([100.5, 83.1, 99.9], 0) def test_kth_largest_transaction_invalid_k_exceeds(): with pytest.raises(ValueError): kth_largest_transaction([55.5, 33.3, 77.7, 5.5, 150.6], 6) def test_kth_largest_transaction_single_element(): assert kth_largest_transaction([42.0], 1) == 42.0","solution":"import heapq def kth_largest_transaction(transactions, k): Find the k-th largest monetary transaction from the list :param transactions: List of transaction amounts (list of floats) :param k: Integer representing the k-th position to find the largest transaction :return: The k-th largest transaction amount if k <= 0: raise ValueError(\\"k must be a positive integer\\") if k > len(transactions): raise ValueError(\\"k exceeds the number of transactions\\") # Use a min-heap of size k to find the k-th largest transaction. min_heap = transactions[:k] heapq.heapify(min_heap) for transaction in transactions[k:]: if transaction > min_heap[0]: heapq.heapreplace(min_heap, transaction) return min_heap[0]"},{"question":"def rotate_array(nums: List[int], k: int) -> List[int]: Rotate the array nums by k steps to the right. if not nums: return nums n = len(nums) k = k % n # handle the case where k is greater than the length of the array nums[:] = nums[-k:] + nums[:-k] return nums def test_rotate_normal_case(): assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] def test_rotate_case_with_negatives(): assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100] def test_rotate_k_greater_than_length(): assert rotate_array([1, 2, 3], 4) == [3, 1, 2] def test_rotate_empty_array(): assert rotate_array([], 3) == [] def test_rotate_single_element_array(): assert rotate_array([1], 10) == [1] def test_rotate_k_zero(): assert rotate_array([1, 2, 3], 0) == [1, 2, 3]","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotate the array nums by k steps to the right. if not nums: return nums n = len(nums) k = k % n # handle the case where k is greater than the length of the array nums[:] = nums[-k:] + nums[:-k] return nums"},{"question":"def paginate_data(records: list, records_per_page: int, page_number: int) -> list: Paginates the given list of records. Args: records (list): A list of records, where each record is represented as a dictionary. records_per_page (int): The number of records to display on each page. page_number (int): The page number (1-indexed) to retrieve. Returns: list: The records for the specified page. If the page number is out of bounds, return an empty list. Examples: >>> records = [ ... {\\"id\\": 1, \\"name\\": \\"Alice\\"}, ... {\\"id\\": 2, \\"name\\": \\"Bob\\"}, ... {\\"id\\": 3, \\"name\\": \\"Charlie\\"}, ... {\\"id\\": 4, \\"name\\": \\"David\\"}, ... {\\"id\\": 5, \\"name\\": \\"Eve\\"} ... ] >>> paginate_data(records, 2, 1) [{\\"id\\": 1, \\"name\\": \\"Alice\\"}, {\\"id\\": 2, \\"name\\": \\"Bob\\"}] >>> paginate_data(records, 2, 2) [{\\"id\\": 3, \\"name\\": \\"Charlie\\"}, {\\"id\\": 4, \\"name\\": \\"David\\"}] >>> paginate_data(records, 2, 3) [{\\"id\\": 5, \\"name\\": \\"Eve\\"}] >>> paginate_data(records, 2, 4) []","solution":"def paginate_data(records: list, records_per_page: int, page_number: int) -> list: Paginates the given list of records. Args: records (list): A list of records, where each record is represented as a dictionary. records_per_page (int): The number of records to display on each page. page_number (int): The page number (1-indexed) to retrieve. Returns: list: The records for the specified page. If the page number is out of bounds, return an empty list. if records_per_page < 1 or page_number < 1: return [] start_index = (page_number - 1) * records_per_page end_index = start_index + records_per_page if start_index >= len(records): return [] return records[start_index:end_index]"},{"question":"def count_consecutive_sum_ways(n: int) -> int: Computes the total number of unique ways to express \`n\` as a sum of two or more consecutive positive integers. >>> count_consecutive_sum_ways(15) 3 >>> count_consecutive_sum_ways(9) 2 >>> count_consecutive_sum_ways(8) 0 pass def test_example_cases(): assert count_consecutive_sum_ways(15) == 3 assert count_consecutive_sum_ways(9) == 2 assert count_consecutive_sum_ways(8) == 0 def test_additional_cases(): assert count_consecutive_sum_ways(5) == 1 # 2+3 assert count_consecutive_sum_ways(1) == 0 # No consecutive sum assert count_consecutive_sum_ways(2) == 0 # No consecutive sum assert count_consecutive_sum_ways(3) == 1 # 1+2 assert count_consecutive_sum_ways(10) == 1 # 1+2+3+4 def test_large_number(): assert count_consecutive_sum_ways(1000000000) > 0 # Check that it handles large inputs properly def test_edge_cases(): assert count_consecutive_sum_ways(4) == 0 # No consecutive sum possible assert count_consecutive_sum_ways(6) == 1 # 1+2+3 def test_complex_cases(): assert count_consecutive_sum_ways(12) == 1 # 3+4+5 assert count_consecutive_sum_ways(21) == 3 # 1+2+3+4+5+6, 6+7+8, 10+11","solution":"def count_consecutive_sum_ways(n: int) -> int: count = 0 k = 1 # Trying to find the values for which \`n\` can be expressed as a sum of \`k\` consecutive integers while (k * (k + 1)) // 2 < n: if (n - (k * (k + 1)) // 2) % (k + 1) == 0: count += 1 k += 1 return count"},{"question":"# Task Implement the function \`min_max_scale(vector: np.ndarray) -> np.ndarray\` which applies Min-Max scaling transformation to a given vector. The Min-Max scaling formula is: [ X' = frac{X - X_{text{min}}}{X_{text{max}} - X_{text{min}}} ] # Function Signature def min_max_scale(vector: np.ndarray) -> np.ndarray: pass # Input: * \`vector\` (np.ndarray): An ndarray representing the input vector where each element will be scaled. # Output: * Returns an ndarray where each element of the initial vector is scaled to the range [0, 1]. # Constraints: * The input vector can have 0 or more elements. * The vector may contain negative values. * If the input vector has all identical elements, the function should return a vector of zeros, because there is no range to scale. # Examples: 1. Input: \`vector = np.array([2, 3, 4, 5])\` Output: \`np.array([0.0, 0.3333, 0.6667, 1.0])\` 2. Input: \`vector = np.array([-3.0, 0.0, 3.0, 6.0])\` Output: \`np.array([0.0, 0.3333, 0.6667, 1.0])\` 3. Input: \`vector = np.array([5, 5, 5, 5])\` Output: \`np.array([0.0, 0.0, 0.0, 0.0])\` # Note: The implementation should handle numerical precision and edge cases gracefully, ensuring the function can transform both small and large datasets efficiently.","solution":"import numpy as np def min_max_scale(vector: np.ndarray) -> np.ndarray: Applies Min-Max scaling to a given vector, scaling each element to the range [0, 1]. Parameters: vector (np.ndarray): Input vector to be scaled. Returns: np.ndarray: Scaled vector with elements ranging between [0, 1]. if vector.size == 0: return vector # Empty array, return as is min_val = np.min(vector) max_val = np.max(vector) if min_val == max_val: return np.zeros_like(vector) # All elements are identical return (vector - min_val) / (max_val - min_val)"},{"question":"def find_kth_smallest(bst: BinarySearchTree, k: int) -> Any: Find the kth smallest element in the BST. If k is out of bounds, return None. Args: bst (BinarySearchTree): An instance of the BinarySearchTree class. k (int): The position (1-based) of the smallest element to find. Returns: Any: The kth smallest element, or None if k is out of bounds. Examples: >>> bst = BinarySearchTree() >>> bst.insert(5).insert(3).insert(7).insert(2).insert(4).insert(6).insert(8) >>> find_kth_smallest(bst, 1) 2 >>> find_kth_smallest(bst, 3) 4 >>> find_kth_smallest(bst, 7) 8 >>> find_kth_smallest(bst, 8) None >>> find_kth_smallest(bst, 0) None >>> bst = BinarySearchTree() >>> find_kth_smallest(bst, 1) None >>> bst = BinarySearchTree() >>> bst.insert(42) >>> find_kth_smallest(bst, 1) 42 >>> find_kth_smallest(bst, 2) None pass class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) return self def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def test_find_kth_smallest(): bst = BinarySearchTree() bst.insert(5).insert(3).insert(7).insert(2).insert(4).insert(6).insert(8) assert find_kth_smallest(bst, 1) == 2 # The smallest element assert find_kth_smallest(bst, 3) == 4 # The 3rd smallest element assert find_kth_smallest(bst, 7) == 8 # The largest element assert find_kth_smallest(bst, 8) is None # Out of bounds assert find_kth_smallest(bst, 0) is None # Out of bounds def test_find_kth_smallest_empty_tree(): bst = BinarySearchTree() assert find_kth_smallest(bst, 1) is None def test_find_kth_smallest_single_node(): bst = BinarySearchTree() bst.insert(42) assert find_kth_smallest(bst, 1) == 42 assert find_kth_smallest(bst, 2) is None","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) return self def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def find_kth_smallest(bst, k): def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right) # Perform inorder traversal of the tree elements = inorder_traversal(bst.root) # Check if k is within bounds if k < 1 or k > len(elements): return None return elements[k-1]"},{"question":"def bubble_sort_with_constraints(arr: list) -> list: Sort an array using bubble sort with the following enhancements: - Ensure input validation. - Implement early stopping for optimization. - Maintain the position of \`None\` values. Parameters: arr (list): List of integers and \`None\` values to be sorted. Returns: list: Sorted list with \`None\` values in their original positions. Raises: ValueError: If the input is not a list or contains non-integer, non-None elements. Examples: >>> bubble_sort_with_constraints([3, 1, 4, 1, 5]) [1, 1, 3, 4, 5] >>> bubble_sort_with_constraints([10, -1, 2, 8, -3]) [-3, -1, 2, 8, 10] >>> bubble_sort_with_constraints([2, 1, None, 4, 3]) [1, 2, None, 3, 4] pass def test_sorted_case(): assert bubble_sort_with_constraints([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_reverse_sorted_case(): assert bubble_sort_with_constraints([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_unsorted_case(): assert bubble_sort_with_constraints([3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] def test_mixed_none_case(): assert bubble_sort_with_constraints([2, 1, None, 4, 3]) == [1, 2, None, 3, 4] def test_all_none_case(): assert bubble_sort_with_constraints([None, None, None]) == [None, None, None] def test_empty_list(): assert bubble_sort_with_constraints([]) == [] def test_single_element(): assert bubble_sort_with_constraints([1]) == [1] def test_negative_numbers(): assert bubble_sort_with_constraints([10, -1, 2, 8, -3]) == [-3, -1, 2, 8, 10] def test_input_validation_not_list(): try: bubble_sort_with_constraints(\\"not a list\\") except ValueError as e: assert str(e) == \\"Input must be a list.\\" def test_input_validation_non_integer_elements(): try: bubble_sort_with_constraints([1, 2, \\"three\\", 4]) except ValueError as e: assert str(e) == \\"All elements of the list must be integers or None.\\"","solution":"def bubble_sort_with_constraints(arr: list) -> list: Sort an array using bubble sort with the following enhancements: - Ensure input validation. - Implement early stopping for optimization. - Maintain the position of \`None\` values. Parameters: arr (list): List of integers and \`None\` values to be sorted. Returns: list: Sorted list with \`None\` values in their original positions. Raises: ValueError: If the input is not a list or contains non-integer, non-None elements. Examples: >>> bubble_sort_with_constraints([3, 1, 4, 1, 5]) [1, 1, 3, 4, 5] >>> bubble_sort_with_constraints([10, -1, 2, 8, -3]) [-3, -1, 2, 8, 10] >>> bubble_sort_with_constraints([2, 1, None, 4, 3]) [1, 2, None, 3, 4] if not isinstance(arr, list): raise ValueError(\\"Input must be a list.\\") for element in arr: if not (isinstance(element, int) or element is None): raise ValueError(\\"All elements of the list must be integers or None.\\") n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): # Skip None elements during comparison if arr[j] is not None and arr[j + 1] is not None: if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break # Sort only the non-None elements and maintain the position of None elements non_none_values = [x for x in arr if x is not None] non_none_values.sort() result = [] non_none_index = 0 for value in arr: if value is None: result.append(None) else: result.append(non_none_values[non_none_index]) non_none_index += 1 return result"},{"question":"def find_closest(nums, target): Finds the number in the sorted list nums that is closest to the given target. If there are two numbers equally close to the target, returns the smaller number. Args: nums (List[int]): A sorted list of integers. target (int): The target integer. Returns: int: The integer from the list that is closest to the target. Raises: ValueError: If the input list nums is empty. Examples: >>> find_closest([1, 3, 5, 8, 10], 7) 8 >>> find_closest([1, 2, 3], 4) 3 # Your code here","solution":"def find_closest(nums, target): Finds the number in the sorted list nums that is closest to the given target. If there are two numbers equally close to the target, returns the smaller number. if not nums: raise ValueError(\\"The input list nums is empty.\\") low, high = 0, len(nums) - 1 # If the target is less than or equal to the first element, return the first element if target <= nums[low]: return nums[low] # If the target is greater than or equal to the last element, return the last element if target >= nums[high]: return nums[high] # Binary search to find the closest number while low <= high: mid = (low + high) // 2 if nums[mid] == target: return nums[mid] if target < nums[mid]: high = mid - 1 else: low = mid + 1 # Post-processing to determine the closest if (abs(nums[low] - target) < abs(nums[high] - target)) or (abs(nums[low] - target) == abs(nums[high] - target) and nums[low] < nums[high]): return nums[low] else: return nums[high]"},{"question":"class HashMap: A basic hash map data structure using separate chaining to handle collisions. Methods: - put(key: str, value: int) -> None: Associates the specified value with the specified key. - get(key: str) -> int: Retrieves the value associated with the specified key. If the key does not exist, it raises a KeyError with the message \\"Key not found\\". - remove(key: str) -> None: Removes the key-value pair associated with the specified key. If the key does not exist, it simply does nothing. Example Usage: >>> hash_map = HashMap() >>> hash_map.put(\\"apple\\", 1) >>> hash_map.put(\\"banana\\", 2) >>> hash_map.get(\\"apple\\") # Output: 1 >>> hash_map.get(\\"banana\\") # Output: 2 >>> hash_map.put(\\"banana\\", 4) >>> hash_map.get(\\"banana\\") # Output: 4 >>> hash_map.remove(\\"orange\\") >>> try: hash_map.get(\\"orange\\") # Raises KeyError: \\"Key not found\\" except KeyError: print(\\"Key not found\\") >>> hash_map.remove(\\"lemon\\") # Does nothing as \\"lemon\\" is not in the map def __init__(self) -> None: pass def put(self, key: str, value: int) -> None: pass def get(self, key: str) -> int: pass def remove(self, key: str) -> None: pass # Test cases def test_put_and_get(): hashmap = HashMap() hashmap.put(\\"apple\\", 1) hashmap.put(\\"banana\\", 2) assert hashmap.get(\\"apple\\") == 1 assert hashmap.get(\\"banana\\") == 2 def test_update_value(): hashmap = HashMap() hashmap.put(\\"apple\\", 1) hashmap.put(\\"apple\\", 2) assert hashmap.get(\\"apple\\") == 2 def test_remove(): hashmap = HashMap() hashmap.put(\\"apple\\", 1) hashmap.remove(\\"apple\\") try: hashmap.get(\\"apple\\") assert False, \\"Expected KeyError\\" except KeyError: assert True def test_remove_non_existent_key(): hashmap = HashMap() hashmap.remove(\\"non_existent\\") # Should not raise any exception assert True def test_collision_handling(): hashmap = HashMap() key1 = \\"key1\\" key2 = \\"key2\\" hashmap.put(key1, 1) hashmap.put(key2, 2) assert hashmap.get(key1) == 1 assert hashmap.get(key2) == 2 def test_multiple_resizes(): hashmap = HashMap() for i in range(100): hashmap.put(f\\"key{i}\\", i) for i in range(100): assert hashmap.get(f\\"key{i}\\") == i def test_key_not_found(): hashmap = HashMap() try: hashmap.get(\\"non_existent\\") assert False, \\"Expected KeyError\\" except KeyError: assert True if __name__ == \\"__main__\\": test_put_and_get() test_update_value() test_remove() test_remove_non_existent_key() test_collision_handling() test_multiple_resizes() test_key_not_found() print(\\"All tests passed.\\")","solution":"class HashMap: def __init__(self): self._initial_capacity = 8 self._size = 0 self._buckets = [[] for _ in range(self._initial_capacity)] def _hash(self, key): return hash(key) % len(self._buckets) def _resize(self): new_capacity = len(self._buckets) * 2 new_buckets = [[] for _ in range(new_capacity)] for bucket in self._buckets: for key, value in bucket: new_index = hash(key) % new_capacity new_buckets[new_index].append((key, value)) self._buckets = new_buckets def put(self, key: str, value: int) -> None: if self._size / len(self._buckets) > 0.7: self._resize() index = self._hash(key) bucket = self._buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self._size += 1 def get(self, key: str) -> int: index = self._hash(key) bucket = self._buckets[index] for k, v in bucket: if k == key: return v raise KeyError(\\"Key not found\\") def remove(self, key: str) -> None: index = self._hash(key) bucket = self._buckets[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self._size -= 1 return"},{"question":"def longest_stock_availability(stock_status: List[int]) -> int: Given a list of integers representing the stock status for consecutive days, find the length of the longest continuous segment where the stock is available (represented by \`1\`). >>> longest_stock_availability([1, 0, 1, 1, 0, 1]) 2 >>> longest_stock_availability([0, 0, 0, 1]) 1 >>> longest_stock_availability([1, 1, 1, 1]) 4 >>> longest_stock_availability([0]) 0 >>> longest_stock_availability([1, 0, 1, 0, 1, 1, 0, 1]) 2","solution":"from typing import List def longest_stock_availability(stock_status: List[int]) -> int: max_length = 0 current_length = 0 for status in stock_status: if status == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"class TemperatureConverter: A class to convert temperatures between Celsius, Fahrenheit, and Kelvin scales. Args: temperature (float): The temperature value. scale (str): The scale of the temperature value, must be one of 'C', 'F', or 'K'. Raises: ValueError: If scale is not 'C', 'F', or 'K'. Methods: to_celsius(self) -> float: Converts the stored temperature to Celsius. to_fahrenheit(self) -> float: Converts the stored temperature to Fahrenheit. to_kelvin(self) -> float: Converts the stored temperature to Kelvin. def __init__(self, temperature: float, scale: str): pass def to_celsius(self) -> float: pass def to_fahrenheit(self) -> float: pass def to_kelvin(self) -> float: pass import pytest def test_init_invalid_scale(): with pytest.raises(ValueError): TemperatureConverter(30, 'X') def test_to_celsius_from_celsius(): tc = TemperatureConverter(100, 'C') assert tc.to_celsius() == 100 def test_to_fahrenheit_from_celsius(): tc = TemperatureConverter(100, 'C') assert pytest.approx(tc.to_fahrenheit(), 0.01) == 212.00 def test_to_kelvin_from_celsius(): tc = TemperatureConverter(100, 'C') assert pytest.approx(tc.to_kelvin(), 0.01) == 373.15 def test_to_celsius_from_fahrenheit(): tc = TemperatureConverter(32, 'F') assert pytest.approx(tc.to_celsius(), 0.01) == 0.00 def test_to_kelvin_from_fahrenheit(): tc = TemperatureConverter(32, 'F') assert pytest.approx(tc.to_kelvin(), 0.01) == 273.15 def test_to_celsius_from_kelvin(): tc = TemperatureConverter(273.15, 'K') assert pytest.approx(tc.to_celsius(), 0.01) == 0.00 def test_to_fahrenheit_from_kelvin(): tc = TemperatureConverter(273.15, 'K') assert pytest.approx(tc.to_fahrenheit(), 0.01) == 32.00 # Edge cases def test_low_temperature(): tc = TemperatureConverter(-1e5, 'C') assert tc.to_fahrenheit() == pytest.approx(-179968.00, 0.01) assert tc.to_kelvin() == pytest.approx(-99726.85, 0.01) def test_high_temperature(): tc = TemperatureConverter(1e5, 'C') assert tc.to_fahrenheit() == pytest.approx(180032.00, 0.01) assert tc.to_kelvin() == pytest.approx(100273.15, 0.01)","solution":"class TemperatureConverter: def __init__(self, temperature: float, scale: str): self.temperature = temperature valid_scales = {'C', 'F', 'K'} if scale not in valid_scales: raise ValueError(\\"Scale must be one of 'C', 'F', 'K'\\") self.scale = scale def to_celsius(self) -> float: if self.scale == 'C': return self.temperature elif self.scale == 'F': return (self.temperature - 32) * 5.0 / 9.0 elif self.scale == 'K': return self.temperature - 273.15 def to_fahrenheit(self) -> float: if self.scale == 'C': return (self.temperature * 9.0 / 5.0) + 32 elif self.scale == 'F': return self.temperature elif self.scale == 'K': return (self.temperature - 273.15) * 9.0 / 5.0 + 32 def to_kelvin(self) -> float: if self.scale == 'C': return self.temperature + 273.15 elif self.scale == 'F': return (self.temperature - 32) * 5.0 / 9.0 + 273.15 elif self.scale == 'K': return self.temperature"},{"question":"def count_valid_binary_strings(n: int) -> int: Computes the number of valid binary strings of length n. Each valid binary string is composed only of '0's and '1's and does not contain consecutive '1's. >>> count_valid_binary_strings(1) 2 >>> count_valid_binary_strings(2) 3 >>> count_valid_binary_strings(3) 5 >>> count_valid_binary_strings(4) 8 >>> count_valid_binary_strings(5) 13","solution":"def count_valid_binary_strings(n: int) -> int: Returns the number of valid binary strings of length n. if n == 1: return 2 # \\"0\\" and \\"1\\" # DP array where dp[i] represents the number of valid strings of length i dp = [0] * (n + 1) # Initial conditions dp[1] = 2 # \\"0\\", \\"1\\" dp[2] = 3 # \\"00\\", \\"01\\", \\"10\\" for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"def perfect(number: int) -> bool: Check if a given number is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding the number itself. Parameters: number (int): The number to check. Returns: bool: True if the number is a perfect number, otherwise False. pass from solution import perfect def test_perfect_numbers(): assert perfect(6) == True assert perfect(28) == True assert perfect(496) == True assert perfect(8128) == True def test_non_perfect_numbers(): assert perfect(10) == False assert perfect(100) == False assert perfect(123) == False def test_edge_cases(): assert perfect(0) == False assert perfect(-1) == False assert perfect(-28) == False def test_non_integer_input(): try: perfect(\\"Hello\\") except ValueError as e: assert str(e) == 'number must be an integer' try: perfect(3.14) except ValueError as e: assert str(e) == 'number must be an integer' try: perfect([6]) except ValueError as e: assert str(e) == 'number must be an integer'","solution":"def perfect(number: int) -> bool: Check if a given number is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding the number itself. Parameters: number (int): The number to check. Returns: bool: True if the number is a perfect number, otherwise False. if not isinstance(number, int): raise ValueError('number must be an integer') if number <= 0: return False sum_divisors = sum(i for i in range(1, number) if number % i == 0) return sum_divisors == number"},{"question":"def find_pair_with_sum(arr: list[int], target_sum: int) -> tuple[int, int]: Finds a pair of numbers in a sorted array that adds up to a given target sum. Params: arr (list of ints): A sorted list of integers. target_sum (int): The target sum to find. Returns: tuple: A tuple of two integers representing the pair that adds up to the target sum, or an empty tuple if no such pair exists. Examples: >>> find_pair_with_sum([1, 2, 3, 4, 6], 6) (2, 4) >>> find_pair_with_sum([2, 3, 4, 8, 12], 16) (4, 12) >>> find_pair_with_sum([1, 1, 1, 1], 2) (1, 1) >>> find_pair_with_sum([-1, 0, 1, 2, 3, 4], 3) (-1, 4) >>> find_pair_with_sum([5, 10, 15], 30) () pass","solution":"def find_pair_with_sum(arr, target_sum): Finds a pair of numbers in a sorted array that add up to a given target sum. Params: arr (list of ints): A sorted list of integers. target_sum (int): The target sum for the pair of numbers. Returns: tuple: A tuple containing the pair of numbers that add up to the target sum, or an empty tuple if no such pair exists. left = 0 right = len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target_sum: return (arr[left], arr[right]) elif current_sum < target_sum: left += 1 else: right -= 1 return ()"},{"question":"def rotate_array(arr: list, k: int) -> list: Rotates the array to the right by k positions. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([], 3) [] >>> rotate_array([10, 20], 0) [10, 20]","solution":"def rotate_array(arr: list, k: int) -> list: Rotates the array to the right by k positions. if not arr: return arr n = len(arr) k = k % n # Normalize k to avoid unnecessary full rotations # Split the array into two parts and reverse the order return arr[-k:] + arr[:-k]"},{"question":"from typing import List, Tuple def range_cumulative_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Calculate the cumulative sum of an array for specified ranges. >>> range_cumulative_sum([1, 2, 3, 4, 5], [(0, 2), (1, 3), (2, 4)]) [6, 9, 12] >>> range_cumulative_sum([10, 20, 30, 40], [(0, 1), (1, 2), (0, 3)]) [30, 50, 100] >>> range_cumulative_sum([-1, -2, 3, 4, -5], [(0, 4), (1, 3), (2, 2)]) [-1, 5, 3]","solution":"from typing import List, Tuple def range_cumulative_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns a list of cumulative sums for the given ranges in the array. # Precompute the prefix sums prefix_sums = [0] * (len(arr) + 1) for i in range(len(arr)): prefix_sums[i + 1] = prefix_sums[i] + arr[i] # Generate the result for each query result = [] for start, end in queries: result.append(prefix_sums[end + 1] - prefix_sums[start]) return result"}]`),A={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const s=this.searchQuery.trim().toLowerCase();return s?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(s)||e.solution&&e.solution.toLowerCase().includes(s)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(s=>setTimeout(s,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},C={class:"card-container"},z={key:0,class:"empty-state"},I=["disabled"],P={key:0},D={key:1};function E(s,e,l,h,i,a){const f=g("PoemCard");return r(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"ðŸ¤”prompts chatðŸ§ ")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"ðŸ”",-1)),p(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(r(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," âœ• ")):u("",!0)]),t("div",C,[(r(!0),n(x,null,v(a.displayedPoems,(o,c)=>(r(),y(f,{key:c,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),n("div",z,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(r(),n("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(r(),n("span",D,"Loading...")):(r(),n("span",P,"See more"))],8,I)):u("",!0)])}const B=_(A,[["render",E],["__scopeId","data-v-8aa3cc0c"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/68.md","filePath":"grok/68.md"}'),M={name:"grok/68.md"},W=Object.assign(M,{setup(s){return(e,l)=>(r(),n("div",null,[w(B)]))}});export{O as __pageData,W as default};
