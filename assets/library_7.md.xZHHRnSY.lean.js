import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},j={class:"review-title"},R={class:"review-content"};function I(i,e,u,c,a,s){return n(),r("div",q,[t("div",T,[t("div",j,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const Y=m(k,[["render",I],["__scopeId","data-v-5bcc1e16"]]),F=JSON.parse('[{"question":"You are given an array `tasks` where `tasks[i]` represents the time required to complete the `i-th` task. You have a `deadline` integer representing the maximum time allowed to complete all the tasks, and an integer `rest` representing the minimum time of break required between two consecutive tasks. Determine the maximum number of tasks you can complete in the given time frame including rest periods, without exceeding the `deadline`. Return the _maximum number of tasks_ you can complete.","solution":"def max_tasks(tasks, deadline, rest): tasks.sort() time_spent = 0 completed_tasks = 0 for task in tasks: if time_spent + task <= deadline: time_spent += task completed_tasks += 1 if time_spent + rest <= deadline: time_spent += rest else: break else: break return completed_tasks"},{"question":"You are given a 2D grid of size `m x n` with non-negative integers. The grid represents a map where `grid[i][j]` denotes the height at the cell `(i, j)`. You want to find the length of the longest increasing path in the grid. From each cell, you can move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary. Return _the length of the longest increasing path in the grid_.","solution":"def longest_increasing_path(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[-1] * n for _ in range(m)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] > grid[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) dp[x][y] = max_length return max_length res = 0 for i in range(m): for j in range(n): res = max(res, dfs(i, j)) return res"},{"question":"You are given a list of non-negative integers `arr` representing the heights of pillars in a fence. The width of each pillar is 1. The goal is to select two pillars and build a roof over them such that the water trapped between the pillars and the roof is maximized. The water trapped is the shorter height of the two pillars multiplied by the distance between them. Write a function that returns _the maximum amount of water trapped between two pillars_ in the fence.","solution":"def max_water_trapped(arr): Returns the maximum amount of water trapped between two pillars in the fence. max_water = 0 left = 0 right = len(arr) - 1 while left < right: height = min(arr[left], arr[right]) width = right - left max_water = max(max_water, height * width) if arr[left] <= arr[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given a string `s` and an integer `k`. You can choose any characters from the string and remove them to form a new string. Return the length of the longest new string you can achieve that contains no more than `k` distinct characters.","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 char_count = {} max_length = 0 left = 0 for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an **n**-ary tree defined via a list of parent-child relationships. Each element in the list consists of a pair `[parent, child]` indicating that `child` is a direct descendant of `parent`. Assume the tree is rooted at node `0`. Your task is to determine the height of the tree. The height of the tree is defined as the length of the longest path from the root node to any leaf node. Leaf nodes are those with no children. The list of parent-child relationships defines a valid n-ary tree structure (i.e., no cycles, one root node). You should implement a function to calculate and return the height of the tree.","solution":"def tree_height(pairs): Calculate the height of an n-ary tree defined via a list of parent-child relationships. :param pairs: List of lists, where each sublist contains two elements [parent, child]. :return: Height of the tree. from collections import defaultdict, deque if not pairs: return 0 # Build the adjacency list representation of the tree adjacency_list = defaultdict(list) for parent, child in pairs: adjacency_list[parent].append(child) # Function to perform DFS and find the height def dfs(node): if not adjacency_list[node]: return 1 # Leaf node else: return 1 + max(dfs(child) for child in adjacency_list[node]) # The tree is rooted at node 0 return dfs(0)"},{"question":"You are given an array of integers `arr` and an integer `k`. You can make at most `k` operations on the array, where in each operation, you can either: 1. Remove a single element from the array. 2. Increment a single element of the array by 1. Your goal is to make all elements in the array equal using at most `k` operations. Return `true` if it is possible to make all elements equal using at most `k` operations, otherwise return `false`.","solution":"def can_make_equal(arr, k): Determines if it\'s possible to make all elements in the array equal using at most k operations. An operation is either removing a single element or incrementing a single element by 1. :param arr: List[int] - The input array of integers. :param k: int - The maximum number of allowed operations. :return: bool - True if possible to make all elements in the array equal, otherwise False. if len(arr) <= 1: # If array has 0 or 1 elements, they are trivially equal return True arr.sort() median = arr[len(arr) // 2] min_ops = sum(abs(x - median) for x in arr) return min_ops <= k"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You can perform the following operation on `s` any number of times: Select any substring of `s` and reverse it. Your task is to determine if you can transform `s` into a given target string `t` by performing the above operation. Return _true_ if it is possible, otherwise return _false_. Both `s` and `t` are of the same length.","solution":"def can_transform(s, t): Determine if string `s` can be transformed into string `t` by reversing any substrings any number of times. Both strings are of the same length and consist only of characters \'a\', \'b\', and \'c\'. # Sorting the strings s and t sorted_s = sorted(s) sorted_t = sorted(t) # If sorted versions of strings are equal, then t can be transformed from s return sorted_s == sorted_t"},{"question":"You are given a list of `logs` representing file operations in a system. Each log entry is a string with three components: the operation (\\"CREATE\\", \\"DELETE\\", \\"RENAME\\"), the filename, and, in the case of a \\"RENAME\\" operation, the new filename. For example, a log entry might be `\\"CREATE file1.txt\\"`, `\\"DELETE file2.txt\\"`, or `\\"RENAME file1.txt file3.txt\\"`. Initially, the system is empty with no files. Write a function that processes each log entry in the given order and returns a list of files that exist in the system after processing all the log entries. If multiple operations are performed on the same file, ensure the system accurately reflects the final state of the file system.","solution":"def process_logs(logs): files = set() for log in logs: parts = log.split() if parts[0] == \\"CREATE\\": files.add(parts[1]) elif parts[0] == \\"DELETE\\": if parts[1] in files: files.remove(parts[1]) elif parts[0] == \\"RENAME\\": if parts[1] in files: files.remove(parts[1]) files.add(parts[2]) return sorted(list(files))"},{"question":"You are given a 2D grid `mat` of size `m x n` consisting of non-negative integers and an integer `k`. You need to find an array `res` such that `res[i]` denotes the number of elements in the `i-th` row of `mat` that are strictly less than `k`. Return the result array `res` of size `m`.","solution":"def count_less_than_k(mat, k): Returns an array where each element at index i denotes the number of elements in the i-th row of mat that are strictly less than k. :param mat: List[List[int]] - 2D grid of non-negative integers :param k: int - integer to compare against :return: List[int] - resulting array of counts res = [] for row in mat: count = sum(1 for value in row if value < k) res.append(count) return res"},{"question":"Implement a class `MovingAverage` that calculates the moving average of the last `n` values seen so far. The class should support the following methods: 1. `__init__(self, size: int)`: Initialize the object with the size of the window `size`. 2. `next(self, val: int) -> float`: Calculate and return the moving average of the last `n` values of the stream, including the new `val`. A moving average is the sum of the last `n` values divided by `n`. If there are fewer than `n` values, then it is the sum of the values so far divided by the number of values.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the moving average with a fixed size window. self.size = size self.queue = deque(maxlen=size) self.sum = 0 def next(self, val: int) -> float: Calculate and return the moving average of the last n values. if len(self.queue) == self.size: self.sum -= self.queue.popleft() self.queue.append(val) self.sum += val return self.sum / len(self.queue)"},{"question":"You are given a **0-indexed** integer array `height` representing the heights of students in a row. A student is considered \\"visible\\" if they are taller than every student in front of them. Write a function that returns the number of visible students in the row. * For example, given `height = [1, 3, 2, 4, 3]`, the visible students are `3` and `4` because no student in front of them is taller. Return _the number of visible students_.","solution":"def visible_students(height): Returns the number of visible students in a row. :param height: List[int] representing the heights of the students in a row :return: int representing the number of visible students count = 0 max_height = 0 for h in height: if h > max_height: count += 1 max_height = h return count"},{"question":"Implement a class `FileSystem` that manages a simple in-memory hierarchical file system. The file system allows you to create paths, store file contents, and retrieve file contents. Paths use forward slashes (`/`) to separate directories. Each directory or file name consists only of lowercase English letters. Paths are guaranteed to be valid; no two different paths will share the same directory or file name at any level. The class should support the following methods: - `FileSystem()`: Initializes the file system with an empty directory structure. - `bool createPath(string path, string value)`: Creates a path and sets the value at that path. Returns `true` if the path is successfully created, and `false` if the path already exists or if its parent path does not exist. - `string getPath(string path)`: Returns the value assigned to `path`, or an empty string if the path does not exist. Example usage: ``` FileSystem fs = new FileSystem(); fs.createPath(\\"/a\\", \\"1\\"); // Returns true fs.createPath(\\"/a/b\\", \\"2\\"); // Returns true fs.createPath(\\"/c/d\\", \\"3\\"); // Returns false because the parent path \\"/c\\" does not exist fs.getPath(\\"/a\\"); // Returns \\"1\\" fs.getPath(\\"/a/b\\"); // Returns \\"2\\" fs.getPath(\\"/c\\"); // Returns \\"\\" ```","solution":"class FileSystem: def __init__(self): self.paths = {} def createPath(self, path, value): parts = path.split(\'/\') current = self.paths for part in parts[1:-1]: if part not in current: return False current = current[part] if parts[-1] in current: return False current[parts[-1]] = {} current[parts[-1]][\'value\'] = value return True def getPath(self, path): parts = path.split(\'/\') current = self.paths for part in parts[1:]: if part not in current: return \\"\\" current = current[part] return current.get(\'value\', \\"\\")"},{"question":"You are given a string `equation`, representing a mathematical equation of the form `A*B=C` where `A`, `B`, and `C` are positive integers. Your task is to determine if there is a way to add exactly one multiplication sign (`*`) to the left-hand side of the equation such that the entire equation remains valid. For example, if the equation is `3*5=15`, adding the multiplication sign again should not affect the equation, as `3*5=15` is already valid. Write a function that returns: * `True` if there is a valid way to add a multiplication sign to the left-hand side to make the equation still valid. * `False` if there is no such way to keep the equation valid by adding a multiplication sign. **Note:** You can assume the given string `equation` is always in the correct form.","solution":"def is_valid_equation(equation): left, right = equation.split(\'=\') A, B = left.split(\'*\') A, B, C = int(A), int(B), int(right) # Check if A * B = C if A * B == C: return True return False"},{"question":"You are given a string `s` consisting of lowercase characters and an array `indices` of the same length. The array `indices` contains a permutation of the `s` indices such that `indices[i]` indicates the position where the character `s[i]` should be moved in the new string. Return _the new string after repositioning each character from` s` according to `indices`._ Implement the function `rearrangeString(s, indices)` that performs the repositioning and returns the modified string.","solution":"def rearrangeString(s, indices): Repositions characters in the string `s` according to the `indices` array. Parameters: s (str): The input string consisting of lowercase characters. indices (list): The list of indices representing the new positions of the characters in `s`. Returns: str: The rearranged string. # Initialize a list of the same length as `s` with empty characters rearranged = [\'\'] * len(s) # Place each character in its new position for i, index in enumerate(indices): rearranged[index] = s[i] # Join the list into a string and return return \'\'.join(rearranged)"},{"question":"Implement a class `Excel` that simulates a simple version of an Excel spreadsheet. The class should support the following operations: - `Excel(int H, char W)`: Initializes an Excel object with `H` rows and columns from \'A\' to the given `W` column (inclusive), using 1-based indexing. Rows are indexed from 1 to `H`. - `void set(int row, char column, int value)`: Sets the value at the cell `(row, column)` to `value`. - `int get(int row, char column)`: Returns the value at the cell `(row, column)`. - `int sum(int row, char column, List<String> numbers)`: Returns the sum of the values of cells allocated within the range represented by `numbers` and updates the cell `(row, column)` to this sum. Each string in `numbers` represents a cell or a rectangular range of cells. For example, `[\\"A1\\", \\"A1:B2\\", \\"A1:A2\\"]`. **Example:** ```text Excel(3, \'C\'); set(1, \'A\', 2); sum(3, \'C\', [\\"A1\\", \\"A1:B2\\", \\"A1:A2\\"]); get(3, \'C\'); // Returns 16 ```","solution":"class Excel: def __init__(self, H, W): Initializes an Excel object with H rows and columns from \'A\' to the given W column (inclusive), using 1-based indexing. self.H = H self.W = ord(W) - ord(\'A\') + 1 self.grid = [[0] * self.W for _ in range(H)] self.formulas = {} def set(self, row, column, value): Sets the value at the cell `(row, column)` to `value`. self.grid[row-1][ord(column)-ord(\'A\')] = value if (row, column) in self.formulas: del self.formulas[(row, column)] def get(self, row, column): Returns the value at the cell `(row, column)`. if (row, column) in self.formulas: return self.calculate_formula(row, column) return self.grid[row-1][ord(column)-ord(\'A\')] def sum(self, row, column, numbers): Returns the sum of the values of cells allocated within the range represented by `numbers` and updates the cell `(row, column)` to this sum. self.formulas[(row, column)] = numbers return self.calculate_formula(row, column) def calculate_formula(self, row, column): total_sum = 0 for part in self.formulas[(row, column)]: total_sum += self.evaluate_range(part) self.grid[row-1][ord(column)-ord(\'A\')] = total_sum return total_sum def evaluate_range(self, part): if \':\' in part: start, end = part.split(\':\') start_row, start_col = int(start[1:]), start[0] end_row, end_col = int(end[1:]), end[0] total_sum = 0 for r in range(start_row, end_row+1): for c in range(ord(start_col), ord(end_col)+1): total_sum += self.get(r, chr(c)) return total_sum else: return self.get(int(part[1:]), part[0])"},{"question":"You are given an integer array `nums`. An element `nums[i]` is called **special** if it is greater than or equal to all the elements to its right in the array. Return _the number of special elements in the array._ For example, given the array `nums = [16, 17, 4, 3, 5, 2]`, the special elements are `[17, 5, 2]`, so the output should be `3`.","solution":"def count_special_elements(nums): Returns the number of special elements in the array `nums`. An element nums[i] is called special if it is greater than or equal to all the elements to its right. if not nums: return 0 special_elements_count = 0 max_so_far = float(\'-inf\') # Traverse from right to left for num in reversed(nums): if num >= max_so_far: special_elements_count += 1 max_so_far = num return special_elements_count"},{"question":"You are given a list of strings `words` and a target string `startString`. We want to form a new string by concatenating some of the words from `words` in any order such that the resulting string starts with `startString`. Return _the **length** of the longest possible concatenated string that can be formed under these conditions_. If no such concatenation is possible, return `0`.","solution":"from itertools import permutations def longest_concatenated_length(words, startString): Returns the length of the longest possible concatenated string that starts with startString. max_len = 0 for perm in permutations(words): concatenated = \'\'.join(perm) if concatenated.startswith(startString): max_len = max(max_len, len(concatenated)) return max_len"},{"question":"You are given two arrays `words1` and `words2` consisting of lowercase English letters. A string `b` from array `words2` is a universal string for array `words1` if for every string `a` in `words1`, all the characters in `b` appear in `a`. More formally, for every string `a` in `words1` and for every character `c` in `b`, the character `c` should appear in `a` at least as many times as it appears in `b`. Return a list of all the universal strings in `words2`. The answer can be returned in any order.","solution":"from collections import Counter from functools import reduce def word_subsets(words1, words2): def count(word): return Counter(word) max_b_count = reduce(lambda a, b: a | b, map(count, words2), Counter()) def is_universal(a): return not max_b_count - count(a) return [word for word in words1 if is_universal(word)]"},{"question":"You are given a string `s` containing only English lowercase letters. Your task is to modify `s` such that no two adjacent characters are the same. You can delete any number of characters from the string. Return _**the minimum number of deletions** required to achieve this_.","solution":"def min_deletions_to_avoid_adjacent_duplicates(s): Returns the minimum number of deletions required so that no two adjacent characters are the same. Parameters: s (str): the input string consisting of lowercase English letters Returns: int: the minimum number of deletions required deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"Given a string `s`, find the length of the **longest subsequence** consisting of unique characters in `s` where the characters appear in alphabetical order. If there are multiple longest subsequences, return the length of any one of them.","solution":"def longest_unique_alphabetical_subsequence_length(s): Returns the length of the longest subsequence consisting of unique characters that appear in alphabetical order in the given string s. if not s: return 0 unique_chars = set(s) unique_sorted_chars = sorted(unique_chars) return len(unique_sorted_chars)"},{"question":"Given an array of integers `heights` representing the height of a bar at each index, compute the amount of water it is able to trap after raining. Water is trapped between the bars, and each bar can hold as much water as the shortest bar around it minus its own height. The water trapped on the outermost bars will always be zero. Return the total amount of water trapped. (Note: You may assume that the width of each bar is 1 unit.)","solution":"def trap(height): Given a list of integer heights representing the height of bars, return the amount of water trapped after raining. :param height: List[int] :return: int if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"You are given a binary tree with `n` nodes, where each node contains a unique integer value. Write a function that finds the path from the root node to a given target node. The path should be represented as a list of integers, corresponding to the values of the nodes in the order they are visited. If the target node does not exist in the tree, return an empty list. **Example**: ``` Input: root = [5, 3, 8, 1, 4, 7, 10], target = 4 Output: [5, 3, 4] Input: root = [5, 3, 8, 1, 4, 7, 10], target = 11 Output: [] ``` **Note**: - The binary tree is represented in the input as an array where the parent-child relationship is maintained as follows: root = `tree[0]`, left child of `tree[i]` = `tree[2*i + 1]`, right child of `tree[i]` = `tree[2*i + 2]`. Return _the path from the root to the given target node as a list of integers, or an empty list if the target does not exist_.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def array_to_bst(arr): Converts a list representing a binary tree in level order into a BST. if not arr: return None root = TreeNode(arr[0]) queue = [root] i = 1 while i < len(arr): current = queue.pop(0) if i < len(arr) and arr[i] is not None: current.left = TreeNode(arr[i]) queue.append(current.left) i += 1 if i < len(arr) and arr[i] is not None: current.right = TreeNode(arr[i]) queue.append(current.right) i += 1 return root def find_path(root, target): Finds the path from root to the target node and returns it as a list of values. If the target node does not exist, returns an empty list. path = [] def helper(node, target): if not node: return False path.append(node.val) if node.val == target: return True if helper(node.left, target) or helper(node.right, target): return True path.pop() return False if helper(root, target): return path else: return [] def find_path_in_tree(arr, target): Combines array_to_bst and find_path to implement the main functionality. root = array_to_bst(arr) return find_path(root, target)"},{"question":"Given an array of integers `nums` where `nums[i]` represents the `i-th` person\'s queue position ticket, write a function to determine the minimum number of minutes needed for everyone in the queue to get their ticket. The queue follows these rules: - Each person takes exactly 1 minute to get their ticket. - Initially, `i-th` person will be served first at `nums[i]` ticket position. - However, after the `i-th` person is served, they move to the back of the line if their ticket count is not zero, otherwise they leave the queue. - The process continues until all tickets are collected by the respective persons. Write a function `tickets_waiting_time(nums)` that takes an array `nums` and returns the minimum minutes required to serve all the tickets in the queue.","solution":"def tickets_waiting_time(nums): Returns the minimum number of minutes needed for everyone in the queue to get their ticket. total_time = 0 while nums: for i in range(len(nums)): if nums[i] > 0: nums[i] -= 1 total_time += 1 if nums[i] == 0: break nums = [ticket for ticket in nums if ticket > 0] return total_time"},{"question":"You are given a log of stock prices for a company over a span of `n` days, represented by an integer array `prices` where `prices[i]` is the price of the stock on the `i-th` day. Implement a function `bool predictProfit(vector<int>& prices)` that determines if there is a way to choose two different days `a` and `b` such that `prices[a] < prices[b]` and `a < b`, meaning you can make a profit by buying the stock on day `a` and selling it on day `b`. The function should return `true` if you can make a profit, otherwise return `false`.","solution":"def predictProfit(prices): Determines if there is a way to make a profit by buying and then selling the stock on different days. Parameters: prices (list): List of stock prices over n days. Returns: bool: True if there is a way to make a profit, False otherwise. if not prices: return False min_price = float(\'inf\') for price in prices: if price > min_price: return True min_price = min(min_price, price) return False"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. A substring of `s` is called **distinct** if it contains no duplicate characters. Return _the **maximum** number of distinct substrings of **length** `k` that can be found in `s`_. Note: - If there are no substrings of length `k` in `s`, return 0. - A substring is a contiguous sequence of characters within a string.","solution":"def max_distinct_substrings(s, k): Returns the number of distinct substrings of length k in s. if k > len(s): return 0 distinct_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] # Check if all characters in the substring are unique if len(set(substring)) == k: distinct_substrings.add(substring) return len(distinct_substrings)"},{"question":"[Question] 4: Given a string `s` containing only characters `\'a\'`, `\'b\'`, and `\'c\'`, you need to **remove** the minimum number of characters from `s` such that the resultant string does not contain any **three** consecutive characters being the same. Return the resultant string after the removals. If there are multiple valid results, return any of them.","solution":"def remove_consecutive_chars(s): Removes the minimum number of characters from s such that there are no three consecutive characters being the same. :param s: Input string containing only \'a\', \'b\', and \'c\' :return: String with no three consecutive characters being the same. if not s: return s result = [s[0], s[1]] # The first two characters remain as they are for i in range(2, len(s)): if s[i] != result[-1] or s[i] != result[-2]: # Check if the current char does not form three consecutive same chars result.append(s[i]) return \'\'.join(result)"},{"question":"You are given an **integer array** `nums` and an integer `k`. The task is to find the smallest length contiguous subarray whose sum is greater than or equal to `k`. If no such subarray exists, return `-1`. Return _the length of the smallest subarray_. Consider using a sliding window approach to efficiently find the solution.","solution":"def smallest_subarray_length(nums, k): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to k. If no such subarray exists, return -1. n = len(nums) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length <= n else -1"},{"question":"Given an array of integers `arr`, determine if it is possible to partition the array into **two non-empty subarrays** such that the sum of the elements in both subarrays are **equal**. Return `true` if such a partition exists, and `false` otherwise.","solution":"def can_partition(arr): Determine if the array can be partitioned into two non-empty subarrays with equal sum. total_sum = sum(arr) # If the total sum is odd, we cannot partition it into two equal sum parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 for i in range(len(arr) - 1): current_sum += arr[i] if current_sum == target_sum: return True return False"},{"question":"Given an integer array `arr` where each element represents a position on a number line, and an integer `k`, you need to group the elements of `arr` into a minimum number of intervals such that the length of each interval is at most `k`. An interval is defined by its minimum and maximum values, and its length is the difference between these two values. Return the minimum number of intervals needed to cover all elements of `arr`.","solution":"def min_intervals(arr, k): Returns the minimum number of intervals needed to cover all elements of `arr` such that the length of each interval is at most `k`. Parameters: arr (list of int): List of integers representing positions on a number line. k (int): Maximum length of each interval. Returns: int: Minimum number of intervals. if not arr: return 0 arr.sort() intervals = 0 i = 0 n = len(arr) while i < n: # Start of the interval start = arr[i] intervals += 1 # Move to the farthest point that can be included in this interval while i < n and arr[i] <= start + k: i += 1 return intervals"},{"question":"A company\'s workforce is organized as a tree structure where each employee (except for the CEO) has exactly one direct manager. The CEO has no manager. Given the root node `ceo` of the company\'s hierarchy tree and an integer `employeesCount`, return the smallest subtree that contains exactly `employeesCount` employees. If multiple subtrees have the same size, return any one of them. Each node in the tree represents an employee and contains an integer `id` and a list of their direct subordinates (`subordinates`).","solution":"class TreeNode: def __init__(self, id): self.id = id self.subordinates = [] def find_smallest_subtree_with_exact_employees(root, employeesCount): Returns the root of the smallest subtree that contains the exact number of employees specified. if not root: return None # Helper function to count the nodes in the subtree def count_nodes(node): if not node: return 0 count = 1 # Count the node itself for child in node.subordinates: count += count_nodes(child) return count # Result variables best_subtree_root = None best_diff = float(\'inf\') # Helper function to traverse the tree and find the best subtree def traverse(node): nonlocal best_subtree_root, best_diff if not node: return 0 # Count the number of employees in the current subtree current_count = count_nodes(node) # Check if the current subtree is the best one so far current_diff = abs(current_count - employeesCount) if current_diff < best_diff: best_diff = current_diff best_subtree_root = node # Traverse the subtree of each child for child in node.subordinates: traverse(child) traverse(root) return best_subtree_root"},{"question":"You are given an integer array `arr` and an integer `k`. The array is initially sorted in non-decreasing order, but then `k` elements are rotated from the end to the beginning. Implement a function `findMinInRotatedArray` that returns the minimum element in the array. The function should have a time complexity of O(log n). You can assume that all the integers in `arr` are unique.","solution":"def findMinInRotatedArray(arr): Returns the minimum element in the k-rotated sorted array. Time complexity should be O(log n). left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[right]: # Minimum is in the right part left = mid + 1 else: # Minimum is in the left part right = mid return arr[left]"},{"question":"You are given an array `citations` where `citations[i]` is the number of citations a researcher received for their `i-th` paper. A researcher has an `h-index` of `h` if `h` of their `n` papers have at least `h` citations each, and the other `n - h` papers have no more than `h` citations each. If there are several possible values for `h`, the maximum one is taken as the `h-index`. Calculate and return the researcher\'s h-index.","solution":"def h_index(citations): Calculates the h-index of a researcher based on their citations. Parameters: citations (list of int): A list where citations[i] is the number of citations a researcher received for their i-th paper. Returns: int: The h-index of the researcher. citations.sort(reverse=True) h = 0 for i, c in enumerate(citations): if i + 1 <= c: h = i + 1 else: break return h"},{"question":"You are given a binary tree represented by the root node `root`. A binary tree is considered balanced if for every node in the tree, the depth of the left and right subtrees differ by at most 1. Write a function to determine if the given binary tree is balanced. Return _true_ if the tree is balanced, otherwise return _false_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root: TreeNode) -> bool: Determines if a binary tree is balanced. def height(node): if not node: return 0 left_height = height(node.left) if left_height == -1: return -1 right_height = height(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return 1 + max(left_height, right_height) return height(root) != -1"},{"question":"You are provided with two strings, `s1` and `s2`, containing only lowercase letters. Your task is to determine if `s2` contains a permutation of `s1`. In other words, you need to check if there exists a substring in `s2` that is an anagram of `s1`. Implement the function `boolean containsPermutation(String s1, String s2)` that returns `true` if `s2` contains a permutation of `s1`, and `false` otherwise.","solution":"from collections import Counter def contains_permutation(s1, s2): Returns True if s2 contains any permutation of s1 as a substring, otherwise False. len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return False s1_counter = Counter(s1) window_counter = Counter(s2[:len_s1]) if s1_counter == window_counter: return True for i in range(len_s1, len_s2): window_counter[s2[i]] += 1 window_counter[s2[i - len_s1]] -= 1 if window_counter[s2[i - len_s1]] == 0: del window_counter[s2[i - len_s1]] if s1_counter == window_counter: return True return False"},{"question":"You are given an array of `n` integers `nums`, where there may be duplicate elements. Your task is to find all unique triplets in the array that sum up to zero. Each triplet should be in non-descending order, and the solution set must not contain duplicate triplets. Return the list of all unique triplets that give the sum of zero. The order of the output triplets does not matter.","solution":"def three_sum(nums): nums.sort() result = [] n = len(nums) for i in range(n-2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i+1, n-1 while left < right: s = nums[i] + nums[left] + nums[right] if s < 0: left += 1 elif s > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left+1]: left += 1 while left < right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 return result"},{"question":"You are given an array of integers `arr` which is guaranteed to have a special property: the array is such that its elements first increase to a certain point (peak) and then decrease. Your task is to find the highest peak in this \\"mountain\\" array. For example, in the array `[2, 4, 8, 6, 3, 1]`, the peak is `8`. Write a function that returns the peak element.","solution":"def find_peak(arr): Given a mountain array, find and return the peak element. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return arr[left]"},{"question":"You are given a binary string `s` that consists only of the characters \'0\' and \'1\'. You need to remove exactly one \'0\' from the string and the result must have the maximum number of consecutive \'1\'s. Return the maximum number of consecutive \'1\'s you can achieve after removing exactly one \'0\'. If there\'s no \'0\' in the string, return the length of the longest consecutive sequence of \'1\'s directly.","solution":"def maximum_consecutive_ones(s): Returns the maximum number of consecutive \'1\'s achievable by removing exactly one \'0\'. max_ones = 0 current_ones = 0 left_ones = 0 for i in range(len(s)): if s[i] == \'1\': current_ones += 1 else: left_ones = current_ones current_ones = 0 max_ones = max(max_ones, left_ones + current_ones) return max_ones if \'0\' in s else len(s)"},{"question":"You are given a matrix `matrix` of integers and an integer `target`. You are allowed to perform an operation any number of times where you can increase or decrease a matrix element by `1`. Your task is to find the **minimum number of operations** required to make the matrix an identical matrix with all elements equal to `target`. If it is not possible to make all elements equal to `target`, return `-1`. Note: - An identical matrix has all elements with the same value. - You can only move from one element to another by either increasing or decreasing it by `1`. Example: ``` matrix = [[1, 2], [3, 4]], target = 2 Minimum operations = 4 ``` Explanation: - Increase `1` to `2`: 1 operation. - Decrease `3` to `2`: 1 operation. - Decrease `4` to `2`: 2 operations. - Total = 1 + 1 + 2 = 4 operations.","solution":"def min_operations(matrix, target): Returns the minimum number of operations required to make the matrix an identical matrix with all elements equal to target. If not possible, returns -1. if not matrix: return -1 num_rows = len(matrix) num_cols = len(matrix[0]) total_operations = 0 for row in range(num_rows): for col in range(num_cols): total_operations += abs(matrix[row][col] - target) return total_operations"},{"question":"You are given an integer array `nums` of size `n`. A **homogeneous subarray** is defined as a contiguous subarray where all elements are the same. Return _the length of the `\'longest contiguous homogeneous subarray\'`_. If there are multiple such subarrays of the same maximum length, return the length of any one of them.","solution":"def longest_homogeneous_subarray(nums): if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"You are given a `n x n` grid of integers `grid` representing a grid of cookies, where `grid[i][j]` is the number of cookies present in the cell `(i, j)`. You are also given an integer `k`. Your goal is to divide this grid into exactly `k` non-overlapping rectangular parts such that the number of cookies in each part is the same. Each part must contain at least one cell. Return `True` if it is possible to divide the grid in such a way, otherwise return `False`.","solution":"def can_divide_grid_equally(grid, k): Returns True if it is possible to divide the grid into k non-overlapping rectangular parts such that the number of cookies in each part is the same, otherwise returns False. def total_cookies_in_grid(grid): return sum(sum(row) for row in grid) # Total number of cookies in the grid total_cookies = total_cookies_in_grid(grid) # Check if the total number of cookies is divisible by k if total_cookies % k != 0: return False target_cookies_per_part = total_cookies // k n = len(grid) # Function to check if a rectangular partition has the exact required cookies def has_target_cookies(start_row, end_row, start_col, end_col, target): total_or_partition = sum(grid[i][j] for i in range(start_row, end_row + 1) for j in range(start_col, end_col + 1)) return total_or_partition == target # Checking possible combinations to partition the grid into k parts for row_divs in range(1, n + 1): # Number of row divisions for col_divs in range(1, n + 1): # Number of column divisions if row_divs * col_divs != k: continue row_heights = [n // row_divs] * row_divs col_widths = [n // col_divs] * col_divs if row_divs * (n // row_divs) != n: row_heights[-1] += n % row_divs if col_divs * (n // col_divs) != n: col_widths[-1] += n % col_divs start_row = 0 partition_valid = True for row_part in range(row_divs): start_col = 0 for col_part in range(col_divs): end_row = start_row + row_heights[row_part] - 1 end_col = start_col + col_widths[col_part] - 1 if not has_target_cookies(start_row, end_row, start_col, end_col, target_cookies_per_part): partition_valid = False break start_col = end_col + 1 if not partition_valid: break start_row = end_row + 1 if partition_valid: return True return False"},{"question":"You are given a list of integers `nums` representing positions of houses along a street, and an integer `k` representing the maximum distance you can travel starting from any house. You need to divide all houses into clusters such that the maximum distance between any two houses in a cluster is no more than `k`. Return _the minimum number of clusters required_. For example, given `nums = [1, 2, 3, 10, 11, 12]` and `k = 2`, the clusters would be `[1, 2, 3]` and `[10, 11, 12]`, resulting in a total of 2 clusters.","solution":"def min_clusters(nums, k): Returns the minimum number of clusters required such that the maximum distance between any two houses in a cluster is no more than k. if not nums: return 0 nums.sort() clusters = 1 start = nums[0] for i in range(1, len(nums)): if nums[i] - start > k: clusters += 1 start = nums[i] return clusters"},{"question":"Given a string `s` consisting of lowercase letters, determine whether it can be transformed into a palindrome by performing at most one operation, where an operation consists of replacing one character in the string with any other character. Return `true` if it is possible to form a palindrome by performing at most one operation, otherwise return `false`. Consider the string to be non-empty and contains only lowercase alphabetical characters.","solution":"def can_be_palindrome_with_one_change(s): Determines whether the string s can be transformed into a palindrome by performing at most one operation. :param s: A string consisting of lowercase letters :return: True if it can be transformed into a palindrome with at most one change, False otherwise def is_palindrome(s): return s == s[::-1] n = len(s) for i in range(n // 2): if s[i] != s[n - 1 - i]: # Check by ignoring one character mismatch either from left or right left_str = s[:i] + s[i + 1:] right_str = s[:n - 1 - i] + s[n - i:] return is_palindrome(left_str) or is_palindrome(right_str) # If the loop completes without finding mismatches or exactly one mismatch which can be replaced return True"},{"question":"Design a system to manage a library\'s book inventory. Each book in the library has a unique identifier. Implement the `Library` class: * `Library()` Initializes the library with an empty inventory. * `void addBook(int bookId)` Adds a book with the given `bookId` to the inventory if it does not already exist. * `void removeBook(int bookId)` Removes the book with the given `bookId` from the inventory if it exists. * `bool checkBook(int bookId)` Returns `true` if the book with the given `bookId` is in the inventory, and `false` otherwise. Note: Each `bookId` is a unique integer, and the inventory should only store unique `bookId` values.","solution":"class Library: def __init__(self): Initializes the library with an empty inventory. self.inventory = set() def addBook(self, bookId): Adds a book with the given bookId to the inventory if it does not already exist. self.inventory.add(bookId) def removeBook(self, bookId): Removes the book with the given bookId from the inventory if it exists. self.inventory.discard(bookId) def checkBook(self, bookId): Returns True if the book with the given bookId is in the inventory, and False otherwise. return bookId in self.inventory"},{"question":"You are given a string `s` composed of lowercase English letters and an integer `k`. You need to construct the lexicographically largest string possible by performing exactly `k` operations on `s`. In one operation, you can select any character in the string and move it to the end of the string. Return _the lexicographically largest string_ you can construct after exactly `k` operations.","solution":"def lexicographically_largest_string(s, k): if k == 1: # For k==1, find the lexicographically largest rotation of the string max_string = s for i in range(1, len(s)): rotated = s[i:] + s[:i] if rotated > max_string: max_string = rotated return max_string else: # For k>1, we can sort the string in descending order return \'\'.join(sorted(s, reverse=True))"},{"question":"Given a binary tree where each node represents a digit between 0 and 9, each root-to-leaf path represents a number. Find the total sum of all the numbers represented by root-to-leaf paths in the given binary tree. The tree is provided in the form of a TreeNode object with `val` as the digit value and `left` and `right` as pointers to the left and right child nodes, respectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_numbers(root): Returns the sum of all root-to-leaf numbers. :param root: TreeNode, the root of the binary tree :return: int, the total sum of all root-to-leaf numbers def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"You are given a string `s` containing only characters `(` and `)`. A valid parentheses string is either **empty** or can be written as `AB` (A and B are both valid parentheses strings) or `(A)` (A is a valid parentheses string). Remove the minimum number of parentheses (either `(` or `)`, in any positions) so that the resulting parentheses string is valid. Return a string representing the valid parentheses string that can be obtained. If there are multiple solutions, return any of them.","solution":"def min_remove_to_make_valid(s): Removes the minimum number of parentheses to make the given string valid. indices_to_remove = set() stack = [] for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: indices_to_remove.add(i) indices_to_remove = indices_to_remove.union(set(stack)) result = [char for i, char in enumerate(s) if i not in indices_to_remove] return \\"\\".join(result)"},{"question":"You are given a grid of `n` rows and `m` columns, represented as a 2D list `grid`, where each cell contains an integer. A move consists of selecting any element from the grid and increasing its value by 1. Your task is to make all the elements in the grid equal using the minimum number of moves. Return the minimum number of moves required. Note that you can only increment the integers.","solution":"def min_moves_to_equal_grid(grid): Returns the minimum number of moves required to make all the elements in the grid equal. # Flatten the grid to a 1D list flattened_grid = [cell for row in grid for cell in row] # Find the maximum element in the grid max_element = max(flattened_grid) # Calculate the total moves needed moves = 0 for value in flattened_grid: moves += max_element - value return moves"},{"question":"You have an array of integers `arr` and an integer `n`. You need to find all unique subsets of the array that sum up to `n`. Return the list of these subsets sorted lexicographically. In a subset, each element must appear in the order they are present in the original array `arr`. If there are no such subsets, return an empty list.","solution":"from itertools import combinations def find_subsets_that_sum_to_n(arr, n): def find_subsets(arr, n): result = [] for r in range(1, len(arr) + 1): for sub in combinations(arr, r): if sum(sub) == n: result.append(sub) return result subsets = find_subsets(arr, n) unique_subsets = list(set(subsets)) unique_subsets = [list(sub) for sub in unique_subsets] unique_subsets.sort() return unique_subsets"},{"question":"You are tasked with developing a simulation for a parking lot management system. The parking lot has `n` parking spaces, labeled from `1` to `n`. You are given a sequence of `events`, where each event is represented as a string. Each string can be one of the following: * \\"arrive X\\": A car arrives and wants to park in space `X`, if it is available. If it is occupied, the car leaves without parking. * \\"depart X\\": A car departs from space `X`. Return an array representing the final occupancy of the parking spaces, where each element is a boolean, `True` if the space is occupied and `False` if it is free. The initial state of all parking spaces is empty (all `False`).","solution":"def manage_parking_lot(n, events): Simulate a parking lot management system with `n` parking spaces and given events. Parameters: n (int): The number of parking spaces. events (list of str): List of events where each event is in the form \\"arrive X\\" or \\"depart X\\". Returns: list of bool: A list representing the final occupancy of the parking spaces. parking_lot = [False] * n # initialize all spaces as empty for event in events: action, space = event.split() space = int(space) - 1 # convert 1-based index to 0-based if action == \\"arrive\\": if not parking_lot[space]: parking_lot[space] = True elif action == \\"depart\\": parking_lot[space] = False return parking_lot"},{"question":"Given an array of integers `nums`, you need to find the maximum sum that can be obtained by selecting a subsequence of the array such that no two elements are adjacent in the original array. Return _the maximum sum you can obtain by selecting a non-adjacent subsequence_. Example: Input: `nums = [3, 2, 5, 10, 7]` Output: `15` Explanation: The maximum sum can be obtained by selecting the subsequence `[3, 10]` or `[2, 10, 3]`, summing up to 15.","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum obtained by selecting a subsequence of the array such that no two elements are adjacent in the original array. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize the two variables indicating the maximal sum including and excluding the previous element include = nums[0] exclude = 0 for i in range(1, len(nums)): # New exclude will be the maximum of the previous include and exclude new_exclude = max(include, exclude) # New include will be the previous exclude plus the current element include = exclude + nums[i] exclude = new_exclude # The answer will be the maximum of include and exclude return max(include, exclude)"},{"question":"You are given a string `s` consisting of only lowercase English letters. You need to transform this string into a new string `t` by rearranging its characters and then choosing a non-empty substring `t\'` such that the following conditions are met: * The substring `t\'` appears in the first half of `t` and in the second half of `t`. * Both occurrences of `t\'` in `t` are disjoint. Return the maximum possible length of such a substring `t\'`. If no such substring exists, return 0.","solution":"def max_substring_length(s): Returns the maximum length of a substring that can appear in both the first half and the second half of the rearranged string s, with both occurrences being disjoint. n = len(s) max_len = 0 for length in range(1, n // 2 + 1): # length of the substring from 1 to n//2 for i in range(n - 2 * length + 1): sub = s[i:i + length] if sub in s[i + length:]: max_len = max(max_len, length) return max_len"},{"question":"You are given a **0-indexed** integer array `height` of length `n` representing the heights of blocks lined up in a row. The width of each block is `1`. You want to fully cover these blocks with water such that the water starts accumulating from index 1 and can flow up to index n-2. The water can only be retained between blocks, i.e., water is retained between the tallest blocks on the left and right. You should return _the maximum amount of water that can be retained_ after it rains. Water cannot be retained beyond the boundary blocks.","solution":"def trap(height): Returns the maximum amount of water that can be retained. if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(1, n - 1): water += max(min(left_max[i], right_max[i]) - height[i], 0) return water"},{"question":"Given a list of `n` non-negative integers representing the amount of rainwater trapped per unit space in between the peaks after `n` consecutive rainy days, write a function that returns the total amount of trapped rainwater. The list represents the height of each peak separated by unit spaces. Rainwater is trapped when there are peaks of greater height on either side of a valley.","solution":"def trap_rainwater(heights): Returns the total amount of rainwater trapped between the peaks. :param heights: List of non-negative integers representing the height of peaks. :return: Integer representing the total trapped rainwater units. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"You are given a matrix `mat` of size `m x n`, where each element is either a `0` or a `1`. In one move, you can select any `0` and flip it to `1`, but this can only be done if flipping this `0` will create a rectangle (including a square) of all `1`s in the matrix. Return _the size of the largest rectangle of `1`s that you can create_ after performing any number of such moves. If no such move can be performed, return the size of the largest rectangle of `1`s in the original matrix. For example: * If `mat = [[1,0,1],[0,0,1],[1,0,1]]`, the best move would turn `mat` into `[[1,1,1],[0,0,1],[1,0,1]]`, making the largest rectangle `3 x 1 = 3`. * If `mat = [[0,0,0],[0,0,0],[0,0,0]]`, you can\'t create any rectangle of `1`s, so the maximum possible size of the rectangle remains `0`.","solution":"def maximalRectangle(matrix): def max_histogram_area(height): stack = [] max_area = 0 index = 0 while index < len(height): if not stack or height[stack[-1]] <= height[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (height[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (height[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area if not matrix: return 0 max_area = 0 height = [0] * len(matrix[0]) for row in matrix: for index, val in enumerate(row): if val == 0: height[index] = 0 else: height[index] += 1 max_area = max(max_area, max_histogram_area(height)) return max_area"},{"question":"You are given two strings `s` and `goal`. Your task is to determine if you can obtain `goal` by rotating `s` exactly **one** time. A string rotation involves moving the first character of `s` to the end of the string. If it is possible to obtain `goal` by performing this operation exactly once on `s`, return `true`. Otherwise, return `false`.","solution":"def rotate_string_once(s, goal): Checks if goal can be obtained by rotating s exactly one time. if len(s) != len(goal): return False rotated_s = s[1:] + s[0] return rotated_s == goal"},{"question":"You are given a binary matrix `mat` of size `m x n`. A **0-1 matrix** is a matrix that contains only `0`s and `1`s. In one **move**, you can choose any row or column and flip all its values (note that flipping means changing `0` to `1` and `1` to `0`). Your task is to return _the minimum number of moves required to make all the rows of the matrix equal_.","solution":"def min_moves_to_equal_rows(mat): def flip(row): return [1 - x for x in row] m = len(mat) n = len(mat[0]) patterns = {} for row in mat: original = tuple(row) flipped = tuple(flip(row)) if original not in patterns: patterns[original] = 0 if flipped not in patterns: patterns[flipped] = 0 patterns[original] += 1 patterns[flipped] += 1 max_count = max(patterns.values()) return m - max_count"},{"question":"A **binary tree** is given where each node contains a **positive integer**. Each path from the root to the leaves forms a number by concatenating the values of the nodes along the path. For example, if a path contains nodes with values `[1, 2, 3]`, the number would be `123`. Given the root of such a binary tree, return _the sum of all the numbers formed by all possible paths from the root to the leaves_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Returns the sum of all numbers formed by root-to-leaf paths in a binary tree. def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: # if it\'s a leaf return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"You are given a non-negative integer array `nums`. Every element appears twice except for one element which appears only once. Write a function that finds the element that only appears once in linear time and using constant extra space. Return the single element.","solution":"def find_single(nums): Finds the single element in a list where every other element appears twice. :param nums: List[int] :return: int unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"Given a list of `n` unique integers, where each integer is between 1 and `n` (inclusive), your task is to find and return the minimum number of swaps required to sort the list in ascending order. Each swap can only involve two elements from the list. Aim to develop an efficient algorithm with a time complexity less than `O(n^2)`.","solution":"def min_swaps_to_sort(arr): Finds the minimum number of swaps needed to sort an array of unique integers. :param arr: List[int] - A list of n unique integers where each integer is between 1 and n (inclusive). :return: int - The minimum number of swaps required to sort the list in ascending order. n = len(arr) # Create a list of tuples where each tuple is (value, index) arr_pos = [(value, index) for index, value in enumerate(arr)] # Sort the array by the value arr_pos.sort(key=lambda x: x[0]) # To keep track of visited elements. Initialize all elements as not visited. visited = [False for _ in range(n)] # Initialize result result = 0 for i in range(n): # already in the correct place or already visited if visited[i] or arr_pos[i][1] == i: continue # find out the number of nodes in this cycle cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr_pos[x][1] cycle_size += 1 # Add the number of swaps required for this cycle to the result if cycle_size > 0: result += (cycle_size - 1) return result"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the length of the longest substring that contains at most `k` distinct characters. If `k` is 0, return 0. Write a function that accomplishes this using an efficient algorithm, such as a sliding window approach.","solution":"def length_of_longest_substring_k_distinct(s, k): Given a string s and an integer k, returns the length of the longest substring that contains at most k distinct characters. if k == 0: return 0 n = len(s) if n == 0: return 0 left = 0 right = 0 max_length = 0 char_count = {} while right < n: if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"Given an `m x n` matrix `mat` of non-negative integers representing the height of each unit cell in a continent, return _the minimum effort path from the top-left cell to the bottom-right cell_. The effort of a path is the maximum absolute difference in heights between two consecutive cells of the path. Return _the minimum effort path_. You can move up, down, left, or right from a cell.","solution":"import heapq def minimum_effort_path(heights): Returns the minimum effort path from the top-left cell to the bottom-right cell in the matrix. if not heights: return 0 rows, cols = len(heights), len(heights[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] effort = [[float(\'inf\')] * cols for _ in range(rows)] effort[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, row, col) while min_heap: current_effort, row, col = heapq.heappop(min_heap) if row == rows - 1 and col == cols - 1: return current_effort for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols: new_effort = max(current_effort, abs(heights[new_row][new_col] - heights[row][col])) if new_effort < effort[new_row][new_col]: effort[new_row][new_col] = new_effort heapq.heappush(min_heap, (new_effort, new_row, new_col)) return effort[-1][-1]"},{"question":"You are given a matrix `grid` of size `m x n` consisting of non-negative integers. A path in the matrix is defined as a sequence of cells where each adjacent pair of cells has consecutive values only, i.e., the difference between the values of two adjacent cells is `1`. Each path can start and end at any cell in the matrix. Return the length of the longest path of consecutive values in the matrix. Note: - You may only move to an adjacent cell using the four possible directions: up, down, left, or right.","solution":"def longest_consecutive_path(grid): if not grid or not grid[0]: return 0 def dfs(x, y, prev_value): # If the coordinates are out of bounds or the current cell value is not consecutive, return 0 if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or (grid[x][y] != prev_value + 1): return 0 if (x, y) in memo: return memo[(x, y)] current_val = grid[x][y] # Explore all four directions: up, down, left, right up = dfs(x-1, y, current_val) down = dfs(x+1, y, current_val) left = dfs(x, y-1, current_val) right = dfs(x, y+1, current_val) # The longest path starting from this cell memo[(x, y)] = 1 + max(up, down, left, right) return memo[(x, y)] memo = {} longest_path = 0 for i in range(len(grid)): for j in range(len(grid[0])): longest_path = max(longest_path, dfs(i, j, grid[i][j]-1)) return longest_path"},{"question":"Given a list of `words` and a string `chars`, you need to determine the length of all words you can form by characters from `chars`. You can use each character in `chars` at most once for each word. Return the total length of all words in the list `words` that can be formed using the characters from `chars`. Example: ``` Input: words = [\\"cat\\",\\"bt\\",\\"hat\\",\\"tree\\"], chars = \\"atach\\" Output: 6 Explanation: The words that can be formed are \\"cat\\" (length 3) and \\"hat\\" (length 3). Total length is 3 + 3 = 6. ``` Note: - The length of `words` and the length of each word are within a reasonable range for practical computation.","solution":"def count_characters(words, chars): from collections import Counter def can_form(word, chars_count): word_count = Counter(word) for char in word_count: if word_count[char] > chars_count.get(char, 0): return False return True chars_count = Counter(chars) total_length = 0 for word in words: if can_form(word, chars_count): total_length += len(word) return total_length"},{"question":"A binary tree is univalued if every node in the tree has the same value. Given the `root` of a binary tree, return `true` if the tree is univalued, or `false` otherwise. * The structure of the TreeNode class is as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isUnivalTree(root): Returns true if the binary tree rooted at `root` is univalued, otherwise false. if not root: return True # Helper function to check univalue. def is_unival(node, value): if not node: return True if node.val != value: return False return is_unival(node.left, value) and is_unival(node.right, value) return is_unival(root, root.val)"},{"question":"You are given a string `s` containing an expression formed by letters and other characters. You need to check if the expression has **balanced parentheses**. An expression has balanced parentheses when: - Every opening parenthesis `(` has a corresponding closing parenthesis `)`. - Closed parentheses must follow the correct order of opening parentheses. Return `true` if the parentheses in the given string are balanced, or `false` otherwise.","solution":"def is_balanced_parentheses(s): Returns true if the parentheses in the given string are balanced, or false otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"You are given a linked list `head` where each node contains a single digit (0-9) and the list represents a non-negative integer in reverse order (i.e., the `head` node contains the least significant digit). Your task is to add one to this number and return the resulting linked list in the same reverse order format. The linked list representation should maintain the existing structure with nodes only containing single digits (0-9). Return the `head` of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_one(head: ListNode) -> ListNode: Adds one to the number represented by the linked list and returns the resulting linked list. carry = 1 current = head while current is not None: new_value = current.val + carry carry = new_value // 10 current.val = new_value % 10 if current.next is None and carry > 0: current.next = ListNode(0) current = current.next return head # Helper function to create a linked list from a list of integers def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for number in lst[1:]: current.next = ListNode(number) current = current.next return head # Helper function to convert a linked list back to a list of integers def linked_list_to_list(head): lst = [] current = head while current is not None: lst.append(current.val) current = current.next return lst"},{"question":"You are given a positive integer `n`. You have to generate an array `arr` of length `n` such that: - Each element at an odd index in `arr` is an odd number. - Each element at an even index in `arr` is an even number. - The values must be consecutive integers starting from 1. Return the resultant array `arr`. If there are multiple valid answers, return any of them.","solution":"def generate_array(n): Generate an array of length n where: - Each element at an odd index is an odd number. - Each element at an even index is an even number. - The values are consecutive integers starting from 1. arr = [0]*n next_odd = 1 next_even = 2 for i in range(n): if i % 2 == 0: arr[i] = next_even next_even += 2 else: arr[i] = next_odd next_odd += 2 return arr"},{"question":"You are working with a stream of integers. Implement the `DataStreamMedian` class to efficiently calculate the median of the integers seen so far. The class should have the following functionality: * `DataStreamMedian()` Initializes the data stream. * `void addNum(int num)` Adds the integer `num` to the data stream. * `double findMedian()` Returns the median of all integers added to the data stream. If the number of integers is even, the median is the average of the two middle numbers; otherwise, it is the middle number.","solution":"import heapq class DataStreamMedian: def __init__(self): self.min_heap = [] self.max_heap = [] def addNum(self, num: int) -> None: heapq.heappush(self.max_heap, -num) if self.max_heap and self.min_heap and -self.max_heap[0] > self.min_heap[0]: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self) -> float: if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2"},{"question":"You are given an integer array `scores` representing the scores of students in a class. Your task is to find and return _the **minimum difference** between the highest and lowest scores among the top `k` scores in the array_. A score is considered as one of the top `k` scores if its rank is within the top `k` scores when all scores are sorted in non-increasing order. For example, if `k=3`, you should find the minimum difference between the maximum and minimum scores among the top 3 highest scores in the array.","solution":"def minimum_difference(scores, k): Finds the minimum difference between the highest and lowest scores among the top k scores. Parameters: scores (list of int): List of student scores. k (int): Number of top scores to consider. Returns: int: Minimum difference between the highest and lowest scores among the top k scores. if k <= 1: return 0 # Sort scores in non-increasing order scores.sort(reverse=True) # Initial minimum difference as high as possible min_diff = float(\'inf\') for i in range(len(scores) - k + 1): current_diff = scores[i] - scores[i + k - 1] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"Given a matrix `grid` with dimensions `m x n` where each cell contains an integer, your task is to find all possible paths from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` of the grid. You can only move either down or right at any point in time. The sum of a path is defined as the sum of all integers along that path. Return _the maximum sum of all possible paths_. Since the answer may be large, return it **modulo** `10^9 + 7`.","solution":"def max_path_sum(grid): Returns the maximum sum of all possible paths from the top-left corner to the bottom-right corner of the grid. MOD = 10**9 + 7 m, n = len(grid), len(grid[0]) # Create a DP table to store the maximum sums dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # Return the maximum sum modulo 10^9 + 7 return dp[m-1][n-1] % MOD"},{"question":"Given a string `s` and a list of words `words`, where each word is a **subsequence** of `s`, find the **shortest** word in `words` that is not a subsequence of `s`. If there are multiple shortest words with the same length, return the lexicographically smallest one. If all words in `words` are subsequences of `s`, return an empty string.","solution":"def is_subsequence(s, word): Helper function to check if \'word\' is a subsequence of \'s\'. it = iter(s) return all(char in it for char in word) def shortest_non_subsequence(s, words): Given a string `s` and a list of words `words`, return the shortest word in `words` that is not a subsequence of `s`. If multiple words have the same length, return the lexicographically smallest one. If all words are subsequences of `s`, return an empty string. non_subsequences = [word for word in words if not is_subsequence(s, word)] if not non_subsequences: return \\"\\" # Find the shortest length among non-subsequences min_length = min(len(word) for word in non_subsequences) # Filter words that have the shortest length shortest_non_subsequence_words = [word for word in non_subsequences if len(word) == min_length] # Return the lexicographically smallest word among the shortest non-subsequences return min(shortest_non_subsequence_words)"},{"question":"You are given a **connected** weighted undirected graph with `n` nodes labeled from `0` to `n-1` and an integer `k`. Each node represents a city, and there is a direct road between certain pairs of cities, with a weight representing the distance of that road. Your task is to determine if there exist at least `k` cities such that each pair of these `k` cities has a path between them with a total distance not exceeding a given threshold `d`. Return `true` _if such a subset of cities exists_, or `false` _if it does not_.","solution":"import heapq def floyd_warshall(n, graph, threshold): # Initialize distance matrix with infinity dist = [[float(\'inf\')] * n for _ in range(n)] # Distance from a node to itself is 0 for i in range(n): dist[i][i] = 0 # Fill in the graph edges for u, v, w in graph: dist[u][v] = dist[v][u] = w # Floyd-Warshall to compute the shortest paths for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def can_find_k_cities_with_threshold(n, graph, k, threshold): dist = floyd_warshall(n, graph, threshold) # Check every combination of `k` nodes from itertools import combinations for combination in combinations(range(n), k): if all(dist[u][v] <= threshold for u, v in combinations(combination, 2)): return True return False"},{"question":"Given a string `s` and an integer `k`, you need to construct a new string by performing some operations. In each operation, you can split `s` into exactly `k` groups (where `k` is a factor of the length of `s`), reverse each group, and then concatenate them back together. Return _the lexicographically smallest string possible_ after any number of operations.","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string possible after any number of operations. In each operation, the string can be split into exactly k groups (where k is a factor of the length of s), reverse each group, and concatenate them back together. from itertools import permutations def reverse_groups(s, k): groups = [s[i:i+k] for i in range(0, len(s), k)] reversed_groups = [group[::-1] for group in groups] return \'\'.join(reversed_groups) factors = [i for i in range(1, len(s)+1) if len(s) % i == 0] smallest_string = s for factor in factors: for perm in permutations([s[i:i+factor] for i in range(0, len(s), factor)]): candidate = \'\'.join(perm) candidate = reverse_groups(candidate, factor) smallest_string = min(smallest_string, candidate) return smallest_string"},{"question":"You are given an array of `n` integers `nums` and an integer `target`. Write a function to return the indices of the two numbers such that they add up to the `target`. The solution should ensure two things: * There is exactly one solution, and you may not use the same element twice. * The solution should aim for an optimal time complexity, preferably better than `O(n^2)`. Return _the indices of the two numbers as an array of length 2, sorted in ascending order_.","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the array that add up to the target. This solution uses a hashmap to find the indices in O(n) time. :param nums: List[int], a list of integers :param target: int, the target sum :return: List[int], the indices of the two numbers that add up to the target num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], index]) num_to_index[num] = index"},{"question":"Given a non-empty array of integers `arr`, find an optimal way to split the array into two non-empty parts such that the absolute difference between the sums of the parts is minimized. Return the minimum possible absolute difference. For example, given the array `[1, 6, 11, 5]`, the optimal way to split the array is `[1, 6, 5]` and `[11]`, with the absolute difference being `|12 - 11| = 1`.","solution":"def find_min_abs_difference(arr): Finds the minimum absolute difference between the sums of two non-empty parts when the array is split optimally. total_sum = sum(arr) n = len(arr) dp = {0} for num in arr: new_dp = dp.copy() for part_sum in dp: new_sum = part_sum + num new_dp.add(new_sum) dp = new_dp min_diff = float(\'inf\') for part_sum in dp: part2_sum = total_sum - part_sum min_diff = min(min_diff, abs(part2_sum - part_sum)) return min_diff"},{"question":"You are given a matrix `grid` of size `n x n` where each cell has the value \'0\' representing water and \'1\' representing land. An island is defined as a group of adjacent \'1\'s (land) connected 4-directionally (horizontal or vertical). You are allowed to change at most one \'0\' (water) into \'1\' (land) to create a larger island. Return the size of the largest island that can be obtained by making at most one change. If no island can be created or expanded, return the size of the largest existing island.","solution":"def largest_island(grid): def dfs(x, y, index): stack = [(x, y)] grid[x][y] = index size = 1 while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 1: grid[nx][ny] = index stack.append((nx, ny)) size += 1 return size n = len(grid) max_island = 0 index = 2 area = {} for i in range(n): for j in range(n): if grid[i][j] == 1: area[index] = dfs(i, j, index) max_island = max(max_island, area[index]) index += 1 if max_island == n * n: return max_island for i in range(n): for j in range(n): if grid[i][j] == 0: surrounding_islands = set() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + dx, j + dy if 0 <= ni < n and 0 <= nj < n and grid[ni][nj] > 1: surrounding_islands.add(grid[ni][nj]) new_island_size = 1 + sum(area[idx] for idx in surrounding_islands) max_island = max(max_island, new_island_size) return max_island"},{"question":"You are given two arrays `startTimes` and `endTimes` of the same length `n`, where `startTimes[i]` and `endTimes[i]` represent the start and end times of the `i`-th event, respectively. Determine the maximum number of non-overlapping events you can attend. Return _the maximum number of non-overlapping events_ you can attend from the given arrays.","solution":"def max_non_overlapping_events(startTimes, endTimes): events = sorted(zip(endTimes, startTimes)) max_events = 0 last_end_time = float(\'-inf\') for end, start in events: if start >= last_end_time: max_events += 1 last_end_time = end return max_events"},{"question":"Given an array of integers `nums` and an integer `k`, return the **total sum** of all contiguous subarrays of size `k` in the array. If the length of `nums` is less than `k`, return 0. You must write an algorithm that runs in `O(n)` time, where `n` is the length of the array.","solution":"def sum_of_contiguous_subarrays(nums, k): Returns the total sum of all contiguous subarrays of size k in the array. If the length of nums is less than k, returns 0. Args: nums : List[int] : the list of integers k : int : the size of the subarrays Returns: int : the total sum of all contiguous subarrays of size k if len(nums) < k: return 0 # Initialize the sum for the first window window_sum = sum(nums[:k]) total_sum = window_sum for i in range(k, len(nums)): window_sum += nums[i] - nums[i - k] total_sum += window_sum return total_sum"},{"question":"You are given a list of items, each item has a value and a weight. You have to pack these items into a knapsack with a weight capacity `W`. Your goal is to maximize the total value of the items in the knapsack. However, there\'s a twist: each item can only be used once, and you can either take it or leave it. Create a function that solves this problem using dynamic programming. Return the maximum value that can be obtained by packing items into the knapsack.","solution":"def knapsack(values, weights, W): Solves the 0/1 knapsack problem using dynamic programming. Parameters: values : list of int The values of the items. weights : list of int The weights of the items. W : int The maximum weight capacity of the knapsack. Returns: int The maximum value that can be obtained by packing items into the knapsack. n = len(values) dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(1, W + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"Write a function `findRotationMatrix` that takes a `3x3` matrix `mat` as input and returns `true` if the matrix can be rotated by 90 degrees clockwise, counter-clockwise, or 180 degrees such that it matches another given `3x3` matrix `target`, otherwise returns `false`.","solution":"def findRotationMatrix(mat, target): Returns True if rotating the input matrix mat by 90 degrees clockwise, counter-clockwise, or 180 degrees results in the target matrix. def rotate_90(matrix): Rotate matrix by 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_180(matrix): Rotate matrix by 180 degrees. return [row[::-1] for row in matrix[::-1]] def rotate_270(matrix): Rotate matrix by 270 degrees clockwise (or 90 degrees counter-clockwise). return [list(row) for row in zip(*matrix)][::-1] if mat == target: return True if rotate_90(mat) == target: return True if rotate_180(mat) == target: return True if rotate_270(mat) == target: return True return False"},{"question":"Given a list of `n` unique integers, write a function to determine the minimum number of swaps required to sort the list in ascending order. A swap means exchanging the positions of any two elements in the list. Return the minimum number of swaps needed.","solution":"def minimum_swaps(arr): Determines the minimum number of swaps required to sort the array in ascending order. n = len(arr) arrpos = [*enumerate(arr)] arrpos.sort(key=lambda it: it[1]) vis = {k: False for k in range(n)} ans = 0 for i in range(n): if vis[i] or arrpos[i][0] == i: continue cycle_size = 0 j = i while not vis[j]: vis[j] = True j = arrpos[j][0] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans"},{"question":"You are given two integer arrays, `nums1` and `nums2`, both with length `n`. Each element in these arrays represents the power level of certain elements. An element in `nums1` can pair with an element in `nums2` if and only if the element in `nums2` is greater than or equal to the element in `nums1`. Your task is to find the maximum number of valid pairs such that each element from `nums1` pairs with exactly one element from `nums2`, and each element from `nums2` pairs with exactly one element from `nums1`. Return the maximum number of valid pairs that can be formed.","solution":"def max_pairs(nums1, nums2): Returns the maximum number of valid pairs such that each element from `nums1` pairs with exactly one element from `nums2`, and each element from `nums2` pairs with exactly one element from `nums1`. nums1.sort() nums2.sort() i, j = 0, 0 pairs = 0 while i < len(nums1) and j < len(nums2): if nums1[i] <= nums2[j]: pairs += 1 i += 1 j += 1 else: j += 1 return pairs"},{"question":"Given a string `s` that consists of only lowercase English letters, you need to split `s` into as many parts as possible that each part is a substring consisting of one type of letter. After splitting, return the _lengths of these parts_ as an array. For example, given `s = \\"aaabbbccc\\"`, the output should be `[3, 3, 3]`. If `s = \\"abaccc\\"`, the output should be `[1, 1, 2, 2]`.","solution":"def split_string_into_parts(s): Splits the string `s` into parts that each part is a substring consisting of one type of letter. Returns the lengths of these parts as an array. if not s: return [] result = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: result.append(count) current_char = char count = 1 result.append(count) return result"},{"question":"You are given an integer array `arr` and a positive integer `k`. Your task is to determine whether there exist `k` distinct indices `i1, i2, ..., ik` in the array such that the absolute difference between any pair of elements at these indices is at most `1`. Return `true` if such indices exist, otherwise return `false`.","solution":"def has_k_indices_with_diff_k(arr, k): from collections import Counter counts = Counter(arr) for num in counts: total_adjacent = counts[num] + counts.get(num + 1, 0) if total_adjacent >= k: return True return False"},{"question":"Given two integers `num1` and `num2`, return the sum of the two numbers without using the operators `+` and `-`. **Note**: You can use bitwise operators such as `^` (bitwise XOR), `&` (bitwise AND), and `<<` (bitwise left shift) to achieve the task. Write a function `getSum(int num1, int num2)` that takes two integer inputs and returns their sum.","solution":"def getSum(num1, num2): Returns the sum of num1 and num2 without using the operators + and -. Uses bitwise operations to achieve the result. # 32-bit mask to handle negative numbers MASK = 0xFFFFFFFF # Keep looping until there is no carry while num2 != 0: # Calculate carry and shift it to the left carry = (num1 & num2) << 1 # Sum without carry using XOR num1 = (num1 ^ num2) & MASK # Update num2 to carry num2 = carry & MASK # If num1 is negative, fix the 32-bit complement discrepancy if num1 <= 0x7FFFFFFF: return num1 else: return ~(num1 ^ MASK)"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to compute the length of the longest path (number of nodes) in the tree where each consecutive node has a difference of 1 in their values (either +1 or -1). The length of the path includes both the starting and ending nodes of the path. Note that the path may start and end at any node in the tree and does not need to go through the root. Each step in the path must move to an adjacent node in the tree (i.e., either to a left or right child). Return the length of the longest such path in the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_consecutive_path(root): def dfs(node, parent, length): nonlocal longest if not node: return if parent and abs(node.val - parent.val) == 1: length += 1 else: length = 1 longest = max(longest, length) dfs(node.left, node, length) dfs(node.right, node, length) longest = 0 dfs(root, None, 0) return longest"},{"question":"Given a 2D integer array `events` where each `events[i] = [startDayi, endDayi, valuei]` represents an event that starts at `startDayi` and ends at `endDayi`, and an integer `k` representing the maximum number of events you can attend, return _the maximum value_ you can get by attending at most `k` events. You can only attend one event at a time, and an event must be fully attended from start to end days (inclusive).","solution":"def maxValue(events, k): from bisect import bisect_right events.sort() # Sort events by starting day # Dynamic Programming with memoization dp = {} def dfs(i, k): if k == 0 or i == len(events): return 0 if (i, k) in dp: return dp[(i, k)] # Skip the current event max_value = dfs(i + 1, k) # Attend the current event next_index = bisect_right(events, [events[i][1]]) max_value = max(max_value, events[i][2] + dfs(next_index, k - 1)) dp[(i, k)] = max_value return max_value return dfs(0, k)"},{"question":"You are given a string `s` representing a file path, which may contain directories (non-empty strings of alphabetic characters), periods (`.`), and slashes (`/`). Write a function to simplify the path to its canonical form. Note that the canonical path must: 1. Always start with a slash (`/`). 2. Eliminate any empty directories resulting from consecutive slashes. 3. Eliminate any directory references to the current directory (a single dot `.`). 4. Resolve any references to the parent directory (double dot `..`), ensuring that the path never goes above the root directory. Return the canonical path that results from applying these simplifications.","solution":"def simplify_path(s): Simplifies the given file path to its canonical form. stack = [] # Split the input path by \'/\' to process each part parts = s.split(\'/\') for part in parts: if part == \'..\': if stack: stack.pop() elif part and part != \'.\': stack.append(part) # Join the stack to form the canonical path canonical_path = \'/\' + \'/\'.join(stack) return canonical_path"},{"question":"You are given a binary tree in which each node contains a value. Write a function `sum_of_levels` that returns a list where each element is the sum of the values of the nodes on that level. The root is at level 0. For example, given the binary tree ``` 1 / 2 3 / 4 5 6 ``` The function should return `[1, 5, 15]` since 1 is the sum of the values on level 0, 5 is the sum of the values on level 1 (2 + 3), and 15 is the sum of the values on level 2 (4 + 5 + 6).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_levels(root): if not root: return [] from collections import deque result = [] queue = deque([root]) while queue: level_sum = 0 level_length = len(queue) for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"You are given two strings `s1` and `s2`. Your task is to find the length of the longest subsequence present in both strings such that the characters of the subsequence are in the same order in both strings. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return the length of this longest subsequence.","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest subsequence present in both strings s1 and s2. m, n = len(s1), len(s2) # Create a 2D array to store the length of the longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The value at dp[m][n] contains the length of the longest common subsequence return dp[m][n]"},{"question":"Given a binary tree, implement an algorithm to flatten the tree into a \\"linked list\\": 1. The \\"linked list\\" should use the same `TreeNode` class where `TreeNode.right` points to the next node in the list and `TreeNode.left` is always `null`. 2. The \\"linked list\\" should be in the same order as a pre-order traversal of the binary tree. For example, given the following tree: ``` 1 / 2 5 / 3 4 6 ``` The flattened tree should look like this: ``` 1 2 3 4 5 6 ``` Your function should return the root of the flattened tree. The tree structure is represented using the `TreeNode` class, which is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` You can assume the input tree is not null and has at least one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flatten the binary tree into a linked list using pre-order traversal. Each tree node will only have right child. # Define a helper recursive function to perform pre-order traversal and flatten def flatten_tree(node): if not node: return None # Flatten left and right subtrees left_tail = flatten_tree(node.left) right_tail = flatten_tree(node.right) # If the node has a left child, we need to shuffle the links if node.left: if left_tail: left_tail.right = node.right node.right = node.left node.left = None # Return the tail of the flattened tree from this node return right_tail if right_tail else left_tail if left_tail else node flatten_tree(root) return root"},{"question":"You are given two strings `s1` and `s2` of equal length consisting of lowercase letters. Your task is to transform `s1` into `s2` using the minimum number of operations, where in one operation, you can choose any substring of `s1` and reverse it. Return the minimum number of operations required to transform `s1` into `s2`.","solution":"def min_operations_to_transform(s1, s2): Returns the minimum number of operations required to transform s1 into s2 by reversing substrings. n = len(s1) # Find the positions in s1 where characters need to be in s2 s1_positions = {char: [] for char in set(s1)} for i, char in enumerate(s1): s1_positions[char].append(i) operations = 0 # Compare and align s1 based on s2 i = 0 while i < n: if s1[i] != s2[i]: # Find the nearest needed character to s1[i] target_char = s2[i] j = i while j < n and s1[j] != target_char: j += 1 # Reverse the substring that brings the target character to position i s1 = s1[:i] + s1[i:j + 1][::-1] + s1[j + 1:] operations += 1 i += 1 return operations"},{"question":"You are given a 2D grid of size `m x n` representing a binary matrix, where each cell is either a `0` (representing water) or a `1` (representing land). An island is a group of connected `1`s (land) connected horizontally or vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected lands). Determine the perimeter of the island. Implement the `islandPerimeter` function: * `int islandPerimeter(vector<vector<int>>& grid)` - The function takes a 2D binary matrix `grid` and returns the perimeter of the island.","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the 2D binary matrix grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Each cell contributes initially 4 to perimeter perimeter += 4 # Check the previous row if r > 0 and grid[r - 1][c] == 1: perimeter -= 2 # Check the previous column if c > 0 and grid[r][c - 1] == 1: perimeter -= 2 return perimeter"},{"question":"Assume you are managing a message queue system that processes messages in the order they are received. Each message has a unique identifier, a sender described by their unique ID, and a creation timestamp. Implement a function that, given a list of messages and a specific sender ID, returns the number of messages sent by that sender that are still in the queue and have not been processed yet. The function should ensure efficient handling of large lists and frequent queries.","solution":"def count_unprocessed_messages(messages, sender_id): Returns the number of unprocessed messages sent by a specific sender. :param messages: List of dictionaries, each dictionary contains: \'id\': unique identifier of the message, \'sender_id\': unique identifier of the sender, \'timestamp\': creation timestamp of the message, \'processed\': boolean indicating if the message is processed or not. :param sender_id: Unique identifier of the sender whose messages are to be counted. :return: Integer count of unprocessed messages from the specified sender. unprocessed_count = sum(1 for message in messages if message[\'sender_id\'] == sender_id and not message[\'processed\']) return unprocessed_count"},{"question":"You are given a linked list of integers `head` and an integer `k`. Return *the head of the linked list after reversing the nodes of the list k at a time*. The length of the linked list is not necessarily a multiple of `k`. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is. You may not alter the values in the nodes, only the nodes themselves may be changed. Implement the function `ListNode* reverseKGroup(ListNode* head, int k)` that reverses the nodes of the list `k` at a time and returns the modified list. **Constraints:** * The number of nodes in the list is `n`. * `1 <= k <= n`, where `n` is the number of nodes in the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(start, end): # This will reverse the linked list from `start` to just before `end` prev, curr = None, start while curr != end: temp = curr.next curr.next = prev prev = curr curr = temp return prev dummy = ListNode(0) dummy.next = head prev = dummy while True: # Check the group length k_tail = prev for _ in range(k): k_tail = k_tail.next if not k_tail: return dummy.next k_head = prev.next # The head of the current k-group next_group_head = k_tail.next # The head of the next group k_tail.next = None # Isolate the k-group prev.next = reverse_linked_list(k_head, None) k_head.next = next_group_head # Connect with the next part of the list prev = k_head # Move the prev to the end of the reversed group return dummy.next"},{"question":"You are given two arrays `startTimes` and `endTimes` representing the start and end times of `n` lectures in a schedule, where `startTimes[i]` is the start time of the `i-th` lecture and `endTimes[i]` is the end time. Your task is to determine if all lectures can be attended by a single person without any overlap. Implement the `Schedule` class: * `Schedule(int[] startTimes, int[] endTimes)` Initializes the schedule with the provided start and end times. * `boolean canAttendAll()` Returns `true` if a single person can attend all the lectures without any overlap, otherwise returns `false`.","solution":"class Schedule: def __init__(self, startTimes, endTimes): Initializes the schedule with the provided start and end times. self.startTimes = startTimes self.endTimes = endTimes def canAttendAll(self): Returns true if a single person can attend all the lectures without any overlap, otherwise false. # Combine start and end times into a list of tuples and sort by start times lectures = sorted(zip(self.startTimes, self.endTimes)) # Iterate through the sorted lectures and check for overlapping for i in range(1, len(lectures)): if lectures[i][0] < lectures[i - 1][1]: # Current lecture starts before the previous one ends return False return True"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` consisting of only `0` and `1`. You want to perform a series of operations to make all the elements in the array equal, either all `0`s or all `1`s. In one operation, you are allowed to select any subarray of length `k` (`1 <= k <= n`) and flip all the bits in that subarray (0 becomes 1 and 1 becomes 0). Return _the minimum number of operations required to make all the elements equal in the array_. If it is impossible to make all elements equal, return `-1`.","solution":"def min_operations_to_make_equal(nums, k): Returns the minimum number of operations required to make all elements in the array equal. If it\'s impossible, return -1. n = len(nums) if k % 2 == 0: return min_operations_even_k(nums, k, n) else: return min_operations_odd_k(nums, k, n) def min_operations_even_k(nums, k, n): Handles the case where k is even. return -1 if nums.count(0) != 0 and nums.count(1) != 0 else 0 def min_operations_odd_k(nums, k, n): Handles the case where k is odd. count0 = nums.count(0) count1 = nums.count(1) return min(count0, count1) The logic of above function is based on: - For even k, all flip operations on any subarray will maintain the same parity of 0s and 1s within a subarray, hence if there is any mixture of 0s and 1s, it\'s impossible. - For odd k, both bits can be flipped which enables making either 0s to 1s or 1s to 0s."},{"question":"Given an integer `n`, return an array `result` where `result[i]` is the number of 1\'s in the binary representation of the integer `i` (for each `i` from `0` to `n`). This task requires you to count the number of binary 1\'s for every number ranging from `0` to `n` and return the results in an array.","solution":"def countBits(n): Given an integer n, returns an array result where result[i] is the number of 1\'s in the binary representation of the integer i for each i from 0 to n. result = [0] * (n + 1) for i in range(1, n + 1): result[i] = result[i >> 1] + (i & 1) return result"},{"question":"You are given a string `s` and an integer `k`. A string is called **interesting** if it contains **at least** `k` distinct characters. You are to determine the length of the shortest consecutive substring of `s` that is **interesting**. If no such substring exists, return `-1`.","solution":"def shortest_interesting_substring(s, k): Returns the length of the shortest consecutive substring of `s` that contains at least `k` distinct characters. If no such substring exists, return `-1`. n = len(s) if k > n: # If k is greater than the length of the string, no such substring can exist return -1 def contains_at_least_k_distinct_chars(subs, k): return len(set(subs)) >= k min_length = float(\'inf\') for i in range(n): visited = set() count = 0 for j in range(i, n): if s[j] not in visited: visited.add(s[j]) count += 1 if count >= k: min_length = min(min_length, j - i + 1) break return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given an array of integers `arr` and an integer `limit`. A **subarray** is defined as a contiguous portion of the array, and its **difference** is the maximum minus the minimum element within that subarray. Return _the length of the longest subarray_ such that the difference between the maximum and minimum values in this subarray is less than or equal to `limit`.","solution":"from collections import deque def longest_subarray_with_limit(arr, limit): Finds the length of the longest subarray such that the difference between the maximum and minimum values in this subarray is <= limit. :param arr: List of integers :param limit: Integer - limit for the subarray\'s max-min difference :returns: Integer - length of the longest valid subarray # Deques to keep track of max and min elements max_deque = deque() min_deque = deque() start = 0 max_length = 0 for end in range(len(arr)): while max_deque and arr[max_deque[-1]] <= arr[end]: max_deque.pop() max_deque.append(end) while min_deque and arr[min_deque[-1]] >= arr[end]: min_deque.pop() min_deque.append(end) while arr[max_deque[0]] - arr[min_deque[0]] > limit: start += 1 if max_deque[0] < start: max_deque.popleft() if min_deque[0] < start: min_deque.popleft() max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a binary tree, imagine each node has an extra pointer called `random` that can point to any node in the tree or be null. Write a function that clones the binary tree. The cloned tree should have the same structure as the original tree, and the `random` pointers should point to the corresponding nodes in the cloned tree. Return the root of the cloned tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, random=None): self.val = val self.left = left self.right = right self.random = random def cloneTree(root): if not root: return None from collections import deque orig_to_copy = {} queue = deque([root]) # Create the new nodes without setting their relationships yet while queue: node = queue.popleft() copy_node = TreeNode(node.val) orig_to_copy[node] = copy_node if node.left: queue.append(node.left) if node.right: queue.append(node.right) # Set left, right, and random pointers for each copied node for orig_node, copy_node in orig_to_copy.items(): if orig_node.left: copy_node.left = orig_to_copy[orig_node.left] if orig_node.right: copy_node.right = orig_to_copy[orig_node.right] if orig_node.random: copy_node.random = orig_to_copy[orig_node.random] return orig_to_copy[root]"},{"question":"Given a string `s` consisting of only lowercase alphabets and an integer `k`, return the lexicographically smallest sub-sequence of `s` of length `k` using distinct characters from `s`. If it is not possible to create such a sub-sequence, return an empty string.","solution":"def smallest_subsequence(s, k): Returns the lexicographically smallest sub-sequence of `s` of length `k` using distinct characters from `s`. If it is not possible, returns an empty string. from collections import Counter # Get the count of each character count = Counter(s) # Check if there are enough distinct characters if len(count) < k: return \\"\\" # Initialize a stack to store the result characters result = [] # Initialize a set to keep track of characters in result result_set = set() for i, char in enumerate(s): # Decrease the count of the current character count[char] -= 1 # If character is already in result, skip it if char in result_set: continue # Maintain result as lexicographically smallest while result and char < result[-1] and len(result) - 1 + len(count) >= k and count[result[-1]] > 0: result_set.remove(result.pop()) # Add character to result and record it in result_set result.append(char) result_set.add(char) # If result of length k is obtained, break the loop if len(result) == k: break # Return the result as a string return \'\'.join(result)"},{"question":"You are given a list of integers `lst` and an integer `k`. Your task is to determine if it is possible to partition the list into exactly `k` non-empty subsets such that the sum of elements in each subset is the same. If it is possible, return `true`; otherwise, return `false`. For example, given the list `[2, 1, 4, 5, 6]` and `k = 2`, the output should be `true` because we can partition the list into subsets `[1, 5]` and `[2, 4, 6]` which both sum to 6.","solution":"def can_partition_k_subsets(nums, k): Determine if it is possible to partition the list `nums` into `k` subsets with equal sum. :param nums: List of integers :param k: Number of subsets :return: True if it\'s possible to partition into `k` subsets with equal sum, otherwise False if not nums or k <= 0: return False total_sum = sum(nums) if total_sum % k != 0: return False # If the total sum is not divisible by k, return False target = total_sum // k nums.sort(reverse=True) used = [False] * len(nums) def can_partition_helper(start_index, number_of_subsets, current_sum): if number_of_subsets == 1: return True if current_sum == target: return can_partition_helper(0, number_of_subsets - 1, 0) for i in range(start_index, len(nums)): if not used[i] and current_sum + nums[i] <= target: used[i] = True if can_partition_helper(i + 1, number_of_subsets, current_sum + nums[i]): return True used[i] = False return False return can_partition_helper(0, k, 0)"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. A **subarray** of `nums` is a contiguous non-empty sequence of elements within `nums`. We define the **weight** of a subarray as the sum of the elements multiplied by the length of that subarray. Your task is to find the **maximum weight** of any subarray of `nums` whose length is `k`. Return the maximum weight as an integer.","solution":"def max_weight_subarray(nums, k): Returns the maximum weight of any subarray of nums whose length is k. Args: nums (list): A list of integers representing the array. k (int): The length of the subarray. Returns: int: The maximum weight of any subarray of length k. n = len(nums) if k > n: return 0 max_weight = current_sum = sum(nums[:k]) max_weight *= k for i in range(k, n): current_sum = current_sum - nums[i - k] + nums[i] max_weight = max(max_weight, current_sum * k) return max_weight"},{"question":"You are given two strings `s` and `t` where `t` is generated by randomly shuffling string `s` and then adding one more letter at a random position. Return the letter that was added to `t`.","solution":"def find_added_letter(s, t): Returns the letter that was added to string t. from collections import Counter # Count characters in both strings counter_s = Counter(s) counter_t = Counter(t) # Find the character with count difference for char in counter_t: if counter_t[char] != counter_s[char]: return char"},{"question":"Given a string `s` representing a sentence containing words separated by single spaces, reverse the characters of each word while maintaining the original word order and return the modified sentence. Ensure your solution has a runtime complexity of O(n), where n is the length of the string.","solution":"def reverse_words_characters(s): Reverse the characters of each word in the sentence while maintaining the original word order. Parameters: s (str): A string representing the sentence with words separated by single spaces. Returns: str: A string with characters of each word reversed. return \' \'.join(word[::-1] for word in s.split())"},{"question":"You are given a string `s` consisting of lowercase English letters. A **duplicate letter** is a letter that appears more than once in the string. Return _a new string_ `result` _which is constructed by removing all duplicate letters from_ `s` _and keeping only the **first occurrence** of each letter in their original order._","solution":"def remove_duplicate_letters(s): Remove all duplicate letters from the string s and keep only the first occurrence of each letter. Parameters: s (str): A string consisting of lowercase English letters. Returns: str: A new string with all duplicates removed, preserving the first occurrence of each letter. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Given a binary tree, implement an algorithm to perform the following operations: 1. **Find the height of the tree**: The height of a binary tree is the number of edges on the longest path from the root to a leaf node. 2. **Count the number of leaf nodes**: A leaf node is a node with no children. 3. **Check if the tree is balanced**: A binary tree is balanced if the difference between the heights of the left and right subtrees of any node in the tree is not more than one. Implement the following methods in the `BinaryTree` class: * `BinaryTree(TreeNode root)` Initializes the object with the root of the binary tree. * `int findHeight()` Returns the height of the tree. * `int countLeafNodes()` Returns the number of leaf nodes in the tree. * `boolean isBalanced()` Returns `true` if the tree is balanced, otherwise `false`. The binary tree is represented using the `TreeNode` class provided below: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def findHeight(self): def height(node): if not node: return -1 return 1 + max(height(node.left), height(node.right)) return height(self.root) def countLeafNodes(self): def countLeaves(node): if not node: return 0 if not node.left and not node.right: return 1 return countLeaves(node.left) + countLeaves(node.right) return countLeaves(self.root) def isBalanced(self): def check_balanced(node): if not node: return 0, True left_height, left_balanced = check_balanced(node.left) right_height, right_balanced = check_balanced(node.right) current_height = 1 + max(left_height, right_height) current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced height, balanced = check_balanced(self.root) return balanced"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a row. Two buildings have a **view** if there are no taller buildings between them. For each building, return _the index of the first building to its right that it can **see**_. If no building can be seen, return `-1` for that building.","solution":"def find_first_visible_building(heights): For each building, returns the index of the first building to its right that it can see. If no building can be seen, returns -1 for that building. n = len(heights) result = [-1] * n stack = [] for i in range(n - 1, -1, -1): while stack and heights[stack[-1]] <= heights[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(i) return result"},{"question":"You are given two strings, `s1` and `s2`, and your task is to determine if `s2` contains a permutation of `s1`. In other words, you need to check if one of `s1`\'s permutations is the substring of `s2`. Implement the `PermutationInclusion` class with the following method: * `boolean checkInclusion(String s1, String s2)` - Returns `true` if `s2` contains a permutation of `s1`, otherwise returns `false`.","solution":"class PermutationInclusion: def checkInclusion(self, s1, s2): from collections import Counter len_s1, len_s2 = len(s1), len(s2) if len_s1 > len_s2: return False s1_count = Counter(s1) window_count = Counter(s2[:len_s1]) if s1_count == window_count: return True for i in range(len_s1, len_s2): start_char = s2[i - len_s1] new_char = s2[i] window_count[new_char] += 1 window_count[start_char] -= 1 if window_count[start_char] == 0: del window_count[start_char] if window_count == s1_count: return True return False"},{"question":"You are given a string `s` containing only lowercase English letters. Your task is to partition the string into as few substrings as possible so that no substring contains more than one distinct letter. Return _a list_ `answer`_, where_ `answer[i]` _is a substring of_ `s` _, and the concatenation of all substrings in the list should be equal to_ `s`. Additionally, the order of substrings in the list should be the same as their order in the original string_.","solution":"def partition_string(s): Partition the string into as few substrings as possible so that no substring contains more than one distinct letter. if not s: return [] partitions = [] current_char = s[0] current_partition = current_char for char in s[1:]: if char == current_char: current_partition += char else: partitions.append(current_partition) current_char = char current_partition = current_char partitions.append(current_partition) return partitions"},{"question":"You are given an integer array `arr` and an integer `k`. Split the array into `k` non-empty subarrays such that the maximum sum among these subarrays is minimized. Return _the minimized maximum sum_. For instance, given `arr = [7, 2, 5, 10, 8]` and `k = 2`, the optimal way to split the array is into `[7, 2, 5]` and `[10, 8]`, and the minimized maximum sum is `18`. You need to implement the function: ``` def splitArray(arr: List[int], k: int) -> int: ``` where: - `arr` is a non-empty list of integers. - `k` is an integer such that `1 <= k <= len(arr)`. - The function returns an integer representing the minimized maximum sum possible.","solution":"def splitArray(arr, k): def canSplit(nums, maxSum, m): count, currentSum = 1, 0 for num in nums: if currentSum + num > maxSum: count += 1 currentSum = num if count > m: return False else: currentSum += num return True left, right = max(arr), sum(arr) while left < right: mid = left + (right - left) // 2 if canSplit(arr, mid, k): right = mid else: left = mid + 1 return left"},{"question":"Given an integer array `arr` and an integer `k`, write a function that returns the number of non-overlapping subarrays with at least `k` elements where every element in the subarray is equal. A subarray is a contiguous part of an array. Implement the function as follows: ``` int countSubarrays(int[] arr, int k) ``` - `countSubarrays(int[] arr, int k)`: Takes an integer array `arr` and an integer `k` as input and returns the number of valid subarrays as described. Ensure your solution efficiently handles the edge cases, such as when `k` is larger than the length of the array, and when the array contains only one distinct element repeated.","solution":"def countSubarrays(arr, k): Returns the number of non-overlapping subarrays with at least k elements where every element in the subarray is equal. if k > len(arr): return 0 count = 0 i = 0 while i < len(arr): j = i while j < len(arr) and arr[j] == arr[i]: j += 1 length = j - i if length >= k: count += length // k i = j return count"},{"question":"Given a string `s` of lowercase alphabets, you are allowed to perform the following operation any number of times: Choose an index `i` (1 <= i <= s.length - 1) and replace the substring `s[i:i+2]` with its reverse. The goal is to convert the string into its lexicographically smallest possible form. Return the lexicographically smallest string that can be achieved after performing the operations any number of times.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be achieved by repeatedly reversing any two-character substring in the input string s. # Convert string to list for in-place manipulation s = list(s) # We can use a simple greedy approach by continually sorting the string n = len(s) for i in range(n - 1): for j in range(n - 1 - i): if s[j] > s[j + 1]: # Swap adjacent characters if they are in wrong order s[j], s[j + 1] = s[j + 1], s[j] # Join the list back into a string return \'\'.join(s)"},{"question":"Given a string `s` consisting of lowercase English letters, you need to calculate the number of distinct non-empty substrings of `s`. Return _the number of distinct substrings_ modulo `10^9 + 7`.","solution":"def distinct_substrings(s): Returns the number of distinct non-empty substrings of the input string `s` modulo 10^9 + 7. Parameters: s (str): A string consisting of lowercase English letters. Returns: int: The number of distinct non-empty substrings of s modulo 10^9 + 7. MOD = 10**9 + 7 n = len(s) # Set to store all unique substrings substrings = set() # Generate substrings for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings) % MOD"},{"question":"You are given a **directed graph** with `n` nodes numbered from `0` to `n - 1` and an integer `source` node. Each node has a `0` or more edges each associated with a **cost** to travel from one node to another node. You are provided with a 2D integer array `edges` where `edges[i] = [ui, vi, costi]` represents a directed edge from node `ui` to node `vi` with a travel cost of `costi`. Your goal is to find the **minimum cost** of traveling from the `source` node to every other node in the graph. If a node is **unreachable** from the source node, the cost to get to that node should be considered as `-1`. Return _an integer array_ `costs` _, where_ `costs[i]` _is the minimum travel cost from the_ `source` _node to node_ `i`_ or `-1` _if the node is unreachable from the_ `source`_.","solution":"import heapq from collections import defaultdict import sys def minimum_costs(n, edges, source): Find the minimum cost to travel from the `source` node to every other node. If a node is unreachable, return -1 for that node. :param n: Number of nodes (indexed from 0 to n-1) :param edges: List of edges where each edge is represented as [ui, vi, costi] :param source: Source node :return: List of minimum costs to each node from the source graph = defaultdict(list) # Build the graph for u, v, cost in edges: graph[u].append((v, cost)) # Initialize distances array with infinities and set the distance to the source itself as 0 costs = [float(\'inf\')] * n costs[source] = 0 # Min-heap to keep track of the minimum cost to travel to each node heap = [(0, source)] while heap: current_cost, u = heapq.heappop(heap) if current_cost > costs[u]: continue for v, cost in graph[u]: next_cost = current_cost + cost if next_cost < costs[v]: costs[v] = next_cost heapq.heappush(heap, (next_cost, v)) # Convert \'inf\' to -1 indicating unreachable nodes return [cost if cost != float(\'inf\') else -1 for cost in costs]"},{"question":"[Question 4]: Given a list of `n` integers where each integer represents the number of files in a folder, you are tasked with writing a function that calculates the total storage space required. Each file has a size of 1 MB. Additionally, there is an overhead cost for each folder which is equal to the number of files in that folder. Return the total storage space required including the overhead. Example: Input: `[3, 5, 2]` Output: `18` Explanation: - The first folder has 3 files, requiring 3 MB of storage, with an overhead of 3 MB. Total for first folder = 3 + 3 = 6 MB. - The second folder has 5 files, requiring 5 MB of storage, with an overhead of 5 MB. Total for second folder = 5 + 5 = 10 MB. - The third folder has 2 files, requiring 2 MB of storage, with an overhead of 2 MB. Total for third folder = 2 + 2 = 4 MB. - Therefore, the total storage required is 6 + 10 + 4 = 20 MB. Implement the function `def total_storage(files: List[int]) -> int:` to return the total storage size required.","solution":"from typing import List def total_storage(files: List[int]) -> int: Calculate the total storage space required including the overhead. Args: files (List[int]): A list of integers where each integer represents the number of files in a folder. Returns: int: The total storage space required in MB. total_space = 0 for file_count in files: total_space += 2 * file_count # 1 MB per file + 1 MB overhead per file return total_space"},{"question":"Given a string `s` containing only lowercase alphabetical characters, you need to determine whether it is possible to rearrange the characters in `s` such that no two adjacent characters are the same. If it is possible, return any valid rearrangement of `s`. If it is not possible, return an empty string. Implement the function `rearrangeString(String s) -> String`.","solution":"from collections import Counter import heapq def rearrangeString(s: str) -> str: Returns a rearranged version of s where no two adjacent characters are the same, or an empty string if no such arrangement is possible. if not s: return \\"\\" # Count frequency of each character counter = Counter(s) # Create a max-heap based on the counts (negative for max heap in python) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap or prev_char: if prev_char and not max_heap: return \\"\\" # It\'s not possible to rearrange # Get the most frequent character count, char = heapq.heappop(max_heap) result.append(char) # Decrease the count of the previous character and push back into the heap if not zero if prev_char: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char if count + 1 < 0 else None prev_count = count + 1 return \'\'.join(result)"},{"question":"Given a binary tree where each node has an integer value, you need to determine the number of possible paths that sum to a given value `S`. A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root. The value of each path should be equal to `S`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, S): def dfs(node, current_sum, prefix_sums): if not node: return 0 current_sum += node.val num_paths_to_curr = prefix_sums.get(current_sum - S, 0) prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1 num_paths_in_left_subtree = dfs(node.left, current_sum, prefix_sums) num_paths_in_right_subtree = dfs(node.right, current_sum, prefix_sums) prefix_sums[current_sum] -= 1 return num_paths_to_curr + num_paths_in_left_subtree + num_paths_in_right_subtree prefix_sums = {0: 1} return dfs(root, 0, prefix_sums)"},{"question":"You are given an array of integers `heights` representing the heights of buildings. Your task is to calculate the **maximum area** of a container that can be formed by two of these buildings and the X-axis. The area of the container is calculated by taking the minimum of the two heights multiplied by the distance between the two indices. Return the maximum area. Implement the function `int maxContainerArea(int[] heights)` that performs this operation and return the result.","solution":"def maxContainerArea(heights): Calculate the maximum area of a container that can be formed by two buildings. :param heights: List of integers representing heights of buildings. :return: Integer representing the maximum area. left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"Given an array of integers `arr`, find the maximum length of a contiguous subarray that contains only unique elements. Return _the length of this subarray_.","solution":"def max_length_unique_subarray(arr): Finds the maximum length of a contiguous subarray of arr that contains only unique elements. Args: arr (List[int]): The input array of integers. Returns: int: The length of the longest contiguous subarray with unique elements. if not arr: return 0 max_length = 0 start = 0 seen = {} # Dictionary to store the last positions of elements for end, value in enumerate(arr): if value in seen and seen[value] >= start: start = seen[value] + 1 seen[value] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a singly linked list `head` where each node contains an integer value, split the linked list into two separate linked lists, `evenList` and `oddList`. The `evenList` should contain nodes from the even positions in the original list, and the `oddList` should contain nodes from the odd positions. Both lists should maintain the order of nodes as they appeared in the original list. Return an array containing the heads of `evenList` and `oddList`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def split_linked_list(head): if not head: return [None, None] even_dummy = ListNode() odd_dummy = ListNode() even_tail = even_dummy odd_tail = odd_dummy current = head index = 1 while current: if index % 2 == 0: even_tail.next = ListNode(current.val) even_tail = even_tail.next else: odd_tail.next = ListNode(current.val) odd_tail = odd_tail.next current = current.next index += 1 return [even_dummy.next, odd_dummy.next] # Function to convert list to linked list for testing convenience def list_to_linked_list(l): if not l: return None head = ListNode(l[0]) current = head for val in l[1:]: current.next = ListNode(val) current = current.next return head # Function to convert linked list to list for testing convenience def linked_list_to_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result"},{"question":"You are given an integer array `arr` and an integer `k`. A **divisible pair** is a pair of indices `(i, j)` where `0 <= i < j < arr.length` and `arr[i] + arr[j]` is divisible by `k`. Your task is to return the number of divisible pairs in the array. Ensure your solution is efficient and can handle large input sizes gracefully.","solution":"def count_divisible_pairs(arr, k): Returns the number of divisible pairs in the array where the sum of the pair is divisible by k. Parameters: arr (list): The list of integers. k (int): The integer divisor. Returns: int: The number of divisible pairs. # Initialize a dictionary to count remainders remainder_counts = {} # This variable will hold our output count count = 0 for number in arr: remainder = number % k complement = (k - remainder) % k if complement in remainder_counts: count += remainder_counts[complement] if remainder in remainder_counts: remainder_counts[remainder] += 1 else: remainder_counts[remainder] = 1 return count"},{"question":"You are given a `maze` represented as a 2D grid where: - `0` represents a walkable path, - `1` represents a wall, and - `2` represents the starting point. You can only move in the four cardinal directions (up, down, left, right). Return _the minimum number of steps required to reach the nearest walkable path (`0`) from the starting point (`2`). If there is no walkable path accessible from the starting point, return_ `-1`.","solution":"from collections import deque def min_steps_to_nearest_path(maze): rows, cols = len(maze), len(maze[0]) # Find the starting point start = None for r in range(rows): for c in range(cols): if maze[r][c] == 2: start = (r, c) break if start: break if not start: return -1 # No starting point found # Directions: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() queue = deque([(start[0], start[1], 0)]) # (row, col, steps) while queue: r, c, steps = queue.popleft() # Check if we hit a walkable path if maze[r][c] == 0: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and maze[nr][nc] != 1: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1 # No walkable path found"},{"question":"[Question] 4: Given a `string` containing just the characters `(`, `)`, `{`, `}`, `[` and `]`, determine if the input string is valid. An input string is valid if: - Open brackets are closed by the same type of brackets. - Open brackets are closed in the correct order. Return _True_ if the string is valid, and _False_ otherwise.","solution":"def is_valid(s): Determines if the input string containing just the characters `(`, `)`, `{`, `}`, `[` and `]` is valid based on the criteria: - Open brackets are closed by the same type of brackets. - Open brackets are closed in the correct order. :param s: str :return: bool stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"You are given a 2D grid of size `m x n` with a mix of water and land cells. The grid is represented by a 2D array `grid` where: - `grid[i][j] == 0` represents a water cell, - `grid[i][j] == 1` represents a land cell. You are tasked to find the maximum area of an island in the grid. An island is a group of connected land cells, where a cell is considered connected if it is adjacent (up, down, left, right) to another land cell. The area of an island is the number of land cells within the island. Return _the maximum area of an island_ in the grid. If there is no island, return `0`.","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the given grid. :param grid: List[List[int]], 2D list representing the map with water (0) and land (1) cells :return: int, maximum area of an island if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0 or visited[i][j]: return 0 visited[i][j] = True area = 1 area += dfs(i + 1, j) area += dfs(i - 1, j) area += dfs(i, j + 1) area += dfs(i, j - 1) return area max_area = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"A **unique-path** grid is an m x n grid where you can only move to the right or down from each cell. Given two integers m and n, representing the dimensions of the grid, return the number of unique paths from the top-left corner to the bottom-right corner. Every move must only go to the right or down.","solution":"def unique_paths(m, n): Returns the number of unique paths in an m x n grid moving only right or down. if m == 1 or n == 1: return 1 # Initialize a 2D array with 1s since there\'s only one path to each cell in the first row and first column dp = [[1]*n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"Given a 2D grid `board` containing `\'X\'` and `\'O\'` (the letter O), capture all regions surrounded by `\'X\'`. A region is captured by flipping all `\'O\'`s into `\'X\'`s in that surrounded region. A region is considered surrounded if it is completely surrounded by `\'X\'`s in all four directions (top, bottom, left, and right). The boundary `O`\'s connected to the edge of the board are to be left as `\'O\'` and not flipped to `\'X\'`. Return the modified board after performing the capture operation.","solution":"def capture_regions(board): if not board: return board rows, cols = len(board), len(board[0]) def dfs(i, j): if i < 0 or i >= rows or j < 0 or j >= cols or board[i][j] != \'O\': return board[i][j] = \'E\' # Mark as part of the escaped region directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for direction in directions: ni, nj = i + direction[0], j + direction[1] dfs(ni, nj) # Start DFS from \'O\'s on the border for i in range(rows): for j in [0, cols-1]: # First and last column if board[i][j] == \'O\': dfs(i, j) for j in range(cols): for i in [0, rows-1]: # First and last row if board[i][j] == \'O\': dfs(i, j) # After marking escape regions, flip the rest \'O\' to \'X\' and \'E\' back to \'O\' for i in range(rows): for j in range(cols): if board[i][j] == \'O\': board[i][j] = \'X\' elif board[i][j] == \'E\': board[i][j] = \'O\' return board"},{"question":"Given a string `s` that consists of only lowercase English letters, determine if you can make all characters of the string the same by performing at most one move. In one move, you can choose any character and change it to any other character. Return `true` if it is possible to make all characters of the string the same with at most one move, otherwise return `false`.","solution":"def can_make_all_chars_same(s): Determines if it is possible to make all characters in the string the same with at most one move. Args: s (str): Input string of lowercase English letters. Returns: bool: True if it\'s possible to make all characters the same, False otherwise. if not s: return False char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # If we have more than 2 unique characters, it\'s not possible with at most one move if len(char_count) > 2: return False # If there are exactly 2 unique characters, check their counts if len(char_count) == 2: vals = list(char_count.values()) return 1 in vals # If all characters are already the same return True"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Write a function to determine if there is a unique pair of indices `(i, j)` such that `nums[i] + nums[j] == target`, where `0 <= i < j < nums.length`. Return `true` if such a pair exists and `false` otherwise.","solution":"def has_unique_pair(nums, target): Determines if there is a unique pair of indices (i, j) such that nums[i] + nums[j] == target and 0 <= i < j < len(nums). :param nums: List[int] - List of integers sorted in non-decreasing order :param target: int - Target sum :return: bool - True if such a unique pair exists, otherwise False left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a 2D `grid` of size `m x n` where each cell represents a plot of land that can either be a part of farmland (`1`) or not (`0`). Farmland plots are rectangular in shape and cannot overlap each other. Identify each farmland and return its coordinates in a list. Each coordinate list of a farmland should describe the top-left and bottom-right corners of the farmland. Sort the coordinates in increasing order. Return _a list of coordinates representing each farmland in the_ `grid`.","solution":"def findFarmland(grid): Finds and returns a list of coordinates representing each farmland in the grid. Each coordinate contains the top-left and bottom-right corners of the farmland. m, n = len(grid), len(grid[0]) farmlands = [] def dfs(i, j): if 0 <= i < m and 0 <= j < n and grid[i][j] == 1: grid[i][j] = -1 top_left[0] = min(top_left[0], i) top_left[1] = min(top_left[1], j) bottom_right[0] = max(bottom_right[0], i) bottom_right[1] = max(bottom_right[1], j) for x, y in [(i+1, j), (i, j+1), (i-1, j), (i, j-1)]: dfs(x, y) for i in range(m): for j in range(n): if grid[i][j] == 1: top_left = [i, j] bottom_right = [i, j] dfs(i, j) farmlands.append([top_left[0], top_left[1], bottom_right[0], bottom_right[1]]) return sorted(farmlands)"},{"question":"You are given a 2D grid consisting of `\'0\'`s (land) and `\'1\'`s (water). An island is a maximal 4-directionally connected group of `\'0\'`s and a lake is a maximal 4-directionally connected group of `\'1\'`s surrounded by land. Your task is to find the number of lakes in the given grid. Return the number of lakes found.","solution":"def num_lakes(grid): Given a 2D grid consisting of \'0\'s (land) and \'1\'s (water), find the number of lakes (maximal 4-directionally connected group of \'1\'s surrounded by land). if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]): return True if grid[x][y] == \'0\': return False if grid[x][y] == \'#\': return False grid[x][y] = \'#\' left = dfs(x, y - 1) right = dfs(x, y + 1) up = dfs(x - 1, y) down = dfs(x + 1, y) return left or right or up or down lakes = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': if not dfs(i, j): lakes += 1 return lakes"},{"question":"**Given a string `s` containing lowercase alphabet characters, you need to remove the duplicate characters using a stack and return it as the result. The final result should maintain the smallest lexicographical order possible.** To accomplish this, follow these steps: 1. Initialize an empty stack to store characters. 2. Track the last occurrence index of each character in the string. 3. Use a set to keep track of characters already present in the stack. 4. Iterate through the string and for each character: - If the character is already in the stack, skip it. - While the stack is not empty, and the current character is smaller than the stack\'s top character and the top character will appear later in the string again, pop the top character from the stack. - Push the current character onto the stack. 5. Convert the stack to the resulting string and return it. **Example:** - Input: `s = \\"cbacdcbc\\"` - Output: `acdb` The required output \\"acdb\\" is the smallest lexicographical order string you can get by removing duplicates from the given string.","solution":"def remove_duplicate_letters(s: str) -> str: stack = [] last_occurrence = {c: i for i, c in enumerate(s)} in_stack = set() for i, c in enumerate(s): if c in in_stack: continue while stack and c < stack[-1] and i < last_occurrence[stack[-1]]: in_stack.remove(stack.pop()) stack.append(c) in_stack.add(c) return \'\'.join(stack)"},{"question":"You are given a 2D grid of characters representing a crossword puzzle and a list of words. Each cell in the grid can hold a single character, and the words in the list should all be placed on the grid. The words can only be placed horizontally or vertically, and once a word is placed, no other word can overlap any of its characters unless they are the same character. Return _a boolean_ `true` _if all the words can be placed on the grid according to the rules, otherwise return_ `false`_. The crossword puzzle and the list of words are given by the matrix `board` and the list `words` respectively_.","solution":"def can_place_word(board, word, row, col, direction): if direction == \\"horizontal\\": if col + len(word) > len(board[0]): return False for i in range(len(word)): if board[row][col + i] not in (\' \', word[i]): return False for i in range(len(word)): board[row][col + i] = word[i] else: # vertical if row + len(word) > len(board): return False for i in range(len(word)): if board[row + i][col] not in (\' \', word[i]): return False for i in range(len(word)): board[row + i][col] = word[i] return True def place_words_on_board(board, words): for word in words: placed = False for row in range(len(board)): for col in range(len(board[0])): if (can_place_word(board, word, row, col, \\"horizontal\\") or can_place_word(board, word, row, col, \\"vertical\\")): placed = True break if placed: break if not placed: return False return True"},{"question":"You are given a list of integers `nums` and an integer `n`. The list represents the **positions** of houses along a straight street. You are tasked with building `n` fire stations along the street such that the **maximum distance** from any house to the nearest fire station is minimized. Return _the minimum possible value of this maximum distance that can be achieved by optimally placing the fire stations along the street_.","solution":"def min_max_distance(nums, n): def is_possible(max_dist): stations_used = 1 last_position = nums[0] for i in range(1, len(nums)): if nums[i] - last_position > max_dist: stations_used += 1 last_position = nums[i] if stations_used > n: return False return True nums.sort() left, right = 0, nums[-1] - nums[0] result = right while left <= right: mid = (left + right) // 2 if is_possible(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a **(0-indexed)** array of integers `houses` representing the prices of houses in a row. A robber can decide to rob houses along this row, but cannot rob two adjacent houses due to security alarms connecting them. You need to determine the **maximum amount of money** the robber can **rob tonight** without alerting the police. Write a function `maxRobAmount(houses)` that takes in the array `houses` and returns the maximum amount of money that can be robbed. Assume that the robber starts at the first house and must rob at least one house.","solution":"def maxRobAmount(houses): Determine the maximum amount of money that can be robbed without robbing two adjacent houses. :param houses: List[int] representing the prices of houses :return: int, maximum amount of money that can be robbed if not houses: return 0 if len(houses) == 1: return houses[0] prev1, prev2 = 0, 0 for amount in houses: temp = prev1 prev1 = max(prev2 + amount, prev1) prev2 = temp return prev1"},{"question":"You are given a list of `n` unique integers and an integer `target`. Write a function that returns the number of subsets that add up to the `target`. Each subset\'s sum is considered distinct if their constituent integers are in different order, even if they add up to the same `target`. For example, if `n = [2, 4, 6, 10]` and `target = 16`, then the valid subsets would be `[6, 10]`, `[2, 4, 10]`, and `[2, 4, 6, 4]` etc. Given an array of integers `nums` and an integer `target`, return the number of possible `distinct` subsets in `nums` that sum up to `target`.","solution":"from itertools import combinations def count_subsets(nums, target): Returns the number of subsets in nums that add up to the target. count = 0 n = len(nums) # Generate all possible subsets using combination logic for i in range(1, n+1): for combo in combinations(nums, i): if sum(combo) == target: count += 1 return count"},{"question":"You are given an integer array `nums` of length `n` with elements being positive integers and a target `k`. You need to modify the array to make it **strictly increasing** by executing a series of operations. In one operation, you can increase any element of the array by 1. Return the **minimum** number of operations required to make the array strictly increasing. For example, if `nums = [1, 1, 1]` and `k = 0`, the answer would be `3`, because you need to perform 3 increment operations to transform the array into [1, 2, 3], which is strictly increasing. Implement the function `int minOperations(int[] nums, int k)` that takes an array `nums` and an integer `k` and returns the minimum number of operations required to transform the array into a strictly increasing sequence.","solution":"def minOperations(nums, k): Calculate the minimum number of operations required to make the given array strictly increasing. Parameters: nums (list of int): The input list of positive integers. k (int): The target integer (although it is not used in the operations directly). Returns: int: The minimum number of operations required. operations = 0 n = len(nums) for i in range(1, n): if nums[i] <= nums[i - 1]: increment = nums[i - 1] - nums[i] + 1 nums[i] += increment operations += increment return operations"},{"question":"Given a list of integers `arr`, return the maximum possible sum of its elements where no two elements are adjacent in the original array. You can skip as many elements as needed to achieve the maximum sum, but you cannot pick two consecutive elements.","solution":"def max_non_adjacent_sum(arr): Returns the maximum possible sum of non-adjacent elements in the given list. :param arr: List of integers :return: Maximum possible sum of non-adjacent elements if not arr: return 0 if len(arr) == 1: return max(0, arr[0]) prev1 = max(0, arr[0]) prev2 = max(prev1, arr[1]) for i in range(2, len(arr)): current = max(prev1 + arr[i], prev2) prev1 = prev2 prev2 = current return prev2"},{"question":"You are a project manager in a software development team. Your team must deliver a sequence of tasks, each with a specific deadline and duration. The tasks cannot overlap, meaning you can only work on one task at a time. You are given two lists, `deadlines` and `durations`, where `deadlines[i]` is the deadline of the ith task and `durations[i]` is the time required to complete the ith task. Your goal is to determine the **minimum number of tasks that cannot be completed** by their respective deadlines if you work optimally. Write a function that takes the lists `deadlines` and `durations` and returns the minimum number of tasks that cannot be completed on time. ```python def min_incomplete_tasks(deadlines: List[int], durations: List[int]) -> int: pass ```","solution":"from typing import List def min_incomplete_tasks(deadlines: List[int], durations: List[int]) -> int: tasks = sorted(zip(deadlines, durations), key=lambda x: x[0]) current_time = 0 incomplete_task_count = 0 for deadline, duration in tasks: if current_time + duration > deadline: incomplete_task_count += 1 else: current_time += duration return incomplete_task_count"},{"question":"Write a function `generateParentheses(n)` that returns all combinations of well-formed parentheses given `n` pairs of parentheses. A combination of parentheses is considered well-formed if every opening parenthesis has a corresponding closing parenthesis, and the pairs are properly nested. For example, given `n = 3`, one valid combination is `((()))`. List all possible combinations in any order.","solution":"def generateParentheses(n): Generate all combinations of well-formed parentheses given n pairs. Args: n (int): Number of pairs of parentheses Returns: list: A list of strings, where each string is a combination of well-formed parentheses def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) result = [] backtrack() return result"},{"question":"Given a string `s` which consists of lowercase and uppercase letters, return the **length** of the longest substring that contains only letters. * For example, if `s = \\"abc123def\\"`, the longest substring is `\\"abc\\"` or `\\"def\\"`, and its length is `3`. * If `s = \\"Hello123World456\\"`, the longest substring is `\\"World\\"`, and its length is `5`. Implement the function `int longestAlphaSubstring(string s)` that returns the length of the longest substring containing only letters.","solution":"def longest_alpha_substring(s): Returns the length of the longest substring containing only letters in the given string. max_len = 0 current_len = 0 for char in s: if char.isalpha(): current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len"},{"question":"You are given a list of integers `nums` representing a binary tree in level order traversal. Write a function to find the maximum path sum. A path in the binary tree is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. The binary tree is represented in level order as follows: - The root node is at the first position of the list. - For each node at index `i`, its left child, if any, is at `2*i + 1` position, and its right child, if any, is at `2*i + 2` position in the list. The function should return the maximum sum of the values along any path in the tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree_from_list(nums): if not nums: return None nodes = [TreeNode(value) if value is not None else None for value in nums] for i in range(len(nums)): if nodes[i] is not None: if 2 * i + 1 < len(nums): nodes[i].left = nodes[2 * i + 1] if 2 * i + 2 < len(nums): nodes[i].right = nodes[2 * i + 2] return nodes[0] def max_path_sum(nums): if not nums: return 0 root = build_tree_from_list(nums) def max_gain(node): if not node: return 0 left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) price_newpath = node.value + left_gain + right_gain max_path_sum.max_sum = max(max_path_sum.max_sum, price_newpath) return node.value + max(left_gain, right_gain) max_path_sum.max_sum = float(\'-inf\') max_gain(root) return max_path_sum.max_sum"},{"question":"Given a **0-indexed** array `prices` where `prices[i]` is the price of a stock on the `i-th` day, find the **minimum** number of non-overlapping intervals you need to select such that each interval contains one local peak. A local peak is defined as `prices[i]` where `prices[i-1] < prices[i]` and `prices[i] > prices[i+1]`. Return _the **minimum** number of intervals needed._","solution":"def min_intervals_to_cover_peaks(prices): Returns the minimum number of non-overlapping intervals needed to cover all local peaks in the prices list. A local peak is prices[i] such that prices[i-1] < prices[i] > prices[i+1]. if not prices or len(prices) < 3: return 0 peaks = [] n = len(prices) # Identify all the peaks for i in range(1, n - 1): if prices[i - 1] < prices[i] > prices[i + 1]: peaks.append(i) if not peaks: return 0 intervals = 1 current_end = peaks[0] + 1 # Traverse through the peaks to find non-overlapping intervals for peak in peaks[1:]: if peak > current_end: intervals += 1 current_end = peak + 1 return intervals"},{"question":"A robot is located at the top-left corner of an `m x n` grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. However, certain cells in the grid are blocked and the robot cannot step on them. Implement a function that takes a grid as input and returns the number of unique paths the robot can take to reach the bottom-right corner from the top-left corner. The grid is represented as a 2D list where `1` represents an open cell and `0` represents a blocked cell.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths for the robot to reach the bottom-right corner of the grid, avoiding blocked cells. :param grid: List[List[int]], a 2D list representing the grid where 1 is an open cell and 0 is a blocked cell. :return: int, the number of unique paths from top-left corner to bottom-right corner. if not grid or grid[0][0] == 0: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"Given a `2D` matrix of dimensions `m x n` containing only the characters \'X\' and \'O\', where: - \'X\' represents an obstacle, - \'O\' represents an open space, Your task is to determine _the size of the largest square consisting entirely of \'O\'s_. Return the area of this square.","solution":"def maximal_square(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == \'O\': if i == 0 or j == 0: dp[i][j] = 1 # edge cases: first row or first column else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `target`. Your task is to find if there exists a continuous subarray (containing at least one number) which sums to `target`. The subarray must be contiguous. Return `_true` if there exists such a subarray, otherwise return_ `false`.","solution":"def subarray_sum(nums, target): Determines if a continuous subarray sums to target. Args: nums : list of int - The input list of integers. target : int - The target integer sum. Returns: bool - True if such a subarray exists, False otherwise. current_sum = 0 sum_map = {0: -1} # Maps cumulative sum to index for quick lookup for index, num in enumerate(nums): current_sum += num if (current_sum - target) in sum_map: return True sum_map[current_sum] = index return False"},{"question":"You are given an `n x n` 2D `grid` representing a square map, where each cell of the grid can have one of three values: * `0` represents water, * `1` represents land, * `2` represents a structure built on land. A structure can be built on `1` land only if the structure has a `1` on all four sides (left, right, top, bottom). You need to construct the maximum number of structures on the grid following this rule and return the updated grid. If it is not possible to build any structure, return the original grid.","solution":"def maxStructures(grid): n = len(grid) def can_build_structure(i, j): return (i > 0 and i < n - 1 and j > 0 and j < n - 1 and grid[i - 1][j] == 1 and grid[i + 1][j] == 1 and grid[i][j - 1] == 1 and grid[i][j + 1] == 1) grid_copy = [row[:] for row in grid] built = False for i in range(1, n - 1): for j in range(1, n - 1): if grid[i][j] == 1 and can_build_structure(i, j): grid_copy[i][j] = 2 built = True return grid_copy if built else grid"},{"question":"Given a string `s` containing only the characters \'0\' and \'1\', we can transform `s` by deleting any two adjacent characters if they are different (i.e., \'01\' or \'10\'). After each deletion, the remaining parts of the string are concatenated together. We want to determine the length of the smallest possible string that can be obtained after applying the above rule any number of times. Return the length of the final string after performing all possible deletions.","solution":"def smallest_possible_length(s): Determines the length of the smallest possible string that can be obtained after applying deletions on adjacent \'01\' or \'10\' pairs any number of times. Parameters: s (str): Input string containing only the characters \'0\' and \'1\'. Returns: int: The length of the final string after performing all possible deletions. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"Given an array of integers `nums` of length `n`, you are required to transform this array into a non-decreasing array by modifying no more than one element. An array is non-decreasing if `nums[i] <= nums[i + 1]` for every `i` (0 <= i < n-1). Your task is to determine if it is possible to achieve this transformation under the given condition. Return `true` if it is possible to make the array non-decreasing by modifying at most one element, otherwise return `false`.","solution":"def can_be_non_decreasing(nums): Determine if the array can be transformed into a non-decreasing array by modifying at most one element. n = len(nums) count = 0 for i in range(1, n): if nums[i - 1] > nums[i]: count += 1 if count > 1: return False if i - 2 < 0 or nums[i - 2] <= nums[i]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return True"},{"question":"You are given an array of integers `tasks`, where `tasks[i]` represents the amount of time it takes to complete the ith task. There are two processors available that can run the tasks simultaneously. You need to assign the tasks to these two processors such that the completion time of the task that finishes the latest is minimized. Return _the minimum possible time required to finish all the tasks_.","solution":"def min_time(tasks): Returns the minimum possible time required to finish all tasks using two processors. tasks: List of integers where tasks[i] represents the amount of time it takes to complete the ith task. Return an integer representing the minimum possible time required to finish all tasks. tasks = sorted(tasks, reverse=True) # Sort tasks in descending order processor_1 = 0 processor_2 = 0 for task in tasks: if processor_1 <= processor_2: processor_1 += task else: processor_2 += task return max(processor_1, processor_2)"},{"question":"You are given a string `s` consisting only of characters \'a\' and \'b\'. You can perform the following operation: select any two adjacent characters and replace them with a single character \'a\' if they are equal or \'b\' if they are different. Return _the minimum length of the string you can achieve after performing this operation repeatedly on the string_.","solution":"def min_length_string(s): Returns the minimum length of the string s after repeatedly performing the described operation. return 1 if s else 0"},{"question":"Given an m x n integer grid `grid`, return _the minimum number of cells you need to remove to make all the remaining elements in the grid equal._ You can remove a cell from the grid only if it has at least one immediate neighbor (top, bottom, left, or right). If it is impossible to make all remaining elements equal, return `-1`.","solution":"def min_removals_to_equalize_grid(grid): from collections import Counter import operator m, n = len(grid), len(grid[0]) # Flatten the grid into a list of elements elements = [grid[i][j] for i in range(m) for j in range(n)] # Count the frequency of each element using Counter frequency = Counter(elements) # If the most common element count covers more than the half of the cells, its possible to make the grid equal max_count = max(frequency.items(), key=operator.itemgetter(1))[1] if max_count >= (m * n) // 2 + 1: return (m * n) - max_count else: return -1"},{"question":"You are given two integers `n` and `k`. You need to rearrange `n` into the lexicographically largest permutation that is smaller than the given permutation of `n` which is a `k`-digit number. If no such permutation exists, return `-1`. For example, for `n = 12354` and `k = 5`, the next largest permutation smaller than `12354` is `12345`. Implement a function `previousPermutation(n: int, k: int) -> int` that achieves this.","solution":"def previousPermutation(n: int, k: int) -> int: Finds the lexicographically largest permutation which is smaller than the given permutation of n. If no such permutation exists, return -1. # Convert the number to a list of digits digits = list(str(n)) # Start from the end of the list and find the first digit that is larger than the digit next to it i = k - 2 while i >= 0 and digits[i] <= digits[i + 1]: i -= 1 if i < 0: return -1 # Find the largest digit to the right of \'i\' that is smaller than digits[i] j = k - 1 while digits[j] >= digits[i]: j -= 1 # Swap digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Reverse the suffix starting at i + 1 digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\'\'.join(digits))"},{"question":"You are given a string `s` and an integer `k`. The string `s` consists of upper and lower case English letters and digits. We want to construct the lexicographically smallest string possible by choosing one character at a time and appending it to the resulting string until we reach length `k`. You can only choose each character from `s` once and maintain the relative order of characters. Return the lexicographically smallest string of length `k`. Example: ``` Input: s = \\"abacb\\", k = 3 Output: \\"aab\\" ``` Explanation: The lexicographically smallest string of length 3 that can be formed by preserving relative order is \\"aab\\".","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string of length k constructed from the string s. stack = [] n = len(s) for i, char in enumerate(s): while stack and stack[-1] > char and len(stack) + n - i > k: stack.pop() if len(stack) < k: stack.append(char) return \'\'.join(stack)"},{"question":"You are given a 2D grid `grid` of dimensions `m x n` where each cell represents a room. A room can either be empty (represented by `0`), have an obstacle (represented by `-1`), or be a treasure room (represented by `999`). Your task is to find the shortest path from the top-left room `(0, 0)` to the bottom-right room `(m-1, n-1)` such that you must collect all treasures (rooms with `999`). Return the length of this path. If it is not possible to collect all treasures or reach the bottom-right room, return `-1`. You can move in four directions: up, down, left, and right.","solution":"from collections import deque def shortest_path_with_treasures(grid): # Helper function to get valid neighbors def get_neighbors(r, c, m, n): for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n: yield nr, nc # Find all the treasures and grid dimensions m, n = len(grid), len(grid[0]) treasures = set() for r in range(m): for c in range(n): if grid[r][c] == 999: treasures.add((r, c)) # Use BFS for shortest path search with multi-source queue = deque([(0, 0, frozenset(), 0)]) visited = set([(0, 0, frozenset())]) while queue: r, c, collected_treasures, steps = queue.popleft() # If we have reached the bottom-right cell and collected all treasures if (r == m-1 and c == n-1 and collected_treasures == treasures): return steps # Explore neighbors for nr, nc in get_neighbors(r, c, m, n): if grid[nr][nc] == -1: continue # Skip obstacles new_collected = collected_treasures | frozenset([(nr, nc)]) if grid[nr][nc] == 999 else collected_treasures if (nr, nc, new_collected) not in visited: visited.add((nr, nc, new_collected)) queue.append((nr, nc, new_collected, steps + 1)) # If we exhaust the queue without finding a valid path return -1"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values. (i.e., from left to right, level by level). In your function, you will receive the root node of the binary tree. You need to return a list of lists, where each list represents the nodes\' values at each level from top to bottom. For example, given a binary tree with the following structure: ``` 3 / 9 20 / 15 7 ``` The level order traversal of the binary tree is: ``` [ [3], [9, 20], [15, 7] ] ``` # Constraints: - The number of nodes in the tree is in the range `[0, 2000]`. - `-1000 <= Node.val <= 1000`.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrder(root): Returns the level order traversal of the binary tree nodes\' values. :param root: TreeNode, root of the binary tree :return: List[List[int]], level order traversal if not root: return [] result = [] queue = deque([root]) while queue: level = [] for _ in range(len(queue)): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"You are given a list of integers `tasks` representing the durations of different tasks you need to complete. Your goal is to allocate these tasks into two separate lists such that the absolute difference between the sum of task durations in the two lists is minimized. Return _the minimum possible absolute difference_. **Implement the `Solution` class:** - `Solution(List<int> tasks)` Initializes the object with the list of task durations. - `int minimizeDifference()` Returns the minimum possible absolute difference of the sums of durations between the two lists.","solution":"class Solution: def __init__(self, tasks): self.tasks = tasks def minimizeDifference(self): total_sum = sum(self.tasks) n = len(self.tasks) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for task in self.tasks: for j in range(target, task - 1, -1): if dp[j - task]: dp[j] = True for i in range(target, -1, -1): if dp[i]: left_sum = i break right_sum = total_sum - left_sum return abs(left_sum - right_sum)"},{"question":"You are provided with a set of strings containing only the characters `\'I\'` (increase) and `\'D\'` (decrease). Write a function to construct the lexicographically smallest permutation of `[0, 1, 2, ..., n]` (where `n` is the length of the string) that would match the given input string of `\'I\'`s and `\'D\'`s. An `\'I\'` at position `i` of the string means that `perm[i] < perm[i + 1]`, and a `\'D\'` at position `i` of the string means that `perm[i] > perm[i + 1]`. For example, given the input string `\\"IDID\\"`, one valid permutation is `[0, 4, 1, 3, 2]`, which is the lexicographically smallest permutation satifying the conditions specified by the input string. Return the lexicographically smallest permutation array.","solution":"def smallest_permutation(s): Construct the lexicographically smallest permutation of [0, 1, 2, ..., n] that matches the given input string of \'I\'s and \'D\'s. :param s: Input string containing only \'I\' and \'D\' :type s: str :return: Lexicographically smallest permutation array :rtype: List[int] n = len(s) low, high = 0, n perm = [] for char in s: if char == \'I\': perm.append(low) low += 1 elif char == \'D\': perm.append(high) high -= 1 perm.append(low) # At the end, low and high should be the same return perm"},{"question":"You are given an integer array `nums` sorted in ascending order, and an integer `target`. Write a function `searchInsert` to determine the index if the `target` is found in `nums`. If not, return the index where it would be if it were inserted in order. Implement the function as follows: * `int searchInsert(int[] nums, int target)` which returns an integer index. The function should use binary search for an optimal time complexity.","solution":"def searchInsert(nums, target): Perform a binary search to find the target or the appropriate insertion index in a sorted array. Parameters: nums (list of int): A list of integers sorted in ascending order. target (int): The target integer to find or insert. Returns: int: The index of the target or the appropriate insertion point. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"You\'re tasked with creating a function that takes an integer array `nums` and an integer `k`, and returns the maximum average value of any contiguous subarray of size `k` in `nums`. The average of a subarray is the sum of the subarray divided by its length. Ensure your solution is efficient for large input sizes.","solution":"def find_max_average(nums, k): Returns the maximum average value of any contiguous subarray of size k in nums. n = len(nums) if n < k: return 0 # Compute the sum of the first \'k\' elements. current_sum = sum(nums[:k]) # Initialize the maximum sum as the current sum. max_sum = current_sum # Slide the window across the array. for i in range(k, n): # Update the current sum by adding the next element in the array and subtracting the element that is left behind. current_sum += nums[i] - nums[i - k] # Update the maximum sum if the current sum is higher. if current_sum > max_sum: max_sum = current_sum # Return the maximum average value. return max_sum / k"},{"question":"You are given a list of unique integers `numbers` and an integer `target`. Your task is to return an array of all unique pairs `[a, b]` from `numbers` such that `a + b = target`. Each pair must be returned in non-descending order, and the array should be sorted in non-descending order based on the first and then the second element of each pair. If no such pairs exist, return an empty array. The solution should not include duplicate pairs.","solution":"def find_pairs_with_target(numbers, target): Returns an array of all unique pairs [a, b] from numbers such that a + b = target. Each pair is in non-descending order, and the array is sorted based on the pairs. pairs = [] seen = set() for num in numbers: if (target - num) in seen: pair = sorted([num, target - num]) if pair not in pairs: pairs.append(pair) seen.add(num) return sorted(pairs)"},{"question":"You are given two integer arrays `startTime` and `endTime`, both of length `n`, where `startTime[i]` and `endTime[i]` represent the start and end times of the `ith` event, respectively. Also, you are given an integer `Q` representing the number of queries. Each query is an integer `queryTime` for which you need to determine how many events are ongoing at that specific time. An event is considered ongoing at `queryTime` if it starts at or before `queryTime` and ends at or after `queryTime`. Return _an array of length `Q` where the `ith` element is the number of events ongoing at `queryTime[i]`_. Example: - Input: `startTime = [1, 2, 3], endTime = [3, 5, 4], queryTime = [4, 5]` - Output: `[2, 1]` Explanation: - At query time 4, events 1 and 3 are ongoing. - At query time 5, event 2 is ongoing.","solution":"def countOngoingEvents(startTime, endTime, queryTime): Args: startTime: List[int] - List of start times of the events. endTime: List[int] - List of end times of the events. queryTime: List[int] - List of query times. Returns: List[int] - List of counts of ongoing events at each query time. result = [] for q in queryTime: count = 0 for start, end in zip(startTime, endTime): if start <= q <= end: count += 1 result.append(count) return result"},{"question":"You are given a string `log` that represents a log of commands in a Unix-style file system. Each command in the log is separated by a newline character `n`. The commands include `cd` to change directories, `mkdir` to create directories, `ls` to list directories, and `touch` to create files. Assume `cd` appropriately changes directories and can be followed by `..` to move up one level or by a directory name to move into it. `mkdir` creates a new directory in the current directory. `ls` lists the directories and files in the current directory and should return them in lexicographical order. `touch` creates a new file in the current directory. You start in the root directory `/`. Your task is to process the given log commands and return the final structure of the file system in a dictionary format, where directories and their contents are represented as nested dictionaries and files are represented by their file names. Return the dictionary structure representing the final state of the file system.","solution":"def process_log(log): from collections import defaultdict def recursive_dict(): return defaultdict(recursive_dict) def update_dict(d, keys, value=None): for key in keys[:-1]: d = d[key] if value: d[keys[-1]] = value else: d[keys[-1]] file_system = recursive_dict() current_path = [\'/\'] commands = log.split(\'n\') for command in commands: parts = command.split() if parts[0] == \'cd\': if parts[1] == \'..\': if len(current_path) > 1: current_path.pop() else: current_path.append(parts[1]) elif parts[0] == \'mkdir\': update_dict(file_system, current_path + [parts[1]]) elif parts[0] == \'touch\': update_dict(file_system, current_path + [parts[1]], parts[1]) elif parts[0] == \'ls\': continue # No state change required for `ls` return file_system[\'/\']"},{"question":"You are given a string `s` consisting of only lowercase English letters. A character can be removed from the string if it appears at least twice consecutively. You need to find the length of the longest substring that can be formed by removing characters according to this rule, such that no two consecutive characters are the same anymore. Return _the length of the longest substring possible after performing the operations_.","solution":"def longest_substring_after_removal(s): Returns the length of the longest substring possible such that no two consecutive characters are the same. if not s: return 0 n = len(s) length = 0 i = 0 while i < n: length += 1 while i + 1 < n and s[i] == s[i + 1]: i += 1 i += 1 return length"},{"question":"You are given a string `s` which is a valid representation of a floating-point number. Implement the function `stringToFloat` to convert the string `s` into its corresponding floating-point number without using any built-in conversion functions. You can assume that the input string always represents a valid floating-point number and contains only valid characters (digits, a single decimal point, and optionally a leading \'-\' for negatives or \'+\' for positives). The function should return the converted floating-point number.","solution":"def stringToFloat(s): Converts a string representation of a floating-point number to its corresponding float value. :param s: str - a string representing a floating-point number :return: float - the converted floating-point number # Check if the string represents a negative number negative = False if s[0] == \'-\': negative = True s = s[1:] elif s[0] == \'+\': s = s[1:] # Split the string into integer and fractional parts if \'.\' in s: integer_part, fractional_part = s.split(\'.\') else: integer_part, fractional_part = s, \'\' # Convert integer part integer_value = 0 for char in integer_part: integer_value = integer_value * 10 + (ord(char) - ord(\'0\')) # Convert fractional part fractional_value = 0 divisor = 1 for char in fractional_part: fractional_value = fractional_value * 10 + (ord(char) - ord(\'0\')) divisor *= 10 # Combine integer and fractional parts result = integer_value + fractional_value / divisor # Apply negative sign if needed if negative: result = -result return result"},{"question":"Given an array `prices` where `prices[i]` is the price of the i-th item, and another array `weights` where `weights[i]` is the weight of the i-th item, determine the maximum total value of items you can include in a knapsack given a weight limit `W`. Each item can be included at most once. Return the maximum total value achievable given the constraints.","solution":"def knapsack(prices, weights, W): Returns the maximum total value of items that can be included in the knapsack without exceeding the weight limit W. :param prices: List[int] - A list of prices (values) of items. :param weights: List[int] - A list of weights of items. :param W: int - The maximum weight limit of the knapsack. :return: int - The maximum total value achievable. n = len(prices) dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(W + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + prices[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"You are given a binary tree where each node has an integer value. Find the maximum sum path between any two nodes in the tree. The path must contain at least one node and does not need to pass through the root. The tree is defined as follows: - `TreeNode` is a class representing a node in the tree with properties `val`, `left`, and `right` where `val` is an integer, and `left` and `right` are the left and right children of the node, respectively. - The function should take the root of the tree as an input and return the maximum sum path. [Question 4]:","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): def helper(node): nonlocal max_sum if not node: return 0 # Recursively get the maximum sum of paths in the left and right subtrees left_gain = max(helper(node.left), 0) right_gain = max(helper(node.right), 0) # Calculate the price to pay for a path passing through the current node current_price_path = node.val + left_gain + right_gain # Update the global maximum sum if the current path is better max_sum = max(max_sum, current_price_path) # Return the maximum sum of the path extending from the current node return node.val + max(left_gain, right_gain) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"You are given a list of `n` integers representing a permutation of numbers from `1` to `n`. Your task is to convert this permutation into its next lexicographical permutation. If such permutation is not possible, you should rearrange it as the lowest possible order (i.e., sorted in ascending order). Implement the following function: ```python def nextPermutation(nums: List[int]) -> None: Do not return anything, modify nums in-place instead. ``` Example: - Input: `nums = [1, 2, 3]` - Output: `[1, 3, 2]` - Input: `nums = [3, 2, 1]` - Output: `[1, 2, 3]`","solution":"from typing import List def nextPermutation(nums: List[int]) -> None: Modify nums in-place to its next permutation. # Step 1: Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, reverse nums. k = -1 for i in range(len(nums) - 1): if nums[i] < nums[i + 1]: k = i if k == -1: nums.reverse() return # Step 2: Find the largest index l greater than k such that nums[k] < nums[l]. l = -1 for j in range(k + 1, len(nums)): if nums[k] < nums[j]: l = j # Step 3: Swap nums[k] and nums[l]. nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] up to and including the final element. nums[k + 1:] = reversed(nums[k + 1:])"},{"question":"Imagine you are given an encoded string in which each digit indicates the number of times the following character (which is guaranteed to be a lowercase letter) appears. For example, the string `\\"3a2b1c\\"` means `\'a\'` appears 3 times, `\'b\'` appears 2 times, and `\'c\'` appears 1 time. Write a function that takes such an encoded string and returns the decoded version of the string where each character is repeated the specified number of times. For example, given `\\"3a2b1c\\"`, the function should return `\\"aaabbc\\"`.","solution":"def decode_string(encoded): Decodes the given encoded string where each digit indicates the number of times the following character (which is guaranteed to be a lowercase letter) appears. Parameters: - encoded (str): Encoded string, e.g., \\"3a2b1c\\". Returns: - str: Decoded string, e.g., \\"aaabbc\\". decoded = [] i = 0 length = len(encoded) while i < length: # get the count count = 0 while i < length and encoded[i].isdigit(): count = count * 10 + int(encoded[i]) i += 1 if i < length and encoded[i].isalpha(): decoded.append(encoded[i] * count) i += 1 return \\"\\".join(decoded)"},{"question":"You are given an integer array `arr` and a target integer `target`. Assume that there exists exactly one pair of distinct elements in the array whose sum is equal to the target. Return _an integer array_ `answer` _of the indices of elements that sum up to the target_ (0-indexed). The answer should be returned in ascending order of indices.","solution":"def two_sum(arr, target): Returns the indices of the two distinct elements in the array whose sum equals the target. Parameters: arr (list of int): The list of integers. target (int): The target sum. Returns: list of int: The indices of the two elements whose sum equals the target, sorted in ascending order. index_map = {} for i, num in enumerate(arr): complement = target - num if complement in index_map: return sorted([index_map[complement], i]) index_map[num] = i"},{"question":"You are given an integer array `nums` and a target integer `k`. Determine if there are two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] == k` and the absolute difference between `i` and `j` is not greater than a given integer `d`. Return _true_ if such indices exist, otherwise return _false_.","solution":"def check_indices_with_sum(nums, k, d): Determines if there are two distinct indices `i` and `j` in the array such that nums[i] + nums[j] == k and the absolute difference between `i` and `j` is not greater than `d`. Args: nums (list of int): The input list of integers. k (int): The target sum. d (int): The maximum allowed distance between indices. Returns: bool: True if such indices exist, False otherwise. for i in range(len(nums)): for j in range(i + 1, min(i + d + 1, len(nums))): if nums[i] + nums[j] == k: return True return False"},{"question":"Given an array of strings `words`, create a function to determine if each string can be formed using letters of a single row of a traditional QWERTY keyboard. The QWERTY keyboard rows are: - First row: \\"qwertyuiop\\" - Second row: \\"asdfghjkl\\" - Third row: \\"zxcvbnm\\" Return a list of words that can be typed using letters of only one row of the keyboard. Consider the case of the characters (uppercase and lowercase) for your solution.","solution":"def find_words(words): Returns a list of words that can be formed using letters of a single row of a traditional QWERTY keyboard. first_row = set(\\"qwertyuiop\\") second_row = set(\\"asdfghjkl\\") third_row = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = word.lower() if all(char in first_row for char in lower_word) or all(char in second_row for char in lower_word) or all(char in third_row for char in lower_word): result.append(word) return result"},{"question":"Given an unsorted integer array `nums`, find the length of the longest arithmetic subsequence in `nums`. An arithmetic subsequence is a subsequence that can be formed by removing some elements (possibly zero) so that the difference between every two consecutive elements is the same. Implement the following function: Function Signature: * `def longest_arith_seq_length(nums: List[int]) -> int:` Example: ```python nums = [3, 6, 9, 12] # The longest arithmetic subsequence is [3, 6, 9, 12], so the result should be 4. nums = [9, 4, 7, 2, 10] # The longest arithmetic subsequence is [4, 7, 10], so the result should be 3. nums = [20, 1, 15, 3, 10, 5, 8] # The longest arithmetic subsequence is [20, 15, 10, 5], so the result should be 4. ``` Return the length of the longest arithmetic subsequence in `nums`.","solution":"from typing import List from collections import defaultdict def longest_arith_seq_length(nums: List[int]) -> int: if not nums: return 0 n = len(nums) if n == 1: return 1 dp = [defaultdict(int) for _ in range(n)] longest_length = 2 for i in range(1, n): for j in range(i): diff = nums[i] - nums[j] dp[i][diff] = dp[j][diff] + 1 longest_length = max(longest_length, dp[i][diff] + 1) return longest_length"},{"question":"Given a list of strings called `words`, where each `word` contains only lowercase English letters, find the string that can be constructed by taking the first character of each word in the list and concatenating them in the same order. Return the resulting concatenated string. For example: - For `words = [\\"apple\\", \\"banana\\", \\"cherry\\"]`, the result would be `\\"abc\\"`.","solution":"def concatenate_first_letters(words): Returns a string constructed by taking the first character of each word in the list and concatenating them in the same order. :param words: List of strings :return: Concatenated string of first letters return \'\'.join(word[0] for word in words) if words else \'\'"},{"question":"You are given an integer array `heights` representing the heights of students in a class. The array is not necessarily sorted. Your task is to determine how many students are standing in the wrong positions if the students were to be arranged in non-decreasing order of their heights. Return the number of students standing in the wrong positions.","solution":"def heightChecker(heights): Returns the number of students standing in the wrong positions. Parameters: heights (list of int): The heights of students. Returns: int: The number of students in the wrong positions. # Copy and sort the heights array sorted_heights = sorted(heights) # Count the number of positions where the heights differ from the sorted array count = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: count += 1 return count"},{"question":"Given an integer array `nums`, sort the array in such a manner that all the even numbers are sorted in ascending order and all the odd numbers are sorted in descending order. The relative positioning of even and odd numbers should remain the same as the original array. Return the sorted array. For example, given the array `[5, 3, 2, 8, 1, 4]`, the output should be `[5, 3, 2, 4, 1, 8]` where the even numbers `[2, 8, 4]` are sorted as `[2, 4, 8]` in ascending order and the odd numbers `[5, 3, 1]` are sorted as `[5, 3, 1]` in descending order, keeping the relative positions of even and odd numbers as in the original array.","solution":"def sort_even_odd(nums): Sorts the even numbers in ascending order and the odd numbers in descending order, keeping their relative positions. even_numbers = sorted([num for num in nums if num % 2 == 0]) odd_numbers = sorted([num for num in nums if num % 2 != 0], reverse=True) even_index = 0 odd_index = 0 result = [] for num in nums: if num % 2 == 0: result.append(even_numbers[even_index]) even_index += 1 else: result.append(odd_numbers[odd_index]) odd_index += 1 return result"},{"question":"Given an m x n binary matrix `mat`, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1. Each cell in the result matrix should contain the shortest distance to a 0 in the original matrix. **Example 1:** **Input:** mat = [[0,0,0],[0,1,0],[1,1,1]] **Output:** [[0,0,0],[0,1,0],[1,2,1]] **Example 2:** **Input:** mat = [[0,0,0],[0,1,0],[1,1,1],[1,1,1]] **Output:** [[0,0,0],[0,1,0],[1,2,1],[2,3,2]] **Constraints:** * `m == mat.length` * `n == mat[i].length` * `1 <= m, n <= 100` * `mat[i][j]` is either 0 or 1. * There is at least one 0 in `mat`.","solution":"from collections import deque def updateMatrix(mat): Returns the distance of the nearest 0 for each cell. m, n = len(mat), len(mat[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Four possible directions queue = deque() dist = [[float(\'inf\')] * n for _ in range(m)] # Initialize the queue with all the cells having 0 and distance matrix for i in range(m): for j in range(n): if mat[i][j] == 0: queue.append((i, j)) dist[i][j] = 0 # Perform BFS while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if dist[nx][ny] > dist[x][y] + 1: dist[nx][ny] = dist[x][y] + 1 queue.append((nx, ny)) return dist"},{"question":"You are given an integer array `nums` and an integer `k`. An array is called **beautiful** if it satisfies the following properties: 1. The array is sorted in non-decreasing order. 2. The absolute difference between any two elements in the array is not greater than `k`. Return _the **longest** possible length of a beautiful subarray from_ `nums`.","solution":"def longest_beautiful_subarray(nums, k): Returns the longest possible length of a beautiful subarray from nums. Parameters: nums (List[int]): A list of integers. k (int): An integer representing the maximum absolute difference allowed between elements. Returns: int: The length of the longest beautiful subarray. nums.sort() left = 0 longest = 0 for right in range(len(nums)): while nums[right] - nums[left] > k: left += 1 longest = max(longest, right - left + 1) return longest"},{"question":"Given a string `ransomNote` and a string `magazine`, return `true` if `ransomNote` can be constructed by using the letters from `magazine` and `false` otherwise. Each letter in `magazine` can only be used once in `ransomNote`.","solution":"def canConstruct(ransomNote, magazine): Determines if ransomNote can be constructed by using the letters from magazine. Each letter in magazine can only be used once in ransomNote. from collections import Counter ransom_note_count = Counter(ransomNote) magazine_count = Counter(magazine) for char, count in ransom_note_count.items(): if magazine_count[char] < count: return False return True"},{"question":"You are given a 2D integer array `events`, where each `events[i]` = [startDay_i, endDay_i, value_i] represents an event that starts on `startDay_i` and ends on `endDay_i`, with a certain value `value_i` attached to it. You can attend an event at most once per day. Your task is to determine the maximum value you can obtain by attending events. You can attend multiple events, but not more than one event per day. Return _the **maximum** value you can obtain_.","solution":"def max_value_events(events): events.sort(key=lambda x: x[1]) dp = [0] * (events[-1][1] + 2) # dp array for storing max value till each day for event in events: start, end, value = event dp[end + 1] = max(dp[end + 1], dp[start] + value) return max(dp)"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. You need to implement a function that returns the maximum sum of a subarray with a length equal to `k`. A subarray is a contiguous segment of the array. For example, if `nums = [2, 5, 1, 8, 2, 9, 1]` and `k = 3`, the maximum sum of a subarray of length 3 would be `19`, for the subarray `[8, 2, 9]`.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray with a length equal to k. if not nums or k <= 0 or k > len(nums): return 0 max_sum = float(\'-inf\') current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given an **n x n** grid `grid` containing positive integers. Starting from the top-left corner of the grid, you need to reach the bottom-right corner. At each step, you can only move down or to the right. Additionally, the grid contains some cells that are **blocked**, and you cannot pass through these cells. Return _the number of different paths_ from the top-left corner to the bottom-right corner. If there is no such path, return `0`.","solution":"def num_paths(grid): Returns the number of different paths from top-left to bottom-right corner in a grid, considering blocked cells. n = len(grid) if n == 0 or grid[0][0] == 0 or grid[n-1][n-1] == 0: return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 0: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"You are given a list of flights represented by pairs of departure and arrival cities [from_i, to_i] and a `src` city from which to start and a `dst` city to reach. Each flight has a price associated with it. Calculate the minimum price required to reach the destination city `dst` from the source city `src` within at most `k` stops. If there is no such route, return -1. Implement the function: * `int findCheapestPrice(int n, int[][] flights, int src, int dst, int k)` where: - `n` is the number of cities represented by cities `0` to `n-1`. - `flights` is a list of flights where `flights[i]` = `[from_i, to_i, price_i]` indicates that there is a flight from city `from_i` to city `to_i` with cost `price_i`. - `src` is the starting city. - `dst` is the destination city. - `k` is the maximum number of stops. Note: You can assume that there will be at most `1000` cities and `10000` flights.","solution":"import heapq from collections import defaultdict, deque def findCheapestPrice(n, flights, src, dst, k): graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) # Use a priority queue to progressively explore the cheapest option pq = [(0, src, 0)] visited = defaultdict(lambda: float(\'inf\')) while pq: cost, u, stops = heapq.heappop(pq) # If we reach the destination if u == dst: return cost # If we have more stops available if stops <= k: for v, w in graph[u]: new_cost = cost + w if new_cost < visited[(v, stops + 1)]: visited[(v, stops + 1)] = new_cost heapq.heappush(pq, (new_cost, v, stops + 1)) return -1"},{"question":"Given a string `s`, consisting of only lowercase alphabetic characters, return a new string `t` such that `t` is the **lexicographically smallest** string that can be obtained by **removing exactly one character** from `s`. The input string `s` will have a length of at least 2.","solution":"def lexicographically_smallest_by_removing_one_char(s): Given a string s, return the lexicographically smallest string that can be obtained by removing exactly one character from s. smallest = s[1:] # Initial candidate by removing the first character for i in range(1, len(s)): candidate = s[:i] + s[i+1:] if candidate < smallest: smallest = candidate return smallest"},{"question":"Given a string `expression` containing digits and the characters `+`, `-`, `*`, `/`, evaluate the expression and return the result as an integer. The input string may contain spaces, that should be ignored. Assume that the given expression is always valid. Additionally, the division operator should truncate towards zero. For example, the expression `\\" 3+5 / 2 \\"` should yield `5`.","solution":"def calculate(expression): Evaluate the arithmetic expression and return the result as an integer. def operate(op, second, first): if op == \\"+\\": return first + second elif op == \\"-\\": return first - second elif op == \\"*\\": return first * second elif op == \\"/\\": return int(first / second) # integer division that truncates towards zero stack = [] num = 0 op = \\"+\\" expression = expression.replace(\\" \\", \\"\\") for i in range(len(expression)): if expression[i].isdigit(): num = num * 10 + int(expression[i]) if not expression[i].isdigit() or i == len(expression) - 1: if op == \\"+\\": stack.append(num) elif op == \\"-\\": stack.append(-num) elif op in (\\"*\\", \\"/\\"): stack.append(operate(op, num, stack.pop())) op = expression[i] num = 0 return sum(stack)"},{"question":"You are given a **binary tree** with `n` nodes. Each node has a `value` associated with it, and the values of the nodes can be either binary `0` or `1`. Implement a data structure that can: * **Add** a node to the tree. * **Calculate** the maximum length of a path in the tree where the values of the nodes in the path alternate between `0` and `1`. Implement the `BinaryTreePath` class: * `BinaryTreePath()` Initializes the object with an empty tree. * `void addNode(int parent, int value, bool isLeftChild)` Adds a node with the given `value` to the tree. If `isLeftChild` is `true`, the node is added as the left child of `parent`. Otherwise, it is added as the right child of `parent`. * `int getMaxAlternatingPathLength()` Returns the maximum length of a path in the tree where the values of the nodes alternate between `0` and `1`. **Note** that a path in the tree is defined as a sequence of nodes connected by edges without revisiting any node.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTreePath: def __init__(self): self.root = None self.nodes = {} def addNode(self, parent, value, isLeftChild): new_node = TreeNode(value) if parent is None: self.root = new_node self.nodes[value] = new_node return if parent not in self.nodes: raise ValueError(f\\"Parent node {parent} does not exist\\") parent_node = self.nodes[parent] if isLeftChild: if parent_node.left is not None: raise ValueError(f\\"Node {parent} already has a left child\\") parent_node.left = new_node else: if parent_node.right is not None: raise ValueError(f\\"Node {parent} already has a right child\\") parent_node.right = new_node self.nodes[value] = new_node def getMaxAlternatingPathLength(self): def dfs(node, prev_value=None): if node is None: return 0 left_length = 0 right_length = 0 if node.left and node.left.value != node.value: left_length = 1 + dfs(node.left, node.value) if node.right and node.right.value != node.value: right_length = 1 + dfs(node.right, node.value) # Get the max length found from both sides max_length[0] = max(max_length[0], left_length, right_length) return max(left_length, right_length) if self.root is None: return 0 max_length = [0] dfs(self.root) return max_length[0]"},{"question":"You are given an array of integers `nums` and a target integer `target`. Write a function that returns all the unique pairs of integers in the array that sum up to the target. Each pair should be represented as a tuple (a, b), where a <= b. The result should be an array of these pairs, sorted in ascending order by their first element, and within each pair, sorted in ascending order by the second element. Example: `nums = [2, 4, 3, 1, 5, 7, 6, -1]` and `target = 6`, the function should return `[(1, 5), (2, 4), (-1, 7)]`.","solution":"def find_pairs(nums, target): Returns all the unique pairs of integers in nums that sum up to target. Each pair (a, b) should satisfy a <= b. The result will be sorted by the first element of each pair, and then by the second element if needed. nums = sorted(nums) pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(pairs)"},{"question":"Design a class `HitCounter` that counts the number of hits received in the past 5 minutes (i.e., the past 300 seconds). Implement the `HitCounter` class: * `void hit(int timestamp)` Records a hit that happened at `timestamp` (in seconds granularity). Several hits may happen at the same timestamp. * `int getHits(int timestamp)` Returns the number of hits in the past 5 minutes from `timestamp` (i.e., the past 300 seconds). You may assume that the `timestamp` is monotonically increasing. Example: ``` HitCounter counter = new HitCounter(); counter.hit(1); // hit at timestamp 1. counter.hit(2); // hit at timestamp 2. counter.hit(3); // hit at timestamp 3. counter.getHits(4); // get hits at timestamp 4, should return 3. counter.hit(300); // hit at timestamp 300. counter.getHits(300); // get hits at timestamp 300, should return 4. counter.getHits(301); // get hits at timestamp 301, should return 3. ```","solution":"from collections import deque class HitCounter: def __init__(self): Initialize your data structure here. self.hits = deque() self.duration = 300 def hit(self, timestamp: int) -> None: Record a hit at a given timestamp. self.hits.append(timestamp) def getHits(self, timestamp: int) -> int: Return the number of hits in the past 5 minutes (300 seconds) from the given timestamp. while self.hits and self.hits[0] <= timestamp - self.duration: self.hits.popleft() return len(self.hits)"},{"question":"A company wants to send a promotional email to all its customers. The company has a list of email addresses stored in a **0-indexed** list `emails`. However, the company has to send the email in groups no larger than `k` emails at a time to avoid being flagged as spam. A group can consist of less than `k` emails, but not more than `k`. The company would like to find out how many groups are needed to send the email to all customers. Write a function that takes in two parameters: the list of email addresses `emails` and an integer `k`, and returns the number of groups needed.","solution":"def number_of_groups(emails, k): Returns the number of groups needed to send the email to all customers. Parameters: emails (list): List of email addresses. k (int): The maximum number of emails that can be sent in a group. Returns: int: The number of groups needed. # Calculate the number of full groups full_groups = len(emails) // k # Check if there is a remainder, meaning we need an additional group if len(emails) % k != 0: full_groups += 1 return full_groups"},{"question":"A queue is an abstract data type that follows the First-In-First-Out (FIFO) principle. Implement a class called `CircularQueue` to represent a circular queue with a fixed size. Your class should include the following methods: - `CircularQueue(int k)` Initializes the circular queue with a size of `k` which indicates the maximum number of elements that can be stored in the queue. - `bool enqueue(int value)` Adds an item at the rear of the queue. Returns `true` if the operation is successful, and `false` if the queue is full. - `bool dequeue()` Removes an item from the front of the queue. Returns `true` if the operation is successful, and `false` if the queue is empty. - `int front()` Returns the front item from the queue but does not remove it. Returns `-1` if the queue is empty. - `int rear()` Returns the last item from the queue but does not remove it. Returns `-1` if the queue is empty. - `bool isEmpty()` Checks whether the queue is empty. Returns `true` if the queue is empty, and `false` otherwise. - `bool isFull()` Checks whether the queue is full. Returns `true` if the queue is full, and `false` otherwise.","solution":"class CircularQueue: def __init__(self, k: int): self.queue = [None] * k self.max_size = k self.head = -1 self.tail = -1 def enqueue(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.max_size self.queue[self.tail] = value return True def dequeue(self) -> bool: if self.isEmpty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.max_size return True def front(self) -> int: if self.isEmpty(): return -1 return self.queue[self.head] def rear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: return self.head == -1 def isFull(self) -> bool: return (self.tail + 1) % self.max_size == self.head"},{"question":"You are given a **0-indexed** integer array `colors` where `colors[i]` represents the color of the `i`th element. Two elements are said to be **adjacent** if their indices differ by 1. We define a contiguous subarray as a subarray where each color appears an even number of times. Return the length of the longest contiguous subarray that satisfies this condition. If no such subarray exists, return 0.","solution":"def longest_balanced_subarray(colors): Returns the length of the longest contiguous subarray where each color appears an even number of times. def is_balanced(subarray): color_count = {} for color in subarray: color_count[color] = color_count.get(color, 0) + 1 return all(count % 2 == 0 for count in color_count.values()) max_length = 0 n = len(colors) for start in range(n): for end in range(start + 1, n + 1): subarray = colors[start:end] if is_balanced(subarray): max_length = max(max_length, end - start) return max_length"},{"question":"A **bitonic sequence** is a sequence of integers that first strictly increases and then strictly decreases. Write a function that, given an integer array `arr`, returns the maximum length of a bitonic subsequence. A **subsequence** is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order. * For example, given `arr = [1, 2, 5, 3, 2]`, the maximum length of a bitonic subsequence is `5` with the sequence `[1, 2, 5, 3, 2]`. * For example, given `arr = [1, 11, 2, 10, 4, 5, 2, 1]`, the maximum length of a bitonic subsequence is `6` with the sequence `[1, 2, 10, 4, 2, 1]`.","solution":"def longest_bitonic_subsequence(arr): Returns the length of the longest bitonic subsequence in the given array. n = len(arr) if n == 0: return 0 # Initialize the increasing and decreasing sequence arrays inc = [1] * n dec = [1] * n # Compute lengths of increasing subsequences ending at each index for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and inc[i] < inc[j] + 1: inc[i] = inc[j] + 1 # Compute lengths of decreasing subsequences starting at each index for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if arr[i] > arr[j] and dec[i] < dec[j] + 1: dec[i] = dec[j] + 1 # Calculate the maximum length of bitonic subsequence max_length = 0 for i in range(n): max_length = max(max_length, inc[i] + dec[i] - 1) return max_length"},{"question":"Given a `0-indexed` integer array `heights` representing the heights of buildings, you can place water between the buildings such that the height of the water at any position is determined by the shorter of the two buildings surrounding it. The water level must be between the heights of these two buildings and not exceed their heights. For a given array, find the total amount of water that can be trapped. For example, given the array `heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the expected output would be `6`, which represents the total water trapped between the buildings.","solution":"def trap_water(heights): Given a list of building heights, calculate the total amount of water that can be trapped between the buildings. :param heights: List[int], list of building heights :return: int, total amount of trapped water if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) total_water = 0 for i in range(n): water_level = min(left_max[i], right_max[i]) total_water += max(0, water_level - heights[i]) return total_water"},{"question":"A video streaming platform is keeping track of the number of viewers watching each video in real-time. Implement the `VideoPlatform` class: * `void startWatching(int userId, int videoId, int startTime)` - A viewer with a unique id `userId` starts watching a video identified by `videoId` at time `startTime`. * `void stopWatching(int userId, int videoId, int stopTime)` - The same viewer with `userId` stops watching the video at time `stopTime`. The viewer must have started watching the same video without stopping it in between. * `int getTotalViewTime(int videoId)` - Returns the total amount of time spent by all viewers watching the video identified by `videoId`. * `double getAverageViewTime(int videoId)` - Returns the average time spent by viewers watching the video identified by `videoId`. The average time is computed from all the previous viewing times for the video. Viewers can start and stop watching videos multiple times.","solution":"class VideoPlatform: def __init__(self): self.viewing_data = {} self.video_times = {} def startWatching(self, userId, videoId, startTime): if videoId not in self.viewing_data: self.viewing_data[videoId] = {} self.viewing_data[videoId][userId] = startTime def stopWatching(self, userId, videoId, stopTime): if videoId in self.viewing_data and userId in self.viewing_data[videoId]: startTime = self.viewing_data[videoId].pop(userId) duration = stopTime - startTime if videoId not in self.video_times: self.video_times[videoId] = [] self.video_times[videoId].append(duration) def getTotalViewTime(self, videoId): if videoId in self.video_times: return sum(self.video_times[videoId]) return 0 def getAverageViewTime(self, videoId): if videoId in self.video_times and len(self.video_times[videoId]) > 0: return sum(self.video_times[videoId]) / len(self.video_times[videoId]) return 0.0"},{"question":"You are given a list of `intervals` where `intervals[i] = [start_i, end_i]` represents the start and end times of the `i`-th interval. While processing these intervals, you need to merge any overlapping intervals and return the list of merged intervals. # Example: ``` Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. ``` # Constraints: * `1 <= intervals.length <= 10^4` * `intervals[i].length == 2` * `0 <= start_i <= end_i <= 10^4`","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns the list of merged intervals. Parameters: intervals (List[List[int]]): A list of intervals where each interval is represented as [start, end] Returns: List[List[int]]: A list of merged intervals. if not intervals: return [] # Sort the intervals based on the start times intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # if the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals"},{"question":"You are given a **1-indexed** integer array `heights` representing the heights of `n` people. The goal is to form a queue such that each person is only taller than those behind them in the queue. If there are multiple solutions, return the one which is lexicographically smallest. Return _the 1-indexed array of indices representing the order of people in the queue_. **Note:** - Lexicographical order means that if there are two different orders, the one with the smaller index at the first difference should be considered smaller.","solution":"def form_queue(heights): Forms a queue such that each person is only taller than those behind them, and returns the lexicographically smallest 1-indexed array of indices representing the order of people in the queue. indexed_heights = [(height, index + 1) for index, height in enumerate(heights)] indexed_heights.sort(key=lambda x: (x[0], x[1])) result = [index for height, index in indexed_heights] return result"},{"question":"You are given a string `s` and an integer `k`. The string is represented by lowercase English letters. You need to find the length of the longest substring that can be converted into a string with exactly `k` unique characters by replacing some or no characters. Return the length of such a substring. For example, given `s = \\"aaabbcc\\"` and `k = 2`, the longest substring is `\\"aaabb\\"` which has been converted to `\\"bbbbb\\"` using 2 unique characters (\'b\' and \'a\' converted to \'b\'). **Note:** If `k` is greater than the number of unique characters in the string, return the length of the string.","solution":"def longest_substring_k_unique(s, k): from collections import defaultdict if k == 0: return 0 n = len(s) left = 0 max_length = 0 char_count = defaultdict(int) for right in range(n): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an integer array `nums`, return `true` if you can partition the array into three non-empty parts with equal sums. Otherwise, return `false`. Each part should have a contiguous subarray structure, meaning the elements of each part appear consecutively in the original array. Ensure you provide an optimized solution in terms of time complexity, as brute-force approaches are less likely to perform well for larger arrays.","solution":"def can_three_parts_equal_sum(nums): Given an integer array nums, return true if you can partition the array into three non-empty parts with equal sums. Otherwise, return false. total_sum = sum(nums) if total_sum % 3 != 0: return False target = total_sum // 3 n, current_sum, count = len(nums), 0, 0 for i in range(n): current_sum += nums[i] if current_sum == target: current_sum = 0 count += 1 if count == 3: return True return False"},{"question":"Given a grid of size `m x n` consisting of only 0s and 1s, an island is a group of `1s` (representing land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Return _the number of islands_. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Here\'s an example of what the function signature might look like in Python: ```python def numIslands(grid: List[List[int]]) -> int: # implementation here ```","solution":"from typing import List def numIslands(grid: List[List[int]]) -> int: def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # Mark the cell as visited by setting it to 0 dfs(x + 1, y) # Visit the cell below dfs(x - 1, y) # Visit the cell above dfs(x, y + 1) # Visit the cell to the right dfs(x, y - 1) # Visit the cell to the left if not grid: return 0 num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: num_islands += 1 dfs(i, j) return num_islands"},{"question":"You are given a list of strings `words` containing English words. Your task is to write a program that finds all the **anagrams** in the list and groups them together. An anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once. The output should be a list of lists, where each sublist contains anagrams grouped together. For example: Input: `[\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\", \\"tac\\"]` Output: `[[\\"bat\\", \\"tab\\"], [\\"cat\\", \\"act\\", \\"tac\\"]]`","solution":"def group_anagrams(words): Groups anagrams together in nested lists. Args: words (list of str): List of words. Returns: list of list of str: List of anagram groups. from collections import defaultdict anagram_dict = defaultdict(list) for word in words: # Sort the word to create a key sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values())"},{"question":"Given a string `t` consisting of lowercase letters and an integer `n`, determine the smallest string that can be obtained by removing exactly `n` characters from `t`. If there are multiple possible results, return the lexicographically smallest one.","solution":"def smallest_string_after_removals(t, n): Determines the smallest string that can be obtained by removing exactly `n` characters from `t`. :param t: str, the original string from which characters need to be removed. :param n: int, the number of characters to remove. :return: str, the lexicographically smallest string after removing `n` characters. stack = [] for char in t: while stack and stack[-1] > char and n > 0: stack.pop() n -= 1 stack.append(char) return \'\'.join(stack[:len(t) - n])"},{"question":"You are given a string `s` of even length consisting only of characters \'a\' and \'b\'. You need to rearrange the characters and split the string into two equal parts such that the number of \'a\'s in the first half is equal to the number of \'b\'s in the second half. Return the string after rearrangement if possible, otherwise return an empty string.","solution":"def rearrange_string(s): Rearranges the string and splits it into two equal parts such that the number of \'a\'s in the first half is equal to the number of \'b\'s in the second half. Returns the rearranged string if possible, otherwise an empty string. n = len(s) half = n // 2 count_a = s.count(\'a\') count_b = s.count(\'b\') # Condition: number of \'a\'s should be equal to \'b\'s # Split them equally in halfs if count_a != half or count_b != half: return \\"\\" # Create first half with \'a\'s and second half with \'b\'s first_half = \'a\' * half second_half = \'b\' * half return first_half + second_half"},{"question":"You are given an integer array `arr` of size `n`, which represents the heights of buildings. Two buildings can form a **scenic pair** if the difference in their heights is greater than or equal to a given threshold `d`. Return _the number of scenic pairs_ in the array. A pair of buildings `(i, j)` is considered scenic if: * `0 <= i < j < n` * `|arr[i] - arr[j]| >= d` Note that `|x|` denotes the absolute value of `x`.","solution":"def scenic_pairs(arr, d): Returns the number of scenic pairs in the array where the difference in their heights is greater than or equal to threshold d. Parameters: arr (list): array of integers representing the heights of buildings d (int): the threshold for difference in heights Returns: int: number of scenic pairs n = len(arr) count = 0 for i in range(n): for j in range(i + 1, n): if abs(arr[i] - arr[j]) >= d: count += 1 return count"},{"question":"You are given two binary trees represented by their root nodes `root1` and `root2`. Return _the merged tree by performing a **node-wise sum** of the two input trees_. If two nodes overlap, sum their values as the new value of the merged node. Otherwise, the non-null node will be used as the node of the new tree. The merged tree should be returned in the form of the root node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(root1, root2): Merges two binary trees by performing a node-wise sum. If two nodes overlap, sum their values as the new value of the merged node. Otherwise, the non-null node will be used. :param root1: TreeNode - Root of the first binary tree. :param root2: TreeNode - Root of the second binary tree. :return: TreeNode - Root of the merged binary tree. if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged_root = TreeNode(root1.val + root2.val) merged_root.left = merge_trees(root1.left, root2.left) merged_root.right = merge_trees(root1.right, root2.right) return merged_root"},{"question":"You are given an array of integers representing the heights of different skyscrapers in a city. The goal is to determine from which skyscraper you can watch the **most uninterrupted sunrise views**. A side view means you are looking from the leftmost side towards the right. You can only see the sunrise if no taller skyscraper blocks your view. Return the index of the skyscraper from which the maximum number of sunrises can be seen. Note that the index is zero-based. If there is a tie for the maximum views, return the smallest index.","solution":"def max_sunrise_views(heights): Returns the index of the skyscraper from which the maximum number of sunrises can be seen. If there is a tie for the maximum views, the smallest index is returned. max_views = 0 best_index = 0 for i in range(len(heights)): views = 0 current_max_height = 0 for j in range(i+1): if heights[j] > current_max_height: views += 1 current_max_height = heights[j] if views > max_views: max_views = views best_index = i return best_index"},{"question":"You are given the head of a linked list and a value `x`. Partition the linked list into two parts such that all nodes less than `x` come before nodes greater than or equal to `x`. You should preserve the original relative order of the nodes in each of the two partitions. Implement the function `ListNode* partition(ListNode* head, int x)` to perform this partitioning.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, x): Partitions the linked list such that all nodes with values less than x come before nodes with values greater than or equal to x. The relative order of the nodes in each partition is preserved. :param head: The head of the linked list. :param x: The partitioning value. :return: The head of the modified linked list. less_head = ListNode(0) greater_head = ListNode(0) less = less_head greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next greater.next = None less.next = greater_head.next return less_head.next"},{"question":"Given a binary string `s`, determine whether it can be partitioned into **one or more subsequences** such that each subsequence forms a strictly **increasing** binary sequence. Return `true` if it is possible to partition the string in such a way, or `false` otherwise. Note that each character should belong to exactly one subsequence in a partition.","solution":"def can_partition_strictly_increasing_subsequences(s): Determines if the binary string s can be partitioned into one or more subsequences such that each subsequence forms a strictly increasing binary sequence. return \'11\' not in s"},{"question":"You are given an array of integers `arr` of size `n`. A subarray `[arr[i], arr[i+1], ..., arr[j]]` (0 <= i <= j < n) is called **special** if for every `i <= k < j`, the sum `arr[k] + arr[k+1]` is even (i.e., `arr[k]` and `arr[k+1]` have the same parity). Return _the length of the **longest** special subarray in_ `arr`.","solution":"def longest_special_subarray(arr): Returns the length of the longest special subarray in arr if not arr: return 0 max_length = 1 current_length = 1 for i in range(len(arr) - 1): if (arr[i] % 2) == (arr[i + 1] % 2): current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # reset for a new subarray max_length = max(max_length, current_length) # compare last subarray return max_length"},{"question":"Write a function `next_greater_elements(nums)` that takes a list of integers `nums` and returns a new list such that, for each element in the original list, the new list contains the next greater element that appears to the right in the original list. If there is no such greater element, the output should be `-1` for that element. For example, given the list `[4, 2, 5, 3, 1]`, the function should return `[5, 5, -1, -1, -1]` because: - The next greater element for `4` is `5`. - The next greater element for `2` is `5`. - The next greater element for `5` is `-1` (no greater element to the right). - The next greater element for `3` is `-1` (no greater element to the right). - The next greater element for `1` is `-1` (no greater element to the right).","solution":"def next_greater_elements(nums): Returns a list of the next greater elements for each element in the input list. If no such element exists, return -1 for that position. result = [-1] * len(nums) stack = [] for i in range(len(nums)): while stack and nums[i] > nums[stack[-1]]: idx = stack.pop() result[idx] = nums[i] stack.append(i) return result"},{"question":"Given a string `s` and an array of integers `indices` of the same length, sort the characters in `s` based on the order defined by `indices`, and return the resulting string. Each element in `indices` represents the position the corresponding character in `s` should go to in the reordered string.","solution":"def restore_string(s, indices): Return a reordered string based on the given indices. Parameters: s (str): The input string. indices (List[int]): The array of indices. Returns: str: The reordered string. # Create a list of the same length as s, filled with empty strings reordered = [\'\'] * len(s) # Place each character at its correct position based on indices for i, index in enumerate(indices): reordered[index] = s[i] # Join the list to form the resulting string return \'\'.join(reordered)"},{"question":"You are given two strings `s` and `t` of the same length. Your task is to determine if you can transform string `s` into string `t` using the following operation any number of times: Select a character in `s` and change it to any character that is lexicographically greater than it. Return `true` if you can transform `s` into `t`, and `false` otherwise.","solution":"def can_transform(s, t): Determines if string s can be transformed into string t using the operation of changing a character in s to any character that is lexicographically greater. # Iterate through the characters of both strings for char_s, char_t in zip(s, t): # Check if for every character in s, character in t is lexicographically # greater than or equal to the character in s if char_s > char_t: return False return True"},{"question":"Given a 2D grid of integers `grid` where each integer represents the height of a particular cell, return _the number of **valleys** in the grid_. A cell `(i, j)` is part of a **valley** if it is lower than all of its adjacent cells (up, down, left, right). Diagonal cells are not considered adjacent. A **valley** is a maximal set of connected cells that are **lower than** their non-diagonal adjacent cells. Two cells `(i1, j1)` and `(i2, j2)` are **connected** if they are adjacent to each other.","solution":"def find_valleys(grid): Finds the number of valleys in a 2D grid of integers. Parameters: grid (List[List[int]]): A 2D grid of integers representing heights. Returns: int: The number of valleys in the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def is_lower_than_adjacent(r, c): \\"Checks if the cell (r, c) is lower than all its adjacent cells.\\" for delta_r, delta_c in [(-1, 0), (1, 0), (0, -1), (0, 1)]: adj_r, adj_c = r + delta_r, c + delta_c if 0 <= adj_r < rows and 0 <= adj_c < cols: if grid[r][c] >= grid[adj_r][adj_c]: return False return True def dfs(r, c, visited): Depth-first search to mark all parts of the valley starting from cell (r, c). stack = [(r, c)] while stack: curr_r, curr_c = stack.pop() visited.add((curr_r, curr_c)) for delta_r, delta_c in [(-1, 0), (1, 0), (0, -1), (0, 1)]: adj_r, adj_c = curr_r + delta_r, curr_c + delta_c if 0 <= adj_r < rows and 0 <= adj_c < cols and (adj_r, adj_c) not in visited: if grid[curr_r][curr_c] == grid[adj_r][adj_c] and is_lower_than_adjacent(adj_r, adj_c): stack.append((adj_r, adj_c)) visited = set() valley_count = 0 for r in range(rows): for c in range(cols): if (r, c) not in visited and is_lower_than_adjacent(r, c): dfs(r, c, visited) valley_count += 1 return valley_count"},{"question":"Given an array of integers `nums`, write a function that returns the index of the first peak element in the array. A peak element is an element that is greater than its neighbors. For corner elements, we need to consider only one neighbor. If the array contains multiple peaks, return the index to the first peak. Implement the function `int findPeakElement(int[] nums)` to solve the problem. Note: - `nums[i]` is considered a peak if `nums[i] > nums[i+1]` and `nums[i] > nums[i-1]`. - For the first element, `nums[0]` is a peak if `nums[0] > nums[1]`. - For the last element, `nums[n-1]` is a peak if `nums[n-1] > nums[n-2]`. Example: - Input: `nums = [1, 2, 3, 1]` - Output: `2` Explanation: 3 is a peak element and your function should return the index number 2.","solution":"def findPeakElement(nums): Returns the index of the first peak element in the array. n = len(nums) if n == 1: return 0 if nums[0] > nums[1]: return 0 if nums[n - 1] > nums[n - 2]: return n - 1 for i in range(1, n - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: return i return -1 # If no peak is found, which theoretically should not happen"},{"question":"You are given a 2D grid of characters consisting of only `\'1\'`s (land) and `\'0\'`s (water). An **island** is a group of `\'1\'`s (land) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Write a function that returns _the number of islands_ in the grid. The function should analyze the connectivity of the land cells to determine how many distinct islands exist in the grid.","solution":"def num_islands(grid): def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != \'1\': return grid[i][j] = \'0\' # Mark the cell as visited dfs(grid, i + 1, j) # Visit down dfs(grid, i - 1, j) # Visit up dfs(grid, i, j + 1) # Visit right dfs(grid, i, j - 1) # Visit left if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': dfs(grid, i, j) count += 1 return count"},{"question":"Given an array of integers `arr`, return the length of the longest subarray where all its elements are equal. For example, if `arr` is `[1, 1, 2, 2, 2, 3]`, the output should be `3`, because the longest subarray where all elements are the same is `[2, 2, 2]`, which has a length of `3`.","solution":"def longest_equal_subarray(arr): Returns the length of the longest subarray where all its elements are equal. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"Given an `n x n` integer matrix `matrix`, write a function to rotate the matrix 90 degrees clockwise in-place. Return the modified matrix. The rotation should be performed without using an additional matrix and must modify the input matrix directly. Each element in the matrix should end up in its transformed position as if the entire matrix were turned 90 degrees to the right.","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. Args: matrix (list of list of int): The n x n matrix to rotate. Returns: list of list of int: The rotated matrix (modified in-place). n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"Given an integer `m`, generate an `m x m` magic square. A magic square is an arrangement of numbers in a square grid where the numbers in each row, each column, and both main diagonals all add up to the same number, known as the magic constant. In this particular problem, the magic square should contain the integers from `1` to `m*m`, arranged such that the magic constant equals `m*(m*m + 1) // 2`. Your task is to return a 2D list representing the `m x m` magic square. If `m` is not a positive odd integer, return an empty list.","solution":"def is_odd_positive_integer(m): return m > 0 and m % 2 == 1 def generate_magic_square(m): Generates an m x m magic square for odd m. :param m: size of the magic square (must be a positive odd integer) :return: m x m list representing the magic square, or an empty list if m is not a positive odd integer if not is_odd_positive_integer(m): return [] magic_square = [[0]*m for _ in range(m)] n = 1 # Start filling with the first number i, j = 0, m // 2 # Start position while n <= m * m: magic_square[i][j] = n n += 1 new_i, new_j = (i - 1) % m, (j + 1) % m if magic_square[new_i][new_j]: # If this cell is already filled i += 1 else: i, j = new_i, new_j return magic_square"},{"question":"You are given a binary tree with `n` nodes numbered from `1` to `n`. Each node has a unique value representing its position in the tree. You are also given an integer array `queries` where each `queries[i]` represents the value of a node for which you need to find the sum of the values of all descendant nodes (including itself). Return an array of integers where the `i-th` element is the sum for the node represented by `queries[i]`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def node_sum(node): Calculate the sum of all descendant nodes\' values including itself. if node is None: return 0 left_sum = node_sum(node.left) right_sum = node_sum(node.right) return node.val + left_sum + right_sum def find_descendant_sums(root, queries): Given a binary tree root and list of queries, returns the sum of all descendants\' values for each query. value_to_node = {} def map_nodes(node): if not node: return value_to_node[node.val] = node map_nodes(node.left) map_nodes(node.right) map_nodes(root) result = [] for q in queries: result.append(node_sum(value_to_node[q])) return result"},{"question":"Given a grid of size m x n, you are initially positioned at the top-left corner (i.e., grid[0][0]). The grid represents a maze where 1 represents a wall and 0 represents an open space you can walk through. You can only move either down or right at any point in time. You need to find the number of unique paths from the top-left corner to the bottom-right corner (i.e., grid[m-1][n-1]) given that you can only pass through open spaces. Return the number of unique paths.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner, navigating through open spaces (represented by 0) and avoiding walls (represented by 1). if not grid or grid[0][0] == 1: # Start is blocked return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Fill the rest of the grid for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"Given an array of `integers` representing the heights of students in a queue, return _the number of pairs of students (i, j) where `i < j` and the students are not in the correct order of height_. A pair (i, j) is said to be out of order if `heights[i] > heights[j]`.","solution":"def count_out_of_order_pairs(heights): Returns the number of pairs of students (i, j) where i < j and heights[i] > heights[j]. Parameters: heights (list): List of integers representing the heights of students in a queue. Returns: int: Number of out of order pairs. count = 0 for i in range(len(heights)): for j in range(i + 1, len(heights)): if heights[i] > heights[j]: count += 1 return count"},{"question":"A valid parentheses string is either an empty string `\\"\\"`, a concatenation of two valid parentheses strings, or a string enclosed by a matching pair of parentheses. For example, `\\"\\"`, `\\"()\\"`, and `\\"(())\\"` are valid parentheses strings, but `\\")(\\"`, `\\"(()\\"`, and `\\"())\\"` are not. Given a string `s` consisting of `(` and `)`, you need to determine if it is a valid parentheses string. Otherwise, you need to return the longest valid parentheses substring. Return _a tuple of boolean and the longest valid parentheses substring. If the string is valid, the substring is the string itself._","solution":"def valid_parentheses_string(s): Determine if the string `s` is a valid parentheses string. If not, return the longest valid parentheses substring. Parameters: s (str): A string consisting of \'(\' and \')\' Returns: tuple: (boolean, substring) - first value indicates if the string is valid, second value is the longest valid parentheses substring (or the string itself if valid) def is_valid(s): stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\' and stack: stack.pop() else: return False return not stack def longest_valid_substring(s): max_len = 0 start = 0 n = len(s) stack = [-1] for i in range(n): if s[i] == \'(\': stack.append(i) else: stack.pop() if stack: length = i - stack[-1] if length > max_len: max_len = length start = stack[-1] + 1 else: stack.append(i) return s[start:start+max_len] valid = is_valid(s) if valid: return (True, s) else: return (False, longest_valid_substring(s))"},{"question":"Given a **0-indexed** integer array `heights` representing the heights of buildings on a street, and an integer `bricks` and `ladders`, you need to reach the last building by moving from the `0th` building to the `n-1th` building. You can only move to the next building if its height is less than or equal to the height of the current building, or if you use either bricks or a ladder. * Each time you use bricks, you decrease the number of bricks by the difference in heights between the current building and the next. * Each time you use a ladder, you can skip the height difference for one move. Return _the maximum index of the building that you can reach_.","solution":"import heapq def furthest_building(heights, bricks, ladders): Return the maximum index of the building that can be reached. Parameters: heights (List[int]): List of building heights. bricks (int): Number of bricks available. ladders (int): Number of ladders available. Returns: int: The maximum index of the building that can be reached. heap = [] for i in range(len(heights) - 1): climb = heights[i + 1] - heights[i] if climb > 0: heapq.heappush(heap, climb) if len(heap) > ladders: bricks -= heapq.heappop(heap) if bricks < 0: return i return len(heights) - 1"},{"question":"You are given a list of non-negative integers representing the height of a series of hills. Imagine that rain falls over the hills and water collects in the valleys between the hills. Write a function that computes the total amount of water that would be collected after raining. Each integer in the list represents the height of the hill at that position. The length of the list `heights` is at least 1 but can be very large. For example, given the list `heights = [0,1,0,2,1,0,1,3,2,1,2,1]`, the function should return `6` because 6 units of water would be collected between the hills. Complete the function with the following signature: ```python def total_water_collected(heights: List[int]) -> int: # implementation here ```","solution":"from typing import List def total_water_collected(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"You are given an array of integers `height` representing the elevation map where the width of each bar is `1`. Write an algorithm to calculate how much water it can trap after raining. The array `height` contains `n` non-negative integers where `n` represents the number of bars in the elevation map and each element in the array specifies the height of the bar at that index. For example, given an elevation map `height` of `[0,1,0,2,1,0,1,3,2,1,2,1]`, your algorithm should return `6`, indicating that `6` units of water can be trapped after raining over this map. Implement the function `int trap(int[] height)` that returns the total amount of water that can be trapped.","solution":"def trap(height): Calculate how much water can be trapped after raining. :param height: List[int] representing the elevation map. :return: int representing the total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given a string `text` containing digits from \'0\' to \'9\' and characters \'#\'. Each \'#\' character in the string represents a digit that is missing. Design an algorithm that finds the smallest number that can be formed by replacing every \'#\' in the string `text` with a digit from \'0\' to \'9\'. Implement the function `String findSmallestNumber(String text)` that returns the smallest possible number as a string.","solution":"def find_smallest_number(text): Returns the smallest number that can be formed by replacing every \'#\' in the text with a digit from \'0\' to \'9\'. result = text.replace(\'#\', \'0\') return result"},{"question":"Given an array of colors, where colors[i] represents the color of the ith house, determine the minimum cost to paint all the houses such that no two adjacent houses have the same color. The painting cost of each house is represented by a 2D array costs where costs[i][j] is the cost of painting the ith house with color j. Return _the minimum cost to paint all houses_.","solution":"def min_cost_paint_houses(costs): if not costs: return 0 n = len(costs) k = len(costs[0]) dp = costs[0] for i in range(1, n): prev_dp = dp[:] for j in range(k): dp[j] = costs[i][j] + min(prev_dp[m] for m in range(k) if m != j) return min(dp)"},{"question":"Given an integer array `arr` of size `n`, your task is to find the **minimum length of a contiguous subarray** of which the sum is greater than or equal to a given integer `s`. If there isnt one, return `0` instead. The time complexity should be `O(n)`.","solution":"def min_subarray_len(s, arr): Finds the minimum length of a contiguous subarray of which the sum is greater than or equal to `s`. Args: - s (int): The target sum. - arr (list of int): The input array. Returns: - int: The length of the minimum subarray with sum at least `s`, or 0 if there is no such subarray. n = len(arr) min_len = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float(\'inf\') else 0"},{"question":"Given an array of integers `arr`, where each element represents the height of a building, determine the number of buildings with an unobstructed ocean view. A building has an ocean view if it is strictly taller than all the buildings to its right. Return the index of each building that has an ocean view in increasing order.","solution":"def findBuildingsWithOceanView(arr): Returns a list of indices of buildings that have an ocean view. A building has an ocean view if it is strictly taller than all the buildings to its right. The returned list is in increasing order. n = len(arr) result = [] max_height = float(\'-inf\') for i in range(n - 1, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] result.reverse() return result"},{"question":"You are given a directed graph represented as an adjacency list in the form of a list of edges `edges`, where `edges[i] = [u, v]` indicates that there is a direct edge from node `u` to node `v`. Each node can only be visited once, and you need to find out if there exists a Hamiltonian Path in the graph. A Hamiltonian Path is a path in a graph that visits each vertex exactly once. Return `true` if there is a Hamiltonian Path in the graph; otherwise, return `false`.","solution":"from collections import defaultdict def has_hamiltonian_path(num_nodes, edges): def dfs(node, visited, num_visited): if num_visited == num_nodes: return True for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True if dfs(neighbor, visited, num_visited + 1): return True visited[neighbor] = False return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) for start_node in range(num_nodes): visited = [False] * num_nodes visited[start_node] = True if dfs(start_node, visited, 1): return True return False"},{"question":"You are given a matrix consisting of integers where each integer represents the elevation at that point. You\'re also given two points in the matrix, a start point `start` and an end point `end`. Your task is to determine the minimum elevation difference between the highest and lowest points you could encounter along any path from `start` to `end`. You may move up, down, left, or right, but you cannot move diagonally. Return the minimum possible elevation difference for any valid path from `start` to `end`.","solution":"import heapq def min_elevation_diff(matrix, start, end): Returns the minimum elevation difference between the highest and lowest points along any path from start to end in the given matrix. rows, cols = len(matrix), len(matrix[0]) directions = [(0,1), (1,0), (0,-1), (-1,0)] start_val = matrix[start[0]][start[1]] end_val = matrix[end[0]][end[1]] min_heap = [(0, start[0], start[1], start_val, start_val)] # elevation_diff, x, y, min_elevation, max_elevation visited = set() while min_heap: elevation_diff, x, y, min_elevation, max_elevation = heapq.heappop(min_heap) if (x, y) == end: return elevation_diff if (x, y) in visited: continue visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: new_min_elevation = min(min_elevation, matrix[nx][ny]) new_max_elevation = max(max_elevation, matrix[nx][ny]) new_elevation_diff = new_max_elevation - new_min_elevation heapq.heappush(min_heap, (new_elevation_diff, nx, ny, new_min_elevation, new_max_elevation)) return -1 # If no path is found"},{"question":"Given a list of integers `nums`, return the maximum possible sum of a subsequence such that the subsequence does not contain any consecutive elements from `nums`.","solution":"def max_non_consecutive_sum(nums): Returns the maximum possible sum of a subsequence such that no consecutive elements are included. if not nums: return 0 n = len(nums) if n == 1: return nums[0] incl = nums[0] excl = 0 for i in range(1, n): new_excl = max(incl, excl) incl = excl + nums[i] excl = new_excl return max(incl, excl)"},{"question":"For a given positive integer `n`, generate all possible valid combinations of `n` pairs of parentheses. The output should be a list of strings, where each string represents a valid combination of parentheses that is balanced. Write a function that returns all possible combinations in **lexicographical** order. The solution should be efficient enough to handle cases where `n` is up to `10`. ```python from typing import List def generateParentheses(n: int) -> List[str]: pass # Example usage: # generateParentheses(3) # Output: [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] ``` # Constraints: - 1  `n`  10","solution":"from typing import List def generateParentheses(n: int) -> List[str]: Generate all combinations of n pairs of balanced parentheses in lexicographical order. def backtrack(s: str, left: int, right: int): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) result = [] backtrack(\'\', 0, 0) return result"},{"question":"Given an integer array `arr` of length `n`, return _the maximum product of any two adjacent elements_ in the array.","solution":"def max_adjacent_product(arr): Returns the maximum product of any two adjacent elements in the array. if len(arr) < 2: raise ValueError(\\"Array must have at least two elements.\\") max_product = arr[0] * arr[1] for i in range(1, len(arr) - 1): max_product = max(max_product, arr[i] * arr[i + 1]) return max_product"},{"question":"Given a string `s` consisting of words separated by spaces, reverse the order of characters in each word while maintaining the order of the words. Return _the transformed string_.","solution":"def reverse_characters_in_words(s: str) -> str: Reverses the characters in each word of the string s while maintaining the order of the words. Parameters: s (str): The input string consisting of words separated by spaces. Returns: str: The string with characters in each word reversed and word order maintained. return \' \'.join(word[::-1] for word in s.split(\' \'))"},{"question":"You are given a string `s` consisting of lowercase Latin letters. Find the length of the **longest substring** without repeating characters and return that length. A substring is a contiguous sequence of characters within a string.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"You are given a string `blocks` consisting of letters `\'R\'`, `\'W\'`, and `\'B\'`. Imagine you are arranging the blocks in a line and want to maximize the number of adjacent pairs of blocks which are identical. Implement the `MaximizeAdjPairs` class: * `MaximizeAdjPairs(String blocks)` Initializes the `MaximizeAdjPairs` object with the string `blocks`. * `int findMaxPairs()` Returns the maximum number of adjacent pairs of blocks which are identical that can be achieved by rearranging the blocks in any order.","solution":"from collections import Counter class MaximizeAdjPairs: def __init__(self, blocks): self.blocks = blocks def findMaxPairs(self): # Count the frequency of each block type counter = Counter(self.blocks) # Calculate the maximum number of pairs for each block type max_pairs = 0 for count in counter.values(): max_pairs += count // 2 return max_pairs"},{"question":"Given an integer `n`, return an array `answer` where `answer[i]` is the number of trailing zeros in the factorial of `i`, for `0 <= i <= n`.","solution":"def trailing_zeros_in_factorials(n): Returns an array where each element `i` is the number of trailing zeros in the factorial of `i`. def count_trailing_zeros(num): count = 0 while num >= 5: num //= 5 count += num return count answer = [count_trailing_zeros(i) for i in range(n + 1)] return answer"},{"question":"Given a binary tree, implement a function `invertTree` to invert the tree. That is, for every node in the tree, swap its left and right children. Write the definition for the aforementioned function which takes the root of the binary tree as input and returns the root of the inverted binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root): Inverts a binary tree by swapping left and right children recursively. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recur on left and right subtrees invertTree(root.left) invertTree(root.right) return root"},{"question":"Given a string `s` containing only lowercase letters, find the length of the longest substring that contains at most two distinct characters. Implement the `LongestSubstring` class: * `LongestSubstring(String s)` Initializes the object with string `s`. * `int findLength()` Returns the length of the longest substring with at most two distinct characters.","solution":"class LongestSubstring: def __init__(self, s): self.s = s def findLength(self): n = len(self.s) if n == 0: return 0 left, right = 0, 0 max_len = 0 char_map = {} while right < n: if len(char_map) < 3: char_map[self.s[right]] = right right += 1 if len(char_map) == 3: del_idx = min(char_map.values()) del char_map[self.s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"Given an array of integers `arr` and an integer `x`, return an array where each element is the position of the next element in `arr` that is greater than `x`. If there is no such element, return -1 for that position. The output array should be of the same length as `arr`.","solution":"def next_greater_elements(arr, x): For each element in arr, return the position of the next element that is greater than x. If there is no such element, return -1 for that position. :param arr: List[int] - input array of integers :param x: int - target integer :return: List[int] - resulting array of positions result = [] n = len(arr) for i in range(n): found = False for j in range(i + 1, n): if arr[j] > x: result.append(j) found = True break if not found: result.append(-1) return result"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house, along a street. A robber wants to rob such that two adjacent houses are never robbed on the same night to prevent alerting the police. Determine the maximum amount of money the robber can steal without robbing two adjacent houses. Return _the maximum amount of money that can be robbed_.","solution":"def rob(nums): Determine the maximum amount of money that can be robbed without robbing two adjacent houses. :param nums: List[int] - the amount of money of each house along a street. :return: int - the maximum amount of money that can be robbed. if not nums: return 0 if len(nums) <= 2: return max(nums) prev_max = 0 curr_max = 0 for num in nums: temp = curr_max curr_max = max(curr_max, prev_max + num) prev_max = temp return curr_max"},{"question":"You are given an array of integers representing the height of consecutive buildings in a row. Every time you can remove the topmost part of `x` heights from any single building, where `x` could be any non-negative integer. However, removing the top part of `x` heights increments the cost by `x`. Your objective is to make the heights of all buildings equal with the **minimum** cost. Write a function that takes the array of building heights and returns the minimum cost to equalize all building heights.","solution":"def min_cost_to_equalize_heights(heights): \'\'\' Calculates the minimum cost to equalize the heights of all buildings. Parameters: heights (list[int]): An array of integers representing the height of each building. Returns: int: Minimum cost to equalize all building heights. \'\'\' min_height = min(heights) return sum(height - min_height for height in heights)"},{"question":"You are given a string `s` consisting only of letters \'a\' and \'b\'. A substring is defined as any contiguous sequence of characters in the string. Write a function that returns the length of the longest contiguous substring containing only one distinct letter. For example: - Given `s = \\"aaabbbaaa\\"`, the function should return `3` because the longest substring of a single distinct letter is either \\"aaa\\" at the beginning or \\"aaa\\" at the end. - Given `s = \\"abababab\\"`, the function should return `1` because the longest substrings of a single distinct letter are \\"a\\" and \\"b\\". Your implementation should be efficient and consider the edge cases such as an empty string or a string where all characters are the same.","solution":"def longest_contiguous_substring(s): Returns the length of the longest contiguous substring containing only one distinct letter. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a string `s` and an array `p` where `p[i]` represents the position of the character that should be swapped with the character at position `i` to reverse the string using the swap operations defined in `p`. Write a function to determine if it is possible to make the string `s` a palindrome after performing all the swaps exactly once. Return `true` if it is possible, otherwise return `false`.","solution":"def can_be_palindrome(s, p): Determine if it\'s possible to make the string s a palindrome after performing all swaps defined in p. :param s: A string :param p: A list of integers representing swap positions :return: True if possible, otherwise False # Perform the swaps as defined in p s = list(s) for i in range(len(p)): swap_pos = p[i] s[i], s[swap_pos] = s[swap_pos], s[i] # Check if the resulting string is a palindrome swapped_s = \'\'.join(s) return swapped_s == swapped_s[::-1]"},{"question":"Given a list of `points` where `points[i] = [xi, yi]` represents a point on the 2D plane, return the number of unique **boomerangs**. A **boomerang** is defined as a tuple of points `(i, j, k)` such that the distance between `i` and `j` is equal to the distance between `i` and `k` (the order of the tuple matters). For example, if `points = [[0,0], [1,0], [2,0]]`, then the answer would be `2` as there are 2 boomerangs: `(0, 1, 2)` and `(0, 2, 1)`.","solution":"def number_of_boomerangs(points): from collections import defaultdict def get_squared_distance(p1, p2): return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 count = 0 for i in range(len(points)): distance_map = defaultdict(int) for j in range(len(points)): if i != j: distance = get_squared_distance(points[i], points[j]) distance_map[distance] += 1 for k in distance_map.values(): count += k * (k - 1) # Permutations of k items taken 2 at a time: kP2 = k * (k - 1) return count"},{"question":"Given an integer array `nums` of size `n`, where all integers are in the range from `1` to `n` inclusive, some elements appear twice and others appear once. Find all the elements that appear more than once and return them as a list. You must write an algorithm that runs in `O(n)` time and uses constant extra space.","solution":"def find_duplicates(nums): Returns a list of elements that appear more than once in the input array. This algorithm runs in O(n) time and uses constant extra space. duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(abs(num)) else: nums[index] = -nums[index] return duplicates"},{"question":"You are given an integer array `nums` and an integer `target`. You must insert `target` into `nums` in such a way that the array remains sorted in non-decreasing order. After inserting `target`, return the new array with `target` in its correct position. If `target` already exists in the array, insert `target` immediately after its last occurrence.","solution":"def insert_and_sort(nums, target): Inserts target into nums in such a way that the array remains sorted in non-decreasing order. If target already exists in the array, it inserts target immediately after its last occurrence. Parameters: nums (list of int): The list of integers target (int): The target integer to be inserted Returns: list of int: The new list with target inserted in the correct position # Find the correct insertion point which is after the last occurrence of target insert_pos = len(nums) for i in range(len(nums)): if nums[i] > target: insert_pos = i break if nums[i] == target: insert_pos = i + 1 # Insert the target at the insertion point nums.insert(insert_pos, target) return nums"},{"question":"You are given a binary search tree (BST) and an integer `k`. Find the `k`-th smallest element in the BST. Assume that `k` is always valid. The binary search tree is represented using `TreeNode` structure where each node has an integer value `val`, a left child (`left`), and a right child (`right`). Return the k-th smallest element in the binary search tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Find the k-th smallest element in the BST. def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Perform in-order traversal to get elements in sorted order elements = inorder_traversal(root) # Return the k-th smallest element return elements[k - 1]"},{"question":"You are given a string `s` consisting of only lowercase English letters. You need to process the string such that each letter can be used to form a subsequence (not necessarily contiguous) that is a palindrome. Return _the length of the longest possible subsequence that can be made using characters from `s` such that the subsequence is a palindrome_. You can assume that the maximum length of `s` is 1000.","solution":"def longest_palindromic_subsequence_length(s): Returns the length of the longest possible palindromic subsequence that can be made using characters from s. from collections import Counter # Count the frequency of each character freq = Counter(s) # Initialize result and flag to check for odd characters result = 0 odd_found = False for count in freq.values(): if count % 2 == 0: result += count else: result += count - 1 odd_found = True # If we found an odd frequency character, we can use it as the center of the palindrome if odd_found: result += 1 return result"},{"question":"You are given an `m x n` 2D grid map of integers representing the elevation at each point. The elevation value can be either positive or negative. You need to find the maximum difference in elevation between any two cells such that both cells are connected to each other directly or indirectly. Two cells are considered connected if they are adjacent horizontally or vertically. Return the maximum difference in elevation.","solution":"def max_elevation_difference(grid): Returns the maximum difference in elevation between any two connected cells in the grid. def dfs(x, y): stack = [(x, y)] visited[x][y] = True min_val, max_val = grid[x][y], grid[x][y] while stack: cx, cy = stack.pop() for nx, ny in get_neighbors(cx, cy): if not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) min_val = min(min_val, grid[nx][ny]) max_val = max(max_val, grid[nx][ny]) return min_val, max_val def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): yield nx, ny visited = [[False] * len(grid[0]) for _ in range(len(grid))] max_diff = 0 for i in range(len(grid)): for j in range(len(grid[i])): if not visited[i][j]: min_val, max_val = dfs(i, j) max_diff = max(max_diff, max_val - min_val) return max_diff"},{"question":"You are given a string `s` and you need to reconstruct the original digits in string format from it. The original digits are all the digits from `0` to `9` that appeared in some random order. The input string `s` contains only lowercase English letters (excluding digits). Each digit in the output must be unique. Find a way to extract digits from `s` and return them in a digit-sorted order (from `0` to `9`). For example, if the input string `s` is \\"owoztneoer\\", then the output should be \\"012\\".","solution":"def original_digits(s): Given a string `s` containing English letters, reconstruct digits from 0 to 9 that appeared in any random order from the string and return them in sorted order. from collections import Counter count = Counter(s) out = {} # Building the digits in the order to uniquely identify each based on unique characters out[\'0\'] = count[\'z\'] # zero out[\'2\'] = count[\'w\'] # two out[\'4\'] = count[\'u\'] # four out[\'6\'] = count[\'x\'] # six out[\'8\'] = count[\'g\'] # eight out[\'5\'] = count[\'f\'] - out[\'4\'] # five out[\'7\'] = count[\'s\'] - out[\'6\'] # seven out[\'3\'] = count[\'h\'] - out[\'8\'] # three out[\'1\'] = count[\'o\'] - out[\'0\'] - out[\'2\'] - out[\'4\'] # one out[\'9\'] = count[\'i\'] - out[\'5\'] - out[\'6\'] - out[\'8\'] # nine result = \'\'.join([num * out[num] for num in sorted(out.keys())]) return result"},{"question":"You are given an integer array `arr` of length `n`, representing the heights of buildings in a straight line. Each building can either be painted or left unpainted. You must paint exactly `k` buildings such that the total difference in height between each pair of adjacent painted buildings is minimized. Return the minimum possible total difference in height achieved by selecting and painting these `k` buildings. If it is not possible to paint exactly `k` buildings, return `-1`.","solution":"def min_total_difference(arr, k): Returns the minimum possible total difference in height achieved by selecting and painting exactly k buildings. If it\'s not possible to paint k buildings, returns -1. Parameters: arr (list): List of integers representing heights of buildings. k (int): Number of buildings to be painted. Returns: int: Minimum possible total difference in height, or -1 if not possible. n = len(arr) if k > n: return -1 arr.sort() min_diff = float(\'inf\') for i in range(n - k + 1): current_diff = arr[i + k - 1] - arr[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"You are given a string `s` consisting only of characters `(` and `)`. A string is called valid if the number of opening brackets `(` is equal to the number of closing brackets `)` and every closing bracket `)` has a preceding corresponding opening bracket `(`. Given a string `s`, find the length of the longest valid (well-formed) substring. Return _the length of the longest valid substring_.","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid (well-formed) substring. max_length = 0 stack = [-1] # Initialize stack with -1 to handle edge case for valid substring from the beginning for i, char in enumerate(s): if char == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"You are given an undirected graph represented as an integer `n` (the number of nodes) and a list of `edges` where each `edges[i] = [ui, vi]` denotes an edge between nodes `ui` and `vi`. Implement a function to determine if the graph is bipartite. A graph is bipartite if the nodes can be colored using exactly two colors, such that no two adjacent nodes have the same color. Return `true` if the given graph is bipartite, otherwise return `false`.","solution":"def is_bipartite(n, edges): Determines if the given graph is bipartite. Parameters: - n: int - The number of nodes in the graph - edges: List[List[int]] - The edges of the graph Returns: - bool - True if the graph is bipartite, False otherwise from collections import deque # Create adjacency list graph = {i: [] for i in range(n)} for u, v in edges: graph[u].append(v) graph[v].append(u) # Initialize all nodes with no color (0: uncolored, 1: color1, -1: color2) color = [0] * n def bfs(start): queue = deque([start]) color[start] = 1 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == 0: # If not colored, color with opposite color color[neighbor] = -color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # If same color as current node return False return True # Check each component of the graph for i in range(n): if color[i] == 0: if not bfs(i): return False return True"},{"question":"Given an array of integers `nums` and an integer `k`, rearrange the array such that the maximum difference between the largest element and the smallest element among any consecutive subarray of `k` elements is minimized. Return the minimized difference. If it is not possible to rearrange the array to meet the condition, return `-1`.","solution":"def minimize_max_difference(nums, k): Rearrange the nums array such that the maximum difference between the largest and smallest element among any consecutive subarray of k elements is minimized. n = len(nums) if n < k: return -1 # Not possible to get subarrays of length k nums.sort() min_diff = float(\'inf\') for i in range(n - k + 1): current_diff = nums[i + k - 1] - nums[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"You are given an **undirected** graph represented by an adjacency list, where nodes are labeled from `0` to `n-1`. Each node in the graph can either be colored red or blue. Two nodes directly connected by an edge cannot have the same color. Design a function that determines if the graph can be **bipartitioned** such that all nodes connected by an edge have different colors. Return `true` if such a bipartition is possible, and `false` otherwise.","solution":"def is_bipartite(graph): Determines if the graph can be bipartitioned such that all nodes connected by an edge have different colors. Parameters: graph (list of list of int): The adjacency list of the graph. Returns: bool: True if the graph can be bipartitioned, False otherwise. n = len(graph) color = [-1] * n # -1 means uncolored def dfs(node, c): color[node] = c for neighbor in graph[node]: if color[neighbor] == -1: if not dfs(neighbor, 1 - c): return False elif color[neighbor] == color[node]: return False return True for i in range(n): if color[i] == -1: if not dfs(i, 0): return False return True"},{"question":"Given an array of integers `arr` and an integer `k`, your task is to split the array into as many subarrays as possible such that the sum of each subarray does not exceed `k`. Return the maximum number of subarrays you can achieve under this condition. For example, if `arr = [2, 3, 1, 2, 4, 3]` and `k = 5`, one possible way is to split the array into `[[2, 3], [1, 2], [4], [3]]`, resulting in 4 subarrays.","solution":"def max_subarrays_with_sum_limit(arr, k): subarrays = [] # Initialize list to store subarrays current_sum = 0 # Initialize current subarray sum current_subarray = [] # Initialize current subarray for num in arr: if current_sum + num > k: # When adding num exceeds the limit, start a new subarray subarrays.append(current_subarray) current_subarray = [num] current_sum = num else: # Otherwise, add num to the current subarray current_subarray.append(num) current_sum += num # Append the last subarray if current_subarray: subarrays.append(current_subarray) # Return the number of subarrays formed return len(subarrays)"},{"question":"Given an array of strings `words`, return a new array where each element is the reverse of the corresponding element in `words`. For example, if the input array is `[\\"hello\\", \\"world\\"]`, the output should be `[\\"olleh\\", \\"dlrow\\"]`.","solution":"def reverse_words(words): Given an array of strings `words`, returns a new array where each element is the reverse of the corresponding element in `words`. return [word[::-1] for word in words]"},{"question":"You are given an integer array `arr` consisting of `n` integers, where the integers may have both positive and negative values. Your task is to find the maximum product of any subarray of length `k`, where `k` is a given positive integer less than or equal to `n`. Return the maximum product obtained, or `-1` if it is not possible to find such a subarray.","solution":"def max_product_of_subarray(arr, k): Returns the maximum product of any subarray of length k. n = len(arr) if k > n or k <= 0: return -1 max_product = float(\'-inf\') # Calculate product for the initial subarray of length k current_product = 1 for i in range(k): current_product *= arr[i] max_product = current_product # Slide the window of size k and calculate the product for i in range(k, n): if arr[i - k] != 0: current_product = current_product // arr[i - k] * arr[i] else: # Recalculate the product for the current window current_product = 1 for j in range(i - k + 1, i + 1): current_product *= arr[j] max_product = max(max_product, current_product) return max_product"},{"question":"Given an array of `n` integers, determine whether there exists a subarray (contiguous segment) whose elements sum up to zero. Return `true` if such a subarray exists, otherwise return `false`. For example, given the array `[4, 2, -3, 1, 6]`, there exists a subarray `[2, -3, 1]` that sums up to zero, so the function should return `true`. For the array `[1, 2, 3]`, no subarray sums up to zero, so the function should return `false`.","solution":"def has_zero_sum_subarray(arr): Checks if there exists a subarray with sum zero in the given array `arr`. :param arr: List[int] - List of integers. :return: bool - True if there is a subarray with sum zero, otherwise False. prefix_sum = 0 prefix_set = set() for num in arr: prefix_sum += num # If prefix_sum is 0 or it is already seen, we have a zero sum subarray if prefix_sum == 0 or prefix_sum in prefix_set: return True prefix_set.add(prefix_sum) return False"},{"question":"Given a list of integers `nums`, you are allowed to perform at most one operation: choose any index `i` (0 <= i < nums.length) and remove any integer at that index, only if it is not the largest or smallest element in the list. Return the maximum possible product of three numbers in the resulting list. If it is not possible to remove any element, return the product of the three largest numbers in the original list. The original list will always have at least three elements.","solution":"def maximum_product(nums): nums.sort() max1 = nums[-1] * nums[-2] * nums[-3] max2 = nums[0] * nums[1] * nums[-1] if len(nums) > 3: if nums[1] != nums[0]: max2 = max(max2, nums[1] * nums[-1] * nums[-2]) if nums[-2] != nums[-1]: max2 = max(max2, nums[0] * nums[1] * nums[-2]) return max(max1, max2)"},{"question":"A company has a hierarchical structure of employees where each employee has a unique ID and a manager ID, except for the company president who does not have a manager. The employees are represented using a list of `[employee_id, manager_id]` pairs. You are given an integer `target_id` representing the employee for whom you need to find the highest-level manager (i.e., the company president). Write a function that, given the list of employees `[employee_id, manager_id]` and the `target_id`, returns the ID of the company\'s president.","solution":"def find_president(employees, target_id): Returns the ID of the company\'s president for the given target_id. Args: employees: List of [employee_id, manager_id] pairs target_id: Integer representing the employee ID to find the president for Returns: Integer representing the president\'s ID # Create a dictionary for quick lookup of manager by employee ID manager_dict = {emp[0]: emp[1] for emp in employees if emp[1] is not None} # Start with the target_id and traverse upwards to find the president current_id = target_id while current_id in manager_dict: current_id = manager_dict[current_id] return current_id"},{"question":"You are given two arrays `preorder` and `postorder`, which represent the pre-order and post-order traversals of a binary tree. Your task is to construct the binary tree from these traversals and return its root. It is guaranteed that there exists at least one such tree and that the values of the nodes in the tree are unique. Each value in the arrays `preorder` and `postorder` is an integer that represents the value of a node in the binary tree. Write a function: ```python def constructFromPrePost(preorder: List[int], postorder: List[int]) -> TreeNode: ``` where `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Example: ```python preorder = [1, 2, 4, 5, 3, 6, 7] postorder = [4, 5, 2, 6, 7, 3, 1] # Constructed binary tree: # 1 # / # 2 3 # / / # 4 5 6 7 root = constructFromPrePost(preorder, postorder) ``` In this example, `root` should be the root of the tree that matches the given traversals.","solution":"from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def constructFromPrePost(preorder: List[int], postorder: List[int]) -> TreeNode: if not preorder or not postorder: return None root = TreeNode(preorder[0]) if len(preorder) == 1: return root # Find the index of the left child in postorder left_child_val = preorder[1] left_size = postorder.index(left_child_val) + 1 root.left = constructFromPrePost(preorder[1:left_size + 1], postorder[:left_size]) root.right = constructFromPrePost(preorder[left_size + 1:], postorder[left_size:-1]) return root"},{"question":"You are given an array of positive integers representing the heights of nodes in a binary tree in level order traversal. The root node is at index 0. The array does not contain any duplicate values. Construct the binary tree from this array and return the root of the tree. Additionally, implement a function `find_depth(TreeNode root)` that returns the depth of the tree. The depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def construct_binary_tree(level_order): if not level_order: return None root = TreeNode(level_order[0]) queue = [root] i = 1 while i < len(level_order): current = queue.pop(0) if i < len(level_order): current.left = TreeNode(level_order[i]) queue.append(current.left) i += 1 if i < len(level_order): current.right = TreeNode(level_order[i]) queue.append(current.right) i += 1 return root def find_depth(root): if root is None: return 0 left_depth = find_depth(root.left) right_depth = find_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"Given a linked list, return _the node at which the cycle begins_. If there is no cycle, return `null`. To represent a cycle in the given linked list, use an integer `pos` which represents the position (0-indexed) in the linked list where the tail connects to. If `pos` is `-1`, then there is no cycle in the linked list. Note that `pos` is not passed as a parameter. Implement the function `ListNode* detectCycle(ListNode* head)` where `ListNode` is defined as: ```cpp struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the node at which the cycle begins in a linked list. If there is no cycle, returns None. if not head or not head.next: return None slow = head fast = head # Detect if there is a cycle using the slow and fast pointers. while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # Move one pointer to the head and leave the other at the meeting point # Each pointer advances one step at a time now slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Given a list of strings, you are to group the strings that are anagrams of each other. Return a list of lists, where each sublist contains strings that are anagrams of each other. Each string consists of lowercase alphabets only. The strings within each sublist and the sublists themselves can be in any order. Each string in the input list is unique. An anagram is a word formed by rearranging the letters of another word using all the original letters exactly once.","solution":"def group_anagrams(strings): Groups the input strings that are anagrams of each other. Parameters: strings (List[str]): The list of strings to be grouped. Returns: List[List[str]]: A list of lists where each sublist contains strings that are anagrams of each other. from collections import defaultdict anagram_dict = defaultdict(list) for string in strings: # Sort the string characters to form key sorted_string = \'\'.join(sorted(string)) # Add string to the corresponding anagram group anagram_dict[sorted_string].append(string) # Convert dictionary values to list of lists return list(anagram_dict.values())"},{"question":"You are given a non-empty string `s` containing only digits. Each digit can be mapped to a number of letters according to these mappings: 0 -> \\" \\" 1 -> \\"\\" 2 -> \\"abc\\" 3 -> \\"def\\" 4 -> \\"ghi\\" 5 -> \\"jkl\\" 6 -> \\"mno\\" 7 -> \\"pqrs\\" 8 -> \\"tuv\\" 9 -> \\"wxyz\\" Your task is to determine the total number of ways to decode the string. A valid decoding must map each digit to a corresponding letter (except for \'1\' which is ignored). Return the total number of distinct decoding combinations. For example, given the string \\"23\\", return 9 (\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\").","solution":"from functools import lru_cache def num_decodings(s): Returns the total number of distinct decoding combinations for a given string s of digits. if not s: return 0 digit_to_char = { \'0\': \' \', \'1\': \'\', \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } # Caching the calculated results @lru_cache(None) def backtrack(index): if index == len(s): return 1 if s[index] == \'1\': return backtrack(index + 1) total_ways = 0 for char in digit_to_char[s[index]]: total_ways += backtrack(index + 1) return total_ways return backtrack(0)"},{"question":"You are given a rectangular grid with `m` rows and `n` columns. Each cell in the grid can either be a `0` (representing water) or a `1` (representing land). A **connected component** of land cells is a group of land cells that are directly connected vertically or horizontally (but not diagonally) and are surrounded by water on all four sides or by the grid boundary. You may **flip** exactly one water cell (`0`) to a land cell (`1`). Return _the **maximum** size of a connected component of land cells that can be formed by flipping exactly one `0` to `1`_.","solution":"def max_connected_land_size(grid): This function computes the maximum size of a connected component of land cells that can be formed by flipping exactly one water cell (\'0\') to land cell (\'1\') in the grid. def bfs(grid, visited, x, y): Performs breadth-first search (BFS) to find the size of connected component. m, n = len(grid), len(grid[0]) queue = [(x, y)] visited.add((x, y)) size = 0 while queue: cx, cy = queue.pop(0) size += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == \'1\' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return size m, n = len(grid), len(grid[0]) max_size = 0 for i in range(m): for j in range(n): if grid[i][j] == \'0\': # Temporarily flip this \'0\' to \'1\' grid[i][j] = \'1\' visited = set() temp_max_size = 0 for x in range(m): for y in range(n): if grid[x][y] == \'1\' and (x, y) not in visited: temp_max_size = max(temp_max_size, bfs(grid, visited, x, y)) # Record max size found max_size = max(max_size, temp_max_size) # Flip back to \'0\' grid[i][j] = \'0\' return max_size"},{"question":"You are given an array `operations` where `operations[i]` is either \\"I x\\" or \\"D x\\". \\"I x\\" means inserting the integer `x` into a set and \\"D x\\" means deleting the integer `x` from the set if it exists. Additionally, you are given two arrays `queries1` and `queries2` each containing integers. For each integer `q1` in `queries1`, return the smallest integer in the set that is greater than `q1` or `-1` if no such integer exists. For each integer `q2` in `queries2`, return the largest integer in the set that is less than `q2` or `-1` if no such integer exists. You need to perform the operations in `operations` in the given order and then answer the queries. Return the results as an array where results for `queries1` are followed by results for `queries2`.","solution":"import bisect def process_operations_and_queries(operations, queries1, queries2): Perform a list of insertion and deletion operations on a set and respond to subsequent queries. :param operations: List of operations, where each operation is a string in the form of \\"I x\\" or \\"D x\\". :param queries1: List of integers for which we need to find the smallest integer in the set that is greater than each integer. :param queries2: List of integers for which we need to find the largest integer in the set that is less than each integer. :return: List of results for queries1 followed by results for queries2. sorted_set = [] # Process the operations for operation in operations: command, value = operation.split() value = int(value) if command == \\"I\\": if value not in sorted_set: bisect.insort(sorted_set, value) elif command == \\"D\\": if value in sorted_set: sorted_set.remove(value) results = [] # Handle queries1 for q1 in queries1: index = bisect.bisect_right(sorted_set, q1) if index < len(sorted_set): results.append(sorted_set[index]) else: results.append(-1) # Handle queries2 for q2 in queries2: index = bisect.bisect_left(sorted_set, q2) if index > 0: results.append(sorted_set[index - 1]) else: results.append(-1) return results"},{"question":"You are given a list of strings `words` and a string `target`. Your goal is to determine the number of strings in `words` that can be formed by removing some characters from `target` without changing the order of remaining characters. Write a function: ```python def numMatchingSubseq(words, target) -> int: pass ``` that takes a list of strings `words` and a string `target`, and returns the count of strings in `words` that are subsequences of `target`. Example: ```python words = [\\"abc\\", \\"ac\\", \\"xyz\\"] target = \\"abxcdy\\" output = numMatchingSubseq(words, target) # Output should be 2 ``` In this example, \\"abc\\" and \\"ac\\" are subsequences of \\"abxcdy\\", but \\"xyz\\" is not. Thus, the function should return `2`.","solution":"def is_subsequence(word, target): it = iter(target) return all(char in it for char in word) def numMatchingSubseq(words, target): Returns the count of words that are subsequences of target. return sum(1 for word in words if is_subsequence(word, target))"},{"question":"Given the `root` of a binary search tree, implement a function that returns the minimum difference between the values of any two different nodes in the tree. The difference between the values of two nodes `a` and `b` is defined as `|a - b|`. Construct your solution to efficiently calculate this minimum difference. Note: - The given tree will have at least two nodes. - The tree nodes must be traversed in such a way that the minimum difference can be determined in an optimal manner, considering the properties of a binary search tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_diff_in_bst(root: TreeNode) -> int: Returns the minimum difference between the values of any two different nodes in the tree. prev = None min_diff = float(\'inf\') def in_order_traverse(node): nonlocal prev, min_diff if node is None: return in_order_traverse(node.left) if prev is not None: min_diff = min(min_diff, node.val - prev) prev = node.val in_order_traverse(node.right) in_order_traverse(root) return min_diff"},{"question":"Write a function that takes in a string containing only English letters (both lowercase and uppercase) and returns the length of the longest substring without repeating characters. For example, given the input string `\\"abcabcbb\\"`, the output should be `3` because the longest substring without repeating characters is `\\"abc\\"`. Similarly, given the input string `\\"bbbbb\\"`, the output should be `1` because the longest substring without repeating characters is `\\"b\\"`. Implement the function `int lengthOfLongestSubstring(String s)` that returns the length of the longest substring without repeating characters.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): Input string containing only English letters (both lowercase and uppercase) Returns: int: Length of the longest substring without repeating characters char_map = {} start = max_length = 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an integer array `nums` representing the value of a row of houses, where each house has some value. You have to rob houses in such a way that no two adjacent houses are robbed. Return the maximum amount of money you can rob tonight without alerting the police. Each house can be represented as `nums[i]` and you must compute the maximum money from `0` to `n-1` given that you can\'t rob two consecutive houses. [Question] 4:","solution":"def rob(nums): Given an integer array nums representing the values of a row of houses, this function returns the maximum amount of money you can rob tonight without alerting the police. You cannot rob two adjacent houses. Parameters: nums (List[int]): A list of integers representing the values of the houses. Returns: int: The maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] n = len(nums) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], nums[i] + dp[i-2]) return dp[-1]"},{"question":"You are given an integer array `arr`, where each element represents a certain number of elements forming a group. For example, if `arr[i] = 3`, it indicates that there are 3 elements forming a sub-group at the `i-th` index. The task is to determine if it\'s possible to partition the entire array into sub-groups of equal sizes. Return `True` if it is possible to equally partition the array into sub-groups, otherwise return `False`. This means checking if you can divide the elements into groups such that the size of every group is identical. Example: - Input: `arr = [3, 3, 3, 3, 2, 2]` - Output: `True` (Explanation: The sub-groups can be [3, 3, 3] [3, 3, 3] or [2, 2] [2, 2] [3, 3, 3]) - Input: `arr = [3, 3, 3, 3, 2, 2, 1]` - Output: `False` (Explanation: It is impossible to partition the array into equal-sized sub-groups due to 1 extra element.)","solution":"def can_partition_into_equal_groups(arr): Determine if it\'s possible to partition the array into sub-groups of identical size. from collections import Counter from math import gcd from functools import reduce if len(arr) == 0: return True freq = Counter(arr) values = list(freq.values()) # Find the GCD of all frequencies common_gcd = reduce(gcd, values) return common_gcd >= 2"},{"question":"You are given a list of tasks, where each task is represented by an integer denoting the time required to complete that task. You are also given an integer `n` which represents the cooldown period between two identical tasks. That means if you have to perform the same task again, you must wait for `n` units of time after the previous execution of that task before you can perform it again. You need to find the minimum time required to complete all tasks in the list while adhering to the cooldown period requirement. Write a function to calculate this minimum time.","solution":"def min_time_to_complete_tasks(tasks, n): Returns the minimum time required to complete all tasks subject to a cooldown period. :param tasks: List[int], list of tasks where each task is represented by an integer. :param n: int, cooldown period between two identical tasks. :return: int, the minimum time required to complete all tasks. if not tasks: return 0 from collections import Counter # Count the occurrence of each task task_counts = Counter(tasks) # Find the maximum frequency of any task max_count = max(task_counts.values()) # Count how many tasks have the maximum frequency max_count_tasks = sum(1 for count in task_counts.values() if count == max_count) # Calculate part length part_length = (max_count - 1) * (n + 1) + max_count_tasks return max(part_length, len(tasks))"},{"question":"Given an m x n binary matrix grid, an island is a group of `1`\'s (representing land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. You need to solve two tasks: 1. Write a function `numIslands(grid: List[List[str]]) -> int` that returns the number of islands. 2. A further complex task: Given a list of positions where land is added (each position is a pair of integers representing the row and column), write a function `numIslands2(grid: List[List[str]], positions: List[List[int]]) -> List[int]` that returns the number of islands after each add operation. Each add operation turns the water at the given position (if it is water) into land. You should write an efficient algorithm to handle updates dynamically.","solution":"def numIslands(grid): Returns the number of islands in the binary matrix grid. if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == \'0\' or visited[i][j]: return visited[i][j] = True dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) count = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\' and not visited[i][j]: dfs(i, j) count += 1 return count def numIslands2(grid, positions): Returns the number of islands after each add operation if not grid or not positions: return 0 m, n = len(grid), len(grid[0]) parent = [-1] * (m * n) rank = [0] * (m * n) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def index(x, y): return x * n + y result = [] num_islands = 0 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] for x, y in positions: if grid[x][y] == \'1\': result.append(num_islands) continue grid[x][y] = \'1\' idx = index(x, y) parent[idx] = idx num_islands += 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == \'1\': if find(index(nx, ny)) != find(idx): union(idx, index(nx, ny)) num_islands -= 1 result.append(num_islands) return result"},{"question":"You are given a list of `n` houses, where each house is painted with one of `k` colors. The colors of the houses are represented by an `n x k` cost matrix, where `cost[i][j]` is the cost of painting the `i-th` house with the `j-th` color. You have to paint all the houses such that no two adjacent houses have the same color. Return the minimum cost to paint all the houses. If it is not possible to paint all the houses under the given conditions, return -1.","solution":"import sys def min_cost_to_paint_houses(cost): if not cost: return 0 n = len(cost) k = len(cost[0]) if k == 1 and n > 1: return -1 for i in range(1, n): for j in range(k): cost[i][j] += min(cost[i-1][l] for l in range(k) if l != j) return min(cost[-1]) # Example cost = [ [1, 5, 3], [2, 9, 4] ] print(min_cost_to_paint_houses(cost)) # should output 5"},{"question":"You are given a 2D grid of characters `grid` which represents a crossword puzzle, and a string `word` that you need to search in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Return _`true` if the word exists in the grid_, and _`false` otherwise_.","solution":"def exist(grid, word): rows, cols = len(grid), len(grid[0]) word_len = len(word) def backtrack(r, c, index): if index == word_len: return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False temp, grid[r][c] = grid[r][c], \'#\' found = (backtrack(r + 1, c, index + 1) or backtrack(r - 1, c, index + 1) or backtrack(r, c + 1, index + 1) or backtrack(r, c - 1, index + 1)) grid[r][c] = temp return found for i in range(rows): for j in range(cols): if backtrack(i, j, 0): return True return False"},{"question":"You are given two strings `s` and `t` both consisting of lowercase English letters. You want to make `s` a subsequence of `t` by deleting the minimum number of characters from `t`. A subsequence is a series of characters that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. Return the minimum number of deletions needed to make `s` a subsequence of `t`. If it is not possible, return `-1`.","solution":"def min_deletions_to_subsequence(s, t): Returns the minimum number of deletions needed from t to make s a subsequence of t. If it\'s not possible, returns -1. # Two pointers approach ptr_s, ptr_t = 0, 0 # Traverse through t and check if all characters of s can be found in sequence while ptr_t < len(t) and ptr_s < len(s): if s[ptr_s] == t[ptr_t]: ptr_s += 1 ptr_t += 1 # If we have traversed all characters of s, then it\'s a valid subsequence if ptr_s == len(s): # Minimum deletions required to make s subsequence of t return len(t) - len(s) else: # If ptr_s did not reach the end of s, s is not a valid subsequence of t return -1"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values. (i.e., from left to right, level by level). The function should be efficient in both time and space complexity, leveraging appropriate data structures to handle large and imbalanced trees effectively.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of a binary tree\'s nodes\' values. :param root: TreeNode, the root of the binary tree :return: List of lists, each inner list contains the values of the nodes at that level if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"Given a string `s` consisting of lowercase English letters, determine the minimum number of characters that need to be changed to make all the characters of `s` distinct. Return the _minimum number of changes_ required to achieve this.","solution":"def min_changes_to_distinct(s): Determines the minimum number of changes to make all characters in the string `s` distinct. Parameters: s (str): A string consisting of lowercase English alphabets. Returns: int: The minimum number of changes required to make all characters distinct. from collections import Counter char_count = Counter(s) changes_needed = 0 # Collect all characters that appear more than once dup_chars = [char for char, count in char_count.items() if count > 1] # Keep replacing duplicates until we have all unique characters for char in dup_chars: while char_count[char] > 1: # This will represent one change changes_needed += 1 char_count[char] -= 1 return changes_needed"},{"question":"Given a 2D grid of characters and a list of words, return _a list of all words that can be formed by sequentially adjacent characters of the grid, where \\"adjacent\\" characters are horizontally or vertically neighboring_. The same letter cell may not be used more than once in a word, and words can be found in any direction in the grid. _The order of words in the output list does not matter_.","solution":"def find_words(board, words): def dfs(board, word, i, j, k, visited): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return False if visited[i][j] or board[i][j] != word[k]: return False visited[i][j] = True if dfs(board, word, i + 1, j, k + 1, visited) or dfs(board, word, i - 1, j, k + 1, visited) or dfs(board, word, i, j + 1, k + 1, visited) or dfs(board, word, i, j - 1, k + 1, visited): return True visited[i][j] = False return False found_words = [] for word in words: found = False for i in range(len(board)): for j in range(len(board[0])): visited = [[False] * len(board[0]) for _ in range(len(board))] if dfs(board, word, i, j, 0, visited): found_words.append(word) found = True break if found: break return found_words"},{"question":"Given a binary tree, implement the function `averageOfLevels` that returns an array of the average value of the nodes on each level in the form of a list of doubles. The binary tree is represented using the `TreeNode` class, which is defined as follows: ``` class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` The function `averageOfLevels` should traverse the tree level by level and calculate the average value of nodes at each level. Example: Given the binary tree `[3,9,20,null,null,15,7]`, the function should return `[3.0, 14.5, 11.0]`.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def averageOfLevels(root): if not root: return [] result = [] queue = deque([root]) while queue: level_sum = 0 level_count = len(queue) for _ in range(level_count): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum / level_count) return result"},{"question":"Given a string `s` and an integer `k`, rearrange the string such that the same characters are at least `k` distance apart. If it is not possible to rearrange the string according to the above rule, return an empty string. Implement the function: ```python def rearrangeString(s: str, k: int) -> str: ``` The function should return the rearranged string if possible, otherwise return an empty string.","solution":"import heapq from collections import Counter, deque def rearrangeString(s: str, k: int) -> str: if k == 0: return s # Step 1: Count frequencies of each character freq = Counter(s) # Step 2: Create a max heap of characters based on their frequencies max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) result = [] queue = deque() # queue to keep track of waiting characters # Step 3: Construct the result while maintaining k distance rule while max_heap: count, char = heapq.heappop(max_heap) result.append(char) queue.append((count + 1, char)) # +1 because count is negative if len(queue) < k: continue # Step 4: Re-add the element back from the queue to the heap if there\'s still more of that character left ready_count, ready_char = queue.popleft() if ready_count < 0: heapq.heappush(max_heap, (ready_count, ready_char)) # If the rearranged string does not match the original length, return an empty string return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"You are given an array of non-negative integers `heights` where `heights[i]` represents the height of a person standing in a queue. A queue is called a **cool queue** if each person\'s height is not shorter than the height of the person standing directly behind them, except for at most one person. In other words, there can be at most one point in the queue where the height decreases. You are required to determine if the given queue can be rearranged to form a **cool queue**. Write a function that takes the list `heights` and returns `true` if it\'s possible to rearrange the array to form a **cool queue**, otherwise, return `false`.","solution":"def can_form_cool_queue(heights): Determines if it\'s possible to rearrange the array `heights` to form a cool queue. n = len(heights) if n <= 2: return True decrease_count = 0 for i in range(1, n): if heights[i-1] > heights[i]: decrease_count += 1 if decrease_count > 1: return False return True"},{"question":"Given a string `s` consisting of lowercase English letters and the `#` character which represents a backspace, return the final string after processing all the backspaces. Note that `#` will remove the character immediately before it, and treating an empty array as having no characters to remove if `#` is the first character in the string. Return the processed string.","solution":"def process_backspace_string(s: str) -> str: Processes a string with backspaces represented by \'#\' and returns the resulting string. stack = [] for char in s: if char == \'#\': if stack: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an integer array `flowers` where `flowers[i]` represents the blooming day of the `i-th` flower. You are also given two integers `k` and `m`. You want to find out if it is possible to pick `m` bouquets of flowers such that each bouquet consists of exactly `k` consecutive flowers. Determine if there exists a day when picking all the bouquets is possible. Return `true` if there is such a day, otherwise, return `false`.","solution":"def can_make_bouquets(flowers, k, m): Determine if it is possible to make m bouquets each consisting of k consecutive flowers. def can_bloom(day): count = 0 # to keep track of consecutive blooming flowers bouquets = 0 # to keep track of bouquets made for bloom_day in flowers: if bloom_day <= day: count += 1 if count == k: bouquets += 1 count = 0 else: count = 0 if bouquets >= m: return True return False low, high = min(flowers), max(flowers) while low < high: mid = (low + high) // 2 if can_bloom(mid): high = mid else: low = mid + 1 return can_bloom(low)"},{"question":"You are given a **0-indexed** integer array `arr` of length `n`. A subsequence of `arr` is a sequence formed by removing some (possibly zero) elements from `arr` without changing the order of the remaining elements. A non-empty subsequence is called **unimodal** if there is an element in the subsequence such that all elements to the left of it are in strictly increasing order and all elements to the right of it are in strictly decreasing order. Find and return _the length of the longest **unimodal** subsequence of_ `arr`.","solution":"def longest_unimodal_subsequence(arr): Finds the length of the longest unimodal subsequence of the input array. n = len(arr) if n == 0: return 0 # Arrays to store the length of the longest increasing subsequence # ending at index i and starting from index i. inc = [1] * n dec = [1] * n # Fill inc[] such that inc[i] stores the length of the longest increasing # subsequence ending at index i for i in range(1, n): for j in range(i): if arr[i] > arr[j] and inc[i] < inc[j] + 1: inc[i] = inc[j] + 1 # Fill dec[] such that dec[i] stores the length of the longest decreasing # subsequence starting from index i for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if arr[i] > arr[j] and dec[i] < dec[j] + 1: dec[i] = dec[j] + 1 # Find the maximum value of inc[i] + dec[i] - 1 (we subtract 1 because arr[i] # is counted twice) max_length = 0 for i in range(n): if inc[i] > 1 and dec[i] > 1: # both increasing and decreasing needed max_length = max(max_length, inc[i] + dec[i] - 1) return max_length"},{"question":"You are given a string `word`, which consists of lowercase English letters. Your task is to find the longest substring of `word` such that the letters can be rearranged to form a palindrome. Return _the length of this longest palindromic substring_. If there are multiple substrings of the same maximum length, return the length of any one of them. A palindrome is a word that reads the same forward and backward, and individual characters can each be reused any number of times.","solution":"from collections import Counter def longest_palindrome_substring_length(word): Returns the length of the longest substring of `word` that can be rearranged to form a palindrome. count = Counter(word) length = 0 odd_found = False for char_count in count.values(): if char_count % 2 == 0: length += char_count else: length += char_count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"Given an integer array `nums` and an integer `k`, rotate the array to the right by `k` steps, where `k` is non-negative. This means that the last `k` elements of the array will be moved to the beginning. For example, given the array `[1,2,3,4,5,6,7]` and `k = 3`, the result should be `[5,6,7,1,2,3,4]`. The rotation should be done in-place with O(1) extra space complexity. Return the array after it has been rotated.","solution":"def rotate(nums, k): Rotates the array to the right by k steps. n = len(nums) k = k % n # In case k is greater than array length nums[:] = nums[-k:] + nums[:-k] # Re-arrange elements in-place return nums"},{"question":"**[Question 4]:** You are given an `n x n` matrix of integers `matrix` and an integer `target`. Your task is to find out whether `target` exists in the matrix. The matrix has the following properties: - Each row is sorted in ascending order. - Each column is sorted in ascending order. Return `true` if `target` is present in the matrix, otherwise, return `false`. Note: You are expected to implement an efficient solution.","solution":"def searchMatrix(matrix, target): Returns true if target is present in the matrix, otherwise false. The matrix has the following properties: - Each row is sorted in ascending order. - Each column is sorted in ascending order. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = cols - 1 # Iterate until we are out of bounds while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"You are given an array `arr` of integers. Determine the smallest positive integer `m` such that `arr` contains a pair of integers `(x, y)` whose sum is equal to `m`. If no such pair exists, return `-1`. Note: A pair `(x, y)` is considered the same as `(y, x)` and should not be counted twice.","solution":"def smallest_positive_sum(arr): Returns the smallest positive integer m such that arr contains a pair of integers (x, y) whose sum is equal to m. If no such pair exists, returns -1. seen = set() smallest_sum = float(\'inf\') for num in arr: for s in seen: if (num + s) > 0: smallest_sum = min(smallest_sum, num + s) seen.add(num) return smallest_sum if smallest_sum != float(\'inf\') else -1"},{"question":"Given a 2D grid of integers where each value represents the height of a cell, write a function `pacificAtlantic` that returns a list of coordinates, where water can flow to both the Pacific and Atlantic oceans. The top and left edges of the grid represent the Pacific Ocean, and the bottom and right edges represent the Atlantic Ocean. Water can only flow from a cell to another cell with height equal or less than the current cell\'s height. ```python def pacificAtlantic(heights: List[List[int]]) -> List[List[int]]: # Your code here ```","solution":"from typing import List def pacificAtlantic(heights: List[List[int]]) -> List[List[int]]: if not heights or not heights[0]: return [] rows, cols = len(heights), len(heights[0]) pacific_reachable = [[False for _ in range(cols)] for _ in range(rows)] atlantic_reachable = [[False for _ in range(cols)] for _ in range(rows)] def dfs(row, col, reachable): reachable[row][col] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_row, new_col = row + dx, col + dy if 0 <= new_row < rows and 0 <= new_col < cols and not reachable[new_row][new_col] and heights[new_row][new_col] >= heights[row][col]: dfs(new_row, new_col, reachable) for i in range(rows): dfs(i, 0, pacific_reachable) dfs(i, cols - 1, atlantic_reachable) for j in range(cols): dfs(0, j, pacific_reachable) dfs(rows - 1, j, atlantic_reachable) result = [] for i in range(rows): for j in range(cols): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"Given an integer array `arr` and an integer `x`, your task is to split the array into two subarrays `arr1` and `arr2`, such that the sum of the elements in `arr1` minus the sum of the elements in `arr2` is equal to `x`. Return _the two subarrays `arr1` and `arr2` if such a split is possible_, otherwise return `\\"Not Possible\\"`. If there are multiple solutions, any valid solution will be accepted. Note that the elements in `arr1` or `arr2` should retain their original order. Implement the `ArraySplitter` class: * `ArraySplitter(int[] arr, int x)` Initializes the object with the integer array `arr` and the integer `x`. * `List<int[]> splitArray()` Returns a list of two integer arrays `arr1` and `arr2` that satisfy the condition or a string `\\"Not Possible\\"` if no such split is possible.","solution":"from typing import List, Union class ArraySplitter: def __init__(self, arr: List[int], x: int): self.arr = arr self.x = x def splitArray(self) -> Union[List[List[int]], str]: total_sum = sum(self.arr) n = len(self.arr) # The sum of arr1 should be (total_sum + x)/2 if (total_sum + self.x) % 2 != 0: return \\"Not Possible\\" target_sum = (total_sum + self.x) // 2 dp = [[False] * (target_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): current_value = self.arr[i - 1] for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= current_value: dp[i][j] = dp[i][j] or dp[i - 1][j - current_value] if not dp[n][target_sum]: return \\"Not Possible\\" arr1 = [] arr2 = [] remaining_sum = target_sum for i in range(n, 0, -1): if not dp[i - 1][remaining_sum]: arr1.append(self.arr[i - 1]) remaining_sum -= self.arr[i - 1] else: arr2.append(self.arr[i - 1]) arr1.reverse() arr2.reverse() return [arr1, arr2]"},{"question":"You are given a string `s` that represents a sequence of characters from an alphabet. The alphabet has `k` unique characters, each character having unique frequencies of occurrence. A **character frequency** of a subsequence is defined as the count of characters in that subsequence. A subsequence is derived by deleting zero or more characters from the string `s` without disturbing the relative order of remaining characters. Given a string `s` and an integer `f`, return the length of the shortest subsequence of `s` such that the **character frequency** of every character in that subsequence is exactly `f`. If no such subsequence exists, return `-1`. For example, given `s = \\"aabbcc\\"` and `f = 2`, one possible shortest subsequence is \\"aabb\\" which has two \'a\'s, two \'b\'s, and two \'c\'s. The length of this subsequence is 4.","solution":"def shortest_subsequence_length(s, f): from collections import Counter char_count = Counter(s) for char in char_count: if char_count[char] < f: return -1 subsequence_length = len(char_count) * f return subsequence_length"},{"question":"Given a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom. The tree is represented by a root node. Note: - The input is given as the root of the binary tree. - Each node contains a single integer value. - A binary tree node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the values of the nodes you can see from the right side of the binary tree. if not root: return [] right_view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # If it\'s the rightmost element if i == level_length - 1: right_view.append(node.val) # Add child nodes in the queue if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"You are given an array of `n` integers where each element represents the height of a building. The goal is to remove a set of buildings such that the remaining buildings form a non-decreasing sequence in terms of heights. You are allowed to remove any number of buildings (including none). Return _the minimum number of buildings that need to be removed to achieve this goal_.","solution":"def min_removals_to_non_decreasing(heights): Returns the minimum number of buildings that need to be removed to achieve a non-decreasing sequence. :param heights: List[int] : List of building heights :return: int : Minimum number of removals if not heights: return 0 n = len(heights) # Find the longest increasing subsequence (LIS) lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The minimum number of removals would be total buildings - length of LIS. return n - max(lis)"},{"question":"You are given an integer array `heights` representing the heights of buildings in a city from left to right. The width of each building is 1. You are required to select two buildings such that the container formed between the two buildings holds the most water. The water is collected according to the shorter of the two buildings. Return the maximum amount of water a container can store. Write a function `maxWater` that takes an integer array `heights` as input and returns the maximum water container capacity.","solution":"def maxWater(heights): Returns the maximum amount of water a container can store. max_water = 0 left, right = 0, len(heights) - 1 while left < right: # Calculate the area h = min(heights[left], heights[right]) w = right - left max_water = max(max_water, h * w) # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given an integer array `arr` and two integers `k1` and `k2`. You need to find the sum of all elements between the k1-th smallest element and the k2-th smallest element in the array (inclusive). The k1-th and k2-th smallest elements are the elements that would be at the k1-th and k2-th positions if the array were sorted. Note that `k1` and `k2` are 1-based indices. If `k1` is greater than `k2`, swap their values before proceeding with the calculation. Return the sum of these elements.","solution":"def sum_between_kth_elements(arr, k1, k2): Returns the sum of all elements between the k1-th smallest element and the k2-th smallest element (inclusive) in the array. Parameters: arr (List[int]): The array of integers. k1 (int): The 1-based index of the first k-th element. k2 (int): The 1-based index of the second k-th element. Returns: int: The sum of elements between k1-th smallest element and k2-th smallest element (inclusive). # Ensure k1 is less than or equal to k2 if k1 > k2: k1, k2 = k2, k1 # Sort the array to determine the k-th smallest elements sorted_arr = sorted(arr) # Sum the elements between the k1-th and k2-th smallest (inclusive) sum_elements = sum(sorted_arr[k1-1:k2]) return sum_elements"},{"question":"You are given a string, `s`, consisting of only lowercase letters, and an integer array `costs` where `costs[i]` represents the cost of inserting the character `s[i]` into a new string. Your task is to form a new string by reordering the characters of `s` such that no two adjacent characters are the same. If it is possible to form such a string, return the minimum total cost of forming this string. Otherwise, return `-1`.","solution":"from heapq import * from collections import Counter def min_cost_to_avoid_adjacent(l: str, costs: list) -> int: Returns the minimum total cost of forming a string such that no two adjacent characters are the same. If it\'s not possible, returns -1. # Edge case: empty string if not l: return 0 n = len(l) if n == 1: return costs[0] # Build frequency map freq_map = Counter(l) # If the highest frequency of any character is more than half the length of the list plus 1, return -1 max_freq = max(freq_map.values()) if max_freq > (n + 1) // 2: return -1 # Create a max-heap with character and its frequency max_heap = [(-freq, char) for char, freq in freq_map.items()] heapify(max_heap) total_cost = 0 prev_char, prev_freq = None, 0 i = 0 while max_heap or prev_freq: if max_heap: freq, char = heappop(max_heap) total_cost += costs[i] i += 1 freq = -freq if prev_freq: heappush(max_heap, (-prev_freq, prev_char)) freq -= 1 prev_char, prev_freq = char, freq else: if prev_freq: return -1 return total_cost"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to output the smallest range that includes at least one number from each of the `k` subarrays formed by partitioning `arr` into `k` contiguous segments. The range is defined by the difference between the maximum and minimum numbers in the selected subarrays. If multiple ranges have the same size, return the range with the smallest starting number.","solution":"def smallest_range_partition(arr, k): Returns the smallest range that includes at least one number from each of the k subarrays formed by partitioning arr into k contiguous segments. if k > len(arr): return [] # Helper function to generate all possible partitions def generate_partitions(arr, k): if k == 1: return [[arr]] partitions = [] for i in range(1, len(arr) - k + 2): for sub_partition in generate_partitions(arr[i:], k - 1): partitions.append([arr[:i]] + sub_partition) return partitions all_partitions = generate_partitions(arr, k) smallest_range = float(\'inf\') best_range = (0, 0) # This will store the smallest range found for partition in all_partitions: # Find the min and max values in this partition min_val = float(\'inf\') max_val = float(\'-inf\') for segment in partition: segment_min = min(segment) segment_max = max(segment) if segment_min < min_val: min_val = segment_min if segment_max > max_val: max_val = segment_max current_range = max_val - min_val if current_range < smallest_range: smallest_range = current_range best_range = (min_val, max_val) elif current_range == smallest_range and min_val < best_range[0]: best_range = (min_val, max_val) return best_range"},{"question":"You are given an array `nums` consisting of positive integers. You are allowed to pick any two adjacent elements in the array and replace them with their greatest common divisor (GCD). You must continue this process until only one element remains. Return _the minimum possible value of the final element_ after performing any number of such operations.","solution":"from math import gcd from functools import reduce def minimum_final_element(nums): Returns the minimum possible value of the final element after any number of operations of replacing two adjacent elements in nums with their GCD. return reduce(gcd, nums)"},{"question":"You are given an array of integers and an integer target. Your task is to implement a class that finds all unique pairs in the array that sum up to the target. Implement the TwoSumPairs class: * `TwoSumPairs(int[] nums, int target)` Initializes the object with an integer array `nums` and the integer `target`. * `List<int[]> findPairs()` Returns a list of all unique pairs `[a, b]` such that `a + b = target`, where `a` and `b` are elements from the array. Each pair should be sorted in ascending order, and the overall list should be sorted lexicographically. **Note:** * No duplicate pairs should be included in the result.","solution":"class TwoSumPairs: def __init__(self, nums, target): self.nums = nums self.target = target def findPairs(self): seen = set() pairs = set() for num in self.nums: complement = self.target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(list(pairs))"},{"question":"Given an array of integers `arr`, you need to find the maximum sum of any contiguous subarray of the array. Return _the maximum sum possible_.","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray of the given array. :param arr: List of integers :return: Integer representing the maximum subarray sum if not arr: return 0 max_ending_here = arr[0] max_so_far = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"You are given a list of integers `arr`, and an integer `target`. Write a function `twoSum` that returns the indices of the two numbers such that they add up to the `target`. Each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example: ```plaintext Input: arr = [2, 7, 11, 15], target = 9 Output: [0, 1] Explanation: Because arr[0] + arr[1] == 9, we return [0, 1]. ```","solution":"def twoSum(arr, target): Returns the indices of the two numbers such that they add up to the target. Parameters: arr (list): List of integers. target (int): Target sum. Returns: list: Indices of the two numbers. num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"Given an integer array `nums`, return the _length of the longest subarray_ that contains only _unique_ elements.","solution":"def length_of_longest_unique_subarray(nums): Returns the length of the longest subarray that contains only unique elements. seen = set() left = 0 max_length = 0 for right in range(len(nums)): while nums[right] in seen: seen.remove(nums[left]) left += 1 seen.add(nums[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"You have three strings `s1`, `s2`, and `s3`. Your task is to determine if `s3` can be formed by an **interleaving** of `s1` and `s2`. The strings `s1` and `s2` can be interleaved to form `s3` if and only if the length of `s3` is equal to the sum of the lengths of `s1` and `s2`, and `s3` can be constructed by taking characters alternately from `s1` and `s2` while maintaining the relative order of characters within each string. Return `true` if `s3` can be formed by interleaving `s1` and `s2`, otherwise return `false`.","solution":"def is_interleave(s1, s2, s3): Check if s3 can be formed by interleaving s1 and s2. :param s1: First string :param s2: Second string :param s3: Third string to be checked :return: Boolean indicating whether s3 is an interleaving of s1 and s2 if len(s1) + len(s2) != len(s3): return False dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)] dp[0][0] = True for i in range(1, len(s1) + 1): dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] for j in range(1, len(s2) + 1): dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] for i in range(1, len(s1) + 1): for j in range(1, len(s2) + 1): dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1]) return dp[-1][-1]"},{"question":"You are given an integer array `nums` and an integer `target`. Find a contiguous subarray from `nums` whose sum is equal to `target`. If there are multiple such subarrays, return the one with the smallest starting index. If no such subarray exists, return an empty array. A subarray is a contiguous part of an array.","solution":"def find_subarray_with_target_sum(nums, target): Returns the first contiguous subarray summing to the target or an empty array if not found. current_sum = 0 prefix_sum_index = {0: -1} for i, num in enumerate(nums): current_sum += num if current_sum - target in prefix_sum_index: start_index = prefix_sum_index[current_sum - target] + 1 return nums[start_index:i+1] prefix_sum_index[current_sum] = i return []"},{"question":"A frog is at the bottom of a well that is `n` meters deep. The frog wants to escape the well by jumping out. It can jump between 1 to `k` meters upwards, but every time it attempts a jump, it slides back down 1 meter because the walls of the well are slippery. You are given two integer inputs `n` and `k` representing the depth of the well and the maximum distance the frog can jump respectively. Write a function that returns the minimum number of jumps the frog needs to escape the well.","solution":"def min_jumps_to_escape(n, k): Calculate the minimum number of jumps needed for a frog to escape a well. :param n: int, depth of the well :param k: int, maximum distance the frog can jump upwards :return: int, minimum number of jumps needed to escape # If the well is 0 meters deep, no jumps are needed if n == 0: return 0 # The effective jump the frog makes after slipping back 1 meter effective_jump = k - 1 # Initialize jump count jumps = 0 while n > 0: # If frog can jump more than or equal to the current depth, it escapes in this jump if n <= k: jumps += 1 break else: # Frog makes an effective jump n -= effective_jump jumps += 1 return jumps"},{"question":"You are given an array of integers `arr` and an integer `target`. Determine if there exist **two distinct elements** in the array such that their sum is equal to `target`. If such a pair exists, return `true`; otherwise, return `false`. You can assume that each input would have exactly one solution, and you may not use the same element twice.","solution":"def exists_pair_with_sum(arr, target): Determines if there exist two distinct elements in the array such that their sum is equal to target. Parameters: arr (list of int): The array of integers. target (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"You are given two integer arrays `arr1` and `arr2` both of length `n`. An operation consists of selecting one element from any of the arrays and replacing it with any positive integer. You need to perform exactly `k` operations in such a way that the sum of the absolute differences between the corresponding elements of `arr1` and `arr2` is minimized. Return the minimum possible sum of the absolute differences between the corresponding elements of `arr1` and `arr2` after performing `k` operations.","solution":"def min_abs_sum_diff(arr1, arr2, k): Returns the minimum possible sum of the absolute differences between the corresponding elements of arr1 and arr2 after performing exactly k operations. n = len(arr1) differences = [] for i in range(n): differences.append(abs(arr1[i] - arr2[i])) differences.sort(reverse=True) for i in range(k): if differences[i] > 0: differences[i] = 0 return sum(differences)"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` integer values. You are allowed to reverse one **subarray** of `nums` exactly once. A subarray is a contiguous part of the array. Your task is to determine if the array can be sorted in **non-decreasing order** by performing exactly one such reverse operation. Return `true` if it is possible; otherwise, return `false`.","solution":"def canBeSortedByReversingOneSubarray(nums): n = len(nums) if n <= 1: return True sorted_nums = sorted(nums) # Find the first and last place where original array differs from sorted array i = 0 while i < n and nums[i] == sorted_nums[i]: i += 1 j = n - 1 while j >= 0 and nums[j] == sorted_nums[j]: j -= 1 if i >= j: # The array is already sorted. return True # Reverse the subarray nums[i:j+1] subarray = nums[i:j+1] subarray.reverse() return nums[:i] + subarray + nums[j+1:] == sorted_nums"},{"question":"Given an **n-ary tree**, find the **diameter** of the tree. The diameter of an n-ary tree is the length of the longest path between any two nodes in the tree. The length of a path is the number of edges in the path. You are given a root node of an n-ary tree. Implement a function to compute the diameter. **Note**: An n-ary tree is a tree in which each node has no more than n children.","solution":"class Node: def __init__(self, value): self.value = value self.children = [] def diameter_of_n_ary_tree(root): Given the root of an n-ary tree, find the diameter of the tree. The diameter is the longest path between any two nodes in the tree. def helper(node): if not node: return 0, 0 # diameter, height max_height1 = 0 max_height2 = 0 max_diameter = 0 for child in node.children: child_diameter, child_height = helper(child) max_diameter = max(max_diameter, child_diameter) if child_height > max_height1: max_height2 = max_height1 max_height1 = child_height elif child_height > max_height2: max_height2 = child_height current_height = max_height1 + 1 current_diameter = max(max_diameter, max_height1 + max_height2) return current_diameter, current_height diameter, _ = helper(root) return diameter"},{"question":"You are given an integer array `nums` of length `n`. You need to perform a series of operations to maximize the sum of the array. In each operation, you can choose any two adjacent elements in the array, say `a` and `b`, and replace `a` with `a + b` and `b` with `a - b`. You can perform this operation any number of times. Return the maximum possible sum of the array you can achieve after performing the above operations. **Example:** `nums = [1, 2, 3]` After the first operation on elements `1` and `2`, the array becomes `[3, -1, 3]`. After the second operation on elements `3` and `-1`, the array becomes `[3, 2, 3]`. After the final operation on elements `3` and `2`, the array becomes `[5, 1, 3]`. Hence, the maximum possible sum of the array is `5 + 1 + 3 = 9`. The test cases are generated so that the answer fits in a **32-bit** signed integer.","solution":"def maximize_sum(nums): Returns the maximum possible sum of the array after performing the given operations. :param nums: List[int] - input integer array. :return: int - maximum possible sum of the array. return abs(sum(nums))"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, find the **kth** smallest element for multiple queries. Each query is represented as an array `queries[i] = [li, ri, ki]`, where `li` and `ri` denote the subarray `nums[li...ri]` (_inclusive_) and `ki` denotes the `ki`th smallest element in this subarray. Return _an array_ `answer` _where_ `answer.length == queries.length` _and_ `answer[i]` _is the answer to the_ `ith` _query_.","solution":"def kth_smallest(nums, queries): Find the kth smallest element in the specified subarrays for multiple queries. :param nums: List[int] - A list of integers. :param queries: List[List[int]] - A list of queries where each query is a list [li, ri, ki]. :return: List[int] - A list of answers for each query. results = [] for li, ri, ki in queries: subarray = nums[li:ri+1] subarray.sort() results.append(subarray[ki-1]) return results"},{"question":"Given a string `s`, develop an algorithm to determine the length of the smallest substring that contains all the distinct characters of the given string. If the string is empty, return 0.","solution":"def length_of_smallest_substring_with_all_distinct_chars(s): Determines the length of the smallest substring that contains all the distinct characters of the given string. if not s: return 0 distinct_chars = set(s) required_char_count = len(distinct_chars) n = len(s) left, right = 0, 0 char_count = {} min_length = float(\'inf\') formed = 0 while right < n: char = s[right] char_count[char] = char_count.get(char, 0) + 1 if char_count[char] == 1: formed += 1 while formed == required_char_count: min_length = min(min_length, right - left + 1) char = s[left] char_count[char] -= 1 if char_count[char] == 0: formed -= 1 left += 1 right += 1 return min_length"},{"question":"You are given a `m x n` integer grid `grid` representing a map where `1` represents land and `0` represents water. An island is a maximal vertically or horizontally connected group of `1`s. Given the grid, return the number of distinct islands. Two islands are considered distinct if and only if one island cannot be translated to equal the other one (one cannot be fully represented by shifting the other one horizontally and/or vertically). To solve the problem, implement the following function: * `int countDistinctIslands(int[][] grid)`: This function should return the number of distinct islands in the grid.","solution":"def countDistinctIslands(grid): def dfs(x, y, origin_x, origin_y): Perform DFS to explore the island and record the relative position. if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0): return grid[x][y] = 0 # Mark as visited shape.append((x - origin_x, y - origin_y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, origin_x, origin_y) distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, i, j) distinct_islands.add(tuple(shape)) return len(distinct_islands)"},{"question":"You are given an unsorted array of integers `nums` and an integer `target`. Implement a function `findPair` that returns `true` if there are two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] = target`, and `false` otherwise. Your solution should aim for an efficient approach in terms of time complexity.","solution":"def findPair(nums, target): Returns true if there are two distinct indices i and j in the array such that nums[i] + nums[j] = target. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"You are given a list of integers representing the costs of different items in a store and an integer `budget` representing the amount of money you have. You want to determine the maximum number of items you can purchase without exceeding the `budget`. Each item can only be bought once. Write a function that returns this maximum number. If no items can be bought, return 0. The function should have the following signature: `def maxItems(costs: List[int], budget: int) -> int:`","solution":"from typing import List def maxItems(costs: List[int], budget: int) -> int: Returns the maximum number of items that can be purchased without exceeding the budget. costs.sort() max_items = 0 current_budget = budget for cost in costs: if cost <= current_budget: max_items += 1 current_budget -= cost else: break return max_items"},{"question":"You are given a string `str` consisting of lowercase English letters. A substring is called a \\"good\\" substring if all the characters of the substring are distinct. Your task is to find the length of the longest \\"good\\" substring in the string `str`. Return _an integer representing the length of the longest \\"good\\" substring._ A **substring** is a contiguous non-empty sequence of characters within a string.","solution":"def length_of_longest_good_substring(s: str) -> int: Finds the length of the longest \'good\' substring in a given string `s`. A substring is called \'good\' if all its characters are distinct. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest \'good\' substring. n = len(s) max_length = 0 char_index_map = {} start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a list of `n` integers where each integer appears exactly twice, except for one integer which appears exactly once. Write a function to find the integer that appears only once. Your solution should have a linear runtime complexity and use only constant extra space.","solution":"def find_single_number(nums): Given a list of integers where each integer appears exactly twice except for one integer which appears exactly once, return the integer that appears exactly once. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"You are given an array of integers `arr` and an integer `k`. The task is to find the length of the smallest subarray that contains at least `k` distinct integers. If no such subarray exists, return -1. The implementation should be efficient, making use of appropriate data structures for optimal performance.","solution":"def smallest_subarray_with_k_distinct(arr, k): from collections import defaultdict n = len(arr) if k > n: return -1 left = 0 min_len = n + 1 freq_map = defaultdict(int) distinct_count = 0 for right in range(n): # Expand the window by adding arr[right] if freq_map[arr[right]] == 0: distinct_count += 1 freq_map[arr[right]] += 1 # Shrink the window from the left until it contains less than k distinct integers while distinct_count >= k: min_len = min(min_len, right - left + 1) freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: distinct_count -= 1 left += 1 return min_len if min_len <= n else -1"},{"question":"Write a function that takes in a list of integers and returns the length of the longest contiguous subarray with an equal number of positive and negative numbers. A subarray is a contiguous part of an array that includes at least one element.","solution":"def longest_equal_positive_negative(nums): Returns the length of the longest contiguous subarray with an equal number of positive and negative numbers. n = len(nums) max_len = 0 sum_map = {} sum_val = 0 for i in range(n): # Convert the array such that -1 is for negative numbers and +1 for positive numbers if nums[i] > 0: sum_val += 1 else: sum_val -= 1 if sum_val == 0: max_len = i + 1 if sum_val in sum_map: max_len = max(max_len, i - sum_map[sum_val]) else: sum_map[sum_val] = i return max_len"},{"question":"Given a string `s`, and an array `queries` where each query is a pair of indices `[ai, bi]`, return _a list of the lengths of the longest palindromic substrings for each of the specified substrings `s[ai:bi+1]`_.","solution":"def longest_palindromic_substring_length(s, queries): Returns the lengths of the longest palindromic substrings for specified substrings. :param s: A string where we need to find palindromic substrings. :param queries: A list of pairs (ai, bi) specifying the substring s[ai:bi+1] :return: A list of lengths of longest palindromic substrings for each query. def longest_palindrome_length(subs): n = len(subs) if n == 0: return 0 # Table to store lengths of longest palindromes dp = [[0] * n for _ in range(n)] max_length = 1 # Each individual character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Check for sub-strings of length 2 for i in range(n-1): if subs[i] == subs[i+1]: dp[i][i+1] = 1 max_length = 2 # Check for lengths greater than 2 for k in range(3, n + 1): # k is the length of substring for i in range(n - k + 1): j = i + k - 1 if subs[i] == subs[j] and dp[i + 1][j - 1] > 0: dp[i][j] = 1 max_length = k return max_length result = [] for ai, bi in queries: substring = s[ai:bi+1] result.append(longest_palindrome_length(substring)) return result"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a city. A building\'s aesthetic value for a particular observer depends on its relative visibility. A building is considered visible if there are no taller buildings before it in the list of heights. Calculate the total number of visible buildings for an observer standing at the beginning of the list. Return _the **total** number of visible buildings._","solution":"def count_visible_buildings(heights): Returns the total number of visible buildings from the beginning of the list. visible_count = 0 max_height = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"Write a function that takes a string `s` consisting of digits and returns a string representing the largest even number that can be formed from the digits of `s`. If no even number can be formed, return an empty string.","solution":"def largest_even_number(s): Returns the largest even number that can be formed from the digits of the input string `s`. If no even number can be formed, returns an empty string. # Separate the digits of s digits = list(s) # Sort the digits in descending order to form the largest possible number digits.sort(reverse=True) # Find an even digit to place at the end for i in range(len(digits)-1, -1, -1): if int(digits[i]) % 2 == 0: # Place the found even digit at the end and break the loop digits.append(digits.pop(i)) return \'\'.join(digits) # If no even digit is found, return empty string return \\"\\""},{"question":"You are given a grid of size `m x n` where each cell can either be `0` (empty) or `1` (blocked). You are also given an integer `k` which represents the maximum number of `1`s you can convert to `0`. You need to decide whether there is a path from the top-left corner of the grid (cell (0,0)) to the bottom-right corner of the grid (cell (m-1, n-1)) given that you can convert up to `k` blocked cells to empty cells. Return `true` if there is a path from the top-left to the bottom-right corner, otherwise return `false`. Implement the function `boolean isPathPossible(int[][] grid, int k)` that determines if the path is possible given the grid and k.","solution":"def isPathPossible(grid, k): Determines if there is a path from the top-left corner to the bottom-right corner of the grid given that up to k number of `1`s can be converted to `0`s. :param grid: List[List[int]] - A 2D list representing the grid. :param k: int - The maximum number of `1`s that can be converted to `0`s. :return: bool - True if the path is possible, otherwise False. from collections import deque m, n = len(grid), len(grid[0]) # Directions for moving right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS queue initialization queue = deque([(0, 0, 0)]) # (row, col, number of converted 1s) visited = set((0, 0, 0)) while queue: x, y, conversions = queue.popleft() # If we reach the bottom-right corner if x == m - 1 and y == n - 1: return True # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy # Ensure the cell is within the grid if 0 <= nx < m and 0 <= ny < n: next_conversions = conversions + grid[nx][ny] if next_conversions <= k and (nx, ny, next_conversions) not in visited: visited.add((nx, ny, next_conversions)) queue.append((nx, ny, next_conversions)) return False"},{"question":"Given a string `s`, return _the length of the longest substring of `s` that can be rearranged to form a palindrome_. The solution should consider only contiguous substrings and return `0` if no such substring exists.","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest contiguous substring of s that can be rearranged to form a palindrome. def can_form_palindrome(sub): counts = {} for char in sub: counts[char] = counts.get(char, 0) + 1 odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 n = len(s) max_length = 0 for start in range(n): for end in range(start, n): substring = s[start:end + 1] if can_form_palindrome(substring): max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an integer array `arr` of size `n`, where `n` is a positive odd number. Your task is to find the median of the array after performing the following operation exactly once: Choose any one element of the array and replace it with any integer. The median of an array is the middle element after sorting the array in ascending order. Return _the minimum possible median that can be obtained after the operation._","solution":"def minimum_possible_median(arr): Returns the minimum possible median of the array after performing one operation: replacing any one element of the array with any integer. n = len(arr) arr.sort() return arr[n // 2]"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a cityscape, where the width of each building is 1 unit. It starts raining and water collects between the buildings. Find the total amount of water that can be trapped between the buildings after raining. The water trapped at each building can be considered as the minimum of the maximum heights to its left and right, minus its own height. Return the total trapped water.","solution":"def trap(height): Calculate the total amount of water that can be trapped between the buildings. :param height: List[int] - List of heights of the buildings. :return: int - Total trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a list of integers `nums` representing the number of transactions completed by each user on an e-commerce website. A user is considered **active** if they have completed at least `k` transactions. Write a function that returns the total number of **active** users. The function should take in the list `nums` and an integer `k` and output the count of users who meet the criteria.","solution":"def count_active_users(nums, k): Returns the count of users who are active. A user is considered active if they have completed at least k transactions. Parameters: nums (list): List of integers where each integer represents the number of transactions by a user k (int): The threshold number of transactions to be considered active Returns: int: The count of active users return sum(1 for num in nums if num >= k)"},{"question":"Given an integer array `stones` of length `n`, where `stones[i]` represents the weight of the `ith` stone, your goal is to combine the stones until only one stone remains. In each operation, you can select any two stones and smash them together. Suppose the stones have weights `x` and `y` with `x <= y`. The result of this smash will be: - If `x == y`, both stones are destroyed. - If `x != y`, the stone with weight `x` is destroyed, and the stone with weight `y` now has weight `y - x`. Return the smallest possible weight of the remaining stone. If there are no stones left, return `0`.","solution":"import heapq def lastStoneWeight(stones): Returns the smallest possible weight of the remaining stone after all possible operations. # Convert all stones to a max-heap by inverting their signs (Python has a min-heap by default) stones = [-stone for stone in stones] heapq.heapify(stones) while len(stones) > 1: y = -heapq.heappop(stones) x = -heapq.heappop(stones) if x != y: heapq.heappush(stones, -(y - x)) return -stones[0] if stones else 0"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` representing the cost of different items in a shop, and an integer `budget` representing the amount of money you have. You want to buy a contiguous subarray of items such that the total cost is as close to the `budget` as possible without exceeding it. Return _the maximum total cost of any subarray you can buy with a total cost not exceeding `budget`_. If no such subarray exists, return `0`.","solution":"def max_subarray_cost(nums, budget): Returns the maximum total cost of any contiguous subarray with a total cost not exceeding budget. :param nums: List[int] - List of integers representing costs of items. :param budget: int - The total available budget. :return: int - Maximum total cost of any contiguous subarray within the budget. n = len(nums) max_cost = 0 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum > budget and start <= end: current_sum -= nums[start] start += 1 if current_sum <= budget: max_cost = max(max_cost, current_sum) return max_cost"},{"question":"In a kingdom, there are `n` knights and each knight has a unique strength value. The strengths of the knights are represented as an integer array `strengths` where `strengths[i]` is the strength of the `i-th` knight. The knights want to form a team such that the team\'s total strength is maximized. A team can be formed by selecting a contiguous subarray of the `strengths` array. Hence, you need to find the contiguous subarray that has the maximum sum of strengths. The subarray must contain at least one element. Given the array `strengths`, return the maximum sum of the strengths for any contiguous subarray.","solution":"def max_contiguous_sum(strengths): Returns the maximum sum of strengths for any contiguous subarray. max_sum = current_sum = strengths[0] for strength in strengths[1:]: current_sum = max(strength, current_sum + strength) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a **0-indexed** `m x n` integer grid `mat`, return the number of **distinct** values that appear at least `k` times in the entire grid. In case no such value exists, return `-1`. Consider the grid to be filled with integers, and the values to be counted only if their occurrences are equal to or greater than `k`.","solution":"def distinct_values_at_least_k_times(mat, k): Returns the number of distinct values that appear at least k times in the grid mat. If no such value exists, returns -1. from collections import Counter # Flatten the matrix into a single list flatten_list = [item for sublist in mat for item in sublist] # Count the occurrences of each element count = Counter(flatten_list) # Filter elements that appear at least k times result = [key for key, value in count.items() if value >= k] # Return the number of such distinct elements or -1 if the list is empty return len(result) if result else -1"},{"question":"You are given a string `s` consisting of lowercase English letters. A sequence of characters is called a palindrome if it reads the same forward and backward. You can perform at most one swap operation on `s`, where you choose any two characters of `s` and swap them. Return _the length of the longest palindromic subsequence that can be obtained by performing at most one swap operation_. Note that a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.","solution":"def longest_palindromic_subsequence_with_one_swap(s): Returns the length of the longest palindromic subsequence that can be obtained by performing at most one swap operation. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n-cl+1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1] n = len(s) max_length = longest_palindromic_subsequence(s) for i in range(n): for j in range(i+1, n): if s[i] != s[j]: swapped_s = list(s) swapped_s[i], swapped_s[j] = swapped_s[j], swapped_s[i] max_length = max(max_length, longest_palindromic_subsequence(\'\'.join(swapped_s))) return max_length"},{"question":"You are given a **0-indexed** array `nums` of length `n` containing distinct integers from `0` to `n - 1`. The array represents a permutation of `n` integers. You need to perform a series of operations called **cyclic rotations**: in a single cyclic rotation, the array `nums` is transformed such that the element at index `0` moves to the end of the array, the element at index `1` moves to the position `0`, and so forth, with the element at index `n-1` moving to the position `n-2`. You are also given an integer `k`, representing the number of cyclic rotations to perform on the array. Return the _resultant array after performing_ `k` _cyclic rotations_.","solution":"def cyclic_rotation(nums, k): Perform k cyclic rotations on the list nums and return the resulting list. n = len(nums) k = k % n # To handle the case where k is larger than n # Perform rotation by slicing return nums[-k:] + nums[:-k]"},{"question":"Implement the `EventEmitter` class, which handles the registration and execution of event listeners. The class should support the following methods: * `void on(String event, Function listener)`: Adds the `listener` function to the list of handlers for the specified `event`. If the same listener is added multiple times, it should be called multiple times when the event is emitted. * `void off(String event, Function listener)`: Removes the `listener` function from the list of handlers for the specified `event`. If the listener was added multiple times for the event, it should be removed only once per call to `off`. * `void emit(String event, Object... args)`: Invokes all listener functions registered under the specified `event`, passing all provided `args` to each listener function.","solution":"class EventEmitter: def __init__(self): self.handlers = {} def on(self, event, listener): if event not in self.handlers: self.handlers[event] = [] self.handlers[event].append(listener) def off(self, event, listener): if event in self.handlers: self.handlers[event].remove(listener) if not self.handlers[event]: del self.handlers[event] def emit(self, event, *args): if event in self.handlers: for listener in self.handlers[event]: listener(*args)"},{"question":"You are given an array of `n` integers, each representing the height of a pillar, where `heights[i]` is the height of the `i`-th pillar. You need to calculate the **maximum rectangular area** that can be formed using a contiguous subarray of pillars. * For example, in an array `[2, 1, 5, 6, 2, 3]`, the largest rectangular area is formed by pillars with heights `[5, 6]`, resulting in an area of `2 * 5 = 10`. Return _the maximum rectangular area that can be formed with the given heights_. Complete the function `maxRectangleArea(heights: List[int]) -> int`.","solution":"from typing import List def maxRectangleArea(heights: List[int]) -> int: Calculate the maximum rectangular area in a histogram represented by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an **n x n binary matrix**, where each cell contains either a `0` or a `1`. You can flip any single row or column in the matrix, changing all `0`s to `1`s and all `1`s to `0`s in that row or column. Your task is to determine the maximum number of `1`s that can be obtained in any row or column after making at most one flip. Return _the maximum number of `1`s that can be achieved._","solution":"def max_ones_after_flip(matrix): Determines the maximum number of 1\'s that can be obtained in any row or column after making at most one flip in an n x n binary matrix. Parameters: - matrix: List[List[int]] - A n x n binary matrix. Returns: - int: The maximum number of 1\'s in any row or column after at most one flip. n = len(matrix) max_ones = 0 # Count the maximum number of 1\'s in any row without any flip for row in matrix: max_ones = max(max_ones, sum(row)) # Count the maximum number of 1\'s in any column without any flip for col in range(n): col_sum = sum(matrix[row][col] for row in range(n)) max_ones = max(max_ones, col_sum) # Check each possible row flip for row in range(n): new_matrix = [row[:] for row in matrix] for col in range(n): new_matrix[row][col] = 1 - new_matrix[row][col] # After flipping this row, calculate the max 1\'s in any row or column for new_row in new_matrix: max_ones = max(max_ones, sum(new_row)) for col in range(n): col_sum = sum(new_matrix[new_row][col] for new_row in range(n)) max_ones = max(max_ones, col_sum) # Check each possible column flip for col in range(n): new_matrix = [row[:] for row in matrix] for row in range(n): new_matrix[row][col] = 1 - new_matrix[row][col] # After flipping this column, calculate the max 1\'s in any row or column for new_row in new_matrix: max_ones = max(max_ones, sum(new_row)) for new_col in range(n): col_sum = sum(new_matrix[new_row][new_col] for new_row in range(n)) max_ones = max(max_ones, col_sum) return max_ones"},{"question":"You are given a string `s` representing bytes of data. You can reformat the string using various formatting rules. You should reformat the string in groups of `k` characters, separated by `-`. Specifically, the rules are as follows: 1. Remove all existing dashes from the string. 2. Convert all lowercase letters to uppercase. 3. Group the characters from right to left in blocks of `k`. The first group may be shorter than `k` but must contain at least one character. It should not be empty or start with a dash. Return the reformatted data string. For example: ``` Input: s = \\"2-4A0r7-4k\\", k = 4 Output: \\"24A0-R74K\\" Input: s = \\"2-4A0r7-4k\\", k = 3 Output: \\"24-A0R-74K\\" ```","solution":"def reformat_string(s, k): Reformats the string `s` as described in the task: 1. Remove all existing dashes. 2. Convert all lowercase letters to uppercase. 3. Group the characters from right to left in blocks of `k`. The first group may be shorter. Parameters: s (str): The string to reformat. k (int): The size of each group of characters. Returns: str: The reformatted string. # Remove all existing dashes and convert to uppercase s = s.replace(\\"-\\", \\"\\").upper() # Start grouping from the end reformatted = [] while len(s) > k: reformatted.append(s[-k:]) s = s[:-k] # Add the remainder of the string (the first group) if s: reformatted.append(s) return \'-\'.join(reversed(reformatted))"},{"question":"You are given an **m x n** matrix `mat` containing only 0s and 1s. Each row is sorted in **non-decreasing** order, and you need to find the leftmost column with at least a `1`. Return the index of the leftmost column with at least a `1`. If such a column does not exist, return `-1`. Try to achieve an optimal solution in terms of complexity.","solution":"def leftmost_column_with_one(mat): Finds the leftmost column with at least one \'1\' in a sorted binary matrix. :param mat: List of lists representing the binary matrix. :return: Index of the leftmost column with at least one \'1\'. If no such column exists, return -1. if not mat or not mat[0]: return -1 rows, cols = len(mat), len(mat[0]) current_row, current_col = 0, cols - 1 result = -1 while current_row < rows and current_col >= 0: if mat[current_row][current_col] == 1: result = current_col current_col -= 1 else: current_row += 1 return result"},{"question":"Imagine you are working with a data log that records user activity on a website. This log is represented by a list of tuples, where each tuple contains two values: a user id and a timestamp. Write a function to identify the top `k` users who have the highest number of activities recorded in the log. If there is a tie, return all users who have the same number of activities as the k-th user when sorting in descending order of activity counts. Your function should output a list of user ids. Example: ``` log = [(1, \'2023-10-01 10:00:00\'), (2, \'2023-10-01 10:05:00\'), (1, \'2023-10-01 10:10:00\'), (3, \'2023-10-01 10:20:00\'), (1, \'2023-10-01 10:25:00\'), (2, \'2023-10-01 10:30:00\')] k = 2 ``` Output: ``` [1, 2] ``` In this example, user 1 has 3 activities and user 2 has 2 activities, while user 3 has only 1 activity. Thus, the top 2 users with the highest number of activities are user 1 and user 2.","solution":"from collections import Counter def top_k_users(log, k): Identify the top k users with the highest number of activities recorded in the log. If there is a tie, return all users who have the same number of activities as the k-th user. :param log: List of tuples containing user id and timestamp :param k: Number of top users to retrieve :return: List of user ids with the highest number of activities # Count activities for each user using Counter user_activity_count = Counter(user_id for user_id, _ in log) # Get the number of activities for each user, sorted in descending order sorted_counts = user_activity_count.most_common() # Collect users from sorted counts that are within the top k users or tie with the k-th user result = [] current_rank = 0 last_count = None for user_id, count in sorted_counts: if len(result) < k or count == last_count: result.append(user_id) current_rank += 1 last_count = count else: break return result"},{"question":"You are given a **positive** integer `k` and an array of `k` strings `rows`, where each string represents a word. You need to construct a k x k board such that: * Each word in `rows` corresponds to one of the rows in the board. * Each column in the board, when read from top to bottom, forms a valid English word. The board should be filled with only the characters present in `rows`. If multiple boards are possible, return any valid one. If no board is possible, return an empty board.","solution":"def is_valid_board(rows): Checks if the columns in the board form valid English words. Here, we will only simulate the valid check by assuming all columns are valid as words are not provided or checked against actual dictionary. k = len(rows) for i in range(k): column_word = \'\'.join(rows[j][i] for j in range(k)) # Assuming every column word is valid for now # In real applications, we might check against a dictionary return True def construct_board(k, rows): Constructs a k x k board such that each column in the board forms a valid English word. If no such board is possible, returns an empty list. if is_valid_board(rows): return rows else: return []"},{"question":"You are given a **0-indexed** integer array `heights` where `heights[i]` represents the height of the `i-th` person. The array `heights` is already sorted in non-decreasing order. The task is to calculate the minimum number of platforms required at a railway station so that no train has to wait. A person (train) at index `i` has a departure time later than or equal to the height of the next person (train) they stand next to. Return the minimum number of platforms required for the given sequence of heights.","solution":"def min_platforms_required(heights): Given an array of heights, calculate the minimum number of platforms required such that no train has to wait. Parameters: heights (list of int): A 0-indexed list of heights sorted in non-decreasing order. Returns: int: Minimum number of platforms required. if not heights: return 0 n = len(heights) platforms = 1 # At least one platform is needed max_platforms = 1 for i in range(1, n): if heights[i] == heights[i-1]: platforms += 1 else: platforms = 1 # Reset platform count for new height # Update maximum platforms count max_platforms = max(max_platforms, platforms) return max_platforms"},{"question":"Given two strings `s1` and `s2`, write a function to determine if `s2` is a rotation of `s1` using only one call to the standard library function that checks for substrings. For example, \\"waterbottle\\" is a rotation of \\"erbottlewat\\". Implement the `is_rotation(s1: str, s2: str) -> bool` function. The function should return: - `True` if `s2` is a rotation of `s1` - `False` otherwise","solution":"def is_rotation(s1, s2): Returns True if s2 is a rotation of s1, otherwise False. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"Given an array of integers `nums`, where every integer appears twice except for one. Find that single one that does not have a pair and return it.","solution":"def single_number(nums): Given an array of integers where every integer appears twice except for one, find the single integer that does not have a pair. Args: nums (list of int): The input array of integers. Returns: int: The single integer that does not have a pair. result = 0 for num in nums: result ^= num return result"},{"question":"**Question 4**: Given an array of integers `nums`, find the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. Return _the length_ of the longest increasing subsequence in `nums`.","solution":"def length_of_LIS(nums): Returns the length of the longest strictly increasing subsequence. :param nums: List[int] :return: int if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a **1-indexed** integer array `weights` where `weights[i]` represents the weight of the `i`-th object. You\'re also given an integer `n` which represents the total number of objects. You need to distribute these objects into two groups such that the absolute difference in the sum of the weights of the two groups is minimized. Return the minimal possible absolute difference.","solution":"def min_difference(weights): n = len(weights) total_sum = sum(weights) half_sum = total_sum // 2 # Initialize a DP array with all False values dp = [False] * (half_sum + 1) dp[0] = True for weight in weights: for j in range(half_sum, weight - 1, -1): if dp[j - weight]: dp[j] = True for i in range(half_sum, -1, -1): if dp[i]: sum1 = i break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"You are given a list of strings `strs`, where each string consists of lowercase English letters. You need to group the strings that are anagrams of each other into the same group and return those groups. Two strings are anagrams if and only if their sorted characters are identical. Each group should be represented as a list of strings, and the groups should be presented in any order. Return the list of groups of anagrams.","solution":"from collections import defaultdict def group_anagrams(strs): Groups the input list of strings into anagrams. Args: strs: List[str] - list of strings to be grouped. Returns: List[List[str]] - list of groups of anagrams. anagram_dict = defaultdict(list) for s in strs: sorted_str = \'\'.join(sorted(s)) anagram_dict[sorted_str].append(s) return list(anagram_dict.values())"},{"question":"You are given a `2D` grid of `m x n` size filled with zeros and ones. A group of connected 1s forms an island. Two 1s are considered connected if they are adjacent horizontally or vertically. You must identify the largest island (the one with the maximum area), and then transform each 0 in the grid to a 1 independently and compute the area of the new island that would form. Return _the maximum area of an island_ you can obtain after this transformation.","solution":"def largest_island(grid): def dfs(x, y, index): area = 1 grid[x][y] = index for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: area += dfs(nx, ny, index) return area def neighbor_indices(x, y): indices = set() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] > 1: indices.add(grid[nx][ny]) return indices if not grid: return 0 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] index = 2 area_map = {0: 0} for i in range(m): for j in range(n): if grid[i][j] == 1: area_map[index] = dfs(i, j, index) index += 1 max_area = max(area_map.values(), default=0) for i in range(m): for j in range(n): if grid[i][j] == 0: neighbor_indices_set = neighbor_indices(i, j) new_area = 1 + sum(area_map[idx] for idx in neighbor_indices_set) max_area = max(max_area, new_area) return max_area"},{"question":"You are given an array of integers representing the rainfall amount recorded each day for a given period. Your task is to find out _the maximum number of consecutive days with non-decreasing rainfall amounts_. Return this number as an integer.","solution":"def max_consecutive_non_decreasing_days(rainfall): Returns the maximum number of consecutive days with non-decreasing rainfall amounts. :param rainfall: List[int] - list of daily rainfall amounts. :return: int - maximum number of consecutive non-decreasing days. if not rainfall: return 0 max_length = 1 current_length = 1 for i in range(1, len(rainfall)): if rainfall[i] >= rainfall[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a list of `n` integers, where each integer represents the position of a town along a straight road. There are `k` postal offices to be built along the same road. The goal is to minimize the maximum distance any town has to a postal office. Return the minimum possible value of the maximum distance any town has to a postal office.","solution":"def can_place_offices(towns, k, max_dist): # Place the first postal office offices_count = 1 last_office = towns[0] # Traverse the towns to place the offices for town in towns: if town - last_office > max_dist: offices_count += 1 last_office = town if offices_count > k: return False return True def min_max_distance(towns, k): # Sort the towns by their positions towns.sort() # Define the search range left, right = 0, towns[-1] - towns[0] # Binary search for the minimum possible maximum distance while left < right: mid = (left + right) // 2 if can_place_offices(towns, k, mid): right = mid else: left = mid + 1 return left"},{"question":"Write a function that takes a list of strings and returns the list of strings sorted with the strings that have more than 5 characters being placed at the beginning of the list, in descending order of their lengths, and the strings with 5 or fewer characters being placed at the end of the list, also sorted in descending order of their lengths. Ignore case while sorting. Each string should appear only once in the result, preserving the order of strings with the same length as they appear in the original list.","solution":"def sort_strings(lst): Sorts the input list of strings such that strings with more than 5 characters are at the beginning in descending order of their lengths, followed by strings with 5 or fewer characters also in descending order of their lengths. The order of strings with the same length is preserved as they appear in the original list. Strings are compared ignoring case, but the original case of the strings is preserved in the result. more_than_five = sorted( [s for s in lst if len(s) > 5], key=lambda x: -len(x) ) five_or_less = sorted( [s for s in lst if len(s) <= 5], key=lambda x: -len(x) ) return more_than_five + five_or_less"},{"question":"Given a binary tree, return the **maximum width** of the binary tree. The **width** of a tree is the maximum width among all levels. The width of one level is defined as the length between the **leftmost** and **rightmost** non-null nodes (inclusive) in that level. If the answer is very large, return it **modulo** `1000000007`.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def widthOfBinaryTree(root): Returns the maximum width of the binary tree. The function uses level-order traversal with a queue and calculates the width at each level. if not root: return 0 max_width = 0 queue = deque([(root, 0)]) # (node, index) while queue: level_length = len(queue) _, first_index = queue[0] for i in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) _, last_index = queue[-1] if queue else (None, 0) max_width = max(max_width, last_index - first_index + 1) return max_width % 1000000007"},{"question":"Given a string `s` containing only characters `a` and `b`, you can swap any two characters in the string at most once. Return the length of the longest substring consisting of only one unique character that you can get.","solution":"def longest_char_substring(s): Given a string s containing only characters \'a\' and \'b\', swap any two characters at most once and return the length of the longest substring consisting of only one unique character that you can get. def max_len_char(c, other_char): max_length = 0 count_other_char = 0 left = 0 for right in range(len(s)): if s[right] == other_char: count_other_char += 1 while count_other_char > 1: if s[left] == other_char: count_other_char -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length return max(max_len_char(\'a\', \'b\'), max_len_char(\'b\', \'a\'))"},{"question":"You are given a **0-indexed** array `heights` consisting of positive integers, where each element represents the height of a building. A rain of water can fill up any space between the given buildings. You need to compute the **maximum amount of water** that can be collected between the buildings without spilling over. Return the maximum number of water units that can be trapped.","solution":"def trap(height): if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given an array of integers `nums` representing a contiguous subarray of a circular array, return the maximum possible sum of the non-empty subarray. A circular array means the end of the array connects to the beginning of the array. Formally, the next element of `nums[nums.length - 1]` is `nums[0]`, and the previous element of `nums[0]` is `nums[nums.length - 1]`. Your task is to find the maximum possible subarray sum in this circular array.","solution":"def maxSubarraySumCircular(nums): def kadane(gen): # Helper function to perform Kadane\'s algorithm # to find the maximum subarray sum for a given iterator `gen`. current_sum = max_sum = next(gen) for num in gen: current_sum = num + max(current_sum, 0) max_sum = max(max_sum, current_sum) return max_sum # Compute the maximum subarray sum using Kadane\'s algorithm max_kadane = kadane(iter(nums)) # Compute the sum of the array total_sum = sum(nums) # Compute the minimum subarray sum using modified Kadane\'s algorithm max_wraparound = total_sum + kadane(-num for num in nums) # Check if all numbers are negative if max_wraparound == 0: return max_kadane # The result is the maximum of the non-circular and circular sums return max(max_kadane, max_wraparound)"},{"question":"You are given an array `arr` of positive integers where each integer represents the height of a building. Because the city is very strict with its city planning, they have decided that a building can only be demolished if it is surrounded by buildings with greater heights (both sides). Write a function to return the number of buildings that can be demolished according to this rule.","solution":"def count_demolishable_buildings(arr): Returns the number of buildings that can be demolished. A building can be demolished if it is surrounded by buildings with greater heights on both sides. :param arr: List of positive integers representing the heights of buildings. :return: Number of demolishable buildings. demolishable_count = 0 for i in range(1, len(arr) - 1): if arr[i] < arr[i - 1] and arr[i] < arr[i + 1]: demolishable_count += 1 return demolishable_count"},{"question":"Given a string representing an arithmetic expression with addition and subtraction, write a function to evaluate the expression and return the result as an integer. The expression may contain parentheses, and you should respect the standard rules of operator precedence. You can assume that the given string does not contain any invalid characters and that it will always be a valid arithmetic expression. For example: - Input: `\\"(1+(4+5+2)-3)+(6+8)\\"` - Output: `23` - Input: `\\"1 - (4 + 2) + 3\\"` - Output: `-2`","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression containing addition and subtraction, with possible parentheses. Args: expression (str): A string representing the arithmetic expression. Returns: int: The result of the evaluated arithmetic expression. def calculate(operators, operands): Helper function to perform arithmetic operations. if operators[-1] == \'+\': operands[-2] += operands[-1] elif operators[-1] == \'-\': operands[-2] -= operands[-1] operators.pop() operands.pop() operators, operands = [], [] i, n = 0, len(expression) while i < n: if expression[i] == \' \': i += 1 continue if expression[i] in \'+-\': while operators and operators[-1] in \\"+-\\": calculate(operators, operands) operators.append(expression[i]) elif expression[i] == \'(\': operators.append(expression[i]) elif expression[i] == \')\': while operators[-1] != \'(\': calculate(operators, operands) operators.pop() else: num = 0 while i < n and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) continue i += 1 while operators: calculate(operators, operands) return operands[0]"},{"question":"You are given a matrix `mat` of size `m x n` consisting of non-negative integers. You can perform the following operation any number of times: Choose any row or column, and increment every element in that row or column by 1. Return _the minimum number of operations required to make all the elements of the matrix equal_.","solution":"def min_operations_to_equal_matrix(mat): Returns the minimum number of operations required to make all the elements of the matrix equal. :param mat: List[List[int]] - 2D non-negative integer matrix :return: int - minimum number of operations if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) # Flatten the matrix and find the median elements = [mat[i][j] for i in range(m) for j in range(n)] elements.sort() median = elements[len(elements) // 2] # Compute the minimum number of operations to make all elements equal to the median operations = sum(abs(median - mat[i][j]) for i in range(m) for j in range(n)) return operations"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a part of a city block. The value `1` in a cell indicates a building and `0` indicates an empty space. The city planners want to build a new road system such that every building can be reached by the road network. The road can only be built on empty spaces (`0`s), and it can be constructed as either horizontal or vertical lines connecting two points with the same row or column index. A road construction plan is represented by a rectangle made of lines connecting four points in the grid. For example, a plan that connects points `(0,0)` to `(0,2)` and `(1,0)` to `(1,2)` would result in a road stretching over the coordinates `[(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]`. Return the minimum number of such road plans required to ensure every building is reachable by the road network.","solution":"def minRoadPlans(grid): def dfs(grid, r, c): if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == 1: grid[r][c] = 0 # Mark visited # Explore all four directions dfs(grid, r + 1, c) dfs(grid, r - 1, c) dfs(grid, r, c + 1) dfs(grid, r, c - 1) def countComponents(grid): components = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: dfs(grid, r, c) components += 1 return components return countComponents(grid)"},{"question":"You are given a binary tree with `n` nodes where each node is uniquely identifiable by a value labelled from `1` to `n`. Each node in the binary tree is represented as `TreeNode { val, left, right }`. Write a function that determines whether the binary tree contains a **valid sequence** of node values from an input array. A valid sequence must follow these criteria: - Start from the root of the binary tree. - Traverse through the nodes following the left or right child pointers. - Form the sequence exactly as in the input array. Return `True` if the input array is a valid sequence in the binary tree, otherwise, return `False`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_sequence(root, arr): Checks if the array represents a valid sequence in the binary tree. Parameters: root (TreeNode): The root of the binary tree. arr (List[int]): The sequence to check. Returns: bool: True if the sequence is valid, otherwise False. def dfs(node, index): if node is None: return False if index >= len(arr) or node.val != arr[index]: return False if index == len(arr) - 1: return node.left is None and node.right is None return dfs(node.left, index + 1) or dfs(node.right, index + 1) return dfs(root, 0)"},{"question":"A university has `n` lecture rooms, each represented by an integer from `1` to `n`. You are given an array `lectures` where `lectures[i] = [s, t, r]` indicates that the `i`-th lecture starts at time `s`, ends at time `t`, and needs room `r`. A lecture room can only hold one lecture at a time, and no lectures scheduled in the same room should overlap. Return the maximum number of lectures that can be conducted without any overlap in their scheduled times. If it\'s not possible to conduct any lectures without conflict, return `0`.","solution":"def maxLecturesWithoutOverlap(n, lectures): Returns the maximum number of lectures that can be conducted without any overlap. Parameters: - n : int : number of lecture rooms - lectures : List[List[int]] : list of lectures with each lecture represented as [start time, end time, room number] Returns: - int : maximum number of non-overlapping lectures from collections import defaultdict # Dictionary to hold the list of lectures for each room room_lectures = defaultdict(list) # Populate the room_lectures dictionary with lectures for lecture in lectures: s, t, r = lecture room_lectures[r].append((s, t)) def max_non_overlapping_intervals(intervals): # Sort intervals by end time intervals.sort(key=lambda x: x[1]) end = float(\'-inf\') count = 0 for s, t in intervals: if s >= end: end = t count += 1 return count # Iterate through each room and calculate the max number of non-overlapping lectures max_lectures = 0 for r in range(1, n+1): max_lectures += max_non_overlapping_intervals(room_lectures[r]) return max_lectures"},{"question":"You are given a string `S` containing only lowercase letters. You can perform the following operation any number of times: select a non-empty substring in which all of the characters are the same and delete it. What is the minimum number of operations required to delete all characters in the string? For example, given the input `\\"aaabbb\\"`, the output would be `2` because you can delete `\\"aaa\\"` in one operation, and `\\"bbb\\"` in another. Return the **minimum number of operations** required to delete all characters in the string.","solution":"def min_operations_to_delete_string(S): Return the minimum number of operations required to delete all characters in the string. :param S: A string containing only lowercase letters. :return: Minimum number of operations to delete all characters. if not S: return 0 count = 1 for i in range(1, len(S)): if S[i] != S[i-1]: count += 1 return count"},{"question":"You are given a list of integers `arr` where each integer represents the number of units of a certain product. You own a warehouse with a total capacity of `capacity` units. You are required to determine whether it is possible to fill the warehouse with exactly `capacity` units using the provided list of products. Each unit of the product can only be used once. Return `true` if it is possible to meet the warehouse capacity using the given list, otherwise return `false`.","solution":"def can_fill_warehouse(arr, capacity): Function to determine if it is possible to fill the warehouse with exactly the given capacity using the provided list of product units. n = len(arr) dp = [[False] * (capacity + 1) for _ in range(n + 1)] # It\'s always possible to achieve 0 capacity with no elements for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, capacity + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] return dp[n][capacity]"},{"question":"You are given a string `expression` that contains only the characters `(`, `)`, `{`, `}`, `[` and `]`. Write a function to determine if the given expression is a valid arithmetic expression. An arithmetic expression is considered valid if all opening brackets have a corresponding closing bracket of the same type, and they are correctly nested. Return `true` if the expression is valid, and `false` otherwise. For example: - Given `expression = \\"()\\"`, the function should return `true`. - Given `expression = \\"{[()]}\\"`, the function should return `true`. - Given `expression = \\"{[(])}\\"`, the function should return `false`.","solution":"def is_valid_expression(expression): Function to determine if the given expression is a valid arithmetic expression. An expression is valid if all opening brackets have a corresponding closing bracket of the same type, and they are correctly nested. Parameters: expression (str): The expression to check. Returns: bool: True if the expression is valid, False otherwise. # Stack to keep track of opening brackets stack = [] # Dictionary to match opening and closing brackets bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} # Iterate over each character in the expression for char in expression: # If the character is a closing bracket if char in bracket_map: # Pop element from stack if stack is not empty, else assign a dummy value top_element = stack.pop() if stack else \'#\' # Check if the popped element matches the corresponding opening bracket if bracket_map[char] != top_element: return False else: # If it\'s an opening bracket, push it onto the stack stack.append(char) # If the stack is empty, all brackets were matched correctly return not stack"},{"question":"You are given a `k` x `k` grid `board` representing a game of **Tic-Tac-Toe** played between two players using \'X\' and \'O\'. The grid contains either \'X\', \'O\', or \'\'. A move is a complete row, column, or diagonal filled with only one type of symbol (\'X\' or \'O\'). Your task is to determine if there is a winner. Return `\'X\'` if the player with \'X\' wins, return `\'O\'` if the player with \'O\' wins, or return `\'Draw\'` if neither player has yet won at the end of the game.","solution":"def check_winner(board): Determines the winner in a Tic-Tac-Toe game. Returns \'X\' if X wins, \'O\' if O wins, or \'Draw\' if there is no winner. size = len(board) def check_line(line): if all(cell == \'X\' for cell in line): return \'X\' if all(cell == \'O\' for cell in line): return \'O\' return None # Check rows and columns for i in range(size): row_result = check_line([board[i][j] for j in range(size)]) if row_result: return row_result col_result = check_line([board[j][i] for j in range(size)]) if col_result: return col_result # Check main diagonal main_diag_result = check_line([board[i][i] for i in range(size)]) if main_diag_result: return main_diag_result # Check anti-diagonal anti_diag_result = check_line([board[i][size - 1 - i] for i in range(size)]) if anti_diag_result: return anti_diag_result return \'Draw\'"},{"question":"Given a string `s` consisting of only the characters `\'a\'`, `\'b\'`, and `\'c\'`, you need to determine if it is possible to remove some characters from `s` such that the resulting string contains at least one `\'a\'`, one `\'b\'`, and one `\'c\'` in any order. Define a function `isPossible(s)` that returns a boolean value indicating whether this is possible. *For example, if `s = \\"abcabc\\"`, the function should return `true` because it is possible to keep the first `\'a\'`, `\'b\'`, and `\'c\'` to satisfy the condition. If `s = \\"aaaa\\"`, the function should return `false` because there is no `\'b\'` or `\'c\'`.*","solution":"def isPossible(s): Returns a boolean indicating whether it\'s possible to remove some characters from s to get at least one \'a\', one \'b\', and one \'c\' in any order. return \'a\' in s and \'b\' in s and \'c\' in s"},{"question":"Given a 2D grid of size `m x n` where each cell represents a different terrain type, return the number of different paths from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time, and you can only traverse through cells of the same terrain type as the starting cell (top-left corner). If there is no such path, return `0`. A path is defined as a sequence of cells from the top-left corner to the bottom-right corner such that every cell in the sequence is adjacent to the previous one, either to the right or below it, and all cells contain the same terrain type.","solution":"def count_paths(grid): Returns the number of different paths from the top-left corner to the bottom-right corner of the grid, moving only down or right and within cells containing the same terrain type as the starting cell. m, n = len(grid), len(grid[0]) start_terrain = grid[0][0] # If start or end cells don\'t have the same terrain type as the start, return 0 if grid[m-1][n-1] != start_terrain: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Starting point for i in range(m): for j in range(n): if grid[i][j] != start_terrain: dp[i][j] = 0 # Not a valid cell else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"You have two friends Alice and Bob playing a memory card game where they need to remember the sequence of the cards. Alice will play by showing Bob an array of integers `cards` where each integer represents a card\'s value. Bob\'s task is to find any repeated card within this array and determine the shortest possible distance between two equal cards. The distance between two equal cards with indices `i` and `j` is defined as `|i - j|`. If there are multiple pairs of the same cards with the same minimum distance, return any of these distances. If there are no repeating cards, return `-1`. Return _the shortest distance between two repeated cards or `-1` if no card is repeated_.","solution":"def shortest_distance(cards): Returns the shortest distance between two repeated cards or -1 if no card is repeated. card_indices = {} min_distance = float(\'inf\') for index, card in enumerate(cards): if card in card_indices: min_distance = min(min_distance, index - card_indices[card]) card_indices[card] = index return -1 if min_distance == float(\'inf\') else min_distance"},{"question":"You are given a string `s` consisting of lowercase English letters, and an array of strings `dictionary`. Write a function to check if any permutation of `s` matches a word in `dictionary`. Return `true` if such a permutation exists, otherwise return `false`. If multiple permutations match different words in the dictionary, return `true`. If no permutation matches any word, return `false`.","solution":"from collections import Counter def has_permutation_in_dictionary(s, dictionary): Returns True if any permutation of s matches a word in dictionary, otherwise False. s_counter = Counter(s) for word in dictionary: if Counter(word) == s_counter: return True return False"},{"question":"Write a function `findDuplicateSubtrees(TreeNode root)` that returns all **duplicate subtrees**. A subtree is considered a duplicate if there are two or more subtrees with the same structure and node values. For each duplicate subtree, only one of them needs to be returned. The function should return a list of `TreeNode` where each element is the root of a duplicate subtree. Duplicate subtrees are defined as subtrees that have the same structure and the same node values.","solution":"from collections import defaultdict from typing import List # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findDuplicateSubtrees(root: TreeNode) -> List[TreeNode]: Finds all duplicate subtrees in a binary tree. :param root: The root node of the binary tree. :return: A list of TreeNode which are the roots of duplicate subtrees. def serialize(node): if not node: return \\"#\\" serial = f\\"{node.val},{serialize(node.left)},{serialize(node.right)}\\" trees[serial].append(node) return serial trees = defaultdict(list) serialize(root) duplicates = [nodes[0] for nodes in trees.values() if len(nodes) > 1] return duplicates"},{"question":"You are given an integer array `arr` of length `n` consisting of unique elements, and an integer `k`. You need to find the top `k` largest elements from the array. However, the requirement is that the order of these `k` elements should be the same as their order in the original array `arr`. Return _an array_ containing the `k` largest elements in the same order as they appear in `arr`.","solution":"def top_k_largest(arr, k): Returns the top k largest elements from the array in the same order as they appear in the original array. Parameters: arr (list of int): The array of unique integers. k (int): The number of largest elements to find. Returns: list of int: The top k largest elements in the same order as they appear in arr. if k <= 0: return [] # Find the top k largest elements top_k_elements = sorted(arr, reverse=True)[:k] # Maintain the order as in the original array result = [x for x in arr if x in top_k_elements] return result[:k]"},{"question":"You are given a string `s` containing only lowercase English letters. You can rearrange the letters of the string such that two adjacent characters are not the same. Return _the **length** of the longest possible rearranged string_ you can create under this condition. If it is not possible to rearrange the string such that no two adjacent characters are the same, return `-1`. For example: - Input: `s = \\"aabb\\"` - Output: 4 - Explanation: One possible rearrangement is \\"abab\\".","solution":"from collections import Counter import heapq def longest_rearranged_length(s): Returns the length of the longest possible rearranged string such that no two adjacent characters are the same. If it is not possible, returns -1. frequency = Counter(s) max_heap = [(-count, char) for char, count in frequency.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' rearranged_length = 0 while max_heap: count, char = heapq.heappop(max_heap) rearranged_length += 1 count += 1 # since heapq is min heap, we used -count, we need to increment if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count, char if rearranged_length == len(s): return rearranged_length else: return -1"},{"question":"You are given a list of strings `words` and a string `letters`. Your task is to return the longest word in `words` that can be constructed by using the letters from `letters` at most once per letter. The returned word must be such that it can be formed by the given letters. If there are multiple possible answers, return the longest one with the smallest lexicographical order. If no words can be formed, return an empty string.","solution":"def longest_word(words, letters): Returns the longest word in \'words\' that can be constructed using \'letters\' at most once per letter. In case of ties, returns the lexicographically smaller word. from collections import Counter def can_form(word, letters_count): word_count = Counter(word) for char in word_count: if word_count[char] > letters_count.get(char, 0): return False return True letters_count = Counter(letters) valid_words = [word for word in words if can_form(word, letters_count)] if not valid_words: return \\"\\" valid_words.sort(key=lambda x: (-len(x), x)) return valid_words[0]"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. An arithmetic triplet is a triplet `(i, j, k)` such that `i < j < k` and `nums[j] - nums[i]` is equal to `d`, and `nums[k] - nums[j]` is equal to `d`. Return _the number of unique arithmetic triplets_ in the array.","solution":"def arithmetic_triplets(nums, d): Returns the number of unique arithmetic triplets in the array. :param nums: List[int] - a list of integers of length n :param d: int - the difference :return: int - the number of unique arithmetic triplets count = 0 nums_set = set(nums) for num in nums: if (num + d in nums_set) and (num + 2 * d in nums_set): count += 1 return count"},{"question":"You are given a **0-indexed** integer array `penalties` where `penalties[i]` denotes the penalty for violating a rule in the `i-th` section of a competition. There are `n` sections, and each section must be completed exactly once in order from section `0` to section `n-1`. The competitors have the option to skip one section entirely to minimize their total penalty. Your task is to determine the minimum possible penalty one can achieve if exactly one section can be skipped. Return _the minimum possible penalty_ that can be achieved by skipping one section of the competition.","solution":"def min_penalty(penalties): Returns the minimum possible penalty by skipping one section. Args: penalties (list of int): The list representing penalties for each section. Returns: int: Minimum possible penalty. total_penalty = sum(penalties) max_penalty_skip = max(penalties) return total_penalty - max_penalty_skip"},{"question":"You are given a string `s` consisting of only lowercase English letters. In one move, you can choose any contiguous substring of `s` that contains exactly one unique letter, and remove it from the string. Your goal is to determine _the minimum number of moves required to remove all characters from the string._ Keep in mind that after removing a substring, the remaining parts of the string will shift to fill the gap. Return the minimum number of moves needed to complete the task.","solution":"def min_moves_to_remove_substrings(s): Determines the minimum number of moves required to remove all characters from the string. Parameters: s (str): The input string consisting of only lowercase English letters. Returns: int: The minimum number of moves required to remove all characters. if not s: # if the string is empty, no moves are needed return 0 moves = 1 # initialize moves to 1, since we need at least 1 move to start for i in range(1, len(s)): # if the current character is different from the previous one, then it\'s a new segment if s[i] != s[i - 1]: moves += 1 return moves"},{"question":"You are given a list of integers representing the heights of buildings in a cityscape where the buildings are of varying heights. You are also given an integer `k` representing the number of consecutive buildings you are interested in. Your task is to find the maximum possible sum of the heights of any `k` consecutive buildings. Return the maximum sum.","solution":"def max_sum_of_consecutive_buildings(heights, k): Returns the maximum possible sum of the heights of any `k` consecutive buildings. :param heights: List of integers representing the heights of buildings. :param k: Integer representing the number of consecutive buildings. :return: Maximum sum of heights of any `k` consecutive buildings. if not heights or k > len(heights) or k <= 0: return 0 current_sum = sum(heights[:k]) max_sum = current_sum for i in range(k, len(heights)): current_sum += heights[i] - heights[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `nums` and an integer `target`. You want to find the number of subsets of `nums` that sum up to `target`. A subset is defined as any sequence of elements taken from `nums` without considering their order. Return _the number of subsets that sum to_ `target`. Since the answer can be very large, return it **modulo** `109 + 7`.","solution":"MOD = 10**9 + 7 def count_subsets(nums, target): from collections import defaultdict dp = defaultdict(int) dp[0] = 1 # There is one way to get sum 0: pick no elements for num in nums: for cur_sum in list(dp.keys())[::-1]: new_sum = cur_sum + num dp[new_sum] = (dp[new_sum] + dp[cur_sum]) % MOD return dp[target]"},{"question":"Given an array of distinct integers `arr`, determine if there exists a pair of elements (x, y) such that x is the double of y (x = 2 * y). Return `true` if such a pair exists, and `false` otherwise. Note that the array may contain both positive and negative numbers.","solution":"def check_if_exist(arr): Determine if there exists a pair of elements (x, y) in the array such that x = 2 * y. Args: arr (list of int): Array of distinct integers. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if 2 * num in seen or (num % 2 == 0 and num // 2 in seen): return True seen.add(num) return False"},{"question":"You are given a list of integers `numbers` that contains both positive and negative integers, as well as a target sum `target`. Write a function to find all unique pairs of integers in the list whose sum is equal to `target`. Each pair should be sorted in ascending order, and the function should return a list of these pairs sorted in ascending order of their first elements. If no such pair exists, return an empty list.","solution":"def find_pairs_with_sum(numbers, target): Finds all unique pairs of integers in the list whose sum equals the target sum. :param numbers: List of integers with both positive and negative values. :param target: The target sum for the pairs. :return: List of pairs (tuples) whose sum equals the target sum. numbers = sorted(numbers) # Sort input list pairs = set() # Use a set to store unique pairs left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: pairs.add((numbers[left], numbers[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return sorted(list(pairs), key=lambda x: x[0])"},{"question":"You are given `n` pairs of numbers. In every pair, the first number is always smaller than the second number. Now, we define a pair chain as a subset of pairs where each pair `(c, d)` follows the pair `(a, b)` such that `b < c`. Your task is to find the length of the longest chain which can be formed. Given an array `pairs` where `pairs[i] = [a, b]`, return _the length of the longest chain you can form_. For example, if `pairs = [[1,2], [2,3], [3,4]]`, then the longest pair chain would be `2` since `(1,2)` can be followed by `(3,4)`, but `(2,3)` does not meet the condition.","solution":"def findLongestChain(pairs): Returns the length of the longest chain that can be formed with given pairs. :param pairs: List of pairs where each pair is represented as [a, b], with a < b :return: Length of the longest chain pairs.sort(key=lambda x: x[1]) # Sort pairs based on the second element of each pair current_end, count = float(\'-inf\'), 0 for pair in pairs: if current_end < pair[0]: current_end = pair[1] count += 1 return count"},{"question":"You are given a string `inputString` that represents a number in which commas appear periodically every three characters, starting from the right (e.g., \\"1,234\\", \\"12,345,678\\"). Your task is to write a function that removes all commas from the `inputString` and returns the resulting number as an integer.","solution":"def remove_commas(input_string): Removes all commas from the input string and returns the resulting number as an integer. return int(input_string.replace(\\",\\", \\"\\"))"},{"question":"You are given an array of integers `tasks` where `tasks[i]` represents the number of minutes required to complete the `i-th` task. Each task can be assigned to one of the `k` workers. The workers can work in parallel. Return _the minimum amount of time required to finish all tasks assigned to the slowest worker_, assuming tasks are assigned optimally to minimize this maximum time.","solution":"def minimum_time_required(tasks, k): def can_finish_in_time(tasks, workers, max_time): workloads = [0] * workers return assign_tasks(tasks, workloads, max_time, 0) def assign_tasks(tasks, workloads, max_time, index): if index == len(tasks): return True for i in range(len(workloads)): if workloads[i] + tasks[index] <= max_time: workloads[i] += tasks[index] if assign_tasks(tasks, workloads, max_time, index + 1): return True workloads[i] -= tasks[index] if workloads[i] == 0: break return False tasks.sort(reverse=True) left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_finish_in_time(tasks, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given two strings `s` and `t`. A subsequence is a sequence that can be derived by deleting some or no elements from the string without changing the order of the remaining elements. Your task is to determine whether string `t` is a subsequence of string `s`. Return `true` if `t` is a subsequence of `s`, and `false` otherwise.","solution":"def is_subsequence(s, t): Determines if t is a subsequence of s. Args: s (str): The string to be checked. t (str): The subsequence string. Returns: bool: True if t is a subsequence of s, False otherwise. t_index = 0 t_len = len(t) if t_len == 0: return True for char in s: if t_index < t_len and char == t[t_index]: t_index += 1 if t_index == t_len: return True return False"},{"question":"Design a function `topKFrequent` that accepts an array of integers `nums` and an integer `k`. The task is to return the `k` most frequent elements in the array. The elements should be returned in decreasing order of frequency. If multiple elements have the same frequency, they can be returned in any order. Implement the function with the following signature: * `List<Integer> topKFrequent(int[] nums, int k)` **Example:** Input: `nums = [1,1,1,2,2,3]`, `k = 2` Output: `[1, 2]` **Example:** Input: `nums = [1]`, `k = 1` Output: `[1]` **Constraints:** - You may assume `k` is always valid, the number of unique elements in the array is `at least k`. - Your algorithm\'s time complexity must be better than `O(n log n)`, where `n` is the array\'s size. - The elements in `nums` are integers from the range `[-10^4, 10^4]`.","solution":"from typing import List from collections import Counter import heapq def topKFrequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the nums array. # Count frequency of each element count = Counter(nums) # Use a heap to find the k most frequent elements return [item for item, _ in heapq.nlargest(k, count.items(), key=lambda x: x[1])]"},{"question":"You are given a **0-indexed** integer array `arr` representing the heights of shrubs in a garden. You are also given an integer limit `d` which represents the maximum difference in height allowed between any two adjacent shrubs. Determine if it is possible to rearrange the shrubs such that the absolute difference in height between any two adjacent shrubs does not exceed `d`. If it is possible, return _a rearranged array_ that meets the condition. If there are multiple valid solutions, return any one of them. If it is not possible, return an empty list.","solution":"def rearrange_shrubs(arr, d): Rearranges the shrubs such that the absolute difference in height between any two adjacent shrubs does not exceed d. If it is not possible, returns an empty list. arr_sorted = sorted(arr) for i in range(1, len(arr_sorted)): if abs(arr_sorted[i] - arr_sorted[i - 1]) > d: return [] return arr_sorted"},{"question":"Given a list of `n` integers representing the elements of a sequence, determine whether the sequence can be sorted into non-decreasing order by performing at most one segment reversal. A segment reversal means choosing two indices `i` and `j` (where `1 <= i <= j <= n`) and reversing the order of the elements between those indices, inclusive. Implement a function that returns `true` if the sequence can be sorted into non-decreasing order by at most one segment reversal, and `false` otherwise.","solution":"def can_sort_by_one_reversal(arr): Determines whether the sequence can be sorted into non-decreasing order by performing at most one segment reversal. n = len(arr) # Identify the first segment that is out of order i = 0 while i < n - 1 and arr[i] <= arr[i + 1]: i += 1 # If the whole array is already sorted if i == n - 1: return True # Identify the last segment that is out of order j = n - 1 while j > 0 and arr[j] >= arr[j - 1]: j -= 1 # Reverse the segment arr[i:j+1] arr[i:j+1] = arr[i:j+1][::-1] # Check if the array is sorted after the reversal return arr == sorted(arr)"},{"question":"You are given a string `s` containing only lowercase letters. You need to partition `s` into one or more substrings such that each letter appears in at most one substring. Return _a list of integers representing the lengths of these substrings._ The partition should be done in a way that the substrings are as long as possible while still satisfying the above condition. For example, if `s = \\"ababcbacadefegdehijhklij\\"`, the output is `[9, 7, 8]` because the partition is `{\\"ababcbaca\\", \\"defegde\\", \\"hijhklij\\"}`. Given a string `s`, return _a list of integers representing the lengths of the longest possible substrings such that each letter appears in at most one substring_.","solution":"def partition_labels(s): Returns a list of integers representing the lengths of the longest possible substrings, such that each letter appears in at most one substring. last_occurrences = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrences[char]) if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"Given a string `s` and a dictionary of words `wordDict`, compose all possible sentences where every word is a valid dictionary word, and words are concatenated without any intervening spaces. Each word in the dictionary can be used multiple times in the formation process. Return _a sorted list of all possible sentences._ Each sentence should be sorted in lexicographical order. For example, given `s = \\"catsanddog\\"` and `wordDict = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]`, one possible output would be `[\\"cat sand dog\\", \\"cats and dog\\"]`.","solution":"def wordBreak(s, wordDict): # Helper function for DFS def backtrack(start, path): if start == len(s): result.append(\' \'.join(path)) return for end in range(start + 1, len(s) + 1): word = s[start:end] if word in wordDict: backtrack(end, path + [word]) wordDict = set(wordDict) # Convert list to set for faster lookups result = [] backtrack(0, []) return sorted(result)"},{"question":"You are given a circular array `nums` of positive integers. The circular array nature means that the next element of the last element is the first element. Implement a function that returns the next greater number for each element in the array. The next greater number of a number `x` is the first greater number to its traversal-order next in the array, which means you could search circularly to find its next greater number. If the next greater number does not exist, output -1 for this number.","solution":"def nextGreaterElements(nums): Returns the next greater number for each element in the circular array nums. Args: nums: List[int] - a circular array of positive integers. Returns: List[int] - a list of the next greater numbers for each element in nums. n = len(nums) result = [-1] * n stack = [] for i in range(2 * n): while stack and nums[stack[-1]] < nums[i % n]: result[stack.pop()] = nums[i % n] if i < n: stack.append(i) return result"},{"question":"Given an integer array `arr`, return the length of the longest subarray that contains an equal number of occurrences of the two integers `0` and `1`.","solution":"def longest_equal_subarray(arr): Returns the length of the longest subarray that contains an equal number of occurrences of the two integers 0 and 1. :param arr: List[int] - input array consisting of integers 0 and 1 :return: int - length of the longest subarray with equal 0\'s and 1\'s count_map = {0: -1} count = 0 max_length = 0 for i, num in enumerate(arr): if num == 0: count -= 1 else: count += 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"You are given an array `rooms` where `rooms[i]` is a list of integers representing the keys in the `i-th` room. Initially, you start with all rooms locked except for room `0`. Each key in the room represents a room that you can unlock. From each room, you can only use the keys found in that room to unlock other rooms. Your task is to determine if you can visit all the rooms. Return `true` if you can visit all the rooms and `false` otherwise.","solution":"def can_visit_all_rooms(rooms): Determines if all rooms can be visited starting from room 0. visited = set() stack = [0] while stack: room = stack.pop() if room not in visited: visited.add(room) for key in rooms[room]: if key not in visited: stack.append(key) return len(visited) == len(rooms)"},{"question":"Given a list of integers `nums` representing a non-negative binary number where each digit is stored from the most significant bit to the least significant bit, return the next binary number as a list of integers. For example, given `nums = [1,0,1,1]`, the output should be `[1,1,0,0]`, which represents the binary number 1011 incremented by 1.","solution":"def increment_binary_number(nums): Given a list of integers representing a non-negative binary number where each digit is stored from the most significant bit to the least significant bit, return the next binary number as a list of integers. length = len(nums) # Starting from the least significant bit for i in range(length - 1, -1, -1): if nums[i] == 0: nums[i] = 1 return nums else: nums[i] = 0 # If all bits were 1, then the result will be 1 followed by all 0s return [1] + nums"},{"question":"You are given a binary tree where each node contains an integer value. Design an algorithm to find the largest unique path from the root node to any leaf node. A path is defined as unique if no two nodes in this path have the same value. Your function should return the length of this largest unique path, or 0 if no such path exists. For example, given the following binary tree: ``` 5 / 4 6 / / 4 1 7 / / 2 3 9 ``` The largest unique path has the length of 4, which can be the path `5 -> 6 -> 1 -> 3`. Another valid path can be `5 -> 6 -> 7 -> 9`. (Note: Remember to handle the constraints where the input tree could be NULL and each node value is guaranteed to be unique.)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_unique_path(root): def dfs(node, path_set): if not node: return len(path_set) if node.val in path_set: return len(path_set) path_set.add(node.val) left_length = dfs(node.left, path_set) right_length = dfs(node.right, path_set) path_set.remove(node.val) return max(left_length, right_length) if not root: return 0 return dfs(root, set())"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `x`. In one operation, you can replace any element of the array with an integer `y` such that `1 <= y <= x`. Return _the minimum number of operations required to make all the elements of the array the same_.","solution":"def min_operations_to_make_equal(arr, x): from collections import Counter # Count the occurrences of each element in the array count = Counter(arr) # Find the maximum frequency of any element max_freq = max(count.values()) # Number of operations needed is total elements minus highest frequency element\'s count min_operations = len(arr) - max_freq return min_operations"},{"question":"Design a data structure that supports adding a new number, finding the median, and querying the k-th smallest element in constant time. Implement the `MedianKth` class: - `MedianKth()` initializes the data structure object. - `void addNum(int num)` adds the integer `num` to the data structure. - `double findMedian()` returns the median of all elements added so far. - `int findKthSmallest(int k)` returns the k-th smallest element added so far. You must implement a solution with `O(1)` time complexity for each function.","solution":"class MedianKth: def __init__(self): self.data = [] def addNum(self, num: int) -> None: self.data.append(num) self.data.sort() def findMedian(self) -> float: n = len(self.data) if n % 2 == 1: return self.data[n // 2] else: return (self.data[n // 2 - 1] + self.data[n // 2]) / 2.0 def findKthSmallest(self, k: int) -> int: return self.data[k - 1]"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to return _the k-th smallest element in the array_. Note that it is the k-th smallest element in the sorted order, not the k-th distinct element. Write a function that finds this element efficiently.","solution":"import heapq def kth_smallest_element(nums, k): Returns the k-th smallest element in the array nums. if not nums or k < 1 or k > len(nums): return None return heapq.nsmallest(k, nums)[-1]"},{"question":"You are given a 2D integer array `events` where each `events[i] = [starti, endi, valuei]` denotes an event that starts at `starti` and ends at `endi`, with a value of `valuei` you can gain by attending the event. You can attend an event if you are present during the entire event time (from the start time to the end time). You are given an integer `k` which represents the maximum number of non-overlapping events you can attend. Your task is to find the maximum value you can accumulate by attending up to `k` non-overlapping events. Return _the maximum value you can achieve_.","solution":"from bisect import bisect_right from functools import lru_cache def maxValue(events, k): # Sort events by ending time events.sort(key=lambda x: x[1]) # Extract the end times for binary search usage end_times = [event[1] for event in events] @lru_cache(None) def dp(index, remaining): # No events left or no remaining slots to attend events if index == len(events) or remaining == 0: return 0 # Option 1: Skip the event at current index max_val = dp(index + 1, remaining) # Option 2: Attend the event at current index next_index = bisect_right(end_times, events[index][1]) max_val = max(max_val, events[index][2] + dp(next_index, remaining - 1)) return max_val return dp(0, k)"},{"question":"Given an array of integers `nums`, find the **shortest** subarray whose sum is **equal** to a given integer `k`. If such a subarray does not exist, return `-1`. Return the length of the shortest subarray.","solution":"def shortest_subarray_with_sum(nums, k): Finds the length of the shortest subarray whose sum is equal to k. Returns -1 if such a subarray does not exist. n = len(nums) if n == 0: return -1 sums = {0: -1} # Dictionary to store the prefix sums current_sum = 0 min_length = float(\'inf\') for i in range(n): current_sum += nums[i] if current_sum - k in sums: min_length = min(min_length, i - sums[current_sum - k]) # store the index only if it\'s not already in the map to keep the shortest subarray if current_sum not in sums: sums[current_sum] = i return min_length if min_length != float(\'inf\') else -1"},{"question":"Given two strings `pattern` and `text`, determine if `text` follows the given `pattern`. Each character in the `pattern` only represents a single word in `text`. For example, if `pattern = \\"abba\\"` and `text = \\"dog cat cat dog\\"`, then the `text` follows the pattern because it maps \'a\' to \\"dog\\" and \'b\' to \\"cat\\". Return `true` if `text` follows the pattern, otherwise return `false`. Consider that `text` and `pattern` may only contain lowercase English letters, and words in `text` are separated by a single space.","solution":"def word_pattern(pattern, text): Determine if text follows the given pattern. :param pattern: A string representing the pattern. :param text: A string where words are separated by spaces. :return: True if text follows the pattern, False otherwise. words = text.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p in char_to_word: if char_to_word[p] != w: return False else: char_to_word[p] = w if w in word_to_char: if word_to_char[w] != p: return False else: word_to_char[w] = p return True"},{"question":"You are given an integer array `arr` and a positive integer `x`. Find the minimum number of operations needed to reduce the sum of the array by at least `x`. In one operation, you can remove any one element from the array. If it is not possible to achieve the reduction, return `-1`.","solution":"def min_operations_to_reduce_sum(arr, x): Returns the minimum number of operations needed to reduce the sum of the array by at least x. In one operation, you can remove any one element from the array. If it is not possible to achieve the reduction, return -1. total_sum = sum(arr) if total_sum < x: return -1 # Sort the array in descending order to remove the largest elements first arr_sorted = sorted(arr, reverse=True) current_sum = total_sum num_operations = 0 for num in arr_sorted: current_sum -= num num_operations += 1 if current_sum <= total_sum - x: return num_operations return -1"},{"question":"You are given a 0-indexed array of integers `nums` representing the current state of a binary tree serialized in a breadth-first search (BFS) order. Your task is to verify if this array can represent a valid binary search tree (BST). - Implement the function `boolean isValidBST(int[] nums)` that returns `true` if `nums` can form a valid BST, or `false` otherwise. - Remember that a BST is defined as follows: - The left subtree of a node contains only nodes with keys less than the node\'s key. - The right subtree of a node contains only nodes with keys greater than the node\'s key. - Both the left and right subtrees must also be binary search trees. For example: - `isValidBST([10, 5, 15, null, null, 11, 20])` should return `true`. - `isValidBST([10, 5, 15, null, null, 10, 20])` should return `false` because `10` appears twice.","solution":"def isValidBST(nums): Determine if the given array nums can form a valid BST. nums : List[int] : A list representing the current state of a binary tree in BFS order return : bool : True if nums can form a valid BST, False otherwise def validate_recursive(index, low, high): if index >= len(nums) or nums[index] is None: return True value = nums[index] if value <= low or value >= high: return False # Calculate the index for left and right children based on BFS order left_index = 2 * index + 1 right_index = 2 * index + 2 return (validate_recursive(left_index, low, value) and validate_recursive(right_index, value, high)) if not nums: return True return validate_recursive(0, float(\'-inf\'), float(\'inf\'))"},{"question":"You are given a binary tree where each node contains an integer value. Write a function to determine the largest sum of any path such that starting from any node, traveling only downward (lateral moves allowed but not upward) ending at any node including the starting node. The path must contain at least one node, but it does not need to pass through the root. Return _the maximum sum of any path_ in the tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_path_sum(root): max_sum = float(\'-inf\') def helper(node): nonlocal max_sum if not node: return 0 # Find max path sum through the left child left = max(helper(node.left), 0) # Find max path sum through the right child right = max(helper(node.right), 0) # Max path sum through the current node (includes both children paths) current_max = node.value + left + right # Update overall maximum max_sum = max(max_sum, current_max) # Return value for parent call: return node.value + max(left, right) helper(root) return max_sum"},{"question":"You are given a string `s` representing a sentence containing words and spaces. A word is defined as a sequence of non-space characters. Your task is to reverse the order of characters in each word while retaining the white spaces and the initial word order. For example, given the input string `s = \\"This is an example\\"`, the function should return `\\"sihT si na elpmaxe\\"`. Return the modified string.","solution":"def reverse_each_word(s): Reverses the order of characters in each word while retaining the white spaces and the initial word order. Parameters: s (str): A string representing a sentence containing words and spaces. Returns: str: The modified string with each word reversed. return \' \'.join(word[::-1] for word in s.split(\' \'))"},{"question":"Write a function that takes a **binary tree** and returns all root-to-leaf paths as a list of strings. A valid path from root to leaf is represented by a string of node values separated by arrows `\\"->\\"`. A leaf is a node with no children. The binary tree is represented using the following class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` For example, given the binary tree rooted at the node with value `1` and structured as follows: ``` 1 / 2 3 5 ``` You should return the following list: `[\\"1->2->5\\", \\"1->3\\"]`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Returns all root-to-leaf paths of the binary tree rooted at \'root\'. Each path is represented by a string of node values separated by arrows \\"->\\". if not root: return [] def dfs(node, path, paths): if not node: return # Add the current node\'s value to the path path += str(node.val) # If leaf node, add to paths list if not node.left and not node.right: paths.append(path) else: path += \'->\' # Add the separator dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"You are given a string `s` containing only the characters `\'0\'` and `\'1\'`. You can perform at most one operation on the string `s` where you select two adjacent characters and swap them. Your goal is to make the entire string non-decreasing (i.e., all zeros should come before all ones) with this operation. If it\'s possible to do so, return `true`; otherwise, return `false`.","solution":"def can_be_non_decreasing_with_one_swap(s): Determines if the binary string can be made non-decreasing with at most one swap. Parameters: s (str): Input string containing only \'0\' and \'1\' characters. Returns: bool: True if the string can be made non-decreasing with one swap, otherwise False. # Find the first point where the order is not non-decreasing for i in range(len(s) - 1): if s[i] > s[i + 1]: # Check if swapping these two indices will result in a non-decreasing string swapped = s[:i] + s[i + 1] + s[i] + s[i + 2:] return swapped == \'\'.join(sorted(s)) # If no swap needed, it\'s already non-decreasing return True"},{"question":"You are given a string `s` consisting of lowercase English letters and a string `t` consisting of unique lowercase English letters. Your goal is to determine the minimum number of times you need to delete a character from `s` to make it a subsequence of `t`. Return _the minimum number of deletions required to make `s` a subsequence of `t`_.","solution":"def min_deletions_to_subsequence(s, t): Returns the minimum number of deletions required to make `s` a subsequence of `t`. n = len(s) m = len(t) # Find the length of the Longest Common Subsequence (LCS) def lcs(s, t, n, m): # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] lcs_length = lcs(s, t, n, m) # The minimum deletions needed is the length of `s` minus the length of LCS return n - lcs_length"},{"question":"You are given an array of integers `nums` where the `i-th` integer represents the color of the `i-th` house. You need to paint all the houses such that no two adjacent houses have the same color, and each house should be painted with a color represented in the array `colors`, which is also given as input. Return _the minimum number of changes required_ to achieve this condition if changes can only be made to the houses\' color in `nums`. If it is not possible, return `-1`.","solution":"def min_changes_to_paint_houses(nums, colors): n = len(nums) color_set = set(colors) if not all(color in color_set for color in nums): return -1 dp = [[float(\'inf\')] * len(color_set) for _ in range(n)] color_index = {color: idx for idx, color in enumerate(colors)} for i in range(n): for c in colors: if i == 0: dp[i][color_index[c]] = 0 if nums[i] == c else 1 else: for prev_c in colors: if c != prev_c: dp[i][color_index[c]] = min(dp[i][color_index[c]], dp[i-1][color_index[prev_c]] + (1 if nums[i] != c else 0)) min_changes = min(dp[n-1]) return min_changes if min_changes != float(\'inf\') else -1"},{"question":"You are given two arrays of integers, `arr1` and `arr2`, each of length `n`. You want to create a new array `result` of length `n` such that `result[i] = max(arr1[i], arr2[i])`. However, you can perform a single operation where you select any contiguous subarray `subarr` of `arr1` and any contiguous subarray `subarr` of `arr2` of the same length, and swap these subarrays. Return _the maximum possible sum of the `result` array after performing at most one subarray swap._","solution":"def max_possible_sum_after_one_swap(arr1, arr2): def max_sum(arr1, arr2): return sum(max(arr1[i], arr2[i]) for i in range(len(arr1))) n = len(arr1) max_sum_result = max_sum(arr1, arr2) # Initial max sum without any swaps max_sum_after_swap = max_sum_result for i in range(n): for j in range(i, n): # Create copies to perform swap between arr1[i:j+1] and arr2[i:j+1] new_arr1 = arr1[:i] + arr2[i:j+1] + arr1[j+1:] new_arr2 = arr2[:i] + arr1[i:j+1] + arr2[j+1:] current_max_sum = max_sum(new_arr1, new_arr2) max_sum_after_swap = max(max_sum_after_swap, current_max_sum) return max_sum_after_swap"},{"question":"Given a string `str`, determine if it can be permuted to form a palindrome. A palindrome is a string that reads the same forward and backward. Only strings with at most one character having an odd count of occurrences can be permuted to form a palindrome. Return _true if `str` can be permuted to form a palindrome, and false otherwise._","solution":"def can_permute_to_palindrome(s): Determines if the input string can be permuted to form a palindrome. :param s: The input string :return: True if the string can be permuted to form a palindrome, False otherwise from collections import Counter count = Counter(s) odd_count = sum(1 for x in count.values() if x % 2 != 0) return odd_count <= 1"},{"question":"We have an array of integers `arr` of length `n` and an integer `threshold`. A contiguous subarray within this array is called a \\"good\\" subarray if the sum of its elements is less than or equal to `threshold`. Your task is to find the length of the longest \\"good\\" subarray. Return the length of the longest \\"good\\" subarray.","solution":"def longest_good_subarray(arr, threshold): Returns the length of the longest \\"good\\" subarray. n = len(arr) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] # add the current element to the window # shrink the window until the current sum is within the threshold while current_sum > threshold and start <= end: current_sum -= arr[start] start += 1 # update the max length if the current window is \\"good\\" max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a string `s` which consists of lowercase alphabets and an integer `n`. Split the string `s` into `n` parts such that each part has an equal number of characters. If the string cannot be evenly split, then add the character `\'_\'` at the end of the last part until all parts have equal length. Return an array of `n` strings having equal lengths.","solution":"def split_string(s, n): Splits the string `s` into `n` parts such that each part has an equal number of characters. If the string cannot be evenly split, then adds the character \'_\' at the end of the last part until all parts have equal length. Parameters: s (str): The input string consisting of lowercase alphabets. n (int): The number of parts to split the string into. Returns: list[str]: A list of `n` strings having equal length. if n <= 0: return [] # Calculate the length of each part part_length = (len(s) + n - 1) // n parts = [] for i in range(n): start_index = i * part_length end_index = start_index + part_length part = s[start_index:end_index] # If the part is shorter than required length, pad with \'_\' if len(part) < part_length: part += \'_\' * (part_length - len(part)) parts.append(part) return parts"},{"question":"You are given a string `s` containing lowercase English letters and an integer `k`. You need to partition the string into `k` contiguous substrings such that the number of distinct characters in each substring is maximized, and no two substrings share any common character. Return _the **maximum number** of distinct characters found in the partition where this maximum is minimized across the substrings._ For example, given the string `s = \\"abac\\"` and `k = 2`, you can partition the string into [\\"ab\\", \\"ac\\"], which results in substrings with distinct characters of 2 and 2 each, so the output should be 2.","solution":"def max_min_distinct_chars_partition(s, k): from collections import Counter if k > len(s): return 0 # Not possible to partition into more parts than characters char_count = Counter(s) distinct_count = len(char_count) if k >= distinct_count: return 1 # Each part will have at least one distinct character return distinct_count // k + (1 if distinct_count % k != 0 else 0)"},{"question":"You are given a list of integers `nums` where each integer represents a course completion time in days. Every course can be taken only once, and once you start a course, you must complete it without taking any other course in between. However, you can study for multiple courses simultaneously. You are also given an integer `k`, which represents the maximum number of simultaneous courses you can study at any given time. Implement a function `minimumTime(int[] nums, int k)` that returns the minimum number of days required to complete all courses under the given constraints. A day is only counted once, regardless of how many courses you study simultaneously on that day.","solution":"def minimumTime(nums, k): Returns the minimum number of days required to complete all courses given that you can study at most k courses simultaneously in a day. :param nums: List[int] - List of integers representing course completion times in days :param k: int - Maximum number of simultaneous courses one can study :return: int - Minimum number of days required to complete all courses nums.sort(reverse=True) days = 0 while nums: days += 1 for _ in range(k): if nums: nums.pop(0) return days"},{"question":"You are given a list of integers representing the elevation of terrain at different points along a horizontal line, with each integer representing a unit elevation at that point. You are tasked with trapping rainwater after it rains over the terrain. The water will fill the voids between the peaks of the elevation terrain. Write a function that takes a list of non-negative integers representing the elevation map and returns the total amount of rainwater that can be trapped after raining. The input list `heights` represents the elevation map, where `heights[i]` is the elevation at point `i`. Return _the total units of trapped rainwater_.","solution":"def trap_rain_water(heights): Calculate the total amount of rainwater trapped given an elevation map. :param heights: List[int] - A list of non-negative integers where heights[i] represents the elevation at point i. :return: int - The total units of trapped rainwater. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"You are given a **non-negative integer** `num`. The integer can be written in various ways as the sum of **distinct** non-negative integers. For example, if `num = 4`, it can be written as `4`, `3 + 1`, or `2 + 1 + 1`. Each representation corresponds to a **different** set of distinct integers. Your task is to return the total number of unique sets of distinct integers that sum to `num`. Note that the order of the integers in the set does not matter.","solution":"def count_sum_ways(num): Returns the number of unique sets of distinct non-negative integers that sum to num. dp = [0] * (num + 1) dp[0] = 1 for i in range(1, num + 1): for j in range(i, num + 1): dp[j] += dp[j - i] return dp[num]"},{"question":"Given a string `s`, you can perform the following operations: 1. Remove any single character from the string. 2. Remove any two adjacent characters if they are identical. Return the _minimum number of operations needed to make the string empty_.","solution":"def min_operations_to_empty_string(s): stack = [] for char in s: if stack and stack[-1] == char: # Remove the last character in stack if it is the same as current character stack.pop() else: # Add the current character to the stack stack.append(char) # If stack is empty, each pair matched and cancelled out # If not, single removals will still be needed for remaining characters return len(stack)"},{"question":"Given a binary tree, write a function to return all root-to-leaf paths. Each path should be represented as a string formed by joining the node values with a \\"->\\" character. The function should handle various tree structures including imbalanced trees. Implement the function: - `List<String> binaryTreePaths(TreeNode root)`: returns a list of all root-to-leaf paths in the binary tree. Where `TreeNode` is defined as: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` Example: ``` Input: [1, 2, 3, null, 5] 1 / 2 3 5 Output: [\\"1->2->5\\", \\"1->3\\"] ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binaryTreePaths(root): Returns a list of all root-to-leaf paths in the binary tree. Each path is represented as a string formed by joining the node values with \\"->\\". if not root: return [] def dfs(node, path, paths): if not node: return path += str(node.val) if not node.left and not node.right: paths.append(path) else: path += \\"->\\" dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"Given a string `s` representing a valid path in a file system (Unix-style), simplify the path following these rules: - Any `\\".\\"` or current directory token should be ignored. - Any `\\"..\\"` token moves up to the parent directory, if not in the root directory. - Any other tokens are directory names and should be appended to the output path. Return the simplified canonical path as a string. For example, given `s = \\"/home//foo/../bar/./baz/..\\"`, the simplified canonical path should be `/home/bar`.","solution":"def simplify_path(path): Simplifies a given Unix-style path to its canonical form. stack = [] parts = path.split(\'/\') for part in parts: if part == \\"..\\": if stack: stack.pop() elif part and part != \\".\\": stack.append(part) return \\"/\\" + \\"/\\".join(stack)"},{"question":"You are given a string `s` and an array `weights` of integers where `weights[i]` is the weight of the character `s[i]`. Define the **weight** of a substring as the sum of the weights of its characters. You need to find the weight of the heaviest substring you can obtain by deleting exactly one character from `s`. Return _the **maximum** weight of such a substring_. Note: Assume the string `s` has at least two characters.","solution":"def max_weight_substring(s, weights): Returns the maximum weight of a substring that can be obtained by deleting exactly one character from `s`. :param s: String `s` :param weights: List of integers `weights` where weights[i] is the weight of s[i] :return: Maximum weight of the substring total_weight = sum(weights) min_weight = min(weights) return total_weight - min_weight"},{"question":"You are given a list of `events` where each event is a pair of [startTime, endTime], representing an event that starts at `startTime` and ends at `endTime`. You are also given an integer `duration`. An event is considered valid if it lasts at least `duration` units of time. Your task is to return the maximum number of valid events that can be attended without any overlap. In other words, if you attend an event, you cannot attend another event that starts before the current one ends. Develop a function that takes in the list of `events` and the integer `duration`, and returns the maximum number of valid, non-overlapping events that can be attended.","solution":"def max_valid_events(events, duration): Returns the maximum number of valid, non-overlapping events that can be attended. Parameters: events (list of tuples): List of events where each event is represented as a tuple (startTime, endTime). duration (int): Minimum duration an event must last to be considered valid. Returns: int: Maximum number of valid, non-overlapping events that can be attended. # Filter events to keep only those that last at least `duration` units of time. valid_events = [(start, end) for start, end in events if end - start >= duration] # Sort the valid events by their end time valid_events.sort(key=lambda x: x[1]) # Initialize the count of maximum events and the end time of the last attended event count, last_end_time = 0, float(\'-inf\') for start, end in valid_events: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"Write a function that takes a list of integers `nums` and determines if there exists a subset of the list with a sum equal to a given target value `target`. Return `true` if such a subset exists, otherwise return `false`.","solution":"def subset_sum(nums, target): Determine if there exists a subset of the list nums with a sum equal to target. n = len(nums) dp = [[False] * (target + 1) for _ in range(n + 1)] # Initializing dp[0][0] as True dp[0][0] = True for i in range(1, n + 1): for t in range(target + 1): dp[i][t] = dp[i-1][t] or (t >= nums[i-1] and dp[i-1][t-nums[i-1]]) return dp[n][target]"},{"question":"You are given a `tree` represented as an array where each element represents the parent node of the corresponding node in the tree. The root node is represented by `-1`. Write a function that returns the maximum depth of the tree. The depth of a node is the number of edges on the longest path from that node to a leaf. The depth of the root node is `0`. For example, given the array `[ -1, 0, 0, 1, 1, 2, 2 ]`, the tree structure is as follows: ``` 0 / 1 2 / / 3 4 5 6 ``` 1. The root node `0` has depth `0`. 2. Nodes `1` and `2` have depth `1`. 3. Nodes `3`, `4`, `5`, and `6` have depth `2`. The maximum depth of this tree is `2`. Your task is to return this value.","solution":"def max_depth(tree): Calculates the maximum depth of the tree represented as array. Args: tree: List[int] - A list where each element represents the parent node of the corresponding node. Returns: int - The maximum depth of the tree. depths = [-1] * len(tree) def get_depth(node): if tree[node] == -1: return 0 if depths[node] != -1: return depths[node] depths[node] = 1 + get_depth(tree[node]) return depths[node] max_depth = 0 for node in range(len(tree)): max_depth = max(max_depth, get_depth(node)) return max_depth"},{"question":"Given an array of integers `arr` and an integer `k`, find the number of subarrays (continuous sub-sequences) whose sum is exactly `k`. The input will contain an integer array `arr` and the integer `k`. Return the integer count of such subarrays. You can assume each element of the array is an integer and the array is non-empty.","solution":"def subarray_sum(arr, k): Finds the number of subarrays whose sum is exactly k. :param arr: List[int] - the input array of integers :param k: int - the target sum for subarrays :return: int - the count of subarrays whose sum is exactly k count = 0 current_sum = 0 prefix_sum = {0: 1} for num in arr: current_sum += num if (current_sum - k) in prefix_sum: count += prefix_sum[current_sum - k] if current_sum in prefix_sum: prefix_sum[current_sum] += 1 else: prefix_sum[current_sum] = 1 return count"},{"question":"Given a string `str` consisting of lowercase English letters, write a function to find the first non-repeating character in it and return its index. If it does not exist, return `-1`. You must solve it in O(n) time and use constant extra space.","solution":"def first_non_repeating_character(s): Find the first non-repeating character in a string and return its index. If no such character exists, return -1. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"You are given a string `s` representing a mathematical expression containing only non-negative integers and the operators `+`, `-`, `*`, and `/` (addition, subtraction, multiplication, and integer division). The expression is guaranteed to be valid and does not contain any parentheses. Return the result of evaluating the expression. Note that: - The integer division should truncate toward zero. - You may assume that the given expression will always be valid and will not lead to division by zero. - The expression will not contain any whitespace. - The length of the input string and the values of the numbers involved are sufficiently small so that they can fit within the standard data type ranges. **Example:** - Input: `\\"3+2*2\\"` - Output: `7`","solution":"def evaluate_expression(s): Evaluate a mathematical expression containing only non-negative integers and the operators +, -, *, and /. The integer division should truncate toward zero. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == \'+\': operands.append(a + b) elif operator == \'-\': operands.append(a - b) elif operator == \'*\': operands.append(a * b) elif operator == \'/\': operands.append(int(a / b)) # int() truncates toward zero def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 operands = [] operators = [] i = 0 while i < len(s): if s[i].isdigit(): num = 0 while i < len(s) and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 operands.append(num) i -= 1 else: while (operators and precedence(operators[-1]) >= precedence(s[i])): apply_operator(operands, operators.pop()) operators.append(s[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[-1]"},{"question":"Given a string `s` representing a sentence containing words separated by spaces, write a function to reverse the order of characters in each word while maintaining the order of words and the space between them. The input string `s` consists of lowercase and uppercase English letters and spaces only. Return _the resulting string after the reversal_. Ensure that the string contains no leading or trailing spaces and that there is only one space between each pair of words. For example: - Input: `s = \\"hello world\\"` - Output: `\\"olleh dlrow\\"` - Input: `s = \\"OpenAI is awesome\\"` - Output: `\\"IAnepo si emosewa\\"` The words in the sentence should be reversed as a whole unit, and not individually within each word.","solution":"def reverse_words(s): Reverses the order of characters in each word while maintaining the order of words and spaces. Parameters: s (str): The input sentence consisting of words and spaces. Returns: str: The sentence with each word\'s characters reversed. return \' \'.join([word[::-1] for word in s.split(\' \')])"},{"question":"Given an array of integers `ages` representing the ages of attendees in a room, you need to split the attendees into two groups based on their ages. The goal is to minimize the absolute difference in the total sums of the ages in the two groups. Return the minimum absolute difference achievable.","solution":"def min_absolute_difference(ages): Splits ages into two groups to minimize the absolute difference in the total sums of the ages in the two groups. total_sum = sum(ages) n = len(ages) dp = [0] * (total_sum // 2 + 1) for age in ages: for j in range(total_sum // 2, age - 1, -1): dp[j] = max(dp[j], dp[j - age] + age) group1_sum = dp[total_sum // 2] group2_sum = total_sum - group1_sum return abs(group1_sum - group2_sum)"},{"question":"You are given a string `s` representing a large integer. Implement an algorithm to remove `k` digits from the string such that the new number is the smallest possible. Return _the resulting string after removing `k` digits_. The string should not contain leading zeros, except the number \\"0\\" itself.","solution":"def removeKdigits(s: str, k: int) -> str: Removes k digits from the string s representing a large integer to produce the smallest possible number. stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) while k > 0: stack.pop() k -= 1 result = \'\'.join(stack).lstrip(\'0\') if not result: # If the result is an empty string, return \'0\' return \'0\' return result"},{"question":"Given a string `s`, return the length of the longest substring where each character appears at least `k` times. If no such substring exists, return 0. Ensure that your algorithm handles edge cases where `s` is empty or contains fewer than `k` unique characters efficiently. Your solution should aim for an optimal time complexity.","solution":"def longestSubstring(s, k): Returns the length of the longest substring where each character appears at least k times. def longest_substring_util(s, k, start, end): if end - start < k: return 0 char_count = {} for i in range(start, end): char_count[s[i]] = char_count.get(s[i], 0) + 1 for mid in range(start, end): if char_count[s[mid]] < k: next_mid = mid + 1 while next_mid < end and char_count[s[next_mid]] < k: next_mid += 1 return max(longest_substring_util(s, k, start, mid), longest_substring_util(s, k, next_mid, end)) return end - start return longest_substring_util(s, k, 0, len(s))"},{"question":"Given a binary tree, return _an array of the tree\'s values in level order traversal_. A binary tree is defined as a structure in which each node has at most two children, referred to as the left child and the right child. A level order traversal visits nodes in their left-to-right order at each level of the tree, starting from the root level down to the lowest level.","solution":"import collections class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root): Returns a list of tree\'s values in level order traversal. if not root: return [] result = [] queue = collections.deque([root]) while queue: node = queue.popleft() result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"Given a string `s` consisting of printable ASCII characters, write a function to determine if it is possible to rearrange the characters in `s` such that every two adjacent characters are different. If possible, return one possible rearrangement. Otherwise, return an empty string.","solution":"from collections import Counter import heapq def rearrange_string(s): if not s: return \\"\\" # Count the frequency of each character counter = Counter(s) # Use a max heap to store the characters based on their frequency (as -ve because heapq is min-heap) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) # Previous element initialized to something that isn\'t any character in s prev_freq, prev_char = 0, \'\' result = [] # Process the heap while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If previous character can still be used, add it back to the heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update previous element to the current one prev_freq, prev_char = freq + 1, char # Increment freq because we use one occurrence of char # If the rearranged string length is not equal to the original string, it means it wasn\'t possible if len(result) != len(s): return \\"\\" return \'\'.join(result)"},{"question":"You are given a list of `n` special integers and an integer `k`. All special integers can be divided into at most `k` groups where each group has at least one special integer. All the integers in a group have the same pairwise greatest common divisor (GCD). You need to find the minimum value of the greatest common divisor (GCD) for any group. Return the minimum possible GCD after dividing the numbers into at most `k` groups.","solution":"import math from functools import reduce def find_min_gcd(arr, k): Return the minimum possible GCD after dividing the numbers into at most k groups. Parameters: arr (list): List of n special integers. k (int): Number of groups. Returns: int: Minimum GCD value for any group. def gcd(a, b): return math.gcd(a, b) total_gcd = reduce(gcd, arr) return total_gcd"},{"question":"Given an array of integers `nums`, return the **maximum length** of a subarray that contains an equal number of `0`s and `1`s. Note: - The subarray has to be contiguous and its length should be the maximum possible among all such subarrays with equal 0\'s and 1\'s.","solution":"def findMaxLength(nums): count = 0 count_map = {0: -1} max_length = 0 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"A **binary gap** within a positive integer `n` is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of `n`. For example, the number `9` has a binary representation of `1001` and contains a binary gap of length `2`. The number `529` has a binary representation of `1000010001` and contains two binary gaps, of lengths `4` and `3`. Given a positive integer `n`, return _the length of its longest binary gap_. If there are no binary gaps, return `0`.","solution":"def longest_binary_gap(n): Returns the length of the longest binary gap within a positive integer n. # Convert the number to its binary representation binary_representation = bin(n)[2:] # Split the binary representation by \'1\' to find the gaps gaps = binary_representation.strip(\'0\').split(\'1\') # The length of each gap is the length of each element in `gaps` gap_lengths = [len(gap) for gap in gaps] # Return the maximum gap length or 0 if no gaps are found return max(gap_lengths) if gap_lengths else 0"},{"question":"You are given an `m x n` binary matrix `mat` where `0` represents an empty cell and `1` represents an obstacle. You are also given an integer `k`, the maximum number of obstacles you can remove. Return _the minimum number of steps to walk from the upper left corner `(0, 0)` to the lower right corner `(m-1, n-1)` on a path that may not cross obstacles more than `k` times_. If it is not possible to find such a path, return `-1`.","solution":"from collections import deque def min_steps_to_walk(mat, k): Returns the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m-1, n-1) in a binary matrix mat where you can remove up to k obstacles. m, n = len(mat), len(mat[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n # BFS setup queue = deque([(0, 0, 0, k)]) # (x, y, steps, remaining obstacles to remove) visited = set((0, 0, k)) while queue: x, y, steps, remaining_k = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: new_x, new_y = x + dx, y + dy if is_valid(new_x, new_y): new_k = remaining_k - mat[new_x][new_y] state = (new_x, new_y, new_k) if new_k >= 0 and state not in visited: visited.add(state) queue.append((new_x, new_y, steps + 1, new_k)) return -1"},{"question":"Write a function `findRedundantConnection` that finds an edge in an undirected graph that can be removed so that the resulting graph is still connected and has no cycles. The input graph is given as an array `edges` of length `n` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` nodes. Each node has an integer value from `1` to `n`. The input graph has at least one redundant connection. The function should return the edge that can be removed to make the graph a tree of `n` nodes. If there are multiple answers, return the edge that appears last in the input array. **Notes:** - The answer edge `[a,b]` should be in the same format as the input `edges[i]`. - The graph is guaranteed to be connected, and there will be exactly one redundant connection.","solution":"def findRedundantConnection(edges): Find the redundant connection in the graph that can be removed so that the resulting graph is still connected and has no cycles. :param edges: List of edges in the graph. :return: The edge that is redundant. parent = list(range(len(edges) + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX == rootY: return False parent[rootX] = rootY return True for edge in edges: if not union(edge[0], edge[1]): return edge"},{"question":"You are given a string `s` which consists of only lowercase English letters. Return _the length of the shortest palindrome you can obtain by adding characters in front of_ `s`. A **palindrome** is a string that reads the same forwards and backwards. For example, if the input is `race`, you can add characters in front to form the palindrome `ecarace` to get a palindrome of length 7.","solution":"def shortest_palindrome_length(s): Returns the length of the shortest palindrome that can be done by adding characters in front of the string s. if s == s[::-1]: return len(s) # Find the longest palindromic prefix for i in range(len(s), -1, -1): if s[:i] == s[:i][::-1]: break # Number of characters that need to be added in the front to make it a palindrome return 2 * len(s) - i"},{"question":"Given a `m x n` grid `grid` consisting of non-negative integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it can trap after raining. Water can only be trapped in the non-boundary cells and is only trapped if all the surrounding heights are greater than the current cell height. Return the total water volume trapped. For example, given the elevation map: ``` [ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1] ] ``` The total volume of water trapped is `4`.","solution":"import heapq def trapRainWater(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Min-heap to keep track of the cells based on height. heap = [] visited = [[False] * n for _ in range(m)] # Add all boundary cells to the heap and mark them visited. for i in range(m): heapq.heappush(heap, (grid[i][0], i, 0)) heapq.heappush(heap, (grid[i][n-1], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(n): heapq.heappush(heap, (grid[0][j], 0, j)) heapq.heappush(heap, (grid[m-1][j], m-1, j)) visited[0][j] = True visited[m-1][j] = True # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] trapped_water = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: trapped_water += max(0, height - grid[nx][ny]) heapq.heappush(heap, (max(height, grid[nx][ny]), nx, ny)) visited[nx][ny] = True return trapped_water"},{"question":"Given a binary tree, imagine each node contains an integer value. Write a function to determine if the tree contains a root-to-leaf path that sums to a given target value. A root-to-leaf path is defined as any path starting from the root and ending at any leaf node, with each node in the path contributing to the sum. You may assume that the given target value is always a non-negative integer. Return `true` if such a path exists, otherwise return `false`. Example: ``` Input: root = [5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1], target = 22 Output: true Explanation: The root-to-leaf path with sum 22 is 5 -> 4 -> 11 -> 2. ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root, targetSum): Determines if there is a root-to-leaf path in the binary tree with the given target sum. if not root: return False # If we reach a leaf node, check if this path sums to targetSum if not root.left and not root.right: return root.val == targetSum # Subtract the current node\'s value from the target sum and continue to search in the left and right subtrees targetSum -= root.val return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)"},{"question":"You are given a **0-indexed** integer array `prices` where `prices[i]` represents the price of a ticket on day `i`. There is also a **positive integer `k`**. You want to buy and sell tickets in such a way that you maximize your profit, given the following conditions: - You can complete at most `k` transactions. - A transaction is defined as buying a ticket on one day and selling it on a later day. - You cannot engage in multiple transactions simultaneously (i.e., you must sell the ticket before you buy another one). Return _the **maximum profit** you can achieve under these conditions._","solution":"def maxProfit(k, prices): n = len(prices) if n == 0: return 0 if k >= n // 2: return sum(x - y for x, y in zip(prices[1:], prices[:-1]) if x > y) profits = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_profit_so_far = -prices[0] for j in range(1, n): profits[i][j] = max(profits[i][j - 1], prices[j] + max_profit_so_far) max_profit_so_far = max(max_profit_so_far, profits[i - 1][j] - prices[j]) return profits[k][n - 1]"},{"question":"You are given a list of strings `words`. Each string S in `words` is composed of lowercase English letters. We\'ll call a string S a \\"valid prefix palindrome\\" if it can be split into two parts (that may be empty), where the first part is a palindrome and the second part is any remaining portion of the string. For each string in the list, identify the length of the longest \\"valid prefix palindrome.\\" Return an array `result` of length `n` where `result[i]` is the length of the longest \\"valid prefix palindrome\\" for the ith string in the input list.","solution":"def is_palindrome(s): Helper function to check if a given string is a palindrome. return s == s[::-1] def longest_valid_prefix_palindrome(words): For each word in the list, find the length of the longest valid prefix palindrome. result = [] for word in words: max_length = 0 for i in range(len(word) + 1): if is_palindrome(word[:i]): max_length = i result.append(max_length) return result"},{"question":"You are given an array of integers `nums` and an integer `k`. You need to find the number of distinct pairs `(i, j)` such that `0 <= i < j < nums.length` and `|nums[i] - nums[j]| == k`. Return _the number of such distinct pairs_.","solution":"def find_pairs(nums, k): Returns the number of distinct pairs (i, j) such that 0 <= i < j < nums.length and |nums[i] - nums[j]| == k. if k < 0: return 0 nums_set = set(nums) count = 0 if k == 0: # If k is 0, we find all elements that appear more than once from collections import Counter num_count = Counter(nums) for num in num_count: if num_count[num] > 1: count += 1 else: # If k is positive, we look for pairs (num, num + k) or (num, num - k) for num in nums_set: if num + k in nums_set: count += 1 return count"},{"question":"You are given an array of distinct integers `nums` representing the locations of stores along a straight street and an integer `k`. Suppose a new store is to be built such that the maximum distance any store has to travel to reach the nearest store is minimized. Determine the optimal location for the new store to achieve this. Return the minimum possible maximum distance.","solution":"def minimize_max_distance(nums, k): Determine the optimal location for a new store such that the maximum distance any store has to travel to reach the nearest store is minimized. Parameters: nums (list of int): Locations of existing stores on the street. k (int): Number of new stores to be built, k is assumed to be 1. Returns: float: The minimum possible maximum distance to the nearest store. sorted_nums = sorted(nums) max_distance = 0 for i in range(len(sorted_nums) - 1): distance = (sorted_nums[i + 1] - sorted_nums[i]) / 2.0 max_distance = max(max_distance, distance) return max_distance"},{"question":"Given a string `s` consisting of lowercase English letters, find the length of the longest substring that contains only unique characters. Your solution should be efficient with a linear time complexity, utilizing two-pointer or sliding window technique. Return the length of the longest unique substring.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_index_map: left = max(char_index_map[s[right]] + 1, left) char_index_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"Implement a function that takes a string as an input and returns `True` if the string is a valid palindrome, and `False` otherwise. A string is considered a valid palindrome if, after ignoring cases, punctuation, and spaces, it reads the same forward and backward.","solution":"import re def is_palindrome(s): Checks if the given string is a valid palindrome, ignoring cases, punctuation, and spaces. # Remove all non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_str == cleaned_str[::-1]"},{"question":"You are given a list of `n` positive integers representing ratings of `n` employees. The employees are standing in a line, and you need to distribute a number of chocolates to each employee such that: - Each employee must get at least one chocolate. - Employees with a higher rating get more chocolates than their neighbors. Write a function to determine the minimum number of chocolates you must give out. Return _the minimum number of chocolates you need to distribute to achieve the above requirements_.","solution":"def min_chocolates(ratings): Calculate the minimum number of chocolates to distribute to employees based on their ratings to ensure that each employee gets at least one chocolate and employees with a higher rating get more chocolates than their neighbors. :param ratings: List[int], list of positive integers representing employee ratings :return: int, the minimum number of chocolates to distribute n = len(ratings) chocolates = [1] * n # Left to right pass, ensuring ratings[i] > ratings[i-1] => chocolates[i] > chocolates[i-1] for i in range(1, n): if ratings[i] > ratings[i - 1]: chocolates[i] = chocolates[i - 1] + 1 # Right to left pass, ensuring ratings[i] > ratings[i + 1] => chocolates[i] > chocolates[i + 1] for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: chocolates[i] = max(chocolates[i], chocolates[i + 1] + 1) return sum(chocolates)"},{"question":"Given an integer array `nums` and an integer `k`, return *the maximum sum of a subarray of length `k`*. A subarray is defined as a contiguous segment of the array. You need to solve this problem using the sliding window technique to ensure a time complexity of O(n). Example: Input: `nums = [1, 4, 2, 10, 23, 3, 1, 0, 20]`, `k = 4` Output: `39` Explanation: Subarray of length 4 with maximum sum is `[4, 2, 10, 23]`, which sums up to 39.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of length k. Parameters: nums (List[int]): The input list of integers. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k. if len(nums) < k or k <= 0: return 0 # Find the initial sum of the first `k` elements current_sum = sum(nums[:k]) max_sum = current_sum # Use sliding window to find the maximum sum for subarrays of length `k` for i in range(k, len(nums)): current_sum = current_sum - nums[i - k] + nums[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given a 2D grid of size m x n and an initial starting coordinate (start_row, start_col) and a target coordinate (target_row, target_col), determine if there is a path for a robot to move from the start position to the target position. The robot can move one step at a time in four directions (up, down, left, right), but cannot move diagonally or off the grid. Some cells in the grid are blocked (represented by 0) and cannot be traversed, while others are open (represented by 1). Return true if there is a path from the start to the target, otherwise, return false.","solution":"def is_path_possible(grid, start_row, start_col, target_row, target_col): Determines if there is a path for a robot to move from the start position to the target position in a 2D grid. :param grid: 2D list of integers (0 = blocked, 1 = open) :param start_row: Starting row coordinate :param start_col: Starting column coordinate :param target_row: Target row coordinate :param target_col: Target column coordinate :return: True if there is a path from start to target, otherwise False if not grid or not grid[0]: return False m, n = len(grid), len(grid[0]) if not (0 <= start_row < m and 0 <= start_col < n): return False if not (0 <= target_row < m and 0 <= target_col < n): return False if grid[start_row][start_col] == 0 or grid[target_row][target_col] == 0: return False directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * n for _ in range(m)] def dfs(r, c): if r == target_row and c == target_col: return True visited[r][c] = True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and grid[nr][nc] == 1: if dfs(nr, nc): return True visited[r][c] = False return False return dfs(start_row, start_col)"},{"question":"You are given a list of `n` items with their respective weights and values. You need to fill a knapsack with a maximum weight capacity of `W` such that the total value of the knapsack is maximized. Note that you can take fractions of an item if the item itself exceeds the knapsack capacity. Return the maximum possible value of items that can be carried in the knapsack.","solution":"def fractional_knapsack(weights, values, capacity): Calculate the maximum value that can be carried in the knapsack with fractional items allowed. Parameters: weights (list): List of weights of the items. values (list): List of values of the items. capacity (int): Maximum capacity of the knapsack. Returns: float: Maximum value that can be carried in the knapsack. # Calculate value to weight ratio for each item value_weight_ratio = [(v/w, w) for v, w in zip(values, weights)] # Sort items by value to weight ratio in descending order value_weight_ratio.sort(reverse=True, key=lambda x: x[0]) total_value = 0.0 for ratio, weight in value_weight_ratio: if capacity - weight >= 0: # Take the whole item total_value += ratio * weight capacity -= weight else: # Take the fraction of the remaining capacity total_value += ratio * capacity break return total_value"},{"question":"Given a string `s` consisting only of characters `\'a\'`, `\'b\'`, and `\'c\'`, rearrange the string such that no two adjacent characters are the same. If it is possible to rearrange the string in this way, return _any valid rearrangement_. If it is not possible, return an empty string.","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s): # Count the frequency of each character counter = Counter(s) # Create a max heap based on counts max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) result = [] prev_char, prev_freq = None, 0 while max_heap: freq, char = heappop(max_heap) # Append current character to the result result.append(char) # If there\'s a prev_char with non-zero frequency, push it back to the heap if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) # Update prev_char and prev_freq prev_char, prev_freq = char, freq + 1 # Check if the result is valid rearranged_str = \'\'.join(result) if len(rearranged_str) != len(s): return \\"\\" return rearranged_str"},{"question":"You are given an **0-indexed** integer array `weights` representing the weights of `n` packages. A truck can only carry packages in non-overlapping trips, where the maximum load it can carry in each trip is `maxLoad`. Each trip can carry any number of packages, as long as their combined weight does not exceed the truck\'s `maxLoad`. Return the _minimum number of trips required to transport all the packages_.","solution":"def min_trips(weights, maxLoad): Returns the minimum number of trips required to transport all the packages. :param weights: List[int] - A list of weights of the packages. :param maxLoad: int - The maximum load the truck can carry in each trip. :return: int - The minimum number of trips required. # Sort the weights in descending order to try and optimize the number of trips weights.sort(reverse=True) trips = 0 # While there are weights left to transport while weights: remaining_load = maxLoad i = 0 # Pick as many packages as possible for the current trip while i < len(weights): if weights[i] <= remaining_load: remaining_load -= weights.pop(i) else: i += 1 trips += 1 return trips"},{"question":"You are given a string `exp` containing a mathematical expression that includes non-negative integers, parentheses, and the operators `+` and `*`. Your task is to parse the expression and return the result of its evaluation, adhering to the usual rules of arithmetic, where multiplication has higher precedence over addition and parentheses can alter precedence. You can assume the input expression is always valid and bounded by the usual constraints.","solution":"def evaluate_expression(exp): Evaluates a mathematical expression containing non-negative integers, parentheses, and operators + and *. It respects the usual rules of arithmetic precedence. def helper(tokens): stack = [] num = 0 op = \\"+\\" while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == \\"(\\": num = helper(tokens) if token in \\"+*)\\" or len(tokens) == 0: if op == \\"+\\": stack.append(num) elif op == \\"*\\": stack[-1] *= num op = token num = 0 if token == \\")\\": break return sum(stack) tokens = [] i = 0 while i < len(exp): if exp[i].isdigit(): j = i while j < len(exp) and exp[j].isdigit(): j += 1 tokens.append(exp[i:j]) i = j else: tokens.append(exp[i]) i += 1 return helper(tokens)"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring is called a **palindromic substring** if it reads the same forward and backward. A **prefix palindrome** is a palindromic substring that starts at the beginning of the string. Return the length of the shortest prefix palindrome that can be obtained by adding characters to the end of the string `s`.","solution":"def shortest_prefix_palindrome_length(s): Returns the length of the shortest prefix palindrome that can be obtained by adding characters to the end of the string s. n = len(s) reverse_s = s[::-1] # Check for the longest prefix palindrome that we can keep for i in range(n): if s[:n-i] == reverse_s[i:]: return 2 * n - (n - i) return 2 * n"},{"question":"You are given an array of integers `arr`. You need to perform the following operation `n` times: Choose any two adjacent elements in the array and remove the smaller one of them. Return the smallest possible value of the largest element in the array after performing exactly `n` operations.","solution":"def smallest_largest_element(arr, n): Returns the smallest possible value of the largest element in the array after performing exactly n operations of removing the smaller one of any two adjacent elements. if n >= len(arr): return -1 # In case n is greater or equal to the array length (which is invalid input) for _ in range(n): temp_max = float(\'inf\') index_to_remove = -1 for i in range(len(arr) - 1): if max(arr[i], arr[i + 1]) < temp_max: temp_max = max(arr[i], arr[i + 1]) index_to_remove = i if arr[i] <= arr[i + 1] else i + 1 if index_to_remove != -1: arr.pop(index_to_remove) return max(arr)"},{"question":"You are given an array `tickets` representing the number of tickets to be sold for N different events, where `tickets[i]` indicates the number of tickets available for the i-th event. You have `T` minutes to maximize your earnings by selling as many tickets as possible. Each ticket sold earns 10. Each minute you can choose any available ticket from any event and sell it. Determine the maximum earnings you can achieve in the given `T` minutes.","solution":"def max_earnings(tickets, T): Returns the maximum earnings by selling as many tickets as possible within T minutes. Each ticket sold earns 10. :param tickets: A list of integers where tickets[i] represents the number of tickets for event i. :param T: An integer representing the available minutes to sell tickets. :return: An integer of the maximum earnings that can be achieved. tickets.sort(reverse=True) earnings = 0 for i in range(T): # Always sell the ticket from the event with the most remaining tickets if tickets and tickets[0] > 0: earnings += 10 tickets[0] -= 1 tickets.sort(reverse=True) # Keep sorted to always access the maximum return earnings"},{"question":"Implement a function to serialize and deserialize a binary search tree (BST). Serialization is the process of converting a data structure into a string, and deserialization is the opposite process. You need to design an algorithm to serialize the BST to a string and deserialize the string back to the original BST structure. **Note**: The resulting string from your serialize function should be such that you can ensure easy re-creation of the tree through your deserialize function.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Serializes a BST to a string. values = [] def preorder(node): if node: values.append(str(node.val)) preorder(node.left) preorder(node.right) else: values.append(\'#\') preorder(root) return \' \'.join(values) def deserialize(data): Deserializes a string to a BST. values = iter(data.split()) def build(): val = next(values) if val == \'#\': return None node = TreeNode(int(val)) node.left = build() node.right = build() return node return build()"},{"question":"You are given a `m x n` matrix filled with non-negative integers that represent the height of each cell in a 2D elevation map. The \\"rainwater\\" can flow from one cell to another if and only if the next cell is adjacent (either vertically or horizontally) and has a height equal to or lower than the current cell. The goal is to determine the lowest height that can trap water in each cell considering the flow constraints and return the total amount of trapped water in all cells.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False]*n for _ in range(m)] min_heap = [] # Initialize the heap with the boundary cells for i in range(m): for j in range(n): if i == 0 or i == m-1 or j == 0 or j == n-1: heapq.heappush(min_heap, (heightMap[i][j], i, j)) visited[i][j] = True direction_vectors = [(-1, 0), (1, 0), (0, -1), (0, 1)] result = 0 while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in direction_vectors: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True result += max(0, height - heightMap[nx][ny]) new_height = max(height, heightMap[nx][ny]) heapq.heappush(min_heap, (new_height, nx, ny)) return result"},{"question":"You are given a **string** `s` consisting of only lowercase English letters. You can perform operations on the string by selecting any character and replacing it with any other lowercase English letter. The cost of an operation is the absolute difference in their positions in the alphabet. For example, replacing \'a\' with \'c\' costs `2` because the positions of \'a\' and \'c\' in the alphabet are `1` and `3`, respectively (|3 - 1| = 2). Return _the **minimum** cost to make all characters in the string `s` equal_.","solution":"def min_cost_to_make_equal(s): Returns the minimum cost to make all characters in the string `s` equal. def char_to_index(c): return ord(c) - ord(\'a\') + 1 # Create a list of indexes of characters in the string indices = [char_to_index(c) for c in s] min_cost = float(\'inf\') # Try to make all characters equal to each character from \'a\' to \'z\' for target in range(1, 27): cost = sum(abs(target - idx) for idx in indices) min_cost = min(min_cost, cost) return min_cost"},{"question":"You are given an integer array `nums` and an integer `target`. You want to find two distinct numbers from the array such that their sum is equal to the `target` value. Return the indices of the two numbers in an array, sorted in ascending order. If there are multiple solutions, return any one of them. You may assume that each input would have exactly one solution. Write a function that takes in `nums` and `target` and returns the indices of the two numbers. The function should have a time complexity of `O(n)`.","solution":"def two_sum(nums, target): Finds two distinct indices in the array such that their values sum up to the target. Returns the indices in ascending order. Parameters: nums (list): A list of integers. target (int): The target sum. Returns: list: A list containing two indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i"},{"question":"Suppose you are given a string `s` consisting of lowercase English letters. A **rotation** of the string `s` is a string obtained by moving the first character of `s` to the end. For example, if `s = \\"abc\\"`, the rotations would be `\\"bca\\"` and `\\"cab\\"`. Write a function to determine the **minimum number of rotations** needed to obtain a lexicographically smallest string. Return _the **lexicographically smallest string**_ after the minimum number of rotations.","solution":"def min_lex_rotation(s): Returns the lexicographically smallest string obtained by rotating string s. n = len(s) rotations = [s[i:] + s[:i] for i in range(n)] return min(rotations)"},{"question":"You are given a `words` array containing strings of equal length `n`. Two words are considered **similar** if they differ by at most two characters. Find the largest group of similar words in the array. Return the size of this largest group. Note that for a pair of words to be considered similar, their difference in characters is measured position-wise (i.e., the number of positions at which the corresponding characters of the two words are different).","solution":"from collections import deque def differByAtMostTwo(word1, word2): Return True if words differ by at most 2 characters. diff_count = 0 for c1, c2 in zip(word1, word2): if c1 != c2: diff_count += 1 if diff_count > 2: return False return True def bfs(words, start, visited): Perform BFS to find the size of the connected component of similar words. Args: - words: list of words - start: starting index - visited: list to keep track of visited nodes Return the size of the connected component. queue = deque([start]) visited[start] = True component_size = 0 while queue: current = queue.popleft() component_size += 1 for i, word in enumerate(words): if not visited[i] and differByAtMostTwo(words[current], word): queue.append(i) visited[i] = True return component_size def largestSimilarWordsGroup(words): Find the size of the largest group of similar words. n = len(words) visited = [False] * n max_group_size = 0 for i in range(n): if not visited[i]: max_group_size = max(max_group_size, bfs(words, i, visited)) return max_group_size"},{"question":"You are given an m x n matrix filled with non-negative integers. Your task is to find the **maximum sum** of any **k x k** submatrix (where k is a positive integer and k  min(m, n)). Return this maximum sum. If k = 1, you\'re finding the maximum element in the matrix. If k = min(m, n), you\'re summing the entire matrix. Ensure your solution runs in `O(m * n)` time complexity.","solution":"def max_sum_submatrix(matrix, k): Returns the maximum sum of any k x k submatrix in the given matrix. Args: matrix : List[List[int]] : 2D list representing the matrix k : int : size of the submatrix Returns: int : maximum submatrix sum m, n = len(matrix), len(matrix[0]) # Create the prefix sum matrix prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): prefix_sum[i + 1][j + 1] = ( matrix[i][j] + prefix_sum[i + 1][j] + prefix_sum[i][j + 1] - prefix_sum[i][j] ) max_sum = float(\'-inf\') for i in range(m - k + 1): for j in range(n - k + 1): current_sum = ( prefix_sum[i + k][j + k] - prefix_sum[i][j + k] - prefix_sum[i + k][j] + prefix_sum[i][j] ) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `arr` and a target integer `target`. Determine if there exist four distinct elements in `arr` that sum up to `target`. Return `true` if such a quadruplet exists, and `false` otherwise. You may assume the given array is always of sufficient length and contains valid integers. For example, given `arr = [1, 0, -1, 0, -2, 2]` and `target = 0`, you should return `true` because `[-1, 0, 0, 1]` sums up to `0`.","solution":"def four_sum_exists(arr, target): arr.sort() n = len(arr) for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[j] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Given a string `s` containing only the characters `\'a\'`, `\'b\'`, and `\'c\'`, you can delete any two adjacent characters in the string that are different. For example, deleting `\'ab\'` or `\'bc\'` from the string will reduce its length by two. Your task is to return _the length of the shortest string possible after performing any number of deletions_. [Question 4]:","solution":"def reduce_string_length(s): Returns the length of the shortest string possible by performing any number of deletions of two adjacent characters that are different. Parameters: s (str): input string containing only \'a\', \'b\' and \'c\' Returns: int: shortest possible length of the string stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"You are given a string `s` that only contains characters `\\"a\\"`, `\\"b\\"`, and `\\"c\\"`. A substring is defined as a contiguous sequence of characters within the string. Your task is to find the length of the smallest substring that contains at least one of each character `\\"a\\"`, `\\"b\\"`, and `\\"c\\"`. If no such substring exists, return 0. For example, given `s = \\"abcabc\\"`, the smallest substring that contains at least one `\\"a\\"`, one `\\"b\\"`, and one `\\"c\\"` is `\\"abc\\"` with length 3.","solution":"def smallest_substring(s): Returns the length of the smallest substring that contains at least one \'a\', one \'b\', and one \'c\'. If no such substring exists, returns 0. if not s or \'a\' not in s or \'b\' not in s or \'c\' not in s: return 0 min_length = float(\'inf\') left = 0 count = {\'a\': 0, \'b\': 0, \'c\': 0} for right in range(len(s)): if s[right] in count: count[s[right]] += 1 while all(count[char] > 0 for char in \'abc\'): min_length = min(min_length, right - left + 1) if s[left] in count: count[s[left]] -= 1 left += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given a **0-indexed** integer array `timeIntervals` where each element `timeIntervals[i]` represents the duration of an event. You need to merge these events such that the total number of unique events is minimized. Two events can be merged if the difference in their durations is no more than `k` minutes. Given the integer `k`, return _the minimum number of unique events after merging_. For example, given `timeIntervals = [30, 40, 20, 90, 10]` and `k = 15`, the merged events could be grouped as follows: `[10, 20]`, `[30, 40]`, and `[90]`, resulting in `3` unique events.","solution":"def minimize_unique_events(timeIntervals, k): Returns the minimum number of unique events after merging events which differ in duration by no more than k minutes. Parameters: timeIntervals (list of int): List of event durations. k (int): Maximum allowed difference to merge two events. Returns: int: Minimum number of unique events after merging. if not timeIntervals: return 0 # Sort the intervals to try merging adjacent events first timeIntervals.sort() unique_events = 1 # There is at least one event # Keep the duration of the last merged event last_merged = timeIntervals[0] for i in range(1, len(timeIntervals)): if timeIntervals[i] - last_merged > k: unique_events += 1 last_merged = timeIntervals[i] return unique_events"},{"question":"You are given a list of integers `heights` representing the heights of buildings in a row. Consider a building at index `i` to be a \\"viewpoint\\" if it has an unobstructed view of the skyline to its right, i.e., there is no building taller than or equal to it to its right. * For example, given `heights = [4, 2, 3, 1]`, the buildings at indexes 0, 2, and 3 are viewpoints because: - The building at index 0 (height 4) has a view because it is taller than all the buildings to its right. - The building at index 2 (height 3) has a view because it is taller than the building to its right. - The building at index 3 (height 1) is the last building, so it has a view by default. Return _the indices of all viewpoint buildings in ascending order_.","solution":"def get_viewpoints(heights): Returns a list of indices of viewpoint buildings in ascending order. A building at index i is considered a viewpoint if it has an unobstructed view of the skyline to its right. viewpoints = [] max_height_to_the_right = 0 # Iterate from the end of the list to the beginning for i in reversed(range(len(heights))): if heights[i] > max_height_to_the_right: viewpoints.append(i) max_height_to_the_right = heights[i] # Return the indices in ascending order return sorted(viewpoints)"},{"question":"You are given a 2D grid of size `m x n` representing an island map. The grid\'s cells can have the following values: - `0` represents water, - `1` represents land, - `2` represents a treasure. You are starting from the top-left corner of the grid (i.e., cell `(0, 0)`) and your goal is to find the shortest path to reach any cell containing a treasure. You can move in four possible directions (left, right, up, down) but you cannot move diagonally. The path length is measured by the number of steps taken. If there is no path to any treasure, return `-1`. Implement a function `int shortestPathToTreasure(vector<vector<int>>& grid)` that returns the shortest path length to the nearest treasure, or `-1` if there is no such path.","solution":"from collections import deque def shortestPathToTreasure(grid): Returns the shortest path length to the nearest treasure in a given 2D grid. If there\'s no path to any treasure, returns -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if grid[x][y] == 2: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != 0: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"You are given a binary tree where each node has a value. Design an algorithm that: - Finds the path in the binary tree with the maximum sum of node values. - The path can start and end at any node in the tree. The `TreeNode` structure is defined as: ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; ``` Implement the `Solution` class with the following method: * `int maxPathSum(TreeNode* root)`: Returns the maximum path sum. **Note**: - A path in the binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. - A path must contain at least one node and does not need to go through the root.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def maxPathSum(self, root): self.max_sum = float(\'-inf\') def helper(node): if not node: return 0 left_max = max(helper(node.left), 0) right_max = max(helper(node.right), 0) current_path_sum = node.val + left_max + right_max self.max_sum = max(self.max_sum, current_path_sum) return node.val + max(left_max, right_max) helper(root) return self.max_sum"},{"question":"Given an m x n binary matrix `grid`, return the maximum length of a contiguous subarray with an equal number of 1s and 0s in each row of the matrix. The subarray must consist of an entire row or part of a row, and the elements of the subarray must be contiguous. Return the length of the longest such subarray for each row in an array `result`, where `result[i]` is the length of the longest subarray in the `ith` row.","solution":"def findMaxLength(nums): max_len = 0 count = 0 count_map = {0: -1} for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len def findMaxLengthInMatrix(grid): return [findMaxLength(row) for row in grid]"},{"question":"Given a non-negative integer `n`, generate the `n`th row of the Pascal\'s triangle. In Pascal\'s triangle, each number is the sum of the two numbers directly above it. The first few rows of Pascal\'s triangle are as follows: ``` [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1], ... ] ``` Return _the `n`th (0-indexed) row of the Pascal\'s triangle_.","solution":"def get_pascals_triangle_row(n): Returns the nth row of Pascal\'s triangle (0-indexed). if n == 0: return [1] row = [1] for k in range(1, n + 1): row.append(row[-1] * (n - k + 1) // k) return row"},{"question":"Implement a data structure that supports the following operations: `insert`, `delete`, `getRandomElement`, and each of these operations should be `O(1)` on average. The data structure will store integers. - `void insert(int val)`: Inserts a value into the data structure. - `void delete(int val)`: Deletes a value from the data structure. - `int getRandomElement()`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Note: You must improve upon a basic data structure to ensure average constant time for all operations.","solution":"import random class RandomizedSet: def __init__(self): self.data = [] self.val_to_index = {} def insert(self, val: int) -> bool: if val in self.val_to_index: return False self.val_to_index[val] = len(self.data) self.data.append(val) return True def delete(self, val: int) -> bool: if val not in self.val_to_index: return False index = self.val_to_index[val] last_val = self.data[-1] self.data[index] = last_val self.val_to_index[last_val] = index self.data.pop() del self.val_to_index[val] return True def getRandomElement(self) -> int: return random.choice(self.data)"},{"question":"Given a sorted array of distinct integers `arr`, find a fixed point in the array, if one exists. A fixed point is an index `i` where `arr[i] == i`. Return the index if a fixed point is found, otherwise return -1. You must solve it in `O(log n)` time complexity.","solution":"def find_fixed_point(arr): Function to find a fixed point in a sorted array of distinct integers. Parameters: arr (list): A sorted array of distinct integers. Returns: int: The index where arr[i] == i, or -1 if no such index exists. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == mid: return mid elif arr[mid] < mid: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given a binary tree with `n` nodes, where each node has a value associated with it. You need to determine the length of the longest path in the tree such that the values along the path form an increasing sequence. The path does not necessarily need to start from the root. Return the length of this longest path.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_path(root): def dfs(node, prev_val): if not node: return 0 left = dfs(node.left, node.val) right = dfs(node.right, node.val) return max(left, right) + 1 if node.val > prev_val else 0 def traverse_and_find(node): if not node: return 0 left_length = traverse_and_find(node.left) right_length = traverse_and_find(node.right) current_length = dfs(node, float(\'-inf\')) return max(left_length, right_length, current_length) return traverse_and_find(root)"},{"question":"You are given a 2D grid `grid` of size `m x n` representing a dungeon where `grid[i][j]` is the amount of health you lose (negative) or gain (positive) when entering cell `(i, j)`. You need to determine the minimum initial health required for a knight to rescue a princess located at the bottom-right corner `(m-1, n-1)` of the dungeon. The knight starts at the top-left corner `(0, 0)` and can only move right or down. The knight should have at least `1` health at all times. Return the minimum initial health required for the knight to reach the princess.","solution":"def calculate_minimum_hp(dungeon): Calculate the minimum initial health required for a knight to rescue the princess. :param dungeon: List[List[int]]: 2D grid of the dungeon where each cell contains health points to be gained or lost. :return: int: Minimum initial health required. if not dungeon or not dungeon[0]: return 1 m, n = len(dungeon), len(dungeon[0]) # Create a dp array of the same size as dungeon dp = [[0] * n for _ in range(m)] # Initialize the bottom-right corner dp[-1][-1] = max(1, 1 - dungeon[-1][-1]) # Fill the last row for j in range(n-2, -1, -1): dp[-1][j] = max(1, dp[-1][j+1] - dungeon[-1][j]) # Fill the last column for i in range(m-2, -1, -1): dp[i][-1] = max(1, dp[i+1][-1] - dungeon[i][-1]) # Fill the rest of dp table for i in range(m-2, -1, -1): for j in range(n-2, -1, -1): dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]) return dp[0][0]"},{"question":"You are given a 2D grid `grid` of size `m x n` composed of characters \'0\' and \'1\'. A cell containing \'1\' represents land, and \'0\' represents water. An island is a group of \'1\'s connected horizontally or vertically. You need to determine the length of the shortest bridge between any two islands (the smallest number of 0\'s you must flip to connect the two islands). Return _the length of the shortest bridge_. If no such bridge exists, return -1.","solution":"from collections import deque def shortestBridge(grid): m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def bfs(queue): while queue: x, y, d = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: if grid[nx][ny] == 1: return d queue.append((nx, ny, d + 1)) visited[nx][ny] = True return -1 def dfs(x, y, queue): if 0 <= x < m and 0 <= y < n and grid[x][y] == 1 and not visited[x][y]: visited[x][y] = True queue.append((x, y, 0)) for dx, dy in directions: dfs(x + dx, y + dy, queue) visited = [[False] * n for _ in range(m)] queue = deque() found = False for i in range(m): for j in range(n): if grid[i][j] == 1: dfs(i, j, queue) found = True break if found: break return bfs(queue)"},{"question":"You are given an array of integers `arr` and an integer `d`. You can perform the following operation on the array: choose an element `arr[i]` and if it\'s not already 1, decrement it by 1. Return the minimum number of operations needed to make every element of the array at least `d`. If it\'s not possible, return -1.","solution":"def min_operations_to_at_least_d(arr, d): Calculate the minimum number of operations needed to make every element in the array at least d. If it\'s not possible, return -1. :param arr: list of integers :param d: integer threshold :return: integer number of operations or -1 if not possible operations = 0 for num in arr: if num < d: operations += (d - num) return operations"},{"question":"You are given an `n x n` matrix `mat` where each of the rows and columns is sorted in ascending order. You are also given an integer `k`. Find the `kth` smallest element in the matrix. Note that it is the `kth` smallest element in the sorted order, not the `kth` distinct element. Return the `kth` smallest element from the matrix.","solution":"import heapq def kthSmallest(mat, k): Returns the kth smallest element in the n x n matrix mat where each of the rows and columns is sorted in ascending order. n = len(mat) min_heap = [(mat[0][0], 0, 0)] visited = set((0, 0)) for _ in range(k - 1): val, x, y = heapq.heappop(min_heap) if x + 1 < n and (x + 1, y) not in visited: visited.add((x + 1, y)) heapq.heappush(min_heap, (mat[x + 1][y], x + 1, y)) if y + 1 < n and (x, y + 1) not in visited: visited.add((x, y + 1)) heapq.heappush(min_heap, (mat[x][y + 1], x, y + 1)) return heapq.heappop(min_heap)[0]"},{"question":"You are given an array of strings `words` and a string `target`. Return the minimum number of characters from `words` that need to be concatenated to form the string `target`. If it is not possible to form the string `target` from the given words, return -1. You may use each word from the array `words` as many times as needed.","solution":"def min_chars_to_form_target(words, target): from collections import Counter words_count = Counter(\'\'.join(words)) target_count = Counter(target) min_chars_needed = 0 for char, count in target_count.items(): if char not in words_count: return -1 min_chars_needed += count return min_chars_needed"},{"question":"Given a string `s` and an integer `k`, you need to perform `k` operations on the string. In each operation, select any one character from the string and delete all its occurrences. Your goal is to minimize the length of the resulting string after all `k` operations. Return the minimal length of the string obtained after performing `k` operations. If `k` is greater than or equal to the number of distinct characters in `s`, return `0`. For example, let\'s say `s = \\"ababc\\"`, and `k = 2`. Possible deletion sequences include: - Deleting `a` and `b` leaves the string `c`, which has length `1`. - Deleting `a` and `c` leaves the string `bb`, which has length `2`. Thus the output should be `1` as that\'s the minimal length after `k` operations.","solution":"from collections import Counter def min_length_after_operations(s, k): Returns the minimal length of the string after performing k operations. Each operation consists of selecting any one character from the string and deleting all its occurrences. Parameters: s (str): The input string. k (int): The number of operations to perform. Returns: int: The minimal length of the resulting string after performing k operations. # Count the occurrences of each character char_count = Counter(s) # If k is greater than or equal to the number of distinct characters, return 0 if k >= len(char_count): return 0 # Create a sorted list of character frequencies frequencies = sorted(char_count.values(), reverse=True) # Remove the k most frequent characters for i in range(k): frequencies.pop(0) # Return the sum of the remaining frequencies return sum(frequencies)"},{"question":"Given an array of integers `nums` and a target integer `T`, find all unique combinations in `nums` where the sum of the elements is equal to `T`. Each number in `nums` may only be used once in the combination. The solution set must not contain duplicate combinations. Return _an array of arrays_, where each sub-array is a unique combination of numbers that sum up to `T`. The elements in each combination should be in non-decreasing order, and the combinations themselves should be in lexicographical order.","solution":"def combination_sum(nums, target): Finds all unique combinations in nums where the sum is equal to the target. Each number in nums may be used only once in the combination. The solution set must not contain duplicate combinations. nums.sort() result = [] def backtrack(start, path, remaining): if remaining == 0: result.append(path) return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue if nums[i] > remaining: break backtrack(i + 1, path + [nums[i]], remaining - nums[i]) backtrack(0, [], target) return result"},{"question":"You are given a list of strings `words` and a target string `target`. Each string in `words` can be rearranged such that it can form new words by only changing the order of its characters. Return _the number of strings in_ `words` _that can be rearranged to match_ `target`_. If no such strings are found, return **0**.","solution":"def count_anagrams(words, target): Returns the number of strings in words that can be rearranged to match target. from collections import Counter target_counter = Counter(target) # Count the frequency of each character in the target count = 0 for word in words: word_counter = Counter(word) if word_counter == target_counter: count += 1 return count"},{"question":"Given an array of integer heights `heights` representing a terrain, where each index represents a different position on the terrain, and the value at each index represents the height at that position. Compute the maximum amount of water that can be trapped after raining, assuming that the terrain has units of height that can form valleys. The array `heights` will have at least two elements and at most 100,000 elements, with each element being a non-negative integer that can be as large as 100,000. Return _the maximum units of water that can be trapped_ after it rains.","solution":"def trap(height): Given an array of integers `height` representing a terrain, compute the maximum amount of water that can be trapped after raining. :param height: List[int] - An array representing the height of the terrain at each point. :return: int - The maximum amount of water that can be trapped. if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"You are given an integer array `heights` representing the heights of a lineup of people, each at a different position from left to right. The array is zero-indexed and ( heights[i] ) represents the height of the person at position `i`. We want to calculate the minimum number of moves required to arrange the lineup in non-decreasing order of height, while keeping the relative order of people with the same height unchanged. A move consists of selecting one person and repositioning them at a different position in the lineup. Return _the minimum number of moves required to achieve the desired order._","solution":"def min_moves_to_sort(heights): Returns the minimum number of moves required to sort the lineup in non-decreasing order of height, while keeping the relative order of people with the same height unchanged. # Find the length of longest increasing subsequence (LIS) def length_of_LIS(nums): if not nums: return 0 dp = [] for x in nums: if not dp or x >= dp[-1]: dp.append(x) else: left, right = 0, len(dp)-1 while left < right: mid = (left + right) // 2 if dp[mid] < x: left = mid + 1 else: right = mid dp[right] = x return len(dp) # Calculate LIS length on the heights array length_lis = length_of_LIS(heights) # The minimum number of moves required to sort is the size of the array minus the length of the LIS return len(heights) - length_lis"},{"question":"You are given a string `s` and an array of strings `words`. All the strings are of the same length and the length of the string `s` is a multiple of the length of each word in `words`. Concatenate each word in `words` exactly once and list all starting indices of the resulting concatenation in `s`. Return all starting indices sorted in increasing order. For example, if `s = \\"barfoothefoobarman\\"` and `words = [\\"foo\\", \\"bar\\"]`, you should return `[0, 9]` as the concatenation \\"foobar\\" starts at index 0 and \\"barfoo\\" starts at index 9 in `s`. Implement the function `List<Integer> findSubstrings(String s, String[] words)` that returns the starting indices of all concatenated substrings.","solution":"def find_substrings(s, words): from collections import defaultdict, Counter word_len = len(words[0]) total_len = word_len * len(words) words_count = Counter(words) results = [] for i in range(word_len): left, count = i, 0 current_count = defaultdict(int) for j in range(i, len(s) - word_len + 1, word_len): word = s[j:j+word_len] if word in words_count: current_count[word] += 1 count += 1 while current_count[word] > words_count[word]: current_count[s[left:left+word_len]] -= 1 left += word_len count -= 1 if count == len(words): results.append(left) else: current_count = defaultdict(int) count = 0 left = j + word_len return results"},{"question":"You are given a list of `n` integers representing the arrival time of guests at a party. A guest can enter the party at their arrival time or later. The goal is to find the minimum number of guests who would have to wait if there is only one entrance through which guests can enter, and only one guest can enter at a time. Each guest takes exactly one minute to enter. Return the minimum number of guests who will have to wait.","solution":"def min_guests_wait(arrival_times): Returns the minimum number of guests who will have to wait. Parameters: arrival_times (list of int): List of integers representing arrival times of guests. Returns: int: Minimum number of guests who will have to wait. if not arrival_times: return 0 arrival_times.sort() last_entry_time = arrival_times[0] waiting_count = 0 for i in range(1, len(arrival_times)): if arrival_times[i] <= last_entry_time: waiting_count += 1 else: last_entry_time = arrival_times[i] return waiting_count"},{"question":"You are given an array `trees` where `trees[i]` represents the height of the `i-th` tree. In one step you can remove one tree. However, you can also water any tree, effectively increasing its height by one unit. You want to make the height of every tree the same in the minimum number of steps. Return the minimum number of steps required to make all the trees have the same height.","solution":"def min_steps_to_equal_height(trees): Returns the minimum number of steps required to make all trees have the same height. :param trees: List[int] heights of the trees. :return: int minimum number of steps required. if not trees: return 0 max_height = max(trees) steps = sum(max_height - height for height in trees) return steps"},{"question":"Given a **0-indexed** integer array `arr` of length `n`, your task is to determine if there exists a **subarray** (contiguous segment) of length `k` such that the average of the subarray is equal to an element in `arr`. Return `true` if such a subarray exists, otherwise return `false`.","solution":"def subarray_average_exists(arr, k): Checks if there exists a subarray of length k such that the average of the subarray is equal to an element in arr. n = len(arr) if k > n: return False # We can use a sliding window approach to find the sum of all subarrays of length k subarray_sum = sum(arr[:k]) subarray_avg_set = {subarray_sum / k} for i in range(1, n - k + 1): subarray_sum = subarray_sum - arr[i - 1] + arr[i + k - 1] subarray_avg_set.add(subarray_sum / k) for a in arr: if a in subarray_avg_set: return True return False"},{"question":"Given an array of integers, return the running sum of the array. The running sum of an array is defined as `runningSum[i]` = sum of all elements from `arr[0]` to `arr[i]`. Implement the function `runningSum` which takes in a list of integers `arr` and returns a list of integers representing the running sum. For example: * If the input array is `[1, 2, 3, 4]`, the running sum would be `[1, 3, 6, 10]`. * If the input array is `[1, 1, 1, 1, 1]`, the running sum would be `[1, 2, 3, 4, 5]`. * If the input array is `[3, 1, 4, 1, 5]`, the running sum would be `[3, 4, 8, 9, 14]`.","solution":"def runningSum(arr): Computes the running sum of the input array. Args: arr (list of int): The input list of integers. Returns: list of int: The running sum list. result = [] cumulative_sum = 0 for num in arr: cumulative_sum += num result.append(cumulative_sum) return result"},{"question":"[Question] 4: You are given a binary tree where each node has an integer value. Write a function to determine if the tree is a binary search tree (BST). A binary search tree is defined as follows: * The left subtree of a node contains only nodes with values less than the node\'s value. * The right subtree of a node contains only nodes with values greater than the node\'s value. * Both the left and right subtrees must also be binary search trees. Return _a boolean value_ indicating whether the given binary tree is a BST. For example, given the root of the binary tree: ``` 2 / 1 3 ``` The function should return `true`. Alternatively, for the tree: ``` 5 / 1 4 / 3 6 ``` The function should return `false` because the node with the value `3` is in the right subtree of `5` but is less than `5`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root): Determines if a binary tree is a binary search tree. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is a BST, otherwise False def validate(node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if not (low < node.val < high): return False return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"Given a `0-indexed` integer array `nums`, return the maximum length of a contiguous subarray that contains at most two distinct integers. You must write an algorithm that runs in `O(n)` time complexity where `n` is the length of the array.","solution":"def max_length_subarray_two_distinct(nums): Returns the maximum length of a contiguous subarray that contains at most two distinct integers. :param nums: List[int] - a list of integers :return: int - the maximum length of such subarray if not nums: return 0 left = 0 right = 0 max_length = 0 count_map = {} while right < len(nums): if nums[right] in count_map: count_map[nums[right]] += 1 else: count_map[nums[right]] = 1 while len(count_map) > 2: count_map[nums[left]] -= 1 if count_map[nums[left]] == 0: del count_map[nums[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given an **undirected graph** where each node represents a city and each edge represents a bidirectional road connecting two cities. You are to implement the `TravelPlanner` class that can update the roads and check if there exists a path between any two cities. Implement the `TravelPlanner` class: * `TravelPlanner(int n)` Initializes the graph with `n` cities. * `void addRoad(int city1, int city2)` Adds a bidirectional road between `city1` and `city2`. * `void removeRoad(int city1, int city2)` Removes the bidirectional road between `city1` and `city2`. * `boolean isConnected(int city1, int city2)` Returns `true` if there is a path between `city1` and `city2`, and `false` otherwise. Your implementation should be efficient, maintaining proper data structures to allow quick updates and path queries.","solution":"class TravelPlanner: def __init__(self, n): self.n = n self.graph = {i: set() for i in range(n)} def addRoad(self, city1, city2): self.graph[city1].add(city2) self.graph[city2].add(city1) def removeRoad(self, city1, city2): self.graph[city1].discard(city2) self.graph[city2].discard(city1) def isConnected(self, city1, city2): visited = set() return self._dfs(city1, city2, visited) def _dfs(self, current, target, visited): if current == target: return True visited.add(current) for neighbor in self.graph[current]: if neighbor not in visited and self._dfs(neighbor, target, visited): return True return False"},{"question":"You are given a **0-indexed** integer array `jobs` representing the amount of time it takes to complete each job. There are `n` workers, each worker can only work on **one** job and can only start a new job after the current one is finished. You want to assign jobs to the workers such that the total time to complete all jobs is minimized. Return the _minimum time required to complete all jobs_.","solution":"def minimumTimeRequired(jobs, n): Returns the minimum time required to complete all jobs with n workers. Greedy approach to balance the workloads among workers. # Early exit for trivial cases if n >= len(jobs): return max(jobs) def can_finish(jobs, n, max_time): workloads = [0] * n def backtrack(idx): if idx == len(jobs): return True for i in range(n): if workloads[i] + jobs[idx] <= max_time: workloads[i] += jobs[idx] if backtrack(idx + 1): return True workloads[i] -= jobs[idx] if workloads[i] == 0: # Skip this worker as it is redundant break return False return backtrack(0) left, right = max(jobs), sum(jobs) while left < right: mid = (left + right) // 2 if can_finish(jobs, n, mid): right = mid else: left = mid + 1 return left"},{"question":"Given a list of integers `arr`, you are to determine if there exist three indices `i`, `j`, `k` such that `0 <= i < j < k < arr.length` and `arr[i] < arr[j] < arr[k]`. If such indices exist, return `true`. Otherwise, return `false`.","solution":"def increasing_triplet(arr): Determines if there exist three indices i, j, k such that 0 <= i < j < k < len(arr) and arr[i] < arr[j] < arr[k]. :param arr: List[int] - list of integers :return: bool - True if such indices exist, otherwise False if len(arr) < 3: return False first = second = float(\'inf\') for num in arr: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"You are given a list of `n` integers. Return a new list such that each element at index `i` of the new list is the product of all the numbers in the original list except the one at `i`. You must solve it **without using division** and in **O(n)** time complexity.","solution":"def product_except_self(nums): Returns a new list such that each element at index `i` of the new list is the product of all the numbers in the original list except the one at `i`. n = len(nums) if n == 0: return [] # Initialize arrays to store the product of elements to the left and right of each index left_products = [1] * n right_products = [1] * n result = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate result by multiplying left and right products for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"You are given a string `s` consisting of lowercase English letters, and an array `queries` where each query is a tuple of `(left, right, k)`. For each query, determine if you can make the substring `s[left:right+1]` a palindrome by changing at most `k` characters. Return an array of booleans where each boolean corresponds to a query.","solution":"def can_make_palindrome(s, queries): def canFormPalindrome(s, left, right, k): changes_needed = 0 l, r = left, right while l < r: if s[l] != s[r]: changes_needed += 1 l += 1 r -= 1 return changes_needed <= k results = [] for left, right, k in queries: results.append(canFormPalindrome(s, left, right, k)) return results"},{"question":"Given an array of meeting time intervals `intervals` where `intervals[i] = [start, end]`, implement a function to return _the minimum number of conference rooms required_. Each interval represents a meeting time and intervals may have overlaps.","solution":"def minMeetingRooms(intervals): Returns the minimum number of conference rooms required given meeting time intervals. :param intervals: List[List[int]] : List of meeting time intervals [start, end] :return: int : Minimum number of conference rooms required if not intervals: return 0 # Separate the start and end times. starts = sorted([i[0] for i in intervals]) ends = sorted([i[1] for i in intervals]) # Use two pointers to track the earliest start and end times. start_pointer, end_pointer = 0, 0 used_rooms = 0 while start_pointer < len(starts): # If the meeting starting is after or exactly when a meeting is ending, free a room if starts[start_pointer] >= ends[end_pointer]: used_rooms -= 1 end_pointer += 1 # Allocate a room and move the start pointer used_rooms += 1 start_pointer += 1 return used_rooms"},{"question":"Given `n` pairs of coordinates `(x[i], y[i])`, determine if there exists a straight line that passes through at least three of these points. If such a line exists, identify the triplet of points that lie on that straight line and return their indices (0-indexed) as a tuple `(i, j, k)`. Otherwise, return `None`. (Note: Assume all coordinate values are integers and can be positive or negative. If there are multiple such triplets, return the lexicographically smallest one in terms of indices.)","solution":"from itertools import combinations def collinear(p1, p2, p3): Check if points p1, p2, and p3 are collinear. Points are collinear if the area of the triangle they form is zero. The area can be calculated using the determinant of a 3x3 matrix formed by the points. (x1, y1), (x2, y2), (x3, y3) = p1, p2, p3 return (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1) def find_triplet(points): Given a list of points, return indices of three collinear points if they exist. n = len(points) # Iterate over all combinations of three points for i, j, k in combinations(range(n), 3): if collinear(points[i], points[j], points[k]): return (i, j, k) return None"},{"question":"You are given an array of integers `nums` and an integer `target`. Write a function that finds two distinct indices `i` and `j` in the array such that `nums[i] + nums[j]` equals the `target`. Return the indices as a tuple `(i, j)`. If there are no such indices, return `None`. Note that each input will have exactly one solution, and you may not use the same element twice.","solution":"def two_sum(nums, target): Finds two distinct indices i and j in the array nums such that nums[i] + nums[j] equals target. Args: nums: List[int] - list of integers. target: int - the target sum. Returns: Tuple[int, int] or None - the indices (i, j) if a solution is found, otherwise None. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"You are given a binary search tree (BST) with `n` nodes. Each node has a unique integer value. Implement the `BST` class with the following methods: * `BST()` Initializes the empty BST. * `void insert(int val)` Inserts a node with the value `val` into the BST. * `boolean search(int val)` Returns `true` if a node with the value `val` exists in the BST, otherwise returns `false`. * `void delete(int val)` Removes a node with the value `val` from the BST if it exists. * `int[] inorderTraversal()` Returns an array of the node values in the BST sorted in ascending order.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): def insert_rec(node, key): if not node: return TreeNode(key) if key < node.val: node.left = insert_rec(node.left, key) else: node.right = insert_rec(node.right, key) return node self.root = insert_rec(self.root, key) def search(self, key): def search_rec(node, key): if not node or node.val == key: return node is not None if key < node.val: return search_rec(node.left, key) return search_rec(node.right, key) return search_rec(self.root, key) def delete(self, key): def delete_rec(node, key): if not node: return node if key < node.val: node.left = delete_rec(node.left, key) elif key > node.val: node.right = delete_rec(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = min_value_node(node.right) node.val = temp.val node.right = delete_rec(node.right, temp.val) return node def min_value_node(node): current = node while current.left is not None: current = current.left return current self.root = delete_rec(self.root, key) def inorderTraversal(self): def inorder_rec(node): return inorder_rec(node.left) + [node.val] + inorder_rec(node.right) if node else [] return inorder_rec(self.root)"},{"question":"Given a singly linked list with `n` nodes, rotate the list to the right by `k` places, where `k` is a non-negative integer. The rotation should be performed such that the list remains intact and only the link pointers are changed. Return the head of the rotated linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or k == 0: return head # Find the length of the linked list length = 1 current = head while current.next: current = current.next length += 1 # Connect the end of the list to the head to form a loop current.next = head # k might be larger than list length, hence reduce unnecessary rotations k = k % length # Find the new tail which is (length - k) steps from the beginning steps_to_new_tail = length - k new_tail = head for _ in range(steps_to_new_tail - 1): new_tail = new_tail.next # The new head is the next node new_head = new_tail.next # Break the loop new_tail.next = None return new_head"},{"question":"You are given a binary tree where each node contains an integer value. Design an algorithm to compute the largest value in each level of the tree. Return a list containing the largest value at each level, ordered from the root level to the lowest level.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values_per_level(root): Returns a list containing the largest value at each level of the binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float(\'-inf\') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"Given an integer array `nums`, you are tasked to return the number of **inversions** in the array. An inversion is a pair of indices `(i, j)` such that `0 <= i < j < nums.length` and `nums[i] > nums[j]`. Implement a function `int countInversions(int[] nums)` that computes the number of inversions in the given array `nums`. **Example:** For `nums = [2, 4, 1, 3, 5]`, the number of inversions is 3: - (2, 1) - (4, 1) - (4, 3) For `nums = [5, 4, 3, 2, 1]`, the number of inversions is 10.","solution":"def count_inversions(nums): Returns the number of inversions in the array `nums`. An inversion is a pair of indices (i, j) such that 0 <= i < j < nums.length and nums[i] > nums[j]. Args: nums : List[int] Returns: int def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count n = len(nums) temp_arr = [0]*n return merge_sort_and_count(nums, temp_arr, 0, n-1)"},{"question":"Given two strings `s1` and `s2`, write a function to determine if `s2` is a rotation of `s1` using only one call to a substring checking method. In other words, determine if there exists a way to split `s1` into two parts, `x` and `y`, such that `s1 = xy` and `s2 = yx`. The function should return `true` if `s2` is a rotation of `s1`, and `false` otherwise.","solution":"def is_rotation(s1, s2): Determine if s2 is a rotation of s1 by using a substring checking method. :param s1: Original string :param s2: String to check as rotation :return: True if s2 is a rotation of s1, False otherwise if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"You are given a list of words `words` and an integer `k`. A word is defined as _palindrome_ if it reads the same backward as forward. Find all the palindrome words in the list and return the first `k` palindromic words found. If there are fewer than `k` palindromic words, return all of them. Note that the words are case-insensitive, meaning \\"RaceCar\\" and \\"racecar\\" are considered the same palindrome. Return the list of palindromic words in their original form as they appear in the input list.","solution":"def find_k_palindromes(words, k): Returns the first k palindromic words from the input list. Args: words: List of words. k: Number of palindromic words to return. Returns: List of first k palindromic words. def is_palindrome(word): # Check if a word is palindrome in a case insensitive manner word_lower = word.lower() return word_lower == word_lower[::-1] palindromes = [word for word in words if is_palindrome(word)] return palindromes[:k]"},{"question":"You are given a **positive** integer `n`. Your task is to determine the **minimum number of operations** needed to reduce `n` to `1`. In each operation, you can either: - Subtract `1` from `n`, - If `n` is even, divide `n` by `2`, - If `n` is divisible by `3`, divide `n` by `3`. Return _the minimum number of operations needed to reduce_ `n` _to `1`_.","solution":"def min_operations_to_one(n): Returns the minimum number of operations needed to reduce n to 1. dp = [0] * (n + 1) for i in range(2, n + 1): dp[i] = dp[i - 1] + 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[n]"},{"question":"You are given a string `s` consisting of lowercase English letters. Determine the length of the **shortest substring** of `s` that contains all the distinct characters of `s`. Return _the length of this substring_. Complete the function `int shortestSubstringWithAllChars(string s)`, which takes a single argument `s` and returns an integer representing the length of the shortest substring containing all distinct characters of `s`.","solution":"def shortestSubstringWithAllChars(s): Returns the length of the shortest substring that contains all the distinct characters of the input string. from collections import defaultdict # Find all unique characters in the string unique_chars = set(s) n_unique = len(unique_chars) # Edge case if the string is empty or has unique character count - return 0 or the length of unique chars itself. if n_unique == 0: return 0 if len(s) == n_unique: return len(s) # Sliding window approach to find the shortest substring containing all unique characters left = 0 min_length = float(\'inf\') char_count = defaultdict(int) for right in range(len(s)): char_count[s[right]] += 1 # When all unique characters are included in the current window while len(char_count) == n_unique: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_length"},{"question":"Given a list of integers, write a function to determine whether the list forms a valid mountain array. Recall that a valid mountain array must satisfy the following conditions: the list must have at least 3 elements, there exists some index `i` (0 < i < len(A) - 1) such that: - `A[0] < A[1] < ... < A[i]` - `A[i] > A[i+1] > ... > A[len(A) - 1]` In other words, the array elements must exclusively increase until a peak element is reached and then exclusively decrease. For example, `[2, 1]`, `[3, 5, 5]`, and `[0, 3, 2, 1]` are not valid mountain arrays, but `[0, 3, 2, 1]` is, and so is `[1, 3, 2]`. Implement a function `bool validMountainArray(List<int> A)` that returns true if the input list forms a valid mountain array, otherwise false.","solution":"def validMountainArray(A): n = len(A) if n < 3: return False # Find the peak of the mountain peak = 0 for i in range(1, n - 1): if A[i] > A[i - 1] and A[i] > A[i + 1]: peak = i break else: return False # Check if the elements before the peak are strictly increasing for i in range(1, peak): if A[i] <= A[i - 1]: return False # Check if the elements after the peak are strictly decreasing for i in range(peak + 1, n): if A[i] >= A[i - 1]: return False return True"},{"question":"You are given the root of a binary tree where each nodes value is either 0 or 1. Each path from root to any leaf forms a binary number interpreted in the path. Return the sum of all these binary numbers. The answer is **guaranteed** to fit in a **32-bit integer**. A leaf is a node with no children. For example, consider the input tree `[1, 0, 1, 0, 1, 0, 1]`, the root-to-leaf paths represent binary numbers \\"100\\", \\"101\\", \\"110\\", and \\"111\\", and their sum is `4 + 5 + 6 + 7 = 22`. ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: # Your code here ```","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: def dfs(node, current_sum): if not node: return 0 current_sum = current_sum * 2 + node.val if not node.left and not node.right: # If it\'s a leaf node return current_sum return dfs(node.left, current_sum) + dfs(node.right, current_sum) return dfs(root, 0)"},{"question":"You are given an integer array `nums` and an integer target `k`. The array contains unique integers sorted in ascending order. Your task is to find all pairs of integers in the array whose sum equals the given target `k`. Return the pairs in ascending order by their first element, and in case of a tie, by their second element. For example, given `nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]` and `k = 10`, the pairs would be `[[1, 9], [2, 8], [3, 7], [4, 6]]`. Note that each pair should be unique such that the pair `[a, b]` and `[b, a]` are considered the same and should not be duplicated in the result.","solution":"def find_pairs(nums, k): Return all pairs of integers in the array whose sum equals k. Args: nums (list of int): The list of unique integers sorted in ascending order. k (int): The target sum. Returns: list of list of int: List of pairs in ascending order. pairs = [] left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == k: pairs.append([nums[left], nums[right]]) left += 1 right -= 1 elif current_sum < k: left += 1 else: right -= 1 return pairs"},{"question":"You are given an **undirected** graph represented by an integer `n` (the number of nodes) and a 2D integer array `edges`, where `edges[i] = [ui, vi]` denotes a bridge between nodes `ui` and `vi`. A bridge in a graph is an edge that, if removed, would cause the graph to become disconnected. Write a function that finds all the bridges in the graph and returns them as a list of pairs `[ui, vi]`. The pairs should be in lexicographical order. If there are no bridges, return an empty list.","solution":"def find_bridges(n, edges): def dfs(u, parent): nonlocal time discovery_time[u] = low[u] = time time += 1 for v in graph[u]: if discovery_time[v] == -1: # v is not visited dfs(v, u) low[u] = min(low[u], low[v]) if low[v] > discovery_time[u]: bridges.append([u, v] if u < v else [v, u]) elif v != parent: low[u] = min(low[u], discovery_time[v]) graph = [[] for _ in range(n)] for u, v in edges: graph[u].append(v) graph[v].append(u) discovery_time = [-1] * n low = [-1] * n time = 0 bridges = [] for u in range(n): if discovery_time[u] == -1: dfs(u, -1) bridges.sort() return bridges"},{"question":"You are given an array of integers `heights` representing the heights of a number of students standing in a line. The students can be rearranged to form another line. Determine the minimum number of students that should be moved (reordered) so that the students are standing in non-decreasing order of their heights. Implement a function `int minReorder(int[] heights)` that returns the minimum number of moves required.","solution":"def min_reorder(heights): Returns the minimum number of students that should be moved so that the students are standing in non-decreasing order of their heights. # Create a sorted version of the heights list sorted_heights = sorted(heights) # Count the number of positions where the current height in the original list # does not match the height in the sorted list moves = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: moves += 1 # Since we are counting the wrong positions, each move corrects a position return moves"},{"question":"You are given two integer arrays `startTime` and `endTime` and an integer array `profit`, each of length `n`. The `i`th job starts at `startTime[i]`, ends at `endTime[i]`, and demands a profit of `profit[i]`. You need to schedule a subset of these jobs to maximize the total profit. Only one job can be scheduled at a time if a job starts before or at the same time another job ends. Return the maximum profit you can earn by scheduling the subset of jobs.","solution":"from typing import List, Tuple import bisect def job_scheduling(startTime: List[int], endTime: List[int], profit: List[int]) -> int: # Create a combined list of jobs with their respective start time, end time, and profit jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1]) # This will store tuples of (end time, total profit at this end time) dp = [(0, 0)] for start, end, prof in jobs: # Find the maximum profit until the job starts i = bisect.bisect_right(dp, (start, float(\'inf\'))) - 1 current_profit = dp[i][1] + prof # We only add this to efficient if the current profit is greater than the last total profit in dp if current_profit > dp[-1][1]: dp.append((end, current_profit)) return dp[-1][1]"},{"question":"You are given a string `s` which consists of lowercase letters and a 2D list `pairs` where each pair `[i, j]` represents an index swap that can be performed on the string. You may perform any number of swaps. Each swap is independent and does not affect the order of the other elements. Return the lexicographically smallest string that can be formed by performing these swaps. Implement the function `smallestStringWithSwaps(s: str, pairs: List[List[int]]) -> str`.","solution":"from typing import List from collections import defaultdict from itertools import combinations def smallestStringWithSwaps(s: str, pairs: List[List[int]]) -> str: parent = list(range(len(s))) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for x, y in pairs: union(x, y) components = defaultdict(list) for i in range(len(s)): root = find(i) components[root].append(i) res = list(s) for indices in components.values(): sorted_chars = sorted(res[i] for i in indices) for i, char in zip(sorted(indices), sorted_chars): res[i] = char return \'\'.join(res)"},{"question":"A directed graph is represented using an adjacency list where each node contains its value and the list of its neighbors. Implement a function that checks if there is a cycle in the directed graph. You are provided with the graph in the form of a dictionary where keys are node values and values are lists of neighboring node values. Return `True` if the graph contains a cycle, otherwise return `False`.","solution":"def has_cycle(graph): Checks if a directed graph contains a cycle. Parameters: graph (dict): Dictionary where keys are node values and values are lists of neighboring node values. Returns: bool: True if the graph contains a cycle, False otherwise. def visit(node): if node in temp_mark: return True if node in perm_mark: return False temp_mark.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True temp_mark.remove(node) perm_mark.add(node) return False temp_mark = set() perm_mark = set() for node in graph: if visit(node): return True return False"},{"question":"Given a binary tree, each node contains an integer value. The level of a node in the tree is the depth of the node, starting from 0 for the root node. Return the largest value in each row (level) of the tree in the form of an array of these largest values. For example, given the input binary tree: ``` 1 / 3 2 / 5 3 9 ``` The output should be [1, 3, 9], where `1` is the largest value at level 0, `3` is the largest value at level 1, and `9` is the largest value at level 2.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float(\'-inf\') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"You are given an array of integers `arr` and a positive integer `k`. Your task is to divide this array into exactly `k` non-empty subarrays such that the largest sum among these subarrays is minimized. Return the minimized largest sum. Each subarray\'s sum is the sum of its elements, and you must use every element of the array in some subarray. Submissions will be assessed based on correctness and efficiency. If your algorithm exceeds the time complexity deemed acceptable for the size constraints, it will be judged as inefficient.","solution":"def splitArray(nums, k): def can_split(mid): curr_sum = 0 parts = 1 for num in nums: if curr_sum + num > mid: parts += 1 curr_sum = num if parts > k: return False else: curr_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"Given a list of integers, implement an algorithm to find the length of the longest consecutive elements sequence. The sequences are defined using any of the integers from the list, and they do not have to be adjacent to each other. However, a sequence must be strictly increasing or decreasing by exactly one integer for each step. For example, in the list `[100, 4, 200, 1, 3, 2]`, the longest consecutive elements sequence is `[1, 2, 3, 4]` with a length of 4. Note that duplicates in the list should be handled, such that each individual occurrence of a duplicate can only be used once in the sequence. Implement an efficient algorithm to solve this problem.","solution":"def longest_consecutive_sequence(nums): Finds the length of the longest consecutive elements sequence in a list of integers. if not nums: return 0 num_set = set(nums) # Use a set to allow O(1) lookups max_length = 0 for num in nums: if num - 1 not in num_set: # Start of a new sequence current_length = 1 current_num = num while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"Write a function `maxConsecutiveOnes(nums: List[int]) -> int` that takes a list of binary integers `nums` and returns the maximum number of consecutive `1`\'s in the list.","solution":"def maxConsecutiveOnes(nums): Returns the maximum number of consecutive 1\'s in the list of binary integers. max_count = 0 current_count = 0 for num in nums: if num == 1: current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 0 return max_count"},{"question":"You are given an array of integers `heights` representing the height of students standing in a line. A group photo can only be taken when the students stand in **non-decreasing** order of their heights. Your task is to determine the minimum number of students that need to be moved to achieve a configuration where the students in the line are in non-decreasing order by their heights. Return the minimum number of moves required.","solution":"def min_moves_to_sort_heights(heights): Determines the minimum number of students that need to be moved to achieve a configuration where the students are in non-decreasing order by their heights. :param heights: List[int] - A list of integers representing the heights of students. :return: int - The minimum number of moves required. n = len(heights) lis = [1] * n # Longest Increasing Subsequence length for each position for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: lis[i] = max(lis[i], lis[j] + 1) max_lis = max(lis) return n - max_lis # Minimum moves to make the array sorted"},{"question":"Given a string `s` consisting of only lowercase English letters, you need to perform the following operation exactly once: - Select any character in `s` and replace all its occurrences with any other lowercase English letter. Return the maximum number of distinct characters in the resulting string after the operation. A string is said to have distinct characters if every character in the string appears exactly once. For example, `\\"aabbcc\\"` has `3` distinct characters, namely `\\"a\\"`, `\\"b\\"`, and `\\"c\\"`. Write a function: ```python def max_distinct_after_replacement(s: str) -> int: # Your code here ``` # Constraints: - `1 <= len(s) <= 1000` - `s` consists of only lowercase English letters.","solution":"def max_distinct_after_replacement(s: str) -> int: Returns the maximum number of distinct characters possible in the string `s` after replacing all occurrences of any one character with any other lowercase English letter. from collections import Counter # Get the frequency of each character in the string char_count = Counter(s) # Total initial distinct characters distinct_chars = len(char_count) # If s already contains 26 distinct letters (all letters of alphabet) if distinct_chars == 26: return 26 # Find the character that appears the most frequently most_freq_char_count = max(char_count.values()) # We can replace this most frequent character with some other character # If the most frequent character has a frequency of 1, replacing it will reduce distinct character count if most_freq_char_count == 1: return distinct_chars # Otherwise, replacing it to make some other one unique will increase unique char count by 1 return distinct_chars + 1"},{"question":"You are given a binary tree root. Each node in the tree contains an integer value. A valid path in the binary tree is any path that starts at some node and goes downwards, meaning it can only move to adjacent nodes in the tree (from a parent to a child). The path sum of a valid path is the sum of the values in the path. Given an integer targetSum, return the number of paths that sum to targetSum. The same node cannot be counted more than once in a path. You may assume that the given input will only consist of a binary tree and an integer targetSum. Consider path directions and sum possibilities within the scope of tree traversal algorithms.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, targetSum): def dfs(node, current_path): if not node: return 0 # Add current node value to current path list current_path.append(node.val) path_count = 0 path_sum = 0 # Traverse backward to see if any sub-path sums to target for val in reversed(current_path): path_sum += val if path_sum == targetSum: path_count += 1 # Continue DFS on child nodes path_count += dfs(node.left, current_path) path_count += dfs(node.right, current_path) # Remove current node value from current path list before returning current_path.pop() return path_count return dfs(root, [])"},{"question":"You are given two binary trees `root1` and `root2`. A node in either tree is considered equivalent to another node if they have the same value. The trees are considered flip equivalent if they are either both null or they are equivalent and one of these conditions holds: - the left child of `root1` is flip equivalent to the left child of `root2` and the right child of `root1` is flip equivalent to the right child of `root2` - or the left child of `root1` is flip equivalent to the right child of `root2` and the right child of `root1` is flip equivalent to the left child of `root2` Write a function that takes the roots of two binary trees as inputs and returns whether the two trees are flip equivalent.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def are_flip_equivalent(root1, root2): Determines if two binary trees are flip equivalent. Args: root1: TreeNode - The root node of the first binary tree root2: TreeNode - The root node of the second binary tree Returns: bool - True if the binary trees are flip equivalent, False otherwise if root1 is None and root2 is None: return True if root1 is None or root2 is None: return False if root1.val != root2.val: return False return (are_flip_equivalent(root1.left, root2.left) and are_flip_equivalent(root1.right, root2.right)) or (are_flip_equivalent(root1.left, root2.right) and are_flip_equivalent(root1.right, root2.left))"},{"question":"You are given an array of strings `words` and a string `target`. Each word in `words` can be formed by a sequence of insertions (possibly zero) made to `target`. Return the length of the longest word in `words` that can be formed by inserting some characters into `target` without changing the order of the existing characters in `target`. A word in `words` is valid if it can become `target` after removing some characters.","solution":"def is_subsequence(target, word): it = iter(target) return all(char in it for char in word) def longest_valid_word(words, target): Returns the length of the longest word in words that can be formed by inserting characters into target without changing the order of target. longest_length = 0 for word in words: if is_subsequence(target, word): longest_length = max(longest_length, len(word)) return longest_length"},{"question":"Design a CacheSystem class with the following functionalities: 1. `put(key, value)`: Insert the key-value pair into the cache. If the key is already present, update its value. 2. `get(key)`: Retrieve the value associated with the key from the cache. If the key is not present, return -1. 3. `evict()`: Remove the least recently used (LRU) key-value pair from the cache. In case of a tie, any one of the least recently used could be removed. 4. `size()`: Return the current number of key-value pairs in the cache. Initially, the cache is empty. The cache should hold a maximum of `n` key-value pairs; once the size exceeds this limit, an eviction should occur automatically to maintain the size limit.","solution":"from collections import OrderedDict class CacheSystem: def __init__(self, capacity: int): Initialize the cache with a given capacity. self.cache = OrderedDict() self.capacity = capacity def put(self, key, value): Insert or update the key-value pair in the cache. if key in self.cache: self.cache.move_to_end(key) # move key to the end to mark it as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.evict() def get(self, key): Retrieve the value associated with the key from the cache. If the key isn\'t present, return -1. if key in self.cache: self.cache.move_to_end(key) # move key to the end to mark it as recently used return self.cache[key] return -1 def evict(self): Remove the least recently used (LRU) key-value pair from the cache. self.cache.popitem(last=False) def size(self): Return the current number of key-value pairs in the cache. return len(self.cache)"},{"question":"You are given an array `arr` of integers, where `arr[i]` represents the height of the `i-th` building in a row of buildings. The goal is to find out how many buildings in the row have an unobstructed view of the sunset, assuming that all the buildings face west. A building has an unobstructed view of the sunset if there are no taller buildings to the west (to its left). Return _an array containing the indices of the buildings that have an unobstructed view of the sunset, starting from index `0`_. The indices in the output array should be sorted in increasing order.","solution":"def buildings_with_sunset_view(arr): Returns the indices of buildings that have an unobstructed view of the sunset. unobstructed_view_indices = [] max_height_so_far = -1 for i in range(len(arr)): if arr[i] > max_height_so_far: unobstructed_view_indices.append(i) max_height_so_far = arr[i] return unobstructed_view_indices"},{"question":"Given a list of integers representing the sizes of files, and a limit representing the maximum allowed total size for a group of files, write a function to determine the minimum number of groups required to store all the files without exceeding the given limit for any group. Each group can contain one or more files, and the sum of the sizes of the files in a group must not exceed the specified limit. Your function should return the minimum number of groups needed to achieve this. Note: You can assume the file sizes and the limit are positive integers.","solution":"def min_groups(file_sizes, limit): Determines the minimum number of groups required to store all the files without exceeding the given limit for any group. Parameters: file_sizes (list of int): The sizes of the files. limit (int): The maximum allowed total size for a group of files. Returns: int: The minimum number of groups needed. file_sizes.sort(reverse=True) groups = [] for file in file_sizes: found_group = False for group in groups: if sum(group) + file <= limit: group.append(file) found_group = True break if not found_group: groups.append([file]) return len(groups)"},{"question":"A **run-length encoded** string is a string where consecutive characters are stored as a single character and its count. For example, the string `\\"aaabbc\\"` would be encoded as `\\"a3b2c1\\"`. Write a function to decode a given run-length encoded string `s` back to its original form. For example, if the input string is `\\"a3b2c1\\"`, the output should be `\\"aaabbc\\"`. The input string will always be valid and will follow the format where character counts are positive integers greater than zero and appear immediately after their respective characters.","solution":"def decode_run_length(encoded: str) -> str: Decodes the run-length encoded string. :param encoded: The run-length encoded string :return: The original decoded string decoded_str = \\"\\" i = 0 while i < len(encoded): char = encoded[i] count = \\"\\" i += 1 # Collect all digits that represent the count while i < len(encoded) and encoded[i].isdigit(): count += encoded[i] i += 1 # Append the character count times to the decoded string decoded_str += char * int(count) return decoded_str"},{"question":"You are given a set of `n` unique integers and an integer `k`. Your task is to determine **whether** there exists a **subset** of size `k` from these integers such that the **mean** of the subset is an integer. If such a subset exists, return _true_, otherwise return _false_. The mean of a subset is the sum of its elements divided by the number of elements in the subset. For example, if the subset is `[2, 4, 6]`, the mean is `(2 + 4 + 6) / 3 = 4`, which is an integer. **Input Format:** - `int n`: The size of the set of integers. - `int k`: The size of the subset to check. - `int[] nums`: An array of `n` unique integers. **Output Format:** - A boolean value indicating whether such a subset exists. **Example:** ```python # Input n = 5 k = 3 nums = [1, 2, 3, 4, 5] # Output True ```","solution":"from itertools import combinations def subset_mean_is_integer(n, k, nums): Determines if there exists a subset of size k such that the mean is an integer. if k > n: return False for comb in combinations(nums, k): if sum(comb) % k == 0: return True return False"},{"question":"Given two **positive** integers `a` and `b`, return _the largest positive integer that divides **both**_ `a` _and_ `b`.","solution":"def gcd(a, b): Returns the largest positive integer that divides both a and b. while b: a, b = b, a % b return a"},{"question":"You have a grid of size `m x n` representing a field of cherries. Each cell in the grid contains an integer representing the number of cherries in that cell, or -1 if the cell is impassable. Your task is to collect the maximum cherries possible by following these rules: - You can only start at the top-left cell (0, 0) and initially proceed towards the bottom-right cell (m-1, n-1). - Once you reach the bottom-right cell, you must then go back to the top-left by reversing your route. - At each step, you may move either down or to the right, but you cannot move left or up. - If you pass through a cell with cherries, you must pick them up, and you cannot pick cherries from the same cell more than once. Given the grid `grid`, return _the maximum number of cherries you can collect by following the rules above. If it is impossible to reach the bottom-right cell or return to the top-left, return `0`_.","solution":"def cherryPickup(grid): def memoize(f): memo = {} def helper(*args): if args not in memo: memo[args] = f(*args) return memo[args] return helper @memoize def dfs(r1, c1, r2, c2): # If out of bounds or impassable if r1 >= N or r2 >= N or c1 >= N or c2 >= N or grid[r1][c1] == -1 or grid[r2][c2] == -1: return -float(\'inf\') # If both persons have reached the bottom-right corner if r1 == N-1 and c1 == N-1: return grid[r1][c1] # Collect cherries with both persons if r1 == r2 and c1 == c2: cherries = grid[r1][c1] else: cherries = grid[r1][c1] + grid[r2][c2] # Move to the next step cherries += max(dfs(r1+1, c1, r2+1, c2), dfs(r1+1, c1, r2, c2+1), dfs(r1, c1+1, r2+1, c2), dfs(r1, c1+1, r2, c2+1)) return cherries N = len(grid) result = dfs(0, 0, 0, 0) return max(0, result)"},{"question":"You are given a string `s` and an integer `k`. Your task is to partition the string into as many parts as possible so that each part is a palindrome and each part has a length of at least `k`. Return the list of partitions in the order they appear in the string. If it\'s not possible to partition the string in such a way, return an empty list.","solution":"def is_palindrome(s): Checks if a given string is a palindrome. return s == s[::-1] def partition_palindromes(s, k): Partitions the given string s into as many parts as possible such that each part is a palindrome and each part has a length of at least k. Returns the list of partitions or an empty list if not possible. n = len(s) partitions = [] i = 0 while i < n: found = False for j in range(i + k, n + 1): if is_palindrome(s[i:j]): partitions.append(s[i:j]) i = j found = True break if not found: return [] return partitions"},{"question":"Given a list of positive integers `nums` and an integer `target`, return _the **number** of **unique pairs** of elements in_ `nums` _such that their **sum** is equal to_ `target`. Each pair of elements must be distinct and the order of elements in the pair does not matter. Pairs (a, b) and (b, a) are considered the same. If no such pairs exist, return `0`.","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs in nums that add up to target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"You are given a matrix `rooms` representing a 2D grid of rooms where: - `-1` represents a wall or an obstacle. - `0` represents a gate. - `INF` represents an empty room. It\'s guaranteed that `INF` will be given as `2^31 - 1`. Fill each empty room with the distance to its **nearest gate**. If it is impossible to reach a gate, leave the room with `INF` as its value. Modify the `rooms` matrix **in-place**. The distance is measured in terms of the number of steps to reach a gate directly in the left, right, up, or down direction.","solution":"from collections import deque def walls_and_gates(rooms): Modify the given 2D grid of rooms in-place to fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave the room with INF as its value. :param rooms: List[List[int]] :return: None if not rooms or not rooms[0]: return INF = 2**31 - 1 rows, cols = len(rooms), len(rooms[0]) queue = deque() for r in range(rows): for c in range(cols): if rooms[r][c] == 0: queue.append((r, c)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: r, c = queue.popleft() for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and rooms[rr][cc] == INF: rooms[rr][cc] = rooms[r][c] + 1 queue.append((rr, cc))"},{"question":"You are given a grid of numbers represented as a 2D array `grid`, with `n` rows and `m` columns. Your task is to find the largest sum of any rectangular subgrid within `grid`. The subgrid must be non-empty and contiguous. Return the maximum sum of any such subgrid.","solution":"def max_sum_subgrid(grid): Returns the maximum sum of any subgrid in the given 2D grid. Args: grid (list of list of int): 2D list representing the grid. Returns: int: The maximum sum of any rectangular subgrid within the given grid. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) max_sum = float(\'-inf\') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += grid[i][right] current_max = kadane(temp) max_sum = max(max_sum, current_max) return max_sum def kadane(array): Helper function to calculate the maximum sum of a contiguous subarray. max_end_here = max_so_far = array[0] for x in array[1:]: max_end_here = max(x, max_end_here + x) max_so_far = max(max_so_far, max_end_here) return max_so_far"},{"question":"Given a directed graph represented as an adjacency list, write a function to determine if there is a cycle in the graph. The graph is represented as a dictionary where each key is a node, and its value is a list of nodes to which it has edges. Nodes are numbered from `0` to `n-1`. Your function should return a boolean value indicating whether the graph contains a cycle. **Function Signature:** ```python def has_cycle(graph: Dict[int, List[int]]) -> bool: pass ```","solution":"from typing import List, Dict def has_cycle(graph: Dict[int, List[int]]) -> bool: def dfs(node): if visiting[node]: return True # found a back edge indicating a cycle if visited[node]: return False # already processed this node visiting[node] = True for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting[node] = False visited[node] = True return False visited = {node: False for node in graph} visiting = {node: False for node in graph} for node in graph: if not visited[node]: # Don\'t visit already processed nodes if dfs(node): return True return False"},{"question":"You are given a map of a grid represented by a 2D integer array `grid` where: - `0` represents an empty cell, - `1` represents a fresh orange, - `2` represents a rotten orange. Every minute, any fresh orange that is adjacent (up, down, left, right) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return `-1`. **Note:** You may assume that the grid is borderless, i.e., has no edges that confine the spread of rot, and the spread of rot happens infinitely in all directions provided there are fresh oranges adjacent to a rotten one.","solution":"from collections import deque def orangesRotting(grid): Given a 2D grid where: - 0 represents an empty cell, - 1 represents a fresh orange, - 2 represents a rotten orange. Returns the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, returns -1. rows, cols = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Add all initially rotten oranges to the queue and count fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh_oranges += 1 # Directions array for up, down, left, right adjacent cells directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] minutes = 0 # Perform BFS to rot all adjacent fresh oranges while queue and fresh_oranges > 0: minutes += 1 for _ in range(len(queue)): x, y = queue.popleft() for dr, dc in directions: nx, ny = x + dr, y + dc if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: # This fresh orange now becomes rotten grid[nx][ny] = 2 queue.append((nx, ny)) fresh_oranges -= 1 return minutes if fresh_oranges == 0 else -1"},{"question":"You are given a list of strings `words` and a reference string `reference`. A word from the `words` list can be transformed into another word if the new word can be obtained by rearranging the letters and/or changing exactly one letter in the original word. Return the maximum number of transformations needed to turn any word in the list into the reference string. If no transformation is possible, return `-1`.","solution":"def can_transform(word, reference): Returns True if the word can be transformed into the reference by rearranging the letters and/or changing exactly one letter. if sorted(word) == sorted(reference): return True if len(word) != len(reference): return False diff_count = sum(1 for a, b in zip(word, reference) if a != b) return diff_count == 1 def max_transformations(words, reference): Returns the maximum number of transformations needed to turn any word in the list into the reference string. If no transformation is possible, returns -1. transformations = 0 for word in words: if can_transform(word, reference): transformations += 1 return transformations if transformations > 0 else -1"},{"question":"You are given an integer array `heights` representing the heights of blocks stacked vertically. You are also given an integer `k` representing the maximum number of adjacent blocks over which you can jump. Starting from the first block, return the minimum number of jumps needed to reach the last block in the array. If it is not possible to reach the last block, return `-1`.","solution":"from collections import deque def min_jumps(heights, k): Returns the minimum number of jumps needed to reach the last block in the array. Returns -1 if it is not possible to reach the last block. n = len(heights) if n == 1: return 0 jumps = [-1] * n queue = deque([0]) jumps[0] = 0 while queue: current = queue.popleft() for step in range(1, k + 1): next_block = current + step if next_block < n and jumps[next_block] == -1 and abs(heights[next_block] - heights[current]) <= k: jumps[next_block] = jumps[current] + 1 if next_block == n - 1: return jumps[next_block] queue.append(next_block) return -1"},{"question":"You are given a string `s` consisting of lowercase alphabets. Reverse every word in the string. A word is defined as a sequence of non-space characters. The words in `s` will be separated by a single space. Return the string obtained after reversing every word in `s`, while preserving the whitespaces.","solution":"def reverse_words(s): Reverses every word in the string s. Each word is separated by a single space. # Split the string by spaces words = s.split(\' \') # Reverse each word and join them with a space reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"Write a function that takes a list of non-negative integers `nums` and returns the next lexicographical permutation of the list. If such an arrangement is not possible, the function should rearrange the list into the lowest possible order (i.e., sorted in ascending order). The replacement must be in-place and use only constant extra memory.","solution":"def next_permutation(nums): Modifies nums in-place to the next lexicographical permutation. If no such permutation exists, rearrange nums to the lowest possible order (sorted in ascending order). # Find the first decreasing element from the end i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Find the element just larger than nums[i] to its right j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap the elements at i and j nums[i], nums[j] = nums[j], nums[i] # Reverse the elements to the right of i nums[i + 1:] = nums[i + 1:][::-1]"},{"question":"A company wants to build a binary tree from a list of node values given in level order (breadth-first order). Implement a function `buildTree(level_order)` that takes in a list of integer values `level_order` representing the nodes of the binary tree in level order traversal. Each element in the list can either be an integer or `None`, where `None` signifies that the position is empty (no node). Each node in the binary tree has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your task is to construct the binary tree from the given list and return the root node of the tree. If the list is empty, return `None`. **Example Input:** ```python level_order = [1, 2, 3, None, 4, 5, None] ``` **Example Output:** ```python # The binary tree should be constructed as: # 1 # / # 2 3 # / # 4 5 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(level_order): if not level_order: return None root = TreeNode(level_order[0]) queue = [root] i = 1 while i < len(level_order): currentNode = queue.pop(0) if currentNode: if i < len(level_order) and level_order[i] is not None: currentNode.left = TreeNode(level_order[i]) queue.append(currentNode.left) i += 1 if i < len(level_order) and level_order[i] is not None: currentNode.right = TreeNode(level_order[i]) queue.append(currentNode.right) i += 1 return root"},{"question":"You are given a string `text` consisting of lowercase English letters and a list of strings `words`. Return _the longest string in_ `words` _such that it is a **subsequence** of_ `text`. If there is more than one possible result, return the longest string that appears earliest in `words`. A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.","solution":"def is_subsequence(s, t): Check if s is a subsequence of t. Parameters: s (str): The subsequence string to verify. t (str): The main string to check against. Returns: bool: True if s is a subsequence of t, else False. it = iter(t) return all(char in it for char in s) def find_longest_subsequence(text, words): Returns the longest string in words that is a subsequence of text. Parameters: text (str): The main string to check against. words (list of str): The list of words to check. Returns: str: The longest subsequence found in text. longest_word = \\"\\" for word in words: if is_subsequence(word, text): if len(word) > len(longest_word) or (len(word) == len(longest_word) and words.index(word) < words.index(longest_word)): longest_word = word return longest_word"},{"question":"Given an array of integers `arr` and an integer `d`, you must choose elements from the array such that the difference between the maximum and minimum elements in the chosen subset is at most `d`. Return _the length of the longest such subset you can form_. All elements in the subset must not necessarily be contiguous in the original array.","solution":"def longest_subarray_length(arr, d): Returns the length of the longest subset such that the difference between the maximum and minimum elements is at most d. if not arr: return 0 # Sort the array arr.sort() left = 0 max_length = 0 for right in range(len(arr)): # If the difference exceeds d, move the left pointer to the right while arr[right] - arr[left] > d: left += 1 # Calculate the length of the current subarray max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. Your task is to partition the array into two contiguous subarrays `left` and `right` such that: - Every element in `left` is less than or equal to every element in `right`. - Both `left` and `right` are non-empty. Return _the minimum possible length of `left` after the partition_. If there is no valid way to partition the array, return `-1`. After the partition: * `left` array should be `nums[0]...nums[p]` * `right` array should be `nums[p + 1]...nums[n-1]` where `p` is the index at which the array is partitioned (`p` is the last index of `left`).","solution":"def partition_disjoint(nums): Returns the minimum possible length of `left` after the partition such that every element in `left` is less than or equal to every element in `right` and both `left` and `right` are non-empty. # Initialize variables n = len(nums) max_left = [0] * n min_right = [0] * n # Fill the max_left array max_left[0] = nums[0] for i in range(1, n): max_left[i] = max(max_left[i-1], nums[i]) # Fill the min_right array min_right[-1] = nums[-1] for i in range(n-2, -1, -1): min_right[i] = min(min_right[i+1], nums[i]) # Find the partition index for i in range(1, n): if max_left[i-1] <= min_right[i]: return i return -1"},{"question":"Given two sorted arrays `arr1` and `arr2`, merge them into one sorted array without using any built-in library functions that handle sorting. The resulting array should be in non-decreasing order.","solution":"def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into one sorted array. merged_array = [] i = j = 0 # Traverse both arrays and pick the smallest element from either array while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # If there are remaining elements in arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # If there are remaining elements in arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"Given a string `s` containing only lowercase English letters, return the length of the longest substring with at most two distinct characters. If there are multiple substrings with the same length, return any one of them. Your solution should have a time complexity of `O(n)`.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring containing at most two distinct characters. if not s: return 0 # Dictionary to keep count of characters char_count = {} left = 0 right = 0 max_len = 0 while right < len(s): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"You are given a string `s` and an integer `numRows`. Convert the string to a zigzag pattern on a given number of rows like this: ``` P I N A L S I G Y A H R P I ``` Then, read the pattern line by line to get the output string. Write the code that will take a string `s` and an integer `numRows` and return the string coded in a zigzag pattern.","solution":"def convert(s, numRows): Convert the string s to a zigzag pattern on a given number of rows. :param s: input string :param numRows: number of rows for zigzag pattern :return: string coded in a zigzag pattern if numRows == 1 or numRows >= len(s): return s rows = [\'\'] * numRows current_row = 0 going_down = False for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 return \'\'.join(rows)"},{"question":"You are given an array of integers representing the heights of the buildings in a city skyline. The array is structured such that heights[i] is the height of the ith building. Write a program that calculates the maximum area of a rectangle formed by any combination of contiguous buildings. Function signature: ```python int maxRectangleArea(int[] heights) ```","solution":"def maxRectangleArea(heights): Calculate the maximum area of a rectangle formed by any combination of contiguous buildings. :param heights: List[int] - a list of integer heights for the buildings. :return: int - the maximum rectangle area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an array `edges` representing an undirected graph with `n` nodes, where `edges[i] = [ui, vi]` indicates there is an edge between nodes `ui` and `vi`. Each node has a unique integer value assigned to it, which you can find in the array `values`. Moreover, you have access to an integer `sum_target` representing a target sum. A path in the graph is defined as any sequence of nodes `p1, p2, ..., pk`, such that there is an edge between every two consecutive nodes in the sequence. The sum of a path is the combined value of all nodes in that path. Return `true` if there exists a path in the graph such that the sum of the values of the nodes in that path equals `sum_target`. Otherwise, return `false`.","solution":"from collections import defaultdict, deque def does_path_with_sum_exist(n, edges, values, sum_target): # Create the graph as an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Function to perform BFS to find paths with the target sum def bfs(start_node): queue = deque([(start_node, values[start_node], {start_node})]) while queue: current_node, current_sum, visited = queue.popleft() if current_sum == sum_target: return True for neighbor in graph[current_node]: if neighbor not in visited: new_visited = set(visited) new_visited.add(neighbor) queue.append((neighbor, current_sum + values[neighbor], new_visited)) return False # Check each node as a start node for node in range(n): if bfs(node): return True return False"},{"question":"You are given a string `expr` representing a valid mathematical expression containing integers, the operators `+`, `-`, `*`, `/`, and parentheses `(` and `)`. Your task is to evaluate the expression and return the result as an integer. The integer division should truncate toward zero. Use the standard operator precedence and parentheses rules when evaluating the expression.","solution":"def evaluate_expression(expr): Evaluate a mathematical expression and return the result as an integer. The expression can contain integers, +, -, *, / operators, and parentheses. import re def parse_expression(tokens): Parse and evaluate the tokens using a recursive approach to handle parentheses. stack = [] num = 0 sign = \'+\' def apply_operation(stack, sign, num): if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': top = stack.pop() stack.append(int(top / num)) # Truncate towards zero while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) elif token in \\"+-*/\\": apply_operation(stack, sign, num) num = 0 sign = token elif token == \'(\': num = parse_expression(tokens) elif token == \')\': break apply_operation(stack, sign, num) return sum(stack) # Tokenize the expression tokens = re.findall(r\'d+|[+*/()-]\', expr.replace(\' \', \'\')) return parse_expression(tokens)"},{"question":"You are given a string `s` containing lowercase English letters. You have to remove the duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Write an algorithm that accepts `s` and returns the modified version of the string.","solution":"def remove_duplicate_letters(s): Remove duplicate letters from s to ensure every letter appears once and only once, and the result is the smallest in lexicographical order among all possible results. stack = [] seen = set() last_occurrence = {char: idx for idx, char in enumerate(s)} for idx, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and idx < last_occurrence[stack[-1]]: seen.discard(stack.pop()) seen.add(char) stack.append(char) return \'\'.join(stack)"},{"question":"You are given a list of non-negative integers `nums` and an integer `x`. Your task is to determine if there exist two elements in the list whose product is equal to `x`. Return `true` if such elements are found, otherwise return `false`. The solution should have a time complexity better than O(n^2).","solution":"def has_pair_with_product(nums, x): Determine if there exist two elements in the list nums whose product is equal to x. if x == 0 and nums.count(0) > 1: return True seen = set() for number in nums: if number != 0 and x % number == 0: if (x // number) in seen: return True seen.add(number) return False"},{"question":"You are given an integer array called `heights`, where each element represents the height of a person. You are also provided an integer `k` which denotes the maximum allowable difference in height between any two people standing next to each other in a line. Your task is to partition the array into the minimum number of contiguous subarrays so that in each subarray, the difference between the maximum and minimum height does not exceed `k`. Return _the minimum number of such subarrays_.","solution":"def minimum_subarrays(heights, k): if not heights: return 0 subarrays = 1 start = 0 for i in range(1, len(heights)): if max(heights[start:i + 1]) - min(heights[start:i + 1]) > k: subarrays += 1 start = i return subarrays"},{"question":"You are given a list of strings `words` and a string `target`. Return the minimum number of `words` in the list required to form the `target` string. Each word from the list can be used multiple times. If it is not possible to create the `target` string using the given `words`, return `-1`.","solution":"def min_words_to_form_target(words, target): from functools import lru_cache @lru_cache(None) def helper(remaining): if remaining == \\"\\": return 0 min_count = float(\'inf\') for word in words: if remaining.startswith(word): next_state = remaining[len(word):] count = helper(next_state) if count != float(\'inf\'): min_count = min(min_count, count + 1) return min_count result = helper(target) return result if result != float(\'inf\') else -1"},{"question":"You are given a linked list where each node contains a positive integer value. The linked list represents a number with each node as a digit (1-9). You need to increment the number by 1 and update the linked list accordingly. The digits are stored in **reverse order**, which means that the 1\'s place is at the head of the list. Write a function that takes the head of the linked list as input and returns the head of the updated linked list representing the incremented number. Note that you should handle cases where the increment causes a carry to propagate through the entire linked list, potentially adding a new digit at the end.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def incrementLinkedList(head): Increment the number represented by the linked list by 1. The digits are stored in reverse order. :param head: Head node of the linked list :return: Head node of the updated linked list if not head: return ListNode(1) carry = 1 current = head prev = None while current and carry: current.val += carry if current.val == 10: current.val = 0 carry = 1 else: carry = 0 prev = current current = current.next if carry: prev.next = ListNode(1) return head"},{"question":"Given an array of distinct integers `nums` and a target integer `k`, return the `k-th` smallest element in the array. Note that it is the `k-th` smallest element **in sorted order**, not the `k-th` distinct element. Implement this in optimal time complexity.","solution":"import heapq def kth_smallest_element(nums, k): Returns the k-th smallest element in the given array of distinct integers. if not nums or k < 1 or k > len(nums): raise ValueError(\\"Invalid input: nums should be non-empty and k should be within the range of the array length.\\") heapq.heapify(nums) return heapq.nsmallest(k, nums)[-1]"},{"question":"You are given an array `arr` of positive integers of size `n` and an integer `k`. You can perform the following operation exactly once: choose any subarray of `arr` and reverse it. After performing this operation, you want to maximize the sum of the largest `k` elements in the array. Return the maximum possible sum of the largest `k` elements in the array after the operation.","solution":"def max_sum_of_largest_k_after_reversal(arr, n, k): Returns the maximum possible sum of the largest k elements in the array arr after reversing exactly one subarray. # Initialize the initial max sum from the largest k elements without any reversal. arr_sorted = sorted(arr, reverse=True) max_sum = sum(arr_sorted[:k]) # Try reversing each possible subarray to find the maximum sum of largest k elements. for i in range(n): for j in range(i+1, n+1): # Reverse the subarray from index i to j-1 new_arr = arr[:i] + arr[i:j][::-1] + arr[j:] # Sort the array in descending order new_arr_sorted = sorted(new_arr, reverse=True) # Get the sum of the top k elements current_sum = sum(new_arr_sorted[:k]) # Update the max_sum if current_sum is larger max_sum = max(max_sum, current_sum) return max_sum # Example usage: arr = [1, 3, 2, 7, 5, 6] n = len(arr) k = 3 print(max_sum_of_largest_k_after_reversal(arr, n, k)) # Output should be 18"},{"question":"Given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. Do not allocate another 2D matrix and do the rotation. Ensure that your solution has a time complexity of O(n^2).","solution":"def rotate(matrix): Rotates an n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]] - the n x n 2D matrix n = len(matrix) # Transpose the matrix (swap rows with columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row to get the rotated matrix for i in range(n): matrix[i].reverse()"},{"question":"Given a list of non-overlapping intervals, merge any subintervals that overlap with the elements of an additional list of intervals. Each interval is represented as a pair of integers `[start, end]` where `start` is less than `end`. Return the resulting list of non-overlapping intervals after merging. The output should be sorted by the starting point of each interval.","solution":"def merge_intervals(existing_intervals, new_intervals): Merges any subintervals that overlap with the elements of an additional list of intervals. Return the resulting list of non-overlapping intervals after merging. :param existing_intervals: List of existing non-overlapping intervals :param new_intervals: Additional list of intervals to merge :return: List of non-overlapping intervals after merging intervals = existing_intervals + new_intervals intervals.sort(key=lambda x: x[0]) # sort by starting point merged = [] for interval in intervals: if not merged or merged[-1][1] < interval[0]: # no overlap merged.append(interval) else: # merge the intervals merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"Given a `2D` matrix of integers `mat` with dimensions `m x n`, you need to return the matrix where each cell contains the sum of the original values of the elements in its `3x3` neighborhood. If some elements in the `3x3` neighborhood lie outside the boundary of the matrix, treat them as zero. Specifically, for each cell `(i, j)` in the new matrix, compute the sum of all elements `mat[x][y]` where `i-1  x  i+1` and `j-1  y  j+1` and replace the value of the cell `(i, j)` with this sum. Implement the function `def matrix_sum_3x3_neighborhood(mat: List[List[int]]) -> List[List[int]]:` - The function should return a new `2D` matrix representing the described transformations. - Preserve the dimensions of the original matrix. Note: - You\'ll often encounter edge cases where the `3x3` window goes beyond the boundaries of the matrix. Handle these by assuming out-of-bound digits as zero.","solution":"from typing import List def matrix_sum_3x3_neighborhood(mat: List[List[int]]) -> List[List[int]]: def get_val(x, y): if 0 <= x < len(mat) and 0 <= y < len(mat[0]): return mat[x][y] return 0 m, n = len(mat), len(mat[0]) result = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): total = 0 for x in range(i-1, i+2): for y in range(j-1, j+2): total += get_val(x, y) result[i][j] = total return result"},{"question":"You are given an array of integers `buildings` where each element represents the height of a building. You need to find the number of buildings from which you can see the sunset, given that the sunset can only be seen if there are no taller buildings to the right. The buildings are represented in a line from left to right, where `buildings[0]` is the leftmost building and `buildings[n-1]` is the rightmost building. Return the number of buildings that have a clear view of the sunset.","solution":"def count_sunset_buildings(buildings): Returns the number of buildings with a clear view of the sunset. Arguments: buildings -- a list of integers representing the heights of the buildings Returns: int -- the count of buildings with a clear view of the sunset count = 0 max_height_so_far = 0 for height in buildings: if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"You are given an array of integers `arr`. Each integer in the array represents the height of a tree in a forest. You can cut down a tree to any height, but you can only perform this operation a maximum of `k` times across all the trees. Return _the maximum possible difference between the heights of the tallest and shortest tree in the forest after performing at most `k` operations_.","solution":"def max_possible_difference(arr, k): arr.sort() return arr[-1] - arr[0]"},{"question":"You are given an array of integers `students` where each `students[i]` represents the height of the `ith` student in a line. The teacher wants to create a non-decreasing line formation by moving some of the students to new positions. However, to minimize disruption, the teacher wants to find the length of the longest non-decreasing subsequence that can be obtained from `students` without repositioning any elements. Return the length of this subsequence.","solution":"def length_of_non_decreasing_subsequence(students): Returns the length of the longest non-decreasing subsequence that can be obtained from the given list \'students\'. if not students: return 0 n = len(students) # dp[i] will be the length of longest non-decreasing subsequence ending at index i dp = [1] * n for i in range(1, n): for j in range(0, i): if students[i] >= students[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a binary tree with `n` nodes. Each node has a value associated with it. You need to find the level of the tree that has the maximum sum of node values. Level of the root node is 0, the level of its direct children is 1, and so on. Return the level with the maximum sum of node values. If there are multiple levels with the same maximum sum, return the smallest level.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxLevelSum(root): Finds the level of the tree that has the maximum sum of node values. if not root: return -1 queue = deque([(root, 0)]) level_sum = {} while queue: node, level = queue.popleft() if level not in level_sum: level_sum[level] = 0 level_sum[level] += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) max_level = max(level_sum, key=lambda k: (level_sum[k], -k)) return max_level"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `x`. In one operation, you can increment or decrement an element of the array by `1`. Return _the minimum number of operations required to make all elements of the array equal to `x`_. * For example, consider `arr = [1, 2, 3]` and `x = 2`, you can perform the following operations to make all elements equal to `2`: ``` 1 -> 2 (1 operation) 3 -> 2 (1 operation) ``` Therefore, the total number of operations is `2`.","solution":"def min_operations_to_equal_x(arr, x): Returns the minimum number of operations required to make all elements of the array equal to x. :param arr: List[int] - The input array of integers. :param x: int - The target integer to which all elements of the array should be made equal. :return: int - The minimum number of operations. operations = 0 for num in arr: operations += abs(num - x) return operations"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to determine if you can make all the characters in the string the same by performing operations of the following type: * Choose any character in the string and change it to any other lowercase English letter. Each character in the string can be changed at most once. Return `true` if you can make all the characters the same by performing these operations, otherwise return `false`.","solution":"def can_make_all_characters_same(s): Determines if it\'s possible to make all characters in the string `s` the same by changing each character at most once. Parameters: s (str): The input string consisting of lowercase English letters. Returns: bool: True if all characters can be made the same, False otherwise. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # If the string length is 1, we can trivially change the only character to itself if len(s) == 1: return True # If there are only 2 unique characters with frequency sum equals to length of string minus one or not if len(freq) > 2: return False return True"},{"question":"You are given two strings `source` and `target`. A **disguise** of `source` is a new string that can be made by replacing zero or more characters in `source` with `?`. Return the number of **disguises** of `source` that contain `target` as a substring. For example, if `source` is `\\"abcde\\"` and `target` is `\\"ab\\"`, disguises containing `target` include `\\"ab?de\\"`, `\\"abcde\\"`, `\\"ab???\\"`, and `\\"ab???e\\"`.","solution":"def count_disguises(source, target): Returns the number of disguises of \'source\' that contain \'target\' as a substring by replacing zero or more characters with \'?\'. :param source: str :param target: str :return: int def is_valid_disguise(s, t, start): # Check if it\'s possible to turn source[start:start+len(target)] into target with ?? for i in range(len(t)): if s[start + i] != t[i] and s[start + i] != \'?\': return False return True count = 0 source_len = len(source) target_len = len(target) for i in range(source_len - target_len + 1): if is_valid_disguise(source, target, i): count += 1 return count"},{"question":"Design a class `MaxStack` that supports the following operations: - `void push(int x)` -- Push element `x` onto the stack. - `int pop()` -- Remove the element on top of the stack and return it. - `int top()` -- Get the element on the top. - `int peekMax()` -- Retrieve the maximum element in the stack without removing it. - `int popMax()` -- Retrieve the maximum element in the stack and remove it. If there is more than one maximum element, only remove the most recently added one. Implement the `MaxStack` class without using any built-in stack or list functionalities. **Example:** Input: ``` MaxStack stack = new MaxStack(); stack.push(5); stack.push(1); stack.push(5); stack.top(); // -> 5 stack.popMax(); // -> 5 stack.top(); // -> 1 stack.peekMax(); // -> 5 stack.pop(); // -> 1 stack.top(); // -> 5 ```","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x): self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self): val = self.stack.pop() if val == self.max_stack[-1]: self.max_stack.pop() return val def top(self): return self.stack[-1] def peekMax(self): return self.max_stack[-1] def popMax(self): max_val = self.peekMax() buffer_stack = [] while self.top() != max_val: buffer_stack.append(self.pop()) self.pop() # Remove the max value while buffer_stack: self.push(buffer_stack.pop()) return max_val"},{"question":"You are given a **0-indexed** integer array `quality` where each element represents the quality score of a product. You are also given an integer `n` which represents the total number of products. For each product, calculate the product\'s **adjusted quality score** defined as the sum of `quality[i]` and the index `i`. Determine the **maximum** adjusted quality score of any product. If there are multiple products with the same maximum adjusted quality score, return the product that appears **last** in the array. Return _an array containing the maximum adjusted quality score and the corresponding product index_.","solution":"def max_adjusted_quality_score(quality, n): Returns the maximum adjusted quality score and the corresponding product index. Parameters: quality (list of int): List of quality scores for each product. n (int): Total number of products. Returns: list: A list containing the maximum adjusted quality score and the corresponding product index. max_score = -float(\'inf\') max_index = -1 for i in range(n): adjusted_score = quality[i] + i if adjusted_score >= max_score: max_score = adjusted_score max_index = i return [max_score, max_index]"},{"question":"A **cyclic graph** is a graph that contains at least one cycle. A cycle is a path that starts and ends at the same vertex with no other vertex repeated. Given an undirected graph represented as `n` vertices and an array of `edges` where `edges[i] = [ui, vi]` indicates a connection between `ui` and `vi`, determine if the graph contains a cycle. * Implement the function `hasCycle(n, edges)` that takes in the number of vertices `n` and the array of `edges`, and returns `true` if there is a cycle in the graph, otherwise it returns `false`.","solution":"def hasCycle(n, edges): Determines if the graph contains a cycle. Parameters: n (int): The number of vertices. edges (list of list of int): The edges of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. # Helper function to perform DFS def dfs(v, visited, parent): visited[v] = True for neighbor in adj_list[v]: if not visited[neighbor]: if dfs(neighbor, visited, v): return True elif neighbor != parent: return True return False # Create an adjacency list adj_list = [[] for _ in range(n)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Initialize visited array visited = [False] * n # Perform DFS from each vertex for i in range(n): if not visited[i]: if dfs(i, visited, -1): return True return False"},{"question":"You are given a binary tree represented by a root node `root`. A node `X` in this binary tree is named \\"good\\" if, in the path from the root to `X`, there are no nodes with a value greater than `X`. Return the number of \\"good\\" nodes in the binary tree. A binary tree node is defined as follows: ``` class TreeNode { let val: Int let left: TreeNode? let right: TreeNode? init(_ val: Int, _ left: TreeNode? = nil, _ right: TreeNode? = nil) { self.val = val self.left = left self.right = right } } ```","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_good_nodes(root: TreeNode) -> int: def dfs(node, max_val): if not node: return 0 # Check if the current node is a good node is_good = node.val >= max_val count = 1 if is_good else 0 # Update the max value to be passed down new_max_val = max(max_val, node.val) # Traverse the left and right subtrees count += dfs(node.left, new_max_val) count += dfs(node.right, new_max_val) return count return dfs(root, float(\'-inf\'))"},{"question":"Given a string `s` containing only lowercase English letters, return _a new string with the characters sorted in **reverse alphabetical order**_. For example, if the input string is `\\"hello\\"`, the output should be `\\"ollhe\\"`.","solution":"def reverse_alphabetical_order(s): Returns a new string with the characters sorted in reverse alphabetical order. Parameters: s (str): Input string containing only lowercase English letters. Returns: str: New string with the characters sorted in reverse alphabetical order. return \'\'.join(sorted(s, reverse=True))"},{"question":"Given a matrix `grid` of size `m x n` which represents a maze, where `1` represents a wall and `0` represents an open path, find the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) while breaking at most one wall. If there is no such path, return `-1`. You can move up, down, left, or right from a given cell.","solution":"from collections import deque def shortest_path_with_one_wall_break(grid): Calculate the length of the shortest path from the top-left corner to the bottom-right corner in a maze represented by a grid where 1 represents a wall and 0 represents an open path. Break at most one wall if needed. If no such path exists, return -1. Args: grid (List[List[int]]): The maze represented as an m x n grid. Returns: int: The length of the shortest path or -1 if no path exists. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS queue containing tuples of the form (row, col, steps, wall_break_used) queue = deque([(0, 0, 1, 0)]) visited = set() visited.add((0, 0, 0)) while queue: row, col, steps, wall_break_used = queue.popleft() # If the bottom-right corner is reached if row == m - 1 and col == n - 1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc # Check if new position is within bounds if 0 <= new_row < m and 0 <= new_col < n: new_wall_break_used = wall_break_used + grid[new_row][new_col] if new_wall_break_used <= 1 and (new_row, new_col, new_wall_break_used) not in visited: visited.add((new_row, new_col, new_wall_break_used)) queue.append((new_row, new_col, steps + 1, new_wall_break_used)) return -1"},{"question":"You are given a 2D list of integers `matrix` representing a rectangular grid where each element is either 0 or 1. A \\"square\\" in this context is a sub-grid where all elements are 1 and it forms a square shape. Find the size of the largest square containing only 1\'s. The size of a square is the number of rows (or columns) it spans. Return _an integer_ representing the size of the largest square. If there is no such square, return 0.","solution":"def maximal_square(matrix): Given a 2D list of integers representing a rectangular grid where each element is either 0 or 1, finds the size of the largest square containing only 1\'s. Args: matrix (list of list of int): 2D list representing the grid. Returns: int: size of the largest square containing only 1\'s. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_square_length = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_square_length = max(max_square_length, dp[i][j]) return max_square_length"},{"question":"Given a grid of size `m x n` consisting of `0`s (empty cells) and `1`s (walls), find the shortest path from the top-left cell to the bottom-right cell. You can move up, down, left, or right through empty cells, and you cannot move through walls. If there is no possible path, return -1. Return the length of the shortest path in terms of the number of steps.","solution":"from collections import deque def shortest_path(grid): Find the shortest path in a grid from top-left to bottom-right moving only through empty cells (0s). If no path exists, return -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Given a binary tree, return the sum of values of its deepest leaves. The deepest leaves are defined as the leaf nodes with the maximum depth in the tree. Write a function that, given the root node of the binary tree, will return the sum of the values of the deepest leaves. Each node contains an integer value and pointers to its left and right children. The structure of a node is given as follows: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` Return the sum of the values of the deepest leaves in the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): if not root: return 0 level_sums = {} def dfs(node, depth): if not node: return if depth in level_sums: level_sums[depth].append(node.val) else: level_sums[depth] = [node.val] dfs(node.left, depth + 1) dfs(node.right, depth + 1) dfs(root, 0) max_depth = max(level_sums.keys()) return sum(level_sums[max_depth])"},{"question":"You are given a list of strings `words` where each string consists of lowercase English letters. Your task is to find a string `longest_word` that can be built one character at a time by other words in the list. If there is more than one possible longest word, return the lexicographically smallest one. For example, if `words` = [\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"], the valid longest word would be \\"apple\\", as every prefix (\\"a\\", \\"ap\\", \\"app\\", \\"appl\\", \\"apple\\") is in the list `words`. Return the longest word found or an empty string if no such word exists.","solution":"def longest_word(words): Returns the longest word that can be built one character at a time by other words in the list. If there is more than one possible longest word, returns the lexicographically smallest one. words_set = set(words) longest_word = \\"\\" for word in words: if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): if all(word[:k] in words_set for k in range(1, len(word))): longest_word = word return longest_word"},{"question":"You are given a string `s` which consists only of lowercase English letters. You can apply the following operation any number of times: Choose any two adjacent characters and replace them with the third character that needs to be inserted between them, maintaining the alphabetical order in the operation (for example, \\"ac\\" can be replaced with \\"b\\"). Return the lexicographically smallest string that can be obtained by applying the above operation any number of times on the given string `s`.","solution":"def find_smallest_lexicographic_string(s): Returns the lexicographically smallest string that can be obtained by applying the given operation any number of times on the input string `s`. if not s: return \\"\\" smallest_char = min(s) result = smallest_char * len(s) return result"},{"question":"You are given a list of integers `nums` representing the heights of different buildings in a row, and an integer `k` representing the maximum number of consecutive buildings you can look at. A building\'s view is considered \\"unblocked\\" if there are no taller buildings within the `k` consecutive buildings before it. Return a list of booleans where each boolean indicates whether the view from the corresponding building in `nums` is unblocked. For edge cases, if there are less than `k` buildings before a particular building, consider only the available buildings.","solution":"def are_views_unblocked(nums, k): Returns a list of booleans where each boolean indicates whether the view from the corresponding building in nums is unblocked. n = len(nums) result = [True] * n for i in range(n): for j in range(max(0, i - k), i): if nums[j] >= nums[i]: result[i] = False break return result"},{"question":"You are given an array of strings `words`. Two strings `a` and `b` are regarded as similar if the sorted list of their characters are identical, i.e., if sorting both strings results in the same sequence of characters. A group of similar strings is called a similar group. Write a function that returns the number of similar groups. **Example:** ``` Input: words = [\\"tars\\", \\"rats\\", \\"arts\\", \\"star\\"] Output: 2 Explanation: There are 2 similar groups: 1. [\\"tars\\", \\"rats\\", \\"arts\\", \\"star\\"] 2. [\\"star\\"] ``` **Note:** - Each word in `words` consists of only lowercase letters. - `words` will contain at most 300 strings, each of length at most 10. - All words will be in the range of printable ASCII characters.","solution":"def num_similar_groups(words): Calculates the number of similar groups in the provided list of words. :param words: List of strings :return: Number of similar groups def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX n = len(words) parent = list(range(n)) for i in range(n): for j in range(i + 1, n): if sorted(words[i]) == sorted(words[j]): union(i, j) return sum(parent[i] == i for i in range(n))"},{"question":"Given a list of integers `nums`, you are allowed to reorder the list in any way you\'d like. Compute the maximum value of `nums[i] * nums[j]` where `i` and `j` are indices and `i < j`. Return the maximum product you can obtain by reordering the list. --- This new question fits well with the provided set in terms of style, complexity, and scope. It explores the concept of reordering a list while maintaining the need for assessing maximum values, similar to finding optimal paths or values in the given sample questions.","solution":"def max_product(nums): Returns the maximum product of any two numbers in the list. if len(nums) < 2: raise ValueError(\\"The input list must have at least two elements.\\") nums.sort() return nums[-1] * nums[-2]"},{"question":"You are given an array of integers `nums` and an integer `target`. Find two distinct numbers in the array whose sum is equal to the target. Return the indices of the two numbers in a tuple `(index1, index2)`, where `index1 < index2`. You may assume that each input would have exactly one solution. You may not use the same element twice. Your implementation should have a time complexity of (O(n)). If no such pair exists, return (None).","solution":"def two_sum(nums, target): Find two distinct numbers in nums whose sum is equal to the target. Return the indices of the two numbers in a tuple (index1, index2). Args: nums (List[int]): List of integers. target (int): Target sum. Returns: Tuple[int, int]: Indices of the two numbers such that index1 < index2. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"Implement a `RangeSum` class that supports efficient updates and querying of the sum of elements in a range for an initial array of integers. The class should support the following methods: - `RangeSum(int[] nums)` Initializes the `RangeSum` object with the given array of integers. - `void update(int index, int val)` Updates the element at `index` in the array to be `val`. - `int sumRange(int left, int right)` Returns the sum of the elements between indices `left` and `right` inclusive.","solution":"class RangeSum: def __init__(self, nums): self.n = len(nums) self.nums = nums self.tree = [0] * (self.n + 1) for i in range(self.n): self._update_tree(i + 1, nums[i]) def _update_tree(self, index, val): while index <= self.n: self.tree[index] += val index += (index & -index) def update(self, index, val): diff = val - self.nums[index] self.nums[index] = val self._update_tree(index + 1, diff) def _sum(self, index): total = 0 while index > 0: total += self.tree[index] index -= (index & -index) return total def sumRange(self, left, right): return self._sum(right + 1) - self._sum(left)"},{"question":"You have a linked list of integers where each node contains a single digit. The digits are stored in **reverse order**, and each of their non-empty linked lists represents a non-negative integer. Add the two numbers and return the sum as a linked list in the same reverse order format. For example, if the input linked lists are: ``` 2 -> 4 -> 3 5 -> 6 -> 4 ``` These lists represent the numbers 342 and 465. The sum of these numbers is 807, so the output should be: ``` 7 -> 0 -> 8 ``` Implement a function `ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)` where ListNode is a structure representing a node in the linked list. The function should return the head of the resultant linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Adds two numbers represented by two linked lists in reverse order and returns the sum as a linked list in reverse order. dummy_head = ListNode() current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next"},{"question":"You are given a `0`-indexed integer array `nums` and an integer `target`. You want to choose `k` **non-overlapping** subarrays from `nums` such that their sum is as close as possible to `target`, and return the sum of these subarrays. Each subarray should contain at least `one` element, and a subarray in this context is defined as a contiguous block of elements within `nums`. If there are multiple sums that are equally close to `target`, return the largest one. If it is not possible to choose `k` such subarrays, return `-1`.","solution":"def max_subarray_sum_k(nums, k, target): Find the sum of k non-overlapping subarrays that is as close as possible to target. :param nums: List[int] - List of integers representing the array. :param k: int - Number of non-overlapping subarrays to choose. :param target: int - The target sum to aim for. :return: int - The sum of the chosen subarrays, or -1 if it\'s not possible. from itertools import combinations # Helper function to find all possible subarrays def find_all_subarrays(arr): subarrays = [] n = len(arr) for start in range(n): for end in range(start + 1, n + 1): subarrays.append(arr[start:end]) return subarrays # Edge case: If it\'s impossible to have k subarrays if len(nums) < k: return -1 all_subarrays = find_all_subarrays(nums) all_subarrays.sort(key=lambda x: -len(x)) # Sort by length descending for easier non-overlap check def non_overlapping_subarrays(lst): Helper to check if list of subarrays are non-overlapping lst.sort(key=lambda x: (x[0], x[1])) for i in range(1, len(lst)): if lst[i][0] < lst[i-1][1]: return False return True max_sum = -float(\'inf\') for combo in combinations(enumerate(all_subarrays), k): subarrays = [c[1] for c in combo] indices = [(c[0], c[0] + len(c[1])) for c in combo] if non_overlapping_subarrays(indices): current_sum = sum(map(sum, subarrays)) if max_sum < current_sum <= target: max_sum = current_sum return max_sum if max_sum != -float(\'inf\') else -1"},{"question":"You are given an integer array `nums` consisting of positive integers. You can apply the following operation on the array **any** number of times: Swap elements at any two indices `i` and `j` (`i != j`), such that the product of the swapped elements is an odd number. Return _the number of **distinct** arrays you can obtain_. Since the answer may be too large, return it **modulo** `109 + 7`.","solution":"def count_distinct_arrays(nums): Returns the number of distinct arrays obtainable by swapping elements such that the product of swapped elements is odd. MOD = 10**9 + 7 # Count the number of odd and even numbers odd_count = sum(1 for num in nums if num % 2 == 1) even_count = len(nums) - odd_count # All odd numbers can be freely swapped with any other odd numbers. # All even numbers can be freely swapped with any other even numbers. # Therefore, the total number of distinct arrays is given by the factorials. def factorial(n): if n == 0 or n == 1: return 1 fact = 1 for i in range(2, n + 1): fact = (fact * i) % MOD return fact # Calculate the number of distinct arrays odd_fact = factorial(odd_count) even_fact = factorial(even_count) return (odd_fact * even_fact) % MOD"},{"question":"A binary tree is considered a **complete binary tree** if all levels are completely filled except possibly the last, which is filled from left to right. Given the `root` of a binary tree, return _whether it is a complete binary tree_.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_complete_binary_tree(root): Determines if a binary tree is a complete binary tree. Args: root (TreeNode): The root of the binary tree. Returns: bool: True if it is a complete binary tree, False otherwise. if not root: return True queue = deque([root]) end = False # flag to indicate the encounter of the first None while queue: node = queue.popleft() if node: if end: return False queue.append(node.left) queue.append(node.right) else: end = True return True"},{"question":"You are given two strings `s` and `t`. You want to determine if there is a way to make `s` equal to `t` by deleting some (possibly zero) characters from `s` without rearranging the order of the remaining characters. Return `true` if it is possible, otherwise return `false`.","solution":"def can_form_by_deleting(s, t): Determines if string t can be formed by deleting some characters from string s without rearranging the remaining characters. Parameters: s (str): The string from which characters can be deleted. t (str): The target string to be formed. Returns: bool: True if t can be formed by deleting characters from s, otherwise False. t_index = 0 t_length = len(t) for char in s: if t_index < t_length and char == t[t_index]: t_index += 1 return t_index == t_length"},{"question":"You are given a list of strings `words` and another string `s`. A string `s` is called a concatenation of a permutation of words if it is formed by concatenating all the strings in some permutation of the given words exactly once without any intervening characters. Return `True` if `s` is a concatenation of a permutation of words, and `False` otherwise. Note: The list `words` may contain duplicates, but each word from `words` must be used exactly once in the concatenation.","solution":"def is_concatenation_of_permutation(words, s): Checks if the string s is a concatenation of a permutation of words. Each word in words must be used exactly once in the concatenation. from collections import Counter concatenated_words = \'\'.join(words) if len(concatenated_words) != len(s): return False return Counter(concatenated_words) == Counter(s)"},{"question":"Given a **0-indexed** integer array `numbers`, find *the longest subsequence from* `numbers` *that forms an increasing sequence*. You must return both *the length of this subsequence* and *the subsequence itself*. If there are multiple such subsequences with the same length, return the lexicographically smallest one.","solution":"from bisect import bisect_left from typing import List, Tuple def longest_increasing_subsequence(numbers: List[int]) -> Tuple[int, List[int]]: Finds the longest increasing subsequence in a given list of numbers. Returns a tuple containing the length of this subsequence and the subsequence itself. If there are multiple increasing subsequences with the same length, the lexicographically smallest one is returned. if not numbers: return 0, [] # Array to store the indexes where the increasing subsequences end sub = [] # Array to keep track of the previous element in the subsequence prev_index = [-1] * len(numbers) lis_indices = [] for i, num in enumerate(numbers): pos = bisect_left(sub, num) if pos == len(sub): sub.append(num) lis_indices.append(i) else: sub[pos] = num lis_indices[pos] = i if pos > 0: prev_index[i] = lis_indices[pos - 1] # Reconstruct the longest increasing subsequence lis_length = len(sub) lis = [] k = lis_indices[-1] while k >= 0: lis.append(numbers[k]) k = prev_index[k] lis.reverse() return lis_length, lis"},{"question":"You are given an array of positive integers `heights` representing the heights of buildings in a street. You need to select a subset of buildings such that no two selected buildings are adjacent to each other, and the sum of their heights is maximized. Return _the maximum sum of heights that can be obtained without selecting two adjacent buildings_.","solution":"def max_subset_sum_no_adjacent(heights): Returns the maximum sum of heights that can be obtained without selecting two adjacent buildings. if not heights: return 0 elif len(heights) == 1: return heights[0] max_sums = heights[:] max_sums[1] = max(heights[0], heights[1]) for i in range(2, len(heights)): max_sums[i] = max(max_sums[i-1], max_sums[i-2] + heights[i]) return max_sums[-1]"},{"question":"You are managing a library system and need to implement a method to determine the order in which books are processed. You have a list of `n` books, each with a unique identifier from `1` to `n`, and each book is associated with an integer `processingTime` that represents the time required to process that book. You are also given a list of dependencies, where each dependency is a pair of book identifiers `[x, y]` indicating that book `x` must be processed before book `y`. Write a function that returns the order in which the books should be processed to respect all the dependencies while minimizing the total processing time. If there are multiple valid orders, return any one of them. If it is not possible to process all books due to circular dependencies, return an empty list.","solution":"from collections import defaultdict, deque def findOrder(n, dependencies): Determine the order to process books given dependencies. Parameters: n (int): Number of books. dependencies (List[List[int]]): List of dependencies [x, y] meaning book x must be processed before book y. Returns: List[int]: The order in which books should be processed, or an empty list if not possible. # Create adjacency list and in-degree array adj_list = defaultdict(list) in_degree = [0] * (n + 1) # Populate adjacency list and in-degree array based on dependencies for x, y in dependencies: adj_list[x].append(y) in_degree[y] += 1 # Use a queue to process nodes with 0 in-degree queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we processed all nodes, return the order, else return empty list return order if len(order) == n else []"},{"question":"You are given an integer `n` representing the number of tasks in a project. Each task is labeled from `0` to `n - 1`. You are also given a **0-indexed** 2D integer array `dependency`, where `dependency[i] = [a, b]` means that task `a` must be completed before task `b` starts. Your goal is to find the order in which the tasks can be completed if there is one possible order. If there are multiple possible orders, return any of them. If it is impossible to complete all tasks due to a cycle in the dependencies, return an empty list. Return _a **list**_ `order`, _representing the order of task completion or an empty list if it is impossible to complete all tasks_.","solution":"from collections import defaultdict, deque def findTaskOrder(n, dependency): Finds the order of task completion. :param n: int - Number of tasks. :param dependency: List[List[int]] - List of dependencies where each sublist [a, b] means task a must be done before task b. :return: List[int] - List representing the order of task completion or an empty list if it is impossible to complete all tasks. # Create the adjacency list and indegree list adj_list = defaultdict(list) indegree = [0] * n for a, b in dependency: adj_list[a].append(b) indegree[b] += 1 # Queue for nodes with no incoming edges queue = deque([i for i in range(n) if indegree[i] == 0]) order = [] # BFS or Kahn\'s algorithm while queue: node = queue.popleft() order.append(node) for neighbor in adj_list[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If all tasks are not in the result order, there is a cycle if len(order) != n: return [] return order"},{"question":"Given a string `s` containing only the characters \'a\' and \'b\', return the length of the longest substring that contains at most one \'a\'. If the string does not contain any \'a\', return the length of the entire string. If there are no \'b\'s in the string and there is at least one \'a\', return 1.","solution":"def longest_substring_one_a(s): Returns the length of the longest substring that contains at most one \'a\'. If the string does not contain any \'a\', returns the length of the entire string. If there are no \'b\'s in the string and there is at least one \'a\', returns 1. # If there\'s no \'a\' in the string, return the entire length of the string if \'a\' not in s: return len(s) # If there are no \'b\'s and at least one \'a\', return 1 if \'b\' not in s: return 1 # Find lengths of all substrings that have at most one \'a\' max_length = 0 current_length = 0 a_count = 0 for char in s: if char == \'b\': current_length += 1 elif char == \'a\': if a_count == 0: current_length += 1 a_count += 1 else: max_length = max(max_length, current_length) current_length = 1 a_count = 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given an array of integers `arr` where each element represents the number of stones in a different pile. Your goal is to combine the stones into one pile. The cost of combining two piles is equal to the sum of the stones in the two piles. You can combine the stones in any order. Return the **minimum cost** required to combine all the piles into one pile.","solution":"import heapq def min_cost_to_combine_stones(arr): Returns the minimum cost required to combine all piles into one pile. Parameters: arr (List[int]): An array where each element represents the number of stones in a pile. Returns: int: The minimum cost required to combine all piles into one pile. if len(arr) <= 1: return 0 heapq.heapify(arr) total_cost = 0 while len(arr) > 1: first_min = heapq.heappop(arr) second_min = heapq.heappop(arr) cost = first_min + second_min total_cost += cost heapq.heappush(arr, cost) return total_cost"},{"question":"You are given a string `s` which consists of lowercase English letters. A k-palindrome string is a string that becomes a palindrome when at most `k` letters are deleted from it. Return `true` if `s` is a k-palindrome string and `false` otherwise. A string is considered a palindrome if it reads the same backward as forward.","solution":"def is_k_palindrome(s, k): Returns True if the string is a k-palindrome string, else returns False. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] lps_length = longest_palindromic_subsequence(s) min_deletions = len(s) - lps_length return min_deletions <= k"},{"question":"Given an array of integers `nums` and an integer `target`, return _the number of pairs_ `(i, j)` such that `i < j` and `nums[i] + nums[j] == target`. Write a function `countPairs` that takes an array of integers `nums` and an integer `target`, and returns the count of such pairs.","solution":"def countPairs(nums, target): Returns the number of pairs (i, j) such that i < j and nums[i] + nums[j] == target. count = 0 for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: count += 1 return count"},{"question":"You are given two integers `start` and `end` representing a range `[start, end]` inclusive, and an integer `divisor`. Your task is to determine how many numbers within this range are divisible by the given `divisor`. Return _the count of numbers within the range `[start, end]` that are divisible by `divisor`_.","solution":"def count_divisibles(start, end, divisor): Returns the count of numbers within the range [start, end] that are divisible by divisor. if divisor == 0: raise ValueError(\\"Divisor cannot be zero\\") count = 0 for num in range(start, end + 1): if num % divisor == 0: count += 1 return count"},{"question":"You are given a **sorted** array `arr` of integers where each element is **distinct** and an integer `k`. Imagine you start at `arr[0]` and want to jump to `arr[arr.length - 1]` (the end of the array). You can only jump to the next index if the difference between the current element and the next element is `k`. Determine if it is possible to reach the end of the array starting from the first element by making such jumps. Return _true_ if it is possible, otherwise return _false_.","solution":"def can_reach_end(arr, k): Determines if it is possible to reach the end of the array from the start given jumps of exactly k. Parameters: arr (list of int): The sorted array of distinct integers. k (int): The exact difference required to jump to the next index. Returns: bool: True if it is possible to reach the end, otherwise False. for i in range(len(arr) - 1): if arr[i + 1] - arr[i] != k: return False return True"},{"question":"You are given a rotated sorted array `nums` of unique integers and an integer target. Return _the index of the target if it is present in `nums`,_, or `-1` if it is not present. An array is rotated if the elements at the start of the array can be moved to the end while preserving their order and all elements remain sorted. * For example, `[4, 5, 6, 7, 0, 1, 2]` is a rotated version of `[0, 1, 2, 4, 5, 6, 7]`. You must write an algorithm with `O(log n)` runtime complexity.","solution":"def search_rotated_array(nums, target): Searches for target in a rotated sorted array and returns its index or -1 if not present. :param nums: List[int] - Rotated sorted array of unique integers :param target: int - Target value to search for :return: int - Index of target if present, otherwise -1 left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid # Determine which half is properly sorted if nums[left] <= nums[mid]: # Left half is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform operations to duplicate **some** characters in `s`. Each duplication involves selecting a character from the string `s` and inserting it **anywhere** in the string. Your objective is to make the string `s` a palindrome. Return _the minimum number of duplications required_ to convert the given string into a palindrome.","solution":"def min_duplications_to_palindrome(s): Returns the minimum number of duplications required to make the string \'s\' a palindrome. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Minimum number of duplications required to make the string a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"Given an array of integers `nums`, you are allowed to choose one element at a time and remove it, but you must remove all occurrences of that element from the array in one go. After removing all instances of that element, the cost of this operation is the sum of the removed elements multiplied by their quantity. Your goal is to minimize the total cost to remove all elements from the array. Return the minimum cost.","solution":"from collections import Counter def min_cost_removal(nums): Given an array of integers, the function returns the minimum cost to remove all elements according to the specified rules. counter = Counter(nums) elements = sorted(counter.items(), key=lambda x: x[0]) total_cost = 0 for num, count in elements: total_cost += num * count**2 return total_cost"},{"question":"Given an array of integers `nums`, return _the length of the longest subarray containing only unique values_. For example, given the input array: `nums = [1, 2, 3, 1, 2, 3, 2, 1]`, the longest subarray with unique values is `[1, 2, 3]`, so the function should return `3`.","solution":"def longest_unique_subarray_length(nums): Returns the length of the longest subarray containing only unique values. num_to_index = {} start = 0 max_length = 0 for end in range(len(nums)): if nums[end] in num_to_index: start = max(start, num_to_index[nums[end]] + 1) num_to_index[nums[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a list of intervals, where each interval is represented as a pair of integers `[start, end]` indicating the start and end times of the interval. Your task is to merge all overlapping intervals and return the list of merged intervals in ascending order based on their start times. Implement the following function: ```python def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: # Your code goes here ``` # Example Input: ``` intervals = [[1, 3], [2, 6], [8, 10], [15, 18]] ``` Output: ``` [[1, 6], [8, 10], [15, 18]] ``` Explanation: - Intervals [1, 3] and [2, 6] overlap, so they are merged into [1, 6]. - Intervals [8, 10] and [15, 18] do not overlap, so they remain as they are.","solution":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges all overlapping intervals and returns the list of merged intervals in ascending order based on their start times. if not intervals: return [] # Sort the intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: # Otherwise, add the current interval as is merged_intervals.append(current) return merged_intervals"},{"question":"Emma has a collection of books and she wants to organize them by their height. Each book is represented by an integer in an array `books`, where `books[i]` denotes the height of the `i-th` book. She wants to create a sequence of stacks such that: 1. Each stack is in non-decreasing order, i.e., all books in a stack have heights that are either equal or increase from bottom to top. 2. No two stacks have the same book height on the top. Given the integer array `books`, return the maximum number of stacks Emma can form following the above rules.","solution":"def max_stacks(books): # Sort the books to ensure we can form non-decreasing stacks books.sort() # Initialize an array to store the top book height of each stack stacks = [] for book in books: # Try to find a stack where we can place the current book # Binary search for the location to replace (acts as a stack top update) left, right = 0, len(stacks) - 1 while left <= right: mid = (left + right) // 2 if stacks[mid] < book: left = mid + 1 else: right = mid - 1 if left < len(stacks): stacks[left] = book else: stacks.append(book) return len(stacks)"},{"question":"Given two strings, `s1` and `s2`, find the length of the **longest common subsequence** (LCS) between the two strings. A subsequence is a sequence that can be derived from another sequence by deleting some elements (possibly zero) without changing the order of the remaining elements. Return _the length of the longest common subsequence_.","solution":"def longest_common_subsequence(s1, s2): Finds the length of the longest common subsequence between two strings s1 and s2. m = len(s1) n = len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given a binary tree where each node has a unique value. Implement a function that returns the minimum number of operations required to convert the binary tree into a linear tree (a tree which every node has at most one child). In each operation, you can remove a node and reattach it as the new child of any existing node in the tree. Note that the tree should remain binary throughout the process (no node can have more than two children).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_operations_to_linear_tree(root): def dfs(node): if not node: return 0 left_ops = dfs(node.left) right_ops = dfs(node.right) return left_ops + right_ops + (1 if node.left and node.right else 0) return dfs(root)"},{"question":"Given a list of intervals where each interval is represented as a tuple `(start, end)`, merge all overlapping intervals and return the list of merged intervals. The intervals in the output list should be sorted by their start time. For example, given `[(1, 3), (2, 6), (8, 10), (15, 18)]`, the result should be `[(1, 6), (8, 10), (15, 18)]`. Use an approach with a time complexity of `O(n log n)`.","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of merged intervals sorted by start time. Parameters: intervals (list of tuples): List of intervals represented by tuples (start, end). Returns: list of tuples: Merged and sorted intervals. if not intervals: return [] # Sort intervals by their start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If merged list is empty or there is no overlap with the last interval in merged if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # There is overlap, merge the current interval with the previous one merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged"},{"question":"Given an array of positive integers `arr` and an integer `k`, your task is to find the maximum number of distinct elements that can appear in any subarray of size `k`. A subarray is defined as a contiguous subset of the array. Return _the maximum number of distinct elements that can appear in any subarray of size `k`._ If `k` is greater than the length of the array, return the number of distinct elements in the entire array.","solution":"def max_distinct_elements(arr, k): Returns the maximum number of distinct elements that can appear in any subarray of size k. if k > len(arr): return len(set(arr)) max_distinct = 0 current_window = {} distinct_count = 0 for i in range(len(arr)): if arr[i] not in current_window or current_window[arr[i]] == 0: distinct_count += 1 current_window[arr[i]] = current_window.get(arr[i], 0) + 1 if i >= k - 1: max_distinct = max(max_distinct, distinct_count) outgoing_element = arr[i - k + 1] current_window[outgoing_element] -= 1 if current_window[outgoing_element] == 0: distinct_count -= 1 return max_distinct"},{"question":"Given an array of integers `nums` and an integer `target`, return **the smallest sum** of any **triplet** in `nums` that is greater than or equal to the `target`. If such a triplet does not exist, return `null`. A **triplet** is defined as a set of three integers `nums[i]`, `nums[j]`, and `nums[k]` where `i`, `j`, and `k` are distinct indices.","solution":"def smallest_triplet_sum_greater_or_equal(nums, target): Returns the smallest sum of any triplet in nums that is greater than or equal to the target. If no such triplet exists, returns None. nums.sort() n = len(nums) smallest_sum = float(\'inf\') for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum >= target: smallest_sum = min(smallest_sum, current_sum) right -= 1 else: left += 1 return smallest_sum if smallest_sum != float(\'inf\') else None"},{"question":"Given a **binary** string `s`, return the number of substrings that start and end with \'1\'. Note that any single \'1\' in the string is considered a valid substring that starts and ends with \'1\'.","solution":"def count_substrings(s): Counts the number of substrings in binary string s that start and end with \'1\'. count_of_ones = s.count(\'1\') # Calculate the number of substrings using the formula for combinations of the 1\'s chosen 2 at a time + the count of 1\'s itself return (count_of_ones * (count_of_ones - 1)) // 2 + count_of_ones"},{"question":"A company is tracking the performance of its employees over several months. Each month, the performance of every employee is recorded as a score between 0 and 100. You are given a 2D integer array `scores` where `scores[i][j]` represents the score of the `j-th` employee in the `i-th` month. Implement the `EmployeePerformance` class: * `EmployeePerformance(int[][] scores)` Initializes the object with the performance scores. * `int[] getTopPerformers(int month, int k)` Returns an array of the indices of the top `k` employees based on their scores in the specified `month`. If there are ties, return the first `k` indices in order of their appearance. For example: ```python scores = [ [80, 85, 90], [78, 88, 84], [92, 80, 77] ] employee_performance = EmployeePerformance(scores) employee_performance.getTopPerformers(1, 2) # Returns indices of the top 2 performers in the second month ```","solution":"class EmployeePerformance: def __init__(self, scores): Initializes the object with the performance scores. :param scores: List[List[int]]: 2D list where scores[i][j] is the score of the j-th employee in the i-th month. self.scores = scores def getTopPerformers(self, month, k): Returns an array of the indices of the top k employees based on their scores in the specified month. :param month: int: Index of the month (0-indexed) :param k: int: Number of top performers to return :return: List[int]: Indices of the top k performers if month < 0 or month >= len(self.scores): raise IndexError(\\"Month index out of range\\") month_scores = self.scores[month] indices_scores = [(index, score) for index, score in enumerate(month_scores)] indices_scores.sort(key=lambda x: x[1], reverse=True) top_indices = [index for index, score in indices_scores[:k]] return top_indices"},{"question":"You are given a 2D integer array `matrix` of size `m x n` and an integer `target`. Each row in `matrix` is sorted in non-decreasing order, and each column is sorted in non-decreasing order. Return `true` if `target` is found in the matrix, and `false` otherwise.","solution":"def search_matrix(matrix, target): Search target in a matrix where each row and column is sorted in non-decreasing order. Args: matrix (list of list of int): 2D integer array target (int): The target number to find Returns: bool: True if target is found, False otherwise if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"You are given a 2D grid of characters `grid` with `m` rows and `n` columns representing a map where `\'1\'` represents land and `\'0\'` represents water. An island is formed by connecting adjacent lands horizontally or vertically. Different islands are surrounded by water, and are distinct if there is at least one water cell separating them. Write a function to count the number of distinct islands in the `grid`.","solution":"def num_islands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): stack = [(r, c)] direction = [(0, 1), (1, 0), (0, -1), (-1, 0)] while stack: r, c = stack.pop() for dr, dc in direction: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == \'1\': visited[nr][nc] = True stack.append((nr, nc)) count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'1\' and not visited[r][c]: count += 1 visited[r][c] = True dfs(r, c) return count"},{"question":"You are given an integer array `arr` and two integers `threshold` and `size`. Find the number of contiguous subarrays of length `size` whose sum is greater than or equal to `threshold`. Return _the number of such subarrays_.","solution":"def count_subarrays(arr, threshold, size): Counts the number of contiguous subarrays of length `size` with sum >= `threshold`. Parameters: arr (list of int): The list of integers. threshold (int): The threshold value. size (int): The size of the subarray. Returns: int: The number of contiguous subarrays of length `size` with sum >= `threshold`. n = len(arr) if size > n: return 0 window_sum = sum(arr[:size]) count = 0 if window_sum >= threshold: count += 1 for i in range(size, n): window_sum += arr[i] - arr[i - size] if window_sum >= threshold: count += 1 return count"},{"question":"An array `nums` of length `n` contains positive integers. A **split** of the array is defined as dividing the array into two contiguous subarrays such that each element in the first subarray is **less than** or **equal to** each element in the second subarray. The goal is to determine the number of possible **splits**. Suppose the array `nums` is given, return _the number of ways the array can be split such that all elements in the first subarray are less than or equal to all elements in the second subarray_.","solution":"def num_of_splits(nums): Returns the number of ways to split the array into two contiguous subarrays such that all elements in the first subarray are less than or equal to all elements in the second subarray. n = len(nums) # Create an array to store the maximum values from left to right left_max = [0] * n left_max[0] = nums[0] for i in range(1, n): left_max[i] = max(left_max[i-1], nums[i]) # Create an array to store the minimum values from right to left right_min = [0] * n right_min[n-1] = nums[n-1] for i in range(n-2, -1, -1): right_min[i] = min(right_min[i+1], nums[i]) # Count the number of splits split_count = 0 for i in range(n-1): if left_max[i] <= right_min[i+1]: split_count += 1 return split_count"},{"question":"You are given a 2D array `matrix` where each row is a sorted integer array in increasing order. Your task is to return a list of all common elements present in all rows of the matrix. If there are no common elements, return an empty list. The elements in the output list should be sorted in increasing order.","solution":"def common_elements_in_rows(matrix): Returns a list of common elements present in all rows of the matrix. :param matrix: List of List of integers :return: List of integers if not matrix: return [] common_elements = set(matrix[0]) for row in matrix[1:]: common_elements &= set(row) return sorted(common_elements)"},{"question":"You are given two strings `s1` and `s2`, and an integer `k`. Your task is to determine if you can transform `s1` into `s2` by making **at most** `k` insertions of **any** character anywhere in `s1`. Note that you cannot delete characters from `s1` or change the order of characters. Return _`True` if it is possible to transform `s1` into `s2` with at most `k` insertions, otherwise return `False`_.","solution":"def lcs_length(s1, s2): Helper function to find the length of the longest common subsequence of s1 and s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def can_transform(s1, s2, k): Determines if s1 can be transformed into s2 by making at most k insertions. lcs_len = lcs_length(s1, s2) required_insertions = len(s2) - lcs_len return required_insertions <= k"},{"question":"Implement a class `ActivityLogger` to track and manage user activities in a system. The system logs activities with timestamps and provides functionalities to query those activities based on time intervals. Implement the `ActivityLogger` class with the following methods: * `ActivityLogger()` Initializes the `ActivityLogger` object. * `void logActivity(String userId, String activity, int timestamp)` Stores the user\'s `activity` at the given `timestamp` (in seconds). * `List<String> getActivitiesForUser(String userId, int startTimestamp, int endTimestamp)` Returns a list of activities for the user with the ID `userId` that were logged between `startTimestamp` and `endTimestamp` (both inclusive). The activities should be returned in the order they were logged. * `List<String> getAllActivities(int startTimestamp, int endTimestamp)` Returns a list of all activities logged in the system between `startTimestamp` and `endTimestamp` (both inclusive). The activities should be returned in the order they were logged. * `List<String> getUsersWithActivity(String activity, int startTimestamp, int endTimestamp)` Returns a list of user IDs that logged the specified `activity` between `startTimestamp` and `endTimestamp` (both inclusive). Each user ID should be unique and the list should be sorted in ascending order.","solution":"class ActivityLogger: def __init__(self): self.logs = [] def logActivity(self, userId, activity, timestamp): self.logs.append((timestamp, userId, activity)) self.logs.sort() def getActivitiesForUser(self, userId, startTimestamp, endTimestamp): return [ activity for timestamp, uid, activity in self.logs if uid == userId and startTimestamp <= timestamp <= endTimestamp ] def getAllActivities(self, startTimestamp, endTimestamp): return [ activity for timestamp, _, activity in self.logs if startTimestamp <= timestamp <= endTimestamp ] def getUsersWithActivity(self, activity, startTimestamp, endTimestamp): users_set = { uid for timestamp, uid, act in self.logs if act == activity and startTimestamp <= timestamp <= endTimestamp } return sorted(users_set)"},{"question":"Given an array of distinct integers `nums`, a **binary search tree (BST)** is a binary tree where each node has up to two children, and for each node, the left subtree contains only values less than the nodes value, and the right subtree contains only values greater than the nodes value. Different arrangements of the `nums` array can lead to distinct BSTs. Return the number of distinct BSTs that can be made by rearranging the elements of `nums`. Since the number can be very large, return it modulo 10^9 + 7.","solution":"def num_trees(n): Returns the number of distinct BSTs that can be made by rearranging the elements of an array of length n. Since the number can be large, the result is returned modulo 10^9 + 7. MOD = 10**9 + 7 # To count the number of distinct BSTs, we use the nth Catalan number. # Catalan number C(n) = (2n)! / ((n + 1)! n!) # We use dynamic programming for efficiency. if n == 0 or n == 1: return 1 catalan = [0] * (n + 1) catalan[0] = 1 catalan[1] = 1 for i in range(2, n+1): catalan[i] = 0 for j in range(i): catalan[i] = (catalan[i] + (catalan[j] * catalan[i-j-1]) % MOD) % MOD return catalan[n]"},{"question":"You are provided with a list of words and a string `target`. You need to determine if `target` can be formed by concatenating words from the list exactly once. The same word from the list cannot be used more than once. You can assume that the words in the list and the target string consist only of lowercase English letters. Implement a function `boolean canFormTarget(String[] words, String target)` that returns `true` if `target` can be formed using words from the list, otherwise `false`.","solution":"def can_form_target(words, target): from collections import Counter # Create a count of all characters in the words list char_count_words = Counter(\'\'.join(words)) # Create a count of all characters in the target string char_count_target = Counter(target) # Check if the target can be formed by the character counts for char, count in char_count_target.items(): if char_count_words[char] < count: return False return True"},{"question":"A company is organizing a team-building event where employees participate in different activities. The company needs to form teams from a list of employees such that each team has exactly `k` employees. Given a list of employee names `employees` and an integer `k`, return all possible teams that can be formed. Each team should be represented as a list of strings. The solution should avoid duplicate teams and the order of teams and members within each team does not matter. For example, given `employees` = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"] and `k` = 2, one possible output could be [[\\"Alice\\", \\"Bob\\"], [\\"Alice\\", \\"Charlie\\"], [\\"Alice\\", \\"David\\"], [\\"Bob\\", \\"Charlie\\"], [\\"Bob\\", \\"David\\"], [\\"Charlie\\", \\"David\\"]].","solution":"from itertools import combinations def form_teams(employees, k): Returns all possible teams of size k from the list of employees. return list(combinations(employees, k))"},{"question":"A string is called **balanced** if the number of occurrences of the letter \'a\' is equal to the number of occurrences of the letter \'b\'. Given a string `s` of length `n` consisting only of the characters \'a\' and \'b\', find the length of the longest substring of `s` that is balanced. If no balanced substring exists, return `0`.","solution":"def longest_balanced_substring(s): Finds the length of the longest balanced substring where the count of \'a\' equals the count of \'b\'. Parameters: s (str): The input string containing only \'a\' and \'b\' characters. Returns: int: The length of the longest balanced substring. If no balanced substring exists, returns 0. max_len = 0 count_dict = {0: -1} count = 0 for i, char in enumerate(s): if char == \'a\': count += 1 elif char == \'b\': count -= 1 if count in count_dict: max_len = max(max_len, i - count_dict[count]) else: count_dict[count] = i return max_len"},{"question":"You are given an array of integers `arr` where each element represents the size of different ropes. Your task is to combine the ropes into one rope with the minimum possible cost. The cost to combine two ropes is equal to the sum of their lengths. Once combined, the resulting rope can then be combined with another rope with the same rule. Return the minimum cost to combine all the ropes into one rope.","solution":"import heapq def min_cost_to_combine_ropes(arr): Given an array of integers where each element represents the size of ropes, return the minimum cost to combine all ropes into one rope. :param arr: List[int] - the sizes of the ropes :return: int - the minimum cost to combine all ropes if len(arr) <= 1: return 0 heapq.heapify(arr) total_cost = 0 while len(arr) > 1: first = heapq.heappop(arr) second = heapq.heappop(arr) cost = first + second total_cost += cost heapq.heappush(arr, cost) return total_cost"},{"question":"You are given a string `s` and a list of strings `words`. All the strings in `words` are of the same length. Return _an integer representing the smallest index in `s` where the full concatenation of each word in `words` exactly once is found as a substring_, or `-1` if no such substring exists. The concatenation must contain each word from `words` exactly once and without any intervening characters.","solution":"def find_substring(s, words): Finds the smallest index in s where the concatenation of each word in words exactly once is found as a substring. Parameters: s (str): The input string. words (list): List of words which needs to be concatenated in any order to form the substring. Returns: int: The starting index of the substring or -1 if no such substring exists. from collections import Counter if not s or not words: return -1 word_length = len(words[0]) total_length = word_length * len(words) word_count = Counter(words) for i in range(len(s) - total_length + 1): seen_words = s[i:i + total_length] temp_word_count = [seen_words[j:j + word_length] for j in range(0, len(seen_words), word_length)] if Counter(temp_word_count) == word_count: return i return -1"},{"question":"You are given a list of integers representing tasks, where each integer represents the duration of a task in minutes. There is also an integer `breakTime` that represents the mandatory break after each task. Return the minimum amount of time required to complete all the tasks if the tasks must be performed sequentially and the break must be taken after each task except the last one. For example, if the task durations are `[5, 2, 8]` and the `breakTime` is `3`, the total time is calculated as `(5 + breakTime) + (2 + breakTime) + 8`.","solution":"def total_time(tasks, breakTime): Calculate the total time required to complete all tasks with mandatory breaks after each task except the last one. :param tasks: List[int] - durations of each task in minutes :param breakTime: int - mandatory break time in minutes between tasks :return: int - minimum amount of time required to complete all tasks if not tasks: return 0 total_time = 0 for i in range(len(tasks) - 1): total_time += tasks[i] + breakTime total_time += tasks[-1] # Add the last task without the break return total_time"},{"question":"You are given an `n x n` matrix. Rotate the matrix 90 degrees clockwise. You need to do this in-place, meaning you have to modify the input matrix directly. Do not allocate another 2D matrix for the rotation. Return the modified matrix.","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise. Args: matrix: List[List[int]] - 2D list representing the n x n matrix Returns: List[List[int]] - the modified matrix after rotation n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"Given an integer array `nums` where all the integers are unique, return _the maximum possible value of an integer `k` such that there exists a subsequence of `nums` with length `k` that is strictly increasing_.","solution":"def maxLengthIncreasingSubsequence(nums): Given a list of unique integers, returns the maximum length of a strictly increasing subsequence. Args: nums (List[int]): List of unique integers Returns: int: Maximum length of a strictly increasing subsequence if not nums: return 0 # Initialize the dp array dp = [1] * len(nums) # Calculate the length of LIS ending at each position for i in range(1, len(nums)): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The maximum value in dp will be the length of the longest increasing subsequence return max(dp)"},{"question":"You are given a binary tree where each node contains an integer value. Given two integer values, `p` and `q`, find the lowest common ancestor (LCA) of the nodes with values `p` and `q`. The LCA is defined as the deepest node that has both p and q as descendants (where we allow a node to be a descendant of itself). Implement the `TreeNode` class: * `TreeNode(int x)` initializes a node with value `x`. And the `BinaryTree` class: * `BinaryTree(TreeNode root)` initializes the binary tree with the given root. * `TreeNode lowestCommonAncestor(TreeNode root, int p, int q)` returns the lowest common ancestor of nodes with values `p` and `q`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTree: def __init__(self, root): self.root = root def find(self, node, value): if not node: return None if node.val == value: return node left = self.find(node.left, value) if left: return left return self.find(node.right, value) def lowestCommonAncestor(self, root, p, q): if not root: return None if root.val == p or root.val == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right"},{"question":"Given a string `text`, return a new string where each character from `text` is followed by the number of times it appears consecutively in `text`. If a character appears only once consecutively, it should be followed by the number `1`. Example: if `text = \\"aaabbcdda\\"`, the output should be `\\"a3b2c1d2a1\\"`.","solution":"def encode_string(text): Returns a new string where each character from `text` is followed by the number of times it appears consecutively in `text`. If a character appears only once consecutively, it is followed by the number `1`. if not text: return \\"\\" encoded = [] count = 1 prev_char = text[0] for char in text[1:]: if char == prev_char: count += 1 else: encoded.append(f\'{prev_char}{count}\') prev_char = char count = 1 # Add the last character sequence encoded.append(f\'{prev_char}{count}\') return \'\'.join(encoded)"},{"question":"You are given an array of strings `words` and a string `pattern`. Return _a list of all the strings that match the given pattern_. A string matches the pattern if there is a bijection (a one-to-one correspondence) between a letter in `pattern` and a letter in the string. The strings and the pattern contain only lowercase letters.","solution":"def find_and_replace_pattern(words, pattern): def match(word, pattern): if len(word) != len(pattern): return False char_map_word_to_pattern = {} char_map_pattern_to_word = {} for w_char, p_char in zip(word, pattern): if (w_char in char_map_word_to_pattern and char_map_word_to_pattern[w_char] != p_char) or (p_char in char_map_pattern_to_word and char_map_pattern_to_word[p_char] != w_char): return False char_map_word_to_pattern[w_char] = p_char char_map_pattern_to_word[p_char] = w_char return True result = [] for word in words: if match(word, pattern): result.append(word) return result"},{"question":"You are given a string `s` which contains spaces and lowercase alphabets. You need to reverse the order of words in this string. A word is defined as a sequence of non-space characters. The words in the string will be separated by a single space. Your task is to return a string where the words appear in reverse order. The spaces between words should be reduced to a single space, and there should be no leading or trailing spaces in the output string. For example, given `s = \\" hello world \\"`, the output should be `\\"world hello\\"`.","solution":"def reverse_words(s): Reverses the order of words in a given string. Args: s (str): Input string containing words. Returns: str: String with words in reversed order. words = s.strip().split() reversed_words = \' \'.join(words[::-1]) return reversed_words"},{"question":"You are given a **0-indexed** array of integers `timeSeries` where `timeSeries[i]` represents the time at which a poisonous spell is cast on a target. Each poisonous spell causes the target to suffer damage for a **duration** `damageDuration` units of time. If a new poisonous spell is cast before the previous one expires, the damage duration is extended by the remaining time from the previous spell. Return the **total time** for which the target suffers from the poisonous spell. For example, given `timeSeries` = `[1, 4, 5]` and `damageDuration` = `4`, the target suffers damage from `[1, 2, 3, 4, 5, 6, 7, 8]`. Thus, the total time the target suffers is `8`.","solution":"def findPoisonedDuration(timeSeries, damageDuration): Calculate the total time for which the target suffers from the poisonous spell. Parameters: timeSeries (list): A list of integers representing the time at which the spells are cast. damageDuration (int): The duration of the damage caused by each spell. Returns: int: The total time of suffering. if not timeSeries: return 0 total_time = 0 for i in range(len(timeSeries) - 1): total_time += min(timeSeries[i + 1] - timeSeries[i], damageDuration) return total_time + damageDuration"},{"question":"You are given a **binary tree** with `n` nodes, where each node has a unique value from `1` to `n`. The tree is represented as an array `parents` where `parents[i]` is the parent of node `i+1`. The root of the tree has `parents[i]` equal to `-1`. Your task is to find the **lowest common ancestor (LCA)** of two given nodes `p` and `q` in this tree. The LCA of two nodes `p` and `q` is the lowest node that has both `p` and `q` as descendants (where a node can be a descendant of itself). Return _the value of the LCA node_.","solution":"class TreeNode: def __init__(self, val: int): self.val = val self.parent = None def build_tree(parents): nodes = [TreeNode(i + 1) for i in range(len(parents))] root = None for i, parent_index in enumerate(parents): if parent_index == -1: root = nodes[i] else: nodes[i].parent = nodes[parent_index - 1] return root, nodes def find_path_to_root(node): path = [] while node: path.append(node.val) node = node.parent return path def lca(parents, p, q): _, nodes = build_tree(parents) node_p = nodes[p - 1] node_q = nodes[q - 1] path_p = find_path_to_root(node_p) path_q = find_path_to_root(node_q) path_p.reverse() path_q.reverse() i = 0 while i < len(path_p) and i < len(path_q) and path_p[i] == path_q[i]: i += 1 return path_p[i - 1]"},{"question":"You are given a string `s` consisting of lowercase and uppercase letters. A letter in `s` is considered \\"good\\" if both its lowercase and uppercase versions are present in the string. Return _the longest \\"good\\" substring of `s`_. If there are multiple answers, return any of them. If no such substring exists, return an empty string.","solution":"def longest_good_substring(s): Returns the longest \\"good\\" substring of s. A substring is considered \\"good\\" if it contains both the lowercase and uppercase versions of each letter in the substring. def is_good(sub): return all(c.lower() in sub and c.upper() in sub for c in sub) max_len = 0 good_substring = \\"\\" n = len(s) for i in range(n): for j in range(i+1, n+1): sub = s[i:j] if is_good(sub) and (j - i) > max_len: max_len = j - i good_substring = sub return good_substring"},{"question":"You are given an array of integers `height` representing the height of buildings. Two buildings `i` and `j` form a container that can hold water, where the width of the container is the distance between the buildings (`j - i`), and the height of the container is the minimum of the heights of the two buildings (`min(height[i], height[j])`). Find the maximum amount of water a container can store. Return _the maximum amount of water a container can store given the constraints_.","solution":"def max_area(height): Compute the maximum amount of water a container can store. The width of the container is the distance between two buildings, and the height is the minimum height of the two buildings. Params: height -- List of integers representing the height of buildings. Returns: int -- Maximum amount of water the container can store. max_water = 0 left = 0 right = len(height)-1 while left < right: width = right - left container_height = min(height[left], height[right]) current_water = width * container_height max_water = max(max_water, current_water) # Move the pointer of the shorter building to try to find a taller one if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given two strings `s` and `t` of lengths `m` and `n` respectively. You want to find the length of the longest subsequence that is a substring in both `s` and `t`. Return _the length of the longest common subsequence of the two_. (For a string `s`, a subsequence is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (For example, \\"ace\\" is a subsequence of \\"abcde\\" while \\"aec\\" is not)).","solution":"def longest_common_subsequence(s, t): Returns the length of the longest common subsequence that is a substring in both s and t. m, n = len(s), len(t) # Create a 2D array to store lengths of longest common suffixes of substrings. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build dp array and keep track of the maximum length. result = 0 for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 result = max(result, dp[i][j]) else: dp[i][j] = 0 return result"},{"question":"Given an array of `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane, return _the maximum number of points that can be formed into a straight line using any subset of the given points_.","solution":"from collections import defaultdict from math import gcd def maxPoints(points): def slope(dx, dy): g = gcd(dx, dy) return (dx // g, dy // g) if g != 0 else (0, 0) n = len(points) if n <= 2: return n max_points = 1 for i in range(n): slopes = defaultdict(int) for j in range(n): if i != j: dx, dy = points[j][0] - points[i][0], points[j][1] - points[i][1] slopes[slope(dx, dy)] += 1 max_points = max(max_points, max(slopes.values(), default=0) + 1) return max_points"},{"question":"You are given two non-empty arrays of integers, `nums1` and `nums2`, where the integers in both arrays are already sorted in non-decreasing order. We want to find the maximum number of **pairs** that can be made from these two arrays such that for each pair `(a, b)`, `a` belongs to `nums1` and `b` belongs to `nums2` and `a` is less than `b`. You are allowed to rearrange the integers within each array. Return the maximum number of such pairs that can be formed.","solution":"def max_pairs(nums1, nums2): Finds the maximum number of pairs such that an element from nums1 is less than an element from nums2. nums1.sort() nums2.sort() i, j = 0, 0 pairs = 0 while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: pairs += 1 i += 1 j += 1 else: j += 1 return pairs"},{"question":"You are given a list of `events` where each event is represented by an interval `[start, end]`, with `start` being the start time and `end` being the end time (inclusive). An event `[start, end]` is valid if it does not overlap with any other event in the list. Your task is to find the **maximum number of valid events** that can be attended. For example, given `events = [[1, 3], [2, 5], [4, 6]]`. The intervals `[1, 3]` and `[4, 6]` do not overlap, so you can attend both of them. Return _the maximum number of valid events that can be attended_.","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping (valid) events that can be attended. Parameters: events (List[List[int]]): A list of events represented by intervals [start, end]. Returns: int: The maximum number of non-overlapping events. # Sort events by their end time to use a greedy approach events.sort(key=lambda x: x[1]) # Initialize variables to keep track of the maximum events and end time of the last attended event max_events = 0 last_end_time = -1 for start, end in events: if start > last_end_time: # Attend this event max_events += 1 last_end_time = end return max_events"},{"question":"You are given two integer arrays `tasks` and `workers` of equal length, where `tasks[i]` represents the difficulty of the `i-th` task and `workers[j]` represents the ability of the `j-th` worker. Each worker can complete any task that has a difficulty less than or equal to their ability. Additionally, you are provided with an integer `p` that represents the number of pairs of tasks and workers you must maximize such that the assignment of workers to tasks is optimal. Return the maximum sum of difficulties of the tasks assigned to workers. Note that each worker can be assigned to at most one task, and each task can be assigned to at most one worker. If `p` pairs cannot be assigned, return `-1`.","solution":"def max_task_difficulty_sum(tasks, workers, p): Maximizes the sum of difficulties of the tasks assigned to workers such that up to p pairs are formed and each worker can be assigned to at most one task, and each task can be assigned to at most one worker. :param tasks: List[int], difficulties of the tasks :param workers: List[int], abilities of the workers :param p: int, number of pairs :return: int, maximum sum of difficulties of assigned tasks, or -1 if p pairs can\'t be formed if len(tasks) != len(workers) or p > len(tasks): return -1 tasks.sort(reverse=True) workers.sort(reverse=True) max_sum = 0 task_index, worker_index = 0, 0 pairs_formed = 0 while task_index < len(tasks) and worker_index < len(workers) and pairs_formed < p: if workers[worker_index] >= tasks[task_index]: max_sum += tasks[task_index] pairs_formed += 1 worker_index += 1 task_index += 1 return max_sum if pairs_formed == p else -1"},{"question":"Given an integer array `arr`, return the **length of the longest** consecutive elements sequence. A consecutive elements sequence is a sequence of numbers, each either one less than or one more than its predecessor. The sequence doesn\'t have to be sorted within the array; only the consecutive numbers matter. For example, in the array `[100, 4, 200, 1, 3, 2]`, the longest consecutive elements sequence is `[1, 2, 3, 4]`, and its length is `4`.","solution":"def longest_consecutive_sequence(arr): if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Implement a function `findLongestCycle` which receives an array of integers `edges` representing a directed graph. Each `edges[i]` = `j` indicates that there is an edge from vertex `i` to vertex `j`. Return the length of the longest cycle in the graph. If there is no cycle, return `-1`. A cycle is defined as a path that starts and ends at the same vertex with no repetition of vertices except for the first and last.","solution":"def findLongestCycle(edges): Given a list of directed edges representing a graph, find the length of the longest cycle in the graph. If there is no cycle, return -1. def dfs(node, seen_time, stack, current_time): if seen_time[node] != -1: # If node is already in stack, detect cycle if node in stack: return current_time - seen_time[node] return -1 # Mark the node as visited with the current timestamp seen_time[node] = current_time stack.append(node) # Recur for the next node next_node = edges[node] result = -1 if next_node != -1: result = dfs(next_node, seen_time, stack, current_time + 1) # Backtrack stack.pop() return result n = len(edges) seen_time = [-1] * n longest_cycle = -1 for i in range(n): if seen_time[i] == -1: # Perform DFS if the node has not been seen longest_cycle = max(longest_cycle, dfs(i, seen_time, [], 0)) return longest_cycle"},{"question":"Given a list of `n` strings `words`, find the **longest common prefix** among all the strings in the list. If there is no common prefix, return an empty string `\\"\\"`. Note that all strings consist only of lowercase English letters. Return _a string representing the longest common prefix_.","solution":"def longest_common_prefix(words): Returns the longest common prefix among the words in the list. :param words: List of strings :return: Longest common prefix string if not words: return \\"\\" # Start by assuming the entire first word is the common prefix prefix = words[0] # Compare the prefix with each word in the list for word in words[1:]: while word[:len(prefix)] != prefix: # Shorten the prefix by one character from the end prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"You are given an array of integers where the element at the index `i` represents the elevation of terrain at that index. The width of each terrain unit is `1`. After a heavy rainfall, water will be trapped in the valleys between the terrain units. You are required to compute the total amount of water that can be trapped between the terrain units. The function should take an array of integers representing the terrain elevations as input and return an integer representing the total volume of water trapped. For example, given the array `[0,1,0,2,1,0,1,3,2,1,2,1]`, the function should return `6`.","solution":"def trap(height): Calculate the total amount of water that can be trapped between the terrain units. :param height: List of integers representing the elevation of terrains. :return: Integer representing the total volume of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] right_max[-1] = height[-1] # Fill left max array for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right max array for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given an array of integers `nums` representing the number of oranges stored in each basket, and a threshold integer `k`, find the minimum number of moves required so that no basket contains more than `k` oranges. In one move, you can take an orange from any basket and put it into any other basket. The move must result in both baskets containing at least one orange each if they initially had oranges. Return _the **minimum** number of moves required to ensure no basket has more than `k` oranges_.","solution":"def min_moves_to_limit_oranges(nums, k): total_moves = 0 excess_oranges = 0 for oranges in nums: if oranges > k: excess_oranges += (oranges - k) return excess_oranges"},{"question":"You are given two strings `s1` and `s2`, both of which are **non-empty** and consist of lowercase English letters. Your task is to determine if the characters of `s2` can be rearranged to form a substring of `s1`. Return `True` if this is possible, and `False` otherwise. For example, if `s1 = \\"eidbaooo\\"` and `s2 = \\"ab\\"`, then `s2` can be rearranged to form the substring \\"ba\\" within `s1`, so you should return `True`. However, if `s1 = \\"eidboaoo\\"` and `s2 = \\"ab\\"`, since there is no substring in `s1` that can be rearranged to form `s2`, you should return `False`.","solution":"def check_inclusion(s1, s2): Determine if s2 can be rearranged to form a substring of s1. from collections import Counter len_s2 = len(s2) counter_s2 = Counter(s2) for i in range(len(s1) - len_s2 + 1): if Counter(s1[i:i+len_s2]) == counter_s2: return True return False"},{"question":"Given an integer array `nums` and an integer `k`, return the **k-th smallest** element in the array in sorted order. Note that it is the **k-th smallest** element in the **sorted** order, not the k-th distinct element. Return the k-th smallest element of the array.","solution":"def kth_smallest(nums, k): Returns the k-th smallest element in the sorted order of the array. nums.sort() return nums[k-1]"},{"question":"Given an n x n grid containing only values 0 and 1, where 0 represents water and 1 represents land, find the largest island. An island is defined as a group of connected 1s (horizontally or vertically) surrounded by water (0s) or the edges of the grid. You may flip up to one 0 to a 1 to form a larger island. Return the size of the largest possible island.","solution":"def largest_island(grid): Returns the size of the largest possible island after flipping one 0 to a 1. def dfs(x, y, index): if 0 <= x < n and 0 <= y < n and grid[x][y] == 1: grid[x][y] = index size = 1 for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)): size += dfs(x + dx, y + dy, index) return size return 0 n = len(grid) index = 2 sizes = {0: 0} # Step 1: Use DFS to find all islands and their sizes for i in range(n): for j in range(n): if grid[i][j] == 1: sizes[index] = dfs(i, j, index) index += 1 # Step 2: Check all 0s to see the largest potential island if we flip one 0 result = max(sizes.values(), default=0) for i in range(n): for j in range(n): if grid[i][j] == 0: seen = set() possible_size = 1 # the new 1 we just flipped for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)): ni, nj = i + dx, j + dy if 0 <= ni < n and 0 <= nj < n: island_index = grid[ni][nj] if island_index > 1 and island_index not in seen: seen.add(island_index) possible_size += sizes[island_index] result = max(result, possible_size) return result"},{"question":"A company has a set of projects and each project can be completed if the preceding projects are completed before it. The company wants to determine the order in which these projects should be completed if there is one. You are given an integer `numProjects` denoting the total number of projects and a 2D array `prerequisites` where `prerequisites[i] = [a, b]` indicates that project `a` should be completed before project `b`. Return _a list of integers_ denoting the ordering of projects to complete all projects. If there are multiple valid orderings, return any one of them. If it is impossible to complete all projects, return an empty list.","solution":"from collections import deque, defaultdict def findOrder(numProjects, prerequisites): # Create adjacency list and in-degree array adj_list = defaultdict(list) in_degree = [0] * numProjects # Build the graph for dest, src in prerequisites: adj_list[src].append(dest) in_degree[dest] += 1 # Find all the projects with no prerequisites queue = deque([i for i in range(numProjects) if in_degree[i] == 0]) result = [] while queue: node = queue.popleft() result.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if the ordering includes all projects if len(result) == numProjects: return result else: return []"},{"question":"Given an array of integers `prices` representing the cost of a product on different days, you can buy the product only once but sell it multiple times. Return _the **maximum** profit you can achieve from these transactions_. Note that you cannot hold more than one product at a time (you must sell the product before buying it again).","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved by buying and selling the product multiple times on different days. :param prices: List[int], list of prices on different days. :return: int, maximum profit. max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"A company is implementing a network of connected nodes for monitoring purposes. The network is represented as an undirected graph with `n` nodes and `m` edges, where each node has a unique ID from `0` to `n-1`. You are given an integer `startNode`, representing the initial node, and the graph\'s connections as an array of edges `connections`, where `connections[i] = [u, v]` indicates an edge between nodes `u` and `v`. Your task is to determine if it\'s possible to visit all the nodes starting from the `startNode`. You can return to a node if necessary to visit all the nodes. Return `true` if it is possible to visit all nodes from the `startNode`, otherwise return `false`. Example: - Input: startNode = 0, connections = [[0, 1], [1, 2], [2, 0], [1, 3]] - Output: true","solution":"def can_visit_all_nodes(n, startNode, connections): from collections import defaultdict, deque # Create an adjacency list to represent the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Use BFS to traverse the graph visited = set() queue = deque([startNode]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbour in graph[node]: if neighbour not in visited: queue.append(neighbour) # Check if all nodes were visited return len(visited) == n"},{"question":"You are given a **0-indexed** integer array `arr`. Determine whether it\'s possible to rearrange `arr` such that every element at an even index is less than or equal to the next element at an odd index. If it is possible, return any such arrangement. If it is impossible, return an empty array.","solution":"def rearrange_array(arr): arr.sort() n = len(arr) result = [0] * n mid = (n + 1) // 2 # Put the smaller half elements into the even index positions result[::2] = arr[:mid] # Put the larger half elements into the odd index positions result[1::2] = arr[mid:] return result"},{"question":"Implement a text editor that can perform the following operations efficiently: 1. **Insert** a character at the end of the document. 2. **Delete** the last character of the document. 3. **PrintKth** the k-th character of the document (for a 1-indexed query). You should support the following operations: - `\\"INSERT c\\"`: Insert character `c` at the end of the document. - `\\"DELETE\\"`: Delete the last character of the document. If the document is empty, do nothing. - `\\"PRINTKth k\\"`: Return the k-th character of the document. If `k` is larger than the current length of the document, return an empty string. Your task is to implement a function that takes a list of operations and returns a list of results for `\\"PRINTKth\\"` operations in the same order. Example input: ``` operations = [\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\", \\"DELETE\\", \\"PRINTKth 2\\", \\"INSERT d\\", \\"PRINTKth 3\\"] ``` Example output: ``` [\\"b\\", \\"c\\"] ```","solution":"def text_editor(operations): Processes a series of text editor operations and returns the results of \\"PRINTKth\\" operations. Args: operations: List of strings, each string represents an operation (\\"INSERT c\\", \\"DELETE\\", \\"PRINTKth k\\"). Returns: List of results from \\"PRINTKth\\" operations. document = [] results = [] for operation in operations: if operation.startswith(\\"INSERT\\"): _, char = operation.split() document.append(char) elif operation == \\"DELETE\\": if document: document.pop() elif operation.startswith(\\"PRINTKth\\"): _, k = operation.split() k = int(k) if k > len(document): results.append(\\"\\") else: results.append(document[k-1]) return results"},{"question":"Given an integer array `jobs` where each element represents the amount of time required to complete a job, and an integer `workers` representing the number of workers available to complete the jobs. Each worker can only handle one job at a time and cannot switch jobs once started. Determine the **minimum amount of time** required to complete all the jobs if the work is distributed optimally among the workers. Return the minimum time required to finish all jobs.","solution":"def min_time_to_complete_jobs(jobs, workers): Returns the minimum amount of time required to complete all jobs given the number of workers. This is found by distributing the jobs optimally among the workers. :param jobs: List[int] - List of job times :param workers: int - Number of workers :return: int - Minimum time to complete all jobs if not jobs or workers <= 0: return 0 left, right = max(jobs), sum(jobs) def can_complete_jobs_in_time(time): total_workers = 1 current_sum = 0 for job in jobs: if current_sum + job > time: total_workers += 1 current_sum = 0 if total_workers > workers: return False current_sum += job return total_workers <= workers while left < right: middle = (left + right) // 2 if can_complete_jobs_in_time(middle): right = middle else: left = middle + 1 return left"},{"question":"You are given a grid `m` x `n` representing a 2D map where `0` represents water and `1` represents land. An island is a maximal region of land cells connected horizontally or vertically. Given the grid, return the number of islands present in the grid. If there are no islands, return `0`.","solution":"def numIslands(grid): Returns the number of islands in the given grid. def dfs(i, j): # If out of bounds or at water, return if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == \'0\': return # Mark current cell as visited grid[i][j] = \'0\' # Visit all adjacent cells dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) if not grid: return 0 num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': num_islands += 1 dfs(i, j) return num_islands"},{"question":"Given an integer array `arr`, write a function to find _the length of the longest subarray with a sum that equals zero_.","solution":"def longest_subarray_with_zero_sum(arr): Finds the length of the longest subarray with a sum that equals zero. :param arr: List[int] - An array of integers :return: int - The length of the longest subarray with sum zero sum_map = {} max_len = 0 curr_sum = 0 for i, num in enumerate(arr): curr_sum += num if curr_sum == 0: max_len = i + 1 elif curr_sum in sum_map: max_len = max(max_len, i - sum_map[curr_sum]) else: sum_map[curr_sum] = i return max_len"},{"question":"You are given an integer array `nums` consisting of `n` elements and an integer `target`. Your task is to determine whether there exist three distinct indices `i`, `j`, and `k` in the array such that `nums[i] + nums[j] + nums[k] == target`. Return `true` if such indices exist, and `false` otherwise. Note that you may assume that all elements within the array are distinct and the required output is a boolean value indicating the presence or absence of such a triplet. Make sure your solution is efficient regarding time complexity.","solution":"def three_sum(nums, target): Given an array of integers and a target integer, determine if there are three distinct indices such that the sum of the elements at these indices equals the target. nums.sort() n = len(nums) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: sum_ = nums[i] + nums[left] + nums[right] if sum_ == target: return True elif sum_ < target: left += 1 else: right -= 1 return False"},{"question":"Given a **0-indexed** integer array `arr` of length `n`, implement the `RangeSum` class to handle multiple queries of the following type: - Calculate the **sum** of the elements in `arr` within a specified range `[i, j]` (inclusive). Implement the `RangeSum` class with the following: - `RangeSum(int[] arr)` Initializes the object with the integer array `arr`. - `void update(int index, int val)` Updates the value of `arr` at the specified index to `val`. - `int rangeSum(int i, int j)` Returns the **sum** of the elements in `arr` within the range `[i, j]` (inclusive). You must design an algorithm where both `update` and `rangeSum` operations can be performed efficiently.","solution":"class RangeSum: def __init__(self, arr): self.n = len(arr) self.arr = arr[:] self.prefix_sum = self._build_prefix_sum(arr) def _build_prefix_sum(self, arr): prefix_sum = [0] * (self.n + 1) for i in range(1, self.n + 1): prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1] return prefix_sum def update(self, index, val): difference = val - self.arr[index] self.arr[index] = val for i in range(index + 1, self.n + 1): self.prefix_sum[i] += difference def rangeSum(self, i, j): return self.prefix_sum[j + 1] - self.prefix_sum[i]"},{"question":"Given an integer array `nums`, you need to find a contiguous subarray (containing at least one number) which has the largest sum and return the sum. A subarray is a contiguous part of an array.","solution":"def max_subarray_sum(nums): Finds the contiguous subarray within an array which has the largest sum. Parameters: nums (List[int]): List of integers. Returns: int: The largest sum of the contiguous subarray. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a list of `n` unique integers, `arr`, sorted in strictly increasing order. Your task is to find the smallest missing positive integer from the list. The smallest missing positive integer is the smallest integer greater than `0` that does not appear in the list. Implement a function `smallestMissingPositive(arr: List[int]) -> int` that returns this integer. For example, if the input list is `[1, 2, 3, 5]`, the function should return `4`, and if the input list is `[2, 3, 4, 7]`, the function should return `1`.","solution":"def smallestMissingPositive(arr): Returns the smallest missing positive integer from the sorted unique integer list \'arr\'. # Initialize the smallest missing positive integer to 1 missing = 1 # Iterate through the array to find the smallest missing positive integer for num in arr: if num == missing: missing += 1 elif num > missing: break return missing"},{"question":"Given a string `s`, return the number of segments in the string. A segment is defined as a contiguous sequence of non-space characters. For example, the string \\"Hello, my name is John\\" has 5 segments: \\"Hello,\\", \\"my\\", \\"name\\", \\"is\\", \\"John\\".","solution":"def count_segments(s): Returns the number of segments in the string s. A segment is defined as a contiguous sequence of non-space characters. return len(s.split())"},{"question":"You are given two integers `n` and `k`. Find the number of unique ways to partition the integer `n` into exactly `k` positive integers. Each unique way means that the order of integers in the partition does not matter. Implement the function `int partition(int n, int k)` that returns the number of unique partitions. Ensure that your solution explores the properties of integer partitions and utilizes effective dynamic programming techniques to solve the problem efficiently.","solution":"def partition(n, k): Returns the number of unique ways to partition the integer n into exactly k positive integers. if n < k: return 0 if k == 1: return 1 # Create a 2D DP array with (n+1) x (k+1) dp = [[0 for j in range(k+1)] for i in range(n+1)] # Base case: dp[i][1] = 1 for all i >= 1 for i in range(1, n+1): dp[i][1] = 1 # Fill dp table for i in range(1, n+1): for j in range(2, k+1): if i >= j: dp[i][j] = dp[i-1][j-1] + dp[i-j][j] return dp[n][k]"},{"question":"Implement a class `Cache` that supports the following operations: 1. `set(key, value)`: Set or insert the value `value` for the key `key`. If the cache exceeds its capacity, it should remove the least recently used item before inserting a new item. 2. `get(key)`: Get the value `value` of the key `key`, if it exists in the cache. Otherwise, return -1. The cache should maintain the property that the most recently used items are the last ones to be removed. The cache should be initialized with a maximum capacity. Initialize your data structure with the size `capacity`.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class Cache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(None, None) # Dummy head self.tail = Node(None, None) # Dummy tail self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): Remove node from the doubly linked list. prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add_to_end(self, node): Add node to the end of the doubly linked list (near the tail). prev_last = self.tail.prev prev_last.next = node node.prev = prev_last node.next = self.tail self.tail.prev = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add_to_end(node) return node.value return -1 def set(self, key: int, value: int): if key in self.cache: node = self.cache[key] self._remove(node) node.value = value self._add_to_end(node) else: if len(self.cache) >= self.capacity: # Remove least recently used item (head.next) lru_node = self.head.next self._remove(lru_node) del self.cache[lru_node.key] new_node = Node(key, value) self._add_to_end(new_node) self.cache[key] = new_node"},{"question":"You are given a string `s` consisting only of lowercase English letters and an integer `k`. You need to construct a new string by shifting each letter in the string `s` k times to the right in the alphabet. This means that for a given letter, shifting it once results in the next letter in the alphabet, and shifting from `\'z\'` goes back to `\'a\'`. Return the newly constructed string after applying the shifts. For example, given `s = \\"abc\\"` and `k = 2`, the result would be `\\"cde\\"` since shifting `\'a\'` two times results in `\'c\'`, `\'b\'` two times results in `\'d\'`, and `\'c\'` two times results in `\'e\'`. **Note:** You can assume `k` is a non-negative integer and shifting can wrap around the alphabet multiple times.","solution":"def shift_string(s, k): Shifts each letter in the string s k times to the right in the alphabet. shifted_string = [] for char in s: new_char = chr(((ord(char) - ord(\'a\') + k) % 26) + ord(\'a\')) shifted_string.append(new_char) return \\"\\".join(shifted_string)"},{"question":"Given a list of integers `nums`, your task is to sort the list such that all the odd numbers appear before all the even numbers while maintaining their relative order within their respective groups. For example, given the list `[3, 1, 2, 4]`, the sorted list should be `[3, 1, 2, 4]` since the odd numbers `3` and `1` appear before the even numbers `2` and `4`, and the relative order is maintained. Return the sorted list.","solution":"def sort_odd_even(nums): Sort the list such that all the odd numbers appear before all the even numbers while maintaining their relative order within their respective groups. odds = [num for num in nums if num % 2 != 0] evens = [num for num in nums if num % 2 == 0] return odds + evens"},{"question":"Given a string `s` and an integer `k`, shift the string to the right by `k` positions. Return the modified string. Note that if `k` is greater than the length of `s`, you should repeatedly shift it by the length of `s` until `k` is reduced to a value less than `s`\'s length. For example, if `s` is \\"abcdefg\\" and `k` is 3, the resulting string should be \\"efgabcd\\".","solution":"def shift_string(s, k): Shifts the string s to the right by k positions. Parameters: - s (str): The input string to be shifted. - k (int): The number of positions to shift the string. Returns: - str: The shifted string. if not s: return s # Empty string case n = len(s) # In case k is greater than the length of the string, reduce k k = k % n # Shift the string if k == 0: return s return s[-k:] + s[:-k]"},{"question":"You are given an array `elevation` of length `n`, where `elevation[i]` represents the elevation at index `i`. The array represents a cross-section of terrain, where each element represents the height above sea level at that point. Calculate the amount of water that will be trapped after a rainstorm, given that water cannot flow off the sides of the terrain. Return the total amount of trapped water. For example: Given `elevation = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the output should be `6`.","solution":"def trap_rain_water(elevation): Calculates the amount of water that can be trapped after a rainstorm. :param elevation: List[int]. A list of integers representing the elevation map. :return: int. The total amount of trapped water. if not elevation: return 0 n = len(elevation) left_max = [0] * n right_max = [0] * n left_max[0] = elevation[0] for i in range(1, n): left_max[i] = max(left_max[i-1], elevation[i]) right_max[n-1] = elevation[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], elevation[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - elevation[i] return trapped_water"},{"question":"Given an integer array `arr` and an integer `k`, your task is to find the maximum possible sum of elements in a subsequence of `arr` such that the subsequence has a length of exactly `k`. A **subsequence** is derived from the array by deleting some or no elements while maintaining the relative order of the remaining elements. If there are multiple subsequences with the same maximum sum, return the one which has the smallest lexicographical order. If no such subsequence can be found, return an empty array.","solution":"def max_sum_subsequence(arr, k): Returns the maximum sum subsequence of length k with the smallest lexicographical order when multiple subsequences have the same sum. if len(arr) < k: return [] n = len(arr) max_sum = float(\'-inf\') result = [] def helper(idx, current_subsequence): nonlocal max_sum, result if len(current_subsequence) == k: current_sum = sum(current_subsequence) if (current_sum > max_sum) or (current_sum == max_sum and current_subsequence < result): max_sum = current_sum result = current_subsequence[:] return if idx >= n: return # Include current element current_subsequence.append(arr[idx]) helper(idx + 1, current_subsequence) current_subsequence.pop() # Exclude current element helper(idx + 1, current_subsequence) helper(0, []) return result"},{"question":"Implement a class `MinHeap` to represent a min-heap data structure. The heap should be able to perform the following operations efficiently: * `MinHeap(int capacity)`: Initializes the heap with a fixed size `capacity`. * `void insert(int val)`: Adds a new element `val` to the heap. * `int extractMin()`: Removes and returns the smallest element from the heap. * `int peek()`: Returns the smallest element without removing it. * `boolean isEmpty()`: Checks if the heap is empty. * `int size()`: Returns the number of elements currently in the heap. Ensure that all operations maintain the properties of a min-heap, where the parent node is always smaller than or equal to its children.","solution":"class MinHeap: def __init__(self, capacity): self.capacity = capacity self.size = 0 self.heap = [0] * (capacity + 1) self.heap[0] = -float(\\"inf\\") def insert(self, val): if self.size >= self.capacity: raise Exception(\\"Heap is full\\") self.size += 1 self.heap[self.size] = val current = self.size while self.heap[current] < self.heap[current // 2]: self._swap(current, current // 2) current = current // 2 def extractMin(self): if self.size == 0: raise Exception(\\"Heap is empty\\") min_val = self.heap[1] self.heap[1] = self.heap[self.size] self.size -= 1 self._heapify(1) return min_val def peek(self): if self.size == 0: raise Exception(\\"Heap is empty\\") return self.heap[1] def isEmpty(self): return self.size == 0 def size(self): return self.size def _swap(self, fpos, spos): self.heap[fpos], self.heap[spos] = self.heap[spos], self.heap[fpos] def _heapify(self, pos): if not pos * 2 > self.size: if self.heap[pos] > self.heap[pos * 2] or (pos * 2 + 1 <= self.size and self.heap[pos] > self.heap[pos * 2 + 1]): if pos * 2 + 1 > self.size or self.heap[pos * 2] < self.heap[pos * 2 + 1]: self._swap(pos, pos * 2) self._heapify(pos * 2) else: self._swap(pos, pos * 2 + 1) self._heapify(pos * 2 + 1)"},{"question":"You are given an array of integers `temps` which represents temperature readings over a period of time. Your task is to find the number of continuous subarrays where the average temperature is above a given threshold `t`. A subarray is a contiguous part of an array. Return the _number of subarrays_ where the average temperature exceeds the threshold `t`. Given an integer array `temps` and an integer `t`, write an algorithm to determine the number of such qualifying subarrays.","solution":"def count_subarrays_with_avg_above_threshold(temps, t): Returns the number of continuous subarrays where the average temperature is above a given threshold t. def average(subarray): return sum(subarray) / len(subarray) n = len(temps) count = 0 for i in range(n): for j in range(i, n): subarray = temps[i:j+1] if average(subarray) > t: count += 1 return count"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. Your task is to calculate a new list `result` where each element `result[i]` is the sum of `nums[i]` and the k next elements in the list, wrapping around to the beginning of the list if necessary. For example, given the list `nums = [1, 2, 3, 4]` and `k = 2`, the `result` list should be `[1 + 2 + 3, 2 + 3 + 4, 3 + 4 + 1, 4 + 1 + 2]`, which equals `[6, 9, 8, 7]`. Return _the new list `result` obtained by this transformation_.","solution":"def sum_with_wraparound(nums, k): Returns a new list where each element at index i is the sum of nums[i] and the k next elements in nums, wrapping around if necessary. n = len(nums) result = [] for i in range(n): current_sum = sum(nums[(i + j) % n] for j in range(k + 1)) result.append(current_sum) return result"},{"question":"You are given two integer arrays `arr1` and `arr2` of equal length representing weights and values of `n` items respectively. You are also given an integer `W` which represents the maximum weight capacity of a knapsack. Your task is to determine the maximum total value that can be obtained by selecting a subset of the items such that the total weight does not exceed `W`. Return _the maximum value you can achieve with the given constraints_.","solution":"def knapsack(arr1, arr2, W): Determines the maximum value that can be achieved with the given weight capacity using the provided weights and values. :param arr1: List[int] - list of weights of n items. :param arr2: List[int] - list of values of n items. :param W: int - maximum weight capacity of the knapsack. :return: int - maximum value obtainable with the given constraints. n = len(arr1) # Create a DP table where dp[i][w] represents the maximum value for the first i items with capacity w dp = [[0] * (W + 1) for _ in range(n + 1)] # Fill DP table using bottom-up approach for i in range(1, n + 1): for w in range(W + 1): if arr1[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-arr1[i-1]] + arr2[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][W]"},{"question":"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`. You have the following three operations permitted on a word: 1. Insert a character 2. Delete a character 3. Replace a character Write a function `minDistance` that takes two strings and returns an integer representing the number of operations needed to transform `word1` into `word2`.","solution":"def minDistance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. Operations allowed: 1. Insert a character 2. Delete a character 3. Replace a character m, n = len(word1), len(word2) # Create a 2D array to store the number of operations dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If word1 is empty, insert all characters of word2 elif j == 0: dp[i][j] = i # If word2 is empty, delete all characters of word1 elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are the same, ignore and recur for the remaining strings else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete from word1 dp[i][j - 1], # Insert into word1 dp[i - 1][j - 1]) # Replace in word1 return dp[m][n]"},{"question":"You have a robot cleaner in a room modeled as a grid of size `m x n`. The grid is represented by an array `room` where `room[i][j]` can have one of three values: - `0` represents an empty space the robot can traverse. - `1` represents an obstacle that the robot cannot traverse. - `2` represents the starting position of the robot. The robot can move up, down, left, or right, but it cannot move into obstacles or leave the boundaries of the grid. The robot must clean all empty spaces (i.e., cells with value `0`). The robot cannot return to a cell it has already cleaned. Implement the function `cleanRoom(room)` that returns `true` if the robot can clean all empty spaces starting from the initial position, or `false` otherwise.","solution":"def cleanRoom(room): Determine if the robot can clean all reachable empty spaces starting from the initial position. :param room: List of lists where room[i][j] is one of 0 (empty space), 1 (obstacle), or 2 (starting position). :return: True if all reachable empty spaces can be cleaned, False otherwise. def dfs(x, y): if not (0 <= x < m and 0 <= y < n) or room[x][y] != 0: return room[x][y] = -1 # Mark the cell as cleaned # Move to adjacent cells for dx, dy in directions: dfs(x + dx, y + dy) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right m, n = len(room), len(room[0]) # Find the starting position start_x = start_y = None for i in range(m): for j in range(n): if room[i][j] == 2: start_x, start_y = i, j break if start_x is not None: break # Clean starting position room[start_x][start_y] = -1 # Mark the starting position as cleaned # Perform DFS to clean all reachable empty cells for dx, dy in directions: dfs(start_x + dx, start_y + dy) # Check if there are any remaining empty spaces for row in room: if 0 in row: return False return True"},{"question":"You are given a list of strings `words` and a string `order` that represents the order of characters in an alien language. Your task is to determine if the given list of words is sorted lexicographically in this alien language. * The string `order` is a permutation of the 26 lowercase English letters. * Each word in `words` consists only of lowercase English letters. Return `true` if `words` are sorted in lexicographical order according to the given `order`, or `false` otherwise. For example, given `words = [\\"hello\\",\\"leetcode\\"]` and `order = \\"hlabcdefgijkmnopqrstuvwxyz\\"`, the output should be `true` because in this alien language, \'h\' comes before \'l\'. 1. `bool isAlienSorted(vector<string>& words, string order)` - Determines if the list of words is sorted according to the given order.","solution":"def isAlienSorted(words, order): Returns True if the list of words is sorted according to the given order. Otherwise, returns False. order_index = {char: index for index, char in enumerate(order)} def is_sorted(word1, word2): for c1, c2 in zip(word1, word2): if c1 != c2: return order_index[c1] < order_index[c2] return len(word1) <= len(word2) for i in range(len(words) - 1): if not is_sorted(words[i], words[i + 1]): return False return True"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting of characters from the set `{\'A\', \'B\', \'C\'}`. You can change `s1` into `s2` by performing the following operations any number of times: - Choose any character from `s1` and change it to any other character in the set. Return the minimum number of operations required to transform `s1` into `s2`.","solution":"def min_operations_to_transform(s1, s2): Returns the minimum number of operations required to transform s1 into s2. Both strings are of equal length and consist of characters from the set {\'A\', \'B\', \'C\'}. An operation consists of choosing any character from s1 and changing it to any character from the set. # The minimum number of operations is simply the count of characters that differ between s1 and s2. return sum(1 for a, b in zip(s1, s2) if a != b)"},{"question":"You are given a string `s` containing only the characters `a`, `b`, and `c`. You are allowed to perform any number of operations to remove exactly one character `a`, or one character `b`, or one character `c` from the string. Your goal is to make the string a \\"balanced\\" string. A string is considered balanced if it does not contain any of the consecutive characters \\"aa\\", \\"bb\\", or \\"cc\\". Return _the minimum number of operations required to make the string balanced_. If the string is already balanced, return 0.","solution":"def min_operations_to_balance(s): Given a string s containing only the characters \'a\', \'b\', and \'c\', this function returns the minimum number of operations to remove exactly one character to make the string balanced. A string is considered balanced if it does not contain consecutive characters \'aa\', \'bb\', or \'cc\'. operations = 0 n = len(s) # If the string has one or zero characters, it is already balanced if n <= 1: return 0 # Traverse the string to identify consecutive characters i = 0 while i < n - 1: if s[i] == s[i + 1]: # Found consecutive characters, so one operation is needed operations += 1 # Skip the next character since we removed one of the consecutive characters i += 2 else: i += 1 return operations"},{"question":"You are given a list of `tasks` where tasks[i] = [taskTime, deadline] represents the amount of time required to complete the `i-th task` and the deadline for that task, respectively. You have a single processor that can handle multiple tasks, but only one task can be processed at any given time. You need to schedule these tasks such that the maximum number of tasks are completed before their respective deadlines. Return _the maximum number of tasks that can be completed on time_. Note: Tasks can be started and finished at any point in time, and they don\'t have to be started or finished at integer time points.","solution":"def max_tasks_on_time(tasks): Returns the maximum number of tasks that can be completed on time. Parameters: tasks (List[List[int]]): A list of tasks where each task is represented as [taskTime, deadline]. Returns: int: The maximum number of tasks that can be completed before their respective deadlines. tasks.sort(key=lambda x: x[1]) # Sort tasks by their deadlines current_time = 0 count = 0 for task in tasks: task_time, deadline = task if current_time + task_time <= deadline: # If the task can be finished before its deadline current_time += task_time count += 1 return count"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to return an array of the maximum values of each subarray of length `k` in the given array. If the length of the array is less than `k`, return an empty array.","solution":"from collections import deque from typing import List def max_sliding_window(arr: List[int], k: int) -> List[int]: Returns the maximum values of each subarray of length `k`. Args: arr: List of integers. k: Integer, length of the sliding window. Returns: List of integers representing the maximum values of each subarray of length `k`. # Return an empty array if length of array is less than k if len(arr) < k or k <= 0: return [] deq = deque() result = [] for i in range(len(arr)): # Remove elements from deque that are out of this window if deq and deq[0] == i - k: deq.popleft() # Remove elements smaller than current element as they are of no use while deq and arr[deq[-1]] < arr[i]: deq.pop() deq.append(i) # Append the current max to result list (starts only when we have a full window) if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"You are given a string `s` of length `n`, consisting of only lowercase English letters `a` through `z`. Calculate the **minimum cost** to replace characters in `s` to make it a palindrome. The cost to replace a character `s[i]` with another character `s[j]` is `|i - j|`, i.e., the absolute difference between their positions in the alphabet. Write a function that takes in the string `s` and returns the minimum cost required to make `s` a palindrome. If the string is already a palindrome, the cost is `0`. Note: A palindrome is a string that reads the same forward and backward. For instance, \\"madam\\" and \\"racecar\\" are palindromes.","solution":"def min_cost_to_palindrome(s): Returns the minimum cost required to make the string `s` a palindrome. n = len(s) cost = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: cost += abs(ord(s[i]) - ord(s[n - i - 1])) return cost"},{"question":"Given a string `text`, you are to implement a function that returns an array of index pairs `[start, end]` such that the substring between the start and end indices (inclusive) forms a palindrome. A palindrome is a string that reads the same forward and backward. The returned list of index pairs should be in the order they appear in the input string. In case of overlapping palindromes, include all possible pairs. Example: For the input `text = \\"ababa\\"`, one possible output could be `[[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [0, 2], [1, 3], [2, 4], [0, 4]]`.","solution":"def find_palindrome_pairs(text): Returns all index pairs [start, end] where the substring text[start:end] is a palindrome. palindromes = [] n = len(text) for i in range(n): # Find all odd length palindromes centered at i start, end = i, i while start >= 0 and end < n and text[start] == text[end]: palindromes.append([start, end]) start -= 1 end += 1 # Find all even length palindromes centered between i and i+1 start, end = i, i + 1 while start >= 0 and end < n and text[start] == text[end]: palindromes.append([start, end]) start -= 1 end += 1 return palindromes"},{"question":"Given a list of `n` integers representing a time series dataset, implement a function that returns the longest increasing subsequence of consecutive elements in the dataset. The sequence must be strictly increasing and the elements must be consecutive in their original position. Return the length of this subsequence. For example, given the input `[2, 3, 5, 4, 6, 7, 1]`, the function should return `3`, as the longest increasing subsequence of consecutive elements is `[4, 6, 7]`.","solution":"def longest_increasing_consecutive_subsequence(lst): Returns the length of the longest increasing subsequence of consecutive elements in the dataset. if not lst: return 0 max_length = 1 current_length = 1 for i in range(1, len(lst)): if lst[i] > lst[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"An array `arr` is called a \\"wave array\\" if the element at every even index is greater than or equal to its adjacent elements, and the element at every odd index is less than or equal to its adjacent elements. Given an unsorted integer array `arr`, modify the array into a wave array and return it. Note: It is allowed to modify the array elements in-place to achieve the wave form. If there are multiple solutions, any one of them is acceptable.","solution":"def to_wave_array(arr): Modifies the given list in-place into a wave array. A wave array satisfies the condition: - arr[i] >= arr[i+1] if i is even - arr[i] <= arr[i+1] if i is odd for i in range(len(arr) - 1): if i % 2 == 0: if arr[i] < arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] else: if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] return arr"},{"question":"You are given a string `s` consisting of lowercase English letters, and an array of strings `dictionary` containing distinct words. Your task is to determine if `s` can be segmented into a sequence of one or more dictionary words, such that every word in the segmentation is a concatenation of one or more words from the dictionary. Note that the same dictionary word may be used multiple times in the segmentation. Return _a boolean value_ that is _`true` if `s` can be segmented_ and _`false` otherwise_.","solution":"def can_segment(s, dictionary): Determines if string `s` can be segmented into a sequence of one or more dictionary words. Args: s (str): The string to be segmented. dictionary (list): A list of dictionary words. Returns: bool: True if `s` can be segmented, otherwise False. word_set = set(dictionary) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"You are given an integer `n`, and you need to generate all binary search trees (BST) that have exactly `n` nodes of unique values from `1` to `n`. Return all the distinct BSTs. Each tree should be serialized in a form where the left child of a node is listed before the right child node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_trees(n): if n == 0: return [] def generate(start, end): if start > end: return [None] all_trees = [] for root_val in range(start, end + 1): left_trees = generate(start, root_val - 1) right_trees = generate(root_val + 1, end) for l in left_trees: for r in right_trees: root = TreeNode(root_val) root.left = l root.right = r all_trees.append(root) return all_trees return generate(1, n) def serialize(root): Helper function to serialize the BST to a tuple. if not root: return None return (root.val, serialize(root.left), serialize(root.right))"},{"question":"Given an integer `n`, return _an array of the first_ `n` _numbers in the Fibonacci sequence_. The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n - 1) + F(n - 2) for n > 1 Ensure the resulting array contains exactly `n` elements.","solution":"def fibonacci_sequence(n): Returns an array of the first n numbers in the Fibonacci sequence. if n <= 0: return [] result = [0, 1] while len(result) < n: result.append(result[-1] + result[-2]) return result[:n]"},{"question":"You are given a **0-indexed** integer array `heights`, where `heights[i]` represents the height of the `i-th` building. A building `i` is considered to have a **good view** if for all buildings `j` to its right (where `j > i`), `heights[i]` is strictly greater than `heights[j]`. A building `i` is also considered to have a **good view** if it is the last building in the array. Return _the number of buildings that have a **good view**_.","solution":"def good_view_buildings(heights): Returns the number of buildings that have a good view. n = len(heights) good_view_count = 0 max_right_height = float(\'-inf\') # Initialize to minus infinity # Traverse the buildings from right to left for i in range(n-1, -1, -1): if heights[i] > max_right_height: good_view_count += 1 max_right_height = heights[i] return good_view_count"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. The array `arr` contains only `0`s and `1`s. You can perform the following operation multiple times: select any subarray of length exactly `k` and flip all the bits in that subarray (i.e., change all `0`s to `1`s and all `1`s to `0`s). Return the minimum number of operations required to make all the elements in the array equal to `1`. If it is not possible to make all the elements `1`, return `-1`.","solution":"def min_operations_to_all_ones(arr, k): Returns the minimum number of operations required to make all elements in the array equal to 1, or -1 if it is not possible. n = len(arr) flips = [0] * n # flips[i] will store the number of flips needed up to index i flip_count = 0 operations = 0 for i in range(n): if i >= k: flip_count -= flips[i - k] if (arr[i] + flip_count) % 2 == 0: if i + k > n: return -1 operations += 1 flip_count += 1 flips[i] = 1 return operations"},{"question":"Given a list of `n` tuples `tasks` where each tuple `(s, d)` represents the start and duration of a task, determine the minimum number of conference rooms required to schedule all the given tasks without conflicts. The tasks must be scheduled such that a task starts exactly at its start time and runs for its duration without interruption. Return _the minimum number of conference rooms required_.","solution":"import heapq def min_conference_rooms(tasks): Determine the minimum number of conference rooms required to schedule all the given tasks without conflicts. Tasks: list of tuples (start time, duration) Returns: minimum number of rooms required if not tasks: return 0 # Create a list of (start, end) times for each task events = [(s, s + d) for s, d in tasks] # Sort the events by start time events.sort(key=lambda x: x[0]) # Use a min-heap to track the end time of tasks min_heap = [] for start, end in events: # If the room with the earliest end time is free, remove it from the heap if min_heap and min_heap[0] <= start: heapq.heappop(min_heap) # Add the current task\'s end time to the heap heapq.heappush(min_heap, end) # The number of rooms needed is the size of the heap return len(min_heap)"},{"question":"You are given a list of `n` integers representing the heights of buildings in a cityscape. The city authorities want to install floodlights such that every building gets direct light from at least one floodlight. A floodlight can only illuminate buildings that are at most `k` units to its left or right. Determine the minimum number of floodlights needed to cover all the buildings. Return the minimum number of floodlights needed. Function Signature: ```python def minFloodlights(heights: List[int], k: int) -> int: ```","solution":"from typing import List def minFloodlights(heights: List[int], k: int) -> int: Determines the minimum number of floodlights needed to cover all buildings in the list. :param heights: A list of integers representing the heights of buildings. :param k: An integer representing the maximum distance a floodlight can illuminate in both directions. :return: The minimum number of floodlights needed. n = len(heights) floodlights = 0 i = 0 while i < n: # Find the farthest building to place a floodlight that can cover the current building farthest = min(i + k, n - 1) while farthest > i and farthest - k <= i: farthest -= 1 # Place the floodlight here floodlights += 1 # Move to the next building that is not covered by this floodlight i = farthest + k + 1 return floodlights"},{"question":"You are given an integer array `nums` and an integer `k`. We call an index `i` in the array a **good index** if the `median` of the contiguous subarray of length `k` starting from `i` is `>= target`. Find and return the number of **good indices** in the array. The **median** of an array of integers is the middle element when the array is sorted in non-decreasing order. If the length of the array is even, the median is the average of the two middle elements. For example, the median of `[2, 3, 5]` is `3`, and the median of `[1, 2, 3, 4]` is `(2 + 3) / 2 = 2.5`.","solution":"def find_good_indices(nums, k, target): Finds the number of good indices in the array. Parameters: nums (list of int): The array of integers k (int): The length of the contiguous subarray target (int): The target for the median to compare against Returns: int: The number of good indices def find_median(subarray): Finds the median of a subarray. Parameters: subarray (list of int): The subarray of integers Returns: float: The median of the subarray subarray.sort() mid = len(subarray) // 2 if len(subarray) % 2 == 0: return (subarray[mid - 1] + subarray[mid]) / 2 else: return subarray[mid] good_indices_count = 0 for i in range(len(nums) - k + 1): subarray = nums[i:i+k] if find_median(subarray) >= target: good_indices_count += 1 return good_indices_count"},{"question":"You are given a **0-indexed** array of integers `nums` of length `n`. Your task is to return an array `result` of the same length where `result[i]` contains the product of all the elements in `nums` except `nums[i]`. Write an algorithm to solve this problem in **O(n)** time complexity and use **constant** extra space (excluding the output array). For example, given the array `[1, 2, 3, 4]`, the result should be `[24, 12, 8, 6]` because: * For `result[0]`, the product is `2*3*4 = 24` * For `result[1]`, the product is `1*3*4 = 12` * For `result[2]`, the product is `1*2*4 = 8` * For `result[3]`, the product is `1*2*3 = 6`","solution":"def product_except_self(nums): Given an array nums of n integers where n > 1, returns an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. n = len(nums) result = [1] * n prefix = 1 for i in range(n): result[i] = prefix prefix *= nums[i] postfix = 1 for i in range(n - 1, -1, -1): result[i] *= postfix postfix *= nums[i] return result"},{"question":"You are given a **binary search tree (BST)** with `n` nodes. Each node carries a unique integer value. You need to implement a function to find the **lowest common ancestor (LCA)** of two given nodes in the BST. The LCA of two nodes `p` and `q` in a BST is defined as the lowest node that has both `p` and `q` as its descendants (where we allow a node to be a descendant of itself). Your function should take the root of the BST and the two nodes `p` and `q`, and return the LCA node. If either `p` or `q` is not found in the BST, return `null`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find(root, val): Helper function to find a node with given value in BST. if root is None: return None if val == root.val: return root elif val < root.val: return find(root.left, val) else: return find(root.right, val) def lowest_common_ancestor(root, p, q): Returns the lowest common ancestor of nodes with values p and q. if find(root, p) is None or find(root, q) is None: return None def lca_helper(node, p, q): if node is None: return None if p < node.val and q < node.val: return lca_helper(node.left, p, q) elif p > node.val and q > node.val: return lca_helper(node.right, p, q) else: return node return lca_helper(root, p, q)"},{"question":"You are given a **0-indexed** array `prices` representing the price of a stock on each day. You are also given a 0-indexed two-dimensional array `queries` where `queries[i]` is a list of two integers `[a, b]`. For each query, you need to find the maximum profit that can be achieved by buying the stock on day `a` and selling it on day `b` (both `a` and `b` must be within the length of the `prices` array). If no profit can be achieved, return 0 for that query. Return _an array containing the maximum profit for each query_.","solution":"def max_profit(prices, queries): Returns an array containing the maximum profit for each query. :param prices: List of prices where prices[i] is the price of the stock on the i-th day. :param queries: List of queries where queries[i] is a list of two integers [a, b]. :return: List of integers where each integer is the maximum profit for the corresponding query. results = [] for a, b in queries: if a >= len(prices) or b >= len(prices) or b <= a: results.append(0) continue max_profit = 0 min_price = prices[a] for i in range(a + 1, b + 1): max_profit = max(max_profit, prices[i] - min_price) min_price = min(min_price, prices[i]) results.append(max_profit) return results"},{"question":"You are given an array `cardPoints` of integers representing points from cards arranged in a row. You can pick `k` cards from the __start__ or the __end__ of the row. The score you get is the sum of the picked cards. Return _the **maximum** score you can obtain by picking exactly_ `k` _cards_.","solution":"def maxScore(cardPoints, k): Returns the maximum score by picking exactly k cards from the start or end of the array. n = len(cardPoints) total_sum = sum(cardPoints) if k >= n: return total_sum current_min_subarray_sum = sum(cardPoints[:n - k]) current_subarray_sum = current_min_subarray_sum for i in range(n - k, n): current_subarray_sum += cardPoints[i] current_subarray_sum -= cardPoints[i - (n - k)] current_min_subarray_sum = min(current_min_subarray_sum, current_subarray_sum) return total_sum - current_min_subarray_sum"},{"question":"You are given an integer array `nums` representing a list of non-negative integers. Your task is to rearrange the elements of `nums` to form the largest possible integer and return it. Since the result may be very large, return the largest number in the form of a string. Ensure that ordering the elements maintains the largest lexicographical order. For example, given `nums = [3, 30, 34, 5, 9]`, the largest formed integer would be `9534330`.","solution":"from functools import cmp_to_key def largest_number(nums): Rearranges the elements of nums to form the largest possible integer and returns it as a string. # Convert all the integers in the list to strings for easier comparison nums_str = list(map(str, nums)) # Define a custom comparator function def compare(x, y): # Compare based on concatenated results if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort the numbers using the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Concatenate the sorted list into a single string result = \'\'.join(nums_str) # Edge case: check if the result is all zeros if result[0] == \'0\': return \'0\' return result"},{"question":"A social media platform wants to track the number of unique users that interact with a post. Each interaction is recorded with a user ID and a timestamp. Given a list of interactions represented as tuples `(userId, timestamp)`, where `userId` is a string representing the unique ID of the user and `timestamp` is an integer representing the time of interaction in seconds since the epoch, you must determine the number of unique users that interacted with the post within a given time window. Define a function `unique_users_in_time_window(interactions: List[Tuple[str, int]], start: int, end: int) -> int` that takes in three arguments: 1. `interactions`: A list of tuples representing user interactions. 2. `start`: An integer representing the start timestamp of the time window. 3. `end`: An integer representing the end timestamp of the time window. Return the number of unique users that interacted with the post within the inclusive time window `[start, end]`. If no interactions occur within the given time window, return `0`. Example: ``` interactions = [(\\"user1\\", 1001), (\\"user2\\", 1004), (\\"user1\\", 1006), (\\"user3\\", 1007)] start = 1002 end = 1006 unique_users_in_time_window(interactions, start, end) -> 2 ``` In the above example, \\"user1\\" and \\"user3\\" interacted within the time window `[1002, 1006]`.","solution":"from typing import List, Tuple def unique_users_in_time_window(interactions: List[Tuple[str, int]], start: int, end: int) -> int: Returns the number of unique users that interacted within the given time window. Args: interactions (List[Tuple[str, int]]): A list of tuples with user ID and timestamp. start (int): The start timestamp of the time window. end (int): The end timestamp of the time window. Returns: int: The count of unique users interacting within the time window. unique_users = set() for user_id, timestamp in interactions: if start <= timestamp <= end: unique_users.add(user_id) return len(unique_users)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to rearrange the characters in `s` such that the same characters are at least `k` distance apart. If it is not possible to rearrange the string in this way, return an empty string. If there are multiple valid rearrangements, return any of them. For example, given `s = \\"aabbcc\\"` and `k = 2`, one possible valid rearrangement is `\\"abcabc\\"`. ```python def rearrangeString(s: str, k: int) -> str: # your code here ``` # Constraints: * 1 <= len(s) <= 10^4 * s consists of only lowercase English letters. * 0 <= k <= len(s)","solution":"import heapq from collections import Counter, deque def rearrangeString(s: str, k: int) -> str: if k == 0: return s # Frequency map of characters char_count = Counter(s) # Max heap (negative count because Python\'s heapq is a min-heap) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) queue = deque() # Queue to keep track of characters and their next valid positions result = [] while max_heap: current_count, current_char = heapq.heappop(max_heap) result.append(current_char) queue.append((current_char, current_count + 1)) if len(queue) >= k: release_char, release_count = queue.popleft() if -release_count > 0: heapq.heappush(max_heap, (release_count, release_char)) if len(result) == len(s): return \'\'.join(result) else: return \\"\\""},{"question":"You are given a **knight** on an `n x n` chessboard. The knight\'s position is given and it needs to reach a target position. The knight moves in an \\"L\\" shape: it can move two squares in one direction and then one square perpendicular to that, or move one square in one direction and then two squares perpendicular to that. Given the initial position of the knight, its target position, and the size of the chessboard `n`, return the minimum number of moves required for the knight to reach the target position. If the knight cannot reach the target position, return `-1`. Implement the function `min_knight_moves(n: int, start: Tuple[int, int], target: Tuple[int, int]) -> int`.","solution":"from collections import deque def min_knight_moves(n, start, target): Returns the minimum number of moves required for a knight to reach from start to target on an n x n chessboard, or -1 if the knight can\'t reach the target. def is_inside_board(x, y): return 0 <= x < n and 0 <= y < n directions = [ (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1) ] if start == target: return 0 queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, moves = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) == target: return moves + 1 if is_inside_board(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"You are given two strings `s1` and `s2` of the same length, consisting only of lowercase letters. A **swap** of two characters in a string means exchanging the characters at two different positions. Return _true_ if it is possible to make the two strings equal by **at most one swap** of two characters within `s1`, or _false_ otherwise. Example: ``` Input: s1 = \\"bank\\", s2 = \\"kanb\\" Output: true Explanation: We can swap \'b\' with \'k\' in \\"bank\\" to get \\"kanb\\", which is equal to s2. Input: s1 = \\"attack\\", s2 = \\"defend\\" Output: false Explanation: It is impossible to make the two strings equal with at most one swap.","solution":"def is_one_swap_away(s1, s2): Check if two strings s1 and s2 can be made equal by at most one swap. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings can be made equal by at most one swap, False otherwise. if s1 == s2: return True diff = [(c1, c2) for c1, c2 in zip(s1, s2) if c1 != c2] if len(diff) == 2 and diff[0] == diff[1][::-1]: return True return False"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to return _all unique pairs of integers from_ `nums` _that add up to_ `target`. Each pair should be in the form of a list `[a, b]`, where `a  b`. The result should not contain duplicate pairs and can be returned in any order.","solution":"def find_pairs(nums, target): Finds all unique pairs of integers in nums that add up to the target. Args: nums (list of int): List of integers. target (int): The target sum. Returns: list of list of int: List of unique pairs that sum to the target. nums.sort() left, right = 0, len(nums) - 1 result = [] seen = set() while left < right: current_sum = nums[left] + nums[right] if current_sum == target: if (nums[left], nums[right]) not in seen: result.append([nums[left], nums[right]]) seen.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return result"},{"question":"A **bouncy number** is a positive number that is neither increasing nor decreasing. In an increasing number, the digits are in non-decreasing order, whereas in a decreasing number, the digits are in non-increasing order. Given an integer `num`, return `true` if `num` is a **bouncy number** or `false` otherwise.","solution":"def is_bouncy_number(num): Determines if the given number is a bouncy number. A bouncy number is a positive number that is neither increasing nor decreasing. if num < 100: return False # By definition, numbers less than 100 are not considered bouncy num_str = str(num) increasing = True decreasing = True for i in range(len(num_str) - 1): if num_str[i] < num_str[i + 1]: decreasing = False elif num_str[i] > num_str[i + 1]: increasing = False return not (increasing or decreasing)"},{"question":"Given an array of integers `nums` that represents n distinct coins, where each coin\'s position in the array corresponds to its weight, you need to determine if it is possible to split the array into exactly two subsets such that the sum of the weights in both subsets is equal. Return `true` if this is possible, otherwise return `false`.","solution":"def can_partition(nums): Determines if it is possible to partition the array into two subsets such that the sum of the subsets is equal. :param nums: List[int] - list of integers representing weights of the coins :returns: bool - True if partition is possible, False otherwise total_sum = sum(nums) # If the total sum is odd, it cannot be partitioned into equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a boolean DP array dp = [False] * (target + 1) dp[0] = True # Base case: zero sum is always possible for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"Given an integer array `arr` of size `n` and an integer `k`, return the minimum possible value of the maximum element after performing at most `k` increments on any of the elements of the array. An increment operation consists of increasing an element of the array by 1.","solution":"def minimize_max_element(arr, k): Minimizes the maximum element in the array after performing at most k increments. Parameters: arr (list of int): The input array. k (int): The maximum number of increments allowed. Returns: int: The minimum possible value of the maximum element after increments. import heapq # Convert array into a min heap heapq.heapify(arr) while k > 0: # Pop the smallest element min_elem = heapq.heappop(arr) # Increment that element min_elem += 1 # Push it back to heap heapq.heappush(arr, min_elem) # Decrease the number of remaining increments k -= 1 # The largest element in heap is the minimum possible value of the maximum element in the array return max(arr)"},{"question":"Write a function that takes a list of integers and an integer `k`, and returns _the number of pairs_ `(i, j)` where `i < j` and the sum of `i` and `j` is divisible by `k`.","solution":"def count_divisible_pairs(arr, k): Returns the number of pairs (i, j) where i < j and the sum of i and j is divisible by k. Parameters: arr (list of int): List of integers. k (int): The divisor. Returns: int: Number of valid pairs. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"Given a string `s` containing only lowercase English letters, return the _length of the longest palindromic substring_ in `s`.","solution":"def longest_palindromic_substring(s): Returns the length of the longest palindromic substring in s. def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 if not s or len(s) == 0: return 0 max_len = 0 for i in range(len(s)): len1 = expand_around_center(i, i) # Odd length palindromes len2 = expand_around_center(i, i + 1) # Even length palindromes max_len = max(max_len, len1, len2) return max_len"},{"question":"Given a string `s` consisting of lowercase English letters and an integer array `indices` of the same length, you have to return a new string where the character at the `i-th` position moves to `indices[i]` in the new string. Ensure the returned string maintains the original order of characters based on the `indices` permutation. If `indices` has invalid positions or duplicates, throw an error or return an appropriate message indicating invalid input.","solution":"def restore_string(s, indices): Returns a new string where the character at the i-th position moves to indices[i] in the new string. if len(s) != len(indices): raise ValueError(\\"The length of the string and the indices array must be the same.\\") if len(set(indices)) != len(indices): raise ValueError(\\"Indices array contains duplicate values.\\") if any(i >= len(s) or i < 0 for i in indices): raise ValueError(\\"Indices array contains invalid positions.\\") result = [\'\'] * len(s) for i, index in enumerate(indices): result[index] = s[i] return \'\'.join(result)"},{"question":"Given a list of integers `nums` and an integer `k`, you need to rotate the array to the right by `k` steps, where `k` is non-negative. Implement a function `rotate(nums, k)` that achieves this rotation in-place, with `O(1)` extra space complexity. For example, given `nums = [1,2,3,4,5,6,7]` and `k = 3`, the output should be `[5,6,7,1,2,3,4]`. If `nums = [-1,-100,3,99]` and `k = 2`, the output should be `[3,99,-1,-100]`. Note that the elements within the array must retain their relative order after rotation.","solution":"def rotate(nums, k): Rotates the list nums to the right by k steps in-place. Parameters: nums (List[int]): The input list of integers to be rotated. k (int): The number of steps to rotate the list. n = len(nums) k = k % n # If k is greater than n, we only need to rotate k % n times nums[:] = nums[-k:] + nums[:-k]"},{"question":"Given the `head` of a singly linked list, reverse the list and return _the head of the reversed list_. The linked list is defined by interacting nodes where each node contains a single integer value and a reference to the next node in the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"You are given a binary tree with `n` nodes, each node contains a value `val` and has two children `left` and `right`. Your task is to find and return the length of the longest path in the binary tree such that each node in the path is either strictly greater than or strictly less than its parent node\'s value. The path does not necessarily have to pass through the root, but must be contiguous.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_monotonic_path(root): Finds the longest path in the binary tree such that each node in the path is either strictly greater than or strictly less than its parent node\'s value. def dfs(node): if not node: return 0, 0 # increasing, decreasing left_inc, left_dec = dfs(node.left) right_inc, right_dec = dfs(node.right) inc = dec = 1 # start with current node if node.left: if node.left.val > node.val: inc = max(inc, left_inc + 1) elif node.left.val < node.val: dec = max(dec, left_dec + 1) if node.right: if node.right.val > node.val: inc = max(inc, right_inc + 1) elif node.right.val < node.val: dec = max(dec, right_dec + 1) # update the longest path longest_path[0] = max(longest_path[0], inc, dec) return inc, dec longest_path = [0] dfs(root) return longest_path[0]"},{"question":"You are given an array of integers `nums` representing the number of different colored balls in a line. Your task is to rearrange the balls so that no two adjacent balls have the same color. If it is not possible to rearrange the balls in such a way, return an empty string. If it is possible, return any rearrangement that satisfies the condition.","solution":"def rearrange_balls(nums): from collections import Counter import heapq # Convert the list of integers to a string of characters representing different colors balls = \'\'.join(str(i) for i in range(len(nums)) for _ in range(nums[i])) n = len(balls) if not balls: return \\"\\" # Use a max heap to store the balls with their frequency counts = Counter(balls) max_heap = [(-freq, ball) for ball, freq in counts.items()] heapq.heapify(max_heap) # Previous ball that was added, initialized to be an impossible value prev_freq, prev_ball = 0, \'\' result = [] while max_heap: # Pop the most frequent ball freq, ball = heapq.heappop(max_heap) # Append the current ball to the result result.append(ball) # If previous ball count is not ready to be pushed again, push it back to heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_ball)) # Update previous ball with the current one prev_freq, prev_ball = freq + 1, ball rearranged = \'\'.join(result) # If the rearranged length is equal to original, it means successful rearrangement if len(rearranged) == n: return rearranged return \\"\\""},{"question":"You\'re given an integer array `arr` representing a running track where each element indicates the elevation at that point. Your task is to determine the **minimum energy** required for a runner to complete a lap around the track starting and ending at the same elevation. The runner can only move forward or backward by one step at a time. The energy required to move between two points is the absolute difference in their elevations. Return _the minimum energy required_ for the runner to complete the lap around the track starting and ending at the same elevation. Note that the runner can start at any point on the track.","solution":"def min_energy_to_complete_lap(arr): Returns the minimum energy required for a runner to complete a lap around the track starting and ending at the same elevation. # Calculate the total energy required if a runner starts at the first point and goes around the track total_energy = 0 for i in range(len(arr)): total_energy += abs(arr[i] - arr[(i + 1) % len(arr)]) # Since the total track must be travelled regardless of the starting point # and the track is circular, the minimum energy to complete the lap is equally based # on the overall height differences between each consecutive pair of points return total_energy"},{"question":"Given a linked list where each node contains a single digit, write a function to add two such linked lists and return the result as a new linked list. The digits are stored in reverse order, meaning that the 1\'s digit is at the head of the list. Each of the linked lists can have different lengths.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): Given two linked lists representing two numbers in reverse order, adds the numbers and returns the sum as a new linked list. dummy = ListNode() current = dummy carry = 0 while l1 or l2 or carry: val1 = (l1.val if l1 else 0) val2 = (l2.val if l2 else 0) total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy.next"},{"question":"You are given an array of integers `nums` and an integer `k` representing the number of sliding window operations to apply. A sliding window operation involves repeatedly shifting a subarray of `k` elements to the right by one position and bringing the last element of this subarray to the beginning of the array. Return _the array_ `nums` _after performing the sliding window operation_ `k` _times_. Note that if `k` is greater than the length of the array, you should repeat the process `k % len(nums)` times.","solution":"def sliding_window_operation(nums, k): Perform the sliding window operation k times on the array nums. If k is greater than the length of the array, repeat the process k % len(nums) times. :param nums: List[int] - The input array of integers. :param k: int - The number of sliding window operations to apply. :return: List[int] - The array after performing the sliding window operations. n = len(nums) if n == 0: return nums # Since repeating the process len(nums) times results in the original array k = k % n for _ in range(k): last_element = nums[-1] # Create new array after moving the last element to the start and shifting the rest one position to the right nums = [last_element] + nums[:-1] return nums"},{"question":"Given an array of integers `nums` representing a list of coordinates, you need to form as many **pairs** as possible. A pair consists of two elements `(a, b)` such that `|a - b| <= 1`. Return _the maximum number of pairs that can be formed from the array_. Note that each element in the array can only be used in one pair.","solution":"def max_pairs(nums): Returns the maximum number of pairs that can be formed from the array, where a pair (a, b) satisfies |a - b| <= 1. nums.sort() i, pairs = 0, 0 while i < len(nums) - 1: if abs(nums[i] - nums[i + 1]) <= 1: pairs += 1 i += 2 # skip the next number as it forms a pair with the current number else: i += 1 # move to next number return pairs"},{"question":"You are given a list of `n` intervals where each interval is represented as a pair of integers `[start, end]` where `start` is the start of the interval and `end` is the end of the interval. A new interval `[new_start, new_end]` is inserted into the list, merging all overlapping intervals in the process. Return the resulting list of intervals after the insertion and merging process. Example: If the initial list of intervals is `[[1, 3], [6, 9]]` and the new interval inserted is `[2, 5]`, the returned list should be `[[1, 5], [6, 9]]`.","solution":"def insert_and_merge_intervals(intervals, new_interval): Inserts a new interval into a list of intervals and merges all overlapping intervals. :param intervals: List of intervals represented as [start, end] pairs :param new_interval: New interval to insert represented as [start, end] :return: List of merged intervals after inserting the new interval intervals.append(new_interval) intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last = merged_intervals[-1] if current[0] <= last[1]: # overlapping intervals merged_intervals[-1] = [last[0], max(last[1], current[1])] else: merged_intervals.append(current) return merged_intervals"},{"question":"You are given a binary tree with `n` nodes labeled from `0` to `n-1`. Each node has **no more than one** parent, forming a valid binary tree. For each node, you want to determine how many nodes are in its subtree (node itself plus all its descendants). Write a function that, given the root of the tree, returns an array where the value at index i is the size of the subtree rooted at node i.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def subtree_sizes(root): Given the root of a binary tree, returns an array where the value at index i is the size of the subtree rooted at node i. :param root: TreeNode, the root of the binary tree :return: List[int], list containing the size of the subtree rooted at each node. # Dictionary to store the size of the subtree for each node sizes = {} def dfs(node): Depth-First Search to calculate subtree sizes if not node: return 0 left_size = dfs(node.left) right_size = dfs(node.right) subtree_size = 1 + left_size + right_size sizes[node.val] = subtree_size return subtree_size # Initiate DFS from the root dfs(root) # Convert sizes dictionary to list result = [0] * len(sizes) for key, value in sizes.items(): result[key] = value return result"},{"question":"You are given a binary tree with `n` nodes where each node denotes a unique number from `1` to `n`. Write a function that returns the list of all node values that do not have any children (leaf nodes). The input will be provided as a list of tuples where each tuple contains two elements, representing the parent and child nodes. For example, if the input list is `[(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]`, the output should be `[4, 5, 6]`.","solution":"def find_leaf_nodes(edges): Given a list of tuples representing edges in a binary tree, returns the list of all leaf nodes (nodes with no children). :param edges: List of tuples where each tuple represents a parent-child connection. :return: List of leaf nodes. from collections import defaultdict # Set to store all nodes that appear in the child position children = set() # Set to store all nodes that appear in the parent position parents = set() for parent, child in edges: parents.add(parent) children.add(child) # Leaf nodes are those which are in children set but not in parent set leaf_nodes = list(children - parents) return leaf_nodes"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and an integer `k`. Define a pair `(u, v)` which consists of one element from the first array and one element from the second array. Find the k pairs `(u1, v1), (u2, v2), ..., (uk, vk)` with the smallest sums. Return _the pairs of these k pairs in ascending order of their sums._ If two pairs have the same sum, the pair with the smaller first element should come first. If two pairs have the same sum and the same first element, the pair with the smaller second element should come first.","solution":"import heapq def k_smallest_pairs(nums1, nums2, k): Find the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums. Parameters: nums1 (List[int]): First sorted integer array. nums2 (List[int]): Second sorted integer array. k (int): The required number of pairs. Returns: List[Tuple[int, int]]: The k pairs with the smallest sums. if not nums1 or not nums2 or k <= 0: return [] min_heap = [] for i in range(min(k, len(nums1))): heapq.heappush(min_heap, (nums1[i]+nums2[0], i, 0)) res = [] while min_heap and len(res) < k: sum_val, i, j = heapq.heappop(min_heap) res.append((nums1[i], nums2[j])) if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i]+nums2[j+1], i, j+1)) return res"},{"question":"You are tasked with designing a seating arrangement for a cinema hall. The cinema seats are arranged in rows of columns, represented by a 2D integer array `seats` where `seats[i][j]` is either `0` (indicating an empty seat) or `1` (indicating a reserved seat). However, seating should optimize for maximum comfort, meaning that every empty seat should ideally have at least one empty seat adjacent to it (horizontally or vertically). Write a function that, given the seating layout, returns the maximum number of people that can be seated such that no two seated people are adjacent (directly next to each other horizontally or vertically). You may assume that all seats are currently empty (i.e., all elements in the `seats` array are initialized to `0`). Return _the maximum number of people that can be seated under the given conditions_.","solution":"def maxNumberOfPeople(seats): Returns the maximum number of people that can be seated such that no two people are adjacent either horizontally or vertically. # Number of rows and columns rows = len(seats) if rows == 0: return 0 cols = len(seats[0]) if cols == 0: return 0 # Count maximum number of people count = 0 # Traverse each seat and attempt to sit people ensuring comfort rule for i in range(rows): for j in range(cols): if seats[i][j] == 0: # Check if any adjacent seat is taken if (i == 0 or seats[i-1][j] == 0) and (i == rows-1 or seats[i+1][j] == 0) and (j == 0 or seats[i][j-1] == 0) and (j == cols-1 or seats[i][j+1] == 0): # Place a person here seats[i][j] = 1 count += 1 return count"},{"question":"Given two strings `s1` and `s2`, find the length of the longest substring that appears in both `s1` and `s2`. The substring is defined as a contiguous sequence of characters that appear in the same order in both strings. If there are multiple longest substrings with the same length, output the length of any one of them. Example: - Input: s1 = \\"substringfinder\\", s2 = \\"stringstart\\" - Output: 6 (The longest common substring is \\"string\\", which has a length of 6) Note: The input strings will have lengths that can occasionally exceed typical sizes, so consider the efficiency of your solution.","solution":"def longest_common_substring(s1, s2): Returns the length of the longest common substring between s1 and s2. m, n = len(s1), len(s2) # Create a 2D list to store lengths of longest common suffixes of substrings lc_suffix = [[0] * (n + 1) for _ in range(m + 1)] longest_length = 0 # Length of the longest common substring # Building the lc_suffix array in bottom-up fashion for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: lc_suffix[i][j] = lc_suffix[i - 1][j - 1] + 1 longest_length = max(longest_length, lc_suffix[i][j]) else: lc_suffix[i][j] = 0 return longest_length"},{"question":"Given an array of integers `nums`, you are tasked with dynamically creating a new array `result` where each element at index `i` of `result` is the product of all the numbers in `nums` except `nums[i]`. You must achieve this without using the division operation and in O(n) time complexity. Return the resulting array `result`.","solution":"def product_except_self(nums): Given an array of integers nums, return an array result where result[i] is the product of all elements of nums except nums[i]. length = len(nums) result = [1] * length prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] suffix = 1 for i in range(length - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"You are given a string `s` and an array of indices `indices` of the same length. The string `s` is a **shuffled** version of a given string that has its characters randomly scrambled. Reorder the `s` string such that the character at the `ith` position moves to the index specified by `indices[i]` in the reordered string. For example, given `s = \\"aiohn\\"` and `indices = [3,1,4,2,0]`, the character `\'a\'` from the original string is at index `0` in the shuffled string and should be moved to index `indices[0]=3` in the reordered string. Return the reordered string.","solution":"def restore_string(s, indices): Reorders the characters in the string `s` based on the given `indices`. Args: s (str): The shuffled input string. indices (List[int]): The list of target indices. Returns: str: The reordered string. n = len(s) reordered = [\'\'] * n for i in range(n): reordered[indices[i]] = s[i] return \'\'.join(reordered)"},{"question":"Design a Notification System where users can subscribe to different types of **events,** receive notifications for those events, and manage their subscriptions. Implement the `NotificationSystem` class: * `NotificationSystem()` Initializes the object. * `void subscribe(int userId, String eventType)` Subscribes the user with the ID `userId` to the event type `eventType`. * `void unsubscribe(int userId, String eventType)` Unsubscribes the user with the ID `userId` from the event type `eventType`. * `void sendNotification(String eventType, String message)` Sends a notification with the content `message` to all users subscribed to the event type `eventType`. * `List<String> getUserNotifications(int userId)` Returns a list of all notifications received by the user with ID `userId`, ordered by the time they were received. Notifications should be stored in the order they are sent, and each notification should only be received once.","solution":"from collections import defaultdict class NotificationSystem: def __init__(self): self.subscriptions = defaultdict(set) # EventType -> Set of UserIds self.notifications = defaultdict(list) # UserId -> List of Notifications def subscribe(self, userId, eventType): self.subscriptions[eventType].add(userId) def unsubscribe(self, userId, eventType): if userId in self.subscriptions[eventType]: self.subscriptions[eventType].remove(userId) def sendNotification(self, eventType, message): for userId in self.subscriptions[eventType]: self.notifications[userId].append(message) def getUserNotifications(self, userId): return self.notifications[userId]"},{"question":"Given an array `nums` consisting of `n` integers, return the length of the longest subconsecutive sequence of integers. A subsequence is defined as a possible sequence derived from the array `nums` where each successive element in the subsequence is exactly `1` greater than the previous element. The elements in the subsequence need not be contiguous in the original array.","solution":"def longest_subconsecutive_sequence(nums): Return the length of the longest subconsecutive sequence of integers in nums. if not nums: return 0 nums = list(set(nums)) # Remove duplicates nums.sort() longest_streak = 1 current_streak = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1] + 1: current_streak += 1 else: longest_streak = max(longest_streak, current_streak) current_streak = 1 return max(longest_streak, current_streak)"},{"question":"Given a string `s` and an integer `k`, return _a list of all unique substrings of length_ `k` _that occur in the string_ `s`. If `s` has less than `k` characters, return an _empty list_. The substrings in the list should appear in the order they are first encountered in the string `s`. For example, given `s = \\"abcabc\\"` and `k = 3`, the result would be `[\\"abc\\", \\"bca\\", \\"cab\\"]`.","solution":"def unique_substrings_of_length_k(s, k): Returns a list of all unique substrings of length k that occur in the string s. Parameters: - s (str): The input string. - k (int): The length of substrings to find. Returns: - list: A list of unique substrings of length k in the order they appear in s. if k > len(s): return [] seen = set() unique_substrings = [] for i in range(len(s) - k + 1): substring = s[i:i+k] if substring not in seen: seen.add(substring) unique_substrings.append(substring) return unique_substrings"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to determine the length of the longest substring that contains no repeated characters. Return _an array where the first element is the length of this substring and the second element is the starting index of the substring in the original string_. If there are multiple substrings with the same maximum length, return the one with the **smallest** starting index.","solution":"def longest_unique_substring(s): Returns an array where the first element is the length of the longest substring containing no repeated characters, and the second element is the starting index of the substring in the original string. max_len = 0 max_start = 0 start = 0 char_index_map = {} for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end current_len = end - start + 1 if current_len > max_len: max_len = current_len max_start = start return [max_len, max_start]"},{"question":"Write a function that takes a string `s` representing a roman numeral and converts it to an integer. The input string is guaranteed to be a valid roman numeral in the range from 1 to 3999.","solution":"def roman_to_int(s): Converts a string representing a Roman numeral to an integer. roman_to_integer_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 previous_value = 0 for char in reversed(s): current_value = roman_to_integer_map[char] if current_value >= previous_value: total += current_value else: total -= current_value previous_value = current_value return total"},{"question":"You are given an integer array `nums` and an integer target value `x`. In one operation, you can remove the leftmost or rightmost element from the array `nums` and subtract its value from `x`. Note that the array is not circular, and after an element is removed, it is no longer part of the array. Your goal is to compute the minimum number of operations required to reduce `x` to exactly zero. If it is not possible, return -1.","solution":"def min_operations(nums, x): Returns the minimum number of operations required to reduce x to zero by removing elements from the left or right of the array. If not possible, returns -1. target = sum(nums) - x if target < 0: return -1 current_sum = 0 max_len = -1 left = 0 for right in range(len(nums)): current_sum += nums[right] while current_sum > target and left <= right: current_sum -= nums[left] left += 1 if current_sum == target: max_len = max(max_len, right - left + 1) return len(nums) - max_len if max_len != -1 else -1"},{"question":"Given a list of non-negative integers representing the heights of buildings, find the maximum area of water that can be trapped between the buildings after a rainstorm. The width of each building is `1`. Implement a function `maxWaterArea(heights)` that takes a list `heights` and returns the maximum area of water that can be trapped.","solution":"def maxWaterArea(heights): Calculate the maximum area of water that can be trapped between buildings after a rainstorm. :param heights: List[int], list of non-negative integers representing the heights of buildings. :return: int, maximum area of water that can be trapped. left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left current_height = min(heights[left], heights[right]) current_area = width * current_height max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"Given an integer `n`, return the number of structurally unique **BSTs** (binary search trees) which has exactly `n` nodes of unique values from `1` to `n`. Implement a function `int numTrees(int n)` to compute this number. Note: Multiple BSTs are considered structurally unique if their layouts are different but may contain the same set of values.","solution":"def numTrees(n): Returns the number of structurally unique BSTs that can be formed with `n` nodes. # Base case if n == 0 or n == 1: return 1 # Create a list to store results of subproblems dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Fill the dp array using the recursive formula for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - j - 1] return dp[n]"},{"question":"Given an integer array `nums`, sort the array in ascending order using the Merge Sort algorithm and return the sorted array. The array can contain both positive and negative numbers. Implement the Merge Sort algorithm recursively and ensure your function can handle edge cases such as an empty array or an array with a single element.","solution":"def merge_sort(nums): Sorts the array in ascending order using the Merge Sort algorithm. if len(nums) <= 1: return nums mid = len(nums) // 2 left_half = merge_sort(nums[:mid]) right_half = merge_sort(nums[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list. sorted_array = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_array.append(left[left_index]) left_index += 1 else: sorted_array.append(right[right_index]) right_index += 1 sorted_array.extend(left[left_index:]) sorted_array.extend(right[right_index:]) return sorted_array"},{"question":"Given a directed graph, design an algorithm to find the shortest path from a given start node to a given end node. Assume the graph is represented as an adjacency list, where `graph[i]` contains a list of all neighboring nodes that can be reached directly from node `i`, and each edge has a weight of one. If there is no path between the start and end nodes, return an empty list. Use Breadth-First Search (BFS) to solve this problem. *Example:* ``` Input: graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: []}, start = 2, end = 1 Output: [2, 0, 1] ```","solution":"from collections import deque def shortest_path(graph, start, end): Finds the shortest path from start to end node in a directed graph represented as an adjacency list using BFS. Returns the path as a list of nodes. :param graph: Dict[int, List[int]] - the graph adjacency list :param start: int - the start node :param end: int - the end node :return: List[int] - the shortest path from start to end node, otherwise empty list. if start == end: return [start] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return path + [neighbor] else: queue.append((neighbor, path + [neighbor])) return []"},{"question":"You are given a binary matrix `grid` of size `m x n`, where `0` represents water and `1` represents land. An island is a maximal 4-directionally connected group of `1`s. The grid is said to be surrounded by water. Your task is to find the smallest island in the grid, and return the number of cells in this island. If there is no island, return `0`.","solution":"def num_cells_in_smallest_island(grid): def dfs(grid, x, y, visited): stack = [(x, y)] island_size = 0 while stack: i, j = stack.pop() if (i, j) not in visited: visited.add((i, j)) island_size += 1 for ni, nj in neighbors(i, j, len(grid), len(grid[0])): if grid[ni][nj] == 1 and (ni, nj) not in visited: stack.append((ni, nj)) return island_size def neighbors(i, j, m, n): for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0 <= ni < m and 0 <= nj < n: yield ni, nj if not grid: return 0 m, n = len(grid), len(grid[0]) visited = set() min_island_size = float(\'inf\') found_island = False for i in range(m): for j in range(n): if grid[i][j] == 1 and (i, j) not in visited: found_island = True size = dfs(grid, i, j, visited) if size < min_island_size: min_island_size = size return min_island_size if found_island else 0"},{"question":"Given a list of non-negative integers `arr` representing the height of each building in a row, find the two buildings that together with the line connecting them can trap the most water. The container cannot be slanted. _Return an integer representing the maximum amount of water that can be trapped._","solution":"def max_water_trapped(arr): Given a list of non-negative integers `arr` representing the height of each building in a row, find the two buildings that together with the line connecting them can trap the most water. Args: arr (list): List of non-negative integers representing building heights. Returns: int: Maximum water that can be trapped. max_water = 0 left, right = 0, len(arr) - 1 while left < right: # Calculate the amount of water that can be trapped height = min(arr[left], arr[right]) width = right - left current_water = height * width # Update maximum water max_water = max(max_water, current_water) # Move the pointer that points to the shorter building if arr[left] < arr[right]: left += 1 else: right -= 1 return max_water"},{"question":"Given a list of integers `nums` representing the rating of movies viewed by a user, return an integer representing the length of the longest increasing subsequence (LIS) in the list. An increasing subsequence is a subsequence where each subsequent number is greater than the previous one. You may assume that the list has a minimum length of 1.","solution":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence in the list nums. :param nums: List of integers :return: Length of the longest increasing subsequence if not nums: return 0 # dp array to store the LIS up to each index dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a list of `n` cities connected by `m` direct flights, where each flight is represented as a tuple `(u, v, w)` indicating a flight from city `u` to city `v` with a travel time `w`, write a function to determine the shortest possible travel time from a start city `s` to an end city `t`. If there is no possible route from `s` to `t`, return `-1`. The function should take in the list of flights, the number of cities `n`, the start city `s`, and the end city `t`, and return the minimum travel time. The cities are numbered from `0` to `n-1`.","solution":"import heapq def find_shortest_travel_time(n, flights, s, t): Determines the shortest travel time from start city `s` to end city `t`. Parameters: n (int): The number of cities. flights (list of tuples): List of flights represented as (u, v, w) where u is the start city, v is the end city, and w is the travel time. s (int): The start city. t (int): The end city. Returns: int: The shortest travel time from city `s` to city `t`; -1 if there is no possible route. # Build the graph using adjacency list representation graph = {i: [] for i in range(n)} for u, v, w in flights: graph[u].append((v, w)) # Dijkstra\'s algorithm to find the shortest path from \'s\' to \'t\' heap = [(0, s)] # (current travel time, current city) distances = {i: float(\'inf\') for i in range(n)} distances[s] = 0 while heap: curr_time, u = heapq.heappop(heap) if u == t: return curr_time for v, w in graph[u]: new_time = curr_time + w if new_time < distances[v]: distances[v] = new_time heapq.heappush(heap, (new_time, v)) return -1 # Example Usage n = 4 flights = [ (0, 1, 1), (0, 2, 4), (1, 2, 2), (1, 3, 6), (2, 3, 3) ] s = 0 t = 3 print(find_shortest_travel_time(n, flights, s, t)) # Output: 6"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to find the length of the longest subsequence of `s` such that the number of distinct characters in the subsequence is at most `k`. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return the length of the longest possible subsequence that meets the condition.","solution":"from collections import Counter def longest_subsequence_k_distinct(s, k): Returns the length of the longest subsequence of `s` such that the number of distinct characters in the subsequence is at most `k`. Parameters: s (str): A string consisting of lowercase English letters k (int): Maximum number of distinct characters in the subsequence Returns: int: The length of the longest possible subsequence with at most `k` distinct characters if k == 0: return 0 frequency = Counter(s) distinct_characters = len(frequency) if distinct_characters <= k: return len(s) freq_sorted = sorted(frequency.values(), reverse=True) return sum(freq_sorted[:k])"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` integers. You need to determine if it is possible to rearrange the elements of `nums` such that they any three consecutive elements form a strictly increasing sequence. If it is possible, return true; otherwise, return false. Note that the array can contain repeated elements.","solution":"def can_form_strictly_increasing_sequence(nums): Determines if it is possible to rearrange the elements of `nums` such that any three consecutive elements form a strictly increasing sequence. if len(nums) < 3: return True nums.sort() for i in range(len(nums) - 2): if nums[i + 1] <= nums[i] or nums[i + 2] <= nums[i + 1]: return False return True"},{"question":"Given an array of integers `nums`, you have to implement a data structure that allows storing and retrieving the frequency of elements. The data structure should support the following operations efficiently: - `FreqStack()` Initializes an empty frequency stack. - `void push(int x)` Adds an integer `x` onto the frequency stack. - `int pop()` Removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element which was pushed most recently should be returned. The frequency stack maintains the frequency of each element and uses this frequency to determine which element to pop. Implement the `FreqStack` class to achieve these functionalities.","solution":"import collections class FreqStack: def __init__(self): self.freq = collections.Counter() self.group = collections.defaultdict(list) self.maxfreq = 0 def push(self, x: int) -> None: freq = self.freq[x] + 1 self.freq[x] = freq if freq > self.maxfreq: self.maxfreq = freq self.group[freq].append(x) def pop(self) -> int: x = self.group[self.maxfreq].pop() self.freq[x] -= 1 if not self.group[self.maxfreq]: self.maxfreq -= 1 return x"},{"question":"Write a function that takes a string `pattern` and a string `str`, and returns `true` if `str` follows the same pattern. In other words, there\'s a one-to-one correspondence between each character in `pattern` and each word in `str`. # Example Given `pattern = \\"abba\\"` and `str = \\"dog cat cat dog\\"`, the function should return `true`, because each \'a\' in `pattern` corresponds to \\"dog\\", and each \'b\' corresponds to \\"cat\\". However, given `pattern = \\"abba\\"` and `str = \\"dog cat cat fish\\"`, the function should return `false` because there is no correspondence that matches \\"dog\\", \\"cat\\", and \\"fish\\" to the pattern \\"abba\\". **Note**: - Assume `len(pattern)` is always valid. - The words in `str` are separated by a single space. - The mapping is unique, meaning that two different characters in `pattern` cannot map to the same word in `str`.","solution":"def word_pattern(pattern, str): Returns True if str follows the same pattern as given in pattern. words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char not in char_to_word: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char elif char_to_word[char] != word: return False return True"},{"question":"Given an `m x n` 2D binary grid grid which represents a map of \'1\'s (land) and \'0\'s (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Implement the function `countIslands(grid: List[List[int]]) -> int` to count the number of islands. The function should traverse the grid and utilize a Depth-First Search (DFS) or Breadth-First Search (BFS) to explore each island, ensuring each cell is visited at most once.","solution":"from typing import List def countIslands(grid: List[List[int]]) -> int: if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): stack = [(r, c)] while stack: row, col = stack.pop() if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0 or visited[row][col]: continue visited[row][col] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: stack.append((row + dr, col + dc)) islands_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: dfs(r, c) islands_count += 1 return islands_count"},{"question":"You are given a list of unique integers `arr` that is sorted in ascending order, and you are provided with a separate target integer `x`. Your task is to determine if there exist exactly two distinct elements in `arr` that add up to `x`. Implement a function `find_sum_pair(arr, x)` that returns a pair of such elements if they exist, otherwise, return `None`. For example, for `arr = [1, 2, 4, 6, 10]` and `target = 8`, the function should return `(2, 6)` since 2 and 6 add up to 8. If no such pair exists, the function should return `None`. Given these requirements, write the `find_sum_pair` function to meet the specifications.","solution":"def find_sum_pair(arr, x): Returns a tuple of two distinct elements that add up to x if such a pair exists. Otherwise, returns None. left = 0 right = len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == x: return (arr[left], arr[right]) elif current_sum < x: left += 1 else: right -= 1 return None"},{"question":"You are given two strings `s` and `t` consisting of only lowercase English letters. You can choose to perform the following operation any number of times: insert a character at any position of `s`. Return _the minimum number of insertions needed to make_ `s` _an anagram of_ `t`. If it is impossible, return `-1`. Two strings are anagrams if they contain the same characters with the same frequencies.","solution":"from collections import Counter def min_insertions_to_anagram(s, t): Returns the minimum number of insertions needed to make s an anagram of t. If it is impossible, returns -1. if len(s) > len(t): return -1 # It is impossible if s is longer than t count_s = Counter(s) count_t = Counter(t) # If there\'s any character in s that is not in t, it is impossible to form an anagram for char in count_s: if char not in count_t: return -1 insertions_needed = 0 for char in count_t: if char in count_s: insertions_needed += max(0, count_t[char] - count_s[char]) else: insertions_needed += count_t[char] return insertions_needed"},{"question":"Given a list of `n` integers representing the heights of pillars arranged in a row, and an integer `k` defining the length of a ladder, you need to determine whether it is possible to reach the last pillar starting from the first one. You can either move to the next pillar or skip up to `k` pillars using the ladder. At each step, you can move to the next pillar if its height is less than or equal to the height of the current pillar plus the ladder length, or directly use the ladder to skip up to `k` pillars. Return _a boolean value that indicates whether you can reach the last pillar or not_.","solution":"def can_reach_last_pillar(heights, k): Determines if it\'s possible to reach the last pillar starting from the first. :param heights: List of integers representing the heights of the pillars. :param k: Integer representing the length of the ladder. :return: Boolean value indicating whether it\'s possible to reach the last pillar or not. n = len(heights) if n == 0: return False reachable = [False] * n reachable[0] = True for i in range(n): if reachable[i]: for j in range(1, k+1): if i + j < n and heights[i + j] <= heights[i] + k: reachable[i + j] = True return reachable[-1]"},{"question":"You are given a binary search tree (BST) with `n` nodes. Write a function that returns the `k`-th smallest element in this tree. The tree structure is represented with nodes where each node contains a `val` (integer value) and pointers to its `left` and `right` child nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the k-th smallest element in a binary search tree (BST). def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Perform inorder traversal to get elements in sorted order sorted_elements = inorder_traversal(root) # Return the k-th smallest element (1-indexed) return sorted_elements[k - 1]"},{"question":"You are given a list of meeting time intervals `intervals` where `intervals[i] = [starti, endi]` represents the starting and ending time of the `ith` meeting. Return _the minimum number of conference rooms required_ to accommodate all the meetings. Each interval `[starti, endi]` is closed, meaning that a meeting starting at `starti` and ending at `endi` includes both `starti` and `endi`.","solution":"def minMeetingRooms(intervals): Return the minimum number of conference rooms required. if not intervals: return 0 # Separate out start and end times. start_times = sorted([i[0] for i in intervals]) end_times = sorted([i[1] for i in intervals]) start_pointer = 0 end_pointer = 0 rooms_needed = 0 max_rooms = 0 while start_pointer < len(intervals): if start_times[start_pointer] <= end_times[end_pointer]: rooms_needed += 1 start_pointer += 1 max_rooms = max(max_rooms, rooms_needed) else: rooms_needed -= 1 end_pointer += 1 return max_rooms"},{"question":"You are given an array of integers `arr` where each element appears exactly three times, except for one element which appears exactly once. Your task is to find and return this unique element. You must implement an algorithm that runs in O(n) time complexity and uses constant extra space.","solution":"def single_number(arr): Finds the element that appears exactly once in an array where all other elements appear exactly three times. Args: arr (list of int): The input array. Returns: int: The unique element that appears exactly once. seen_once = seen_twice = 0 for num in arr: # First appearance: # Add num to seen_once if it\'s not in seen_twice seen_once = ~seen_twice & (seen_once ^ num) # Second appearance: # Add num to seen_twice if it\'s not in seen_once seen_twice = ~seen_once & (seen_twice ^ num) return seen_once"},{"question":"Given an integer array `arr` of size `n` and an integer `k`, find the `k` closest integers to a given value `x` in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are preferred. Return the resulting array.","solution":"def find_k_closest_elements(arr, k, x): Returns k closest integers to x in the array arr sorted in ascending order. Parameters: arr (List[int]): List of integers. k (int): The number of closest integers to find. x (int): The target integer. Returns: List[int]: The list of k closest integers to x sorted in ascending order. # Sort the array based on two keys: # 1. The absolute difference between the elements and x. # 2. The values themselves to break ties. sorted_arr = sorted(arr, key=lambda num: (abs(num - x), num)) # Take the first k elements from the sorted array result = sorted(sorted_arr[:k]) return result"},{"question":"You are given an integer array `heights` representing the height of buildings along a street. Each building\'s height can be increased by any non-negative integer amount, but cannot be decreased. You want to ensure that the skyline formed by these buildings, when viewed from the left, is as smooth as possible. The \\"smoothness\\" of the skyline is defined as the maximum difference in height between any two consecutive buildings. Return _the minimum possible \\"smoothness\\"_ that can be achieved by only increasing the buildings\' heights.","solution":"def min_smoothness(heights): Returns the minimum possible \\"smoothness\\" that can be achieved by only increasing the buildings\' heights. n = len(heights) smoothness = 0 for i in range(1, n): if heights[i] < heights[i - 1]: smoothness = max(smoothness, heights[i - 1] - heights[i]) return smoothness"},{"question":"You are given an array of integers `arr`, and an integer `difference`. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Find the length of the longest subsequence where the difference between consecutive elements is exactly equal to `difference`. Implement the function `int longestSubsequence(int[] arr, int difference)` which takes the array of integers `arr` and the integer value `difference` as inputs, and returns the length of the longest such subsequence.","solution":"def longestSubsequence(arr, difference): Find the length of the longest subsequence where the difference between consecutive elements is exactly equal to `difference`. if not arr: return 0 dp = {} max_len = 1 for num in arr: if num - difference in dp: dp[num] = dp[num - difference] + 1 else: dp[num] = 1 max_len = max(max_len, dp[num]) return max_len"},{"question":"You are given an array of strings `words` and another string `target`. Each string in `words` contains only lowercase alphabets. You need to determine if `target` can be formed using the characters from the strings in `words`. Each character in `words` can only be used once. Return `true` if `target` can be formed, otherwise return `false`.","solution":"def can_form_target(words, target): Determines if the `target` string can be formed using characters from `words`. Args: words (list of str): List of strings containing lowercase alphabets. target (str): The target string to be formed. Returns: bool: True if target can be formed, False otherwise. from collections import Counter words_counter = Counter(\'\'.join(words)) target_counter = Counter(target) for char, count in target_counter.items(): if words_counter[char] < count: return False return True"},{"question":"You are given an unsorted integer array `arr` and an integer `k`. Your task is to find the `kth` smallest element in the array. If `k` is greater than the number of elements in the array, return `-1`. * For example, given the array `[7, 10, 4, 3, 20, 15]` and `k = 3`, the `3rd` smallest element is `7`. * If the array is `[7, 10, 4, 3, 20, 15]` and `k = 10`, the result should be `-1` because there are fewer than 10 elements in the array. Return an integer denoting the `kth` smallest element in `arr`, or `-1` if `k` is out of bounds.","solution":"def kth_smallest_element(arr, k): Returns the kth smallest element in the array. If k is greater than the number of elements in the array, returns -1. if k > len(arr) or k <= 0: return -1 arr_sorted = sorted(arr) return arr_sorted[k - 1]"},{"question":"Given a sorted array `arr` of distinct integers, write a function that finds the smallest positive integer missing from the array. The function should return this smallest positive integer. For example, if the input array is `arr = [1, 2, 3, 5]`, the function should return `4` since `4` is the smallest positive integer missing from the array `arr`. If the input array is `arr = [-2, -1, 0, 1, 2, 4]`, the function should return `3`.","solution":"def find_smallest_missing_positive(arr): Finds the smallest positive integer missing from the sorted array of distinct integers. Parameters: arr (list): A sorted list of distinct integers Returns: int: The smallest missing positive integer smallest_missing = 1 for num in arr: if num == smallest_missing: smallest_missing += 1 elif num > smallest_missing: break return smallest_missing"},{"question":"You are given a string `s` consisting of lowercase and uppercase English letters. You need to determine if it is possible to delete some characters (possibly none) from `s` such that the resulting string is a palindrome while maintaining the relative order of the remaining characters. Return `true` if it is possible, otherwise return `false`. A string is a palindrome if it reads the same forward and backward. [Example Input]: \\"aAbBc\\" [Example Output]: true (Explanation: By deleting \'c\' and \'B\', the resulting string \\"aAbA\\" is a palindrome)","solution":"def can_form_palindrome(s): from collections import Counter # Count the frequency of each character in the string freq = Counter(s.lower()) # At most one character can have an odd count in a palindromic string odd_count = sum(1 for count in freq.values() if count % 2 == 1) return odd_count <= 1"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house along a street, and a non-negative integer `k` representing the maximum number of houses you can rob. However, you cannot rob two adjacent houses. Implement a function that returns the maximum amount of money you can rob given these constraints. The implementation should provide a solution by considering the following aspects: * Define a function `maxRob(nums, k)` which takes in the list `nums` and the integer `k`. * The function should return the maximum amount of money you can rob without alerting the police by robbing two adjacent houses, and without exceeding the limit of `k` houses.","solution":"def maxRob(nums, k): Returns the maximum amount of money you can rob given the constraints: - You cannot rob two adjacent houses. - You cannot rob more than k houses. :param nums: List of non-negative integers representing the amount of money in each house. :param k: Max number of houses that can be robbed. :return: Maximum amount of money that can be robbed. n = len(nums) if k == 0 or n == 0: return 0 # Initialize dp array with two rows dp = [[0] * (k + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, k + 1): # If we rob the current house, we add its value to the best solution for the previous houses excluding the adjacent one dp[i][j] = max(dp[i - 1][j], dp[i - 2][j - 1] + nums[i - 1]) return dp[n][k]"},{"question":"You are given an integer array `arr` and an integer `target`. Each element in `arr` represents the cost of an item. You want to purchase exactly three items whose total cost is as close as possible to the `target`. Return _the sum of the costs of the three items_. If there are multiple answers, return any of them.","solution":"def three_sum_closest(arr, target): Find three items in `arr` whose sum is closest to the `target`. Args: arr (list of int): List of item costs. target (int): The target sum to achieve. Returns: int: The sum of the three item costs closest to the target. arr.sort() closest_sum = float(\'inf\') for i in range(len(arr) - 2): left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"You are given a string `s` consisting of lowercase letters. You need to find and return the first non-repeating character in it. If there is no such character, return an underscore (`\'_\'`). Your solution should have linear time complexity and use a constant amount of extra space.","solution":"def first_non_repeating_character(s): Find and return the first non-repeating character in the string s. If there is no such character, return an underscore (\'_\'). Parameters: s (str): The input string consisting of lowercase letters. Returns: str: The first non-repeating character or \'_\' if none exists. char_count = {} # Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char return \'_\'"},{"question":"You are given a string `s` and a list of words `dict`. Each word in the dictionary is a string that is of the same length. You need to find out the minimum number of characters that need to be replaced in the string `s` in order to transform it into any of the words in the list `dict`. If it\'s not possible to transform `s` into any word in `dict`, return `-1`. **Notes:** * The string `s` and all words in `dict` consist of lowercase English letters only. * All words in `dict` are of the same length as `s`.","solution":"def min_replacements_to_transform(s, dict): Returns the minimum number of characters that need to be replaced in the string `s` in order to transform it into any of the words in the list `dict`. If it\'s not possible to transform `s` into any word in `dict`, return -1. if not dict: return -1 min_replacements = float(\'inf\') for word in dict: if len(word) != len(s): return -1 differences = sum(1 for i in range(len(s)) if s[i] != word[i]) min_replacements = min(min_replacements, differences) return min_replacements if min_replacements != float(\'inf\') else -1"},{"question":"You are given an integer array `heights` representing the heights of skyscrapers in a city skyline from left to right. Write a function that returns the **total** sum of the **areas** of all the rectangular buildings that a horizontal laser beam would intersect if shot straight across from left to right at the maximum height among the buildings. For simplicity, assume that all buildings start at the same horizontal level (the ground) and extend purely vertically based on their respective heights. The width of each building is `1`. The height of each building is given by the corresponding element in the array `heights`. Return the total sum of the areas of the intersection of the laser beam at the highest building height.","solution":"def laser_beam_area(heights): Returns the total sum of the areas of all rectangular buildings intersected by a horizontal laser beam shot at the height of the maximum building height. if not heights: return 0 max_height = max(heights) total_area = 0 for height in heights: if height == max_height: total_area += max_height return total_area"},{"question":"Given a list of integers `numbers`, return the length of the longest subsequence where each number is divisible by the previous one. The sequence must be strictly increasing in terms of values, not indices. For example, given the list `[1, 2, 4, 8, 3]`, one possible longest subsequence would be `[1, 2, 4, 8]`, and its length would be 4.","solution":"def longest_divisible_subsequence(numbers): Returns the length of the longest subsequence where each number is divisible by the previous one. if not numbers: return 0 n = len(numbers) dp = [1] * n numbers.sort() for i in range(n): for j in range(i): if numbers[i] % numbers[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage: # numbers = [1, 2, 4, 8, 3] # print(longest_divisible_subsequence(numbers)) # Output: 4"},{"question":"You are provided with a list of strings `words` where each word can appear multiple times. Implement a data structure that allows you to efficiently find whether a specific word exists in the list and how many times it occurs. Implement the `WordFrequency` class: - `WordFrequency(List<String> words)`: Initializes the data structure with the given list of words. - `bool exists(String word)`: Returns `true` if the word exists in the list, otherwise `false`. - `int count(String word)`: Returns the number of times the word occurs in the list, or `0` if the word does not exist.","solution":"class WordFrequency: def __init__(self, words): Initializes the data structure with the given list of words. self.word_count = {} for word in words: if word in self.word_count: self.word_count[word] += 1 else: self.word_count[word] = 1 def exists(self, word): Returns true if the word exists in the list, otherwise false. return word in self.word_count def count(self, word): Returns the number of times the word occurs in the list, or 0 if the word does not exist. return self.word_count.get(word, 0)"},{"question":"Given a string `s`, a character `repeatChar`, and an integer `k`, return the length of the longest substring containing the same character that can be obtained by repeating `repeatChar` at most `k` times in `s`.","solution":"def longest_substring_with_repeats(s, repeatChar, k): Returns the length of the longest substring containing the same character that can be obtained by repeating `repeatChar` at most `k` times in `s`. Parameters: s (str): The original string. repeatChar (str): The character that can be repeated. k (int): The maximum number of times `repeatChar` can be repeated. Returns: int: The length of the longest substring. if not s: return 0 max_len = start = count = 0 counts = {c: 0 for c in set(s)} for end, char in enumerate(s): counts[char] += 1 # Count occurrences of repeatChar in current window if char == repeatChar: count += 1 # Maintain a valid window while (end - start + 1) - max(counts.values()) > k: if s[start] == repeatChar: count -= 1 counts[s[start]] -= 1 start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an integer array `nums` representing the number of balls in each box. You have another array `costs` where `costs[i]` is the cost to move one ball from the `ith` box to another box. You need to move all balls from each box to the `0-th` index box. Return the minimum cost to collect all balls in the `0-th` index box. For example, if you have `nums = [3, 2, 1]` and `costs = [0, 1, 2]`, you would move 2 balls from index 1 to index 0, costing `2 * 1 = 2`, and 1 ball from index 2 to index 0, costing `1 * 2 = 2`. Thus, the total minimum cost is `2 + 2 = 4`.","solution":"def min_cost_to_collect_balls(nums, costs): Returns the minimum cost to collect all balls from each box to the 0-th index box. Args: nums: List[int] - number of balls in each box. costs: List[int] - cost to move one ball from the ith box to another box. Returns: int - minimum cost to collect all balls in the 0-th index box. total_cost = 0 for i in range(1, len(nums)): total_cost += nums[i] * costs[i] return total_cost"},{"question":"Given an array of integers `arr` and an integer `k`, determine whether it is possible to partition the array into `k` non-empty subsets with equal sum. Return `true` if it is possible, otherwise, return `false`. The task requires using logical thinking to check all potential partitions and ensure that each subset\'s sum equals the designated value. Keep in mind that the solution must consider all elements of the array and efficiently handle potential partitioning scenarios within feasible time constraints.","solution":"def can_partition_into_k_subsets(arr, k): Determine whether it is possible to partition the array into k non-empty subsets with equal sum. :param arr: List[int] - An array of integers :param k: int - The number of subsets :return: bool - True if it is possible to partition, otherwise False total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k arr.sort(reverse=True) used = [False] * len(arr) def can_partition(start_index, k, current_sum, target_sum): if k == 0: return True if current_sum == target_sum: return can_partition(0, k - 1, 0, target_sum) for i in range(start_index, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if can_partition(i + 1, k, current_sum + arr[i], target_sum): return True used[i] = False return False return can_partition(0, k, 0, target_sum)"},{"question":"Given a list of `points` represented as pairs of coordinates `points[i] = (xi, yi)`, return the total number of rectangles that can be formed using pairs of these points. A rectangle is formed when four points `(x1, y1)`, `(x1, y2)`, `(x2, y1)`, and `(x2, y2)` coexist in the list of points, where `x1 != x2` and `y1 != y2`. All coordinates are assumed to be distinct integers. The points are given in no particular order. **For example:** - Input: `points = [(1, 2), (2, 1), (1, 1), (2, 2)]` - Output: `1` (The points form exactly one rectangle) - Input: `points = [(0, 0), (0, 1), (1, 0), (1, 1), (2, 2)]` - Output: `1` (The points form exactly one rectangle despite the extra point (2, 2) not contributing to any rectangle)","solution":"def count_rectangles(points): Returns the total number of rectangles that can be formed using pairs of points. point_set = set(points) rectangle_count = 0 # Iterate over pairs of points for i in range(len(points)): for j in range(i + 1, len(points)): (x1, y1), (x2, y2) = points[i], points[j] # Check for diagonally opposite corners of a rectangle if x1 != x2 and y1 != y2: if (x1, y2) in point_set and (x2, y1) in point_set: rectangle_count += 1 # Each rectangle is counted twice, so divide the result by 2 return rectangle_count // 2"},{"question":"You are given a **non-empty** string `arrangement` representing a list of items arranged in a linear sequence. Each item is represented by a **lowercase** English letter. Your task is to reorganize the string such that no two adjacent items are the same. If it is not possible to rearrange the items to meet this condition, return the empty string `\\"\\"`. If there are multiple valid arrangements, return any of them. Return _the rearranged string or an indication of impossibility_.","solution":"from collections import Counter import heapq def reorganize_string(arrangement): # Count frequency of each character char_count = Counter(arrangement) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) result.append(char) prev_char = char prev_count = count + 1 if len(result) != len(arrangement): return \\"\\" return \\"\\".join(result)"},{"question":"You are given a string `s` consisting of lowercase Latin letters. You want to remove the minimum number of characters from the string such that the remaining string does not contain any two consecutive identical characters. Return _the minimum number of characters you need to remove_.","solution":"def min_removals_to_avoid_consecutive_duplicates(s): Returns the minimum number of characters that need to be removed from the string s so that no two consecutive characters are identical. Args: s (str): Input string consisting of lowercase Latin letters. Returns: int: Minimum number of characters to remove. if not s: return 0 removals = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: removals += 1 return removals"},{"question":"Given a list of integers `weights` representing the weights of different packages, and an integer `days` representing the number of days required to ship all packages, return the minimum capacity of a shipping container that will allow all packages to be shipped within the given days. Each day, you can load packages onto the container, but you can\'t exceed the container\'s capacity. Once a package is placed on the container, it must be shipped on that day. You cannot split a package into smaller parts; each package must be shipped whole.","solution":"def ship_within_days(weights, days): def can_ship(capacity): total = 0 day_count = 1 for weight in weights: total += weight if total > capacity: day_count += 1 total = weight if day_count > days: return False return True left, right = max(weights), sum(weights) while left < right: mid = (left + right) // 2 if can_ship(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` and an array `queries` where each query is a two-element list containing two integers, `start` and `end`. For each query, you need to determine whether the substring from index `start` to index `end` (inclusive) is a palindrome. A string is a palindrome if it reads the same forward and backward. Return an array of boolean values where each element corresponds to the result of a query, `true` for palindrome and `false` otherwise. You must write an algorithm that provides fast querying after an initial preprocessing step.","solution":"def preprocess_palindrome(s): n = len(s) dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j] and dp[i+1][j-1]) return dp def is_palindrome(s, queries): palindrome_dp = preprocess_palindrome(s) results = [] for start, end in queries: results.append(palindrome_dp[start][end]) return results"},{"question":"You are given a 2D binary matrix filled with 0\'s and 1\'s. Each 1 represents land, and each 0 represents water. The connected land cells form an island. Formally, an island is a group of 1\'s connected vertically or horizontally, with no water (0\'s) separating them. You need to write a function to find the maximum area of an island in the given binary matrix. Return the size of the largest island. If there are no islands, return 0. Use depth-first search (DFS) to solve this problem. *Implement the function `int maxAreaOfIsland(vector<vector<int>>& grid)`*.","solution":"def maxAreaOfIsland(grid): Finds the maximum area of an island in the given binary grid. Args: grid (List[List[int]]): A 2D list where each cell is either 0 or 1. Returns: int: The size of the largest island. If there are no islands, return 0. def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark the land as visited area = 1 area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given two **0-indexed** integer arrays `nums1` and `nums2` of the same length `n`. Your task is to create a new array `result` of length `n`, where each element at index `i` of `result` is defined as follows: * If `nums1[i]` is even, set `result[i]` to the sum of `nums1[i]` and `nums2[i]`. * If `nums1[i]` is odd, set `result[i]` to the absolute difference between `nums2[i]` and `nums1[i]`. Return the resulting array `result`. **Note:** You must maintain the order of elements in the new array as per the given conditions.","solution":"def generate_result_array(nums1, nums2): Generate a result array based on the given conditions: - If nums1[i] is even, result[i] = nums1[i] + nums2[i] - If nums1[i] is odd, result[i] = abs(nums2[i] - nums1[i]) Args: nums1 (list of int): The first input list of integers. nums2 (list of int): The second input list of integers. Returns: list of int: The resulting list of integers as per the conditions. result = [] for i in range(len(nums1)): if nums1[i] % 2 == 0: result.append(nums1[i] + nums2[i]) else: result.append(abs(nums2[i] - nums1[i])) return result"},{"question":"Given a binary tree, imagine that each node has an additional pointer called `next` which is initially set to `null`. Populate each `next` pointer to point to its next right node. If there is no next right node, the `next` pointer should be set to `null`. Initially, the binary tree is given as a `Node` class which has the following definition: ``` class Node { int val; Node left; Node right; Node next; Node(int x) { val = x; } } ``` Your task is to implement a function that takes the root of the binary tree and populates the `next` pointer of each node as described.","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Populates each \'next\' pointer to point to its next right node. If there is no next right node, the \'next\' pointer should be set to None. This function connects nodes at the same level. if not root: return None leftmost = root while leftmost: head = leftmost leftmost = None prev = None while head: def process_child(child): nonlocal leftmost, prev if child: if not leftmost: leftmost = child if prev: prev.next = child prev = child process_child(head.left) process_child(head.right) head = head.next return root"},{"question":"In a tree structure, each node has a set of children nodes. We define the \\"even depth nodes\\" of the tree as nodes that are at an even distance from the root (root being at depth 0). Given the tree in a specific format, where the root node and its children are represented as a nested dictionary, return a list of values of all \\"even depth nodes\\" in the order they appear in the tree traversal. For example, given a tree structured as `{\\"val\\": 1, \\"children\\": [{\\"val\\": 2, \\"children\\": [{\\"val\\": 4, \\"children\\": []}, {\\"val\\": 5, \\"children\\": []}]}, {\\"val\\": 3, \\"children\\": [{\\"val\\": 6, \\"children\\": []}, {\\"val\\": 7, \\"children\\": []}]}]}`, the output would be `[1, 4, 5, 6, 7]`.","solution":"def even_depth_nodes(tree): Returns a list of values of all nodes that are at an even distance from the root. Parameters: tree (dict): A dictionary representing the tree, with \\"val\\" representing the value of a node and \\"children\\" representing a list of its child nodes. Returns: List: A list of values of nodes at an even distance from the root. result = [] def traverse(node, depth): if node is None: return if depth % 2 == 0: result.append(node[\\"val\\"]) for child in node[\\"children\\"]: traverse(child, depth + 1) traverse(tree, 0) return result"},{"question":"Implement a function that finds the **next greater element** for each element in a given array `nums` of integers. The **next greater element** for an element `x` is the first greater element on its right side in `nums`. If no such element exists, output `-1` for that position. The function should return an array containing the next greater elements for each corresponding element in the input array. * For example, let `nums = [4, 5, 2, 25]`. The next greater elements are `[5, 25, 25, -1]` because: - For `4`, the next greater element is `5`. - For `5`, the next greater element is `25`. - For `2`, the next greater element is `25`. - For `25`, there is no greater element, so the output is `-1`.","solution":"def next_greater_elements(nums): Finds the next greater element for each position in the list nums. Args: nums (list): A list of integers. Returns: list: A list containing the next greater elements for each corresponding element in nums. n = len(nums) result = [-1] * n stack = [] for i in range(n): while stack and nums[i] > nums[stack[-1]]: index = stack.pop() result[index] = nums[i] stack.append(i) return result"},{"question":"You are given an **m x n** 2D matrix `mat`, where each row is sorted in non-decreasing order and each column is sorted in non-decreasing order. Write a function to determine if a given target number exists in the matrix. Return `true` if the target is found, otherwise return `false`. Try to achieve an algorithm with a time complexity better than O(m * n).","solution":"def search_matrix(mat, target): Determines if the target number exists in the matrix. :param mat: List of List of integers representing the matrix :param target: Integer, the number to search for :return: Boolean, True if target is found, otherwise False if not mat or not mat[0]: return False m, n = len(mat), len(mat[0]) # Start from the top-right corner of the matrix row, col = 0, n - 1 while row < m and col >= 0: if mat[row][col] == target: return True elif mat[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given a string `s` containing only the characters `\'a\'`, `\'b\'`, and `\'c\'`. You need to partition the string into as few substrings as possible so that each substring contains exactly one unique character. Return _the minimum number of partitions required_. For example, given `s = \\"aaabbbccc\\"`, the output should be `3` since `\\"aaa\\"`, `\\"bbb\\"`, and `\\"ccc\\"` are the three required partitions.","solution":"def min_partitions(s): Returns the minimum number of partitions required for the string such that each substring contains exactly one unique character. :param s: String containing only characters \'a\', \'b\', and \'c\' :type s: str :return: Minimum number of partitions required :rtype: int if not s: return 0 partitions = 1 for i in range(1, len(s)): if s[i] != s[i - 1]: partitions += 1 return partitions"},{"question":"You are given a binary tree with `n` nodes where each node has either a value of 0 or 1. You need to perform an operation called \\"prune\\" on the tree. To prune the tree, you remove all subtrees that do not contain any nodes with the value 1. After pruning, a subtree rooted at node `N` should remain in the tree if and only if at least one node in the subtree has value 1. Write a function that performs this pruning operation on the binary tree and returns the pruned tree. The tree is represented using the `TreeNode` class where each `TreeNode` has properties `val`, `left`, and `right`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root): Removes all subtrees that do not contain any nodes with the value 1. Args: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the pruned binary tree. if not root: return None root.left = pruneTree(root.left) root.right = pruneTree(root.right) if root.val == 0 and not root.left and not root.right: return None return root"},{"question":"You are given a string `s` representing a sequence of operations, where each operation is one of the following: P (push an element to the stack with its value equal to the current size of the stack), or O (pop an element from the stack). There is a constraint that the stack cannot pop an element if it is empty. Return _the length of the longest consecutive sequence of operations that can be performed without violating the stack constraints_.","solution":"def longest_valid_sequence(s): Returns the length of the longest valid sequence of operations without violating stack constraints. Parameters: s (str): A string of operations (\'P\' for push, \'O\' for pop). Returns: int: Length of the longest valid sequence of operations. max_length = 0 current_length = 0 stack_size = 0 for operation in s: if operation == \'P\': stack_size += 1 current_length += 1 elif operation == \'O\': if stack_size > 0: stack_size -= 1 current_length += 1 else: break max_length = max(max_length, current_length) return max_length"},{"question":"You are given an array of integers `nums` and a target integer `k`. Your task is to determine if there exists a continuous subarray whose sum is exactly `k`. The subarray must contain at least one number. If such a subarray exists, return `true`; otherwise, return `false`. For example, given `nums = [1, 2, 3, 4, 5]` and `k = 9`, the subarray `[2, 3, 4]` sums up to `9`, so the function should return `true`. If no such subarray exists, return `false`.","solution":"def check_subarray_sum(nums, k): Determines if there exists a continuous subarray whose sum is exactly k. Parameters: - nums: List[int], array of integers - k: int, target sum Returns: - bool: True if such a subarray exists, otherwise False cumulative_sum = 0 sum_dict = {0: -1} # To handle the case when subarray starts from index 0 for i, num in enumerate(nums): cumulative_sum += num if cumulative_sum - k in sum_dict: return True sum_dict[cumulative_sum] = i return False"},{"question":"Write a program that takes an integer `n` and returns a list of all prime numbers less than `n`. A prime number is a number that is greater than `1` and has no positive divisors other than `1` and itself. For example, given `n = 10`, the output should be `[2, 3, 5, 7]`.","solution":"def primes_less_than(n): Returns a list of all prime numbers less than n. if n <= 2: return [] primes = [] for num in range(2, n): is_prime = True for i in range(2, int(num ** 0.5) + 1): if num % i == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"Given an array of integers `arr` and an integer `k`, rotate the array to the right by `k` steps, where `k` is non-negative. Implement the function `rotateRight(arr, k)` that modifies the array in-place and returns nothing. Note that rotating the array by `k` steps means that every element shifts `k` positions to the right, and the elements that \\"fall off\\" the end reappear at the start of the array.","solution":"def rotateRight(arr, k): Rotates the array arr to the right by k steps in-place. Parameters: arr (list of int): The array to be rotated. k (int): The number of steps to rotate the array to the right. if not arr or k <= 0: return n = len(arr) k = k % n # In case k is greater than array length # Rotate the array using slicing arr[:] = arr[-k:] + arr[:-k]"},{"question":"You are given a string `s` consisting of lowercase English letters. Find and return the length of the longest substring without repeating characters. The substring must be contiguous. Analyze the time complexity of your solution.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. start = 0 max_length = 0 used_char = {} for index, char in enumerate(s): if char in used_char and start <= used_char[char]: start = used_char[char] + 1 else: max_length = max(max_length, index - start + 1) used_char[char] = index return max_length"},{"question":"Given a list of non-negative integers `nums` representing the maximum you can advance in the array at each position, determine if you can reach the last index starting from the first index. Each element in the list represents the maximum jump length at that position. _Return `true` if you can reach the last index, otherwise return `false`._ For example, given `nums = [2, 3, 1, 1, 4]`, the output should be `true` because you can jump from index 0 to 1 (since 2 steps allow reaching index 1), then from index 1 to 4. However, given `nums = [3, 2, 1, 0, 4]`, the output should be `false` because you will be unable to reach the last index.","solution":"def can_jump(nums): Determine if you can reach the last index starting from the first index. Args: nums (list of int): List of non-negative integers representing the maximum jump length at each position. Returns: bool: True if you can reach the last index, False otherwise. max_reach = 0 for i, num in enumerate(nums): if i > max_reach: return False max_reach = max(max_reach, i + num) return max_reach >= len(nums) - 1"},{"question":"You are given a list of `n` tasks that need to be executed. Each task has a start and end time represented by a pair of integers, where `tasks[i] = [starti, endi]`. Write a function to determine the minimum number of time units needed to execute all tasks without any overlaps. Return _the minimum number of units required_.","solution":"def min_time_units(tasks): Given a list of tasks with their start and end times, returns the minimum number of time units needed to execute all tasks without any overlaps. Args: tasks (list of list of int): List of tasks where each task is represented by [start, end]. Returns: int: Minimum number of time units required to execute all tasks without overlaps. if not tasks: return 0 # Sort tasks based on end time tasks.sort(key=lambda x: x[1]) # Initialize variables end_time = tasks[0][1] time_units = end_time - tasks[0][0] for task in tasks[1:]: # If task starts after or when the previous task ended, add its duration to time_units if task[0] >= end_time: end_time = task[1] time_units += task[1] - task[0] return time_units"},{"question":"Given a `matrix` of integers where each element represents the cost to step on that cell, write a function to find the minimum cost to travel from the top-left corner to the bottom-right corner of the matrix. You are only allowed to move either down or right at any point in time. Return the minimum cost of the path.","solution":"def min_cost_path(matrix): Finds the minimum cost to travel from top-left corner to bottom-right corner of the matrix moving only down or right. :param matrix: List[List[int]] :return: int if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"Given an integer array `nums` of unique elements, construct a binary search tree (BST) from `nums` where elements are inserted into the BST in the order they appear in `nums`. Return the height of the BST. The height of a BST is the number of edges in the longest path from the root to a leaf node.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 # If the tree is empty, its height is -1 else: left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1 def bst_height(nums): bst = BST() for num in nums: bst.insert(num) return bst.height()"},{"question":"Given an integer array `nums`, write a function to move all the negative numbers to the beginning of the array, followed by all the positive numbers. The relative order of the positive numbers should be preserved. Do this in-place without using any extra space for another array.","solution":"def move_negatives(nums): Moves all negative numbers to the beginning of the array followed by all positive numbers. The relative order of the positive numbers is preserved. # Maintain a pointer for the position to place the next negative number pos = 0 for i in range(len(nums)): if nums[i] < 0: # Move the negative number to the current \'pos\' index nums.insert(pos, nums.pop(i)) pos += 1 return nums"},{"question":"You are given a string `s` consisting of parentheses (`\'(\'` and `\')\'`) and asterisks (`\'*\'`). Asterisks can be treated as either an open parenthesis, a close parenthesis, or an empty string. Your task is to determine if it is possible to make the string `s` valid. That is, if by replacing or deleting the asterisks, the string can become a valid parentheses sequence. Return _true if the string can be valid and _false otherwise_. A valid parentheses sequence is one where each same type of parentheses make a valid pair and the pairs are properly nested.","solution":"def checkValidString(s): Returns True if the string s can be made valid by replacing or deleting the asterisks, and False otherwise. left_balance = 0 right_balance = 0 n = len(s) for i in range(n): if s[i] in \\"(*\\": left_balance += 1 else: left_balance -= 1 if s[n-1-i] in \\"*)\\": right_balance += 1 else: right_balance -= 1 if left_balance < 0 or right_balance < 0: return False return True"},{"question":"You are given an `n x n` matrix `grid` containing integers. A square is considered **special** if all the integers in the row and column of that square are distinct. Find the number of **special** squares in the matrix. Implement the function `int numSpecialSquares(int[][] grid)`, which returns the count of special squares in the given matrix.","solution":"def numSpecialSquares(grid): def is_distinct(arr): return len(arr) == len(set(arr)) n = len(grid) count = 0 for i in range(n): for j in range(n): row_elements = grid[i][:] col_elements = [grid[x][j] for x in range(n)] if is_distinct(row_elements) and is_distinct(col_elements): count += 1 return count"},{"question":"Given a singly linked list of integers, return the list after reversing only the nodes that are between position `m` and `n`. The positions are **1-indexed** inclusive, where `1 <= m <= n <= length of the list`. For example, if the list is `1 -> 2 -> 3 -> 4 -> 5` and `m = 2`, `n = 4`, the list should become `1 -> 4 -> 3 -> 2 -> 5`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head, m, n): Reverses the nodes of a singly linked list between positions m and n. Parameters: head (ListNode): The head of the singly linked list. m (int): The starting position (1-indexed) of the reversal. n (int): The ending position (1-indexed) of the reversal. Returns: ListNode: The head of the modified linked list. if not head or m == n: return head dummy = ListNode(0) dummy.next = head prev = dummy # Move `prev` to the node before position `m` for _ in range(m - 1): prev = prev.next current = prev.next next_node = current.next # Reverse the nodes between m and n for _ in range(n - m): current.next = next_node.next next_node.next = prev.next prev.next = next_node next_node = current.next return dummy.next"},{"question":"You are given an unsorted array of integers `arr` and an integer `k`. The task is to find the `k`-th smallest element in the array. You must solve this using an optimal algorithm that has an average time complexity better than `O(n log n)`. Return the `k`-th smallest element in the given array `arr`.","solution":"import random def kth_smallest(arr, k): Find the k-th smallest element in an unsorted array using the Quickselect algorithm. :param arr: List[int] - List of unsorted integers. :param k: int - The order of the smallest element to find (1 based index). :return: int - The k-th smallest element. if arr is None or len(arr) < k: raise ValueError(\\"Array must have at least k elements\\") return quickselect(arr, 0, len(arr) - 1, k - 1) def quickselect(arr, low, high, k): Helper function to perform the quickselect algorithm. if low == high: return arr[low] pivot_index = random.randint(low, high) pivot_index = partition(arr, low, high, pivot_index) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) def partition(arr, low, high, pivot_index): Partition the array around the pivot. pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index"},{"question":"Given an array of integers `arr`, find the number of **reverse pairs** in the array. A **reverse pair** is a pair `(i, j)` where `0 <= i < j < arr.length` and `arr[i] > 2 * arr[j]`. For example, given the array `[1, 3, 2, 3, 1]`, there are `2` reverse pairs: `(3, 1)` and `(3, 0)`. Return the number of reverse pairs in the array.","solution":"def reverse_pairs(arr): Returns the number of reverse pairs in the array. A reverse pair is defined as (i, j) where 0 <= i < j < len(arr) and arr[i] > 2 * arr[j]. if not arr: return 0 def merge_sort(start, end): if start >= end: return 0 mid = (start + end) // 2 count = merge_sort(start, mid) + merge_sort(mid + 1, end) j = mid + 1 for i in range(start, mid + 1): while j <= end and arr[i] > 2 * arr[j]: j += 1 count += j - (mid + 1) arr[start:end + 1] = sorted(arr[start:end + 1]) return count return merge_sort(0, len(arr) - 1)"},{"question":"You are given two binary strings `a` and `b`, both of which have the same length. You need to simulate the process of adding these two binary numbers and return the result as a new binary string. The addition process should be similar to how you would perform binary addition by hand, starting from the least significant bit (rightmost side). If the sum of two bits results in a value greater than `1`, carry over the excess to the next higher bit position. Ensure you account for any carry value that may extend beyond the most significant bit. Return _the resulting binary string after adding the two input binary strings_.","solution":"def add_binary(a, b): Adds two binary strings and returns the result as a binary string. max_len = max(len(a), len(b)) # Padding the shorter string with \'0\' a = a.zfill(max_len) b = b.zfill(max_len) result = \\"\\" carry = 0 # Iterate from the last character to the first character for i in range(max_len - 1, -1, -1): bit_a = int(a[i]) bit_b = int(b[i]) # Sum of two bits and the carry total = bit_a + bit_b + carry # Resultant bit result = str(total % 2) + result # Calculate the new carry carry = total // 2 # If there is a carry left, we add it to the result if carry > 0: result = str(carry) + result return result"},{"question":"Given a binary tree, return the zigzag level order traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). The binary tree is represented by its root node, which is an instance of a `TreeNode` class having properties `val` (an integer representing the node\'s value) and `left` and `right` (pointers to the left and right child nodes, respectively).","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. if not root: return [] results = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) level = deque() for _ in range(level_size): node = node_queue.popleft() if left_to_right: level.append(node.val) else: level.appendleft(node.val) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) results.append(list(level)) left_to_right = not left_to_right return results"},{"question":"You are given a list of integers `heights` representing the heights of students standing in a line. The students are to be arranged in increasing order of height, but you need to maintain the relative order of the students with the same height. You are also given a list of integers `positions` where `positions[i]` indicates the new position of the student at index `i` in the original list. Return the rearranged list of heights after performing the position changes. [Question] 4:","solution":"def rearrange_heights(heights, positions): Rearrange the heights of students based on the given new positions. Parameters: - heights: A list of integers where each integer represents the height of a student. - positions: A list of integers where each integer represents the new position of the corresponding student in the heights list. Returns: - A list of integers representing the rearranged heights. # Creating a new list of the same length as heights initialized with None values rearranged = [None] * len(heights) # Placing each height at the new position for i in range(len(heights)): rearranged[positions[i]] = heights[i] return rearranged"},{"question":"A string `s` is called a **balanced string** if it contains an equal number of characters \'L\' and \'R\'. Given a string `s` of length `n`, split the string into the maximum number of balanced strings. Return _the number of balanced strings_ that can be obtained. A balanced string can be any contiguous segment of string `s` as long as it meets the balanced string condition.","solution":"def balanced_string_split(s): Returns the maximum number of balanced strings that can be obtained from the input string s. balance = 0 count = 0 for char in s: if char == \'L\': balance += 1 else: # char == \'R\' balance -= 1 if balance == 0: count += 1 return count"},{"question":"You are given an array of strings `words` where each string is a single **word**. A **compound word** is defined as a word that consists of at least two other words found in the `words` array concatenated together. Write a function to identify all compound words in the `words` array. The order of the words in the array should be maintained. Return an array of compound words found in `words`. If no compound words are found, return an empty array.","solution":"def find_compound_words(words): Returns all compound words in the array of words. A compound word is defined as a word that consists of at least two other words found in the array concatenated together. word_set = set(words) compound_words = [] def is_compound(word): n = len(word) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and word[j:i] in word_set and word[j:i] != word: dp[i] = True break return dp[-1] for word in words: if is_compound(word): compound_words.append(word) return compound_words"},{"question":"You are given a string `s` consisting of only the characters `a` and `b`. You can delete any number of characters from the string to create a subsequence. A subsequence is considered valid if it is a palindrome. Return the length of the longest valid palindromic subsequence that can be obtained from `s`.","solution":"def longest_palindromic_subsequence(s): Given a string s consisting of only characters \'a\' and \'b\', return the length of the longest valid palindromic subsequence that can be obtained from s. count_a = s.count(\'a\') count_b = s.count(\'b\') # The longest palindromic subsequence can be made by picking all occurrences of \'a\' # and/or all occurrences of \'b\' (whichever is higher), as each single character is # a palindrome and removing others still keeps the subsequence a palindrome. return max(count_a, count_b)"},{"question":"Write a function that takes a list of strings as input and returns the longest common prefix among all the strings. If there is no common prefix, return an empty string. For example, given the input `[\\"flower\\", \\"flow\\", \\"flight\\"]`, the function should return `\\"fl\\"`. If the input is `[\\"dog\\", \\"racecar\\", \\"car\\"]`, the function should return an empty string. The function signature should be: ```python def longestCommonPrefix(strs: List[str]) -> str: ```","solution":"from typing import List def longestCommonPrefix(strs: List[str]) -> str: if not strs: return \\"\\" # Sort the list, the common prefix of the whole list # would be the common prefix of the first and last elements strs.sort() first = strs[0] last = strs[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"You are given two non-empty binary trees `s` and `t`. Imagine there is a subtree of `s` that consists of all the nodes in `t`. Check whether `t` is a subtree of `s`. A subtree of a binary tree `s` is a tree `t` consisting of a node in `s` and all of this node\'s descendants. The tree `s` could also be considered as a subtree of itself. Return `true` if `t` is a subtree of `s`, otherwise return `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s, t): if not t: return True if not s: return False if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t) def is_same_tree(s, t): if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right)"},{"question":"You are given an array of integers `arr` and an integer `k`. Write a function that will return `true` if there is a continuous subarray of size at least `k` that sums up to a multiple of `k`, otherwise return `false`. A continuous subarray of size at least `k` means it has `k` or more consecutive elements from the array `arr`.","solution":"def check_subarray_sum(arr, k): Returns True if there is a continuous subarray of size at least k that sums up to a multiple of k, otherwise False. if len(arr) < k: return False cum_sum = 0 mod_dict = {0: -1} for i, num in enumerate(arr): cum_sum += num mod = cum_sum % k if mod in mod_dict: if i - mod_dict[mod] >= k: return True else: mod_dict[mod] = i return False"},{"question":"You have a linked list where each node contains an extra pointer called `random`, which can point to any node in the list or be `null`. Write a function to clone the list. The function should return a new, deep-copied linked list. Function Signature: ```python def clone_linked_list(head): # your code here ``` The cloned list should contain exactly the same values as the original list, in the same order, and the `random` pointers in the cloned list must point to the corresponding nodes in the new list, not the original list.","solution":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def clone_linked_list(head): if not head: return None # Step 1: Create new nodes interleaved with the original nodes current = head while current: new_node = Node(current.val) new_node.next = current.next current.next = new_node current = new_node.next # Step 2: Assign random pointers to the new nodes current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the new nodes from the original nodes old_list = head new_list = head.next new_head = head.next while old_list: old_list.next = old_list.next.next if new_list.next: new_list.next = new_list.next.next old_list = old_list.next new_list = new_list.next return new_head"},{"question":"You are given a `head` of a singly linked list. Each node contains an integer value. Design an algorithm to rearrange the list so that all odd-indexed nodes appear before all even-indexed nodes. Note that the relative order inside both the odd and even groups should remain as it was in the input. For example, given a linked list `1 -> 2 -> 3 -> 4 -> 5`, the function should return `1 -> 3 -> 5 -> 2 -> 4`. Implement a function that takes the `head` of the list and returns the new `head` of the rearranged list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head"},{"question":"You are given a string `s` of lowercase English letters and an integer `k`. You need to construct a new string by choosing some characters from `s` and concatenating them in the same order they appear in `s`. However, the newly constructed string must be a subsequence of `s` and must contain exactly `k` distinct characters. Return the lexicographically smallest string that meets these criteria. If there is no such string, return an empty string. For example, given `s = \\"abcde\\"` and `k = 3`, the possible strings are \\"abc\\", \\"abd\\", \\"abe\\", \\"acd\\", \\"ace\\", etc., and among these, the lexicographically smallest string is \\"abc\\".","solution":"def smallest_subsequence(s, k): from collections import Counter count = Counter(s) stack = [] seen = set() for char in s: if char not in seen: while stack and stack[-1] > char and count[stack[-1]] > 0 and len(seen) + 1 <= k: removed_char = stack.pop() seen.remove(removed_char) if len(seen) < k: stack.append(char) seen.add(char) count[char] -= 1 if len(seen) != k: return \\"\\" return \\"\\".join(stack)"},{"question":"Given an integer array `arr` of size `n`, you need to perform two types of operations: 1. **Update:** Update the value at a given index to a new value. 2. **Sum Range:** Calculate the sum of the elements between two given indices inclusive. Initially, the array `arr` is filled with zeros. Implement a class `NumArray` with the following methods: - `NumArray(int n)`: Initializes an array of size `n` with zeros. - `void update(int index, int value)`: Updates the value at `index` in the array to `value`. - `int sumRange(int left, int right)`: Returns the sum of elements in the range `[left, right]`. Your implementation should be efficient enough to handle a large number of updates and queries.","solution":"class NumArray: def __init__(self, n): Initializes an array of size n with zeros. self.n = n self.arr = [0] * n self.tree = [0] * (n + 1) def update(self, index, value): Updates the value at index in the array to value. diff = value - self.arr[index] self.arr[index] = value index += 1 while index <= self.n: self.tree[index] += diff index += (index & -index) def sumRange(self, left, right): Returns the sum of elements in range [left, right]. return self._prefix_sum(right + 1) - self._prefix_sum(left) def _prefix_sum(self, idx): total = 0 while idx > 0: total += self.tree[idx] idx -= (idx & -idx) return total"},{"question":"A binary tree is represented by a set of nodes, where each node has a value and possibly two children. Given a binary tree, determine the length of the longest path where each node in the path has a value of `1`. The path can be either from one node to any of its descendants or between any two nodes in the tree. Return _the length of the longest path consisting only of nodes with value `1`._","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_path_with_ones(root): def helper(node): if not node: return 0, 0 left_len, left_max = helper(node.left) right_len, right_max = helper(node.right) if node.val == 1: current_len = 1 + max(left_len, right_len) current_max = max(left_max, right_max, left_len + right_len + 1) else: current_len = 0 current_max = max(left_max, right_max) return current_len, current_max return max(helper(root)[1] - 1, 0)"},{"question":"You are given a binary tree where each node contains an integer value. Implement a class `BinaryTreePaths` that contains a method `getAllPaths`. The `getAllPaths` method should return all root-to-leaf paths as a list of strings. Each path should be presented as a string of the integers separated by \\"->\\". For example, for a binary tree with the structure: ``` 1 / 2 3 5 ``` The `getAllPaths` method should return `[\\"1->2->5\\", \\"1->3\\"]`. Implement the `BinaryTreePaths` class: * `BinaryTreePaths(TreeNode root)`: Initializes the object with the root of the binary tree. * `List<String> getAllPaths()`: Returns a list of all root-to-leaf paths as strings.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreePaths: def __init__(self, root: TreeNode): self.root = root def getAllPaths(self) -> List[str]: def dfs(node, path): if node: # Append the current node\'s value to the path path += str(node.val) if not node.left and not node.right: # If it\'s a leaf node paths.append(path) # Append the current path to the paths list else: path += \\"->\\" # Add the arrow for the next child nodes dfs(node.left, path) dfs(node.right, path) paths = [] dfs(self.root, \\"\\") return paths"},{"question":"An e-commerce company tracks the availability of products in its warehouses using a 2D grid. Each cell in the grid contains a number representing the number of units of the product stored in that particular warehouse section. Over time, the stock depletes due to sales, and the company wishes to assess the maximum inventory level of each section after depletion events. You are given a 2D array `inventory` representing the initial stock of the product in each section and a list of events `events`. Each event is represented as a tuple `(r, c, d)` meaning that `d` units are depleted from the section at row `r` and column `c`. Write a function `max_inventory_after_events(inventory, events)` that returns a 2D array representing the maximum inventory level of each section after applying all depletion events. If the depletion causes the units in a section to drop below zero, the inventory level for that section should be set to zero (since the inventory cannot go negative).","solution":"def max_inventory_after_events(inventory, events): Updates the inventory grid based on the depletion events and ensures no inventory level is negative. Parameters: - inventory (list of list of int): 2D list representing initial inventory levels - events (list of tuple of (int, int, int)): List of depletion events, where each event is a tuple (r, c, d) indicating \'d\' units depleted from row \'r\' and column \'c\' Returns: - list of list of int: 2D list representing the maximum inventory level of each section after depletion events for r, c, d in events: inventory[r][c] = max(0, inventory[r][c] - d) return inventory"},{"question":"We are given a list of integers `nums` and a target integer `k`. Each integer in the list represents the number of pens a person has. We want to determine if it is possible to distribute the pens among them such that the difference between the number of pens any two people have is at most `k`. If possible, return `true`, otherwise return `false`.","solution":"def can_distribute_pens(nums, k): Determines if the pens can be distributed such that the difference between the number of pens any two people have is at most k. :param nums: List of integers representing the number of pens each person has. :param k: Integer representing the maximum allowed difference in the number of pens between any two people. :return: True if possible to distribute, else False. if not nums: return True min_pens = min(nums) max_pens = max(nums) return (max_pens - min_pens) <= k"},{"question":"You are given a binary string `s`. You need to determine the length of the longest substring of `s` containing an equal number of \'0\'s and \'1\'s. If multiple such substrings exist, you can return the length of any of them. The input string `s` will not be empty and will have at least one \'0\' and one \'1\'. Return _the length of the longest substring with equal numbers of \'0\'s and \'1\'s_.","solution":"def longest_balanced_substring(s): Returns the length of the longest substring with equal numbers of \'0\'s and \'1\'s. count = 0 max_len = 0 index_map = {0: -1} for i, char in enumerate(s): count += 1 if char == \'1\' else -1 if count in index_map: max_len = max(max_len, i - index_map[count]) else: index_map[count] = i return max_len"},{"question":"Write a function `int findLongestConsecutiveSequence(int[] nums)` that takes an unsorted array of integers `nums` and returns the length of the longest consecutive elements sequence. **Example:** In the array `nums = [100, 4, 200, 1, 3, 2]`, the longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore, the function should return `4`. **Note:** - Your solution should run in O(n) time complexity.","solution":"def findLongestConsecutiveSequence(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a string `s` representing a simplified version of an algebraic expression, consisting of non-negative integers and the operators `+` and `-`. Your task is to parse this string and evaluate the result. The string does not contain any parentheses, and every number is followed by an operator (either `+` or `-`), except for the last number which completes the expression. For example, if `s = \\"10+5-3+6\\"`, the result would be `18`. Return the result of evaluating the expression represented by `s`.","solution":"def evaluate_expression(s): Evaluates a simplified algebraic expression consisting of non-negative integers and the operators `+` and `-`. Parameters: s (str): The input expression string. Returns: int: The result of the expression. num = 0 sign = 1 # 1 for positive, -1 for negative result = 0 for char in s: if char.isdigit(): num = num * 10 + int(char) else: result += sign * num num = 0 sign = 1 if char == \'+\' else -1 result += sign * num return result"},{"question":"Given an array of integers `nums`, for each integer in the array, consider the sum of all its distinct prime factors (a prime factor only counted once for each occurrence in the array). Return an array where each element is the sum of the distinct prime factors of the corresponding element in `nums`.","solution":"def get_prime_factors(n): Returns a set of distinct prime factors of the integer n. i = 2 factors = set() while i * i <= n: if n % i: i += 1 else: n //= i factors.add(i) if n > 1: factors.add(n) return factors def sum_of_distinct_prime_factors(nums): Returns an array where each element is the sum of the distinct prime factors of the corresponding element in nums. results = [] for num in nums: prime_factors = get_prime_factors(num) results.append(sum(prime_factors)) return results"},{"question":"You are given a string `s` and an array of strings `patterns`. Return an array containing all patterns that are **anagrams** of any substring of `s`. The returned array should be **distinct** and can be in any order. An **anagram** of a string is another string that contains the same characters, only the order of characters can be different.","solution":"from collections import Counter def find_anagrams(s, patterns): Returns a list of all distinct patterns that are anagrams of any substring of s. def is_anagram(sub, pat): return Counter(sub) == Counter(pat) s_len = len(s) results = set() for pattern in patterns: pat_len = len(pattern) for i in range(s_len - pat_len + 1): if is_anagram(s[i:i + pat_len], pattern): results.add(pattern) break # No need to check further substrings in `s` for this pattern return list(results)"},{"question":"A string `s` is called diverse if every character in `s` appears an odd number of times. You are given a string `s` of length `n` consisting of lowercase English letters. Your task is to determine the minimum number of characters you need to add or delete to make the string diverse. A single operation is defined as either adding one character to `s`, or deleting one character from `s`. Return the minimum number of operations required to make `s` diverse.","solution":"from collections import Counter def min_operations_to_make_diverse(s): Returns the minimum number of operations to make the string diverse. char_count = Counter(s) operations = 0 for count in char_count.values(): if count % 2 == 0: # If count is even, we need to change it to odd operations += 1 return operations"},{"question":"You are given an array of integers `heights` representing the height of buildings along a street. The array is 0-indexed, where `heights[i]` represents the height of the building at position `i`. A person can walk on the roof of these buildings provided that the height of the next building is equal to or less than the height of the current building. The person starts at the first building (index `0`). Determine the maximum number of buildings that the person can walk on consecutively, starting from the first building. Return an integer representing the maximum number of buildings the person can walk on consecutively, including the starting building.","solution":"def max_buildings_walkable(heights): Returns the maximum number of buildings that can be walked on consecutively starting from the first building. The walk is possible only if the height of the next building is less than or equal to the current building\'s height. :param heights: List[int], heights of the buildings. :return: int, maximum number of buildings walkable consecutively. if not heights: return 0 count = 1 for i in range(1, len(heights)): if heights[i] <= heights[i-1]: count += 1 else: break return count"},{"question":"You are given a list of non-negative integers `nums`, which are arranged in a non-decreasing order. However, the list can have duplicates. Your task is to remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. You should then return the length of the modified list. Additionally, fill the remaining slots in the list with the integer `-1` up to the original size of `nums`. For example, given `nums = [1, 1, 2, 2, 3, 4, 4]`, after removing duplicates you should return the length `4`, and the list should be modified to `[1, 2, 3, 4, -1, -1, -1]`.","solution":"def remove_duplicates(nums): Removes duplicates from the sorted list nums in-place, fills remaining slots with -1 and returns the new length. if not nums: return 0 # If the list is empty, return 0 write_index = 1 for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[write_index] = nums[i] write_index += 1 # Fill the remaining slots with -1 for i in range(write_index, len(nums)): nums[i] = -1 return write_index"},{"question":"You are given a string `s` consisting of lowercase alpha characters and an integer `k`. In one operation, you can choose any character in the string and change it to any other lowercase alpha character. Return _the **minimum** number of operations needed to make the string contain a substring of length_ `k` _that consists of the same character repeated_ `k` _times_.","solution":"def min_operations_to_uniform_substring(s, k): Returns the minimum number of operations needed to make the string s contain a substring of length k that consists of the same character repeated k times. n = len(s) min_operations = float(\'inf\') for i in range(n - k + 1): substring = s[i:i+k] count = [0] * 26 # Count frequency of each character in the substring for char in substring: count[ord(char) - ord(\'a\')] += 1 # Find the most frequent character frequency max_freq = max(count) # Calculate the number of operations needed to make all characters the same operations = k - max_freq # Track the minimum operations encountered min_operations = min(min_operations, operations) return min_operations"},{"question":"You are given a binary tree, where each node contains an integer value. Write a function `findLargestUniquePathSum` that returns the maximum sum of values of nodes in any unique-value path in the tree. A unique-value path is defined as a path from the root to any leaf node where all the node values must be distinct. A binary tree is represented by a TreeNode class in Python as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Note:** - A leaf is a node with no children. - If there is no unique-value path, return `0`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLargestUniquePathSum(root): def dfs(node, path_set, current_sum): if not node: return current_sum if node.val in path_set: return current_sum path_set.add(node.val) current_sum += node.val if not node.left and not node.right: result = current_sum else: left_sum = dfs(node.left, path_set.copy(), current_sum) right_sum = dfs(node.right, path_set.copy(), current_sum) result = max(left_sum, right_sum) path_set.remove(node.val) return result if not root: return 0 unique_values_path_set = set() max_sum = dfs(root, unique_values_path_set, 0) return max_sum"},{"question":"In a grid-based city represented as a 2D matrix of integers, certain cells are designated as buildings (represented by a 1), and empty plot cells are designated as 0. You need to determine a central point to build a post office such that the sum of the Manhattan distances from the post office to all the buildings is minimized. If there are multiple optimal locations, return any one of them. The Manhattan distance between two points ((x1, y1)) and ((x2, y2)) is (|x1 - x2| + |y1 - y2|). Write a function that takes in the 2D matrix `grid` and returns the coordinates of the optimal location for the post office. If there are no buildings in the grid, return `[-1, -1]`.","solution":"def min_total_distance(grid): Returns the coordinates of the optimal location for a post office in a grid-based city. If there are no buildings in the grid, returns [-1, -1]. if not grid or not grid[0]: return [-1, -1] rows, cols = len(grid), len(grid[0]) buildings = [(r, c) for r in range(rows) for c in range(cols) if grid[r][c] == 1] if not buildings: return [-1, -1] def get_min_distance(coords): mid = len(coords) // 2 return coords[mid] x_coords = sorted(r for r, _ in buildings) y_coords = sorted(c for _, c in buildings) optimal_x = get_min_distance(x_coords) optimal_y = get_min_distance(y_coords) return [optimal_x, optimal_y]"},{"question":"You are given a **0-indexed** integer array `skills` where `skills[i]` represents the skill level of the `i-th` team member. There is an integer `x` which represents the number of team members that should perform a certain task, and an integer `k` which signifies the minimum skill level required for any individual to be included in this group of `x` members. Return `true` if it is possible to select exactly `x` team members whose skill levels are all at least `k`, otherwise return `false`.","solution":"def can_select_team(skills, x, k): Returns true if it\'s possible to select exactly x members from skills array such that all have skill level of at least k. :param skills: List[int] - skill levels of team members. :param x: int - number of team members to select. :param k: int - minimum skill level required for selection. :return: bool - True if possible to select x members with skill level  k, False otherwise. # Filter out members that meet the skill level requirement suitable_members = [skill for skill in skills if skill >= k] # Check if there are at least x suitable members return len(suitable_members) >= x"},{"question":"You are given an array of strings `words` and another string `chars`. Each string in `words` is composed of lowercase English letters. The string `chars` is also composed of lowercase English letters. We want to determine the length of strings in `words` that can be formed using the letters in `chars`. Each letter in `chars` can only be used once per string. Return the total length of all strings in `words` that can be formed by using the letters in `chars` exactly once.","solution":"from collections import Counter def count_characters(words, chars): Returns the total length of all strings in `words` that can be formed by using the letters in `chars` exactly once. chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) for char in word_count: if word_count[char] > chars_count.get(char, 0): break else: total_length += len(word) return total_length"},{"question":"**Question 4**: You are given an array of integers `nums`, and you need to perform a series of query operations on it. Each query is defined by two integers `left` and `right` where `0 <= left <= right < nums.length`. The result of a query is the sum of the elements from index `left` to index `right` (inclusive). Implement a function that processes multiple queries efficiently and returns the sum for each query. In a more optimized approach, you are required to preprocess the array to allow querying the sum of any subarray efficiently in constant time. The preprocessing step should prepare any necessary data structure before processing the queries.","solution":"def preprocess(nums): Preprocess the nums array to allow querying sum of any subarray efficiently. n = len(nums) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + nums[i] return prefix_sums def query_sum(prefix_sums, left, right): Return the sum of the elements from index left to index right (inclusive) using preprocessed prefix sums. return prefix_sums[right + 1] - prefix_sums[left] # Example usage: # nums = [1, 2, 3, 4] # prefix_sums = preprocess(nums) # result = query_sum(prefix_sums, 1, 3) # Should return the sum from index 1 to 3, i.e., 2 + 3 + 4 = 9"},{"question":"You are given a **sorted** array `arr` of `n` integers which can be positive, negative, or zero, and a **target** integer `k`. Your task is to find the **number of unique pairs** `(arr[i], arr[j])` such that `i != j` and `arr[i] + arr[j] = k`. Each pair should be counted only once, even if there are multiple duplicates. Return _the **count** of such unique pairs_.","solution":"def count_unique_pairs(arr, k): Returns the count of unique pairs (arr[i], arr[j]) such that i != j and arr[i] + arr[j] = k. unique_pairs = set() seen = set() for num in arr: complement = k - num if complement in seen: unique_pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(unique_pairs)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer array `indices` of the same length. Each index in `indices` represents the position in the string `s` that the corresponding character in `s` should be moved to. Reconstruct the string after performing the moves and return it. For example, if `s = \\"abc\\"` and `indices = [2, 0, 1]`, the character `\'a\'` should be moved to index `2`, `\'b\'` to index `0`, and `\'c\'` to index `1`, making the resulting string `\\"bca\\"`.","solution":"def restore_string(s, indices): Reconstruct the string `s` based on the rearrangement provided by `indices`. Parameters: s (str): The input string. indices (list): The list of indices indicating the positions characters should be moved to. Returns: str: The reconstructed string. # Create a list of the same length as \'s\' with empty characters reconstructed = [\'\'] * len(s) # Place each character of \'s\' to its respective index in the reconstructed list for char, index in zip(s, indices): reconstructed[index] = char # Join the list into a string and return return \'\'.join(reconstructed)"},{"question":"Given a list of strings `words`, return a list of lists where each sublist contains all anagrams of a given string from the input list. Each sublist should contain the words in the same order they appeared in the input list. Ensure the relative order of the original strings is preserved in each sublist. If a word does not have any anagrams, it should appear as a single-element sublist.","solution":"from collections import defaultdict def group_anagrams(words): Returns a list of lists where each sublist contains all anagrams of a given string from the input list. anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"A company is migrating its database system and needs to optimize its query performance. You are given a `m x n` grid representing the current database storage layout. Each cell in the grid can either be `0` (indicating an empty space) or `1` (indicating a filled space). The task is to find the largest square (composed of `1`s) that can be formed within this grid. The side length of the square should be maximized. Return the area of this largest square. For example, given the grid: ``` [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] ``` The largest square formed by `1`s has a side length of `2`, and thus, the area would be `4`.","solution":"def maximal_square(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] max_side = 0 for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i-1][j-1] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given an array of integers `weights` representing the weights of different items, and an integer `limit` representing the weight limit of a single boat. Each boat can carry at most two items. Return the minimum number of boats required to carry all the items. You must ensure that the sum of weights of items carried by any boat does not exceed the `limit`.","solution":"def num_rescue_boats(weights, limit): Returns the minimum number of boats required to carry all items within the weight limit. Each boat can carry at most two items. weights.sort() left, right = 0, len(weights) - 1 boats = 0 while left <= right: if weights[left] + weights[right] <= limit: left += 1 right -= 1 boats += 1 return boats"},{"question":"You are given a 2D integer array `connections` where `connections[i] = [computer1, computer2, length]` represents a connection between `computer1` and `computer2` with a cable of `length`. Your task is to configure the network so that all computers are connected with the **minimum total length** of cable. The network should be a tree, meaning there are no cycles and all computers are connected directly or indirectly. If it is impossible to connect all the computers, return `-1`. Implement the function `int minCostConnectAllComputers(int n, int[][] connections)` where `n` is the number of computers, and `connections` is the array of connections. **Example:** ``` Input: n = 4, connections = [[1, 2, 5], [1, 3, 8], [2, 4, 1], [3, 4, 10]] Output: 14 Explanation: The minimum total length of cable needed to connect all computers is 14. ``` **Constraints:** - `1 <= n <= 1000` - `1 <= connections.length <= 10000` - `connections[i].length == 3` - `1 <= computer1, computer2 <= n` - `1 <= length <= 10000` - There are no repeated connections and no cable connects a computer to itself.","solution":"def minCostConnectAllComputers(n, connections): Calculates the minimum cost to connect all computers in a network algorithm using Kruskal\'s algorithm. Returns -1 if it is impossible to connect all computers. # Kruskal\'s algorithm requires sorting edges by weight and union-find to detect and avoid cycles def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 # Sort connections based on the cable length connections.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n + 1): parent.append(node) rank.append(0) result = 0 num_edges = 0 i = 0 while num_edges < n - 1 and i < len(connections): u, v, w = connections[i] i += 1 x = find(parent, u) y = find(parent, v) if x != y: num_edges += 1 result += w union(parent, rank, x, y) return result if num_edges == n - 1 else -1"},{"question":"Given an array of `n` integers, find a continuous subarray which has the largest sum. Return the sum of this subarray. This problem is a variation of the \\"Maximum Subarray Problem\\" which is solved using Kadane\'s Algorithm.","solution":"def max_subarray_sum(arr): Find the largest sum of a continuous subarray using Kadane\'s Algorithm. Args: arr: list of integers Returns: int: largest sum of continuous subarray if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given an array of integers `nums` representing the values on a circular track. The circular track is such that the element after the last element is the first element. You need to find the maximum sum of a subarray in this circular track. A subarray can only include contiguous elements from the array, but it can wrap around the end of the array. Return the maximum sum of a subarray in this circular track. For example, if `nums` = [5, -3, 5], the maximum sum of a subarray would be 10, considering the subarray [5, 5] that wraps from the end back to the beginning.","solution":"def max_subarray_sum_circular(nums): Returns the maximum sum of a subarray in the circular track represented by nums. def kadane(arr): current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum # Step 1: Find the maximum subarray sum using standard Kadane\'s algorithm max_kadane = kadane(nums) # Step 2: Find the maximum subarray sum that includes the wrapping around elements total_sum = sum(nums) inverted_nums = [-num for num in nums] max_wraparound = total_sum + kadane(inverted_nums) # max_wrap = total_sum - min_subarray_sum if max_wraparound == 0: return max_kadane return max(max_kadane, max_wraparound)"},{"question":"You are given a 2D grid of size `m x n` where each cell is either `0` (empty) or `1` (contains an obstacle). You need to find the number of unique paths from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1), such that you can only move either down or right, and you cannot pass through cells with obstacles. Return the number of unique paths. If there is no valid path, return `0`. For example, given the following grid: ``` [[0, 0, 0], [0, 1, 0], [0, 0, 0]] ``` The number of unique paths is `2`, since the valid paths are: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid that contains obstacles. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Start point for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given a binary tree with `n` nodes where each node has a unique value between `1` and `n`. The root of the tree has a value of `1`. You are tasked with finding the **diameter** of the tree, which is defined as the length of the longest path between any two nodes in the tree. The length of a path is represented by the number of edges between the corresponding nodes. Write a function that takes in an integer `n` and a list of edges, where each edge is represented as `[u, v]`, indicating that there is an edge between nodes `u` and `v`. Return the length of the diameter of the tree.","solution":"def tree_diameter(n, edges): from collections import defaultdict, deque if n == 1: return 0 # Create an adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Helper function to do BFS and return the farthest node and its distance def bfs(start): visited = [-1] * (n + 1) queue = deque([(start, 0)]) visited[start] = 0 farthest_node = start max_distance = 0 while queue: node, dist = queue.popleft() for neighbor in adj_list[node]: if visited[neighbor] == -1: visited[neighbor] = dist + 1 queue.append((neighbor, dist + 1)) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance # Start BFS from an arbitrary node (root in this case, which is 1) farthest_node_from_root, _ = bfs(1) # Perform BFS again from the farthest node found to get the diameter _, diameter_length = bfs(farthest_node_from_root) return diameter_length"},{"question":"You are given a **0-indexed** integer array `nums` and a target integer `target`. You are allowed to decrease any element of the array by `1` any number of times. Return the minimum number of operations required so that at least one subsequence of the array sums to the target. If it is not possible, return `-1`.","solution":"def min_operations_to_target(nums, target): Returns the minimum number of operations required so that at least one subsequence of nums sums to the target. :param nums: List[int] - an array of integers :param target: int - the target sum :return: int - the minimum number of operations or -1 if not possible nums.sort(reverse=True) current_sum = 0 operations = 0 for num in nums: if current_sum >= target: break if current_sum + num > target: operations += current_sum + num - target num = target - current_sum current_sum += num if current_sum >= target: return operations return -1 if current_sum < target else operations"},{"question":"You are given a **0-indexed** string `s` of length `n` consisting of digits from `\'0\'` to `\'9\'`. A **special substring** is defined as a substring that starts and ends with the same character, and all the characters in this substring should be the same. Your task is to find the number of **different** special substrings in the given string `s`. Return the count of such substrings.","solution":"def count_special_substrings(s): Return the number of different special substrings in the given string `s`. A special substring is defined as a substring that starts and ends with the same character, and all the characters in this substring should be the same. count = 0 n = len(s) # Iterate over each character in the string for i in range(n): # Expand around the character to count all special substrings for j in range(i, n): if s[i] == s[j] and (s[i:j+1] == s[i] * (j - i + 1)): count += 1 else: break # if we found a non-special substring, break the inner loop return count"},{"question":"A **valid parentheses sequence** is a string consisting only of the characters `\'(\'` and `\')\'` that is correctly balanced. A string is correctly balanced if for every opening parenthesis `\'(\'` there is a corresponding closing parenthesis `\')\'`, and no closing parenthesis `\')\'` is unmatched by a preceding opening parenthesis `\'(\'`. Given a string `s` containing only these two characters, determine whether it forms a valid parentheses sequence. Return `true` if the string is a valid parentheses sequence, and `false` otherwise.","solution":"def is_valid_parentheses(s): Check if the input string s is a valid parentheses sequence. Args: s (str): The input string containing only \'(\' and \')\' Returns: bool: True if s is a valid parentheses sequence, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to construct a new string by performing the following operation exactly `k` times: 1. Select any character in the current string `s` and double it (i.e., add one copy of the selected character at the current position in the string). Return the lexicographically smallest string that can be obtained after performing this operation exactly `k` times. For example, given `s = \\"abc\\"` and `k = 2`, one possible sequence of operations to achieve the lexicographically smallest string is: on the first operation, double \'a\' resulting in \\"aabc\\", and on the second operation, double \'a\' again to get \\"aaabc\\", which is the lexicographically smallest string possible.","solution":"def double_characters_to_lexico_smallest(s, k): Returns the lexicographically smallest string by doubling characters in the string `s` exactly `k` times. # Convert the string to a list of characters to facilitate character insertion s = list(s) # Perform `k` operations for _ in range(k): # Find the first character that when doubled results in the smaller lexicographical string smallest_char = min(s) smallest_char_pos = s.index(smallest_char) # Double the smallest character by inserting one at its position s.insert(smallest_char_pos, smallest_char) # Join the list back to a string and return return \\"\\".join(s)"},{"question":"Given a list of non-negative integers `nums` where each element represents the maximum number of steps you can take forward from that position, implement a function that determines if you can reach the last index starting from the first index. * For example, given `nums = [2,3,1,1,4]`, the output should be `true` because you can jump to the last index by jumping `1` step to index `1`, then `3` steps to the last index. * Another example, given `nums = [3,2,1,0,4]`, the output should be `false` because you will always end up at index `3` which has a step value of `0`, thus making it impossible to move further to the last index. The function should return a boolean value, `true` if it is possible to reach the last index, and `false` otherwise.","solution":"def can_jump(nums): Determines if you can reach the last index starting from the first index in an array of non-negative integers. :param nums: List[int], a list of non-negative integers where each element represents the maximum number of steps forward. :return: bool, True if you can reach the last index, False otherwise. max_reachable = 0 for i in range(len(nums)): if i > max_reachable: return False max_reachable = max(max_reachable, i + nums[i]) return max_reachable >= len(nums) - 1"},{"question":"You are given a string `s` and a string `t`. Return the minimum window substring of `s` that contains all the characters in `t`. If there is no such substring, return an empty string. If there are multiple such substrings, return the smallest lexicographical one. Keep in mind that the characters in the strings are case-sensitive.","solution":"from collections import Counter def min_window_substring(s, t): Returns the minimum window substring of `s` that contains all the characters in `t`. If no such window exists, returns an empty string. If there are multiple windows with the same length, return the lexicographically smallest one. if not s or not t or len(s) < len(t): return \\"\\" dict_t = Counter(t) required = len(dict_t) left, right = 0, 0 formed = 0 window_counts = {} min_len = float(\\"inf\\") min_window = \\"\\" while right < len(s): char = s[right] window_counts[char] = window_counts.get(char, 0) + 1 if char in dict_t and window_counts[char] == dict_t[char]: formed += 1 while left <= right and formed == required: char = s[left] end = right + 1 if end - left < min_len or (end - left == min_len and s[left:end] < min_window): min_len = end - left min_window = s[left:end] window_counts[char] -= 1 if char in dict_t and window_counts[char] < dict_t[char]: formed -= 1 left += 1 right += 1 return min_window"},{"question":"You are given a list of non-negative integers representing the heights of walls with unit width. Calculate the maximum amount of water that can be trapped between the walls after raining. Write a function `trap` that takes the list of integers `height` and returns the maximum volume of water that can be trapped.","solution":"def trap(height): Calculate the maximum amount of water that can be trapped between walls. :param height: List[int], list of non-negative integers representing the heights of the walls :return: int, the maximum amount of water that can be trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a binary string `s` which contains only the characters \'0\' and \'1\'. A substring of `s` is called balanced if the number of \'0\'s and the number of \'1\'s in the substring are equal. Write a function that returns the length of the longest balanced substring in `s`. If there is no balanced substring, return 0.","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring in the binary string `s`. A balanced substring contains an equal number of \'0\'s and \'1\'s. longest_length = 0 balance = 0 balance_dict = {0:-1} for i, char in enumerate(s): if char == \'0\': balance -= 1 else: balance += 1 if balance in balance_dict: longest_length = max(longest_length, i - balance_dict[balance]) else: balance_dict[balance] = i return longest_length"},{"question":"A warehouse manager needs to stack crates efficiently. Given an array `crates` where `crates[i]` represents the height of the `i-th` crate, and an integer `n` representing the exact number of stacks required, you need to determine the minimum possible height difference between the tallest and the shortest stacks after all crates have been stacked. You can only stack crates vertically, and each stack must consist of at least one crate. Return the minimum possible height difference.","solution":"def min_height_difference(crates, n): Determines the minimum possible height difference between the tallest and the shortest stacks after all crates have been stacked. :param crates: List[int] where crates[i] represents the height of the i-th crate :param n: int representing the number of stacks required :return: int - minimum possible height difference if len(crates) == n: return 0 # Each crate will be in its own stack crates.sort() min_diff = float(\'inf\') for i in range(len(crates) - n + 1): current_diff = crates[i + n - 1] - crates[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"You are given a list of integers `nums` where each integer `nums[i]` represents the number of occurrences of a letter. Each letter can have multiple occurrences. However, no two letters can have exactly the same number of occurrences. Return a boolean value `true` if it is possible to assign frequencies such that no two letters have the same frequency; otherwise, return `false`.","solution":"def uniqueFrequencies(nums): Returns True if no two letters have the same frequency, otherwise False frequencies_set = set(nums) # Convert the list to a set to remove duplicates return len(frequencies_set) == len(nums)"},{"question":"You are given a list of `meetingTimes` where each element is a pair `[start_time, end_time]` representing the start and end times of a meeting. Assume the times are given as integers in a 24-hour format. Determine if a person can attend all the meetings without any overlaps. Return `true` if a person can attend all the meetings, otherwise return `false`. Example: ``` Input: meetingTimes = [[9, 10], [11, 12], [10, 11]] Output: true ``` Example: ``` Input: meetingTimes = [[9, 11], [10, 12]] Output: false ```","solution":"def can_attend_all_meetings(meetingTimes): Determines if a person can attend all meetings without any overlaps. Args: meetingTimes: List of pair of integers where each pair represents the start and end time of a meeting. Returns: bool: True if a person can attend all meetings without any overlaps, False otherwise. if not meetingTimes: return True # Sort meetings by start time meetingTimes.sort(key=lambda x: x[0]) # Check for overlaps for i in range(1, len(meetingTimes)): if meetingTimes[i][0] < meetingTimes[i-1][1]: return False return True"},{"question":"Given a string `s` containing only the characters `\'(\'` and `\')\'`, find the length of the longest valid (well-formed) parentheses substring. A valid parentheses substring is a substring that opens and closes correctly. Write an algorithm that returns this length. Consider using a dynamic programming approach or a stack-based solution to achieve an optimal implementation.","solution":"def longestValidParentheses(s): Returns the length of the longest valid (well-formed) parentheses substring. Parameters: s (str): The input string containing only \'(\' and \')\'. Returns: int: The length of the longest valid parentheses substring. max_length = 0 stack = [-1] for i, char in enumerate(s): if char == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"You are given a binary tree with `n` nodes labeled from `1` to `n` and an integer `x`. Your task is to remove all nodes whose value is greater than `x`. After removing a node, if it had children, they should also be removed. Return the root of the modified tree. Write a function `TreeNode* pruneTree(TreeNode* root, int x)` where `TreeNode` is a class with public attributes `int val`, `TreeNode* left`, and `TreeNode* right`. The tree is guaranteed to be non-empty.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root, x): if root is None: return None # Recursively prune the left and right subtrees root.left = pruneTree(root.left, x) root.right = pruneTree(root.right, x) # If the current node\'s value is greater than x, remove this node if root.val > x: return None # Otherwise return the current node return root"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values (i.e., from left to right, level by level). You are provided the root of the binary tree and should return a 2D list where each sublist represents a level of the binary tree. For example: Input: ``` 3 / 9 20 / 15 7 ``` Output: ``` [ [3], [9, 20], [15, 7] ] ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns the level order traversal of a binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"You are given a string `s` consisting of lowercase alphabetical characters and a list of queries `queries` where each query is a tuple `(left, right, character)`. For each query, you need to determine how many times the given `character` appears in the substring of `s` starting at index `left` and ending at index `right` (both inclusive). Return _an array_ `results` _where_ `results[i]` _is the answer to the_ `i-th` _query_. For example, given `s = \\"abbaca\\"` and `queries = [(1, 4, \'a\'), (0, 3, \'b\')]`, the result should be `[1, 2]` because in the substring `s[1:5]` (i.e., \\"bba\\") the character `a` appears once, and in the substring `s[0:4]` (i.e., \\"abba\\") the character `b` appears twice.","solution":"def count_character_occurrences(s, queries): For each query, counts the occurrences of the specified character in the given substring. Args: s (str): A string consisting of lowercase alphabetical characters. queries (list of tuples): A list of queries where each query is a tuple containing (left index, right index, character). Returns: list of int: A list where each element is the count of the character in the specified substring. results = [] for left, right, character in queries: count = 0 for i in range(left, right + 1): if s[i] == character: count += 1 results.append(count) return results"},{"question":"Given an array `nums` containing `n` integers, you need to find a contiguous subarray which has the largest sum and return its sum. A subarray is a contiguous part of an array. For example, if `nums` is `[-2,1,-3,4,-1,2,1,-5,4]`, the subarray `[4,-1,2,1]` has the largest sum of `6`.","solution":"def max_subarray_sum(nums): Finds the contiguous subarray with the largest sum and returns that sum. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a list of `n` distinct integers `arr` and an integer `target`. Find all unique quadruples in the array which gives the sum of the `target`. The solution set must not contain duplicate quadruples. For example, given the array `arr = [1, 0, -1, 0, -2, 2]` and the `target = 0`, the unique quadruples are: - `[-1, 0, 0, 1]` - `[-2, -1, 1, 2]` - `[-2, 0, 0, 2]` Return all such unique quadruples in any order.","solution":"def four_sum(arr, target): Finds all unique quadruples in the array that sum to the target. arr.sort() n = len(arr) result = [] for i in range(n - 3): if i > 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue left, right = j + 1, n - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: result.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return result"},{"question":"You are given an integer array `heights` representing the height of buildings, where `heights[i]` is the height of the `i`-th building. The city contains one skyline made up of the visible parts of the buildings when viewed from a distance. The **skyline** is represented as a list of \\"key points\\" in the format `[x, y]`, where `x` is the x-coordinate of a peak and `y` is the height of that peak. The resulting contour should be a list of such points that follows the direction of the skyline from left to right. Write a function `getSkyline` that takes the array `heights` and returns the skyline formed by these buildings as described. Implement the `getSkyline` function: - `List[List[int]] getSkyline(int[][] buildings)` where `buildings` is an array of height values. The solution must effectively handle the complexity in skyline problems and return the minimum number of points that correctly represent the skyline.","solution":"def getSkyline(heights): Returns the skyline of the given buildings represented by heights. if not heights: return [] n = len(heights) result = [[0, heights[0]]] for i in range(1, n): if heights[i] != heights[i - 1]: result.append([i, heights[i]]) result.append([n, 0]) return result"},{"question":"Given an array of integers `heights` representing the heights of students and an integer `k`, return _the minimum possible difference between the maximum height and the minimum height after performing at most `k` operations_. In each operation, you can choose any student and either increase or decrease their height by `1`.","solution":"def minDifferenceAfterOperations(heights, k): Returns the minimum possible difference between the maximum height and the minimum height after performing at most k operations on the heights. In each operation, you can choose any student and either increase or decrease their height by 1. Parameters: heights (List[int]): List of heights of the students. k (int): Maximum number of operations that can be performed on the heights. Returns: int: The minimum possible difference between the maximum and minimum height. if not heights: return 0 max_height = max(heights) min_height = min(heights) # If the difference is less than or equal to twice k, we can definitely make all heights the same if max_height - min_height <= 2 * k: return 0 # Otherwise, we adjust the maximum and minimum values accordingly return (max_height - k) - (min_height + k)"},{"question":"Given a string `s`, count the number of times a non-overlapping substring, which is a palindrome, appears in `s`. A **palindrome** is a sequence of characters that reads the same backward as forward. Two occurrences of the same substring are counted as different if they start at different positions in the string. Return _the number of non-overlapping palindromic substrings in `s`_. For example, in the string `\\"aaaa\\"`, the non-overlapping palindromic substrings are `\\"a\\"`, `\\"a\\"`, `\\"a\\"`, and `\\"a\\"`, which appears 4 times.","solution":"def is_palindrome(s): return s == s[::-1] def count_palindromic_substrings(s): n = len(s) count = 0 # Iterate over all possible substring lengths for length in range(1, n + 1): i = 0 # Iterate over all possible substrings of length `length` while i + length <= n: substring = s[i:i + length] if is_palindrome(substring): count += 1 i += 1 return count"},{"question":"Given a string `s` containing only lowercase English letters and a string `target`, return the minimum number of character deletions required in `s` to make it a subsequence of `target`. A subsequence is obtained by deleting some (possibly zero) characters from `target` without changing the order of the remaining characters.","solution":"def min_deletions_to_subsequence(s, target): Returns the minimum number of character deletions required in \'s\' to make it a subsequence of \'target\'. m, n = len(s), len(target) # Create a 2D DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(m): for j in range(n): if s[i] == target[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) longest_subsequence_length = dp[m][n] return m - longest_subsequence_length"},{"question":"You are given a two-dimensional grid `grid` of integers where `grid[i][j]` represents the number of apples in the cell `(i, j)`. You can move from a given cell to another cell that is either directly below it or directly to the right of it. Starting from the top-left cell `(0, 0)`, you want to find the maximum number of apples you can collect by the time you reach the bottom-right cell `(n-1, m-1)` of the grid. You are asked to return _an integer_ `maxApples` _that represents the maximum number of apples you can collect with the given constraints_. For example, given the 2D grid: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The function should return 29 because the path that collects the maximum number of apples is `[1  4  7  8  9]`.","solution":"def max_apples(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) return dp[n-1][m-1]"},{"question":": Given an integer `n`, generate a zigzag pattern in a `n x n` matrix by filling it with consecutive integers starting from 1. The pattern should start from the top-left corner of the matrix and zigzag through the rows. Specifically, the first row should be filled left to right, the second row right to left, the third row left to right, and so on. Return the resulting `n x n` matrix.","solution":"def generate_zigzag_matrix(n): Generate a zigzag pattern in an n x n matrix by filling it with consecutive integers starting from 1. The pattern starts from the top-left corner and zigzags through the rows. Parameters: n (int): The dimension of the n x n matrix. Returns: matrix (list of list of int): The n x n matrix with the zigzag pattern. matrix = [[0] * n for _ in range(n)] current_number = 1 for i in range(n): if i % 2 == 0: # Fill left to right for j in range(n): matrix[i][j] = current_number current_number += 1 else: # Fill right to left for j in range(n-1, -1, -1): matrix[i][j] = current_number current_number += 1 return matrix"},{"question":"You are given a `0-indexed` 2D integer matrix `matrix`, where `matrix[i][j]` represents the height of the cell `(i, j)`. A cell `(i, j)` is considered a **peak** if it is greater than or equal to all its surrounding cells. This means for a cell to be a peak, the following conditions should hold true (considering boundaries of the matrix): * For `i > 0`, `matrix[i][j] >= matrix[i-1][j]` (cell above) * For `i < rows-1`, `matrix[i][j] >= matrix[i+1][j]` (cell below) * For `j > 0`, `matrix[i][j] >= matrix[i][j-1]` (cell to the left) * For `j < cols-1`, `matrix[i][j] >= matrix[i][j+1]` (cell to the right) Return _a list of coordinates of all the peaks in the matrix_. The order of the coordinates in the output does not matter. If there are multiple peaks, include all of them.","solution":"def find_peaks(matrix): Returns a list of coordinates (i, j) of all peaks in the matrix. rows, cols = len(matrix), len(matrix[0]) peaks = [] for i in range(rows): for j in range(cols): is_peak = True if i > 0 and matrix[i][j] < matrix[i-1][j]: is_peak = False if i < rows-1 and matrix[i][j] < matrix[i+1][j]: is_peak = False if j > 0 and matrix[i][j] < matrix[i][j-1]: is_peak = False if j < cols-1 and matrix[i][j] < matrix[i][j+1]: is_peak = False if is_peak: peaks.append((i, j)) return peaks"},{"question":"You are given a **0-indexed** array `nums` of integers and an integer `x`. You need to find and return the minimum number of operations required to reduce the sum of the elements in `nums` to be less than or equal to `x`. In one operation, you can either remove the leftmost or rightmost element from the array `nums`. If it is not possible to make the sum less than or equal to `x`, return `-1`.","solution":"def min_operations(nums, x): total_sum = sum(nums) target = total_sum - x if target < 0: return -1 if target == 0: return len(nums) max_length = -1 current_sum = 0 left = 0 for right in range(len(nums)): current_sum += nums[right] while current_sum > target and left <= right: current_sum -= nums[left] left += 1 if current_sum == target: max_length = max(max_length, right - left + 1) return len(nums) - max_length if max_length != -1 else -1"},{"question":"You are given an integer array `arr` where each element represents the cost of a meal on a menu. You have an integer `budget`. Return _a list of unique combinations of meals_ such that the combined cost of the meals in each combination does not exceed `budget`. Each element in the combination must be unique and each combination should be represented as an array of meal costs. You can use any number of meals from the given `arr`, and the same meal cost can be used multiple times within a combination.","solution":"from typing import List def meal_combinations(arr: List[int], budget: int) -> List[List[int]]: Returns a list of unique combinations of meal costs such that the total cost does not exceed the budget. result = [] def backtrack(start, path, remaining_budget): if remaining_budget == 0: result.append(path[:]) return if remaining_budget < 0: return for i in range(start, len(arr)): path.append(arr[i]) backtrack(i, path, remaining_budget - arr[i]) path.pop() arr = list(set(arr)) # Remove duplicates arr.sort() # Sort to handle combinations in non-decreasing order backtrack(0, [], budget) return result"},{"question":"Implement a function that takes a string containing a mathematical expression in postfix notation and evaluates the expression. The postfix notation (also known as Reverse Polish notation) is a mathematical notation in which operators follow their operands. For example, the postfix expression `\\"3 4 + 2 * 7 /\\"` is evaluated as `((3 + 4) * 2) / 7 = 2`. The expression contains only non-negative integers and the operators `+`, `-`, `*`, and `/`. Assume that the division operator `/` implements integer division. Return the result of the evaluated expression.","solution":"def evaluate_postfix(expression): Evaluates a mathematical expression in postfix notation. Parameters: expression (str): A string containing the postfix notation expression. Returns: int: The result of the evaluated postfix expression. stack = [] for token in expression.split(): if token.isdigit(): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a // b) # Integer division return stack.pop()"},{"question":"You are given a directed graph with `n` nodes labeled from `0` to `n-1` and an array `edges` where each `edges[i] = [u, v]` represents a directed edge from node `u` to node `v`. Additionally, you are given an integer `k`. A valid path in the graph is defined as a sequence of distinct nodes where each consecutive pair is connected by a directed edge. Return _the **number** of valid paths that have exactly `k` edges_. If there is no such path, return `0`. As the answer may be too large, return it **modulo** `109 + 7`.","solution":"def count_paths(n, edges, k): MOD = 1000000007 # Create a adjacency matrix to store the number of ways to go from i to j in 1 step adj_matrix = [[0] * n for _ in range(n)] for u, v in edges: adj_matrix[u][v] += 1 # dp[i][j] will store the number of paths from node i to node j in exactly k steps dp = [[[0] * n for _ in range(n)] for _ in range(k + 1)] # Base case: paths with exactly 0 edges for i in range(n): dp[0][i][i] = 1 # Fill the dp array for paths with 1 to k edges for step in range(1, k + 1): for u in range(n): for v in range(n): dp[step][u][v] = 0 for mid in range(n): dp[step][u][v] = (dp[step][u][v] + dp[step - 1][u][mid] * adj_matrix[mid][v]) % MOD # Sum up all the valid paths from any node to any node with exactly k steps result = 0 for i in range(n): for j in range(n): result = (result + dp[k][i][j]) % MOD return result"},{"question":"Suppose you are given a **0-indexed** integer array `nums`. Your task is to determine if you can rearrange the elements of `nums` to form an array of **rounds**. A **round** is formed by starting from the first element of the rearranged array, moving to the second, and so on until you reach the last element, where you then return to the first without repeating any elements. Specifically, for an array to be divided into rounds of each element having sum `s`, it must hold that each element `nums[i]` plus its subsequent unique element should be equal to `s` (wrap around to the start if necessary), and all elements must be used. Return `true` if you can arrange `nums` into such rounds, and `false` otherwise. For example, if `nums = [2, 3, 6, 5, 1, 4]`, you can rearrange it to `[1, 6, 4, 3, 2, 5]` where each pair sums up to 7.","solution":"def can_form_rounds(nums): Check if the array can be rearranged into rounds where each pair sums up to a constant value. total_sum = sum(nums) n = len(nums) if total_sum % (n // 2) != 0: return False target_sum = total_sum // (n // 2) nums.sort() used = [False] * n for i in range(n): if used[i]: continue found_pair = False for j in range(i + 1, n): if not used[j] and nums[i] + nums[j] == target_sum: used[i] = used[j] = True found_pair = True break if not found_pair: return False return True"},{"question":"You are given two strings `word1` and `word2`. You want to construct a string `target` from `word1` and `word2` by alternating the characters starting with the first character of `word1`, then the first character of `word2`, then the second character of `word1`, then the second character of `word2`, and so on. If one of the strings is shorter than the other, append the rest of the characters of the longer string to the target at the end. Return the resulting `target` string.","solution":"def merge_alternate(word1, word2): Constructs a string by alternating characters from `word1` and `word2`. If one string is shorter, append the rest of the longer string at the end. Parameters: word1 (str): The first string. word2 (str): The second string. Returns: str: The resulting merged string. target = [] len1, len2 = len(word1), len(word2) for i in range(max(len1, len2)): if i < len1: target.append(word1[i]) if i < len2: target.append(word2[i]) return \'\'.join(target)"},{"question":"You are given an integer array `nums` of length `n` representing the daily temperatures. The temperature on day `i` is `nums[i]`. You need to compute an array `result` such that `result[i]` is the number of days you have to wait after the `i-th` day to get a warmer temperature. If there is no future day for which this is possible, keep `result[i]` as `0`. * For example, given the list `nums = [73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`. Implement the function `dailyTemperatures`: * `def dailyTemperatures(nums: List[int]) -> List[int]` : This function takes an integer array `nums` and returns an array `result` where for each day `i`, `result[i]` is the number of days until a warmer temperature.","solution":"from typing import List def dailyTemperatures(nums: List[int]) -> List[int]: Given a list of daily temperatures, returns a list of days you have to wait until a warmer temperature. If there is no future day with warmer temperature, returns 0 for that day. n = len(nums) result = [0] * n stack = [] # stores indices of \'nums\' elements for i in range(n): while stack and nums[i] > nums[stack[-1]]: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"You are given a list of `n` pairs of non-negative integers as `coordinates`, where `coordinates[i] = [x, y]` represents the coordinates of a point on a 2D plane. A point `(x1, y1)` is said to be reachable from another point `(x2, y2)` if one can move horizontally or vertically without crossing any point in the list. Formally, for two points to be connected, either the x-coordinates must be the same (direct vertical move) or the y-coordinates must be the same (direct horizontal move). The reachability relationship is transitive, meaning if point A can reach point B, and point B can reach point C, then point A can reach point C. Determine the number of distinct connected groups formed by the points.","solution":"def findNumberOfGroups(coordinates): Finds the number of distinct connected groups formed by the points. from collections import defaultdict def dfs(point, visited, graph): stack = [point] while stack: current = stack.pop() visited.add(current) for neighbor in graph[current]: if neighbor not in visited: stack.append(neighbor) graph = defaultdict(list) for i, (x1, y1) in enumerate(coordinates): for j, (x2, y2) in enumerate(coordinates): if i != j and (x1 == x2 or y1 == y2): graph[(x1, y1)].append((x2, y2)) graph[(x2, y2)].append((x1, y1)) visited = set() count = 0 for point in coordinates: if tuple(point) not in visited: dfs(tuple(point), visited, graph) count += 1 return count"},{"question":"You are given an integer array `weights` where `weights[i]` represents the weight of the `i-th` item and a positive integer `maxWeight` representing the maximum weight capacity of a container. You need to determine if it is possible to select a subset of the items such that their total weight is exactly `maxWeight`. Return `true` if there exists such a subset, otherwise return `false`.","solution":"def can_form_exact_weight(weights, maxWeight): Determines if a subset of weights sums up to exactly maxWeight. :param weights: List of integers representing weights of items. :param maxWeight: An integer representing the maximum weight capacity. :return: A boolean indicating whether a subset with sum exactly equal to maxWeight exists. n = len(weights) dp = [False] * (maxWeight + 1) dp[0] = True # We can always form a sum of 0 with an empty set. for weight in weights: for j in range(maxWeight, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] return dp[maxWeight]"},{"question":"You are given a string `s` which represents a file containing words separated by spaces, and another string `substring`. You need to check if there exists a word in `s` that contains the given substring as a prefix. Implement the function `bool containsPrefix(s, substring)` that returns `true` if there is a word in `s` that starts with the given `substring` and `false` otherwise.","solution":"def containsPrefix(s, substring): Returns True if any word in the string `s` starts with the given `substring`, otherwise returns False. words = s.split() for word in words: if word.startswith(substring): return True return False"},{"question":"You are given an array `heights` representing the heights of students standing in a line. Each index of `heights` corresponds to a unique student. A line is considered sorted in \\"non-decreasing order\\" if for every pair of indices `i` and `j` (where `i < j`), `heights[i] <= heights[j]`. You need to determine the minimum number of students that need to be moved to a different position so the line becomes sorted in non-decreasing order. Return this minimum number of moves.","solution":"def min_students_to_move(heights): Calculate the minimum number of students to move to make the heights non-decreasing. :param heights: List[int], list of heights of the students :return: int, minimum number of students that need to be moved sorted_heights = sorted(heights) moves = sum(1 for i in range(len(heights)) if heights[i] != sorted_heights[i]) return moves"},{"question":"Given a list of integers `nums` representing the positions of markers on a number line, and an integer `k`, determine the minimum number of additional markers needed such that every pair of consecutive markers has a gap of at most `k` units. Markers can only be placed at integer positions. Return the minimum number of additional markers required.","solution":"def min_additional_markers(nums, k): Given a list of integers `nums` representing the positions of markers on a number line, and an integer `k`, determine the minimum number of additional markers needed such that every pair of consecutive markers has a gap of at most `k` units. Markers can only be placed at integer positions. Return the minimum number of additional markers required. # Sort the list to ensure the markers are in increasing order nums.sort() additional_markers_needed = 0 # Iterate through the pairs of consecutive markers for i in range(1, len(nums)): gap = nums[i] - nums[i-1] if gap > k: # Calculate the number of markers needed in between additional_markers_needed += (gap - 1) // k return additional_markers_needed"},{"question":"You are given a string `str` consisting of lowercase English letters. You can swap any two characters in the string any number of times. Your task is to determine the number of distinct permutations of the given string that result in a valid palindrome. A string is considered a valid palindrome if it reads the same backward as forward. Return the number of distinct palindromic permutations of `str`.","solution":"from collections import Counter from math import factorial def palindromic_permutations_count(s): # Count frequency of each character in the string char_count = Counter(s) # Count how many characters have odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If more than one characters have odd frequencies, no palindromic permutation is possible if odd_count > 1: return 0 # Half counts of characters (for half of the palindrome) half_count = [count // 2 for count in char_count.values()] # Calculate the total permutations of the half string half_permutations_count = factorial(sum(half_count)) # Divide by factorial of each half character\'s count to account for duplicates for count in half_count: if count > 1: half_permutations_count //= factorial(count) return half_permutations_count"},{"question":"Write a function that takes as input a list of non-negative integers representing a binary number and returns the decimal integer it corresponds to. For example, the binary number `[1, 0, 1]` should be converted to the decimal number `5`. The list format will be such that the first item represents the most significant bit (MSB) and the last item represents the least significant bit (LSB).","solution":"def binary_to_decimal(binary_list): This function converts a binary number represented as a list of non-negative integers to its decimal equivalent. :param binary_list: List[int] - A list of 0s and 1s representing a binary number, with the most significant bit at the start. :return: int - The decimal equivalent of the binary number. decimal_number = 0 length = len(binary_list) for i in range(length): decimal_number += binary_list[i] * (2 ** (length - i - 1)) return decimal_number"},{"question":"A popular social media app allows users to post updates, and each update is given a unique ID starting from `0` and increasing sequentially. The platform also updates the view count for each post periodically. You are given a **0-indexed** 2D integer array `logs` where `logs[i] = [timei, postId, viewsi]` indicating that at `timei`, the view count of the post with `ID = postId` becomes `viewsi`. The logs are sorted by `timei`. Implement an algorithm that, given the `logs` array and an integer `targetPostId`, returns the maximum view count recorded for the post with `ID = targetPostId`.","solution":"def max_views(logs, targetPostId): Returns the maximum view count recorded for the post with ID = targetPostId. Args: logs (List[List[int]]): 2D list where each element is [timei, postId, viewsi]. targetPostId (int): The ID of the target post. Returns: int: The maximum view count recorded for the target post. max_view_count = 0 for log in logs: timei, postId, viewsi = log if postId == targetPostId: max_view_count = max(max_view_count, viewsi) return max_view_count"},{"question":"Given a list of integers `nums`, return the longest contiguous subarray such that every element in this subarray is unique. If there are multiple subarrays with the same maximum length, return the first one you encounter. Additionally, ensure the algorithm operates in linear time using efficient data structures.","solution":"def longest_unique_subarray(nums): Returns the longest contiguous subarray with all unique elements. if not nums: return [] element_index = {} start = 0 maxLength = 0 maxStart = 0 for i in range(len(nums)): if nums[i] in element_index and element_index[nums[i]] >= start: start = element_index[nums[i]] + 1 element_index[nums[i]] = i if i - start + 1 > maxLength: maxLength = i - start + 1 maxStart = start return nums[maxStart:maxStart + maxLength]"},{"question":"You are given a **0-indexed** integer array `earrings` where each element represents the price of an earring in a jewelry shop. You are tasked with finding the **maximum possible profit** you can achieve by buying one earring and then selling it at a higher price on a later day. Return the _maximum profit_ you can achieve. If no profit can be achieved, return `0`.","solution":"def max_profit(earrings): Returns the maximum profit that can be achieved by buying and selling earrings on different days. if not earrings or len(earrings) == 1: return 0 min_price = earrings[0] max_profit = 0 for price in earrings[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Given a binary tree where each node has a value `0` or `1`, calculate the **longest path** consisting of nodes with the same value. The path does not need to go through the root and the path can be either from one node to any of its descendants or across the tree horizontally. Return the length of the longest path that consists of nodes with the same value.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root): Function to calculate the longest path in a binary tree where each node has value 0 or 1 and all nodes in the path have the same value. Args: root (TreeNode): The root of the binary tree. Returns: int: The length of the longest path with the same value. def helper(node): if not node: return 0, 0 left_length, left_max = helper(node.left) right_length, right_max = helper(node.right) left_path = right_path = 0 if node.left and node.left.val == node.val: left_path = left_length + 1 if node.right and node.right.val == node.val: right_path = right_length + 1 max_path = max(left_max, right_max, left_path + right_path) return max(left_path, right_path), max_path _, result = helper(root) return result"},{"question":"You are given a string `s` representing a document containing lowercase English letters and punctuation marks. A word is a contiguous sequence of letters. Write a function to identify the k most frequent words in the document. If there are multiple words with the same frequency, return them in alphabetical order. You should return a list of words sorted first by their frequency and then lexicographically if frequencies are the same. Return _an array of the k most frequent words in the document_.","solution":"from collections import Counter import re def top_k_frequent_words(s, k): Identify the k most frequent words in the document. Args: s (str): the input string/document. k (int): the number of top frequent words to return. Returns: list: a list of the top k most frequent words. # Using regex to find all words words = re.findall(r\'b[a-z]+b\', s) # Count the frequency of each word word_count = Counter(words) # Sort words by frequency and then lexicographically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Get the top k frequent words top_k_words = [word for word, count in sorted_words[:k]] return top_k_words"},{"question":"Given a string `s` and an array of strings `words`, return the number of words in `words` that are subsequences of `s`. A **subsequence** of a string is a string that can be derived from another string by deleting some characters without changing the order of the remaining characters. [Question] 4: Given a string `s` and an array of strings `words`, return the number of words in `words` that are subsequences of `s`. A **subsequence** of a string is a string that can be derived from another string by deleting some characters without changing the order of the remaining characters.","solution":"def num_matching_subseq(s, words): Returns the number of words in `words` that are subsequences of `s`. def is_subsequence(word, s): it = iter(s) return all(char in it for char in word) return sum(is_subsequence(word, s) for word in words)"},{"question":"You are given a binary tree where each node represents a digit (0-9). The root of the tree is at level 1. For a given integer `k`, return _the sum of all the numbers formed by the paths from the root to the nodes at level `k`_. A path from the root to a node is formed by appending the digits of each node along the path. If there is no node at level `k`, return 0. The result may be large, so return it **modulo** `10^9 + 7`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_numbers_at_level_k(root, k): MOD = 10**9 + 7 def dfs(node, current_number, level): if not node: return 0 # Form the number from root to current node current_number = (current_number * 10 + node.val) % MOD if level == k: return current_number left_sum = dfs(node.left, current_number, level + 1) right_sum = dfs(node.right, current_number, level + 1) return (left_sum + right_sum) % MOD return dfs(root, 0, 1)"},{"question":"You are given two integer arrays `startTime` and `endTime` and an integer array `profit` where `startTime[i]` denotes the start time, `endTime[i]` denotes the end time, and `profit[i]` denotes the profit of the `i-th` job. You\'re also given an integer `maxJobs` which indicates the maximum number of non-overlapping jobs you can pick. A job is considered non-overlapping if its start time is not before the end time of any previously selected job. Write a function that returns the `maximum profit` you can achieve by selecting at most `maxJobs` non-overlapping jobs.","solution":"from typing import List from functools import lru_cache def maxProfit(startTime: List[int], endTime: List[int], profit: List[int], maxJobs: int) -> int: jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1]) @lru_cache(None) def dp(n: int, k: int) -> int: if k == 0 or n == 0: return 0 start, end, prof = jobs[n-1] idx = next((j for j in range(n-1, -1, -1) if jobs[j][1] <= start), -1) return max(dp(n-1, k), prof + dp(idx + 1, k - 1)) return dp(len(jobs), maxJobs)"},{"question":"Given a string `s` consisting of only the digits \'0\' and \'1\', return the _maximum number of non-overlapping substrings_ `s1, s2, ..., sk` such that each substring satisfies the condition that the number of \'0\'s is equal to the number of \'1\'s. Each substring should be a contiguous block within the string.","solution":"def max_non_overlapping_substrings(s): Returns the maximum number of non-overlapping substrings such that each substring has an equal number of \'0\'s and \'1\'s. count_0 = count_1 = 0 max_substrings = 0 for char in s: if char == \'0\': count_0 += 1 elif char == \'1\': count_1 += 1 if count_0 == count_1: max_substrings += 1 count_0 = count_1 = 0 return max_substrings"},{"question":"Given a binary tree, imagine you can place cameras on the tree nodes. Each camera can monitor its parent, itself, and its immediate children. Determine the minimum number of cameras needed to monitor all nodes in the tree. Implement a function `int minCameraCover(TreeNode root)` that returns the minimum number of cameras required.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minCameraCover(root: TreeNode) -> int: def dfs(node): if not node: return 0, 0, float(\'inf\') la, lb, lc = dfs(node.left) ra, rb, rc = dfs(node.right) a = lb + rb b = min(lc + min(rb, rc), rc + min(lb, lc)) c = 1 + min(la, lb, lc) + min(ra, rb, rc) return a, b, c return min(dfs(root)[1:])"},{"question":"You are managing a small airline reservation system. You are given an array `flights`, where each element is a tuple `(src, dst, price)` representing a flight from the city `src` to the city `dst` costing `price` dollars. You are also given an integer `src`, an integer `dst`, and an integer `k`, representing the starting city, the destination city, and the maximum number of stops you are allowed to make. Write a function that finds the cheapest price from `src` to `dst` with at most `k` stops. If there is no such route, return -1.","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(flights, src, dst, k): Finds the cheapest price from src to dst with at most k stops. graph = defaultdict(list) # Build the graph for u, v, price in flights: graph[u].append((v, price)) # Priority queue to get the cheapest flights first # (cost, current_city, current_stops) pq = [(0, src, 0)] # Dictionary to store the best result for each (city, stops) best = defaultdict(lambda: float(\'inf\')) best[(src, 0)] = 0 while pq: cost, u, stops = heapq.heappop(pq) # If we have reached the destination if u == dst: return cost # If number of stops is within limit if stops <= k: for v, price in graph[u]: new_cost = cost + price if new_cost < best[(v, stops + 1)]: best[(v, stops + 1)] = new_cost heapq.heappush(pq, (new_cost, v, stops + 1)) return -1"},{"question":"You are given two string arrays `word1` and `word2`. Each string array represents a sequence of words. Check if the two string arrays are equivalent. Two string arrays are considered equivalent if the concatenation of the words in `word1` is equal to the concatenation of the words in `word2`. Return `true` if the two string arrays are equivalent, and `false` otherwise. (Consider the following `word1` = [\\"ab\\", \\"c\\"] and `word2` = [\\"a\\", \\"bc\\"]. The concatenation of the words in `word1` is \\"abc\\" which is equal to the concatenation of the words in `word2`, which is also \\"abc\\". Therefore, the output should be `true`.)","solution":"def array_strings_are_equal(word1, word2): Returns True if the concatenation of the words in word1 is equal to the concatenation of the words in word2. return \'\'.join(word1) == \'\'.join(word2)"},{"question":"Write a function called `mergeSortedArrays` that takes two arguments `arr1` and `arr2`. These arguments are two sorted arrays containing integers. The function should return a new array that contains all the elements from `arr1` and `arr2` merged into a single sorted array. You should not use any built-in functions that directly solve the problem (e.g., no use of `sort` or similar functionality). For example: *mergeSortedArrays([1,3,5], [2,4,6]) should return [1,2,3,4,5,6]* *mergeSortedArrays([0,1], [2,3]) should return [0,1,2,3]*","solution":"def mergeSortedArrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: Merged sorted array. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"You are given two strings `s1` and `s2` of the same length consisting only of lowercase alphabetical characters. Your task is to determine if you can make `s1` equal to `s2` with exactly one move. In one move, you can swap any two characters in `s1`. Return `true` if it is possible to make `s1` equal to `s2` with exactly one swap, otherwise return `false`.","solution":"def can_be_equal_with_one_swap(s1, s2): Determines if s1 can be made equal to s2 with exactly one swap. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 can be made equal to s2 with exactly one swap, False otherwise. if s1 == s2: return False # Find the indices with different characters diff_indices = [i for i in range(len(s1)) if s1[i] != s2[i]] # If there are not exactly two differences, return False if len(diff_indices) != 2: return False i, j = diff_indices # Check if swapping the differing characters in s1 makes it equal to s2 return s1[i] == s2[j] and s1[j] == s2[i]"},{"question":"Given a list of `n` integers, divide the list into `m` consecutive subarrays such that the sum of each subarray is as balanced as possible. The goal is to minimize the difference between the sum of the largest subarray and the sum of the smallest subarray. Return the minimum possible difference between the largest and smallest subarray sums. **Example:** ```plaintext Input: nums = [7, 2, 5, 10, 8], m = 2 Output: 18 Explanation: There are two ways to divide this list into 2 subarrays. (1) [7, 2, 5] and [10, 8], with sums 14 and 18. (2) [7, 2, 5, 10] and [8], with sums 24 and 8. The smallest difference between the largest and smallest subarray sums is 18. ```","solution":"def splitArray(nums, m): def can_split(nums, m, mid): count = 1 total = 0 for num in nums: total += num if total > mid: total = num count += 1 if count > m: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"Given a 2D grid of characters and a word, return _whether the word exists in the grid_. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, consider the following grid: ```plaintext [ [\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\'] ] ``` - Given `word = \\"ABCCED\\"`, return `true`. - Given `word = \\"SEE\\"`, return `true`. - Given `word = \\"ABCB\\"`, return `false`.","solution":"def exist(board, word): Returns whether the word exists in the given 2D grid. if not board or not board[0] or not word: return False rows, cols = len(board), len(board[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[index]: return False temp, board[r][c] = board[r][c], \'#\' found = (dfs(r+1, c, index+1) or dfs(r-1, c, index+1) or dfs(r, c+1, index+1) or dfs(r, c-1, index+1)) board[r][c] = temp return found for i in range(rows): for j in range(cols): if board[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"Given a string `num` representing a large integer, add one to the integer and return the resulting number as a string. The string `num` consists of digits only and will not contain any leading zeroes. Return the _resultant integer as a string_.","solution":"def add_one(num: str) -> str: Adds one to the integer represented by the string num and returns the resulting number as a string. carry = 1 result = [] for digit in reversed(num): sum_val = int(digit) + carry result.append(str(sum_val % 10)) carry = sum_val // 10 if carry > 0: result.append(str(carry)) return \'\'.join(reversed(result))"},{"question":"Given a string `s` that contains only digits `0-9`, and an integer `k`, write a function to calculate the minimum possible number you can obtain by removing exactly `k` digits from the string `s`. The result should not contain any leading zeros unless the number is `0` itself. Implement the function `string removeKdigits(string s, int k)`.","solution":"def removeKdigits(s, k): Returns the minimum possible number by removing exactly k digits from the string s. stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If k is still greater than 0, remove the remaining digits from the end while k > 0: stack.pop() k -= 1 # Convert to string and remove leading zeros result = \'\'.join(stack).lstrip(\'0\') return result if result else \\"0\\""},{"question":"Given an integer array `nums`, return the smallest **positive integer** that does not exist in the array. The algorithm should run in **O(n)** time and use **constant extra space**.","solution":"def first_missing_positive(nums): Returns the smallest positive integer that does not exist in the given array. The algorithm runs in O(n) time and uses constant extra space. n = len(nums) # Place each number in its right place for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first number not in the correct place for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"You are given an array of integers `arr` and an integer `limit`. Your task is to implement the function `minSubArrayLen` which finds the minimal length of a contiguous subarray of which the sum is greater than or equal to `limit`. If there is no such subarray, return `0` instead. The function should return an integer representing the length of the smallest such subarray. Implement the `Solution` class: * `Solution(int[] arr, int limit)` initializes the object with the integer array `arr` and the integer `limit`. * `minSubArrayLen()` returns the length of the minimal subarray with sum >= `limit`, or `0` if no such subarray exists. For example, given `arr = [2,3,1,2,4,3]` and `limit = 7`, your function should return `2` because the subarray `[4,3]` has the minimal length under the problem constraint.","solution":"class Solution: def __init__(self, arr, limit): self.arr = arr self.limit = limit def minSubArrayLen(self): Returns the minimal length of a contiguous subarray of which the sum is greater than or equal to limit. If no such subarray exists, returns 0. n = len(self.arr) left = 0 curr_sum = 0 min_len = float(\'inf\') for right in range(n): curr_sum += self.arr[right] while curr_sum >= self.limit: min_len = min(min_len, right - left + 1) curr_sum -= self.arr[left] left += 1 return min_len if min_len != float(\'inf\') else 0"},{"question":"Given an integer array `nums` of length `n`, where all integers are in the range from `1` to `n` inclusive, and some elements appear twice while others appear once, find all the integers that appear twice. Return the result as an array of integers.","solution":"def find_duplicates(nums): Find all integers that appear twice in the array. :param nums: List[int], an array of integers where integers are in the range from 1 to n inclusive :return: List[int], an array of integers that appear twice duplicates = [] for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] < 0: duplicates.append(index + 1) nums[index] = -nums[index] return duplicates"},{"question":"You are given an integer array `nums` sorted in ascending order. Return the number of unique combinations of three integers in the array that sum up to a target value `target`. Each combination should be unique, and the order of the integers in the combination does not matter. If there are no such combinations, return `0`.","solution":"def three_sum(nums, target): Returns the number of unique combinations of three integers in the array that sum up to the target value. :param nums: List[int] - The input array of integers sorted in ascending order. :param target: int - The target sum. :return: int - Number of unique combinations. nums.sort() n = len(nums) unique_combinations = set() for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # avoid duplicate combinations left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: unique_combinations.add((nums[i], nums[left], nums[right])) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return len(unique_combinations)"},{"question":"You are given a string `s` and an integer `k`. The string `s` consists of lowercase English letters. Your task is to divide string `s` into exactly `k` non-empty subsequences such that each subsequence is sorted in non-decreasing order. Return `true` if it is possible to split the string in such a manner, and `false` otherwise. Note that a subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def can_be_divided_in_k_subsequences(s, k): Returns true if string s can be divided into exactly k non-empty subsequences such that each subsequence is sorted in non-decreasing order, false otherwise. # Edge case: if k is greater than the number of distinct characters in s, it is impossible if k > len(set(s)): return False return True"},{"question":"You are given a string consisting of lowercase alphabets and an integer `k`. Your task is to rearrange the characters of the string such that any two adjacent characters are not the same. If it is not possible to rearrange the characters under this constraint, return an empty string. Otherwise, return the rearranged string. If there are multiple valid solutions, return any of them.","solution":"import heapq from collections import Counter def rearrange_string(s, k): if not s: return \\"\\" # Calculate frequencies of each character counter = Counter(s) # Create a max-heap using negative frequencies maxHeap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(maxHeap) result = [] # Queue to store characters with pending positions queue = [] while maxHeap: freq, char = heapq.heappop(maxHeap) result.append(char) queue.append((freq + 1, char)) # Make sure we have k positions between the same character if len(queue) < k: continue prev_freq, prev_char = queue.pop(0) if prev_freq < 0: heapq.heappush(maxHeap, (prev_freq, prev_char)) return \\"\\".join(result) if len(result) == len(s) else \\"\\""},{"question":"You are given a string `expression` that includes numbers, `+`, `-`, `*`, `/`, and parentheses `(` and `)` representing an arithmetic expression. Implement a function to evaluate the expression and return its value, ensuring that the operator precedence is correctly followed. The expression is guaranteed to be valid, and all intermediate calculations will fit within the range of a 32-bit signed integer.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression given as a string and returns its integer result. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # Use int() for truncating towards zero def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] in \'+-*/\': while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"Given an array of integers `nums`, return the sum of all its elements except the largest one. If the array contains only one element, return `0`. Implement a function that efficiently handles both small and large arrays while maintaining readability and performance.","solution":"def sum_except_largest(nums): Returns the sum of all elements in the array except the largest one. If the array contains only one element, return 0. if len(nums) == 1: return 0 largest = max(nums) return sum(nums) - largest"},{"question":"Given a binary tree, return the postorder traversal of its nodes\' values. You must solve it without using recursion and must implement the solution using an iterative approach.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root): Returns the postorder traversal of a binary tree\'s nodes\' values using an iterative approach. if not root: return [] stack, result = [root], [] while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1] # reverse the result to get correct postorder"},{"question":"You are given a **0-indexed** integer array `nums` of distinct integers. Consider the following operation: 1. Choose an index `i` and an index `j` such that `0 <= i < j < nums.length`. 2. Swap the values of `nums[i]` and `nums[j]`. Return _the minimum number of such operations required_ to make the array sorted in **non-decreasing** order.","solution":"def minSwapsToSort(nums): Returns the minimum number of swaps to sort the array in non-decreasing order. # Create a list of tuples where each tuple is (value, index) arr_with_index = [(num, i) for i, num in enumerate(nums)] # Sort the tuples based on the values arr_with_index.sort() vis = [False] * len(nums) # Visited array to mark visited elements swaps = 0 for i in range(len(nums)): # If element is already visited or is already in the correct position if vis[i] or arr_with_index[i][1] == i: continue # Initialize cycle cycle_size = 0 x = i while not vis[x]: vis[x] = True next_index = arr_with_index[x][1] x = next_index cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"Given an integer array `arr` and an integer `sum`, determine _the number of unique pairs of elements in the array that add up to_ `sum`. A pair is considered unique if no elements are reused.","solution":"def count_unique_pairs(arr, target_sum): Returns the number of unique pairs of elements in the array that add up to target_sum. seen = set() pairs = set() for num in arr: complement = target_sum - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. A linked list is defined as a structure where each node has a value and a reference to the next node. The last node references a null value indicating the end of the list. The function should identify the middle node using a fast and slow pointer technique, ensuring efficient traversal of the nodes in a single pass.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def middleNode(head: ListNode) -> ListNode: Returns the middle node of the linked list. If there are two middle nodes, return the second middle node. Uses the fast and slow pointer technique. slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow"},{"question":"There is a list of `tasks` where each task is represented as an interval `[work, end]`, with `work` representing the amount of work needed to complete the task, and `end` representing the deadline by which the task must be completed. You need to design an algorithm that selects the maximum number of tasks that can be completed without exceeding their respective deadlines. Implement the `TaskScheduler` class: * `TaskScheduler(int[][] tasks)` Initializes the object with the list of `tasks`. * `int maximumTasks()` Returns the maximum number of tasks that can be completed without exceeding their respective deadlines.","solution":"from typing import List class TaskScheduler: def __init__(self, tasks: List[List[int]]): self.tasks = tasks def maximumTasks(self) -> int: # Sort tasks by their end time self.tasks.sort(key=lambda x: x[1]) time = 0 count = 0 for work, end in self.tasks: if time + work <= end: count += 1 time += work return count"},{"question":"You are given an integer array `heights` representing the heights of `n` buildings in a row. The buildings are perfect rectangles aligned at the base and each building has a width of 1. Compute the maximum rectangular area that can be formed by choosing any subset of consecutive buildings. Return an integer representing this maximum area. For example, given the array `heights = [2,1,5,6,2,3]`, the largest rectangle achievable has an area of 10.","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed using consecutive buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an array of n non-negative integers representing the amount of rainwater trapped in each block, where the width of each block is 1. Write a function to compute the total amount of water trapped, taking into account the elevation map defined by the array. The function should return an integer representing the total units of trapped water.","solution":"def trap(height): Calculate the total amount of trapped rainwater given the elevation map. Parameters: height (list of int): A list of non-negative integers representing the elevation map. Returns: int: The total units of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate total trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"You are given an array of integers `arr` and an integer `k`. You need to determine if there are two distinct indices `i` and `j` in the array such that `arr[i] * arr[j]` is divisible by `k`. Return `true` if such a pair exists, and `false` otherwise.","solution":"def has_divisible_pair(arr, k): Determines if there are two distinct indices i and j in the array such that arr[i] * arr[j] is divisible by k. Args: arr: List[int] - list of integers. k: int - the integer divisor. Returns: bool - True if such a pair exists, False otherwise. # Iterate through each pair of indices for i in range(len(arr)): for j in range(i + 1, len(arr)): if (arr[i] * arr[j]) % k == 0: return True return False"},{"question":"A string `s` is a **valid parenthesis string** if it is an empty string, or it can be written as `AB` (where `A` and `B` are valid parenthesis strings), or it can be written as `(A)` (where `A` is a valid parenthesis string). Given a string `s`, provide the minimum number of parentheses that need to be added to make `s` a valid parenthesis string. Return the minimum number of parentheses to be added.","solution":"def min_add_to_make_valid(s): Returns the minimum number of parentheses that need to be added to make \'s\' a valid parenthesis string. left_unbalanced = 0 right_unbalanced = 0 for char in s: if char == \'(\': left_unbalanced += 1 elif char == \')\': if left_unbalanced > 0: left_unbalanced -= 1 else: right_unbalanced += 1 return left_unbalanced + right_unbalanced"},{"question":"You are given two strings `s` and `goal`. A \\"swap\\" operation involves taking any two indices in the string `s` and swapping the characters at these indices. Return **true** if and only if you can generate the string `goal` from the string `s` using **at most one swap operation**.","solution":"def can_be_equal_with_one_swap(s, goal): Determines if the string `goal` can be obtained by swapping at most once in the string `s`. if len(s) != len(goal): return False # If the strings are already equal, no swaps are needed. if s == goal: return True # To collect indices where characters differ. diff_indices = [] # Find all differing positions. for i in range(len(s)): if s[i] != goal[i]: diff_indices.append(i) # Check if we can make goal with one swap. if len(diff_indices) == 2: i, j = diff_indices # Swap the characters in s. swapped_s = list(s) swapped_s[i], swapped_s[j] = swapped_s[j], swapped_s[i] return \'\'.join(swapped_s) == goal # If there are not exactly 2 differences, one swap won\'t fix it. return len(diff_indices) == 0"},{"question":"Given an array of integers representing daily temperatures, return an array of integers where the value at each index represents the number of days until a warmer temperature. If there is no future day with a warmer temperature, the value should be 0. You may assume that the temperature values are unique.","solution":"def daily_temperatures(temperatures): Given an array of integers representing daily temperatures, return an array where each value indicates the number of days until a warmer temperature. If there is no future day with a warmer temperature, the value is 0. Parameters: temperatures (List[int]): List of daily temperatures. Returns: List[int]: List of days until a warmer temperature or 0 if no warmer temperature is found. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() result[idx] = i - idx stack.append(i) return result"},{"question":"Given a string `s`, implement a function to check whether it is a valid **parentheses string**. A valid parentheses string is defined as: * An empty string is valid. * Any string in the form \\"(A)\\" is valid, where A is a valid parentheses string. * Any string in the form \\"AB\\" is valid, where A and B are valid parentheses strings. The function should return `true` if the string is a valid parentheses string, otherwise it should return `false`. Example: ```python isValidParentheses(\\"()\\") -> True isValidParentheses(\\"(())\\") -> True isValidParentheses(\\"()()\\") -> True isValidParentheses(\\"(()\\") -> False ```","solution":"def isValidParentheses(s: str) -> bool: Checks if the given string is a valid parentheses string. Args: s: A string consisting only of characters \'(\' and \')\'. Returns: bool: True if the input string is valid, otherwise False. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"There is a robot on an `m x n` grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m-1][n-1]). The robot can only move either down or right at any point in time. The grid can have obstacles, where some cells are marked as blocked (denoted by `1`) and others as free (denoted by `0`). Write a function `uniquePathsWithObstacles(grid: List[List[int]]) -> int` that returns the number of possible unique paths that the robot can take to reach the bottom-right corner of the grid. If there is no way for the robot to reach the destination, return `0`.","solution":"def uniquePathsWithObstacles(grid): m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are working on an application that manages booking of rooms for events within a hotel. Each room booking is given as a tuple of `(room_id, start_time, end_time)`, where `start_time` and `end_time` are given in hours, and the room is available for booking for the full hour specified. Implement the `HotelBookingSystem` class to manage the bookings. The system should support the following functionalities: * **Book**: Books a room for a given time period if the room is available. If the room is already booked during any part of the specified period, the booking should be rejected. * **Cancel**: Cancels a previously booked room for a given time period. * **GetAvailableRooms**: Returns a list of room_ids that are available for booking during a specified time period. Implement the `HotelBookingSystem` class: * `HotelBookingSystem(int numberOfRooms)` Initializes the `HotelBookingSystem` object with the specified number of rooms. * `bool book(int room_id, int start_time, int end_time)` Books the room with the specified `room_id` from `start_time` to `end_time`. Returns `true` if the booking is successful, and `false` otherwise. * `void cancel(int room_id, int start_time, int end_time)` Cancels the booking of the room with the specified `room_id` from `start_time` to `end_time`. * `List<Integer> getAvailableRooms(int start_time, int end_time)` Returns a list of room_ids that are available for booking from `start_time` to `end_time` as described above. If no rooms are available, return an empty list.","solution":"class HotelBookingSystem: def __init__(self, numberOfRooms): Initializes the HotelBookingSystem with the specified number of rooms. Each room\'s booking schedule is stored in a dictionary with room_id as key and list of booked times as value. self.room_bookings = {i: [] for i in range(numberOfRooms)} def book(self, room_id, start_time, end_time): Books the room with the specified room_id from start_time to end_time. Args: room_id (int): The ID of the room to be booked. start_time (int): The start time of the booking. end_time (int): The end time of the booking. Returns: bool: True if the booking is successful, False otherwise. for (start, end) in self.room_bookings[room_id]: if start_time < end and end_time > start: # Overlaps with existing booking return False # No overlap, safe to book self.room_bookings[room_id].append((start_time, end_time)) return True def cancel(self, room_id, start_time, end_time): Cancels the booking of the room with the specified room_id from start_time to end_time. Args: room_id (int): The ID of the room booking to be cancelled. start_time (int): The start time of the booking to be cancelled. end_time (int): The end time of the booking to be cancelled. if (start_time, end_time) in self.room_bookings[room_id]: self.room_bookings[room_id].remove((start_time, end_time)) def getAvailableRooms(self, start_time, end_time): Returns a list of room_ids that are available for booking from start_time to end_time. Args: start_time (int): The start time of the desired booking period. end_time (int): The end time of the desired booking period. Returns: List[int]: A list of room_ids that are available for the specified period. available_rooms = [] for room_id, bookings in self.room_bookings.items(): if all(start_time >= end or end_time <= start for start, end in bookings): available_rooms.append(room_id) return available_rooms"},{"question":"You are given a 2D grid of characters representing a word search game board and a word. Write a function that determines if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Return `true` if the word exists in the grid, and `false` otherwise. It should follow this structure: ``` boolean exist(char[][] board, String word) ``` Your function should: - Take a character grid `board` and a string `word`. - Return a boolean indicating whether the word can be found in the grid according to the specified rules.","solution":"def exist(board, word): Determines if the word exists in the given 2D grid by checking sequentially adjacent cells. :param board: List[List[str]] - 2D grid of characters. :param word: str - The word to be found in the grid. :return: bool - True if the word exists in the grid, otherwise False. if not board or not word: return False rows, cols = len(board), len(board[0]) def backtrack(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[index]: return False temp = board[r][c] board[r][c] = \'#\' # Mark the cell as being visited # Explore the neighbors found = (backtrack(r + 1, c, index + 1) or backtrack(r - 1, c, index + 1) or backtrack(r, c + 1, index + 1) or backtrack(r, c - 1, index + 1)) board[r][c] = temp # Restore the cell value return found for i in range(rows): for j in range(cols): if board[i][j] == word[0] and backtrack(i, j, 0): return True return False"},{"question":"You are given a string `s` and an array of pairs of indices in the string `pairs` where each `pairs[i] = [a, b]` represents a swap operation that can be performed on the characters at position `a` and `b`. Return the lexicographically smallest string that can be obtained by performing the swaps allowed. You can perform each swap any number of times. Implement the function `smallestString`: * `String smallestString(String s, List<List<Integer>> pairs)` where: * `s` is a string consisting of lowercase English letters. * `pairs` is a list of lists, where each list contains two integers representing indices in the string. Use union-find data structure to determine connected components and sort each component to achieve the smallest possible string configuration.","solution":"def smallestString(s, pairs): Returns the lexicographically smallest string that can be obtained by performing swaps allowed by pairs. :param s: str - The input string :param pairs: List[List[int]] - List of pairs of indices in the string where swaps can be performed :return: str - The lexicographically smallest string after performing swaps import collections # Union-Find (Disjoint Set Union) Helper Functions def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX n = len(s) parent = list(range(n)) # Perform union operations for each pair for a, b in pairs: union(a, b) # Group all characters by their connected component components = collections.defaultdict(list) for i in range(n): root = find(i) components[root].append(i) # For each component, sort the indices and corresponding characters sorted_s = list(s) for indices in components.values(): sorted_chars = sorted(s[i] for i in indices) for i, char in zip(sorted(indices), sorted_chars): sorted_s[i] = char return \'\'.join(sorted_s)"},{"question":"You are given a **positive** integer array `nums`. For each element `num` in the array, calculate the product of all elements in the array except `num` without using division. Return _an integer array_ `result` _where_ `result[i]` _is the product of all elements of_ `nums` _except_ `nums[i]`.","solution":"def product_except_self(nums): Given an array nums, return an array result where result[i] is the product of all elements in the array except nums[i]. length = len(nums) result = [1] * length # Calculate left product for each element left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate right product for each element and multiply it with the left product right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"You are given an integer array `cookies`, where each `cookie` represents the number of cookies in a jar, and an integer `children`, representing the number of children. You need to distribute all the cookies to the children such that each child gets exactly one jar. Return the _minimum possible unfairness_ of the distribution. Unfairness is measured by the difference between the highest and the lowest number of cookies given to any two children. If the number of children is greater than the number of jars, return `0`. If the number of jars is zero, return `-1`.","solution":"def distribute_cookies(cookies, children): Distribute cookies to children to achieve minimum unfairness. :param cookies: List of integers representing number of cookies in each jar :param children: Integer representing number of children :return: Integer, minimum possible unfairness or specific edge case values if not cookies: return -1 if children > len(cookies): return 0 cookies.sort() # sort the jars by number of cookies min_unfairness = float(\'inf\') for i in range(len(cookies) - children + 1): unfairness = cookies[i + children - 1] - cookies[i] min_unfairness = min(min_unfairness, unfairness) return min_unfairness"},{"question":"Given a list of `n` distinct strings, write a function that groups the anagrams together. An anagram is a word formed by rearranging the letters of another, such as `listen` formed from `silent`. The function should return a list of lists where each inner list contains strings that are anagrams of each other. The order of the groups or the order within the groups does not matter. For example, given the input `[\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]`, your function should return `[ [\\"bat\\"], [\\"nat\\", \\"tan\\"], [\\"ate\\", \\"eat\\", \\"tea\\"] ]`. Your solution should have a time complexity of `O(n * k * log k)` where `n` is the number of strings and `k` is the maximum length of a string in the list.","solution":"def group_anagrams(strs): Groups anagrams from a list of strings. from collections import defaultdict anagrams = defaultdict(list) for s in strs: # Use sorted string as key key = \'\'.join(sorted(s)) anagrams[key].append(s) return list(anagrams.values())"},{"question":"You are given a string `s` consisting of lowercase English letters and a dictionary `wordList` containing a list of non-empty words. You need to find the length of the shortest transformation sequence from `s` to a word in `wordList`, such that only one letter can be changed at a time and each transformed word must exist in the wordList. Note that `s` does not need to be in `wordList`. If no such transformation sequence exists, return 0.","solution":"from collections import deque def shortest_transformation_length(s, wordList): Returns the length of the shortest transformation sequence from s to a word in wordList. If no transformation sequence exists, returns 0. wordSet = set(wordList) if not wordSet or s in wordSet: return 0 queue = deque([(s, 1)]) # (current_word, current_sequence_length) while queue: current_word, current_length = queue.popleft() for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': if c != current_word[i]: next_word = current_word[:i] + c + current_word[i + 1:] if next_word in wordSet: return current_length + 1 if next_word not in wordSet: continue queue.append((next_word, current_length + 1)) wordSet.remove(next_word) return 0"},{"question":"You are given an unsorted list of unique integers `arr` and a target integer `target`. Your task is to find whether there exist two integers in the list whose sum is equal to the target. If such a pair exists, return `true`; otherwise, return `false`. You must aim to implement this with an optimized time complexity.","solution":"def has_pair_with_sum(arr, target): Returns True if there are two numbers in arr that add up to target, otherwise False. seen_numbers = set() for number in arr: complement = target - number if complement in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"Given a list of integers `heights` representing the heights of a series of buildings standing in a row, return _the maximum number of buildings you can see looking from left to right_. A building is visible if there are no taller buildings in between. For example, with heights `[2, 4, 3, 1, 5]`, looking from left, you can see the buildings with heights `2, 4, and 5`.","solution":"def max_visible_buildings(heights): Returns the maximum number of buildings visible from left to right. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The maximum number of buildings visible from left to right. max_height = 0 visible_count = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given a binary tree in which each node contains an integer value. Design an algorithm that returns the sum of the node values that are at the maximum depth of the tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. If the tree is empty, return 0.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): if not root: return 0 from collections import deque queue = deque([(root, 0)]) max_depth = 0 current_sum = 0 while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth current_sum = node.val elif depth == max_depth: current_sum += node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return current_sum"},{"question":"Given a 0-indexed integer array `nums` and an integer `target`, return the **minimum number of operations** required to make the sum of all elements in the array equal to `target`. In one operation, you can **increment or decrement** any element of the array by 1. Each element can be modified independently. **Constraints**: - `1 <= nums.length <= 10^4` - `-10^6 <= nums[i], target <= 10^6`","solution":"def min_operations_to_target_sum(nums, target): Returns the minimum number of operations required to make the sum of all elements in the array `nums` equal to `target`. current_sum = sum(nums) return abs(current_sum - target)"},{"question":"Given a list of integers `nums`, return an integer representing the minimum number of moves required to make all elements equal. In each move, you can increment `n-1` elements by 1 (where `n` is the length of the list).","solution":"def min_moves(nums): Returns the minimum number of moves required to make all list elements equal. In one move, you can increment n-1 elements by 1. min_num = min(nums) return sum(num - min_num for num in nums)"},{"question":"Given an `n x n` matrix `grid` containing integers, where each integer represents the cost associated with visiting that cell, return the minimum cost to travel from the top-left cell to the bottom-right cell. You can only move right or down from a cell at any time. Each move incurs a cost equal to the value of the cell you move into. Assume all values in the grid are non-negative integers.","solution":"def minPathSum(grid): Given a 2D grid of non-negative integers, this function returns the minimum cost to travel from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. :param grid: List[List[int]] :return: int if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the first row by accumulating the cost moving right for c in range(1, cols): grid[0][c] += grid[0][c - 1] # Initialize the first column by accumulating the cost moving down for r in range(1, rows): grid[r][0] += grid[r - 1][0] # Start from (1, 1) and compute the minimum cost path for each cell for r in range(1, rows): for c in range(1, cols): grid[r][c] += min(grid[r - 1][c], grid[r][c - 1]) # The bottom-right cell contains the minimum cost to reach the end return grid[rows - 1][cols - 1]"},{"question":"You are given an integer array `arr` of length `n` and an integer `k`. Your task is to determine whether there exists a **subarray** of length `k` that is a permutation of the sequence `[1, 2, ..., k]`. Return `true` if such a subarray exists, and `false` otherwise. Implement the `PermutationSubarray` class: - `PermutationSubarray(int[] arr, int k)` Initializes the object with the array `arr` and the integer `k`. - `boolean containsPermutation()` Checks and returns whether there exists a subarray of length `k` that is a permutation of `[1, 2, ..., k]`. **Example:** ``` PermutationSubarray obj = new PermutationSubarray(new int[]{1, 2, 3, 4, 5}, 3); boolean result = obj.containsPermutation(); // returns true PermutationSubarray obj2 = new PermutationSubarray(new int[]{2, 3, 4, 5, 6}, 3); boolean result2 = obj2.containsPermutation(); // returns false ```","solution":"from collections import Counter class PermutationSubarray: def __init__(self, arr, k): self.arr = arr self.k = k def containsPermutation(self): n = len(self.arr) if n < self.k: return False target_count = Counter(range(1, self.k + 1)) for i in range(n - self.k + 1): window = self.arr[i:i + self.k] if Counter(window) == target_count: return True return False"},{"question":"Given an integer array `nums` and an integer `k`, implement a class that can efficiently return the **k most frequent elements** in the array. Implement the `FrequencyFinder` class: * `FrequencyFinder(int[] nums)` - Initializes the class with the given integer array `nums`. * `List<Integer> query(int k)` - Returns a list of `k` most frequent elements in the array `nums`. If there are multiple elements with the same frequency, sort them in ascending order. If `k` is more than the number of unique elements in the array, return all elements sorted by frequency and then by ascending order.","solution":"from collections import Counter from heapq import nlargest class FrequencyFinder: def __init__(self, nums): self.num_counts = Counter(nums) self.freq_list = None def query(self, k): if self.freq_list is None: # Create a sorted list of elements based on frequency and value self.freq_list = sorted(self.num_counts.items(), key=lambda x: (-x[1], x[0])) # Extract the k most frequent elements result = [item[0] for item in self.freq_list[:k]] return result"},{"question":"You are given an array of integers `arr` and an integer `k`. A contiguous subarray is defined as an interval `[i, j]` of `arr` where `0 <= i <= j < len(arr)`. We say a subarray `[i, j]` is **special** if the product of all the elements in this subarray is less than `k`. Return _the number of special subarrays in_ `arr`.","solution":"def num_special_subarrays(arr, k): Returns the number of special subarrays where the product of all the elements is less than `k`. if k <= 1: return 0 product = 1 result = 0 left = 0 for right, value in enumerate(arr): product *= value while product >= k: product //= arr[left] left += 1 result += right - left + 1 return result"},{"question":"You are given a string `expression` that contains a valid mathematical expression composed of non-negative integers and operators (`+`, `-`, `*`, `/`). The expression should be evaluated following the standard operator precedence (multiplication and division before addition and subtraction), but without any parentheses to change the order of operations. Note that the integer division should truncate toward zero. Return the result of the evaluated expression.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression composed of non-negative integers and operators (+, -, *, /). It follows the standard operator precedence without any parentheses. Integer division truncates toward zero. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # truncate toward zero operators, values = [], [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] in \'0123456789\': j = i while j < len(expression) and expression[j] in \'0123456789\': j += 1 values.append(int(expression[i:j])) i = j else: while (operators and operators[-1] in \\"*/\\" and expression[i] in \\"+-\\") or (operators and operators[-1] in \\"*/\\" and expression[i] in \\"*/\\"): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"A balanced string is a string that has the same number of characters \'L\' and \'R\'. A balanced string can be split into balanced substrings. The task is to count the number of balanced substrings that can be found within the given string. Given a string `s` containing only characters \'L\' and \'R\', write a function to return the maximum number of balanced substrings. For example, given `s = \\"RLRRLLRLRL\\"`, the function should return `4` since it can be split into `[\\"RL\\", \\"RRLL\\", \\"RL\\", \\"RL\\"]` which are all balanced substrings.","solution":"def balancedStringSplit(s): Returns the maximum number of balanced substrings within the given string. Parameters: s (str): A string containing only \'L\' and \'R\' characters. Returns: int: The maximum number of balanced substrings. count = 0 balance = 0 for char in s: if char == \'L\': balance += 1 else: balance -= 1 if balance == 0: count += 1 return count"},{"question":"Given a string `s` and a set of characters `chars`, return _the length of the longest **substring** of_ `s` _that contains only characters from_ `chars`_. If no such substring exists, return 0.","solution":"def longest_substring(s, chars): Returns the length of the longest substring of `s` that contains only characters from `chars`. Parameters: s (str): The input string. chars (set): The set of characters to include in the substring. Returns: int: Length of the longest valid substring, or 0 if no such substring exists. max_length = 0 current_length = 0 for char in s: if char in chars: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"A company\'s supply chain management system logs each shipment received in the inventory. Each shipment is recorded with a shipment ID represented as a string of **alphanumeric characters** and the time it was received represented as a string in the **24-hour \\"HH:MM\\"** format. You are tasked with analyzing the logs to detect possible fraudulent activities. Fraudulent activities are suspected if there is any shipment ID that appears **two or more times** within a **two-hour window**. Given two lists `shipmentID` and `shipmentTime`, where `[shipmentID[i], shipmentTime[i]]` represents the ID and time of the `i-th` shipment received, return a list of unique shipment IDs that are flagged for potential fraud. The list should be sorted in **ascending order**. Notice that the difference in time is calculated as the absolute difference, so a shipment received at `\\"01:00\\"` and another at `\\"02:59\\"` falls within the two-hour window, but `\\"01:00\\"` and `\\"03:01\\"` do not.","solution":"from datetime import datetime, timedelta from collections import defaultdict def detect_fraudulent_shipments(shipmentID, shipmentTime): Detect possible fraudulent activities based on shipment IDs appearing two or more times within a two-hour window. Parameters: shipmentID (List[str]): List of shipment IDs. shipmentTime (List[str]): List of shipment times in \\"HH:MM\\" format. Returns: List[str]: Sorted list of unique shipment IDs flagged for potential fraud. log = defaultdict(list) fraudulent_ids = set() # Convert shipment times to datetime objects for easy comparison shipment_times = [datetime.strptime(time, \\"%H:%M\\") for time in shipmentTime] for i in range(len(shipmentID)): current_id = shipmentID[i] current_time = shipment_times[i] if current_id in log: for previous_time in log[current_id]: # Check if time difference is within 2 hours if abs(current_time - previous_time) <= timedelta(hours=2): fraudulent_ids.add(current_id) break log[current_id].append(current_time) return sorted(list(fraudulent_ids))"},{"question":"You are given a list of strings `words` and a string `s`. Each string in `words` represents a pattern of dots and dashes (`.` and `-` respectively), and the string `s` contains only dots and dashes as well. The task is to find how many of the strings in `words` can be formed as subsequences of the string `s`. A subsequence of a string is obtained by deleting some (or none) of the characters without disturbing the relative positions of the remaining characters. Return _the number of `words` from the list that can be formed as subsequences of the string `s`_.","solution":"def is_subsequence(pattern, s): Helper function to check if a pattern is a subsequence of string `s`. it = iter(s) return all(char in it for char in pattern) def count_subsequences(words, s): Returns the count of words that are subsequences of string `s`. count = 0 for word in words: if is_subsequence(word, s): count += 1 return count"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a city. The city has a restricted plot of land on which to erect a new building. For aesthetic reasons, this new building must not exceed the height of buildings adjacent to it by more than a fixed margin, `k`. Formally, if the new building is placed between the buildings at indices `i-1` and `i`, its height `new_height` must satisfy: `heights[i-1] - k <= new_height <= heights[i] + k`. Your task is to determine the **maximum possible height** for the new building given the positions of the existing buildings and the restriction `k`. You are guaranteed that there is at least one valid position to place the new building based on the restriction. Return _the **maximum** height_ the new building can be constructed.","solution":"def max_possible_height(heights, k): Returns the maximum possible height for the new building. max_height = float(\'-inf\') for i in range(1, len(heights)): max_height = max(max_height, heights[i-1] + k, heights[i] + k) return max_height"},{"question":"You are given an unsorted array of integers `arr` and an integer `x`. Your task is to move all occurrences of `x` to the end of the array while maintaining the relative order of the other elements. Return the modified array after performing the operation.","solution":"def move_all_x_to_end(arr, x): Moves all occurrences of `x` to the end of the array `arr` while maintaining the relative order of the other elements. :param arr: List of integers :param x: Integer to move to the end :return: Modified array with all `x` moved to the end result = [element for element in arr if element != x] count_x = arr.count(x) result.extend([x] * count_x) return result"},{"question":"You are given a **0-indexed** integer array `heights` of length `n` representing the heights of columns in a histogram. Each column\'s width is `1`. You are asked to find the **largest rectangle** that can be formed under the histogram. You can choose to either: - Leave the array **unchanged** - Modify heights of **at most one** column to any positive integer value, including making it `0` Return the **maximum area** of the largest rectangle that can be formed after changing at most one column\'s height.","solution":"def largestRectangleArea(heights): Returns the maximum area of the largest rectangle in the histogram. stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) heights.pop() # Restore the list return max_area def maxAreaUnderModifiedHistogram(heights): Returns the maximum rectangle area that can be obtained by changing at most one column\'s height. # Calculate the max area without any modification original_max_area = largestRectangleArea(heights) # Get all the original heights original_heights = heights[:] # Try changing each column to zero and calculate the potential new maximum area modified_max_area = 0 for i in range(len(heights)): original_height = heights[i] # Set the height to zero and calculate the largest rectangle area heights[i] = 0 modified_max_area = max(modified_max_area, largestRectangleArea(heights)) # Restore the original height heights[i] = original_height return max(original_max_area, modified_max_area)"},{"question":"Implement a function `findAllAnagrams(s: str, p: str) -> List[int]` that finds all the start indices of `p`\'s anagrams in `s`. The function should return these indices in a list. The string `p` is the anagram pattern, and `s` is the string to be searched. An anagram is produced by rearranging the letters of a different word or phrase, using all the original letters exactly once. Each input string consists of lowercase letters only.","solution":"from collections import Counter from typing import List def findAllAnagrams(s: str, p: str) -> List[int]: Finds all start indices of p\'s anagrams in s. result = [] len_s, len_p = len(s), len(p) if len_s < len_p: return result # Create frequency counter for pattern p p_counter = Counter(p) # Initial window counter for the first window in s with the same length as p window_counter = Counter(s[:len_p]) if p_counter == window_counter: result.append(0) # Sliding window for i in range(len_p, len_s): # Include next character into the window window_counter[s[i]] += 1 # Exclude the oldest character from the window window_counter[s[i - len_p]] -= 1 # Remove the count from the counter if it turns to zero if window_counter[s[i - len_p]] == 0: del window_counter[s[i - len_p]] # Check if current window_counter matches p_counter if p_counter == window_counter: result.append(i - len_p + 1) return result"},{"question":"Given two strings, `s1` and `s2`, write a function to determine if `s2` is a rotation of `s1`, using only one call to a string manipulation method (e.g., substring, concatenation). Return `true` if `s2` is a rotation of `s1`, and `false` otherwise. For example, \\"waterbottle\\" is a rotation of \\"erbottlewat\\".","solution":"def is_rotation(s1, s2): Determine if s2 is a rotation of s1. Args: s1 (str): the original string s2 (str): the string to check if it is a rotation of s1 Returns: bool: True if s2 is a rotation of s1, False otherwise if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"A company wants to schedule meetings in a single conference room. Each meeting `i` is represented by a pair of integers `(start[i], end[i])`, indicating the starting and ending times of the meeting. You need to efficiently organize the meetings so that the maximum number of non-overlapping meetings can be scheduled. Two meetings `i` and `j` are non-overlapping if `end[i] <= start[j]` or `end[j] <= start[i]`. Given `n` meetings represented by two arrays `start` and `end`, return _the **maximum** number of non-overlapping meetings that can be scheduled in the conference room_.","solution":"def max_non_overlapping_meetings(start, end): Returns the maximum number of non-overlapping meetings that can be scheduled. :param start: List of integers, start times of the meetings :param end: List of integers, end times of the meetings :return: Integer, maximum number of non-overlapping meetings n = len(start) if n == 0: return 0 # Create pairs of (end[i], start[i]) meetings = list(zip(end, start)) # Sort the meetings by their end times meetings.sort() # The count of non-overlapping meetings and the end time of the last selected meeting count = 0 last_end_time = float(\'-inf\') for meeting in meetings: end_time, start_time = meeting if start_time >= last_end_time: count += 1 last_end_time = end_time return count"},{"question":"You are provided with a list of integers `nums` and an integer `target`. Your task is to determine if any three distinct integers in the list can be added together to equal the `target`. If such a combination exists, return `true`. Otherwise, return `false`.","solution":"def three_sum(nums, target): Determines if any three distinct integers in the list can be added together to equal the target. Args: nums (list of int): List of integers. target (int): The target sum. Returns: bool: True if such a combination exists, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Given an array of integers `nums`, determine the **number of reverse pairs** in the array. A **reverse pair** is a pair of indices `(i, j)` such that `0 <= i < j < nums.length` and `nums[i] > 2 * nums[j]`. Return the number of reverse pairs in the array.","solution":"def count_reverse_pairs(nums): Counts the number of reverse pairs in the array where nums[i] > 2 * nums[j] for 0 <= i < j < len(nums). :param nums: List[int] - The input list of integers :return: int - The number of reverse pairs if not nums: return 0 def merge_sort(nums, start, end): if start >= end: return 0 mid = (start + end) // 2 count = merge_sort(nums, start, mid) + merge_sort(nums, mid + 1, end) j = mid + 1 for i in range(start, mid + 1): while j <= end and nums[i] > 2 * nums[j]: j += 1 count += j - (mid + 1) nums[start:end + 1] = sorted(nums[start:end + 1]) return count return merge_sort(nums, 0, len(nums) - 1)"},{"question":"Given a string `s` consisting of lowercase alphabets, returns the shortest palindrome you can find by adding characters in front of `s`. A palindrome is a word that reads the same forwards and backwards. **Example:** - Input: \\"abcd\\" - Output: \\"dcbabcd\\"","solution":"def shortest_palindrome(s): Returns the shortest palindrome you can form by adding characters in front of the input string s. if not s: return s # Reverse of the string s rev_s = s[::-1] # Create a new string which is s + a special character not in s + reversed s new_s = s + \'#\' + rev_s # KMP table for the new string kmp = [0] * len(new_s) # Build KMP table for i in range(1, len(new_s)): j = kmp[i - 1] while j > 0 and new_s[i] != new_s[j]: j = kmp[j - 1] if new_s[i] == new_s[j]: j += 1 kmp[i] = j # The maximum suffix which is also prefix max_suffix_prefix = kmp[-1] # Add the remaining characters in the front return rev_s[: len(s) - max_suffix_prefix] + s"},{"question":"Given a linked list, `head`, which contains integer values, determine if the linked list has a cycle in it. To represent a cycle, some node in the linked list\'s next pointer might point to a previous node, making a loop. Implement the `hasCycle` function that returns `true` if there is a cycle in the linked list, otherwise, it returns `false`. The definition of the linked list node is provided as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Note: You must solve it using constant extra space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Determines if the linked list has a cycle. :param head: ListNode, the head of the linked list :return: bool, True if the list has a cycle, otherwise False if not head: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"Given a binary tree where each node contains an integer value, determine the value of the minimum path sum from the tree\'s root node to any leaf. A path sum is the sum of the values of all the nodes along a path from the root to a leaf. A leaf is a node with no children. Return the minimum path sum.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_path_sum(root): if not root: return float(\'inf\') if not root.left and not root.right: return root.val left_sum = min_path_sum(root.left) right_sum = min_path_sum(root.right) return root.val + min(left_sum, right_sum)"},{"question":"You are given an array `heights` representing the heights of buildings. Let\'s assume that a person can see the ocean if there are no taller buildings to the right of their current building. Write a function that returns an array of indices representing the buildings that can see the ocean. The buildings are considered from left to right, so a building at index `i` can see the ocean if there are no taller buildings to the right of `heights[i]`. Return _the indices of the buildings that can see the ocean in **non-decreasing** order_.","solution":"def buildings_with_ocean_view(heights): Returns an array of indices representing the buildings that can see the ocean. if not heights: return [] n = len(heights) result = [] max_height = float(\'-inf\') for i in reversed(range(n)): if heights[i] > max_height: result.append(i) max_height = heights[i] return sorted(result)"},{"question":"In a social network, people are represented by a 0-indexed integer array `popularity` where `popularity[i]` represents the popularity score of the i-th person. The social network allows friend connections to be formed between two people if and only if the absolute difference between their popularity scores is less than or equal to a given integer `k`. Determine the **total number of friend connections** that can be formed in the network. Note: Each connection is bidirectional, meaning if person `i` is friends with person `j`, then person `j` must be friends with person `i`. Also, a person cannot be friends with themselves.","solution":"def total_friend_connections(popularity, k): n = len(popularity) total_connections = 0 for i in range(n): for j in range(i + 1, n): if abs(popularity[i] - popularity[j]) <= k: total_connections += 1 return total_connections"},{"question":"You are given an array of integers `heights` representing the height of buildings along a street. Assume the street runs from left to right, and there is a viewer standing at the rightmost end of the street. Find the indices of the buildings that are visible to the viewer. A building is visible if all the buildings to its right have a smaller height. Return the indices of the visible buildings in a list, ordered from left to right.","solution":"def find_visible_buildings(heights): Returns the indices of the buildings that are visible to the viewer standing at the rightmost end of the street. n = len(heights) if n == 0: return [] visible_buildings = [] max_height = float(\'-inf\') for i in range(n-1, -1, -1): if heights[i] > max_height: visible_buildings.append(i) max_height = heights[i] visible_buildings.reverse() return visible_buildings"},{"question":"Given a string `s` which consists of lowercase letters, a **duplicate removal** operation will be performed on `s`. In each duplicate removal operation, select two adjacent and equal letters and remove them. The algorithm should repeatedly make duplicate removals on `s` until no adjacent equal letters remain. Return the final string after all such duplicate removals have been made. If the final string is empty, return an empty string.","solution":"def remove_duplicates(s): Function to remove adjacent duplicates in the string `s`. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"Given an array of integers `arr` and an integer `d`, you must choose `d` elements (not necessarily contiguous) from `arr` such that the difference between the maximum and minimum elements among these chosen `d` elements is minimized. Return the minimized difference between the maximum and minimum elements after choosing the `d` elements.","solution":"def minimize_difference(arr, d): Minimize the difference between the maximum and minimum of `d` elements chosen from `arr`. Parameters: arr (list of int): List of integers from which to choose. d (int): Number of elements to choose from the list. Returns: int: The minimized difference between the maximum and minimum of the chosen `d` elements. # Sort the array to enable finding the smallest range arr.sort() # Initialize the minimum difference to a large number min_diff = float(\'inf\') # Iterate through the sorted array and find the minimum range of `d` elements for i in range(len(arr) - d + 1): current_diff = arr[i + d - 1] - arr[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"You are given a linked list where each node contains an integer. You can perform the following operation any number of times on the linked list: * Reverse a sublist of the linked list which starts and ends at a node with an odd value. Your goal is to sort the linked list in **non-decreasing** order using the above operation. Return `true` if it is possible to sort the linked list using the reverse operation on sublists that start and end with odd values, or `false` otherwise.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def can_sort_linked_list(head): if not head: return True values = [] current = head while current: values.append(current.value) current = current.next sorted_values = sorted(values) return sorted_values == values or all(v % 2 == 0 for v in values)"},{"question":"You are given a string `s` consisting of only lowercase English letters. You need to count the number of substrings that start and end with the same character. A substring is a contiguous sequence of characters within a string. Given the string `s`, return the _number of substrings_ that start and end with the same character.","solution":"def count_substrings_same_start_end(s): Returns the number of substrings that start and end with the same character. Parameters: s (str): The input string consisting of only lowercase English letters. Returns: int: The number of substrings that start and end with the same character. # Dictionary to count occurrences of each character count_dict = {} # Fill the dictionary with the frequency of each character in s for char in s: if char not in count_dict: count_dict[char] = 0 count_dict[char] += 1 # Calculate the number of substrings that start and end with the same character # For each character with frequency `f`, number of such substrings is f * (f + 1) // 2 result = 0 for char in count_dict: f = count_dict[char] result += (f * (f + 1)) // 2 return result"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to determine if there exists a subarray of length `k` that is a permutation of the first `k` natural numbers. Return `true` if such a subarray exists and `false` otherwise.","solution":"def has_permutation_of_first_k_naturals(arr, k): Determines if there exists a subarray of length k that is a permutation of the first k natural numbers. :param arr: List of integers :param k: Integer representing the length and the first k natural numbers :return: Boolean, True if such subarray exists, False otherwise from collections import Counter if k > len(arr): return False target_counter = Counter(range(1, k + 1)) for i in range(len(arr) - k + 1): subarray = arr[i:i + k] if Counter(subarray) == target_counter: return True return False"},{"question":"You are given a list of non-negative integers representing the amount of time each task requires to be completed. Assuming you have an unlimited number of workers and each worker can only work on one task at a time, return the minimum amount of time required to finish all tasks if any worker can start another task as soon as they finish their current one.","solution":"def min_time_to_finish_tasks(task_times): Returns the minimum amount of time required to finish all tasks with unlimited workers. :param task_times: List of non-negative integers representing task times. :return: Minimum time required to complete all tasks. if not task_times: return 0 return max(task_times)"},{"question":"You are given a 2D integer matrix `matrix` where each cell contains either `0` (representing water) or `1` (representing land). Each cell is a perfect square with a side length of 1. Islands are formed by connecting adjacent lands horizontally or vertically, and you may assume that all four edges of the grid are surrounded by water. An island is considered completely surrounded if all the land within the island is entirely surrounded by water. Write a function to return _the **number** of completely surrounded islands_ in the given matrix.","solution":"def count_completely_surrounded_islands(matrix): def dfs(matrix, i, j, is_surrounded): if i < 0 or j < 0 or i >= len(matrix) or j >= len(matrix[0]): return False if matrix[i][j] == 0: return True if matrix[i][j] == -1: return True matrix[i][j] = -1 top = dfs(matrix, i - 1, j, is_surrounded) bottom = dfs(matrix, i + 1, j, is_surrounded) left = dfs(matrix, i, j - 1, is_surrounded) right = dfs(matrix, i, j + 1, is_surrounded) return top and bottom and left and right if not matrix or not matrix[0]: return 0 count = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1: if dfs(matrix, i, j, True): count += 1 return count"},{"question":"A palindrome is a string that reads the same backward as forward. Given a string `s`, you need to construct and return the shortest palindrome that you can form by adding characters in front of `s`. For example, if `s = \\"aacecaaa\\"`, the result should be `\\"aaacecaaa\\"`, and for `s = \\"abcd\\"`, the result should be `\\"dcbabcd\\"`. Write a function that takes a string `s` and returns the shortest palindrome that can be formed by adding characters in front of `s`.","solution":"def shortest_palindrome(s): Returns the shortest palindrome that can be formed by adding characters to the front of s. if not s: return s reverse_s = s[::-1] # Create a new string which is s + \\"#\\" + reversed s new_s = s + \\"#\\" + reverse_s # Create a temporary array for the KMP algorithm kmp_table = [0] * len(new_s) # KMP preprocessing to fill KMP table for i in range(1, len(new_s)): j = kmp_table[i - 1] while j > 0 and new_s[i] != new_s[j]: j = kmp_table[j - 1] if new_s[i] == new_s[j]: j += 1 kmp_table[i] = j # The length of the longest palindromic suffix longest_palindromic_suffix_length = kmp_table[-1] # Characters needed to be added in front to make the palindrome appended_part = reverse_s[:len(s) - longest_palindromic_suffix_length] return appended_part + s"},{"question":"You are given a string `input` containing a mix of lowercase English letters and digits. Define the **frequency beauty** of a string as the sum of the frequency of the most common character and the frequency of the least common character in the string. Write a function to return the frequency beauty of the string. If there are multiple characters with the same minimum or maximum frequency, consider their frequencies only once. Your function should also handle edge cases where the string is empty or contains only one unique character.","solution":"from collections import Counter def frequency_beauty(input_str): Returns the frequency beauty of the given string. The frequency beauty is defined as the sum of the frequency of the most common character and the frequency of the least common character. if not input_str: return 0 counter = Counter(input_str) frequencies = list(counter.values()) if len(frequencies) == 1: # if there is only one unique character, its frequency will be both max and min return frequencies[0] * 2 max_freq = max(frequencies) min_freq = min(frequencies) return max_freq + min_freq"},{"question":"Given an `m x n` binary matrix `mat`, return the largest rectangle containing only 1\'s and its area. Your answer will be an integer representing the area of the largest rectangle. Implement the function `maximalRectangle(List<List<Integer>> mat)` to solve the problem. Ensure your solution efficiently handles the potentially large size of the matrix.","solution":"def maximalRectangle(mat): if not mat: return 0 max_area = 0 n = len(mat[0]) heights = [0] * n for row in mat: for i in range(n): if row[i] == 0: heights[i] = 0 else: heights[i] += 1 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): heights.append(0) stack = [-1] max_area = 0 for i in range(len(heights)): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"You are given a binary tree in which each node contains an integer value. Implement a function `int maxZigZag(TreeNode root)` to find the length of the longest ZigZag path in the binary tree. A ZigZag path is defined as a sequence of nodes such that: - Each node in the sequence only moves to its child (left or right alternatively). - The path continues while alternating between left and right. For example, if you move from the root to its left child, the next move must be to the right child of the left child, and the next move after that must be to the left, and so on. The length of the ZigZag path is represented by the number of nodes in the path minus one. Return the maximum length of any ZigZag path in the given binary tree. Implement the `maxZigZag` function which takes `TreeNode` as input and returns an integer getting the maximum ZigZag path length.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxZigZag(root): def dfs(node, direction, length): nonlocal max_length if not node: return max_length = max(max_length, length) if direction == \'left\': dfs(node.left, \'right\', length + 1) dfs(node.right, \'left\', 1) else: dfs(node.right, \'left\', length + 1) dfs(node.left, \'right\', 1) max_length = 0 dfs(root, \'left\', 0) dfs(root, \'right\', 0) return max_length"},{"question":"A robot is placed on a grid with `m` rows and `n` columns. The robot is initially located at the top-left corner (i.e., `grid[0][0]`). The robot tries to move to the bottom-right corner (i.e., `grid[m-1][n-1]`). The robot can only move either down or right at any point in time. Write a function to count the number of unique paths that the robot can take to reach the bottom-right corner. Note that `m` and `n` will be at most 100.","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid with m rows and n columns. # Create a 2D array to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # Initialize the first row and first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform the following operation as many times as you want: choose a substring of `s` and rearrange the letters in it such that each letter appears at least once in contiguous blocks (e.g., `aa`, `bbb`). Your goal is to find the **minimum number of operations** needed such that no two letters in the string are adjacent to each other (i.e., all letters in the string become unique). Return _the minimum number of operations needed to achieve this goal_.","solution":"def min_operations_to_make_unique(s): Returns the minimum number of operations needed to make all characters in the string unique. :param s: The input string consisting of lowercase English letters :type s: str :return: The minimum number of operations needed :rtype: int from collections import Counter char_count = Counter(s) operations = 0 for count in char_count.values(): if count > 1: operations += count - 1 return operations"},{"question":"You are given the `head` of a singly linked list and an integer `k`. Split the linked list into `k` consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null if there are fewer nodes than parts. Return a list of `k` linked list parts. Each part should be a ListNode. For example, given the list 1 -> 2 -> 3 -> 4 -> 5 and k = 3, the linked list should be split into three parts: [1 -> 2], [3 -> 4], and [5]. (Note: The definition for singly linked list node can be as assumed in the format: `struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} };`)","solution":"class ListNode: def __init__(self, x=0, next=None): self.val = x self.next = next def splitListToParts(head, k): # First, find the length of the linked list length = 0 current = head while current is not None: length += 1 current = current.next # Determine the size of each part and the remainder part_size = length // k remainder = length % k result = [] current = head for i in range(k): part_head = current prev = None for j in range(part_size + (i < remainder)): prev = current current = current.next if current else None if prev: prev.next = None result.append(part_head) return result"},{"question":"You are given a binary matrix `grid` of size `m x n`. A cell `(r, c)` of `grid` is called **special** if and only if `grid[r][c]` is equal to `1` and all other cells in the row `r` and column `c` are `0`. Return _the number of **special** cells in the matrix_ `grid`.","solution":"def numSpecial(grid): Returns the number of special cells in the matrix grid. A cell (r, c) is special if: 1. grid[r][c] == 1 2. All other cells in row r and column c are 0. # Count the number of 1s in each row and each column row_count = [sum(row) for row in grid] col_count = [sum(col) for col in zip(*grid)] special_cells = 0 # Traverse each cell to find special cells for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1 and row_count[r] == 1 and col_count[c] == 1: special_cells += 1 return special_cells"},{"question":"Given a list of integers `nums`, a target integer `k`, and an integer `x`, return the `k` closest integers to `x` in the list `nums`. The result should also be sorted in ascending order. If there is a tie, prefer the smaller element.","solution":"def find_closest_elements(nums, k, x): Finds the k closest integers to x in the list nums. Parameters: nums (list of int): List of integers. k (int): Number of closest integers to find. x (int): Target integer. Returns: list of int: k closest integers to x, sorted in ascending order. nums.sort() # First, sort the list of numbers in ascending order. # Use a lambda function to sort nums by absolute difference from x, and in case of a tie, by the number itself. sorted_nums = sorted(nums, key=lambda num: (abs(num - x), num)) # Return the first k elements of the sorted list of closest elements. return sorted(sorted_nums[:k])"},{"question":"You are given a list of words `words` and a string `s`, find the number of words in the list that are subsequences of `s`. A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. Implement a function `numMatchingSubseq(s, words)` that returns the count of words in `words` that are subsequences of `s`. **Example:** ``` Input: s = \\"abcde\\", words = [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"] Output: 3 Explanation: \\"a\\", \\"acd\\", and \\"ace\\" are subsequences of \\"abcde\\". ```","solution":"def is_subsequence(s, word): Helper function to check if \'word\' is a subsequence of \'s\'. it = iter(s) return all(char in it for char in word) def numMatchingSubseq(s, words): Returns the number of words in the list that are subsequences of \'s\'. count = 0 for word in words: if is_subsequence(s, word): count += 1 return count"},{"question":"Given a **0-indexed** integer array `arr` representing the heights of buildings, and an integer `k`, return the length of the **longest** subarray where the difference between the maximum and minimum heights is less than or equal to `k`. A **subarray** is a contiguous non-empty sequence of elements within an array.","solution":"from collections import deque def longest_subarray_with_diff(arr, k): if not arr: return 0 max_len = 0 min_queue = deque() max_queue = deque() left = 0 for right in range(len(arr)): while min_queue and arr[min_queue[-1]] >= arr[right]: min_queue.pop() while max_queue and arr[max_queue[-1]] <= arr[right]: max_queue.pop() min_queue.append(right) max_queue.append(right) while arr[max_queue[0]] - arr[min_queue[0]] > k: left += 1 if min_queue[0] < left: min_queue.popleft() if max_queue[0] < left: max_queue.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given an integer array `nums` and an integer `threshold`. A **subarray** is a contiguous non-empty sequence of elements within an array. Your task is to find the length of the longest subarray such that the sum of its elements is less than or equal to `threshold`. If there are multiple subarrays with the same maximum length, return the count of such subarrays. Return an integer array where the first element is the length of the longest subarray and the second element is the count of such subarrays. For example, given `nums = [1, 2, 3, 4, 5]` and `threshold = 10`, the longest subarray length would be 4 (the subarray is `[1, 2, 3, 4]`) and the count would be 1.","solution":"def longest_subarray_less_than_threshold(nums, threshold): Finds the length of the longest subarray such that the sum of its elements is less than or equal to threshold, and counts how many such subarrays exist. :param nums: List of integers. :param threshold: Integer threshold. :return: List of two integers. The first is the length of the longest subarray, and the second is the count of such subarrays. n = len(nums) max_len = 0 count = 0 for start in range(n): current_sum = 0 for end in range(start, n): current_sum += nums[end] if current_sum > threshold: break subarray_len = end - start + 1 if subarray_len > max_len: max_len = subarray_len count = 1 elif subarray_len == max_len: count += 1 return [max_len, count]"},{"question":"You are given an undirected graph with `n` vertices and `m` edges. Each vertex is labeled from `0` to `n-1`. You need to check if the graph contains a cycle. If the graph contains a cycle, return `true`, otherwise return `false`. You must write an algorithm with less than `O(n^2)` runtime complexity.","solution":"def has_cycle(graph): Check if the undirected graph contains a cycle. Parameters: graph (dict): A dictionary where keys are node ids and values are lists of adjacent nodes. Returns: bool: True if the graph contains a cycle, False otherwise. def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: # Found a back edge (cycle) return True return False n = len(graph) visited = [False] * n for v in range(n): if not visited[v]: if dfs(v, -1): return True return False"},{"question":"Given an array `nums` of size `n`, where each element is between `1` and `n` inclusive, with no duplicates, except one repeated number, find the repeated number. You must solve this problem without modifying the input array and using only `O(1)` extra space.","solution":"def find_duplicate(nums): Finds the duplicate number in the given array nums. The array nums has n+1 integers where each integer is between 1 and n (inclusive), and only one number is repeated. :param nums: List[int] - The input list of integers :return: int - The duplicate number # Using the Floyd\'s Tortoise and Hare (Cycle Detection) algorithm tortoise = hare = nums[0] # Phase 1: Finding the intersection point while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break # Phase 2: Finding the entrance to the cycle (the duplicate number) tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare"},{"question":"You are given a `0-indexed` binary string `s` of length `n`. In one operation, you can choose any character of the string and flip it (i.e., change \'0\' to \'1\' or vice versa). Your goal is to make the string either all \'0\'s or all \'1\'s. Return the minimum number of operations needed to achieve this. For example, if `s = \\"0101\\"`, you can flip the second and fourth characters to get `\\"0000\\"`, which takes 2 operations. Alternatively, you could flip the first and third characters to get `\\"1111\\"`, also taking 2 operations. Both options are valid, and the answer is 2.","solution":"def min_flips(s): Returns the minimum number of flips needed to make the binary string s all 0\'s or all 1\'s. # Count the number of 0\'s and 1\'s in the string count_0 = s.count(\'0\') count_1 = s.count(\'1\') # The minimum flips would be to either convert all to 0\'s or all to 1\'s, so return the smaller count return min(count_0, count_1)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to rearrange the string such that any two **adjacent characters are not the same**. If it is not possible to rearrange the string in such a way, return an empty string. If there are multiple valid rearrangements, return any one of them. The resulting string\'s length should be exactly the same as the input string `s`. Use the integer `k` to define a constraint: No character should repeat within any span of `k` positions for the rearrangement to be valid. If it is possible to rearrange the string to satisfy the mentioned conditions, return the rearranged string. If it is not possible, return an empty string.","solution":"from collections import Counter, deque import heapq def rearrange_string(s, k): if k == 0: return s count = Counter(s) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((char, freq + 1)) if len(queue) >= k: front_char, front_freq = queue.popleft() if front_freq < 0: heapq.heappush(max_heap, (front_freq, front_char)) if len(result) == len(s): return \'\'.join(result) else: return \\"\\""},{"question":"You are given an integer array `heights` representing the heights of students standing in a line. A student can see the person in front of them if every person in between is shorter than both the student and the person they are looking at. Return the number of students who can see **at least one** other student standing in front of them.","solution":"def can_see_count(heights): Returns the number of students who can see at least one other student standing in front of them. A student can see the person in front of them if every person in between is shorter than both the student and the person they are looking at. count = 0 for i in range(len(heights) - 1): # no need to check the last student can_see = False max_height = heights[i] for j in range(i + 1, len(heights)): if heights[j] > max_height: can_see = True break max_height = max(max_height, heights[j]) if can_see: count += 1 return count"},{"question":"Given a binary tree, implement a class `BinaryTreeDiameter` that computes the diameter of the binary tree. The diameter of a binary tree is defined as the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. Implement the `BinaryTreeDiameter` class: * `BinaryTreeDiameter(TreeNode root)` Initializes the class with the root of the binary tree. * `int getDiameter()` Returns the diameter of the binary tree. Your code will be tested with the following pseudocode: initialize instance with root return instance.getDiameter() If the returned diameter matches the expected diameter, then your code will be judged as correct.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTreeDiameter: def __init__(self, root): self.root = root self.diameter = 0 def getDiameter(self): self.calculateDiameter(self.root) return self.diameter def calculateDiameter(self, node): if not node: return 0 left_height = self.calculateDiameter(node.left) right_height = self.calculateDiameter(node.right) # The diameter at the current node will be the sum of the heights of its left and right subtrees self.diameter = max(self.diameter, left_height + right_height) # The height of the current node will be the max height of its left or right subtree plus 1 (for the current node) return max(left_height, right_height) + 1"},{"question":"You are given a 2-dimensional list `tasks` where `tasks[i] = [start_i, end_i]` represents a task starting at time `start_i` and ending at time `end_i`. A person can attend two tasks if and only if the time intervals of the two tasks do not overlap with each other. Return _the maximum number of non-overlapping tasks a person can attend_.","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks. if not tasks: return 0 # Sort tasks based on their end time tasks.sort(key=lambda x: x[1]) count = 0 end_time = float(\'-inf\') for start, end in tasks: if start >= end_time: # If the current task starts after or when the last task ends count += 1 end_time = end return count"},{"question":"Given an integer array `nums`, you need to find the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to `limit`. Return _the length of the longest subarray that satisfies this condition_.","solution":"from collections import deque def longest_subarray(nums, limit): max_d = deque() min_d = deque() left = 0 max_len = 0 for right in range(len(nums)): while max_d and nums[max_d[-1]] <= nums[right]: max_d.pop() while min_d and nums[min_d[-1]] >= nums[right]: min_d.pop() max_d.append(right) min_d.append(right) while nums[max_d[0]] - nums[min_d[0]] > limit: left += 1 if max_d[0] < left: max_d.popleft() if min_d[0] < left: min_d.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a string `s` and a list of indices representing start positions of each word in `s`, you are to reverse the order of the words without changing the order of characters within each word. The start positions are given in a list `positions`. For example, given `s= \\"hello world\\"` and `positions = [0, 6]`, the output should be `s = \\"world hello\\"`. Note that the characters within each word remain in their original order, but the words themselves are reversed. Write a function that takes a string `s` and a list of integers `positions`, and returns a string with the words reversed as described. Your function should return the modified string.","solution":"def reverse_words(s, positions): Reverses the order of words in the string s as specified by the positions list. Args: s (str): The input string. positions (list): A list of start positions of each word in the input string. Returns: str: The string with the words reversed. words = [] for i, pos in enumerate(positions): if i + 1 < len(positions): words.append(s[pos:positions[i + 1] - 1].strip()) else: words.append(s[pos:].strip()) words.reverse() return \' \'.join(words)"},{"question":"You are given a **0-indexed** integer array `arr`. In one move, a player can select an index `i` and change `arr[i]` to any value between `arr[i] - k` and `arr[i] + k` (inclusive). The goal is to make all the array elements equal using the minimum number of moves. Return _the minimum number of moves needed to make all elements of `arr` equal_.","solution":"def min_moves_to_equal(arr, k): Returns the minimum number of moves needed to make all elements of arr equal with the allowed range k for each move. if not arr: return 0 # Find the maximum and minimum values in the array min_val = min(arr) max_val = max(arr) # Compute the possible target range to be all equal range_start = max_val - k range_end = min_val + k # If the valid range overlaps, return 0 moves (as they can all be made equal within the range) if range_start <= range_end: return 0 # Otherwise, it\'s not possible to make all elements equal within the given k range # as there is no common intersection range for all elements, return -1 indicating impossibility return -1"},{"question":"You are given an integer array `arr` and an integer `k`. Find the `k`th largest element in the array. Implement the `KthLargest` class: * `KthLargest(int k, int[] arr)` Initializes the object with the integer array `arr` and the integer `k`. * `int add(int val)` Appends the integer `val` to the array and returns the `k`th largest element in the array.","solution":"import heapq class KthLargest: def __init__(self, k, arr): self.k = k self.min_heap = [] # Initialize min heap with the kth largest elements for num in arr: self.add(num) def add(self, val): heapq.heappush(self.min_heap, val) if len(self.min_heap) > self.k: heapq.heappop(self.min_heap) return self.min_heap[0]"},{"question":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. Given an integer array `nums` of distinct integers, there is a function `next_permutation(nums)` that rearranges the numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it rearranges it to the lowest possible order (i.e., sorted in ascending order). The replacement must be in-place and use only constant extra memory. Return the array `nums` after it has been modified to the next permutation. Example: - Input: nums = [1,2,3] - Output: [1,3,2]","solution":"def next_permutation(nums): Modifies nums in-place to the next permutation or the smallest permutation if the next permutation is not possible. # Find the first descending element from the end i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Find the larger number to swap with nums[i] j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap nums[i], nums[j] = nums[j], nums[i] # Reverse the numbers after the i-th position nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"You are given an array of integers `nums` and a target value `target`. Each integer represents the size of a square tile. Your task is to return the smallest number of square tiles that sum up to the target value exactly. If it is not possible to reach the target value using the given tiles, return -1. You may use each integer in the array an unlimited number of times.","solution":"def min_square_tiles(nums, target): Returns the minimum number of square tiles that sum up to the target. Uses dynamic programming to solve the problem. # Initialize the DP array with a large value dp = [float(\'inf\')] * (target + 1) # Base case: zero square tiles are needed to reach target 0 dp[0] = 0 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] = min(dp[i], dp[i - num] + 1) return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"You are given a binary tree where each node has a value of `0` or `1`. Each root-to-leaf path represents a binary number (with the start of the path as the most significant bit). Return the sum of these binary numbers, where each binary number is converted to its decimal form. The tree is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Each root-to-leaf path in the tree will be a unique binary number. The sum should be the total sum of all these binary numbers converted to their decimal form.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: def dfs(node, current_number): if node is None: return 0 current_number = (current_number << 1) | node.val if node.left is None and node.right is None: return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"Given an array of integers `nums` representing a circular queue, rotate the queue to the right by `k` steps, where `k` is non-negative. This means that the element at the end of the array moves to the front and each subsequent element shifts one position to the right for each step. For instance, given the array `[1, 2, 3, 4, 5, 6, 7]` and `k = 3`, the array becomes `[5, 6, 7, 1, 2, 3, 4]` after rotating 3 steps. Implement the function `rotate_queue(nums, k)` that modifies the array `nums` in-place to achieve the required rotation.","solution":"def rotate_queue(nums, k): Rotates the queue (nums) to the right by k steps in-place. n = len(nums) k = k % n # To handle if k > n nums[:] = nums[-k:] + nums[:-k]"},{"question":"Given a string `s` that consists of only uppercase English letters, find and return the length of the longest subsequence in `s` such that every letter in the subsequence appears in alphabetical order. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For instance, if the input string is `\\"ABCDE\\"`, the longest subsequence in alphabetical order is `\\"ABCDE\\"` itself. However, for the input string `\\"CBADE\\"`, the longest subsequence in alphabetical order is `\\"ABDE\\"`.","solution":"def longest_alphabetical_subsequence(s): Returns the length of the longest subsequence in s such that every letter in the subsequence appears in alphabetical order. if not s: return 0 dp = [1] * len(s) for i in range(1, len(s)): for j in range(i): if s[i] >= s[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You have a list of non-negative integers representing the amount of money in each house arranged in a horizontal line. You are a professional robber and you want to maximize the amount of money you can rob tonight without alerting the police. However, if you rob two adjacent houses on the same night, it will alert the police due to the proximity alarm system. Calculate the maximum amount of money you can rob if you cannot rob two adjacent houses on the same night. Return _the **maximum** amount of money you can rob without alerting the police._","solution":"def rob(nums): Given a list of non-negative integers representing the amount of money of each house, return the maximum amount of money you can rob without alerting the police. if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"Given a string `S` and a dictionary of words `dictionary`, find all the starting indices of substring(s) in `S` that are a concatenation of each word in `dictionary` exactly once without any intervening characters. The order of words in the concatenation can be different from the order in the dictionary. Return the list of all starting indices sorted in ascending order.","solution":"def findSubstring(S, dictionary): Given a string S and a list of words dictionary, returns all starting indices of substrings in S that are a concatenation of each word in dictionary exactly once without any intervening characters. if not S or not dictionary: return [] word_length = len(dictionary[0]) total_length = word_length * len(dictionary) word_count = len(dictionary) word_dict = {} for word in dictionary: if word in word_dict: word_dict[word] += 1 else: word_dict[word] = 1 result_indices = [] for i in range(0, len(S) - total_length + 1): seen = {} j = 0 while j < word_count: word = S[i + j * word_length: i + (j + 1) * word_length] if word in word_dict: if word in seen: seen[word] += 1 else: seen[word] = 1 if seen[word] > word_dict[word]: break else: break j += 1 if j == word_count: result_indices.append(i) return result_indices"},{"question":"You are given a string `s` of lowercase English letters. You need to construct a new string by rearranging the characters of `s` and deleting some characters if necessary. The new string should not contain any consecutive repeating characters. Return _the length of the longest possible such string you can construct_.","solution":"def longest_substring_without_consecutive_repeats(s): Constructs the longest possible string without consecutive repeating characters. Parameters: s (str): Input string of lowercase English letters. Returns: int: The length of the longest possible string without consecutive repeating characters. if not s: return 0 prev_char = None length = 0 for char in s: if char != prev_char: length += 1 prev_char = char return length"},{"question":"You are given a 2D grid representing a dungeon with `m` rows and `n` columns. Each cell in the grid contains an integer representing the health points a player gains or loses upon entering that cell (negative values for losing health points). The player starts at the top-left corner (cell (0, 0)) and must reach the bottom-right corner (cell (m-1, n-1)), but can only move either down or right at each step. The player must have a positive health level at all times. Determine the minimum initial health point the player needs to start at cell (0, 0) to reach cell (m-1, n-1) successfully. The player\'s health should never drop to 0 or below at any point in time. Return the minimum initial health point required to achieve this goal.","solution":"def calculateMinimumHP(dungeon): Calculate the minimum initial health required for a player to survive in a dungeon grid. :param dungeon: List[List[int]]: a 2D grid where each cell contains an integer (positive or negative) representing health points gained or lost :return: int: the minimum initial health points needed to start at (0,0) and reach (m-1,n-1) if not dungeon or not dungeon[0]: return 1 m, n = len(dungeon), len(dungeon[0]) # dp[i][j] represents the minimum health points needed to reach the bottom-right corner from cell (i, j) dp = [[0] * n for _ in range(m)] # Bottom-right corner (base case) dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1]) # Fill the last column for i in range(m-2, -1, -1): dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1]) # Fill the last row for j in range(n-2, -1, -1): dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j]) # Fill the rest of the dp table for i in range(m-2, -1, -1): for j in range(n-2, -1, -1): min_health_on_exit = min(dp[i+1][j], dp[i][j+1]) dp[i][j] = max(1, min_health_on_exit - dungeon[i][j]) return dp[0][0]"},{"question":"Given a sorted array of integers `nums` and an integer `k`, return _the number of unique pairs_ `(i, j)` _where_ `i < j` _and_ `nums[j] - nums[i] == k`.","solution":"def find_unique_pairs(nums, k): Returns the number of unique pairs (i, j) where i < j and nums[j] - nums[i] == k. if not nums or k < 0: return 0 left, right = 0, 1 unique_pairs = set() nums_len = len(nums) while right < nums_len: diff = nums[right] - nums[left] if diff == k: unique_pairs.add((nums[left], nums[right])) left += 1 right += 1 elif diff < k: right += 1 else: left += 1 if left == right: right += 1 return len(unique_pairs)"},{"question":"**[Question 4]:** Given an array of integers `arr` and an integer `k`, find the maximum sum of any contiguous subarray of length `k` in `arr`. If no such subarray exists, return `0`.","solution":"def max_contiguous_subarray_sum(arr, k): Returns the maximum sum of any contiguous subarray of length k in arr. If no such subarray exists, return 0. n = len(arr) # If the length of array is less than k, no such subarray exists. if n < k: return 0 # Compute the sum of the first \'k\' elements max_sum = sum(arr[:k]) current_sum = max_sum # Traverse the array from the \'k\'th element to the end for i in range(k, n): current_sum = current_sum + arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You have been tasked with designing a **stock trading algorithm** to maximize profit. You are given a list where each element represents the stock price on a given day. You can complete as many transactions as you want, but you must sell the stock before you buy again. Write a function that computes the **maximum profit** you can achieve. Function Signature: `def maxProfit(prices: List[int]) -> int` Example: ```python prices = [7, 1, 5, 3, 6, 4] # On day 2 (price = 1), buy the stock, and on day 3 (price = 5), sell it. # On day 4 (price = 3), buy the stock, and on day 5 (price = 6), sell it. # Total profit = (5 - 1) + (6 - 3) = 7. print(maxProfit(prices)) # Output: 7 ``` It is guaranteed that you are given prices for at least one day.","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved given a list of daily stock prices. max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"A company has an automated ticket processor that processes customer service tickets. Each ticket is represented as a string and contains the name of the customer who submitted the ticket and a priority level separated by a colon. The priority levels are represented as integers, where a smaller number indicates a higher priority. Your task is to create a function that processes a list of tickets and returns the names of the customers in the order in which their tickets should be handled, from the highest priority to the lowest. Implement a function `processTickets(tickets: List[str]) -> List[str]` that takes a list of tickets and returns a list of customer names in processing order. Examples: 1. Input: `tickets = [\\"Alice:1\\", \\"Bob:3\\", \\"Charlie:2\\"]` Output: `[\\"Alice\\", \\"Charlie\\", \\"Bob\\"]` 2. Input: `tickets = [\\"Dave:5\\", \\"Eve:3\\", \\"Frank:2\\", \\"Gina:4\\", \\"Hank:1\\"]` Output: `[\\"Hank\\", \\"Frank\\", \\"Eve\\", \\"Gina\\", \\"Dave\\"]` Note: - The priority levels will be unique for each ticket in the list. - The returned list should only contain the customer names, sorted according to their ticket priorities.","solution":"def processTickets(tickets): Processes a list of tickets and returns the customer names sorted by their ticket priority. Parameters: tickets (list of str): List of tickets, where each ticket is a string in the format \\"Name:Priority\\". Returns: list of str: List of customer names sorted by their ticket priority from highest to lowest. # Split each ticket into a tuple of (name, priority) split_tickets = [(ticket.split(\':\')[0], int(ticket.split(\':\')[1])) for ticket in tickets] # Sort the list of tuples by the priority (second element) in ascending order sorted_tickets = sorted(split_tickets, key=lambda x: x[1]) # Extract the names from the sorted list of tuples sorted_names = [name for name, priority in sorted_tickets] return sorted_names"},{"question":"You are given a list of `intervals`, where each interval is represented by a pair of integers `[start, end]`. These intervals may overlap, and you need to determine the maximum number of intervals that overlap at any point. Return _that maximum number of overlapping intervals_. For example, given the input `intervals = [[1, 5], [2, 6], [8, 10], [5, 8], [3, 7]]`, the function should return `3`, as the intervals `[1, 5]`, `[2, 6]`, and `[3, 7]` overlap between time `3` and `5`, forming a maximum of `3` overlapping intervals.","solution":"def max_overlapping_intervals(intervals): Given a list of intervals, returns the maximum number of intervals that overlap. events = [] for start, end in intervals: events.append((start, \'start\')) events.append((end, \'end\')) # Sort events: # - first by time # - ensure that if times are the same, \'end\' events come before \'start\' events events.sort(key=lambda x: (x[0], x[1] == \'start\')) current_overlaps = 0 max_overlaps = 0 for event in events: if event[1] == \'start\': current_overlaps += 1 max_overlaps = max(max_overlaps, current_overlaps) else: current_overlaps -= 1 return max_overlaps"},{"question":"You are given a list of `logs` where `logs[i]` is a tuple `(id, timestamp, event)` indicating that a user with `id` performed an `event` at the `timestamp`. The `event` can be either \\"start\\" or \\"end\\". Each user will have exactly one \\"start\\" event and one \\"end\\" event, and the \\"end\\" event\'s timestamp will always be greater than the \\"start\\" event\'s timestamp. Return a list of `user_ids` sorted in ascending order based on the total duration each user was active (difference between \\"end\\" and \\"start\\" timestamps). If two users have the same total active duration, sort them by their `id` in ascending order.","solution":"def calculate_active_durations(logs): Calculate the active durations for each user and return the user IDs sorted by active duration. If two users have the same total active duration, sort them by their ID. :param logs: List of tuples in the form (id, timestamp, event) :return: List of user IDs sorted based on total active duration and IDs from collections import defaultdict user_events = defaultdict(dict) for log in logs: user_id, timestamp, event = log user_events[user_id][event] = timestamp active_durations = [] for user_id, events in user_events.items(): duration = events[\'end\'] - events[\'start\'] active_durations.append((duration, user_id)) sorted_users = sorted(active_durations, key=lambda x: (x[0], x[1])) return [user_id for _, user_id in sorted_users]"},{"question":"You are given an array of non-negative integers `nums` and an integer `k`. You are tasked with finding a contiguous subarray whose length is exactly `k` that has the highest average among all possible subarrays of that length. Return _the highest average_ as a floating-point number. If there are multiple such subarrays, return the highest average among them.","solution":"def find_max_average(nums, k): Finds a contiguous subarray of length k that has the highest average. Returns the highest average as a floating-point number. n = len(nums) if k > n: return None # Not possible to have a subarray of length greater than array length # Compute the sum of the first window window_sum = sum(nums[:k]) max_sum = window_sum # Slide the window across the array for i in range(k, n): window_sum += nums[i] - nums[i - k] max_sum = max(max_sum, window_sum) # Compute the maximum average max_average = max_sum / k return max_average"},{"question":"You are given an integer `n` representing the total number of students in a class. Each student is assigned a unique ID number from `1` to `n`. Additionally, you are given an integer array `votes` where each element `votes[i]` represents the ID number of the student receiving the `i-th` vote. Each student can vote for another student exactly once (but not for themselves), and the student with the highest number of votes gets elected as the class representative. However, if there is a tie for the highest number of votes, the student with the smallest ID number among those who tied gets elected. Return the ID number of the elected class representative.","solution":"def class_representative(n, votes): Given the number of students `n` and a list of votes `votes`, returns the ID number of the elected class representative. from collections import Counter vote_count = Counter(votes) # Get the maximum number of votes received max_votes = max(vote_count.values()) # Find all students who received the maximum number of votes max_voters = [student for student, count in vote_count.items() if count == max_votes] # Return the student with the smallest ID among those who tied return min(max_voters)"},{"question":"Given an integer `n`, return the number of unique binary search trees (BSTs) that can be constructed using values from `1` to `n` inclusive. For example, if `n = 3`, there are a total of `5` unique BSTs that can be constructed. The value `n` can be any integer from `1` to `15`.","solution":"def num_trees(n): Returns the number of unique binary search trees (BSTs) that can be constructed using values from 1 to n inclusive. if n == 0 or n == 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for nodes in range(2, n + 1): total_trees = 0 for root in range(1, nodes + 1): left_trees = dp[root - 1] right_trees = dp[nodes - root] total_trees += left_trees * right_trees dp[nodes] = total_trees return dp[n]"},{"question":"You are given an undirected graph in the form of an adjacency list where each node is labeled with a unique integer. Your task is to determine if the graph is bipartite. A graph is bipartite if you can split its set of nodes into two independent subsets A and B such that every edge (u, v) connects a node in A to a node in B. Return _true_ if the graph is bipartite, or _false_ otherwise.","solution":"def is_bipartite(graph): Determine if a given undirected graph is bipartite. :param graph: List[List[int]] - an adjacency list where graph[i] is a list of node i\'s neighbors. :return: bool - True if the graph is bipartite, False otherwise. color = {} def dfs(node, c): if node in color: return color[node] == c color[node] = c return all(dfs(nei, c ^ 1) for nei in graph[node]) return all(dfs(node, 0) for node in range(len(graph)) if node not in color)"},{"question":"You are given a string `expression` representing a mathematical expression. The expression can contain digits, the operators `+`, `-`, `*`, and `/`, and empty spaces. Your task is to evaluate the expression and return the result as an integer. The integers used in the expression are valid and within the range of a 32-bit signed integer. # Additional Information: - The division operator `/` should truncate the result toward zero. - Assume the given `expression` is always valid. - You need to consider the precedence of the operators: `*` and `/` have higher precedence than `+` and `-`. **Example**: - For the input `expression = \\"3+2*2\\"`, the output should be `7`. - For the input `expression = \\" 3/2 \\"`, the output should be `1`. - For the input `expression = \\" 3+5 / 2 \\"`, the output should be `5`.","solution":"def calculate(expression): Evaluate the given mathematical expression and return the result as an integer. if not expression: return 0 stack = [] num = 0 sign = \\"+\\" # The initial sign is positive n = len(expression) for i in range(n): char = expression[i] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or i == n - 1: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) # Python 2 division ensures truncation towards zero sign = char num = 0 return sum(stack)"},{"question":"You have an array of n positive integers and an integer target. You need to determine if the array contains three integers such that the sum of the three integers is equal to the target. Implement a function to find a triplet (a, b, c) in the array that satisfies a + b + c = target. If no such triplet exists, return false. If such a triplet exists, return true.","solution":"def find_triplet(nums, target): Determines if there are three numbers in the list nums that add up to the target. Args: nums (list): List of n positive integers. target (int): Target sum. Returns: bool: True if there exists a triplet such that their sum equals target, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Given a string `s` consisting solely of characters `\'a\'`, `\'b\'`, and `\'c\'`, return _the length of the longest substring that contains at most two distinct characters_.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. Parameters: s (str): Input string consisting of \'a\', \'b\', and \'c\' Returns: int: Length of the longest substring with at most two distinct characters if len(s) == 0: return 0 window_start = 0 max_length = 0 char_frequency = {} for window_end in range(len(s)): right_char = s[window_end] if right_char in char_frequency: char_frequency[right_char] += 1 else: char_frequency[right_char] = 1 while len(char_frequency) > 2: left_char = s[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"A cinema hall uses a seating arrangement where each row has a certain number of seats (which may vary across rows). You are given a 2D integer array `seats` where `seats[i]` represents the i-th row and `seats[i][j]` represents the j-th seat in the i-th row (0 if the seat is empty and 1 if the seat is filled). Your task is to find the row with the most number of filled seats (1s). If there are multiple rows with the same maximum number of filled seats, return the row with the smallest index. Return _the index of the row with the most filled seats_.","solution":"def row_with_most_filled_seats(seats): Function to find the row with the most number of filled seats. Parameters: seats (list of list of ints): 2D array representing the seating arrangement Returns: int: Index of the row with the most filled seats max_filled = -1 row_index = -1 for i, row in enumerate(seats): filled_count = sum(row) if filled_count > max_filled: max_filled = filled_count row_index = i return row_index"},{"question":"Given an unsorted array of integers `arr`, determine if there exist two distinct indices `i` and `j` in the array such that `arr[i]` and `arr[j]` add up to a given target value `k`. If such indices exist, return `true`, otherwise return `false`.","solution":"def has_pair_with_sum(arr, k): Determines if there exist two distinct indices `i` and `j` in the array such that arr[i] + arr[j] == k. Parameters: arr (list): List of integers. k (int): Target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"You are given a hidden target number between `1` and `n`. You need to find out what this target number is with the least number of guesses. Each guess will be provided to you in the form of a function `guess(num)` which returns 3 possible results: - `-1`: The target number is lower than the guessed number. - `1`: The target number is higher than the guessed number. - `0`: The guessed number is correct. Write a function to find the target number using the least number of guesses. As a hint, consider the use of a search algorithm to minimize the number of steps required.","solution":"def guess_number(n, guess): Function to find the hidden target number between 1 and n using binary search. :param n: The upper limit of the range. :param guess: Function that returns -1, 1, or 0 based on the guessed number. :return: The target number. left, right = 1, n while left <= right: mid = (left + right) // 2 result = guess(mid) if result == 0: return mid elif result == -1: right = mid - 1 else: left = mid + 1"},{"question":"You are given an array representing a sequence of operations involving a single string. Each operation is represented as `ops[i] = [type, index, char]`, where: - `type` can be either `1` or `2`. If it is `1`, it indicates an insertion operation, and if it is `2`, it indicates a deletion operation. - `index` indicates the position at which the operation is to be performed. - `char` is a character to be inserted in the string for `type = 1`, and `null` for `type = 2`. Initially, the string is empty. Perform all the operations in the sequence and return the resulting string after all operations have been executed. If a deletion operation attempts to delete a character beyond the current length of the string, ignore that operation. Write a function: ```python def process_operations(ops: List[List[Union[int, int, Optional[str]]]]) -> str: ``` **Example:** ```python ops = [ [1, 0, \\"a\\"], # Insert \'a\' at index 0 [1, 1, \\"b\\"], # Insert \'b\' at index 1 [2, 2, None], # Attempt to delete character at index 2 (ignored as string length is 2) [1, 1, \\"c\\"], # Insert \'c\' at index 1 [2, 0, None] # Delete character at index 0 ] print(process_operations(ops)) # Output: \\"cb\\" ``` **Note:** - The operations should be processed in the given order. - Insertions are 0-indexed and insertions at an index that is beyond the current length append the character to the end. - Perform operations efficiently considering the potential length of the operations list.","solution":"from typing import List, Union, Optional def process_operations(ops: List[List[Union[int, int, Optional[str]]]]) -> str: result = [] for op in ops: type, index, char = op if type == 1: # Insertion operation if index >= len(result): # Append character to the end result.append(char) else: # Insert character at specified index result.insert(index, char) elif type == 2: # Deletion operation if 0 <= index < len(result): result.pop(index) # Perform deletion at specified index return \'\'.join(result)"},{"question":"You are given a matrix `grid` of size `m x n` consisting of positive integers. You are also given an integer threshold. Your task is to find the maximum side length of a square sub-matrix such that the sum of all the elements within this square is less than or equal to the given threshold. Return the maximum side length of such a square sub-matrix. If no such square sub-matrix exists, return 0.","solution":"def maxSideLength(grid, threshold): Returns the maximum side length of a square sub-matrix such that the sum of all the elements within this square is less than or equal to the given threshold. m, n = len(grid), len(grid[0]) # Compute prefix sums prefix = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): prefix[i+1][j+1] = grid[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j] def square_sum(x1, y1, x2, y2): return prefix[x2][y2] - prefix[x1][y2] - prefix[x2][y1] + prefix[x1][y1] # Binary search on the side length of the square sub-matrix left, right, max_side = 1, min(m, n), 0 while left <= right: mid = (left + right) // 2 found = False for i in range(m - mid + 1): for j in range(n - mid + 1): if square_sum(i, j, i + mid, j + mid) <= threshold: found = True break if found: break if found: max_side = mid left = mid + 1 else: right = mid - 1 return max_side"},{"question":"You are given an array of integers `heights` representing the heights of buildings along a street. An array of integers `requirements` is also given, where each element indicates the maximum height allowed for each corresponding building in the `heights` array. Return the number of buildings that need to have their heights reduced to comply with the `requirements`. If a building\'s height is already less than or equal to the required maximum height, no changes need to be made to that building.","solution":"def count_buildings_to_reduce(heights, requirements): Returns the number of buildings that need to have their heights reduced to comply with the requirements. Parameters: heights (list of int): List of heights of buildings. requirements (list of int): List of maximum allowed heights for the corresponding buildings. Returns: int: Number of buildings that need their heights reduced. count = 0 for height, requirement in zip(heights, requirements): if height > requirement: count += 1 return count"},{"question":"Given an array of unique integers, write a function that determines if these integers can form an arithmetic progression. An arithmetic progression is a sequence of numbers such that the difference between any two consecutive elements is the same. Return `true` if the array can be rearranged to form an arithmetic progression, and `false` otherwise.","solution":"def can_form_arithmetic_progression(arr): Determine if an array of unique integers can form an arithmetic progression. :param arr: List[int] - An array of unique integers :return: bool - True if the array can be rearranged to form an arithmetic progression, False otherwise if len(arr) <= 2: return True arr.sort() diff = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] != diff: return False return True"},{"question":"You are given a list of `n` non-negative integers representing the amount of energy each person has in a group. Your task is to determine the maximum amount of energy that can be accumulated by selecting and pairing people such that for each pair, the energy accumulated is the difference between the two energy values. Each person can be paired with exactly one other person, and you want to maximize the total accumulated energy. Return the maximum total energy that can be accumulated by optimally pairing the people. For example: Given the list `[3, 6, 1, 10]`, the optimal pairing would be (3, 1) and (10, 6), resulting in a total energy of `2 + 4 = 6`. Hence, the output should be `6`.","solution":"def max_energy_accumulated(energies): Returns the maximum amount of energy that can be accumulated by optimally pairing people based on their energies. :param energies: List of non-negative integers representing energies :return: Maximum total accumulated energy energies.sort() total_energy = 0 for i in range(1, len(energies), 2): total_energy += energies[i] - energies[i - 1] return total_energy"},{"question":"A sequence of integers is called **bitonic** if it consists of an increasing sequence of integers followed by a decreasing sequence of integers. Your task is to write a function `longestBitonicSequence(nums)` that takes an array `nums` of integers and returns the length of the longest bitonic subsequence. A subsequence is a sequence that can be derived from `nums` by deleting some or no elements without changing the order of the remaining elements. The function should return an integer.","solution":"def longestBitonicSequence(nums): if not nums: return 0 n = len(nums) inc = [1] * n dec = [1] * n # Compute LIS for every element for i in range(1, n): for j in range(i): if nums[i] > nums[j]: inc[i] = max(inc[i], inc[j] + 1) # Compute LDS for every element for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if nums[i] > nums[j]: dec[i] = max(dec[i], dec[j] + 1) # Compute the maximum length of bitonic subsequence max_len = 0 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"An **image** can be represented by a 2D integer matrix `image`, where each integer represents the pixel value of that image. You are also given three integers `sr`, `sc`, and `newColor`. Starting from the pixel at coordinates (`sr`, `sc`) in the image, paint the connected area of the same color as this pixel with the `newColor`. The connected area refers to all pixels that are connected to the starting pixel by any number of 4-directional movements (up, down, left, and right) and have the same original color as the starting pixel. Return the modified image after performing the flood fill algorithm. ```python def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: pass # Your implementation here ```","solution":"from typing import List def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: rows, cols = len(image), len(image[0]) originalColor = image[sr][sc] def dfs(r, c): if (r < 0 or r >= rows or c < 0 or c >= cols or image[r][c] != originalColor or image[r][c] == newColor): return image[r][c] = newColor dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) if originalColor != newColor: dfs(sr, sc) return image"},{"question":"You are given a list of integers `nums` and an integer `k`. A subarray is defined as a contiguous block of elements in the original array. Return _the length of the longest subarray_ whose sum is less than or equal to `k`. If no such subarray exists, return 0.","solution":"def longest_subarray_with_sum_at_most_k(nums, k): Returns the length of the longest subarray whose sum is less than or equal to k. :param nums: List of integers. :param k: An integer representing the maximum sum allowed. :return: Length of the longest subarray with sum <= k. n = len(nums) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum > k and start <= end: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an array of integers `arr` and an integer `target`, return _an array of arrays where each subarray contains distinct integers from `arr` that add up to `target`_. Each element in `arr` can only be used once in each combination. You may return the combinations in any order.","solution":"from typing import List def combination_sum(arr: List[int], target: int) -> List[List[int]]: def backtrack(start, path, target): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(arr)): if i > start and arr[i] == arr[i - 1]: continue backtrack(i + 1, path + [arr[i]], target - arr[i]) arr.sort() # Sort to handle duplicates and make it easier to skip them result = [] backtrack(0, [], target) return result"},{"question":"You are given a positive integer `num` representing the number of digits in a phone number. Write a function that returns all possible combinations of `num` digits in such a way that no consecutive digits are the same. The digits can be from 0 to 9. Return the list of combinations sorted in lexicographical order.","solution":"def generate_phone_numbers(num): Returns all possible combinations of `num` digits such that no consecutive digits are the same. Sorted in lexicographical order. if num <= 0: return [] def dfs(path): if len(path) == num: result.append(\\"\\".join(path)) return for digit in map(str, range(10)): if not path or path[-1] != digit: dfs(path + [digit]) result = [] for start_digit in map(str, range(10)): dfs([start_digit]) result.sort() return result"},{"question":"Given a string `s`, return the length of the longest substring containing only unique characters. The substring must be contiguous and the characters in the substring must all be distinct. For example, if `s = \\"abcabcbb\\"`, the longest substring with all unique characters is `\\"abc\\"`, which has a length of 3. Write an algorithm with a time complexity of `O(n)`.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given two strings `s1` and `s2`. You can perform the following operations on `s1`: - Insert a character. - Delete a character. - Replace a character. Your task is to implement a function `int minDistance(string s1, string s2)` that returns the minimum number of operations required to convert `s1` into `s2`. Use dynamic programming to optimize the solution.","solution":"def minDistance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. m, n = len(s1), len(s2) # Create a DP table with (m+1) x (n+1) dimensions dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, remove all characters of first string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If characters are same, no new operation is needed else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"Given a list of integers `arr`, where `arr[i]` might be duplicated, implement a function that finds all distinct contiguous subarrays where the maximum element is at least twice the minimum element. Return the list of all such subarrays. Your function should maintain efficient performance even for large inputs. The order in which the subarrays are returned does not matter.","solution":"def distinct_contiguous_subarrays(arr): def is_valid_subarray(subarray): max_element = max(subarray) min_element = min(subarray) return max_element >= 2 * min_element all_subarrays = set() n = len(arr) for i in range(n): for j in range(i + 1, n + 1): subarray = tuple(arr[i:j]) if subarray not in all_subarrays and is_valid_subarray(subarray): all_subarrays.add(subarray) return [list(subarray) for subarray in all_subarrays]"},{"question":"Implement a function `int minPathSum(int[][] grid)` that takes in a grid of size `m x n` filled with non-negative integers and returns the minimal path sum from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. The minimal path sum is the sum of all the numbers along a path that minimizes this sum. The function should efficiently compute the minimal path using dynamic programming.","solution":"def minPathSum(grid): Returns the minimal path sum from the top-left to the bottom-right corner of a given grid. :param grid: List[List[int]] -- a 2D list of non-negative integers :return: int -- the minimal path sum from the top-left to the bottom-right corner if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"Given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You need to rotate the image in-place, which means you have to modify the input matrix directly. Do not allocate another 2D matrix for the rotation. For example, if the input matrix is: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The matrix should be rotated in-place to become: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Write a function: ```python def rotate(matrix: List[List[int]]) -> None: # Your code here ``` Where `matrix` is the `n x n` 2D list of integers that represents the image to be rotated.","solution":"def rotate(matrix): Rotates the given n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given a string `s` and a dictionary of strings `wordDict`. Add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Each word in the dictionary can be used more than once. Implement the `WordBreak` class: * `WordBreak()` Initializes the object with an empty state. * `List<String> wordBreak(String s, List<String> wordDict)` Finds and returns all possible sentences that can be formed by adding spaces in `s`, ensuring that each word is a valid dictionary word from `wordDict`.","solution":"from typing import List class WordBreak: def __init__(self): pass def wordBreak(self, s: str, wordDict: List[str]) -> List[str]: memo = {} def helper(s): if s in memo: return memo[s] if not s: return [\'\'] res = [] for word in wordDict: if s.startswith(word): sublist = helper(s[len(word):]) for sub in sublist: if sub: res.append(word + \' \' + sub) else: res.append(word) memo[s] = res return res return helper(s)"},{"question":"Given an integer array `nums`, return a **2-dimensional** array containing **all unique permutations** of the elements in `nums`. Each permutation should be in a **lexicographical** order. **Note:** The result should not contain duplicate permutations. **Example:** ``` nums = [1, 2, 3] Output: [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ```","solution":"from itertools import permutations def permute_unique(nums): Return all unique permutations of the given list of numbers in lexicographical order. return sorted(list(set(permutations(nums))))"},{"question":"You are given an integer array `nums`. A contiguous subarray is defined as a segment within the array that maintains the order of elements. We define the **\\"beauty\\"** of a subarray as the absolute difference between the minimum and maximum values of the subarray. Find the **maximum beauty** out of all possible contiguous subarrays of `nums`. Returning an integer representing the **highest beauty** among all these subarrays.","solution":"def maximum_beauty(nums): Returns the maximum beauty out of all possible contiguous subarrays of nums. Beauty is defined as the absolute difference between the minimum and maximum values of the subarray. n = len(nums) if n == 0: return 0 max_beauty = 0 for i in range(n): min_val = max_val = nums[i] for j in range(i, n): min_val = min(min_val, nums[j]) max_val = max(max_val, nums[j]) max_beauty = max(max_beauty, max_val - min_val) return max_beauty"},{"question":"You are given an integer array `arr` and a positive integer `d`. The integer array represents the heights of trees lined up in a row. During each jump, you can jump from a tree to another tree if the height of the destination tree is strictly smaller than the height of the current tree and the distance between the trees is at most `d`. You can choose any tree and start the jump from there. Your task is to find the maximum number of trees you can jump to. Write a function `maxJumps` that will take the array `arr` and the integer `d` as inputs and return the maximum number of trees that can be jumped.","solution":"def maxJumps(arr, d): n = len(arr) dp = [0] * n def dfs(i): if dp[i] != 0: return dp[i] max_jump = 1 # move to the right for j in range(i + 1, min(i + d + 1, n)): if arr[j] >= arr[i]: break max_jump = max(max_jump, 1 + dfs(j)) # move to the left for j in range(i - 1, max(i - d - 1, -1), -1): if arr[j] >= arr[i]: break max_jump = max(max_jump, 1 + dfs(j)) dp[i] = max_jump return dp[i] return max(dfs(i) for i in range(n))"},{"question":"You are given a string `text` and an array of words `words`. A **prefix** of a string is any leading contiguous substring of that string. For example, the prefixes of the string `\\"abcdef\\"` are `\\"a\\"`, `\\"ab\\"`, `\\"abc\\"`, `\\"abcd\\"`, `\\"abcde\\"`, and `\\"abcdef\\"`. For each word in `words`, find the **longest** prefix of that word which is also a prefix of `text`. Return _the array of lengths of these longest prefixes_. For example, given `text = \\"abcdef\\"` and `words = [\\"abc\\", \\"abcd\\", \\"abz\\", \\"abcdefg\\"]`, the output should be `[3, 4, 2, 6]` because: - The longest prefix of `\\"abc\\"` that matches with a prefix of `\\"abcdef\\"` is `\\"abc\\"` itself (length 3). - The longest prefix of `\\"abcd\\"` that matches with a prefix of `\\"abcdef\\"` is `\\"abcd\\"` itself (length 4). - The longest prefix of `\\"abz\\"` that matches with a prefix of `\\"abcdef\\"` is `\\"ab\\"` (length 2). - The longest prefix of `\\"abcdefg\\"` that matches with a prefix of `\\"abcdef\\"` is `\\"abcdef\\"` itself (length 6).","solution":"def longest_prefix_lengths(text, words): For each word in words, find the longest prefix that matches any prefix of text. Return the array of lengths of these longest prefixes. result = [] for word in words: max_len = min(len(text), len(word)) i = 0 while i < max_len and word[i] == text[i]: i += 1 result.append(i) return result"},{"question":"You are given a **0-indexed** array of integers `nums` and an integer `threshold`. A contiguous subarray of `nums` is considered **valid** if the **sum** of its elements is **greater than or equal to** `threshold`. Return _the length of the **shortest valid** contiguous subarray_. If no such subarray exists, return `-1`.","solution":"def shortest_valid_subarray(nums, threshold): Returns the length of the shortest valid contiguous subarray where the sum of its elements is greater than or equal to threshold. If no such subarray exists, returns -1. n = len(nums) min_length = float(\'inf\') for start in range(n): curr_sum = 0 for end in range(start, n): curr_sum += nums[end] if curr_sum >= threshold: min_length = min(min_length, end - start + 1) break return min_length if min_length != float(\'inf\') else -1"},{"question":"Given two strings `s` and `t`, return _the minimum window substring of `s` which contains all the characters in `t`, including duplicates_. If there is no such substring, return an empty string `\\"\\"`. If there are multiple such substrings, return the one which starts first. For example: - Input: `s = \\"ADOBECODEBANC\\", t = \\"ABC\\"` - Output: `\\"BANC\\"` Note: A substring is a contiguous sequence of characters within the string.","solution":"from collections import Counter, defaultdict def min_window(s, t): Returns the minimum window substring of `s` which contains all characters in `t`. if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) # Number of unique characters in t l, r = 0, 0 # Left and right pointer formed = 0 # Keep track of how many unique characters in t are present in the current window in desired frequency window_counts = defaultdict(int) # Dictionary to keep track of all characters in the current window ans = float(\\"inf\\"), None, None # Form (window length, left, right) while r < len(s): character = s[r] window_counts[character] += 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if (r - l + 1) < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]:ans[2] + 1]"},{"question":"You are developing an application that assists in scheduling tasks on a single-core processor. Each task is represented as an interval with a start and end time, and may require a certain number of time slots to complete. You are given a list of tasks `tasks`, where `tasks[i] = [start_i, end_i, length_i]` represents the `i`-th task that must start at or after `start_i`, finish at or before `end_i`, and requires exactly `length_i` time slots to complete. Determine if all the tasks can be scheduled without overlapping. Return `true` if it is possible to schedule all tasks, otherwise return `false`.","solution":"def can_schedule_tasks(tasks): Determines if all tasks can be scheduled without overlapping. Args: - tasks (List[List[int]]): List of tasks where each task is represented as [start, end, length] Returns: - bool: True if all tasks can be scheduled without overlapping, False otherwise. # Sort tasks based on their end times primarily, and start times secondarily tasks.sort(key=lambda x: (x[1], x[0])) # Array to keep track of the used time slots used_slots = [] for task in tasks: start, end, length = task # Find slots that can be allocated to this task allocated_slots = 0 for t in range(start, end + 1): # Check if the slot t is free if allocated_slots < length and t not in used_slots: used_slots.append(t) allocated_slots += 1 # Check if enough slots were allocated for this task if allocated_slots < length: return False return True"},{"question":"You are given a **0-indexed** integer array `stones` representing the position of stones along a river. Each stone\'s position is given such that `stones[i]` < `stones[i + 1]` for all valid `i`. You start at stone `0` and can move from a stone at position `stones[i]` to a stone at position `stones[j]` for `j > i` with a jump of length exactly equal to `stones[j] - stones[i]`. Initially, you can move from the position `stones[0]` with a jump length of `1`. Thereafter, if you made a jump of length `x` to reach a stone, you can only choose to jump `x - 1`, `x`, or `x + 1` units to the next stone. Return _whether you can reach the last stone_. For example: - If `stones = [0,1,3,5,6,8,12,17]`, the output should be `true` because you can jump through the stones by following the sequence `[1, 2, 2, 1, 2, 4, 5]`. - If `stones = [0,1,2,3,4,8,9,11]`, the output should be `false` because there is no way to reach the last stone from stone `4`.","solution":"def can_cross(stones): Determine if you can cross the river by landing on the last stone. :param stones: List[int] - A list of stone positions in increasing order. :return: bool - True if you can reach the last stone, False otherwise. if not stones: return False # Dictionary to hold the reachable distances from each stone stone_reach = {stone: set() for stone in stones} stone_reach[stones[0]].add(0) for stone in stones: for jump in stone_reach[stone]: # Check for jump - 1, jump, and jump + 1 for k in range(jump - 1, jump + 2): if k > 0 and stone + k in stone_reach: stone_reach[stone + k].add(k) return bool(stone_reach[stones[-1]]) # Example usage: # stones = [0,1,3,5,6,8,12,17] # print(can_cross(stones)) # Output: True # stones = [0,1,2,3,4,8,9,11] # print(can_cross(stones)) # Output: False"},{"question":"You are given a `string` `s` representing a binary number. Your task is to find the length of the longest substring of `s` that can be rearranged to form a palindrome. Return the length of the longest palindromic substring that can be formed by rearranging the characters of `s`. A palindrome is a string that reads the same forwards and backwards. For example, if `s` is `\\"110110\\"`, the longest palindromic substring that can be formed is `\\"110011\\"`, and the length is `6`. If no palindromic rearrangement is possible, return `0`.","solution":"def longest_palindromic_length(s): from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can have at most one character with an odd count to be able to rearrange into a palindrome if odd_count > 1: return len(s) - (odd_count - 1) else: return len(s)"},{"question":"You are given the head of a singly linked list. The nodes in the linked list have values either `0` or `1`. There is a total of `n` nodes in the linked list. The linked list represents a binary number where the first node is the most significant bit and the last node is the least significant bit. Return _the integer value of the binary number represented by the linked list_.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_decimal_value(head): Given the head of a singly linked list with nodes containing binary values (0 and 1), return the integer value of the binary number represented by the list. binary_num = 0 current = head while current: binary_num = binary_num * 2 + current.val current = current.next return binary_num"},{"question":"Given two binary trees `root1` and `root2`, return _true_ if the second tree is a **subtree** of the first tree. A subtree of a binary tree is a tree that consists of a node in the tree and all of this node\'s descendants. The tree `root2` is considered a subtree of `root1` if there is a node in `root1` where the tree rooted at that node has the same structure and node values as `root2`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val=val self.left=left self.right=right def is_same_tree(tree1, tree2): Checks if two binary trees are the same. if not tree1 and not tree2: return True if not tree1 or not tree2: return False return (tree1.val == tree2.val and is_same_tree(tree1.left, tree2.left) and is_same_tree(tree1.right, tree2.right)) def is_subtree(root1, root2): Checks if root2 is a subtree of root1. if not root2: return True if not root1: return False if is_same_tree(root1, root2): return True return is_subtree(root1.left, root2) or is_subtree(root1.right, root2)"},{"question":"You are given two integer arrays `X` and `Y` both of size `n` representing coordinates in a 2D plane. A pair of points `(X[i], Y[i])` and `(X[j], Y[j])` is considered **connected** if the Euclidean distance between them is less than or equal to a given threshold `D`. Determine the number of distinct **connected components** in this graph, where each point `(X[i], Y[i])` is a node and each connected pair `(X[i], Y[i])` and `(X[j], Y[j])` forms an edge. A **connected component** is a maximal set of points in which any two points are connected directly or indirectly through other points. Return the total number of such connected components.","solution":"import math def euclidean_distance(x1, y1, x2, y2): Calculate the Euclidean distance between two points (x1, y1) and (x2, y2). return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) def find_connected_components(X, Y, D): Find the number of connected components in the graph defined by the points with coordinates (X[i], Y[i]). n = len(X) visited = [False] * n adj_list = {i: [] for i in range(n)} # Build the adjacency list based on the distance threshold D for i in range(n): for j in range(i + 1, n): if euclidean_distance(X[i], Y[i], X[j], Y[j]) <= D: adj_list[i].append(j) adj_list[j].append(i) def dfs(node): Depth First Search to visit all nodes in the current connected component. stack = [node] while stack: curr = stack.pop() for neighbor in adj_list[curr]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) components_count = 0 for i in range(n): if not visited[i]: visited[i] = True dfs(i) components_count += 1 return components_count"},{"question":"Given an `m x n` matrix where each row is sorted in **non-decreasing order**, return all elements of the matrix in a sorted, non-decreasing order. The sorting should be done in place if possible without using any extra space for another matrix. If not feasible, explain your approach and the space complexity involved.","solution":"def sorted_elements(matrix): Given an `m x n` matrix where each row is sorted in non-decreasing order, returns all elements of the matrix in a sorted, non-decreasing order. A new list is created to store and then sort the elements. :param matrix: List[List[int]] - 2D list of integers sorted in each row :return: List[int] - Sorted elements of the matrix in non-decreasing order # Extract all elements from the matrix elements = [element for row in matrix for element in row] # Sort the elements elements.sort() return elements"},{"question":"Given a 2D integer matrix `grid`, return `true` _if there is a path from the top-left corner (0,0) to the bottom-right corner (m-1,n-1) that only passes through cells with the value 1_. You can only move **up**, **down**, **left**, or **right**. The grid contains only the values 0 and 1, where 1 represents a traversable cell and 0 represents an obstacle. * For example, given the grid `[[1, 0, 0], [1, 1, 0], [0, 1, 1]]`, there is a path from the top-left to the bottom-right corner: `(0,0) -> (1,0) -> (1,1) -> (2,1) -> (2,2)`.","solution":"def is_path_exist(grid): Determines if there is a path from top-left to bottom-right in a grid traversing only cells with the value 1. if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) if grid[0][0] != 1 or grid[rows-1][cols-1] != 1: return False def dfs(x, y): if x == rows - 1 and y == cols - 1: return True if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] != 1: return False grid[x][y] = 0 # Mark the cell as visited if (dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1)): return True return False return dfs(0, 0)"},{"question":"Given an integer array `arr`, your task is to sort the array in non-decreasing order by performing a series of operations. In each operation, you can select a subarray of length `x` (where `1 <= x <= n`, and `n` is the length of the array) and reverse it. Determine the minimum number of operations required to sort the array. Return the minimum number of operations as an integer.","solution":"def min_operations_to_sort(arr): Returns the minimum number of operations required to sort the given array. if arr == sorted(arr): return 0 else: return 1"},{"question":"You are given a list of `intervals`, where each interval is represented as a pair of integers `[start, end]`. Each interval represents a particular job scheduled on a timeline. Write a program to merge all overlapping intervals. Implement the function `mergeIntervals(List intervals)` which will return a list of the merged intervals sorted by their starting times. * For example, if the input is `[[1, 3], [2, 6], [8, 10], [15, 18]]`, the output should be `[[1, 6], [8, 10], [15, 18]]`. Note that intervals `[1, 3]` and `[2, 6]` overlap and thus should be merged into `[1, 6]` and the other intervals should remain unchanged.","solution":"from typing import List def mergeIntervals(intervals: List[List[int]]) -> List[List[int]]: if not intervals: return [] # Sort intervals by starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval if current[0] <= last_merged[1]: # Merge the two intervals last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals"},{"question":"You are given a **0-indexed** string `s` that represents a sandwich, where \'B\' stands for bread and \'I\' stands for ingredient. An ingredient is considered **properly enclosed** if it is surrounded by \'B\' on both sides. Write a function that returns the number of properly enclosed ingredients in the sandwich.","solution":"def count_enclosed_ingredients(s): Returns the number of properly enclosed ingredients in the sandwich string `s`. Parameters: s (str): A string representing the sandwich. Returns: int: The number of properly enclosed ingredients. if len(s) < 3: # At least \\"BIB\\" is needed to have an enclosed ingredient. return 0 count = 0 for i in range(1, len(s) - 1): if s[i] == \'I\' and s[i - 1] == \'B\' and s[i + 1] == \'B\': count += 1 return count"},{"question":"Assume you are given the head of a singly linked list where each node contains an integer value. Design an algorithm to partition this linked list around a value `x`, such that all nodes less than `x` come before nodes greater than or equal to `x`. The relative order of nodes in each partition should remain the same as in the original linked list. Return the head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, x): Partitions a linked list around a value x such that all nodes less than x come before nodes greater than or equal to x. The relative order of nodes in each partition should remain the same as in the original linked list. Parameters: - head: ListNode, the head of the linked list - x: int, the partition value Returns: - ListNode, the head of the modified linked list. if not head: return head # Two dummy nodes for the heads of the two lists before_head = ListNode(0) after_head = ListNode(0) # Two pointers to build the two lists before = before_head after = after_head current = head while current: if current.val < x: before.next = current before = before.next else: after.next = current after = after.next current = current.next # Combine the two lists after.next = None # End of the \'after\' list before.next = after_head.next # Combine before list with after list return before_head.next"},{"question":"You are given a list of integers `arrivalTimes` representing the arrival times of `n` customers in a service center and an integer `k` representing the number of service counters available. Each service counter can serve one customer at a time, and a customer leaves the counter as soon as they are served. Customers are assigned to the earliest available counter when they arrive. Return an array `result` where `result[i]` is the total number of customers served by the `i-th` service counter.","solution":"def customers_served(arrivalTimes, k): Returns an array where result[i] is the total number of customers served by the i-th service counter. Parameters: arrivalTimes (list): A list of integers representing the arrival times of customers. k (int): The number of service counters. Returns: list: An array containing the number of customers served by each counter. counters = [0] * k # Array to keep track of customers served by each counter next_available = [0] * k # Array to keep track of the next available time for each counter for arrival in arrivalTimes: # Find the next available counter (the counter with the earliest availability) earliest_counter = next_available.index(min(next_available)) # Serve the customer counters[earliest_counter] += 1 # Update the next available time for this counter next_available[earliest_counter] = arrival + 1 return counters"},{"question":"Given an array `arr` of integers, you need to find and return the length of the longest contiguous subarray such that every element in this subarray is unique. If there are multiple subarrays with the same maximum length, return the length of any one of them. A contiguous subarray is a subarray consisting of consecutive elements from the original array.","solution":"def length_of_longest_unique_subarray(arr): Returns the length of the longest contiguous subarray with all unique elements. n = len(arr) if n == 0: return 0 max_len = 0 current_start = 0 index_map = {} for current_end in range(n): if arr[current_end] in index_map and index_map[arr[current_end]] >= current_start: current_start = index_map[arr[current_end]] + 1 index_map[arr[current_end]] = current_end max_len = max(max_len, current_end - current_start + 1) return max_len"},{"question":"You are given an array of integers `nums` and an integer `k`. Find the maximum sum of a subarray of length `k` that you can obtain by rearranging the elements of `nums`. Note that you may only rearrange the elements of `nums` once if necessary. Return the maximum sum possible.","solution":"def max_sum_with_k_elements(nums, k): Returns the maximum sum of a subarray of length k that can be obtained by rearranging the elements of nums. # Sort the array in descending order nums.sort(reverse=True) # Calculate the sum of the first \'k\' elements after sorting max_sum = sum(nums[:k]) return max_sum"},{"question":"You are given a 2D integer grid `grid` of size `m x n` representing a map where `1` represents land and `0` represents water. A **horizontal** move consists of moving from one cell to another cell on the left or right, and a **vertical** move consists of moving from one cell to another cell up or down. Return the size of the largest connected component of `1`s on the grid. Two cells are considered connected if a path of lands (horizontal and vertical moves only) from one cell to the other can be established.","solution":"def largest_connected_land(grid): Returns the size of the largest connected component of 1\'s (land) in the grid. m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] largest = 0 def dfs(x, y): if not (0 <= x < m and 0 <= y < n) or grid[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: connected_size = dfs(i, j) largest = max(largest, connected_size) return largest"},{"question":"You are given a grid of size `m x n` consisting of `0\'s` (land) and `1\'s` (water). An island is a group of `0\'s` connected horizontally, vertically, or diagonally. You may assume all four edges of the grid are surrounded by `1\'s`. The function should return the number of islands in `grid`.","solution":"def num_islands(grid): Returns the number of islands in the grid. if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == \'1\' or visited[i][j]: return visited[i][j] = True directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for di, dj in directions: dfs(i + di, j + dj) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == \'0\' and not visited[i][j]: island_count += 1 dfs(i, j) return island_count"},{"question":"You are given an array `heights` representing the heights of students in a class, where `heights[i]` is the height of the `i-th` student. Implement the function `maxVisibleStudents(height)` that returns the maximum number of students visible from the front of the class. A student at index `i` is visible if there is no student taller than them before position `i`. The function should output the number of students who are visible directly or indirectly without being obstructed by a taller student in front of them.","solution":"def maxVisibleStudents(heights): Returns the maximum number of students visible from the front. if not heights: return 0 visible_count = 1 # The first student is always visible max_height = heights[0] for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given an array `nums` of length `n`, where each element is an integer. You are allowed to **increment** any element of the array by 1 any number of times. Your goal is to make all the elements of the array **pairwise distinct** (no two elements should be equal). Return _the minimum number of increments required to achieve this_.","solution":"def min_increments_to_make_unique(nums): Returns the minimum number of increments needed to make all elements of the array pairwise distinct. nums.sort() increments = 0 for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: needed = nums[i - 1] - nums[i] + 1 nums[i] += needed increments += needed return increments"},{"question":"You are given an array of integers `nums` of length `n` representing the number of points each target has. An archer can shoot at targets in a given range, capturing the points. However, the archer has to rest for one turn after hitting a target before they can continue shooting. Return _the maximum points the archer can accumulate without hitting consecutive targets_.","solution":"def max_points(nums): Returns the maximum points the archer can accumulate without hitting consecutive targets. :param nums: List[int] - List of points each target has. :return: int - Maximum points. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize two variables to store the maximum points without hitting consecutive targets prev1 = nums[0] prev2 = max(nums[0], nums[1]) for i in range(2, n): # Calculate maximum points at current target current = max(prev2, prev1 + nums[i]) # Update the variables for the next iteration prev1, prev2 = prev2, current return prev2"},{"question":"You are given a list of integers `nums` and two integers `x` and `y`. You need to determine whether there exist three distinct elements in `nums` such that their sum equals `x`, and another three distinct elements (not necessarily different from the first three) in `nums` such that their sum equals `y`. Return `True` if both such triplets exist, otherwise return `False`.","solution":"def find_triplets(nums, x, y): Determine whether there exist two sets of three distinct elements in nums such that their sums are x and y, respectively. Parameters: nums (list): List of integers. x (int): Target sum for the first triplet. y (int): Target sum for the second triplet. Returns: bool: True if such triplets exist, otherwise False. from itertools import combinations triplets = list(combinations(nums, 3)) found_x = False found_y = False for triplet in triplets: if sum(triplet) == x: found_x = True if sum(triplet) == y: found_y = True if found_x and found_y: return True return False"},{"question":"Given a `string` S, find the length of the **longest substring** that contains at most `k` distinct characters. If `k` is `0`, return `0`. Implement an algorithm that runs in `O(n)` time complexity where `n` is the length of the string.","solution":"def longest_substring_with_k_distinct_chars(s, k): Finds the length of the longest substring with at most k distinct characters. :param s: Input string :param k: Maximum number of distinct characters in the substring :return: Length of the longest substring with at most k distinct characters if k == 0: return 0 n = len(s) left = 0 right = 0 max_length = 0 char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"Given an integer array `nums`, you need to find a contiguous subarray such that the product of all the elements in this subarray is `positive` and the product is the largest among all contiguous subarrays with a positive product. Return the maximum product you can get. If no such subarray exists, return `0`.","solution":"def max_product_subarray(nums): Returns the maximum product of a contiguous subarray with a positive product. If no such subarray exists, returns 0. if not nums: return 0 max_so_far = 0 max_ending_here = 1 min_ending_here = 1 for num in nums: if num == 0: max_ending_here = 1 min_ending_here = 1 continue temp = max_ending_here * num max_ending_here = max(num * min_ending_here, temp, num) min_ending_here = min(temp, num * min_ending_here, num) if max_ending_here > 0: max_so_far = max(max_so_far, max_ending_here) return max_so_far if max_so_far > 0 else 0"},{"question":"You are given an array of non-negative integers `nums` and an integer `target`. Write a function to find the length of the shortest contiguous subarray that sums to `target`. If there is no such subarray, return `-1`. A subarray is a contiguous portion of an array.","solution":"def min_subarray_len(nums, target): Returns the length of the shortest contiguous subarray that sums to target. If there is no such subarray, returns -1. n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a singly linked list where each node contains an integer value. Write a function to reorder the list such that it alternates between picking a node from the start of the list and then from the end of the list. The function should modify the list in-place. For example, for the linked list `1 -> 2 -> 3 -> 4 -> 5`, the reordered list should be `1 -> 5 -> 2 -> 4 -> 3`. Return the reordered linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): Reorders the linked list such that it alternates between picking a node from the start and the end of the list. :param ListNode head: The head of the linked list. :return: The reordered linked list head. if not head or not head.next: return head def split_half(head): fast = slow = head while fast and fast.next: fast = fast.next.next if fast and fast.next: slow = slow.next mid = slow.next slow.next = None return head, mid def reverse(head): prev = None curr = head while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev def merge_lists(l1, l2): tail = l1 head = tail l1 = l1.next while l2: tail.next = l2 tail = tail.next l2 = l2.next if l1: l1, l2 = l2, l1 return head first_half, second_half = split_half(head) second_half = reverse(second_half) return merge_lists(first_half, second_half)"},{"question":"Implement a function that takes two strings `s1` and `s2`, and returns `true` if `s2` contains an anagram of `s1`, and `false` otherwise. An anagram is formed by rearranging the letters of a string using all the original letters exactly once.","solution":"def contains_anagram(s1, s2): Returns True if s2 contains an anagram of s1, False otherwise. from collections import Counter len_s1 = len(s1) s1_counter = Counter(s1) for i in range(len(s2) - len_s1 + 1): if Counter(s2[i:i+len_s1]) == s1_counter: return True return False"},{"question":"You are given an `m x n` grid filled with non-negative numbers. A robot is initially located at the top-left corner of the grid (i.e., grid[0][0]). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (i.e., grid[m-1][n-1]) with the goal of collecting the maximum amount of points along the way. You cannot revisit any cell. Implement a function `maxPoints(grid)` that calculates the maximum points the robot can collect. Example: ``` Input: grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: 29 Explanation: Path that collects the maximum points is 1  4  7  8  9. ```","solution":"def maxPoints(grid): Returns the maximum points the robot can collect while moving from top-left to bottom-right of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp table with the same size as the grid dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = grid[0][0] # Initialize the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Initialize the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the dp table for the rest of the grid for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The last cell contains the maximum points that can be collected return dp[m - 1][n - 1]"},{"question":"A company has `n` employees numbered from `0` to `n-1` and they work in `m` different departments. The company wants to implement a system where they can group employees based on their departments and list all employees of a particular department in a sorted order. You are given a **0-indexed** integer array `employees` where `employees[i]` denotes the department number that the i-th employee belongs to. You are also given an integer `d` representing the department number you need to query. Write a function that returns a **sorted list** of all the employee numbers who belong to the department `d`. If no employee belongs to the department `d`, return an empty list.","solution":"def get_employees_in_department(employees, d): Returns a sorted list of all the employee numbers who belong to the department `d`. Parameters: employees (list): A list where employees[i] denotes the department number that the i-th employee belongs to. d (int): The department number to query. Returns: list: Sorted list of employee numbers who belong to department `d`. employees_in_department = [i for i, dept in enumerate(employees) if dept == d] return sorted(employees_in_department)"},{"question":"You are given a list of `n` intervals `[start, end]` representing the working hours of `n` employees in a company. Each interval `[start_i, end_i]` indicates the times when employee `i` is available. Return a list of intervals during which all employees are simultaneously available. If there is no common interval, return an empty list. The intervals in the output list should be disjoint and sorted by the start time.","solution":"def common_intervals(intervals): Returns a list of intervals during which all employees are simultaneously available. Args: intervals (List[List[int]]): A list of intervals representing the working hours of employees. Returns: List[List[int]]: A list of common intervals when all employees are simultaneously available. if not intervals: return [] # Sort intervals by the start time intervals.sort(key=lambda x: x[0]) # Initialize the common availability window as the first employee\'s interval common_avail = intervals[0] for interval in intervals[1:]: if interval[0] > common_avail[1] or interval[1] < common_avail[0]: # No overlap return [] else: common_avail[0] = max(common_avail[0], interval[0]) common_avail[1] = min(common_avail[1], interval[1]) return [common_avail]"},{"question":"You are given a 2D grid of characters and a word. The grid is represented as a list of lists of characters, and the word is a string. Your task is to determine if the word can be constructed from a sequence of adjacent cells in the grid. The word can be constructed by moving horizontally or vertically from one cell to another. However, the same cell cannot be used more than once in the construction of the word. Return _True_ if the word can be formed, otherwise return _False_.","solution":"def exist(board, word): Determine if the word can be constructed from the grid by moving horizontally or vertically. :param board: List[List[str]] - 2D grid of characters :param word: str - The word to search for :return: bool - True if the word can be formed, otherwise False if not board or not word: return False rows, cols = len(board), len(board[0]) def dfs(x, y, index): if index == len(word): return True if x < 0 or y < 0 or x >= rows or y >= cols or board[x][y] != word[index]: return False # Temporarily mark the cell as visited temp, board[x][y] = board[x][y], \'#\' found = (dfs(x+1, y, index+1) or dfs(x-1, y, index+1) or dfs(x, y+1, index+1) or dfs(x, y-1, index+1)) # Unmark the cell board[x][y] = temp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"Given an array of integers `nums` and an integer `k`, you are tasked with rearranging the array such that it meets the following conditions: For every i (0 <= i < len(nums) - k), `nums[i] <= nums[i + k]`. If there are multiple solutions, return any one of them. If it is not possible to rearrange the array to meet the condition, return an empty list.","solution":"def rearrange_array(nums, k): Rearranges the array such that for every i (0 <= i < len(nums) - k), nums[i] <= nums[i + k]. If there are multiple solutions, returns any one of them. If it is not possible to rearrange the array to meet the condition, returns an empty list. # Sort the array to start with the smallest elements nums.sort() # If the array has less than k elements, return an empty array if len(nums) < k: return [] # Initialize the result array result = [0] * len(nums) # Split the sorted array into two halves for i in range(len(nums)): if i % 2 == 0: result[i // 2] = nums[i] else: result[len(nums) // 2 + i // 2] = nums[i] # Check if the result array meets the conditions for i in range(len(nums) - k): if result[i] > result[i + k]: return [] return result"},{"question":"Given a binary tree, implement the `BinaryTree` class with the following methods: * `BinaryTree()` initializes the binary tree with an empty root. * `void insert(int value)` inserts a node with the given value into the binary tree maintaining the binary search tree property. * `boolean find(int value)` returns `true` if there exists a node in the binary tree with the given value, otherwise returns `false`. * `int getMaxDepth()` returns the maximum depth of the binary tree.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left: self._insert_recursive(node.left, value) else: node.left = Node(value) elif value > node.value: if node.right: self._insert_recursive(node.right, value) else: node.right = Node(value) def find(self, value): return self._find_recursive(self.root, value) def _find_recursive(self, node, value): if node is None: return False if node.value == value: return True elif value < node.value: return self._find_recursive(node.left, value) else: return self._find_recursive(node.right, value) def getMaxDepth(self): return self._get_max_depth(self.root) def _get_max_depth(self, node): if not node: return 0 left_depth = self._get_max_depth(node.left) right_depth = self._get_max_depth(node.right) return max(left_depth, right_depth) + 1"},{"question":"You are given an array `operations` where each element is one of the following strings: `\\"PUSH x\\"`, `\\"POP\\"`, or `\\"PUSH_WITH_MIN\\"`, representing a sequence of stack operations. `\\"PUSH x\\"` pushes integer `x` onto the stack, `\\"POP\\"` removes the top element of the stack if it is not empty, and `\\"PUSH_WITH_MIN\\"` pushes the minimum element currently in the stack. Implement a function that returns the final state of the stack after performing all operations in the given order. If an operation attempts to `\\"POP\\"` from an empty stack or `\\"PUSH_WITH_MIN\\"` when the stack is empty, ignore that operation.","solution":"def perform_operations(operations): stack = [] for operation in operations: if operation.startswith(\\"PUSH \\"): _, x = operation.split() stack.append(int(x)) elif operation == \\"POP\\" and stack: stack.pop() elif operation == \\"PUSH_WITH_MIN\\" and stack: stack.append(min(stack)) return stack"},{"question":"Given a 2D grid of characters `grid` and a string `word`, return _true_ if _word_ exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in the word. For example, consider the following grid: ``` [ [\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\'] ] ``` Given `word = \\"ABCCED\\"`, return true. Given `word = \\"SEE\\"`, return true. Given `word = \\"ABCB\\"`, return false. The function signature is: ``` boolean exist(char[][] grid, String word) ```","solution":"def exist(grid, word): rows, cols = len(grid), len(grid[0]) def dfs(r, c, idx): if idx == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[idx]: return False temp = grid[r][c] grid[r][c] = \'#\' found = (dfs(r + 1, c, idx + 1) or dfs(r - 1, c, idx + 1) or dfs(r, c + 1, idx + 1) or dfs(r, c - 1, idx + 1)) grid[r][c] = temp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"A company is developing an event management system where they need to manage a variety of events happening over different dates. Each event has a unique identifier and a start and end date. Implement the `EventManager` class to manage these events efficiently. The functionalities required are adding an event, removing an event, checking if an event overlaps with another event, and retrieving events happening on a given date. Implement the `EventManager` class: * `EventManager()`: Initializes the object. * `void addEvent(int eventId, String startDate, String endDate)`: Adds an event with the given `eventId`, `startDate`, and `endDate` to the system. * `void removeEvent(int eventId)`: Removes the event with the given `eventId` from the system. * `boolean isOverlapping(int eventId1, int eventId2)`: Checks if the event with `eventId1` overlaps with the event with `eventId2`. Returns `true` if they overlap, otherwise returns `false`. * `List<Integer> getEvents(String date)`: Returns a list of event IDs that are happening on the given `date`. If no events are found, returns an empty list. An event is considered overlapping if there is any common date between the start and end dates of the two events. The date format is \\"YYYY-MM-DD\\".","solution":"from datetime import datetime class EventManager: def __init__(self): self.events = {} def addEvent(self, eventId, startDate, endDate): start = datetime.strptime(startDate, \\"%Y-%m-%d\\") end = datetime.strptime(endDate, \\"%Y-%m-%d\\") self.events[eventId] = (start, end) def removeEvent(self, eventId): if eventId in self.events: del self.events[eventId] def isOverlapping(self, eventId1, eventId2): if eventId1 not in self.events or eventId2 not in self.events: return False start1, end1 = self.events[eventId1] start2, end2 = self.events[eventId2] return not (end1 < start2 or end2 < start1) def getEvents(self, date): check_date = datetime.strptime(date, \\"%Y-%m-%d\\") return [eventId for eventId, (start, end) in self.events.items() if start <= check_date <= end]"},{"question":"Given an array of integers `nums` and an integer `k`, return _the number of unique continuous subarrays that sum to_ `k`. A subarray is a contiguous part of an array.","solution":"def subarray_sum(nums, k): Returns the number of unique continuous subarrays that sum to k. :param nums: List[int] - The input array of integers. :param k: int - The target sum. :return: int - The number of unique continuous subarrays that sum to k. count = 0 sum_count = {0: 1} current_sum = 0 for num in nums: current_sum += num if current_sum - k in sum_count: count += sum_count[current_sum - k] if current_sum in sum_count: sum_count[current_sum] += 1 else: sum_count[current_sum] = 1 return count"},{"question":"A company has `n` employees, and each employee has a unique ID number from `0` to `n-1`. You are given a list of friendships where each friendship is represented as a pair of employee IDs who are friends. Two employees are directly friends if they share a pair in the list, and indirectly friends if they are connected through a chain of direct friendships. A **closure** of a friendship group is a new group of employees, such that any employee in the group is friends with every other employee in the group. Your task is to determine the size of the smallest friendship group closure that includes all `n` employees, if possible. If it\'s not possible to include all employees in a single closure, return `-1`.","solution":"def smallest_friendship_closure(n, friendships): from collections import defaultdict, deque def bfs(start): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) if not friendships and n > 1: # No friendships at all but multiple employees return -1 graph = defaultdict(list) for a, b in friendships: graph[a].append(b) graph[b].append(a) visited = set() components = 0 for employee in range(n): if employee not in visited: components += 1 bfs(employee) if components > 1: return -1 return n"},{"question":"You are given a binary tree with `n` nodes. Each node in the tree has a value corresponding to an integer. Design the `BinaryTree` class and implement the following methods: * `BinaryTree(int[] values)` - Constructs the binary tree from an array of integers (values in level order). * `int findMaxDepth()` - Returns the maximum depth of the binary tree. * `boolean checkPathSum(int sum)` - Returns `true` if there is a path from the root to a leaf such that adding up all the values along the path equals the given sum, otherwise returns `false`. The binary tree will have at least one node and the array values given to construct the tree are guaranteed to form a valid binary tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, values): if not values: raise ValueError(\\"Values array must not be empty\\") self.root = self.construct_tree(values) def construct_tree(self, values): nodes = [None if val is None else TreeNode(val) for val in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root def findMaxDepth(self): def max_depth(node): if not node: return 0 left_depth = max_depth(node.left) right_depth = max_depth(node.right) return max(left_depth, right_depth) + 1 return max_depth(self.root) def checkPathSum(self, sum): def has_path_sum(node, current_sum): if not node: return False current_sum += node.value if not node.left and not node.right: return current_sum == sum return has_path_sum(node.left, current_sum) or has_path_sum(node.right, current_sum) return has_path_sum(self.root, 0)"},{"question":"Given the `root` of a binary tree, return the list of nodes you encounter during a **zigzag level order traversal** of the tree. A **zigzag level order traversal** is a traversal of nodes where the nodes at each level are visited alternately left to right and then right to left. For instance, the traversal starting at the root level goes left to right, the next level goes right to left, and this continues alternating for each subsequent level.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Perform a zigzag level order traversal of a binary tree. :param root: TreeNode :return: List[List[int]] if not root: return [] results = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) results.append(list(level_nodes)) left_to_right = not left_to_right return results"},{"question":"You are given a string `s` containing only lowercase alphabetic characters. A substring is defined as any contiguous sequence of characters within the string. Your task is to find the length of the longest substring that contains exactly `k` distinct characters. If there is no such substring, return `0`. Example: ```plaintext Input: s = \\"eceba\\", k = 2 Output: 3 Explanation: The substring is \\"ece\\" with length 3. ``` ```plaintext Input: s = \\"aa\\", k = 1 Output: 2 Explanation: The substring is \\"aa\\" with length 2. ```","solution":"def length_of_longest_substring_k_distinct(s, k): if k == 0: return 0 from collections import defaultdict char_map = defaultdict(int) left = 0 max_len = 0 for right, char in enumerate(s): char_map[char] += 1 while len(char_map) > k: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a list of work-related tasks represented as a list of intervals `tasks`, where `tasks[i] = [start, end]` represents the start and end times of the `i-th` task. Each task can only be assigned to one worker. Workers are assigned tasks such that no two tasks assigned to the same worker overlap. Return _the minimum number of workers required to complete all tasks without any overlap_. [Input] Example: - `tasks = [[1, 3], [2, 4], [3, 5]]` [Output] Example: - `Output: 2`","solution":"def min_workers(tasks): Returns the minimum number of workers required to complete all tasks without any overlap. if not tasks: return 0 # Sort tasks based on start time tasks.sort(key=lambda x: x[0]) # Use a min heap to track the end time of tasks import heapq end_times = [] # Go through each task for task in tasks: start, end = task # If the earliest ending task ends before the current task start, # they can be assigned to the same worker. if end_times and end_times[0] <= start: heapq.heappop(end_times) # Assign the current task (add its end time to the heap) heapq.heappush(end_times, end) # The heap size will be the number of workers needed return len(end_times)"},{"question":"Given a list of integers representing the heights of buildings on a street, and a positive integer `D`, your task is to determine whether it\'s possible to place `D` billboards on some of these buildings such that no two billboards are on buildings that are side by side. Return `True` if it is possible to place the billboards under the given constraints, otherwise return `False`. Example: ``` buildings = [4, 2, 3, 7, 4, 5] D = 3 ``` Output: ``` True ```","solution":"def can_place_billboards(buildings, D): Determines if it\'s possible to place D billboards on buildings such that no two billboards are on side by side buildings. Parameters: buildings (list): List of integers representing the heights of buildings. D (int): Number of billboards to place. Returns: bool: True if possible to place D billboards with the given constraints, otherwise False. n = len(buildings) # If there are less buildings than number of billboards, return False if D > n: return False # Greedily place billboards at every other building until we place all D billboards count = 0 i = 0 while i < n: count += 1 if count == D: return True i += 2 return False"},{"question":"Given a 0-indexed integer array `nums` of length `n`, you need to divide the array into one or more contiguous subarrays. Each subarray should contain at least one element. After dividing the array, you have to check the sum of elements within each subarray. If the sum is even, assign it a value of `0`, and if the sum is odd, assign it a value of `1`. Your goal is to return the minimum number of subarrays needed such that the XOR of all assigned values is `1`. Return _the **minimum number of subarrays** required to achieve this goal_.","solution":"def min_subarray_xor_odd(nums): Determines the minimum number of subarrays such that the XOR of the sums\' parities is 1. Args: nums (list): The list of integers. Returns: int: The minimum number of subarrays. # XOR of parity indicates that we need at least one subarray with odd sum. odd_count = 0 for num in nums: if num % 2 != 0: odd_count += 1 # If there are no odd elements, we cannot achieve an XOR of 1. if odd_count == 0: return -1 # Not possible to have an XOR of 1. # Minimum number of subarrays required is 1 if there is at least one odd element return 1"},{"question":"You are given a **0-indexed** integer array `nums` where each element represents the number of units of water in a container. Every day, rainwater adds one more unit of water to each container. Given `d` days, return the number of containers that overflow after `d` days. Assume a container overflows if the amount of water reaches or exceeds a given integer threshold, `threshold`. Each container is independent in terms of exceeding the threshold.","solution":"def count_overflowing_containers(nums, d, threshold): Returns the number of containers that overflow after d days. Parameters: nums (list): List of integer units of water in each container. d (int): Number of days of rain. threshold (int): The threshold units of water for a container to overflow. Returns: int: Number of containers that overflow. overflow_count = 0 for water in nums: if water + d >= threshold: overflow_count += 1 return overflow_count"},{"question":"Given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image **in-place**, which means you have to modify the input 2D matrix directly. **Do not** return anything from your function. The rotation should be done in layers, starting with the outermost layer and working your way towards the inner layers. In other words, if you have: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` After rotating, the matrix should become: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"def rotate(matrix): Rotates the given n x n 2D matrix by 90 degrees (clockwise) in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Write a function `rotateMatrix` that rotates an `n x n` 2D matrix by 90 degrees clockwise. The rotation should be performed in-place, meaning you cannot use any other matrix to perform the rotation. The matrix is represented by an array of arrays, where each inner array represents a row in the matrix. Return the modified matrix after the rotation. For example, given the matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The function should modify it to: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"def rotateMatrix(matrix): Rotates an n x n 2D matrix by 90 degrees clockwise in-place. Args: matrix: List[List[int]], the 2D matrix to be rotated. Returns: List[List[int]]: The rotated 2D matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"Given a list of integers `nums` and an integer `target`, write a function to find two distinct indices `i` and `j` such that `nums[i]` and `nums[j]` add up to `target`. Return the indices as a list `[i, j]` in any order. If no such indices exist, return an empty list `[]`.","solution":"def two_sum(nums, target): Finds two distinct indices i and j such that nums[i] + nums[j] == target. :param nums: List of integers. :param target: The target integer. :return: List containing the indices [i, j] or an empty list if no such indices exist. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"You are given a **0-indexed** string `s` consisting of only lowercase English letters. A **subsequence** is derived from `s` by deleting zero or more characters without changing the order of the remaining characters. A **unique subsequence** is a subsequence that appears only once in `s`. Return _the length of the longest **unique subsequence** in_ `s`. If no such subsequence exists, return `-1`.","solution":"from collections import Counter def length_of_longest_unique_subsequence(s): Returns the length of the longest unique subsequence in the given string s. If no such subsequence exists, returns -1. frequency = Counter(s) if all(count > 1 for count in frequency.values()): return -1 # Get all unique characters (those with a count of 1) unique_subseq = \'\'.join([char for char, count in frequency.items() if count == 1]) return len(unique_subseq) if unique_subseq else -1"},{"question":"You are given a matrix `grid` where each cell contains a non-negative integer representing the height of a building. You can move left, right, up, or down from a cell to the next only if the height of the next cell is less than or equal to 1 unit higher than the current cell. You need to find the minimum height difference path starting from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1). Return _the minimum height difference_ for such a path. Implement the function: ```python def minHeightDifference(grid: List[List[int]]) -> int: pass ```","solution":"from typing import List import heapq def minHeightDifference(grid: List[List[int]]) -> int: n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_diff = [[float(\'inf\')] * m for _ in range(n)] pq = [(0, 0, 0)] # (difference, row, column) min_diff[0][0] = 0 while pq: diff, x, y = heapq.heappop(pq) if (x, y) == (n - 1, m - 1): return diff for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_diff = max(diff, abs(grid[nx][ny] - grid[x][y])) if new_diff < min_diff[nx][ny]: min_diff[nx][ny] = new_diff heapq.heappush(pq, (new_diff, nx, ny)) return -1"},{"question":"You are given a `d x n` matrix grid representing a cityscape, where `d` is the number of days and `n` is the number of houses. Each element `grid[i][j]` represents the amount of pollution at house `j` on day `i`. The goal is to reduce pollution by planting trees. On each day, you can plant one tree at any house `j`, reducing its pollution to zero for that day and every subsequent day. Return _the minimum number of trees you need to plant so that no house exceeds the pollution threshold `k` on any day_. It is guaranteed that a solution always exists. For example, given `d = 3`, `n = 4`, `grid = [[3, 8, 4, 1], [2, 10, 7, 3], [5, 6, 3, 4]]`, and `k = 5`, you need to plant a minimum of 3 trees. You could plant one tree in the second column on day 0, another in the first column on day 1, and another in the third column on day 1.","solution":"def min_trees_to_plant(grid, k): Returns the minimum number of trees needed to plant so that no house exceeds the pollution threshold k on any day. d = len(grid) n = len(grid[0]) trees_planted = 0 pollution = [grid[i][j] for j in range(n) for i in range(d)] for day in range(d): for house in range(n): if grid[day][house] > k: pollution[day*n+house] = 0 for future_day in range(day, d): grid[future_day][house] = 0 trees_planted += 1 return trees_planted"},{"question":"Given a list of words, create a function to find all the pairs of indices (i, j) such that the concatenation of words[i] and words[j] is a palindrome. A palindrome is a word that reads the same backward as forward. Return the list of pairs sorted in lexicographical order according to the pair values. For example, with the input words = [\\"bat\\", \\"tab\\", \\"cat\\"], the output should be [[0, 1], [1, 0]] because \\"battab\\" and \\"tabbat\\" are palindromes.","solution":"def is_palindrome(word): Checks if a given word is a palindrome. return word == word[::-1] def palindrome_pairs(words): Finds all pairs of indices (i, j) such that the concatenation of words[i] and words[j] is a palindrome. Returns the list of pairs sorted in lexicographical order according to the pair values. pairs = [] for i in range(len(words)): for j in range(len(words)): if i != j: combined = words[i] + words[j] if is_palindrome(combined): pairs.append([i, j]) pairs.sort() return pairs"},{"question":"You are given a **0-indexed** array `nums` consisting of non-negative integers with `n` elements. You are also given an integer `k`. Define the operation `k-sum` on the array as the process of summing every `k-th` element starting from the beginning of the array, wrapping back to the start if necessary. Formally, the `k-sum` is computed as: `nums[0] + nums[k] + nums[2k] + ... + nums[(m-1)k]` where `m` is the largest integer such that `(m-1)k < n`. If `k` is such that no elements are summed, return `0`. Return _the value of the `k-sum` for the given array and integer_.","solution":"def k_sum(nums, k): Returns the k-sum of the array `nums`. Parameters: nums (list): A list of non-negative integers. k (int): The step value. Returns: int: The k-sum value. if k <= 0: return 0 n = len(nums) k_sum_value = 0 for i in range(0, n, k): k_sum_value += nums[i] return k_sum_value"},{"question":"You are given an array of integers `nums` and an integer `k`. A **subarray** is defined as a contiguous part of the array. A subarray is called **distinct** if each element in the subarray appears exactly once. Return _the number of **distinct subarrays** of length exactly `k` in_ `nums`.","solution":"def count_distinct_subarrays(nums, k): Returns the number of distinct subarrays of length exactly k in nums. Each element in the subarray must appear exactly once. if k > len(nums): return 0 distinct_subarray_count = 0 for i in range(len(nums) - k + 1): subarray = nums[i:i + k] if len(subarray) == len(set(subarray)): distinct_subarray_count += 1 return distinct_subarray_count"},{"question":"You are given an array of integers `arr` where elements might appear more than once. Return an array of all the _unique elements_ in `arr` sorted in **ascending order** by their first occurrence in the original array. For example, given `arr = [4, 5, 6, 4, 1, 5, 1]`, the result should be `[4, 5, 6, 1]`.","solution":"def unique_elements_sorted_by_first_occurrence(arr): Returns the list of unique elements sorted by their first occurrence in the original array. seen = set() result = [] for element in arr: if element not in seen: seen.add(element) result.append(element) return result"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, determine if it is possible to split the array into exactly `k` subarrays such that each subarray is strictly increasing. Each subarray must contain at least one element. Return `true` if such a split is possible, otherwise return `false`.","solution":"def can_split_into_k_subarrays(nums, k): Determines if it is possible to split the array into exactly k subarrays such that each subarray is strictly increasing. Parameters: nums (list): A list of integers. k (int): Number of subarrays to split into. Returns: bool: True if it\'s possible to split into k strictly increasing subarrays, False otherwise. if k > len(nums): return False increasing_subarrays = 1 # We start with at least one subarray for i in range(1, len(nums)): if nums[i] > nums[i - 1]: continue increasing_subarrays += 1 return increasing_subarrays <= k"},{"question":"You are given a `0-indexed` 2D integer array `buildings` where `buildings[i] = [xi, hi]`. `xi` denotes the X-coordinate of the ith building, and `hi` denotes the height of the ith building. A building is visible if there is no other taller building to its right (i.e., with a greater X-coordinate). Return the _number of visible buildings_ from left to right.","solution":"def count_visible_buildings(buildings): Returns the number of visible buildings from left to right. Arguments: buildings -- a list of lists where each sublist contains two integers [xi, hi] xi: the X-coordinate of the building hi: the height of the building Returns: int -- the number of visible buildings if not buildings: return 0 visible_count = 0 max_height_so_far = 0 # Traverse the buildings from left to right for x, h in buildings: if h > max_height_so_far: visible_count += 1 max_height_so_far = h return visible_count"},{"question":"Given an integer `n`, return _a list of all possible unique binary trees with exactly `n` nodes_ where each node has a unique value from `1` to `n`. Each binary tree should be represented by a root node of type `TreeNode`. Implement the `TreeNode` class with the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` For example, given `n = 3`, your function should return all possible unique binary trees that can be constructed using nodes `1`, `2`, and `3`. Illustrate the unique trees using their root nodes.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n: int) -> List[TreeNode]: if n == 0: return [] def generate_trees(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): # Generate all left and right subtrees recursively left_trees = generate_trees(start, i - 1) right_trees = generate_trees(i + 1, end) # Connect left and right subtrees to the root `i` for left in left_trees: for right in right_trees: current_tree = TreeNode(i) current_tree.left = left current_tree.right = right all_trees.append(current_tree) return all_trees return generate_trees(1, n)"},{"question":"You are given a string `colors` representing the colors of the houses on a street. The string consists of characters `\'R\'`, `\'G\'`, and `\'B\'` where `\'R\'` stands for a red house, `\'G\'` stands for a green house, and `\'B\'` stands for a blue house. No two adjacent houses should be painted the same color. You are allowed to repaint some houses to achieve this condition. Return _the **minimum** number of repaints required to make sure no two adjacent houses have the same color_.","solution":"def min_repaints(colors): Returns the minimum number of repaints required such that no two adjacent houses have the same color, given a string colors. if not colors: return 0 n = len(colors) repaint_count1 = 0 # start with first house as \'R\' repaint_count2 = 0 # start with first house as \'G\' previous_color1 = \'R\' previous_color2 = \'G\' for i in range(n): if colors[i] == previous_color1: repaint_count1 += 1 previous_color1 = get_next_color(previous_color1, colors, i) else: previous_color1 = colors[i] if colors[i] == previous_color2: repaint_count2 += 1 previous_color2 = get_next_color(previous_color2, colors, i) else: previous_color2 = colors[i] return min(repaint_count1, repaint_count2) def get_next_color(previous, colors, i): Get the next color different from the previous one and the next one in the list. if previous == \'R\': return \'G\' if i+1 >= len(colors) or colors[i+1] != \'G\' else \'B\' elif previous == \'G\': return \'R\' if i+1 >= len(colors) or colors[i+1] != \'R\' else \'B\' else: # previous == \'B\' return \'R\' if i+1 >= len(colors) or colors[i+1] != \'R\' else \'G\'"},{"question":"Given a string `s`, return _the length of the longest substring without repeating characters._ For example, the length of the longest substring without repeating characters in \\"abcabcbb\\" is 3, which corresponds to \\"abc\\". Use the sliding window technique to solve this problem efficiently.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"Given a binary tree, imagine that each node has a \\"next\\" pointer that points to its next right node. If there is no next right node, the next pointer should be set to `null`. Initially, all next pointers are set to `null`. Populate each next pointer to point to its next right node. The tree is a perfect binary tree (every level except possibly the last is completely filled, and all nodes are as far left as possible). Return the root node of the tree after updating the next pointers.","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Populate each next pointer to point to its next right node. if not root: return root leftmost = root # Traverse the tree level by level while leftmost.left: head = leftmost while head: head.left.next = head.right if head.next: head.right.next = head.next.left head = head.next leftmost = leftmost.left return root"},{"question":"Implement a function `isRotation` that checks if one string is a rotation of another. Given two strings `s1` and `s2`, your function should return `true` if `s2` is a rotation of `s1`, and `false` otherwise. A string `s2` is a rotation of `s1` if we can split `s1` into two parts `x` and `y` such that when we concatenate `y` and `x`, we get `s2`. Example: - `isRotation(\\"waterbottle\\", \\"erbottlewat\\")` returns `true`. - `isRotation(\\"hello\\", \\"lohel\\")` returns `true`. - `isRotation(\\"hello\\", \\"world\\")` returns `false`.","solution":"def isRotation(s1, s2): Returns true if s2 is a rotation of s1, false otherwise. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"A company has multiple branches each identified by unique IDs. The profit generated by each branch over the first quarter of the year is given in an array `profits`, where `profits[i]` represents the profit made by the branch with ID `i`. Write a function that returns an array of branch IDs sorted in descending order of their profits. If two branches have the same profit, they should be ordered by their IDs in ascending order. For example, if the input array `profits` is `[300, 500, 300]`, the output should be `[1, 0, 2]`.","solution":"def sort_branches_by_profits(profits): Returns a list of branch IDs sorted in descending order of their profits. If two branches have the same profit, they are ordered by their IDs in ascending order. :param profits: List of profits where profits[i] is the profit of branch with ID i :return: List of branch IDs sorted by profits descending, then IDs ascending # Create a list of tuples (id, profit) branches = [(i, profit) for i, profit in enumerate(profits)] # Sort by profit descending and then by id ascending branches.sort(key=lambda x: (-x[1], x[0])) # Extract sorted ids sorted_ids = [branch[0] for branch in branches] return sorted_ids"},{"question":"You are given a list of strings `words`, where each string consists of lower-case English letters. Your task is to find and return the longest string in `words` that can be constructed using the letters of another string `target`. Each letter in `target` can only be used as many times as it appears in `target`. If there is a tie, return any one of the longest strings. If no words can be constructed, return an empty string.","solution":"from collections import Counter def can_construct_from_target(word, target_counter): word_counter = Counter(word) for letter in word_counter: if word_counter[letter] > target_counter.get(letter, 0): return False return True def longest_constructible_word(words, target): target_counter = Counter(target) longest_word = \\"\\" for word in words: if can_construct_from_target(word, target_counter): if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"You are given a `m x n` matrix consisting of non-negative integers and extractions of submatrix sums from it. Each submatrix is defined by its top-left corner `(row1, col1)` and bottom-right corner `(row2, col2)`. Your task is to write a function to return the sum of the elements in the submatrix defined by these coordinates. The function should be able to handle multiple queries efficiently.","solution":"class NumMatrix: def __init__(self, matrix): Initializes the NumMatrix object with the matrix, and preprocesses it to compute the prefix sum for efficient submatrix sum queries. if not matrix or not matrix[0]: self.prefixSum = [] return m, n = len(matrix), len(matrix[0]) self.prefixSum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): self.prefixSum[i + 1][j + 1] = matrix[i][j] + self.prefixSum[i + 1][j] + self.prefixSum[i][j + 1] - self.prefixSum[i][j] def sumRegion(self, row1, col1, row2, col2): Returns the sum of the elements within the rectangle defined by (row1, col1) and (row2, col2), inclusive. return self.prefixSum[row2 + 1][col2 + 1] - self.prefixSum[row1][col2 + 1] - self.prefixSum[row2 + 1][col1] + self.prefixSum[row1][col1]"},{"question":"You are given a 2D grid of characters `grid` and a word `word`. Find all occurrences of the word in the grid, where a word can be constructed from letters of sequentially adjacent cells, horizontally or vertically. The same letter cell may not be used more than once in constructing the word. Return the starting positions of each occurrence of the word in the grid. The positions should be returned as a list of tuples, where each tuple contains the row and column indices of the starting position. Example: ``` grid = [ [\'C\', \'A\', \'T\'], [\'A\', \'G\', \'T\'], [\'T\', \'G\', \'A\'] ] word = \\"CAT\\" ``` Output: [(0, 0)] Explanation: The word \\"CAT\\" starts at position (0, 0) in the grid.","solution":"def find_word(grid, word): def dfs(x, y, word_index): if word_index == len(word): return True if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != word[word_index]: return False temp, grid[x][y] = grid[x][y], \\"#\\" found = dfs(x+1, y, word_index+1) or dfs(x-1, y, word_index+1) or dfs(x, y+1, word_index+1) or dfs(x, y-1, word_index+1) grid[x][y] = temp return found rows, cols = len(grid), len(grid[0]) starting_positions = [] for i in range(rows): for j in range(cols): if grid[i][j] == word[0] and dfs(i, j, 0): starting_positions.append((i, j)) return starting_positions"},{"question":"You are given an array of `n` integers `arr` and an integer `k`. Your task is to partition the array into two non-empty subarrays such that the absolute difference between the sum of the elements in the left subarray and the sum of the elements in the right subarray is minimized. If there are multiple ways to partition the array, return the lexicographically smallest partition point. Return the index `i` such that the sum of elements from `arr[0]` to `arr[i-1]` (left subarray) and the sum of elements from `arr[i]` to `arr[n-1]` (right subarray) minimizes the absolute difference between the two sums.","solution":"def minimum_partition(arr): Function to find the partition point which minimizes the absolute difference between the sum of the left and right subarrays. Parameters: arr (List[int]): The input array Returns: int: The index at which the partition should be made n = len(arr) total_sum = sum(arr) left_sum = 0 min_diff = float(\'inf\') partition_index = -1 for i in range(1, n): left_sum += arr[i-1] right_sum = total_sum - left_sum diff = abs(left_sum - right_sum) if diff < min_diff: min_diff = diff partition_index = i return partition_index"},{"question":"You are given a string `s` consisting only of characters `\'a\'`, `\'b\'`, and `\'c\'`. You can delete any number of characters from `s` to create a new string. The score of the new string is defined as the total number of substrings that contain only the character `\'a\'`. Write a function that returns the **maximum score** that can be achieved by deleting characters from `s`.","solution":"def maximum_score(s): Returns the maximum score that can be achieved by deleting characters from s. The score is defined as the total number of substrings that contain only the character \'a\'. # The maximum score is achieved by retaining all \'a\'s in the string # as every substring with \'a\' adds to the score. # The score for \'a\'s is the sum of the first k natural numbers where k is the count of \'a\'s in the substring. # This is calculated by k*(k+1)//2. a_count = s.count(\'a\') return a_count * (a_count + 1) // 2"},{"question":"You are given a **0-indexed** integer array `arr` consisting of positive integers. In one operation, you can choose any subarray of `arr` and increase each element within that subarray by `1`. Return _the minimum number of operations required to make all the elements in the array equal_.","solution":"def min_operations_to_equal_elements(arr): Returns the minimum number of operations required to make all the elements in the array equal. min_value = min(arr) operations = sum(x - min_value for x in arr) return operations"},{"question":"You are given a list of integers `rectangles` where `rectangles[i]` represents the width of a rectangle with a height of 1. You need to find the largest rectangle that can be formed by combining any number of consecutive rectangles in the list. Return the area of the largest rectangle that can be formed.","solution":"def largestRectangleArea(rectangles): Find the largest rectangle that can be formed by combining consecutive rectangles. :param rectangles: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(rectangles): if not stack or rectangles[index] >= rectangles[stack[-1]]: stack.append(index) index += 1 else: height = rectangles[stack.pop()] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) while stack: height = rectangles[stack.pop()] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"You are organizing a string manipulation coding challenge and want to create a function that can find and replace words in a given string. Given a string `text` and a 2D list `substitutions`, where each element in `substitutions` is a list of two strings `[old_word, new_word]`, write a function that performs all substitutions in the order they appear in the list. Your function should replace every occurrence of `old_word` with `new_word` within `text`. Return the modified `text` after all replacements have been made. For example, given `text` = \\"the quick brown fox jumps over the lazy dog\\" and `substitutions` = [[\\"quick\\", \\"slow\\"], [\\"fox\\", \\"cat\\"], [\\"lazy\\", \\"energetic\\"]], the function should return \\"the slow brown cat jumps over the energetic dog\\".","solution":"def replace_words(text, substitutions): Replaces words in the given text according to the substitutions list. :param text: The input string where words need to be replaced. :param substitutions: A 2D list containing lists of two strings [old_word, new_word]. :return: The modified text after all replacements. for old_word, new_word in substitutions: text = text.replace(old_word, new_word) return text"},{"question":"You are given an integer array `heights` representing the heights of buildings in a city, where `heights[i]` is the height of the `i`-th building. A building is considered to have an **excellent view** if you can see the ocean horizon from that building without any taller building obscuring the view. The ocean is to the right of all buildings (i.e., to the east). Determine which buildings have an excellent view and return their indices in ascending order. Implement a function `List<Integer> buildingsWithView(int[] heights)` that takes the integer array `heights` and returns a list of indices of buildings that have an excellent view.","solution":"def buildings_with_view(heights): Returns a list of indices of buildings that have an excellent view of the ocean. The ocean is to the east, meaning to the right of all buildings. A building has an excellent view if there are no taller buildings between it and the ocean. Args: heights (list of int): List of building heights Returns: list of int: List of indices of buildings with an excellent view n = len(heights) result = [] if n == 0: return result max_height = -1 for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1] # reverse to get ascending order of indices"},{"question":"You are given two arrays `nums1` and `nums2` both of which contain positive integers. Write a function that returns the result of merging the two arrays following these conditions: - The combined array should contain all elements from both `nums1` and `nums2`. - Both `nums1` and `nums2` initially contain unique elements. - The order of elements from the merged array should be the same as their appearance in either `nums1` or `nums2`. - If there are common elements in both arrays, they should appear only once in the merged array, and their position is determined by their first occurrence in the concatenated sequence of `nums1` followed by `nums2`. For example, given `nums1 = [1, 3, 2, 4]` and `nums2 = [3, 5, 6]`, the function should return `[1, 3, 2, 4, 5, 6]`.","solution":"def merge_arrays(nums1, nums2): Merges two arrays, maintaining their original order and ensuring unique elements. If an element appears in both arrays, it is included once in the result based on its first occurrence in nums1 followed by nums2. merged = [] seen = set() for num in nums1 + nums2: if num not in seen: merged.append(num) seen.add(num) return merged"},{"question":"You are given a list of integers `weights` representing the weights of parcels you need to deliver. Each parcel can be delivered individually or combined with one or two other parcels in a single trip, provided the total weight of the trip does not exceed the weight limit `limit`. Return _the **minimum number of trips** required to deliver all parcels, given that each trip can carry up to `limit` weight_.","solution":"def min_trips(weights, limit): Returns the minimum number of trips required to deliver parcels given weight limit per trip. weights.sort() i, j = 0, len(weights) - 1 trips = 0 while i <= j: if weights[j] + (weights[i] if i != j else 0) <= limit: i += 1 j -= 1 trips += 1 return trips"},{"question":"You are given a 2D matrix of characters `board` representing an `m x n` grid, and a string `word`. You need to determine if there is a path in the board that spells out the given word. The path can start from any cell in the grid and move either up, down, left, or right, but not diagonally. However, a cell cannot be reused in the same path. Return `true` if such a path exists and `false` otherwise.","solution":"def exist(board, word): Determines if there is a path in the board that spells out the given word. :param board: List[List[str]], the board of characters :param word: str, the word to look for in the board :return: bool, True if there is a path that spells out the word, False otherwise if not board or not board[0]: return False rows, cols = len(board), len(board[0]) def dfs(x, y, index): if index == len(word): return True if x < 0 or x >= rows or y < 0 or y >= cols or board[x][y] != word[index]: return False temp = board[x][y] board[x][y] = \'#\' found = (dfs(x + 1, y, index + 1) or dfs(x - 1, y, index + 1) or dfs(x, y + 1, index + 1) or dfs(x, y - 1, index + 1)) board[x][y] = temp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"You are given an array of integers `nums` representing a forest where `nums[i]` is the height of the tree at index `i`. You can perform the following operation on the array: choose any index `i` and increment the height of the tree at index `i` by 1. You need to make the heights of all the trees the same. Return the minimum number of operations needed to achieve this condition.","solution":"def min_operations_to_equal_height(nums): Returns the minimum number of operations needed to make all heights of the trees equal. The operation allowed is incrementing the height of a tree by 1. :param nums: List[int] - Heights of the trees :return: int - Minimum number of operations max_height = max(nums) operations = 0 for height in nums: operations += max_height - height return operations"},{"question":"You are given a binary tree in which each node contains an integer value. Design a class `SumRangeTree` that supports the following three operations: - `SumRangeTree(TreeNode root)`: Initializes the object with the binary tree\'s root node. - `void update(int index, int value)`: Updates the value of the node at the given index to the new value. Each node is indexed using a level-order traversal. - `int sumRange(int left, int right)`: Returns the sum of values of all nodes between the indices `left` and `right` inclusive, based on a level-order traversal. The implementation should efficiently support the `update` and `sumRange` operations on the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class SumRangeTree: def __init__(self, root): self.root = root self.nodes = [] self.level_order_traversal() def level_order_traversal(self): from collections import deque queue = deque([self.root]) self.nodes = [] while queue: curr = queue.popleft() self.nodes.append(curr) if curr.left: queue.append(curr.left) if curr.right: queue.append(curr.right) def update(self, index, value): if index < 0 or index >= len(self.nodes): raise IndexError(\\"Index out of range\\") self.nodes[index].val = value def sumRange(self, left, right): if left < 0 or right >= len(self.nodes) or left > right: raise IndexError(\\"Index range invalid\\") total = 0 for i in range(left, right + 1): total += self.nodes[i].val return total"},{"question":"You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Write a function that connects the nodes such that each node\'s next pointer points to its next right node. If there is no next right node, the next pointer should be set to `null`. Initially, all next pointers are set to `null`. Return the root of the updated tree. For example, consider the following perfect binary tree: ``` 1 / 2 3 / / 4 5 6 7 ``` After connecting the next pointers, the tree should look as follows: ``` 1 -> null / 2 -> 3 -> null / / 4-> 5->6->7 -> null ``` Note: - You are not allowed to use extra space other than the given tree data structure. - Use only constant extra space to solve the problem. # Function Signature ```python def connect(root: \'Optional[Node]\') -> \'Optional[Node]\': ```","solution":"class Node: def __init__(self, val: int = 0, left: \'Node\' = None, right: \'Node\' = None, next: \'Node\' = None): self.val = val self.left = left self.right = right self.next = next def connect(root: \'Node\') -> \'Node\': if not root: return root current_level_start = root while current_level_start: current = current_level_start next_level_start = None previous = None while current: if current.left: if previous: previous.next = current.left else: next_level_start = current.left previous = current.left if current.right: if previous: previous.next = current.right else: next_level_start = current.right previous = current.right current = current.next current_level_start = next_level_start return root"},{"question":"You are given a binary tree where each node has an integer value. Your task is to implement a function that returns the **depth** of the deepest odd-level node in the binary tree. The root is considered level 1. If there are no odd-level nodes, return -1.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_odd_level_node_depth(root): if not root: return -1 queue = [(root, 1)] # (node, level) max_depth = -1 while queue: node, level = queue.pop(0) if level % 2 != 0: max_depth = max(max_depth, level) if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return max_depth"},{"question":"Given a string `str` consisting of lowercase English letters, you need to determine the **minimum number of deletions** required to make `str` a palindrome. A palindrome is a word that reads the same forward and backward (e.g., `madam`). Return _the smallest number of deletions needed to transform `str` into a palindrome_.","solution":"def min_deletions_to_palindrome(s): Returns the minimum number of deletions required to make the input string a palindrome. def longest_palindromic_subsequence(seq): n = len(seq) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if seq[i] == seq[j] and cl == 2: dp[i][j] = 2 elif seq[i] == seq[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] lps_length = longest_palindromic_subsequence(s) return len(s) - lps_length"},{"question":"The skyline problem is to find the **outlines** of a set of buildings, each represented as a triplet `(left, right, height)`, where `left` is the x-coordinate of the left edge, `right` is the x-coordinate of the right edge, and `height` is the height of the building. Assume all buildings rest on a flat surface at height `0`. Given a list of buildings, `buildings`, return _the skyline formed by these buildings represented as a list of \\"key points\\" _. A key point is defined as a tuple `(x, height)` representing a horizontal surface change at coordinate `x`. For example, the skyline formed by two buildings `[(2, 9, 10), (3, 7, 15)]` is represented as `[(2, 10), (3, 15), (7, 10), (9, 0)]`.","solution":"from heapq import heappush, heappop def get_skyline(buildings): Calculate the skyline formed by the given buildings. Each building is represented by a triplet (left, right, height). The result is a list of key points representing the skyline. Each key point is represented as a tuple (x, height). # Initialize the result list and events list result = [] events = [] # Populate the events with the start and end of each building for l, r, h in buildings: events.append((l, -h, r)) events.append((r, 0, 0)) # Sort events by x coordinate, height, and right edge events.sort() # Use a max-heap to keep track of the current buildings heap = [(0, float(\'inf\'))] # (height, end) prev_max_height = 0 for x, neg_height, end in events: while heap[0][1] <= x: heappop(heap) if neg_height != 0: heappush(heap, (neg_height, end)) cur_max_height = -heap[0][0] if cur_max_height != prev_max_height: result.append((x, cur_max_height)) prev_max_height = cur_max_height return result"},{"question":"Given two strings `s` and `t`, return the minimum number of operations required to convert `s` into `t`. The allowed operations are: 1. Insert a character, 2. Delete a character, or 3. Replace a character. All operations incur a cost of one unit.","solution":"def min_distance(s, t): Returns the minimum number of operations required to convert string s into string t. Allowed operations are insert, delete, or replace a character. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s is empty, you need to insert all characters of t elif j == 0: dp[i][j] = i # If t is empty, you need to delete all characters of s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"You are given a series of `t` test cases. Each test case represents an online bookstore with a collection of `n` books. Each book has an integer rating and an integer price. You are given an array `ratings` and an array `prices` both of size `n`, where `ratings[i]` represents the rating of the `ith` book, and `prices[i]` represents the price of the `ith` book. Your task is to determine the maximum sum of ratings you can achieve while keeping the sum of the prices under a given budget `k` for each test case. If it is not possible to select any books within the budget, return `0` for that test case. Return an array containing the result for each test case.","solution":"def max_ratings_under_budget(t, test_cases): For each test case, determine the maximum sum of ratings achievable while keeping the sum of the prices under a given budget. :param t: Number of test cases. :param test_cases: List of test case tuples. Each tuple contains (n, ratings, prices, k). n - Number of books. ratings - List of integer ratings for the books. prices - List of integer prices for the books. k - Budget. :return: List of maximum sum of ratings for each test case. results = [] for case in test_cases: n, ratings, prices, k = case dp = [0] * (k + 1) for i in range(n): for j in range(k, prices[i] - 1, -1): dp[j] = max(dp[j], dp[j - prices[i]] + ratings[i]) results.append(dp[k]) return results"},{"question":"You are given a binary tree with `n` nodes, where each node contains an integer value. The tree can be represented as a list of tuples where each tuple `(parent, child)` denotes an edge between the parent and the child node. Implement a function that returns the diameter of the tree. The diameter of a tree is defined as the length of the longest path between any two nodes in the tree. The length of a path is represented by the number of edges in the path.","solution":"from collections import defaultdict def tree_diameter(edges): Returns the diameter of the tree given its edges. :param edges: List of tuples where each tuple represents (parent, child) relationship. :return: Integer representing the diameter of the tree. def dfs(node, parent): # Returns the longest path from the node to leaf and updates the diameter depths = [0, 0] # Largest two depths initialized to 0 for neighbor in adj[node]: if neighbor == parent: continue # Don\'t go back to the parent depth = dfs(neighbor, node) + 1 if depth > depths[0]: depths = [depth, depths[0]] elif depth > depths[1]: depths[1] = depth nonlocal diameter diameter = max(diameter, sum(depths)) return depths[0] if not edges: return 0 # For empty tree or single node tree # Build adjacency list from edges adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) diameter = 0 dfs(0, -1) # Arbitrary start from node 0 (assuming nodes are 0-indexed) return diameter"},{"question":"Given a string `s` containing digits from `2` to `9` inclusive, return all possible letter combinations that the number could represent, using the mapping on a telephone keypad (e.g., 2 maps to \\"abc\\", 3 maps to \\"def\\", etc.). Return the answer in any order. Note that 1 does not map to any letters.","solution":"def letter_combinations(digits): Given a string containing digits from \'2\' to \'9\', return all possible letter combinations that the numbers could represent on a telephone keypad. if not digits: return [] phone_mapping = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } # Helper function to perform backtracking def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_mapping[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"You are given a **0-indexed** integer array `height` representing the height of pillars positioned in a straight line. You can place a **bridge** between two pillars if the pillars are exactly one position apart (i.e., you can place a bridge between the pillar at index `i` and the pillar at index `i + 1`). The **stability** of a bridge is defined as the sum of the heights of the two pillars it connects. Return _the **maximum stability** among all possible bridges you can place_. If no bridge can be placed, return `0`.","solution":"def max_bridge_stability(height): Given a list of pillar heights, returns the maximum stability of bridges that can be placed. Stability is defined as the sum of the heights of two adjacent pillars. if not height or len(height) == 1: return 0 max_stability = 0 for i in range(len(height) - 1): stability = height[i] + height[i + 1] if stability > max_stability: max_stability = stability return max_stability"},{"question":"Given an integer array `arr` and an integer `d`, you must determine the maximum possible sum of any non-empty subarray of `arr` such that the sum of every pair of consecutive elements in the subarray is divisible by `d`. Return this maximum sum. If no such subarray exists, return 0.","solution":"def max_sum_divisible_subarray(arr, d): Returns the maximum sum of any non-empty subarray of `arr` such that the sum of every pair of consecutive elements in the subarray is divisible by `d`. If no such subarray exists, returns 0. Parameters: arr (list): List of integers. d (int): Integer divisor. Returns: int: Maximum possible sum of the subarray. max_sum = float(\'-inf\') current_sum = 0 found_valid_subarray = False for i in range(len(arr)): current_sum = arr[i] potential_max_sum = current_sum if current_sum % d == 0: max_sum = max(max_sum, current_sum) found_valid_subarray = True for j in range(i + 1, len(arr)): current_sum += arr[j] if arr[j] % d == 0: potential_max_sum = max(potential_max_sum, current_sum) max_sum = max(max_sum, potential_max_sum) found_valid_subarray = True if potential_max_sum % d == 0: max_sum = max(max_sum, potential_max_sum) found_valid_subarray = True return max_sum if found_valid_subarray else 0"},{"question":"Given an integer array `arr`, partition the array into two sub-arrays (possibly empty) such that the sum of the elements in both sub-arrays is the same. Return `true` if you can achieve this, otherwise return `false`.","solution":"def can_partition(arr): Determines if the array can be partitioned into two sub-arrays with equal sum. total_sum = sum(arr) # If the total sum is odd, we can\'t possibly split it into two equal sub-arrays if total_sum % 2 != 0: return False target = total_sum // 2 n = len(arr) # dp[i] will be True if a subset with sum i can be formed from the elements dp = [False] * (target + 1) dp[0] = True # Base case: A subset with sum 0 is always possible for num in arr: # Update the dp array backwards for i in range(target, num - 1, -1): if dp[i - num]: dp[i] = True return dp[target]"},{"question":"Given an integer array `arr` representing the sea levels measured at different points in time, find _the length of the longest subsequence of increasing sea levels_ such that the difference between **consecutive elements** is at most `d`.","solution":"def longest_increasing_subsequence_with_difference(arr, d): Returns the length of the longest subsequence of increasing sea levels such that the difference between consecutive elements is at most d. if not arr: return 0 n = len(arr) dp = [1] * n # Initialize dp array for i in range(1, n): for j in range(i): if arr[i] > arr[j] and arr[i] - arr[j] <= d: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given two integers `m` and `n`, where `1  m, n  9`, return _an m x n matrix filled with elements from 1 to m * n in spiral order_. The matrix should be filled by moving from the outermost elements towards the inner ones, spiraling inwards in a clockwise direction.","solution":"def generate_spiral_matrix(m, n): Generate an m x n matrix filled with elements from 1 to m*n in spiral order. :param m: Number of rows (1  m  9) :param n: Number of columns (1  n  9) :return: The generated spiral matrix matrix = [[0] * n for _ in range(m)] left, right, top, bottom = 0, n - 1, 0, m - 1 num = 1 while left <= right and top <= bottom: # Traverse from left to right for j in range(left, right + 1): matrix[top][j] = num num += 1 top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Traverse from right to left if top <= bottom: for j in range(right, left - 1, -1): matrix[bottom][j] = num num += 1 bottom -= 1 # Traverse from bottom to top if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"Given the root of a binary tree, determine if it is a **full binary tree**. A full binary tree is a binary tree in which every node has either 0 or 2 children. Return `true` if the tree is full, and `false` otherwise. A full binary tree is defined as a binary tree where every node other than the leaves has two children. You are given the `root` of the binary tree as input.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_full_binary_tree(root): Determine if a binary tree is a full binary tree. :param TreeNode root: Root of the binary tree. :return: True if the binary tree is full, False otherwise. if root is None: return True # If leaf node if root.left is None and root.right is None: return True # If both left and right are not None, and both subtrees # must be full binary trees if root.left is not None and root.right is not None: return is_full_binary_tree(root.left) and is_full_binary_tree(root.right) # If neither of the above conditions are true, it\'s not a full binary tree return False"},{"question":"Given a string `s`, return the length of the longest substring of `s` that contains only unique characters. Implement your solution with a linear runtime complexity. For example: - Input: `s = \\"abcabcbb\\"` - Output: `3` In this example, the longest substring with all unique characters is \\"abc\\", which has a length of 3.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. Args: s : str : input string Returns: int : length of the longest substring with only unique characters char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `nums` of length `n` and an integer `target`. Write a function that finds all unique combinations in `nums` where the elements sum up to `target`. Each number in `nums` may only be used once in the combination. The solution set must not contain duplicate combinations. Return a list of all possible unique combinations that sum to `target`. **Example:** ```python nums = [10,1,2,7,6,1,5] target = 8 ``` **Output:** ```python [ [1,1,6], [1,2,5], [1,7], [2,6] ] ```","solution":"def combinationSum2(nums, target): nums.sort() res = [] find_combinations(nums, target, 0, [], res) return res def find_combinations(nums, target, index, path, res): if target == 0: res.append(path) return for i in range(index, len(nums)): if i > index and nums[i] == nums[i-1]: continue if nums[i] > target: break find_combinations(nums, target-nums[i], i+1, path + [nums[i]], res)"},{"question":"A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same. Given an array `arr` of `n` integers, you need to determine if it can be rearranged to form an arithmetic progression. If it can, return `true`; otherwise, return `false`.","solution":"def can_make_arithmetic_progression(arr): Determines if the array can be rearranged to form an arithmetic progression. Parameters: arr (list of int): The input array of integers. Returns: bool: True if the array can be rearranged to form an arithmetic progression, False otherwise. if len(arr) < 2: return True arr.sort() diff = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i - 1] != diff: return False return True"},{"question":"Given a string `s` consisting of lowercase English letters, find the first letter that appears twice. Return the letter as a string. If no letter appears twice, return an empty string. The function should aim to have a time complexity of O(n), where n is the length of the string.","solution":"def first_repeated_letter(s): Returns the first letter that appears twice in the string, or an empty string if no letter appears twice. :param s: str - The input string with lowercase English letters. :return: str - The first letter that appears twice or an empty string. seen = set() for char in s: if char in seen: return char seen.add(char) return \\"\\""},{"question":"You have a collection of `n` books and a shelf that can only fit a certain weight. Each book has a unique weight defined in an integer array `weights` of length `n`, where `weights[i]` represents the weight of the `i-th` book. You have to arrange the books on the shelf such that the total weight does not exceed a given integer `maxWeight`. However, you can only add books in increasing order of their weight (strictly lighter to heavier). Return _the **maximum number** of books you can place on the shelf without exceeding the weight limit._","solution":"def max_books_on_shelf(weights, maxWeight): Returns the maximum number of books that can be placed on the shelf without exceeding the weight limit, in increasing order of their weights. weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= maxWeight: total_weight += weight count += 1 else: break return count"},{"question":"You are tasked with developing a simplified contact management system. Your system should allow for adding new contacts and searching through them efficiently. Contacts are case-insensitive and consist only of English letters. Implement the `ContactManager` class: * `void addContact(string contact)` - Adds a new contact to the system. * `vector<string> searchContact(string prefix)` - Returns a list of all contacts starting with the given prefix, ordered lexicographically. If the system already contains a contact that is being added, it should not add it again but proceed without any errors. Assume that the max length for a contact is 50 characters, and the system can handle up to 100,000 contacts.","solution":"class ContactManager: def __init__(self): self.contacts = set() def addContact(self, contact): Adds a new contact to the system. if len(contact) <= 50: self.contacts.add(contact.lower()) def searchContact(self, prefix): Returns a list of all contacts starting with the given prefix, ordered lexicographically. prefix = prefix.lower() result = [contact for contact in self.contacts if contact.startswith(prefix)] result.sort() return result"},{"question":"You are given a string `s` consisting of digits and a **0-indexed** list of strings `words` where each word is composed of unique digits. A word is considered a subsequence of `s` if it can be obtained by deleting some (or no) characters of `s` without changing the order of the remaining characters. Return _the number of words from the list that are subsequences of the string `s`.","solution":"def num_matching_subseq(s, words): def is_subsequence(word, s): it = iter(s) return all(char in it for char in word) count = 0 for word in words: if is_subsequence(word, s): count += 1 return count"},{"question":"Given an array of integers `nums` and an integer `k`, return `true` if `nums` contains a subarray of length at least `2` whose elements sum up to a multiple of `k`, or `false` otherwise.","solution":"def check_subarray_sum(nums, k): Returns True if there is a subarray of length at least 2 that sums up to a multiple of k, otherwise returns False. if len(nums) < 2: return False mod_map = {0: -1} # Dictionary to store the remainder and its index total_sum = 0 for i, num in enumerate(nums): total_sum += num mod = total_sum % k if k != 0 else total_sum if mod in mod_map: if i - mod_map[mod] > 1: return True else: mod_map[mod] = i return False"},{"question":"You are given a grid of size `m x n` and an integer `k`. Each cell in the grid has a non-negative integer value representing the cost to move through that cell. You want to start from the top-left corner of the grid and reach the bottom-right corner with exactly `k` moves. Each move you can go up, down, left, or right. You can revisit cells but you must ensure that the total number of moves equals `k`. Write a function to determine if it\'s possible to travel from the top-left corner to the bottom-right corner with exactly `k` moves. Return `true` if it\'s possible, otherwise, return `false`.","solution":"def is_possible_to_reach_with_moves(grid, m, n, k): Determines if it\'s possible to reach the bottom-right corner of the grid with exactly k moves. :param grid: 2D list of non-negative integers representing the grid cost. :param m: number of rows in the grid. :param n: number of columns in the grid. :param k: exact number of moves. :return: True if possible to reach the bottom-right corner with exactly k moves, False otherwise. # Utilizing DFS to check the path def dfs(x, y, moves): if moves == k: # When the number of moves is exactly k return x == m - 1 and y == n - 1 # Mark the current cell to avoid re-visiting in the same path visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: if dfs(nx, ny, moves + 1): return True # Unmark the current cell visited.remove((x, y)) return False # If the minimum moves required are greater than k, return False early if m + n - 2 > k: return False directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() return dfs(0, 0, 0)"},{"question":"You are given a list of `n` integers, `nums`, and an integer `k`. Your task is to determine if there exists a sublist of exactly `k` distinct integers where the sum of that sublist is equal to a given integer `target`. Return `true` if such a sublist exists, otherwise return `false`. A sublist is a contiguous part of the list.","solution":"def has_sublist_with_sum(nums, k, target): from itertools import combinations n = len(nums) for i in range(n - k + 1): sublist = nums[i:i + k] if len(set(sublist)) == k and sum(sublist) == target: return True return False"},{"question":"You are given a `0-indexed` array `heights` representing the heights of a group of people standing in a line. The goal is to rearrange their positions so that the resulting lineup follows a zigzag pattern where each person\'s height is greater than or equal to the height of the next person if their position is even, and less than or equal to the height of the next person if their position is odd. Return _the array of heights rearranged in the zigzag pattern_.","solution":"def zigzag_heights(heights): Rearranges the given list of heights into a zigzag pattern. Heights are adjusted so each person\'s height is greater than or equal to the height of the next person if their position is even, and less than or equal to the height of the next person if their position is odd. n = len(heights) for i in range(n-1): if i % 2 == 0: if heights[i] < heights[i+1]: heights[i], heights[i+1] = heights[i+1], heights[i] else: if heights[i] > heights[i+1]: heights[i], heights[i+1] = heights[i+1], heights[i] return heights"},{"question":"Given an integer array `A` of size `n`, you need to split this array into two groups, `B` and `C`, such that the sum of the absolute differences of the means of the groups is minimized. Formally, let `mean(B)` be the mean of group `B` and `mean(C)` be the mean of group `C`. Minimize the value of `|mean(B) - mean(C)|`. Return a pair of arrays `[B, C]` that achieve this condition. **Example:** - If the input array `A` is `[1, 2, 3, 4, 5]`, one possible output could be `[[1, 2, 3], [4, 5]]` with the absolute difference of means being `|(1+2+3)/3 - (4+5)/2| = |2 - 4.5| = 2.5`. **Note:** - You may assume that there is at least one way to split the array into two non-empty groups. - Multiple correct outputs may exist, any one of them is acceptable.","solution":"def split_array_minimize_mean_difference(A): # Sort the array to facilitate splitting into balanced groups A.sort() n = len(A) # Splitting the array into two roughly equal parts mid = n // 2 # Initial groups B = A[:mid] C = A[mid:] return [B, C]"},{"question":"Given a list of integers `arr`, your task is to find the first missing positive integer in linear time and constant space. In other words, find the smallest positive integer that does not appear in the list. Your algorithm should run in O(n) time and use constant extra space.","solution":"def first_missing_positive(arr): n = len(arr) # Mark numbers (num < 0) and (num > n) with a special marker number (n+1) for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Utilize the index as a hash key and place negative marker in corresponding position for i in range(n): val = abs(arr[i]) if val <= n: arr[val - 1] = -abs(arr[val - 1]) # The first index which has a positive value will be the answer for i in range(n): if arr[i] > 0: return i + 1 return n + 1"},{"question":"You are given a **0-indexed** integer array `arr` containing `n` elements and an integer `k`. You are permitted to perform the following operation any number of times: Choose any subarray of length `k` and sort it in non-decreasing order. Return _the minimum number of such operations required to sort the entire array `arr` in non-decreasing order._ If it is not possible to sort the array using the given operation, return `-1`.","solution":"def min_operations_to_sort(arr, k): Returns the minimum number of operations required to sort the given array using the allowed subarray sorting operation. If it is not possible, returns -1. def can_sort(arr, k): # Function to determine if subarray sorting of length k can sort entire array. sorted_arr = sorted(arr) if arr == sorted_arr: return 0 if k == 1: return -1 segments = [] for i in range(0, len(arr), k): segments.append(arr[i:i+k]) for seg in segments: seg.sort() flat_sorted = [num for segment in segments for num in segment] if flat_sorted == sorted_arr: return 1 return -1 return can_sort(arr, k)"},{"question":"You are given an integer array `arr` and an integer value `k`. Your task is to determine the number of pairs of distinct indices `(i, j)` such that `arr[i] + arr[j] == k`. Return this count. You can assume that the array has at least two elements.","solution":"def count_pairs_with_sum(arr, k): Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] == k. pair_count = 0 seen = {} for num in arr: target = k - num if target in seen: pair_count += seen[target] if num in seen: seen[num] += 1 else: seen[num] = 1 return pair_count"},{"question":"You are given an integer array `nums` containing `n` distinct integers. You need to perform the following operations: - **Insert** a new integer, `val`, into the array while maintaining the sorted order. - **Delete** an integer, `val`, from the array if it exists. - **Search** for an integer, `val`, in the array and return its index if it exists, otherwise return -1. Implement the `SortedArray` class: - `SortedArray(int[] nums)` Initializes the array with the `nums` integers sorted in ascending order. - `void insert(int val)` Inserts `val` into the array, maintaining the sorted order. - `void delete(int val)` Deletes `val` from the array if it exists. - `int search(int val)` Returns the index of `val` in the array if it exists, otherwise returns -1. Make sure to handle edge cases such as inserting or deleting integers that lead to an empty array or searching for an integer in an empty array.","solution":"class SortedArray: def __init__(self, nums): Initializes the array with the \'nums\' integers sorted in ascending order. self.nums = sorted(nums) def insert(self, val): Inserts \'val\' into the array, maintaining the sorted order. left, right = 0, len(self.nums) while left < right: mid = (left + right) // 2 if self.nums[mid] < val: left = mid + 1 else: right = mid self.nums.insert(left, val) def delete(self, val): Deletes \'val\' from the array if it exists. idx = self.search(val) if idx != -1: self.nums.pop(idx) def search(self, val): Returns the index of \'val\' in the array if it exists, otherwise returns -1. left, right = 0, len(self.nums) - 1 while left <= right: mid = (left + right) // 2 if self.nums[mid] == val: return mid elif self.nums[mid] < val: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Given an array of integers `arr`, return _the length of the longest subsequence which is bitwise AND of its elements is non-zero._ A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_non_zero_bitwise_and_subsequence(arr): Returns the length of the longest subsequence where the bitwise AND of its elements is non-zero. max_elem = max(arr) count = 0 for num in arr: if num == max_elem: count += 1 return count"},{"question":"Given a list of integers `nums`, find _the maximum difference between any two elements such that the larger element appears after the smaller element in the list_. Return the maximum difference. If no such elements exist, return `-1`.","solution":"def maximum_difference(nums): Given a list of integers \'nums\', this function finds the maximum difference between any two elements such that the larger element appears after the smaller element in the list. If no such elements exist, returns -1. if not nums or len(nums) < 2: return -1 min_element = nums[0] max_diff = -1 for num in nums[1:]: if num > min_element: max_diff = max(max_diff, num - min_element) min_element = min(min_element, num) return max_diff"},{"question":"You are given a matrix of integers `grid` representing a 2D grid of digits from `0` to `9`. Your task is to find the maximum sum of a sub-grid which forms an hourglass shape. An hourglass shape consists of values at the pattern: ``` a b c d e f g ``` Here, `(a, b, c, d, e, f, g)` are elements in the grid. Write a function to return the maximum hourglass sum found in the grid. The grid will have at least size `3x3`.","solution":"def max_hourglass_sum(grid): Returns the maximum sum of an hourglass shape in the 2D grid. max_sum = float(\'-inf\') rows, cols = len(grid), len(grid[0]) for i in range(rows - 2): for j in range(cols - 2): top = sum(grid[i][j:j+3]) middle = grid[i+1][j+1] bottom = sum(grid[i+2][j:j+3]) hourglass_sum = top + middle + bottom max_sum = max(max_sum, hourglass_sum) return max_sum"},{"question":"You are given two integer arrays `startTime` and `endTime`, both of length `n`, where `startTime[i]` and `endTime[i]` represent the start and end times of the `i`th work interval. You\'re also given an integer `queryTime`. Return _the number of work intervals during which the worker is busy at time_ `queryTime`. More precisely, return the number of intervals `(startTime[i], endTime[i])` that satisfy `startTime[i] <= queryTime <= endTime[i]`.","solution":"def busyStudent(startTime, endTime, queryTime): Returns the number of work intervals during which the worker is busy at queryTime. count = 0 for start, end in zip(startTime, endTime): if start <= queryTime <= end: count += 1 return count"},{"question":"Given a 2D matrix representing a chessboard and a specific square in the matrix labeled `(r, c)`, determine if a knight placed on that square can move to an empty square within `k` moves. The matrix has `n` rows and `m` columns where board[i][j] equals 1 indicates the presence of an obstacle and equals 0 indicates an empty square. The knight moves in an \\"L\\" shape: two squares in a cardinal direction and one square perpendicular, or one square in a cardinal direction and two squares perpendicular. Return `true` if the knight can reach an empty square within `k` moves, otherwise return `false`.","solution":"def can_knight_reach(board, r, c, k): Determines if a knight can reach an empty square within k moves. :param board: List of List of int: 2D matrix representing the chessboard. :param r: int: Starting row of the knight. :param c: int: Starting column of the knight. :param k: int: Maximum number of moves. :return: bool: True if a knight can reach an empty square, False otherwise. from collections import deque def is_valid_move(x, y): return 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] == 0 # All possible moves for a knight in chess directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] queue = deque([(r, c, 0)]) visited = set((r, c)) while queue: x, y, moves = queue.popleft() if moves > k: break for direction in directions: new_x, new_y = x + direction[0], y + direction[1] if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited: return True if (new_x, new_y) not in visited and 0 <= new_x < len(board) and 0 <= new_y < len(board[0]): visited.add((new_x, new_y)) queue.append((new_x, new_y, moves + 1)) return False"},{"question":"Given two integer lists `nums1` and `nums2`, return a list of their intersection. Each element in the result must be unique and you may return the result in any order. For example, if `nums1 = [4,9,5]` and `nums2 = [9,4,9,8,4]`, the intersection is `[4,9]`. Write a function to compute the intersection of the two lists and ensure that the result does not contain duplicate elements.","solution":"def intersection(nums1, nums2): Returns a list of unique elements that are present in both nums1 and nums2. set1 = set(nums1) set2 = set(nums2) return list(set1.intersection(set2))"},{"question":"You are given a list of integers `arr` and an integer `threshold`. A **subarray sum threshold** consists of the sum of all elements in a contiguous subarray being greater than or equal to `threshold`. Return the length of the smallest subarray where the subarray sum threshold is met. If no such subarray exists, return `-1`.","solution":"def smallest_subarray_with_sum_threshold(arr, threshold): n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= threshold: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a string `str1` and a string `str2`, determine if `str2` is an anagram of a substring of `str1`. Return `true` if `str2` is an anagram of any substring of `str1`; otherwise, return `false`.","solution":"def is_anagram_of_substring(str1, str2): Determines if str2 is an anagram of any substring of str1. Args: str1 (str): The string to search within. str2 (str): The string to check as an anagram of a substring of str1. Returns: bool: True if str2 is an anagram of any substring of str1, False otherwise. from collections import Counter len1, len2 = len(str1), len(str2) if len2 > len1: return False counter1 = Counter(str1[:len2]) counter2 = Counter(str2) if counter1 == counter2: return True for i in range(len2, len1): counter1[str1[i]] += 1 counter1[str1[i - len2]] -= 1 if counter1[str1[i - len2]] == 0: del counter1[str1[i - len2]] if counter1 == counter2: return True return False"},{"question":"Given a list of integers, write a function that transforms the list such that each element in the list is replaced by its rank. The rank represents the position of the element in the sorted list of unique elements, starting from 1. For example, the list `[40, 10, 20, 30]` will be transformed to `[4, 1, 2, 3]` since in the sorted list `[10, 20, 30, 40]`, 40 is the 4th element, 10 is the 1st, 20 is the 2nd, and 30 is the 3rd. If an element occurs multiple times in the list, it should have the same rank each time it appears.","solution":"def rank_transform(lst): Transforms the list such that each element is replaced by its rank. Parameters: lst (list): The input list of integers. Returns: list: The list with each element replaced by its rank. # Create a sorted list of unique elements sorted_unique_elements = sorted(set(lst)) # Create a rank dictionary rank_dict = {value: index + 1 for index, value in enumerate(sorted_unique_elements)} # Replace each element with its rank transformed_list = [rank_dict[element] for element in lst] return transformed_list"},{"question":"You are given a list of integers `nums` and an integer `target`. Each element in `nums` can be added to itself any number of times to form new values. Return the minimum number of operations required to form the `target` by adding the elements of `nums` any number of times. If it is not possible to form the `target`, return `-1`.","solution":"def min_operations_to_form_target(nums, target): Return the minimum number of operations required to form the target by adding elements of nums any number of times. If it is not possible, return -1. if target == 0: return 0 if not nums: return -1 dp = [float(\'inf\')] * (target + 1) dp[0] = 0 for num in nums: for i in range(num, target + 1): dp[i] = min(dp[i], dp[i - num] + 1) return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"You are given an unsorted array `numbers` of `n` integers where `numbers = [a1, a2, ..., an]`. Find the length of the longest subsequence such that every element of the subsequence is an **odd** number. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, given the array `numbers = [2, 3, 6, 7, 11, 8, 9]`, the longest subsequence of odd numbers is `[3, 7, 11, 9]`, so the output should be `4`. Return the length of the longest subsequence of odd numbers in the given array.","solution":"def longest_odd_subsequence_length(numbers): Returns the length of the longest subsequence of odd numbers. return len([num for num in numbers if num % 2 != 0]) # Example numbers = [2, 3, 6, 7, 11, 8, 9] print(longest_odd_subsequence_length(numbers)) # Output should be 4 because [3, 7, 11, 9] is the longest subsequence of odd numbers"},{"question":"You are given a **0-indexed** array of integers `arr` of length `n` and an integer `k`. You need to determine if there exists a **subarray** of length exactly `k` that is a **perfect square** when considered as a whole number formed by concatenating its elements. A number is considered a perfect square if it is the product of an integer with itself. Return _`true` if such a subarray exists, otherwise return `false`_.","solution":"import math def is_perfect_square(n): Checks if the given number n is a perfect square. sqrt_n = int(math.sqrt(n)) return sqrt_n * sqrt_n == n def subarray_has_perfect_square(arr, k): Determines if there exists a subarray of length exactly k that forms a number which is a perfect square. n = len(arr) for i in range(n - k + 1): # Form the number from the subarray arr[i:i+k] number_as_str = \'\'.join(map(str, arr[i:i+k])) number_as_int = int(number_as_str) # Check if this number is a perfect square if is_perfect_square(number_as_int): return True return False"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to find the **k-th largest** element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. You must solve this problem with a time complexity of O(n log k) or better. Implement the `findKthLargest` function: * `findKthLargest(vector<int>& nums, int k)` - Returns the k-th largest element in the array `nums`. Provide the implementation for the `findKthLargest` function to solve the problem.","solution":"import heapq def findKthLargest(nums, k): Returns the k-th largest element in the array nums. # Use a min heap to maintain the k largest elements seen so far min_heap = [] for num in nums: heapq.heappush(min_heap, num) # If the heap size exceeds k, pop the smallest element if len(min_heap) > k: heapq.heappop(min_heap) return heapq.heappop(min_heap)"},{"question":"You are given a list of `n` rooms and a list of `m` values representing keys. A 2D integer array `keys[i]` where `keys[i][j]` means that the `i-th` room contains a key that opens the `keys[i][j]`-th room. Initially, you are in room 0, and you can move freely between rooms as long as you have keys for them. Your task is to determine if it is possible to visit all the rooms starting from room 0. Return `true` if you can visit all the rooms, otherwise return `false`.","solution":"def can_visit_all_rooms(rooms): Determine if all rooms can be visited starting from room 0. Args: rooms (List[List[int]]): A 2D list where the i-th element is a list of keys found in the i-th room. Returns: bool: True if all rooms can be visited, otherwise False. def dfs(room, visited): visited.add(room) for key in rooms[room]: if key not in visited: dfs(key, visited) visited = set() dfs(0, visited) return len(visited) == len(rooms)"},{"question":"You are given a list of `n` integers `nums` where each integer represents a building\'s height. You are tasked with calculating how much water can be trapped between the buildings after it rains. The width of each building and the gap between buildings is 1. Return _an integer_ representing the total amount of water trapped. For example, given `nums = [4, 2, 0, 3, 2, 5]`, the total water trapped would be `9` by the following calculations: * The first building of height `4` traps `0` water; * The second building of height `2` traps `2` units of water between itself and the first building; * The fourth building of height `3` traps `3` units of water between itself and the second building; * The last building of height `5` traps `2` units of water between itself and the fourth building.","solution":"def trap_rain_water(nums): Calculate how much water can be trapped between buildings after it rains. :param nums: List of integers representing building heights. :return: Integer representing total amount of water trapped. if not nums or len(nums) < 3: return 0 n = len(nums) left_max = [0] * n right_max = [0] * n left_max[0] = nums[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], nums[i]) right_max[n - 1] = nums[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], nums[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - nums[i] return total_water"},{"question":"You are given a list of `n` events represented by an array of strings `events`, where each event i is of the form `start_time-end_time`. The `start_time` and `end_time` are given in the format `\\"HH:MM\\"`. You need to find the maximum number of events that can happen concurrently at any given time. Two events are considered concurrent if their time intervals overlap. Return *the maximum number of concurrently running events*. **Note**: - The `start_time` is inclusive, and the `end_time` is exclusive. - Events may start and end at the same times as other events.","solution":"def max_concurrent_events(events): Returns the maximum number of concurrently running events. times = [] for event in events: start, end = event.split(\\"-\\") times.append((start, \'start\')) times.append((end, \'end\')) times.sort() # Sorting based on time followed by type (\'end\' before \'start\' if times are the same) max_concurrent, current_concurrent = 0, 0 for time, ttype in times: if ttype == \'start\': current_concurrent += 1 else: current_concurrent -= 1 max_concurrent = max(max_concurrent, current_concurrent) return max_concurrent"},{"question":"# New Question: [Question 4]: You are given an integer array `nums` of length `n`, where each element represents the maximum number of steps you can take forward from that position. Return _the minimum number of jumps needed to reach the end of the array_ starting from the first element. If it\'s not possible to reach the end, return `-1`.","solution":"def min_jumps(nums): Returns the minimum number of jumps needed to reach the end of the array. If it\'s not possible to reach the end, returns -1. if len(nums) == 1: return 0 # Initialize variables jumps = 0 max_reach = 0 step = 0 last_jump_max_reach = 0 for i in range(len(nums) - 1): max_reach = max(max_reach, i + nums[i]) if i == last_jump_max_reach: jumps += 1 last_jump_max_reach = max_reach if last_jump_max_reach >= len(nums) - 1: return jumps return -1 if last_jump_max_reach < len(nums) - 1 else jumps"},{"question":"Given a binary tree, you need to implement a function that returns the values of its nodes in a diagonal traversal order. A diagonal traversal of a binary tree is defined as follows: - Start from the root node. - Move in the diagonal direction (from the current node to its right child node). - If there is a left child of the current node, consider it for the next level of diagonal traversal. The function should return a list of lists, where each sublist contains the nodes present at the same diagonal level. For example, for the input binary tree: ``` 8 / / 3 10 / / 1 6 14 / / 4 7 13 ``` The expected output would be: ``` [ [8, 10, 14], [3, 6, 7, 13], [1, 4] ] ```","solution":"from collections import defaultdict from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def diagonalTraversal(root: Optional[TreeNode]) -> List[List[int]]: Returns the diagonal traversal of a binary tree rooted at `root`. if not root: return [] # Dictionary to hold the nodes at each level diagonal_dict = defaultdict(list) # Helper function to traverse the tree def diagonal_traversal_util(node, d): if not node: return diagonal_dict[d].append(node.val) # For left child, increase diagonal distance diagonal_traversal_util(node.left, d + 1) # For right child, keep diagonal distance the same diagonal_traversal_util(node.right, d) # Start the traversal from root with distance 0 diagonal_traversal_util(root, 0) # Extract the results from dictionary and sort it based on keys result = [diagonal_dict[i] for i in sorted(diagonal_dict.keys())] return result"},{"question":"You are given a directed graph with `N` nodes labeled from `0` to `N-1` and `M` edges, represented as a list of pairs `edges` where `edges[i] = [u, v]` means there is a directed edge from node `u` to node `v`. You are also given an integer `k`. Your task is to determine if there exists a simple cycle in the graph with exactly `k` edges. Return `true` if such a cycle exists, otherwise return `false`.","solution":"from collections import defaultdict from functools import lru_cache def has_cycle_with_k_edges(N, edges, k): # Helper function using memoization @lru_cache(None) def dfs(node, edges_left, start_node): if edges_left == 0: return node == start_node for neighbor in graph[node]: if dfs(neighbor, edges_left - 1, start_node): return True return False # Build the adjacency list representation of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Try to find a cycle with exactly \'k\' edges starting from any node for node in range(N): if dfs(node, k, node): return True dfs.cache_clear() # clear the cache for the next starting node return False"},{"question":"You are given an arbitrary number of word sets and a target word. Represent each word as a lowercase string. The word sets are provided in a 2D array `wordSets`, where each `wordSets[i]` is a list of words representing a specific set. You need to determine if it\'s possible to form the `targetWord` by selecting exactly one word from each word set and then concatenating them together in order. For example, given `wordSets = [[\\"ab\\", \\"ac\\"], [\\"ba\\", \\"bb\\"], [\\"ca\\", \\"cb\\"]]` and `targetWord = \\"abbbca\\"`, the result is `True` since the target word can be formed by selecting \\"ab\\" from the first set, \\"bb\\" from the second set, and \\"ca\\" from the third set and then concatenating them together. However, given `wordSets = [[\\"ab\\", \\"ac\\"], [\\"ba\\", \\"bb\\"], [\\"ca\\", \\"cd\\"]]` and `targetWord = \\"abbbcc\\"`, the result is `False` since the target word can\'t be formed by concatenating exactly one word from each set in order. Write a function to determine if it\'s possible to form the `targetWord` using the given word sets. Return `True` if it\'s possible, otherwise, return `False`.","solution":"def can_form_target_word(wordSets, targetWord): Determines if `targetWord` can be formed by selecting exactly one word from each word set in order. Args: wordSets (List[List[str]]): The list of word sets. targetWord (str): The target word to form. Returns: bool: True if `targetWord` can be formed, otherwise False. def can_form(index, current): if index == len(wordSets): return current == targetWord for word in wordSets[index]: if can_form(index + 1, current + word): return True return False return can_form(0, \'\') # Example usage # wordSets = [[\\"ab\\", \\"ac\\"], [\\"ba\\", \\"bb\\"], [\\"ca\\", \\"cb\\"]] # targetWord = \\"abbbca\\" # print(can_form_target_word(wordSets, targetWord)) # Output: True"},{"question":"You are managing the schedule for a team of workers and need to optimize their shifts. Each worker can only work `X` number of hours per week, and there are `N` shifts that need to be covered, with each shift requiring `Y` number of hours to complete. You are given a **0-indexed** integer array `workers` of length `P`, where `workers[i]` denotes the maximum number of hours the `i-th` worker can work in a week. You need to determine if it is possible to assign all `N` shifts to the workers such that no worker exceeds their maximum allowed working hours. Return _True if it\'s possible to assign all the shifts under these constraints, or False otherwise._","solution":"def can_assign_shifts(workers, num_shifts, shift_hours): Determines if it is possible to assign all `num_shifts` shifts to the workers such that no worker exceeds their maximum allowed working hours. Parameters: workers (list[int]): A list containing the maximum hours each worker can work in a week. num_shifts (int): The number of shifts that need to be covered. shift_hours (int): The number of hours each shift requires. Returns: bool: True if it is possible to assign all shifts, otherwise False. total_shift_hours = num_shifts * shift_hours max_available_hours = sum(workers) # If the total required hours exceed the total available hours, return False if total_shift_hours > max_available_hours: return False # Sort workers in descending order of their available hours workers.sort(reverse=True) # Try assigning shifts to the workers for worker_hours in workers: if total_shift_hours <= 0: return True if worker_hours >= shift_hours: shifts_covered_by_worker = min(worker_hours // shift_hours, num_shifts) total_shift_hours -= shifts_covered_by_worker * shift_hours num_shifts -= shifts_covered_by_worker return total_shift_hours <= 0"},{"question":"You are given a **0-indexed** 2D array `grid` of dimensions `m x n` representing a map where `grid[i][j]` can be: - `1` representing land, - `0` representing water, - `2` representing a building. In one move, you can move from one cell to an adjacent cell. A cell is considered adjacent if it is directly connected to it (up, down, left, right). Your task is to find the shortest distance from any building to a land cell. The distance is defined as the number of moves to travel from one cell to another, considering only land cells are traversable. Return the shortest distance from any building to the nearest land cell. If no such distance exists, return `-1`.","solution":"from collections import deque def shortest_distance_from_building_to_land(grid): Returns the shortest distance from any building to the nearest land cell in the given grid. grid is an m x n 2D array where grid[i][j] can be 0 (water), 1 (land), or 2 (building). if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs_from_buildings(): queue = deque() visited = [[False] * n for _ in range(m)] for i in range(m): for j in range(n): if grid[i][j] == 2: queue.append((i, j, 0)) visited[i][j] = True while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True if grid[nx][ny] == 1: return dist + 1 if grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) return -1 return bfs_from_buildings()"},{"question":"Given a string `s` and an integer `k`, shift each character in `s` by `k` positions forward in the alphabet, wrapping around if necessary. Return the final string after all shifts have been applied. Note that characters are case-sensitive, and \'z\' followed by a shift of 1 becomes \'a\', while \'Z\' followed by a shift of 1 becomes \'A\'.","solution":"def shift_characters(s, k): Shifts each character in the string s by k positions forward in the alphabet. Wrapping around if necessary. Case-sensitive. Parameters: s (str): The input string to shift. k (int): The number of positions to shift each character. Returns: str: The shifted string. def shift_char(c, k): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + k) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + k) % 26 + ord(\'A\')) else: return c return \'\'.join(shift_char(c, k) for c in s)"},{"question":"Given a **0-indexed** integer array `time` where `time[i]` represents the duration of the ith song, return the number of pairs of songs where the total duration of two songs is divisible by `60`. For example, if there are songs with durations `[30, 20, 150, 100, 40]`, the valid pairs are `(0, 2)`, `(1, 4)`, and `(2, 3)`, since `(30 + 150) % 60 == 0`, `(20 + 40) % 60 == 0`, and `(150 + 30) % 60 == 0`.","solution":"def num_pairs_divisible_by_60(time): Returns the number of pairs of songs where the total duration is divisible by 60. # Create a remainder array to count the frequency of different remainders when divided by 60 remainder_count = [0] * 60 count = 0 for t in time: remainder = t % 60 # Pair remainder with 0 with itself if remainder == 0: count += remainder_count[0] else: # Pair with its complement to 60 count += remainder_count[60 - remainder] # Update remainder count remainder_count[remainder] += 1 return count"},{"question":"You are given a **0-indexed** array of integers `nums`. An array is called \\"growth-stable\\" if the difference between any two adjacent elements is equal. Determine if the given array `nums` is growth-stable. Return `true` if the array is growth-stable and `false` otherwise.","solution":"def is_growth_stable(nums): Determine if the given array is growth-stable. An array is growth-stable if the difference between any two adjacent elements is equal. :param nums: List of integers. :return: Boolean indicating if the array is growth-stable. if len(nums) < 2: return True difference = nums[1] - nums[0] for i in range(2, len(nums)): if nums[i] - nums[i - 1] != difference: return False return True"},{"question":"Given a list of integers `nums` and an integer `k`, return the number of unique k-length subarrays of `nums` that have an average value greater than or equal to a given threshold `t`. A subarray is a contiguous non-empty sequence of elements within an array.","solution":"def count_subarrays(nums, k, t): Returns the number of unique k-length subarrays of nums that have an average value greater than or equal to t. count = 0 threshold_sum = k * t # Calculate the sum of the first k-length subarray current_sum = sum(nums[:k]) if current_sum >= threshold_sum: count += 1 # Use sliding window technique to calculate sums of all k-length subarrays for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum >= threshold_sum: count += 1 return count"},{"question":"Given an `m x n` grid called `rooms` initialized with these possible values: * `-1` - A wall or an obstacle. * `0` - A gate. * `INF` (2^31 - 1) - An empty room. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, that room should remain filled with `INF`. You may assume that there is at least one empty room and one gate. Implement a function `wallsAndGates(int[][] rooms)` that updates the grid in-place.","solution":"from collections import deque def wallsAndGates(rooms): Fill each empty room with the distance to its nearest gate. :param rooms: List[List[int]] - The input 2D grid. :return: None - The grid is modified in-place. if not rooms or not rooms[0]: return INF = 2 ** 31 - 1 m, n = len(rooms), len(rooms[0]) queue = deque() # Find all gates and add them to the queue for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # BFS from the gates directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"You are given a 2D grid of size `m x n` representing a maze. Each cell in the grid can either be a `0` (empty cell) or a `1` (obstacle). You can move up, down, left, or right from an empty cell to another empty cell. Determine the minimum number of moves required to travel from the top-left cell to the bottom-right cell. If it is not possible to reach the bottom-right cell, return `-1`. The top-left and bottom-right cells are guaranteed to be empty cells.","solution":"from collections import deque def min_moves_to_reach_end(grid): Returns the minimum number of moves required to travel from the top-left cell to the bottom-right cell in a 2D grid, or -1 if it is not possible. m, n = len(grid), len(grid[0]) # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, moves) visited = set((0, 0)) while queue: row, col, moves = queue.popleft() # If we reach the bottom-right cell if row == m - 1 and col == n - 1: return moves # Explore all possible directions for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, moves + 1)) # If reaching the bottom-right cell is not possible return -1"},{"question":"Given an array of integers `arr`, return the number of **equivalent pairs** of indices `(i, j)` such that `arr[i] == arr[j]` and `i < j`. Two pairs `(i, j)` and `(k, l)` are considered equivalent if `arr[i] == arr[k]` and `arr[j] == arr[l]`. This task is to find and count all such distinct pairs.","solution":"def count_equivalent_pairs(arr): Returns the number of equivalent pairs of indices (i, j) such that arr[i] == arr[j] and i < j. from collections import defaultdict # Dictionary to keep track of the frequency of each number freq = defaultdict(int) count = 0 for num in arr: count += freq[num] freq[num] += 1 return count"},{"question":"You are given an array `events` where `events[i]` is a pair of start and end timestamps of an event. Assume the timestamps are in the format `\\"HH:MM\\"`. Write a function to determine if it is possible to attend all events without any overlap in times. Return `true` _if it is possible to attend all events without overlap_; otherwise, return `false`.","solution":"def can_attend_all_events(events): Determines if it is possible to attend all events without overlap. :param events: List of tuples, where each tuple contains start and end times in \\"HH:MM\\" format :return: True if it is possible to attend all events without overlap, else False # Convert the time strings to minutes from midnight for easier comparison events_in_minutes = [] for event in events: start_time = event[0] end_time = event[1] start_minutes = int(start_time.split(\':\')[0]) * 60 + int(start_time.split(\':\')[1]) end_minutes = int(end_time.split(\':\')[0]) * 60 + int(end_time.split(\':\')[1]) events_in_minutes.append((start_minutes, end_minutes)) # Sort the events by their starting times events_in_minutes.sort() # Check for any overlaps for i in range(len(events_in_minutes) - 1): if events_in_minutes[i][1] > events_in_minutes[i + 1][0]: return False return True"},{"question":"A certain kingdom has `n` cities, connected by `n-1` roads forming a tree structure. The king loves to travel and wants to find the longest possible path he can take within his kingdom. Given the array `roads` where `roads[i] = [city1, city2]` denotes a road between `city1` and `city2`, return the length of the longest path in the tree.","solution":"from collections import defaultdict def longest_path(n, roads): def dfs(node, parent): max_depth = [0, 0] # Store the top two maximum depths for neighbor in graph[node]: if neighbor == parent: continue child_depth = dfs(neighbor, node) if child_depth > max_depth[0]: max_depth[1] = max_depth[0] max_depth[0] = child_depth elif child_depth > max_depth[1]: max_depth[1] = child_depth # Update longest diameter seen so far nonlocal longest longest = max(longest, max_depth[0] + max_depth[1]) return max_depth[0] + 1 graph = defaultdict(list) for city1, city2 in roads: graph[city1].append(city2) graph[city2].append(city1) longest = 0 dfs(0, -1) return longest"},{"question":"Given a list of integers `arr`, an integer `k`, and a positive integer `x`, divide the list into `x` contiguous subarrays such that the maximum sum of the subarrays is minimized. Each contiguous subarray must contain between `k` and `(n - k*x + k)` elements, where `n` is the length of `arr`. Return the minimized maximum sum.","solution":"def is_valid_division(arr, k, x, max_sum): current_sum = 0 count_subarrays = 1 for num in arr: if current_sum + num > max_sum: count_subarrays += 1 current_sum = num if count_subarrays > x: return False else: current_sum += num return True def minimize_max_sum(arr, k, x): n = len(arr) left = max(arr) right = sum(arr) result = right while left <= right: mid = (left + right) // 2 if is_valid_division(arr, k, x, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"Given an input string `input_str`, write a function that returns the index of the first non-repeating character in the string. If all characters are repeating or the string is empty, return `-1`. Note that all characters in the string are lowercase English letters.","solution":"def first_non_repeating_character(input_str): Returns the index of the first non-repeating character in the input string. If all characters are repeating or the string is empty, returns -1. # Dictionary to hold character counts char_count = {} # Fill the dictionary with character counts for char in input_str: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for index, char in enumerate(input_str): if char_count[char] == 1: return index return -1"},{"question":"Given an array `nums` and an integer `target`, return the number of pairs `(i, j)` where `i < j` and `nums[i] + nums[j]` equals `target`. Each element in the array can only be used once in a pair. If no such pair exists, return `0`. The solution should have a time complexity of O(nlogn) or better.","solution":"def count_pairs_with_sum(nums, target): Returns the number of pairs (i, j) where i < j and nums[i] + nums[j] equals target. nums.sort() count = 0 left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: count += 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return count"},{"question":"Given a binary tree, implement a function `boundaryOfBinaryTree` that returns the boundary values of the binary tree in an anti-clockwise direction starting from the root. The boundary includes the left boundary, leaves, and the right boundary. The left boundary is defined as the path from the root to the left-most node. The right boundary is defined as the path from the root to the right-most node. If the root has no left or right subtree, the left or the right boundary will be an empty list respectively. Leaves are defined as nodes without children. Note that the boundary should not contain duplicate nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def boundaryOfBinaryTree(root): if not root: return [] def is_leaf(node): return not node.left and not node.right def add_left_boundary(node, res): while node: if not is_leaf(node): res.append(node.val) if node.left: node = node.left else: node = node.right def add_leaves(node, res): if is_leaf(node): res.append(node.val) return if node.left: add_leaves(node.left, res) if node.right: add_leaves(node.right, res) def add_right_boundary(node, res): tmp = [] while node: if not is_leaf(node): tmp.append(node.val) if node.right: node = node.right else: node = node.left res.extend(tmp[::-1]) boundary = [] if not is_leaf(root): boundary.append(root.val) if root.left: add_left_boundary(root.left, boundary) add_leaves(root, boundary) if root.right: add_right_boundary(root.right, boundary) return boundary"},{"question":"You are given two arrays, `arr1` and `arr2`, each consisting of distinct integers. Your goal is to create a new array `result` such that for each element `x` in `arr1`, if `x` exists in `arr2`, then `x` will be replaced by the index of `x` in `arr2`. If `x` does not exist in `arr2`, then it should remain the same. The order of elements in `arr1` should be preserved in `result`. Return the resulting array `result`.","solution":"def replace_elements_with_indices(arr1, arr2): Replace elements of arr1 with their indices in arr2 if they exist in arr2. If they do not exist in arr2, they remain unchanged. index_map = {value: idx for idx, value in enumerate(arr2)} return [index_map.get(x, x) for x in arr1] # Example usage: # arr1 = [4, 1, 5, 6, 3] # arr2 = [5, 3, 4, 7, 1] # result should be [2, 4, 0, 6, 1]"},{"question":"Given a string `s` consisting of lowercase English letters and an array of pairs of indices representing the positions that can be swapped, return the lexicographically smallest string that can be formed by repeatedly swapping the characters at the given indices. You can perform any number of swaps at the provided indices in any order. **Notes:** - The length of the string `s` will be between 1 and 1000. - The number of pairs will be between 0 and 1000. - Assume that you can swap any character in the string as long as there is a path connecting them via the given pairs.","solution":"def smallest_string_with_swaps(s, pairs): Returns the lexicographically smallest string that can be formed by repeatedly swapping the characters at the given indices in pairs. from collections import defaultdict, deque def bfs(start, visited, adj): queue = deque([start]) component = [] while queue: node = queue.popleft() if not visited[node]: visited[node] = True component.append(node) for neighbor in adj[node]: if not visited[neighbor]: queue.append(neighbor) return component n = len(s) adj = defaultdict(list) visited = [False] * n # Build adjacency list for x, y in pairs: adj[x].append(y) adj[y].append(x) # Find connected components using BFS components = [] for i in range(n): if not visited[i]: component = bfs(i, visited, adj) components.append(component) # Create the smallest string by sorting the characters in each component s_list = list(s) for component in components: component.sort() chars = sorted(s[i] for i in component) for i, idx in enumerate(component): s_list[idx] = chars[i] return \'\'.join(s_list)"},{"question":"Given a list of non-negative integers representing the heights of buildings with windows aligned in a straight line, determine the maximum area of a rectangle formed by any two windows, where the width of the rectangle is the distance between the two windows, and the height is the minimum height of the two windows. You are to find this maximum area by considering all pairs of windows.","solution":"def max_rectangle_area(heights): Determines the maximum area of a rectangle formed by any two windows where the width of the rectangle is the distance between the two windows, and the height is the minimum height of the two windows. Parameters: heights (list of int): List of non-negative integers representing the heights of buildings. Returns: int: Maximum area of the rectangle. if not heights or len(heights) < 2: return 0 max_area = 0 left = 0 right = len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given an array of strings `tokens` that represents an arithmetic expression in Reverse Polish Notation (RPN). Evaluate the expression and return the result. Note that: - Each element in the array `tokens` is either an integer or an operator (\'+\', \'-\', \'*\', \'/\'). - The operators are applied between the most recent operands in the stack. - The division operator \'/\' should truncate the result towards zero. **Example:** Input: `tokens = [\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]` Output: `9` Explanation: ((2 + 1) * 3) = 9","solution":"def evalRPN(tokens): Evaluate an arithmetic expression in Reverse Polish Notation. Args: tokens (list): A list of strings representing the arithmetic expression in RPN. Returns: int: The result of the expression. stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': # Truncate towards zero stack.append(int(a / b)) else: stack.append(int(token)) return stack[0]"},{"question":"You are given a string array `words` and a string `target`. Your task is to return the length of the shortest word in the array `words` that contains all the characters of the `target` string. If no such word exists, return -1. Implement the `WordFinder` class: * `WordFinder(String[] words)` Initializes the object with the string array `words`. * `int shortestContainingWord(String target)` Returns the length of the shortest word in the array `words` that contains all the characters of the `target` string. If no such word exists, return -1.","solution":"from collections import Counter class WordFinder: def __init__(self, words): self.words = words def shortestContainingWord(self, target): target_count = Counter(target) shortest_length = float(\'inf\') found = False for word in self.words: word_count = Counter(word) if all(target_count[char] <= word_count[char] for char in target_count): found = True shortest_length = min(shortest_length, len(word)) return shortest_length if found else -1"},{"question":"Given a positive integer `n`, determine the number of distinct non-negative integer pairs (a, b) such that a * b = n. Return the list of pairs in any order. Each pair should consist of two non-negative integers [a, b]. If there are multiple pairs that satisfy the condition, any ordering is acceptable. Ensure that the solution is efficient for larger integers. Example: Input: n = 12 Output: [[1, 12], [2, 6], [3, 4], [4, 3], [6, 2], [12, 1]]","solution":"def find_pairs(n): Given a positive integer n, returns the list of distinct non-negative integer pairs (a, b) such that a * b = n. Each pair is represented as a list [a, b]. pairs = [] for a in range(1, int(n**0.5) + 1): if n % a == 0: b = n // a pairs.append([a, b]) if a != b: pairs.append([b, a]) return pairs"},{"question":"You are tasked with developing an algorithm to find the shortest distance from a starting node to all other nodes in an unweighted graph. The graph is represented as an adjacency list where `graph[i]` is a list of all the nodes `j` such that there is an edge between node `i` and node `j`. Given the number of nodes `n`, the adjacency list `graph`, and a starting node `start`, return an array of length `n` where the value at index `i` represents the shortest distance from the starting node to node `i`. If a node is unreachable from the starting node, the distance should be represented as `-1`.","solution":"from collections import deque def shortest_distance(n, graph, start): Returns the shortest distances from the starting node to all other nodes in an unweighted graph. Parameters: n (int): Number of nodes graph (list): Adjacency list of the graph start (int): Starting node Returns: list: A list of shortest distances distances = [-1] * n distances[start] = 0 queue = deque([start]) while queue: current_node = queue.popleft() current_distance = distances[current_node] for neighbor in graph[current_node]: if distances[neighbor] == -1: # neighbor not visited yet distances[neighbor] = current_distance + 1 queue.append(neighbor) return distances"},{"question":"You are given an unsorted array `arr` of positive integers. Your task is to find the smallest `missing positive integer` from the array. A positive integer is considered missing if it is not present in the array. Return _the **smallest missing positive integer** from_ `arr`_.","solution":"def smallest_missing_positive(arr): Returns the smallest missing positive integer from the array. # Step 1: Segregate positive numbers and move non-positive numbers to the left n = len(arr) j = 0 for i in range(n): if arr[i] <= 0: # Swap arr[i] and arr[j] arr[i], arr[j] = arr[j], arr[i] j += 1 # Now, arr from index j to n-1 contains all positive numbers positive_arr = arr[j:] # Step 2: Mark elements as visited by turning the value at index \'value-1\' negative for i in range(len(positive_arr)): val = abs(positive_arr[i]) if val - 1 < len(positive_arr) and positive_arr[val - 1] > 0: positive_arr[val - 1] = -positive_arr[val - 1] # Step 3: The first index which has a positive value indicates the missing smallest positive number for i in range(len(positive_arr)): if positive_arr[i] > 0: return i + 1 # If all indexes hold correct values, return len(positive_arr) + 1 return len(positive_arr) + 1"},{"question":"Given a list of integers `nums`, your task is to determine if the array contains any duplicates. Return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.","solution":"def contains_duplicate(nums): Determines if the array contains any duplicates. Args: nums (list): A list of integers. Returns: bool: True if any value appears at least twice in the array, False if every element is distinct. return len(set(nums)) != len(nums)"},{"question":"You are provided with a `2D` grid of size `m x n` and a car starting at the top left cell `(0, 0)`. The car can move either right or down, but some cells are blocked and cannot be entered. You need to calculate the number of distinct paths from the top left cell to the bottom right cell `(m-1, n-1)`. Write a function that takes in the grid and returns the number of such distinct paths. If there is no possible path, return `0`. # Example: ```python grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]] number_of_paths(grid) -> 2 ``` In the above example, there are two paths from `(0,0)` to `(2,2)`: 1. Right, Right, Down, Down 2. Down, Down, Right, Right","solution":"def number_of_paths(grid): Calculate the number of distinct paths from the top left cell to the bottom right cell in a 2D grid, avoiding blocked cells. Args: grid (list of list of int): The m x n grid where 0 represents an open cell and 1 represents a blocked cell. Returns: int: Number of distinct paths from top left to bottom right cell. m = len(grid) n = len(grid[0]) # Initialize a DP table with 0s dp = [[0]*n for _ in range(m)] # If the start or end cell is blocked, return 0 as no path is possible. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize the start position dp[0][0] = 1 # Fill out the DP table for i in range(m): for j in range(n): if grid[i][j] == 1: # Blocked cell dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] # paths from the top if j > 0: dp[i][j] += dp[i][j-1] # paths from the left return dp[m-1][n-1]"},{"question":"You are given a list of non-negative integers representing the amount of money of each house, arranged in a circle. Determine the maximum amount of money you can rob tonight without alerting the police. **Note**: Since the houses are arranged in a circle, the first house and the last house are adjacent to each other. You cannot rob two adjacent houses. Implement the `rob` function: * `int rob(List<Integer> nums)` where `nums` is the list of integers representing the money in each house. The function should return the maximum amount of money you can rob without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money one can rob from houses arranged in a circle. :param nums: List of non-negative integers representing the amount of money in each house. :return: Maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) # Helper function to rob a line of houses (non-circular) def rob_line(nums): prev, curr = 0, 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr # Rob houses from 0 to n-2 and from 1 to n-1, then take the maximum of both scenarios return max(rob_line(nums[:-1]), rob_line(nums[1:]))"},{"question":"Write a function that takes a single string `s` as input, which represents a column title as appears in an Excel sheet, and returns the corresponding column number. For example: - `A` -> 1 - `B` -> 2 - `C` -> 3 - `Z` -> 26 - `AA` -> 27 - `AB` -> 28 Your task is to convert the given column title into its corresponding column number.","solution":"def excel_column_number(s): Convert an Excel column title to its corresponding column number. result = 0 for char in s: result = result * 26 + (ord(char) - ord(\'A\') + 1) return result"},{"question":"You are given two positive integers `a` and `b` representing the dimensions of a grid. Each cell of the grid can contain either a `0` (empty) or a `1` (occupied). You start from the top-left corner of the grid and want to reach the bottom-right corner. You can move in four possible directions: left, right, up, and down, but you can only move to an adjacent cell that contains `0`. Determine if there exists a path from the top-left corner to the bottom-right corner. If such a path exists, return a list of the coordinates representing the path taken. If no such path exists, return an empty list. The grid boundaries are represented by cells with `1`, so no path can go outside the grid\'s boundaries.","solution":"def find_path(grid): def dfs(x, y, path): if x == len(grid) - 1 and y == len(grid[0]) - 1: path.append((x, y)) return True if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 1: return False grid[x][y] = 1 # Mark cell as visited to prevent revisiting path.append((x, y)) # Explore the four possible directions if (dfs(x + 1, y, path) or dfs(x - 1, y, path) or dfs(x, y + 1, path) or dfs(x, y - 1, path)): return True path.pop() return False if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return [] path = [] if dfs(0, 0, path): return path else: return []"},{"question":"You are given a string `word` that consists of lowercase and uppercase English letters. You need to determine if `word` follows the rules of capital usage. Specifically, there are three types of capital usage rules: 1. All letters in the word are capital letters. 2. All letters in the word are not capital letters. 3. Only the first letter in the word is a capital letter. Return `true` if `word` matches any of the aforementioned rules, otherwise return `false`.","solution":"def detect_capital_use(word): Returns True if the word follows the capital usage rules, False otherwise. The capital usage rules are: 1. All letters in the word are capital letters. 2. All letters in the word are not capital letters. 3. Only the first letter in the word is a capital letter. if word.isupper(): return True if word.islower(): return True if word[0].isupper() and word[1:].islower(): return True return False"},{"question":"You are given an integer array `nums` and an integer `k`. Split the array into `k` non-empty contiguous subarrays with each subarray having the largest possible sum such that the smallest sum among these subarrays is as large as possible. Return _this largest possible smallest sum_.","solution":"def split_array(nums, k): def can_split(max_sum): count, curr_sum = 1, 0 for num in nums: curr_sum += num if curr_sum > max_sum: count += 1 curr_sum = num if count > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` containing only lowercase English letters. You need to perform the following operations repeatedly until the string becomes empty: 1. Identify the lexicographically smallest character in the string. 2. Remove all occurrences of this character from the string. Return a list where each element represents the number of occurrences of each character removed in each step. For example, for the input string `s = \\"banana\\"`, the output should be `[2, 1, 1, 1, 1]` because: - In the first step, \'a\' is the smallest character and appears 3 times, the string becomes \\"bnn\\". - In the second step, \'b\' is the smallest character and appears 1 time, the string becomes \\"nn\\". - In the third step, \'n\' is the smallest character and appears 2 times, the string becomes empty.","solution":"def remove_lexicographically_smallest(s): Removes the lexicographically smallest character from the string s until it\'s empty. Returns a list of counts of the smallest character removed in each step. frequency_counts = [] while s: smallest_char = min(s) count = s.count(smallest_char) frequency_counts.append(count) s = s.replace(smallest_char, \'\') # Remove all occurrences of the smallest character return frequency_counts"},{"question":"You are given an array of integers `arr` and a target integer `target`. Your task is to find two integers in `arr` such that their sum is closest to the `target`. Return the sum of the two integers. You may assume that each input would have exactly one solution, and you may not use the same element twice in the sum. Write a function `closestSum(int[] arr, int target)` that returns the closest sum.","solution":"def closestSum(arr, target): Finds two integers in arr such that their sum is closest to the target. Returns the sum of the two integers. arr.sort() closest_sum = float(\'inf\') left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"You are given a matrix `grid` consisting of `m` rows and `n` columns, where each cell contains a non-negative integer. The goal is to find the maximum sum of a subgrid of size `k x k` that can be placed anywhere within the `grid`. The subgrid must be entirely contained within the `grid`. Return the maximum sum of any such subgrid.","solution":"def max_sum_subgrid(grid, k): Returns the maximum sum of a k x k subgrid within the given grid. Parameters: grid (list of list of int): 2D list representing the grid. k (int): size of the subgrid. Returns: int: maximum sum of any k x k subgrid. m, n = len(grid), len(grid[0]) out = float(\'-inf\') for i in range(m - k + 1): for j in range(n - k + 1): current_sum = sum( grid[x][y] for x in range(i, i + k) for y in range(j, j + k) ) out = max(out, current_sum) return out"},{"question":"Given a string `text` and an array of words `queries`, check for each word in `queries` if it can be formed by deleting some characters of the string `text` without reordering the remaining characters. Return an array of boolean values indicating the results for each word in `queries`.","solution":"def can_form_by_deleting(text, word): Check if `word` can be formed by deleting some characters of `text` without reordering. it = iter(text) return all(char in it for char in word) def check_words_by_deleting(text, queries): Check for each word in `queries` if it can be formed by deleting some characters of `text` without reordering the remaining characters. return [can_form_by_deleting(text, word) for word in queries]"},{"question":"In this task, you need to implement an algorithm to find the shortest transformation sequence from a starting word `beginWord` to an ending word `endWord`. Given a list of words `wordList` which contains all the words that can be used for the transformation, your algorithm should output the length of the shortest transformation sequence. If no valid transformation sequence exists, return 0. A valid transformation is defined by the following rules: - Only one letter can be changed at a time. - Each transformed word must exist in the `wordList`. **Note:** - The starting word (`beginWord`) is not included in the `wordList`. - Each transformation must be a valid word from the `wordList`. **Example:** ``` Input: beginWord = \\"hit\\", endWord = \\"cog\\", wordList = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"] Output: 5 Explanation: One shortest transformation sequence is \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\", which is 5 words long. ```","solution":"from collections import deque def shortest_transformation_sequence(beginWord, endWord, wordList): word_set = set(wordList) if endWord not in word_set: return 0 queue = deque([(beginWord, 1)]) while queue: current_word, level = queue.popleft() if current_word == endWord: return level for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: queue.append((next_word, level + 1)) word_set.remove(next_word) return 0"},{"question":"Given a string `s` which consists of lowercase English letters, return the first non-repeating character in `s`. If there is no non-repeating character, return a single dot (`\'.\'`). The function should be efficient and operate in linear time complexity. For example: - For `s = \\"leetcode\\"`, the first non-repeating character is `\'l\'`. - For `s = \\"loveleetcode\\"`, the first non-repeating character is `\'v\'`. - For `s = \\"aabb\\"`, there is no non-repeating character, so the function should return `\'.\'`.","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in s. If there is no non-repeating character, returns a single dot (\'.\'). from collections import Counter # First, count the frequency of each character in the string char_count = Counter(s) # Iterate through the string to find the first non-repeating character for char in s: if char_count[char] == 1: return char # If no non-repeating character was found, return \'.\' return \'.\'"},{"question":"You are given a `Trie` (pronounced as \\"try\\"), which is a type of k-ary search tree used to store a dynamic set or associative array where the keys are usually strings. Each node of the trie represents a single character of a string. Implement the Trie data structure with the following functions: * `Trie()`: Initializes the trie object. * `void insert(String word)`: Inserts the string `word` into the trie. * `boolean search(String word)`: Returns `true` if the string `word` is in the trie, and `false` otherwise. * `boolean startsWith(String prefix)`: Returns `true` if there is any string in the trie that starts with the string `prefix`, and `false` otherwise. Your implementation should handle standard trie operations and ensure efficient insertion and search functionalities.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word: str) -> bool: current_node = self.root for char in word: if char not in current_node.children: return False current_node = current_node.children[char] return current_node.is_end_of_word def startsWith(self, prefix: str) -> bool: current_node = self.root for char in prefix: if char not in current_node.children: return False current_node = current_node.children[char] return True"},{"question":"Given two strings `s` and `goal`, return `true` if and only if `s` can become `goal` after one or more swaps of any two characters in `s`. Otherwise, return `false`.","solution":"def can_become_goal(s, goal): Returns true if s can become goal after one or more swaps of any two characters in s. if len(s) != len(goal): return False # Check if the sorted characters of both strings are the same return sorted(s) == sorted(goal)"},{"question":"Given an integer array `arr` and an integer `target`, return the number of tuples `(i, j, k, l)` such that `i < j < k < l` and `arr[i] + arr[j] + arr[k] + arr[l] == target`.","solution":"def count_quadruples(arr, target): Returns the number of tuples (i, j, k, l) such that i < j < k < l and arr[i] + arr[j] + arr[k] + arr[l] == target. n = len(arr) count = 0 for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): for l in range(k + 1, n): if arr[i] + arr[j] + arr[k] + arr[l] == target: count += 1 return count"},{"question":"You are given two strings `s1` and `s2`. You need to check if `s2` is a permutation of `s1`. A permutation of a string is another string that contains the same characters, only the order of characters can be different. Return `true` if `s2` is a permutation of `s1`, otherwise return `false`.","solution":"def is_permutation(s1, s2): Check if s2 is a permutation of s1. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s2 is a permutation of s1, False otherwise. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"Given an integer array `nums` and an integer `x`, return _the minimum number of operations to reduce `x` to exactly_ `0` _by subtracting elements from the edges of the array_ `nums`. _An operation consists of removing either the leftmost or the rightmost element from the array, and subtracting its value from_ `x`. _If its not possible to reduce_ `x` _to zero, return_ `-1`.","solution":"def minOperations(nums, x): Returns the minimum number of operations to reduce x to exactly 0 by subtracting elements from the edges of the array nums. target = sum(nums) - x if target == 0: return len(nums) left = 0 current_sum = 0 max_len = -1 for right in range(len(nums)): current_sum += nums[right] while current_sum > target and left <= right: current_sum -= nums[left] left += 1 if current_sum == target: max_len = max(max_len, right - left + 1) return -1 if max_len == -1 else len(nums) - max_len"},{"question":"You are given an integer `n` denoting the number of nodes in a binary tree and an array `edges` where `edges[i] = [ui, vi]` represents a direct edge between nodes `ui` and `vi`. Assume the nodes are labeled from `0` to `n - 1`. Write a function to find and return the _diameter_ of the binary tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.","solution":"from collections import defaultdict, deque def tree_diameter(n, edges): Returns the diameter of the binary tree. if n == 0: return 0 if n == 1: return 0 # Create an adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Function to perform BFS and return the farthest node and distance def bfs(start_node): visited = [False] * n distance = [-1] * n queue = deque([start_node]) visited[start_node] = True distance[start_node] = 0 farthest_node = start_node farthest_distance = 0 while queue: node = queue.popleft() for neighbor in tree[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) distance[neighbor] = distance[node] + 1 if distance[neighbor] > farthest_distance: farthest_distance = distance[neighbor] farthest_node = neighbor return farthest_node, farthest_distance # Perform BFS twice to find the diameter # First BFS to find the farthest node from an arbitrary start node farthest_node, _ = bfs(0) # Second BFS from the farthest node found to find the maximum distance _, diameter = bfs(farthest_node) return diameter"},{"question":"Write a function to determine if a given string `s` can be rearranged to form a string such that every adjacent character is different. If it is possible, return one such rearrangement. If it is not possible, return an empty string. Note that the rearranged string does not have to be unique. Such a string is a string in which there are no adjacent characters that are the same.","solution":"import heapq from collections import Counter def rearrange_string(s): The function to determine if a given string `s` can be rearranged to form a string such that every adjacent character is different. If it is possible, return one such rearrangement. If it is not possible, return an empty string. # Counter for frequencies of each character counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) result = [] prev_char, prev_freq = None, 0 while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char, prev_freq = char, freq + 1 rearranged = \'\'.join(result) if len(rearranged) != len(s): return \\"\\" return rearranged"},{"question":"Given a circular linked list, return the node where the cycle begins. If there is no cycle, return `null`. Implement a function `ListNode* detectCycle(ListNode* head)` where: - `ListNode` is a structure for linked-list nodes, with an integer value `val` and a pointer `next` to the next node. Your solution should use constant extra space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Detect the node where the cycle begins in a circular linked list. If there is no cycle, return None. if not head or not head.next: return None slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if not fast or not fast.next: return None slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given a collection of `n` nodes labeled 1 to `n`. Each node is either a friend or an enemy with respect to another node. The relationships are given as an array of strings `relations` where each string `relations[i]` is of the form `\\"A B R\\"`, indicating that node `A` has relationship `R` with node `B`. `R` can be either `\\"friend\\"` or `\\"enemy\\"`. Determine if it is possible to assign a group to each node such that friends are in the same group and enemies are in different groups. Return `true` if it is possible, otherwise return `false`.","solution":"def possible_groups(n, relations): from collections import defaultdict graph = defaultdict(list) for relation in relations: A, B, R = relation.split() A, B = int(A), int(B) if R == \\"friend\\": graph[A].append((B, True)) graph[B].append((A, True)) elif R == \\"enemy\\": graph[A].append((B, False)) graph[B].append((A, False)) color = {} def dfs(node, c): if node in color: return color[node] == c color[node] = c for neighbor, is_friend in graph[node]: if is_friend: # friends in the same group if not dfs(neighbor, c): return False else: # enemies in different groups if not dfs(neighbor, not c): return False return True for node in range(1, n + 1): if node not in color: if not dfs(node, True): return False return True"},{"question":"You are given a string `s` consisting of multiple words separated by spaces. Write a function that returns the length of the longest word in the string. A word is defined as a contiguous sequence of non-space characters. If multiple words have the maximum length, return the length of the first such word encountered.","solution":"def length_of_longest_word(s): Returns the length of the longest word in the given string s. words = s.split() if not words: return 0 longest_word = max(words, key=len) return len(longest_word)"},{"question":"You are given two arrays of strings `words1` and `words2`. A string b in words2 is a subset of a string a in words1 if every character in b occurs in a including multiplicity. Return an array of all the strings in words1 where every string in words2 is a subset of it. **Note:** You may presume the inputs are lowercase English letters, and the length of words1 and words2 does not surpass 1000.","solution":"from collections import Counter def wordSubsets(words1, words2): Returns a list of words in words1 where every string in words2 is a subset of it. def countChars(word): return Counter(word) def isSubset(word_count, words2_count): for char, count in words2_count.items(): if word_count[char] < count: return False return True max_words2_count = Counter() for word in words2: word_count = countChars(word) for char, count in word_count.items(): max_words2_count[char] = max(max_words2_count[char], count) result = [] for word in words1: if isSubset(countChars(word), max_words2_count): result.append(word) return result"},{"question":"You are given an array of integers `nums` where each integer represents the number of candies a child has. Determine the **minimum** number of candies that you need to distribute to ensure every child has a **different** number of candies, given that you can only **add** candies (not remove) to each child. Return _the **minimum** additional candies needed_ to make the count of candies each child has unique.","solution":"def min_additional_candies(nums): Determine the minimum number of additional candies needed to make each count unique. Args: nums (list of int): List of integers representing candies each child has. Returns: int: Minimum additional candies needed. nums.sort() additional_candies = 0 for i in range(1, len(nums)): if nums[i] <= nums[i-1]: additional_candies += nums[i-1] - nums[i] + 1 nums[i] = nums[i-1] + 1 return additional_candies"},{"question":"You have a string `s` consisting of only lowercase English letters. You want to construct a new string by deleting exactly one character from `s` and moving the remaining characters freely such that the new string is a palindrome. Return `true` if it\'s possible to create such a palindrome through this process, or `false` otherwise.","solution":"def can_form_palindrome_by_deleting_one_char(s): def is_palindrome(sub_s): return sub_s == sub_s[::-1] for i in range(len(s)): if is_palindrome(s[:i] + s[i+1:]): return True return False"},{"question":"Given an integer array `arr`, find the length of the longest decreasing subsequence. The subsequence must be strictly decreasing, and the elements must appear in the same order as in the original array. Return the length of the longest decreasing subsequence.","solution":"def length_of_LDS(arr): Returns the length of the longest decreasing subsequence in the array. if not arr: return 0 n = len(arr) # Initialize the list to hold the length of longest decreasing subsequence ending at each index lds_lengths = [1] * n # Compute the lengths for each index for i in range(1, n): for j in range(i): if arr[j] > arr[i]: lds_lengths[i] = max(lds_lengths[i], lds_lengths[j] + 1) return max(lds_lengths)"},{"question":"Given a string `s`, return _the length of the longest contiguous substring that contains only unique characters_. If there are multiple longest substrings with the same length, return the length of any one of them. The input string will contain only ASCII characters.","solution":"def length_of_longest_substring(s): Returns the length of the longest contiguous substring that contains only unique characters. char_index_map = {} max_length = start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a string `s` containing only the characters `\'a\'` and `\'b\'`, you can perform an unlimited number of moves. In each move, you can remove one occurrence of the substring `\\"ab\\"` or `\\"ba\\"` from the string `s`. Your task is to return the minimum possible length of the resulting string after performing any number of moves. For example, given `s = \\"abab\\"`, the minimum possible length of the resulting string would be `0` because you can remove all characters by performing the following moves: 1. Remove `\\"ab\\"` from `\\"abab\\"` to get `\\"ab\\"`. 2. Remove `\\"ab\\"` from `\\"ab\\"` to get an empty string `\\"\\"`.","solution":"def min_length_after_removals(s): Returns the minimum possible length of the resulting string after performing moves to remove \\"ab\\" or \\"ba\\" substrings any number of times. # Count the number of \'a\'s and \'b\'s in the string a_count = s.count(\'a\') b_count = s.count(\'b\') # The resulting length will be the absolute difference between counts of \'a\' and \'b\' return abs(a_count - b_count)"},{"question":"Define a function `findLongestPalindrome` that, given a string `s`, returns the longest palindromic substring in `s`. A palindromic substring is a sequence of characters that reads the same backward as forward. You may assume that the maximum length of the string `s` is 1000.","solution":"def findLongestPalindrome(s): Returns the longest palindromic substring in the given string s. n = len(s) if n == 0: return \\"\\" # Table to store results of subproblems dp = [[False for _ in range(n)] for _ in range(n)] start = 0 max_length = 1 # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for sub-string of length 2. for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2. for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 # Ending index of current substring # Checking for sub-string from ith index to jth index if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"Given a 2D grid of `m` rows and `n` columns, each cell in the grid can be empty (`.`, an empty string), blocked (`#`, a block character), or can be a start point (`S`) or a destination point (`D`). The robot can move up, down, left, or right to an adjacent empty cell. Find the length of the shortest path from the start point to the destination point, passing through empty cells only. If there is no such path, return -1.","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from start \'S\' to destination \'D\' in the grid. The robot can move in 4 directions: up, down, left, right. If there is no path, returns -1. def bfs(start): q = deque([start]) visited = set() visited.add(start) steps = 0 while q: for _ in range(len(q)): x, y = q.popleft() if grid[x][y] == \'D\': return steps for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited and grid[nx][ny] != \'#\': visited.add((nx, ny)) q.append((nx, ny)) steps += 1 return -1 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'S\': return bfs((i, j)) return -1"},{"question":"Given a string `s` consisting of lowercase English letters, you need to determine the smallest string that can be obtained by removing one character from `s`. Return the resulting string. If there are multiple strings possible, return the lexicographically smallest one. For example, given `s = \\"abc\\"`, removing any character gives `[\\"ab\\", \\"ac\\", \\"bc\\"]`. The lexicographically smallest string is `\\"ab\\"`.","solution":"def smallest_string_after_removal(s): Returns the lexicographically smallest string that can be obtained by removing one character from the string s. smallest = None for i in range(len(s)): candidate = s[:i] + s[i+1:] if smallest is None or candidate < smallest: smallest = candidate return smallest"},{"question":"You are given two non-empty binary trees `root1` and `root2`. Each node in these trees contains a single digit (0-9) value. You need to merge these two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum their values as the new value of the merged node. Otherwise, the non-null node will be used as the node of the new tree. Return the merged binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(root1, root2): Merges two binary trees by summing the values of overlapping nodes. If a node is non-null in only one tree, it is used as the node of the new tree. Parameters: root1 (TreeNode): Root node of the first binary tree. root2 (TreeNode): Root node of the second binary tree. Returns: TreeNode: Root node of the merged binary tree. if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged_val = root1.val + root2.val merged_tree = TreeNode(merged_val) merged_tree.left = merge_trees(root1.left, root2.left) merged_tree.right = merge_trees(root1.right, root2.right) return merged_tree"},{"question":"A **run-length encoding** is a data compression technique where consecutive occurrences of the same character are stored as a single character followed by the number of occurrences. For example, the run-length encoding of the string `\\"aabbbcccc\\"` would be `\\"a2b3c4\\"`. Given a string `encodedString` representing a run-length encoded input, return the **decoded** string. Consider the following run-length encoded string as an example: - Input: `\\"a2b1c5a3\\"` - Output: `\\"aabcccccaaa\\"` Write a function that takes `encodedString` as input and returns the corresponding **decoded** string. The encoded string contains only lowercase alphabetical characters and numeric digits. Assume valid input encoding with no leading zeros in counts.","solution":"def decode_run_length(encodedString): Decodes a run-length encoded string. Parameters: encodedString (str): The run-length encoded string. Returns: str: The decoded string. decoded_string = [] i = 0 while i < len(encodedString): char = encodedString[i] i += 1 count = 0 while i < len(encodedString) and encodedString[i].isdigit(): count = count * 10 + int(encodedString[i]) i += 1 decoded_string.append(char * count) return \'\'.join(decoded_string)"},{"question":"You are given a string `s` consisting of lowercase English letters and you need to make this string a palindrome. You can insert any character at any position in the string. Find the minimum number of insertions needed to make the string a palindrome. Design a function `minInsertionsToPalindrome` to calculate this: ```python def minInsertionsToPalindrome(s: str) -> int: # Your code here ```","solution":"def minInsertionsToPalindrome(s: str) -> int: Returns the minimum number of insertions needed to make the string a palindrome. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Minimum number of insertions required. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for left in range(n - length + 1): right = left + length - 1 if s[left] == s[right]: dp[left][right] = dp[left + 1][right - 1] else: dp[left][right] = min(dp[left + 1][right], dp[left][right - 1]) + 1 return dp[0][n - 1]"},{"question":"You are given an array `arr` of positive integers and an integer `target`. Your task is to determine if the array contains three distinct elements `a`, `b`, and `c` such that `a + b + c = target`. Return a boolean value `true` if such elements exist, otherwise return `false`. Assume that the array has at least three elements.","solution":"def three_sum(arr, target): Determines if there are three distinct elements in the array that sum up to the target. :param arr: List of positive integers :param target: Target sum :return: Boolean value indicating if such elements exist arr.sort() n = len(arr) for i in range(n-2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given an integer array `nums` consisting of `n` elements, and an integer `target`. You want to determine if there exists a contiguous subarray in `nums` whose sum is exactly equal to `target`. If such a subarray exists, return `true`; otherwise, return `false`. The subarray must have at least one element. For example, given `nums = [1, 2, 3, 7, 5]` and `target = 12`, the function should return `true` because the subarray `[2, 3, 7]` sums to `12`.","solution":"def has_subarray_with_sum(nums, target): Determines if there exists a contiguous subarray in `nums` whose sum is exactly equal to `target`. current_sum = 0 sum_map = {} for index, num in enumerate(nums): current_sum += num if current_sum == target: return True if (current_sum - target) in sum_map: return True sum_map[current_sum] = index return False"},{"question":"Given an array of `customers`, where `customers[i] = [arrival_i, departure_i]`, representing the arrival and departure times of the ith customer at a restaurant, determine the maximum number of customers that are in the restaurant simultaneously at any time. The `arrival_i` and `departure_i` times are given in 24-hour format. Return _the maximum number of customers that are in the restaurant at the same time_.","solution":"def max_customers(customers): This function takes a list of customers, where each customer is represented by a list containing their arrival and departure times. It returns the maximum number of customers that are in the restaurant simultaneously. events = [] for arrival, departure in customers: events.append((arrival, \'arrival\')) events.append((departure, \'departure\')) events.sort() max_count = 0 current_count = 0 for event in events: if event[1] == \'arrival\': current_count += 1 max_count = max(max_count, current_count) else: # event[1] == \'departure\' current_count -= 1 return max_count"},{"question":"Given a list of non-negative integers `arr`, return the maximum value of |arr[i] - arr[j]| + |i - j|, where 0  i, j < arr.length. Here, |x| denotes the absolute value of x.","solution":"def max_value(arr): Given a list of non-negative integers arr, returns the maximum value of |arr[i] - arr[j]| + |i - j|, where 0  i, j < arr.length. :param arr: List of non-negative integers :return: Maximum value as described if not arr or len(arr) == 1: return 0 max1 = max2 = float(\'-inf\') min1 = min2 = float(\'inf\') for i in range(len(arr)): max1 = max(max1, arr[i] + i) min1 = min(min1, arr[i] + i) max2 = max(max2, arr[i] - i) min2 = min(min2, arr[i] - i) return max(max1 - min1, max2 - min2)"},{"question":"Given a string `s` and a pattern `p`, return `true` if `s` matches the pattern `p`. The pattern `p` may include \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. The matching should cover the entire `s` string (not partial). For example, given `s = \\"aab\\"` and `p = \\"c*a*b\\"`, the return value would be `true` since `c*` can be ignored, and `a*` matches both \'a\'s, followed by \'b\'.","solution":"def is_match(s, p): Returns true if the string s matches the pattern p. The pattern p can include \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. # s is the input string # p is the pattern def match_helper(i, j): # If we have reached the end of the pattern if j == len(p): return i == len(s) # Check if the current characters match or if the pattern has a \'.\' first_match = i < len(s) and (p[j] == s[i] or p[j] == \'.\') # If there\'s a \'*\' in the pattern if j + 1 < len(p) and p[j + 1] == \'*\': # We use or because \'*\' can mean zero previous element or one or more previous elements return match_helper(i, j + 2) or (first_match and match_helper(i + 1, j)) else: # No \'*\' in the pattern, we move to the next characters return first_match and match_helper(i + 1, j + 1) return match_helper(0, 0)"},{"question":"You are given two strings `s` and `t` that both represent large integers. The strings contain digits only and do not have leading zeros. Implement a function `multiplyStrings(s: str, t: str) -> str` to multiply the two numbers and return the product as a string. The function should handle multiplication of very large numbers efficiently, as typical integer types may not suffice due to potential overflow. Note that you should not use any built-in libraries that directly handle large integer multiplication.","solution":"def multiplyStrings(s: str, t: str) -> str: Multiplies two large integers represented as strings and returns the result as a string. # Edge case when one of the inputs is \\"0\\" if s == \\"0\\" or t == \\"0\\": return \\"0\\" # Initialize array to store the intermediate results product = [0] * (len(s) + len(t)) # Reverse both strings to facilitate multiplication from least significant digit s = s[::-1] t = t[::-1] # Perform multiplication digit by digit for i in range(len(s)): for j in range(len(t)): product[i + j] += int(s[i]) * int(t[j]) # Handle carry over product[i + j + 1] += product[i + j] // 10 product[i + j] %= 10 # Convert product array back to string and remove leading zeros while len(product) > 1 and product[-1] == 0: product.pop() return \'\'.join(map(str, product[::-1]))"},{"question":"You are given an array of integers `arr` representing the sizes of files. You need to merge these files into one file. The cost of merging two files is equal to the sum of their sizes. Return the minimum cost to merge all the given files into one file. For example, if `arr = [4, 6, 8]`, the optimal way to merge the files is: - Merge the files with sizes 4 and 6. The cost is 10. The array becomes [10, 8]. - Next, merge the files with sizes 10 and 8. The cost is 18. Thus, the total minimum cost is 10 + 18 = 28. If there is no file or only one file, the cost is zero.","solution":"import heapq def min_cost_to_merge_files(arr): Returns the minimum cost to merge all files into one single file. :param arr: List[int] - List of integers representing file sizes. :return: int - Minimum cost to merge all files. if not arr or len(arr) == 1: return 0 heapq.heapify(arr) total_cost = 0 while len(arr) > 1: first = heapq.heappop(arr) second = heapq.heappop(arr) cost = first + second total_cost += cost heapq.heappush(arr, cost) return total_cost"},{"question":"You are given an integer array `arr` of length `n`. You need to identify the first integer in the array that appears more than once when traversing the array from left to right. If no such integer exists, return `-1`. For example, given the array `[2, 3, 3, 4, 2]`, the output should be `3` because it\'s the first integer that repeats. However, if the array were `[1, 2, 3, 4]`, since no element repeats, the output should be `-1`. Return the integer that appears more than once or `-1` if there are no repeating integers.","solution":"def first_repeating_element(arr): Returns the first integer in the array that appears more than once, or -1 if no such integer exists. seen = set() for num in arr: if num in seen: return num seen.add(num) return -1"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. Write a function that returns the length of the longest subarray in `nums` such that the absolute difference between the largest and smallest element of the subarray is less than or equal to `k`. **Example:** ```python # Input: nums = [8, 2, 4, 7], k = 4 # Output: 2 # Explanation: The longest subarrays with elements satisfying the condition are [8, 2] and [2, 4]. ```","solution":"from collections import deque def longestSubarray(nums, k): Returns the length of the longest subarray such that the absolute difference between the largest and smallest element of the subarray is less than or equal to k. if not nums: return 0 max_deque = deque() min_deque = deque() left = 0 max_length = 0 for right in range(len(nums)): while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"A string is a valid parentheses string (VPS) if it meets one of the following: - It is an empty string `\\"\\"`, or a single character not equal to `\'(\'` or `\')\'`. - It can be written as `AB` (A and B are VPSs), or as `(A)` (A is a VPS). You are given a function that receives a string `s`. Your task is to create a function that removes the minimum number of invalid parentheses in `s` to make the input string a valid parentheses string and return all possible results. You may return the answer in any order.","solution":"def remove_invalid_parentheses(s: str): def is_valid(string): count = 0 for char in string: if char == \'(\': count += 1 elif char == \')\': count -= 1 if count < 0: return False return count == 0 from collections import deque if not s: return [\\"\\"] visited = set([s]) queue = deque([s]) found = False valid_expressions = [] while queue: current_string = queue.popleft() if is_valid(current_string): found = True valid_expressions.append(current_string) if found: continue for i in range(len(current_string)): if current_string[i] not in (\'(\', \')\'): continue next_string = current_string[:i] + current_string[i+1:] if next_string not in visited: visited.add(next_string) queue.append(next_string) return valid_expressions"},{"question":"You are given an array of integers `arr` of length `n` and an integer `k`. You are allowed to reverse any subarray of length exactly `k` at most once. Your task is to find the lexicographically smallest array that can be obtained by reversing any such subarray exactly once. If multiple valid arrays exist, return any of them. Return the resulting array.","solution":"def reverse_k_group(arr, k): n = len(arr) min_array = arr[:] for i in range(n - k + 1): subarray_reversed = arr[:i] + arr[i:i + k][::-1] + arr[i + k:] if subarray_reversed < min_array: min_array = subarray_reversed return min_array"},{"question":"You are given an array `connections` where `connections[i] = [city1, city2]` represents a connection between `city1` and `city2` in the network. You are given an integer `n` representing the number of cities, numbered from `0` to `n-1`. Initially, the network is disconnected, and you can join two cities by connecting them directly. Your task is to find the minimum number of operations needed to make the entire network connected, or return `-1` if it is not possible. Each connection can be used only once to connect two cities.","solution":"def minimum_operations_to_connect_network(n, connections): Returns the minimum number of operations needed to make the entire network connected, or -1 if it is not possible. if len(connections) < n - 1: return -1 parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return True return False operations = 0 for city1, city2 in connections: if union(city1, city2): operations += 1 components = len({find(x) for x in range(n)}) return components - 1 if components == 1 else operations + (components - 1) if operations >= n - 1 else -1"},{"question":"You are given a string `s` containing only the characters \'(\' and \')\'. Your task is to determine if the given string is a valid parenthesis string. A valid parenthesis string satisfies the following conditions: - Every opening parenthesis \'(\' must have a corresponding closing parenthesis \')\'. - Every closing parenthesis \')\' must have a corresponding opening parenthesis \'(\'. - Open parentheses must be closed in the correct order, i.e., a closing parenthesis \')\' should not occur before its corresponding opening parenthesis \'(\'. Write a function that takes the string `s` as input and returns `True` if the string is a valid parenthesis string, and `False` otherwise. For example: - Input: s = \\"()\\" Output: True - Input: s = \\"(()\\" Output: False","solution":"def is_valid_parenthesis(s): Determines if the given string s is a valid parenthesis string. Args: s (str): A string containing only characters \'(\' and \')\'. Returns: bool: True if the string is a valid parenthesis string, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"Develop a program to manage an inventory system for a store, which tracks the quantity of various items. Implement the `InventorySystem` class: * `void addItem(string itemName, int quantity)`: Adds `quantity` amount of the item `itemName` into the inventory. If the item already exists, increment its quantity by the provided amount. * `void removeItem(string itemName, int quantity)`: Removes `quantity` amount of the item `itemName` from the inventory. If the quantity to be removed exceeds the current quantity, set the item\'s quantity to 0. * `int getQuantity(string itemName)`: Returns the current quantity of the item `itemName` in the inventory. If the item does not exist, returns 0. * `list<string> getItemsBelowThreshold(int threshold)`: Returns a list of item names whose quantities are below the specified `threshold`. Ensure each method operates efficiently and correctly handles various edge cases, such as adding or removing items not present in the inventory or managing items with quantities that may potentially reach zero.","solution":"class InventorySystem: def __init__(self): self.inventory = {} def addItem(self, itemName, quantity): if itemName in self.inventory: self.inventory[itemName] += quantity else: self.inventory[itemName] = quantity def removeItem(self, itemName, quantity): if itemName in self.inventory: self.inventory[itemName] = max(0, self.inventory[itemName] - quantity) def getQuantity(self, itemName): return self.inventory.get(itemName, 0) def getItemsBelowThreshold(self, threshold): return [item for item, quantity in self.inventory.items() if quantity < threshold]"},{"question":"You are given a binary tree with `n` nodes, where each node has a unique value from `1` to `n`. The root of the tree is always `1`. Each node has at most two children. You are also given a 2D list `edges` where each `edges[i]` contains `[u, v, d]` denoting that there is an edge between node `u` and node `v`, and `d` is either `0` indicating `v` is the left child of `u`, or `1` indicating `v` is the right child of `u`. Given a target integer `k`, determine if there is a path from the root to any leaf such that the sum of all node values along the path equals `k`. Return `true` if such a path exists, otherwise return `false`. A **leaf** is a node with no children.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(edges): if not edges: return None tree_nodes = {} for u, v, d in edges: if u not in tree_nodes: tree_nodes[u] = TreeNode(u) if v not in tree_nodes: tree_nodes[v] = TreeNode(v) if d == 0: tree_nodes[u].left = tree_nodes[v] else: tree_nodes[u].right = tree_nodes[v] return tree_nodes[1] def has_path_sum(root, k): if not root: return False if not root.left and not root.right: return root.val == k k -= root.val return has_path_sum(root.left, k) or has_path_sum(root.right, k) def is_path_sum(edges, k): root = build_tree(edges) return has_path_sum(root, k)"},{"question":"You are given an array `tasks` where each element is a positive integer representing the time taken to complete that task. You also have an integer `totalTime` representing the maximum time you can spend completing tasks in one day. Each day, you must complete as many tasks as possible without exceeding `totalTime`. Return _the maximum number of days_ required to complete all tasks. Note that you cannot partially complete a task in one day and finish it on another day.","solution":"def max_days_to_complete_tasks(tasks, totalTime): Parameters: tasks: List[int] - list of positive integers representing the time taken to complete each task totalTime: int - maximum time you can spend completing tasks in one day Returns: int: maximum number of days required to complete all tasks days = 0 current_time = 0 for task in tasks: if current_time + task > totalTime: days += 1 current_time = 0 current_time += task if current_time > 0: days += 1 return days"},{"question":"Given a string `s` consisting of lowercase English letters and digits, place each character in ascending order while maintaining the relative positions of letters and digits. Return the rearranged string. Example: Input: \\"c2a1d3b\\" Output: \\"a1b2c3d\\"","solution":"def rearrange_string(s): Rearrange the given string such that letters and digits are in ascending order while maintaining their relative positions. Args: s (str): Input string containing lowercase English letters and digits. Returns: str: The rearranged string. # Separate the letters and digits letters = sorted([ch for ch in s if ch.isalpha()]) digits = sorted([ch for ch in s if ch.isdigit()]) # Track the positions to fill in letters and digits letter_index = 0 digit_index = 0 result = [] # Reconstruct the string by placing sorted letters and digits for ch in s: if ch.isalpha(): result.append(letters[letter_index]) letter_index += 1 else: result.append(digits[digit_index]) digit_index += 1 return \'\'.join(result)"},{"question":"Given a binary tree, write an algorithm to connect each node with its next right node. The next right node is defined as the node at the same level and immediately to the right of the current node. If there is no next right node, the next pointer should be set to `null`. Implement the function `connect(Node root)`, where `Node` is defined as: ```python class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next ``` The function should populate each `next` pointer to point to its next right node. The algorithm should work efficiently with an expected time complexity of O(n) where n is the number of nodes in the binary tree.","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): if not root: return None # Initialize the current node as the root current = root # Use dummy node technique to establish the \'next\' pointers while current: dummy = Node(0) tail = dummy # Iterate over the current level while current: if current.left: tail.next = current.left tail = tail.next if current.right: tail.next = current.right tail = tail.next current = current.next # Move to the next level current = dummy.next return root"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `d`. You can jump at most `d` steps to the left or to the right from each index `i` (i.e., from index `i`, you can jump to any index in the range `[i-d, i+d]` inclusive if that index exists within the bounds of the array). You can only jump if the target index has a strictly smaller value than the current index. Return _the maximum number of indices you can visit using the described jump strategy starting from any index_.","solution":"def max_jumps(arr, d): def dfs(i): if dp[i] != -1: return dp[i] max_count = 1 for direction in [-1, 1]: for j in range(1, d + 1): new_index = i + direction * j if 0 <= new_index < len(arr) and arr[new_index] < arr[i]: max_count = max(max_count, 1 + dfs(new_index)) else: break dp[i] = max_count return dp[i] dp = [-1] * len(arr) return max(dfs(i) for i in range(len(arr)))"},{"question":"You are given an array `arr` of positive integers and two integers `k` and `m`. Your task is to partition the array into exactly `k` non-empty subsets such that the sum of elements in each subset is less than or equal to `m`. Return `true` if such a partitioning is possible, and `false` otherwise. Implement the function: ```python def canPartition(arr: List[int], k: int, m: int) -> bool: # your code here ```","solution":"from typing import List def canPartition(arr: List[int], k: int, m: int) -> bool: def canPartitionKSubsets(nums, k, target, start, cur_sum, visited): if k == 1: return True if cur_sum > target: return False if cur_sum == target: return canPartitionKSubsets(nums, k - 1, target, 0, 0, visited) for i in range(start, len(nums)): if not visited[i]: visited[i] = True if canPartitionKSubsets(nums, k, target, i + 1, cur_sum + nums[i], visited): return True visited[i] = False return False if sum(arr) % k != 0: return False target = sum(arr) // k if target > m: return False visited = [False] * len(arr) arr.sort(reverse=True) return canPartitionKSubsets(arr, k, target, 0, 0, visited)"},{"question":"You are given a list of `n` non-negative integers representing the amount of water that each bucket can hold. The buckets are placed next to each other on a straight line, and the `k-th` bucket has a height `height[k]`. Compute the maximum amount of water that can be trapped between the buckets after raining. Use the heights of the buckets as an indication of the barriers that can trap water. Return the maximum amount of trapped water.","solution":"def max_trapped_water(height): Calculates the maximum amount of water that can be trapped between the buckets. :param height: List[int], List of non-negative integers representing the heights of buckets. :return: int, The maximum amount of trapped water. if not height: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) trapped_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) trapped_water += max(0, right_max - height[right]) return trapped_water"},{"question":"Given a binary tree, return the zigzag level order traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). Each node in the binary tree has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` The input is the root node of the binary tree. Each node will have a value and pointers to its left and right children, which may be null. Return the traversal as a list of lists, where each inner list represents the node values at a particular level.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. if not root: return [] results = [] current_level = [root] left_to_right = True while current_level: level_values = [node.val for node in current_level] if not left_to_right: level_values.reverse() results.append(level_values) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level left_to_right = not left_to_right return results"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and two integers `k1` and `k2`. The task is to perform exactly `k1` increments on the elements of `nums1` and `k2` increments on the elements of `nums2`. Each increment operation allows you to select one element from an array and increment its value by 1. Your goal is to find the minimum possible sum of the absolute differences between the elements of `nums1` and `nums2` after all the increment operations have been performed. The absolute difference between two elements `a` from `nums1` and `b` from `nums2` is defined as `|a - b|`. Implement the `minAbsoluteSumDiff` class: * `int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2)` - Returns the minimum possible sum of absolute differences after performing exactly `k1` increments on the elements of `nums1` and `k2` increments on the elements of `nums2`.","solution":"def minAbsoluteSumDiff(nums1, nums2, k1, k2): total_operations = k1 + k2 if not total_operations: return sum(abs(a - b) for a, b in zip(nums1, nums2)) diffs = [abs(a - b) for a, b in zip(nums1, nums2)] i = 0 while total_operations: max_diff_index = diffs.index(max(diffs)) if nums1[max_diff_index] > nums2[max_diff_index]: diff = nums1[max_diff_index] - nums2[max_diff_index] nums1[max_diff_index] -= 1 new_diff = abs(nums1[max_diff_index] - nums2[max_diff_index]) elif nums2[max_diff_index] > nums1[max_diff_index]: diff = nums2[max_diff_index] - nums1[max_diff_index] nums2[max_diff_index] -= 1 new_diff = abs(nums2[max_diff_index] - nums1[max_diff_index]) else: total_operations -= 1 continue diffs[max_diff_index] = new_diff total_operations -= 1 return sum(diffs)"},{"question":"You are given two integers, `n` and `k`. Create a string `s` of length `n` such that the lexicographical rank of `s` when all permutations of `n` characters (\'a\', \'b\', ..., up to `n`th English lowercase letter) are considered, is `k`. If such a string does not exist, return an empty string. The lexicographical rank is the position of the permutation when all permutations are sorted in dictionary order.","solution":"import math def find_kth_permutation(n, k): Finds and returns the k-th permutation of the first n lowercase English letters. If such a permutation does not exist, returns an empty string. if k > math.factorial(n): return \\"\\" letters = [chr(ord(\'a\') + i) for i in range(n)] permutation = [] k -= 1 # Convert k to zero-based index for i in range(n, 0, -1): factorial = math.factorial(i - 1) index = k // factorial permutation.append(letters.pop(index)) k %= factorial return \'\'.join(permutation)"},{"question":"A company has a list of `n` employees represented by integers from `0` to `n-1`. The company organizes a meeting where some employees are directly connected to others. You are given a 2D integer array `connections` where `connections[i] = [employee1i, employee2i]` indicates that employee `employee1i` and employee `employee2i` are directly connected for the purpose of this meeting. An employee can communicate with another if there is a direct or indirect connection between them. Write a function to determine the minimum number of groups the employees need to form so that every employee in each group can communicate with every other employee in the same group. Return the number of such groups. If no connections are provided, each employee should be considered as their own group.","solution":"def find_number_of_groups(n, connections): Determine the minimum number of groups the employees need to form so that every employee in each group can communicate with every other employee in the same group. :param n: Total number of employees :param connections: List of direct connections between employees :return: Minimum number of groups # Utility DFS function to explore the graph def dfs(employee, visited, adjacency_list): visited.add(employee) for neighbor in adjacency_list[employee]: if neighbor not in visited: dfs(neighbor, visited, adjacency_list) # Build the adjacency list adjacency_list = {i: [] for i in range(n)} for e1, e2 in connections: adjacency_list[e1].append(e2) adjacency_list[e2].append(e1) # Find all connected components (groups) visited = set() groups = 0 for employee in range(n): if employee not in visited: groups += 1 dfs(employee, visited, adjacency_list) return groups"},{"question":"Given a list of integers `nums` and an integer `k`, return the `k` most frequent elements in the list. The order of the output does not matter, but each element in the result must appear exactly `k` times. Implement the function `topKFrequent(nums: List[int], k: int) -> List[int]` that meets the described requirements. You can assume that the input list `nums` is non-empty, and `k` is always a positive integer not greater than the number of unique elements in the list.","solution":"from collections import Counter from typing import List def topKFrequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the list nums. count = Counter(nums) return [item for item, _ in count.most_common(k)]"},{"question":"Given an integer array `arr`, return _the length of the longest subarray that is either strictly increasing or strictly decreasing_. A subarray is a contiguous part of an array. For example, given `arr = [1, 3, 5, 4, 2, 1, 2, 3]`, the longest subarray that is strictly increasing or decreasing is `[5, 4, 2, 1]` and its length is `4`.","solution":"def longest_inc_dec_subarray(arr): n = len(arr) if n == 0: return 0 longest = 1 length_inc = 1 length_dec = 1 for i in range(1, n): if arr[i] > arr[i - 1]: length_inc += 1 length_dec = 1 elif arr[i] < arr[i - 1]: length_dec += 1 length_inc = 1 else: length_inc = 1 length_dec = 1 longest = max(longest, length_inc, length_dec) return longest"},{"question":"You are given an array `intervals` where `intervals[i] = [starti, endi]` represent the start and end times of the `i-th` interval. Write a function to insert a new interval `newInterval = [start, end]` into `intervals`, merging if necessary, to ensure that all intervals remain disjoint and sorted in ascending order of their start times. Return the resulting array of intervals after the insertion.","solution":"def insert(intervals, newInterval): Inserts a new interval into a list of existing intervals, merging overlapping intervals if necessary. :param intervals: List[List[int]] - A list of intervals [start, end] :param newInterval: List[int] - The interval that needs to be inserted [start, end] :return: List[List[int]] - The list of updated intervals after merging, if necessary. merged = [] i, n = 0, len(intervals) # Add all intervals ending before the new interval starts. while i < n and intervals[i][1] < newInterval[0]: merged.append(intervals[i]) i += 1 # Merge all overlapping intervals to the new interval. while i < n and intervals[i][0] <= newInterval[1]: newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i += 1 merged.append(newInterval) # Add all the remaining intervals. while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"Given a binary tree, return the values of its nodes as if you were performing a level-order traversal (also known as breadth-first traversal). Level-order traversal visits each level of the tree from left to right, starting from the root. Output the values in a single list.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Perform a level-order traversal on a binary tree and return the values of its nodes. :param root: TreeNode, the root of the binary tree :return: List[int], list of values in level-order if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"Given an array of distinct integers `arr` and an integer `k`, return the `kth` smallest pair distance in the array. The distance of a pair (`arr[i]`, `arr[j]`) is defined as the absolute difference between `arr[i]` and `arr[j]`.","solution":"def kth_smallest_pair_distance(arr, k): Returns the kth smallest pair distance in the array. arr.sort() n = len(arr) pair_distances = [] for i in range(n): for j in range(i + 1, n): pair_distances.append(abs(arr[i] - arr[j])) pair_distances.sort() return pair_distances[k - 1]"},{"question":"Given an array `nums` of integers, you need to find a subarray of `nums` of length `k` that has the maximum average value and return the average value of this subarray. A subarray is a contiguous part of an array. Note: The length of the array `n` is greater than or equal to `k`.","solution":"def findMaxAverage(nums, k): Finds the subarray of length k with the maximum average value and returns the average value. Parameters: nums (List[int]): The input array of integers. k (int): The length of the subarray. Returns: float: The maximum average value of the subarray of length k. n = len(nums) if n == 0 or k == 0 or k > n: return 0 # Calculate the sum of the first subarray of length k max_sum = curr_sum = sum(nums[:k]) # Traverse the array from the (k+1)-th element to the end for i in range(k, n): curr_sum = curr_sum - nums[i - k] + nums[i] max_sum = max(max_sum, curr_sum) # The maximum average is the maximum sum divided by k return max_sum / k"},{"question":"Given two integer arrays `arr1` and `arr2` sorted in non-decreasing order, return an array of the **intersection** of these two arrays. Each element in the result must be unique and you may return the result in any order. An integer `a` is in the intersection if it appears in both `arr1` and `arr2`.","solution":"def intersection(arr1, arr2): Returns an array of the intersection of two arrays with unique elements. Args: arr1 (List[int]): First sorted array. arr2 (List[int]): Second sorted array. Returns: List[int]: Array of the unique intersection elements. set1 = set(arr1) set2 = set(arr2) return list(set1.intersection(set2))"},{"question":": Given a string `expression` representing an arithmetic expression with integers and the operators `+`, `-`, `*`, and `/`, evaluate the expression and return the result as an integer. The expression is guaranteed to be valid, with no leading or trailing spaces, and all operations are performed in integer arithmetic (i.e., the result of division is an integer without rounding). You can assume the expression does not contain any parentheses and follows the correct operator precedence rules.","solution":"def evaluate_expression(expression): Evaluate the arithmetic expression provided and return the result as an integer. # We use stack to handle multiplication and division correctly num, stack, sign = 0, [], \'+\' for i, s in enumerate(expression): if s.isdigit(): num = num * 10 + int(s) if s in \'+-*/\' or i == len(expression) - 1: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': stack.append(int(stack.pop() / num)) sign = s num = 0 return sum(stack)"},{"question":"Given an array of integers `nums` where every element appears twice except for one element which appears only once, find that single element.","solution":"def single_number(nums): Returns the single element in an array where every other element appears twice. single = 0 for num in nums: single ^= num return single"},{"question":"You are given two strings `text1` and `text2`. Write a function that returns the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. For example, \\"ace\\" is a subsequence of \\"abcde\\". A common subsequence of two strings is a subsequence that is common to both strings. Implement the function `int longestCommonSubsequence(String text1, String text2)` that takes in two strings and returns the length of their longest common subsequence.","solution":"def longestCommonSubsequence(text1, text2): Returns the length of the longest common subsequence between text1 and text2. m, n = len(text1), len(text2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The last cell of dp array contains the length of longest common subsequence return dp[m][n]"},{"question":"You are given two arrays `word1` and `word2`. Both arrays consist of strings of lowercase English letters. Return `true` if the two arrays represent the same string when concatenated, and `false` otherwise. Assemble the strings in both arrays by concatenating their elements in order, and then compare the resulting strings.","solution":"def arrayStringsAreEqual(word1, word2): Returns True if the concatenation of the strings in word1 equals the concatenation of the strings in word2. return \'\'.join(word1) == \'\'.join(word2)"},{"question":"A **palindromic number** is a number that remains the same when its digits are reversed. For example, `121` is palindromic, whereas `123` is not. Given an integer `n`, return _a list of all palindromic numbers less than or equal to `n`._ Can you optimize your solution to handle large values of `n` efficiently?","solution":"def is_palindromic_number(x): Helper function to check if a number is palindromic. return str(x) == str(x)[::-1] def palindromic_numbers(n): Returns a list of all palindromic numbers less than or equal to n. return [i for i in range(n + 1) if is_palindromic_number(i)]"},{"question":"Given a list of integers `flowerbed` representing a flowerbed, where `0` means empty and `1` means not empty, and an integer `n`, return `True` if `n` new flowers can be planted without violating the rule that no two flowers can be planted in adjacent spots. Return `False` otherwise.","solution":"def can_place_flowers(flowerbed, n): Returns True if n new flowers can be planted in the flowerbed without violating the rule that no two flowers can be planted in adjacent spots. Otherwise, returns False. count = 0 length = len(flowerbed) for i in range(length): if flowerbed[i] == 0: prev_empty = (i == 0) or (flowerbed[i-1] == 0) next_empty = (i == length-1) or (flowerbed[i+1] == 0) if prev_empty and next_empty: flowerbed[i] = 1 count += 1 if count >= n: return True return count >= n"},{"question":"You are given an array `heights` representing the heights of students standing in a line in classroom. The array is not necessarily sorted. A sort operation involves rearranging the students such that any pair of adjacent heights differ by at most 1 unit. Your task is to determine the **minimum** number of sort operations required to achieve this arrangement. Return _the **minimum** number of sort operations needed to achieve the sorted heights with adjacent differences at most 1 unit_.","solution":"def min_sort_operations(heights): Returns the minimum number of sort operations required such that any pair of adjacent heights differ by at most 1 unit. heights.sort() # First sort the heights operations = 0 for i in range(1, len(heights)): if heights[i] - heights[i - 1] > 1: diff = heights[i] - (heights[i - 1] + 1) operations += diff heights[i] = heights[i - 1] + 1 # Adjust the current height to be max 1 unit more than previous one return operations"},{"question":"Given a binary string `s`, return _the length of the largest substring containing continuous \'1\'s that can be turned into all \'0\'s or vice versa by a single flipping of a contiguous segment_ (i.e., flipping either all \'1\'s to \'0\'s or all \'0\'s to \'1\'s in that segment).","solution":"def max_flip_length(s): Returns the length of the largest substring containing continuous \'1\'s that can be turned into all \'0\'s or vice versa by a single flipping of a contiguous segment. max_len = 0 count = 0 prev_char = \'\' for char in s: if char == prev_char: count += 1 else: max_len = max(max_len, count) count = 1 prev_char = char max_len = max(max_len, count) return max_len"},{"question":"You are given a `0-indexed` integer array `nums` and an integer `target`. Your task is to find the two integers in `nums` that add up to `target` and return their indices as a list `[index1, index2]`, where `index1 < index2`. If no such pair exists, return an empty list. It is guaranteed that there exists exactly one solution.","solution":"def two_sum(nums, target): Returns the indices of the two numbers in nums that add up to target. Parameters: nums (list of int): The list of integers to search. target (int): The target sum. Returns: list of int: A list containing the two indices. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"You have been given an `m x n` 2D grid initialized with these three possible values: - `-1` representing a wall, - `0` representing a gate, and - `INF` representing an empty room. Find the distance to the nearest gate for each empty room. The distance is represented by the number of steps (edges) in the shortest path from the empty room to the gate. If it is impossible to reach a gate, keep the room\'s value as `INF`. Fill the 2D grid with the updated values. You can assume that `INF` is an integer larger than the number of cells in the grid. Implement the function `void wallsAndGates(vector<vector<int>>& rooms)` that modifies the grid in-place.","solution":"from collections import deque def wallsAndGates(rooms): if not rooms or not rooms[0]: return rows, cols = len(rooms), len(rooms[0]) queue = deque() INF = 2147483647 # Initialize the queue with the positions of all gates for r in range(rows): for c in range(cols): if rooms[r][c] == 0: queue.append((r, c)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Perform BFS from each gate while queue: r, c = queue.popleft() for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and rooms[rr][cc] == INF: rooms[rr][cc] = rooms[r][c] + 1 queue.append((rr, cc))"}]'),N={name:"App",components:{PoemCard:Y},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},A={class:"search-container"},L={class:"card-container"},z={key:0,class:"empty-state"},C=["disabled"],S={key:0},E={key:1};function D(i,e,u,c,a,s){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",A,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>a.searchQuery=o),placeholder:"Search..."},null,512),[[b,a.searchQuery]]),a.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>a.searchQuery="")},"  ")):l("",!0)]),t("div",L,[(n(!0),r(y,null,v(s.displayedPoems,(o,g)=>(n(),w(f,{key:g,poem:o},null,8,["poem"]))),128)),s.displayedPoems.length===0?(n(),r("div",z,' No results found for "'+h(a.searchQuery)+'". ',1)):l("",!0)]),s.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:a.isLoading,onClick:e[2]||(e[2]=(...o)=>s.loadMore&&s.loadMore(...o))},[a.isLoading?(n(),r("span",E,"Loading...")):(n(),r("span",S,"See more"))],8,C)):l("",!0)])}const G=m(N,[["render",D],["__scopeId","data-v-d81f6100"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/7.md","filePath":"library/7.md"}'),P={name:"library/7.md"},O=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{B as __pageData,O as default};
