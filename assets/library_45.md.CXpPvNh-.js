import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-878ca328"]]),N=JSON.parse('[{"question":"# Question: Implement a Custom Activation Function in a Neural Network You are tasked with implementing a custom activation function for a feedforward neural network. The neural network class is already provided, but currently, it only supports the ReLU activation function. You need to extend this functionality by implementing a custom activation function that can handle multiple types of activations. Your task is to: 1. Implement the `custom_activation` method that performs different activation functions based on the input parameter. 2. Integrate this custom activation function into the feedforward process of the neural network class. Requirements: - Your `custom_activation` method should accept two parameters: - `x`: A numpy array representing the input to the activation function. - `activation_type`: Type of activation function to apply, which can be either \\"relu\\", \\"sigmoid\\", or \\"tanh\\". Input: - `x`: Numpy array. - `activation_type` (str): Activation function type, either \\"relu\\", \\"sigmoid\\", or \\"tanh\\". Output: - `activated_x`: Numpy array after applying the specified activation function. Constraints: - Assume that the input array `x` can be of any shape. # Example: ```python # Example input: x = np.array([-1, 0, 1]) activation_type = \'sigmoid\' # Expected output: # activated_x = np.array([0.26894142, 0.5, 0.73105858]) ``` Function signature: ```python def custom_activation(x: np.ndarray, activation_type: str) -> np.ndarray: pass ``` Example Neural Network Class: ```python class NeuralNetwork: def __init__(self, input_size, hidden_size, output_size): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.weights1 = np.random.rand(self.input_size, self.hidden_size) self.weights2 = np.random.rand(self.hidden_size, self.output_size) def feedforward(self, X, activation_type=\'relu\'): self.hidden = custom_activation(np.dot(X, self.weights1), activation_type) self.output = custom_activation(np.dot(self.hidden, self.weights2), activation_type) return self.output # Demonstrating the activation function within the class: nn = NeuralNetwork(3, 3, 2) X = np.array([[1, 2, 3]]) activation_type = \'tanh\' output = nn.feedforward(X, activation_type) print(output) ``` You should integrate your `custom_activation` method into the provided neural network class, ensuring it can handle the specified activation functions during the feedforward process.","solution":"import numpy as np def custom_activation(x: np.ndarray, activation_type: str) -> np.ndarray: if activation_type == \'relu\': return np.maximum(0, x) elif activation_type == \'sigmoid\': return 1 / (1 + np.exp(-x)) elif activation_type == \'tanh\': return np.tanh(x) else: raise ValueError(\\"Unsupported activation type. Supported types: \'relu\', \'sigmoid\', \'tanh\'.\\") class NeuralNetwork: def __init__(self, input_size, hidden_size, output_size): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.weights1 = np.random.rand(self.input_size, self.hidden_size) self.weights2 = np.random.rand(self.hidden_size, self.output_size) def feedforward(self, X, activation_type=\'relu\'): self.hidden = custom_activation(np.dot(X, self.weights1), activation_type) self.output = custom_activation(np.dot(self.hidden, self.weights2), activation_type) return self.output"},{"question":"# Maximum Subarray Sum with Dynamic Programming **Scenario/Context:** You are developing an automated trading system and need to analyze past stock price data to identify the most profitable trading periods. One way to do this is by finding the maximum sum of a contiguous subarray within a one-dimensional array of stock price changes. **Task:** Implement a function that uses Dynamic Programming to find the maximum sum of a contiguous subarray within a given array of integers. **Function Signature:** ```python def max_subarray_sum(arr: list) -> int: pass ``` # Input 1. **arr** (list): A list of integers representing the changes in stock prices. # Output - An integer representing the maximum sum of any contiguous subarray. # Constraints - `1 ≤ len(arr) ≤ 10^5` - `-10^3 ≤ arr[i] ≤ 10^3` for all elements in `arr` - The input list can contain both positive and negative integers. # Performance Requirements - The solution should have a time complexity of O(n) and space complexity of O(1). # Example ```python arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # Expected Output: # 6 # Explanation: # The subarray [4,-1,2,1] has the largest sum 6. print(max_subarray_sum(arr)) ``` # Edge Cases - Handle arrays with only one element. - Consider arrays with all negative numbers. - Include scenarios where the maximum sum is achieved by taking the entire array. # Validation Ensure that the input is a list of integers and not empty. Implement validation checks for the input constraints and handle any potential corner cases.","solution":"def max_subarray_sum(arr: list) -> int: Returns the maximum sum of a contiguous subarray within the given array. # Edge case: If the array has only one element, return that element. if len(arr) == 1: return arr[0] # Initialize the variables. max_so_far = arr[0] max_ending_here = arr[0] # Iterate through the array starting from the second element. for i in range(1, len(arr)): # Update max_ending_here by either starting a new subarray or extending the existing one. max_ending_here = max(arr[i], max_ending_here + arr[i]) # Update max_so_far to keep track of the maximum sum found so far. max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Coding Assessment Question Scenario You are tasked with creating a library management system that includes categorizing books by their genres and checking their availability. One specific feature needed is to determine the least populous genre when a new book is added, to ensure a balanced collection. Task Implement a function `find_least_populous_genre(library: dict, new_book: dict) -> str` that determines and returns the genre with the fewest books in the library when a new book is added. The library\'s data structure is a dictionary where the keys are genre names and the values are lists of book titles. The new book\'s data is a dictionary containing the book\'s title and genre. Requirements * **Input**: Two dictionaries: - `library`: keys are genre names (str), and values are lists of book titles (list of str) - `new_book`: keys are \'title\' (str) and \'genre\' (str) * **Output**: Genre name (str) with the fewest books after adding the new book. Constraints * Handle cases where the library initially has multiple genres with the same number of books. * If the new book\'s genre does not exist in the library, add it with the new book as its first entry. * The input dictionaries will always have a valid structure. Example ```python library = { \'Science Fiction\': [\'Dune\', \'Neuromancer\'], \'Fantasy\': [\'Harry Potter\', \'The Hobbit\'], \'Mystery\': [\'The Hound of the Baskervilles\'] } new_book = {\'title\': \'Ender\'s Game\', \'genre\': \'Science Fiction\'} find_least_populous_genre(library, new_book) # Output: \'Mystery\' ``` Notes * Update the library with the new book before determining the least populous genre. * In case of a tie among multiple genres, return any one of the least populous genres. * Use appropriate data structures to efficiently determine the genre with the fewest books.","solution":"def find_least_populous_genre(library, new_book): Determines and returns the genre with the fewest books in the library when a new book is added. :param library: dict, keys are genre names (str), values are lists of book titles (str) :param new_book: dict, keys are \'title\' (str) and \'genre\' (str) :return: str, genre with the fewest books after adding the new book genre = new_book[\'genre\'] title = new_book[\'title\'] if genre not in library: library[genre] = [] library[genre].append(title) min_genre = min(library, key=lambda g: len(library[g])) return min_genre"},{"question":"# Problem Statement Write a function `reorganize_string` that takes a string `s` and returns a new string such that no two adjacent characters are the same. If it is not possible to reorganize the string to satisfy this condition, return an empty string. # Requirements * The function should raise a ValueError with the message \\"Input string contains invalid characters\\" if the string `s` contains non-alphabetic characters. * The function should preserve the case of the original characters. * The function should not modify the input string `s`. * The solution must have a time complexity of O(n log n) or better for a string of length n. # Input * A string `s` containing alphabetic characters (both uppercase and lowercase). # Output * A new string with the same characters but reorganized such that no two adjacent characters are the same, or an empty string if such a reorganization is not possible. # Function Signature ```python def reorganize_string(s: str) -> str: pass ``` # Example ```python >>> reorganize_string(\\"aab\\") \\"aba\\" >>> reorganize_string(\\"aaab\\") \\"\\" >>> reorganize_string(\\"aabbcc\\") \\"abcabc\\" >>> reorganize_string(\\"abc123\\") Traceback (most recent call last): ... ValueError: Input string contains invalid characters ``` # Constraints * The length of the input string `s` can be between 0 and 10^5. * The input string `s` will only contain alphabetic characters and spaces.","solution":"import heapq from collections import Counter def reorganize_string(s: str) -> str: # Check for invalid characters if not s.isalpha(): raise ValueError(\\"Input string contains invalid characters\\") # Count the frequencies of each character counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] # Create a max heap based on character frequencies heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) result.append(char) prev_char = char prev_count = count + 1 # Decrease count (since it was negative, increase towards zero) if len(result) != len(s): return \\"\\" return \'\'.join(result)"},{"question":"# Context A company maintains a list of active users and each user has a corresponding activity score. The company wants to regularly identify their top-k active users to reward them. # Task Implement the `find_top_k_users` function that takes a list of tuples (where each tuple contains a user\'s name as a string and their respective activity score as an integer), and an integer k. The function should return the top-k users based on their activity scores in descending order. If multiple users have the same score, they should be sorted alphabetically by their names. # Function Signature ```python def find_top_k_users(users: list, k: int) -> list: pass ``` # Input * `users` (list): A list of tuples where each tuple contains: - `name` (string): The user\'s name. - `score` (integer): The user\'s activity score. * `k` (int): The number of top users to return. # Output * A list of strings representing the top-k users\' names sorted by their scores in descending order. If multiple users have the same score, they should be sorted by their names alphabetically. # Constraints * The list `users` can have up to 1000 elements. * Each `name` is a string (1 ≤ length of `name` ≤ 100). * Each `score` is an integer (-10^6 ≤ score ≤ 10^6). * 0 ≤ k ≤ 1000. # Examples ```python users = [(\\"Alice\\", 50), (\\"Bob\\", 50), (\\"Charlie\\", 40), (\\"David\\", 60)] print(find_top_k_users(users, 2)) # Output: [\\"David\\", \\"Alice\\"] users = [(\\"Eve\\", 60), (\\"Mallory\\", 60), (\\"Trudy\\", 60)] print(find_top_k_users(users, 2)) # Output: [\\"Eve\\", \\"Mallory\\"] users = [(\\"Oscar\\", 30), (\\"Trent\\", 20)] print(find_top_k_users(users, 1)) # Output: [\\"Oscar\\"] users = [] print(find_top_k_users(users, 3)) # Output: [] ``` # Performance Requirements The function should operate efficiently within the time limits for inputs up to 1000 elements. # Additional Instructions * Ensure your implementation is purely in Python and does not depend on any external libraries. * Include inline comments to document the main steps of your algorithm. * Handle edge cases such as an empty list or k being 0 gracefully. * Ensure your function maintains its performance for the upper limit of input sizes.","solution":"def find_top_k_users(users, k): Returns the top-k active users based on their activity scores in descending order. If multiple users have the same score, they are sorted alphabetically by their names. # Sort the users firstly by score in descending order (-score for descending), # and then by name alphabetically for users with same score sorted_users = sorted(users, key=lambda x: (-x[1], x[0])) # Extract only the names of the top-k users top_k_users = [user[0] for user in sorted_users[:k]] return top_k_users"},{"question":"# The Magic of Permutations: List Order Challenge **Context**: In this task, you will implement functions to calculate permutations for a given list of elements and a specific rank or order of permutation. **Objective**: Write functions to generate the nth permutation of a list and to find the rank of a given permutation. **Function Specifications**: 1. **find_permutation(items: List[int], perm_order: int) -> List[int]** - Input: * `items`: The original list of integers (the elements are all unique and sorted in ascending order). * `perm_order`: The zero-based index (rank) of the permutation to find (0 represents the first permutation in lexicographic order). - Output: * The permutation of the list corresponding to the `perm_order`. 2. **find_rank(items: List[int], perm: List[int]) -> int** - Input: * `items`: The original list of integers (the elements are all unique and sorted in ascending order). * `perm`: A specific permutation of the original list. - Output: * The zero-based index (rank) of the permutation `perm` within the lexicographic order of all permutations. **Requirements**: - Assume factorials needed to calculate permutations will fit within standard integer ranges. - Handle edge cases where the permutation order is the last possible permutation. **Example**: ```python items = [1, 2, 3] perm_order = 4 nth_permutation = find_permutation(items, perm_order) print(f\\"The 5th permutation = {nth_permutation}\\") rank = find_rank(items, nth_permutation) print(f\\"The rank of the permutation {nth_permutation} = {rank}\\") # Expected Output: # The 5th permutation = [3, 1, 2] # The rank of the permutation [3, 1, 2] = 4 ``` **Explanation**: 1. For the list `[1, 2, 3]`: - The first permutation (0th order) is `[1, 2, 3]`. - The second permutation (1st order) is `[1, 3, 2]`. - The third permutation (2nd order) is `[2, 1, 3]`. - The fourth permutation (3rd order) is `[2, 3, 1]`. - The fifth permutation (4th order) is `[3, 1, 2]`. - The sixth permutation (5th order) is `[3, 2, 1]`. 2. The rank of the permutation `[3, 1, 2]` within these is 4.","solution":"from math import factorial from typing import List def find_permutation(items: List[int], perm_order: int) -> List[int]: Returns the perm_order-th permutation of the given list of items. items = sorted(items) permutation = [] n = len(items) while n > 0: fact = factorial(n - 1) index = perm_order // fact permutation.append(items[index]) items.pop(index) perm_order %= fact n -= 1 return permutation def find_rank(items: List[int], perm: List[int]) -> int: Returns the rank of the given permutation in the sorted order list of all permutations. items = sorted(items) rank = 0 n = len(items) for i in range(n): index = items.index(perm[i]) rank += index * factorial(n - 1 - i) items.pop(index) return rank"},{"question":"# List Flattening Scenario A software application often needs to process nested lists and flatten them into a single list. You are tasked with implementing a function that accomplishes this, taking into account various levels of nesting. Task Write a function `flatten_list` that accepts a nested list of arbitrary depth and returns a single list with all the elements in depth-first order. Function Signature ```python def flatten_list(nested_list: list) -> list: Flattens a nested list into a single list containing all the elements in depth-first order. :param nested_list: A list which can contain other nested lists. :returns: A single list with all elements from the nested list. Examples: >>> flatten_list([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_list([[\'a\'], [\'b\', [\'c\', [\'d\']], \'e\'], \'f\']) [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] >>> flatten_list([[], [1, 2, [], [3]], [[4]], 5]) [1, 2, 3, 4, 5] ``` Input and Output Format - **Input**: - `nested_list`: A list that can contain other lists as elements, including nested lists of arbitrary depth. - **Output**: - A single list containing all elements from the nested list, preserved in a depth-first order. Constraints - The input may include any type of elements. - The input list is guaranteed to have at least one element. - Standard list operations like `append`, `extend`, etc. can be used to create the output list. Example ```python assert flatten_list([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_list([[\'a\'], [\'b\', [\'c\', [\'d\']], \'e\'], \'f\']) == [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] assert flatten_list([[], [1, 2, [], [3]], [[4]], 5]) == [1, 2, 3, 4, 5] ```","solution":"def flatten_list(nested_list): Flattens a nested list into a single list containing all elements in depth-first order. :param nested_list: A list which can contain other nested lists. :returns: A single list with all elements from the nested list. flat_list = [] for item in nested_list: if isinstance(item, list): flat_list.extend(flatten_list(item)) else: flat_list.append(item) return flat_list"},{"question":"# Coding Assessment Question As part of your assessments on graph theory and pathfinding algorithms, you are tasked with implementing a more efficient version of a classic pathfinding algorithm. This problem requires enhancing the Dijkstra\'s algorithm to efficiently handle graphs containing negative edge weights by leveraging the Bellman-Ford algorithm in scenarios where necessary. Function Signature ```python def efficient_pathfinder(graph, start, end): pass ``` Input/Output * **Input**: - `graph`: A dictionary of dictionaries representing the weighted graph. The keys are node identifiers (integers or strings), and the value for each key is another dictionary where the keys are the adjacent nodes and the values are the respective edge weights. Edge weights can be positive or negative integers. - `start`: The identifier (integer or string) of the starting node. - `end`: The identifier (integer or string) of the destination node. * **Output**: - Returns a tuple consisting of the shortest path (as a list of nodes) from `start` to `end`, and the total path cost as an integer. Constraints * The graph is sparse, containing up to 500 nodes and 2000 edges. * Negative edge weights are present, but there are no negative weight cycles accessible from the start node. * Nodes are uniquely identifiable by their labels (integers or strings). Scenario You are working as a logistics planner for a delivery company. You need to find the shortest path between various warehouses and customers while considering travel distances that sometimes involve negative shortcuts due to toll rebates, special offers, or other incentives. The system must be both efficient and capable of handling negative edges without falling into infinite loops caused by negative weight cycles. Performance Requirements * Must handle the computation for graphs up to the specified limit (500 nodes, 2000 edges) within a reasonable time frame (≤ 2 seconds for typical queries). Example ```python # Example usage graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5, \'E\': -3}, \'C\': {\'D\': 1}, \'D\': {\'E\': 3}, \'E\': {\'D\': 2} } print(efficient_pathfinder(graph, \'A\', \'D\')) # Output example: ([\'A\', \'B\', \'E\', \'D\'], 1) graph2 = { 0: {1: 4, 2: -2}, 1: {2: 3, 3: 2, 4: 2}, 2: {3: 1}, 3: {4: 5}, 4: {3: -3} } print(efficient_pathfinder(graph2, 0, 4)) # Output example: ([0, 2, 3, 4], 2) ``` Note You need to determine when to apply Dijkstra’s algorithm and when to switch to the Bellman-Ford algorithm based on the presence of negative weights, ensuring the shortest path is calculated correctly and efficiently.","solution":"import heapq def bellman_ford(graph, start, end): # Initialization distance = {node: float(\'inf\') for node in graph} predecessor = {node: None for node in graph} distance[start] = 0 # Relax edges |V|-1 times for _ in range(len(graph) - 1): for u in graph: for v in graph[u]: if distance[u] + graph[u][v] < distance[v]: distance[v] = distance[u] + graph[u][v] predecessor[v] = u # Check for negative-weight cycles for u in graph: for v in graph[u]: if distance[u] + graph[u][v] < distance[v]: raise ValueError(\\"Graph contains a negative weight cycle reachable from the start\\") # Retrieve the path path = [] current = end while current is not None: path.insert(0, current) current = predecessor[current] if path[0] != start: return [], float(\'inf\') return path, distance[end] def dijkstra(graph, start, end): # Priority queue of (cost, vertex) pq = [(0, start)] distance = {node: float(\'inf\') for node in graph} predecessor = {node: None for node in graph} distance[start] = 0 while pq: curr_distance, u = heapq.heappop(pq) if curr_distance > distance[u]: continue for v in graph[u]: weight = graph[u][v] distance_v = curr_distance + weight if distance_v < distance[v]: distance[v] = distance_v predecessor[v] = u heapq.heappush(pq, (distance_v, v)) # Retrieve the path path = [] current = end while current is not None: path.insert(0, current) current = predecessor[current] if path[0] != start: return [], float(\'inf\') return path, distance[end] def has_negative_edge(graph): for u in graph: for v in graph[u]: if graph[u][v] < 0: return True return False def efficient_pathfinder(graph, start, end): if has_negative_edge(graph): return bellman_ford(graph, start, end) else: return dijkstra(graph, start, end)"},{"question":"# Coding Assessment Question You are tasked with finding the Nth smallest element in a sorted matrix. # Problem Statement Write a function `find_nth_smallest(matrix: List[List[int]], n: int) -> int` that returns the Nth smallest element in a sorted matrix. The matrix is sorted in non-decreasing order both row-wise and column-wise. # Input - A 2D list `matrix` of dimensions `m x m`, where `1 <= m <= 300` and each element lies in the range [-10^9, 10^9]. - An integer `n` (1 <= n <= m*m) representing the position of the smallest element you need to find. # Output - An integer representing the Nth smallest element in the matrix. # Constraints - The matrix is square (i.e., `m` rows and `m` columns). - The matrix is sorted in non-decreasing order both row-wise and column-wise. # Example ```python >>> matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] >>> find_nth_smallest(matrix, 8) 13 >>> matrix = [ [1, 2], [1, 3] ] >>> find_nth_smallest(matrix, 2) 1 ``` # Notes - You must implement an efficient algorithm to handle the matrix dimensions and range of values effectively. - Aim for a solution with time complexity better than O(m^2) where possible. # Implementation Hints 1. Consider using a Min-Heap to iteratively extract the Nth smallest element. 2. Alternatively, using binary search in combination with the matrix\'s sorted properties may yield efficient solutions.","solution":"import heapq from typing import List def find_nth_smallest(matrix: List[List[int]], n: int) -> int: Finds the Nth smallest element in a sorted matrix. m = len(matrix) # Min-heap to store elements along with their coordinates in the matrix min_heap = [(matrix[r][0], r, 0) for r in range(m)] heapq.heapify(min_heap) # Extract the nth smallest element from the heap count = 0 while count < n: element, r, c = heapq.heappop(min_heap) count += 1 if c + 1 < m: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return element"},{"question":"# Coding Assessment Question **Objective:** Write a function to determine if a number is a highly composite number. Highly composite numbers are defined as a positive integer that has more divisors than any smaller positive integer. **Function Signature:** ```python def is_highly_composite_number(n: int) -> bool: pass ``` **Input/Output Format:** - Input: A single integer `n` which is to be tested whether it\'s a highly composite number. - Output: Return `True` if `n` is a highly composite number, otherwise `False`. **Constraints:** - `n` should be a positive integer in the range [1, 10^6]. **Example:** ```python assert is_highly_composite_number(1) == True assert is_highly_composite_number(2) == True assert is_highly_composite_number(3) == False assert is_highly_composite_number(12) == True assert is_highly_composite_number(16) == False ``` **Performance Requirements:** - Solution must handle large inputs efficiently using appropriate optimizations. **Scenario:** You are implementing a mathematical library that will be used in a variety of analytical applications. One of the features required is the identification of highly composite numbers, which are useful in statistical analysis and various branches of number theory. An efficient and correct implementation is critical for performance in large-scale data processing contexts.","solution":"import math def count_divisors(n): count = 0 for i in range(1, int(math.sqrt(n)) + 1): if n % i == 0: count += 1 if i != n // i: count += 1 return count def is_highly_composite_number(n): max_divisors = 0 for i in range(1, n): current_divisors = count_divisors(i) if current_divisors > max_divisors: max_divisors = current_divisors n_divisors = count_divisors(n) return n_divisors > max_divisors"},{"question":"# Problem Statement You are asked to create a function that performs a left rotation on an array. This is a common algorithmic task used to test proficiency in array manipulation and understanding of algorithmic time complexities. # Array Left Rotation # Objective: Implement a function `left_rotate_array(arr: list, k: int) -> list` that performs a left rotation on a given list `arr`. The number of positions to rotate the array is specified by the integer `k`. A left rotation operation shifts each element of the array one unit to the left. The first element of the array becomes the last after a left rotation. # Requirements: 1. **Input**: * A list `arr` with size `n (0 <= n <= 10^5)` elements. * An integer `k (0 <= k <= 10^5)` representing the number of positions to rotate the list. 2. **Output**: * A new list that represents the left-rotated version of `arr`. 3. **Constraints**: * The implementation must run in O(n) time complexity. * Ensure that the function handles all edge cases correctly. 4. **Edge cases**: * Handle cases where `k` is greater than the length of the list by using modulus operation (i.e., `k % n`). * Handle empty lists and single-element lists. # Function Signature: ```python def left_rotate_array(arr: list, k: int) -> list: pass ``` # Example: ```python # Example 1: arr = [1, 2, 3, 4, 5] k = 2 # Output: [3, 4, 5, 1, 2] # Example 2: arr = [1, 2, 3, 4, 5] k = 7 # Output: [3, 4, 5, 1, 2] # Example 3: arr = [] k = 3 # Output: [] # Example 4: arr = [42] k = 1 # Output: [42] ``` # Notes: 1. If `k` is 0, the array remains unchanged. 2. For an array `arr` with size `n`, rotating `k` times is equivalent to rotating `k % n` times. 3. The function should work efficiently for arrays up to the maximum constraint size. This problem tests the ability to manipulate arrays and understand rotational operations, ensuring efficiency and correctness for both small and large input sizes.","solution":"def left_rotate_array(arr: list, k: int) -> list: Returns the list `arr` after performing `k` left rotations. n = len(arr) if n == 0 or k == 0: return arr # Normalize k to be within the bounds of 0 and n-1 k = k % n return arr[k:] + arr[:k]"},{"question":"# Matrix Column Sum Calculator You are tasked with developing a function that computes the sum of elements in each column of a matrix. The function should take a matrix represented as a list of lists and return a list containing the sums of each column. The function should: 1. Receive a matrix in the form of a list of `N` lists, where each list is of length `M`. Each element of this matrix is an integer. 2. Calculate the sum of elements for each of the `M` columns. 3. Return a list of `M` integers, where each integer is the sum of the corresponding column. **Function Signature**: ```python from typing import List def column_sums(matrix: List[List[int]]) -> List[int]: pass ``` # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] output = column_sums(matrix) print(output) # Output should be: [12, 15, 18] ``` # Constraints: 1. The number of rows `N` in the matrix will be between 1 and 1000. 2. The number of columns `M` in the matrix will be between 1 and 1000. 3. Each element of the matrix is an integer between -1000 and 1000. # Performance: Ensure that your implementation is efficient, ideally O(N * M) where N is the number of rows and M is the number of columns in the matrix.","solution":"from typing import List def column_sums(matrix: List[List[int]]) -> List[int]: Computes the sum of elements in each column of a matrix. Args: matrix (List[List[int]]): A list of lists where each inner list represents a row of the matrix. Returns: List[int]: A list where each element is the sum of the corresponding column in the matrix. if not matrix or not matrix[0]: return [] num_rows = len(matrix) num_cols = len(matrix[0]) sums = [0] * num_cols for row in matrix: for col in range(num_cols): sums[col] += row[col] return sums"},{"question":"# Coding Assessment Question Context: In certain domains, such as cryptography and data compression, sequences of integers are often encoded using a run-length encoding scheme. This algorithm replaces consecutive identical values with a single value and a count of its occurrences. For example, the sequence `[4, 4, 4, 2, 2, 3]` would become `[(4, 3), (2, 2), (3, 1)]`. Problem: Write a function that takes a list of integers and returns its run-length encoded version. The output should be a list of tuples, where each tuple contains an integer and its count of consecutive appearances in the input list. Function Signature: ```python def run_length_encode(sequence: list[int]) -> list[tuple[int, int]]: ``` Input: - `sequence`: a list of integers to be encoded. Output: - Returns a list of tuples, where each tuple contains an integer and its count of consecutive appearances in the input list. Requirements: 1. The function must handle edge cases such as an empty list gracefully. 2. The function must check that the input list elements are all integers. 3. Optimize for performance and handle large input sizes efficiently. Constraints: - The input list can be empty, which should return an empty list. - The input list can only contain integers. Example: ```python >>> run_length_encode([4, 4, 4, 2, 2, 3]) [(4, 3), (2, 2), (3, 1)] >>> run_length_encode([1, 1, 1, 1, 1]) [(1, 5)] >>> run_length_encode([1, 2, 3, 4, 5]) [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)] >>> run_length_encode([]) [] ``` Note: Implement necessary checks for the input list to ensure it contains only integers and handle invalid inputs appropriately.","solution":"def run_length_encode(sequence: list[int]) -> list[tuple[int, int]]: Returns the run-length encoded version of the input list. Parameters: sequence (list of int): The list of integers to be encoded. Returns: list of tuples: A list of tuples where each tuple contains an integer and its count of consecutive appearances. if not all(isinstance(item, int) for item in sequence): raise ValueError(\\"All elements in the input list must be integers\\") if not sequence: return [] encoded = [] current_value = sequence[0] count = 1 for i in range(1, len(sequence)): if sequence[i] == current_value: count += 1 else: encoded.append((current_value, count)) current_value = sequence[i] count = 1 encoded.append((current_value, count)) return encoded"},{"question":"# Objective You are required to implement an efficient function to evaluate and simplify a given mathematical expression containing only non-negative integers and the operators +, -, *, and /. This task will test your understanding of string manipulation, operator precedence, and algorithm efficiency. # Problem Statement Write a Python function `evaluate_expression(expression: str) -> int` that takes a single string `expression` containing a valid mathematical expression and returns the evaluated result as an integer. # Input and Output: * **Input**: A string `expression`, containing non-negative integers and the four basic arithmetic operators (+, -, *, /). * **Output**: The evaluated result of the expression as an integer. # Constraints: 1. The expression will only contain non-negative integers separated by the operators +, -, *, /. There will be no parentheses. 2. Each integer in the expression is guaranteed to be a non-negative integer (0 ≤ each integer ≤ 1000). 3. The expression will always be a valid mathematical expression in valid infix notation. 4. Division should truncate towards zero. # Function Signature: ```python def evaluate_expression(expression: str) -> int: ``` # Example Input and Output * Input: `expression = \\"3+2*2\\"` * Output: `7` * Input: `expression = \\" 3/2 \\"` * Output: `1` * Input: `expression = \\"3+5/2\\"` * Output: `5` # Constraints and Considerations: 1. **Edge Cases**: * Handle situations where there are multiple spaces between the operators and numbers. * Evaluate expressions with sequences of different operators accurately by respecting operator precedence. 2. **Performance**: * Efficiently parse and evaluate the string. * Minimize parsing complexity to handle large and complex expressions. # Approach: 1. Parse the string to handle spaces and convert the initial expression into a list of tokens (numbers and operators). 2. Use a stack to handle operator precedence and perform the operations in the correct order. 3. Maintain intermediary results in a stack and combine results efficiently to return the final evaluated result. Note: Since only infix notation is used and no parentheses are present, a single pass parsing with a stack-based approach should suffice for handling operator precedence correctly.","solution":"def evaluate_expression(expression: str) -> int: num = 0 stack = [] sign = \'+\' n = len(expression) for i in range(n): char = expression[i] if char.isdigit(): num = num * 10 + int(char) if char in \'+-*/\' or i == n - 1: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': stack.append(int(float(stack.pop()) / num)) # use int() to truncate towards zero sign = char num = 0 return sum(stack)"},{"question":"# Coding Assessment Question Context You are tasked with developing a solution to simulate the management of an online inventory where stock quantities are constantly updated. To efficiently track and query the inventory, you decide to implement a segment tree data structure. Task Write a class `InventoryManager` that models an inventory management system using a segment tree. This class should support the following operations: 1. **Initialization**: Initialize the inventory with a list of stock quantities. 2. **Update Stock**: Update the stock quantity at a specific index. 3. **Query Stock**: Query the total stock quantity within a specific range. Methods 1. `__init__(self, quantities: list[int]) -> None`: Initializes the `InventoryManager` with initial stock quantities. 2. `update_stock(self, index: int, quantity: int) -> None`: Updates the stock quantity at index `index` to `quantity`. 3. `query_stock(self, left: int, right: int) -> int`: Queries the total stock quantity in the inclusive range from `left` to `right`. Constraints - The initial list `quantities` will contain between (1) and (10^5) integers. - Indices for updating and querying are zero-based. - The integers in `quantities` will range from (0) to (10^9). - `left` and `right` will be valid indices within the list bounds. Class Signature ```python class InventoryManager: def __init__(self, quantities: list[int]) -> None: pass def update_stock(self, index: int, quantity: int) -> None: pass def query_stock(self, left: int, right: int) -> int: pass ``` Expected Input and Output ```python # Initialize inventory manager with quantities [5, 3, 10, 4, 7] inv_manager = InventoryManager([5, 3, 10, 4, 7]) # Query total stock from index 1 to 3 print(inv_manager.query_stock(1, 3)) # Output: 17 (3 + 10 + 4) # Update the stock quantity at index 2 to 8 inv_manager.update_stock(2, 8) # Query total stock from index 0 to 4 print(inv_manager.query_stock(0, 4)) # Output: 27 (5 + 3 + 8 + 4 + 7) # Query total stock from index 2 to 4 print(inv_manager.query_stock(2, 4)) # Output: 19 (8 + 4 + 7) ``` Performance Requirements - Initialization should be efficient and suitable for large input sizes. - Update and query operations should be executed in O(log n) time complexity. - Ensure to handle boundary conditions and edge cases effectively.","solution":"class InventoryManager: def __init__(self, quantities: list[int]) -> None: self.n = len(quantities) self.tree = [0] * (2 * self.n) self.build(quantities) def build(self, quantities): # Build the segment tree for i in range(self.n): self.tree[self.n + i] = quantities[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update_stock(self, index: int, quantity: int) -> None: pos = self.n + index self.tree[pos] = quantity while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query_stock(self, left: int, right: int) -> int: result = 0 left += self.n right += self.n + 1 while left < right: if left % 2 == 1: result += self.tree[left] left += 1 if right % 2 == 1: right -= 1 result += self.tree[right] left //= 2 right //= 2 return result"},{"question":"# Coding Assessment Question Context You are developing a software system that needs to manage and manipulate a library of unique books. Each book is identified by its title, author, and published year. The system must provide efficient insertion, deletion, search operations, and list all books sorted by title. Problem Statement **Task**: Implement a `BookLibrary` class in Python that manages a collection of books. Each book is represented by a dictionary with the keys `title`, `author`, and `year`. The class should support adding a book, removing a book by title, searching for a book by title, and listing all books sorted by title. * **Class Specifications**: - **Class**: `BookLibrary` - **Method 1**: `add_book` - **Input**: A dictionary with keys `title` (str), `author` (str), and `year` (int). - **Output**: None. - **Functionality**: Adds the book to the library if a book with the same title does not already exist. If it does, the method should raise a `ValueError`. - **Method 2**: `remove_book` - **Input**: A string representing the title of the book to be removed. - **Output**: None. - **Functionality**: Removes the book from the library. If the book does not exist, the method should raise a `ValueError`. - **Method 3**: `search_book` - **Input**: A string representing the title of the book to be searched. - **Output**: A dictionary with keys `title`, `author`, and `year` if the book is found, otherwise `None`. - **Method 4**: `list_books` - **Input**: None. - **Output**: A list of dictionaries, each representing a book, sorted by title in ascending order. * **Constraints**: - All book titles in the library must be unique. - Book titles, author names, and publication years should be valid strings or integers as described. - Methods should handle error cases gracefully, raising appropriate exceptions when necessary. * **Performance Requirements**: - Efficient insertion and deletion operations (ideally O(1) for insertion if no conflicts, and O(1) for deletion using a dictionary). - Searching for a book should be O(1) on average. - Listing books sorted by title should be O(n log n) due to the sorting operation. Example Usage ```python class BookLibrary: def __init__(self): self.books = {} def add_book(self, book: dict): >>> library = BookLibrary() >>> library.add_book({\'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\', \'year\': 1951}) >>> library.add_book({\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960}) >>> library.add_book({\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}) >>> library.add_book({\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}) Traceback (most recent call last): ... ValueError: Book with title \'1984\' already exists. if book[\'title\'] in self.books: raise ValueError(f\\"Book with title \'{book[\'title\']}\' already exists.\\") self.books[book[\'title\']] = book def remove_book(self, title: str): >>> library = BookLibrary() >>> library.add_book({\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}) >>> library.remove_book(\'1984\') >>> library.remove_book(\'1984\') Traceback (most recent call last): ... ValueError: Book with title \'1984\' does not exist. if title not in self.books: raise ValueError(f\\"Book with title \'{title}\' does not exist.\\") del self.books[title] def search_book(self, title: str) -> dict: >>> library = BookLibrary() >>> library.add_book({\'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\', \'year\': 1951}) >>> library.search_book(\'The Catcher in the Rye\') {\'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\', \'year\': 1951} >>> library.search_book(\'Moby Dick\') None return self.books.get(title) def list_books(self) -> list: >>> library = BookLibrary() >>> library.add_book({\'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\', \'year\': 1951}) >>> library.add_book({\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960}) >>> library.add_book({\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}) >>> library.list_books() [{\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}, {\'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\', \'year\': 1951}, {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960}] return sorted(self.books.values(), key=lambda x: x[\'title\']) # Your program should be able to execute the following upon running the script. if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed.","solution":"class BookLibrary: def __init__(self): self.books = {} def add_book(self, book: dict): Adds the book to the library if it does not already exist. if book[\'title\'] in self.books: raise ValueError(f\\"Book with title \'{book[\'title\']}\' already exists.\\") self.books[book[\'title\']] = book def remove_book(self, title: str): Removes the book from the library. if title not in self.books: raise ValueError(f\\"Book with title \'{title}\' does not exist.\\") del self.books[title] def search_book(self, title: str) -> dict: Searches and returns the book with the given title from the library. return self.books.get(title) def list_books(self) -> list: Lists all books sorted by title. return sorted(self.books.values(), key=lambda x: x[\'title\'])"},{"question":"Distributed Task Scheduling **Objective**: Implement a distributed task scheduling system in which a central server distributes computational tasks among multiple worker nodes based on their availability and load. # Problem Statement You are given a framework of a distributed computing system where a central server assigns tasks to multiple worker nodes. Each worker node can handle tasks independently and notify the central server upon completion. Your task is to create the task assignment and load balancing logic to ensure efficient distribution of tasks. # Expected Input and Output * **Input**: - Configuration of the worker nodes including their IDs and initial load (number of tasks in queue). - A stream of incoming tasks where each task has a unique ID and a time-to-completion estimate. * **Output**: - For each incoming task, determine which worker node it should be assigned to. - The updated load of each worker node after each task assignment. # Constraints 1. (1 leq text{number of worker nodes} leq 100) 2. Worker IDs are unique integers. 3. Load values and task time-to-completion are positive integers. 4. Task stream may involve a very high number of tasks, requiring efficient real-time processing. # Function Definitions Implement the following classes and methods: ```python class WorkerNode: def __init__(self, node_id: int, initial_load: int): self.node_id = node_id self.load = initial_load def add_task(self, time_to_completion: int) -> None: Add a task to the worker node. Adjust the load accordingly. pass class CentralServer: def __init__(self, workers: List[WorkerNode]): self.workers = workers def assign_task(self, task_id: int, time_to_completion: int) -> int: Assign a task to the least loaded worker node and return the assigned worker\'s ID. pass ``` # Implementation Details * **WorkerNode Class**: - `add_task`: This method will update the load of the worker node by adding the task\'s time-to-completion. * **CentralServer Class**: - `assign_task`: This method will iterate over the worker nodes, find the least loaded worker node, assign the task to it, and return the assigned worker\'s ID. # Example Scenario Consider a scenario with three worker nodes and a stream of tasks: 1. Worker Nodes: - Worker 1: ID = 1, Initial Load = 2 - Worker 2: ID = 2, Initial Load = 1 - Worker 3: ID = 3, Initial Load = 3 2. Incoming Task Stream: - Task 1: Time-to-Completion = 5 - Task 2: Time-to-Completion = 2 - Task 3: Time-to-Completion = 3 3. After assigning the tasks: - Task 1 goes to Worker 2 (least loaded initially). - Task 2 goes to Worker 1 (now least loaded after Task 1 is assigned). - Task 3 goes to Worker 1 (still least loaded after Task 2 is assigned). The final assignment would result in the updated loads and task distribution across worker nodes as follows: - Worker 1: Load = 7 - Worker 2: Load = 6 - Worker 3: Load = 3","solution":"from typing import List class WorkerNode: def __init__(self, node_id: int, initial_load: int): self.node_id = node_id self.load = initial_load def add_task(self, time_to_completion: int) -> None: Add a task to the worker node. Adjust the load accordingly. self.load += time_to_completion class CentralServer: def __init__(self, workers: List[WorkerNode]): self.workers = workers def assign_task(self, task_id: int, time_to_completion: int) -> int: Assign a task to the least loaded worker node and return the assigned worker\'s ID. # Find the least loaded worker least_loaded_worker = min(self.workers, key=lambda worker: worker.load) # Assign the task to the least loaded worker least_loaded_worker.add_task(time_to_completion) # Return the assigned worker\'s ID return least_loaded_worker.node_id"},{"question":"# Coding Question Objective Write a function `sort_words_by_length` that sorts a list of strings based on the length of each string. If two words have the same length, they should maintain their relative order from the input (i.e., the sort should be stable). Function Signature ```python def sort_words_by_length(words: List[str]) -> List[str]: pass ``` Input * `words`: A list of strings. Output * A list of strings sorted by length. Constraints * The function should handle an empty list by returning an empty list. * The function should not alter the original list. * Consider using a stable sorting algorithm to maintain the order of words with the same length. Examples ```python >>> sort_words_by_length([\\"apple\\", \\"fig\\", \\"banana\\", \\"date\\"]) [\'fig\', \'date\', \'apple\', \'banana\'] >>> sort_words_by_length([\\"abc\\", \\"de\\", \\"f\\", \\"gh\\", \\"ijk\\"]) [\'f\', \'de\', \'gh\', \'abc\', \'ijk\'] >>> sort_words_by_length([]) [] >>> sort_words_by_length([\\"same\\", \\"length\\", \\"words\\"]) [\'same\', \'words\', \'length\'] ``` Additional Requirements * The function should handle both lowercase and uppercase strings without differentiation. * The function should be efficient and maintain a time complexity of O(n log n), given that n is the number of strings in the list. * Ensure the resulting order of words with the same length is preserved as in the input list.","solution":"from typing import List def sort_words_by_length(words: List[str]) -> List[str]: return sorted(words, key=len)"},{"question":"# Merge Sorted Arrays Context: You are working for a company that manages a huge database of recorded events. These events are stored in multiple servers, and each server stores its events in a sorted array. Occasionally, you need to compile a global timeline of events which requires merging these sorted arrays into a single sorted array. Task: Write a function **`merge_sorted_arrays(arrays: List[List[int]]) -> List[int]`** that merges multiple sorted arrays into one single sorted array. The function receives a list of sorted arrays and returns a single sorted array containing all elements. Input: * A list of `k` sorted arrays `arrays`, where 1 <= k <= 100 and each array\'s length is between 1 and 10,000. Output: * A list containing all elements from the input arrays in sorted order. Example: ```python # Example to illustrate arrays = [ [1, 4, 5], [1, 3, 4], [2, 6] ] assert merge_sorted_arrays(arrays) == [1, 1, 2, 3, 4, 4, 5, 6] ``` Performance Considerations: Your implementation should be efficient in merging sorted arrays, particularly focusing on minimizing time complexity. A good approach to consider would be using a heap (priority queue) to manage the merging process.","solution":"from heapq import heappush, heappop from typing import List def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merges multiple sorted arrays into a single sorted array. Args: arrays (List[List[int]]): A list of sorted arrays. Returns: List[int]: A merged sorted array. min_heap = [] result = [] # Insert the first element along with the array index and element index into the heap for i, array in enumerate(arrays): if len(array) > 0: heappush(min_heap, (array[0], i, 0)) # Extract the smallest element from the heap and add the next element from the same array while min_heap: val, list_index, element_index = heappop(min_heap) result.append(val) if element_index + 1 < len(arrays[list_index]): heappush(min_heap, (arrays[list_index][element_index + 1], list_index, element_index + 1)) return result"},{"question":"Here is a description of a coding task to evaluate the students\' understanding of dynamic programming and optimization techniques. # Scenario You are asked to solve the coin change problem using dynamic programming, where you need to find the fewest number of coins that you need to make up a given amount. # Problem Statement Given an integer array `coins` representing different denominations of coins and an integer `amount` representing the total amount of money, return the minimum number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`. You must solve the problem using dynamic programming to ensure efficient computation. # Function Signature Implement the following function in Python: ```python def coin_change(coins: List[int], amount: int) -> int: pass ``` # Constraints * `1 <= coins.length <= 12` * `1 <= coins[i] <= 2^31 - 1` * `0 <= amount <= 10^4` # Input * A list of integers `coins` representing coin denominations. * An integer `amount` representing the total amount of money to be made up. # Output * An integer representing the minimum number of coins needed to make up the given amount, or `-1` if it is not possible. # Example ```python assert coin_change([1, 2, 5], 11) == 3 # Explanation: 11 = 5 + 5 + 1 assert coin_change([2], 3) == -1 # Explanation: We cannot make the amount 3 with just a coin of 2. assert coin_change([1], 0) == 0 # Explanation: The amount is already made up, so 0 coins are needed. ``` In these cases, the function should correctly compute the minimum number of coins required to make the given amount or determine if it\'s not possible to do so using the provided denominations.","solution":"from typing import List def coin_change(coins: List[int], amount: int) -> int: # Initialize a list to store the minimum coins needed for each amount up to the desired amount. dp = [float(\'inf\')] * (amount + 1) # Base case: To create amount 0, we need 0 coins. dp[0] = 0 # Iterate over each coin for coin in coins: for a in range(coin, amount + 1): # If the current amount can be achieved by using the current coin, # update the dp table with the minimum of the current value and the new calculated value. dp[a] = min(dp[a], dp[a - coin] + 1) # If we have found a solution, it will be stored in dp[amount], # if not, it will still be infinity. return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"# Binary Tree Paths Scenario You are working on a data visualization tool that displays all possible paths from the root node to the leaf nodes in a binary tree. Each path is represented as a string of node values separated by arrows (`->`). Task Implement the `binary_tree_paths` function to find all paths from the root node to the leaf nodes in a binary tree. Input and Output Formats ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def binary_tree_paths(root: TreeNode) -> List[str]: pass ``` * The `root` parameter is the root node of a binary tree. * Return a list of strings where each string represents a path from the root to a leaf. Details * Each path should be in the form: - For example, a path from root `1` through nodes `2` and `5` should be represented as `\\"1->2->5\\"`. * A leaf node is a node with no children. Constraints * The number of nodes in the binary tree is in the range `[1, 5000]`. * Each node\'s value is a unique integer within the range `[-1000, 1000]`. Example ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) >>> binary_tree_paths(root) [\'1->2->5\', \'1->3\'] ``` Notes * You may use either depth-first search (DFS) or breadth-first search (BFS) to solve this problem. * Ensure to handle edge cases such as null root or trees with only one node.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def binary_tree_paths(root: TreeNode) -> list: Returns all root to leaf paths in a binary tree. :param root: TreeNode, the root of the binary tree :return: list of strings, where each string represents a path from the root to a leaf def dfs(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # if leaf node, store the path paths.append(path) else: path += \\"->\\" dfs(node.left, path, paths) dfs(node.right, path, paths) result = [] dfs(root, \\"\\", result) return result"},{"question":"# Coding Assessment Question Scenario You are working on a city transport simulation that models the flow of traffic through a series of intersections. To streamline the simulation, you need to manage and optimize the sequence of traffic signals at each intersection. Task 1. **Class Definition**: Implement a class `TrafficSignal` that models the state of traffic signals and provides methods for managing the sequence of lights. 2. **Detailed Steps**: - Define the class `TrafficSignal` with the following attributes and methods: - `__init__(self, states: List[str], initial_state: str)`: Initializes the signal with a list of possible states (e.g., `[\\"Red\\", \\"Green\\", \\"Yellow\\"]`) and sets the initial state. - `current_state(self) -> str`: Returns the current state of the traffic signal. - `next_state(self)`: Advances the signal to the next state in the sequence. - `reset(self)`: Resets the signal to the initial state. 3. **Requirements**: - The class should maintain the sequence of states and wrap around to the beginning once the end is reached. - The `next_state` method should cyclically move through the states. 4. **Example**: ```python >>> signal = TrafficSignal([\\"Red\\", \\"Green\\", \\"Yellow\\"], \\"Red\\") >>> print(signal.current_state()) Red >>> signal.next_state() >>> print(signal.current_state()) Green >>> signal.next_state() >>> print(signal.current_state()) Yellow >>> signal.next_state() >>> print(signal.current_state()) Red >>> signal.reset() >>> print(signal.current_state()) Red ``` Constraints * **Input**: - The list `states` will have at least two states. - `initial_state` will always be one of the elements in the list `states`. * **Expected Output**: - Correctly modeled traffic signals transitioning through states as described. Performance Requirements * The methods should return results in constant time O(1). * The space complexity should be O(1), excluding the storage of state names.","solution":"from typing import List class TrafficSignal: def __init__(self, states: List[str], initial_state: str): self.states = states self.current_index = self.states.index(initial_state) self.initial_state = initial_state def current_state(self) -> str: return self.states[self.current_index] def next_state(self): self.current_index = (self.current_index + 1) % len(self.states) def reset(self): self.current_index = self.states.index(self.initial_state)"},{"question":"# Question: Write a function that evaluates the classical Travelling Salesman Problem (TSP) using a heuristic approach. Your task is to implement the nearest neighbor algorithm to approximate the shortest possible route that visits each city exactly once and returns to the origin city. # Requirements: 1. **Function Signature**: ```python def tsp_nearest_neighbor(distance_matrix: List[List[int]]) -> Tuple[List[int], int]: ``` 2. **Input**: - `distance_matrix` (List[List[int]]): A two-dimensional list representing the distances between cities. `distance_matrix[i][j]` gives the distance from city `i` to city `j`. It is guaranteed that `distance_matrix` is a non-empty square matrix with non-negative integers. 3. **Output**: - Return a tuple where: - The first element is a list of integers representing the order of cities visited in the path starting from city `0`. - The second element is an integer representing the total distance of the path. # Constraints: - The distance matrix will have at least 2 cities (2x2 matrix) and at most 10 cities (10x10 matrix). # Example: ```python >>> distance_matrix = [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ] >>> tsp_nearest_neighbor(distance_matrix) ([0, 1, 3, 2, 0], 80) ``` # Explanation: In the example provided, the function finds the route `[0, 1, 3, 2, 0]` starting from city `0` that visits each city exactly once and returns to the starting city. The total distance for this route is `80`. # Scenario: You are a logistics planner tasked with estimating an efficient route for a delivery truck that needs to visit each customer exactly once before returning to the depot. Using the nearest neighbor heuristic, you aim to provide a quick solution that approximates the shortest possible path to minimize travel distance and optimize delivery schedules.","solution":"from typing import List, Tuple def tsp_nearest_neighbor(distance_matrix: List[List[int]]) -> Tuple[List[int], int]: n = len(distance_matrix) unvisited = set(range(n)) current_city = 0 path = [current_city] total_distance = 0 unvisited.remove(current_city) while unvisited: next_city = min(unvisited, key=lambda city: distance_matrix[current_city][city]) total_distance += distance_matrix[current_city][next_city] current_city = next_city path.append(next_city) unvisited.remove(next_city) total_distance += distance_matrix[current_city][path[0]] path.append(path[0]) return path, total_distance"},{"question":"# Reverse Words in a String You are required to implement a function that takes a string and returns a new string where each word in the original string is reversed. Words are considered as sequences of non-space characters, separated by spaces. Function Signature ```python def reverse_words(input_string: str) -> str: Reverses each word in the input string while maintaining the word order. Args: input_string (str): The string whose words are to be reversed. Returns: str: A new string with each word reversed, maintaining the original word order. ``` Example ```python >>> print(reverse_words(\\"hello world\\")) \\"olleh dlrow\\" >>> print(reverse_words(\\"Python is fun\\")) \\"nohtyP si nuf\\" ``` # Requirements 1. **Word Detection**: - Words are substrings of the input string separated by spaces. - Ensure to detect words irrespective of multiple spaces. 2. **Output Format**: - The output should be a string where each word in the input string is reversed, maintaining the order of words. - Preserve all original whitespaces between words. 3. **Constraints**: - The function should handle empty strings smoothly, returning an empty string. - Leading, trailing, and multiple consecutive spaces should be preserved in the output. # Objective This question tests the student\'s understanding of: - String manipulation and slicing. - Handling leading, trailing, and consecutive spaces. - Maintaining the original sequence and structure of words and spaces in the input string while applying transformations to individual words.","solution":"def reverse_words(input_string: str) -> str: Reverses each word in the input string while maintaining the word order. Args: input_string (str): The string whose words are to be reversed. Returns: str: A new string with each word reversed, maintaining the original word order. # Split the string into words based on spaces words = input_string.split(\' \') # Reverse each word and join them back with spaces reversed_words = [word[::-1] for word in words] # Join the reversed words with a space character to retain original spaces return \' \'.join(reversed_words)"},{"question":"# Problem Statement Create a function to determine the maximum depth of a valid, balanced parenthesis string. A balanced parenthesis string is defined as a string of \'(\' and \')\' characters that is completely balanced, such that every opening parenthesis \'(\' has a corresponding closing parenthesis \')\' and the string is properly nested. # Function Signature ```python def max_parenthesis_depth(s: str) -> int: pass ``` # Input * `s` (string): A balanced parenthesis string composed of characters \'(\', \')\'. (1 ≤ len(s) ≤ 10^4) # Output * An integer representing the maximum depth of nested parentheses in the input string. # Example ```python >>> max_parenthesis_depth(\\"((()))\\") 3 >>> max_parenthesis_depth(\\"()\\") 1 >>> max_parenthesis_depth(\\"(())()\\") 2 >>> max_parenthesis_depth(\\"()()()\\") 1 ``` # Constraints * The function should handle edge cases such as the minimum length string `()`. * The function should operate efficiently given the constraint of the maximum length for the input string `s`. * Proper error handling should be incorporated for invalid inputs, such as ensuring the input is a balanced parenthesis string. # Explanation For the input `((()))`, the maximum depth is 3 because there are three nested layers of parentheses. For `()`, the depth is 1, indicating a single pair of parenthesis. The function should correctly compute the depth by counting the layers of nested parentheses.","solution":"def max_parenthesis_depth(s: str) -> int: Determine the maximum depth of a valid, balanced parenthesis string. :param s: A balanced parenthesis string composed of characters \'(\' and \')\'. :return: An integer representing the maximum depth of nested parentheses. max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"# Question: Integer to Roman Numerals Scenario: Converting between different numeral systems is a common problem in computer science and programming. One interesting variation of this problem is converting integers to their Roman numeral representations. Roman numerals are a numeral system originating from ancient Rome, and they use combinations of letters from the Latin alphabet. Task: Write a function `int_to_roman(num: int) -> str` that converts a given integer to its Roman numeral representation. Implement a helper function `verify_conversion(num: int) -> str` to show the integer and its corresponding Roman numeral form. Function Specifications: 1. `int_to_roman(num: int) -> str` - **Input**: A non-negative integer `num` (1 <= num <= 3999). - **Output**: A string representing the Roman numeral form of the given integer. 2. `verify_conversion(num: int) -> str` - **Input**: A non-negative integer `num`. - **Output**: A formatted string showing the integer and its Roman numeral form. Examples: ```python >>> print(verify_conversion(1)) 1: I >>> print(verify_conversion(4)) 4: IV >>> print(verify_conversion(9)) 9: IX >>> print(verify_conversion(58)) 58: LVIII >>> print(verify_conversion(1994)) 1994: MCMXCIV >>> print(verify_conversion(2023)) 2023: MMXXIII >>> print(verify_conversion(3999)) 3999: MMMCMXCIX ``` Guidelines: - Use the following Roman numeral symbols and their corresponding values: | Symbol | Value | |--------|-------| | I | 1 | | V | 5 | | X | 10 | | L | 50 | | C | 100 | | D | 500 | | M | 1000 | - Follow the Roman numeral rules, such as IV for 4, IX for 9, and so forth. Make sure to handle the subtractive combinations. Constraints: - Use logical constructs and operations to map integer values to their Roman numeral representations. Avoid using complex data structures like arrays or dictionaries for this task. Performance Requirements: - The solution must handle the conversion and representation efficiently within the given range.","solution":"def int_to_roman(num: int) -> str: Converts a given integer to its Roman numeral representation. value_to_roman = [ (1000, \\"M\\"), (900, \\"CM\\"), (500, \\"D\\"), (400, \\"CD\\"), (100, \\"C\\"), (90, \\"XC\\"), (50, \\"L\\"), (40, \\"XL\\"), (10, \\"X\\"), (9, \\"IX\\"), (5, \\"V\\"), (4, \\"IV\\"), (1, \\"I\\") ] roman_numeral = \\"\\" for value, roman in value_to_roman: while num >= value: roman_numeral += roman num -= value return roman_numeral def verify_conversion(num: int) -> str: Shows the integer and its corresponding Roman numeral form. return f\\"{num}: {int_to_roman(num)}\\""},{"question":"# Coding Assessment Question You are tasked with developing a module to assist a logistics company in tracking the state of packages across their entire delivery network. One important feature required is monitoring the temperature of perishable goods. You need to implement a function that determines if the temperature recorded at various checkpoints remains within allowed limits throughout the delivery process. Task Write a function `is_temperature_within_limits(temperatures: list, min_temp: float, max_temp: float) -> bool` that checks whether all recorded temperatures at various checkpoints are within specified minimum and maximum limits. Input: - `temperatures` (list of float): A list of recorded temperatures at different checkpoints, given in degrees Celsius. The list will contain at least one temperature record. - `min_temp` (float): The minimum allowable temperature limit for the perishable goods in degrees Celsius. It can be a negative or positive float. - `max_temp` (float): The maximum allowable temperature limit for the perishable goods in degrees Celsius. It will always be greater than `min_temp`. Output: - `within_limits` (bool): A boolean value indicating if all recorded temperatures in the list are within the specified range, inclusive of the limits. Constraints: - The function should return `False` if any recorded temperature is outside the specified limits. - The function should handle temperatures with precision up to two decimal places. Examples: ```python # Example 1: All temperatures within limits temperatures = [5.5, 7.0, 6.8, 6.1] min_temp = 5.0 max_temp = 8.0 assert is_temperature_within_limits(temperatures, min_temp, max_temp) == True # Example 2: Some temperatures outside limits temperatures = [2.9, 4.0, 5.1, 8.5] min_temp = 3.0 max_temp = 8.0 assert is_temperature_within_limits(temperatures, min_temp, max_temp) == False # Example 3: Temperatures exactly on the limits temperatures = [3.0, 3.5, 4.0, 8.0] min_temp = 3.0 max_temp = 8.0 assert is_temperature_within_limits(temperatures, min_temp, max_temp) == True ``` Provide comprehensive test cases for your function, including edge cases where temperatures are exactly on the limits, and scenarios with negative temperatures.","solution":"def is_temperature_within_limits(temperatures, min_temp, max_temp): Checks whether all recorded temperatures at various checkpoints are within the specified minimum and maximum limits (inclusive). Parameters: temperatures (list of float): List of recorded temperatures at different checkpoints. min_temp (float): Minimum allowable temperature limit. max_temp (float): Maximum allowable temperature limit. Returns: bool: True if all temperatures are within the specified limits, False otherwise. for temp in temperatures: if temp < min_temp or temp > max_temp: return False return True"},{"question":"# Problem: Largest Consecutive Subsequence Sum Context: You are tasked with developing a function that identifies the largest sum of any contiguous subsequence within a given list of integers. This is a common problem in algorithm design and is known as the \\"Maximum Subarray Problem.\\" Task: Write a function `max_subsequence_sum(nums: List[int]) -> int` that takes in a list of integers and returns the maximum sum of any contiguous subsequence within the list. Input: - A list of integers `nums` (1 ≤ len(nums) ≤ 10^5, -10^4 ≤ nums[i] ≤ 10^4). Output: - An integer representing the largest sum of any contiguous subsequence in the provided list. Constraints: - The function should be efficient with a target time complexity of O(N), where N is the length of the list. Examples: ```python assert max_subsequence_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 assert max_subsequence_sum([1]) == 1 assert max_subsequence_sum([5,4,-1,7,8]) == 23 assert max_subsequence_sum([-1,-2,-3,-4]) == -1 ``` Performance Requirements: - The solution should implement an efficient algorithm to handle the potential size of the input list. Hints: - Consider using Kadane\'s Algorithm to solve this problem with linear time complexity. - Keep track of the current subsequence sum and update it based on conditions to ensure it captures the maximum possible sum.","solution":"def max_subsequence_sum(nums): Returns the maximum sum of any contiguous subsequence within the list. Uses Kadane\'s Algorithm to achieve the solution in O(N) time complexity. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Question: Non-repeating Characters in a Substring You are given a string `s` and an integer `k`. Write a Python function to find the length of the longest substring with all unique characters that is exactly `k` consecutive characters long. If there is no such substring, return `-1`. Function Signature ```python def longest_unique_substring(s: str, k: int) -> int: ``` # Input * `s` - a string of length `n` (1 <= n <= 10^5), containing only lowercase English letters. * `k` - an integer (1 <= k <= n). # Output * Return an integer representing the length of the longest substring with all unique characters that is exactly `k` characters long. If no such substring exists, return `-1`. # Constraints * The string `s` will always contain only lowercase English letters. * `1 <= k <= n <= 10^5`. # Example Given the string `s = \\"abcabcbb\\"` and `k = 3`, ```python s = \\"abcabcbb\\" k = 3 ``` Your function, when called as `longest_unique_substring(s, k)`, should return `3`, since the substrings \\"abc\\" and \\"cab\\" are both of length 3 and have all unique characters. Given the string `s = \\"aaaaa\\"` and `k = 2`, ```python s = \\"aaaaa\\" k = 2 ``` Your function, when called as `longest_unique_substring(s, k)`, should return `-1`, since there are no substrings of length 2 with all unique characters. # Additional Information: * Use efficient algorithms to ensure the solution is performant for large input sizes. * Handle edge cases where `k` is greater than the string length or the string has all identical characters. * Optimize your code to minimize the number of checks and computations per candidate substring. # Implementation Guidelines: - Utilize sliding window technique or similar efficient method to examine substrings of length `k`. - Carefully manage character counts to determine uniqueness within the current window. - Ensure proper checks to handle edge conditions and return the correct result in all cases.","solution":"def longest_unique_substring(s: str, k: int) -> int: if k > len(s): return -1 max_length = -1 n = len(s) for i in range(n - k + 1): substring = s[i:i+k] if len(set(substring)) == k: max_length = k break return max_length"},{"question":"# Problem Statement You are given an undirected graph represented by an adjacency matrix. Your task is to implement a function `minimum_spanning_tree(graph: np.ndarray) -> np.ndarray` that computes the weight of the Minimum Spanning Tree (MST) of the given graph using Prim\'s algorithm. The function should return the total weight of the MST. # Input * `graph`: A 2D numpy array of shape (n, n). Each element `graph[i][j]` represents the weight of the edge between nodes `i` and `j`. If there is no edge between `i` and `j`, the corresponding value will be `np.inf`. # Output * An integer representing the total weight of the MST. # Constraints 1. You may assume that the input graph is connected. 2. The graph will have at least 2 nodes and a maximum of 100 nodes. 3. The weights of the edges are non-negative integers. # Requirements * Implement Prim\'s algorithm for finding the MST. * Optimize for intermediate-sized graphs. * Handle numerical precision errors adequately. # Example ```python import numpy as np graph = np.array([ [np.inf, 2, np.inf, 6, np.inf], [2, np.inf, 3, 8, 5], [np.inf, 3, np.inf, np.inf, 7], [6, 8, np.inf, np.inf, 9], [np.inf, 5, 7, 9, np.inf] ]) # Example usage total_weight = minimum_spanning_tree(graph) print(total_weight) # Output should be: 16 ```","solution":"import numpy as np def minimum_spanning_tree(graph: np.ndarray) -> int: Computes the weight of the Minimum Spanning Tree (MST) using Prim\'s algorithm. Parameters: graph (np.ndarray): A 2D numpy array representing the adjacency matrix of the graph. Returns: int: The total weight of the MST. n = graph.shape[0] selected_nodes = [False] * n selected_nodes[0] = True edges = [] for i in range(1, n): minimum = np.inf x = y = 0 for j in range(n): if selected_nodes[j]: for k in range(n): if not selected_nodes[k] and graph[j][k]: if minimum > graph[j][k]: minimum = graph[j][k] x, y = j, k edges.append((x, y, graph[x][y])) selected_nodes[y] = True total_weight = sum([weight for x, y, weight in edges]) return total_weight"},{"question":"# Task: You are required to write a function that processes a CSV file containing weather data and calculates the average temperature for a given city. # Function Signature: ```python def average_temperature(city: str, file_path: str) -> float: pass ``` # Description: Your task is to implement a function `average_temperature` that reads a CSV file containing weather data and calculates the average temperature for a specified city. The CSV file will have columns such as `City`, `Date`, and `Temperature`. # Requirements: 1. **Input**: - `city`: A string representing the city name to filter the weather data. - `file_path`: A string representing the path to the CSV file. 2. **Output**: A float representing the average temperature for the given city. If no data is found for the city, return `None`. 3. **Constraints**: - The function should handle file I/O exceptions gracefully. - Ensure that the CSV file follows a consistent format. 4. **Performance**: - Aim for efficient reading and processing of the CSV data, considering large files. # Example: ```python # Assuming the CSV file content is as follows: # City,Date,Temperature # New York,2023-01-01,5.0 # Los Angeles,2023-01-01,15.0 # New York,2023-01-02,6.0 # Los Angeles,2023-01-02,16.0 file_path = \\"weather_data.csv\\" city = \\"New York\\" average_temp = average_temperature(city, file_path) print(f\\"The average temperature in {city} is {average_temp:.2f}\\") ``` # Hints: - Use libraries such as `csv` to read and parse the CSV file. - Filter the data by the specified city and calculate the average of the temperatures. - Handle possible exceptions such as file not found or incorrect file format.","solution":"import csv def average_temperature(city: str, file_path: str) -> float: Reads a CSV file containing weather data and calculates the average temperature for a given city. Args: city (str): The city name to filter the weather data. file_path (str): The path to the CSV file. Returns: float: The average temperature for the given city, or None if no data is found for the city or an error occurs. try: total_temperature = 0.0 count = 0 with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: if row[\'City\'] == city: total_temperature += float(row[\'Temperature\']) count += 1 if count == 0: return None return total_temperature / count except (FileNotFoundError, KeyError, ValueError) as e: print(f\\"An error occurred: {e}\\") return None"},{"question":"# Zigzag Pattern Generator In this problem, you are required to write a function to generate a zigzag pattern for a given string. The pattern should appear as if the string characters are placed in a zigzag fashion on a given number of rows. Function Signature ```python def zigzag_conversion(s: str, num_rows: int) -> str: ``` Parameters - `s` (str): The input string containing only alphanumeric characters and spaces. - `num_rows` (int): The number of rows for the zigzag pattern. Returns - `str`: The resultant string after applying the zigzag pattern on the input string. Constraints - `num_rows` is an integer such that 1 <= num_rows <= len(s) (These constraints ensure valid row counts relative to string length). Example ```python assert zigzag_conversion(\\"PAYPALISHIRING\\", 3) == \\"PAHNAPLSIIGYIR\\" assert zigzag_conversion(\\"ABCD\\", 2) == \\"ACBD\\" assert zigzag_conversion(\\"A\\", 1) == \\"A\\" ``` Edge Cases - Ensure your function handles cases where `num_rows` is 1, which should return the original string. - Handle cases where the input string length is less than or equal to `num_rows` by returning the original string. **Your task** is to implement the `zigzag_conversion` function to convert the input string into the desired zigzag pattern and return the resultant string, ensuring that it efficiently handles all mentioned scenarios.","solution":"def zigzag_conversion(s: str, num_rows: int) -> str: if num_rows == 1 or num_rows >= len(s): return s rows = [\'\'] * min(num_rows, len(s)) cur_row = 0 going_down = False for char in s: rows[cur_row] += char if cur_row == 0 or cur_row == num_rows - 1: going_down = not going_down cur_row += 1 if going_down else -1 return \'\'.join(rows)"},{"question":"**Circular Buffer Implementation** You are required to implement a `CircularBuffer` class, a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure supports efficient addition and removal of elements, ensuring that older entries are overwritten by new ones once the buffer’s capacity is reached. # Class Definition: Your class should be defined as follows: ```python class CircularBuffer: def __init__(self, capacity: int): Initialize the circular buffer with the given capacity. pass def write(self, value: int) -> bool: Write an integer value to the buffer. If the buffer is full, return False; otherwise, return True. pass def read(self) -> int: Read and remove the oldest value from the buffer. If the buffer is empty, raise an IndexError. pass def is_empty(self) -> bool: Return True if the buffer is empty, otherwise return False. pass def is_full(self) -> bool: Return True if the buffer is full, otherwise return False. pass ``` # Operations: 1. **Initialization (`__init__`)**: * Takes an integer `capacity` as an argument and initializes an empty buffer with the specified capacity. 2. **Write (`write`)**: * Takes an integer `value` as an argument and attempts to write it to the buffer. * Returns `True` if the write operation is successful, and `False` if the buffer is full. 3. **Read (`read`)**: * Reads and removes the oldest element from the buffer. * Returns the integer value read from the buffer. * Raises an `IndexError` if the buffer is empty when attempting to read. 4. **Check Empty (`is_empty`)**: * Returns `True` if the buffer is empty, and `False` otherwise. 5. **Check Full (`is_full`)**: * Returns `True` if the buffer is full, and `False` otherwise. # Example Usage: ```python buffer = CircularBuffer(3) print(buffer.is_empty()) # Output: True print(buffer.is_full()) # Output: False print(buffer.write(10)) # Output: True print(buffer.write(20)) # Output: True print(buffer.write(30)) # Output: True print(buffer.write(40)) # Output: False (buffer is full) print(buffer.read()) # Output: 10 print(buffer.read()) # Output: 20 print(buffer.write(40)) # Output: True print(buffer.is_empty()) # Output: False print(buffer.is_full()) # Output: True print(buffer.read()) # Output: 30 print(buffer.read()) # Output: 40 print(buffer.is_empty()) # Output: True ``` # Constraints: * The capacity of the buffer (`capacity`) will be at least `1`. * The values inserted into the buffer will be non-negative integers. # Implementation Details: Implement the `CircularBuffer` class to match the described behavior and ensure efficiency in handling the operations. The class should exhibit proper circular buffering behavior, where overwrites are appropriately managed once the buffer reaches its full capacity. Ensure that your class handles edge cases, such as reads from an empty buffer, gracefully.","solution":"class CircularBuffer: def __init__(self, capacity: int): Initialize the circular buffer with the given capacity. if capacity < 1: raise ValueError(\\"Capacity must be at least 1\\") self.capacity = capacity self.buffer = [None] * capacity self.start = 0 self.end = 0 self.size = 0 def write(self, value: int) -> bool: Write an integer value to the buffer. If the buffer is full, return False; otherwise, return True. if self.is_full(): return False self.buffer[self.end] = value self.end = (self.end + 1) % self.capacity self.size += 1 return True def read(self) -> int: Read and remove the oldest value from the buffer. If the buffer is empty, raise an IndexError. if self.is_empty(): raise IndexError(\\"Read from an empty buffer\\") value = self.buffer[self.start] self.buffer[self.start] = None self.start = (self.start + 1) % self.capacity self.size -= 1 return value def is_empty(self) -> bool: Return True if the buffer is empty, otherwise return False. return self.size == 0 def is_full(self) -> bool: Return True if the buffer is full, otherwise return False. return self.size == self.capacity"},{"question":"**Scenario:** You\'re working on a software project for a logistics company that needs to manage an extensive fleet of vehicles and track their maintenance schedules. The software should efficiently determine the next maintenance date based on the vehicle\'s current mileage and the vehicle type\'s standard maintenance interval. Each vehicle type has a predefined mileage interval after which it should go through maintenance. **Task:** Implement a function `next_maintenance` that calculates the next maintenance date for a vehicle based on its current mileage, the last maintenance date, and the type of vehicle. The function should properly handle vehicle types and their respective maintenance intervals. **Function Signature:** ```python def next_maintenance(current_mileage: int, last_maintenance_date: str, vehicle_type: str) -> str: pass ``` **Input and Output:** - **Input**: - `current_mileage` (int): The current mileage of the vehicle. - `last_maintenance_date` (str): The last maintenance date in the format \\"YYYY-MM-DD\\". - `vehicle_type` (str): The type of the vehicle. Can be one of the following: \\"car\\", \\"truck\\", \\"motorcycle\\". - **Output**: - Returns the next maintenance date as a string in the format \\"YYYY-MM-DD\\". **Constraints/Requirements**: - Assume that the maintenance intervals are as follows: - Car: every 10,000 miles - Truck: every 20,000 miles - Motorcycle: every 5,000 miles - The function should account for cases where the current mileage is less than the last recorded maintenance mileage. - Perform appropriate error handling for invalid vehicle types. - The date calculations should correctly handle leap years. **Example**: ```python print(next_maintenance(15000, \\"2023-01-01\\", \\"car\\")) # Expected output: \\"2023-01-01\\" (since the next maintenance will be at 20000 miles) print(next_maintenance(18000, \\"2023-01-01\\", \\"car\\")) # Expected output: \\"2023-01-01\\" (since the next maintenance will be at 20000 miles) print(next_maintenance(21000, \\"2023-01-01\\", \\"truck\\")) # Expected output: \\"2023-01-01\\" (since the next maintenance will be at 40000 miles) print(next_maintenance(4900, \\"2023-01-01\\", \\"motorcycle\\")) # Expected output: \\"2023-01-01\\" (since the next maintenance will be at 5000 miles) print(next_maintenance(8000, \\"2023-01-01\\", \\"motorcycle\\")) # Expected output: \\"2023-01-01\\" (since the next maintenance will be at 10000 miles) ``` Ensure accurate calculations and proper error handling for invalid inputs.","solution":"from datetime import datetime, timedelta def next_maintenance(current_mileage: int, last_maintenance_date: str, vehicle_type: str) -> str: # Define maintenance intervals for each vehicle type maintenance_intervals = { \\"car\\": 10000, \\"truck\\": 20000, \\"motorcycle\\": 5000 } # Check if the vehicle type is valid if vehicle_type not in maintenance_intervals: raise ValueError(\\"Invalid vehicle type\\") # Calculate the required maintenance mileage last_maintenance_date_obj = datetime.strptime(last_maintenance_date, \\"%Y-%m-%d\\") maintenance_interval = maintenance_intervals[vehicle_type] next_mileage = ((current_mileage // maintenance_interval) + 1) * maintenance_interval return last_maintenance_date"},{"question":"# Student Record Processing You have a file `students.csv`, which contains student records in the following format: ``` id,name,math,science,english 1,John Doe,78,85,90 2,Jane Smith,88,92,81 3,Alice Johnson,90,70,80 ... ``` Each student has an ID, a name, and scores for three subjects: Math, Science, and English. Your task is to write a function `calculate_subject_average` that reads this file, calculates the average score for each subject, and writes the results to a new file `subject_averages.csv` in the following format: ``` subject,average math,85.33 science,82.33 english,83.67 ``` # Function Signature ```python def calculate_subject_average(input_file: str, output_file: str) -> None: pass ``` # Input - `input_file` (string): The path to the CSV file containing student records. - `output_file` (string): The path to the output CSV file where the subject averages will be written. # Output - The function returns nothing. It writes the calculated averages to the `output_file`. # Constraints - Assume the file exists and is accessible. - File contains valid student records in the specified format. # Example Using a sample input file `students.csv`: ``` id,name,math,science,english 1,John Doe,78,85,90 2,Jane Smith,88,92,81 3,Alice Johnson,90,70,80 ``` The resulting `subject_averages.csv` would be: ``` subject,average math,85.33 science,82.33 english,83.67 ``` # Notes Consider handling edge cases such as: - Incomplete records (some students might have missing scores). - Non-numeric values in the scores. # Implementation Implement the function and ensure it meets the requirements and constraints.","solution":"import csv def calculate_subject_average(input_file: str, output_file: str) -> None: Calculates the average scores for each subject from the input CSV file and writes the averages to the output CSV file. Args: input_file (str): The path to the input CSV file containing student records. output_file (str): The path to the output CSV file for the subject averages. Returns: None subject_totals = {\'math\': 0, \'science\': 0, \'english\': 0} subject_counts = {\'math\': 0, \'science\': 0, \'english\': 0} with open(input_file, \'r\') as infile: reader = csv.DictReader(infile) for row in reader: for subject in subject_totals.keys(): if row[subject].isdigit(): # Making sure the value is numeric subject_totals[subject] += int(row[subject]) subject_counts[subject] += 1 subject_averages = {subject: (subject_totals[subject] / subject_counts[subject]) if subject_counts[subject] != 0 else 0 for subject in subject_totals} with open(output_file, \'w\', newline=\'\') as outfile: writer = csv.writer(outfile) writer.writerow([\'subject\', \'average\']) for subject, average in subject_averages.items(): writer.writerow([subject, round(average, 2)])"},{"question":"# Coding Question: Matrix Traversal and Largest Connected Component Problem Statement Consider a 2D Matrix consisting of integers where each cell can either contain a `1` (representing land) or a `0` (representing water). Your task is to write methods to traverse this matrix in a Depth-First Search (DFS) manner and find the largest connected component (i.e., the largest island of `1`s). Requirements 1. **Depth-First Search (DFS) Traversal**: - Implement the `dfs` method which performs a DFS traversal starting from a given cell and marks all connected `1`s as visited. - If the starting cell is not a `1`, return without marking any cells. 2. **Largest Connected Component**: - Implement the `largest_component` method which iterates through the matrix and uses the `dfs` method to find and return the size of the largest connected component of `1`s. Method Signatures - `def dfs(self, matrix: list[list[int]], x: int, y: int, visited: set[tuple[int, int]]) -> int:` - `def largest_component(self, matrix: list[list[int]]) -> int:` Input and Output Formats - **DFS Method**: - **Input**: The matrix, starting cell coordinates (x, y), and a set to keep track of visited cells. - **Output**: An integer representing the size of the connected component starting from the given cell. - **Largest Component Method**: - **Input**: The matrix. - **Output**: An integer representing the size of the largest connected component of `1`s. Constraints - The matrix can have up to `100 x 100` cells. - The matrix values are only `1`s or `0`s. Example Given the following matrix: ```python matrix = [ [1, 1, 0, 1], [0, 1, 1, 0], [1, 0, 0, 1], [0, 1, 1, 1] ] ``` - For `largest_component(matrix)`, the output would be `5`. Implementation ```python class MatrixTraversal: def dfs(self, matrix: list[list[int]], x: int, y: int, visited: set[tuple[int, int]]) -> int: if (x < 0 or x >= len(matrix) or y < 0 or y >= len(matrix[0]) or matrix[x][y] == 0 or (x, y) in visited): return 0 # Mark the cell as visited visited.add((x, y)) # Count the current cell size = 1 # Visit all 4 adjacent cells size += self.dfs(matrix, x + 1, y, visited) size += self.dfs(matrix, x - 1, y, visited) size += self.dfs(matrix, x, y + 1, visited) size += self.dfs(matrix, x, y - 1, visited) return size def largest_component(self, matrix: list[list[int]]) -> int: visited = set() max_size = 0 for x in range(len(matrix)): for y in range(len(matrix[0])): if matrix[x][y] == 1 and (x, y) not in visited: component_size = self.dfs(matrix, x, y, visited) max_size = max(max_size, component_size) return max_size # Example of how to use: matrix = [ [1, 1, 0, 1], [0, 1, 1, 0], [1, 0, 0, 1], [0, 1, 1, 1] ] traversal = MatrixTraversal() print(traversal.largest_component(matrix)) # Output: 5 ```","solution":"class MatrixTraversal: def dfs(self, matrix: list[list[int]], x: int, y: int, visited: set[tuple[int, int]]) -> int: if (x < 0 or x >= len(matrix) or y < 0 or y >= len(matrix[0]) or matrix[x][y] == 0 or (x, y) in visited): return 0 # Mark the cell as visited visited.add((x, y)) # Count the current cell size = 1 # Visit all 4 adjacent cells size += self.dfs(matrix, x + 1, y, visited) size += self.dfs(matrix, x - 1, y, visited) size += self.dfs(matrix, x, y + 1, visited) size += self.dfs(matrix, x, y - 1, visited) return size def largest_component(self, matrix: list[list[int]]) -> int: visited = set() max_size = 0 for x in range(len(matrix)): for y in range(len(matrix[0])): if matrix[x][y] == 1 and (x, y) not in visited: component_size = self.dfs(matrix, x, y, visited) max_size = max(max_size, component_size) return max_size # Example of how to use: matrix = [ [1, 1, 0, 1], [0, 1, 1, 0], [1, 0, 0, 1], [0, 1, 1, 1] ] traversal = MatrixTraversal() print(traversal.largest_component(matrix)) # Output: 5"},{"question":"# Coding Question: Detect and Remove Loop in a Linked List Objective: Implement a function to detect and remove a loop in a given singly linked list. Ensure your solution is efficient in terms of both time and space complexity. Problem Statement: You are provided with a singly linked list, which may contain a loop. Your task is to detect if a loop exists and remove it if found, making the linked list loop-free. Implementation Details: 1. **Function: `remove_loop(head: ListNode) -> None`** - Input: The head node of a singly linked list. - Output: None (Modify the linked list in place). - Method: - Detect if a loop exists using Floyd\'s Cycle-Finding Algorithm (Tortoise and Hare). - If a loop is detected, find the starting node of the loop. - Remove the loop by setting the `next` pointer of the last node in the loop to `None`. Constraints: - You may assume the linked list contains at least one node. - The input list can be assumed to have a `ListNode` structure defined as follows: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next ``` - Ensure the function does not return any value, and the modification is done in place. Example: ```python # Example of function usage: # Creating a looped list manually for the example: node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = node2 # Creates a loop back to node2 # Detect and remove the loop: remove_loop(node1) # Function to print the linked list to verify no loop exists: def print_list(head): current = head while current: print(current.value, end=\\" -> \\") current = current.next print(\\"None\\") print_list(node1) # Expected Output after removing loop: 1 -> 2 -> 3 -> 4 -> 5 -> None ``` Evaluation: Your implementation will be evaluated based on: - Correctness of logic. - Handling and edge case scenarios of looping and non-looping lists. - Efficient detection and removal of the loop. - Adherence to space and time complexity constraints.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_loop(head: ListNode) -> None: if not head or not head.next: return # Step 1: Detect the loop using Floyd\'s Cycle-Finding Algorithm slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # No loop found if slow != fast: return # Step 2: Identify the start of the loop slow = head while slow != fast: slow = slow.next fast = fast.next # Step 3: Find the last node in the loop and remove the loop # This node should point to the start of the loop loop_start = slow while fast.next != loop_start: fast = fast.next # Remove the loop fast.next = None"},{"question":"# Problem Statement Develop a function to simulate a simple task scheduling system that prioritizes the execution of tasks based on their urgency and arrival times. Each task is identified by its name, urgency level, and arrival time. Your function should sort and return the list of tasks in the correct order of execution. # Requirements: 1. **Function to Schedule Tasks**: - Name: `schedule_tasks` - Input: A list of dictionaries, where each dictionary contains: - `name`: A string representing the task\'s name. - `urgency`: An integer where a higher number signifies a more urgent task. - `arrival_time`: A timestamp string in the format `\'YYYY-MM-DD HH:MM:SS\'`. - Output: A list of dictionaries, sorted first by urgency in descending order, and then by arrival time in ascending order if two tasks have the same urgency. - Constraints: - The input list will have at least one task and no more than 1000 tasks. - Raise an appropriate exception if the input format is invalid (e.g., missing required fields or incorrect timestamp format). # Example: ```python import datetime def schedule_tasks(tasks: list[dict[str, str | int]]) -> list[dict[str, str | int]]: try: return sorted( tasks, key=lambda task: (-task[\\"urgency\\"], datetime.datetime.strptime(task[\\"arrival_time\\"], \'%Y-%m-%d %H:%M:%S\')) ) except KeyError as e: raise ValueError(f\\"Missing required field: {e}\\") except ValueError as e: raise ValueError(f\\"Incorrect timestamp format: {e}\\") tasks = [ {\\"name\\": \\"Task A\\", \\"urgency\\": 2, \\"arrival_time\\": \\"2023-10-01 12:00:00\\"}, {\\"name\\": \\"Task B\\", \\"urgency\\": 1, \\"arrival_time\\": \\"2023-10-01 10:00:00\\"}, {\\"name\\": \\"Task C\\", \\"urgency\\": 2, \\"arrival_time\\": \\"2023-10-01 11:00:00\\"}, ] scheduled_tasks = schedule_tasks(tasks) print(scheduled_tasks) # Output: [ # {\'name\': \'Task C\', \'urgency\': 2, \'arrival_time\': \'2023-10-01 11:00:00\'}, # {\'name\': \'Task A\', \'urgency\': 2, \'arrival_time\': \'2023-10-01 12:00:00\'}, # {\'name\': \'Task B\', \'urgency\': 1, \'arrival_time\': \'2023-10-01 10:00:00\'} # ] ``` # Notes: - Ensure to handle edge cases effectively, including invalid inputs and incorrect timestamp formats. - Consider performance optimizations for handling the upper limit of input sizes. - Include comprehensive tests to validate your solution against various scenarios, including different urgencies and arrival times.","solution":"import datetime def schedule_tasks(tasks: list[dict[str, str | int]]) -> list[dict[str, str | int]]: Schedules tasks based on urgency and arrival time. Args: tasks : list of dictionaries containing \'name\', \'urgency\', and \'arrival_time\' keys. Returns: list of dictionaries sorted by urgency and arrival time. Raises: ValueError: If any task is missing required fields or has an incorrect timestamp format. try: sorted_tasks = sorted( tasks, key=lambda task: ( -task[\\"urgency\\"], datetime.datetime.strptime(task[\\"arrival_time\\"], \'%Y-%m-%d %H:%M:%S\') ) ) return sorted_tasks except KeyError as e: raise ValueError(f\\"Missing required field: {e}\\") except ValueError as e: raise ValueError(f\\"Incorrect timestamp format: {e}\\")"},{"question":"# Question: Implement a Text-based Tic-Tac-Toe Game Create a basic text-based Tic-Tac-Toe game where two players can play against each other. Implement a function `play_tic_tac_toe` which initializes a 3x3 board and allows the players to make moves alternately. Each move involves placing either \'X\' or \'O\' on the board. The game should continue until one of the players wins or the board is full, resulting in a draw. Function Signature ```python def play_tic_tac_toe(): ``` Requirements - The game should initialize an empty 3x3 board and allow two players to input their names. - The board should be printed after each move, displaying the current state of the game. - The game should check after each move whether there is a winner or if the game ends in a draw. - If a player wins, the game should announce the winner and terminate. - If the game ends in a draw, it should also announce this and terminate. - The players should take turns placing their markers (\'X\' or \'O\') on the board by specifying the row and column numbers. Constraints 1. Assume players will input valid names. 2. The function should handle invalid moves (such as moves to an already occupied cell) gracefully, informing the player and allowing them to try again. 3. Use a list for the board representation. Example Usage ```python # tic-tac-toe game execution play_tic_tac_toe() # Expected Output (example game): # Enter Player 1\'s name: Alice # Enter Player 2\'s name: Bob # Current board: # 1 | 2 | 3 # 4 | 5 | 6 # 7 | 8 | 9 # Alice\'s move (X): Enter row and column numbers (1-3) separated by space: 1 1 # Current board: # X | 2 | 3 # 4 | 5 | 6 # 7 | 8 | 9 # # ... # Bob wins! ``` # Notes: * Implement helper functions as needed to improve the code\'s readability and maintainability. * Focus on ensuring a smooth user experience, including clear instructions and prompts.","solution":"def initialize_board(): return [[\' \' for _ in range(3)] for _ in range(3)] def print_board(board): for row in board: print(\' | \'.join(row)) print(\'-\' * 5) def check_winner(board, marker): # Check rows, columns, and diagonals for row in board: if all(spot == marker for spot in row): return True for col in range(3): if all(row[col] == marker for row in board): return True if all(board[i][i] == marker for i in range(3)) or all(board[i][2 - i] == marker for i in range(3)): return True return False def is_board_full(board): return all(all(spot != \' \' for spot in row) for row in board) def get_player_move(player_name): while True: try: move = input(f\\"{player_name}\'s move: Enter row and column numbers (1-3) separated by space: \\") row, col = map(int, move.split()) if 1 <= row <= 3 and 1 <= col <= 3: return row - 1, col - 1 else: print(\\"Invalid input. Row and column numbers must be between 1 and 3.\\") except ValueError: print(\\"Invalid input. Please enter two numbers separated by a space.\\") def play_tic_tac_toe(): player_1 = input(\\"Enter Player 1\'s name: \\") player_2 = input(\\"Enter Player 2\'s name: \\") board = initialize_board() current_player = player_1 current_marker = \'X\' while True: print_board(board) row, col = get_player_move(current_player) if board[row][col] == \' \': board[row][col] = current_marker else: print(\\"Cell already occupied. Try again.\\") continue if check_winner(board, current_marker): print_board(board) print(f\\"{current_player} wins!\\") break if is_board_full(board): print_board(board) print(\\"The game is a draw!\\") break current_player = player_2 if current_player == player_1 else player_1 current_marker = \'O\' if current_marker == \'X\' else \'X\'"},{"question":"# Problem Statement You are tasked with implementing a function, `find_missing_number`, which identifies the missing number from a list containing a sequence of integers from 1 to n. The sequence will always have exactly one number missing. The function should optimize for performance and handle edge cases appropriately, such as an empty array or invalid types. # Function Signature ```python def find_missing_number(nums: list[int]) -> int: Detects the missing number in a list of integers. Args: nums (list[int]): The list of integers in sequence containing exactly one missing number. Returns: int: The missing number in the sequence. Raises: ValueError: If the input list does not follow the expected structure. TypeError: If the input is not of type list or contains non-integer values. # Example ```python >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([]) Traceback (most recent call last): ... ValueError: Input list must not be empty and must follow the missing number constraint >>> find_missing_number([3, 7, 1, 2, \\"4\\", 5]) Traceback (most recent call last): ... TypeError: All elements in the input list must be integers >>> find_missing_number([3, 4, 2, 1, 0]) Traceback (most recent call last): ... ValueError: List elements must be in the range 1 to n inclusive # Constraints - Your solution should aim for an O(n) time complexity and try to avoid sorting the input list. - The input list can have elements in any order. - The input sequence will always have exactly one number missing, and the rest of the numbers in the range from 1 to n will be present. ```","solution":"def find_missing_number(nums): Detects the missing number in a list of integers. Args: nums (list[int]): The list of integers in sequence containing exactly one missing number. Returns: int: The missing number in the sequence. Raises: ValueError: If the input list does not follow the expected structure. TypeError: If the input is not of type list or contains non-integer values. if not isinstance(nums, list): raise TypeError(\\"Input must be a list\\") if not nums: raise ValueError(\\"Input list must not be empty and must follow the missing number constraint\\") if not all(isinstance(num, int) for num in nums): raise TypeError(\\"All elements in the input list must be integers\\") n = len(nums) + 1 # since one number is missing expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum if not (1 <= missing_number <= n): raise ValueError(\\"List elements must be in the range 1 to n inclusive\\") return missing_number"},{"question":"# Coding Assessment Question Background In computer graphics, transformations are often applied to images and shapes. One common transformation is rotating an image by 90 degrees clockwise. Given a 2D integer matrix representing an image, your task is to rotate it by 90 degrees clockwise in-place. Problem Statement You are required to implement a function that rotates a given N x N integer matrix by 90 degrees clockwise. Do not return a new matrix; modify the input matrix in-place. Input * An integer matrix `matrix` of size N x N where `1 ≤ N ≤ 100`, and each element of the matrix `-1000 ≤ matrix[i][j] ≤ 1000`. Output * The function should modify the input matrix in-place to its rotated version. Constraints * Do not use any extra space for another matrix; rotate the matrix in-place. Example ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix) >>> matrix [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] >>> matrix = [[1]] >>> rotate_matrix(matrix) >>> matrix [[1]] ``` Implementation Notes: 1. To rotate the matrix in-place, one can first transpose the matrix (swap `matrix[i][j]` with `matrix[j][i]`), and then reverse each row in the transposed matrix. 2. Ensure you handle both small and large matrices efficiently within the given constraints.","solution":"def rotate_matrix(matrix): Rotates the given N x N matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]] - 2D list representing the matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question: Rotated Array Minimum Finder You are given a list of integers that has been rotated at some pivot unknown to you beforehand. For example, the list `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`. Your task is to find the minimum element in this rotated sorted array. **Function Signature**: ```python def find_min(nums: list[int]) -> int: ... ``` # Input - `nums`: A list of integers, where 1 ≤ len(nums) ≤ 10^5, and all elements are unique. # Output - Return the minimum element in the given list of integers `nums`. # Constraints * The function should execute in O(log n) time complexity and utilize O(1) additional space. # Examples ```python # Example 1 assert find_min([4, 5, 6, 7, 0, 1, 2]) == 0 # Example 2 assert find_min([3, 4, 5, 1, 2]) == 1 # Example 3 assert find_min([11, 13, 15, 17]) == 11 # Example 4 assert find_min([2, 1]) == 1 # Example 5 assert find_min([1]) == 1 ``` # Description - Your task is to implement the function `find_min(nums: list[int]) -> int` which returns the minimum element in a rotated sorted array `nums`. - **Rotated Sorted Array**: * A sorted array is rotated by shifting elements at a certain pivot. - Use a binary search approach to achieve the required time complexity. # Notes * Consider edge cases such as arrays of length one. * The rotation pivot points might be at the start or end of the array. By creating an efficient function leveraging the binary search, we can ensure our solution meets the constraints even for large inputs.","solution":"def find_min(nums): Finds the minimum element in a rotated sorted array. Args: nums: A list of integers which is a rotated sorted array. Returns: The minimum element in the array. left, right = 0, len(nums) - 1 # Handle case when array is not rotated at all if nums[left] < nums[right]: return nums[left] while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 # Minimum is in the right part else: right = mid # Minimum is in the left part or is mid itself return nums[left]"},{"question":"# Problem Statement **Context:** You have recently been given the task to analyze a sequence of integers to find the \\"peak\\" element. A peak element in an array is defined as an element that is strictly greater than its neighbors. An array may contain multiple peak elements, and if the array contains multiple peaks, any of those peaks can be returned. **Definition:** Given an array of integers, your task is to find any one peak element and return its index. **Requirements:** Implement the following function: ```python def find_peak_element(nums: list) -> int: Finds a peak element in the given array and returns its index. The peak element is an element that is greater than its neighbors. Args: nums (list): List of integers Returns: int: Index of any peak element pass ``` **Input:** - `nums`: A list of integers with a length no less than 1 (len(nums) >= 1) **Output:** - An integer representing the index of any peak element **Examples:** ```python assert find_peak_element([1, 2, 3, 1]) == 2 # 3 is a peak element at index 2 assert find_peak_element([1, 2, 1, 3, 5, 6, 4]) in [1, 5] # 2 and 6 are peak elements at indexes 1 or 5 assert find_peak_element([1]) == 0 # The only element is a peak by definition assert find_peak_element([1, 2]) == 1 # 2 is a peak element at index 1 ``` **Constraints:** - The array should have at least one element. - Edge elements can be considered peak elements if they are greater than their only neighbor. - Arrays with only one element have that single element as a peak. **Notes:** - You may assume that the array is not empty and has at least one element. - Your algorithm should run in O(log n) time complexity for optimum performance.","solution":"def find_peak_element(nums: list) -> int: Finds a peak element in the given array and returns its index. The peak element is an element that is greater than its neighbors. Args: nums (list): List of integers Returns: int: Index of any peak element left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"# Problem Description You are tasked with implementing a lightweight, in-memory caching system that supports basic cache operations and provides a method for cache eviction based on the Least Recently Used (LRU) algorithm. The caching system should allow for setting a maximum cache size, adding and retrieving items, and automatically evicting the least recently used items when the cache exceeds its capacity. # Function Specifications 1. **__init__(max_size: int)**: Initialize the cache with a maximum size. - **Input**: An integer `max_size` representing the maximum number of items the cache can hold. - **Output**: None - **Behavior**: Initialize the cache with the specified maximum size. 2. **put(key: str, value: str)**: Add an item to the cache. - **Input**: A string `key` representing the item\'s key and a string `value` representing the item\'s value. - **Output**: None - **Behavior**: Add the key-value pair to the cache. If the cache exceeds its maximum size, evict the least recently used item. 3. **get(key: str) -> str**: Retrieve an item from the cache. - **Input**: A string `key` representing the item\'s key. - **Output**: A string representing the item\'s value. - **Behavior**: Return the value associated with the key if it exists in the cache and mark it as recently used. If the key does not exist, return `None`. 4. **delete(key: str)**: Remove an item from the cache. - **Input**: A string `key` representing the item\'s key. - **Output**: None - **Behavior**: Remove the key-value pair from the cache if it exists. If the key does not exist, do nothing. # Constraints - The `max_size` parameter will always be a positive integer. - The cache will store a reasonable number of items (up to 1000 items in typical use cases). - The key and value strings will be of reasonable length (up to 1000 characters). # Example ```python cache = LRUCache(max_size=2) cache.put(\\"a\\", \\"apple\\") cache.put(\\"b\\", \\"banana\\") print(cache.get(\\"a\\")) # Output: \\"apple\\" cache.put(\\"c\\", \\"cherry\\") print(cache.get(\\"b\\")) # Output: None (evicted because it\'s the least recently used) print(cache.get(\\"a\\")) # Output: \\"apple\\" print(cache.get(\\"c\\")) # Output: \\"cherry\\" cache.put(\\"d\\", \\"date\\") print(cache.get(\\"a\\")) # Output: None (evicted because it\'s the least recently used) print(cache.get(\\"c\\")) # Output: \\"cherry\\" print(cache.get(\\"d\\")) # Output: \\"date\\" ``` # Requirements - Ensure the `put`, `get`, and `delete` operations have efficient time complexities. - Handle edge cases such as adding items beyond capacity, attempting to retrieve or delete non-existent keys, and working with an initially empty cache. - Implement the LRU eviction policy correctly when the cache hits its maximum size.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, max_size: int): self.cache = OrderedDict() self.max_size = max_size def put(self, key: str, value: str): if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.max_size: self.cache.popitem(last=False) def get(self, key: str) -> str: if key in self.cache: self.cache.move_to_end(key) return self.cache[key] return None def delete(self, key: str): if key in self.cache: del self.cache[key]"},{"question":"# Problem Statement: You are tasked with creating a function that determines whether all elements within a two-dimensional list (matrix) are unique. This implementation is essential for validated data input before processing tasks such as matrix inversion or solving linear equations. # Function Signature: ```python def all_unique(matrix: List[List[int]]) -> bool: pass ``` # Input: * `matrix` (List[List[int]]): A two-dimensional list of integers. # Output: * Returns a `bool`: `True` if all elements in the matrix are unique, `False` otherwise. # Constraints: * The matrix will not be empty and will have dimensions `n x m` where `1 <= n, m <= 1000`. * The elements of the matrix can be any integer within the range `-10^6 <= element <= 10^6`. # Example: ```python def all_unique(matrix: List[List[int]]) -> bool: seen = set() for row in matrix: for elem in row: if elem in seen: return False seen.add(elem) return True # Example usage print(all_unique([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # Output: True print(all_unique([[1, 2, 3], [4, 5, 6], [7, 8, 1]])) # Output: False ``` # Requirements: 1. Implement the function `all_unique` that checks the uniqueness of elements within the matrix. 2. Ensure the function operates within an efficient time complexity, suitable for matrix dimensions up to `1000 x 1000`. 3. Test the function with various input sizes and ranges of integers to ensure accuracy and performance. # Hints: 1. Utilize a set to track seen elements efficiently. 2. Consider edge cases such as matrices with negative and large integer values. This question integrates with the given set by maintaining a focus on handling multi-dimensional data, ensuring computational efficiency, and requiring systematic verification of constraints.","solution":"from typing import List def all_unique(matrix: List[List[int]]) -> bool: seen = set() for row in matrix: for elem in row: if elem in seen: return False seen.add(elem) return True"},{"question":"# Problem Statement You are required to create a function that generates all possible subsets of a given list of unique integers. Subsets of a set are all possible collections of the elements in any order, including the empty set and the set itself. The order of subsets in the output does not matter. # Requirements: 1. **Function to Generate Subsets**: - Name: `generate_subsets` - Input: A list of unique integers `nums`. - Output: A list of lists where each inner list represents a subset. - Constraints: - The input list can contain up to 10 unique integers. - The output should not contain duplicate subsets. - The order of the subsets in the output list does not matter. # Example: ```python def generate_subsets(nums: list[int]) -> list[list[int]]: result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result # Example usage print(generate_subsets([1, 2])) # Output: [[], [1], [2], [1, 2]] print(generate_subsets([1, 2, 3])) # Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] ``` # Notes: - Ensure the function handles the edge case of an empty input list correctly, returning `[[]]`. - Include tests to validate your function against various cases including the smallest (empty list) and largest possible (10 unique integers) inputs. - Optimize the function for readability and efficiency to handle the constraints effectively.","solution":"def generate_subsets(nums): Generate all possible subsets of a given list of unique integers. Args: nums (list of int): A list of unique integers. Returns: list of list of int: A list containing all possible subsets. result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"# Data Analysis and Visualization with Pandas and Matplotlib Context You are given a dataset containing information about the daily weather conditions (temperature, humidity, and precipitation) in a city over a year. Your task is to analyze this data, extract meaningful insights, and visualize the trends effectively using Python\'s Pandas and Matplotlib libraries. Task 1. **Data Loading and Cleaning**: - Load the dataset from a CSV file. - Check for any missing values and handle them appropriately. - Convert the date column to `datetime` format if not already. 2. **Statistical Analysis**: - Compute the monthly average, minimum, and maximum temperatures. - Compute the monthly total precipitation. 3. **Visualization**: - Plot the monthly average, minimum, and maximum temperatures on a single line graph. - Plot the monthly total precipitation on a bar graph. 4. **Seasonal Trends**: - Identify and display the season (Winter, Spring, Summer, Fall) with the highest and lowest average temperature. - Identify and display the season with the highest and lowest total precipitation. Function Signatures You are to implement the following functions: ```python def load_and_clean_data(file_path: str) -> pd.DataFrame: :param file_path: str: Path to the CSV file containing the weather data. :return: pd.DataFrame: Cleaned Pandas DataFrame. ... def compute_monthly_statistics(df: pd.DataFrame) -> pd.DataFrame: :param df: pd.DataFrame: Cleaned Pandas DataFrame. :return: pd.DataFrame: DataFrame containing the monthly average, min, max temperatures, and total precipitation. ... def plot_temperature_trends(statistics: pd.DataFrame) -> None: :param statistics: pd.DataFrame: DataFrame containing monthly temperature statistics. :return: None: Displays the line graph of temperature trends. ... def plot_precipitation_trends(statistics: pd.DataFrame) -> None: :param statistics: pd.DataFrame: DataFrame containing monthly precipitation statistics. :return: None: Displays the bar graph of precipitation trends. ... def identify_seasonal_trends(statistics: pd.DataFrame) -> Dict[str, Any]: :param statistics: pd.DataFrame: DataFrame containing monthly statistics. :return: dict: Dictionary containing information about seasonal trends for temperature and precipitation. ... ``` Constraints - The input CSV file is assumed to have the columns: [\'Date\', \'Temperature\', \'Humidity\', \'Precipitation\']. - Handle any missing or incorrect data appropriately. - Use Pandas for data manipulation and Matplotlib for plotting. - Ensure seasonal trends are identified based on the following date ranges: - Winter: December 21 - March 19 - Spring: March 20 - June 20 - Summer: June 21 - September 22 - Fall: September 23 - December 20 - Interpret each season starting from the mentioned date of the current year to just before the starting date of the next season. Example Suppose we have the following synthetic daily weather data for January and February: ```csv Date,Temperature,Humidity,Precipitation 2023-01-01,32,70,0.0 2023-01-02,30,65,0.1 ... 2023-02-28,28,60,0.0 ``` Load and clean the data: ```python df = load_and_clean_data(\'weather_data.csv\') ``` Compute monthly statistics: ```python monthly_stats = compute_monthly_statistics(df) ``` Plot temperature trends: ```python plot_temperature_trends(monthly_stats) ``` Plot precipitation trends: ```python plot_precipitation_trends(monthly_stats) ``` Identify seasonal trends: ```python seasonal_trends = identify_seasonal_trends(monthly_stats) ``` The identified seasonal trends could be: ```python { \'Highest Avg Temperature Season\': \'Summer\', \'Lowest Avg Temperature Season\': \'Winter\', \'Highest Total Precipitation Season\': \'Spring\', \'Lowest Total Precipitation Season\': \'Fall\' } ``` Use the results to verify the trends and insights derived from the weather data.","solution":"import pandas as pd import matplotlib.pyplot as plt from typing import Dict, Any def load_and_clean_data(file_path: str) -> pd.DataFrame: # Load the dataset df = pd.read_csv(file_path) # Convert \'Date\' column to datetime df[\'Date\'] = pd.to_datetime(df[\'Date\']) # Handle missing values by filling them with the mean of respective columns df[\'Temperature\'].fillna(df[\'Temperature\'].mean(), inplace=True) df[\'Humidity\'].fillna(df[\'Humidity\'].mean(), inplace=True) df[\'Precipitation\'].fillna(df[\'Precipitation\'].mean(), inplace=True) return df def compute_monthly_statistics(df: pd.DataFrame) -> pd.DataFrame: # Extract month and year from the date df[\'YearMonth\'] = df[\'Date\'].dt.to_period(\'M\') # Compute monthly statistics monthly_stats = df.groupby(\'YearMonth\').agg({ \'Temperature\': [\'mean\', \'min\', \'max\'], \'Precipitation\': \'sum\' }) # Flatten the multi-level column structure monthly_stats.columns = [\'Avg_Temperature\', \'Min_Temperature\', \'Max_Temperature\', \'Total_Precipitation\'] monthly_stats.reset_index(inplace=True) return monthly_stats def plot_temperature_trends(statistics: pd.DataFrame) -> None: plt.figure(figsize=(10, 6)) plt.plot(statistics[\'YearMonth\'].astype(str), statistics[\'Avg_Temperature\'], label=\'Avg Temperature\', marker=\'o\') plt.plot(statistics[\'YearMonth\'].astype(str), statistics[\'Min_Temperature\'], label=\'Min Temperature\', linestyle=\'--\', marker=\'^\') plt.plot(statistics[\'YearMonth\'].astype(str), statistics[\'Max_Temperature\'], label=\'Max Temperature\', linestyle=\':\', marker=\'s\') plt.xlabel(\'Month\') plt.ylabel(\'Temperature (°C)\') plt.title(\'Monthly Temperature Trends\') plt.legend() plt.grid(True) plt.xticks(rotation=45) plt.tight_layout() plt.show() def plot_precipitation_trends(statistics: pd.DataFrame) -> None: plt.figure(figsize=(10, 6)) plt.bar(statistics[\'YearMonth\'].astype(str), statistics[\'Total_Precipitation\'], color=\'skyblue\') plt.xlabel(\'Month\') plt.ylabel(\'Total Precipitation (mm)\') plt.title(\'Monthly Precipitation Trends\') plt.grid(True) plt.xticks(rotation=45) plt.tight_layout() plt.show() def identify_seasonal_trends(statistics: pd.DataFrame) -> Dict[str, Any]: # Define season ranges seasons = { \'Winter\': ((12, 21), (3, 19)), \'Spring\': ((3, 20), (6, 20)), \'Summer\': ((6, 21), (9, 22)), \'Fall\': ((9, 23), (12, 20)), } # Map months to seasons def get_season(month, day): for season, ((start_month, start_day), (end_month, end_day)) in seasons.items(): if (month > start_month or (month == start_month and day >= start_day)) and (month < end_month or (month == end_month and day <= end_day)): return season return \'Winter\' if month <= 2 or month == 12 else \'Fall\' # Add Season column statistics[\'Season\'] = statistics[\'YearMonth\'].apply(lambda x: get_season(x.month, x.day)) # Compute seasonal statistics seasonal_stats = statistics.groupby(\'Season\')[\'Avg_Temperature\'].mean() highest_avg_temp_season = seasonal_stats.idxmax() lowest_avg_temp_season = seasonal_stats.idxmin() seasonal_precipitation = statistics.groupby(\'Season\')[\'Total_Precipitation\'].sum() highest_precipitation_season = seasonal_precipitation.idxmax() lowest_precipitation_season = seasonal_precipitation.idxmin() return { \'Highest Avg Temperature Season\': highest_avg_temp_season, \'Lowest Avg Temperature Season\': lowest_avg_temp_season, \'Highest Total Precipitation Season\': highest_precipitation_season, \'Lowest Total Precipitation Season\': lowest_precipitation_season, }"},{"question":"# Coding Assessment Question Context: In computational geometry, the problem of finding the area of the intersection of two rectangles is a common exercise. This involves concepts such as coordinate geometry and basic arithmetic operations. Problem: Given the coordinates of two rectangles that are axis-aligned, implement a function to calculate the area of their intersection. Function Signature: ```python def intersection_area(rect1: list, rect2: list) -> int: pass ``` Input: * `rect1`: A list of four integers representing the coordinates of the first rectangle in the form `[x1, y1, x2, y2]`, where `(x1, y1)` is the bottom-left corner and `(x2, y2)` is the top-right corner. * `rect2`: A list of four integers representing the coordinates of the second rectangle in the same format. Output: * An integer representing the area of the intersection of the two rectangles. If the rectangles do not intersect, return `0`. Constraints: * The rectangles are always aligned with the x and y axes. * The coordinates are given in a Cartesian plane where `(x, y)` values are integer numbers. * You must handle cases where the rectangles do not intersect. Example: ```python rect1 = [1, 1, 4, 4] rect2 = [2, 2, 5, 5] intersection_area(rect1, rect2) # Output: 4 rect1 = [1, 1, 2, 2] rect2 = [3, 3, 4, 4] intersection_area(rect1, rect2) # Output: 0 rect1 = [0, 0, 3, 3] rect2 = [1, 1, 2, 2] intersection_area(rect1, rect2) # Output: 1 rect1 = [0, 0, 5, 5] rect2 = [3, 3, 7, 7] intersection_area(rect1, rect2) # Output: 4 ``` Instructions: 1. Implement the `intersection_area` function that calculates the intersecting area of two rectangles. 2. Handle edge cases such as the rectangles not intersecting or touching only at the edges. 3. Optimize your solution to run efficiently within the provided constraints. Note: You may define any helper functions as necessary to keep your code clean and modular.","solution":"def intersection_area(rect1: list, rect2: list) -> int: Calculate the area of intersection between two axis-aligned rectangles. Parameters: - rect1: List of four integers [x1, y1, x2, y2] representing the first rectangle. - rect2: List of four integers [x1, y1, x2, y2] representing the second rectangle. Returns: - The area of intersection of the two rectangles. If they do not intersect, return 0. # Unpack the rectangles x1_1, y1_1, x2_1, y2_1 = rect1 x1_2, y1_2, x2_2, y2_2 = rect2 # Calculate the (x, y) coordinates of the intersection rectangle intersect_x1 = max(x1_1, x1_2) intersect_y1 = max(y1_1, y1_2) intersect_x2 = min(x2_1, x2_2) intersect_y2 = min(y2_1, y2_2) # Calculate the width and height of the intersection rectangle width = intersect_x2 - intersect_x1 height = intersect_y2 - intersect_y1 # If there\'s no intersection, width or height would be non-positive if width <= 0 or height <= 0: return 0 # Calculate and return the area of the intersection rectangle return width * height"},{"question":"# Coding Assessment Question Graph Cycle Detection Given an undirected graph represented as an adjacency list, your task is to implement a function that determines if the graph contains a cycle. Function Signature: ```python def contains_cycle(graph: dict[int, list[int]]) -> bool: pass ``` Input: - `graph`: A dictionary where keys represent nodes, and values are lists of adjacent nodes. Output: - Return `True` if the graph contains at least one cycle, otherwise return `False`. Constraints: - The graph is undirected, meaning that if node `A` is connected to node `B`, then node `B` is also connected to node `A`. - The graph can be disconnected, i.e., it might consist of multiple components. Example: ```python graph1 = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2, 4], 4: [3] } print(contains_cycle(graph1)) # Output should be True (since 0-1-2-0 forms a cycle) graph2 = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } print(contains_cycle(graph2)) # Output should be False (no cycle in this graph) ``` Requirements: - Use Depth-First Search (DFS) to detect cycles in the graph. - Maintain a `visited` set to keep track of visited nodes to avoid redundant checks. - Ensure that the check does not consider trivial cycles between the current node and the parent node (i.e., treat it as a proper cycle if it involves at least 3 nodes). Hints: - Use a helper function to perform DFS on each unvisited node while maintaining a parent reference to detect back edges, which indicate cycles. - Consider the graph might have multiple components, thus initiate the DFS from each node not yet visited. Good luck!","solution":"def contains_cycle(graph: dict[int, list[int]]) -> bool: def dfs(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node): return True elif neighbor != parent: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, -1): # start DFS with no parent return True return False"},{"question":"Question: Customer Churn Prediction Using Random Forest You are tasked with predicting customer churn based on a dataset using the Random Forest classifier. The goal is to train a Random Forest model on the given dataset and evaluate its performance based on Accuracy, F1-Score, Precision, and Recall. # Task 1. **Data Handling** - Write a function `data_handling(data: dict) -> tuple` that takes a dictionary containing the dataset and target values. This function should return a tuple containing the feature data (`data[\\"data\\"]`) and the target labels (`data[\\"target\\"]`). 2. **Model Training and Prediction** - Write a function `random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray` that: - Initializes and trains a Random Forest classifier on provided training features and target labels. - Predicts the target labels for the given test features. - Returns the predictions. 3. **Main Function** - Write a function `main()` that: - Loads a synthetic customer churn dataset. - Handles the dataset using the `data_handling` function. - Splits the data into training and testing sets. - Trains the model and makes predictions using the `random_forest` function. - Computes and prints the Accuracy, F1-Score, Precision, and Recall of the predictions. # Constraints - Do not alter the structure of the dataset. - Ensure reproducibility with a fixed random state of 42. - Handle edge cases where the dataset might have missing or NaN values. # Example ```python import numpy as np from sklearn.datasets import make_classification from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score from sklearn.model_selection import train_test_split def data_handling(data: dict) -> tuple: return (data[\\"data\\"], data[\\"target\\"]) def random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray: rf = RandomForestClassifier(n_estimators=100, random_state=42) rf.fit(features, target) predictions = rf.predict(test_features) return predictions def main() -> None: data, target = make_classification(n_samples=1000, n_features=20, n_informative=2, n_redundant=10, random_state=42) data_dict = {\\"data\\": data, \\"target\\": target} features, target = data_handling(data_dict) x_train, x_test, y_train, y_test = train_test_split(features, target, test_size=0.25, random_state=42) predictions = random_forest(x_train, y_train, x_test) print(f\\"Accuracy: {accuracy_score(y_test, predictions)}\\") print(f\\"F1 Score: {f1_score(y_test, predictions)}\\") print(f\\"Precision: {precision_score(y_test, predictions)}\\") print(f\\"Recall: {recall_score(y_test, predictions)}\\") if __name__ == \\"__main__\\": main() ``` # Expected Results You should expect the following metrics: - **Accuracy**: ~0.95 - **F1 Score**: ~0.95 - **Precision**: ~0.94 - **Recall**: ~0.95","solution":"import numpy as np from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score from sklearn.model_selection import train_test_split def data_handling(data: dict) -> tuple: Takes a dictionary containing the dataset and target values and returns a tuple containing the feature data and the target labels. return (data[\\"data\\"], data[\\"target\\"]) def random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray: Initializes and trains a Random Forest classifier on provided training features and target labels, then predicts the target labels for the given test features and returns the predictions. rf = RandomForestClassifier(n_estimators=100, random_state=42) rf.fit(features, target) predictions = rf.predict(test_features) return predictions def main() -> None: Main function that: - Loads a synthetic customer churn dataset. - Handles the dataset using the data_handling function. - Splits the data into training and testing sets. - Trains the model and makes predictions using the random_forest function. - Computes and prints the Accuracy, F1-Score, Precision, and Recall of the predictions. from sklearn.datasets import make_classification # Generating a synthetic customer churn dataset data, target = make_classification(n_samples=1000, n_features=20, n_informative=2, n_redundant=10, random_state=42) data_dict = {\\"data\\": data, \\"target\\": target} features, target = data_handling(data_dict) x_train, x_test, y_train, y_test = train_test_split(features, target, test_size=0.25, random_state=42) predictions = random_forest(x_train, y_train, x_test) print(f\\"Accuracy: {accuracy_score(y_test, predictions)}\\") print(f\\"F1 Score: {f1_score(y_test, predictions)}\\") print(f\\"Precision: {precision_score(y_test, predictions)}\\") print(f\\"Recall: {recall_score(y_test, predictions)}\\")"},{"question":"# Task Scheduler Problem Statement You are asked to implement a task scheduler function that organizes a list of tasks with cooldown periods. Each task is represented by a character and the cooldown period is a specific time during which the same task cannot be executed again. Implement a function that returns the minimum time required to execute all tasks given the cooldown interval for each task. Requirements 1. **Function**: `task_scheduler(tasks: List[str], cooldown: int) -> int` - `tasks`: A list of tasks represented by characters (each character is a single task). - `cooldown`: An integer representing the cooldown period for any specific task. Input Format - A list `tasks` where each task is represented by a character. - An integer `cooldown` representing the cooldown time. Output Format - Return an integer representing the minimum total time to execute all tasks. Constraints - The `tasks` list will have at most (10^4) elements. - Characters in `tasks` are limited to uppercase English letters. - The `cooldown` period is a non-negative integer and will not exceed 100. Performance Requirements - Aim to achieve a time complexity that efficiently handles the maximum constraints. Example ```python tasks = [\'A\', \'A\', \'A\', \'B\', \'B\', \'B\'] cooldown = 2 print(task_scheduler(tasks, cooldown)) # Outputs: 8 tasks = [\'A\', \'B\', \'A\'] cooldown = 3 print(task_scheduler(tasks, cooldown)) # Outputs: 5 ``` Explanation In the first example: - Tasks can be scheduled as `A B _ | A B _ | A B`, where `_` denotes idle time, giving a total time of 8. In the second example: - Tasks can be scheduled as `A _ _ _ B _ _ _ A`, giving a total time of 5. Signature ```python def task_scheduler(tasks: List[str], cooldown: int) -> int: # Your code here ```","solution":"from collections import Counter import heapq def task_scheduler(tasks, cooldown): if cooldown == 0: return len(tasks) task_counts = Counter(tasks) max_heap = [-count for count in task_counts.values()] heapq.heapify(max_heap) time = 0 while max_heap: wait_list = [] n = cooldown + 1 while n > 0 and max_heap: task_count = heapq.heappop(max_heap) time += 1 if task_count + 1 < 0: wait_list.append(task_count + 1) n -= 1 for item in wait_list: heapq.heappush(max_heap, item) if max_heap: time += n # idle time return time"},{"question":"# Introduction You have been tasked with the implementation of a simple calculator that can process a string containing a mathematical expression involving addition and subtraction of integers. This calculator will help validate input and compute the result of valid expressions. # Problem Write a function `evaluate_expression(expression: str) -> int` that evaluates the given string expression, which consists of integers and the operators `+` and `-`. The function should also handle invalid input appropriately. # Function Signature ```python def evaluate_expression(expression: str) -> int: ``` # Input The input is a single string, `expression`, which represents a mathematical expression. The string may contain: - valid integers and operators `+` or `-` - spaces interspersed throughout the expression - invalid characters or invalid format # Output The function should return an integer which is the result of evaluating the expression. If the input is invalid, the function should raise a `ValueError` with an appropriate error message (as detailed below). # Constraints 1. An empty input string or one that contains only whitespace should raise a `ValueError` with the message `Empty string was passed to the function`. 2. An input string which contains characters other than digits, `+`, `-`, or spaces (invalid characters) should raise a `ValueError` with the message `Invalid characters in the expression`. # Examples ```python assert evaluate_expression(\\"12 + 7 - 5\\") == 14 assert evaluate_expression(\\" 3 - 2 + 4 \\") == 5 assert evaluate_expression(\\"1\\") == 1 assert evaluate_expression(\\"0\\") == 0 assert evaluate_expression(\\"-5 + 3\\") == -2 assert evaluate_expression(\\"20 - 4 - 8 + 2\\") == 10 try: evaluate_expression(\\"\\") except ValueError as e: assert str(e) == \\"Empty string was passed to the function\\" try: evaluate_expression(\\"10 + a\\") except ValueError as e: assert str(e) == \\"Invalid characters in the expression\\" ``` Make sure your solution passes the above examples and adheres to the constraints provided.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a string expression containing integers with + and - operators. import re # Check if the expression is empty or contains only whitespace if not expression.strip(): raise ValueError(\\"Empty string was passed to the function\\") # Check for invalid characters if not re.match(r\'^[ds+-]+\', expression): raise ValueError(\\"Invalid characters in the expression\\") # Strip any whitespace and split the expression by spaces tokens = expression.strip().split() # Initialize the accumulator for the result result = 0 current_number = \'\' current_sign = 1 for token in tokens: if token in \'+-\': # When we encounter a sign, it indicates the end of a number if current_number: result += current_sign * int(current_number) current_number = \'\' current_sign = 1 if token == \'+\' else -1 else: current_number += token # Add the last accumulated number if any if current_number: result += current_sign * int(current_number) return result"},{"question":"**Graph Traversal Challenge: Minimum Path Sum** # Problem Statement: Given a 2D grid of size `m x n` where each cell contains a non-negative integer representing the cost to traverse through that cell, find a path from the top-left corner to the bottom-right corner which minimizes the sum of the costs of the cells in the path. You can only move either down or right at any point in time. Write a function `min_path_sum(grid: List[List[int]]) -> int` that computes this minimum path sum. # Input - A 2D list `grid` of size `m x n` (1 ≤ `m`, `n` ≤ 100) where each element is a non-negative integer (0 ≤ `grid[i][j]` ≤ 100). # Output - An integer representing the minimum path sum. # Requirements - You must use a dynamic programming approach to solve this problem. - Consider edge cases such as grids where the dimensions are the smallest or the values are either all zeros or all maximums. - Ensure that your implementation is efficient and can handle the largest grid sizes within a reasonable time. # Example ```python >>> min_path_sum([[1,3,1],[1,5,1],[4,2,1]]) 7 >>> min_path_sum([[1,2,3],[4,5,6]]) 12 >>> min_path_sum([[1]]) 1 ``` # Constraints - Your solution should ideally have a time complexity of O(m * n). - Optimize space complexity to O(n) if possible, otherwise O(m * n) is acceptable. Write your code below: ```python from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [0] * n dp[0] = grid[0][0] for j in range(1, n): dp[j] = dp[j - 1] + grid[0][j] for i in range(1, m): dp[0] += grid[i][0] for j in range(1, n): dp[j] = min(dp[j - 1], dp[j]) + grid[i][j] return dp[-1] # Example usage if __name__ == \\"__main__\\": print(min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) # Output: 7 ```","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [0] * n dp[0] = grid[0][0] for j in range(1, n): dp[j] = dp[j - 1] + grid[0][j] for i in range(1, m): dp[0] += grid[i][0] for j in range(1, n): dp[j] = min(dp[j - 1], dp[j]) + grid[i][j] return dp[-1]"},{"question":"# Coding Assessment Question: Binary Search and Dynamic Programming Objective Design a class for efficient stock trading strategies, which includes methods for finding the maximum profit from a single buy and sell, and another method for optimal buy and sell timings for multiple transactions. Requirements 1. **Single Transaction**: Implement a method to determine the maximum profit you can achieve from one transaction (buy one and sell one share of the stock). 2. **Multiple Transactions**: Implement a method to determine the maximum profit you can achieve from an unlimited number of transactions (you may buy and sell multiple times). Method Specifications - **Single Transaction**: 1. `max_single_transaction_profit() -> int`: Find the maximum profit from a single buy and sell. - **Multiple Transactions**: 1. `max_multiple_transactions_profit() -> int`: Find the maximum profit from making multiple buy and sell transactions. # Input and Output Formats - **Input**: The stock prices will be provided as a list of integers representing the price of the stock on each day. - **Output**: The methods should return an integer representing the maximum profit. # Constraints - The stock prices list will have a length `1 <= n <= 10000`. - Stock prices will be positive integers within the range [1, 10000]. # Performance Requirements - The single transaction profit calculation should handle lists up to length 10000 efficiently. - The multiple transaction profit calculation should also handle similar list sizes within reasonable time limits. # Function Signature ```python def max_single_transaction_profit(self) -> int: pass def max_multiple_transactions_profit(self) -> int: pass ``` # Example Usage: ```python prices = [7, 1, 5, 3, 6, 4, 8] trading_strategy = TradingStrategy(prices) # Maximum profit from a single transaction print(trading_strategy.max_single_transaction_profit()) # Output should be 7 (buy at 1, sell at 8) # Maximum profit from multiple transactions print(trading_strategy.max_multiple_transactions_profit()) # Output should be 9 (buy at 1, sell at 6, buy at 3, sell at 8) ``` # Class Definition ```python class TradingStrategy: def __init__(self, prices: List[int]): self.prices = prices def max_single_transaction_profit(self) -> int: # Implement the logic to find the max single transaction profit pass def max_multiple_transactions_profit(self) -> int: # Implement the logic to find the max profit from multiple transactions pass ```","solution":"class TradingStrategy: def __init__(self, prices): self.prices = prices def max_single_transaction_profit(self): if not self.prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in self.prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def max_multiple_transactions_profit(self): max_profit = 0 for i in range(1, len(self.prices)): if self.prices[i] > self.prices[i - 1]: max_profit += self.prices[i] - self.prices[i - 1] return max_profit"},{"question":"# Problem Statement You are tasked with implementing a function that will rotate a 2D square matrix by 90 degrees in the clockwise direction. This problem is common in image processing and computer graphics and tests your understanding of matrix manipulation. # Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Given a 2D square matrix, rotates it 90 degrees clockwise. Args: matrix: List[List[int]] - A 2D list representing the square matrix. Returns: List[List[int]] - The rotated 2D list. Raises: TypeError: If the input is not a 2D list of integers. ValueError: If the input matrix is not square or if it is empty. Examples: >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] ``` # Constraints 1. The input matrix will always be a square matrix with integers. 2. The function should raise a ValueError if the input is not a square matrix or if the matrix is empty. 3. The function should raise a TypeError if the input is not a 2D list of integers. 4. The matrix dimensions should not exceed 1000x1000 elements. # Detailed Requirements and Examples 1. **Input** - 2D list representing the square matrix. 2. **Output** - 2D list representing the rotated matrix. 3. **Example Scenarios** ```python - rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> [[7, 4, 1], [8, 5, 2], [9, 6, 3]] - rotate_matrix([[1]]) -> [[1]] - rotate_matrix([[1, 2], [3, 4]]) -> [[3, 1], [4, 2]] ``` # Performance Requirements - Time complexity must be (O(N^2)) where (N) is the dimension of the matrix. - Space complexity must be (O(1)) if modifying the matrix in place, otherwise (O(N^2)) for a new matrix. # Hints - Consider transposing the matrix first and then reversing each row. - Take care to validate the input to ensure that it is a valid square matrix. # Error Handling - If the input is not a square matrix or is empty, raise a ValueError. - If the input is not a 2D list of integers, raise a TypeError.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Given a 2D square matrix, rotates it 90 degrees clockwise. Args: matrix: List[List[int]] - A 2D list representing the square matrix. Returns: List[List[int]] - The rotated 2D list. Raises: TypeError: If the input is not a 2D list of integers. ValueError: If the input matrix is not square or if it is empty. Examples: >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] # Check if matrix is empty if not matrix: raise ValueError(\\"Input matrix is empty\\") # Check if matrix is a square matrix n = len(matrix) for row in matrix: if len(row) != n: raise ValueError(\\"Input matrix is not square\\") # Check if elements are integers for row in matrix: if not all(isinstance(x, int) for x in row): raise TypeError(\\"Input matrix should only contain integers\\") # Rotate the matrix by 90 degrees clockwise rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"# Problem Statement You are asked to develop a module for a simple text-based file management system. One of the key functionalities this system should offer is the efficient search and replacement of strings within file content. Objective Write a function `search_and_replace(file_content: str, search_term: str, replacement: str) -> str` that replaces all occurrences of the `search_term` in the `file_content` with the `replacement`. Input * `file_content`: A string representing the content of the file where the search and replace operation will be performed. * `search_term`: A string representing the term to search for in the `file_content`. * `replacement`: A string representing the term to replace each occurrence of the `search_term`. Output * A modified string with all occurrences of the `search_term` replaced by the `replacement`. Constraints * The lengths of `file_content`, `search_term`, and `replacement` are between 1 and 10^6 inclusive. * The search should be case-sensitive. * Ensure your solution handles the upper limit constraints efficiently. Requirements 1. Implement `search_and_replace` such that all occurrences of the `search_term` in the `file_content` are replaced with the `replacement`. 2. Ensure that your solution runs efficiently given the constraint sizes, aiming for time complexity close to O(n), where n is the length of `file_content`. # Example ```python search_and_replace( \\"Hello world! The world is beautiful.\\", \\"world\\", \\"universe\\" ) # Output: \\"Hello universe! The universe is beautiful.\\" search_and_replace( \\"abcdeabcde\\", \\"abc\\", \\"xyz\\" ) # Output: \\"xyzdexyzde\\" search_and_replace( \\"no replacements here\\", \\"notfound\\", \\"replacement\\" ) # Output: \\"no replacements here\\" ```","solution":"def search_and_replace(file_content: str, search_term: str, replacement: str) -> str: Replaces all occurrences of the search_term in the file_content with the replacement. Args: file_content (str): The content of the file. search_term (str): The term to search for. replacement (str): The term to replace the search_term with. Returns: str: The modified file content with all occurrences of search_term replaced by replacement. return file_content.replace(search_term, replacement)"},{"question":"# Cyclic Dependencies in a Directed Graph **Objective**: Implement a function to detect cyclic dependencies in a directed graph. A cyclic dependency exists if there is a cycle in the graph. Input You are given a directed graph represented as an adjacency list, where `dependencies` is a dictionary such that `dependencies[v]` is a list of vertices that vertex `v` has edges to. Your function should accept a dictionary `dependencies` where the keys are vertex identifiers (integers starting from 0) and the values are lists of adjacent vertex identifiers. Output Return `True` if there is at least one cycle in the graph, otherwise return `False`. Constraints 1. The graph can have up to 10,000 vertices. 2. There can be no edges and vertices. 3. The vertices are indexed with non-negative integers starting from 0. 4. No self-loops are allowed. Example ```python def has_cycle(dependencies: dict[int, list[int]]) -> bool: Return True if the directed graph contains a cycle, otherwise return False. Examples: >>> has_cycle({ >>> 0: [1, 2], >>> 1: [2], >>> 2: [0, 3], >>> 3: [3] >>> }) True >>> has_cycle({ >>> 0: [1], >>> 1: [2], >>> 2: [3], >>> 3: [] >>> }) False Example for empty dependency list: >>> has_cycle({}) False # Write your implementation here ``` Explanation In the first example, there is a cycle formed by the vertices 0 -> 1 -> 2 -> 0, so the function returns `True`. Additionally, vertex 3 has a self-loop (3 -> 3), which also indicates a cycle. In the second example, the directed graph is acyclic, so the function returns `False`. To detect cycles efficiently, you can employ Depth First Search (DFS) with coloring methods or use Kahn\'s Algorithm for topological sorting and detect any remaining nodes after processing all nodes with zero in-degrees.","solution":"def has_cycle(dependencies: dict[int, list[int]]) -> bool: Return True if the directed graph contains a cycle, otherwise return False. # Helper function for DFS traversal def dfs(v): nonlocal has_cycle_flag if visited[v] == 1: # visiting (gray) has_cycle_flag = True return if visited[v] == 2: # visited (black) return visited[v] = 1 # mark as visiting (gray) for neighbor in dependencies.get(v, []): dfs(neighbor) visited[v] = 2 # mark as visited (black) visited = {v: 0 for v in dependencies} # 0: unvisited, 1: visiting, 2: visited has_cycle_flag = False for vertex in dependencies: if visited[vertex] == 0: # If the vertex is unvisited, perform DFS from it dfs(vertex) if has_cycle_flag: return True return False"},{"question":"# Coding Assessment Question **Context**: You are tasked with detecting cycles in a directed graph. Given a list of edges representing a directed graph, your goal is to determine if there are any cycles present. This problem arises frequently in dependencies analysis, task scheduling, and other areas of computer science. **Function Specification**: **Function Name**: `has_cycle` **Parameters**: * `edges: list[tuple[int, int]]`: A list of tuples where each tuple `(u, v)` represents a directed edge from node `u` to node `v`. **Return**: * `bool`: Return `True` if there is a cycle in the graph, otherwise return `False`. **Constraints**: * There will be no self-loops (i.e., no edge from a node to itself). * The number of edges will not exceed 10^4. * Node values are non-negative integers and will be within the range of 0 to 10^3. **Example**: ```python # Example 1: print(has_cycle([(0, 1), (1, 2), (2, 0)])) # Output: True # Example 2: print(has_cycle([(0, 1), (1, 2), (2, 3)])) # Output: False # Example 3: print(has_cycle([(0, 1), (1, 2), (2, 3), (3, 1)])) # Output: True # Example 4: print(has_cycle([(0, 1), (1, 2), (3, 4)])) # Output: False # Example 5: print(has_cycle([(0, 0), (1, 2), (2, 3)])) # Output: False ``` # Instructions: 1. Implement the function `has_cycle` that takes in a list of directed edges and checks if there is a cycle present in the graph. 2. Utilize appropriate graph traversal algorithms such as Depth-First Search (DFS) or other techniques to detect cycles. 3. Ensure the function is optimized and runs efficiently for the given constraints and dataset size.","solution":"def has_cycle(edges): Detect if there is a cycle in the given directed graph. :param edges: List[Tuple[int, int]] :return: bool from collections import defaultdict, deque # Build graph adjacency list graph = defaultdict(list) in_degree = defaultdict(int) for u, v in edges: graph[u].append(v) in_degree[v] += 1 if u not in in_degree: in_degree[u] = 0 # Queue for nodes with no incoming edges queue = deque([node for node in in_degree if in_degree[node] == 0]) visited = 0 while queue: node = queue.popleft() visited += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return visited != len(in_degree)"},{"question":"# Problem Statement Implement a function `rotate_image(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D matrix of integers representing an image and returns the matrix after rotating it 90 degrees clockwise. # Input and Output * **Input**: * A 2D list `matrix` representing an ( n times n ) image, where ( 1 leq n leq 1000 ). * **Output**: * A 2D list representing the image after being rotated 90 degrees clockwise. # Constraints * The input matrix is guaranteed to be a square (same number of rows and columns). * The matrix can contain any valid integer values. # Example ```python >>> rotate_image([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_image([ [1, 2], [3, 4] ]) [ [3, 1], [4, 2] ] ``` # Notes * You may not use any external libraries for matrix manipulation; the function should perform the rotation in-place if possible. * Consider the implications of memory usage and computation complexity, particularly for the larger ( n ) values.","solution":"from typing import List def rotate_image(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n 2D matrix representing an image 90 degrees clockwise. Parameters: matrix (List[List[int]]): The n x n 2D list of integers representing the image. Returns: List[List[int]]: The rotated 2D list. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Pathfinding in Weighted Graphs Problem Statement: You are given a weighted undirected graph represented by an adjacency matrix `graph`. Your task is to implement Dijkstra\'s algorithm to find the shortest path from a starting vertex `start_index` to a target vertex `end_index`. The graph may contain positive weights, and the path must consider the minimal total weight. Task: Implement a function `shortest_path` to determine the shortest path from the starting vertex to the target vertex in the given weighted graph. The function should return the path as a list of vertices. If no path exists, return an empty list. Function Signature: ```python def shortest_path(graph: list[list[int]], start_index: int, end_index: int) -> list[int]: ``` Input: * `graph`: A 2D list representing an adjacency matrix of a weighted graph (N x N grid where `graph[i][j]` is the weight of the edge from vertex `i` to vertex `j`, or `0` if there is no edge). * `start_index`: An integer representing the starting vertex (0-based index). * `end_index`: An integer representing the target vertex (0-based index). Output: * A list of integers representing the vertices in the shortest path from `start_index` to `end_index` in the order of traversal. If no path exists, return an empty list. Constraints: * `2 <= N <= 50`, where `N` is the number of vertices in the graph. * The weights are all positive integers. Example: ```python graph = [ [0, 10, 0, 30, 100], [10, 0, 50, 0, 0], [0, 50, 0, 20, 10], [30, 0, 20, 0, 60], [100, 0, 10, 60, 0] ] start_index = 0 end_index = 4 print(shortest_path(graph, start_index, end_index)) # Output: [0, 3, 2, 4] graph = [ [0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0] ] start_index = 0 end_index = 3 print(shortest_path(graph, start_index, end_index)) # Output: [0, 1, 2, 3] ``` Hints: To solve this problem, you may: 1. Use a priority queue to select the vertex with the smallest tentative distance. 2. Maintain a list to keep track of visited vertices. 3. Record the shortest distance to each vertex from the start vertex, updating them as shorter paths are discovered. 4. Use a backtracking mechanism to reconstruct the shortest path once the end vertex is reached.","solution":"import heapq def shortest_path(graph, start_index, end_index): Finds the shortest path in a weighted undirected graph using Dijkstra\'s algorithm. Parameters: graph (list[list[int]]): 2D list representing the adjacency matrix of the graph. start_index (int): The starting vertex. end_index (int): The target vertex. Returns: list[int]: The shortest path from start_index to end_index. # Number of vertices N = len(graph) # Distance and predecessor arrays dist = [float(\'inf\')] * N prev = [None] * N # Distance to the start vertex is 0 dist[start_index] = 0 # Priority queue to hold vertices to explore; initialized with the start vertex priority_queue = [(0, start_index)] while priority_queue: current_dist, current_vertex = heapq.heappop(priority_queue) # If we have reached the target vertex, stop searching if current_vertex == end_index: break # Iterate through the neighbors of the current vertex for neighbor, weight in enumerate(graph[current_vertex]): if weight > 0: # If there is an edge distance = current_dist + weight # Only consider this new path if it\'s better if distance < dist[neighbor]: dist[neighbor] = distance prev[neighbor] = current_vertex heapq.heappush(priority_queue, (distance, neighbor)) # To reconstruct the path from start_index to end_index path = [] current = end_index while current is not None: path.insert(0, current) current = prev[current] # If the target is unreachable, return an empty list if dist[end_index] == float(\'inf\'): return [] return path"},{"question":"# Problem Statement: You are provided with a list of words and a target word. Your task is to implement a function to find the shortest transformation sequence from the start word (first word in the list) to the target word (last word in the list), such that only one letter can be changed at a time and each transformed word must exist in the list. If no such transformation sequence exists, return an empty list. # Function Signature: ```python def shortest_word_transformation(words: List[str]) -> List[str]: Find the shortest transformation sequence from the start word to the target word. Args: words: List[str] : The list of words, where the first word is the starting word and the last word is the target word. Returns: List[str] : The shortest transformation sequence from the start word to the target word. If no such sequence exists, return an empty list. ``` # Input: * `words`: A list of strings where: * The first element is the start word. * The last element is the target word. * The list contains 1 to 50 words. * Each word consists of lowercase English letters and has a length between 1 and 10. # Output: * A list of strings representing the shortest transformation sequence from the start word to the target word. Each string in the list is one of the words from the input list. If no transformation sequence exists, return an empty list. # Constraints: * 1 <= len(words) <= 50 * 1 <= len(word) <= 10 * All words in the list are lowercase English letters. # Example: ```python words = [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] transformation_sequence = shortest_word_transformation(words) print(transformation_sequence) # should output the shortest transformation sequence, e.g., [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] words = [\\"hit\\", \\"hot\\", \\"dog\\", \\"cog\\"] transformation_sequence = shortest_word_transformation(words) print(transformation_sequence) # should output the shortest transformation sequence, e.g., [\\"hit\\", \\"hot\\", \\"dog\\", \\"cog\\"] words = [\\"start\\", \\"stark\\", \\"stack\\", \\"slack\\", \\"black\\", \\"blank\\"] transformation_sequence = shortest_word_transformation(words) print(transformation_sequence) # should output [\\"start\\", \\"stark\\", \\"stack\\", \\"slack\\", \\"black\\", \\"blank\\"] ``` # Notes: * The transformation sequence is shortest if it has the fewest number of intermediate words. * Each word can be used only once in the sequence, except for the start and target words (which naturally occur only once at the beginning and end, respectively).","solution":"from collections import deque from typing import List def shortest_word_transformation(words: List[str]) -> List[str]: Find the shortest transformation sequence from the start word to the target word. if not words or len(words) < 2: return [] start_word = words[0] target_word = words[-1] word_set = set(words) def one_letter_diff(w1: str, w2: str) -> bool: return sum(1 for a, b in zip(w1, w2) if a != b) == 1 queue = deque([(start_word, [start_word])]) while queue: current_word, path = queue.popleft() if current_word == target_word: return path for next_word in set(word_set): if one_letter_diff(current_word, next_word): queue.append((next_word, path + [next_word])) word_set.remove(next_word) return []"},{"question":"# Multi-Level Depth Traversal in a Tree **Scenario**: As a software engineer at a company developing a new data visualization tool, you are tasked with creating an algorithm that can efficiently traverse hierarchical data structures. One common structure used is a tree, which stores data in a parent-child relationship. Your goal is to implement a function that performs a multi-level depth traversal on a tree, aggregating nodes\' values at each depth into a nested list. The tree can be either a binary tree or a generic tree. Each node contains an integer value and has zero or more child nodes. **Task**: Write a function `depth_traversal` which takes the root of the tree and produces a nested list of node values. Each inner list corresponds to the collective values at a certain depth of the tree. # Function Signature ```python def depth_traversal(root: Optional[TreeNode]) -> list[list[int]]: pass ``` # Input - `root`: The root node of the tree, which may be `None` if the tree is empty. Each node in the tree has the following structure: ```python class TreeNode: def __init__(self, val=0, children=None): self.val = val self.children = children if children is not None else [] ``` # Output - A nested list where each inner list contains integer values corresponding to the nodes at each depth level of the tree. # Constraints 1. The number of nodes in the tree will be in the range [0, 10^5]. 2. Each node value is an integer in the range [-10^9, 10^9]. 3. The tree may contain duplicate values. 4. The tree can be a binary tree or a generic tree. # Examples ```python # Example 1: Generic Tree with three levels root = TreeNode(1, [TreeNode(2, [TreeNode(4), TreeNode(5)]), TreeNode(3)]) print(depth_traversal(root)) # Output: [[1], [2, 3], [4, 5]] # Example 2: Single node tree root = TreeNode(7) print(depth_traversal(root)) # Output: [[7]] # Example 3: Empty tree root = None print(depth_traversal(root)) # Output: [] ``` # Evaluation Criteria 1. **Accuracy**: Correctly produces the nested list of node values for each depth level. 2. **Efficiency**: Able to handle the upper constraint of 100,000 nodes without performance issues. 3. **Robustness**: Handles edge cases effectively, including empty trees and trees with a single node. 4. **Clarity**: Code is well-structured and easily comprehensible. **Note**: Thorough internal comments explaining the logic of your traversal approach will be appreciated.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, children=None): self.val = val self.children = children if children is not None else [] def depth_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] # Output result variable result = [] # Current level nodes queue current_level = [root] while current_level: # Collecting the values of the current level level_values = [node.val for node in current_level] result.append(level_values) # Preparing for the next level next_level = [] for node in current_level: next_level.extend(node.children) # Add all children nodes to the queue current_level = next_level return result"},{"question":"# Array Rotation **Objective**: Implement a function that rotates an array to the right by a given number of steps, handling edge cases such as empty arrays and rotations greater than the array size. **Function Signature**: ```python def rotate_array(nums: list[int], k: int) -> list[int]: Rotates the array nums to the right by k steps. Args: nums (list[int]): The input array that needs to be rotated. k (int): The number of steps to rotate the array. Returns: list[int]: The rotated array. ``` **Input**: - A list of integers `nums` (0 ≤ len(nums) ≤ 10^5). - An integer `k` (0 ≤ k ≤ 10^5). **Output**: - A list of integers representing the array after being rotated. **Constraints**: - The input list can contain duplicates. - If `k` is greater than the length of the array, it should be handled by taking `k % len(nums)` rotations instead. **Example**: ```python nums = [1, 2, 3, 4, 5, 6, 7] k = 3 result = rotate_array(nums, k) # Expected Output: [5, 6, 7, 1, 2, 3, 4] nums = [1, 2, 3, 4, 5, 6, 7] k = 10 result = rotate_array(nums, k) # Expected Output: [5, 6, 7, 1, 2, 3, 4] ``` **Scenario**: You are given a problem where you need to rotate a list to the right by a given number of steps. For instance, given an array of integers, you need to rotate it such that elements move from the end to the beginning. This can be useful in various programming applications, ranging from data rearrangement to implementing certain algorithms that require positional adjustment of elements. **Performance Requirement**: - The solution should efficiently handle large input sizes, ensuring the operation runs within acceptable time limits for up to the maximum constraints. **Testing**: 1. Rotating an array where the number of rotations is much larger than the array size. 2. An empty array or an array with one element. 3. An array containing negative numbers and duplicates.","solution":"def rotate_array(nums: list[int], k: int) -> list[int]: Rotates the array nums to the right by k steps. Args: nums (list[int]): The input array that needs to be rotated. k (int): The number of steps to rotate the array. Returns: list[int]: The rotated array. # Edge case: If the array is empty or has only one element, no rotation is needed. if not nums or len(nums) == 1: return nums n = len(nums) k = k % n # In case k is larger than the array length # Rotate the array by slicing it return nums[-k:] + nums[:-k]"},{"question":"# **Coding Assessment Question** **String Parsing and Manipulation** In this task, you are required to implement functionalities to analyze and process strings using a `TextProcessor` class. The objective is to demonstrate your competence in string manipulation, parsing, and handling edge cases by completing the methods as specified below. **Task** 1. **Word Count Method**: Implement a method `word_count` to return a dictionary where the keys are words and the values are the number of occurrences of those words in the input text. ```python def word_count(self) -> dict: Return a dictionary with words as keys and their count of occurrences as values. >>> TextProcessor(\\"hello world hello\\").word_count() {\'hello\': 2, \'world\': 1} >>> TextProcessor(\\"\\").word_count() {} >>> TextProcessor(\\"a a a b b c\\").word_count() {\'a\': 3, \'b\': 2, \'c\': 1} # Implement the method here ``` 2. **Longest Word Method**: Implement a method `longest_word` to return the longest word in the text. If there are multiple words of the same length, return the one that appears first. ```python def longest_word(self) -> str: Return the longest word in the text. If multiple words are found with the same length, return the first found. >>> TextProcessor(\\"a abc abcde\\").longest_word() \'abcde\' >>> TextProcessor(\\"this is a test longestword\\").longest_word() \'longestword\' >>> TextProcessor(\\"\\").longest_word() \'\' # Implement the method here ``` 3. **Most Common Character Method**: Implement a method `most_common_char` to return the most common character in the text. Ignore spaces and return the alphabetically first character in case of a tie in frequency. ```python def most_common_char(self) -> str: Return the most common character in the text ignoring spaces. In case of a tie, return the alphabetically first character. >>> TextProcessor(\\"hello world\\").most_common_char() \'l\' >>> TextProcessor(\\"abc abc\\").most_common_char() \'a\' >>> TextProcessor(\\"\\").most_common_char() \'\' # Implement the method here ``` **Function Signature** ```python class TextProcessor: def __init__(self, text: str): self.text = text def word_count(self) -> dict: # Implement here pass def longest_word(self) -> str: # Implement here pass def most_common_char(self) -> str: # Implement here pass ``` **Input and Output Formats** * The `word_count` method should return a dictionary with words as keys and their respective counts as values. * The `longest_word` method should return a string representing the longest word in the text. * The `most_common_char` method should return a character representing the most commonly occurring character in the text, excluding spaces. **Constraints/Limitations** * The input text may contain letters (both uppercase and lowercase), digits, spaces, and punctuation. * The methods should handle edge cases gracefully, such as an empty string or text with no valid words or characters. * Ensure efficient processing of the text for potentially large inputs.","solution":"class TextProcessor: def __init__(self, text: str): self.text = text def word_count(self) -> dict: Return a dictionary with words as keys and their count of occurrences as values. words = self.text.split() word_count_dict = {} for word in words: word_count_dict[word] = word_count_dict.get(word, 0) + 1 return word_count_dict def longest_word(self) -> str: Return the longest word in the text. If multiple words are found with the same length, return the first found. words = self.text.split() if not words: return \\"\\" longest = words[0] for word in words: if len(word) > len(longest): longest = word return longest def most_common_char(self) -> str: Return the most common character in the text ignoring spaces. In case of a tie, return the alphabetically first character. from collections import Counter text_without_spaces = self.text.replace(\\" \\", \\"\\") if not text_without_spaces: return \\"\\" char_count = Counter(text_without_spaces) most_common = min(char_count.items(), key=lambda item: (-item[1], item[0])) return most_common[0]"},{"question":"# Question You are asked to write a function that rotates a given square matrix 90 degrees clockwise in-place. A matrix rotation in-place means you cannot use any extra space; just modify the input matrix to achieve the desired rotation. Your function should adhere to the following specifications: **Function Signature:** ```python def rotate_matrix(matrix: List[List[int]]) -> None: ``` **Input:** - `matrix` (List[List[int]]): A 2D square matrix of integers (where 1 ≤ len(matrix) ≤ 20). **Output:** - The function should not return anything; it should modify the input matrix in-place. **Example:** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # After the function call, the matrix should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) # After the function call, the matrix should be: # [ # [3, 1], # [4, 2] # ] ``` **Constraints and Notes:** - The rotation must be achieved strictly in place, altering the input matrix directly. - The length of the matrix sides will be between 1 and 20, inclusive. - Consider the transpose of the matrix followed by a reflection to achieve the rotation efficiently. - Ensure that your solution handles edge cases such as a 1x1 matrix. # Evaluation Criteria: - Correctness and robustness of the rotation transformation. - Efficiency in achieving the rotation without additional space. - Clarity and maintainability of the code.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given square matrix 90 degrees clockwise in-place. # Step 1: Transpose the matrix (swap rows with columns) n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reflect the matrix horizontally (reverse each row) for i in range(n): matrix[i].reverse()"},{"question":"# Question You are supposed to implement a text processing function that highlights the keyword occurrences within sentences. This method takes a sentence and a list of keywords, and then marks any occurrence of each keyword within the sentence by enclosing it with square brackets. # Requirements Your function should: 1. Iterate through each word in the sentence. 2. Check if the word is one of the provided keywords. 3. Enclose the keyword with square brackets if it is found in the sentence. # Function Signature ```python def highlight_keywords(sentence: str, keywords: list) -> str: Highlight keywords in a sentence by enclosing them with square brackets. :param sentence: A string representing the sentence to process :param keywords: A list of strings representing the keywords to highlight :return: A string with keywords highlighted pass ``` # Input * `sentence` (str): A string containing the sentence to be processed. * `keywords` (list): A list containing the keywords to highlight in the sentence. # Output * Returns a string where each keyword occurrence in the sentence is enclosed with square brackets. # Constraints * The sentence will be a non-empty string consisting of alphanumeric characters and spaces. * The keywords list will contain only words consisting of alphanumeric characters and will be non-empty. * The case of the words should not matter; treat all words as case-insensitive during the match, but preserve the original case in the output. # Example Scenario Given the sentence \\"The quick brown fox jumps over the lazy dog\\" and the keywords [\\"quick\\", \\"fox\\"], the function should return \\"The [quick] brown [fox] jumps over the lazy dog\\".","solution":"def highlight_keywords(sentence: str, keywords: list) -> str: Highlight keywords in a sentence by enclosing them with square brackets. :param sentence: A string representing the sentence to process :param keywords: A list of strings representing the keywords to highlight :return: A string with keywords highlighted words = sentence.split() lower_keywords = [keyword.lower() for keyword in keywords] highlighted_sentence = [] for word in words: if word.lower() in lower_keywords: highlighted_sentence.append(f\'[{word}]\') else: highlighted_sentence.append(word) return \' \'.join(highlighted_sentence)"},{"question":"# Neural Network from Scratch Your task is to implement a simple feedforward neural network from scratch, using only Python\'s standard libraries. This network will perform binary classification on a provided dataset. The neural network will have one input layer, one hidden layer, and one output layer with the following functions: Function Signatures: 1. `def sigmoid(x: float) -> float:` - **Input**: - `x`: a float representing the input value. - **Output**: - The result of the sigmoid activation function applied to `x`. 2. `def sigmoid_derivative(x: float) -> float:` - **Input**: - `x`: a float representing the input value. - **Output**: - The derivative of the sigmoid function at `x`. 3. `def initialize_weights(input_size: int, hidden_size: int) -> tuple[np.array, np.array]:` - **Input**: - `input_size`: an integer representing the number of input neurons. - `hidden_size`: an integer representing the number of hidden neurons. - **Output**: - Two numpy arrays representing the initialized weights for the input-to-hidden and hidden-to-output layers. 4. `def forward_propagation(inputs: np.array, weights_input_hidden: np.array, weights_hidden_output: np.array) -> tuple[np.array, np.array, np.array]:` - **Input**: - `inputs`: a numpy array of input data. - `weights_input_hidden`: a numpy array containing weights from input to hidden layer. - `weights_hidden_output`: a numpy array containing weights from hidden to output layer. - **Output**: - Three numpy arrays representing the outputs of the hidden layer, and the final network outputs, and the inputs to the hidden layer (for use in backpropagation). 5. `def back_propagation(inputs: np.array, hidden_outputs: np.array, final_outputs: np.array, expected_outputs: np.array, weights_input_hidden: np.array, weights_hidden_output: np.array, learning_rate: float) -> tuple[np.array, np.array]:` - **Input**: - `inputs`: a numpy array of input data. - `hidden_outputs`: a numpy array containing the outputs of the hidden layer. - `final_outputs`: a numpy array containing the final output of the network. - `expected_outputs`: a numpy array containing expected outputs (targets). - `weights_input_hidden`: a numpy array containing weights from input to hidden layer. - `weights_hidden_output`: a numpy array containing weights from hidden to output layer. - `learning_rate`: a float representing the learning rate for weight updates. - **Output**: - Two numpy arrays representing the updated weights for both layers. 6. `def train_neural_network(inputs: np.array, expected_outputs: np.array, input_size: int, hidden_size: int, learning_rate: float, epochs: int) -> tuple[np.array, np.array]:` - **Input**: - `inputs`: a numpy array of input data. - `expected_outputs`: a numpy array containing expected outputs (targets). - `input_size`: an integer representing the number of input neurons. - `hidden_size`: an integer representing the number of hidden neurons. - `learning_rate`: a float representing the learning rate for weight updates. - `epochs`: an integer representing the number of training iterations. - **Output**: - Two numpy arrays representing the trained weights for both layers. 7. `def predict(inputs: np.array, weights_input_hidden: np.array, weights_hidden_output: np.array) -> np.array:` - **Input**: - `inputs`: a numpy array of input data. - `weights_input_hidden`: a numpy array containing weights from input to hidden layer. - `weights_hidden_output`: a numpy array containing weights from hidden to output layer. - **Output**: - A numpy array representing the predicted outputs of the neural network. Constraints: - The input dataset can have features up to 50. - The hidden layer should have between 5 to 20 neurons. - The training should run for a maximum of 10,000 epochs. Example: ```python import numpy as np # Example dataset inputs = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) outputs = np.array([[0], [1], [1], [0]]) # Training the network input_size = 2 hidden_size = 5 learning_rate = 0.1 epochs = 5000 weights_input_hidden, weights_hidden_output = train_neural_network(inputs, outputs, input_size, hidden_size, learning_rate, epochs) # Predicting for i in inputs: print(f\\"Input: {i} - Predicted: {predict(i, weights_input_hidden, weights_hidden_output)}\\") ``` Notes: - The `train_neural_network` function should initialize weights, perform forward and backward propagation in each epoch, and update weights accordingly. - Make sure to use the appropriate activation function (sigmoid) and its derivative during propagation. - Ensure that the final implementation is efficient and handles edge cases where input values may be either zero or one.","solution":"import numpy as np def sigmoid(x: float) -> float: Sigmoid activation function. return 1 / (1 + np.exp(-x)) def sigmoid_derivative(x: float) -> float: Derivative of the sigmoid function. return x * (1 - x) def initialize_weights(input_size: int, hidden_size: int) -> tuple: Initialize weights for the neural network. weights_input_hidden = np.random.uniform(size=(input_size, hidden_size)) weights_hidden_output = np.random.uniform(size=(hidden_size, 1)) return weights_input_hidden, weights_hidden_output def forward_propagation(inputs: np.array, weights_input_hidden: np.array, weights_hidden_output: np.array) -> tuple: Perform forward propagation. hidden_inputs = np.dot(inputs, weights_input_hidden) hidden_outputs = sigmoid(hidden_inputs) final_inputs = np.dot(hidden_outputs, weights_hidden_output) final_outputs = sigmoid(final_inputs) return hidden_outputs, final_outputs, hidden_inputs def back_propagation(inputs: np.array, hidden_outputs: np.array, final_outputs: np.array, expected_outputs: np.array, weights_input_hidden: np.array, weights_hidden_output: np.array, learning_rate: float) -> tuple: Perform backpropagation and update weights. final_error = expected_outputs - final_outputs final_delta = final_error * sigmoid_derivative(final_outputs) hidden_error = final_delta.dot(weights_hidden_output.T) hidden_delta = hidden_error * sigmoid_derivative(hidden_outputs) weights_hidden_output += hidden_outputs.T.dot(final_delta) * learning_rate weights_input_hidden += inputs.T.dot(hidden_delta) * learning_rate return weights_input_hidden, weights_hidden_output def train_neural_network(inputs: np.array, expected_outputs: np.array, input_size: int, hidden_size: int, learning_rate: float, epochs: int) -> tuple: Train the neural network. weights_input_hidden, weights_hidden_output = initialize_weights(input_size, hidden_size) for epoch in range(epochs): hidden_outputs, final_outputs, hidden_inputs = forward_propagation(inputs, weights_input_hidden, weights_hidden_output) weights_input_hidden, weights_hidden_output = back_propagation( inputs, hidden_outputs, final_outputs, expected_outputs, weights_input_hidden, weights_hidden_output, learning_rate ) return weights_input_hidden, weights_hidden_output def predict(inputs: np.array, weights_input_hidden: np.array, weights_hidden_output: np.array) -> np.array: Predict output for given input. _, final_outputs, _ = forward_propagation(inputs, weights_input_hidden, weights_hidden_output) return final_outputs"},{"question":"# Problem Scenario You are working on a warehouse management system that needs to keep track of the inventory levels of various items. The system should be able to handle multiple operations such as adding new items, increasing the stock of existing items, decreasing the stock, and generating a report of the current inventory. Implement a system that supports these operations efficiently. # Function Implementations Implement the following functions: 1. **add_item(inventory: Dict[str, int], item: str, quantity: int) -> None** - Input: A dictionary representing the current inventory, a string representing the item name, and an integer representing the quantity of the item. - Output: None. The function should add the item to the inventory with the given quantity. If the item already exists, it should increase the quantity by the given amount. 2. **remove_item(inventory: Dict[str, int], item: str, quantity: int) -> bool** - Input: A dictionary representing the current inventory, a string representing the item name, and an integer representing the quantity of the item. - Output: A boolean indicating whether the operation was successful. If the item does not exist or if the quantity to be removed is greater than the available quantity, return False. Otherwise, decrease the inventory and return True. 3. **generate_report(inventory: Dict[str, int]) -> str** - Input: A dictionary representing the current inventory. - Output: A string representing the inventory report, where each item is listed in alphabetical order followed by its quantity, one item per line. # Constraints - The number of inventory operations can range from 1 to (10^4). - The item names are non-empty strings containing only alphabetic characters and have a maximum length of 50. - Quantities are positive integers and will not exceed (10^6). # Example ```python # Example Usage: inventory = {} add_item(inventory, \\"apple\\", 50) add_item(inventory, \\"banana\\", 100) add_item(inventory, \\"apple\\", 25) remove_item(inventory, \\"banana\\", 30) report = generate_report(inventory) assert inventory == { \\"apple\\": 75, \\"banana\\": 70 } assert report == \\"apple: 75nbanana: 70\\" assert remove_item(inventory, \\"banana\\", 80) == False print(\\"Inventory operations were successful!\\") ``` # Notes - Ensure to handle edge cases, such as attempting to remove an item that does not exist or attempting to remove more quantity than available. - The implementation should efficiently handle multiple operations and maintain the inventory.","solution":"def add_item(inventory, item, quantity): Adds the specified quantity of the item to the inventory. If the item already exists, increases the quantity by the given amount. if item in inventory: inventory[item] += quantity else: inventory[item] = quantity def remove_item(inventory, item, quantity): Removes the specified quantity of the item from the inventory. Returns True if the operation was successful, False otherwise. if item not in inventory or inventory[item] < quantity: return False inventory[item] -= quantity if inventory[item] == 0: del inventory[item] return True def generate_report(inventory): Generates a report of the current inventory. Each item is listed in alphabetical order followed by its quantity, one item per line. report_lines = [f\\"{item}: {quantity}\\" for item, quantity in sorted(inventory.items())] return \\"n\\".join(report_lines)"},{"question":"# Context You are tasked with developing a sorting algorithm that sorts a list of integers. The algorithm must not only sort the elements in ascending order but also group the elements with the same value together. This is a specialized version of a sorting function that ensures values appearing multiple times are kept together. # Task Implement a function `group_and_sort` that performs the sorting of a list of integers while grouping identical elements together. Your function should handle the following operations: * Validate the input list. * Sort the integers in ascending order. * Group together integers that have the same value. # Requirements * **Input**: * `numbers` (list): A list of integers which may contain duplicates. * **Output**: * A list of integers sorted in ascending order, with identical elements grouped together. * **Constraints**: * The input list may contain any number of integers, including duplicates or none. * The integers in the input list can be positive, negative, or zero. * **Performance**: The function should run in O(n log n) time complexity. # Example ```python def group_and_sort(numbers: list) -> list: Sorts a list of integers in ascending order and groups identical elements together. Parameters: numbers : list: A list of integers which may contain duplicates. Returns: list: A list of integers sorted in ascending order, with identical elements grouped together. Raises: ValueError: If `numbers` is not a list. Example: >>> group_and_sort([4, 5, 2, 3, 2, 4]) [2, 2, 3, 4, 4, 5] >>> group_and_sort([0, -1, 3, -1, 3, 0]) [-1, -1, 0, 0, 3, 3] >>> group_and_sort([5]) [5] >>> group_and_sort([]) [] # Your implementation here pass # Test cases print(group_and_sort([4, 5, 2, 3, 2, 4])) # Output: [2, 2, 3, 4, 4, 5] print(group_and_sort([0, -1, 3, -1, 3, 0])) # Output: [-1, -1, 0, 0, 3, 3] print(group_and_sort([7, 3, 3, 7, 8, 1])) # Output: [1, 3, 3, 7, 7, 8] print(group_and_sort([])) # Output: [] ```","solution":"def group_and_sort(numbers: list) -> list: Sorts a list of integers in ascending order and groups identical elements together. Parameters: numbers : list: A list of integers which may contain duplicates. Returns: list: A list of integers sorted in ascending order, with identical elements grouped together. Raises: ValueError: If `numbers` is not a list. if not isinstance(numbers, list): raise ValueError(\\"Input must be a list\\") return sorted(numbers)"},{"question":"# Coding Assessment Question Problem Statement You are tasked with developing a function that calculates the half-life of a radioactive substance based on its decay constant. Currently, functions are provided to determine the initial quantity and the remaining quantity of a substance after a given amount of time has passed. Your objective is to implement an additional function to calculate the half-life of the substance using its decay constant. Detailed Description * **Function Name**: `calculate_half_life` * **Inputs**: * `decay_constant` (float): The decay constant of the substance (in s^-1). * **Output**: * Returns the half-life of the substance (in seconds). * **Constraints**: * Decay constant `decay_constant` must be positive. * Raise appropriate exceptions with helpful error messages if the constraints are violated. Formulas The half-life (T) is calculated by: [ T = frac{ln(2)}{lambda} ] Where: * (ln) is the natural logarithm. * (lambda) is the decay constant. Example ```python >>> calculate_half_life(0.0001) 6931.471805599453 >>> calculate_half_life(0.005) 138.62943611198905 >>> calculate_half_life(0) Traceback (most recent call last): ... Exception: Decay constant should be greater than 0 >>> calculate_half_life(-0.01) Traceback (most recent call last): ... Exception: Decay constant should be greater than 0 ``` Implementation Implement the function in Python, structured as follows: ```python from math import log def calculate_half_life(decay_constant: float) -> float: Takes the decay constant (in s^-1) of a radioactive substance and returns its half-life (in seconds). Examples: >>> calculate_half_life(0.0001) 6931.471805599453 >>> calculate_half_life(0.005) 138.62943611198905 >>> calculate_half_life(0) Traceback (most recent call last): ... Exception: Decay constant should be greater than 0 >>> calculate_half_life(-0.01) Traceback (most recent call last): ... Exception: Decay constant should be greater than 0 if decay_constant <= 0: raise Exception(\\"Decay constant should be greater than 0\\") return log(2) / decay_constant ```","solution":"from math import log def calculate_half_life(decay_constant: float) -> float: Takes the decay constant (in s^-1) of a radioactive substance and returns its half-life (in seconds). Examples: >>> calculate_half_life(0.0001) 6931.471805599453 >>> calculate_half_life(0.005) 138.62943611198905 >>> calculate_half_life(0) Traceback (most recent call last): ... Exception: Decay constant should be greater than 0 >>> calculate_half_life(-0.01) Traceback (most recent call last): ... Exception: Decay constant should be greater than 0 if decay_constant <= 0: raise Exception(\\"Decay constant should be greater than 0\\") return log(2) / decay_constant"},{"question":"# Task Implement a function to simulate a simple social media platform where users can follow each other and posts can be made. We want to retrieve the 10 most recent posts in the news feed for a user, prioritizing posts from people they follow. # Function Signature ```python class SocialMediaPlatform: def __init__(self): pass def follow(self, user: int, followee: int) -> None: pass def unfollow(self, user: int, followee: int) -> None: pass def post(self, user: int, post_id: int) -> None: pass def get_news_feed(self, user: int) -> list: pass ``` # Requirements 1. **Initialization**: - The constructor initializes the platform with no users or posts. 2. **Follow**: - Allows a user to follow another user. - Should handle the case where users follow or unfollow themselves if specified (up to the specific platform rules). 3. **Unfollow**: - Allows a user to unfollow another user. - Should handle the case where users try to unfollow someone they are not following without errors. 4. **Post**: - Allows a user to create a post with a unique `post_id`. - Posts should be timestamped internally to maintain order. 5. **Get News Feed**: - Retrieves the 10 most recent post IDs combined from the user and all users they follow. - Posts should be sorted by their timestamp, most recent first. - If fewer than 10 posts are available, retrieve as many as possible. # Example Usage ```python smp = SocialMediaPlatform() smp.post(1, 101) smp.post(1, 102) smp.post(2, 201) smp.follow(1, 2) smp.post(2, 202) smp.post(1, 103) print(smp.get_news_feed(1)) # Should display posts with IDs: [103, 202, 102, 101] smp.unfollow(1, 2) print(smp.get_news_feed(1)) # Should display posts with IDs: [103, 102, 101] ``` # Constraints and Limits - Users are represented by unique integers. - Posts are represented by unique integers (`post_id`). - Users should be able to follow/unfollow, such that followers and followees lists are maintained correctly. - The `get_news_feed` method should prioritize recent posts and handle up to `N` users efficiently. - Assume a maximum of 10,000 users and up to 1,000,000 posts can be handled, ensuring the program can scale appropriately.","solution":"from collections import defaultdict, deque import heapq import time class SocialMediaPlatform: def __init__(self): self.followees = defaultdict(set) self.posts = defaultdict(deque) self.timestamp = 0 def follow(self, user: int, followee: int) -> None: if user != followee: self.followees[user].add(followee) def unfollow(self, user: int, followee: int) -> None: self.followees[user].discard(followee) def post(self, user: int, post_id: int) -> None: self.posts[user].appendleft((self.timestamp, post_id)) self.timestamp += 1 def get_news_feed(self, user: int) -> list: min_heap = [] users_to_check = self.followees[user] | {user} for u in users_to_check: for post in list(self.posts[u])[:10]: if len(min_heap) < 10: heapq.heappush(min_heap, post) else: heapq.heappushpop(min_heap, post) return [post_id for _, post_id in sorted(min_heap, reverse=True)]"},{"question":"# Question: Lowest Common Ancestor in a Binary Tree You are working as a software engineer for a company that specializes in genetic research. You are developing a software tool to analyze the relationships in a binary tree structure representing gene evolution. Your task is to write a function that finds the lowest common ancestor (LCA) of two given nodes in a binary tree. **Function Specification** **Function Name**: `find_lca` **Parameters**: - `root` (TreeNode): The root node of the binary tree. - `node1` (TreeNode): The first node. - `node2` (TreeNode): The second node. **Output**: - Returns the lowest common ancestor node of the two given nodes. **Constraints**: - The binary tree can have at most 1000 nodes. - All node values are unique. - Both `node1` and `node2` are guaranteed to exist in the binary tree. **Performance Requirements**: - The algorithm should run in linear time O(n) relative to the number of nodes in the tree. **Example Usage**: Consider the following binary tree structure: ``` 3 / 5 1 / / 6 2 0 8 / 7 4 ``` ```python >>> root = TreeNode(3) >>> node5 = TreeNode(5) >>> node1 = TreeNode(1) >>> root.left = node5 >>> root.right = node1 >>> node5.left = TreeNode(6) >>> node5.right = TreeNode(2) >>> node1.left = TreeNode(0) >>> node1.right = TreeNode(8) >>> node5.right.left = TreeNode(7) >>> node5.right.right = TreeNode(4) >>> find_lca(root, node5, node1).val 3 >>> find_lca(root, node5, TreeNode(4)).val 5 >>> find_lca(root, TreeNode(6), TreeNode(4)).val 5 ``` **Implementation**: Write a function that uses a recursive approach to determine the lowest common ancestor of two nodes in a binary tree. The function should be able to handle the case where the two nodes are deep within the tree or where one is the ancestor of the other. **Error Handling**: - If the root is `None`, the function should return `None`. ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root, node1, node2): if root is None: return None if root == node1 or root == node2: return root left_lca = find_lca(root.left, node1, node2) right_lca = find_lca(root.right, node1, node2) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lca(root, node1, node2): Returns the lowest common ancestor (LCA) of node1 and node2 in the binary tree rooted at root. if root is None: return None if root == node1 or root == node2: return root left_lca = find_lca(root.left, node1, node2) right_lca = find_lca(root.right, node1, node2) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca"},{"question":"# Image Processing Filter Application You are required to implement a function that applies a specified filter to an image in order to process it. The function should read the image file, apply the filter, and save the processed image with a new filename indicating the applied filter. Objective: Create the `apply_filter` function to: * Open an image from the file system. * Apply the specified filter to the image. * Save the filtered image with a filename that includes the filter name. Function Signature: ```python def apply_filter(image_path: str, filter_name: str) -> str: Applies the specified filter to the image and saves the new image with the filter name appended to the filename. Args: - image_path: str: Path to the input image file. - filter_name: str: The name of the filter to apply (e.g., \\"blur\\", \\"grayscale\\", \\"edge_enhance\\"). Returns: - str: The file name of the saved filtered image. ``` Input: * `image_path` (str): A string representing the file path to the image. * `filter_name` (str): A string representing the name of the filter to apply. Valid filters include \\"blur\\", \\"grayscale\\", and \\"edge_enhance\\". Output: * A string representing the filename of the filtered image, formatted as \\"original_filename_filtername.extension\\". Constraints: * The image file must exist and be a valid image format (e.g., JPEG, PNG). * The function should handle invalid filter names by raising an appropriate exception. * The function should use image processing libraries like PIL (Pillow). Example Usage: ```python from PIL import Image, ImageFilter def apply_filter(image_path: str, filter_name: str) -> str: try: # Open the image img = Image.open(image_path) # Apply the specified filter if filter_name == \'blur\': img = img.filter(ImageFilter.BLUR) elif filter_name == \'grayscale\': img = img.convert(\'L\') elif filter_name == \'edge_enhance\': img = img.filter(ImageFilter.EDGE_ENHANCE) else: raise ValueError(\\"Invalid filter name provided\\") # Prepare the new filename filename_parts = image_path.split(\'.\') new_filename = f\\"{\'\'.join(filename_parts[:-1])}_{filter_name}.{filename_parts[-1]}\\" # Save the new image img.save(new_filename) return new_filename except Exception as e: raise e try: filtered_image_name = apply_filter(\\"example.jpg\\", \\"grayscale\\") print(f\\"Image successfully processed and saved as {filtered_image_name}.\\") except Exception as e: print(f\\"Failed to process image: {e}\\") ``` Performance: - Ensure efficient processing of images without excessive memory usage. - Handle large images gracefully and optimize for speed. # Additional Notes: - Use the `PIL` library (Pillow) to manage image loading, processing, and saving. - Ensure that appropriate error handling is in place for missing files or incorrect file paths.","solution":"from PIL import Image, ImageFilter def apply_filter(image_path: str, filter_name: str) -> str: Applies the specified filter to the image and saves the new image with the filter name appended to the filename. Args: - image_path: str: Path to the input image file. - filter_name: str: The name of the filter to apply (e.g., \\"blur\\", \\"grayscale\\", \\"edge_enhance\\"). Returns: - str: The file name of the saved filtered image. try: # Open the image img = Image.open(image_path) # Apply the specified filter if filter_name == \'blur\': img = img.filter(ImageFilter.BLUR) elif filter_name == \'grayscale\': img = img.convert(\'L\') elif filter_name == \'edge_enhance\': img = img.filter(ImageFilter.EDGE_ENHANCE) else: raise ValueError(\\"Invalid filter name provided\\") # Prepare the new filename filename_parts = image_path.rsplit(\'.\', 1) new_filename = f\\"{filename_parts[0]}_{filter_name}.{filename_parts[1]}\\" # Save the new image img.save(new_filename) return new_filename except Exception as e: raise e"},{"question":"# Problem Statement: Lois is an internationally recognized string artist who creates unique art from well-structured strings. She wants to automate parts of her process and needs your help by writing a program that determines if a string can be segmented into a sequence of dictionary words. # Requirements: 1. Implement the following function: - `word_break(s: str, word_dict: list) -> bool` 2. The functions should: - Take a string `s` and a list of words `word_dict` as input. - Return `True` if `s` can be segmented into a sequence of one or more dictionary words from `word_dict`, otherwise return `False`. # Input: - A string `s` containing lowercase English letters (1 ≤ |s| ≤ 300). - A list of strings `word_dict` containing lowercase English words (1 ≤ |word_dict| ≤ 1000 and 1 ≤ |word| ≤ 20 for each word in the dictionary). # Output: - A boolean value: `True` if the string can be segmented into one or more dictionary words, and `False` otherwise. # Example: ```plaintext word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) Expected Output: True word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) Expected Output: True word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) Expected Output: False word_break(\\"aaaaaaa\\", [\\"aaa\\", \\"aaaa\\"]) Expected Output: True ``` # Notes: - The input `s` consists of only lowercase English letters. - All words in the `word_dict` are unique. - You can assume that `word_dict` does not contain any redundant words. - Aim for a solution with optimal time complexity for the given constraints. The provided problem requires you to understand algorithms such as dynamic programming to efficiently solve whether the input string `s` can be segmented into a sequence of dictionary words.","solution":"def word_break(s: str, word_dict: list) -> bool: Determines if the string s can be segmented into a sequence of one or more dictionary words. word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"**Objective**: To practice implementing custom data structures and algorithms with a focus on tree traversal and manipulation. **Binary Search Tree (BST) Operations**: Implement a Python class `BinarySearchTree` that supports basic operations such as insertion, deletion, search, and traversal in a Binary Search Tree. Additionally, provide functionality to find the Lowest Common Ancestor (LCA) of two nodes in the tree. # Tasks 1. **insert**: Write a method `insert` that takes in a single parameter `val` (an integer value) and inserts it into the BST. If the value already exists in the tree, ignore the insertion. 2. **delete**: Write a method `delete` that accepts a single parameter `val` (an integer). It should delete the node with the given value from the BST and maintain the properties of the BST. If the value is not found in the tree, do nothing. 3. **search**: Write a method `search` that accepts a single parameter `val` (an integer) and returns `True` if the value exists in the BST, otherwise `False`. 4. **inorder_traversal**: Write a method `inorder_traversal` that returns a list of all elements in the BST in in-order sequence. 5. **find_lca**: Write a method `find_lca` that takes in two parameters, `val1` and `val2` (both integers), and returns the value of the Lowest Common Ancestor (LCA) of the nodes containing these values. If either value does not exist in the tree, return `None`. # Specifications - Class should handle the creation and manipulation of nodes internally. - Assume all values are unique within the BST. - Develop a simple `__main__` method to demonstrate the usage of your class and methods. # Example ```python # Example usage bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(18) print(bst.inorder_traversal()) # Output: [3, 5, 7, 10, 12, 15, 18] print(bst.search(7)) # Output: True print(bst.search(8)) # Output: False bst.delete(5) print(bst.inorder_traversal()) # Output: [3, 7, 10, 12, 15, 18] print(bst.find_lca(3, 7)) # Output: 10 print(bst.find_lca(12, 18)) # Might Output: 15 ``` # Constraints: - Assume all node values are integers. - The values can be any integer within the range of Python\'s `int`. - The BST will not contain duplicate values. **Note**: Focus on the accuracy of BST properties and ensure your methods handle edge cases, such as deletion of a node with one or two children and finding LCA when one or both values are not present in the tree.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = Node(val) else: self._insert(self.root, val) def _insert(self, root, val): if val < root.val: if root.left is None: root.left = Node(val) else: self._insert(root.left, val) elif val > root.val: if root.right is None: root.right = Node(val) else: self._insert(root.right, val) def delete(self, val): self.root = self._delete(self.root, val) def _delete(self, root, val): if root is None: return root if val < root.val: root.left = self._delete(root.left, val) elif val > root.val: root.right = self._delete(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left min_val_node = self._get_min(root.right) root.val = min_val_node.val root.right = self._delete(root.right, min_val_node.val) return root def _get_min(self, root): current = root while current.left is not None: current = current.left return current def search(self, val): return self._search(self.root, val) def _search(self, root, val): if root is None: return False if val == root.val: return True elif val < root.val: return self._search(root.left, val) else: return self._search(root.right, val) def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, root, result): if root: self._inorder_traversal(root.left, result) result.append(root.val) self._inorder_traversal(root.right, result) def find_lca(self, val1, val2): return self._find_lca(self.root, val1, val2) def _find_lca(self, root, val1, val2): if root is None: return None if val1 < root.val and val2 < root.val: return self._find_lca(root.left, val1, val2) if val1 > root.val and val2 > root.val: return self._find_lca(root.right, val1, val2) if self._search(root, val1) and self._search(root, val2): return root.val else: return None"},{"question":"# Context: You\'re working on a text processing library that requires efficient and customizable string matching capabilities. To enhance the library, you need to implement a new feature that allows users to match strings using a specified pattern with optional wildcards. # Task: Develop a function `match_pattern` that takes a string and a pattern as input and returns a boolean indicating whether the string matches the pattern. The pattern string can contain two special characters: - `?` which matches any single character. - `*` which matches any sequence of characters (including an empty sequence). # Requirements: 1. **Function Implementation:** - Implement the `match_pattern` function to correctly interpret and apply `?` and `*` within the pattern. - Ensure that the function handles edge cases, such as empty strings or patterns beginning or ending with `*`. 2. **Efficiency:** - Aim for an efficient solution, avoiding unnecessary computations. 3. **Testing:** - Write tests to validate the correctness of your implementation with a variety of cases, including edge cases. **Input and Output formats:** - **Input:** A string `s` and a pattern `p`. - **Output:** A boolean value indicating whether the string `s` matches the pattern `p`. **Constraints:** - The length of the input string `s` and the pattern `p` will not exceed 1000 characters each. - The pattern `p` will only contain lowercase letters and the special characters `?` and `*`. # Example: ```python assert match_pattern(\\"abcdef\\", \\"a*e?\\") == False assert match_pattern(\\"abcdef\\", \\"a*d?f\\") == True assert match_pattern(\\"abcdef\\", \\"a*d*f\\") == True assert match_pattern(\\"abcdef\\", \\"?bcdef\\") == True assert match_pattern(\\"abcdef\\", \\"a*c*b\\") == False ``` **Note:** Ensure the function correctly handles patterns with consecutive `*` characters and does not rely on external string matching libraries or functions.","solution":"def match_pattern(s, p): Checks if the given string `s` matches the pattern `p` where `?` matches any single character and `*` matches any sequence of characters. m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == \'?\' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"# Scheduling Events with Constraints You are tasked with writing a program that schedules events in a series of slots while respecting various constraints. The goal is to assign each event to exactly one slot in such a way that none of the constraints are violated. Function Signature ```python def schedule_events(events: list[str], slots: list[str], constraints: list[tuple[int, int]]) -> dict[str, str]: ``` Input * **events**: A list of strings where each string represents an event. * **slots**: A list of strings where each string represents a time slot. * **constraints**: A list of tuples `(i, j)` such that event `i` and event `j` cannot be scheduled at the same slot. Output * Returns a dictionary where the keys are the event names and the values are the slot names. If it\'s impossible to schedule all events without violating constraints, return an empty dictionary. Constraints 1. The length of `events` will be between 1 and 50. 2. The length of `slots` will be between 1 and 50. 3. The length of `constraints` will be between 0 and 100. 4. All inputs are guaranteed to be within the specified range. 5. Ensure consistent handling of edge cases such as insufficient slots or impossible constraints. # Sample Input ```python events = [\\"A\\", \\"B\\", \\"C\\"] slots = [\\"9AM\\", \\"10AM\\", \\"11AM\\"] constraints = [(0, 1), (1, 2)] ``` # Sample Output ```python { \\"A\\": \\"9AM\\", \\"B\\": \\"10AM\\", \\"C\\": \\"11AM\\" } ``` # Notes * If there are multiple valid solutions, returning any one of them is acceptable. * Consider using backtracking or graph coloring techniques to come up with a feasible schedule.","solution":"def schedule_events(events, slots, constraints): Schedules events in slots while respecting constraints. :param events: List of event names. :param slots: List of slot names. :param constraints: List of tuples specifying pairs of events that cannot be scheduled at the same slot. :return: Dictionary mapping events to slots. If impossible, returns an empty dictionary. n = len(events) m = len(slots) # If there are more events than slots, it\'s impossible to schedule if n > m: return {} # Prepare adjacency list for constraints constraints_dict = {i: set() for i in range(n)} for i, j in constraints: constraints_dict[i].add(j) constraints_dict[j].add(i) result = {} # Helper function to check if it\'s valid to assign slot to event def is_valid(event_index, slot): for neighbor in constraints_dict[event_index]: if events[neighbor] in result and result[events[neighbor]] == slot: return False return True # Backtracking function to schedule events def backtrack(event_index): if event_index == n: return True for slot in slots: if is_valid(event_index, slot): result[events[event_index]] = slot if backtrack(event_index + 1): return True del result[events[event_index]] return False if backtrack(0): return result else: return {}"},{"question":"# Question: Implement a Reverse Polish Notation (RPN) Calculator You are required to implement a Reverse Polish Notation (RPN) Calculator. RPN is a mathematical notation in which every operator follows all of its operands. For example, to add 3 and 4, one would write \\"3 4 +\\", rather than \\"3 + 4\\". If there are multiple operations, the operator is given immediately after its second operand; for example, the expression written \\"3 − 4 + 5\\" would be written \\"3 4 − 5 +\\" in RPN. Implement the following function: 1. `rpn_calculate(expression: str) -> float` * This function should take a string expression written in Reverse Polish Notation. * Return the result of the expression as a float. * Raise an exception for invalid RPN expressions. # Constraints: * The input string `expression` may contain digits (0-9), spaces, and the following operators: `+`, `-`, `*`, and `/`. * The RPN expression will be valid and will not include any spaces between multi-digit numbers or floating-point numbers. * The length of `expression` will not exceed 1000 characters. * Division by zero should raise an exception. # Example Usage: ```python >>> rpn_calculate(\\"3 4 +\\") 7.0 >>> rpn_calculate(\\"3 4 - 5 +\\") 4.0 >>> rpn_calculate(\\"5 1 2 + 4 * + 3 -\\") 14.0 >>> rpn_calculate(\\"5 4 3 + 2 * 1 - /\\") 1.0 ``` Implement the function with appropriate error handling and considerations for performance.","solution":"def rpn_calculate(expression: str) -> float: Evaluates a Reverse Polish Notation (RPN) expression. Args: expression (str): The RPN expression to evaluate. Returns: float: The result of the evaluated expression. Raises: ValueError: If the expression is invalid or if division by zero is attempted. stack = [] operators = {\'+\': lambda x, y: x + y, \'-\': lambda x, y: x - y, \'*\': lambda x, y: x * y, \'/\': lambda x, y: x / y if y != 0 else (_ for _ in ()).throw(ValueError(\\"Division by zero\\"))} tokens = expression.split() for token in tokens: if token in operators: if len(stack) < 2: raise ValueError(\\"Invalid RPN expression\\") b = stack.pop() a = stack.pop() operation = operators[token] stack.append(operation(a, b)) else: try: stack.append(float(token)) except ValueError: raise ValueError(\\"Invalid token in RPN expression\\") if len(stack) != 1: raise ValueError(\\"Invalid RPN expression\\") return stack[0]"},{"question":"# Minimize Maximum Difference Between Array Elements **Context**: You are a software engineer tasked with optimizing the performance of network routers. One way to improve efficiency is by balancing the load handled by different routers. This load can be represented as an array of integers, where each element stands for the load on a specific router. Your goal is to minimize the maximum difference between any two loads in the array by distributing the load more evenly. **Task**: Implement a function `balance_load` which, given an array of integers representing router loads, redistributes the load such that the maximum difference between any two elements is minimized. You can either increment or decrement any element by 1 to redistribute the loads. **Function Signature**: ```python def balance_load(loads: list[int], max_operations: int) -> int: pass ``` **Input**: - `loads` (list of ints): A list of integers representing the load on each router. - `max_operations` (int): The maximum number of increment/decrement operations allowed. **Output**: - An integer representing the minimized maximum difference between any two loads after performing the allowed number of operations. **Constraints**: - The length of `loads` (n) ranges from `1` to `1000`. - Each load value is an integer between `0` and `1000`. - The number of operations allowed (`max_operations`) ranges from `0` to `10^6`. **Example**: ```python assert balance_load([1, 3, 6], 3) == 1 assert balance_load([1, 1, 1], 100) == 0 assert balance_load([10, 10, 10, 10], 5) == 0 ``` **Notes**: * When `max_operations` is `0`, the function should return the initial maximum difference between the loads. * Think about efficient ways to balance the load within the given constraints. Binary search, two pointers, or a heap might be useful. * Your solution should handle edge cases effectively, including scenarios with very large numbers of operations allowed. This question examines your problem-solving skills involving array manipulation, efficient data structures, and optimization techniques.","solution":"from heapq import heappop, heappush, heapify def balance_load(loads: list[int], max_operations: int) -> int: def can_achieve(mid): pos_heap = [] neg_heap = [] for load in loads: heappush(pos_heap, -load) heappush(neg_heap, load) operations = 0 while operations <= max_operations: max_val = -heappop(pos_heap) min_val = heappop(neg_heap) if max_val - min_val <= mid: return True diff = max_val - min_val move = min(diff - mid, max_val - min_val) operations += move heappush(pos_heap, -(max_val - move)) heappush(neg_heap, min_val + move) return False low, high = 0, max(loads) - min(loads) result = high while low <= high: mid = (low + high) // 2 if can_achieve(mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"# Scenario You are enhancing a medical application that keeps track of patients\' medication schedules. One critical functionality required is to generate a \\"medication report\\" for each patient that shows the total number of days a patient is expected to take each medication within a specific period. Your task is to implement a function that calculates the medication schedule based on given start and end dates and the frequency of doses. # Function Implementation Implement a function `medication_schedule(start_date: str, end_date: str, frequency: int) -> int` in Python, which computes the number of days on which a patient needs to take their medication within the given date range. The `start_date` and `end_date` parameters will be string inputs in the format `YYYY-MM-DD`. # Input and Output Formats * **Input**: * `start_date`: A string representing the start date in the format `YYYY-MM-DD`. * `end_date`: A string representing the end date in the format `YYYY-MM-DD`. * `frequency`: An integer representing the frequency in days at which the medication should be taken. Constraints: `1 <= frequency <= 30`. * **Output**: An integer representing the total number of days the medication should be taken between the start and end dates (inclusive). # Constraints * Ensure that the start date is not later than the end date. * Handle edge cases where the medication period might not fit perfectly within the date range. # Requirements 1. Parse the input dates and calculate the difference in days. 2. Based on the given frequency, compute the total number of medication days within the date range. 3. Return the computed number of days as an integer. # Example ```python # Example Usage print(medication_schedule(\\"2022-01-01\\", \\"2022-01-10\\", 2)) # Output: 5 print(medication_schedule(\\"2022-01-01\\", \\"2022-01-30\\", 7)) # Output: 5 print(medication_schedule(\\"2023-03-15\\", \\"2023-03-20\\", 3)) # Output: 2 ``` # Detailed Steps 1. Convert the `start_date` and `end_date` strings to `datetime` objects. 2. Calculate the total number of days between the `start_date` and `end_date`. 3. Determine the number of days reserved for medication using the given frequency. This can be computed by dividing the total days by the frequency and adding one for the starting date. 4. Return the total count of medication days as an integer.","solution":"from datetime import datetime, timedelta def medication_schedule(start_date: str, end_date: str, frequency: int) -> int: Calculate the number of days a patient needs to take medication between start_date and end_date with a given frequency. Parameters: - start_date: Start date in the format \'YYYY-MM-DD\'. - end_date: End date in the format \'YYYY-MM-DD\'. - frequency: Frequency in days (interval between doses). Returns: - Total number of medication days as an integer. # Convert input date strings to datetime objects start = datetime.strptime(start_date, \'%Y-%m-%d\') end = datetime.strptime(end_date, \'%Y-%m-%d\') # Calculate the number of days between the start and end date (inclusive) delta_days = (end - start).days + 1 # Calculate the number of medication days medication_days = (delta_days + frequency - 1) // frequency return medication_days"},{"question":"# Coding Assessment Question **Title**: Implement Levenshtein Distance Calculation **Context**: You are writing a text processing application that needs to measure the similarity between two strings. The Levenshtein distance (also known as edit distance) is a popular metric for this purpose. It calculates the minimum number of single-character edits (insertions, deletions or substitutions) required to change one string into the other. **Task**: Write a function `calculate_levenshtein_distance` that takes two strings and returns the Levenshtein distance between them. **Input**: - `s1`: a string consisting of lowercase English letters (a to z). - `s2`: a string consisting of lowercase English letters (a to z). **Output**: - An integer representing the Levenshtein distance between `s1` and `s2`. **Constraints**: - The length of `s1` and `s2` will be at least 1 and at most 1000. - Both strings will only contain lowercase English letters. **Example**: ```python s1 = \\"kitten\\" s2 = \\"sitting\\" print(calculate_levenshtein_distance(s1, s2)) ``` **Expected Output**: ``` 3 ``` **Notes**: - Use dynamic programming to efficiently solve the problem within the constraint limits. - Utilize a two-dimensional table where `dp[i][j]` represents the minimum edit distance between the first `i` characters of `s1` and the first `j` characters of `s2`. Use the relationship: [ dp[i][j] = min left( dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + (text{if } s1[i-1] neq s2[j-1] text{ then } 1 text{ else } 0) right) ] ```python def calculate_levenshtein_distance(s1, s2): m, j = len(s1) + 1, len(s2) + 1 dp = [[0] * j for _ in range(m)] for i in range(m): for j in range(j): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i else: cost = 0 if s1[i-1] == s2[j-1] else 1 dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + cost) return dp[-1][-1] ```","solution":"def calculate_levenshtein_distance(s1, s2): m, n = len(s1), len(s2) # Initialize the dp array with dimensions (m + 1) x (n + 1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the first row and column with the respective index values for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Populate the dp array based on the recurrence relation for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: cost = 0 else: cost = 1 dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + cost) # Substitution return dp[m][n]"},{"question":"Task Customer Service Simulation: Order Management System # Scenario You are working for an e-commerce company building a customer service system for managing customer orders. One of the system\'s core functionalities is to provide information about orders based on specific queries. You need to design and implement a function that processes and retrieves order details using the criteria provided. # Implementation Write a function `get_order_details` that takes a list of orders and a query dictionary as inputs and returns a list of orders that match the query. Each order is represented by a dictionary with the following keys: - `order_id` (int): Unique identifier for the order. - `customer_name` (str): Name of the customer who placed the order. - `order_date` (str): Date when the order was placed in \'YYYY-MM-DD\' format. - `total_amount` (float): Total amount for the order. - `status` (str): Current status of the order, which can be \'Pending\', \'Shipped\', \'Delivered\', or \'Cancelled\'. The query dictionary may have the following keys: - `customer_name` (str, optional): Filter orders by customer name. - `order_date` (str, optional): Filter orders by the exact date. - `min_amount` (float, optional): Minimum total amount for the filtered orders. - `max_amount` (float, optional): Maximum total amount for the filtered orders. - `status` (str, optional): Filter orders by their status. # Function Signature ```python def get_order_details(orders: list, query: dict) -> list: Retrieves a list of orders based on the query criteria. Parameters: - orders (list): A list of dictionaries, each representing an order. - query (dict): A dictionary containing query criteria. Returns: - list: A list of orders matching the query criteria. ``` # Requirements 1. Filter orders based on the presence and values of the query criteria. 2. Handle cases where none or only some of the query criteria are provided. 3. Ensure that the function returns orders that meet all specified criteria. 4. The function should be efficient and handle a reasonable amount of data. # Constraints - The `orders` list can contain up to 10,000 orders. - Each order dictionary is guaranteed to have the keys described above. - The query dictionary can be empty or contain any subset of the aforementioned keys. - Provide robust handling for edge cases such as empty orders list, no matching orders, and missing query fields. # Example Usage ```python orders = [ {\'order_id\': 1, \'customer_name\': \'Alice\', \'order_date\': \'2023-01-15\', \'total_amount\': 250.0, \'status\': \'Pending\'}, {\'order_id\': 2, \'customer_name\': \'Bob\', \'order_date\': \'2023-01-16\', \'total_amount\': 450.0, \'status\': \'Shipped\'}, {\'order_id\': 3, \'customer_name\': \'Alice\', \'order_date\': \'2023-01-17\', \'total_amount\': 300.0, \'status\': \'Delivered\'}, ] query = {\'customer_name\': \'Alice\', \'min_amount\': 200.0, \'status\': \'Pending\'} print(get_order_details(orders, query)) # Expected output: [{\'order_id\': 1, \'customer_name\': \'Alice\', \'order_date\': \'2023-01-15\', \'total_amount\': 250.0, \'status\': \'Pending\'}] ``` # Notes - Ensure proper handling and validation of input data. - Test the implementation with various combinations of query criteria to validate correctness. - Discuss any assumptions or improvements you made while developing the function.","solution":"def get_order_details(orders, query): Retrieves a list of orders based on the query criteria. Parameters: - orders (list): A list of dictionaries, each representing an order. - query (dict): A dictionary containing query criteria. Returns: - list: A list of orders matching the query criteria. def match(order): return ((query.get(\'customer_name\') is None or order[\'customer_name\'] == query[\'customer_name\']) and (query.get(\'order_date\') is None or order[\'order_date\'] == query[\'order_date\']) and (query.get(\'min_amount\') is None or order[\'total_amount\'] >= query[\'min_amount\']) and (query.get(\'max_amount\') is None or order[\'total_amount\'] <= query[\'max_amount\']) and (query.get(\'status\') is None or order[\'status\'] == query[\'status\'])) return [order for order in orders if match(order)]"},{"question":"# Scenario and Task You are working on a robotic warehouse management system, and part of your task is to ensure that the robots do not collide while moving items around the warehouse. To achieve this, you need to implement a collision detection system for the robots. # Problem Statement Implement a function `collision_detect` that checks for collisions between moving robots in a 2D space. # Function Signature ```python def collision_detect(robots: List[Tuple[str, Tuple[float, float], Tuple[float, float]]], threshold: float) -> List[Tuple[str, str]]: Detect collisions between robots in a 2D space. Parameters: robots (List[Tuple[str, Tuple[float, float], Tuple[float, float]]]): A list of tuples where each tuple represents a robot. Each tuple contains: - A string (name of the robot) - A tuple with the x and y coordinates representing the current position of the robot - A tuple with the x and y coordinates representing the next position of the robot threshold (float): The minimum distance between any two robots to consider as a collision. Returns: List[Tuple[str, str]]: A list of tuples where each tuple contains the names of the two robots that are within the threshold distance of each other at any point during their movement (either at the current or next position). pass ``` # Input - `robots`: A list of tuples representing information about robots. Each tuple contains: - A string representing the name of the robot. - A tuple `(x, y)` representing the current position of the robot. - A tuple `(x_next, y_next)` representing the next position of the robot. - `threshold`: A float representing the minimum distance below which two robots are considered to collide. # Output - Returns a list of tuples, where each tuple contains the names of two robots that are within the threshold distance of each other at any point during their movement. # Constraints - There can be between 2 and 100 robots. - Positions `(x, y)` and `(x_next, y_next)` are floating point numbers. - The threshold is a positive floating point number. # Example ```python robots = [ (\\"R1\\", (2.0, 3.0), (2.1, 3.1)), (\\"R2\\", (2.05, 3.05), (2.2, 3.2)), (\\"R3\\", (5.0, 5.0), (5.1, 5.1)) ] threshold = 0.2 result = collision_detect(robots, threshold) # Expected output: [(\'R1\', \'R2\')] # robot R1 and R2 are within the threshold distance at their current positions. ```","solution":"from typing import List, Tuple import math def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float: Helper function to calculate the Euclidean distance between two points. return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) def collision_detect(robots: List[Tuple[str, Tuple[float, float], Tuple[float, float]]], threshold: float) -> List[Tuple[str, str]]: Detect collisions between robots in a 2D space. Parameters: robots (List[Tuple[str, Tuple[float, float], Tuple[float, float]]]): A list of tuples where each tuple represents a robot. Each tuple contains: - A string (name of the robot) - A tuple with the x and y coordinates representing the current position of the robot - A tuple with the x and y coordinates representing the next position of the robot threshold (float): The minimum distance between any two robots to consider as a collision. Returns: List[Tuple[str, str]]: A list of tuples where each tuple contains the names of the two robots that are within the threshold distance of each other at any point during their movement (either at the current or next position). collisions = [] for i in range(len(robots)): for j in range(i + 1, len(robots)): robot1 = robots[i] robot2 = robots[j] current_distance = distance(robot1[1], robot2[1]) next_distance = distance(robot1[2], robot2[2]) if current_distance < threshold or next_distance < threshold: collisions.append((robot1[0], robot2[0])) return collisions"},{"question":"# Matrix Multiplication and Linear Transformations You are tasked with implementing functionality for basic matrix multiplication and applying a linear transformation to a point using a transformation matrix. Specifically, you need to create a function that multiplies two matrices and another function that applies a linear transformation to a 2D point. Requirements 1. **`multiply_matrices` function**: * **Input**: Two matrices `matrix_a` and `matrix_b`. Each matrix is represented as a list of lists, where each inner list is a row in the matrix. * **Output**: The resulting matrix product of `matrix_a` and `matrix_b`. If multiplication is not possible, return `None`. * **Function Signature**: ```python def multiply_matrices(matrix_a: list[list[float]], matrix_b: list[list[float]]) -> list[list[float]] | None: ``` 2. **`transform_point` function**: * **Input**: A 2D point represented by coordinates `(x, y)`, and a `2x2` transformation matrix. * **Output**: The transformed 2D point `(transformed_x, transformed_y)`. * **Function Signature**: ```python def transform_point(x: float, y: float, transformation_matrix: list[list[float]]) -> tuple[float, float]: ``` Constraints * Input values must be numeric (either `float` or `int`). * The transformation matrix must be a 2x2 matrix. * Ensure the matrix dimensions are compatible for multiplication in `multiply_matrices`. Example ```python # Example usage of multiply_matrices matrix_a = [[1, 2], [3, 4]] matrix_b = [[2, 0], [1, 2]] product = multiply_matrices(matrix_a, matrix_b) print(product) # Output: [[4, 4], [10, 8]] # Example usage of transform_point transformation_matrix = [[2, 0], [0, 2]] transformed = transform_point(1.0, 2.0, transformation_matrix) print(transformed) # Output: (2.0, 4.0) ``` Notes * Ensure that your implementation handles non-numeric inputs gracefully by raising appropriate exceptions. * Use numpy or nested loops for matrix multiplication implementation. Good luck, and happy coding!","solution":"def multiply_matrices(matrix_a, matrix_b): Multiplies two matrices if their dimensions are compatible. If not, return None. # Check if matrices can be multiplied if len(matrix_a[0]) != len(matrix_b): return None # Initialize the result matrix with zeros result = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] # Perform multiplication for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result def transform_point(x, y, transformation_matrix): Applies a 2x2 transformation matrix to a 2D point. # Check if transformation matrix is 2x2 if len(transformation_matrix) != 2 or len(transformation_matrix[0]) != 2: raise ValueError(\\"Transformation matrix must be 2x2.\\") # Apply transformation transformed_x = transformation_matrix[0][0] * x + transformation_matrix[0][1] * y transformed_y = transformation_matrix[1][0] * x + transformation_matrix[1][1] * y return transformed_x, transformed_y"},{"question":"Coding Assessment Question # Context You are developing a software for restaurant management that involves reserving tables for customers. To efficiently manage table reservations, you need a way to handle overlapping and non-overlapping reservations. # Task Implement a Reservation System where you can add reservations and check for overlapping reservations. # Function Specifications **Function 1: Add Reservation** - **Function Name**: `add_reservation` - **Input**: A dictionary representing a reservation (`reservation: Dict[str, Union[int, str]]`). The dictionary contains the following keys: - `id: int` − unique identifier for the reservation. - `start_time: str` − reservation start time in \\"HH:MM\\" format. - `end_time: str` − reservation end time in \\"HH:MM\\" format. - **Output**: None. **Function 2: Check Overlap** - **Function Name**: `check_overlap` - **Input**: The reservation dictionary (`reservation: Dict[str, Union[int, str]]`). - **Output**: A boolean indicating if there is an existing reservation that overlaps with the given reservation (`bool`). # Constraints - Time format follows a 24-hour clock. - `start_time` is always earlier than `end_time`. - Each added reservation is stored in a list, and reservations are checked against the stored list to determine overlaps. - If two reservations share the same `start_time` or `end_time` but do not overlap otherwise, they are not considered overlapping. # Example Usage ```python # Initialize an empty list to store reservations reservations = [] def add_reservation(reservation: Dict[str, Union[int, str]]) -> None: reservations.append(reservation) def check_overlap(reservation: Dict[str, Union[int, str]]) -> bool: new_start_time = int(reservation[\'start_time\'].replace(\':\', \'\')) new_end_time = int(reservation[\'end_time\'].replace(\':\', \'\')) for res in reservations: existing_start_time = int(res[\'start_time\'].replace(\':\', \'\')) existing_end_time = int(res[\'end_time\'].replace(\':\', \'\')) if not (new_end_time <= existing_start_time or new_start_time >= existing_end_time): return True return False # Adding a reservation reservation_1 = {\'id\': 1, \'start_time\': \'18:00\', \'end_time\': \'19:30\'} add_reservation(reservation_1) # Checking overlap for a new reservation reservation_2 = {\'id\': 2, \'start_time\': \'19:00\', \'end_time\': \'20:00\'} print(check_overlap(reservation_2)) # Expected output: True, as it overlaps with reservation_1 # Adding another reservation that doesn\'t conflict reservation_3 = {\'id\': 3, \'start_time\': \'20:00\', \'end_time\': \'21:00\'} add_reservation(reservation_3) print(check_overlap(reservation_2)) # This check would still output True ``` # Notes - Ensure the function correctly handles edge cases, such as overlapping and non-overlapping reservations that share boundary times. - The implementation should be efficient in terms of both time and space, accommodating multiple reservations.","solution":"from typing import Dict, Union reservations = [] def add_reservation(reservation: Dict[str, Union[int, str]]) -> None: reservations.append(reservation) def check_overlap(reservation: Dict[str, Union[int, str]]) -> bool: new_start_time = int(reservation[\'start_time\'].replace(\':\', \'\')) new_end_time = int(reservation[\'end_time\'].replace(\':\', \'\')) for res in reservations: existing_start_time = int(res[\'start_time\'].replace(\':\', \'\')) existing_end_time = int(res[\'end_time\'].replace(\':\', \'\')) if not (new_end_time <= existing_start_time or new_start_time >= existing_end_time): return True return False"},{"question":"# Question: Average Temperature Calculator Problem Statement: You are required to implement a Python function that calculates the average temperature over a given week. The function should take a list of daily temperatures and return the average temperature rounded to two decimal places. Function Signature: ```python def average_temperature(temperatures: list) -> float: ``` Input: - **temperatures** (list): A list of 7 floating-point numbers representing temperatures in degree Celsius. Output: - Returns the average temperature (float) rounded to two decimal places. Constraints: - If the list does not contain exactly 7 temperatures, raise a `ValueError` with the message: - \\"A week\'s temperature data should contain exactly 7 days.\\" Examples: ```python >>> average_temperature([20.0, 22.5, 19.0, 18.0, 21.5, 25.0, 23.0]) 21.43 >>> average_temperature([15.5, 16.3, 20.0, 18.7, 19.2, 21.1, 20.5]) 18.76 >>> average_temperature([10.0, 12.0, 14.0, 13.0, 15.0, 16.0, 10.0]) 12.86 >>> average_temperature([25.0, 25.0, 25.0, 25.0, 25.0, 25.0, 25.0]) 25.00 >>> average_temperature([30.1, 29.3, 28.4, 27.5, 26.6, 25.7, 24.8]) 27.49 ``` Implementation: Use basic Python arithmetic to calculate the average temperature and built-in functions to handle list operations. Ensure properly handling of floating-point arithmetic to maintain precision.","solution":"def average_temperature(temperatures: list) -> float: Return the average temperature over a given week. :param temperatures: List of 7 floating-point numbers representing daily temperatures. :raises ValueError: If the list does not contain exactly 7 temperatures. :return: Average temperature rounded to two decimal places. if len(temperatures) != 7: raise ValueError(\\"A week\'s temperature data should contain exactly 7 days.\\") avg_temp = sum(temperatures) / 7 return round(avg_temp, 2)"},{"question":"# Coding Assessment Question **Objective:** Write a function that identifies amicable numbers. Two numbers are amicable if the sum of the proper divisors (excluding itself) of each is equal to the other number. Your implementation should be efficient and handle large numbers gracefully. **Function Signature:** ```python def are_amicable_numbers(a: int, b: int) -> bool: pass ``` **Input/Output Format:** - Input: Two integers `a` and `b`, which are to be tested whether they are amicable numbers. - Output: Return `True` if `a` and `b` are amicable numbers, otherwise `False`. **Constraints:** - `a` and `b` should be positive integers in the range [1, 10^6]. **Example:** ```python assert are_amicable_numbers(220, 284) == True assert are_amicable_numbers(1184, 1210) == True assert are_amicable_numbers(2620, 2924) == True assert are_amicable_numbers(100, 200) == False assert are_amicable_numbers(50, 75) == False ``` **Performance Requirements:** - Solution must efficiently compute the sum of proper divisors, especially for larger numbers up to 10^6. **Scenario:** Your task is to develop a utility function for a mathematical software suite that identifies pairs of amicable numbers. This feature is essential for research in number theory and can aid in the discovery of new amicable pairs, which hold significance in various mathematical studies.","solution":"def sum_of_proper_divisors(n: int) -> int: Calculate the sum of proper divisors of n (excluding the number itself) if n <= 1: return 0 result = 1 # 1 is a proper divisor of any number > 1 sqrt_n = int(n ** 0.5) for i in range(2, sqrt_n + 1): if n % i == 0: result += i if i != n // i: result += n // i return result def are_amicable_numbers(a: int, b: int) -> bool: Return True if a and b are amicable numbers, otherwise False. return a != b and sum_of_proper_divisors(a) == b and sum_of_proper_divisors(b) == a"},{"question":"# Question: Unique Character Counter Develop a Python function `unique_char_counter(s: str) -> dict` that takes a string and returns a dictionary with each character from the string (excluding spaces and punctuation) as keys and their respective counts as values. This function should be case-insensitive. Constraints: - The input string can include alphabetic characters, digits, spaces, and punctuation marks (.,!?:;). - Treat characters with different cases (e.g., \\"a\\" and \\"A\\") as the same character (case-insensitive). - Exclude spaces and punctuation marks from the count. Input: - A single string `s` with length (1 leq |s| leq 10^6). Output: - A dictionary where keys are unique characters (lowercased and without spaces or punctuation) and values are their counts. Example: ```python >>> s = \\"Hello, World! How\'s everything?\\" >>> unique_char_counter(s) {\'h\': 3, \'e\': 2, \'l\': 3, \'o\': 3, \'w\': 2, \'r\': 1, \'d\': 1, \'s\': 1, \'v\': 1, \'y\': 1, \'t\': 1, \'i\': 1, \'n\': 1, \'g\': 1} ``` Implementation: Provide the implementation of the function to meet the above requirements. Ensure the function handles various edge cases, including mixed case characters and multiple spaces or punctuation. ```python import string def unique_char_counter(s: str) -> dict: s = s.lower() s = \'\'.join(c for c in s if c.isalnum()) counter = {} for char in s: if char in counter: counter[char] += 1 else: counter[char] = 1 return counter ```","solution":"import string def unique_char_counter(s: str) -> dict: This function returns a dictionary with each character from the string (excluding spaces and punctuation) as keys and their respective counts as values. It treats characters case-insensitively. :param s: The input string :returns: A dictionary with character counts s = s.lower() s = \'\'.join(c for c in s if c.isalnum()) counter = {} for char in s: if char in counter: counter[char] += 1 else: counter[char] = 1 return counter"},{"question":"# Coding Assessment Question **Problem Statement:** You are given a collection of strings, and your task is to implement a class `PrefixTree` (Trie) with methods to insert words, search for words, and list all words with a given prefix. Requirements: 1. **Inserting Words**: Implement a method `insert` that takes a string and inserts it into the Prefix Tree. 2. **Searching Words**: Implement a method `search` that takes a string and returns `True` if the string exists in the Prefix Tree, or `False` otherwise. 3. **Prefix Listing**: Implement a method `starts_with` that takes a prefix string and returns a list of all words in the Prefix Tree that start with the given prefix. Input: - The operations list will contain at most 10^3 operations including word insertions, searches, and prefix listings. - The strings will consist of lowercase English letters only. Output: - For each `search` operation, output `True` or `False`. - For each `starts_with` operation, output a list of strings starting with the given prefix in lexicographical order. Constraints: - All input strings have a maximum length of 100 characters. Class and Method Signatures: ```python class PrefixTreeNode: def __init__(self) -> None: self.children = {} self.is_word = False class PrefixTree: def __init__(self) -> None: self.root = PrefixTreeNode() def insert(self, word: str) -> None: ... def search(self, word: str) -> bool: ... def starts_with(self, prefix: str) -> list[str]: ... # Example Usage: # trie = PrefixTree() # trie.insert(\\"apple\\") # print(trie.search(\\"apple\\")) # Returns True # print(trie.search(\\"app\\")) # Returns False # print(trie.starts_with(\\"app\\")) # Returns [\\"apple\\"] # trie.insert(\\"app\\") # print(trie.search(\\"app\\")) # Returns True # print(trie.starts_with(\\"ap\\")) # Returns [\\"app\\", \\"apple\\"] ``` You are expected to design the methods to handle the operations efficiently. This exercise will test your understanding of trie data structures and string manipulation within a tree context. --- **Example Implementation:** ```python class PrefixTreeNode: def __init__(self) -> None: self.children = {} self.is_word = False class PrefixTree: def __init__(self) -> None: self.root = PrefixTreeNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = PrefixTreeNode() node = node.children[char] node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix: str) -> list[str]: def dfs(current_node: PrefixTreeNode, path: str, results: list) -> None: if current_node.is_word: results.append(path) for char, next_node in sorted(current_node.children.items()): dfs(next_node, path + char, results) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix, results) return results # Test trie = PrefixTree() words = [\\"apple\\", \\"app\\", \\"bat\\", \\"ball\\", \\"batch\\", \\"bats\\"] for word in words: trie.insert(word) print(trie.search(\\"apple\\")) # Returns True print(trie.search(\\"app\\")) # Returns True print(trie.search(\\"appl\\")) # Returns False print(trie.starts_with(\\"bat\\")) # Returns [\\"bat\\", \\"batch\\", \\"bats\\"] print(trie.starts_with(\\"bal\\")) # Returns [\\"ball\\"] print(trie.starts_with(\\"ba\\")) # Returns [\\"ball\\", \\"bat\\", \\"batch\\", \\"bats\\"] print(trie.starts_with(\\"xyz\\")) # Returns [] ``` You are expected to understand and implement the insert, search, and prefix listing functions efficiently to handle up to 10^3 operations effectively.","solution":"class PrefixTreeNode: def __init__(self) -> None: self.children = {} self.is_word = False class PrefixTree: def __init__(self) -> None: self.root = PrefixTreeNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = PrefixTreeNode() node = node.children[char] node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix: str) -> list[str]: def dfs(current_node: PrefixTreeNode, path: str, results: list) -> None: if current_node.is_word: results.append(path) for char, next_node in sorted(current_node.children.items()): dfs(next_node, path + char, results) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix, results) return results"},{"question":"# Coding Assessment Question: You are tasked with implementing a system to track and merge multiple sorted streams of integers in real-time. Write a function `merge_streams(streams)` that takes a list of `k` sorted lists of integers `streams` and merges them into one sorted output list. Input: * A list of `k` sorted lists `streams`, where each list contains integers sorted in ascending order (0 ≤ k ≤ 100, 0 ≤ len(stream[i]) ≤ 1000, -10^6 ≤ stream[i][j] ≤ 10^6). Output: * A single list containing all the integers from each list in `streams`, sorted in ascending order. Example: ```python assert merge_streams([[1, 3, 5], [2, 4, 6], [0, 9]]) == [0, 1, 2, 3, 4, 5, 6, 9] assert merge_streams([[], [1, 2, 3], []]) == [1, 2, 3] assert merge_streams([[-5, 0, 5], [-4, 2, 6], [1, 3, 7]]) == [-5, -4, 0, 1, 2, 3, 5, 6, 7] assert merge_streams([[]]) == [] assert merge_streams([[10, 20, 30], [5, 15, 25], [1, 2, 3, 4, 5]]) == [1, 2, 3, 4, 5, 5, 10, 15, 20, 25, 30] ``` Your function will be evaluated on the following: * Correctness of the merging algorithm. * Handling of edge cases such as empty input lists and varying lengths of input streams. * Efficient merging process to ensure optimal performance. **Constraints**: * Do not use Python’s built-in sort() method or any external libraries for sorting. * Consider the most optimal way to merge the sorted lists. **Performance Requirement**: Ensure the implementation effectively manages the given constraints, aiming for a solution that performs efficiently with the upper limit of input size.","solution":"from heapq import heappush, heappop def merge_streams(streams): Merges multiple sorted streams into one sorted stream. Parameters: - streams (List[List[int]]): A list of k sorted lists of integers. Returns: - List[int]: A single list containing all the integers from each list in streams, sorted in ascending order. min_heap = [] result = [] # Initialize heap for i, stream in enumerate(streams): if stream: heappush(min_heap, (stream[0], i, 0)) # (value, stream index, element index) # Merge all streams while min_heap: val, stream_index, element_index = heappop(min_heap) result.append(val) # If there are more elements in the current stream, push the next element to the heap if element_index + 1 < len(streams[stream_index]): next_val = streams[stream_index][element_index + 1] heappush(min_heap, (next_val, stream_index, element_index + 1)) return result"},{"question":"# Scenario: You are building a competitive programming platform where users can upload their solutions to various coding challenges. To make sure the submissions are unique and avoid plagiarism, you want to implement a system to detect similar code submissions based on a set of predefined transformation rules. Each rule describes a way to normalize code so that even if two pieces of code look different, they can be converted into a common form for comparison purposes. # Task: Implement a class `CodeNormalizer` that applies a series of transformation rules on code submissions to normalize them. Your class should provide functionalities to: 1. **Add a normalization rule**: Add a rule that specifies a pattern to be transformed into another pattern. 2. **Normalize code**: Apply all the added rules to a code submission and output the normalized code. # Requirements: - Implement the given functionalities using string replacement techniques and regex where necessary. - Ensure all rules are applied in the order they were added. - Support two types of rules: - Simple string replacement. - Regex-based replacement. # Function Specifications: 1. **add_rule(pattern: str, replacement: str, is_regex: bool = False) -> None**: Adds a normalization rule where `pattern` is replaced with `replacement`. The `is_regex` parameter denotes whether the pattern is a regular expression. 2. **normalize_code(code: str) -> str**: Applies all rules to the given `code` and returns the normalized code. # Constraints: - The length of the code will not exceed 10^5 characters. - The number of rules will not exceed 10^4. - Patterns and replacements will have a maximum length of 100 characters. # Example: ```python normalizer = CodeNormalizer() normalizer.add_rule(\'int\', \'long\') normalizer.add_rule(r\'s+\', \' \', is_regex=True) normalizer.add_rule(\'main()\', \'main(int argc, char *argv[])\') code = int main() { int a = 10; return a; } print(normalizer.normalize_code(code)) # Output: # \'long main(int argc, char *argv[]) { long a = 10; return a; }\' ``` # Note: - Simple string replacements are performed as they appear, whereas regex-based replacements use Python\'s `re.sub` method. - Ensure edge cases are handled, such as when the code or patterns contain special characters or whitespace. By implementing the `CodeNormalizer` class, you will facilitate a more robust plagiarism detection system that effectively standardizes code submissions for comparison.","solution":"import re class CodeNormalizer: def __init__(self): self.rules = [] def add_rule(self, pattern: str, replacement: str, is_regex: bool = False) -> None: Adds a normalization rule. :param pattern: The pattern to replace. :param replacement: The string to replace the pattern with. :param is_regex: Whether the pattern is treated as regex. self.rules.append((pattern, replacement, is_regex)) def normalize_code(self, code: str) -> str: Applies all rules to the given code and returns the normalized code. :param code: The code to be normalized. :return: The normalized code. for pattern, replacement, is_regex in self.rules: if is_regex: code = re.sub(pattern, replacement, code) else: code = code.replace(pattern, replacement) return code"},{"question":"# Longest Subarray with Sum K Context You are working on a data processing application that analyzes sequences of numbers. One of the tasks involves finding the longest contiguous subarray within a given list that sums up to a specified value `K`. Your goal is to implement a function that can efficiently determine the length of such a subarray. Task Write a function `longest_subarray_with_sum_k(nums: list[int], k: int) -> int` that finds the length of the longest contiguous subarray whose sum is equal to the given integer `K`. Input - `nums`: A list of integers `nums[]` of length `n` (0 <= n <= 10^5), representing the sequence of numbers. - `k`: An integer `K` (|K| <= 10^9), the target sum of the subarray. Output - Returns an integer, which is the length of the longest contiguous subarray with sum equal to `K`. Constraints - The list may contain both positive and negative integers. - If no such subarray exists, return 0. - The solution must be of linear time complexity, O(n). - The space complexity must be linear, O(n), in terms of auxiliary space usage. Example ```python print(longest_subarray_with_sum_k([1, -1, 5, -2, 3], 3)) # Output: 4 print(longest_subarray_with_sum_k([-2, -1, 2, 1], 1)) # Output: 2 print(longest_subarray_with_sum_k([1, 2, 3, 4, 5], 15)) # Output: 5 print(longest_subarray_with_sum_k([1, 2, 3, -2, 4, -2, 2], 3)) # Output: 4 print(longest_subarray_with_sum_k([1, 2, 3], 7)) # Output: 0 ``` Criteria - The solution should use appropriate data structures to handle the requirements efficiently. - Handle special cases like empty lists and lists with a single element effectively.","solution":"def longest_subarray_with_sum_k(nums, k): Returns the length of the longest contiguous subarray whose sum is equal to k. :param nums: List of integers, the input array :param k: Integer, the target sum :return: Integer, the length of the longest subarray with sum equal to k prefix_sum_map = {} current_sum = 0 max_length = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum == k: max_length = i + 1 if current_sum - k in prefix_sum_map: max_length = max(max_length, i - prefix_sum_map[current_sum - k]) if current_sum not in prefix_sum_map: prefix_sum_map[current_sum] = i return max_length"},{"question":"# Problem Statement You are required to implement a `MinHeap` class for a min-heap data structure in Python. The min-heap should support the following operations efficiently: * `insert(item)`: Adds an item to the heap and maintains the heap property. * `get_min()`: Returns the smallest item from the heap without removing it. Raises an `IndexError` if the heap is empty. * `extract_min()`: Removes and returns the smallest item from the heap. Raises an `IndexError` if the heap is empty. * `is_empty()`: Returns `True` if the heap is empty, `False` otherwise. # Input/Output Format * The `MinHeap` class does not take any input during instantiation. * Operations include `insert(item: T) -> None`, `get_min() -> T`, `extract_min() -> T`, and `is_empty() -> bool`. # Constraints * You may assume that the item inserted into the heap will always be valid and can be any comparable type. * You must handle the scenario where `get_min` or `extract_min` operations are called on an empty heap, by raising an appropriate exception. # Example Usage ```python heap = MinHeap() heap.insert(5) heap.insert(3) heap.insert(10) print(heap.get_min()) # Output: 3 print(heap.extract_min()) # Output: 3 print(heap.get_min()) # Output: 5 print(heap.is_empty()) # Output: False ``` Implement the class `MinHeap` in Python by completing the following definitions.","solution":"import heapq class MinHeap: def __init__(self): self.heap = [] def insert(self, item): heapq.heappush(self.heap, item) def get_min(self): if not self.heap: raise IndexError(\\"get_min from an empty heap\\") return self.heap[0] def extract_min(self): if not self.heap: raise IndexError(\\"extract_min from an empty heap\\") return heapq.heappop(self.heap) def is_empty(self): return len(self.heap) == 0"},{"question":"# Problem Statement **Scenario**: You\'ve been given the task of implementing an inventory management system for a warehouse. This system must keep track of the items in stock, and the goal is to design a function that can process a list of transactions. Each transaction includes adding items to the inventory, removing items (as long as they are available in sufficient quantity), and querying the current quantity of a specific item. # Task Implement the function `process_transactions(transactions: List[Tuple[str, str, int]]) -> List[Union[int, str]]` which takes a list of transactions. Each transaction is a tuple containing an action (`\'add\'`, `\'remove\'`, or `\'query\'`), an item name (string), and an integer value (quantity). The function should process the transactions and return a list of results for each `\'query\'` action. If a `\'remove\'` action tries to remove more items than are available, it should leave the stock unchanged for that item. # Requirements * You must handle invalid inputs appropriately. * Ensure your program efficiently handles large lists of transactions. # Function Signature ```python def process_transactions(transactions: List[Tuple[str, str, int]]) -> List[Union[int, str]]: Args: transactions (List[Tuple[str, str, int]]): A list of transactions where each transaction is a tuple (action, item, quantity). Returns: List[Union[int, str]]: A list of results corresponding to \'query\' transactions. ``` # Constraints * `1 <= len(transactions) <= 10^5` * `1 <= len(item) <= 50` * `1 <= quantity <= 10^5` # Example ```python # Example 1 transactions1 = [ (\'add\', \'apple\', 10), (\'query\', \'apple\', 0), (\'remove\', \'apple\', 5), (\'query\', \'apple\', 0), (\'remove\', \'apple\', 10), (\'query\', \'apple\', 0), ] assert process_transactions(transactions1) == [10, 5, \'not enough stock\'] # Example 2 transactions2 = [ (\'add\', \'banana\', 20), (\'query\', \'banana\', 0), (\'add\', \'banana\', 5), (\'query\', \'banana\', 0), (\'remove\', \'banana\', 15), (\'query\', \'banana\', 0) ] assert process_transactions(transactions2) == [20, 25, 10] ``` # Explanation In each example: - **Example 1**: - Add 10 apples → inventory: {\'apple\': 10} - Query apples → result: 10 - Remove 5 apples → inventory: {\'apple\': 5} - Query apples → result: 5 - Remove 10 apples (not enough stock) → inventory unchanged, result: \'not enough stock\' - Query apples → result: \'not enough stock\' - **Example 2**: - Add 20 bananas → inventory: {\'banana\': 20} - Query bananas → result: 20 - Add 5 bananas → inventory: {\'banana\': 25} - Query bananas → result: 25 - Remove 15 bananas → inventory: {\'banana\': 10} - Query bananas → result: 10","solution":"def process_transactions(transactions): Args: transactions (List[Tuple[str, str, int]]): A list of transactions where each transaction is a tuple (action, item, quantity). Returns: List[Union[int, str]]: A list of results corresponding to \'query\' transactions. inventory = {} results = [] for action, item, quantity in transactions: if action == \'add\': if item in inventory: inventory[item] += quantity else: inventory[item] = quantity elif action == \'remove\': if item in inventory and inventory[item] >= quantity: inventory[item] -= quantity elif action == \'query\': if item in inventory: results.append(inventory[item]) else: results.append(0) return results"},{"question":"# Coding Assessment Question Context Implement a system that manages a simple locked safe. The safe can be locked or unlocked by a user, and it keeps track of the number of unsuccessful attempts to unlock it. A user must provide the correct PIN to unlock the safe. Task You are required to implement the class `Safe` with the following methods: 1. **Method Name**: `__init__` - **Parameters**: `self`, `pin` (a string representing the PIN needed to unlock the safe) - **Description**: Initializes the Safe object with the provided `pin` and sets it in a locked state. 2. **Method Name**: `lock` - **Parameters**: `self` - **Description**: Locks the safe. 3. **Method Name**: `unlock` - **Parameters**: `self`, `pin_attempt` (a string representing a PIN attempt) - **Output**: A boolean indicating if the safe was successfully unlocked. - **Description**: Attempts to unlock the safe using `pin_attempt`. If the attempt is successful, changes the state to unlocked and resets the unsuccessful attempts counter. If the attempt is unsuccessful, increments the unsuccessful attempts counter. 4. **Method Name**: `is_locked` - **Parameters**: `self` - **Output**: A boolean indicating whether the safe is currently locked. 5. **Method Name**: `get_unsuccessful_attempts` - **Parameters**: `self` - **Output**: An integer indicating the number of unsuccessful unlock attempts since the last time the safe was successfully unlocked. Constraints * The PIN provided during initialization and in attempts will only contain numeric characters (`0-9`) and will be of length 4. * Your implementation should handle cases where the PIN attempts are not exactly 4 characters or contain non-numeric characters, treating them as invalid and counting them as unsuccessful attempts. Examples ```python safe = Safe(\'1234\') # Initial state assert safe.is_locked() == True assert safe.get_unsuccessful_attempts() == 0 # Successful unlock attempt assert safe.unlock(\'1234\') == True assert safe.is_locked() == False assert safe.get_unsuccessful_attempts() == 0 # Lock the safe again safe.lock() assert safe.is_locked() == True # Unsuccessful unlock attempts assert safe.unlock(\'1111\') == False assert safe.get_unsuccessful_attempts() == 1 assert safe.unlock(\'abcd\') == False # Invalid PIN format assert safe.get_unsuccessful_attempts() == 2 assert safe.unlock(\'12345\') == False # Invalid PIN length assert safe.get_unsuccessful_attempts() == 3 # Successful unlock after unsuccessful attempts assert safe.unlock(\'1234\') == True assert safe.is_locked() == False assert safe.get_unsuccessful_attempts() == 0 ```","solution":"class Safe: def __init__(self, pin): self.pin = pin self.locked = True self.unsuccessful_attempts = 0 def lock(self): self.locked = True def unlock(self, pin_attempt): if len(pin_attempt) != 4 or not pin_attempt.isdigit() or pin_attempt != self.pin: self.unsuccessful_attempts += 1 return False else: self.locked = False self.unsuccessful_attempts = 0 return True def is_locked(self): return self.locked def get_unsuccessful_attempts(self): return self.unsuccessful_attempts"},{"question":"# Question: You are working on a data processing module for an e-commerce platform. Your task is to implement a function that helps determine the most frequently purchased item within a specific period. Write a function `most_frequent_item(purchases: List[Tuple[str, str]]) -> str` that computes the most frequently purchased item among a list of purchases. If there are multiple items with the same highest frequency, return the lexicographically smallest item. # Input: - `purchases` (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings. - The first string represents the date of purchase in the format \'YYYY-MM-DD\'. - The second string represents the name of the item purchased. # Output: A single string representing the name of the most frequently purchased item. # Constraints: - The items in the `purchases` list are case-sensitive, and all item names will comprise only alphabetic characters. - The `purchases` list may contain between 1 and 10,000 tuples. - Dates will be in the correct format and all items\' names will consist of up to 50 characters. - There might be multiple items with the same highest purchase frequency. In such a case, return the lexicographically smallest item. - The input list will always contain at least one purchase. # Examples: 1. When purchases are: ```python [ (\\"2023-07-16\\", \\"Laptop\\"), (\\"2023-07-17\\", \\"Laptop\\"), (\\"2023-07-17\\", \\"Headphones\\"), (\\"2023-07-18\\", \\"Headphones\\"), (\\"2023-07-18\\", \\"Mouse\\") ] ``` ```python most_frequent_item([ (\\"2023-07-16\\", \\"Laptop\\"), (\\"2023-07-17\\", \\"Laptop\\"), (\\"2023-07-17\\", \\"Headphones\\"), (\\"2023-07-18\\", \\"Headphones\\"), (\\"2023-07-18\\", \\"Mouse\\") ]) ``` Should return `\\"Headphones\\"` since \\"Headphones\\" and \\"Laptop\\" both have the highest frequency, but \\"Headphones\\" is lexicographically smaller. 2. When purchases are: ```python [ (\\"2023-06-12\\", \\"Book\\"), (\\"2023-06-13\\", \\"Book\\"), (\\"2023-06-14\\", \\"Pencil\\"), (\\"2023-06-15\\", \\"Book\\"), (\\"2023-06-16\\", \\"Eraser\\") ] ``` ```python most_frequent_item([ (\\"2023-06-12\\", \\"Book\\"), (\\"2023-06-13\\", \\"Book\\"), (\\"2023-06-14\\", \\"Pencil\\"), (\\"2023-06-15\\", \\"Book\\"), (\\"2023-06-16\\", \\"Eraser\\") ]) ``` Should return `\\"Book\\"` since it has the highest frequency. # Additional Notes: - Ensure your function handles large input efficiently. - Implement edge cases to verify the correctness of the function. - Use appropriate data structures to efficiently track and compare purchase frequencies.","solution":"from typing import List, Tuple from collections import Counter def most_frequent_item(purchases: List[Tuple[str, str]]) -> str: Function to determine the most frequently purchased item. Args: purchases (List[Tuple[str, str]]): List of tuples where each tuple contains the date of purchase and the item purchased. Returns: str: The name of the most frequently purchased item. item_counter = Counter(item for date, item in purchases) max_frequency = max(item_counter.values()) most_frequent_items = [item for item, count in item_counter.items() if count == max_frequency] return min(most_frequent_items)"},{"question":"# Sorting Emails by Domain Context In many applications, email addresses need to be processed and sorted for various purposes. Sorting email addresses by their domain names (the part after \'@\') can be particularly useful for organizing and analyzing data. Problem Statement You are required to implement a function `sort_emails_by_domain` that sorts a list of email addresses by their domain names. If two email addresses have the same domain, their order should be determined by the normal alphabetical order of the entire email address. Function Signature ```python def sort_emails_by_domain(emails: List[str]) -> List[str]: pass ``` Parameters - `emails` (List[str]): A list of strings where each string represents a valid email address. Returns - List[str]: A list of email addresses sorted primarily by their domain names, and secondarily by the entire email address when domains are identical. Constraints - All input email addresses are guaranteed to be valid and contain exactly one \'@\' symbol. - The list of email addresses can be empty. Examples ```python >>> sort_emails_by_domain([\\"alice@xyz.com\\", \\"bob@abc.com\\", \\"charlie@abc.com\\", \\"dave@ddd.com\\"]) [\'bob@abc.com\', \'charlie@abc.com\', \'dave@ddd.com\', \'alice@xyz.com\'] >>> sort_emails_by_domain([\\"user1@gmail.com\\", \\"user2@yahoo.com\\", \\"user3@gmail.com\\"]) [\'user3@gmail.com\', \'user1@gmail.com\', \'user2@yahoo.com\'] >>> sort_emails_by_domain([]) [] >>> sort_emails_by_domain([\\"same@domain.com\\", \\"different@domain.com\\"]) [\'different@domain.com\', \'same@domain.com\'] ``` Notes - Assume the input list will contain string elements only. - Implement error handling to ensure the function works correctly with lists that might be unsorted or contain edge cases. For instance, multiple emails with the same domain should still be sorted lexicographically within the same domain. - Consider efficiency in the sorting process, especially when dealing with large lists of email addresses.","solution":"def sort_emails_by_domain(emails): Sorts a list of email addresses by their domain names. If two email addresses have the same domain, their order is determined by the email address. :param emails: List of email addresses. :return: List of sorted email addresses. return sorted(emails, key=lambda email: (email.split(\'@\')[1], email))"},{"question":"# Question: Implement a Simple File Metadata Extractor You are required to implement functions that extract and return file metadata, such as file size, creation date, modification date, and file type from a given file path. Use appropriate libraries in Python and handle any errors that may occur gracefully. Implement the following two functions: 1. `get_file_size(file_path: str) -> int` * This function should return the size of the file in bytes. * Raise a `FileNotFoundError` if the file does not exist. 2. `get_file_metadata(file_path: str) -> dict` * This function should return a dictionary containing the file\'s metadata. The dictionary should have the following keys: `size`, `creation_date`, `modification_date`, and `file_type`. * The `creation_date` and `modification_date` should be in ISO 8601 format (YYYY-MM-DDTHH:MM:SS). * The `file_type` should be derived from the file extension. * Raise a `FileNotFoundError` if the file does not exist. # Constraints: * Your code should be tested on an operating system that supports file metadata retrieval via standard Python libraries. * The file path will always be a valid string up to 256 characters. * Assume that the file path provided is accessible and readable by the user running the code. # Example Usage: ```python >>> get_file_size(\\"example.txt\\") 124 >>> get_file_metadata(\\"example.txt\\") { \'size\': 124, \'creation_date\': \'2022-01-01T12:00:00\', \'modification_date\': \'2022-01-01T13:00:00\', \'file_type\': \'txt\' } >>> get_file_size(\\"nonexistent.txt\\") # Raises FileNotFoundError >>> get_file_metadata(\\"nonexistent.txt\\") # Raises FileNotFoundError ``` **Note:** You may use the `os` and `datetime` modules to achieve the desired functionality.","solution":"import os import datetime def get_file_size(file_path: str) -> int: Returns the size of the file in bytes. :param file_path: The path to the file :return: Size of the file in bytes :raises FileNotFoundError: If the file does not exist if not os.path.isfile(file_path): raise FileNotFoundError(f\\"File not found: {file_path}\\") return os.path.getsize(file_path) def get_file_metadata(file_path: str) -> dict: Returns the metadata of the file. :param file_path: The path to the file :return: Dictionary containing file metadata :raises FileNotFoundError: If the file does not exist if not os.path.isfile(file_path): raise FileNotFoundError(f\\"File not found: {file_path}\\") size = os.path.getsize(file_path) creation_time = datetime.datetime.fromtimestamp(os.path.getctime(file_path)).isoformat() modification_time = datetime.datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat() file_type = os.path.splitext(file_path)[1][1:] # Get the file extension without the dot return { \\"size\\": size, \\"creation_date\\": creation_time, \\"modification_date\\": modification_time, \\"file_type\\": file_type }"},{"question":"# Matrix Transpose with Validation You need to write a function that transposes a given matrix and validates the input to ensure it is a valid 2D list with consistent row lengths. If the input is not a valid matrix, the function should return `None`. Implement the function `validated_transpose(matrix: list[list[int]]) -> list[list[int]]` that: * Takes a 2D list of integers as input. * Returns the transposed matrix if the input is a valid 2D list. * Returns `None` if the input is not a valid 2D list with consistent row lengths. Function Signature ```python def validated_transpose(matrix: list[list[int]]) -> list[list[int]]: pass ``` # Input * `matrix`: A 2D list of integers. # Output * Returns the transposed matrix if the input is valid. * Returns `None` if the input is not a valid 2D list with consistent row lengths. # Examples Here are some sample test cases for your implementation: ```python assert validated_transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]] assert validated_transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] assert validated_transpose([[1, 2], [3]]) == None assert validated_transpose([[1], [2, 3]]) == None assert validated_transpose(\\"not a matrix\\") == None assert validated_transpose([[1, 2], [3, 4, 5]]) == None ```","solution":"def validated_transpose(matrix: list[list[int]]) -> list[list[int]]: # Check if the input is a list of lists if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return None # Check if the matrix has consistent row lengths row_length = len(matrix[0]) if matrix else 0 if not all(len(row) == row_length for row in matrix): return None # Perform the transpose transposed_matrix = [[matrix[j][i] for j in range(len(matrix))] for i in range(row_length)] return transposed_matrix"},{"question":"# Problem Statement You are required to develop a function that finds the most frequent word in a given text. The function needs to handle case sensitivity and punctuation properly. # Function Specification ```python def find_most_frequent_word(text: str) -> str: Determines and returns the most frequent word in a given text. Parameters: text (str): A string containing the text to analyze. Returns: str: The most frequent word in the text. ``` # Input * `text`: A string containing the text in which to search for the most frequent word. # Output * **str**: The word that appears the most frequently in the text. # Constraints * The input text will have a maximum length of 10^5 characters. * The input text will contain only ASCII characters. * Words are defined as sequences of alphanumeric characters separated by whitespace or punctuation. # Example ```python assert find_most_frequent_word(\\"This is a test. This test is only a test.\\") == \\"test\\" assert find_most_frequent_word(\\"Word! Another word; and yet, another word.\\") == \\"word\\" assert find_most_frequent_word(\\"One fish, two fish, red fish, blue fish.\\") == \\"fish\\" ``` **Solution Requirements**: The function should properly handle punctuation, and ignore case differences (e.g., \\"Word\\" and \\"word\\" should be considered the same word). If there are multiple words with the same frequency, return any one of them. **Hint**: You may find Python\'s `collections.Counter` and `string` modules useful in solving this problem. --- This question explores basic string manipulation, the use of regular expressions for parsing text, handling of punctuation, and counting and comparing frequencies—skills commonly required for text processing tasks. This aligns well with the programming concepts covered in the provided sample question.","solution":"import re from collections import Counter def find_most_frequent_word(text: str) -> str: Determines and returns the most frequent word in a given text. Parameters: text (str): A string containing the text to analyze. Returns: str: The most frequent word in the text. # Normalize the text: convert to lower case and remove punctuation using regex words = re.findall(r\'bw+b\', text.lower()) # Count the frequency of each word word_count = Counter(words) # Find the word with the highest frequency most_common_word, _ = word_count.most_common(1)[0] return most_common_word"},{"question":"# Question Develop a function `unique_pair_sums` which identifies all unique pairs of integers in a given list that add up to a target sum. Implement additional features to handle: 1. **Input Validation**: Ensure the list of integers and the target sum are valid. 2. **Multiplicity Handling**: Account for multiple pairs producing the same sum. 3. **Result Order**: Return unique pairs in a specified order (either ascending or descending by pair sums). Function Signature ```python def unique_pair_sums(numbers: list[int], target_sum: int, order: str = \\"ascending\\") -> list[tuple[int, int]]: pass ``` Input and Output Formats * **Inputs**: * `numbers`: List of integers (can include positive and negative numbers). * `target_sum`: An integer representing the target sum for pairs of numbers. * `order`: A string specifying the order of results (\\"ascending\\" or \\"descending\\"). Default is \\"ascending\\". * **Output**: * Returns a list of tuples, where each tuple contains a unique pair of integers from the input list that add up to the target sum, sorted by the specified order. Constraints * The function should handle cases where no such pairs exist by returning an empty list. * If the input list is empty or the target sum is not an integer, the function should return an empty list. Scenario Imagine you are developing a feature for a financial application that analyzes potential investment pairs from a list of stock prices. Users can specify a desired target sum to match pairs of stock prices that together meet their budget constraints. The functionality should also provide options to return the pairs in an order that aids user decisions. Example ```python # Basic usage >>> unique_pair_sums([2, 4, 3, 5, 7, 8, -1, 0], 7) [(0, 7), (-1, 8), (2, 5), (3, 4)] # Specifying descending order >>> unique_pair_sums([2, 4, 3, 5, 7, 8, -1, 0], 7, \\"descending\\") [(3, 4), (2, 5), (-1, 8), (0, 7)] # Handling no pairs found >>> unique_pair_sums([1, 2, 3], 10) [] ```","solution":"def unique_pair_sums(numbers, target_sum, order=\\"ascending\\"): if not isinstance(target_sum, int): return [] numbers = list(numbers) # Ensure we are working with a list pairs_set = set() unique_numbers = set(numbers) for num in numbers: complement = target_sum - num if complement in unique_numbers: pairs_set.add(tuple(sorted((num, complement)))) # Remove the complement from unique_numbers to avoid duplicates unique_numbers.discard(num) unique_numbers.discard(complement) pairs_list = list(pairs_set) if order == \\"ascending\\": pairs_list.sort() elif order == \\"descending\\": pairs_list.sort(reverse=True) return pairs_list"},{"question":"# Question Title: Currency Exchange Rate Fetcher with Caching # Scenario You are required to develop a Python script that retrieves and caches the latest exchange rate from USD to EUR using an external API. The caching mechanism will store the fetched exchange rates in a local file to minimize the number of API calls, keeping the data fresh for a configurable duration. # Requirements 1. **Data Fetching**: - Use the `requests` library to fetch the current exchange rate from USD to EUR from `https://api.exchangerate-api.com/v4/latest/USD`. - Extract the exchange rate to EUR from the JSON response. 2. **Caching Mechanism**: - Store the exchange rate in a local file named `exchange_rate_cache.txt` with the timestamp of when it was fetched. - Implement a function to read from the cache and determine if a fresh API call is needed based on a configurable time duration (e.g., 1 hour). If the data in the cache is older than the duration, fetch new data and update the cache. 3. **Edge Case Handling**: - Handle HTTP and network errors gracefully with appropriate messages. - Utilize Python\'s exception handling to manage I/O errors related to file operations. # Function Signature Implement the following function: ```python def get_exchange_rate(cache_duration: int = 3600, cache_file: str = \\"exchange_rate_cache.txt\\") -> float: pass ``` # Input - `cache_duration`: The duration (in seconds) to consider the cache valid. Default is 3600 seconds (1 hour). - `cache_file`: The name of the file where the cache is stored. Default is `exchange_rate_cache.txt`. # Output The function should return the current exchange rate from USD to EUR as a float. # Constraints - Use the `requests` library for fetching data. - Store and read cache data using standard file I/O operations. - Ensure the function handles cache validation and updates correctly. # Example Usage ```python rate = get_exchange_rate() print(f\\"The current exchange rate from USD to EUR is: {rate:.4f}\\") ``` Expected output (subject to current exchange rate): ``` The current exchange rate from USD to EUR is: 0.8471 ``` Write your implementation of `get_exchange_rate` and ensure it meets the requirements specified above.","solution":"import requests import time import os def get_exchange_rate(cache_duration: int = 3600, cache_file: str = \\"exchange_rate_cache.txt\\") -> float: current_time = time.time() # Check if cache file exists and is within cache duration if os.path.exists(cache_file): with open(cache_file, \'r\') as file: cached_time, cached_rate = file.read().split() cached_time = float(cached_time) cached_rate = float(cached_rate) if current_time - cached_time < cache_duration: return cached_rate try: response = requests.get(\\"https://api.exchangerate-api.com/v4/latest/USD\\") response.raise_for_status() # Raise HTTPError for bad responses data = response.json() exchange_rate = data[\'rates\'][\'EUR\'] with open(cache_file, \'w\') as file: file.write(f\\"{current_time} {exchange_rate}\\") return exchange_rate except requests.RequestException as e: print(f\\"Error fetching data: {e}\\") if os.path.exists(cache_file): return cached_rate else: raise SystemExit(\\"Unable to fetch exchange rate and no cache is available.\\")"},{"question":"# Coding Assessment Question: Array Rotation for Minimum Value **Context**: As a software engineer, you are often tasked with optimizing and manipulating data structures to improve performance and efficiency. One common problem is to find the minimum value in a rotated sorted array. Your task is to write a function that achieves this goal. **Problem Statement**: Write a function named `find_min_in_rotated_array` that takes a rotated sorted array and returns the minimum element in the array. **Function Signature**: ```python def find_min_in_rotated_array(rotated_array: list[int]) -> int: :param rotated_array: A list of integers which is a sorted array initially, then rotated. :returns: An integer representing the minimum element in the rotated sorted array. ``` **Input**: - `rotated_array`: A list of integers where the array was initially sorted in ascending order and then rotated. **Output**: - An integer, which is the minimum element in the rotated sorted array. **Constraints**: - 1 ≤ length of rotated_array ≤ 10^5 - -10^4 ≤ each element in rotated_array ≤ 10^4 - Elements are unique. **Performance Requirements**: - The implementation should be optimized for time complexity, preferably O(log n), utilizing techniques like binary search. **Example**: ```python rotated_array = [4, 5, 6, 7, 0, 1, 2] print(find_min_in_rotated_array(rotated_array)) # Expected Output: 0 rotated_array = [11, 13, 15, 17, 19, 2, 5, 7] print(find_min_in_rotated_array(rotated_array)) # Expected Output: 2 rotated_array = [2, 3, 4, 5, 6, 7, 8, 1] print(find_min_in_rotated_array(rotated_array)) # Expected Output: 1 ``` Your implementation will be tested against various cases, including large inputs to check for efficiency. Ensure the correctness and optimize the algorithm to handle different scenarios effectively, especially focusing on edge cases and performance. This question requires a deep understanding of algorithms, particularly binary search, to achieve optimal performance.","solution":"def find_min_in_rotated_array(rotated_array: list[int]) -> int: Finds the minimum element in a rotated sorted array. :param rotated_array: A list of integers which is a sorted array initially, then rotated. :returns: An integer representing the minimum element in the rotated sorted array. left, right = 0, len(rotated_array) - 1 if rotated_array[left] <= rotated_array[right]: # Array is not rotated return rotated_array[left] while left < right: mid = (left + right) // 2 if rotated_array[mid] > rotated_array[right]: left = mid + 1 else: right = mid return rotated_array[left] # Examples to illustrate how the solution works: # rotated_array = [4, 5, 6, 7, 0, 1, 2] # print(find_min_in_rotated_array(rotated_array)) # Output: 0"},{"question":"# Coding Assessment Question Context You are developing a file processing system and need to ensure that file extensions being uploaded conform to a whitelist of acceptable extensions. To streamline this process, you will create a function to validate file extensions. Task Write a function `is_valid_extension(filename: str, allowed_extensions: List[str]) -> bool` that returns `True` if the file extension of the input `filename` is found in the `allowed_extensions` list, and `False` otherwise. Your function should correctly handle filenames with no extension or filenames ending with a dot. Input * A string `filename`, where `1 <= len(filename) <= 255`. * A list of strings `allowed_extensions`, where `1 <= len(allowed_extensions) <= 100` and each extension is a non-empty string. Output * A boolean value: `True` if the `filename`\'s extension is in `allowed_extensions`, otherwise `False`. Constraints * Filenames and extensions should be case-insensitive. * An extension in the allowed list will not include the leading dot. * You should handle edge cases such as filenames without extensions or filenames ending with a dot correctly. Examples ```python assert is_valid_extension(\\"example.txt\\", [\\"txt\\", \\"pdf\\", \\"doc\\"]) == True assert is_valid_extension(\\"example.pdf\\", [\\"txt\\", \\"pdf\\", \\"doc\\"]) == True assert is_valid_extension(\\"example\\", [\\"txt\\", \\"pdf\\", \\"doc\\"]) == False assert is_valid_extension(\\"example.\\", [\\"txt\\", \\"pdf\\", \\"doc\\"]) == False assert is_valid_extension(\\"example.TXT\\", [\\"txt\\", \\"pdf\\", \\"doc\\"]) == True assert is_valid_extension(\\"example.jpeg\\", [\\"jpg\\", \\"jpeg\\", \\"png\\"]) == True assert is_valid_extension(\\"example.docx\\", [\\"doc\\", \\"pdf\\"]) == False ``` **Note**: Ensure to handle the case-insensitivity comparison and edge cases thoughtfully to meet the specified requirements.","solution":"from typing import List def is_valid_extension(filename: str, allowed_extensions: List[str]) -> bool: # Strip the extension from the filename if \'.\' not in filename or filename.endswith(\'.\'): return False # Get the extension and make it case insensitive extension = filename.rsplit(\'.\', 1)[-1].lower() # Convert allowed extensions to a set for O(1) look-up time and case insensitive allowed_extensions_set = {ext.lower() for ext in allowed_extensions} # Check if the extension is in the allowed extensions return extension in allowed_extensions_set"},{"question":"# Question Binary Tree Level Order Traversal You are required to implement an algorithm to perform a level order traversal (also known as breadth-first traversal) of a binary tree. The algorithm should return a list of lists, where each inner list contains the values of the nodes at that level in the tree, from left to right. Function Signature ```python def level_order_traversal(root: \'TreeNode\') -> list[list[int]]: ``` Input * `root`: The root node of a binary tree. It can be `None` for an empty tree. Output * A list of lists, where each inner list contains the values of the nodes at each level of the tree, starting from the root level to the leaf level. Performance Requirements * The solution should run in O(n) time complexity, where n is the number of nodes in the tree. Description and Steps 1. If the tree is empty, return an empty list. 2. Use a queue to help traverse each level of the tree. 3. Start by adding the root node to the queue. 4. While the queue is not empty, repeat the following steps: 1. Determine the number of nodes at the current level. 2. Initialize an empty list to hold the values of the nodes at the current level. 3. For each node at the current level, remove it from the queue and add its value to the current level\'s list. 4. Add the left and right children of each node to the queue (if they exist). 5. Append the current level\'s list to the final result. 6. Return the final result containing lists of node values level by level. # Example ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(level_order_traversal(root)) # Output: [[3], [9, 20], [15, 7]] print(level_order_traversal(None)) # Output: [] print(level_order_traversal(TreeNode(42))) # Output: [[42]] ``` Considerations * Handling of edge cases such as an empty tree or a tree with only a single node. * Ensuring that the algorithm works efficiently for large trees. * Correctly capturing and returning the values level by level for accurate breadth-first traversal representation.","solution":"from collections import deque from typing import Optional, List class TreeNode: def __init__(self, val=0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# String Pattern Matching in Text Context: You are given a string and a pattern, and your task is to determine whether the pattern appears in the string. This is a common problem in text processing and often arises in tasks like searching for keywords in documents, DNA sequence matching, etc. Problem Statement: Write a function `search_pattern(text: str, pattern: str) -> bool` that checks if the given `pattern` exists in the `text`. Input: - `text` (str): The text in which to search for the pattern. - `pattern` (str): The pattern to search for within the text. Output: - Returns a boolean: `True` if the pattern is found in the text, otherwise `False`. Constraints: - (1 leq text{len(text)}, text{len(pattern)} leq 10^4) Example: ```python >>> search_pattern(\\"hello world\\", \\"world\\") True >>> search_pattern(\\"hello world\\", \\"worlds\\") False >>> search_pattern(\\"abababab\\", \\"abab\\") True >>> search_pattern(\\"testing123\\", \\"1234\\") False ``` Performance Requirements: - The function should efficiently handle the given constraint sizes. Note: - You can assume that the input text and pattern are non-empty and contain only ASCII characters. # Implementation Constraints: - Use efficient algorithms such as the Knuth-Morris-Pratt (KMP) algorithm or the Rabin-Karp algorithm for pattern searching. - Avoid using built-in string matching functions (like `in` operator or `find` method in Python). # Solution Template: ```python def search_pattern(text: str, pattern: str) -> bool: # Your implementation here pass # Example usage: if __name__ == \\"__main__\\": text = \\"hello world\\" pattern = \\"world\\" print(search_pattern(text, pattern)) # Expected output: True ```","solution":"def search_pattern(text: str, pattern: str) -> bool: def build_kmp_table(pattern: str): m = len(pattern) kmp_table = [0] * m j = 0 for i in range(1, m): if pattern[i] == pattern[j]: j += 1 kmp_table[i] = j else: if j != 0: j = kmp_table[j-1] i -= 1 else: kmp_table[i] = 0 return kmp_table n = len(text) m = len(pattern) kmp_table = build_kmp_table(pattern) i = 0 j = 0 while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: return True elif i < n and pattern[j] != text[i]: if j != 0: j = kmp_table[j-1] else: i += 1 return False"},{"question":"# Question You are required to develop a function `calculate_pollution_risk` that evaluates the pollution risk level for a list of cities based on provided pollution index data. Each city\'s pollution risk should be categorized into one of four levels: \\"Low\\", \\"Moderate\\", \\"High\\", and \\"Severe\\". Specifications - Function: `calculate_pollution_risk(data: dict[str, float]) -> dict[str, str]` - **Input**: - `data`: A dictionary where keys are city names (strings) and values are their respective pollution indices (floats). - **Output**: - A dictionary where keys are city names and values are strings indicating their pollution risk level (\\"Low\\", \\"Moderate\\", \\"High\\", or \\"Severe\\"). Pollution Risk Criteria - \\"Low\\": Pollution index < 50 - \\"Moderate\\": 50 <= Pollution index < 100 - \\"High\\": 100 <= Pollution index < 200 - \\"Severe\\": Pollution index >= 200 Constraints - You may assume that all city names are unique. - There will be at most 500 cities in the input dictionary. - Pollution index will be a non-negative float and can be as high as 1000. Example ```python >>> data = {\\"CityA\\": 45.0, \\"CityB\\": 78.5, \\"CityC\\": 120.3, \\"CityD\\": 305.2} >>> calculate_pollution_risk(data) {\\"CityA\\": \\"Low\\", \\"CityB\\": \\"Moderate\\", \\"CityC\\": \\"High\\", \\"CityD\\": \\"Severe\\"} ```","solution":"def calculate_pollution_risk(data): Returns a dictionary categorizing the pollution risk level for each city based on its pollution index. Parameters: data (dict): A dictionary where keys are city names (strings) and values are their pollution indices (floats). Returns: dict: A dictionary where keys are city names and values are the pollution risk levels (\\"Low\\", \\"Moderate\\", \\"High\\", or \\"Severe\\"). risk_levels = {} for city, index in data.items(): if index < 50: risk_levels[city] = \\"Low\\" elif 50 <= index < 100: risk_levels[city] = \\"Moderate\\" elif 100 <= index < 200: risk_levels[city] = \\"High\\" else: risk_levels[city] = \\"Severe\\" return risk_levels"},{"question":"# Question You are required to design an algorithm that identifies and extracts all unique words from a given text and returns them in alphabetical order. Additionally, your function should disregard common English stop words to focus on meaningful words. # Requirements Your function should: 1. Tokenize the input text into words. 2. Filter out stop words from the tokenized list. 3. Identify unique words from the filtered list. 4. Return the unique words sorted in alphabetical order. # Function Signature ```python def extract_unique_words(text: str, stop_words: set) -> list: Extract and return unique words in alphabetical order after filtering out stop words. :param text: Input text string :param stop_words: Set of common English stop words :return: List of unique words in alphabetical order pass ``` # Input * `text` (str): A string containing the input text. * `stop_words` (set): A set containing common English stop words. # Output * Returns a list of unique words in alphabetical order after filtering out stop words. # Constraints * The input text can contain punctuation which should be removed during tokenization (e.g., commas, periods). * The unique words should be case-insensitive (i.e., treat \\"Word\\" and \\"word\\" as the same word). * The returned list should include only unique words, sorted in alphabetical order. # Sample Scenario Given the text `\\"Hello, this is a sample text. This text is for unit testing!\\"` and stop words `{\\"this\\", \\"is\\", \\"a\\", \\"for\\"}`, the function should return `[\'hello\', \'sample\', \'text\', \'testing\', \'unit\']`. # Implementation Details You might find it useful to use regular expressions for tokenizing the words and to handle punctuation. Converting all words to lower case would help in ensuring case insensitivity.","solution":"import re def extract_unique_words(text: str, stop_words: set) -> list: Extract and return unique words in alphabetical order after filtering out stop words. :param text: Input text string :param stop_words: Set of common English stop words :return: List of unique words in alphabetical order # Convert text to lower case to ensure case insensitivity text = text.lower() # Use regex to find all words (tokens) while ignoring punctuation words = re.findall(r\'bw+b\', text) # Filter out stop words meaningful_words = [word for word in words if word not in stop_words] # Identify unique words unique_words = set(meaningful_words) # Return the unique words sorted in alphabetical order return sorted(unique_words)"},{"question":"**Context**: In analog signal processing, the concept of a moving average filter is widely used to smooth out noise in signals. The moving average filter calculates the average of a fixed number of the most recent data points. **Task**: Write a function `moving_average(sequence, k)` that computes the moving average of a given list of numbers using a window size of `k`. The function should: - Take a list of integers `sequence` and an integer `k` as input. - Return a list of floating-point numbers, representing the moving average of the input list. The moving average for `sequence[i]` is computed by averaging the previous `k` elements, including `sequence[i]`. For the first `k`-1 elements, return `None` since a full window cannot be computed. **Constraints**: - The list `sequence` will have at least one element and at most `10^5` elements. - The window size `k` is a positive integer and will be less than or equal to the length of `sequence`. **Examples**: ```python >>> moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) [None, None, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] >>> moving_average([10, 20, 30, 40, 50], 2) [None, 15.0, 25.0, 35.0, 45.0] >>> moving_average([1, 2, 3, 4, 5], 5) [None, None, None, None, 3.0] ``` **Hint**: Consider using a sliding window technique to efficiently compute the moving averages without recalculating sums from scratch for each position.","solution":"def moving_average(sequence, k): Computes the moving average of a given list of numbers using a window size of k. For the first (k-1) elements, return None since a full window cannot be computed. :param sequence: List[int] - list of integers :param k: int - window size :return: List[float] - list of floating-point numbers, representing the moving average if not sequence or k <= 0: return [] n = len(sequence) result = [None] * (k - 1) # For the first (k-1) elements window_sum = sum(sequence[:k]) for i in range(k, n + 1): result.append(window_sum / k) if i < n: window_sum = window_sum - sequence[i - k] + sequence[i] return result"},{"question":"# Coding Assessment Question **Scenario**: When dealing with string manipulation, one common task is to identify and count unique characters in a string. This challenge is encountered in various applications like text processing, data compression algorithms, and cryptographic systems. Efficiently determining the number of unique characters can be critical in optimizing storage and transmission of textual data. **Problem Statement**: You are required to implement a function that counts the number of unique characters in a given string. Design the following function in Python: 1. `count_unique_characters(text: str) -> int`: This function returns the count of unique characters in the `text`. # Function Signature ```python def count_unique_characters(text: str) -> int: pass ``` # Input and Output Format * **Input**: * `text` (str): A string consisting of ASCII characters. * **Output**: * Returns an integer representing the number of unique characters in the string. # Constraints * The input string can have a length of up to 10^4 characters. * The string will only contain printable ASCII characters (i.e., characters with ASCII codes between 32 and 126 inclusive). # Example ```python assert count_unique_characters(\\"hello\\") == 4 assert count_unique_characters(\\"abcdef\\") == 6 assert count_unique_characters(\\"abcdeffedcba\\") == 6 assert count_unique_characters(\\"\\") == 0 assert count_unique_characters(\\"111222333\\") == 3 ``` Implement this function as specified, ensuring to handle the potential edge cases where the string could be empty or contain all unique characters.","solution":"def count_unique_characters(text: str) -> int: Count the number of unique characters in the input text. Parameters: text (str): The string in which to count unique characters. Returns: int: The number of unique characters in the text. return len(set(text))"},{"question":"# Problem Statement Develop a class that manages a collection of tasks, supporting functionalities to add, remove, mark as complete, and list tasks. Each task in the collection will have a title, description, and status (either incomplete or complete). # Class Definition - Implement a class `TaskManager` that provides functionalities for task management. - Each task should be represented as a dictionary with `\\"title\\"`, `\\"description\\"`, and `\\"status\\"` keys. - The class should be initialized with an empty list of tasks. # Functional Requirements 1. **Add Task**: - `add_task(title: str, description: str) -> None` - Add a new task with the given title and description. Default status should be incomplete. 2. **Remove Task**: - `remove_task(title: str) -> bool` - Remove the task with the given title. Return `True` if the task was successfully removed, or `False` if the task was not found. 3. **Mark Task as Complete**: - `mark_task_complete(title: str) -> bool` - Mark the task with the given title as complete. Return `True` if the status was successfully updated, or `False` if the task was not found. 4. **List Tasks**: - `list_tasks() -> list` - Return a list of all tasks. # Constraints - Task titles are unique strings. - Titles and descriptions are non-empty strings with a maximum length of 100 characters. # Input - `title` (str): Title of the task. - `description` (str): Description of the task. # Output - For `add_task()`: None. - For `remove_task()`: bool. - For `mark_task_complete()`: bool. - For `list_tasks()`: list of dictionaries, each dictionary containing keys `\\"title\\"`, `\\"description\\"`, and `\\"status\\"`. # Example ```python tm = TaskManager() tm.add_task(\\"Buy groceries\\", \\"Buy milk, eggs, and bread\\") tm.add_task(\\"Complete assignment\\", \\"Finish math homework\\") print(tm.list_tasks()) ``` should produce ```python [ {\\"title\\": \\"Buy groceries\\", \\"description\\": \\"Buy milk, eggs, and bread\\", \\"status\\": \\"incomplete\\"}, {\\"title\\": \\"Complete assignment\\", \\"description\\": \\"Finish math homework\\", \\"status\\": \\"incomplete\\"} ] ``` Calling ```python tm.mark_task_complete(\\"Buy groceries\\") print(tm.list_tasks()) ``` should produce ```python [ {\\"title\\": \\"Buy groceries\\", \\"description\\": \\"Buy milk, eggs, and bread\\", \\"status\\": \\"complete\\"}, {\\"title\\": \\"Complete assignment\\", \\"description\\": \\"Finish math homework\\", \\"status\\": \\"incomplete\\"} ] ``` And calling ```python tm.remove_task(\\"Complete assignment\\") print(tm.list_tasks()) ``` should produce ```python [ {\\"title\\": \\"Buy groceries\\", \\"description\\": \\"Buy milk, eggs, and bread\\", \\"status\\": \\"complete\\"} ] ``` # Scenario You are building a productivity application to help people manage their daily tasks. The application has basic task management features that allow users to keep track of their to-dos. Ensure the functionality is robust and handles edge cases, such as attempting to mark non-existent tasks as complete or removing tasks that don\'t exist. # Performance Requirements - The solution should efficiently handle operations with up to 1000 tasks. - The operations should maintain a time complexity of O(n) at worst, where n is the number of tasks. # Hints - Use a list to store tasks and perform operations by iterating through the list. - Make use of list comprehensions where possible to simplify code.","solution":"class TaskManager: def __init__(self): self.tasks = [] def add_task(self, title: str, description: str) -> None: Add a new task with the given title and description. Default status is \'incomplete\'. self.tasks.append({\\"title\\": title, \\"description\\": description, \\"status\\": \\"incomplete\\"}) def remove_task(self, title: str) -> bool: Remove the task with the given title. Return True if the task was successfully removed, or False if the task was not found. for task in self.tasks: if task[\\"title\\"] == title: self.tasks.remove(task) return True return False def mark_task_complete(self, title: str) -> bool: Mark the task with the given title as complete. Return True if the status was successfully updated, or False if the task was not found. for task in self.tasks: if task[\\"title\\"] == title: task[\\"status\\"] = \\"complete\\" return True return False def list_tasks(self) -> list: Return a list of all tasks. return self.tasks"},{"question":"# Distinct Permutations Finder Problem Statement Given an array of integers with possible duplicate elements, write a function to return all possible distinct permutations of the array. Write a function `find_permutations` that receives an array of integers and returns a list of lists, where each inner list is a distinct permutation of the array. The permutations can be in any order. Function Signature ```python def find_permutations(arr: List[int]) -> List[List[int]]: pass ``` # Input - `arr`: A list of integers where 1 ≤ length of array ≤ 8 and -10 ≤ element of array ≤ 10. # Output - A list of lists, where each list represents a distinct permutation of the input array. # Constraints - The function should handle arrays with duplicate values and return only unique permutations. Examples ```python print(find_permutations([1, 1, 2])) # Output: [[1,1,2],[1,2,1],[2,1,1]] print(find_permutations([1, 2, 3])) # Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] print(find_permutations([2, 2, 2])) # Output: [[2,2,2]] ``` Scenario You have an array of integers that represents choices or items that may not be all unique. Your task is to generate all possible unique sequences of these choices/items. This can be useful in scenarios where order matters, like generating unique sequences for testing, ensuring that every possible configuration is tested, or shuffling elements in a unique way. Ensure that the duplicate values in the array do not produce repeated permutations in the output.","solution":"from typing import List from itertools import permutations def find_permutations(arr: List[int]) -> List[List[int]]: Returns a list of all distinct permutations of the input array `arr`. # Use a set to avoid duplicate permutations perm_set = set(permutations(arr)) # Convert set of permutations back to a list of lists return [list(perm) for perm in perm_set]"},{"question":"# Task Description You are required to implement a function that simulates a water retention problem in a given topography and determines the maximum amount of water that can be trapped after raining. # Problem Statement Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute the maximum amount of water that can be trapped after raining. # Function Signature ```python def trap(height: List[int]) -> int: Calculates the maximum amount of water that can be trapped between the bars represented by the provided elevation map. ``` # Input * `height` (List[int]): A list of non-negative integers representing the elevation map. # Output * An integer representing the maximum amount of water that can be trapped. # Constraints * The length of the list will be between 0 and 10^4. * Each element in the list will be a non-negative integer no greater than 10^5. # Examples ```python >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([1,0,2]) 1 >>> trap([4,2,3]) 1 ``` # Additional Requirements 1. Use a two-pointer approach for an efficient (O(n)) solution. 2. Ensure the solution handles edge cases such as very short or flat elevation maps. 3. Avoid floating-point calculations to prevent precision issues. # Scenario Your task is to efficiently calculate how much water can be trapped given the varying heights of an elevation map, optimizing the solution for performance and accuracy.","solution":"from typing import List def trap(height: List[int]) -> int: Calculates the maximum amount of water that can be trapped between the bars represented by the provided elevation map. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"# Problem Statement You are provided with a list containing `(x, y)` coordinate pairs representing positions on a 2D grid. Your task is to implement a function that sorts these pairs based on their distance from the origin `(0, 0)`. The distance should be calculated using the Euclidean distance formula: `sqrt(x^2 + y^2)`. If two points have the same distance from the origin, they should be sorted by their x-coordinate, and if their x-coordinates are the same, then by their y-coordinate. # Requirements 1. Implement a function `sort_coordinates_by_distance(lst: list[tuple[int, int]]) -> list[tuple[int, int]]` that returns a new list of coordinate pairs sorted based on the aforementioned criteria. 2. Handle edge cases such as empty lists and lists containing a single coordinate pair effectively. 3. Ensure that all coordinates are valid integers and handle invalid input gracefully. # Function Signature Complete the function `sort_coordinates_by_distance` adhering to the following signature: ```python def sort_coordinates_by_distance(lst: list[tuple[int, int]]) -> list[tuple[int, int]]: pass ``` # Input and Output * **Input**: A list `lst` containing tuples representing `(x, y)` coordinate pairs. * `0 <= len(lst) <= 10^6` * Each tuple contains two integer values representing the x and y coordinates respectively, and these values fit in a 32-bit signed integer. * **Output**: A new list of coordinate pairs sorted based on their distance from the origin. # Constraints * The sorting algorithm should accurately sort up to 10^6 coordinate pairs. * Each coordinate pair in the input list is valid and contains exactly two integers. # Example ```python >>> coordinates = [(1, 2), (0, 0), (5, 5), (3, 1)] >>> result = sort_coordinates_by_distance(coordinates) >>> print(result) [(0, 0), (1, 2), (3, 1), (5, 5)] >>> coordinates = [(2, 3), (3, 2), (1, 1)] >>> result = sort_coordinates_by_distance(coordinates) >>> print(result) [(1, 1), (2, 3), (3, 2)] >>> coordinates = [(10, 10), (7, 24), (-3, 4)] >>> result = sort_coordinates_by_distance(coordinates) >>> print(result) [(-3, 4), (10, 10), (7, 24)] ``` # Notes * Focus on accurately computing distances and maintaining correct sequence in case of ties. * Assume inputs are valid coordinate pairs, handle gracefully if any coordinate doesn\'t meet the required format or range.","solution":"def sort_coordinates_by_distance(lst): from math import sqrt def distance_from_origin(pt): x, y = pt return sqrt(x**2 + y**2) sorted_lst = sorted(lst, key=lambda pt: (distance_from_origin(pt), pt[0], pt[1])) return sorted_lst"},{"question":"# Problem Statement Given an array of integers, design and implement an algorithm that finds two distinct indices `i` and `j` in the array such that the sum of the elements at those indices equals a given target value. Your solution should return both indices in the form of a tuple. If no such indices exist, return `None`. # Function Signature ```python def two_sum(nums: list[int], target: int) -> tuple[int, int] or None: pass ``` # Input - `nums`: A list of integers representing the array. - `target`: An integer, the target sum you need to find. # Output - The function should return a tuple of two integers representing the indices `i` and `j` where `nums[i] + nums[j] = target`. - If no such indices exist, return `None`. # Constraints - 2 ≤ len(nums) ≤ 10^5 - -10^9 ≤ nums[i] ≤ 10^9 - -10^9 ≤ target ≤ 10^9 # Example ```python nums = [2, 7, 11, 15] target = 9 result = two_sum(nums, target) print(result) # Expected: (0, 1) nums = [1, 2, 3, 4, 5] target = 10 result = two_sum(nums, target) print(result) # Expected: None ``` # Notes - The function should have a time complexity of O(n). - Ensure the indices `i` and `j` are distinct (i.e., `i ≠ j`). - Consider edge cases where the array has fewer than two elements or all elements are the same but don\'t sum to the target value.","solution":"def two_sum(nums: list[int], target: int) -> tuple[int, int] or None: Returns two distinct indices i and j such that nums[i] + nums[j] equals the target. If no such indices exist, returns None. # Create a dictionary to store the number and its index num_dict = {} for index, num in enumerate(nums): # Calculate the complement complement = target - num # Check if the complement is already in the dictionary if complement in num_dict: return (num_dict[complement], index) # Store the number and its index in the dictionary num_dict[num] = index # If no indices are found, return None return None"},{"question":"# Problem Statement Scenario You have been requested to write a function that handles text manipulation by reversing the words in a given sentence while maintaining the original word order. The requirement specifically excludes using any built-in functions that directly perform the reversal or manipulation of words within the string. Task Write a function `reverse_words` which takes a single string as input and returns a new string with each word reversed, but the order of words maintained. Input Format * A single string `s` containing words separated by spaces. The string will only consist of printable ASCII characters and spaces, with no leading or trailing spaces, and no consecutive spaces. Output Format * A single string with each word reversed while retaining original word order. Constraints * The length of the input string `s` will be between 1 and 1000 characters. * You may not use built-in functions like `split()`, `reverse()`, or `join()` which directly perform or assist in reversing words within the string. Example ```python reverse_words(\\"hello world\\") # Output: \\"olleh dlrow\\" reverse_words(\\"good morning\\") # Output: \\"doog gninrom\\" reverse_words(\\"reverse the words\\") # Output: \\"esrever eht sdrow\\" reverse_words(\\"coding is fun\\") # Output: \\"gnidoc si nuf\\" ``` Notes * Implement the function without using `split()`, `reverse()`, or `join()`. * Focus on implementing an efficient solution that handles the given constraints.","solution":"def reverse_words(s): Reverses each word in a given string s while maintaining the word order. Parameters: s (str): The input sentence string. Returns: str: A new string with each word reversed. result = [] word = [] for char in s: if char != \' \': word.append(char) else: while word: result.append(word.pop()) result.append(\' \') while word: result.append(word.pop()) return \'\'.join(result)"},{"question":"# Scenario You are working as a software developer for a logistics company. Your team needs a tool to estimate the shortest delivery time using the Dijkstra algorithm for different routes in a city. Each route has a specific travel time, and you will assume that all travel times between locations are positive. # Task Write a Python function `shortest_travel_time` to compute the shortest travel time between two locations in the city using Dijkstra\'s algorithm. The function should take in the graph of the city routes, the starting location, and the destination. # Input - `graph` (dict): A dictionary where each key is a starting location (str) and the value is another dictionary with neighboring locations as keys and travel times (float) as values. Travel times must be positive. - `start` (str): The starting location. - `end` (str): The destination location. # Output - Return a float representing the shortest travel time from the start to the end. - If the destination cannot be reached from the starting location, return `float(\'inf\')`. # Constraints 1. The graph must be represented as specified. 2. All travel times must be positive float numbers. 3. Raise `ValueError` with a descriptive message if any of the provided travel times are not positive. 4. Assume the graph is connected and contains at least one location and one route. # Examples ```python >>> graph = { ... \'A\': {\'B\': 1, \'C\': 4}, ... \'B\': {\'C\': 2, \'D\': 5}, ... \'C\': {\'D\': 1}, ... \'D\': {} ... } >>> shortest_travel_time(graph, \'A\', \'D\') 4.0 >>> shortest_travel_time(graph, \'A\', \'E\') float(\'inf\') >>> shortest_travel_time({\'A\': {\'B\': -1}}, \'A\', \'B\') Traceback (most recent call last): ... ValueError: Travel times must be positive ```","solution":"import heapq def shortest_travel_time(graph, start, end): Computes the shortest travel time between two locations in the city using Dijkstra\'s algorithm. Parameters: graph (dict): A dictionary representing the graph of city routes. Each key is a starting location (str) and the value is another dictionary with neighboring locations as keys and travel times (float) as values. start (str): The starting location. end (str): The destination location. Returns: float: The shortest travel time from start to end. If the destination cannot be reached, returns float(\'inf\'). Raises: ValueError: If any travel time provided in the graph is not positive. # Check for any non-positive travel times and raise ValueError if found for neighbors in graph.values(): for time in neighbors.values(): if time <= 0: raise ValueError(\\"Travel times must be positive\\") # Priority queue to store and fetch the current shortest travel time priority_queue = [(0, start)] # Dictionary to store the shortest known time to reach each location shortest_times = {start: 0} while priority_queue: current_time, current_location = heapq.heappop(priority_queue) if current_location == end: return current_time for neighbor, travel_time in graph.get(current_location, {}).items(): time = current_time + travel_time if neighbor not in shortest_times or time < shortest_times[neighbor]: shortest_times[neighbor] = time heapq.heappush(priority_queue, (time, neighbor)) return float(\'inf\')"},{"question":"# Coding Question **Context:** Arrays are a fundamental data structure in computer science, enabling efficient storage and access to sequences of values. A common operation involving arrays is the rotation, where elements are shifted to the left or right by a specified number of positions. **Task:** You are required to implement a function `rotate_array(arr: List[int], k: int) -> List[int]` that takes a list of integers and an integer, then rotates the array to the right by `k` steps and returns the modified array. **Function Signature:** ```python from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: ``` **Input:** * `arr` (List[int]): A list of integers. * `k` (int): A non-negative integer indicating the number of positions to rotate the array. **Output:** * A list of integers representing the array after being rotated to the right by `k` steps. **Constraints:** * The length of the array can be between 0 and 1000 inclusive. * The integers in the array can be between -1000 and 1000 inclusive. * `k` is a non-negative integer (`k >= 0`). **Examples:** ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3], 3) [1, 2, 3] >>> rotate_array([1], 3) [1] >>> rotate_array([], 3) [] ``` **Edge Cases:** * Inputs such as `rotate_array([1, 2, 3], 0)` should return `[1, 2, 3]` since no rotation is needed. * Inputs such as `rotate_array([1, 2, 3], 3)` should return `[1, 2, 3]` as rotating by the array\'s length results in the same array. * Inputs such as `rotate_array([1, 2, 3], -1)` should raise a `ValueError`. **Testing:** Use the following template to test your function: ```python if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. Parameters: arr (List[int]): A list of integers. k (int): A non-negative integer indicating the number of positions to rotate the array. Returns: List[int]: The rotated array. if k < 0: raise ValueError(\\"k must be a non-negative integer\\") n = len(arr) if n == 0: return arr k = k % n # Handle the case where k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"# Movie Database Management Objective Develop a `MovieDatabase` application that manages a collection of movies. The application should support adding new movies with various attributes, searching for movies by title or director, and calculating summary statistics such as the average rating and total duration of all movies in the database. Instructions 1. **Class Definition**: Write a class `MovieDatabase` that: - Maintains a list of movies, where each movie has a title, director, release year, duration (in minutes), and rating (out of 10). - Provides methods to add new movies to the database. - Allows searching movies by title or director. - Calculates the total duration and average rating of the movies in the database. 2. **Class Methods**: - `add_movie(title: str, director: str, year: int, duration: int, rating: float) -> None`: Adds a movie to the database. - `search_by_title(title: str) -> list`: Returns a list of movies with the given title. - `search_by_director(director: str) -> list`: Returns a list of movies directed by the given director. - `total_duration() -> int`: Returns the sum of the durations of all movies in the database. - `average_rating() -> float`: Returns the average rating of all movies in the database. 3. **Validation**: - Ensure that movie titles and directors\' names are non-empty strings. - Ensure that the year is a positive integer and not greater than the current year. - Ensure that the duration is a positive integer not exceeding 300 minutes. - Ensure that the rating is a float between 0 and 10. # Example Here\'s an example of how your `MovieDatabase` can be used: ```python db = MovieDatabase() db.add_movie(\\"Inception\\", \\"Christopher Nolan\\", 2010, 148, 8.8) db.add_movie(\\"The Dark Knight\\", \\"Christopher Nolan\\", 2008, 152, 9.0) db.add_movie(\\"Interstellar\\", \\"Christopher Nolan\\", 2014, 169, 8.6) db.add_movie(\\"Titanic\\", \\"James Cameron\\", 1997, 195, 7.8) print(\\"Movies directed by Christopher Nolan:\\", db.search_by_director(\\"Christopher Nolan\\")) print(\\"Total Duration:\\", db.total_duration()) print(\\"Average Rating:\\", db.average_rating()) ``` Constraints - Movie titles and directors\' names must be non-empty strings. - Year must be a valid integer representing a year not greater than the current year. - Duration must be a positive integer between 1 and 300 minutes. - Rating must be a float between 0.0 and 10.0.","solution":"import datetime class MovieDatabase: def __init__(self): self.movies = [] def add_movie(self, title: str, director: str, year: int, duration: int, rating: float) -> None: # Validation current_year = datetime.datetime.now().year if not title or not director: raise ValueError(\\"Title and Director cannot be empty.\\") if not (0 < year <= current_year): raise ValueError(\\"Year must be a positive integer and not greater than the current year.\\") if not (1 <= duration <= 300): raise ValueError(\\"Duration must be between 1 and 300 minutes.\\") if not (0 <= rating <= 10): raise ValueError(\\"Rating must be between 0 and 10.\\") self.movies.append({ \'title\': title, \'director\': director, \'year\': year, \'duration\': duration, \'rating\': rating }) def search_by_title(self, title: str) -> list: return [movie for movie in self.movies if movie[\'title\'] == title] def search_by_director(self, director: str) -> list: return [movie for movie in self.movies if movie[\'director\'] == director] def total_duration(self) -> int: return sum(movie[\'duration\'] for movie in self.movies) def average_rating(self) -> float: if not self.movies: return 0.0 return sum(movie[\'rating\'] for movie in self.movies) / len(self.movies) # Usage # db = MovieDatabase() # db.add_movie(\\"Inception\\", \\"Christopher Nolan\\", 2010, 148, 8.8) # db.add_movie(\\"The Dark Knight\\", \\"Christopher Nolan\\", 2008, 152, 9.0) # db.add_movie(\\"Interstellar\\", \\"Christopher Nolan\\", 2014, 169, 8.6) # db.add_movie(\\"Titanic\\", \\"James Cameron\\", 1997, 195, 7.8) # # print(\\"Movies directed by Christopher Nolan:\\", db.search_by_director(\\"Christopher Nolan\\")) # print(\\"Total Duration:\\", db.total_duration()) # print(\\"Average Rating:\\", db.average_rating())"},{"question":"# Complex Number Multiplication You need to write a function to multiply two complex numbers. Complex numbers are represented as strings in the form \\"a+bi\\", where a and b are integers, and \\"i\\" is the imaginary unit. The result should also be presented as a string in the same format. Function Signature ```python def multiply_complex_numbers(num1: str, num2: str) -> str: ``` Inputs - `num1` (str): The first complex number in the format \\"a+bi\\". - `num2` (str): The second complex number in the format \\"a+bi\\". Output - (str): The result of the multiplication, expressed as a string in the format \\"a+bi\\". Constraints - The input string is always in the valid format for a complex number. - The integers in the complex number string can be negative. - Leading zeros in the integers should be avoided in the output. Example Usage ```python >>> multiply_complex_numbers(\\"1+1i\\", \\"1+1i\\") \'0+2i\' >>> multiply_complex_numbers(\\"1+-1i\\", \\"1+-1i\\") \'0+-2i\' >>> multiply_complex_numbers(\\"3+2i\\", \\"1+-4i\\") \'11+-10i\' >>> multiply_complex_numbers(\\"0+0i\\", \\"5+3i\\") \'0+0i\' ``` Explanation Write a function that: 1. Parses the real and imaginary parts of the two input complex numbers. 2. Applies the complex number multiplication formula: [(a + bi) cdot (c + di) = (ac - bd) + (ad + bc)i] 3. Constructs and returns the resulting complex number in the correct format.","solution":"def multiply_complex_numbers(num1: str, num2: str) -> str: def parse_complex(num: str): parts = num[:-1].split(\'+\') real = int(parts[0]) imag = int(parts[1]) return real, imag real1, imag1 = parse_complex(num1) real2, imag2 = parse_complex(num2) real_result = real1 * real2 - imag1 * imag2 imag_result = real1 * imag2 + imag1 * real2 return f\\"{real_result}+{imag_result}i\\""},{"question":"Question: Detect and Delete a Node in a Cycle Linked List # Scenario You are developing a function for a linked list data structure. Your objective is to identify if a cycle exists in the linked list and, if a cycle is detected, remove the node that causes the cycle to be formed while preserving the remaining nodes. # Implementation Requirements - Implement a function `detect_and_remove_cycle(head: ListNode) -> ListNode` that identifies a cycle in a linked list and removes the node causing the cycle. # Input - A singly linked list represented by its head node. # Output - The head node of the linked list after removing the cycle, if it exists. The list should not contain any cycles afterward. # Constraints - The list can have zero or more nodes. - Use a consistent definition for the linked list node (`ListNode` class as shown in the examples). # Example ```python class ListNode: def __init__(self, x): self.val = x self.next = None # Example 1: # Given: head -> [3] -> [2] -> [0] -> [-4] --| # ↑---------------------------| head = ListNode(3) head.next = ListNode(2) head.next.next = ListNode(0) head.next.next.next = ListNode(-4) head.next.next.next.next = head.next head = detect_and_remove_cycle(head) # Output: head -> 3 -> 2 -> 0 -> -4 # Example 2: # Given: head -> [1] -> [2] --| # ↑------------| head = ListNode(1) head.next = ListNode(2) head.next.next = head head = detect_and_remove_cycle(head) # Output: head -> 1 -> 2 # Example 3: # Given: head -> [1] head = ListNode(1) head = detect_and_remove_cycle(head) # Output: head -> 1 ``` # Edge Cases - If the linked list does not contain any nodes, the function should return `None`. - If the linked list does not contain any cycles, the function should return the same linked list without modifications. - Ensure that the detection and removal of cycles handle linked lists of arbitrary length efficiently.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detect_and_remove_cycle(head: ListNode) -> ListNode: if not head or not head.next: return head slow, fast = head, head cycle_detected = False # Detect cycle using Floyd\'s Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_detected = True break if not cycle_detected: return head # Find the start node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next # To remove the cycle, find the node just before the start of the cycle # and set its next to None iterator = slow while iterator.next != slow: iterator = iterator.next iterator.next = None return head"},{"question":"# Problem Statement You are given an array of integers and a target sum. Your task is to write a function to determine if there exists a pair of numbers in the array whose sum is equal to the target sum. # Function Signature ```python def has_pair_with_sum(nums: List[int], target: int) -> bool: pass ``` # Input * `nums (List[int])`: A list of integers. * `target (int)`: The target sum as an integer. # Output * Returns `True` if there exists at least one pair of numbers in the array whose sum equals the target sum; otherwise, returns `False`. # Constraints * The length of the array will be between 1 and 10^5. * Each integer in the array can be between -10^9 and 10^9. * The function must run in linear time (O(n)) and use constant space (O(1)) in terms of the additional array or dictionary storage. # Requirements * Your solution should handle and validate all possible edge cases. * Pay attention to performance requirements; ensure that your solution runs efficiently within the given constraints. # Example ```python >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True >>> has_pair_with_sum([5, 7, 1, 2, 8, 4, 3], 10) True >>> has_pair_with_sum([1, -2, 3, -4], -1) True ``` # Implementation In this task, you are asked to implement the `has_pair_with_sum` function according to the provided specifications and constraints. The function should identify if there exists a pair of numbers in the array whose sum equals the target sum efficiently.","solution":"from typing import List def has_pair_with_sum(nums: List[int], target: int) -> bool: Determines if there exists a pair of numbers in the array whose sum is equal to the target sum. Args: nums: List[int] - A list of integers. target: int - The target sum. Returns: bool: True if there exists at least one pair of numbers whose sum equals the target sum, otherwise False. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"# Question: Fibonacci Sequence Checker and Sum You are tasked with implementing a function that checks if a list of numbers represents a portion of the Fibonacci sequence and another function that calculates the sum of that sequence. The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n >= 2 Implement the Following Functions: **1. Function `is_fibonacci_sequence(series: list) -> bool`:** * **Input**: A list of integers. * **Output**: A boolean value indicating whether the series follows the Fibonacci sequence. * **Constraints**: * Raise a `ValueError` for invalid (non-integer elements) or empty input. **2. Function `fibonacci_sum(series: list) -> int`:** * **Input**: A list of integers. * **Output**: An integer representing the sum of the series. * **Constraints**: * Raise a `ValueError` for invalid (non-integer elements) or empty input. Example ```python >>> is_fibonacci_sequence([0, 1, 1, 2, 3, 5, 8]) True >>> is_fibonacci_sequence([2, 3, 5, 8]) False >>> is_fibonacci_sequence([1, 1, 2, 3, 5]) True >>> is_fibonacci_sequence([5, 8, 13]) False >>> is_fibonacci_sequence([0]) True >>> fibonacci_sum([0, 1, 1, 2, 3, 5, 8]) 20 >>> fibonacci_sum([1, 1, 2]) 4 >>> fibonacci_sum([2, 3, 5]) 10 >>> fibonacci_sum([0, 1, 1]) 2 >>> fibonacci_sum([13, 21]) 34 ``` Notes: * Consider edge cases, such as improper series input and single-element lists. * The sum of an empty series or an invalid series should raise a `ValueError`. Performance Requirements * Your implementations should be O(n) in time complexity and O(1) in space complexity. **Good Luck!**","solution":"def is_fibonacci_sequence(series): Checks if the provided series is a portion of the Fibonacci sequence. :param series: list of integers :return: bool indicating whether the series is part of the Fibonacci sequence if not isinstance(series, list) or not series: raise ValueError(\\"Input must be a non-empty list.\\") if not all(isinstance(x, int) for x in series): raise ValueError(\\"All elements in the list must be integers.\\") if len(series) == 1: return series[0] == 0 or series[0] == 1 fib1, fib2 = 0, 1 if series[0] != 0 and series[0] != 1: return False for num in series: if num != fib1 and num != fib2: return False fib1, fib2 = fib2, fib1 + fib2 return True def fibonacci_sum(series): Calculates the sum of the provided Fibonacci series. :param series: list of integers :return: int sum of the series if not isinstance(series, list) or not series: raise ValueError(\\"Input must be a non-empty list.\\") if not all(isinstance(x, int) for x in series): raise ValueError(\\"All elements in the list must be integers.\\") if not is_fibonacci_sequence(series): raise ValueError(\\"The list is not a valid Fibonacci sequence.\\") return sum(series)"},{"question":"# Question: You are tasked with designing a system that tracks product inventory in a warehouse using an efficient storage and retrieval mechanism. Your goal is to implement a function `inventory_management` that simulates an inventory system allowing product addition, removal, and query operations. **Function Signature**: ```python def inventory_management(operations: List[Tuple[str, Union[str, int]]]) -> List[int]: # implement the function ``` # Requirements: 1. **Input Format**: - `operations`: A list of tuples, where each tuple contains an operation. - `\\"ADD\\"`: A product is added to the inventory with a unique identifier. The tuple format is `(\\"ADD\\", \\"product_id\\")`. - `\\"REMOVE\\"`: A product is removed from the inventory with its identifier. The tuple format is `(\\"REMOVE\\", \\"product_id\\")`. - `\\"QUERY\\"`: Returns the total number of unique products currently in the inventory. The tuple format is `(\\"QUERY\\", index)`, where `index` is the query index to maintain order. 2. **Output Format**: - A list of integers, where each integer represents the result of a `\\"QUERY\\"` operation. # Constraints: - The number of operations is between `1` and `10^5`. - Product identifiers are strings with a length between `1` and `50`. - It is guaranteed that for any `\\"REMOVE\\"` operation, the product exists in the inventory. # Performance Requirements: - Ensure that your implementation handles up to `100,000` operations efficiently. # Example: ```python operations = [ (\\"ADD\\", \\"product_1\\"), (\\"ADD\\", \\"product_2\\"), (\\"QUERY\\", 0), (\\"REMOVE\\", \\"product_1\\"), (\\"QUERY\\", 1) ] result = inventory_management(operations) print(result) # Output: [2, 1] ``` # Function Behavior: 1. For the `\\"ADD\\"` operation, add the product identifier to the inventory. 2. For the `\\"REMOVE\\"` operation, remove the product identifier from the inventory. 3. For the `\\"QUERY\\"` operation, return the current count of unique product identifiers in the inventory. # Additional Notes: - Handle the operations in the order they are given to ensure the integrity of the inventory state. - Consider efficient data structures to manage the addition, removal, and count operations. # Hints: * Utilize a `set` for tracking unique product identifiers efficiently. * Maintain the order of queries to match them with the correct index.","solution":"from typing import List, Tuple, Union def inventory_management(operations: List[Tuple[str, Union[str, int]]]) -> List[int]: inventory = set() results = [] for operation in operations: if operation[0] == \\"ADD\\": inventory.add(operation[1]) elif operation[0] == \\"REMOVE\\": inventory.remove(operation[1]) elif operation[0] == \\"QUERY\\": results.append(len(inventory)) return results"},{"question":"# Graph Shortest Path Algorithm Graphs are data structures that consist of vertices (or nodes) connected by edges. Finding the shortest path from one vertex to another is a common problem which can be efficiently solved using algorithms like Dijkstra\'s algorithm. # Objective: Implement a function that computes the shortest path from a starting vertex to a target vertex in a weighted graph using Dijkstra\'s algorithm. # Context: You are asked to design a navigation system that helps users find the quickest route between two locations. Given that each road (edge) has a specified travel time (weight), your task is to compute the shortest travel time between their start and end points. # Function Signature: ```python def dijkstra_shortest_path(graph: Dict[Any, Dict[Any, int]], start: Any, target: Any) -> Optional[int]: pass ``` # Input: - `graph`: A dictionary representing the weighted graph, where keys are vertices and values are dictionaries with adjacent vertices as keys and edge weights as values. - `start`: The starting vertex. - `target`: The target vertex. # Output: - Returns the minimum travel time (sum of edge weights) from the starting vertex to the target vertex. If there is no path, return `None`. # Constraints: - Assume the graph has no negative weight edges. - The graph might be disconnected, so some vertices might not have a path to the target. - Vertices and edge weights are non-negative integers. # Performance Requirements: - The solution should aim to run in O((V + E) log V) time complexity, where V is the number of vertices and E is the number of edges. # Scenario: ```python # Let\'s assume we have the following graph structure stored as an adjacency list: # A # / | # B C D # | / # E # with the following edge weights: # A-B: 1, A-C: 4, A-D: 2, B-E: 2, C-E: 1, D-E: 3 graph = { \'A\': {\'B\': 1, \'C\': 4, \'D\': 2}, \'B\': {\'E\': 2}, \'C\': {\'E\': 1}, \'D\': {\'E\': 3}, \'E\': {} } # Example test cases: print(dijkstra_shortest_path(graph, \'A\', \'E\')) # 3 (A -> B -> E or A -> D -> E) print(dijkstra_shortest_path(graph, \'A\', \'C\')) # 4 (A -> C) print(dijkstra_shortest_path(graph, \'A\', \'D\')) # 2 (A -> D) print(dijkstra_shortest_path(graph, \'E\', \'A\')) # None (No path from E to A) ``` # Hints: 1. Utilize a priority queue (such as the heapq module in Python) to efficiently fetch the next vertex with the shortest tentative distance. 2. Keep track of the shortest distance to each vertex, updating it as you find shorter paths during the algorithm. Formulate your function to parse and compute the shortest paths according to these principles and scenarios.","solution":"import heapq from typing import Dict, Any, Optional def dijkstra_shortest_path(graph: Dict[Any, Dict[Any, int]], start: Any, target: Any) -> Optional[int]: Implements Dijkstra\'s algorithm to find the shortest path in a graph. Parameters: graph (Dict[Any, Dict[Any, int]]): The weighted graph where key is the node and value is a dictionary of adjacent nodes and their edge weights. start (Any): The starting vertex. target (Any): The target vertex. Returns: Optional[int]: The minimum travel time (sum of edge weights) from the start to the target vertex, or None if no such path exists. # Priority queue for the minimum distance search priority_queue = [(0, start)] # Dictionary to store the minimum distances to each vertex distances = {start: 0} # Set to keep track of visited nodes visited = set() while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the current vertex is the target, return the distance if current_vertex == target: return current_distance if current_vertex in visited: continue visited.add(current_vertex) # Explore neighbors for neighbor, weight in graph[current_vertex].items(): distance = current_distance + weight # If a shorter path to neighbor is found if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return None # If there\'s no path to the target"},{"question":"# Coding Assessment Question **Context:** You are tasked with implementing a text-based adventure game engine function that manages a player\'s movements within a fixed-size grid. The game world is a 2D grid where each cell can be represented by a pair of coordinates (x, y). The grid is bounded from (0, 0) to (9, 9), where (0, 0) is the top-left corner, and (9, 9) is the bottom-right corner. **Function Specification:** - **Function Name**: `update_position` - **Input**: - `current_position` (tuple of int): A tuple `(x, y)` representing the player\'s current coordinates on the grid. - `commands` (list of str): A list of movement commands, where each command is one of \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\". - **Output**: - A tuple `(x, y)` representing the player\'s new position after executing all the commands. **Input Constraints**: - `current_position` will always be a pair of integers within the range 0 to 9 inclusive. - Each command in `commands` will be a valid string as specified above. **Movement Rules**: - \\"UP\\" decreases the y-coordinate by 1 (if it doesn’t move the player out of bounds). - \\"DOWN\\" increases the y-coordinate by 1 (if it doesn’t move the player out of bounds). - \\"LEFT\\" decreases the x-coordinate by 1 (if it doesn’t move the player out of bounds). - \\"RIGHT\\" increases the x-coordinate by 1 (if it doesn’t move the player out of bounds). - The player cannot move outside the grid boundaries. **Edge Cases to Consider**: - Commands that result in moving out of bounds should be ignored. - An empty `commands` list should result in no change to the player\'s position. **Examples**: ```python >>> update_position((5, 5), [\\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\"]) (4, 4) >>> update_position((0, 0), [\\"LEFT\\", \\"UP\\"]) (0, 0) >>> update_position((9, 9), [\\"RIGHT\\", \\"DOWN\\"]) (9, 9) >>> update_position((2, 3), [\\"RIGHT\\", \\"RIGHT\\", \\"DOWN\\", \\"DOWN\\"]) (4, 5) ``` # Implementation Notes: - Ensure that the function handles edge cases appropriately, such as commands trying to move the player out of boundaries. - Strive for a clean and efficient implementation that checks the grid boundaries with each command.","solution":"def update_position(current_position, commands): Update the player\'s position based on a list of movement commands. Parameters: current_position (tuple of int): A tuple (x, y) representing the player\'s current coordinates on the grid. commands (list of str): A list of movement commands, where each command is one of \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\". Returns: tuple of int: A tuple (x, y) representing the player\'s new position after executing all the commands. x, y = current_position for command in commands: if command == \\"UP\\" and y > 0: y -= 1 elif command == \\"DOWN\\" and y < 9: y += 1 elif command == \\"LEFT\\" and x > 0: x -= 1 elif command == \\"RIGHT\\" and x < 9: x += 1 return (x, y)"},{"question":"# Problem Statement Given an array of integers, write a function to find the first missing positive integer that does not appear in the array. Function Signature ```python def first_missing_positive(nums: list[int]) -> int: ``` Input - A list of integers `nums` which can contain both positive and negative integers. - The list can have duplicates and can be of any size between 1 and 10^6. Output - Return the smallest positive integer that does not appear in the list. Constraints - The list will not be empty. - The integers can range from -10^9 to 10^9. Examples ```python assert first_missing_positive([3, 4, -1, 1]) == 2 assert first_missing_positive([1, 2, 0]) == 3 assert first_missing_positive([7, 8, 9, 11, 12]) == 1 assert first_missing_positive([-3, -2, -1, -5]) == 1 assert first_missing_positive([1, 1, 1, 1]) == 2 ``` Additional Notes - The algorithm should run in O(n) time and use constant extra space. - Focus on efficiently handling large inputs within the given constraints. Scenario Imagine you are a software engineer at a tech company that manages server racks. The racks are equipped with sensors sending periodic signals. Due to possible glitches, some signals might be missing. Your task is to identify the first missing positive signal from the array to ensure proper rack monitoring and maintenance scheduling.","solution":"def first_missing_positive(nums): Returns the smallest missing positive integer from the list. # Place each number in its corresponding index position n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: target_index = nums[i] - 1 nums[i], nums[target_index] = nums[target_index], nums[i] # Find the first index which doesn\'t have the right number for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Coding Assessment Question Scenario: As a software engineer, you are tasked with developing a functionality for an online bookstore to help categorize books by their titles. The bookstore wants to group the books such that all books with titles that are anagrams of each other are placed in the same category. You need to implement a function to achieve this grouping efficiently. Task: Write a Python function `group_anagrams(titles)` that takes a list of book titles and groups them into categories based on anagrams. **Function Signature**: ```python def group_anagrams(titles: list) -> list: ``` **Input**: - `titles`: A list of strings where each string represents a book title. **Output**: - A list of lists, where each sublist contains book titles that are anagrams of each other. **Constraints**: - All strings in the `titles` list are not empty. - Each book title consists of lowercase alphabets only. - The length of the `titles` list will not exceed 1000. **Edge Cases to Handle**: - If the `titles` list is empty, the function should return an empty list. - Ensure performance is efficient even for the upper limit of inputs. **Examples**: ```python print(group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"])) # Expected Output: [[\'eat\', \'tea\', \'ate\'], [\'tan\', \'nat\'], [\'bat\']] print(group_anagrams([\\"\\"])) # Expected Output: [[\'\']] print(group_anagrams([\\"a\\"])) # Expected Output: [[\'a\']] ``` **Explanation**: 1. The function should categorize book titles that are anagrams into the same list. 2. In the first example, \\"eat\\", \\"tea\\", and \\"ate\\" are anagrams, hence they are grouped together. 3. Titles that do not have anagrams should be in their own separate list.","solution":"from collections import defaultdict def group_anagrams(titles): Groups book titles by anagrams. Parameters: titles (list): A list of strings where each string represents a book title. Returns: list: A list of lists, where each sublist contains book titles that are anagrams of each other. anagram_map = defaultdict(list) for title in titles: # Sort the title to form the key sorted_title = \'\'.join(sorted(title)) anagram_map[sorted_title].append(title) # Return the grouped anagrams as a list of lists return list(anagram_map.values())"},{"question":"# Interval Tree Problem Context You are developing a library for managing and querying intervals. An interval is represented by a pair of numbers `[start, end]`, where `start` is less than or equal to `end`. You need to implement an `IntervalTree` that allows efficient insertion of intervals, deletion of intervals, and querying of all intervals that overlap with a given interval. Task Implement a class `IntervalTree` in Python that supports the following operations: 1. Insertion of an interval. 2. Deletion of an interval. 3. Querying of all intervals that overlap with a given interval. 4. String representation of intervals in the tree. 5. Checking if a given interval tree is equal to another interval tree. Requirements 1. **Insertion**: - Insert an interval `[start, end]` into the interval tree. ```python def insert(self, interval: Tuple[int, int]) -> None: ``` 2. **Deletion**: - Delete an interval `[start, end]` from the interval tree. ```python def delete(self, interval: Tuple[int, int]) -> None: ``` 3. **Query**: - Query and return all intervals that overlap with a given interval `[start, end]`. ```python def query(self, interval: Tuple[int, int]) -> List[Tuple[int, int]]: ``` 4. **String Representation**: - Return a string representation of all intervals in the tree sorted by the start time. ```python def __str__(self) -> str: ``` 5. **Equality Check**: - Check if two interval trees are equal, meaning they contain the exact same intervals. ```python def __eq__(self, tree_2: object) -> bool: ``` Input and Output Formats: - **Insertion**: `IntervalTree().insert((1, 3))` inserts the interval `[1, 3]` into the tree. - **Deletion**: `IntervalTree().delete((1, 3))` deletes the interval `[1, 3]` from the tree. - **Query**: `IntervalTree().query((2, 5))` returns all intervals that overlap with `[2, 5]`. - **String Representation**: `str(IntervalTree())` displays all intervals in the tree in a sorted string format. - **Equality Check**: `IntervalTree() == IntervalTree()` checks if two interval trees are equal. Constraints: - Intervals will have integer values. - Intervals can overlap and touch at boundaries. - Ensure your implementation is efficient and handles large datasets within reasonable limits. - Assume inputs for insert and delete are always valid intervals in the form `(start, end)` where `start <= end`. Example: ```python tree = IntervalTree() tree.insert((1, 3)) tree.insert((5, 8)) tree.insert((4, 6)) print(tree.query((4, 7))) # Should return [(5, 8), (4, 6)] tree.delete((5, 8)) print(tree) # Should display \\"[(1, 3), (4, 6)]\\" tree2 = IntervalTree() tree2.insert((1, 3)) tree2.insert((4, 6)) print(tree == tree2) # Should return True ```","solution":"from typing import List, Tuple class IntervalTree: def __init__(self): self.intervals = [] def insert(self, interval: Tuple[int, int]) -> None: self.intervals.append(interval) self.intervals.sort() def delete(self, interval: Tuple[int, int]) -> None: if interval in self.intervals: self.intervals.remove(interval) def query(self, interval: Tuple[int, int]) -> List[Tuple[int, int]]: start, end = interval return [i for i in self.intervals if i[0] <= end and i[1] >= start] def __str__(self) -> str: return str(sorted(self.intervals)) def __eq__(self, tree_2: object) -> bool: if not isinstance(tree_2, IntervalTree): return False return sorted(self.intervals) == sorted(tree_2.intervals)"},{"question":"Meeting Rooms II You are given an array of meeting time intervals consisting of start and end times `intervals[i] = [start[i], end[i]]`. Write a function `min_meeting_rooms` that determines the minimum number of conference rooms required to hold all the meetings. Function Signature ```python def min_meeting_rooms(intervals: List[List[int]]) -> int: ``` Input * **intervals**: A list of lists, where each list contains two integers `[start, end]` representing the start and end times of a meeting. Output * **rooms_needed**: An integer representing the minimum number of conference rooms required to hold all meetings without any overlap. Constraints * The number of meeting intervals `|intervals|` will not exceed 10^4. * Meeting start and end times are non-negative integers. Example ```python intervals = [[0, 30], [5, 10], [15, 20]] print(min_meeting_rooms(intervals)) # Output: 2 intervals = [[7, 10], [2, 4]] print(min_meeting_rooms(intervals)) # Output: 1 ``` Approach 1. **Sort Intervals**: First, sort the meeting intervals based on their start times. 2. **Use a Min-Heap**: Utilize a min-heap to keep track of the end times of the meetings. This helps in efficiently finding the earliest meeting that finishes. 3. **Heap Operations**: For each meeting, if the room due to free up the earliest is not free, allocate a new room. If the room is free, update the end time in the heap. * **Edge Cases**: Consider scenarios with empty intervals, intervals that end exactly when others start, and multiple meetings fully overlapping. Using this information, implement the `min_meeting_rooms` function to compute the minimum number of conference rooms required to accommodate all meetings.","solution":"import heapq from typing import List def min_meeting_rooms(intervals: List[List[int]]) -> int: if not intervals: return 0 # Sort the intervals by starting times intervals.sort(key=lambda x: x[0]) # Initialize a min heap min_heap = [] # Add the first meeting\'s end time to the heap heapq.heappush(min_heap, intervals[0][1]) for i in range(1, len(intervals)): # If the room with the earliest end time is free before the next meeting start time if min_heap[0] <= intervals[i][0]: heapq.heappop(min_heap) # Add the new meeting\'s end time to the heap heapq.heappush(min_heap, intervals[i][1]) # The size of the heap is the number of rooms required return len(min_heap)"},{"question":"# Question: Rotational Cipher A rotational cipher, also known as a Caesar Cipher, is a simple encryption technique where each letter in a given text is shifted a certain number of places down or up the alphabet. For this problem, you\'ll write two functions: 1. `rotational_cipher_encrypt` that encrypts a given string using a specified shift. 2. `rotational_cipher_decrypt` that decrypts a given string using a specified shift. Implement the following Python functions: Function 1: `rotational_cipher_encrypt` ```python def rotational_cipher_encrypt(text: str, shift: int) -> str: Encrypts the given text using a rotational cipher with the specified shift. Args: text (str): The string to encrypt. shift (int): The integer shift value. Returns: str: The encrypted string. Examples: >>> rotational_cipher_encrypt(\'Hello, World!\', 3) \'Khoor, Zruog!\' >>> rotational_cipher_encrypt(\'HELLO, WORLD!\', 5) \'MJQQT, BTWQI!\' >>> rotational_cipher_encrypt(\'abcXYZ\', 2) \'cdeZAB\' >>> rotational_cipher_encrypt(\'\', 10) \'\' pass ``` Function 2: `rotational_cipher_decrypt` ```python def rotational_cipher_decrypt(text: str, shift: int) -> str: Decrypts the given text encrypted by a rotational cipher with the specified shift. Args: text (str): The string to decrypt. shift (int): The integer shift value. Returns: str: The decrypted string. Examples: >>> rotational_cipher_decrypt(\'Khoor, Zruog!\', 3) \'Hello, World!\' >>> rotational_cipher_decrypt(\'MJQQT, BTWQI!\', 5) \'HELLO, WORLD!\' >>> rotational_cipher_decrypt(\'cdeZAB\', 2) \'abcXYZ\' >>> rotational_cipher_decrypt(\'\', 10) \'\' pass ``` # Constraints * The shift value will be in the range 0 <= shift < 26. * The input text will only contain printable ASCII characters. * The function must maintain the case of each character (i.e., lowercase letters should stay lowercase, and uppercase letters should stay uppercase). * Non-alphabetic characters should remain unchanged. # Explanation * **rotational_cipher_encrypt**: This function shifts each alphabetic character in the input text by the specified `shift` value, wrapping around the alphabet if necessary. * **rotational_cipher_decrypt**: This function reverses the encryption by shifting characters backward by the specified `shift`. Ensure your implementation passes the provided examples and handles edge cases such as shifts that cause wrapping around the alphabet or non-alphabetic characters.","solution":"def rotational_cipher_encrypt(text: str, shift: int) -> str: Encrypts the given text using a rotational cipher with the specified shift. result = [] for char in text: if \'a\' <= char <= \'z\': result.append(chr((ord(char) - ord(\'a\') + shift) % 26 + ord(\'a\'))) elif \'A\' <= char <= \'Z\': result.append(chr((ord(char) - ord(\'A\') + shift) % 26 + ord(\'A\'))) else: result.append(char) return \'\'.join(result) def rotational_cipher_decrypt(text: str, shift: int) -> str: Decrypts the given text encrypted by a rotational cipher with the specified shift. return rotational_cipher_encrypt(text, -shift % 26)"},{"question":"**Coding Question: Zigzag (Diagonal) Traverse a Matrix** You are given a 2D matrix (a list of lists) containing integers. Your task is to implement a function that traverses and returns the elements of the matrix in a diagonal (zigzag) order. The traversal should start from the top-left corner and proceed in a zigzag manner. You first traverse the element at `(0,0)`, then the down-left diagonal to the bottom of the matrix, followed by an up-right diagonal till the rightmost column or topmost row, and so forth. # Function Signature ```python def zigzag_traversal(matrix: list[list[int]]) -> list[int]: pass ``` # Inputs - `matrix` (list of lists of ints): A 2D array of integers representing the matrix. The matrix can be of varying dimensions but is guaranteed to have consistent row lengths (i.e., every row has the same number of columns). # Output - Returns a list of integers representing the matrix elements in zigzag (diagonal) order. # Example ```python >>> zigzag_traversal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 4, 7, 5, 3, 6, 8, 9] >>> zigzag_traversal([[1, 2], [3, 4]]) [1, 2, 3, 4] ``` # Constraints - The number of rows (m) and columns (n) will each range from 1 to 100. - The matrix will be well-formed, i.e., each row will have the same number of columns. # Requirements - Ensure your solution handles edge cases such as a single-row or single-column matrix. - Your implementation must meet a time complexity of O(m*n), where \'m\' is the number of rows and \'n\' is the number of columns. # Notes - Implement an iterative solution rather than relying on recursion to avoid depth limitations. - Consider the direction change effectively while traversing the matrix diagonally.","solution":"def zigzag_traversal(matrix: list[list[int]]) -> list[int]: Traverses the matrix in a zigzag (diagonal) order and returns the traversal as a list. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) result = [] for d in range(rows + cols - 1): if d % 2 == 0: # Even diagonals go from down-left to up-right r = min(d, rows - 1) c = d - r while r >= 0 and c < cols: result.append(matrix[r][c]) r -= 1 c += 1 else: # Odd diagonals go from up-right to down-left c = min(d, cols - 1) r = d - c while c >= 0 and r < rows: result.append(matrix[r][c]) r += 1 c -= 1 return result"},{"question":"# Coding Question - Implementing a Custom Memory Allocator You\'re tasked with designing a memory allocator that manages memory allocation and deallocation for a simulated system. The allocator will follow a first-fit strategy to handle memory requests. # Scenario In embedded systems and certain high-performance applications, custom memory allocators are used to manage memory more efficiently than the default system allocators. Your task is to implement a simple memory allocator that can manage a fixed-size memory block and perform allocations and deallocations. # Task 1. Implement the `MemoryAllocator` class with the specified methods. 2. The allocator should use a first-fit strategy to allocate memory blocks. 3. Ensure that allocated memory blocks are not overlapping and that free memory is managed correctly. # Class Definition ```python class MemoryAllocator: def __init__(self, size: int): pass def allocate(self, size: int) -> int: pass def deallocate(self, address: int) -> None: pass ``` # Methods * `__init__(self, size: int)` - Initialize the memory allocator with a fixed block of memory of the given size. * `allocate(self, size: int) -> int` - Allocate a block of memory of the specified size and return the starting address of the allocated block. Return -1 if allocation fails. * `deallocate(self, address: int) -> None` - Deallocate the block of memory starting at the given address. # Constraints * Assume that `size` in the `__init__` method is a positive integer. * Memory should be allocated and managed optimally to minimize fragmentation. * Address 0 indicates the start of the memory block managed by the allocator. * Freeing memory with an invalid address should have no effect. # Example ```python allocator = MemoryAllocator(100) assert allocator.allocate(10) == 0 # Allocates 10 bytes at address 0 assert allocator.allocate(20) == 10 # Allocates 20 bytes at address 10 allocator.deallocate(0) # Deallocates the block starting at address 0 assert allocator.allocate(5) == 0 # Allocates 5 bytes at address 0 assert allocator.allocate(50) == 30 # Allocates 50 bytes at address 30 assert allocator.allocate(40) == -1 # Allocation fails, not enough memory allocator.deallocate(10) # Deallocates the block starting at address 10 assert allocator.allocate(15) == 10 # Allocates 15 bytes at address 10 ``` # Additional Notes * Ensure thread safety if the allocator will be used in a multithreaded environment. * Handle edge cases such as trying to deallocate memory that has not been allocated or has already been deallocated. * Aim for O(n) time complexity for both allocation and deallocation operations.","solution":"class MemoryAllocator: def __init__(self, size: int): Initialize the memory allocator with a fixed block of memory of the given size. self.size = size self.memory = [0] * size # 0 means free, 1 means allocated self.allocations = {} # Tracks allocated blocks with their start addresses and sizes def allocate(self, size: int) -> int: Allocate a block of memory of the specified size and return the starting address of the allocated block. Return -1 if allocation fails. if size <= 0 or size > self.size: return -1 # First-fit strategy for start in range(self.size - size + 1): if all(self.memory[start + i] == 0 for i in range(size)): for i in range(size): self.memory[start + i] = 1 self.allocations[start] = size return start return -1 def deallocate(self, address: int) -> None: Deallocate the block of memory starting at the given address. if address not in self.allocations: return size = self.allocations.pop(address) for i in range(size): self.memory[address + i] = 0"},{"question":"# Bitwise Array Manipulation Context: You are developing a data analysis tool that allows users to manipulate arrays with bitwise operations. One common requirement is to perform a bitwise AND operation between pairs of elements in an array and return the result. You need to implement this feature efficiently. Task: Implement a function `bitwise_and_pairs(arr: List[int]) -> List[int]` that processes a given array and returns a new array where each element is the result of a bitwise AND operation between adjacent pairs in the input array. If the array has an odd number of elements, the last element should remain unchanged in the output array. Bitwise AND Operation: For two integers `a` and `b`, bitwise AND is performed as: ```python a & b ``` Input: - `arr`: A list of integers representing the input array. The length of the list is `N`. Output: - Should return a new list where each adjacent pair of elements in the input array is replaced by their bitwise AND result. If the input list has an odd length, the last element should be included in the result as is. Constraints: - The length of the input list is `1 <= N <= 1000`. - Each integer in the list is non-negative and in the range `0 <= arr[i] <= 10000`. Example: ```python arr = [5, 3, 12, 6, 9] bitwise_and_pairs(arr) Output: [1, 4, 9] ``` Explanation: - Pair 1: `5 & 3 = 1` - Pair 2: `12 & 6 = 4` - Since the array has an odd number of elements, the last element `9` remains unchanged in the output. Notes: - Ensure the function handles arrays of both even and odd lengths efficiently. - Consider edge cases like very small input sizes (e.g., `N = 1` or `N = 2`). - Optimize for performance within the given constraints.","solution":"from typing import List def bitwise_and_pairs(arr: List[int]) -> List[int]: Performs a bitwise AND operation between pairs of elements in the input array. If the array has an odd number of elements, the last element remains unchanged. :param arr: List of integers :return: New list where each element is a result of a bitwise AND operation of adjacent pairs. result = [] n = len(arr) for i in range(0, n - 1, 2): result.append(arr[i] & arr[i + 1]) # If there is an odd number of elements, append the last one if n % 2 != 0: result.append(arr[-1]) return result"},{"question":"Problem Statement # Context You have been given the responsibility to develop a system that can help track the busiest period in a store based on customer check-in and check-out times. Your task is to implement a function that determines the maximum number of people present in the store at any given time based on a list of check-in and check-out events. # Task Write a Python function `find_peak_visitors` that finds the peak number of people present in the store at any given time. # Requirements * **Input**: * `events` (list of tuple): A list of tuples where each tuple contains two integers `(check_in, check_out)`, representing the check-in and check-out times of a customer. All times are positive integers and `check_in < check_out`. * **Output**: * An integer representing the peak number of people present in the store at any given time. # Constraints 1. The input list will have at most 10^5 events. 2. The check-in and check-out times will be integers within the range [1, 10^9]. # Function Signature ```python def find_peak_visitors(events: list[tuple[int, int]]) -> int: pass ``` # Example ```python assert find_peak_visitors([(1, 4), (2, 5), (9, 12), (5, 9), (5, 12)]) == 3 assert find_peak_visitors([(2, 3), (4, 5), (6, 7), (8, 9)]) == 1 assert find_peak_visitors([(1, 10), (2, 6), (5, 8)]) == 3 ``` # Performance Considerations Your solution should ideally have a time complexity of O(n log n) due to the sorting step, where n is the number of events. Efficient handling of the events is key to solving this problem within the time constraints.","solution":"def find_peak_visitors(events): Finds the peak number of people in the store at any given time. :param events: list of tuples where each tuple contains two integers (check_in, check_out) :return: an integer representing the peak number of people present in the store at any given time times = [] # Collect both check-in and check-out times for event in events: check_in, check_out = event times.append((check_in, \'in\')) times.append((check_out, \'out\')) # Sort the times times.sort() current_visitors = 0 max_visitors = 0 # Traverse through the times for time, type in times: if type == \'in\': current_visitors += 1 if current_visitors > max_visitors: max_visitors = current_visitors elif type == \'out\': current_visitors -= 1 return max_visitors"},{"question":"# File System Path Manipulator Background In many programming scenarios, manipulating file paths is a common operation. This could involve normalizing, joining, or extracting parts of paths for various purposes. Working with file paths can be tricky due to the different conventions between operating systems. Task Write a function `normalize_path` that takes a file path as input and returns the normalized path. Normalization in this context means resolving `.` (current directory) and `..` (parent directory) to get the absolute equivalent path. Function Signature ```python def normalize_path(path: str) -> str: pass ``` Input - `path`: A string representing the file path, which may contain `.` and `..` to denote current and parent directories respectively. It assumes Unix-style paths (e.g., paths with `/`). Output - A string representing the normalized path. Constraints - The `path` will always start with a `/` (root directory). - The `path` is guaranteed not to have any spaces. - The length of the path will not exceed 1024 characters. Example ```python print(normalize_path(\\"/home/user/.././user2/docs/./../images/\\")) # Expected Output: /home/user2/images print(normalize_path(\\"/../\\")) # Expected Output: / print(normalize_path(\\"/a/./b/../../c/\\")) # Expected Output: /c ``` # Instructions 1. Implement the `normalize_path` function such that it handles paths with `.` and `..` accurately. 2. Ensure the function is efficient and can handle the given constraints. 3. Add a brief docstring explaining the implementation.","solution":"def normalize_path(path: str) -> str: Normalizes a given Unix-style file path by resolving `.` and `..`. Parameters: path (str): The original file path. Returns: str: The normalized file path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) normalized_path = \'/\' + \'/\'.join(stack) return normalized_path"},{"question":"# Problem Statement: Depth-First Search (DFS) Pathfinder Depth-First Search (DFS) is a classic graph traversal algorithm commonly used to explore nodes and edges of a graph. In this problem, you are required to implement the DFS algorithm to find a specific path from a given starting node to a destination node in an unweighted, undirected graph. # Implementation Details You need to define a class `Graph` and implement the following methods: 1. **Constructor**: ```python def __init__(self, num_of_nodes: int) -> None ``` - Initializes a graph with the specified number of nodes. - `num_of_nodes`: Number of nodes in the graph. 2. **add_edge**: ```python def add_edge(self, u_node: int, v_node: int) -> None ``` - Adds an edge between two nodes. - `u_node`: First node of the edge. - `v_node`: Second node of the edge. 3. **dfs**: ```python def dfs(self, start_node: int, destination_node: int) -> List[int] ``` - Implements DFS from the `start_node` to find a path to the `destination_node`. - Returns the path as a list of nodes. - If no path exists, returns an empty list. # Example Usage Given a graph with 6 nodes and the following edges: - (0, 1) - (0, 2) - (1, 3) - (2, 3) - (3, 4) - (4, 5) You need to find a path from node 0 to node 5. ```python g = Graph(6) for u_v in ((0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5)): g.add_edge(*u_v) path = g.dfs(0, 5) print(\\"Path:\\", path) ``` # Expected Output The output should be: ``` Path: [0, 2, 3, 4, 5] ``` # Constraints - The number of nodes (1 leq V leq 10^4) - The number of edges (0 leq E leq 10^6) Implement the `Graph` class and its methods to solve the problem. Ensure to handle edge cases, such as when no path exists between the start and destination nodes.","solution":"from typing import List class Graph: def __init__(self, num_of_nodes: int) -> None: self.num_of_nodes = num_of_nodes self.adj_list = [[] for _ in range(num_of_nodes)] def add_edge(self, u_node: int, v_node: int) -> None: self.adj_list[u_node].append(v_node) self.adj_list[v_node].append(u_node) def dfs_util(self, current_node: int, destination_node: int, visited: List[bool], path: List[int]) -> bool: visited[current_node] = True path.append(current_node) if current_node == destination_node: return True for neighbor in self.adj_list[current_node]: if not visited[neighbor]: if self.dfs_util(neighbor, destination_node, visited, path): return True path.pop() return False def dfs(self, start_node: int, destination_node: int) -> List[int]: visited = [False] * self.num_of_nodes path = [] if self.dfs_util(start_node, destination_node, visited, path): return path else: return []"},{"question":"# Binary Search in a Sorted Array You are required to implement the binary search algorithm. Given a sorted array of integers and a target value, your task is to determine whether the target value exists in the array. You need to return the index of the target value if it exists, otherwise return -1. Binary search is an efficient algorithm with a time complexity of O(log n) for finding an item from a sorted list of items. # Function Signature ```python def binary_search(arr: List[int], target: int) -> int: pass ``` # Input - `arr` (List[int]): A sorted list of n integers (1 <= n <= 10^5). - `target` (int): An integer to search for in the array. # Output - Returns the index of the target value if it exists in the array. Otherwise, returns -1. # Constraints - The array will be sorted in non-decreasing order. - All integers in the array and the target will be within the range of -10^9 to 10^9. # Example ```python assert binary_search([1, 2, 3, 4, 5, 6], 4) == 3 assert binary_search([1, 2, 3, 4, 5, 6], 7) == -1 assert binary_search([-10, -5, 0, 5, 10], -5) == 1 assert binary_search([2, 4, 6, 8, 10, 12, 14], 10) == 4 ``` # Context This question assesses your understanding of the binary search algorithm and ensures that you can implement an efficient searching mechanism over a sorted collection of data.","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Prime Number Path Given a grid of numbers, your task is to determine if there exists a path from the top-left corner to the bottom-right corner, where every number in the path is a prime number. You can only move right or down at any point in time. # Problem Statement Create a function `prime_path_exists` that checks whether it\'s possible to traverse a grid exclusively through prime numbers. # Function Definition ```python def prime_path_exists(grid: List[List[int]]) -> bool: pass ``` # Detailed Requirements 1. **Function Input**: * `grid`: A 2D list of integers, where each integer (1 ≤ grid[i][j] ≤ 10^4) represents the grid value. * (1 ≤ len(grid), len(grid[0]) ≤ 100) 2. **Function Output**: * Return a boolean value `True` if a prime number path exists from the top-left corner to the bottom-right corner, otherwise return `False`. # Explanation 1. **Prime Number Check**: * Develop a helper function to determine if a given number is prime. 2. **Path Traversal**: * Implement a traversal method (e.g., DFS or BFS) to find a path consisting only of prime numbers in the permissible directions (right or down). 3. **Edge Cases**: * Ensure to handle grids with no primes or grids where the start or end points are not prime numbers. 4. **Performance**: * The solution should efficiently check for prime numbers and traverse the grid within a time complexity suitable for the input constraints. # Example ```python grid = [ [2, 3, 5], [4, 2, 3], [7, 11, 13] ] print(prime_path_exists(grid)) # Expected Output: True grid = [ [4, 6, 8], [2, 2, 3], [5, 5, 6] ] print(prime_path_exists(grid)) # Expected Output: False ``` # Additional Constraints 1. **Prime Identification**: * Ensure that prime identification is consistent with mathematical definitions (e.g., 2 is prime, but 1 is not). 2. **Grid Size**: * The solution should handle the maximum grid size without significant performance degradation. # Notes - Implement a helper function to check if a number is prime. - Use efficient traversal algorithms to explore the grid. - Pay special attention to edge cases, such as grids with no potential prime paths.","solution":"from typing import List from collections import deque def is_prime(n: int) -> bool: Check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_path_exists(grid: List[List[int]]) -> bool: Check if there exists a path from top-left to bottom-right composed of prime numbers. if not grid: return False rows, cols = len(grid), len(grid[0]) if not is_prime(grid[0][0]) or not is_prime(grid[rows-1][cols-1]): return False # Directions for moving right and down directions = [(0, 1), (1, 0)] # BFS initialization queue = deque([(0, 0)]) visited = set((0, 0)) while queue: r, c = queue.popleft() # If we have reached the bottom-right corner if r == rows - 1 and c == cols - 1: return True # Explore the neighbors (right and down) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and is_prime(grid[nr][nc]): visited.add((nr, nc)) queue.append((nr, nc)) return False"},{"question":"# Problem Statement: Implement a function to perform basic clustering using the K-means algorithm with a specified number of centroids and a fixed number of iterations. # Objective: Write a function `k_means_clustering` that accepts the following parameters: 1. **data_points**: List[Tuple[float, float]] - A list of 2D points represented as tuples. 2. **num_centroids**: int - The number of centroids to be used for clustering. 3. **num_iterations**: int - The number of iterations to run the K-means algorithm. Default is 100. Your function should perform the following tasks: 1. Randomly initialize `num_centroids` centroids. 2. Perform the K-means clustering for `num_iterations`. 3. Return the final centroids and the cluster assignment for each data point. Constraints: 1. Each data point must be assigned to the nearest centroid based on Euclidean distance. 2. After each iteration, update the centroids as the mean of all data points assigned to it. 3. Ensure your function handles cases with different data densities and scales appropriately. # Input/Output: Input: - A list of 2D points and appropriate parameters as described above. Output: - Tuple[List[Tuple[float, float]], List[int]] - A list of final centroids and a list of cluster assignments for each data point, respectively. # Example: ```python data_points = [(1.0, 2.0), (1.5, 1.8), (5.0, 8.0), (8.0, 8.0), (1.0, 0.6), (9.0, 11.0)] num_centroids = 2 num_iterations = 10 final_centroids, cluster_assignments = k_means_clustering(data_points, num_centroids, num_iterations) print(final_centroids) # Expected output: A list of 2 final centroids, e.g., [(x1, y1), (x2, y2)] print(cluster_assignments) # Expected output: A list of cluster assignments for each data point, e.g., [0, 0, 1, 1, 0, 1] ``` # Your Task: Write the function `k_means_clustering` that implements the specification detailed above. Notes: - You may use helper functions if needed. - Ensure proper handling and initialization of centroids. - Iterate the algorithm for the specified number of iterations and update centroids accordingly.","solution":"import random from typing import List, Tuple import math def k_means_clustering(data_points: List[Tuple[float, float]], num_centroids: int, num_iterations: int = 100) -> Tuple[List[Tuple[float, float]], List[int]]: def euclidean_distance(point1, point2): return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) # Step 1: Randomly initialize centroids centroids = random.sample(data_points, num_centroids) for _ in range(num_iterations): # Step 2: Assign points to the nearest centroid clusters = [[] for _ in range(num_centroids)] for point in data_points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) clusters[closest_centroid_index].append(point) # Step 3: Update centroids as the mean of their points for i in range(num_centroids): if clusters[i]: # Avoid empty cluster division by zero centroids[i] = ( sum([point[0] for point in clusters[i]]) / len(clusters[i]), sum([point[1] for point in clusters[i]]) / len(clusters[i]) ) # Final assignment cluster_assignments = [] for point in data_points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) cluster_assignments.append(closest_centroid_index) return centroids, cluster_assignments"},{"question":"# Stock Price Analyzer You are provided with historical stock price data in the form of a list of tuples, where each tuple represents the stock price at the end of a specific day. Each tuple contains a string representing the date in the format \'YYYY-MM-DD\' and a float representing the stock price on that date. # Task 1. Define a class `StockAnalyzer` that can perform the following operations on the stock price data: * Add new stock price entries. * Get the highest stock price within a specified date range. * Calculate the average stock price over a specified date range. * Find the longest streak of increasing stock prices. * Find the longest streak of decreasing stock prices. # Class and Function Specifications 1. **Class `StockAnalyzer`**: * Method: `add_entry(date: str, price: float)`: - `date`: a string representing the date in the format \'YYYY-MM-DD\'. - `price`: a float representing the stock price on that date. * Method: `get_highest_price(start_date: str, end_date: str) -> float`: - Returns the highest stock price in the inclusive range from `start_date` to `end_date`. * Method: `get_average_price(start_date: str, end_date: str) -> float`: - Returns the average stock price in the inclusive range from `start_date` to `end_date`. * Method: `longest_increasing_streak() -> int`: - Returns the length of the longest streak of increasing stock prices. * Method: `longest_decreasing_streak() -> int`: - Returns the length of the longest streak of decreasing stock prices. # Input and Output Formats * **Input**: * `date`: string in the format \'YYYY-MM-DD\'. * `price`: float representing the stock price. * `start_date`, `end_date`: strings in the format \'YYYY-MM-DD\', representing the range of dates. * **Output**: * For `get_highest_price` and `get_average_price`, returns a float. * For `longest_increasing_streak` and `longest_decreasing_streak`, returns an integer. # Constraints * `date` values provided to methods will be valid and in correct chronological order. * All stock prices will be non-negative floats. * There will be no duplicate `date` entries in the provided data. # Example ```python analyzer = StockAnalyzer() analyzer.add_entry(\\"2023-01-01\\", 100.5) analyzer.add_entry(\\"2023-01-02\\", 101.0) analyzer.add_entry(\\"2023-01-03\\", 102.0) analyzer.add_entry(\\"2023-01-04\\", 100.8) analyzer.add_entry(\\"2023-01-05\\", 99.5) print(analyzer.get_highest_price(\\"2023-01-01\\", \\"2023-01-03\\")) # Expected output: 102.0 print(analyzer.get_average_price(\\"2023-01-01\\", \\"2023-01-05\\")) # Expected output: 100.76 print(analyzer.longest_increasing_streak()) # Expected output: 3 print(analyzer.longest_decreasing_streak()) # Expected output: 2 ``` Ensure to handle boundary cases effectively and validate the correctness of your solution with thorough testing. Document any assumptions made during implementation.","solution":"from datetime import datetime class StockAnalyzer: def __init__(self): self.data = [] def add_entry(self, date: str, price: float): self.data.append((date, price)) self.data.sort() # Ensure data is sorted after each entry def get_highest_price(self, start_date: str, end_date: str) -> float: start_date = datetime.strptime(start_date, \'%Y-%m-%d\') end_date = datetime.strptime(end_date, \'%Y-%m-%d\') max_price = float(\'-inf\') for date_str, price in self.data: date = datetime.strptime(date_str, \'%Y-%m-%d\') if start_date <= date <= end_date: if price > max_price: max_price = price return max_price def get_average_price(self, start_date: str, end_date: str) -> float: start_date = datetime.strptime(start_date, \'%Y-%m-%d\') end_date = datetime.strptime(end_date, \'%Y-%m-%d\') total_price = 0 count = 0 for date_str, price in self.data: date = datetime.strptime(date_str, \'%Y-%m-%d\') if start_date <= date <= end_date: total_price += price count += 1 if count == 0: return 0.0 return total_price / count def longest_increasing_streak(self) -> int: if not self.data: return 0 max_streak = 1 current_streak = 1 for i in range(1, len(self.data)): if self.data[i][1] > self.data[i-1][1]: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 1 return max_streak def longest_decreasing_streak(self) -> int: if not self.data: return 0 max_streak = 1 current_streak = 1 for i in range(1, len(self.data)): if self.data[i][1] < self.data[i-1][1]: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 1 return max_streak"},{"question":"# Problem Statement You are given a class designed to represent a binary tree with integer values. Your task is to extend this class by adding a new method that finds the maximum depth of the binary tree. # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add(self, value: int) -> None: Adds a value to the binary tree according to the binary search tree property. def max_depth(self) -> int: This method should return the maximum depth of the binary tree. ``` # Input & Output - **Input**: - No input parameters are required for the method. Use the internal state of the binary tree. - **Output**: - The method should return an integer representing the maximum depth of the tree. # Examples 1. **Example 1**: ```python tree = BinaryTree() tree.add(1) tree.add(2) tree.add(3) print(tree.max_depth()) ``` **Output**: ``` 3 ``` 2. **Example 2**: ```python tree = BinaryTree() tree.add(5) tree.add(4) tree.add(6) tree.add(2) print(tree.max_depth()) ``` **Output**: ``` 3 ``` 3. **Example 3**: ```python tree = BinaryTree() print(tree.max_depth()) ``` **Output**: ``` 0 ``` # Constraints - The number of nodes in the binary tree does not exceed 10^5. - Node values are integers and can be negative. # Notes - A binary tree\'s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. - The tree can be empty, and in such cases, the depth should be 0. Implement the `max_depth` method in the `BinaryTree` class.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add(self, value: int) -> None: Adds a value to the binary tree according to the binary search tree property. if not self.root: self.root = TreeNode(value) else: self._add_recursive(self.root, value) def _add_recursive(self, node, value): if value < node.val: if node.left: self._add_recursive(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._add_recursive(node.right, value) else: node.right = TreeNode(value) def max_depth(self) -> int: This method should return the maximum depth of the binary tree. def depth(node): if not node: return 0 else: left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(self.root)"},{"question":"# Coding Assessment Question **Context:** You are hired to build a custom citation manager for researchers, which identifies and categorizes citations in varied document formats. The tool should be able to identify author names, publication titles, and year of publication from a formatted citation string and categorize them under corresponding fields. **Function Specification:** - **Function Name**: `parse_citation` - **Input**: - `citation` (string): A properly formatted citation string. Examples include `\\"Smith, John. \'Innovations in AI\'. AI Journal, 2020.\\"` or `\\"Doe, Jane. \'Quantum Computing: An Overview\'. Computing Today, 2021.\\"`. - **Output**: - A dictionary with keys \\"author\\", \\"title\\", \\"journal\\", and \\"year\\" containing the respective parts of the citation. **Input Constraints**: - The citation format will always follow the structure: - `\\"Last Name, First Name. \'Title\'. Journal Name, Year.\\"` **Edge Cases to Consider**: - Variations in the author name (hyphenated names, multiple names). - Ensuring the correct parsing of the citation parts, even if they contain commas or periods within the fields. **Examples**: ```python >>> parse_citation(\\"Smith, John. \'Innovations in AI\'. AI Journal, 2020.\\") {\'author\': \'Smith, John\', \'title\': \'Innovations in AI\', \'journal\': \'AI Journal\', \'year\': \'2020\'} >>> parse_citation(\\"Doe, Jane. \'Quantum Computing: An Overview\'. Computing Today, 2021.\\") {\'author\': \'Doe, Jane\', \'title\': \'Quantum Computing: An Overview\', \'journal\': \'Computing Today\', \'year\': \'2021\'} >>> parse_citation(\\"Lin, Michelle. \'Advanced Topics in Machine Learning\'. Machine Learning Monthly, 2019.\\") {\'author\': \'Lin, Michelle\', \'title\': \'Advanced Topics in Machine Learning\', \'journal\': \'Machine Learning Monthly\', \'year\': \'2019\'} ``` **Implementation Notes**: - You may assume the input will always follow the strict format specified above. - Consider edge cases where names, titles, or journal names may contain punctuation. - The solution should handle invalid inputs gracefully, potentially returning an error message or empty dictionary.","solution":"def parse_citation(citation): Parses a citation string into its components: author, title, journal, and year. Args: citation (str): The formatted citation string. Returns: dict: A dictionary with keys \\"author\\", \\"title\\", \\"journal\\", and \\"year\\". try: # Splitting the citation into parts parts = citation.split(\\". \'\\") author_part = parts[0] title_journal_part = parts[1].rsplit(\\"\'. \\", 1) title_part = title_journal_part[0] journal_year_part = title_journal_part[1].split(\', \') journal_part = journal_year_part[0] year_part = journal_year_part[1].strip(\'.\') return { \\"author\\": author_part, \\"title\\": title_part, \\"journal\\": journal_part, \\"year\\": year_part } except (IndexError, ValueError): # Return an empty dictionary if parsing fails return {}"},{"question":"# Coding Assessment Question Given a list of integers, implement a function to determine whether there exists a pair of numbers in the list that adds up to a given target sum. The function should return a boolean value indicating whether such a pair exists. Ensure that the solution works efficiently even for large lists. Function Signature: ```python def has_pair_with_sum(numbers: list[int], target: int) -> bool: ``` # Input: - A list `numbers` of integers. - An integer `target` representing the target sum. # Output: - A boolean value: `True` if there exists a pair of integers in the list whose sum equals the target, otherwise `False`. # Constraints: - The input list may contain positive, negative, or zero integer values. - The target can be any integer value (positive, negative, or zero). - The input list and target are always provided. # Example: ```python >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([3, 3], 6) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -10) False ``` Detailed Explanation: - For the list [2, 7, 11, 15] and the target sum of 9, there is a pair (2, 7) that adds up to 9, so the result is `True`. - For the list [3, 3] and the target sum of 6, the pair (3, 3) adds up to 6, so the result is `True`. - For the list [1, 2, 3, 4, 5] and the target sum of 10, no pair adds up to 10, so the result is `False`. - For the list [-1, -2, -3, -4, -5] and the target sum of -10, no pair adds up to -10, so the result is `False`. Ensure that your function handles edge cases and invalid inputs appropriately, raising a `ValueError` when necessary.","solution":"def has_pair_with_sum(numbers, target): Determines if there exists a pair of numbers in the list that adds up to the target sum. :param numbers: List of integers. :param target: Target sum. :return: True if a pair is found that adds up to the target, else False. seen = set() for number in numbers: complement = target - number if complement in seen: return True seen.add(number) return False"},{"question":"# Coding Question You are working on a data processing system where managing files with varying extensions and performing specific operations based on their types is crucial. Your task is to create a function that handles this requirement seamlessly. Write a function `process_files(file_list, operation)` that processes a list of files based on their extensions and applies given operations accordingly. The function should: 1. Accept two parameters: * `file_list`: a list of file names (each file name includes an extension). * `operation`: a dictionary mapping file extensions to corresponding operations (represented as strings). 2. Identify the extension of each file in `file_list`. 3. Print a message indicating which operation will be performed for each file. 4. Return a dictionary mapping each extension to a list of files that will be processed for that extension. # Function Signature: ```python def process_files(file_list: list[str], operation: dict[str, str]) -> dict[str, list[str]] ``` # Constraints: * `1 <= len(file_list) <= 10^4` * File names in `file_list` contain a single period (`.`), separating the name from the extension. * File extensions and operations in `operation` are case-sensitive. # Example: ```py file_list = [\\"data.csv\\", \\"image.png\\", \\"document.pdf\\", \\"archive.zip\\", \\"script.py\\"] operation = { \\"csv\\": \\"Load to Database\\", \\"png\\": \\"Compress Image\\", \\"pdf\\": \\"Extract Text\\", \\"zip\\": \\"Unzip Archive\\", \\"py\\": \\"Execute Script\\" } result = process_files(file_list, operation) # Expected output: # Loading to Database: data.csv # Compressing Image: image.png # Extracting Text: document.pdf # Unzipping Archive: archive.zip # Executing Script: script.py print(result) # Output: {\'csv\': [\'data.csv\'], \'png\': [\'image.png\'], \'pdf\': [\'document.pdf\'], \'zip\': [\'archive.zip\'], \'py\': [\'script.py\']} ``` You need to ensure the function correctly identifies and processes each file based on its extension and maps it to the corresponding operation.","solution":"def process_files(file_list, operation): Processes the file list based on their extensions and the given operations. Parameters: - file_list (list of str): List of file names. - operation (dict of str: str): A dictionary mapping file extensions to operations. Returns: - dict of str: list of str: Dictionary mapping each extension to a list of files. result = {} for file in file_list: # Split the file name to get the extension file_name, ext = file.rsplit(\'.\', 1) # Get the operation for the current extension if ext in operation: op = operation[ext] print(f\\"{op}: {file}\\") # Append the file to the list of this extension if ext not in result: result[ext] = [] result[ext].append(file) return result"},{"question":"# File Merging and Deduplication **Scenario**: You\'re required to merge multiple text files containing lists of names into a single unified file without any duplicates. Each file contains one name per line, and names might appear in different formats (e.g., uppercase, lowercase, mixed case). **Requirements**: 1. **Function to Merge Files**: Write a function `merge_files(file_paths: list[str], output_file: str) -> None`: - **Input**: - `file_paths`: A list of strings where each string represents the path to a text file. - `output_file`: A string representing the path to the output text file. - **Output**: None. The function writes the merged and deduplicated list of names to the specified output file. 2. **Handling Case Insensitivity**: Ensure that the merging process is case-insensitive, but the output should retain the original case format of the first occurrence of any given name. 3. **Sorting the Output**: The final unified file should contain names sorted in case-insensitive alphabetical order. 4. **Performance Constraints**: Ensure the solution works efficiently for multiple input files with combined sizes up to 1,000,000 lines. **Constraints**: - Names do not contain spaces or special characters. - The solution should handle up to 1000 input files. - Each name can appear in multiple files in different casing formats. - Maintain the original case format for duplicated names as they first appeared. **Example**: Given three files with the following content: ``` file1.txt: Alice bob CHARLIE dave file2.txt: alice Bob Eve Frank file3.txt: ALICE eve frank Grace ``` Your function `merge_files([\\"file1.txt\\", \\"file2.txt\\", \\"file3.txt\\"], \\"output.txt\\")` should create `output.txt` with the following content: ``` Alice bob CHARLIE dave Eve Frank Grace ``` --- This new question integrates seamlessly with the provided question set by maintaining the style, complexity, and scope. It focuses on file processing, data manipulation, sorting, and deduplication, which aligns well with tasks such as anagram classification. The problem is unique and explores different concepts while retaining a comparable level of difficulty and length.","solution":"def merge_files(file_paths, output_file): merged_names = {} for file_path in file_paths: with open(file_path, \'r\') as file: for line in file: name = line.strip() name_lower = name.lower() if name_lower not in merged_names: merged_names[name_lower] = name sorted_names = sorted(merged_names.values(), key=lambda x: x.lower()) with open(output_file, \'w\') as file: for name in sorted_names: file.write(f\\"{name}n\\")"},{"question":"# Coding Assessment Question: Implement K-Means Clustering Algorithm You are required to implement a K-Means Clustering algorithm. The algorithm must be capable of partitioning a given dataset into K clusters. Your implementation should utilize the basic concepts of K-Means clustering. Task Requirements: 1. **Function 1**: Initialize centroids for the K clusters. - **Function Name**: `initialize_centroids` - **Input**: Data Points (`list of list of float`), Number of Clusters (`int`) - **Output**: List of Initialized Centroids (`list of list of float`). 2. **Function 2**: Assign data points to the nearest cluster centroid. - **Function Name**: `assign_clusters` - **Input**: Data Points (`list of list of float`), Centroids (`list of list of float`) - **Output**: List of Cluster Assignments (`list of int`). 3. **Function 3**: Compute new centroids for the clusters. - **Function Name**: `compute_centroids` - **Input**: Data Points (`list of list of float`), Cluster Assignments (`list of int`), Number of Clusters (`int`) - **Output**: List of New Centroids (`list of list of float`). 4. **Function 4**: Calculate the Euclidean distance between data points and centroids. - **Function Name**: `euclidean_distance` - **Input**: Data Point (`list of float`), Centroid (`list of float`) - **Output**: Calculated Distance (`float`). 5. **Function 5**: Perform the K-Means Clustering algorithm to partition the data points. - **Function Name**: `k_means_clustering` - **Input**: Data Points (`list of list of float`), Number of Clusters (`int`), Maximum Iterations (`int`) - **Output**: Tuple containing List of Centroids (`list of list of float`) and List of Cluster Assignments (`list of int`). 6. **Function 6**: Evaluate the clustering performance using sum of squared errors (SSE). - **Function Name**: `evaluate_clustering` - **Input**: Data Points (`list of list of float`), Centroids (`list of list of float`), Cluster Assignments (`list of int`) - **Output**: Calculated SSE Value (`float`). Constraints: 1. Assume input data is valid and well-formed. 2. Implement error handling for invalid inputs. 3. Optimize your solution for readability and performance. Example: ```python # Sample Data data = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ] # Example 1. Initializing centroids centroids = initialize_centroids(data_points=data, number_of_clusters=2) # Example 2. Assigning clusters assignments = assign_clusters(data_points=data, centroids=centroids) # Example 3. Computing new centroids new_centroids = compute_centroids(data_points=data, cluster_assignments=assignments, number_of_clusters=2) # Example 4. Calculating Euclidean distance distance = euclidean_distance(data_point=[1.0, 2.0], centroid=[5.0, 8.0]) # Example 5. Running K-Means Clustering final_centroids, final_assignments = k_means_clustering(data_points=data, number_of_clusters=2, max_iterations=100) # Example 6. Evaluating the clustering using SSE sse = evaluate_clustering(data_points=data, centroids=final_centroids, cluster_assignments=final_assignments) ``` You are allowed to use any standard libraries in Python to accomplish your task.","solution":"import random import math def initialize_centroids(data_points, number_of_clusters): Initialize centroids by selecting K random data points as initial centroids. return random.sample(data_points, number_of_clusters) def euclidean_distance(data_point, centroid): Calculate the Euclidean distance between a data point and a centroid. return math.sqrt(sum((dp - c) ** 2 for dp, c in zip(data_point, centroid))) def assign_clusters(data_points, centroids): Assign each data point to the nearest centroid. assignments = [] for point in data_points: distances = [euclidean_distance(point, centroid) for centroid in centroids] assignments.append(distances.index(min(distances))) return assignments def compute_centroids(data_points, cluster_assignments, number_of_clusters): Recompute centroids as the mean of all data points assigned to each cluster. clusters = [[] for _ in range(number_of_clusters)] for point, assignment in zip(data_points, cluster_assignments): clusters[assignment].append(point) new_centroids = [list(map(lambda x: sum(x) / len(x), zip(*cluster))) if cluster else random.choice(data_points) for cluster in clusters] return new_centroids def k_means_clustering(data_points, number_of_clusters, max_iterations): Perform K-Means Clustering. centroids = initialize_centroids(data_points, number_of_clusters) for _ in range(max_iterations): assignments = assign_clusters(data_points, centroids) new_centroids = compute_centroids(data_points, assignments, number_of_clusters) if new_centroids == centroids: break centroids = new_centroids return centroids, assignments def evaluate_clustering(data_points, centroids, cluster_assignments): Evaluate the clustering performance using sum of squared errors (SSE). sse = 0.0 for point, assignment in zip(data_points, cluster_assignments): centroid = centroids[assignment] sse += euclidean_distance(point, centroid) ** 2 return sse"},{"question":"# Question You are given a task to implement a function that segments a list of strings into groups where each group contains strings with the same number of vowels. The provided Python function `group_by_vowel_count` should return a dictionary where the keys are the counts of vowels and the values are lists of strings that have that count of vowels. To implement this function, follow these steps: 1. Define a helper function `count_vowels` that counts the number of vowels in a given string. 2. Iterate through the list of strings. 3. Use the helper function to count the vowels for each string. 4. Group the strings based on their vowel counts. Function Signature ```python def count_vowels(s: str) -> int: pass def group_by_vowel_count(strings: list[str]) -> dict[int, list[str]]: pass ``` **Constraints**: - Input strings only contain lowercase alphabetic characters. - The function should handle an empty list of strings gracefully. - Vowels are \'a\', \'e\', \'i\', \'o\', and \'u\'. **Example**: ```python strings = [\\"apple\\", \\"banana\\", \\"pear\\", \\"grape\\", \\"kiwi\\", \\"plum\\", \\"blueberry\\", \\"mango\\"] result = group_by_vowel_count(strings) print(result) ``` **Expected Output**: ```python { 2: [\\"apple\\", \\"pear\\", \\"grape\\", \\"kiwi\\"], 3: [\\"banana\\", \\"blueberry\\", \\"mango\\"], 1: [\\"plum\\"] } ``` **Explanation**: - \\"apple\\" has 2 vowels: \'a\', \'e\' - \\"banana\\" has 3 vowels: \'a\', \'a\', \'a\' - \\"pear\\" has 2 vowels: \'e\', \'a\' - \\"grape\\" has 2 vowels: \'a\', \'e\' - \\"kiwi\\" has 2 vowels: \'i\', \'i\' - \\"plum\\" has 1 vowel: \'u\' - \\"blueberry\\" has 3 vowels: \'u\', \'e\', \'e\' - \\"mango\\" has 3 vowels: \'a\', \'o\'","solution":"def count_vowels(s: str) -> int: Counts the number of vowels in a given string. vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} return sum(1 for char in s if char in vowels) def group_by_vowel_count(strings: list[str]) -> dict[int, list[str]]: Segments a list of strings into groups where each group contains strings with the same number of vowels. result = {} for string in strings: vowel_count = count_vowels(string) if vowel_count not in result: result[vowel_count] = [] result[vowel_count].append(string) return result"},{"question":"# Sum of Node Depths in a Binary Tree You are given a task to compute the sum of the depths of all nodes in a binary tree. The depth of a node is defined as the number of edges from the root node to the node itself. Function to Implement ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def node_depths(root): Calculate the sum of the depths of all nodes in the binary tree. Parameters: root (TreeNode): The root node of the binary tree. Returns: int: The sum of the depths of all nodes. pass ``` Input: * `root`: A TreeNode representing the root of the binary tree. Output: * Return the sum of the depths of all nodes as an integer. Constraints: * The number of nodes in the tree is at most (10^4). * Each node\'s value will be a non-negative integer. Value of the nodes is irrelevant for this problem. Performance Requirements: * Time Complexity: O(n), where n is the number of nodes in the binary tree. * Space Complexity: O(h), where h is the height of the binary tree, which can be at most O(n) in the case of a skewed tree. Example: ```python # Example binary tree: # 1 # / # 2 3 # /| | # 4 5 6 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) # Using the node_depths function to calculate the sum of node depths total_depths = node_depths(root) print(f\\"Total sum of node depths: {total_depths}\\") ``` *Expected Output*: `Total sum of node depths: 10` *Explanation*: * Node 1 depth: 0 * Node 2 depth: 1 * Node 3 depth: 1 * Node 4 depth: 2 * Node 5 depth: 2 * Node 6 depth: 2 * Node 7 depth: 2 * Sum of depths = 0 + 1 + 1 + 2 + 2 + 2 + 2 = 10","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def node_depths(root): Calculate the sum of the depths of all nodes in the binary tree. Parameters: root (TreeNode): The root node of the binary tree. Returns: int: The sum of the depths of all nodes. def calculate_depths(node, depth): if node is None: return 0 return depth + calculate_depths(node.left, depth + 1) + calculate_depths(node.right, depth + 1) return calculate_depths(root, 0)"},{"question":"# Problem Statement Design a system that reads from a log file and identifies the top `N` most frequent words. # Function Signature ```python def top_n_words_from_log(file_path: str, n: int) -> List[str]: ``` # Input: * `file_path`: A string, representing the path to the log file. * `n`: An integer, representing the number of top frequent words to return. (1 ≤ `n` ≤ 100) # Output: * A list of strings representing the top `n` most frequently occurring words in the log file, sorted by frequency in descending order. - If two words have the same frequency, they should be ordered alphabetically. - The words should be case-insensitive in terms of frequency count but should be returned in lowercase. # Constraints: * The log file content is limited to ASCII characters. * Words are considered sequences of alphabetic characters separated by spaces or punctuation. * Ignore case during the count but return words in lowercase. * If `n` exceeds the distinct number of words in the log, return all unique words. # Requirements: 1. Open and read the contents of the provided log file. 2. Normalize the text (convert to lower case, remove punctuation). 3. Count the occurrence of each word. 4. Return the top `n` words as described. # Example Usage: Assume the log file `\\"sample.log\\"` contains: ``` ERROR: Server not found. Warning: Low memory. DEBUG: Disk space low. error: server overheating. ``` The function call: ```python top_words = top_n_words_from_log(\\"sample.log\\", 3) print(top_words) ``` Should return: ``` [\\"server\\", \\"error\\", \\"low\\"] ``` # Notes: * Use efficient data structures to handle the word frequency counting. * Ensure that your implementation handles large files gracefully and in reasonable time. * Consider edge cases such as punctuation handling and empty files. # Evaluation Criteria: * Correctness: Accurate frequency counting and correct ordering of words. * Robustness: Handling various edge cases such as empty files or punctuation. * Efficiency: Optimized reading and counting process. # Bonus: * Allow the function to skip counting common stop words (like \\"the\\", \\"is\\", \\"at\\", etc.), which can be passed as an optional parameter. * Provide a feature to include/exclude specific words via an additional parameter.","solution":"from typing import List from collections import Counter import re def top_n_words_from_log(file_path: str, n: int) -> List[str]: # Function to normalize text to lowercase and remove punctuation def normalize(text): return re.sub(r\'[^ws]\', \'\', text).lower() # Read the contents of the log file with open(file_path, \'r\') as file: log_content = file.read() # Normalize the log content normalized_content = normalize(log_content) # Split the content into words words = normalized_content.split() # Count the occurrences of each word word_counts = Counter(words) # Sort the words first by frequency (descending) then alphabetically sorted_words = sorted(word_counts.items(), key=lambda item: (-item[1], item[0])) # Extract the top `n` words top_n_words = [word for word, count in sorted_words[:n]] return top_n_words"},{"question":"# Problem Statement You are tasked with implementing a function that simulates a simplified version of the game \\"Battleship\\" on a one-dimensional board. The board is represented as a string with certain ships already placed. Each ship is represented by a contiguous segment of \'X\' characters, while empty locations are represented by \'.\' characters. Your function will determine the total number of ships placed on the board by counting the contiguous segments of \'X\' characters. # Requirements Write a function `count_ships(board: str) -> int` that: - Takes a string `board` representing the 1D Battleship board. - Returns the total number of ships placed on the board. # Constraints - `board` will only contain the characters \'X\' and \'.\'. - The length of `board` will be between 1 and 1000, inclusive. # Function Signature ```python def count_ships(board: str) -> int: ``` # Example ```python >>> count_ships(\'XX...X.X....XXX\') 3 >>> count_ships(\'.......\') 0 >>> count_ships(\'X\') 1 >>> count_ships(\'XX..X\') 2 ``` # Explanation - In the first example, there are three ships: \\"XX\\", \\"X\\", and \\"XXX\\". - In the second example, there are no ships. - In the third example, there is one single ship. - In the fourth example, there are two ships: \\"XX\\" and \\"X\\". # Additional Context To solve this problem, iterate through the board string and count the contiguous segments of \'X\' characters. A new ship starts when an \'X\' character is found and either it is the first character or the previous character was a \'.\'.","solution":"def count_ships(board: str) -> int: Returns the number of ships on a one-dimensional battleship board. Args: board (str): A string representing the board where \'X\' is a part of a ship and \'.\' is water. Returns: int: The number of ships on the board. if not board: return 0 ship_count = 0 in_ship = False for char in board: if char == \'X\': if not in_ship: ship_count += 1 in_ship = True else: in_ship = False return ship_count"},{"question":"# Coding Assessment Question You are a software developer assigned to enhance the company\'s text processing library. One common task is to remove duplicates from text sequences, which is essential for various preprocessing steps in natural language processing and data cleaning pipelines. Problem Statement Write a function named `remove_duplicates` that takes a string as input and returns a new string with all the duplicate characters removed. The order of the characters in the returned string should be the same as their first occurrences in the input string. Function Signature ```python def remove_duplicates(text: str) -> str: pass ``` Input - `text`: A string that can contain any printable ASCII characters, including spaces and punctuation. Output - Returns a string with duplicate characters removed and the order of characters maintained as in the original string. Example ```python assert remove_duplicates(\\"programming\\") == \\"progamin\\" assert remove_duplicates(\\"mississippi\\") == \\"misp\\" assert remove_duplicates(\\"aabbccdd\\") == \\"abcd\\" assert remove_duplicates(\\"hello world\\") == \\"helo wrd\\" assert remove_duplicates(\\"1122334455\\") == \\"12345\\" ``` Constraints - The function must handle an empty string input and should return an empty string in that case. - The function must preserve the order of first occurrences of characters. - The function must handle inputs with a mix of uppercase and lowercase letters and other ASCII characters. Requirements - Implement the function `remove_duplicates` as described. - Ensure the function passes basic tests to verify its correctness.","solution":"def remove_duplicates(text: str) -> str: Remove duplicate characters from the given string while maintaining the order of first occurrences. Args: text: A string that can contain any printable ASCII characters. Returns: A new string with all duplicate characters removed. seen = set() result = [] for char in text: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Array Rotation Problem Given a list of integers and an integer `k`, your task is to write a function that rotates the list to the right by `k` positions iteratively. The rotations should “wrap around” the list elements that go past the end. Function Signature ```python def rotate_array(arr: List[int], k: int) -> List[int]: # Your code here ``` Input - A list of integers `arr` (0 ≤ len(arr) ≤ 10^5). - An integer `k` (0 ≤ k). Output - A list of integers, which is the original list rotated to the right by `k` positions. Constraints - The function should handle large lists efficiently. - Do not use any built-in functions for rotating the list. - Ensure your solution is iterative and optimized for performance. Example ```python assert rotate_array([], 3) == [] assert rotate_array([1, 2, 3, 4, 5], 1) == [5, 1, 2, 3, 4] assert rotate_array([1, 2, 3, 4, 5], 3) == [3, 4, 5, 1, 2] assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert rotate_array([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] ``` Create a program that reads a comma-separated list of integers from the user and an integer `k`, computes the rotated list using your `rotate_array` function, and prints the result. - **Input Format**: - Single string of comma-separated integers, e.g., \\"1,2,3,4,5\\". - An integer `k`. - **Output Format**: - List of integers rotated to the right by `k` positions.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k positions. n = len(arr) if n == 0: return arr k = k % n # Handle cases where k is larger than the length of the array return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement: You are tasked with creating a scheduling system to manage tasks and resources effectively. Write a function to determine the minimum number of resources required to execute all tasks without overlapping. # Requirements 1. Implement a function `min_resources(tasks: List[Tuple[int, int]]) -> int` to compute the minimum number of resources required. 2. The input `tasks` will be a list of tuples, where each tuple represents a task with its start and end times. 3. Each task is identified by its start time `start` and end time `end` (both inclusive). Here is an example task list: ```python tasks = [(1, 4), (2, 6), (8, 10), (2, 3), (5, 8), (9, 12)] ``` In this task list: - Task 1 starts at time 1 and ends at time 4. - Task 2 starts at time 2 and ends at time 6. - Task 3 starts at time 8 and ends at time 10. - And so on. # Steps to implement: 1. Parse the list of tasks to identify start and end times. 2. Sort the tasks based on start times. 3. Use a min-heap or priority queue to track the end times of tasks to determine resource allocation: - Allocate a new resource if the start time of the current task is less than the earliest end time in the heap. - Release resources by removing end times from the heap once a task is completed. 4. Return the number of resources at the peak allocation time. # Constraints: - Tasks are represented as tuples of two integers `(start, end)`. - Tasks are always positive integers, and `start <= end`. - The input list of tasks is always valid and non-empty. # Input: A list of tuples representing the task start and end times. # Output: A single integer representing the minimum number of resources required to handle all tasks without overlapping. # Example: ```python tasks = [(1, 4), (2, 6), (8, 10), (2, 3), (5, 8), (9, 12)] result = min_resources(tasks) # Expected Number of Resources: 3 (derived from analysis of overlaps and required resources) ``` Evaluate your solution for edge cases including: - Single task. - Multiple tasks with no overlap. - Multiple tasks all overlapping at some point. - Randomly ordered tasks.","solution":"from typing import List, Tuple import heapq def min_resources(tasks: List[Tuple[int, int]]) -> int: Determines the minimum number of resources required to execute all tasks without overlapping. Parameters: tasks (List[Tuple[int, int]]): List of tasks where each task is represented by a tuple (start, end). Returns: int: Minimum number of resources required. if not tasks: return 0 # Sort the tasks by start time tasks.sort(key=lambda x: x[0]) # Create a min-heap to keep track of end times of tasks heap = [] for task in tasks: start, end = task # If the heap is not empty and the earliest end time is less than the current start time if heap and heap[0] <= start: # Remove the earliest end time from the heap heapq.heappop(heap) # Push the current end time into the heap heapq.heappush(heap, end) # The size of the heap is the maximum number of overlapping tasks at any point return len(heap)"},{"question":"# Coding Question: Tracking Moving Objects Scenario: You are developing a tracking system for moving objects in a 2D plane. The system is required to record the positions of objects, calculate their trajectories, and identify if any of the objects will collide within a given timeframe. Task: Implement a function `predict_collision` that determines whether any two objects will collide in the next `t` seconds given their initial positions and velocities. Function Signature: ```python def predict_collision(positions: List[Tuple[int, int]], velocities: List[Tuple[int, int]], t: int) -> bool: pass ``` Input: * `positions` (List of Tuples): A list of initial positions of the objects as tuples of integers (x, y). * `velocities` (List of Tuples): A list of velocities of the objects as tuples of integers (vx, vy). * `t` (int): The number of seconds into the future to predict potential collisions. Output: * Return `True` if any two objects collide within `t` seconds, otherwise `False`. Constraints: * You may assume the lists `positions` and `velocities` contain the same number of entries (between 1 and 1000 objects). * Both the positions and velocities components range between -10^3 and 10^3. * The value of `t` will be between 1 and 10^5. Example: ```python >>> predict_collision([(0, 0), (10, 10)], [(1, 1), (-1, -1)], 5) True # The two objects collide at (5, 5). >>> predict_collision([(0, 0), (10, 10)], [(1, 2), (-1, -2)], 3) False # The two objects are not on a collision course within 3 seconds. ``` Additional Information: - Think about the formula for calculating future positions based on initial positions and velocities. - Consider the geometric and kinematic principles to determine when and where collisions occur. - Pay attention to precision and edge cases where objects might just miss each other.","solution":"from typing import List, Tuple def predict_collision(positions: List[Tuple[int, int]], velocities: List[Tuple[int, int]], t: int) -> bool: Determines whether any two objects will collide in the next t seconds given their initial positions and velocities. for i in range(len(positions)): for j in range(i + 1, len(positions)): # Calculate the future positions pos1_x = positions[i][0] + velocities[i][0] * t pos1_y = positions[i][1] + velocities[i][1] * t pos2_x = positions[j][0] + velocities[j][0] * t pos2_y = positions[j][1] + velocities[j][1] * t # Check if the two positions are the same if pos1_x == pos2_x and pos1_y == pos2_y: return True return False"},{"question":"# Problem Statement Write a function that determines the longest contiguous subarray with an equal number of 0\'s and 1\'s. This type of calculation is useful in many coding applications, especially in scenarios where binary data streams need to be analyzed for balanced patterns. # Requirements Function Signature ```python def longest_balanced_subarray(arr: list[int]) -> int: ``` Functionality Description - The function should accept a single parameter: * `arr` (list[int]): A list of integers containing only 0\'s and 1\'s. - The function should return the length of the longest contiguous subarray with an equal number of 0\'s and 1\'s. # Constraints 1. The input list `arr` must be non-empty and contain only integers (`0` or `1`). 2. The function should be designed to work in linear time complexity, O(n), where n is the length of `arr`. 3. The function should use O(n) additional space. # Error Handling 1. Raise a `ValueError` if `arr` contains elements other than `0` or `1`. # Example Usage ```python >>> longest_balanced_subarray([0, 1, 0, 1, 1, 0]) 6 >>> longest_balanced_subarray([0, 0, 1, 1, 0]) 4 >>> longest_balanced_subarray([1, 1, 0, 0, 1, 1, 0, 0]) 8 >>> longest_balanced_subarray([1, 0, 1, 0, 1]) 4 >>> longest_balanced_subarray([0]) 0 >>> longest_balanced_subarray([1]) 0 ``` In addition, ensure that the function properly raises exceptions on incorrect argument types: ```python >>> longest_balanced_subarray([0, 1, 2]) Traceback (most recent call last): ... ValueError: Input list should only contain 0\'s and 1\'s ``` Ensure all these aspects are covered and code functions correctly under the constraints.","solution":"def longest_balanced_subarray(arr: list[int]) -> int: Determines the length of the longest contiguous subarray with an equal number of 0\'s and 1\'s. :param arr: List of integers containing only 0\'s and 1\'s :return: Length of the longest balanced subarray :raises ValueError: If the input list contains elements other than 0\'s and 1\'s if any(x not in {0, 1} for x in arr): raise ValueError(\\"Input list should only contain 0\'s and 1\'s\\") # Map to store the first occurrence of cumulative sum sum_map = {} # Initialize variables max_length = 0 current_sum = 0 # Traverse through the array for i in range(len(arr)): # Subtract 1 for 0 and add 1 for 1 current_sum += 1 if arr[i] == 1 else -1 # Check if current_sum is zero, which means starting from index 0 to i, we have balance if current_sum == 0: max_length = i + 1 # If current_sum is seen before, # there is a subarray from the previous occurrence + 1 to the current index with 0\'s and 1\'s balanced if current_sum in sum_map: max_length = max(max_length, i - sum_map[current_sum]) else: # Store the first occurrence of the current_sum sum_map[current_sum] = i return max_length"},{"question":"# Coding Assessment Question You are given an array `nums` consisting of positive integers and an integer `k`. Write a function `find_kth_smallest(nums: List[int], k: int) -> int` that returns the kth smallest element in the array. Your implementation should be highly efficient and utilize an appropriate algorithm to handle large inputs effectively. # Input - A list of integers `nums`, where the size can be up to 10^5. - An integer `k`, which is the position (1-indexed) of the smallest element to find. # Output - An integer representing the kth smallest element in the list. # Constraints - 1 <= len(nums) <= 100,000 - 1 <= nums[i] <= 10^9 - 1 <= k <= min(100, len(nums)) Here is the skeleton of the function you need to implement: ```python from typing import List import random def find_kth_smallest(nums: List[int], k: int) -> int: # Your implementation here pass def test_find_kth_smallest(): # Your test cases here pass if __name__ == \\"__main__\\": test_find_kth_smallest() ``` # Example ```python nums1 = [7, 10, 4, 3, 20, 15] k1 = 3 print(find_kth_smallest(nums1, k1)) # Output: 7 nums2 = [2, 1, 6, 8, 5, 3] k2 = 5 print(find_kth_smallest(nums2, k2)) # Output: 6 nums3 = [50, 40, 30, 20, 10] k3 = 4 print(find_kth_smallest(nums3, k3)) # Output: 40 large_nums = generate_large_nums() # Generate large input list with size 100,000 k_large = 50 print(find_kth_smallest(large_nums, k_large)) # Output should be tested for large input performance ``` # Approach Comparison Discuss the likely performance of your implementation. Compare it with a naive approach where you sort the list and directly retrieve the kth element. Measure execution time for both methods across different sizes of input arrays and provide the observed time complexity. - Sorting Approach: Time Complexity - O(n log n) - Optimized Approach: Time Complexity - O(n) on average for quickselect algorithm Your optimized implementation should demonstrate substantially better performance for large input arrays.","solution":"from typing import List import random def partition(nums, left, right): pivot = nums[right] i = left for j in range(left, right): if nums[j] <= pivot: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[right] = nums[right], nums[i] return i def quickselect(nums, left, right, k): if left == right: return nums[left] pivot_index = random.randint(left, right) nums[pivot_index], nums[right] = nums[right], nums[pivot_index] pivot_index = partition(nums, left, right) if k == pivot_index: return nums[k] elif k < pivot_index: return quickselect(nums, left, pivot_index - 1, k) else: return quickselect(nums, pivot_index + 1, right, k) def find_kth_smallest(nums: List[int], k: int) -> int: return quickselect(nums, 0, len(nums) - 1, k - 1)"},{"question":"# Longest Consecutive Sequence in an Array You are given an array of integers representing daily data readings, which may not be sorted. Write a function to determine the length of the longest consecutive elements sequence in the array. The algorithm should run in O(n) time complexity. **Function Signature**: `def longest_consecutive_sequence(arr: Sequence[int]) -> int` **Inputs**: 1. `arr` (Sequence[int]): A sequence of integers which can include both positive and negative numbers. **Outputs**: - An integer representing the length of the longest consecutive elements sequence. **Constraints**: - The length of the array is between 0 and 10^6. - The elements of the array are between -10^9 and 10^9. - If the array is empty, return 0. **Examples**: 1. `longest_consecutive_sequence([100, 4, 200, 1, 3, 2])` should return `4` (because the longest consecutive sequence is [1, 2, 3, 4]). 2. `longest_consecutive_sequence([1, 2, 0, 1])` should return `3` (because the longest consecutive sequence is [0, 1, 2]). 3. `longest_consecutive_sequence([])` should return `0`. Implement the function `longest_consecutive_sequence`.","solution":"def longest_consecutive_sequence(arr): Returns the length of the longest consecutive elements sequence in the array. if not arr: return 0 nums_set = set(arr) longest_length = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"# Context As part of a data processing pipeline, you need to sort data records from different sources and remove duplicates. This is a common task in data cleaning which directly impacts the quality of data analysis outcomes. Your solution should be able to handle various data types and ensure the sorted output maintains the original structure while removing any redundant entries. # Task You are to implement a function that takes a list of records, each represented as a tuple, sorts them, and removes duplicates. # Function to Implement ```python def clean_and_sort_records(records: list[tuple]) -> list[tuple]: Args: records: A list of tuples where each tuple contains multiple elements of various types (integers, strings, etc.). Returns: A list of sorted tuples with duplicates removed. The sorting should be ascending and based on the standard tuple comparison. pass ``` # Expected Constraints and Limitations - The input list can contain any number of tuples. - Each tuple could contain elements of different types (e.g., integers, strings). - The function should be efficient even for large lists of tuples. # Requirements - Ensure the tuples are sorted in ascending order based on standard tuple comparison. - Remove any duplicate tuples, maintaining one instance of each unique tuple. - The solution should be efficient with a time complexity close to O(n log n), where n is the number of tuples. # Example ```python records = [(2, \\"apple\\"), (1, \\"banana\\"), (3, \\"apple\\"), (1, \\"banana\\"), (2, \\"apple\\")] output = clean_and_sort_records(records) print(output) # Expected Output: # [(1, \'banana\'), (2, \'apple\'), (3, \'apple\')] ```","solution":"def clean_and_sort_records(records: list[tuple]) -> list[tuple]: Args: records: A list of tuples where each tuple contains multiple elements of various types (integers, strings, etc.). Returns: A list of sorted tuples with duplicates removed. The sorting should be ascending and based on the standard tuple comparison. # Use a set to remove duplicates, then convert back to a list unique_records = list(set(records)) # Sort the list of unique records unique_records.sort() return unique_records"},{"question":"Anagram Checker You are tasked with creating a function that checks whether two strings are anagrams. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using exactly the same letters with the exact same frequency but in a different order. Constraints: - The input must be two strings. - The function should ignore spaces and be case-insensitive. Expected Input and Output: - The function should accept two strings as input. - The function should return `True` if the strings are anagrams, otherwise `False`. Implement the function with the following signature: ```python def are_anagrams(string1: str, string2: str) -> bool: pass ``` # Examples: ```python >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"Triangle\\", \\"Integral\\") True >>> are_anagrams(\\"The eyes\\", \\"They see\\") True >>> are_anagrams(\\"Hello\\", \\"Ole H\\") False >>> are_anagrams(\\"Astronomer\\", \\"Moon starer\\") True >>> are_anagrams(\\"School master\\", \\"The classroom\\") True >>> are_anagrams(\\"Astronomer\\", \\"Moonstare\\") False >>> are_anagrams(\\"Astronomer\\", 123) Traceback (most recent call last): ... TypeError: Both inputs must be strings >>> are_anagrams(123, \\"Moonstare\\") Traceback (most recent call last): ... TypeError: Both inputs must be strings >>> are_anagrams(True, False) Traceback (most recent call last): ... TypeError: Both inputs must be strings ``` Note: - The inputs for the function are restricted to strings only. - The function should raise a `TypeError` if the inputs are not strings.","solution":"def are_anagrams(string1: str, string2: str) -> bool: Check if two strings are anagrams. Parameters: string1 (str): The first string to compare. string2 (str): The second string to compare. Returns: bool: True if the strings are anagrams, False otherwise. Raises: TypeError: If any of the inputs is not a string. if not isinstance(string1, str) or not isinstance(string2, str): raise TypeError(\\"Both inputs must be strings\\") normalized_str1 = \'\'.join(filter(str.isalnum, string1)).lower() normalized_str2 = \'\'.join(filter(str.isalnum, string2)).lower() return sorted(normalized_str1) == sorted(normalized_str2)"},{"question":"**Context**: You are developing a flight reservation system that requires managing a list of booked passengers. The system should support efficient insertion and deletion of passenger records, and allow querying of passenger details based on their booking ID. **Objective**: Implement a class `FlightReservationSystem` that manages the list of passengers using a balanced binary search tree (BST) for optimal performance during inserts, deletions, and lookups. # Requirements: 1. **Class Definition**: Implement the `FlightReservationSystem` with the following methods: * `add_passenger`: Add a passenger to the reservation system. * `remove_passenger`: Remove a passenger from the reservation system. * `find_passenger`: Find and return passenger details by booking ID. * `in_order_traversal`: Return a list of passengers in ascending order of their booking ID. 2. **Passenger Node Implementation**: * `PassengerNode` should have the attributes `booking_id`, `name`, `left`, `right`, and `parent`. 3. **Balanced BST Maintenance**: * Ensure that the tree remains balanced after each insertion and deletion to maintain O(log n) operations. Implement rotations or other balancing operations as needed. # Define Class Structure ```python class PassengerNode: def __init__(self, booking_id, name): self.booking_id = booking_id self.name = name self.left = None self.right = None self.parent = None class FlightReservationSystem: def __init__(self): self.root = None def add_passenger(self, booking_id: int, name: str): Insert a new passenger into the system. # Implement insertion logic, maintaining balance def remove_passenger(self, booking_id: int): Remove a passenger from the system. # Implement deletion logic, maintaining balance def find_passenger(self, booking_id: int) -> str: Find and return the name of the passenger with the given booking ID. # Implement search logic def in_order_traversal(self) -> list: Return a list of all passenger names sorted by booking ID. # Implement in-order traversal logic ``` # Instructions 1. **Insertion**: * Add a `PassengerNode` and maintain the BST properties. * Balance the tree if necessary after insertion. 2. **Deletion**: * Locate the `PassengerNode` to delete, remove it, and maintain BST properties. * Balance the tree if necessary after deletion. 3. **Searching**: * Implement a standard BST search to find a passenger by `booking_id`. 4. **Traversal**: * Implement in-order traversal to return passengers sorted by `booking_id`. # Constraints * `booking_id` is a unique positive integer. * `name` is a non-empty string. * The system initially starts empty. # Example ```python # Example usage flight_system = FlightReservationSystem() flight_system.add_passenger(101, \\"Alice\\") flight_system.add_passenger(203, \\"Bob\\") flight_system.add_passenger(150, \\"Charlie\\") print(flight_system.find_passenger(203)) # Output: Bob flight_system.remove_passenger(101) print(flight_system.in_order_traversal()) # Output: [\'Charlie\', \'Bob\'] ``` In this problem, the candidate is required to implement a flight reservation system using a balanced binary search tree, ensuring optimal performance for insertion, deletion, and lookup operations while keeping the tree balanced after each operation. The problem tests the candidate\'s understanding of binary search trees and their ability to implement and maintain a balanced BST.","solution":"class PassengerNode: def __init__(self, booking_id, name): self.booking_id = booking_id self.name = name self.left = None self.right = None self.parent = None class FlightReservationSystem: def __init__(self): self.root = None def add_passenger(self, booking_id: int, name: str): node = PassengerNode(booking_id, name) if not self.root: self.root = node else: self._insert(self.root, node) self._balance(node) def _insert(self, current, node): if node.booking_id < current.booking_id: if current.left: self._insert(current.left, node) else: current.left = node node.parent = current else: if current.right: self._insert(current.right, node) else: current.right = node node.parent = current def remove_passenger(self, booking_id: int): node = self._find(self.root, booking_id) if node: self._delete(node) self._balance(node.parent) def _delete(self, node): if not (node.left or node.right): self._replace_node_in_parent(node, None) elif node.left and node.right: successor = self._find_min(node.right) node.booking_id, node.name = successor.booking_id, successor.name self._delete(successor) else: if node.left: self._replace_node_in_parent(node, node.left) else: self._replace_node_in_parent(node, node.right) def _replace_node_in_parent(self, node, new_value): if node.parent: if node == node.parent.left: node.parent.left = new_value else: node.parent.right = new_value if new_value: new_value.parent = node.parent else: self.root = new_value if new_value: new_value.parent = None def find_passenger(self, booking_id: int) -> str: node = self._find(self.root, booking_id) return node.name if node else None def _find(self, current, booking_id): if not current or current.booking_id == booking_id: return current elif booking_id < current.booking_id: return self._find(current.left, booking_id) else: return self._find(current.right, booking_id) def in_order_traversal(self) -> list: return [node.name for node in self._in_order(self.root)] def _in_order(self, current): nodes = [] if current: nodes.extend(self._in_order(current.left)) nodes.append(current) nodes.extend(self._in_order(current.right)) return nodes def _find_min(self, current): while current.left: current = current.left return current def _balance(self, node): # This method would include balancing operations like rotations pass"},{"question":"# Scenario: You are tasked with developing a system that handles a series of operations on a collection of strings. This system needs to support efficient prefix and suffix operations to a set of strings. # Task: Implement a class `StringCollection` that efficiently manages a collection of strings. Your class should provide functionality to perform the following operations: 1. **Add a string**: Adds a new string to the collection. 2. **Find strings with a given prefix**: Returns all strings from the collection that start with a given prefix. 3. **Find strings with a given suffix**: Returns all strings from the collection that end with a given suffix. 4. **Remove a string**: Removes a specified string from the collection if it exists. # Requirements: - Assume that strings consist of lowercase English letters only. - You should aim for optimal performance when handling prefix and suffix operations. # Function Specifications: 1. **add_string(s: str) -> None**: Adds the string `s` to the collection. 2. **find_by_prefix(prefix: str) -> list**: Returns a list of strings that start with the specified `prefix`. The list should be lexicographically sorted. 3. **find_by_suffix(suffix: str) -> list**: Returns a list of strings that end with the specified `suffix`. The list should be lexicographically sorted. 4. **remove_string(s: str) -> bool**: Removes the string `s` from the collection if present. Returns `True` if the string was present and removed, otherwise returns `False`. # Constraints: - The length of any string `1 <= len(s) <= 100` - The number of operations will not exceed 10^5. # Example: ```python collection = StringCollection() collection.add_string(\\"apple\\") collection.add_string(\\"app\\") collection.add_string(\\"ape\\") collection.add_string(\\"banana\\") collection.add_string(\\"band\\") print(collection.find_by_prefix(\\"ap\\")) # Output: [\\"ape\\", \\"app\\", \\"apple\\"] print(collection.find_by_suffix(\\"ana\\")) # Output: [\\"banana\\"] collection.remove_string(\\"apple\\") print(collection.find_by_prefix(\\"ap\\")) # Output: [\\"ape\\", \\"app\\"] print(collection.find_by_suffix(\\"ana\\")) # Output: [\\"banana\\"] ``` # Note: - Make sure to handle edge cases, such as attempting to find prefixes or suffixes that do not exist in the collection. - Optimize for both time and space complexity where possible.","solution":"class StringCollection: def __init__(self): self.strings = set() def add_string(self, s: str) -> None: self.strings.add(s) def find_by_prefix(self, prefix: str) -> list: return sorted([s for s in self.strings if s.startswith(prefix)]) def find_by_suffix(self, suffix: str) -> list: return sorted([s for s in self.strings if s.endswith(suffix)]) def remove_string(self, s: str) -> bool: if s in self.strings: self.strings.remove(s) return True return False"},{"question":"# Binary Search Tree: Implementation and Traversal You are required to implement a Binary Search Tree (BST) with basic functionalities and traversal methods. This exercise will help in understanding the properties of BSTs and how to traverse them in various orders. Scenario: Imagine you are working on a module that involves searching and sorting data efficiently. Using a BST, you can ensure that the data remains sorted while allowing efficient insertion, deletion, and lookup operations. Your task is to create a BST with essential operations and methods for in-order traversal. Requirements: 1. **Class Definition**: Define a class `BinarySearchTree` with appropriate methods. 2. **Initialization**: * The tree should be initialized empty, i.e., without any nodes. 3. **Insertion**: * Implement an `insert` method that takes an integer and inserts it into the BST at the correct position. 4. **In-Order Traversal**: * Implement an `in_order_traversal` method that returns a list of all values in the BST in in-order sequence. 5. **Search**: * Implement a `search` method that takes an integer and returns `True` if the value is present in the BST, else returns `False`. 6. **Constraints**: * All values inserted into the BST will be unique integers. Input and Output Formats: * **Input**: * `insert` method: Takes one argument `value` (an integer). * `in_order_traversal` method: Takes no arguments. * `search` method: Takes one argument `value` (an integer). * **Output**: * `insert` method: No return value. * `in_order_traversal` method: Returns a list of integers. * `search` method: Returns a boolean. Example Usage: ```python bst = BinarySearchTree() bst.insert(4) bst.insert(2) bst.insert(6) bst.insert(1) bst.insert(3) bst.insert(5) bst.insert(7) print(bst.in_order_traversal()) # Output: [1, 2, 3, 4, 5, 6, 7] print(bst.search(4)) # Output: True print(bst.search(8)) # Output: False ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, root, result): if root: self._in_order_traversal(root.left, result) result.append(root.val) self._in_order_traversal(root.right, result) def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None: return False if root.val == key: return True elif key < root.val: return self._search(root.left, key) else: return self._search(root.right, key)"},{"question":"**Context**: You are developing a scheduling system where events could be recurring. To simplify the implementation, you need a function to determine the next occurrence of an event given its recurrence pattern and the current date. **Coding Task**: Write a function named `next_occurrence` that takes three parameters: * `current_date` (a string in the format \\"YYYY-MM-DD\\"), * `recurrence` (a string that could be \\"daily\\", \\"weekly\\", or \\"monthly\\"), * `weekday` (optional, a string representing the day of the week, applicable only if `recurrence` is \\"weekly\\"). The function should return the date of the next occurrence of the event in the format \\"YYYY-MM-DD\\". # Input * The function will be called as: `next_occurrence(current_date: str, recurrence: str, weekday: str = None) -> str` * `current_date` (a string): The current date in the format \\"YYYY-MM-DD\\". * `recurrence` (a string): The recurrence pattern (\\"daily\\", \\"weekly\\", \\"monthly\\"). * `weekday` (a string): The day of the week (\\"Monday\\", \\"Tuesday\\", ..., \\"Sunday\\"), applicable only if `recurrence` is \\"weekly\\". # Output * Return a string, indicating the date of the next occurrence in the format \\"YYYY-MM-DD\\". # Constraints * You may assume all inputs are valid dates and strings. * The function should handle possible edge cases such as month-end and leap years. * If `recurrence` is \\"weekly\\" and `weekday` is not provided, raise a ValueError. # Example ```python from datetime import datetime, timedelta def next_occurrence(current_date: str, recurrence: str, weekday: str = None) -> str: # Your implementation here # Example usage print(next_occurrence(\\"2023-10-01\\", \\"daily\\")) # Output: \\"2023-10-02\\" print(next_occurrence(\\"2023-10-01\\", \\"weekly\\", \\"Friday\\")) # Output: \\"2023-10-06\\" print(next_occurrence(\\"2023-10-01\\", \\"monthly\\")) # Output: \\"2023-11-01\\" print(next_occurrence(\\"2023-12-31\\", \\"monthly\\")) # Output: \\"2024-01-31\\" ``` # Explanation * In the first example, a daily recurrence just adds one day to the current date. * In the second example, the next Friday after October 1, 2023, is October 6, 2023. * In the third example, a monthly recurrence moves from October 1 to November 1. * In the fourth example, the function accounts for the end of the year, correctly moving from December 31, 2023, to January 31, 2024.","solution":"from datetime import datetime, timedelta def next_occurrence(current_date: str, recurrence: str, weekday: str = None) -> str: current_date = datetime.strptime(current_date, \\"%Y-%m-%d\\") if recurrence == \\"daily\\": next_date = current_date + timedelta(days=1) elif recurrence == \\"weekly\\": if weekday is None: raise ValueError(\\"Weekday must be provided for \'weekly\' recurrence.\\") days_of_week = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] if weekday not in days_of_week: raise ValueError(\\"Invalid weekday provided.\\") target_day_index = days_of_week.index(weekday) current_day_index = current_date.weekday() days_until_next = (target_day_index - current_day_index + 7) % 7 if days_until_next == 0: days_until_next = 7 # Ensuring that the next day is in the future next_date = current_date + timedelta(days=days_until_next) elif recurrence == \\"monthly\\": next_month = current_date.month + 1 year = current_date.year + next_month // 12 next_month = next_month % 12 or 12 last_day_of_next_month = (datetime(year, next_month + 1, 1) - timedelta(days=1)).day day = min(current_date.day, last_day_of_next_month) next_date = datetime(year, next_month, day) return next_date.strftime(\\"%Y-%m-%d\\")"},{"question":"# Next Largest Permutation Challenge **Objective**: Create a function that takes an array of integers and generates the next lexicographical permutation of the numbers. **Problem Statement**: Write a function `next_largest_permutation(nums: List[int]) -> List[int]` that will rearrange the given list of numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it should rearrange the numbers into the smallest possible order (i.e., sorted in ascending order). **Constraints**: 1. The list contains non-negative integers. 2. The list length can range from 1 to 10^4. 3. You need to achieve the solution with an in-place algorithm (i.e., without using extra space for another array). **Expected Input and Output**: *Function Signature*: ```python def next_largest_permutation(nums: List[int]) -> List[int]: pass ``` - Input: ```python next_largest_permutation([1, 2, 3]) ``` - Output: ```python [1, 3, 2] ``` **Examples**: 1. `next_largest_permutation([3, 2, 1])` should return `[1, 2, 3]`. 2. `next_largest_permutation([1, 1, 5])` should return `[1, 5, 1]`. 3. `next_largest_permutation([1, 3, 2])` should return `[2, 1, 3]`. **Performance Requirements**: 1. Time Complexity: O(n) 2. Space Complexity: O(1) **Note**: To generate the next lexicographical permutation, you can follow these steps: 1. Find the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, the permutation is the last permutation (sorted in descending order), and you need to reverse the entire list to get the smallest permutation (sorted in ascending order). 2. Find the largest index `l` such that `l > k` and `nums[k] < nums[l]`. 3. Swap the value of `nums[k]` with `nums[l]`. 4. Reverse the sequence from `nums[k + 1]` up to the end of the list. Write your function considering these steps and constraints. Ensure the solution handles edge cases and validate its correctness with comprehensive test cases.","solution":"from typing import List def next_largest_permutation(nums: List[int]) -> List[int]: Rearranges the list of numbers into the lexicographically next greater permutation of numbers. If there is no next permutation, rearrange as the smallest possible order. This function modifies the input list in place. # Step 1: Find the largest index `k` such that `nums[k] < nums[k + 1]` k = len(nums) - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k == -1: # No such index exists, reverse the entire list nums.reverse() return nums # Step 2: Find the largest index `l` such that `l > k` and `nums[k] < nums[l]` l = len(nums) - 1 while nums[l] <= nums[k]: l -= 1 # Step 3: Swap `nums[k]` and `nums[l]` nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from `nums[k + 1]` to the end of the list nums[k + 1:] = reversed(nums[k + 1:]) return nums"},{"question":"# Problem Statement You are developing a library system that needs to efficiently allocate books to shelves such that the total weight of books on each shelf does not exceed a specified maximum weight capacity. Your task is to implement an algorithm that distributes the books in an optimal way. # Implementation Details 1. **Function Signature**: Implement the function `allocate_books(books: List[int], max_weight: int) -> List[List[int]]` 2. **Input**: - `books` (List[int]): A list where each element represents the weight of a book. - `max_weight` (int): The maximum weight capacity of each shelf. 3. **Output**: - A list of lists, where each sublist represents the books allocated to a single shelf. 4. **Constraints**: - The list `books` will contain at most 1000 books. - Each book\'s weight will be a positive integer not exceeding the `max_weight`. # Example ```python books = [5, 10, 8, 7, 3, 14, 9] max_weight = 15 assert allocate_books(books, max_weight) == [[5, 8], [10, 3], [7], [14], [9]] # Note: The order of the books within each shelf and the order of shelves in the list might differ as long as the distribution respects the max_weight constraint. ``` # Additional Notes - Your solution should aim to minimize the number of shelves used. - It\'s not necessary for the order of the books in the output to match the order given in the input, as long as the total weight does not exceed the maximum weight for any shelf. - Ensure the function handles edge cases, such as an empty list of books or books that individually exceed the maximum weight (in which case they should be placed on separate shelves).","solution":"from typing import List def allocate_books(books: List[int], max_weight: int) -> List[List[int]]: Distributes the books onto shelves such that no shelf exceeds the max_weight. Tries to minimize the number of shelves used. :param books: List of book weights to be distributed on shelves. :param max_weight: Maximum weight capacity of each shelf. :return: A list of lists, where each sublist represents the books on a single shelf. if not books: return [] books.sort(reverse=True) shelves = [] for book in books: placed = False for shelf in shelves: if sum(shelf) + book <= max_weight: shelf.append(book) placed = True break if not placed: shelves.append([book]) return shelves"},{"question":"# Task Description Implement a function that finds all unique subsets of a given set of integers. The answer should not contain duplicate subsets, and the elements within each subset should be in non-decreasing order. # Function Signature ```python def unique_subsets(nums: List[int]) -> List[List[int]]: pass ``` # Input - A list of integers `nums` representing the set. (0 ≤ len(nums) ≤ 10, -10 ≤ nums[i] ≤ 10) # Output - Return a list of lists, where each inner list is a unique subset of `nums` in non-decreasing order. # Constraints - The solution should handle sets with duplicate elements, ensuring that subsets are unique. - Subsets should be returned in any order. # Example ```python assert unique_subsets([1, 2, 2]) == [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] assert unique_subsets([4, 4, 4, 1, 4]) == [[], [1], [1, 4], [1, 4, 4], [1, 4, 4, 4], [1, 4, 4, 4, 4], [4], [4, 4], [4, 4, 4], [4, 4, 4, 4]] assert unique_subsets([]) == [[]] assert unique_subsets([2, 2]) == [[], [2], [2, 2]] ``` # Special Note - Ensure the algorithm does not generate duplicate subsets. - Use backtracking or iterative approaches to explore subsets efficiently. - Consider sorting `nums` initially to ease the generation of subsets in non-decreasing order.","solution":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: def backtrack(start, path): result.append(path) for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue backtrack(i + 1, path + [nums[i]]) nums.sort() result = [] backtrack(0, []) return result"},{"question":"# Scenario You are part of a development team working on a text-processing application. One of the features of this application is a function that counts the frequency of each word in a given text, ignoring common \\"stop words.\\" # Coding Task Implement a function `word_frequency` that counts the occurrences of each word in a text, ignoring a predefined set of \\"stop words\\". Your function should be case-insensitive and handle punctuation properly. # Constraints 1. **Inputs**: - `text`: String, up to 10^6 characters. - `stop_words`: List of strings, each string up to 100 characters, total length of the list up to 10^3 words. 2. **Outputs**: - Return a dictionary where the keys are the words (in lowercase) and the values are their frequencies in the text. # Example ```python def word_frequency(text: str, stop_words: List[str]) -> Dict[str, int]: # implementation required here example_text = \\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\" stop_words = [\\"the\\", \\"was\\", \\"over\\", \\"not\\"] assert word_frequency(example_text, stop_words) == { \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'lazy\': 1, \'dog\': 2, \'amused\': 1 } ``` # Additional Requirements 1. **Case Insensitive**: Treat the text as case insensitive, and convert all words to lowercase. 2. **Punctuation Handling**: Ignore punctuation marks (e.g., periods, commas, etc.) when counting words. 3. **Efficiency**: Ensure the function runs efficiently, even for the upper limits of the input sizes. You are expected to write clean, efficient, and well-commented code.","solution":"import re from collections import defaultdict from typing import List, Dict def word_frequency(text: str, stop_words: List[str]) -> Dict[str, int]: Counts the occurrences of each word in the text, ignoring common stop words. The function is case-insensitive and handles punctuation properly. Args: text (str): The input text. stop_words (List[str]): The list of stop words to be ignored. Returns: Dict[str, int]: A dictionary with words as keys and their frequencies as values. # Convert stop words to a set of lowercase words for faster lookup stop_words_set = set(word.lower() for word in stop_words) # Normalize the text to lowercase and use regex to find all words words = re.findall(r\'bw+b\', text.lower()) # Count the occurrences of each word ignoring the stop words word_count = defaultdict(int) for word in words: if word not in stop_words_set: word_count[word] += 1 return dict(word_count)"},{"question":"# Coding Assessment: Implementing K-Means Clustering **Objective**: Implement the K-Means Clustering algorithm to group a set of instances into `k` clusters. You will use provided functions and general algorithmic steps as a reference to create new functions that complete the clustering process. # Problem Statement Given a series of steps and a structure for the K-Means Clustering algorithm, implement additional functionality to assign instances to clusters and update cluster centroids iteratively. Your task is to complete the clustering process, handle edge cases, and ensure accurate cluster formation. # Scenario A research team wants to use K-Means Clustering to analyze their large dataset by grouping data points into meaningful clusters. You are to implement the clustering model that will assign data points to clusters iteratively based on given features and desired number of clusters, `k`. # Requirements 1. **Function to Assign Instances to Clusters**: * Input: `features` (2D list of feature values), `centroids` (2D list of centroid values). * Output: List of cluster assignments for each instance. 2. **Function to Update Centroids**: * Input: `features` (2D list of feature values), `assignments` (list of cluster assignments). * Output: List of updated centroids. 3. **Function to Execute K-Means Clustering**: * Input: `features` (2D list of feature values), `k` (number of clusters), `max_iters` (maximum number of iterations). * Output: Tuple of (final centroids, final assignments). # Input and Output Format **Function 1: assign_clusters** ```python def assign_clusters(features: list[list[float]], centroids: list[list[float]]) -> list[int]: pass ``` **Function 2: update_centroids** ```python def update_centroids(features: list[list[float]], assignments: list[int]) -> list[list[float]]: pass ``` **Function 3: k_means** ```python def k_means(features: list[list[float]], k: int, max_iters: int = 100) -> tuple[list[list[float]], list[int]]: pass ``` # Constraints * Assume that `k` is less than or equal to the number of instances. * The initial centroids for the K-Means algorithm can be selected randomly from existing data points. * The algorithm should stop if the centroids do not change or if `max_iters` is reached. # Example ```python # Example data features = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.2, 0.8], [9.0, 11.0], ] # Perform K-Means clustering with k=2 k = 2 centroids, assignments = k_means(features, k) print(centroids) # Expected output: Centroids of the clusters print(assignments) # Expected output: Cluster assignments, e.g., [0, 0, 1, 1, 0, 1] ``` # Edge Cases * Handle cases where clusters become empty during the iterations. * Ensure the algorithm can handle datasets with overlapping clusters. * Deal with cases where convergence is reached before `max_iters`. # Submission Complete the functions to assign instances to clusters, update centroids, and execute the K-Means clustering algorithm. Ensure your solution works as expected on given data and handles edge cases appropriately.","solution":"import random import math def assign_clusters(features, centroids): Assigns data points to the nearest centroid. Parameters: features (list[list[float]]): 2D list of feature values. centroids (list[list[float]]): 2D list of centroid values. Returns: list[int]: List of cluster assignments for each instance. assignments = [] for feature in features: closest_centroid = min(range(len(centroids)), key=lambda i: euclidean_distance(feature, centroids[i])) assignments.append(closest_centroid) return assignments def update_centroids(features, assignments, k): Updates centroids based on the mean of assigned data points. Parameters: features (list[list[float]]): 2D list of feature values. assignments (list[int]): List of cluster assignments. k (int): Number of clusters. Returns: list[list[float]]: List of updated centroids. new_centroids = [[0] * len(features[0]) for _ in range(k)] counts = [0] * k for assignment, feature in zip(assignments, features): for i in range(len(feature)): new_centroids[assignment][i] += feature[i] counts[assignment] += 1 for i in range(k): for j in range(len(new_centroids[i])): if counts[i] > 0: new_centroids[i][j] /= counts[i] else: # Handle empty cluster by reinitializing the centroid randomly new_centroids[i] = random.choice(features) return new_centroids def euclidean_distance(point1, point2): return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def k_means(features, k, max_iters=100): Executes the K-Means clustering algorithm. Parameters: features (list[list[float]]): 2D list of feature values. k (int): Number of clusters. max_iters (int): Maximum number of iterations. Returns: tuple[list[list[float]], list[int]]: Tuple of final centroids and final assignments. # Initialize centroids randomly from features centroids = random.sample(features, k) for _ in range(max_iters): assignments = assign_clusters(features, centroids) new_centroids = update_centroids(features, assignments, k) if new_centroids == centroids: break centroids = new_centroids return centroids, assignments"},{"question":"# Question: Enhance Custom Linked List Class You have been provided with a partially implemented `LinkedList` class that supports basic linked list operations such as adding and removing elements. Your task is to enhance the existing `LinkedList` class to include the following advanced features: 1. **Reverse the Linked List**: Implement a method `reverse(self) -> None` to reverse the linked list in place. 2. **Detect Loop**: Implement a method `has_loop(self) -> bool` to detect if the linked list contains a loop (cycle). Return `True` if a loop is detected, otherwise return `False`. 3. **Find the k-th Last Element**: Implement a method `kth_last_element(self, k: int) -> Any` to find and return the k-th last element in the linked list. If `k` is greater than the length of the list, raise an IndexError. Input: - The provided `LinkedList` class and its instance methods. Output: - For `reverse()`, the linked list will be modified in place. - For `has_loop()`, return a boolean indicating whether a loop is present. - For `kth_last_element()`, return the value of the k-th last element. Constraints: - The linked list can contain up to 1000 elements. - Elements of the linked list can be of any data type. Example: ```python # Creating the linked list linked_list = LinkedList() linked_list.append(1) linked_list.append(2) linked_list.append(3) linked_list.append(4) linked_list.append(5) # Reverse the linked list linked_list.reverse() # The list is now 5 -> 4 -> 3 -> 2 -> 1 # Detect loop print(linked_list.has_loop()) # Output: False # Create a loop for testing node1 = linked_list.head node2 = linked_list.head.next.next node2.next.next = node1 # Creating a loop: 1 -> 2 -> 3 -> 1 print(linked_list.has_loop()) # Output: True # Find the k-th last element print(linked_list.kth_last_element(2)) # Output: 4 # If k is greater than the length of the list try: linked_list.kth_last_element(6) except IndexError as e: print(e) # Output: IndexError ```","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = ListNode(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def has_loop(self): slow = fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def kth_last_element(self, k): # Two-pointer approach main_ptr = ref_ptr = self.head count = 0 while count < k: if not ref_ptr: raise IndexError(\\"k is greater than the length of the linked list\\") ref_ptr = ref_ptr.next count += 1 while ref_ptr: main_ptr = main_ptr.next ref_ptr = ref_ptr.next if main_ptr: return main_ptr.value else: raise IndexError(\\"k is greater than the length of the linked list\\")"},{"question":"# Problem Statement You are given a grid of size `m x n` and two points `(x1, y1)` and `(x2, y2)` on the grid, where `x1`, `y1`, `x2`, and `y2` are the coordinates of the initial and target positions, respectively. Your task is to implement a function `min_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> int` that returns the minimum number of steps required to move from the start point to the end point. You can only move left, right, up, or down, and only over the cells that contain a `1`. Cells containing `0` represent obstacles and cannot be traversed. # Function Signature ```python def min_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> int: pass ``` # Input - `grid`: A 2D list of integers representing the grid. - `start`: A tuple `(x1, y1)` representing the coordinates of the starting point. - `end`: A tuple `(x2, y2)` representing the coordinates of the end point. # Output - An integer representing the minimum number of steps to reach from the start to the end point. If it is not possible to reach the end point, return `-1`. # Constraints - `1 <= m, n <= 100` - `0 <= x1, y1, x2, y2 < m` - `0 <= grid[i][j] <= 1` # Example ```python grid = [ [1, 1, 0, 0, 0], [0, 1, 1, 1, 1], [0, 0, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 1, 1, 1] ] start = (0, 0) end = (4, 4) min_path(grid, start, end) # Expected output: 8 ``` # Notes - If `start` is the same as `end`, the output should be `0` (zero steps needed since you are already at the target). - Consider edge cases where the grid has no `1` at all, or the start or end points are on a `0`. - Optimize the implementation to handle the constraints efficiently.","solution":"from collections import deque def min_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> int: m, n = len(grid), len(grid[0]) x1, y1 = start x2, y2 = end if grid[x1][y1] == 0 or grid[x2][y2] == 0: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(x1, y1, 0)]) visited = set([(x1, y1)]) while queue: x, y, steps = queue.popleft() if (x, y) == (x2, y2): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"# Problem Statement Given a string of words separated by spaces, write a function that returns the length of the longest word in the string. If there are multiple words of the same longest length, return the first one encountered. Ensure your solution efficiently handles long strings with numerous words. # Function Signature ```python def longest_word_length(s: str) -> int: ``` # Input * `s` (str): A string composed of words separated by single spaces. The string can be empty or contain only spaces. # Output * (int): The length of the longest word in the string. # Constraints * The length of the input string `s` can be as large as 10^6 characters. * Words are separated by single spaces. No leading, trailing, or multiple spaces between words. * A word is defined as a maximal substring consisting of non-space characters. # Example ```python assert longest_word_length(\\"The quick brown fox jumps over the lazy dog\\") == 5 assert longest_word_length(\\"Hello world\\") == 5 assert longest_word_length(\\"To be or not to be\\") == 3 assert longest_word_length(\\"\\") == 0 assert longest_word_length(\\"a ab abc abcd abcde abcdef\\") == 6 ``` # Requirements * Implement the solution with a time complexity of O(N). * Ensure the solution handles edge cases like an empty string, a string with a single long word, and strings with words of equal length.","solution":"def longest_word_length(s: str) -> int: Returns the length of the longest word in the string s. if not s.strip(): return 0 words = s.split(\' \') max_length = 0 for word in words: max_length = max(max_length, len(word)) return max_length"},{"question":"# Coding Assessment Question In this assessment, you need to extend a URL shortening service by implementing a custom algorithm to generate unique short URLs and ensure the service can handle high volumes of URL shortening requests while preventing collisions. This exercise is designed to test your understanding of hash functions, data structures, and system design. Your Task 1. **Generate Unique Short URLs**: - Implement an algorithm to generate short URLs using a base62 encoding scheme (using the characters `[0-9, a-z, A-Z]`). - Ensure that the generated short URL is unique and does not already exist in the database of shortened URLs. 2. **Handle High Volume Requests**: - Design a method to efficiently check for collisions and ensure consistent performance under high volume URL shortening requests. - Optimize the database interactions to minimize latency and prevent bottlenecks. # Implementation Details Required Functions: 1. **`generate_short_url(long_url: str) -> str`**: - Converts a given long URL to a unique short URL using base62 encoding. - Verifies that the generated URL is unique, and if not, generates a new one until a unique URL is found. 2. **`is_unique(short_url: str) -> bool`**: - Checks the database to determine if a generated short URL is unique. 3. **`store_url_mapping(short_url: str, long_url: str) -> None`**: - Stores the mapping of the short URL to the original long URL in the database. Constraints: - The long URL can be up to 2048 characters. - Ensure high availability and fault tolerance. - The service should be able to shorten and resolve URLs within a few milliseconds. Input/Output: - **Input**: - A string representing the long URL to be shortened. - **Output**: - A generated short URL as a string which is guaranteed to be unique. # Performance Requirements - The designed solution must be able to process up to 10,000 URL shortening requests per second. # Scenario You are tasked with upgrading a URL shortening service. Your goal is to implement a robust algorithm for generating unique short URLs using a base62 encoding scheme, and to ensure the service maintains high performance and availability even when handling large volumes of requests. The solution should effectively manage the URL mappings and prevent collisions to ensure that every shortened URL is unique and correctly mapped to its original long URL.","solution":"import string import random import threading # Base62 characters BASE62 = string.digits + string.ascii_letters # In-memory store for URL mappings, for demonstration purposes url_mapping = {} lock = threading.Lock() def base62_encode(num): Encodes a number in base62. if num == 0: return BASE62[0] base62 = [] while num: num, rem = divmod(num, 62) base62.append(BASE62[rem]) return \'\'.join(reversed(base62)) def is_unique(short_url): Checks if the generated short URL is unique in the database. with lock: return short_url not in url_mapping def store_url_mapping(short_url, long_url): Stores the mapping of short URL to the original long URL in the database. with lock: url_mapping[short_url] = long_url def generate_short_url(long_url): Generates a unique short URL for the given long URL. while True: # Use a random number for base62 encoding to generate short URL random_num = random.randint(0, 62**6 - 1) # Limiting to 6 characters short_url = base62_encode(random_num) # Ensure the generated short URL is unique if is_unique(short_url): # Store the mapping in our in-memory database store_url_mapping(short_url, long_url) return short_url"},{"question":"# Coding Assessment Question Scenario You are tasked with enhancing a web application\'s backend by implementing an efficient caching mechanism to reduce the number of database queries and improve response times. Task Implement a `LRUCache` class that uses the Least Recently Used (LRU) caching strategy. This class should store key-value pairs and ensure that when the cache reaches its maximum capacity, it evicts the least recently used item before inserting a new one. Class Definition ```python class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` Methods - `__init__(self, capacity: int)`: Initializes the LRU cache with a fixed capacity. - `get(self, key: int) -> int`: Returns the value of the key if the key exists in the cache, otherwise returns -1. - `put(self, key: int, value: int) -> None`: Updates the value of the key if the key already exists. Otherwise, it inserts the key-value pair into the cache. If the cache is at capacity, it should evict the least recently used item. Example Usage ```python # Create a cache with capacity 2 cache = LRUCache(2) # Add a key-value pair (1, 1) cache.put(1, 1) # Add a key-value pair (2, 2) cache.put(2, 2) # Retrieve value for key 1 (expected 1) print(cache.get(1)) # Output: 1 # Add a key-value pair (3, 3), this operation will evict key 2 cache.put(3, 3) # Retrieving key 2 should return -1 as it was evicted print(cache.get(2)) # Output: -1 # Add a key-value pair (4, 4), this operation will evict key 1 cache.put(4, 4) # Retrieve value for key 1 (expected -1 as it was evicted) print(cache.get(1)) # Output: -1 # Retrieve value for key 3 (expected 3) print(cache.get(3)) # Output: 3 # Retrieve value for key 4 (expected 4) print(cache.get(4)) # Output: 4 ``` Constraints - The total number of entries in the cache should not exceed its capacity. - The operations `get` and `put` should run in O(1) average time complexity. Additional Requirements - Provide at least two edge cases in your test cases such as trying to `get` a key from an empty cache and handling the case where `put` is called with existing keys. Make sure to structure your code efficiently and handle edge cases to conform with the LRU caching strategy principles.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key, last=True) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key, last=True) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"Problem Description: You are given a list of integer intervals and an integer value `k`. The task is to determine if `k` overlaps with any of the intervals in the list. Each interval is represented as a tuple `(start, end)` with both start and end included. **Objective**: Write a function `is_k_in_intervals(intervals: List[Tuple[int, int]], k: int) -> bool` that returns `True` if `k` overlaps with any of the intervals and `False` otherwise. **Function Signature**: ```python from typing import List, Tuple def is_k_in_intervals(intervals: List[Tuple[int, int]], k: int) -> bool: pass ``` **Input**: - `intervals`: A list of tuples where each tuple contains two integers `(start, end)` representing an interval. - `k`: An integer to be checked against the intervals. **Output**: - A boolean value indicating whether `k` overlaps with any interval in the list. **Constraints**: 1. The list `intervals` may contain between 1 and 10,000 intervals. 2. The value of `k` and the interval bounds will be in the range of `-10^6` to `10^6`. **Performance Requirements**: - The solution should be efficient, ideally operating in linear time with respect to the number of intervals. **Example**: ```python >>> is_k_in_intervals([(1, 5), (10, 20), (30, 40)], 3) True >>> is_k_in_intervals([(1, 5), (10, 20), (30, 40)], 6) False >>> is_k_in_intervals([(1, 5), (10, 20), (30, 40)], 10) True >>> is_k_in_intervals([(1, 5), (10, 20), (30, 40)], -1) False ``` **Explanation**: 1. This problem requires you to check each interval to see if `k` falls within its range. 2. Efficient checking is needed to ensure performance is acceptable with large input sizes. 3. Ensure robustness in handling the range of integer values and various list sizes.","solution":"from typing import List, Tuple def is_k_in_intervals(intervals: List[Tuple[int, int]], k: int) -> bool: Determines if the given integer k lies within any of the intervals. Parameters: - intervals (List[Tuple[int, int]]): A list of tuples where each tuple denotes an interval (start, end) - k (int): The integer to check for in the intervals. Returns: - bool: True if k is within any of the intervals, False otherwise. for (start, end) in intervals: if start <= k <= end: return True return False"},{"question":"# Snake Case to Camel Case Conversion In programming, the naming conventions for identifiers vary. One common format is the snake_case where words are separated by underscores. Another format is the camelCase, where the first letter of each word is capitalized except the initial word. Your task is to convert a given snake_case string to camelCase. Task You are required to implement a function `snake_to_camel` that takes a string in snake_case format and returns its camelCase representation. Function Signature ```python def snake_to_camel(snake: str) -> str: pass ``` Input * `snake` (str): A string in snake_case format. Output * Returns a string representing the camelCase format of the input. Constraints * The input string only contains lowercase letters and underscores. * The input string will not start or end with an underscore. * There will be no consecutive underscores. * The length of the input string will not exceed 100 characters. Examples * Example 1: - Input: `example_string` - Output: `exampleString` * Example 2: - Input: `convert_this_to_camel_case` - Output: `convertThisToCamelCase` * Example 3: - Input: `test_string` - Output: `testString` * Example 4: - Input: `long_example_for_testing` - Output: `longExampleForTesting` * Example 5: - Input: `sample_input` - Output: `sampleInput` Requirements * Handle edge cases gracefully, such as single-word inputs with no underscores. * Ensure that each word after the first word starts with an uppercase letter in the output. * Consider performance implications for the given constraints and optimize accordingly.","solution":"def snake_to_camel(snake: str) -> str: Converts a snake_case string to camelCase. parts = snake.split(\'_\') return parts[0] + \'\'.join(word.capitalize() for word in parts[1:])"},{"question":"# Inventory Management System As the chief developer of an inventory management system, you need to implement a function that processes a list of transactions and updates the available stock for each product category accordingly. Each transaction either adds to or removes from the existing stock of a product category. Requirements: 1. Maintain a dictionary where the keys are product categories and the values are the current stock levels. 2. Process a list of transactions, where each transaction is a tuple consisting of a product category, an operation (\'add\' or \'remove\'), and a quantity. 3. Update the stock levels based on the transactions, ensuring the stock levels never drop below zero. # Function Specification Implement the function `update_inventory(stock: dict, transactions: list) -> dict` that processes the transactions and returns the updated stock levels. Inputs: - `stock`: A dictionary where the keys are product categories (strings) and the values are integers representing the current stock levels. - `transactions`: A list of tuples, each representing a transaction. Each tuple is of the form `(category: str, operation: str, quantity: int)`. Outputs: - A dictionary representing the updated stock levels. Constraints: - `stock` will have non-negative integers only. - The `operation` in the transactions will be either \'add\' or \'remove\'. - The `quantity` in the transactions will be a positive integer. Performance Requirements: - The function should handle large lists of transactions efficiently. Example Usage: ```python initial_stock = {\'apples\': 10, \'bananas\': 5, \'oranges\': 8} transactions = [(\'apples\', \'add\', 5), (\'bananas\', \'remove\', 2), (\'apples\', \'remove\', 15), (\'oranges\', \'add\', 7)] updated_stock = update_inventory(initial_stock, transactions) print(updated_stock) # Output: {\'apples\': 0, \'bananas\': 3, \'oranges\': 15} ``` In this example, the stock of \'apples\' is reduced to 0 because the removal operation would otherwise result in negative stock. The stock of \'bananas\' is updated to 3 after a removal, and the stock of \'oranges\' is increased by 7.","solution":"def update_inventory(stock: dict, transactions: list) -> dict: Updates the stock levels based on a list of transactions. Parameters: stock (dict): A dictionary where keys are product categories and values are their stock levels. transactions (list): A list of tuples, where each tuple consists of (category, operation, quantity). Returns: dict: The updated stock levels. for category, operation, quantity in transactions: if category in stock: if operation == \'add\': stock[category] += quantity elif operation == \'remove\': stock[category] = max(stock[category] - quantity, 0) else: if operation == \'add\': stock[category] = quantity elif operation == \'remove\': stock[category] = 0 # If the category does not exist, removing results in 0 stock return stock"},{"question":"# String Pattern Matcher **Problem Statement**: You are tasked to create a Python class `PatternMatcher` to check if a given string matches a specific pattern where the pattern may include the special character `*` that can replace any sequence of characters (including an empty sequence). **Requirements**: 1. Implement the `PatternMatcher` class with the following methods: - A constructor that takes a string representing the pattern. - A method `matches(string)` that takes a string as an argument and returns `True` if the string matches the pattern, or `False` otherwise. **Input Format**: - The constructor of `PatternMatcher` takes a single string which represents the pattern. The pattern may contain alphanumeric characters and the `*` symbol. **Output Format**: - The `matches(string)` method returns a boolean indicating whether the given string matches the pattern. **Constraints**: - The input pattern and string will only contain alphanumeric characters and the `*` symbol. - The length of the pattern and string will be between 1 and 1000, inclusive. **Example**: ```python >>> pm = PatternMatcher(\\"a*b\\") >>> pm.matches(\\"aaab\\") True >>> pm.matches(\\"ab\\") True >>> pm.matches(\\"abc\\") False ``` **Notes**: - Ensure to test with multiple patterns and strings to validate all possible cases, including edge cases such as an empty string (where applicable) and patterns filled only with `*`.","solution":"class PatternMatcher: def __init__(self, pattern): self.pattern = pattern def matches(self, string): return self._match_helper(self.pattern, string) def _match_helper(self, pattern, string): # Base case: if pattern is empty, string should also be empty for a match if not pattern: return not string # Match the first characters or the wildcard \'*\' first_match = bool(string) and (pattern[0] == string[0] or pattern[0] == \'*\') # If current character in pattern is \'*\', it can match zero or more characters in string if pattern and pattern[0] == \'*\': return self._match_helper(pattern[1:], string) or (first_match and self._match_helper(pattern, string[1:])) else: return first_match and self._match_helper(pattern[1:], string[1:])"},{"question":"# Coding Assessment Question Question: Given a dictionary where the keys are words and the values are lists of synonyms, write a function `find_synonyms_chain(word1: str, word2: str, synonyms_dict: dict) -> List[str]` that finds the shortest chain of synonyms starting from `word1` to reach `word2`. A chain of synonyms is a sequence of words where each word in the sequence is a synonym of the next word. If no such chain exists, return an empty list. If `word1` is equal to `word2`, return a list containing only `word1`. Function Signature: ```python from typing import List, Dict def find_synonyms_chain(word1: str, word2: str, synonyms_dict: Dict[str, List[str]]) -> List[str]: pass ``` Input: - `word1` (str): The starting word (assume no leading or trailing spaces). - `word2` (str): The target word (assume no leading or trailing spaces). - `synonyms_dict` (dict): A dictionary where keys are words and values are lists of their synonyms. Output: - `List[str]`: The shortest chain of synonyms from `word1` to `word2`. Constraints: - The maximum number of words in the dictionary will be 1000. - Each word will have at most 10 synonyms. - Each word will be a non-empty string with a maximum length of 100 characters. - Your algorithm should be efficient enough to handle the maximum input sizes. Performance Requirements: - Time Complexity should be O(N), where N is the number of words in the dictionary (considering the operations involved in graph traversal). Example: ```python >>> synonyms_dict = { \'happy\': [\'joyful\', \'content\'], \'joyful\': [\'cheerful\'], \'content\': [\'fulfilled\'], \'cheerful\': [\'merry\'], } >>> find_synonyms_chain(\'happy\', \'merry\', synonyms_dict) [\'happy\', \'joyful\', \'cheerful\', \'merry\'] >>> find_synonyms_chain(\'happy\', \'fulfilled\', synonyms_dict) [\'happy\', \'content\', \'fulfilled\'] >>> find_synonyms_chain(\'happy\', \'happy\', synonyms_dict) [\'happy\'] >>> find_synonyms_chain(\'happy\', \'sad\', synonyms_dict) [] ``` # Additional Information: 1. Consider the problem as finding the shortest path in an unweighted graph where nodes are words and edges are synonymous relationships. 2. You might find Breadth-First Search (BFS) useful for finding the shortest path in this context. 3. Ensure to handle cases where either `word1` or `word2` may not be present in the synonyms dictionary.","solution":"from typing import List, Dict from collections import deque def find_synonyms_chain(word1: str, word2: str, synonyms_dict: Dict[str, List[str]]) -> List[str]: if word1 == word2: return [word1] if word1 not in synonyms_dict and word2 not in synonyms_dict: return [] # Use BFS to find the shortest path queue = deque([[word1]]) visited = set([word1]) while queue: path = queue.popleft() current_word = path[-1] for synonym in synonyms_dict.get(current_word, []): if synonym == word2: return path + [synonym] if synonym not in visited: visited.add(synonym) queue.append(path + [synonym]) return []"},{"question":"# Question: Rotate Matrix You are tasked with creating a function that rotates an NxN matrix by 90 degrees clockwise. The rotation should be performed in place, meaning you are not allowed to use extra matrices for performing the rotation. Implement the function `rotate_matrix(matrix: List[List[int]]) -> None` that accepts a list of N lists, each containing N integers and rotates the matrix by 90 degrees clockwise. Ensure that your function: - Handles erroneous input dimensions by raising a `ValueError` with the message: \\"The matrix must be NxN.\\" **Input:** - `matrix`: List[List[int]] - A list of N lists, each containing N integers representing an NxN matrix. **Output:** - The function does not return anything; it modifies the matrix in place. **Constraints:** - The matrix should always be a list of lists containing integers, with each list being of equal length. **Example:** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` **Please Note:** The function should modify the matrix directly and does not create or return a new matrix. Ensure to handle edge cases like a single element matrix or an empty matrix appropriately by raising the specified exception if they do not meet the NxN requirement.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: n = len(matrix) # Check if the input matrix is NxN if any(len(row) != n for row in matrix): raise ValueError(\\"The matrix must be NxN\\") # Transpose the matrix in place for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement You are assigned to implement a text-based search engine for a collection of documents. The search engine should be able to index the documents and process search queries to return a list of documents that contain all search terms. Each document is represented as a string of text, and the search queries are single words. # Requirements: 1. **Class to handle Document Indexing and Searching**: - Name: `SearchEngine` 2. **Methods**: - `add_document(doc_id: int, text: str) -> None`: Adds a document to the search engine\'s index. - `search(query: str) -> list[int]`: Returns a list of `doc_id`s where the document contains the `query` term. The list should be sorted in ascending order of `doc_id`. 3. **Constraints**: - Document texts are non-empty and contain only lower-case alphabetic characters and spaces. - Each `doc_id` is a unique integer. - Handle edge cases like queries that match no documents or addition of documents with the same `doc_id`. 4. **Example**: ```python class SearchEngine: def __init__(self): self.index = {} def add_document(self, doc_id: int, text: str) -> None: # Your implementation here pass def search(self, query: str) -> list[int]: # Your implementation here pass ``` - **Example Usage**: ```python # Initialize the search engine search_engine = SearchEngine() # Add documents search_engine.add_document(1, \\"this is a simple document\\") search_engine.add_document(2, \\"this document is a sample\\") search_engine.add_document(3, \\"another simple example\\") # Perform searches results = search_engine.search(\\"simple\\") # Expected output: [1, 3] results = search_engine.search(\\"document\\") # Expected output: [1, 2] results = search_engine.search(\\"example\\") # Expected output: [3] results = search_engine.search(\\"missing\\") # Expected output: [] ``` # Notes: - Implement an efficient indexing and search mechanism to handle potentially large collections of documents. - Consider edge cases such as adding duplicate `doc_id`s, which should overwrite the previous entry. - Thoroughly test your code to ensure it functions correctly across various edge cases and large datasets.","solution":"class SearchEngine: def __init__(self): # Initialize an empty dictionary for indexing the documents self.index = {} def add_document(self, doc_id: int, text: str) -> None: # Add or update the document specified by doc_id # Remove previous entries for this doc_id if exists for term in self.index: if doc_id in self.index[term]: self.index[term].remove(doc_id) # Split the text into words and index each word for word in set(text.split()): if word not in self.index: self.index[word] = set() self.index[word].add(doc_id) def search(self, query: str) -> list[int]: # Return the list of document ids that contain the query term if query in self.index: return sorted(list(self.index[query])) else: return []"},{"question":"**Context**: You are developing a feature for a web application that monitors user activity and identifies the peak usage hours. The application logs user activity with timestamps, and your goal is to analyze this data to find the hour of the day with the highest user activity. **Task**: Your task is to implement functions to load and preprocess the log data, count the number of activities for each hour, and identify the hour with the maximum activity. 1. Write a function `load_log_data` that reads a CSV file containing user activity logs and returns a list of timestamps. 2. Implement a `count_activities_per_hour` function to count the number of activities for each hour of the day. 3. Write a function called `find_peak_hour` that takes the hourly activity counts and identifies the hour with the highest activity. **Function Specifications**: 1. `load_log_data(file_path: str) -> list` - Reads a CSV file containing user activity logs. - Each row in the CSV file has a timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". - Returns a list of timestamps as strings. 2. `count_activities_per_hour(timestamps: list) -> dict` - Takes a list of timestamps as input. - Counts the number of activities for each hour (0 through 23). - Returns a dictionary where the keys are the hours and the values are the activity counts. 3. `find_peak_hour(activity_counts: dict) -> int` - Takes a dictionary of hourly activity counts. - Identifies the hour with the highest activity count. - Returns the hour (0 through 23) with the maximum activity. **Example**: ```python def main(): timestamps = load_log_data(\'user_activity_logs.csv\') hourly_counts = count_activities_per_hour(timestamps) peak_hour = find_peak_hour(hourly_counts) print(f\\"The peak usage hour is: {peak_hour}h\\") if __name__ == \\"__main__\\": main() ``` **Constraints**: - Assume the CSV file exists at the given file path and is formatted correctly. **Note**: - You may use the `csv` module to read the CSV file. - Handle any necessary parsing of the timestamps using the `datetime` module.","solution":"import csv from datetime import datetime def load_log_data(file_path: str) -> list: Reads a CSV file containing user activity logs and returns a list of timestamps. Each row in the CSV file has a timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". timestamps = [] with open(file_path, newline=\'\') as csvfile: reader = csv.reader(csvfile) for row in reader: timestamps.append(row[0]) return timestamps def count_activities_per_hour(timestamps: list) -> dict: Takes a list of timestamps as input. Counts the number of activities for each hour (0 through 23). Returns a dictionary where the keys are the hours and the values are the activity counts. activity_counts = {hour: 0 for hour in range(24)} for timestamp in timestamps: hour = datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\').hour activity_counts[hour] += 1 return activity_counts def find_peak_hour(activity_counts: dict) -> int: Takes a dictionary of hourly activity counts. Identifies the hour with the highest activity count. Returns the hour (0 through 23) with the maximum activity. peak_hour = max(activity_counts, key=activity_counts.get) return peak_hour"},{"question":"# Question: Calculate the Power of a Number You are required to write a function to calculate the power of a number. Given two integers `base` and `exponent`, compute ( text{base}^{text{exponent}} ). **Function Signature**: `def power(base: int, exponent: int) -> float:` **Input**: - An integer `base` where ( -100 leq text{base} leq 100 ). - An integer `exponent` where ( -100 leq text{exponent} leq 100 ). **Output**: - Return a floating-point number representing ( text{base}^{text{exponent}} ). **Constraints**: - Do not use built-in exponentiation operators (`**` or `pow`). - Handle cases where the base and exponent are negative. - Ensure the function returns precise results for fractional powers. **Example**: ```python assert power(2, 3) == 8.0 assert power(5, 0) == 1.0 assert power(-2, 3) == -8.0 assert power(4, -1) == 0.25 assert power(0, 5) == 0.0 ``` **Notes**: - Consider both iterative and recursive approaches for implementing exponentiation. - Think about how to handle negative exponents to ensure the result is a floating-point number. - Ensure the function handles edge cases like zero and one correctly. Implement your solution in the following function definition: ```python def power(base: int, exponent: int) -> float: # Your code here ```","solution":"def power(base: int, exponent: int) -> float: Computes the power of a number without using built-in exponentiation operators. # Handle base cases if exponent == 0: return 1.0 elif base == 0: if exponent > 0: return 0.0 else: raise ValueError(\\"0 cannot be raised to a negative power\\") # Handle negative exponents by computing the positive exponent and then taking the reciprocal is_negative_exponent = exponent < 0 positive_exponent = abs(exponent) result = 1.0 for _ in range(positive_exponent): result *= base if is_negative_exponent: result = 1.0 / result return result"},{"question":"# Letter Frequency Analysis Implement a function that analyzes the frequency of each letter in a given sentence and returns a dictionary where the keys are the letters and the values are their corresponding frequencies. The function should ignore case and exclude non-alphabetic characters. Function Signature: ```python def letter_frequency(sentence: str) -> dict: ``` # Requirements: 1. **Inputs**: - `sentence` (str): A string containing a sentence (e.g., \\"Hello World!\\"). 2. **Outputs**: - `frequency_dict` (dict): A dictionary where keys are lowercase letters and values are their frequency counts. # Constraints: 1. The sentence can include spaces, punctuation, and numbers, which should be ignored. 2. The function should be case-insensitive, treating \'A\' and \'a\' as the same letter. # Example: ```python sentence = \\"The quick brown fox jumps over the lazy dog!\\" print(letter_frequency(sentence)) # Output: {\'t\': 2, \'h\': 2, \'e\': 3, \'q\': 1, \'u\': 2, \'i\': 1, \'c\': 1, \'k\': 1, \'b\': 1, \'r\': 2, \'o\': 4, \'w\': 1, \'n\': 1, \'f\': 1, \'x\': 1, \'j\': 1, \'m\': 1, \'p\': 1, \'s\': 1, \'v\': 1, \'l\': 1, \'a\': 1, \'z\': 1, \'y\': 1, \'d\': 1, \'g\': 1} ``` # Implementation Details: - Initialize an empty dictionary to store the frequency of each letter. - Iterate through each character in the sentence. - Convert characters to lowercase and check if they are alphabetic. If so, update their count in the dictionary. - Return the dictionary containing the frequencies of each letter. - Handle any invalid input by ensuring input is always a string before processing.","solution":"def letter_frequency(sentence: str) -> dict: Returns a dictionary where the keys are the lowercase letters and the values are their corresponding frequency counts in the given sentence. Non-alphabetic characters are ignored. :param sentence: str: A string containing a sentence. :return: dict: A dictionary with letter frequencies. from collections import defaultdict frequency_dict = defaultdict(int) for char in sentence.lower(): if char.isalpha(): frequency_dict[char] += 1 return dict(frequency_dict)"},{"question":"# Array Rotation and Recovery Context: In data processing, it\'s sometimes necessary to rotate an array according to a given number of steps. The rotation operation shifts each element of the array to the right by one position, and the last element moves to the first position. Your task is to implement a function that performs the rotation and returns the resulting array. # Task: Implement a function `rotate_array(arr: List[int], k: int) -> List[int]` that rotates the elements of the given array `arr` by `k` steps to the right. # Input: - `arr`: A list of integers representing the array to be rotated (length <= 10^5). - `k`: An integer representing the number of steps to rotate the array (0 <= k <= 10^9). # Output: - Returns a list of integers representing the rotated array. # Constraints: - An array can be rotated by any number of steps, where `k` can be larger than the length of the array. - If `k` equals zero, the original array should be returned. - Consider large values of `k` where `k` can be much larger than the array length. # Examples: ```python # Example 1 arr = [1, 2, 3, 4, 5] k = 2 # Expected output: [4, 5, 1, 2, 3] # Example 2 arr = [0, 1, 2, 3, 4] k = 3 # Expected output: [2, 3, 4, 0, 1] # Example 3 arr = [1, 2, 3] k = 4 # Expected output: [3, 1, 2] # Example 4 arr = [7, 8, 9] k = 0 # Expected output: [7, 8, 9] # Example 5 arr = [1] k = 1000000000 # Expected output: [1] ``` # Note: Ensure the implementation efficiently handles large values of `k` by reducing unnecessary rotations.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the elements of the array arr by k steps to the right. Parameters: arr (List[int]): The array to be rotated. k (int): The number of steps to rotate the array. Returns: List[int]: The rotated array. n = len(arr) if n == 0: return arr k = k % n # Handle cases where k is greater than array length return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement: Given a string `sequence` and an integer `k`, your task is to find the length of the shortest subsequence of `sequence` that contains at least `k` distinct characters. If no such subsequence exists, return -1. # Requirements: - You are to write a function: ```python def shortest_subsequence_with_k_distinct(sequence: str, k: int) -> int: ``` - **Input** * A string `sequence` consisting only of lowercase English letters (1 ≤ len(sequence) ≤ 10,000). * An integer `k` (1 ≤ k ≤ 26). - **Output** * An integer representing the length of the shortest subsequence containing at least `k` distinct characters, or -1 if no such subsequence exists. # Example: ```python # Example 1: shortest_subsequence_with_k_distinct(\\"abcde\\", 3) # Output: 3 (the subsequence \\"abc\\" will work as it has exactly 3 distinct characters) # Example 2: shortest_subsequence_with_k_distinct(\\"aaabbbccc\\", 2) # Output: 2 (the subsequence \\"ab\\" will work as it has exactly 2 distinct characters) # Example 3: shortest_subsequence_with_k_distinct(\\"aaaaa\\", 2) # Output: -1 (no subsequence can have 2 distinct characters) ``` # Constraints: - The solution should be efficient enough to handle the upper limit of the input size.","solution":"def shortest_subsequence_with_k_distinct(sequence: str, k: int) -> int: if len(set(sequence)) < k: return -1 n = len(sequence) min_length = n + 1 for i in range(n): char_set = set() for j in range(i, n): char_set.add(sequence[j]) if len(char_set) == k: min_length = min(min_length, j - i + 1) break return min_length if min_length != n + 1 else -1"},{"question":"# Problem Statement: You are asked to develop a function to simulate a simple traffic management system for a series of traffic lights at intersections in a grid. Each intersection can have traffic lights on either a north-south (vertical) or east-west (horizontal) direction. Traffic lights can either be in a \'green\' or \'red\' state, with \'green\' allowing traffic to pass and \'red\' stopping traffic. # Requirements 1. Implement a function `calculate_green_time(input_grid: List[List[str]]) -> List[List[int]]` that calculates how many intersections can simultaneously have \'green\' lights for optimal traffic flow. 2. The input `input_grid` is a 2D grid where each cell contains either: - \'N\' for a north-south green light. - \'E\' for an east-west green light. - \'.\' for an empty intersection with no traffic light. 3. The function should count intersections that have \'green\' lights and store the count for each respective cell in an output grid. The goal is to maximize the number of intersections with \'green\' lights. Intersections are adjacent if they share a common side (up, down, left, right). # Constraints: - The grid will be a rectangular 2D grid with dimensions m x n (1 <= m, n <= 1000). - Input values are always valid and will only contain \'N\', \'E\', or \'.\'. # Steps to implement: 1. Parse the input to identify intersections with traffic lights. 2. Determine the maximum number of intersections that can have \'green\' lights simultaneously. 3. Create an output grid with the same dimensions as the input grid and store counts of \'green\' light intersections at each cell. 4. Return the resulting grid of counts. # Input: A 2D list `input_grid` representing the grid configuration. # Output: A 2D list of the same dimensions representing the counts of intersections with \'green\' lights. # Example: ```python example_input_grid = [ [\'N\', \'.\', \'E\'], [\'.\', \'N\', \'E\'], [\'N\', \'E\', \'.\'] ] result = calculate_green_time(example_input_grid) # Expected output grid: [ # [1, 0, 1], # [0, 1, 1], # [1, 1, 0] # ] ``` The output should reflect counts of simultaneous \'green\' lights optimized for traffic flow in the intersections.","solution":"def calculate_green_time(input_grid): Counts the number of green lights (either \'N\' for north-south or \'E\' for east-west) in a given input grid of traffic light intersections. rows = len(input_grid) cols = len(input_grid[0]) result_grid = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): if input_grid[i][j] == \'N\' or input_grid[i][j] == \'E\': result_grid[i][j] = 1 return result_grid"},{"question":"# Problem Statement You are tasked with writing a function that simulates a basic transaction ledger for a cryptocurrency wallet. The ledger must support basic operations such as adding transactions, retrieving the balance, and reversing a transaction by its ID. Requirements: 1. **Function Name**: `crypto_ledger` 2. **Classes and Methods**: - `class Ledger`: - `add_transaction(transaction_id, amount)`: Adds a new transaction with a specified amount (either positive for deposits or negative for withdrawals). - `get_balance()`: Returns the current balance of the wallet. - `reverse_transaction(transaction_id)`: Reverses the specified transaction by its transaction ID. 3. **Input**: - Transactions consist of a unique ID (string) and an amount (float). - Transaction IDs are unique, and reversing a transaction by an ID that doesn\'t exist or has already been reversed should be handled gracefully. 4. **Output**: - `add_transaction` does not return anything. - `get_balance` returns the current wallet balance as a float value. - `reverse_transaction` does not return anything but updates the ledger accordingly. 5. **Constraints**: - Ensure that transactions are additive and reversible. - All transaction amounts should be handled with precision up to two decimal places. - Handle edge case where reversing a non-existent or already-reversed transaction should not affect the balance. 6. **Example Usage**: ```python ledger = Ledger() ledger.add_transaction(\\"tx1\\", 100.50) ledger.add_transaction(\\"tx2\\", -20.25) ledger.add_transaction(\\"tx3\\", 300.00) print(ledger.get_balance()) # Output: 380.25 ledger.reverse_transaction(\\"tx2\\") print(ledger.get_balance()) # Output: 400.50 ledger.reverse_transaction(\\"tx4\\") # Should not affect the balance as tx4 does not exist print(ledger.get_balance()) # Output: 400.50 ``` Implement the class `Ledger` with the described methods and ensure it correctly manages the transactions and maintains the balance accurately: ```python class Ledger: def __init__(self): self.transactions = {} self.balance = 0.0 def add_transaction(self, transaction_id: str, amount: float) -> None: Adds a transaction to the ledger. if transaction_id not in self.transactions: self.transactions[transaction_id] = amount self.balance += amount def get_balance(self) -> float: Returns the current balance. return round(self.balance, 2) def reverse_transaction(self, transaction_id: str) -> None: Reverses a transaction by its ID. if transaction_id in self.transactions: self.balance -= self.transactions[transaction_id] del self.transactions[transaction_id] ```","solution":"class Ledger: def __init__(self): self.transactions = {} self.balance = 0.0 def add_transaction(self, transaction_id: str, amount: float) -> None: Adds a transaction to the ledger. if transaction_id not in self.transactions: self.transactions[transaction_id] = amount self.balance += amount def get_balance(self) -> float: Returns the current balance. return round(self.balance, 2) def reverse_transaction(self, transaction_id: str) -> None: Reverses a transaction by its ID. if transaction_id in self.transactions: self.balance -= self.transactions[transaction_id] del self.transactions[transaction_id]"},{"question":"# Question: Pascal\'s Triangle Row Calculation A Pascal\'s triangle is a triangular array of numbers where the values on the edges are always 1, and every other value is the sum of the two values directly above it. For example, the first few rows of Pascal\'s triangle look like this: ``` 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 ``` Given a non-negative index `n`, implement a function to calculate the `n`-th row of Pascal\'s triangle. Function: `pascals_triangle_row` ```python def pascals_triangle_row(n: int) -> list: Returns the n-th (0-indexed) row of Pascal\'s triangle. Args: n (int): The index of the row to generate. Must be a non-negative integer. Returns: list: A list of integers representing the n-th row of Pascal\'s triangle. Examples: >>> pascals_triangle_row(0) [1] >>> pascals_triangle_row(1) [1, 1] >>> pascals_triangle_row(2) [1, 2, 1] >>> pascals_triangle_row(3) [1, 3, 3, 1] >>> pascals_triangle_row(4) [1, 4, 6, 4, 1] >>> pascals_triangle_row(5) [1, 5, 10, 10, 5, 1] >>> pascals_triangle_row(10) [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1] pass ``` # Constraints * The function should handle non-negative integers up to `n=30` efficiently. # Requirements * Compute the row iteratively rather than generating the entire Pascal\'s triangle. * Ensure that your solution does not use excessive memory or computational resources. # Explanation * **pascals_triangle_row**: Computes and returns the specified row of Pascal\'s triangle using iterative computations. The row is represented as a list of integers. * Handles edge cases, such as `n=0`, and efficiently calculates higher index rows without generating unnecessary intermediate rows.","solution":"def pascals_triangle_row(n: int) -> list: Returns the n-th (0-indexed) row of Pascal\'s triangle. Args: n (int): The index of the row to generate. Must be a non-negative integer. Returns: list: A list of integers representing the n-th row of Pascal\'s triangle. if n == 0: return [1] row = [1] for k in range(1, n + 1): # Calculate value using combinatorial formula row.append(row[-1] * (n - k + 1) // k) return row"},{"question":"Problem Statement: You are given a non-negative integer `n`. Your task is to implement a function that returns the number of unique binary search trees (BSTs) that can be constructed with `n` nodes labeled from 1 to `n`. # Function Signature: ```python def num_trees(n: int) -> int: ``` # Input: - An integer `n` (0 ≤ n ≤ 19) # Output: - An integer representing the total number of unique BSTs that can be formed with `n` nodes. # Constraints: - The function should handle small values of `n` efficiently. - Memoization or dynamic programming techniques are encouraged to optimize the function for larger values of `n`. # Example: Example 1: Input: ```python n = 3 ``` Output: ```python 5 ``` Example 2: Input: ```python n = 1 ``` Output: ```python 1 ``` Example 3: Input: ```python n = 0 ``` Output: ```python 1 ``` # Explanation: - For `n = 3`, the possible BSTs are: - 1 as root: Trees with nodes {2, 3} as right subtree. - 2 as root: Trees with nodes {1} as left subtree and {3} as right subtree. - 3 as root: Trees with nodes {1, 2} as left subtree. - Total = 5 BSTs. - For `n = 1`, there\'s only one node, hence only one BST. - For `n = 0`, there\'s no node, so there\'s one empty BST by definition. # Notes: - This problem corresponds to the nth Catalan number in combinatorics, often used for counting problems in tree structures, and can be solved using dynamic programming.","solution":"def num_trees(n: int) -> int: Returns the number of unique BSTs that can be constructed with n nodes. # Base case if n == 0 or n == 1: return 1 # DP array to store the number of unique BSTs dp = [0] * (n + 1) dp[0] = dp[1] = 1 for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"# Sorting Mixed Datatypes You are tasked with creating a custom sorting function that can handle a list containing mixed datatypes such as integers, floats, and strings. The function should sort the list based on the following rules: 1. **Type Priority**: Sort by datatype in the order of integers, floats, and then strings. 2. **Within Type**: - Integers: Sort in ascending order. - Floats: Sort in ascending order. - Strings: Sort alphabetically, but case-insensitively. Function Specifications 1. **custom_sort(arr: list) -> list**: - **Input**: A list containing integers, floats, and strings. - **Output**: A sorted list following the specified rules. Additional Requirements - Implement the sorting logic without using any third-party sorting libraries. - Ensure the solution efficiently handles a list with a large number of elements. - Edge cases such as empty lists, lists with a single type, and varying cases in strings should be handled appropriately. # Example ```python # Expected usage example: # Mixed list with integers, floats, and strings mixed_list = [42, \\"apple\\", 3.14, \\"Banana\\", 20, \\"cherry\\", 2.718, \\"APPLE\\"] # Sort the mixed list sorted_list = custom_sort(mixed_list) print(sorted_list) # Output should be: [20, 42, 2.718, 3.14, \'APPLE\', \'apple\', \'Banana\', \'cherry\'] ``` # Constraints - You may assume the list will contain at least one element. - Integers, floats, and strings are the only types that will be present in the list. - Solution should be written in clean, readable, and well-documented code. ```python # Function template for reference: def custom_sort(arr: list) -> list: # Separate the list into three different lists for each type: integers, floats, and strings int_part = [x for x in arr if isinstance(x, int)] float_part = [x for x in arr if isinstance(x, float)] str_part = [x for x in arr if isinstance(x, str)] # Sort each part individually int_part.sort() float_part.sort() str_part.sort(key=lambda s: s.lower()) # Concatenate the sorted lists in the required order return int_part + float_part + str_part ```","solution":"def custom_sort(arr: list) -> list: Sort a list containing integers, floats, and strings by: 1. Integers in ascending order. 2. Floats in ascending order. 3. Strings alphabetically (case-insensitively). # Separate the list into three different lists for each type: integers, floats, and strings int_part = [x for x in arr if isinstance(x, int)] float_part = [x for x in arr if isinstance(x, float)] str_part = [x for x in arr if isinstance(x, str)] # Sort each part individually int_part.sort() float_part.sort() str_part.sort(key=lambda s: s.lower()) # Concatenate the sorted lists in the required order return int_part + float_part + str_part"},{"question":"# Coding Question Scenario You are working on an automated system to manage banking transactions and ensure they are processed in a specific sequential order based on their input time. You have decided to use a queue structure to manage these transactions. Implement a system that processes transactions in the order they are added to the queue and maintains a log of processed transactions. Requirements Implement a class `TransactionQueue` that uses a queue to handle a sequence of transactions. Each transaction will be represented as a string. The class should support adding a transaction, processing the next transaction in the queue, and retrieving the history of all processed transactions. Class Definition ```python class TransactionQueue: def __init__(self): # Initializes the queue and the processed history pass def add_transaction(self, transaction: str) -> None: # Adds a transaction to the queue pass def process_next_transaction(self) -> str: # Processes the next transaction in the queue and returns it pass def get_processed_history(self) -> list[str]: # Returns a list of all processed transactions pass ``` Methods 1. `add_transaction(self, transaction: str) -> None`: Adds a transaction to the queue. 2. `process_next_transaction(self) -> str`: Removes and returns the next transaction from the queue and stores it in the history of processed transactions. If the queue is empty, it should return `None`. 3. `get_processed_history(self) -> list[str]`: Returns a list of all processed transactions in the order they were processed. Example ```python queue = TransactionQueue() queue.add_transaction(\'Deposit 100\') queue.add_transaction(\'Withdraw 50\') print(queue.process_next_transaction()) # Output: \'Deposit 100\' print(queue.get_processed_history()) # Output: [\'Deposit 100\'] print(queue.process_next_transaction()) # Output: \'Withdraw 50\' print(queue.get_processed_history()) # Output: [\'Deposit 100\', \'Withdraw 50\'] print(queue.process_next_transaction()) # Output: None print(queue.get_processed_history()) # Output: [\'Deposit 100\', \'Withdraw 50\'] ``` Constraints 1. Each transaction is a non-empty string. 2. The number of transactions added to the queue will not exceed 1000. Edge Cases 1. The queue is empty and a `process_next_transaction` call is made. 2. Transactions with identical strings are added to the queue. This class should enable the automated system to manage and process banking transactions in a predictable and orderly manner.","solution":"from collections import deque class TransactionQueue: def __init__(self): # Initializes the queue and the processed history self.queue = deque() self.processed_history = [] def add_transaction(self, transaction: str) -> None: # Adds a transaction to the queue self.queue.append(transaction) def process_next_transaction(self) -> str: # Processes the next transaction in the queue and returns it if self.queue: transaction = self.queue.popleft() self.processed_history.append(transaction) return transaction return None def get_processed_history(self) -> list[str]: # Returns a list of all processed transactions return self.processed_history"},{"question":"# Order Statistics for Randomized Data # You are given a class that helps maintain an array of unique integers and supports randomized quickselect operations to find the k-th smallest element. Task: Extend this class to add the following functionalities: 1. A method `find_kth_largest(k)` to find the k-th largest element in the array. 2. An iterator method `elements_on_rank(rank)` that yields all elements that would appear at the given rank in sorted order when dealing with ties. # Inputs and Outputs: **Method 1: find_kth_largest(k)** - **Input:** k: Integer, the rank of the largest element to find (1-based index) - **Output:** Integer, the k-th largest element in the array **Method 2: elements_on_rank(rank)** - **Input:** rank: Integer, the rank of the elements to find (1-based index) - **Output:** Yields integers as they appear at the given rank # Examples: 1. For `find_kth_largest(k)`: ```python array = [3, 2, 1, 5, 4] os = OrderStatistics(array) print(os.find_kth_largest(2)) ``` **Output:** ``` 4 # The 2nd largest element is 4 ``` 2. For `elements_on_rank(rank)`: ```python array = [4, 1, 4, 3, 2] os = OrderStatistics(array) results = list(os.elements_on_rank(2)) print(results) ``` **Output:** ``` [2] # The elements at rank 2 are: [2] ``` # Constraints: - The array length will be in the range [1, 10^4]. - Array elements will be unique integers. - k and rank will be valid integers within the bounds of the array. # Implementation: ```python import random class OrderStatistics: def __init__(self, array: list[int]) -> None: self.array = array def quickselect(self, left: int, right: int, k: int) -> int: if left == right: return self.array[left] pivot_index = random.randint(left, right) pivot_index = self.partition(left, right, pivot_index) if k == pivot_index: return self.array[k] elif k < pivot_index: return self.quickselect(left, pivot_index - 1, k) else: return self.quickselect(pivot_index + 1, right, k) def partition(self, left: int, right: int, pivot_index: int) -> int: pivot_value = self.array[pivot_index] self.array[pivot_index], self.array[right] = self.array[right], self.array[pivot_index] store_index = left for i in range(left, right): if self.array[i] < pivot_value: self.array[store_index], self.array[i] = self.array[i], self.array[store_index] store_index += 1 self.array[right], self.array[store_index] = self.array[store_index], self.array[right] return store_index def find_kth_largest(self, k: int) -> int: Returns the k-th largest element in the array. size = len(self.array) return self.quickselect(0, size - 1, size - k) def elements_on_rank(self, rank: int): Yields all elements at the given rank in sorted order sorted_array = sorted(self.array) for elem in sorted_array: if sorted_array.index(elem) == rank - 1: yield elem ``` This new question requires the interviewee to expand on the class `OrderStatistics` by implementing methods that find the k-th largest element and produce elements on a specified rank, aligning with the complexity and scope of dealing with arrays and algorithmic thinking.","solution":"import random class OrderStatistics: def __init__(self, array: list[int]) -> None: self.array = array def quickselect(self, left: int, right: int, k: int) -> int: if left == right: return self.array[left] pivot_index = random.randint(left, right) pivot_index = self.partition(left, right, pivot_index) if k == pivot_index: return self.array[k] elif k < pivot_index: return self.quickselect(left, pivot_index - 1, k) else: return self.quickselect(pivot_index + 1, right, k) def partition(self, left: int, right: int, pivot_index: int) -> int: pivot_value = self.array[pivot_index] self.array[pivot_index], self.array[right] = self.array[right], self.array[pivot_index] store_index = left for i in range(left, right): if self.array[i] < pivot_value: self.array[store_index], self.array[i] = self.array[i], self.array[store_index] store_index += 1 self.array[right], self.array[store_index] = self.array[store_index], self.array[right] return store_index def find_kth_largest(self, k: int) -> int: Returns the k-th largest element in the array. size = len(self.array) return self.quickselect(0, size - 1, size - k) def elements_on_rank(self, rank: int): Yields all elements at the given rank in sorted order sorted_array = sorted(self.array) target_value = sorted_array[rank - 1] yield target_value"},{"question":"# Unique Anagrams by Length You are asked to write a function that generates a list of unique anagrams from a given string and organizes them by the lengths of the anagram subsets. Function Signature ```python def unique_anagrams_by_length(s: str) -> Dict[int, List[str]]: pass ``` Objective Write a function `unique_anagrams_by_length` that takes a string `s` and returns a dictionary where the keys are the lengths of the unique anagram subsets and the values are lists of anagrams of that length. Input * `s` (str): Input string (1 <= len(s) <= 10). Output * Dictionary: Keys are integers representing lengths of anagram subsets, values are lists of unique anagrams of that length. Constraints * Each anagram list should be unique and contain only valid anagrams. * Return the anagrams sorted in lexicographical order. Examples ```python assert unique_anagrams_by_length(\\"abc\\") == { 1: [\'a\', \'b\', \'c\'], 2: [\'ab\', \'ac\', \'bc\'], 3: [\'abc\'] } assert unique_anagrams_by_length(\\"aabb\\") == { 1: [\'a\', \'b\'], 2: [\'aa\', \'ab\', \'bb\'], 3: [\'aab\', \'abb\'], 4: [\'aabb\'] } assert unique_anagrams_by_length(\\"bo\\") == { 1: [\'b\', \'o\'], 2: [\'bo\'] } ``` Notes: * An anagram is defined as a rearrangement of the letters of another word to form a new word. * The function should handle duplicate letters appropriately. * The order within each list and the dictionary keys do not matter, but the lists themselves should be sorted. Good luck!","solution":"from itertools import permutations from collections import defaultdict from typing import Dict, List def unique_anagrams_by_length(s: str) -> Dict[int, List[str]]: result = defaultdict(set) # Generate all substrings for all possible lengths for length in range(1, len(s) + 1): substrings = set(\'\'.join(p) for p in permutations(s, length)) result[length].update(substrings) # Sort and convert to list for key in result: result[key] = sorted(result[key]) return result"},{"question":"# Coding Assessment Question Scenario You are developing a scheduling application that needs to handle recurring events. The application should generate a list of dates when specific recurring events will occur within a given time range. Each event can recur daily, weekly, or monthly. Task Implement a function that generates a list of dates for recurring events based on the recurrence pattern (daily, weekly, monthly), start date, end date, and interval. The recurrence should account for different intervals such as every 2 days, every 3 weeks, or every month. Function Signature ```python from typing import List from datetime import date def generate_recurring_dates(start: date, end: date, pattern: str, interval: int) -> List[date]: Generate a list of dates for recurring events. :param start: The start date of the recurrence. :param end: The end date of the recurrence. :param pattern: The recurrence pattern (\\"daily\\", \\"weekly\\", \\"monthly\\"). :param interval: The interval between recurrences. :return: List of dates when the event occurs. ``` Inputs and Outputs * **Input Format**: * `start`: A date object representing the start date of the recurrence. * `end`: A date object representing the end date of the recurrence. * `pattern`: A string specifying the recurrence pattern (\\"daily\\", \\"weekly\\", \\"monthly\\"). * `interval`: An integer specifying the interval between recurrences. * **Output Format**: * The function should return a list of date objects representing the dates when the event occurs. Constraints * The `start` date is always less than or equal to the `end` date. * The `interval` is always a positive integer. * The `pattern` is always one of \\"daily\\", \\"weekly\\", or \\"monthly\\". Performance Requirements * Handle date ranges up to 10 years efficiently. Example ```python # Example usage of the function from datetime import date dates = generate_recurring_dates(date(2023, 1, 1), date(2023, 1, 10), \\"daily\\", 2) # Expected output: [date(2023, 1, 1), date(2023, 1, 3), date(2023, 1, 5), date(2023, 1, 7), date(2023, 1, 9)] dates = generate_recurring_dates(date(2023, 1, 1), date(2023, 3, 1), \\"weekly\\", 1) # Expected output: [date(2023, 1, 1), date(2023, 1, 8), date(2023, 1, 15), date(2023, 1, 22), date(2023, 1, 29), date(2023, 2, 5), date(2023, 2, 12), date(2023, 2, 19), date(2023, 2, 26)] dates = generate_recurring_dates(date(2023, 1, 1), date(2023, 12, 1), \\"monthly\\", 2) # Expected output: [date(2023, 1, 1), date(2023, 3, 1), date(2023, 5, 1), date(2023, 7, 1), date(2023, 9, 1), date(2023, 11, 1)] ``` Evaluation Criteria: 1. Correctness: The function should correctly generate the list of dates based on the given recurrence pattern and interval. 2. Efficiency: The function should handle large date ranges efficiently without excessive computation time. 3. Code Quality: Code should be clean, well-commented, and follow good practices.","solution":"from typing import List from datetime import date, timedelta def generate_recurring_dates(start: date, end: date, pattern: str, interval: int) -> List[date]: Generate a list of dates for recurring events. :param start: The start date of the recurrence. :param end: The end date of the recurrence. :param pattern: The recurrence pattern (\\"daily\\", \\"weekly\\", \\"monthly\\"). :param interval: The interval between recurrences. :return: List of dates when the event occurs. dates = [] current_date = start while current_date <= end: dates.append(current_date) if pattern == \\"daily\\": current_date += timedelta(days=interval) elif pattern == \\"weekly\\": current_date += timedelta(weeks=interval) elif pattern == \\"monthly\\": month = current_date.month - 1 + interval year = current_date.year + month // 12 month = month % 12 + 1 day = min(current_date.day, [31, 29 if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1]) current_date = date(year, month, day) else: raise ValueError(\\"Invalid pattern. Should be \'daily\', \'weekly\', or \'monthly\'.\\") return dates"},{"question":"**Largest Anagram Group** **Context:** You\'re building a tool to help users find relationships between words based on their anagrams. The core task involves sorting groups of words such that each group contains only words that are anagrams of each other. **Task:** Implement a function `largest_anagram_group(words: list) -> list` that finds the largest group of anagrams in a given list of words. An anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once. **Input:** - `words`: A list of strings, where each string only contains lowercase English letters. **Output:** - Returns a list of strings representing the largest group of anagrams. If there are multiple groups of the same size, return the one that appears first in the input list. **Constraints:** - `0 <= len(words) <= 1000` - Each word consists of lowercase English letters only. - All words are of lengths between `1` and `100`. **Examples:** ```python >>> largest_anagram_group([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [\\"eat\\", \\"tea\\", \\"ate\\"] >>> largest_anagram_group([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"yxz\\", \\"zxy\\", \\"bac\\"]) [\\"abc\\", \\"bca\\", \\"cab\\"] >>> largest_anagram_group([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"goolge\\"]) [\\"listen\\", \\"silent\\", \\"enlist\\"] ``` **Instructions:** 1. Implement the `largest_anagram_group` function in Python. 2. Group the words by their anagrams and identify the group with the maximum words. 3. To determine if two words are anagrams, sort the letters of each word and compare them. 4. If there are multiple groups with the same size, return the group that appears first based on the input list\'s order.","solution":"def largest_anagram_group(words): from collections import defaultdict # Dictionary to hold anagram groups anagrams = defaultdict(list) # Group words by their sorted tuple of characters for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) # Find the largest group of anagrams largest_group = [] for group in anagrams.values(): if len(group) > len(largest_group): largest_group = group return largest_group"},{"question":"# Coding Assessment Question Context You are working as a data scientist responsible for analyzing and processing text data for sentiment analysis. As a preliminary step, you need to clean and preprocess the text data to ensure it is in a suitable format for analysis. One common preprocessing step is to remove stop words (common words that do not contribute meaningful information) from the text data. Task You are asked to implement a function called **remove_stop_words** that takes a list of sentences and a list of stop words, and returns a list of sentences with all the stop words removed. # Input and Output Specifications * **Function Signature:** ```python def remove_stop_words(sentences: List[str], stop_words: List[str]) -> List[str]: ``` * **Input:** - `sentences`: A list of strings, where each string is a sentence. - `stop_words`: A list of strings, where each string is a common stop word to be removed from the sentences. * **Output:** - The function must return a list of strings, where each string is a sentence with all stop words removed. # Example *Given the following sentences and stop words:* ```python sentences = [\\"This is a test sentence\\", \\"Remove the stop words from this list\\"] stop_words = [\\"is\\", \\"a\\", \\"the\\", \\"from\\", \\"this\\"] cleaned_sentences = remove_stop_words(sentences, stop_words) print(cleaned_sentences) ``` *Expected Output:* ``` [\'This test sentence\', \'Remove stop words list\'] ``` # Constraints 1. Sentences are case-sensitive, meaning \\"This\\" and \\"this\\" are considered different words. 2. Stop words are also case-sensitive and should match exactly as they appear in the sentences. 3. Words in the sentences are separated by single spaces. # Hint - Consider using string manipulation techniques and list comprehensions to remove the stop words efficiently.","solution":"from typing import List def remove_stop_words(sentences: List[str], stop_words: List[str]) -> List[str]: Remove stop words from a list of sentences. Parameters: sentences (List[str]): A list of sentences. stop_words (List[str]): A list of stop words to be removed from the sentences. Returns: List[str]: A list of sentences with the stop words removed. stop_words_set = set(stop_words) cleaned_sentences = [] for sentence in sentences: words = sentence.split() filtered_words = [word for word in words if word not in stop_words_set] cleaned_sentences.append(\\" \\".join(filtered_words)) return cleaned_sentences"},{"question":"# Stock Ticker Data Analysis You need to analyze historical stock data for multiple companies and compute annual report information. Your task is to write a function that processes this data to return summary statistics for specified companies. Specifically, you need to: 1. Read a CSV file containing historical stock prices. Each row in the CSV comprises: - Date (string in `YYYY-MM-DD` format) - Company Ticker (string) - Opening Price (float) - Closing Price (float) 2. For each company, compute the following annual statistics: - Yearly Returns: Percentage change from the first close of the year to the last close of the year. Input - A string `file_path` representing the file path to the CSV containing the historical stock prices. - A list of strings `tickers` that specifies the company tickers you need to analyze. Output - A dictionary where keys are ticker symbols and values are dictionaries. Each dictionary contains: - `yearly_returns` (dictionary): Keys are years and values are percentages (floats). Constraints - The CSV file is guaranteed to have data for at least one complete calendar year for each ticker. - Consider the CSV file to be moderately large. - You may use the `csv` library for reading the CSV file. - Handle cases where stock data for a ticker might be missing for a few days. Performance Requirements - Efficiently handle the parsing and computation even for large datasets. - Implement necessary error handling for file reading issues and data inconsistencies. Example ```plaintext date,company_ticker,open,close 2022-01-03,AAPL,175.25,176.22 2022-01-04,AAPL,177.83,174.92 2022-01-05,AAPL,179.61,179.38 2022-01-03,GOOGL,2915.35,2933.40 2022-01-04,GOOGL,2937.00,2891.35 2022-01-05,GOOGL,2895.12,2882.00 ... tickers = [\\"AAPL\\", \\"GOOGL\\"] ``` ```python import csv from datetime import datetime from collections import defaultdict def analyze_stock_data(file_path: str, tickers: list) -> dict: stock_data = defaultdict(lambda: defaultdict(list)) # Read CSV file and aggregate data with open(file_path, newline=\'\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: date = datetime.strptime(row[\'date\'], \'%Y-%m-%d\') year = date.year ticker = row[\'company_ticker\'] if ticker in tickers: open_price = float(row[\'open\']) close_price = float(row[\'close\']) stock_data[ticker][year].append((open_price, close_price)) results = {} for ticker in tickers: yearly_data = stock_data[ticker] yearly_returns = {} for year, prices in yearly_data.items(): if prices: # Ensure there are prices available for the year start_close = prices[0][1] end_close = prices[-1][1] yearly_return = ((end_close - start_close) / start_close) * 100 yearly_returns[year] = yearly_return results[ticker] = {\\"yearly_returns\\": yearly_returns} return results # Example usage file_path = \\"historical_stock_data.csv\\" tickers = [\\"AAPL\\", \\"GOOGL\\"] stock_analysis = analyze_stock_data(file_path, tickers) print(stock_analysis) ``` Note Ensure the calculation of yearly returns is accurate, considering possible gaps within the daily stock data for particular years. The output dictionary should provide clear and correctly formatted summary statistics for each specified ticker.","solution":"import csv from datetime import datetime from collections import defaultdict def analyze_stock_data(file_path: str, tickers: list) -> dict: stock_data = defaultdict(lambda: defaultdict(list)) # Read CSV file and aggregate data with open(file_path, newline=\'\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: try: date = datetime.strptime(row[\'date\'], \'%Y-%m-%d\') year = date.year ticker = row[\'company_ticker\'] if ticker in tickers: open_price = float(row[\'open\']) close_price = float(row[\'close\']) stock_data[ticker][year].append((open_price, close_price)) except (ValueError, KeyError) as e: print(f\\"Skipping row due to error: {e}, row: {row}\\") results = {} for ticker in tickers: yearly_data = stock_data[ticker] yearly_returns = {} for year, prices in sorted(yearly_data.items()): if prices: # Ensure there are prices available for the year start_close = prices[0][1] end_close = prices[-1][1] yearly_return = ((end_close - start_close) / start_close) * 100 yearly_returns[year] = yearly_return results[ticker] = {\\"yearly_returns\\": yearly_returns} return results"},{"question":"# Problem Statement You are given a list of integers representing the time intervals at which different tasks start, measured in minutes from the beginning of a day (00:00). Each task is represented as an interval `[start, end)`, meaning that it starts at `start` minutes and continues until `end` minutes, but does not include `end` itself. Your task is to find the maximum number of non-overlapping tasks that can be scheduled. # Function Signature ```python def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: ``` # Input A list of tuples `tasks`: * Each tuple `(start, end)` denotes a task interval such that `0 ≤ start < end ≤ 1440` (where 1440 is the number of minutes in a day). # Output * Return an integer representing the maximum number of non-overlapping tasks that can be scheduled. # Example ```python assert max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6)]) == 2 assert max_non_overlapping_tasks([(0, 2), (1, 3), (3, 5)]) == 2 assert max_non_overlapping_tasks([(10, 20), (15, 25), (20, 30)]) == 2 ``` # Constraints * The solution should be efficient in terms of time complexity. * Consider constraints where tasks have minimal to numerous overlaps. # Note You can use greedy algorithms like sorting tasks by their end time and selecting the earliest finishing tasks to maximize non-overlapping count. # Hints * Think about sorting the tasks based on their end times. * Use a loop to iterate through the sorted tasks and keep track of the end time of the last selected task.","solution":"from typing import List, Tuple def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled. Arguments: tasks -- list of tuples, where each tuple (start, end) represents a task interval. Returns: An integer representing the maximum number of non-overlapping tasks. # Sort the tasks based on their end time tasks.sort(key=lambda x: x[1]) # Initialize the end time of the last selected task to the minimum possible value last_end_time = -1 count = 0 for start, end in tasks: if start >= last_end_time: last_end_time = end count += 1 return count"},{"question":"# Problem Statement You are tasked with finding the smallest prime factor of each number in a given list of positive integers. A prime factor of a number is a prime number that divides the number exactly, without leaving a remainder. Write a function `smallest_prime_factors(numbers: List[int]) -> List[int]` that returns a list of the smallest prime factors for each of the integers in the input list `numbers`. # Input - `numbers` (List[int]): A list of positive integers. Constraints: ( 1 leq text{len(numbers)} leq 10^4 ) and ( 1 leq text{numbers[i]} leq 10^6 ). # Output - (List[int]): A list of integers where each element corresponds to the smallest prime factor of the respective integer in the input list. # Constraints - The function should handle computation efficiently, even for the upper bounds of input size. - Ensure that the handling of large numbers and composed operations does not result in excessive execution time. # Example ```python assert smallest_prime_factors([10, 15, 21, 29, 77]) == [2, 3, 3, 29, 7] ``` # Performance Expectations - The function should be optimized using techniques such as the Sieve of Eratosthenes to precompute prime factors for efficient lookup. - Time complexity should ideally be linear or near-linear with respect to the size of the input list and the maximum value within the list. # Implementation Guidelines - Precompute the smallest prime factor for every number up to the maximum number in the input list using a modified Sieve of Eratosthenes. - Use the precomputed values to determine the smallest prime factor for each number in the input list. - Ensure the solution is both time and space efficient, managing memory usage carefully. Here\'s an example of using Sieve of Eratosthenes: ```python def smallest_prime_factors(numbers: List[int]) -> List[int]: max_num = max(numbers) spf = list(range(max_num + 1)) # Smallest Prime Factor array for i in range(2, int(max_num**0.5) + 1): if spf[i] == i: # i is a prime number for j in range(i * i, max_num + 1, i): if spf[j] == j: spf[j] = i # Update the smallest prime factor for j result = [spf[num] for num in numbers] return result # Example usage assert smallest_prime_factors([10, 15, 21, 29, 77]) == [2, 3, 3, 29, 7] ```","solution":"from typing import List def smallest_prime_factors(numbers: List[int]) -> List[int]: Returns the smallest prime factor for each number in the input list. if not numbers: return [] max_num = max(numbers) spf = list(range(max_num + 1)) # Smallest Prime Factor array for i in range(2, int(max_num**0.5) + 1): if spf[i] == i: # i is a prime number for j in range(i * i, max_num + 1, i): if spf[j] == j: spf[j] = i # Update the smallest prime factor for j result = [spf[num] for num in numbers] return result"},{"question":"# Fibonacci-Like Numbers Calculation Context A Fibonacci-like sequence is defined as a sequence where each number is the sum of the two preceding ones, usually starting with two arbitrary numbers. For example, the sequence starting with 3 and 5 would be [3, 5, 8, 13, 21, ...]. Task Given two integers a and b, and an integer n, implement a function `fibonacci_like(a, b, n)` that returns the first n numbers of the Fibonacci-like sequence starting with a and b. ```python def fibonacci_like(a: int, b: int, n: int) -> list: Given two initial integers `a` and `b`, and a positive integer `n`, return the first `n` numbers of the Fibonacci-like sequence starting with `a` and `b`. :param a: The first number of the sequence :type a: int :param b: The second number of the sequence :type b: int :param n: The number of elements to generate in the sequence :type n: int :return: A list of the first `n` Fibonacci-like numbers, starting with `a` and `b` :rtype: list Examples: >>> fibonacci_like(3, 5, 5) [3, 5, 8, 13, 21] >>> fibonacci_like(1, 1, 6) [1, 1, 2, 3, 5, 8] >>> fibonacci_like(2, 7, 4) [2, 7, 9, 16] pass ``` Constraints - (-10^6 leq a, b leq 10^6) - (1 leq n leq 10^4) Requirements - Ensure the function handles edge cases where `n` is very small or very large within the given constraints. - Optimize the function for both time and space efficiency where applicable.","solution":"def fibonacci_like(a: int, b: int, n: int) -> list: Given two initial integers `a` and `b`, and a positive integer `n`, return the first `n` numbers of the Fibonacci-like sequence starting with `a` and `b`. :param a: The first number of the sequence :type a: int :param b: The second number of the sequence :type b: int :param n: The number of elements to generate in the sequence :type n: int :return: A list of the first `n` Fibonacci-like numbers, starting with `a` and `b` :rtype: list Examples: >>> fibonacci_like(3, 5, 5) [3, 5, 8, 13, 21] >>> fibonacci_like(1, 1, 6) [1, 1, 2, 3, 5, 8] >>> fibonacci_like(2, 7, 4) [2, 7, 9, 16] # Initialize the sequence with the first two numbers a and b sequence = [a, b] # Generate the rest of the sequence up to n elements for _ in range(2, n): next_number = sequence[-1] + sequence[-2] sequence.append(next_number) return sequence[:n]"},{"question":"Scenario To practice implementing and optimizing tree-based algorithms, you will develop a function to evaluate the maximum sum of node values from the root to any leaf in a binary tree. This problem is crucial in understanding traversal techniques and dynamic programming. # Problem Statement Write a function `max_root_to_leaf_sum(root)` that takes the root of a binary tree and returns the maximum sum of the values from the root to any leaf node. # Input * `root`: The root node of a binary tree where each node contains an integer value. # Output * Return the maximum sum from the root to any leaf node. # Constraints * The number of nodes in the tree is between 1 and 10^4. * The value of each node is between -10^3 and 10^3. # Performance Requirements Your solution must run in O(n) time complexity, where n is the number of nodes in the tree. # Example Consider the following binary tree: ``` 10 / 2 10 / 20 1 25 / 3 4 ``` The maximum sum from the root to a leaf node is 10 + 10 + 25 + 4 = 49. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_root_to_leaf_sum(root): # Implement your function here # Example usage: root = TreeNode(10) root.left = TreeNode(2) root.right = TreeNode(10) root.left.left = TreeNode(20) root.left.right = TreeNode(1) root.right.right = TreeNode(25) root.right.right.left = TreeNode(3) root.right.right.right = TreeNode(4) print(max_root_to_leaf_sum(root)) # Output should be 49 ``` # Notes 1. A leaf node is a node with no children. 2. Use depth-first search (DFS) or another tree traversal technique to solve the problem efficiently. 3. Implement necessary helper functions to support your main function if needed. By evaluating the maximum path sums, this question tests your knowledge in tree traversals and dynamic programming.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_root_to_leaf_sum(root): Returns the maximum sum from the root to any leaf node in the binary tree. if not root: return 0 def max_sum_from_node(node): if not node: return 0 if not node.left and not node.right: return node.val left_sum = max_sum_from_node(node.left) right_sum = max_sum_from_node(node.right) return node.val + max(left_sum, right_sum) return max_sum_from_node(root)"},{"question":"# Question: Reverse a Sublist in a Linked List You are required to implement a function that reverses a sublist within a singly linked list. The function should take the head of the linked list and the positions `left` and `right` that define the boundaries of the sublist to be reversed. Positions are 1-based and inclusive. Write a function `reverse_sublist(head: ListNode, left: int, right: int) -> ListNode` that reverses the nodes from position `left` to position `right` and returns the head of the modified linked list. **Function Signature:** ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_sublist(head: ListNode, left: int, right: int) -> ListNode: pass ``` **Input:** - `head` (ListNode): The head of the linked list. - `left` (int): An integer representing the starting position of the sublist (1 ≤ left ≤ right ≤ n, where n is the length of the list). - `right` (int): An integer representing the ending position of the sublist. **Output:** - A ListNode representing the head of the linked list after the sublist has been reversed. **Constraints:** - The inputs will always satisfy the constraints (1 ≤ left ≤ right ≤ n, where n is the length of the list). **Examples:** ```python # Example 1 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) left, right = 2, 4 new_head = reverse_sublist(head, left, right) # The new list should be 1 -> 4 -> 3 -> 2 -> 5 # Example 2 head = ListNode(1, ListNode(2, ListNode(3))) left, right = 1, 3 new_head = reverse_sublist(head, left, right) # The new list should be 3 -> 2 -> 1 ``` **Explanation:** - For the first example, reversing the sublist from position 2 to 4 results in the linked list 1->4->3->2->5. - For the second example, reversing the entire list results in the linked list 3->2->1. Write a function implementing this logic by considering the proper handling of edge cases, performance, and correctness.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_sublist(head: ListNode, left: int, right: int) -> ListNode: if not head or left == right: return head dummy = ListNode(0) dummy.next = head prev = dummy for _ in range(left - 1): prev = prev.next curr = prev.next next = None for _ in range(right - left): next = curr.next curr.next = next.next next.next = prev.next prev.next = next return dummy.next def linked_list_to_list(head: ListNode) -> list: result = [] while head: result.append(head.val) head = head.next return result def list_to_linked_list(lst: list) -> ListNode: dummy = ListNode() current = dummy for value in lst: current.next = ListNode(value) current = current.next return dummy.next"},{"question":"# Coding Challenge: Find the Smallest Distinct-Positive Product Problem Statement You are given a list of positive integers. Your task is to find the smallest positive product of two distinct elements in the list. Functional Requirements: Write a function `smallest_distinct_positive_product(arr: List[int]) -> int` that: - Returns the smallest positive product of two distinct integers from the input list. # Input: - `arr` (List[int]): A list of positive integers, with a length between 2 and 1000. # Output: - Returns an integer which is the smallest product of two distinct integers from the list. # Constraints: - The input list will contain at least two positive integers. - All integers in the list are positive and within the range 1 to 10^6. # Performance: - Optimize to minimize the computational complexity. - Consider the limitations on time and memory for large lists. Example: ```python assert smallest_distinct_positive_product([5, 7, 10, 2]) == 10 assert smallest_distinct_positive_product([1, 3, 4, 6]) == 3 assert smallest_distinct_positive_product([100, 120, 130, 95]) == 9500 ``` In the first example, the smallest product is 10 (from 2 and 5). In the second example, the smallest product is 3 (from 1 and 3). In the third example, the smallest product is 9500 (from 100 and 95). Guidelines: - Iterate over the list to find the smallest and second smallest numbers. - Compute their product and return it as the result. - Consider edge cases where the smallest number appears more than once in the list. Below is an example of how you might implement this in Python: ```python from typing import List def smallest_distinct_positive_product(arr: List[int]) -> int: if len(arr) < 2: raise ValueError(\\"Array must contain at least two elements.\\") min1, min2 = float(\'inf\'), float(\'inf\') for num in arr: if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return min1 * min2 ``` Reflect on the provided examples and their corresponding returns when determining your implementation.","solution":"from typing import List def smallest_distinct_positive_product(arr: List[int]) -> int: if len(arr) < 2: raise ValueError(\\"Array must contain at least two elements.\\") # Initialize the two smallest numbers to the highest possible number min1, min2 = float(\'inf\'), float(\'inf\') for num in arr: if num < min1: # Update both min1 and min2 min2 = min1 min1 = num elif num < min2: # Update only min2 min2 = num return min1 * min2"},{"question":"# IP Address Validator Problem Statement Given a string, determine if it is a valid IP address. An IP address (IPv4) consists of four numbers (0-255) separated by periods. Task Write a function `validate_ip_address(ip: str) -> bool` that takes a string representing the IP address and returns `True` if the IP address is a valid IP address according to IPv4 format, otherwise `False`. Input - `ip`: A string representing the IP address to be validated. Output - `True` if the IP address is valid; otherwise, `False`. Examples ```python validate_ip_address(\\"192.168.0.1\\") # True validate_ip_address(\\"255.255.255.255\\") # True validate_ip_address(\\"256.100.100.100\\") # False validate_ip_address(\\"192.168.01.1\\") # False validate_ip_address(\\"192.168.0\\") # False validate_ip_address(\\"192.168.0.1.1\\") # False validate_ip_address(\\"abc.def.ghi.jkl\\") # False ``` Constraints 1. The string `ip` will be non-empty and contain only printable ASCII characters. 2. The length of the string `ip` will be at most 100 characters. 3. The string will strictly be in the format of digits and periods. Notes - Pay attention to the range of valid integers (0-255) for each section. - Ensure no leading zeros in each section unless the section itself is \'0\'. - Validate exactly four integer segments separated by periods. - Consider edge cases with different invalid formats mentioned in the examples.","solution":"def validate_ip_address(ip: str) -> bool: Validate if the given string is a valid IPv4 address. :param ip: A string representing the IP address to be validated. :return: True if the IP address is valid; otherwise, False. # Split the IP address by periods parts = ip.split(\'.\') # There should be exactly 4 parts if len(parts) != 4: return False for part in parts: # Part should be a number if not part.isdigit(): return False # Convert part to integer num = int(part) # Validate range if num < 0 or num > 255: return False # Validate no leading zeros, e.g., \\"01\\" if str(num) != part: return False return True"},{"question":"# Scenario: You are developing a scheduling system for a hospital, where various appointments must be organized and managed efficiently. Each appointment is characterized by a start time and an end time, and no two appointments can overlap. Your task is to implement an algorithm to determine the maximum number of non-overlapping appointments that can be accommodated. # Task: Write a function `max_non_overlapping_appointments` that takes a list of appointments, where each appointment is a tuple containing the start and end times. # Input Format: - A list of appointments, where each appointment is represented as a tuple (start, end). - Each `start` and `end` is an integer representing the time in hours (0 to 23). # Output Format: - Return an integer representing the maximum number of non-overlapping appointments that can be scheduled. # Constraints: - Ensure efficient processing of the appointments given typical length constraints of hospital schedules. - The list of appointments will contain between 1 and 1000 elements. # Example: ```python appointments = [(1, 3), (2, 5), (3, 4), (6, 8), (7, 9)] # Expected Output: # 3 # Explanation: The maximum number of non-overlapping appointments that can be scheduled is 3: (1, 3), (3, 4), and (6, 8). ``` # Implementation: Implement the `max_non_overlapping_appointments` function using a greedy algorithm approach for efficiency. ```python def max_non_overlapping_appointments(appointments): # Sort appointments based on their end times appointments.sort(key=lambda x: x[1]) max_appointments = 0 last_end_time = 0 for start, end in appointments: if start >= last_end_time: max_appointments += 1 last_end_time = end return max_appointments # Example usage appointments = [(1, 3), (2, 5), (3, 4), (6, 8), (7, 9)] print(max_non_overlapping_appointments(appointments)) # Expected output: 3 ``` This new question involves scheduling, a concept related to efficiently managing tasks and resources, aligning well with the domain of algorithmic problem solving as shown in the provided sample. The selected greedy algorithm approach reflects the complexity level needed and introduces a novel scenario relevant to practical applications.","solution":"def max_non_overlapping_appointments(appointments): Determine the maximum number of non-overlapping appointments. Parameters: appointments (list of tuples): A list where each tuple contains two integers representing the start and end times of an appointment. Returns: int: Maximum number of non-overlapping appointments that can be scheduled. # Sort appointments based on their end times appointments.sort(key=lambda x: x[1]) max_appointments = 0 last_end_time = -1 for start, end in appointments: if start >= last_end_time: max_appointments += 1 last_end_time = end return max_appointments"},{"question":"Scenario: You are building a component for a logistics management system that needs to optimize the allocation of delivery vehicles based on the proximity of delivery points. The system represents delivery points and the distances between them as a graph, where each delivery point is a vertex and each distance is an edge with a positive weight. Your task is to deploy an algorithm that computes the minimum spanning tree (MST) of this graph to determine the most efficient way to connect all delivery points with the minimal total distance. # Question: Implement Prim\'s algorithm to compute the Minimum Spanning Tree (MST) for the given graph. The system should be able to handle a variety of input sizes and weights, ensuring the minimal total distance to connect all vertices. # Function Signature: * **function name**: `prim_mst` * **inputs**: - `graph` (List[List[float]]): A 2D list representing the weighted adjacency matrix of the graph where `graph[i][j]` indicates the weight of the edge from vertex `i` to vertex `j`. If there is no edge between two vertices, the entry is `float(\\"inf\\")`. - `v` (int): The number of vertices in the graph. * **outputs**: - `mst` (List[Tuple[int, int, float]]): A list of tuples representing the edges in the MST, where each tuple contains two vertices (i, j) and the weight of the edge between them. # Constraints: 1. The number of vertices (V) will be between 2 to 100 (inclusive). 2. The graph will have positive edge weights only. 3. The graph is connected, ensuring a valid MST exists. # Example: ```python # Example usage: graph = [ [0, 2, float(\\"inf\\"), 6, float(\\"inf\\")], [2, 0, 3, 8, 5], [float(\\"inf\\"), 3, 0, float(\\"inf\\"), 7], [6, 8, float(\\"inf\\"), 0, 9], [float(\\"inf\\"), 5, 7, 9, 0] ] v = 5 mst = prim_mst(graph, v) print(mst) # Expected Output: # [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)] ``` # Additional Notes: - Ensure you validate the input matrix for the correct dimension and handle any edge cases where the input graph might be improperly formatted. - Consider using a priority queue for efficient edge selection during the MST construction. - Handle errors gracefully and return appropriate messages if the input is invalid.","solution":"import heapq def prim_mst(graph, v): Implements Prim\'s algorithm to compute the Minimum Spanning Tree (MST) of a given graph. Parameters: graph (List[List[float]]): A 2D list representing the weighted adjacency matrix of the graph. v (int): The number of vertices in the graph. Returns: List[Tuple[int, int, float]]: A list of tuples representing the edges in the MST. if not graph or len(graph) != v or not all(len(row) == v for row in graph): raise ValueError(\\"Invalid graph representation\\") mst_edges = [] visited = [False] * v min_heap = [(0, 0, -1)] while min_heap: weight, current_vertex, parent = heapq.heappop(min_heap) if visited[current_vertex]: continue visited[current_vertex] = True if parent != -1: mst_edges.append((parent, current_vertex, weight)) for neighbor in range(v): if not visited[neighbor] and graph[current_vertex][neighbor] != float(\'inf\'): heapq.heappush(min_heap, (graph[current_vertex][neighbor], neighbor, current_vertex)) return mst_edges"},{"question":"# Scenario You are developing a personal finance management application. One feature the users find particularly useful is the ability to generate a breakdown of their monthly expenses by category. Your task is to implement a function that takes a list of transactions and calculates the total expenses for each category. # Task Implement the function `calculate_expenses`, which organizes and calculates the expenses for each category based on the provided list of transactions. # Requirements 1. **Function Signature**: ```python def calculate_expenses(transactions: List[Tuple[str, float]]) -> Dict[str, float]: pass ``` 2. **Parameters**: - `transactions` (List[Tuple[str, float]]): A list of tuples where each tuple contains a category (str) and an expense amount (float). 3. **Returns**: - (Dict[str, float]): A dictionary where the keys are categories and the values are the total expenses for each category, rounded to two decimal places. 4. **Constraints**: - Each category will be a non-empty string. - Expense amounts will be non-negative floats. - If no transactions are given, return an empty dictionary. - Categories are case-insensitive, meaning \\"food\\" and \\"Food\\" should be considered the same category. # Examples ```python >>> calculate_expenses([(\\"food\\", 20), (\\"entertainment\\", 50), (\\"food\\", 30)]) {\\"food\\": 50.0, \\"entertainment\\": 50.0} >>> calculate_expenses([(\\"Travel\\", 100), (\\"travel\\", 200), (\\"Savings\\", 150)]) {\\"travel\\": 300.0, \\"savings\\": 150.0} >>> calculate_expenses([(\\"Food\\", 12.75), (\\"food\\", 7.25), (\\"Gym\\", 25.5)]) {\\"food\\": 20.0, \\"gym\\": 25.5} >>> calculate_expenses([]) {} ``` # Additional Notes Consider edge cases such as: - Transactions with zero expense amounts. - Categories with various casing. - A large number of transactions.","solution":"from typing import List, Tuple, Dict def calculate_expenses(transactions: List[Tuple[str, float]]) -> Dict[str, float]: expense_summary = {} for category, amount in transactions: category = category.lower() if category in expense_summary: expense_summary[category] += amount else: expense_summary[category] = amount # Round each entry to two decimal places for category in expense_summary: expense_summary[category] = round(expense_summary[category], 2) return expense_summary"},{"question":"# Prime Number Checker with Memoization Problem Statement You need to implement a function that checks whether a given number is prime using memoization to improve efficiency. The function should return `True` if the number is prime, and `False` otherwise. Function Specification ```python def is_prime(num: int, memo: dict = {}) -> bool: Check if a given number is prime using memoization. Parameters: num (int): The number to check for primality. memo (dict, optional): A dictionary used to store the primality results of previous checks for memoization. Returns: bool: `True` if the number is prime, `False` otherwise. ``` Input & Output Format * **Input**: * An integer `num` (0 <= num <= 10^6), representing the number to check for primality. * An optional dictionary `memo`, used for memoization. * **Output**: * A boolean indicating whether the given number is prime. Constraints: * The function should handle cases where `num` is 0 or 1. * The maximum value for `num` is 1,000,000 to ensure that the function runs efficiently on reasonable input sizes. * Handle any invalid input within the provided range and raise a ValueError with an appropriate message (e.g., for negative numbers or non-integer inputs). Example ```python >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(997) True ``` Additional Notes * Use memoization to store previously checked results and improve efficiency for multiple calls. * Consider handling edge cases and invalid input as specified. * Ensure that your function is efficient in terms of both time and space complexity within the given constraints.","solution":"def is_prime(num: int, memo: dict = {}) -> bool: Check if a given number is prime using memoization. Parameters: num (int): The number to check for primality. memo (dict, optional): A dictionary used to store the primality results of previous checks for memoization. Returns: bool: `True` if the number is prime, `False` otherwise. Raises: ValueError: If the input is negative or non-integer. if not isinstance(num, int): raise ValueError(\\"The number must be an integer.\\") if num < 0: raise ValueError(\\"The number must be non-negative.\\") if num in memo: return memo[num] if num < 2: memo[num] = False return False if num == 2: memo[num] = True return True if num % 2 == 0: memo[num] = False return False sqrt_num = int(num ** 0.5) + 1 for i in range(3, sqrt_num, 2): if num % i == 0: memo[num] = False return False memo[num] = True return True"},{"question":"# Coding Question: Efficient Graph Traversal and Modification Context In graph theory, certain tasks involve both traversal and dynamic modification of graph structures. Imagine we have a directed graph where each node represents a task and each edge represents a dependency. The graph can be modified by adding or removing edges, and we need to find the shortest path between two nodes after modifications. Task Write a function `manage_graph` that performs a series of operations on a directed graph as specified in an input list. Operations include adding edges, removing edges, and finding the shortest path between two nodes. Function Signature ```python def manage_graph(n: int, operations: list[tuple[str, int, int]]) -> list[int]: Manages a directed graph following the given operations. Args: n: Integer, number of nodes in the graph. operations: List of tuples where each tuple represents an operation in the format (op_type, node1, node2) - op_type: Operation type - \\"add_edge\\", \\"remove_edge\\", \\"shortest_path\\" - node1: Starting node (0 <= node1 < n) - node2: Ending node (0 <= node2 < n) Returns: List of shortest path lengths after each \\"shortest_path\\" operation. Example: manage_graph(4, [ (\\"add_edge\\", 0, 1), (\\"add_edge\\", 1, 2), (\\"shortest_path\\", 0, 2), (\\"add_edge\\", 2, 3), (\\"shortest_path\\", 0, 3), (\\"remove_edge\\", 1, 2), (\\"shortest_path\\", 0, 2) ]) => [2, 3, -1] ``` Requirements * Implement efficient handling of the graph using a suitable representation (e.g., adjacency list). * The input list `operations` consists of multiple tuples where each tuple represents an operation on the graph. * The first element in the tuple (`op_type`) is the type of operation to perform, the second (`node1`) corresponds to the starting node, and the third (`node2`) corresponds to the ending node. * For \\"shortest_path\\" operations, if there is no path between `node1` and `node2`, return `-1`. * The function should return a list of shortest path lengths after each \\"shortest_path\\" operation. Constraints - The tuple elements will always follow the format (\\"operation_type\\", node1, node2). - The number of nodes `n` is in the range 1 to 1000. - The number of operations will not exceed 5000. - For \\"add_edge\\" and \\"remove_edge\\", node1 and node2 are distinct and adhere to 0 <= node1, node2 < n. Example ```python manage_graph(4, [ (\\"add_edge\\", 0, 1), (\\"add_edge\\", 1, 2), (\\"shortest_path\\", 0, 2), (\\"add_edge\\", 2, 3), (\\"shortest_path\\", 0, 3), (\\"remove_edge\\", 1, 2), (\\"shortest_path\\", 0, 2) ]) => [2, 3, -1] ``` Notes - Implement efficient algorithms like Breadth-First Search (BFS) for finding the shortest path in the graph. - Ensure the graph representation allows for dynamic updates efficiently.","solution":"from collections import deque, defaultdict def bfs_shortest_path(graph, start, end, n): Perform BFS to determine the shortest path from start to end node. If there is no path, return -1. if start == end: return 0 visited = [False] * n queue = deque([(start, 0)]) visited[start] = True while queue: current, distance = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: if neighbor == end: return distance + 1 queue.append((neighbor, distance + 1)) visited[neighbor] = True return -1 def manage_graph(n, operations): Manages a directed graph by performing a series of operations. graph = defaultdict(list) results = [] for operation in operations: op_type, node1, node2 = operation if op_type == \\"add_edge\\": if node2 not in graph[node1]: graph[node1].append(node2) elif op_type == \\"remove_edge\\": if node2 in graph[node1]: graph[node1].remove(node2) elif op_type == \\"shortest_path\\": shortest_path_length = bfs_shortest_path(graph, node1, node2, n) results.append(shortest_path_length) return results"},{"question":"# String Zipper Function You are required to implement a Python function that merges two strings in a zigzag or \\"zipper\\" fashion. Your task is to create a function that combines characters from both strings alternately. If one string is longer than the other, append the remaining part of the longer string at the end of the merged result. # Objective Write a function `zip_strings` that interlaces two input strings in a specified manner. # Input and Output * **Inputs**: * `str1: str` - the first input string. * `str2: str` - the second input string. * **Output**: * `merged_str: str` - the resulting string after interlacing characters from both strings. # Constraints * `1 <= len(str1), len(str2) <= 100` # Guidelines 1. Start with the first character of `str1`, then the first character of `str2`, followed by the second character of `str1`, and so on. 2. If one string is shorter, add the remaining characters of the longer string to the end. # Function Signature ```python def zip_strings(str1: str, str2: str) -> str: # Your code here ``` # Example ```python def zip_strings(str1: str, str2: str) -> str: i, j = 0, 0 merged_str = [] while i < len(str1) and j < len(str2): merged_str.append(str1[i]) merged_str.append(str2[j]) i += 1 j += 1 if i < len(str1): merged_str.append(str1[i:]) if j < len(str2): merged_str.append(str2[j:]) return \'\'.join(merged_str) # Test cases print(zip_strings(\\"abc\\", \\"xyz\\")) # Output: \\"axbycz\\" print(zip_strings(\\"abc\\", \\"xyzw\\")) # Output: \\"axbyczw\\" print(zip_strings(\\"abcd\\", \\"xyz\\")) # Output: \\"axbyczd\\" ``` # Scenario Consider you are developing a text processing tool that generates alternating patterns for input strings, which is particularly useful for creating unique mixed-content displays or for cryptographic applications where patterns need to be non-obvious. Implement the function to achieve this string zipper effect and briefly discuss the potential use case scenarios.","solution":"def zip_strings(str1: str, str2: str) -> str: i, j = 0, 0 merged_str = [] while i < len(str1) and j < len(str2): merged_str.append(str1[i]) merged_str.append(str2[j]) i += 1 j += 1 if i < len(str1): merged_str.append(str1[i:]) if j < len(str2): merged_str.append(str2[j:]) return \'\'.join(merged_str)"},{"question":"# Pascal\'s Triangle Row Retrieval Given a non-negative integer `k`, write a Python function to generate the `k-th` (0-based) row of Pascal\'s Triangle. Input - A single integer `k` where `0 <= k <= 33`. Output - A list of integers representing the `k-th` row of Pascal\'s Triangle. Constraints - The input integer `k` will be between 0 and 33 (inclusive). Example For `k = 3`, the function should return `[1, 3, 3, 1]`. For `k = 0`, the function should return `[1]`. For `k = 5`, the function should return `[1, 5, 10, 10, 5, 1]`. Implementation Requirements - The function should be named `get_pascals_triangle_row(k: int) -> list`. ```python def get_pascals_triangle_row(k: int) -> list: if k == 0: return [1] row = [1] for i in range(1, k + 1): row.append(row[-1] * (k - i + 1) // i) return row # You can test your function with # print(get_pascals_triangle_row(3)) # Output should be [1, 3, 3, 1] # print(get_pascals_triangle_row(5)) # Output should be [1, 5, 10, 10, 5, 1] ```","solution":"def get_pascals_triangle_row(k: int) -> list: Returns the k-th row of Pascal\'s Triangle. if k == 0: return [1] row = [1] for i in range(1, k + 1): row.append(row[-1] * (k - i + 1) // i) return row"},{"question":"# Reverse Polish Notation Calculator Problem Statement Reverse Polish Notation (RPN) is a mathematical notation in which every operator follows all of its operands. For example, to add two numbers together using RPN, you would write \\"3 4 +\\" instead of \\"3 + 4\\". Your task is to implement an RPN calculator that evaluates a given RPN expression. Write a function `evaluate_rpn` that takes a list of strings representing the RPN expression and returns the result as a float. The expression will always be valid and will only contain integers, and the operators `+`, `-`, `*`, and `/`. Function Signature ```python def evaluate_rpn(expression: List[str]) -> float: pass ``` # Input - A list of strings `expression` where each string is either an integer or one of the operators `+`, `-`, `*`, `/`. # Output - The function returns the result of the RPN expression as a float. # Constraints - The list `expression` will have a length between 1 and 1000. - The integer values in `expression` will be in the range [-10000, 10000]. Example ```python # Example 1 print(evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"])) # Outputs: 9.0 # Example 2 print(evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"])) # Outputs: 6.6 ``` Scenario You are tasked with implementing an algorithm to evaluate mathematical expressions written in Reverse Polish Notation. The challenge comprises handling a stack-based approach to evaluate the expression efficiently. Given the variety of operations and numbers, ensure your solution accurately applies the operators while maintaining performance with a large number of elements in the expression list.","solution":"def evaluate_rpn(expression): Evaluates the given RPN expression and returns the result as a float. Args: expression (List[str]): A list of strings where each string is either an integer or an operator. Returns: float: The result of the RPN expression. stack = [] operators = {\\"+\\", \\"-\\", \\"*\\", \\"/\\"} for token in expression: if token in operators: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a / b) else: stack.append(int(token)) return float(stack.pop())"},{"question":"# Question: Evaluate Expressions with Variables You are given an expression represented as a string containing integers, variable names, and the operators `+`, `-`, `*`, `/`. Variables are represented as uppercase English letters and are stored in a dictionary with their corresponding integer values. Implement a function `evaluate_expression` that evaluates the expression using the given variable values. Function Signature: ```python def evaluate_expression(expr: str, variables: dict[str, int]) -> int: pass ``` # Input 1. `expr` (a string): A valid arithmetic expression containing integers, variable names, and the operators `+`, `-`, `*`, `/`. 2. `variables` (a dictionary): A dictionary where keys are uppercase English letters and values are integers. # Output - Returns an integer which is the result of evaluating the expression. # Example: ```python expr = \\"A + 3 * (B - C)\\" variables = { \\"A\\": 5, \\"B\\": 10, \\"C\\": 2 } print(evaluate_expression(expr, variables)) # Output: 29 ``` # Constraints - `expr` is a non-empty string containing only valid arithmetic expressions, integers, variable names, parentheses, and spaces. - Each variable in the expression is guaranteed to be a key in the `variables` dictionary. - Division by zero will not occur in the provided input. - The expression follows standard mathematical precedence rules (parentheses first, then multiplication and division, then addition and subtraction).","solution":"def evaluate_expression(expr: str, variables: dict[str, int]) -> int: # Replace variables with their values in the expression for var, value in variables.items(): expr = expr.replace(var, str(value)) # Use Python\'s eval to evaluate the expression # Eval handles parentheses and operator precedence by default return eval(expr)"},{"question":"# Question: Implementing a Circular Queue You need to implement a circular queue using an array, where the operations `enqueue`, `dequeue`, and `display` must be performed efficiently. The queue should handle wrap-around scenarios, for example, when the end of the array is reached, it should start storing elements from the beginning if there is space. **Requirements**: - Implement a method `enqueue` to add an element to the queue. - Implement a method `dequeue` to remove an element from the queue. - Implement a method `display` to print the current elements in the queue in the correct order. # Function Signature ```python class CircularQueue: def __init__(self, size: int): pass def enqueue(self, value: int) -> None: pass def dequeue(self) -> int | None: pass def display(self) -> None: pass ``` # Input Format - No direct input. The sequence of operations is performed via the class methods and will be in the form of function calls. # Output Format - The method `enqueue` should not return anything. - The method `dequeue` should return the integer being dequeued or `None` if the queue is empty. - The method `display` should print the current queue elements space-separated in the correct order of processing, or \\"Queue is empty\\" if the queue is empty. # Constraints - The queue contains only integer values. - Queue size is specified during initialization and remains fixed. - The methods should handle wrap-around properly. - Ensure efficient memory usage and operations. # Example ```python queue = CircularQueue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.display() # Output: 1 2 3 print(queue.dequeue()) # Output: 1 queue.enqueue(4) queue.display() # Output: 2 3 4 print(queue.dequeue()) # Output: 2 queue.display() # Output: 3 4 ``` **Hint**: Use a fixed-size list and dynamically update the front and rear indices with wrap-around logic.","solution":"class CircularQueue: def __init__(self, size: int): self.size = size self.queue = [None] * size self.front = -1 self.rear = -1 def enqueue(self, value: int) -> None: if ((self.rear + 1) % self.size == self.front): print(\\"Queue is full\\") return if self.front == -1: self.front = 0 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value def dequeue(self) -> int | None: if self.front == -1: return None dequeued_value = self.queue[self.front] self.queue[self.front] = None if self.front == self.rear: self.front = -1 self.rear = -1 else: self.front = (self.front + 1) % self.size return dequeued_value def display(self) -> None: if self.front == -1: print(\\"Queue is empty\\") return elements = [] i = self.front while True: elements.append(self.queue[i]) if i == self.rear: break i = (i + 1) % self.size print(\\" \\".join(map(str, elements)))"},{"question":"**Problem Statement**: Given a list of integers `nums`, return the maximum length of a contiguous subarray with an equal number of 1s and 0s. Write a function `find_max_length(nums: list[int]) -> int` that takes in a list of integers and returns the maximum length of a contiguous subarray that contains an equal number of 1s and 0s. **Function Signature**: ```python def find_max_length(nums: list[int]) -> int: pass ``` **Input**: * `nums`: A list of integers consisting of only 0s and 1s. **Output**: * An integer representing the maximum length of a contiguous subarray with an equal number of 1s and 0s. **Examples**: ```python # Example 1 nums = [0, 1, 0] print(find_max_length(nums)) # Output: 2 # Example 2 nums = [0, 1, 0, 1] print(find_max_length(nums)) # Output: 4 # Example 3 nums = [0, 1, 1, 0, 1, 0, 1] print(find_max_length(nums)) # Output: 6 # Example 4 nums = [1, 1, 1, 1] print(find_max_length(nums)) # Output: 0 ``` **Constraints**: * The length of `nums` will be in the range [1, 10^5]. * `nums[i]` is either 0 or 1. **Notes**: * You are expected to find the solution with a time complexity of O(n). * Consider prefix sums to track the balance of 0s and 1s as you traverse the array. * Use a dictionary to store the first occurrence of each balance to optimize the search for the maximum length.","solution":"def find_max_length(nums): Returns the maximum length of a contiguous subarray with an equal number of 1s and 0s. # Dictionary to store the first occurrence of each count count_dict = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): # Increment count for 1, decrement for 0 count += 1 if num == 1 else -1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length"},{"question":"# Question A company wants to ensure their employees\' passwords are strong. A strong password is defined by the following rules: 1. It must be at least 8 characters long. 2. It must contain at least one uppercase letter. 3. It must contain at least one lowercase letter. 4. It must contain at least one digit. 5. It must contain at least one special character from the set `[\'@\', \'#\', \'\', \'%\', \'^\', \'&\', \'*\', \'(\', \')\']`. Write a function that checks if a given password is strong based on the rules stated above. Function Signature ```python def is_strong_password(password: str) -> bool: pass ``` Requirements 1. **Input**: - `password`: A string representing the password to check. 2. **Output**: - Return a boolean value: `True` if the password is strong, `False` otherwise. 3. **Constraints**: - The length of `password` will be at least 1 character and at most 100 characters. 4. **Performance**: - Aim for a solution that runs efficiently within the constraints provided. Examples ```python # Example 1 >>> is_strong_password(\\"Aa1@bcde\\") Output: True # Example 2 >>> is_strong_password(\\"Aa1bcde\\") Output: False # Missing special character # Example 3 >>> is_strong_password(\\"Aa@bcde\\") Output: False # Missing numeric character # Example 4 >>> is_strong_password(\\"a1@bcdef\\") Output: False # Missing uppercase letter # Example 5 >>> is_strong_password(\\"A1@BCDEF\\") Output: False # Missing lowercase letter ``` Notes * The function should evaluate the password strength by checking all the rules. * Ensure that the solution considers edge cases such as single character strings or strings that are exactly 8 characters but fail to meet the other criteria.","solution":"import re def is_strong_password(password: str) -> bool: Checks if the given password is strong based on the following rules: 1. Must be at least 8 characters long. 2. Must contain at least one uppercase letter. 3. Must contain at least one lowercase letter. 4. Must contain at least one digit. 5. Must contain at least one special character (@, #, , %, ^, &, *, (, )). if len(password) < 8: return False if not re.search(r\'[A-Z]\', password): return False if not re.search(r\'[a-z]\', password): return False if not re.search(r\'[0-9]\', password): return False if not re.search(r\'[@#%^&*()]\', password): return False return True"},{"question":"# Coding Question - Implementing a Simple Text Compression Algorithm In a data-heavy application, you need to implement a basic text compression algorithm to reduce the size of messages before transmission. An efficient and straightforward approach is to use Run-Length Encoding (RLE) for compressing simple text sequences. # Scenario A messaging application is transmitting a large number of repetitive text sequences, resulting in inefficient use of bandwidth. By compressing these sequences using Run-Length Encoding, the application can minimize the amount of data transmitted. # Task 1. Implement a function `rle_compress` that applies the Run-Length Encoding algorithm to compress a given text input. 2. Ensure the function can handle Unicode characters as the text input may include non-ASCII characters. # Function Signature ```python def rle_compress(text: str) -> str: pass ``` # Input * `text`: A string of arbitrary text which may contain any Unicode characters. # Output * Return the compressed string using the Run-Length Encoding format. # Constraints * Handle inputs of varying lengths, including empty strings. * Ensure the solution can handle large text inputs within reasonable memory constraints. # Performance Requirements * Aim to maintain O(n) time complexity where n is the length of the text input. * Ensure space complexity is proportional to the length of the input, but optimize where possible. # Example ```python assert rle_compress(\'aaabbc\') == \'a3b2c1\' assert rle_compress(\'\') == \'\' assert rle_compress(\'abcdefgh\') == \'a1b1c1d1e1f1g1h1\' assert rle_compress(\'aaAA\') == \'a2A2\' # handle case sensitivity assert rle_compress(\'😀😀😀abc\') == \'😀3a1b1c1\' # handle Unicode characters ``` # Additional Notes * The Run-Length Encoding format should represent runs of characters as the character followed by its count (e.g., \\"aaabb\\" becomes \\"a3b2\\"). * Consider edge cases such as an empty input, single character repetitions, and varied character sets. * Do not use external libraries for Run-Length Encoding to maintain simplicity and portability.","solution":"def rle_compress(text: str) -> str: Compresses the input text using Run-Length Encoding (RLE). Parameters: text (str): The input string to compress. Returns: str: The RLE compressed string. if not text: return \'\' compressed = [] prev_char = text[0] count = 1 for char in text[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) return \'\'.join(compressed)"},{"question":"# Problem Description You have been given the task of creating a file search utility for a mock file system. Your utility will search for files in a hierarchical structure based on a given directory path and specific file name patterns. # Objective Implement the following function: ```python def search_files(file_system: dict, start_path: str, file_pattern: str) -> list: Searches for files matching the given file pattern starting from a specified directory path in a hierarchical file system. Parameters: file_system (dict): A nested dictionary representing the file system, where keys are folder names or file names, and values are either nested dictionaries (for folders) or None (for files). start_path (str): The starting directory path from which to begin the search, separated by slashes (/). file_pattern (str): A string representing the file name pattern to search for, which may include \'*\' as a wildcard character. Returns: list: A list of file paths that match the file pattern within the file system, starting from `start_path`. ``` # Input * `file_system`: A nested dictionary structure where keys are folder names or file names, and values are either nested dictionaries (representing folders) or `None` (representing files). * `start_path`: A string path separated by slashes (/), indicating the starting directory for the search. * `file_pattern`: A string representing the file name pattern to match, where a \'*\' wildcard can replace zero or more characters. # Output * A list of strings representing the full paths of all files that match the given file pattern, starting from the `start_path`. # Constraints * The maximum depth of the file system hierarchy is 100. * The number of directories and files in the file system can be up to 10^5. * The length of `start_path` and `file_pattern` is at most 100 characters. * Only lowercase English letters (a-z), numbers (0-9), slashes (/), and dots (.) are used in folder and file names. # Example ```python # Mock file system file_system = { \'root\': { \'documents\': { \'report.doc\': None, \'data.xlsx\': None, \'summary.pdf\': None }, \'music\': { \'rock\': { \'song1.mp3\': None, \'song2.mp3\': None }, \'classical\': { \'symphony.mp3\': None } }, \'pictures\': { \'image1.png\': None, \'image2.jpg\': None } } } # Starting path and file pattern start_path = \'root/music\' file_pattern = \'*.mp3\' # Function call result = search_files(file_system, start_path, file_pattern) # Expected output # [\'root/music/rock/song1.mp3\', \'root/music/rock/song2.mp3\', \'root/music/classical/symphony.mp3\'] ``` Implement the `search_files` function to complete the task.","solution":"import fnmatch def search_files(file_system: dict, start_path: str, file_pattern: str) -> list: Searches for files matching the given file pattern starting from a specified directory path in a hierarchical file system. Parameters: file_system (dict): A nested dictionary representing the file system, where keys are folder names or file names, and values are either nested dictionaries (for folders) or None (for files). start_path (str): The starting directory path from which to begin the search, separated by slashes (/). file_pattern (str): A string representing the file name pattern to search for, which may include \'*\' as a wildcard character. Returns: list: A list of file paths that match the file pattern within the file system, starting from `start_path`. def traverse_fs(current_fs, current_path): results = [] for name, content in current_fs.items(): new_path = f\\"{current_path}/{name}\\" if current_path else name if content is None: # It\'s a file if fnmatch.fnmatch(name, file_pattern): results.append(new_path) else: # It\'s a directory results.extend(traverse_fs(content, new_path)) return results # Navigate to the starting path parts = start_path.split(\'/\') current_fs = file_system for part in parts: if part in current_fs: current_fs = current_fs[part] else: return [] # If the start path does not exist return traverse_fs(current_fs, start_path)"},{"question":"# Coding Assessment Question: Generate All Possible Full Binary Trees Your task is to write a function that generates all possible full binary trees with `n` nodes. A full binary tree is a tree where every node has either 0 or 2 children. Problem Description Given an integer `n`, implement a function `generate_all_full_binary_trees(n: int) -> List[TreeNode]` that returns a list of all possible full binary trees with `n` nodes. Each tree should be represented by its root node in the form of a `TreeNode` object. Input - `n`: An integer representing the number of nodes in the full binary tree. Output - A list of `TreeNode` objects, where each object is the root node of a unique full binary tree with `n` nodes. TreeNode Class Definition ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_all_full_binary_trees(n): if n % 2 == 0: # Full binary trees have an odd number of nodes. return [] if n == 1: return [TreeNode()] result = [] for left_tree_size in range(1, n, 2): right_tree_size = n - 1 - left_tree_size for left_subtree in generate_all_full_binary_trees(left_tree_size): for right_subtree in generate_all_full_binary_trees(right_tree_size): root = TreeNode() root.left = left_subtree root.right = right_subtree result.append(root) return result # Examples of Usage: trees = generate_all_full_binary_trees(7) print(len(trees)) # Output: 5 (There are 5 unique full binary trees with 7 nodes) ``` Constraints - `n` will be a positive integer less than or equal to 19.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_all_full_binary_trees(n: int) -> List[TreeNode]: Generate all possible full binary trees with n nodes. if n % 2 == 0: # Full binary trees have an odd number of nodes. return [] if n == 1: return [TreeNode()] result = [] for left_tree_size in range(1, n, 2): right_tree_size = n - 1 - left_tree_size for left_subtree in generate_all_full_binary_trees(left_tree_size): for right_subtree in generate_all_full_binary_trees(right_tree_size): root = TreeNode() root.left = left_subtree root.right = right_subtree result.append(root) return result"},{"question":"# Problem Statement: You are developing a library management system and need to implement a function that sorts books based on their due dates in ascending order. Each book has a title and a due date. The function should return the titles of the books sorted by their due dates. # Function Signature: ```python def sort_books_by_due_date(books: list[dict]) -> list[str]: Sort books by their due dates in ascending order. :param books: List of dictionaries, where each dictionary contains \'title\' and \'due_date\' keys. :return: List of book titles sorted by their due dates. ``` # Input: * `books` (list): A list of dictionaries, each containing: - `title` (str): The title of the book. - `due_date` (str): The due date of the book in the format \'YYYY-MM-DD\'. # Output: * List[str]: A list of book titles sorted by their due dates in ascending order. # Constraints: 1. Each string representing a due date will be a valid date in the \'YYYY-MM-DD\' format. 2. The list of books will contain between 1 and 10^5 books. 3. The titles of the books are unique. # Example: 1. `sort_books_by_due_date([{\\"title\\": \\"Book A\\", \\"due_date\\": \\"2023-10-01\\"}, {\\"title\\": \\"Book B\\", \\"due_date\\": \\"2023-09-30\\"}, {\\"title\\": \\"Book C\\", \\"due_date\\": \\"2023-10-02\\"}])` should return `[\'Book B\', \'Book A\', \'Book C\']` 2. `sort_books_by_due_date([{\\"title\\": \\"Book D\\", \\"due_date\\": \\"2023-01-15\\"}, {\\"title\\": \\"Book E\\", \\"due_date\\": \\"2023-01-10\\"}])` should return `[\'Book E\', \'Book D\']` # Instructions: * Implement the function `sort_books_by_due_date` to correctly sort the given books by their due dates. * Ensure the function passes the provided examples. * The function should handle the given constraints effectively.","solution":"def sort_books_by_due_date(books): Sort books by their due dates in ascending order. :param books: List of dictionaries, where each dictionary contains \'title\' and \'due_date\' keys. :return: List of book titles sorted by their due dates. # Sort the books list based on the \'due_date\' key sorted_books = sorted(books, key=lambda book: book[\'due_date\']) # Extract and return the titles of the sorted books return [book[\'title\'] for book in sorted_books]"},{"question":"# Problem Statement You are responsible for organizing coding challenge competitions at your organization. Each competition requires a certain amount of preparatory work, and you have a limited number of work hours to allocate each day. You want to distribute the work such that the maximum number of competitions can be prepared. Write a function named `max_competitions` that takes a list of integers representing the hours required for each competition and an integer representing the total number of work hours available each day. The function should return an integer representing the maximum number of competitions that can be prepared in one day. # Input * `work_hours` (list of int): A list of integers where each integer represents the hours required to prepare for a single competition. * `total_hours` (int): An integer representing the total number of work hours available in a single day. # Output * An integer representing the maximum number of competitions that can be fully prepared in one day. # Examples ```python # Example 1 assert max_competitions([2, 3, 1, 4], 8) == 3 # Example 2 assert max_competitions([5, 2, 1, 8], 10) == 3 # Example 3 assert max_competitions([1, 1, 1, 1, 1], 5) == 5 # Example 4 assert max_competitions([4, 4, 4], 5) == 1 # Example 5 assert max_competitions([10, 10, 10, 10], 10) == 1 ``` # Constraints * All work hours are positive integers. * The length of the input list will be between 0 and 10^4. * The maximum number of work hours required for any competition will be 10^3. * The total number of work hours available in a single day will be between 1 and 10^4. # Performance Requirements * The algorithm should run in O(n log n) time complexity. # Additional Notes * If the input list is empty, the function should return 0. * If the total number of work hours is zero, the function should return 0 as no work can be done.","solution":"def max_competitions(work_hours, total_hours): Returns the maximum number of competitions that can be fully prepared in one day given the work_hours required for each competition and total_hours available. work_hours.sort() count = 0 current_hours = 0 for hours in work_hours: if current_hours + hours <= total_hours: current_hours += hours count += 1 else: break return count"},{"question":"# Question: Inventory Stock Balance Context You are developing an inventory management system for a small store. To ensure that the inventory is balanced, you need to create a program to verify that the total quantity of incoming products matches the total quantity of outgoing products over a given period. This will help the store maintain accurate records and avoid discrepancies. Task Implement a Python function `check_inventory_balance(transactions: List[Tuple[str, str, int]]) -> bool` that determines if the inventory of a store is balanced. The function should check if the sum of incoming and outgoing quantities for a list of transactions is equal. Input - `transactions`: A list of tuples where each tuple contains three elements: * `id` (str): A unique identifier for the product. * `type` (str): Either `\\"in\\"` for incoming products or `\\"out\\"` for outgoing products. * `quantity` (int): The quantity of products involved in the transaction. Output - Returns a boolean value `True` if the inventory is balanced (i.e., total incoming equals total outgoing for each product), otherwise `False`. Constraints 1. The `id` will be a non-empty string. 2. The `type` will be either `\\"in\\"` or `\\"out\\"`. 3. The `quantity` will be a non-negative integer. Example ```python from typing import List, Tuple def check_inventory_balance(transactions: List[Tuple[str, str, int]]) -> bool: # Function to be implemented pass # Example usage transactions = [ (\'A123\', \'in\', 30), (\'A123\', \'out\', 20), (\'A123\', \'in\', 20), (\'B456\', \'in\', 15), (\'B456\', \'out\', 12), (\'B456\', \'in\', 5), (\'B456\', \'out\', 8), (\'A123\', \'out\', 30) ] print(check_inventory_balance(transactions)) # Output: True transactions = [ (\'X789\', \'in\', 10), (\'Y012\', \'out\', 10) ] print(check_inventory_balance(transactions)) # Output: False ``` Notes - Ensure that the function handles multiple products with different IDs. - Consider using a dictionary or similar data structure to keep track of the product IDs and their corresponding balances. - Handle edge cases such as no transactions or only incoming/only outgoing transactions appropriately.","solution":"from typing import List, Tuple def check_inventory_balance(transactions: List[Tuple[str, str, int]]) -> bool: balance = {} for trans_id, trans_type, quantity in transactions: if trans_id not in balance: balance[trans_id] = 0 if trans_type == \'in\': balance[trans_id] += quantity elif trans_type == \'out\': balance[trans_id] -= quantity return all(balance[id] == 0 for id in balance)"},{"question":"# Implement a Priority Queue with Custom Comparator Objective: Design and implement a priority queue that uses a custom comparator to determine the priority of elements. Problem Statement: Write a class `PriorityQueue` that supports insertion of elements and extraction of the highest priority element according to a custom comparator function. Class Signature: ```python from typing import Callable, Any class PriorityQueue: def __init__(self, comparator: Callable[[Any, Any], bool]): pass def insert(self, item: Any) -> None: pass def extract(self) -> Any: pass ``` Inputs: * `comparator` (Callable[[Any, Any], bool]): A custom comparator function that takes two elements and returns `True` if the first element has higher priority than the second, and `False` otherwise. * `item` (Any): An element to be inserted into the priority queue. Outputs: * `extract` should return the highest priority element from the queue. Example: ```python # Example comparator functions def max_comparator(a, b): return a > b def min_comparator(a, b): return a < b # Example usage pq = PriorityQueue(max_comparator) pq.insert(3) pq.insert(1) pq.insert(4) pq.insert(1) pq.insert(5) print(pq.extract()) # Output: 5 print(pq.extract()) # Output: 4 print(pq.extract()) # Output: 3 pq_min = PriorityQueue(min_comparator) pq_min.insert(3) pq_min.insert(1) pq_min.insert(4) pq_min.insert(1) pq_min.insert(5) print(pq_min.extract()) # Output: 1 print(pq_min.extract()) # Output: 1 print(pq_min.extract()) # Output: 3 ``` Constraints: * Do not use built-in priority queue implementations or libraries. * Ensure the solution handles duplicate elements appropriately. * Implement efficient extraction to adhere to the usual priority queue operations. * Handle edge cases like extracting from an empty queue.","solution":"from typing import Callable, Any import heapq class PriorityQueue: def __init__(self, comparator: Callable[[Any, Any], bool]): self.comparator = comparator self._data = [] def _wrap(self, item): Wraps the item in a structure that incorporates the comparator for proper heapq operation. class ComparatorWrapper: def __init__(self, item, comparator): self.item = item self.comparator = comparator def __lt__(self, other): return self.comparator(self.item, other.item) return ComparatorWrapper(item, self.comparator) def insert(self, item: Any) -> None: heapq.heappush(self._data, self._wrap(item)) def extract(self) -> Any: if not self._data: raise IndexError(\\"extract from empty priority queue\\") return heapq.heappop(self._data).item"},{"question":"# Top K Frequent Words Given a list of words and an integer k, return the k most frequent words. The output should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lexicographically smaller (i.e., alphabetical) order should appear first. # Requirements: 1. Implement a function, `top_k_frequent(words: List[str], k: int) -> List[str]` that returns a list of the k most frequent words. 2. If the input list is empty or k is zero, return an empty list. # Constraints: - `1 <= len(words) <= 10^4` - Each word has a maximum length of 100 - Words consist of lowercase English letters - `1 <= k <= the number of unique words` # Example: ```python # Example 1 words = [\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"] k = 2 top_k_frequent(words, k) => [\\"i\\", \\"love\\"] # Example 2 words = [\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"] k = 4 top_k_frequent(words, k) => [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"] # Example 3 words = [\\"apple\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"cherry\\"] k = 2 top_k_frequent(words, k) => [\\"apple\\", \\"banana\\"] # Example 4 words = [\\"apple\\", \\"banana\\", \\"cherry\\"] k = 3 top_k_frequent(words, k) => [\\"apple\\", \\"banana\\", \\"cherry\\"] ``` # Edge Cases: - The list `words` can contain up to `10^4` words. - If `k` is greater than the number of unique words, the function should return all unique words sorted by their frequency. # Performance Consideration: - The solution should be efficient in terms of time and space, aiming for O(n log k) complexity, where n is the length of the `words` list. # Function Signature: ```python def top_k_frequent(words: List[str], k: int) -> List[str]: pass ``` # Implementation Note: - Use appropriate data structures to maintain the frequency count and manage the sorting and ordering processes effectively.","solution":"from typing import List from collections import Counter import heapq def top_k_frequent(words: List[str], k: int) -> List[str]: Returns the k most frequent words from the input list of words. if not words or k == 0: return [] # Count frequency of each word count = Counter(words) # Create a min-heap for the frequencies heap = [(-freq, word) for word, freq in count.items()] heapq.heapify(heap) # Extract the top k frequent elements res = [heapq.heappop(heap)[1] for _ in range(k)] return res"},{"question":"# Scenario You have been tasked with creating a feature for a library management system to help librarians keep track of book loans. The system needs to ensure that books are loaned according to the priority of requests, using a priority queue. # Task Write a function `loan_book(requests: List[Tuple[int, str]], book_title: str) -> List[str]` that determines the order in which library members should receive a specific book based on their request priority. # Input Format * `requests`: A list of tuples, where each tuple contains an integer (representing the priority) and a string (representing the member\'s name). Lower integer values indicate higher priority. * `book_title`: The title of the book being loaned (string). # Output Format * Return a list of member names in the order they should receive the book. # Constraints * The list of requests will contain at most (10^3) members. * Priority values will be between 1 and (10^4). * The book_title string length will not exceed 100 characters. # Example ```python requests = [ (3, \\"Alice\\"), (2, \\"Bob\\"), (5, \\"Charlie\\"), (1, \\"Diana\\"), (4, \\"Eve\\") ] book_title = \\"Introduction to Algorithms\\" print(loan_book(requests, book_title)) # Output: [\\"Diana\\", \\"Bob\\", \\"Alice\\", \\"Eve\\", \\"Charlie\\"] ```","solution":"from typing import List, Tuple def loan_book(requests: List[Tuple[int, str]], book_title: str) -> List[str]: Determines the order in which library members should receive a specific book based on their request priority. Args: - requests: List[Tuple[int, str]] - A list of tuples where each tuple contains a priority (lower value means higher priority) and a member\'s name. - book_title: str - The title of the book being loaned. Returns: - List[str] - A list of member names in the order they should receive the book. # Sort the requests by priority first, then by member name to break ties deterministically sorted_requests = sorted(requests, key=lambda x: x[0]) return [member for _, member in sorted_requests]"},{"question":"# Coding Question **Problem Statement**: You are tasked with implementing a function that will determine whether a provided string is a valid Sudoku move. A valid move in Sudoku means placing a digit from 1 to 9 in an empty cell (represented by \'.\') without breaking the Sudoku rules: no duplicate digits in a row, column, or 3x3 sub-grid. # Objective: Write a function `is_valid_sudoku_move(board: List[List[str]], row: int, col: int, digit: str) -> bool` that returns True if the move is valid and False otherwise. # Function Signature ```python def is_valid_sudoku_move(board: List[List[str]], row: int, col: int, digit: str) -> bool: ``` # Input * `board`: A 9x9 2D list representing the current state of the Sudoku board where each cell is either a digit \'1\'-\'9\' or \'.\'. * `row`: An integer `row` (0 <= row < 9), the row index where the move is made. * `col`: An integer `col` (0 <= col < 9), the column index where the move is made. * `digit`: A character from \'1\' to \'9\', representing the digit to be placed. # Output * Return `True` if the move is valid, otherwise return `False`. # Example ```python board = [ [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ] >>> is_valid_sudoku_move(board, 0, 2, \'3\') False >>> is_valid_sudoku_move(board, 0, 2, \'1\') True ``` # Constraints * Ensure the function handles the 9x9 board efficiently. * Utilize appropriate checks to keep the solution optimized and succinct. # Scenario A Sudoku game application allows users to place digits on a board. Your function will be invoked to validate each move made by the user. This is crucial to prevent invalid placements and ensure the game state remains correct.","solution":"from typing import List def is_valid_sudoku_move(board: List[List[str]], row: int, col: int, digit: str) -> bool: # Check if the digit already exists in the same row for c in range(9): if board[row][c] == digit: return False # Check if the digit already exists in the same column for r in range(9): if board[r][col] == digit: return False # Check if the digit already exists in the same 3x3 sub-grid box_row_start = (row // 3) * 3 box_col_start = (col // 3) * 3 for r in range(box_row_start, box_row_start + 3): for c in range(box_col_start, box_col_start + 3): if board[r][c] == digit: return False # If no conflicts, the move is valid return True"},{"question":"# Data Validation for User Registration You have been tasked with developing a user registration system, and a critical part of this system is to validate the input data to ensure they meet certain criteria. Task Write a Python function `validate_registration(data: dict) -> bool` that checks the user registration details for validity. # Input - A dictionary `data` with the following keys: - `username`: A string representing the user\'s username. - `email`: A string representing the user\'s email address. - `password`: A string representing the user\'s password. # Output - A boolean value `True` if all the input data is valid, and `False` otherwise. # Requirements and Constraints 1. **Username**: - Must be between 3 and 15 characters long. - Can only contain alphanumeric characters and underscores (`_`). 2. **Email**: - Must follow a valid email format (e.g., `example@domain.com`). - Use a simple regex to validate the email format. 3. **Password**: - Must be at least 8 characters long. - Must contain at least one uppercase letter, one lowercase letter, one digit, and one special character from `!@#%^&*()-_=+`. 4. **Input Integrity**: - All fields must be non-empty strings. - Check for the presence and type of each key. # Edge Cases 1. **Missing Fields**: Any of the required fields (`username`, `email`, `password`) is missing. 2. **Invalid Formats**: Any of the fields does not meet the format constraints. 3. **Special Characters**: Ensure only allowed characters are present in `username` and `password`. Example: Suppose the input data is: ```python { \\"username\\": \\"user_123\\", \\"email\\": \\"user@example.com\\", \\"password\\": \\"Passw0rd!\\" } ``` Your function should return `True` because all the values meet the validation criteria. However, if the input data is: ```python { \\"username\\": \\"user!\\", \\"email\\": \\"useratexample.com\\", \\"password\\": \\"password\\" } ``` Your function should return `False` because: - `username` contains an invalid character (`!`). - `email` does not follow the correct format. - `password` does not meet the complexity requirements. Implement the function `validate_registration` to meet the described requirements and considerations.","solution":"import re def validate_registration(data): Validates user registration details. Args: data (dict): A dictionary containing \'username\', \'email\', and \'password\'. Returns: bool: True if all input data is valid, False otherwise. # Check for presence and type of each key required_fields = [\'username\', \'email\', \'password\'] for field in required_fields: if field not in data or not isinstance(data[field], str): return False username = data[\'username\'] email = data[\'email\'] password = data[\'password\'] # Validate username if not (3 <= len(username) <= 15): return False if not re.match(r\'^[a-zA-Z0-9_]+\', username): return False # Validate email if not re.match(r\'^[^@]+@[^@]+.[^@]+\', email): return False # Validate password if len(password) < 8: return False if not re.search(r\'[A-Z]\', password): return False if not re.search(r\'[a-z]\', password): return False if not re.search(r\'[0-9]\', password): return False if not re.search(r\'[!@#%^&*()-_=+]\', password): return False return True"},{"question":"# Problem Statement You need to find the mode of a list of integers. The mode of a list is the number that appears most frequently. If there are multiple modes, return all of them in ascending order. Your task is to implement a function `find_modes(numbers: List[int]) -> List[int]` that takes a list of integers and returns a list of the mode(s) in ascending order. # Function Signature ```python from typing import List def find_modes(numbers: List[int]) -> List[int]: pass ``` # Input * `numbers`: A list of integers (e.g., `[1, 3, 3, 2, 2, 5, 2]`). # Output * A list of integers where each integer is a mode of the input list (e.g., `[2]`). # Constraints * The list `numbers` will contain between 1 and 1,000 elements. * Each element of the list is an integer between `-10^6` and `10^6`. # Example ```python assert find_modes([1, 3, 3, 2, 2, 5, 2]) == [2] assert find_modes([4, 4, 2, 2, 3, 3]) == [2, 3, 4] assert find_modes([5, 7, 7, 2, 5, 5, 7]) == [5, 7] ``` # Notes * You should take into account the given constraints to ensure efficient operation and reasonably short runtime. * Consider edge cases such as an empty list, or a list where all elements are unique. * Your solution should efficiently count the frequency of each number and determine the modes in ascending order.","solution":"from typing import List from collections import Counter def find_modes(numbers: List[int]) -> List[int]: if not numbers: return [] count = Counter(numbers) max_count = max(count.values()) modes = [num for num, freq in count.items() if freq == max_count] return sorted(modes)"},{"question":"# Question: (String Permutations) Given the following recursive approach to generate all unique permutations of a string, implement a function that, given a string `s`, returns all distinct permutations of the string in sorted order. **Function Signature:** ```python def string_permutations(s: str) -> List[str]: ``` **Input:** * A string `s` consisting of up to 10 characters. The string may contain duplicate characters and will only contain lowercase alphabetic characters (\'a\' to \'z\'). **Output:** * A list of strings representing all distinct permutations of the input string, sorted lexicographically. **Example:** ```python >>> string_permutations(\\"cat\\") [\'act\', \'atc\', \'cat\', \'cta\', \'tac\', \'tca\'] >>> string_permutations(\\"aab\\") [\'aab\', \'aba\', \'baa\'] ``` **Constraints:** * You may assume the input string will only contain lowercase letters and its length will not exceed 10 characters. **Guidelines:** * Use a recursive approach to generate permutations. * Filter out duplicate permutations to ensure the output list contains only unique results. * Sort the resulting permutations before returning them. **Scenario:** You have been hired by a text processing software company to implement a feature that generates all possible unique anagrams of input words. This feature will help users explore different word combinations for creative writing and puzzle-solving purposes. Ensure the results are provided in a clear and organized manner, reflecting all possible unique arrangements of the given input string.","solution":"from typing import List def string_permutations(s: str) -> List[str]: def permute(remaining, path, result): if not remaining: result.add(path) return for i in range(len(remaining)): permute(remaining[:i] + remaining[i+1:], path + remaining[i], result) result = set() permute(s, \\"\\", result) return sorted(result)"},{"question":"# Remove Duplicates from a Sorted Array Given a sorted array of integers, your task is to implement a function that removes the duplicates in-place such that each unique element appears only once. It should return the new length of the array and modify the input array to contain the unique elements in the first `n` slots, where `n` is the returned length. The order of the elements should be maintained as in the original array. # Function Signature Implement the function `remove_duplicates` using the following signature: ```python def remove_duplicates(arr: List[int]) -> int: ``` # Parameters 1. **arr (List[int])**: A sorted list of integers. # Returns **int**: The length of the array after removing duplicates. The elements in the array up to this returned length should be unique. # Requirements * The function should modify the input array in place and shouldn\'t use extra space for another array. * The memory usage should be O(1). # Example ```python arr = [1, 1, 2] print(remove_duplicates(arr)) # Output: 2 print(arr[:2]) # Output: [1, 2] arr = [0,0,1,1,1,2,2,3,3,4] print(remove_duplicates(arr)) # Output: 5 print(arr[:5]) # Output: [0, 1, 2, 3, 4] arr = [] print(remove_duplicates(arr)) # Output: 0 print(arr) # Output: [] ``` # Constraints * The array can have between 0 and 10^5 elements. * Each element in the array can have a value between -10^4 and 10^4. * The input array is sorted in non-decreasing order. # Notes * Do not return any array or list; just the length of the unique part of the array. * Since the input array is sorted, you should only need to inspect each element once to achieve the desired result. * Carefully handle edge cases such as empty arrays or arrays with all identical elements. * This will involve utilizing a two-pointer technique to keep track of the unique elements and their positions in the array.","solution":"from typing import List def remove_duplicates(arr: List[int]) -> int: if not arr: return 0 write_index = 1 for read_index in range(1, len(arr)): if arr[read_index] != arr[write_index - 1]: arr[write_index] = arr[read_index] write_index += 1 return write_index"},{"question":"**Problem Statement**: You are tasked with implementing a dynamic array (similar to Python\'s built-in list) that supports automatic resizing as elements are added or removed. This dynamic array class must adhere to the following specifications: # Features to Implement: 1. **Initialization**: - Method: `__init__(self, initial_capacity: int = 10) -> None` - Description: Initializes the dynamic array with the given initial capacity. The default initial capacity should be 10. 2. **Add Element**: - Method: `append(self, element: T) -> None` - Description: Adds an element to the end of the array. If the current capacity is reached, double the array\'s capacity. 3. **Insert Element**: - Method: `insert(self, index: int, element: T) -> None` - Description: Inserts an element at the specified index. If the index is out of bounds, raise an `IndexError`. 4. **Remove Element**: - Method: `remove(self, index: int) -> None` - Description: Removes the element at the specified index. If the index is out of bounds, raise an `IndexError`. If the size after removal is less than a quarter of the capacity, halve the array’s capacity. 5. **Get Element**: - Method: `get(self, index: int) -> T` - Description: Returns the element at the specified index. If the index is out of bounds, raise an `IndexError`. 6. **Set Element**: - Method: `set(self, index: int, element: T) -> None` - Description: Sets the element at the specified index to a new value. If the index is out of bounds, raise an `IndexError`. 7. **Size of Array**: - Method: `size(self) -> int` - Description: Returns the current number of elements in the array. 8. **Capacity of Array**: - Method: `capacity(self) -> int` - Description: Returns the current capacity of the array. # Constraints: - The dynamic array should support generic types (`T`). - Ensure efficient resizing, i.e., doubling and halving the capacity, when adding or removing elements. - The operations should maintain the complexity characteristics of a dynamic array. # Example: ```python # Example Usage dyn_array = DynamicArray[int](5) dyn_array.append(1) dyn_array.append(2) dyn_array.append(3) dyn_array.insert(1, 4) assert dyn_array.get(0) == 1 assert dyn_array.get(1) == 4 assert dyn_array.get(2) == 2 assert dyn_array.size() == 4 assert dyn_array.capacity() == 5 dyn_array.remove(1) assert dyn_array.get(1) == 2 assert dyn_array.size() == 3 assert dyn_array.capacity() == 5 dyn_array.remove(0) dyn_array.remove(0) assert dyn_array.size() == 1 assert dyn_array.capacity() == 2 # Array capacity should shrink assert dyn_array.get(0) == 3 ``` Implement the `DynamicArray` class following the above description and ensuring your implementation passes all necessary edge cases.","solution":"from typing import Generic, TypeVar, List T = TypeVar(\'T\') class DynamicArray(Generic[T]): def __init__(self, initial_capacity: int = 10) -> None: self.capacity = initial_capacity self.size = 0 self.array = [None] * self.capacity def append(self, element: T) -> None: if self.size == self.capacity: self._resize(2 * self.capacity) self.array[self.size] = element self.size += 1 def insert(self, index: int, element: T) -> None: if index < 0 or index > self.size: raise IndexError(\'Index out of bounds\') if self.size == self.capacity: self._resize(2 * self.capacity) for i in range(self.size, index, -1): self.array[i] = self.array[i - 1] self.array[index] = element self.size += 1 def remove(self, index: int) -> None: if index < 0 or index >= self.size: raise IndexError(\'Index out of bounds\') for i in range(index, self.size - 1): self.array[i] = self.array[i + 1] self.array[self.size - 1] = None self.size -= 1 if self.size > 0 and self.size <= self.capacity // 4: self._resize(self.capacity // 2) def get(self, index: int) -> T: if index < 0 or index >= self.size: raise IndexError(\'Index out of bounds\') return self.array[index] def set(self, index: int, element: T) -> None: if index < 0 or index >= self.size: raise IndexError(\'Index out of bounds\') self.array[index] = element def size(self) -> int: return self.size def capacity(self) -> int: return self.capacity def _resize(self, new_capacity: int) -> None: new_array = [None] * new_capacity for i in range(self.size): new_array[i] = self.array[i] self.array = new_array self.capacity = new_capacity"},{"question":"# Problem Description You are tasked with implementing a function that checks whether a given integer is a Carmichael number. Carmichael numbers are composite numbers (non-prime) that satisfy specific properties in modular arithmetic, making them pseudo-primes for one or more bases. Implement a function `is_carmichael_number` to determine if the given integer is a Carmichael number. **Function Signature**: ```python def is_carmichael_number(n: int) -> bool: pass ``` # Input * An integer `n` (n > 1) # Output * Return `True` if the integer is a Carmichael number, otherwise return `False`. # Constraints * Ensure the function handles large input values efficiently. # Example **Example 1**: ```python assert is_carmichael_number(561) == True ``` Explanation: 561 is a known Carmichael number. **Example 2**: ```python assert is_carmichael_number(1105) == True ``` Explanation: 1105 is a known Carmichael number. **Example 3**: ```python assert is_carmichael_number(1729) == True ``` Explanation: 1729 is a known Carmichael number. **Example 4**: ```python assert is_carmichael_number(15) == False ``` Explanation: 15 is not a Carmichael number. # Notes * A Carmichael number is defined as a composite number ( n ) that satisfies ( b^{n-1} equiv 1 mod n ) for all integers ( b ) that are coprime to ( n ). * Utilize an efficient algorithm to check composite status and the Carmichael number properties. * Employ techniques such as the Miller-Rabin primality test and modular exponentiation to ensure efficiency.","solution":"def gcd(a, b): while b: a, b = b, a % b return a def is_composite(n): if n < 4: return False if n % 2 == 0 or n % 3 == 0: return True i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return True i += 6 return False def is_carmichael_number(n: int) -> bool: if n < 2 or not is_composite(n): return False for b in range(2, n): if gcd(b, n) == 1: if pow(b, n - 1, n) != 1: return False return True"},{"question":"# Problem Statement: Reversing a String Preserving Alphanumeric Characters In this problem, you are required to write a function that takes a string and reverses the order of its alphanumeric characters while leaving any non-alphanumeric characters in their original positions. Function Signature ```python def reverse_preserve_non_alpha(string: str) -> str: Given a string, return a new string with the order of the alphanumeric characters reversed and non-alphanumeric characters left in their original positions. Parameters: string (str): The input string containing alphanumeric and non-alphanumeric characters. Returns: str: The string with alphanumeric characters reversed and non-alphanumeric characters preserved. Raises: ValueError: If the input is not a string. pass ``` Examples ```python reverse_preserve_non_alpha(\\"a!b.c\\") # Output: \\"c!b.a\\" reverse_preserve_non_alpha(\\"123-abc\\") # Output: \\"cba-321\\" reverse_preserve_non_alpha(\\"a1b2c3\\") # Output: \\"3c2b1a\\" reverse_preserve_non_alpha(\\"@hello#\\") # Output: \\"@olleh#\\" reverse_preserve_non_alpha(\\"\\") # Output: \\"\\" ``` Constraints * The input should be a valid string. Raises a `ValueError` for any non-string inputs. * The function should handle an empty string, returning an empty string as output. * Only alphanumeric characters are reversed. Special characters (e.g., punctuation, spaces) remain in their original positions. * The function should be efficient in terms of time and space complexity. Notes * Ensure proper validation of the input. * Emphasize maintaining O(n) time complexity and O(n) space complexity where n is the length of the string.","solution":"def reverse_preserve_non_alpha(string: str) -> str: Given a string, return a new string with the order of the alphanumeric characters reversed and non-alphanumeric characters left in their original positions. if not isinstance(string, str): raise ValueError(\\"Input must be a string\\") # Filtering alphanumeric characters alphanumeric_chars = [c for c in string if c.isalnum()] # Reversing the list of alphanumeric characters alphanumeric_chars.reverse() # Constructing the final result result = [] alphanumeric_index = 0 for char in string: if char.isalnum(): result.append(alphanumeric_chars[alphanumeric_index]) alphanumeric_index += 1 else: result.append(char) return \'\'.join(result)"},{"question":"Employee Schedule Adjustment You are tasked with developing an automated system for a company to manage its employees\' work schedules. In this system, each employee is assigned a list of work shifts, represented as pairs of integers where the first integer is the start time and the second integer is the end time of the shift (24-hour format). Sometimes, the shifts overlap, and the goal is to merge overlapping shifts and provide a non-overlapping schedule for each employee. # Requirements 1. **Function to Merge Shifts**: Write a function `merge_shifts` that takes a list of pairs of integers and returns a new list of pairs where overlapping shifts have been merged. - **Input**: - `shifts`: a list of tuples, where each tuple contains two integers representing the start and end times of a shift. - **Output**: - A list of tuples representing the merged, non-overlapping shifts. # Constraints - The start and end times will be integers within the range [0, 23]. - The list may contain between 1 and 100 shifts. - A shift always starts before it ends (start time < end time). # Example ```python merge_shifts([(9, 12), (11, 14), (16, 18), (18, 20)]) ``` Expected Output: ```python [(9, 14), (16, 20)] ``` # Notes - If a shift is within another shift, it should be merged into the outer shift. - Consider edge cases such as a shift that ends as another shift starts. - Ensure the returned list of shifts is sorted by start times for consistency.","solution":"def merge_shifts(shifts): Merges overlapping shifts into non-overlapping shifts in a sorted order. Parameters: - shifts: List of tuples, where each tuple contains two integers representing the start and end times of a shift. Returns: - A list of merged, non-overlapping shifts sorted by start times. if not shifts: return [] # Sort shifts by start time shifts.sort() merged_shifts = [shifts[0]] for current in shifts[1:]: last = merged_shifts[-1] if current[0] <= last[1]: # Overlapping shifts merged_shifts[-1] = (last[0], max(last[1], current[1])) else: merged_shifts.append(current) return merged_shifts"},{"question":"# Grouped Anagrams Finder **Context:** In a menu planning application, we have a list of ingredient names. For organizational purposes, we want to group together all the ingredients that are anagrams of each other. # Task: Write a function, `group_anagrams`, that takes a list of ingredient names and groups them into lists of anagrams. # Requirements: * Input: * `ingredients` (List[str]): A list of ingredient names. * Output: * Return a list of lists, where each sublist contains ingredient names that are anagrams of each other. # Constraints: * All ingredient names contain only lower-case alphabetic characters. * Each ingredient name is at most 100 characters long. * The list of ingredients has at most 1000 names. # Example: ```python def group_anagrams(ingredients: List[str]) -> List[List[str]]: >>> group_anagrams([\'maple\', \'leap\', \'beta\', \'abe\', \'peal\', \'abet\']) [[\'maple\'], [\'leap\', \'peal\'], [\'beta\', \'abet\'], [\'abe\']] pass ``` # Additional Notes: 1. Ensure your solution prints the final output in the same format as the example. 2. The order of the groups and the order of the anagram pairs within the groups does not matter. 3. Use a dictionary to efficiently group anagrams during the implementation. 4. Handle edge cases where the list may contain no ingredients or only one ingredient. **Testing:** Use the provided example to validate your function implementation and add additional tests to cover edge cases and constraints.","solution":"from typing import List from collections import defaultdict def group_anagrams(ingredients: List[str]) -> List[List[str]]: Groups the ingredient names into lists of anagrams. Parameters: ingredients (List[str]): A list of ingredient names. Returns: List[List[str]]: A list of lists, where each sublist contains ingredient names that are anagrams of each other. anagrams = defaultdict(list) for ingredient in ingredients: # Sort the characters in the ingredient to form the key key = \'\'.join(sorted(ingredient)) anagrams[key].append(ingredient) # Return the values of the dictionary as a list of lists return list(anagrams.values())"},{"question":"# Problem Statement Write a function that takes a list of integers and recursively calculates the sum of all elements in the list. The function should not use any iterative structures (e.g., loops) and should only utilize recursion. # Function Signature ```python def recursive_sum(arr: list) -> int: ``` # Input - A list `arr` containing integers. # Output - An integer representing the sum of all elements in the list `arr`. # Constraints - `0 <= len(arr) <= 1000` - Each integer in the list can be between `-10^6` and `10^6`. # Example ```python assert recursive_sum([1, 2, 3, 4, 5]) == 15 assert recursive_sum([10, -10, 20]) == 20 assert recursive_sum([]) == 0 assert recursive_sum([100]) == 100 ``` # Explanation For the list `[1, 2, 3, 4, 5]`: 1. The sum is calculated as `1 + (2 + (3 + (4 + (5))))` which equals `15`. # Edge Cases to Consider - An empty list should return `0`. - A list with a single element should return that element. - The function should handle both positive and negative integers. Implement the function ensuring it utilizes recursion effectively and handles the base case appropriately.","solution":"def recursive_sum(arr): if not arr: return 0 return arr[0] + recursive_sum(arr[1:])"},{"question":"# Minimum Number of Platforms Required You are given an array of train arrival times and an array of train departure times at a railway station. Your task is to determine the minimum number of platforms required so that no train waits. Each train requires one platform on arrival and keeps occupying the platform until it departs. Function Signature ```python def minimum_platforms(arrivals: list[str], departures: list[str]) -> int: ``` # Input * Two lists of strings `arrivals` and `departures`, each containing n elements (1 ≤ n ≤ 10^5), representing train arrival and departure times respectively. * Each time is in the \\"HH:MM\\" format (24-hour). * It is guaranteed that all arrival times are before their corresponding departure times for each train. # Output * Return the minimum number of platforms required as an integer. # Constraints * The time will be in the valid \\"HH:MM\\" 24-hour format. * The lists may contain overlapping times. # Performance Requirements * Your implementation should run in O(n log n) time complexity. # Example ```python print(minimum_platforms([\\"09:00\\", \\"09:40\\", \\"09:50\\"], [\\"09:10\\", \\"12:00\\", \\"10:30\\"])) # Output: 2 print(minimum_platforms([\\"10:00\\", \\"11:00\\", \\"11:10\\", \\"12:00\\", \\"16:30\\", \\"17:20\\"], [\\"10:30\\", \\"11:30\\", \\"12:00\\", \\"13:00\\", \\"17:00\\", \\"20:00\\"])) # Output: 2 ``` # Edge Cases to Consider * If there is only one train, the result should be 1. * Ensure proper handling of midnight (\\"00:00\\"). * Schedules where all trains arrive and depart at different times from each other require the platform count to be 1. * Cases where all trains are present at the station simultaneously will need a number of platforms equal to the number of trains.","solution":"def minimum_platforms(arrivals: list[str], departures: list[str]) -> int: # Convert time strings to minutes since midnight for easier comparison def time_to_minutes(t): hours, minutes = map(int, t.split(\':\')) return hours * 60 + minutes arrival_times = sorted(time_to_minutes(arrival) for arrival in arrivals) departure_times = sorted(time_to_minutes(departure) for departure in departures) platforms_needed = 0 max_platforms = 0 i = 0 j = 0 while i < len(arrival_times) and j < len(departure_times): if arrival_times[i] < departure_times[j]: platforms_needed += 1 max_platforms = max(max_platforms, platforms_needed) i += 1 else: platforms_needed -= 1 j += 1 return max_platforms"},{"question":"# Question: Implement a Circular Buffer with Dynamic Resizing You are required to implement a circular buffer (also known as a ring buffer) that supports dynamic resizing. The circular buffer should allow new elements to be added and old elements to be overwritten when the buffer becomes full. Additionally, you must implement methods to resize the buffer dynamically when necessary. # Requirements: 1. **Initialization**: Initialize the buffer with a given size. 2. **Add Element**: Implement a method `add(self, item: int) -> None` that adds an element to the buffer. - If the buffer is full, the oldest element should be overwritten. 3. **Get All Elements**: Implement a method `get_all(self) -> List[int]` that returns all elements in the buffer in the order they were added. 4. **Resize Buffer**: Implement a method `resize(self, new_size: int) -> None` that resizes the buffer to the new size. If the new size is smaller, discard the oldest elements. # Implementation: Class Definition: ```python class CircularBuffer: def __init__(self, size: int) -> None: self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.count = 0 def add(self, item: int) -> None: Adds an item to the buffer. If the buffer is full, the oldest item is overwritten. :param item: the item to add to the buffer def get_all(self) -> List[int]: Returns all elements in the buffer in the order they were added. :return: list of elements in the buffer def resize(self, new_size: int) -> None: Resizes the buffer to the new size. If the new size is smaller than the current number of elements, discard the oldest elements. :param new_size: the new size of the buffer ``` Expected Input/Output: 1. **add(self, item: int) -> None** - **Input**: An integer `item`. - **Output**: None. - **Example**: ```python buffer.add(1) buffer.add(2) buffer.add(3) ``` If the buffer size is 3, the buffer now contains `[1, 2, 3]`. 2. **get_all(self) -> List[int]** - **Input**: None. - **Output**: List of all elements in the buffer in the order they were added. - **Example**: ```python buffer.get_all() ``` If the buffer contains `[1, 2, 3]`, the output should be: ```python [1, 2, 3] ``` 3. **resize(self, new_size: int) -> None** - **Input**: An integer `new_size`. - **Output**: None. - **Example**: ```python buffer.resize(5) buffer.add(4) buffer.add(5) buffer.add(6) buffer.get_all() ``` If the buffer was originally `[1, 2, 3]` and resized to 5, after adding elements 4, 5, and 6, the output should be: ```python [1, 2, 3, 4, 5] ``` # Constraints: 1. The buffer must efficiently handle insertion and retrieval operations. 2. The resize operation must adjust the buffer without losing the most recently added elements. 3. The buffer should maintain optimal memory usage after resizing. # Performance Requirements: 1. Addition of elements should be O(1). 2. Retrieval of all elements should be O(n), where n is the current number of elements in the buffer. 3. Resizing should be efficient, and minimal data should be moved when increasing or decreasing size.","solution":"class CircularBuffer: def __init__(self, size: int) -> None: self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.count = 0 def add(self, item: int) -> None: Adds an item to the buffer. If the buffer is full, the oldest item is overwritten. :param item: the item to add to the buffer self.buffer[self.end] = item self.end = (self.end + 1) % self.size if self.count < self.size: self.count += 1 else: self.start = (self.start + 1) % self.size def get_all(self) -> list: Returns all elements in the buffer in the order they were added. :return: list of elements in the buffer result = [] index = self.start for _ in range(self.count): result.append(self.buffer[index]) index = (index + 1) % self.size return result def resize(self, new_size: int) -> None: Resizes the buffer to the new size. If the new size is smaller than the current number of elements, discard the oldest elements. :param new_size: the new size of the buffer new_buffer = [None] * new_size current_elements = self.get_all() if new_size < self.count: current_elements = current_elements[-new_size:] self.size = new_size self.buffer = new_buffer for i, item in enumerate(current_elements): self.buffer[i] = item self.start = 0 self.end = len(current_elements) self.count = len(current_elements)"},{"question":"# Coding Assessment Question Context You are working on an algorithm that helps analyze connectivity in networks. One of the major operations involves checking reachability between different nodes in a given network. The network is represented as an undirected graph where nodes represent users and edges represent connections between them. Given the size of the network, the adjacency list representation is used for efficiency. Task Write a function `is_reachable` that, given an adjacency list representation of an undirected graph and two nodes, determines if there is a path between the two nodes. # Function Signature ```python def is_reachable( adj_list: Dict[int, List[int]], start: int, end: int ) -> bool: Checks if there is a path between two nodes in an undirected graph. Args: adj_list: A dictionary where keys are node identifiers and values are lists of adjacent nodes. start: An integer representing the starting node. end: An integer representing the target node. Returns: bool: True if a path exists between start and end nodes, False otherwise. ``` # Input and Output Format - **Input**: - `adj_list`: A dictionary where keys are integers representing node identifiers and values are lists of integers representing adjacent nodes. - `start`: An integer representing the starting node. - `end`: An integer representing the target node. - **Output**: A boolean value, `True` if a path exists between the `start` and `end` nodes, and `False` otherwise. # Constraints - Assume nodes identifiers are integers between 0 and 10^5. - The graph may contain up to 10^6 edges. - The graph is undirected and there are no parallel edges. - The `adj_list` represents all nodes, even those without any connections (sparse nodes). # Example ```python adj_list = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2] } start = 0 end = 3 print(is_reachable(adj_list, start, end)) # Expected output: True ``` ```python adj_list = { 0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3] } start = 0 end = 4 print(is_reachable(adj_list, start, end)) # Expected output: False ``` Hints 1. Use BFS or DFS to explore the graph from the start node. 2. Maintain a visited set to avoid reprocessing nodes. 3. If you encounter the end node during your graph traversal, return `True`. If the traversal completes without encountering the end node, return `False`. # Notes - Ensure your solution can handle large graphs efficiently in terms of both time and space complexity. - Consider edge cases such as poorly connected graph sections and isolated nodes.","solution":"def is_reachable(adj_list, start, end): Checks if there is a path between two nodes in an undirected graph. Args: adj_list: A dictionary where keys are node identifiers and values are lists of adjacent nodes. start: An integer representing the starting node. end: An integer representing the target node. Returns: bool: True if a path exists between start and end nodes, False otherwise. if start == end: return True visited = set() stack = [start] while stack: node = stack.pop() if node == end: return True if node not in visited: visited.add(node) for neighbor in adj_list[node]: if neighbor not in visited: stack.append(neighbor) return False"},{"question":"# Coding Assessment Question **Scenario**: You are designing a network where each node represents a computer and each edge has a weight representing the bandwidth between two nodes. The network must be configured to ensure maximum efficiency in data transmission. A critical part of this configuration is determining the Minimum Spanning Tree (MST) of the network graph. **Task**: Implement the `NetworkGraph` class, which includes the following methods: 1. **add_edge**: ```python def add_edge(self, u: int, v: int, w: int) -> None: ``` - **Input**: - `u` (int): Starting node of the edge. - `v` (int): Ending node of the edge. - `w` (int): Weight of the edge. - **Output**: None 2. **find_mst**: ```python def find_mst(self) -> list[tuple[int, int, int]]: ``` - **Output**: List of edges forming the MST, where each edge is represented as a tuple `(u, v, w)`. **Constraints**: - The number of nodes in the graph will not exceed `1000`. - The weight of each edge will be an integer within the range `[1, 10000]`. **Example**: ```python # Create a NetworkGraph instance network = NetworkGraph(4) # Add edges to the graph network.add_edge(0, 1, 10) network.add_edge(0, 2, 6) network.add_edge(0, 3, 5) network.add_edge(1, 3, 15) network.add_edge(2, 3, 4) # Find the MST mst = network.find_mst() print(mst) # Output: [(0, 3, 5), (2, 3, 4), (0, 1, 10)] ``` # Explanation: In this problem, you need to design a `NetworkGraph` class to build a graph using nodes and weighted edges. You must implement a method to add edges to the graph and a method to compute the Minimum Spanning Tree (MST) using Kruskal\'s algorithm or Prim\'s algorithm. The `add_edge` method will allow you to add edges between nodes with specific weights, and the `find_mst` method will return a list of edges that form the MST, ensuring that all nodes are connected with the minimum possible total edge weight.","solution":"class NetworkGraph: def __init__(self, vertices): self.vertices = vertices self.edges = [] def add_edge(self, u: int, v: int, w: int) -> None: self.edges.append((u, v, w)) def find_mst(self) -> list[tuple[int, int, int]]: # Implementing Kruskal\'s Algorithm self.edges.sort(key=lambda edge: edge[2]) parent = list(range(self.vertices)) def find(x): if parent[x] == x: return x else: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX mst = [] for u, v, w in self.edges: if find(u) != find(v): union(u, v) mst.append((u, v, w)) return mst"},{"question":"# Problem Statement You are responsible for creating a scheduling tool for a project management system. This tool will work with tasks, dependencies, and schedules. Your task is to extend the capabilities of the `TaskScheduler` class specifically in the following areas: 1. Determine the order in which tasks should be executed given their dependencies. 2. Identify any circular dependencies within the tasks. 3. Calculate the earliest possible completion time for all tasks given their durations. # Task Requirements 1. Implement three new methods in the `TaskScheduler` class: * `task_order(self) -> list[str]`: Returns a list of task names representing the order in which tasks should be executed. If a circular dependency exists, return an empty list. * `has_circular_dependency(self) -> bool`: Returns `True` if there is any circular dependency between tasks, otherwise returns `False`. * `earliest_completion_time(self) -> int`: Returns an integer representing the earliest possible completion time for all tasks, considering the tasks\' durations and dependencies. # Input - Tasks are represented as a dictionary where keys are task names (strings) and values are the duration of the task (integers). - Dependencies are managed using the `add_dependency(self, task1: str, task2: str)` method where `task1` is dependent on `task2`. # Output - For `task_order`, return a list of task names. - For `has_circular_dependency`, return a boolean. - For `earliest_completion_time`, return an integer. # Constraints 1. The system can have up to `10^4` tasks. 2. Each task name will be unique. 3. Each task can have up to `10^3` dependencies. # Example ```python scheduler = TaskScheduler() scheduler.add_task(\'A\', 3).add_task(\'B\', 2).add_task(\'C\', 1).add_task(\'D\', 4) scheduler.add_dependency(\'B\', \'A\').add_dependency(\'C\', \'B\').add_dependency(\'D\', \'C\') # Example usage: print(scheduler.task_order()) # Output: [\'A\', \'B\', \'C\', \'D\'] print(scheduler.has_circular_dependency()) # Output: False print(scheduler.earliest_completion_time()) # Output: 10 ``` Implement the methods in such a way that they are efficient and handle the constraints mentioned.","solution":"from collections import defaultdict, deque class TaskScheduler: def __init__(self): self.tasks = {} self.dependencies = defaultdict(list) self.in_degree = defaultdict(int) def add_task(self, name: str, duration: int): self.tasks[name] = duration if name not in self.in_degree: self.in_degree[name] = 0 return self def add_dependency(self, task1: str, task2: str): self.dependencies[task2].append(task1) self.in_degree[task1] += 1 return self def task_order(self) -> list[str]: result = [] zero_in_degree = deque([task for task in self.tasks if self.in_degree[task] == 0]) while zero_in_degree: current = zero_in_degree.popleft() result.append(current) for dependent in self.dependencies[current]: self.in_degree[dependent] -= 1 if self.in_degree[dependent] == 0: zero_in_degree.append(dependent) return result if len(result) == len(self.tasks) else [] def has_circular_dependency(self) -> bool: return len(self.task_order()) == 0 def earliest_completion_time(self) -> int: order = self.task_order() if not order: return -1 # Circular dependency exists completion_time = {task: 0 for task in self.tasks} for task in order: task_time = self.tasks[task] for dependent in self.dependencies[task]: completion_time[dependent] = max(completion_time[dependent], completion_time[task] + task_time) return max(completion_time[task] + self.tasks[task] for task in self.tasks)"},{"question":"# Question You have been tasked with implementing a function that multiplies two non-negative integers using bitwise operations. The function should take two non-negative integers and return their product without using the \'*\' operator or any external libraries. Function Signature ```python def bitwise_multiplication(number: int, other_number: int) -> int: pass ``` Input * `number` (int): A non-negative integer. * `other_number` (int): A non-negative integer. Output * (int): The product of the two numbers. Constraints * Both `number` and `other_number` are within the range of 0 to 10^9. * Both inputs are guaranteed to be integers and non-negative. Performance Requirements * Your function should have the time complexity of O(n*m), where n and m are the numbers of bits in `number` and `other_number` respectively. * Space complexity should be O(1). Example ```python >>> bitwise_multiplication(4, 5) 20 >>> bitwise_multiplication(8, 9) 72 >>> bitwise_multiplication(0, 4) 0 ``` Additional Notes The solution should handle the multiplication process manually using bitwise shifts and additions without using direct multiplication operators.","solution":"def bitwise_multiplication(number: int, other_number: int) -> int: Multiplies two non-negative integers using bitwise operations. Args: number (int): The first non-negative integer. other_number (int): The second non-negative integer. Returns: int: The product of the two numbers. result = 0 while other_number > 0: if other_number & 1: result += number number <<= 1 other_number >>= 1 return result"},{"question":"# Question: String Permutation Pair Validator Objective Implement a solution to determine if a pair of strings are permutations of each other. If they are, return `True`; otherwise, return `False`. Task 1. **Implement a function, `are_permutations(s1: str, s2: str) -> bool`,** that checks if two strings are permutations of each other. Permutations are strings that contain the same characters with identical frequency counts. Function Signature ```python def are_permutations(s1: str, s2: str) -> bool: # Check if the two strings are permutations pass ``` Expected Input and Output - **Input**: Two strings `s1` and `s2`. - **Output**: A boolean value indicating if `s1` and `s2` are permutations of each other. Constraints - The strings can contain any ASCII characters. - The length of the strings will not exceed 100,000 characters. Example ```python >>> are_permutations(\\"abc\\", \\"bca\\") True >>> are_permutations(\\"abc\\", \\"def\\") False >>> are_permutations(\\"apple\\", \\"papel\\") True >>> are_permutations(\\"apple\\", \\"appe\\") False ``` Explanation - For `\\"abc\\"` and `\\"bca\\"`, they are permutations as they contain the same characters with the same frequencies. - For `\\"abc\\"` and `\\"def\\"`, they are not permutations as they contain different characters. - For `\\"apple\\"` and `\\"papel\\"`, they are permutations as they contain the same characters with the same frequencies. - For `\\"apple\\"` and `\\"appe\\"`, they are not permutations as they are of differing lengths.","solution":"def are_permutations(s1: str, s2: str) -> bool: Checks if two strings are permutations of each other. :param s1: First string :param s2: Second string :return: True if they are permutations, False otherwise if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Coding Question Scenario You have been asked to implement a feature for a library management system that classifies books based on their International Standard Book Number (ISBN). The system needs to sort a list of ISBNs, which are represented as strings. ISBNs can have 10 or 13 digits and may contain hyphens. Objective Implement the `sort_isbn_list` function that sorts a list of ISBNs in lexicographical order. Assume that valid ISBNs (with or without hyphens) will be provided as input. Function Signature ```python def sort_isbn_list(isbn_list: list[str]) -> list[str]: ``` Input * A list of strings, where each string represents a valid ISBN of either 10 or 13 digits and may include hyphens. Output * A list of strings, representing ISBNs sorted in lexicographical order. Constraints * The list can contain between 0 and 10^5 ISBNs. * Each ISBN is guaranteed to be valid and properly formatted. * The input list may be empty. Example ```python assert sort_isbn_list([\'978-3-16-148410-0\', \'0-0605-008-26\', \'9783161484100\']) == [\'0-0605-008-26\', \'9783161484100\', \'978-3-16-148410-0\'] assert sort_isbn_list([]) == [] assert sort_isbn_list([\'111222333X\', \'111-222-333X\', \'111 222 333X\']) == [\'111 222 333X\', \'111-222-333X\', \'111222333X\'] ``` Constraints & Performance Requirements * The function should efficiently handle the maximum input size. * ISBNs must be sorted considering their natural ordering with respect to lexicography. * Ensure the solution considers both formats uniformly (with and without hyphens). Instructions 1. Implement the function `sort_isbn_list`. 2. Write your implementation to pass all the given example cases. 3. Keep in mind edge cases and performance considerations discussed in the analysis.","solution":"def sort_isbn_list(isbn_list: list[str]) -> list[str]: Sorts a list of ISBNs in lexicographical order. Args: - isbn_list: A list of ISBN strings, each of 10 or 13 digits, possibly containing hyphens. Returns: - A list of sorted ISBN strings. return sorted(isbn_list)"},{"question":"# Problem Statement You need to implement a function `max_zeros_subarray` that finds the longest contiguous subarray with the maximum number of zeros in a given binary array (an array consisting only of 0s and 1s). If there are multiple subarrays meeting this condition, return the one that appears first. # Input - A list of integers `binary_array` where each element is either 0 or 1 and the length of the array is between 0 and 1000 inclusive. # Output - A list of integers representing the longest contiguous subarray with the maximum number of zeros. # Constraints 1. The length of the array will be between 0 and 1000 inclusive. 2. Each element of the array is either 0 or 1. # Examples ```python max_zeros_subarray([1, 0, 0, 1, 0, 0, 0]) # Output: [0, 0, 0] max_zeros_subarray([1, 1, 1, 1]) # Output: [] max_zeros_subarray([0, 0, 0, 1, 0]) # Output: [0, 0, 0] max_zeros_subarray([0, 1, 1, 0, 0, 0]) # Output: [0, 0, 0] max_zeros_subarray([0, 0, 1, 0, 0, 0, 0]) # Output: [0, 0, 0, 0] ``` # Performance Requirements Ensure that your solution runs efficiently within the given constraints. The expected time complexity is (O(n)). # Submission Compose a function `max_zeros_subarray` that accurately fulfills the above requirements.","solution":"def max_zeros_subarray(binary_array): Finds the longest contiguous subarray with the maximum number of zeros. Args: binary_array (list of int): List of integers containing only 0s and 1s. Returns: list of int: The longest contiguous subarray with the maximum number of zeros. max_len = 0 max_start_index = None current_len = 0 current_start_index = None for index, value in enumerate(binary_array): if value == 0: if current_start_index is None: current_start_index = index current_len += 1 else: if current_len > max_len: max_len = current_len max_start_index = current_start_index current_start_index = None current_len = 0 # Final check at the end of the list if current_len > max_len: max_len = current_len max_start_index = current_start_index if max_start_index is not None: return binary_array[max_start_index:max_start_index + max_len] else: return []"},{"question":"# Temperature Conversion with Input Validation You are required to write a function that converts temperature values between Celsius and Fahrenheit. Your function should also validate the input to ensure it is within logical boundaries for temperature values that are physically possible on Earth. # Problem Description Create a function `convert_temperature` that converts a temperature value from Celsius to Fahrenheit or vice versa. Additionally, the function should validate the input temperature such that it falls within the range of -273.15°C to 1,000°C for Celsius and -459.67°F to 1,832°F for Fahrenheit. # Requirements 1. The function should accept a temperature value and the target unit (\'C\' for Celsius and \'F\' for Fahrenheit). 2. Validate the input temperature to ensure it falls within the specified logical boundaries. 3. If the input value is out of bounds, raise a `ValueError` with the message: \\"Temperature out of logical range\\". # Function Signature ```python def convert_temperature(value: float, to_unit: str) -> float: ``` # Input * `value` (float): The temperature value to be converted. * `to_unit` (str): The unit to convert the temperature to. It can be \'C\' for Celsius or \'F\' for Fahrenheit. # Output * The function should return a float representing the converted temperature value in the specified unit. # Constraints 1. Temperature value should be validated within the given ranges for Celsius and Fahrenheit. 2. If `to_unit` is not \'C\' or \'F\', raise a `ValueError` with the message: \\"Invalid target unit\\". # Example ```python def convert_temperature(value: float, to_unit: str) -> float: >>> convert_temperature(0, \'F\') 32.0 >>> convert_temperature(32, \'C\') 0.0 >>> convert_temperature(-273.15, \'F\') -459.67 >>> convert_temperature(100, \'F\') 212.0 >>> convert_temperature(212, \'C\') 100.0 >>> convert_temperature(-500, \'F\') Traceback (most recent call last): ... ValueError: Temperature out of logical range >>> convert_temperature(50, \'X\') Traceback (most recent call last): ... ValueError: Invalid target unit if to_unit == \'C\': if value < -459.67 or value > 1832: raise ValueError(\\"Temperature out of logical range\\") return (value - 32) * 5/9 elif to_unit == \'F\': if value < -273.15 or value > 1000: raise ValueError(\\"Temperature out of logical range\\") return (value * 9/5) + 32 else: raise ValueError(\\"Invalid target unit\\") ``` # Note - Ensure that the function adheres to the requirements and validates the input correctly. - Implement appropriate error handling to deal with invalid input cases. - Utilize consistent coding practices akin to the original set of questions.","solution":"def convert_temperature(value: float, to_unit: str) -> float: Converts a temperature value from Celsius to Fahrenheit or vice versa. Args: - value (float): The temperature value to be converted. - to_unit (str): The unit to convert the temperature to. It can be \'C\' for Celsius or \'F\' for Fahrenheit. Returns: - float: The converted temperature value. Raises: - ValueError: If the input temperature is out of logical range or if the target unit is invalid. if to_unit == \'C\': if value < -459.67 or value > 1832: raise ValueError(\\"Temperature out of logical range\\") return (value - 32) * 5/9 elif to_unit == \'F\': if value < -273.15 or value > 1000: raise ValueError(\\"Temperature out of logical range\\") return (value * 9/5) + 32 else: raise ValueError(\\"Invalid target unit\\")"},{"question":"# Question: Creating an Efficient Dijkstra’s Algorithm Implementation **Scenario:** You are working on a navigation system that needs to calculate the shortest path in a weighted graph where the nodes represent landmarks and the edges represent roads with different distances. A previous implementation of Dijkstra’s algorithm is in place, but it only works efficiently for small graphs and suffers from performance issues for larger datasets. **Task:** Implement a function `dijkstra_algorithm` that computes the shortest path from a starting node to all other nodes in a weighted graph using Dijkstra’s algorithm. Your implementation should utilize a priority queue to optimize performance. **Function Signature:** ```python def dijkstra_algorithm(graph: Dict[int, List[Tuple[int, int]]], start_node: int) -> Dict[int, int]: pass ``` **Input:** - `graph` (dict): A dictionary where keys are node identifiers (int) and values are lists of tuples `(neighbor, weight)` representing the adjacent nodes and edge weights. - `start_node` (int): The starting node identifier. **Output:** - (dict): A dictionary where keys are node identifiers and values are the shortest distance from the `start_node` to that node. **Constraints:** - `graph` contains at least one node. - Nodes and weights are non-negative integers. - `start_node` is a valid key in the graph. **Example:** ```python >>> graph = { >>> 0: [(1, 4), (2, 1)], >>> 1: [(3, 1)], >>> 2: [(1, 2), (3, 5)], >>> 3: [] >>> } >>> dijkstra_algorithm(graph, 0) {0: 0, 1: 3, 2: 1, 3: 4} ``` **Explanation:** Your function `dijkstra_algorithm` will compute the shortest path from the `start_node` to all other nodes in the graph. The output dictionary will contain the shortest distances from the starting node to each node in the graph. The priority queue should be used to ensure that the shortest path calculations are performed efficiently.","solution":"from typing import Dict, List, Tuple import heapq def dijkstra_algorithm(graph: Dict[int, List[Tuple[int, int]]], start_node: int) -> Dict[int, int]: Compute the shortest path from start_node to all other nodes in a weighted graph. :param graph: A dictionary where keys are node identifiers and values are lists of tuples (neighbor, weight) :param start_node: The starting node identifier :return: A dictionary where keys are node identifiers and values are the shortest distance from the start_node # Distance dictionary to store the shortest path from start_node to each node distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 # Priority queue to determine the next node to process priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the distance is greater than the recorded shortest path, continue if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Question: Validate Graph Bipartiteness Given a graph represented as an adjacency list, write a function to determine whether the graph is bipartite. A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets (U) and (V) such that every edge connects a vertex in (U) to one in (V). Implement the `is_bipartite` function. Function Signature ```python def is_bipartite(graph: Dict[int, List[int]]) -> bool: pass ``` Inputs - `graph (Dict[int, List[int]])`: Adjacency list where the keys are vertices and values are lists of adjacent vertices. Outputs - Returns `True` if the graph is bipartite, otherwise returns `False`. Constraints - The number of vertices in the graph is between 1 and 1000. - Each vertex is an integer, and the adjacency list properly represents all edges of the graph. - The graph might be disconnected. Implementation Details 1. Use Breadth-First Search (BFS) or Depth-First Search (DFS) to try and color the vertices in two colors. 2. If it is possible to color the graph using two colors without conflict, the graph is bipartite. Example ```python def is_bipartite(graph: Dict[int, List[int]]) -> bool: # Implement the bipartiteness checking algorithm pass # Example Test Cases graph1 = { 0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2] } print(is_bipartite(graph1)) # Output: True graph2 = { 0: [1, 2], 1: [0, 2], 2: [0, 1] } print(is_bipartite(graph2)) # Output: False ``` Hints 1. If you encounter an uncolored node, color it with one color and proceed to color its neighbors with the opposite color. 2. If you find a neighbor with the same color during traversal, the graph is not bipartite.","solution":"from collections import deque def is_bipartite(graph): Returns True if the graph is bipartite, otherwise False. color = {} def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() current_color = color[node] next_color = 1 - current_color for neighbor in graph[node]: if neighbor not in color: color[neighbor] = next_color queue.append(neighbor) elif color[neighbor] == current_color: return False return True for node in graph: if node not in color: if not bfs(node): return False return True"},{"question":"# Question: Check If Power of Four Write a function to check if a given integer is a power of four. The function should return `True` if the number is a power of four, and `False` otherwise. Function Definition ```python def is_power_of_four(number: int) -> bool: Checks if a given integer is a power of four. Arguments: number -- an integer to be checked. Returns: True if the integer is a power of four, otherwise False. ``` Input Format - A single integer, `number`, which should be an integer. It can be positive, negative, or zero. Output Format - A boolean value: `True` if the number is a power of four, otherwise `False`. Constraints - The function should raise a `TypeError` if the input is not an integer. # Example Input/Output ```python is_power_of_four(16) # Output: True is_power_of_four(1) # Output: True is_power_of_four(0) # Output: False is_power_of_four(5) # Output: False is_power_of_four(-64) # Output: False ``` Additional Notes - Do not use any built-in functions or libraries that directly determine if a number is a power of four. - You may use mathematical operations and bitwise operations to determine if a number is a power of four.","solution":"def is_power_of_four(number: int) -> bool: Checks if a given integer is a power of four. Arguments: number -- an integer to be checked. Returns: True if the integer is a power of four, otherwise False. if not isinstance(number, int): raise TypeError(\\"The input must be an integer.\\") if number <= 0: return False while number % 4 == 0: number /= 4 return number == 1"},{"question":"# Task Write a function `find_missing_number` that finds the single missing number from a given list containing `n` distinct numbers taken from the range `[0, n]`. The list does not contain any duplicates. # Function Signature ```python def find_missing_number(nums: list[int]) -> int: ``` # Input * `nums`: A list of `n` distinct integers taken from the range `[0, n+1]` (inclusive). # Output * Returns an integer representing the missing number from the range `[0, n]`. # Constraints * The length of the list `nums` will be `n` where `1 <= n <= 10^4`. * All elements in `nums` will be distinct integers within the range `[0, n]`. # Requirements Your solution should: * Handle the given constraints efficiently. * Be able to find the missing number in linear time `O(n)` and constant space `O(1)`. # Examples ```python >>> find_missing_number([0, 1, 3]) 2 >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0]) 1 >>> find_missing_number([1]) 0 >>> find_missing_number([0, 2]) 1 >>> find_missing_number([0, 1, 2, 3, 4, 5, 6, 8, 9]) 7 ``` # Notes * Your implementation should leverage the mathematical properties of sums or XOR to achieve the desired time and space complexity. * Consider edge cases such as the smallest and largest possible lengths of the input list.","solution":"def find_missing_number(nums: list[int]) -> int: Returns the single missing number from the given list. The list contains distinct numbers in the range [0, n]. n = len(nums) # Calculate the expected sum of the numbers from 0 to n expected_sum = n * (n + 1) // 2 # Calculate the actual sum of the numbers in the list actual_sum = sum(nums) # The missing number is the difference between the expected sum and actual sum return expected_sum - actual_sum"},{"question":"# Coding Assessment Question Problem Statement You have been provided with a basic function that processes a list of numerical data points and returns a sorted list of their squares. Your task is to extend this functionality to include additional capabilities to filter the numbers based on a given range and to handle potential exceptions gracefully. Specifically, if the input list contains non-numeric data, your function should raise a `ValueError`. Function to Implement ```python def process_and_filter_squares(data: List, min_value: int = None, max_value: int = None) -> List[int]: Process the list of data points, return a sorted list of squares, and filter numbers based on the given range. Parameters: - data (List): List of numerical data points. - min_value (int, optional): Minimum value for filtering data points. - max_value (int, optional): Maximum value for filtering data points. Returns: - List[int]: Sorted list of squares of the data points meeting the criteria. Raises: - ValueError: If the data list contains non-numeric data. pass ``` Expectations 1. **Functionality**: - The function should return a sorted list of squares of the numerical data points in the provided `data` list. - If `min_value` is provided, only include numbers that are greater than or equal to `min_value`. - If `max_value` is provided, only include numbers that are less than or equal to `max_value`. - If an element in the `data` list is not numeric, raise a `ValueError`. 2. **Input/Output**: - The function takes a list `data` of numerical data points and two optional integer parameters: `min_value` and `max_value`. - It returns a sorted list of squared integers meeting the filtering criteria. 3. **Constraints**: - Handle edge cases such as an empty list, lists with negative numbers, and lists where all numbers fall outside the filtering range. - Ensure robust error handling for non-numeric data in the list. - The function should efficiently process even when the `data` list is large. Example Usage ```python # Example usages when calling your function # Example 1 print(process_and_filter_squares([1, 2, 3, -4, 5], min_value=0)) # Output: [1, 4, 9, 25] # Example 2 print(process_and_filter_squares([1, 2, \\"a\\", 4], min_value=1)) # Raises ValueError: Non-numeric data found in the list # Example 3 print(process_and_filter_squares([10, -3, -2, \\"b\\", 7], max_value=7)) # Raises ValueError: Non-numeric data found in the list ``` Assure that the question fits within the guidelines of your style and complexity consistency requirements.","solution":"from typing import List def process_and_filter_squares(data: List, min_value: int = None, max_value: int = None) -> List[int]: Process the list of data points, return a sorted list of squares, and filter numbers based on the given range. Parameters: - data (List): List of numerical data points. - min_value (int, optional): Minimum value for filtering data points. - max_value (int, optional): Maximum value for filtering data points. Returns: - List[int]: Sorted list of squares of the data points meeting the criteria. Raises: - ValueError: If the data list contains non-numeric data. squares = [] for item in data: if not isinstance(item, (int, float)): raise ValueError(\\"Non-numeric data found in the list\\") if (min_value is not None and item < min_value) or (max_value is not None and item > max_value): continue squares.append(item ** 2) return sorted(squares)"},{"question":"# Stock Market Analysis – Contiguous Subarray with Maximum Sum Context You are analyzing stock market data to determine the periods of highest profitability. Your task is to implement a function that finds the contiguous subarray within a one-dimensional array of daily stock gains and losses which has the largest sum. Problem Statement Find the contiguous subarray (containing at least one number) with the maximum sum from an array representing daily stock gains and losses. # Task Implement a function `max_subarray_sum(arr: list[int]) -> int` that returns the sum of the contiguous subarray with the largest sum. Parameters: * `arr` (List[int]): A list of integers representing daily stock gains and losses. The list will contain at least one integer. Expected Output: * An integer representing the sum of the contiguous subarray with the maximum sum. # Constraints: 1. The length of `arr` will be between 1 and 10^5. 2. The values in `arr` are within the range [-10^4, 10^4]. Example ```python arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] max_subarray_sum(arr) # Output: 6 # Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum = 6. arr = [1] max_subarray_sum(arr) # Output: 1 # Explanation: The only subarray is [1] with sum = 1. arr = [5, 4, -1, 7, 8] max_subarray_sum(arr) # Output: 23 # Explanation: The entire array is the contiguous subarray with the largest sum = 23. ``` # Implementation Notes: 1. Consider using Kadane\'s Algorithm to achieve an optimal solution with O(n) time complexity. 2. Make sure that your solution handles both positive and negative values effectively.","solution":"def max_subarray_sum(arr): Returns the sum of the contiguous subarray with the largest sum. Uses Kadane\'s algorithm to find the maximum sum efficiently. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Coding Assessment Question Context You are developing a system that simulates the movement of objects in a vacuum. To accurately track object trajectories, you need to calculate the resulting position of an object after moving it a specified distance in a given direction. The movement occurs directly in 3D space along a vector. Task Write a function `move_objects(objects: list[tuple[float, float, float]], direction: tuple[float, float, float], distance: float) -> list[tuple[float, float, float]]` that: 1. Calculates the new position for each object after moving it along the given direction vector by the specified distance. 2. Returns a list of tuples representing the new 3D positions of the objects. Input - `objects`: List of tuples representing the initial 3D coordinates (x, y, z) of the objects. - `direction`: Tuple representing the direction vector (dx, dy, dz) along which to move the objects. - `distance`: Float representing the distance each object should be moved along the direction vector. Output - A list of tuples representing the new 3D coordinates of the objects after being moved. Constraints - All coordinates in `objects`, as well as `direction` vector components and `distance`, will be floats or integers. - The direction vector will not be a zero vector. - Assume well-formed input data. Performance Requirements - Ensure the code handles up to 10⁵ objects efficiently within a reasonable execution time. Example ```python objects = [(1, 2, 3), (4, 5, 6), (7, 8, 9)] direction = (0, 1, 1) distance = 10.0 result = move_objects(objects, direction, distance) print(result) # Expected output: [(1, 9.07106781186548, 10.07106781186548), (4, 12.07106781186548, 13.07106781186548), (7, 15.07106781186548, 16.07106781186548)] ``` Hint To move an object in the direction of a vector by a certain distance, calculate the unit vector of the direction and then update the object\'s coordinates accordingly. Example: For a move vector `(dx, dy, dz)`, calculate the unit vector as `(dx / magnitude, dy / magnitude, dz / magnitude)`, where `magnitude = sqrt(dx^2 + dy^2 + dz^2)`. Implement your function based on this principle for accurate movement computations.","solution":"from typing import List, Tuple import math def move_objects(objects: List[Tuple[float, float, float]], direction: Tuple[float, float, float], distance: float) -> List[Tuple[float, float, float]]: Calculates the new positions of objects after moving them along the direction vector by the specified distance in 3D space. Parameters: - objects: List of tuples representing the initial 3D coordinates (x, y, z) of the objects. - direction: Tuple representing the direction vector (dx, dy, dz). - distance: Float representing the distance to move each object along the direction vector. Returns: - A list of tuples representing the new 3D coordinates of the objects. dx, dy, dz = direction magnitude = math.sqrt(dx**2 + dy**2 + dz**2) unit_vector = (dx / magnitude, dy / magnitude, dz / magnitude) new_positions = [] for x, y, z in objects: new_x = x + unit_vector[0] * distance new_y = y + unit_vector[1] * distance new_z = z + unit_vector[2] * distance new_positions.append((new_x, new_y, new_z)) return new_positions"},{"question":"# Context You are developing a software module for an inventory management system that tracks products in a warehouse. One of the features is to generate a summary report of the inventory levels for different products. Each product has a unique identifier, a name, and a quantity in stock. # Task Implement a Python function called `generate_inventory_report` that creates a summary report of the inventory levels. Your function should adhere to the following requirements: # Requirements * Define the function as `generate_inventory_report(inventory: List[Dict[str, Union[str, int]]]) -> str`. * The function should take a list of dictionaries as input. Each dictionary represents a product with the following keys: `\'product_id\'`, `\'product_name\'`, and `\'quantity\'`. * The function should output a formatted string report where each product is listed on a new line in the format: `\\"Product ID: {product_id}, Product Name: {product_name}, Quantity: {quantity}\\"`. * If the inventory list is empty, the function should return the string `\\"No products in inventory.\\"`. # Example Usage ```python >>> inventory = [ ... {\'product_id\': \'P001\', \'product_name\': \'Widget\', \'quantity\': 100}, ... {\'product_id\': \'P002\', \'product_name\': \'Gadget\', \'quantity\': 50}, ... {\'product_id\': \'P003\', \'product_name\': \'Doohickey\', \'quantity\': 75} ... ] >>> print(generate_inventory_report(inventory)) Product ID: P001, Product Name: Widget, Quantity: 100 Product ID: P002, Product Name: Gadget, Quantity: 50 Product ID: P003, Product Name: Doohickey, Quantity: 75 >>> print(generate_inventory_report([])) No products in inventory. ``` # Constraints * The product identifiers (`product_id`) and names (`product_name`) will be non-empty strings. * Quantities (`quantity`) will be non-negative integers. * The input list will not contain duplicate product identifiers. # Performance Requirements * The function should run in linear time, O(n), where n is the number of products in the inventory list. * Ensure the function is designed with readability and maintainability in mind.","solution":"from typing import List, Dict, Union def generate_inventory_report(inventory: List[Dict[str, Union[str, int]]]) -> str: if not inventory: return \\"No products in inventory.\\" report_lines = [] for item in inventory: report_line = f\\"Product ID: {item[\'product_id\']}, Product Name: {item[\'product_name\']}, Quantity: {item[\'quantity\']}\\" report_lines.append(report_line) return \\"n\\".join(report_lines)"},{"question":"# Container With Most Water Question You are given an array `height` where `height[i]` represents the height of an `i`-th vertical line on a 2D plane. The `i`-th line together with the `j`-th line and the x-axis forms a container. Find two lines that form a container, such that the container contains the most water. # Function Signature ```python def max_area(height: list) -> int: ``` # Input - `height` (list of int): An array of non-negative integers where (2 ≤ `len(height)` ≤ 100000 and 0 ≤ `height[i]` ≤ 10000). # Output - Returns (int): The maximum amount of water a container can store. # Constraints - Each element in the array represents the height of a vertical line at that index position. - The width between the two lines is the difference of their indices. - You cannot slant the container. # Example ```python def test_max_area(): assert max_area([1,8,6,2,5,4,8,3,7]) == 49 assert max_area([1,1]) == 1 assert max_area([4,3,2,1,4]) == 16 assert max_area([1,2,1]) == 2 assert max_area([2,3,4,5,18,17,6]) == 17 test_max_area() ``` # Description 1. Implement the `max_area` function to take in the height list and return the maximum amount of water the container can store. 2. Use a two-pointer approach to efficiently find the maximum area. 3. Include appropriate checks to handle errors and edge cases. # Hint Use two pointers, one at the beginning and one at the end of the list, and iterate towards the center, always moving the pointer which is at the shorter height to maximize the area calculation. This approach ensures a time complexity of O(n).","solution":"def max_area(height: list) -> int: Find the maximum area of water a container can store. Args: height (list of int): List of non-negative integers representing the height of lines. Returns: int: Maximum area of water a container can store. left = 0 right = len(height) - 1 max_area = 0 while left < right: current_height = min(height[left], height[right]) current_width = right - left current_area = current_height * current_width max_area = max(max_area, current_area) # Move the shorter line inwards if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Problem Statement You are asked to create a system to manage library books using a binary search tree (BST) as the underlying data structure. The system should support the following operations: inserting new books, searching for books by the unique book ID, deleting a book when it is checked out permanently, and providing a list of all books currently in the library in sorted order by their IDs. Requirements 1. **`insert(book_id: int, book_title: str) -> None`**: * Insert a book with the given `book_id` and `book_title` into the BST. * Each `book_id` is unique and identifies a book in the library. 2. **`search(book_id: int) -> str`**: * Search for a book by its `book_id` and return the `book_title`. * If the book does not exist, return `None`. 3. **`delete(book_id: int) -> bool`**: * Remove the book with the specified `book_id` from the BST. * Return `True` if the book was found and deleted, `False` otherwise. 4. **`get_books_in_order() -> List[Tuple[int, str]]`**: * Return a list of all books in the library in ascending order by `book_id`. * Each list item should be a tuple containing the `book_id` and `book_title`. Constraints * The `book_id` is an integer and will always be positive. * The `book_title` is a non-empty string. * Consider edge cases such as inserting into an empty tree, searching for non-existent books, and deleting books from an empty or non-empty tree. Example ```python class BookBSTNode: def __init__(self, book_id: int, book_title: str): self.book_id = book_id self.book_title = book_title self.left = None self.right = None class LibrarySystem: def __init__(self): # Initialize an empty BST for managing the books. def insert(self, book_id, book_title): # Implement the insertion method. def search(self, book_id): # Implement the search method. def delete(self, book_id): # Implement the deletion method. def get_books_in_order(self): # Implement the in-order traversal method. ``` Testing * Initialize the library system and perform a series of insertions to build the BST. * Test searching for both existing and non-existing book IDs. * Delete books and verify the remaining BST structure is correct. * Ensure that getting books in order returns the correct list of books in ascending order by ID.","solution":"class BookBSTNode: def __init__(self, book_id: int, book_title: str): self.book_id = book_id self.book_title = book_title self.left = None self.right = None class LibrarySystem: def __init__(self): self.root = None def insert(self, book_id: int, book_title: str) -> None: if self.root is None: self.root = BookBSTNode(book_id, book_title) else: self._insert_recursive(self.root, book_id, book_title) def _insert_recursive(self, node: BookBSTNode, book_id: int, book_title: str): if book_id < node.book_id: if node.left is None: node.left = BookBSTNode(book_id, book_title) else: self._insert_recursive(node.left, book_id, book_title) elif book_id > node.book_id: if node.right is None: node.right = BookBSTNode(book_id, book_title) else: self._insert_recursive(node.right, book_id, book_title) def search(self, book_id: int) -> str: return self._search_recursive(self.root, book_id) def _search_recursive(self, node: BookBSTNode, book_id: int) -> str: if node is None: return None if book_id == node.book_id: return node.book_title elif book_id < node.book_id: return self._search_recursive(node.left, book_id) else: return self._search_recursive(node.right, book_id) def delete(self, book_id: int) -> bool: self.root, deleted = self._delete_recursive(self.root, book_id) return deleted def _delete_recursive(self, node: BookBSTNode, book_id: int): if node is None: return node, False if book_id < node.book_id: node.left, deleted = self._delete_recursive(node.left, book_id) elif book_id > node.book_id: node.right, deleted = self._delete_recursive(node.right, book_id) else: if node.left is None: return node.right, True elif node.right is None: return node.left, True min_larger_node = self._find_min(node.right) node.book_id, node.book_title = min_larger_node.book_id, min_larger_node.book_title node.right, _ = self._delete_recursive(node.right, node.book_id) return node, True return node, deleted def _find_min(self, node: BookBSTNode) -> BookBSTNode: while node.left is not None: node = node.left return node def get_books_in_order(self) -> list: books_list = [] self._in_order_traversal(self.root, books_list) return books_list def _in_order_traversal(self, node: BookBSTNode, books_list: list): if node is not None: self._in_order_traversal(node.left, books_list) books_list.append((node.book_id, node.book_title)) self._in_order_traversal(node.right, books_list)"},{"question":"# Text File Word Counter As a software engineer, you are tasked with creating a utility that reads and processes text files to count the frequency of unique words. Your task involves the following steps: 1. **Read and Process the File**: Write a function `count_words(file_path)` that: * Takes as input: * `file_path`, a string that represents the path to a text file. * Returns: * A dictionary where keys are unique words (strings) found in the text and values are their respective frequencies (integers). 2. **Data Cleaning**: Ensure that the words are counted correctly by: * Converting all words to lowercase to ensure case insensitivity. * Stripping punctuation from words (you may use Python\'s `string.punctuation` for this). * Ignoring whitespace and empty strings. 3. **Efficiency**: Your function should efficiently read and process the file, handling reasonably large text files without performance degradation. **Input and Output Format:** Input file (represented as `file_path` pointing to \'sample.txt\', containing): ``` Hello world! Hello, Python world. Welcome to the world of programming. ``` Output: ```python {\'hello\': 2, \'world\': 3, \'python\': 1, \'welcome\': 1, \'to\': 1, \'the\': 1, \'of\': 1, \'programming\': 1} ``` Your implementation must account for the following constraints and ensure it performs these operations correctly and efficiently. ```python import string def count_words(file_path): Count the frequency of unique words in a text file. Args: file_path (str): The path to the text file. Returns: dict: A dictionary with words as keys and their frequencies as values. word_count = {} with open(file_path, \'r\') as file: for line in file: # Remove punctuation, convert to lowercase and split line into words line = line.translate(str.maketrans(\'\', \'\', string.punctuation)).lower() words = line.split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count # Example usage (you can use this for testing your function by creating a \'sample.txt\' file): file_path = \'sample.txt\' word_frequencies = count_words(file_path) print(word_frequencies) # Expected output: {\'hello\': 2, \'world\': 3, \'python\': 1, \'welcome\': 1, \'to\': 1, \'the\': 1, \'of\': 1, \'programming\': 1} ```","solution":"import string def count_words(file_path): Count the frequency of unique words in a text file. Args: file_path (str): The path to the text file. Returns: dict: A dictionary with words as keys and their frequencies as values. word_count = {} with open(file_path, \'r\') as file: for line in file: # Remove punctuation, convert to lowercase and split line into words line = line.translate(str.maketrans(\'\', \'\', string.punctuation)).lower() words = line.split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count"},{"question":"# Find the Closest Pair in a Sorted Array Problem Statement: Given a sorted array of distinct integers and a target integer, find the pair of integers in the array whose sum is closest to the target. If there are multiple pairs that have the same closest sum, return any one of them. Task: 1. Implement a function that accepts a sorted list of integers and a target integer. 2. Find and return a tuple containing the pair of integers whose sum is closest to the target value. Expected Function Signature: ```python def closest_pair(arr: list[int], target: int) -> tuple[int, int] ``` Example: ```python arr = [1, 3, 4, 7, 10] target = 15 result = closest_pair(arr, target) print(result) # Output could be (4, 10) or any closest pair to the target 15 ``` Constraints: 1. The array length can be up to 10^5. 2. The array contains distinct integers. 3. The array is sorted in ascending order. 4. All integers in the array and the target will be within the range [-10^4, 10^4]. Hint: Utilize a two-pointer technique to efficiently find the closest pair in a single pass.","solution":"def closest_pair(arr, target): Finds the pair of integers in the sorted array whose sum is closest to the target. Parameters: arr (list of int): Sorted list of distinct integers. target (int): The target sum. Returns: tuple of int: The pair of integers whose sum is closest to the target. left, right = 0, len(arr) - 1 closest_pair = (arr[left], arr[right]) closest_diff = abs(arr[left] + arr[right] - target) while left < right: current_sum = arr[left] + arr[right] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_diff = current_diff closest_pair = (arr[left], arr[right]) if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: # If the current_sum is exactly equal to the target, we found the closest pair return (arr[left], arr[right]) return closest_pair"},{"question":"# Knapsack Problem with Memoization Context: The Knapsack problem is a classic problem in combinatorial optimization. Given a set of items, each with a weight and a value, determine the maximum value that can be obtained by selecting items such that their total weight does not exceed a given limit. This problem is useful in resource allocation where resources are limited and must be optimally used. Problem Statement: Given an integer array `weights` and an integer array `values` where `weights[i]` represents the weight of the `i-th` item and `values[i]` represents the value of the `i-th` item, and a maximum weight capacity `W`, your task is to compute the maximum value that can be achieved by selecting items without exceeding the weight capacity `W`. Function Signature: ```python def knapsack(weights: List[int], values: List[int], W: int) -> int: This function returns the maximum value that can be obtained without exceeding the weight capacity. >>> knapsack([1, 2, 3], [10, 15, 40], 6) 65 >>> knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7) 9 ``` Input: - An integer array `weights` (1 <= len(weights) <= 1000, 1 <= weights[i] <= 1000): the weights of the items. - An integer array `values` (1 <= len(values) <= 1000, 1 <= values[i] <= 1000): the values of the items. - A single integer `W` (1 <= W <= 1000): the maximum weight capacity of the knapsack. Output: - An integer, the maximum value that can be obtained by selecting items without exceeding the weight capacity `W`. Constraints: - The number of items is the same in both arrays `weights` and `values`. Example: ```python assert knapsack([1, 2, 3], [10, 15, 40], 6) == 65 assert knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7) == 9 ``` Explanation: - For the input `weights = [1, 2, 3]` and `values = [10, 15, 40]` with `W = 6`, the maximum value that can be obtained is 65 by taking all items. - For the input `weights = [1, 3, 4, 5]` and `values = [1, 4, 5, 7]` with `W = 7`, the maximum value that can be obtained is 9 by taking the first and fourth items. Implement the function using dynamic programming with memoization to find and return the maximum value achievable within the given weight capacity `W`. Consider optimizing both time and space complexity where possible.","solution":"from typing import List def knapsack(weights: List[int], values: List[int], W: int) -> int: Returns the maximum value that can be obtained without exceeding the weight capacity. Uses dynamic programming with memoization approach. n = len(weights) # Create a 2D array to store the maximum value for each subproblem dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] # Build the dp array from bottom up for i in range(n + 1): for w in range(W + 1): if i == 0 or w == 0: dp[i][w] = 0 elif weights[i - 1] <= w: dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"# Task You are tasked with implementing a function to sort a list of integers using the Merge Sort algorithm. This sorting algorithm is known for its efficiency in handling large datasets due to its O(n log n) complexity. # Problem Statement **Function Signature**: ```python def merge_sort(arr: List[int]) -> List[int]: \'\'\' Parameters: arr (List[int]): A list of integers that needs to be sorted. Returns: List[int]: The sorted list of integers. \'\'\' ``` Your task is to implement the `merge_sort` function, which will take a list of integers and return the list sorted in ascending order using the Merge Sort algorithm. The Merge Sort algorithm should be implemented from scratch without the use of built-in sorting functions. # Constraints * The input list `arr` can contain elements between `-10^6` and `10^6`. * The size of the list `arr` can be up to `10^5`. # Examples Example 1: * Input: ```python arr = [38, 27, 43, 3, 9, 82, 10] ``` * Output: ```python [3, 9, 10, 27, 38, 43, 82] ``` Example 2: * Input: ```python arr = [5, 1, 1, 2, 0, 0] ``` * Output: ```python [0, 0, 1, 1, 2, 5] ``` # Notes * Make sure your implementation correctly handles duplicate values. * Test your implementation with lists of different sizes and values to ensure its efficiency and correctness.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Problem Statement You need to implement a calculator for fraction arithmetic. The calculator should be able to perform addition, subtraction, multiplication, and division of fractions and output the result in simplest form. # Function Signatures ```python def add_fractions(frac1: tuple[int, int], frac2: tuple[int, int]) -> tuple[int, int]: pass def subtract_fractions(frac1: tuple[int, int], frac2: tuple[int, int]) -> tuple[int, int]: pass def multiply_fractions(frac1: tuple[int, int], frac2: tuple[int, int]) -> tuple[int, int]: pass def divide_fractions(frac1: tuple[int, int], frac2: tuple[int, int]) -> tuple[int, int]: pass ``` # Input/Output Formats - **add_fractions**: - **Input**: Two tuples, `frac1` and `frac2`, each representing a fraction in the form (numerator, denominator). - **Output**: A tuple representing the result of the addition in simplest form. - **subtract_fractions**: - **Input**: Two tuples, `frac1` and `frac2`, each representing a fraction in the form (numerator, denominator). - **Output**: A tuple representing the result of the subtraction in simplest form. - **multiply_fractions**: - **Input**: Two tuples, `frac1` and `frac2`, each representing a fraction in the form (numerator, denominator). - **Output**: A tuple representing the result of the multiplication in simplest form. - **divide_fractions**: - **Input**: Two tuples, `frac1` and `frac2`, each representing a fraction in the form (numerator, denominator). - **Output**: A tuple representing the result of the division in simplest form or an assertion failure if division by zero is attempted. # Example ```python assert add_fractions((1, 3), (1, 6)) == (1, 2) assert subtract_fractions((1, 3), (1, 6)) == (1, 6) assert multiply_fractions((1, 3), (1, 6)) == (1, 18) assert divide_fractions((1, 3), (1, 6)) == (2, 1) ``` # Implementation Notes 1. **Simplifying Fractions**: After each operation, the result should be simplified. Use the Euclidean algorithm to find the GCD and divide the numerator and denominator by their GCD. 2. **Addition/Subtraction**: Use the common denominator to perform the operation and then simplify. 3. **Multiplication/Division**: Multiply or divide numerators and denominators directly and then simplify. # Constraints - The numerators and denominators for input fractions are non-zero integers. - The denominators for input fractions are positive integers. - The fractions in the output should be in simplest form with a positive denominator.","solution":"from math import gcd def simplify_fraction(numerator: int, denominator: int) -> tuple[int, int]: common_divisor = gcd(numerator, denominator) return numerator // common_divisor, denominator // common_divisor def add_fractions(frac1: tuple[int, int], frac2: tuple[int, int]) -> tuple[int, int]: num1, den1 = frac1 num2, den2 = frac2 common_denominator = den1 * den2 numerator_sum = num1 * den2 + num2 * den1 return simplify_fraction(numerator_sum, common_denominator) def subtract_fractions(frac1: tuple[int, int], frac2: tuple[int, int]) -> tuple[int, int]: num1, den1 = frac1 num2, den2 = frac2 common_denominator = den1 * den2 numerator_diff = num1 * den2 - num2 * den1 return simplify_fraction(numerator_diff, common_denominator) def multiply_fractions(frac1: tuple[int, int], frac2: tuple[int, int]) -> tuple[int, int]: num1, den1 = frac1 num2, den2 = frac2 numerator_product = num1 * num2 denominator_product = den1 * den2 return simplify_fraction(numerator_product, denominator_product) def divide_fractions(frac1: tuple[int, int], frac2: tuple[int, int]) -> tuple[int, int]: num1, den1 = frac1 num2, den2 = frac2 assert num2 != 0, \\"Cannot divide by zero\\" numerator_quotient = num1 * den2 denominator_quotient = den1 * num2 return simplify_fraction(numerator_quotient, denominator_quotient)"},{"question":"# Coding Question: Develop a Most Frequent Elements Finder In many applications, it is crucial to identify the most frequent elements within a collection of data. Your task is to implement a function that finds and returns the k most frequent elements in a given list of integers. The function should be efficient and capable of handling large datasets. **Instructions**: 1. Implement the function `top_k_frequent(nums: List[int], k: int) -> List[int]` where `nums` is the list of integers and `k` is the number of top frequent elements to return. 2. Ensure the function handles edge cases such as empty lists, lists with all unique elements, and cases where `k` is greater than the number of unique elements in the list. 3. Write appropriate test cases that cover: - Normal cases with random distributions of integers. - Edge cases like empty lists or lists with the same or very few unique elements. - Large datasets to test performance and efficiency. ```python from typing import List from collections import Counter import heapq def top_k_frequent(nums: List[int], k: int) -> List[int]: # Your implementation goes here pass def test_top_k_frequent() -> None: # Test cases are provided to validate the implementation pass # Example of running tests if __name__ == \\"__main__\\": test_top_k_frequent() ``` **Function Specification**: - **Input**: - `nums (List[int])`: The list of integers from which to find the most frequent elements. - `k (int)`: The number of top frequent elements to return. - **Output**: - `List[int]`: A list containing the `k` most frequent elements from `nums`, in any order. **Constraints**: - The function should be efficient with a time complexity target of O(n log k), where n is the number of elements in `nums`. - The input list `nums` can have up to 10^5 elements. - The value of `k` will always be a positive integer and may be up to the number of unique elements in `nums`. **Performance Requirements**: - Efficient execution with acceptable runtime for large datasets. - Appropriate handling of edge cases to ensure robustness. Develop your solution iteratively and test thoroughly. Best of luck!","solution":"from typing import List from collections import Counter import heapq def top_k_frequent(nums: List[int], k: int) -> List[int]: if not nums: return [] # Build a frequency map count = Counter(nums) # Use a heap to get the top k frequent elements return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"# Problem Statement: **Maze Path Finder** You are given a 2D maze where each cell is either an empty space `.` or a wall `#`. You need to find the shortest path from a starting cell to a finish cell, moving only in the four cardinal directions (up, down, left, right). Implement the `MazeSolver` class with the following methods: - `__init__(self, maze: List[List[str]])`: Initializes the maze. - `add_wall(self, row: int, col: int)`: Adds a wall `#` at the specified row and column. Raises a `ValueError` for invalid indices. - `shortest_path(self, start: Tuple[int, int], finish: Tuple[int, int]) -> int`: Returns the shortest path length from the start cell to the finish cell. Raises a `ValueError` if there is no valid path. Input - A 2D list of strings representing the maze, where `.` represents an empty space and `#` represents a wall. - Multiple pairs of integers `row`, `col` to specify the locations of additional walls. - A pair of tuples `start` and `finish` representing the starting and finishing positions in the maze. Output - Returns the shortest path length from `start` to `finish`. - Raises a `ValueError` if there is no valid path between the start and finish cells. # Example ```python maze = [ [\\".\\", \\".\\", \\".\\", \\"#\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"#\\", \\".\\", \\"#\\", \\".\\", \\"#\\", \\".\\"], [\\".\\", \\"#\\", \\".\\", \\".\\", \\".\\", \\"#\\", \\".\\"], [\\".\\", \\"#\\", \\"#\\", \\"#\\", \\".\\", \\"#\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"] ] solver = MazeSolver(maze) solver.add_wall(0, 3) # Already a wall, shouldn\'t modify the maze solver.add_wall(3, 2) solver.add_wall(3, 3) assert solver.shortest_path((0, 0), (4, 6)) == 10 assert solver.shortest_path((2, 0), (3, 5)) == 6 assert solver.shortest_path((1, 1), (4, 5)) == ValueError(\\"No path from start to finish.\\") ``` You need to complete the class `MazeSolver` as per the specified requirements: ```python from typing import List, Tuple class MazeSolver: def __init__(self, maze: List[List[str]]): # Initialize your data structures here self.maze = maze self.num_rows = len(maze) self.num_cols = len(maze[0]) def add_wall(self, row: int, col: int): # Add a wall with validation checks if row < 0 or row >= self.num_rows or col < 0 or col >= self.num_cols: raise ValueError(\\"Invalid wall position.\\") self.maze[row][col] = \\"#\\" def shortest_path(self, start: Tuple[int, int], finish: Tuple[int, int]) -> int: # Implement BFS or other algorithm to find the shortest path from collections import deque if self.maze[start[0]][start[1]] == \\"#\\" or self.maze[finish[0]][finish[1]] == \\"#\\": raise ValueError(\\"No path from start to finish.\\") directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add((start[0], start[1])) while queue: r, c, dist = queue.popleft() if (r, c) == finish: return dist for dr, dc in directions: new_r, new_c = r + dr, c + dc if 0 <= new_r < self.num_rows and 0 <= new_c < self.num_cols and self.maze[new_r][new_c] == \\".\\" and (new_r, new_c) not in visited: visited.add((new_r, new_c)) queue.append((new_r, new_c, dist + 1)) raise ValueError(\\"No path from start to finish.\\") ``` # Constraints - `1 <= num_rows, num_cols <= 1000` - `0 <= row < num_rows` - `0 <= col < num_cols` # Notes - Ensure your solution handles edge cases appropriately. - Optimize for both time and space, adhering to the constraints and expected complexity.","solution":"from typing import List, Tuple from collections import deque class MazeSolver: def __init__(self, maze: List[List[str]]): self.maze = maze self.num_rows = len(maze) self.num_cols = len(maze[0]) def add_wall(self, row: int, col: int): if row < 0 or row >= self.num_rows or col < 0 or col >= self.num_cols: raise ValueError(\\"Invalid wall position.\\") self.maze[row][col] = \\"#\\" def shortest_path(self, start: Tuple[int, int], finish: Tuple[int, int]) -> int: if self.maze[start[0]][start[1]] == \\"#\\" or self.maze[finish[0]][finish[1]] == \\"#\\": raise ValueError(\\"No path from start to finish.\\") directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add((start[0], start[1])) while queue: r, c, dist = queue.popleft() if (r, c) == finish: return dist for dr, dc in directions: new_r, new_c = r + dr, c + dc if 0 <= new_r < self.num_rows and 0 <= new_c < self.num_cols and self.maze[new_r][new_c] == \\".\\" and (new_r, new_c) not in visited: visited.add((new_r, new_c)) queue.append((new_r, new_c, dist + 1)) raise ValueError(\\"No path from start to finish.\\")"},{"question":"# Problem: Implement a Basic Calculator You are tasked with implementing a basic string-based calculator. The calculator should be able to evaluate simple mathematical expressions and return the correct result. Function 1: `evaluate_expression` Write a method `evaluate_expression(expression: str) -> float` that evaluates a given mathematical expression. The expression may contain: - Non-negative integers - The operators +, -, *, / - Parentheses for grouping Input * `expression`: A string representing the mathematical expression. Output * Returns the evaluated result as a floating point number. Example ```python >>> evaluate_expression(\\"3+5*2\\") 13.0 >>> evaluate_expression(\\"(2+3)*4\\") 20.0 >>> evaluate_expression(\\"10/(2+3)\\") 2.0 >>> evaluate_expression(\\"(5*(3+2))-(12/6)\\") 23.0 ``` Constraints * The input expression consists of integers and the operators +, -, *, /, with balanced parentheses. * The operations should follow standard mathematical precedence rules. # Additional Notes * Handle cases with nested parentheses. * Ensure the function can handle division by evaluating as a floating-point operation.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a given mathematical expression and returns the result. The expression may contain non-negative integers and the operators +, -, *, / with possible parentheses. Args: expression (str): The mathematical expression to evaluate. Returns: float: The evaluated result as a floating-point number. try: result = eval(expression, {\\"__builtins__\\": None}, {}) return float(result) except Exception as e: raise ValueError(\\"Invalid expression\\") from e"},{"question":"# Problem Description: In a city, there are multiple paths and intersections. Each intersection connects to others with a given distance. You need to find the shortest path between any two given intersections using Dijkstra\'s Algorithm. # Function Signature: ```python def find_shortest_path(num_intersections: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: pass ``` # Input: - `num_intersections`: An integer representing the number of intersections. - `roads`: A list of tuples where each tuple `(u, v, d)` represents a road between intersections `u` and `v` with distance `d`. - `start`: An integer representing the starting intersection. - `end`: An integer representing the destination intersection. # Output: - An integer representing the shortest distance from the starting intersection to the destination intersection. If there is no path, return -1. # Constraints: - (1 leq num_intersections leq 1000) - (0 leq u, v < num_intersections) - (1 leq d leq 10^4) - Intersections are numbered from (0) to (num_intersections-1). # Example: ```python # Example Usage num_intersections = 5 roads = [(0, 1, 10), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 3, 8), (3, 4, 7)] start = 0 end = 4 print(find_shortest_path(num_intersections, roads, start, end)) # Output: 18 ``` # Explanation: In the given example, Dijkstra\'s Algorithm computes the shortest distance from intersection 0 to intersection 4 as 18 units. # Notes: - You may assume the input graph is a directed graph without self-loops and parallel roads. - Helper methods within the `find_shortest_path` function to handle priority queues and distance updates can be useful. # Edge Cases: - Consider cases where the start and end intersections are the same, ensuring the distance is 0. - Handle cases where there is no path between the start and end intersections, ensuring to return -1. - Consider graphs with isolated intersections and ensure efficient computation to handle larger datasets optimally. # Additional Examples: ```python num_intersections = 4 roads = [(0, 1, 5), (1, 2, 10), (1, 3, 15)] start = 0 end = 3 print(find_shortest_path(num_intersections, roads, start, end)) # Output: 20 num_intersections = 3 roads = [(0, 1, 4), (1, 2, 8)] start = 0 end = 2 print(find_shortest_path(num_intersections, roads, start, end)) # Output: 12 ```","solution":"import heapq from typing import List, Tuple def find_shortest_path(num_intersections: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: # Create a graph in the form of an adjacency list graph = [[] for _ in range(num_intersections)] for u, v, d in roads: graph[u].append((v, d)) # Priority queue to implement Dijkstra\'s algorithm min_heap = [(0, start)] # (distance, vertex) distances = [float(\'inf\')] * num_intersections distances[start] = 0 # Dijkstra\'s algorithm while min_heap: current_distance, u = heapq.heappop(min_heap) # If we pop the end vertex from the heap, we have found the shortest path if u == end: return current_distance # If the popped distance is greater than the stored distance, it means we\'ve already found a shorter path if current_distance > distances[u]: continue # Explore neighbors for v, weight in graph[u]: distance = current_distance + weight # Relaxation step if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) # If we finished the loop and never reached the end node, there\'s no path return -1 if distances[end] == float(\'inf\') else distances[end]"},{"question":"# Scenario You are developing a text processing tool and need to implement a function that extracts and counts the frequency of all distinct words from a given string. The function should be able to handle punctuation, ignore case differences, and efficiently manage large input strings. # Task Implement a function `word_frequencies` that processes a string and returns a dictionary with the frequency of each distinct word. # Function Signature ```python def word_frequencies(text: str) -> Dict[str, int]: ``` # Input * `text`: A string containing the text data. # Output * Returns a dictionary where the keys are the unique words (in lowercase) and the values are their frequencies. # Constraints * The function should handle input strings of length up to (10^6) characters efficiently. * Words are sequences of characters separated by whitespace or punctuation (.,!?;:). # Example ```python >>> word_frequencies(\\"Hello, world! Hello...\\") {\'hello\': 2, \'world\': 1} >>> word_frequencies(\\"A quick brown fox jumps over a lazy dog.\\") {\'a\': 2, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 1} ``` # Performance Requirements * The solution should run within reasonable time limits for the input size constraint. * Proper handling of memory and efficient usage of data structures are expected. # Edge Cases * Handle empty strings without any errors. * Normalize the text to handle different cases (uppercase vs lowercase) uniformly.","solution":"import re from typing import Dict def word_frequencies(text: str) -> Dict[str, int]: Processes a string and returns a dictionary with the frequency of each distinct word. Words are considered as sequences of characters separated by whitespaces or punctuations. words = re.findall(r\'bw+b\', text.lower()) frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"# Problem Statement You are given a list of integers where each integer represents the value of a node in an organizational hierarchy tree structure. The tree structure can be represented as a list where each element contains a tuple of two integers: `(parent, child)` which indicates that `child` is a direct subordinate of `parent`. Given this structure, your task is to compute and return the sum of the values of all nodes in the subtree rooted at a given target node. Write a function `subtree_sum` that accepts three arguments: 1. A list of integers `values` where `values[i]` represents the value of the node `i`. 2. A list of tuples `edges` where each tuple `(parent, child)` represents an edge from `parent` to `child`. 3. An integer `target` representing the root node of the subtree for which you need to calculate the sum of node values. # Function Signature ```python def subtree_sum(values: List[int], edges: List[Tuple[int, int]], target: int) -> int: ``` # Input and Output * **Input**: - `values`: A list of integers of length `n` representing node values. - `edges`: A list of tuples `(parent, child)` indicating the tree structure. - `target`: An integer representing the root node of the subtree of interest. * **Output**: An integer representing the sum of values of all nodes in the subtree rooted at `target`. # Constraints - The length of `values` and the number of nodes `n` will always be the same. - The `edges` list will have `n-1` tuples representing a valid tree. - The `target` will always exist in the tree. # Example ```python values = [1, 2, 3, 4, 5] edges = [(0, 1), (0, 2), (1, 3), (1, 4)] target = 1 # The subtree rooted at node 1 includes nodes 1, 3, and 4. # Their values are 2, 4, and 5 respectively. result = subtree_sum(values, edges, target) print(result) # Output should be 11 ``` # Notes - Use an efficient traversal technique like Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the subtree from the target node. - Ensure that your solution handles trees of arbitrary node values and structure effectively.","solution":"from typing import List, Tuple def subtree_sum(values: List[int], edges: List[Tuple[int, int]], target: int) -> int: # Create a dictionary to store the adjacency list of the tree tree = {} for parent, child in edges: if parent in tree: tree[parent].append(child) else: tree[parent] = [child] def dfs(node: int) -> int: # Start with the value of the current node total = values[node] # Add the sum of the values of all sub-nodes recursively if node in tree: for child in tree[node]: total += dfs(child) return total return dfs(target)"},{"question":"You are given a list of strings that represents a sequence of nested or potentially nested function calls in a simplified programming language. Your task is to implement the function `validate_function_calls` that determines whether the sequence of function calls is properly nested. **Function Signature**: `def validate_function_calls(calls: list[str]) -> bool` **Input**: * A list of `n` strings where each string is either `\'FUNC\'` indicating the start of a function call or `\'END\'` indicating the end of the most recent function call. The length of the list `1 ≤ n ≤ 10^5`. **Output**: * A boolean value `True` if the sequence of function calls is properly nested. * A boolean value `False` if the sequence of function calls is not properly nested. **Constraints**: * The list will only contain the strings `\'FUNC\'` and `\'END\'`. * An empty list is considered as properly nested. * If at any point an `\'END\'` appears without a corresponding `\'FUNC\'` before it, the sequence is not properly nested and should return `False`. **Detailed Description**: * To determine if a sequence of function calls is properly nested, each `\'FUNC\'` must correspond to exactly one `\'END\'` in the correct order. * Treat the sequence like a stack where `\'FUNC\'` pushes an element onto the stack, and `\'END\'` pops from the stack. If you attempt to pop from an empty stack, the sequence is invalid. * The function should handle large input sizes efficiently. **Edge Cases to Consider**: * List with only `\'FUNC\'` or only `\'END\'`. * Odd-length lists which cannot pair correctly. * Lists where `\'END\'` appears before any `\'FUNC\'`. **Examples**: ```python >>> validate_function_calls([\'FUNC\', \'FUNC\', \'END\', \'END\']) True >>> validate_function_calls([\'FUNC\', \'END\', \'END\']) False >>> validate_function_calls([\'END\', \'FUNC\', \'END\']) False >>> validate_function_calls([\'FUNC\', \'FUNC\', \'FUNC\', \'END\', \'END\', \'FUNC\', \'END\', \'END\']) False >>> validate_function_calls([\'FUNC\', \'END\', \'FUNC\', \'END\']) True >>> validate_function_calls([]) True ``` Implement the function `validate_function_calls` in Python to solve the problem as described.","solution":"def validate_function_calls(calls): Determines whether the sequence of function calls is properly nested. Args: calls (list): A list of strings where each string is either \'FUNC\' or \'END\'. Returns: bool: True if the sequence is properly nested, False otherwise. stack = [] for call in calls: if call == \'FUNC\': stack.append(call) elif call == \'END\': if not stack: # Trying to end a function that hasn\'t started return False stack.pop() # If stack is empty, all FUNC have corresponding END return len(stack) == 0"},{"question":"# Context A company using their transportation fleet wants a more efficient way to assign packages. Each package has a delivery deadline in days, and it\'s important that drivers are given enough time to deliver all their packages without missing any deadlines. # Problem Statement Write a function `delivery_schedule(packages, limit)` that determines the minimum number of days necessary to deliver all packages within their respective deadlines. Each package is represented as a list of integers where each integer represents the deadline in days for a package. The limit is the maximum number of packages that can be delivered in a single day. # Input - `packages`: A list of integers representing deadlines in days for packages. - `limit`: An integer representing the maximum number of packages that can be delivered in a single day. # Output - An integer representing the minimum number of days necessary to deliver all packages without missing any deadlines. # Constraints - The length of packages list will be between 1 and 1000. - Each deadline entry in the list will be between 1 and 365. - Limit will be a positive integer between 1 and 100. # Example ```python >>> delivery_schedule([1, 2, 1, 2, 3, 3], 2) 4 >>> delivery_schedule([1, 2, 1, 2, 3, 3], 3) 2 >>> delivery_schedule([1, 2, 3, 4, 5], 1) 5 ``` # Implementation ```python def delivery_schedule(packages, limit): from collections import Counter package_count = Counter(packages) # To meet deadline, each day should not exceed its order limit day_counts = [0] * 366 for deadline, count in package_count.items(): day_counts[deadline] += count current_day = 1 while current_day <= 365: if day_counts[current_day] > limit: next_day = current_day while day_counts[next_day] > limit: excess = day_counts[next_day] - limit day_counts[next_day] = limit day_counts[next_day + 1] += excess next_day += 1 current_day += 1 # Finding the last day at which we have packages last_day = max(i for i, count in enumerate(day_counts) if count > 0) return last_day ```","solution":"def delivery_schedule(packages, limit): packages.sort() days_needed = 0 current_load = 0 for deadline in packages: if current_load < limit: current_load += 1 else: days_needed += 1 current_load = 1 days_needed = max(days_needed, deadline) return days_needed"},{"question":"Multi-Class Logistic Regression Implementation You are required to implement a multi-class logistic regression classifier from scratch and optimize its performance for training and prediction tasks. Implement the following functions: 1. **softmax** - To compute the softmax activation for a given input vector. 2. **cross_entropy_loss** - To compute the cross-entropy loss for the given predicted and actual labels. 3. **train** - To train the logistic regression model using the provided training samples and labels. 4. **predict** - To predict the class for a new sample based on the trained model. # Function Definitions Function 1: softmax ```python def softmax(logits: list[float]) -> list[float]: Compute the softmax activation for the given input vector. Args: - logits (list[float]): Input vector of logits. Returns: - list[float]: Softmax probabilities. ``` Function 2: cross_entropy_loss ```python def cross_entropy_loss(predicted: list[float], actual: list[int]) -> float: Compute the cross-entropy loss for the given predicted and actual labels. Args: - predicted (list[float]): Predicted probabilities. - actual (list[int]): One-hot encoded actual labels. Returns: - float: Cross-entropy loss. ``` Function 3: train ```python def train(training_samples: list[list[float]], labels: list[int], epochs: int, lr: float) -> dict: Train the multi-class logistic regression model. Args: - training_samples (list[list[float]]): Matrix of training samples. - labels (list[int]): List of class labels for the training samples. - epochs (int): Number of training epochs. - lr (float): Learning rate. Returns: - dict: Trained parameters (weights and bias). ``` Function 4: predict ```python def predict(parameters: dict, sample: list[float]) -> int: Predict the class for a given sample using the trained model. Args: - parameters (dict): Trained model parameters. - sample (list[float]): Input sample vector. Returns: - int: Predicted class label. ``` # Input and Output - **Input**: - training_samples: List of training sample vectors (each vector is a list of floats). - labels: List of integers representing class labels corresponding to training samples. - epochs: Integer representing the number of training epochs. - lr: Float representing the learning rate for gradient descent. - sample: List of floats representing a sample vector to be classified. - **Output**: - For training, return a dictionary containing the trained parameters (weights and bias). - For prediction, return the predicted class label. # Constraints - The input arrays and labels contain only valid numerical values. - The sample array and weights have lengths within the range [1, 1000]. - The learning rate (`lr`) is a float within the range [0.0, 1.0]. - The number of classes is between 2 and 10. # Additional Notes - Ensure numerical stability when computing the softmax values. - Implement efficient matrix operations for performance optimization. - Handle edge cases like numerical underflow and overflow during training. - Comments and docstrings are encouraged for code clarity. # Example Usage ```python training_samples = [[0.5, 1.4], [1.3, 0.3], [0.7, 1.1], [1.6, 1.9]] labels = [0, 1, 0, 1] epochs = 1000 lr = 0.01 # Train logistic regression model parameters = train(training_samples, labels, epochs, lr) # Predict a new sample sample = [1.2, 0.4] predicted_class = predict(parameters, sample) print(f\\"Predicted class: {predicted_class}\\") print(f\\"Trained parameters: {parameters}\\") ```","solution":"import numpy as np def softmax(logits: list[float]) -> list[float]: Compute the softmax activation for the given input vector. Args: - logits (list[float]): Input vector of logits. Returns: - list[float]: Softmax probabilities. exp_logits = np.exp(logits - np.max(logits)) # Subtract max for numerical stability return (exp_logits / np.sum(exp_logits)).tolist() def cross_entropy_loss(predicted: list[float], actual: list[int]) -> float: Compute the cross-entropy loss for the given predicted and actual labels. Args: - predicted (list[float]): Predicted probabilities. - actual (list[int]): One-hot encoded actual labels. Returns: - float: Cross-entropy loss. predicted = np.clip(predicted, 1e-15, 1 - 1e-15) # Avoid log(0) return -np.sum(np.array(actual) * np.log(np.array(predicted))) def train(training_samples: list[list[float]], labels: list[int], epochs: int, lr: float) -> dict: Train the multi-class logistic regression model. Args: - training_samples (list[list[float]]): Matrix of training samples. - labels (list[int]): List of class labels for the training samples. - epochs (int): Number of training epochs. - lr (float): Learning rate. Returns: - dict: Trained parameters (weights and bias). X = np.array(training_samples) y = np.array(labels) m, n = X.shape # Number of samples and number of features num_classes = len(np.unique(y)) W = np.zeros((num_classes, n)) b = np.zeros(num_classes) for epoch in range(epochs): linear_output = np.dot(X, W.T) + b predictions = np.apply_along_axis(softmax, 1, linear_output) y_one_hot = np.eye(num_classes)[y] loss = cross_entropy_loss(predictions, y_one_hot) gradients_w = -np.dot((y_one_hot - predictions).T, X) / m gradients_b = -np.mean(y_one_hot - predictions, axis=0) W -= lr * gradients_w b -= lr * gradients_b return {\'weights\': W, \'bias\': b} def predict(parameters: dict, sample: list[float]) -> int: Predict the class for a given sample using the trained model. Args: - parameters (dict): Trained model parameters. - sample (list[float]): Input sample vector. Returns: - int: Predicted class label. W = parameters[\'weights\'] b = parameters[\'bias\'] logits = np.dot(sample, W.T) + b probabilities = softmax(logits.tolist()) return np.argmax(probabilities)"},{"question":"# Question Write a function that reads a string representing a mathematical expression and evaluates it. The expression will only contain non-negative integers, operators (\'+\', \'-\', \'*\', \'/\'), and parentheses. The function should correctly handle the order of operations (PEMDAS) and return the result as a float if any division operation is performed, otherwise as an integer. Function Signature ```python def evaluate_math_expression(expression: str) -> float: Evaluate a mathematical expression and return the result. :param expression: A string representing a mathematical expression. :return: A float representing the result of the evaluation. pass ``` Input - `expression`: A string containing a valid mathematical expression. The expression will only contain non-negative integers, `+`, `-`, `*`, `/`, and parentheses. Output - A float representing the result. If no division is involved, the result should be an integer. Constraints - The expression will be a valid mathematical expression. - The function should handle expressions up to length 1000 characters. - Division results should be represented as floats, even if the result is a whole number. Example Given the following inputs: ```python expression = \\"3 + 2 * (1 + 2)\\" ``` The function should return: ```python 9.0 ``` Given the following inputs: ```python expression = \\"10 / 2 + 5 * (3 - 1)\\" ``` The function should return: ```python 15.0 ``` Given the following inputs: ```python expression = \\"7 + (6 * 5^2 + 3)\\" ``` The function should return: ```python 160.0 ``` Steps 1. Implement a function to parse the expression. 2. Evaluate the parsed expression while considering the order of operations. 3. Handle nested operations within parentheses. 4. Return the result as a float if any division operation is involved, else return as an integer.","solution":"def evaluate_math_expression(expression: str) -> float: def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return a / b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue if tokens[i] == \'(\': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while len(ops) != 0 and ops[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return float(evaluate(expression))"},{"question":"# Scenario You have been assigned the task of developing a tool for automatically generating short URLs for a URL shortening service. The tool needs to support the process of encoding full URLs into unique shortened URLs and decoding these shortened URLs back into their original form. # Task Write a class `URLShortener` that can encode long URLs into shortened URLs and decode shortened URLs back to their original form. # Class `URLShortener` Method 1: `encode` - **Input**: A string `url` representing the full URL to be shortened. - **Output**: A string representing the shortened URL. Method 2: `decode` - **Input**: A string `shortUrl` representing the shortened URL. - **Output**: A string representing the original long URL. # Example ```python url_shortener = URLShortener() # Encode short_url = url_shortener.encode(\\"https://www.example.com/path/to/resource\\") assert short_url.startswith(\\"http://short.url/\\") # Decode original_url = url_shortener.decode(short_url) assert original_url == \\"https://www.example.com/path/to/resource\\" ``` # Constraints - Ensure that each long URL maps to a unique shortened URL. - Ensure that the same long URL always maps to the same shortened URL. - Implement error handling for invalid inputs and edge cases. - Optimize for collision resistance and efficiency. # Notes - You may assume that URLs consist of ASCII characters only. - Solutions that directly reference existing code or solutions may result in immediate disqualification. - Provide necessary documentation and comments for the clarity of your implementation.","solution":"import hashlib class URLShortener: def __init__(self): self.url_to_short = {} self.short_to_url = {} self.short_url_prefix = \\"http://short.url/\\" def encode(self, url): Encodes a long URL to a shortened URL. Parameters: url (str): The original URL to be shortened. Returns: str: The shortened URL. if url in self.url_to_short: return self.url_to_short[url] # Create a unique hash of the URL short_hash = hashlib.md5(url.encode()).hexdigest()[:6] short_url = self.short_url_prefix + short_hash # Store the mapping between the original URL and the shortened URL self.url_to_short[url] = short_url self.short_to_url[short_url] = url return short_url def decode(self, shortUrl): Decodes a shortened URL to its original URL. Parameters: shortUrl (str): The shortened URL to be expanded. Returns: str: The original URL. return self.short_to_url.get(shortUrl, \\"\\") # For testing purposes url_shortener = URLShortener() short_url = url_shortener.encode(\\"https://www.example.com/path/to/resource\\") print(short_url) # Expect: http://short.url/some_hash_value original_url = url_shortener.decode(short_url) print(original_url) # Expect: https://www.example.com/path/to/resource"},{"question":"# Coding Task: Implement Circular Linked List Merge Background You are provided with the implementation of a circular singly linked list. Your task is to write a function to merge two such circular linked lists into one sorted circular linked list. Function Signature ```python class Node: def __init__(self, data): self.data = data self.next = None def merge_circular_lists(head1, head2): Merges two circular linked lists into one sorted circular linked list. head1 : Node The head of the first circular linked list. head2 : Node The head of the second circular linked list. Returns the head of the merged sorted circular linked list. >>> n1 = Node(1) >>> n2 = Node(3) >>> n3 = Node(5) >>> n1.next = n2 >>> n2.next = n3 >>> n3.next = n1 >>> m1 = Node(2) >>> m2 = Node(4) >>> m3 = Node(6) >>> m1.next = m2 >>> m2.next = m3 >>> m3.next = m1 >>> new_head = merge_circular_lists(n1, m1) >>> result = [] >>> current = new_head >>> while True: >>> result.append(current.data) >>> current = current.next >>> if current == new_head: >>> break >>> result [1, 2, 3, 4, 5, 6] ``` Input 1. **head1**: The head node of the first circular linked list. 2. **head2**: The head node of the second circular linked list. Output * Returns the head of the merged sorted circular linked list. Constraints * The number of nodes in each list is less than 10^4. * All nodes contain integer values. * The circular linked lists are already sorted individually. Example ```python n1 = Node(1) n2 = Node(3) n3 = Node(5) n1.next = n2 n2.next = n3 n3.next = n1 m1 = Node(2) m2 = Node(4) m3 = Node(6) m1.next = m2 m2.next = m3 m3.next = m1 new_head = merge_circular_lists(n1, m1) result = [] current = new_head while True: result.append(current.data) current = current.next if current == new_head: break print(result) # Output: [1, 2, 3, 4, 5, 6] ``` In this task, you are required to merge the two given sorted circular linked lists into a single sorted circular linked list without any duplicates.","solution":"class Node: def __init__(self, data): self.data = data self.next = None def merge_circular_lists(head1, head2): # Helper function to break the circular nature of the list def break_circle(head): if not head: return None current = head while current.next != head: current = current.next current.next = None return head # Helper function to form the circular list def form_circle(head): if not head: return None current = head while current.next: current = current.next current.next = head return head # Helper function to merge two normal sorted linked lists def merge_sorted_lists(l1, l2): dummy = Node(0) tail = dummy while l1 and l2: if l1.data < l2.data: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 if l2: tail.next = l2 return dummy.next # Break the circular nature of both lists head1 = break_circle(head1) head2 = break_circle(head2) # Merge the two non-circular lists merged_head = merge_sorted_lists(head1, head2) # Form the circular list merged_head = form_circle(merged_head) return merged_head"},{"question":"Question: Implement Linked List Operations You are tasked with implementing a linked list class and some fundamental operations associated with it. This will test your understanding of data structures, specifically linked lists, their traversal, and manipulation. # Class to Implement Create a class named `LinkedList` which supports the following functionalities: 1. **Insert at End**: Insert a new element at the end of the linked list. ```python def insert_at_end(self, value: int) -> None: pass ``` 2. **Delete by Value**: Delete the first occurrence of the specified value from the linked list. ```python def delete_by_value(self, value: int) -> None: pass ``` 3. **Search**: Search for a value in the linked list and return its position if found, otherwise return -1. Positioning starts from 0. ```python def search(self, value: int) -> int: pass ``` 4. **Get Size**: Return the number of elements currently in the linked list. ```python def size(self) -> int: pass ``` 5. **Convert to List**: Convert the linked list into a Python list. ```python def to_list(self) -> List[int]: pass ``` # Node Class To achieve the above functionalities, define a helper class `Node` that represents the structure of each element in the linked list. # Input & Output Specifications: - Implement proper constructors for your classes. - Raise `ValueError` if an operation cannot be performed (e.g., deleting a value not present in the list). - Define `__str__()` method for the `LinkedList` class to visualize the contents of the linked list. # Example Usage: ```python # Example Node class: class Node: def __init__(self, value: int): self.value = value self.next = None # Example LinkedList class with implementations: class LinkedList: def __init__(self): self.head = None def insert_at_end(self, value: int) -> None: new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete_by_value(self, value: int) -> None: current = self.head if current is None: raise ValueError(f\\"Value {value} not found in the list.\\") if current.value == value: self.head = current.next return while current.next and current.next.value != value: current = current.next if current.next is None: raise ValueError(f\\"Value {value} not found in the list.\\") current.next = current.next.next def search(self, value: int) -> int: current = self.head index = 0 while current: if current.value == value: return index current = current.next index += 1 return -1 def size(self) -> int: current = self.head count = 0 while current: count += 1 current = current.next return count def to_list(self) -> List[int]: result = [] current = self.head while current: result.append(current.value) current = current.next return result def __str__(self) -> str: return \\" -> \\".join(str(value) for value in self.to_list()) # Example usage: linked_list = LinkedList() linked_list.insert_at_end(3) linked_list.insert_at_end(5) linked_list.insert_at_end(7) print(linked_list) # Output: \\"3 -> 5 -> 7\\" linked_list.delete_by_value(5) print(linked_list) # Output: \\"3 -> 7\\" print(linked_list.search(7)) # Output: 1 print(linked_list.size()) # Output: 2 print(linked_list.to_list()) # Output: [3, 7] ``` # Constraints: - Nodes in the linked list are integers. - The linked list can contain a maximum of 1000 nodes. # Performance Requirements: Ensure the operations perform efficiently for the linked list with up to 1000 nodes.","solution":"from typing import List class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert_at_end(self, value: int) -> None: new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete_by_value(self, value: int) -> None: current = self.head if current is None: raise ValueError(f\\"Value {value} not found in the list.\\") if current.value == value: self.head = current.next return while current.next and current.next.value != value: current = current.next if current.next is None: raise ValueError(f\\"Value {value} not found in the list.\\") current.next = current.next.next def search(self, value: int) -> int: current = self.head index = 0 while current: if current.value == value: return index current = current.next index += 1 return -1 def size(self) -> int: current = self.head count = 0 while current: count += 1 current = current.next return count def to_list(self) -> List[int]: result = [] current = self.head while current: result.append(current.value) current = current.next return result def __str__(self) -> str: return \\" -> \\".join(str(value) for value in self.to_list())"},{"question":"# Coding Assessment Question Context You are given a number and your task is to search for specific patterns within the factors of this number. Problem Statement Given a positive integer `n`, find the sum of all factors of `n` that are prime numbers. Write a function `sum_of_prime_factors` that implements this computation. Function Signature ```python def sum_of_prime_factors(n: int) -> int: Returns the sum of all prime factors of the given number \'n\'. Args: n : int : a positive integer (2 ≤ n ≤ 10^6) Returns: int: The sum of all prime factors of \'n\'. pass ``` Constraints - The input `n` will be an integer such that ( 2 le n le 10^6 ). - The function should efficiently compute the factors and check their primality. Examples ```python # Example 1 print(sum_of_prime_factors(28)) # Output: 10 # Explanation: The factors of 28 are 1, 2, 4, 7, 14, and 28. The prime factors are 2 and 7. Their sum is 2 + 7 = 9. # Example 2 print(sum_of_prime_factors(60)) # Output: 10 # Explanation: The factors of 60 are 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, and 60. The prime factors are 2, 3, and 5. Their sum is 2 + 3 + 5 = 10. # Example 3 print(sum_of_prime_factors(100)) # Output: 5 # Explanation: The factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50, and 100. The prime factors are 2 and 5. Their sum is 2 + 5 = 7. ``` **Note**: - Ensure to handle large values of `n` efficiently. - You may write helper functions to check for primality or to factorize the number.","solution":"def sum_of_prime_factors(n: int) -> int: def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # To store prime numbers using Sieve of Eratosthenes max_limit = n + 1 sieve = [True] * max_limit p = 2 while (p * p <= n): if (sieve[p] == True): for i in range(p * p, max_limit, p): sieve[i] = False p += 1 prime_factors_sum = 0 # Check for each number if it is a factor and prime for i in range(2, n + 1): if n % i == 0 and sieve[i]: prime_factors_sum += i return prime_factors_sum"},{"question":"# Question: Binary Search with Bitwise Operations Context: Binary Search is an efficient algorithm for finding an element in a sorted array. It operates using divide-and-conquer to systematically reduce the search space. Traditional binary search uses arithmetic operations to calculate the middle index. However, you can also implement it using bitwise operations, which may offer a marginal performance benefit due to lower-level computations. Objective: Implement a binary search function using bitwise operations to calculate the middle index in each iteration. Requirements: 1. Implement a function `bitwise_binary_search(sorted_list: list[int], target: int) -> int | None` that performs binary search on a given sorted list of integers and uses bitwise operations to find the middle index. 2. The function should return the index of the target if found; otherwise, return `None`. 3. Ensure the function handles edge cases such as an empty list, a single-element list, and values not present in the list. Input: - `sorted_list`: A list of integers sorted in ascending order. - `target`: An integer value to search for in the list. Output: - The index of the target value in the sorted list, or `None` if the target is not found. Constraints: - The length of `sorted_list` will not exceed 10^6. Example: ```python # Example usage print(bitwise_binary_search([1, 2, 3, 4, 5], 3)) # Output: 2 print(bitwise_binary_search([10, 20, 30, 40, 50], 15)) # Output: None print(bitwise_binary_search([], 1)) # Output: None print(bitwise_binary_search([100], 100)) # Output: 0 print(bitwise_binary_search([1, 3, 5, 7, 9, 11, 13, 15, 17], 15)) # Output: 7 ``` ```python # Function definition skeleton def bitwise_binary_search(sorted_list: list[int], target: int) -> int | None: # Write your implementation here pass # You can create your tests using the examples provided ```","solution":"def bitwise_binary_search(sorted_list, target): Perform a binary search using bitwise operations to find the target in the sorted list. Parameters: sorted_list (list[int]): a list of integers sorted in ascending order target (int): the target integer to search for Returns: int | None: the index of the target if found, otherwise None left, right = 0, len(sorted_list) - 1 while left <= right: mid = left + ((right - left) >> 1) if sorted_list[mid] == target: return mid elif sorted_list[mid] < target: left = mid + 1 else: right = mid - 1 return None"},{"question":"# Creating an Image Filter Pipeline You are working on an image processing application and need to implement a pipeline for applying a series of filters to an image. Each filter transforms the image in a specific way, such as blurring, sharpening, or edge detection. You will implement a function that applies a series of these filters to an input image. Task Description: Implement a function `apply_filters` that: - Takes as input: * `image` (np.ndarray): The input image as a 2D numpy array (grayscale). * `filters` (List[Callable[[np.ndarray], np.ndarray]]): A list of filter functions. Each filter function takes an image (np.ndarray) as input and returns a transformed image (np.ndarray). - Returns: * A numpy array representing the final transformed image after applying all the filters in sequence. Constraints: - The input image will be a valid 2D numpy array with pixel values ranging from 0 to 255. - The `filters` list will contain at least one filter function. - Each filter function in the `filters` list will be properly defined and will return a valid numpy array of the same shape as the input image. Notes: - Ensure that the function handles images of various resolutions efficiently. - Optimize for performance to handle large images. - Include edge detection for boundary conditions to prevent errors during filter application. Example Usage: ```python >>> import numpy as np >>> from scipy.ndimage import gaussian_filter, sobel >>> def blur_filter(image): >>> return gaussian_filter(image, sigma=1.0) >>> def edge_detection_filter(image): >>> return sobel(image) >>> image = np.random.randint(0, 256, (100, 100), dtype=np.uint8) >>> filters = [blur_filter, edge_detection_filter] >>> transformed_image = apply_filters(image, filters) >>> transformed_image.shape (100, 100) ```","solution":"import numpy as np from typing import List, Callable def apply_filters(image: np.ndarray, filters: List[Callable[[np.ndarray], np.ndarray]]) -> np.ndarray: Applies a series of filters to an image. Parameters: - image (np.ndarray): The input image as a 2D numpy array (grayscale). - filters (List[Callable[[np.ndarray], np.ndarray]]): A list of filter functions. Returns: - np.ndarray: The final transformed image. for filter_func in filters: image = filter_func(image) return image"},{"question":"# Scenario You are working on a project to streamline the process of processing natural language text data. As part of this, you need to clean and preprocess textual data by removing any stopwords. A stopword is a commonly used word (such as \\"the\\", \\"a\\", \\"an\\", \\"in\\") that a search engine has been programmed to ignore, both when indexing entries for searching and when retrieving them as the result of a search query. # Task Write a Python function `remove_stopwords(text, stopwords)` that: 1. Takes a string of text and a list of stopwords as input. 2. Removes all stopwords from the text. 3. Preserves the original order of the non-stopword words. 4. Returns the cleaned text as a string. # Input Format * `text` (string): The input text to be cleaned. * `stopwords` (list of strings): The list of stopwords to be removed from the text. # Output Format * A single string representing the cleaned text with all stopwords removed. # Constraints 1. The input `text` is a non-empty string. 2. The `stopwords` list contains only lowercase words and is non-empty. 3. The provided text may contain punctuation and mixed case words. # Example ```python text = \\"This is an example of text processing. It\'s designed to remove the stopwords efficiently.\\" stopwords = [\\"this\\", \\"is\\", \\"an\\", \\"of\\", \\"to\\", \\"the\\"] assert remove_stopwords(text, stopwords) == \\"example text processing. It\'s designed remove stopwords efficiently.\\" ``` # Requirements 1. The function should handle case sensitivity appropriately (e.g., \'This\' and \'this\' should both be considered stopwords if \'this\' is in the list). 2. Consider using Python\'s `str.split()` and `str.join()` methods for efficient string manipulation. 3. Implement the function in an efficient manner, ensuring that the runtime complexity is acceptable for large inputs.","solution":"def remove_stopwords(text, stopwords): Removes all stopwords from the input text. Args: text (str): The input text to be cleaned. stopwords (list): The list of stopwords to be removed from the text. Returns: str: The cleaned text with all stopwords removed. words = text.split() cleaned_words = [word for word in words if word.lower().strip(\\".,!?;:\'\\"\\") not in stopwords] return \\" \\".join(cleaned_words)"},{"question":"# Binary Search Tree Operations Context You are familiar with binary search trees (BST), which are efficient data structures for maintaining ordered data. Given a BST, you can perform standard operations like insertion, deletion, and searching. This question extends your knowledge by focusing on additional operations like finding the kth smallest element and checking for a valid BST. Task 1. **Insertion**: Implement a method to insert a new value into the BST while maintaining its properties. 2. **Deletion**: Implement a method to delete a value from the BST while maintaining its properties. 3. **Finding kth Smallest Element**: Implement a method to find the kth smallest element in the BST. 4. **Valid BST Check**: Implement a method to verify if a given binary tree is a valid BST. Function Signatures You are to implement the following methods in a class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: ... def delete(self, val: int) -> None: ... def find_kth_smallest(self, k: int) -> int: ... def is_valid_bst(self, node: TreeNode = None, low=float(\'-inf\'), high=float(\'inf\')) -> bool: ... ``` Constraints - The BST must not contain duplicate values. - Assume all inputs are valid integers within the range [-10^4, 10^4]. - For `find_kth_smallest`, `k` is guaranteed to be valid (1 ≤ k ≤ N, where N is the number of nodes in the BST). - The `is_valid_bst` method should work correctly even for an empty tree. Example Suppose we perform a sequence of operations on an initially empty BST: ```python bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) print(bst.find_kth_smallest(3)) # Output: 4 bst.delete(5) print(bst.is_valid_bst(bst.root)) # Output: True ``` After these operations, the tree should be: ``` 6 / 3 7 / 2 4 8 ``` Ensure that all operations maintain the BST properties and the output should match expected results.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right = self._delete(node.right, min_larger_node.val) return node def _get_min(self, node): while node.left: node = node.left return node def find_kth_smallest(self, k: int) -> int: stack = [] current = self.root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() k -= 1 if k == 0: return current.val current = current.right def is_valid_bst(self, node: TreeNode = None, low=float(\'-inf\'), high=float(\'inf\')) -> bool: if node is None: return True if not (low < node.val < high): return False return (self.is_valid_bst(node.left, low, node.val) and self.is_valid_bst(node.right, node.val, high))"},{"question":"# Question: First Non-Repeated Character in a String Context: Identifying the first non-repeated character in a string is a common task that has applications in various text-processing and data-validation scenarios. This task tests your knowledge of string manipulation, data structures for counting occurrences, and algorithm design. Task: Write a function `first_non_repeated(s: str) -> str` that takes a string `s`, and returns the first character that does not repeat in the string. If no such character exists, return an empty string. Input: - A single string `s` containing only lowercase alphabetical characters, where `1 <= len(s) <= 10^5`. Output: - A single character which is the first non-repeated character or an empty string if all characters are repeated. Constraints: - The input string contains only lowercase English letters. - If the input is not a string, the function should raise a `TypeError` with the message `\\"input must be a string\\"`. Examples: ```python first_non_repeated(\\"swiss\\") # Returns: \\"w\\" first_non_repeated(\\"programming\\") # Returns: \\"p\\" first_non_repeated(\\"aabbcc\\") # Returns: \\"\\" first_non_repeated(\\"example\\") # Returns: \\"e\\" ``` Notes: - The function should efficiently handle strings up to the maximum size constraint. - You may assume the input is a valid string unless specified otherwise in the problem constraints.","solution":"def first_non_repeated(s: str) -> str: Returns the first non-repeated character in the string s. If no such character exists, returns an empty string. if not isinstance(s, str): raise TypeError(\\"input must be a string\\") char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"# Coding Challenge **Scenario**: You are provided with a list of words. Your task is to find the longest word in the list that can be constructed by concatenating other words from the list (including the word itself multiple times). **Function Signature**: ```python def longest_concatenated_word(words: list[str]) -> str: pass ``` # Input * `words` (list[str]): A list of strings representing the input words. # Output * (str): The longest word that can be constructed by concatenating other words from the list. If there are multiple words with the same length, return the lexicographically smallest one. If no such word exists, return an empty string. # Constraints * (1 leq |words| leq 1000) * (1 leq text{length of each word} leq 100) * All words contain only lowercase English letters. # Examples **Example 1** * Input: ```python words = [\\"cat\\", \\"dog\\", \\"catdog\\"] ``` * Output: `\\"catdog\\"` **Example 2** * Input: ```python words = [\\"apple\\", \\"banana\\", \\"app\\", \\"le\\", \\"appapple\\"] ``` * Output: `\\"appapple\\"` **Example 3** * Input: ```python words = [\\"hello\\", \\"world\\"] ``` * Output: `\\"\\"` # Guidelines: * Implement a function that checks if a word can be constructed by concatenating other words from the list using a dynamic programming approach or recursion with memoization. * Ensure the function handles edge cases such as words that cannot be concatenated from any other words, or lists with a single word. * Consider both time and space complexity, and optimize the solution accordingly. * Your solution should properly address cases where multiple longest words of the same length exist by returning the lexicographically smallest one.","solution":"def can_form(word, word_set, memo): if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in word_set and (suffix in word_set or can_form(suffix, word_set, memo)): memo[word] = True return True memo[word] = False return False def longest_concatenated_word(words): word_set = set(words) longest_word = \\"\\" memo = {} for word in words: if can_form(word, word_set, memo): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"# Scenario A popular social media platform requires an efficient way to manage and search through user posts. Each post is represented as a string, and the goal is to implement a simple search functionality that looks for the presence of a specific keyword within the posts. # Task Write a Python function `search_posts` that takes two parameters: 1. `posts`: A list of strings, where each string represents a user post. 2. `keyword`: A string representing the keyword to search for. The function should: 1. Search through each post in the `posts` list. 2. Return a list of all posts that contain the `keyword`. 3. Perform a case-insensitive search for the `keyword`. # Input * `posts`: A list of strings. Each string is a user post and can contain multiple words and characters. * `keyword`: A string representing the keyword to search for. # Output * A list of strings. Each string is a user post that contains the keyword. # Constraints * The `posts` list can contain up to 10,000 posts. * Each post string can be of arbitrary length. * The search should ignore case (i.e., be case-insensitive). # Example ```python def search_posts(posts: list[str], keyword: str) -> list[str]: return [post for post in posts if keyword.lower() in post.lower()] # Example of usage posts = [ \\"This is the first post\\", \\"Another insightful post about Python\\", \\"Yet another post that we should consider\\" ] keyword = \\"post\\" print(search_posts(posts, keyword)) # Output: [\'This is the first post\', \'Another insightful post about Python\', \'Yet another post that we should consider\'] ``` The function should return a list of all posts that contain the keyword, ignoring case differences.","solution":"def search_posts(posts, keyword): Returns a list of posts that contain the keyword (case-insensitive). Parameters: posts (list of str): List of user posts. keyword (str): The keyword to search for. Returns: list of str: List of posts containing the keyword. return [post for post in posts if keyword.lower() in post.lower()]"},{"question":"Question: Develop a function to reverse the order of words in a given sentence. This task will measure your ability to manipulate strings and handle various edge cases in a sentence format while maintaining efficient performance. # Requirements: 1. **Function**: `def reverse_words(sentence: str) -> str:` 2. **Input**: * A string `sentence` that represents a sentence, e.g., `\\"The quick brown fox\\"`. 3. **Output**: * A string with the words in reverse order. 4. **Constraints**: * The input string can be empty or contain up to 10^5 characters. * Words are separated by a single space. * There will be no leading or trailing spaces and the sentence will have at least one word other than an empty case. # Scenario: You\'re building a text manipulation library for your software. One of the requested features is an ability to reverse the order of words in a given sentence, to create a \\"mirror\\" effect. This transformation must be applied quickly and handle large input sizes efficiently. # Example: Input: `\\"The quick brown fox\\"` Output: `\\"fox brown quick The\\"` # Edge Cases to Consider: * Handle an empty string by returning an empty string. * Sentences with only one word should return the same word. # Additional Tests: Make sure your implementation passes the expected outputs for the following scenarios: 1. Input: `\\"Hello World\\"` Output: `\\"World Hello\\"` 2. Input: `\\"a b c d e\\"` Output: `\\"e d c b a\\"` 3. Input: `\\"\\"` Output: `\\"\\"` # Instructions: * Implement your solution in Python. * Ensure your code is well-structured and includes necessary comments for clarity. * Test your solution against multiple test cases to verify correctness.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. Args: sentence (str): A string representing a sentence. Returns: str: A string with the words in reverse order. if not sentence: return \\"\\" words = sentence.split() reversed_words = words[::-1] return \\" \\".join(reversed_words)"},{"question":"# Permutation in String Scenario You are given two strings `s1` and `s2`, and you need to determine if `s2` contains a permutation of `s1`. In other words, check if one of `s1`\'s permutations is a substring of `s2`. This problem often arises in scenarios related to string manipulation, pattern matching, and searching algorithms. Problem # Function Signature ```python def check_inclusion(s1: str, s2: str) -> bool: ``` # Input * `s1` (string): The first string (source). * `s2` (string): The second string (target). # Output * `bool`: `True` if `s2` contains a permutation of `s1`, otherwise `False`. # Constraints * `1 <= len(s1) <= 1000` * `1 <= len(s2) <= 10000` * Both strings contain only lowercase English letters. Example ```python >>> check_inclusion(\\"ab\\", \\"eidbaooo\\") True >>> check_inclusion(\\"ab\\", \\"eidboaoo\\") False ``` Requirements * Implement the function using a sliding window technique along with frequency counting. * Ensure to handle edge cases such as when `s1` is larger than `s2`.","solution":"from collections import Counter def check_inclusion(s1: str, s2: str) -> bool: Check if s2 contains a permutation of s1. len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return False s1_count = Counter(s1) window_count = Counter(s2[:len_s1]) if s1_count == window_count: return True for i in range(len_s1, len_s2): window_count[s2[i]] += 1 window_count[s2[i - len_s1]] -= 1 if window_count[s2[i - len_s1]] == 0: del window_count[s2[i - len_s1]] if s1_count == window_count: return True return False"},{"question":"# Coding Assessment Question You are presented with the challenge of implementing a function that parses and evaluates mathematical expressions involving basic arithmetic operations, including addition, subtraction, multiplication, division, and parentheses. Your task is to develop a function that accurately computes the result of such expressions, respecting the order of operations (PEMDAS/BODMAS rule). Function Signature ```python def evaluate_expression(expression): pass ``` Input/Output * **Input**: - `expression`: A string representing a mathematical expression (e.g., \\"3 + 5 * (2 - 8)\\"). * **Output**: - Returns a float or integer representing the computed result of the expression. Constraints * The expression will contain only digits (0-9), parentheses `()`, and the operators `+`, `-`, `*`, `/`. * The input string will be a valid mathematical expression with no syntax errors. * Division by zero will not occur in any input expression. * The evaluation should handle nested and multiple levels of parentheses. Scenario Imagine you are working on a scientific calculator and need an efficient way to evaluate complex mathematical expressions entered by users. Your implementation should ensure that the expressions are evaluated strictly according to the order of operations to return correct results. Example ```python # Example usage print(evaluate_expression(\\"3 + 5 * 2\\")) # Output: 13 print(evaluate_expression(\\"(1 + 2) * (3 / 4)\\")) # Output: 2.25 print(evaluate_expression(\\"10 * (6 / (1 + 2))\\")) # Output: 20 ``` Note It is advisable to implement a two-pass algorithm where the first pass converts the input expression into a format (like Reverse Polish Notation) that can be easily evaluated in the second pass, ensuring proper handling of parentheses and operator precedence.","solution":"import operator import re def evaluate_expression(expression): Evaluates a mathematical expression string and returns the result. Args: expression (str): The mathematical expression to evaluate. Returns: float or int: The result of the evaluated expression. # Operator precedence and corresponding functions ops = { \'+\': (1, operator.add), \'-\': (1, operator.sub), \'*\': (2, operator.mul), \'/\': (2, operator.truediv) } def parse_expression(expression): Parses the mathematical expression into tokens. Args: expression (str): The expression to parse. Returns: list: Tokens in the expression. tokens = re.findall(r\'d+|[-+*/()]\', expression) return tokens def shunting_yard(tokens): Converts infix notation to Reverse Polish Notation (RPN) using the shunting yard algorithm. Args: tokens (list): List of tokens in the infix expression. Returns: list: Tokens in RPN. output = [] operators = [] for token in tokens: if token.isdigit(): output.append(int(token)) elif token in ops: while (operators and operators[-1] in ops and ops[token][0] <= ops[operators[-1]][0]): output.append(operators.pop()) operators.append(token) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': output.append(operators.pop()) operators.pop() # Remove \'(\' from stack while operators: output.append(operators.pop()) return output def evaluate_rpn(tokens): Evaluates an expression in Reverse Polish Notation (RPN). Args: tokens (list): List of tokens in RPN. Returns: float: The result of the evaluated RPN expression. stack = [] for token in tokens: if isinstance(token, int): stack.append(token) else: b = stack.pop() a = stack.pop() stack.append(ops[token][1](a, b)) return stack[0] tokens = parse_expression(expression) rpn_tokens = shunting_yard(tokens) result = evaluate_rpn(rpn_tokens) return result"},{"question":"# Stock Prices Fluctuation Visualization You are tasked with creating a visualization tool for a given list of daily stock prices. The tool should generate an output that visualizes the trend of the stock prices in a visually intuitive manner, using asterisks (*) to represent each day\'s price point. Function Signature: ```python def visualize_stock_prices(prices: list[int]) -> str: \'\'\' :param prices: a list of integers representing daily stock prices. :return: a string that visualizes the stock prices trend. \'\'\' ``` Input: * `prices` (1 <= len(prices) <= 100, 1 <= prices[i] <= 100): A list of integers representing daily stock prices. Output: * A string with each line representing the price of a stock on a particular day using asterisks (*). Each line should contain the price value followed by that many asterisks. Example: ```python # Example 1: # Input: prices = [3, 5, 7, 6] # Output: \'\'\' 3: *** 5: ***** 7: ******* 6: ****** \'\'\' # Example 2: # Input: prices = [1, 10, 3, 4, 7] # Output: \'\'\' 1: * 10: ********** 3: *** 4: **** 7: ******* \'\'\' # Example 3: # Input: prices = [2, 2, 2, 2] # Output: \'\'\' 2: ** 2: ** 2: ** 2: ** \'\'\' ``` Implementation Notes: 1. Validate the input parameter to ensure it adheres to the given constraints. 2. Iterate through the list of prices and generate a corresponding string for each day\'s price, appending the price followed by that many asterisks. 3. Concatenate and return the generated strings in the same order as the input list. Implement the function `visualize_stock_prices` according to the above requirements.","solution":"def visualize_stock_prices(prices: list[int]) -> str: \'\'\' :param prices: a list of integers representing daily stock prices. :return: a string that visualizes the stock prices trend. \'\'\' visualization = [] for price in prices: visualization.append(f\\"{price}: {\'*\' * price}\\") return \'n\'.join(visualization)"},{"question":"**Task**: Implement a function that determines the maximum product obtainable from splitting a number into the sum of several positive integers. # Scenario You are working on a problem where you need to split a positive integer `n` into at least two positive integers, such that when multiplied together, they produce the maximum possible product. This task involves understanding dynamic programming concepts to find the optimal solution efficiently. # Implementation Write a function called `max_product_partition` that adheres to the following signature: ```python def max_product_partition(n: int) -> int: Determines the maximum product obtained by partitioning the integer `n` into the sum of at least two positive integers. Parameters: - n (int): The integer to be partitioned. Returns: - int: The maximum product obtained from the partitions. ``` # Requirements 1. Implement the logic to compute the maximum product, ensuring efficiency. 2. Use dynamic programming to optimize the computation. 3. Handle base cases correctly (e.g., n <= 2). 4. Ensure correctness and efficiency, running ideally in O(n^2) time complexity. # Constraints - The input integer `n` is a positive integer between 2 and 58 inclusive. # Example Usage ```python print(max_product_partition(2)) # Expected output: 1 (1+1) print(max_product_partition(10)) # Expected output: 36 (3+3+4 or equivalent) print(max_product_partition(15)) # Expected output: 243 (3*3*3*3*3 or equivalent) print(max_product_partition(8)) # Expected output: 18 (3+3+2 or equivalent) ``` # Notes - Ensure to test your implementation against edge cases and verify its correctness. - Discuss any assumptions or improvements you made while implementing the function. # Explanation - The function takes an integer `n` and finds the maximum product achievable by partitioning the number into a sum of at least two integers. - Dynamic Programming (DP) is a suitable approach here, where we maintain an array `dp` such that `dp[i]` represents the maximum product obtainable for the integer `i`. - For each integer, we try every possible split and update the DP table to reflect the maximum product obtainable from the splits. - The result is stored in `dp[n]` after considering all possible partitions. # Detailed Example For `n = 10`, possible partitions could include: - `3 + 3 + 4` which gives `3*3*4 = 36` - `2 + 2 + 6` which gives `2*2*6 = 24` From all possible combinations, `3 + 3 + 4` gives the highest product, so the function should return `36`.","solution":"def max_product_partition(n: int) -> int: Determines the maximum product obtained by partitioning the integer `n` into the sum of at least two positive integers. Parameters: - n (int): The integer to be partitioned. Returns: - int: The maximum product obtained from the partitions. if n <= 2: return 1 # dp[i] will store the maximum product obtainable for integer i dp = [0] * (n + 1) # Initialize base cases dp[1] = 1 dp[2] = 1 for i in range(3, n + 1): for j in range(1, i): dp[i] = max(dp[i], max(j, dp[j]) * (i - j)) return dp[n]"},{"question":"# Coding Assessment Question You have been tasked with developing a budgeting application for a small business. The application must allow users to track and manage income, expenses, and budget projections for various categories (e.g., marketing, salaries, utilities). # Objective Implement a class `BudgetTracker` that allows users to: 1. Add income or expenses to specific categories. 2. Retrieve the current balance for a category. 3. Get the total income, total expenses, and net balance. 4. Project the future balance based on a monthly projection value for each category. # Requirements 1. **Attributes**: - `categories` (dict): A dictionary where keys are category names and values are the balance (income minus expenses) of each category. - `projections` (dict): A dictionary where keys are category names and values are tuples representing the projected monthly income and expenses `(projected_income, projected_expenses)` for each category. 2. **Methods**: - `add_transaction(category: str, amount: float, type: str) -> None`: Add an income or expense to a category. The `type` is either \\"income\\" or \\"expense\\". - `get_balance(category: str) -> float`: Retrieve the balance for a specific category. - `total_income() -> float`: Retrieve the total income across all categories. - `total_expenses() -> float`: Retrieve the total expenses across all categories. - `net_balance() -> float`: Compute the net balance (total income - total expenses). - `add_projection(category: str, projected_income: float, projected_expenses: float) -> None`: Add a monthly projection for a category. - `projected_balance(category: str, months: int) -> float`: Calculate future balance for a category based on its current balance and the monthly projections over a specified number of months. 3. **Input Constraints**: - `category` must be a non-empty string. - `amount` must be a real number. - `type` must be either \\"income\\" or \\"expense\\". - `projected_income` and `projected_expenses` must be real numbers. - `months` must be a positive integer. 4. **Output**: - If a specified category doesn\'t exist when trying to get a balance or add a projection, raise a `ValueError`. # Example Usage ```python # Create a budget tracker bt = BudgetTracker() # Add transactions bt.add_transaction(\\"marketing\\", 1000.0, \\"income\\") bt.add_transaction(\\"salaries\\", 2000.0, \\"expense\\") # Get balances print(bt.get_balance(\\"marketing\\")) # Output: 1000.0 print(bt.get_balance(\\"salaries\\")) # Output: -2000.0 # Add projections bt.add_projection(\\"marketing\\", 3000.0, 500.0) bt.add_projection(\\"salaries\\", 0.0, 2500.0) # Calculate projected balance print(bt.projected_balance(\\"marketing\\", 6)) # Output: 17500.0 print(bt.projected_balance(\\"salaries\\", 6)) # Output: -17000.0 # Get financial summary print(bt.total_income()) # Output: 1000.0 print(bt.total_expenses()) # Output: 2000.0 print(bt.net_balance()) # Output: -1000.0 ``` # Implementation Requirements 1. Define the `BudgetTracker` class with appropriate methods. 2. Handle edge cases and invalid inputs using exceptions. 3. Ensure performance is optimized for at least 100 transactions and projections. # Notes - Make sure to validate the inputs. - Implement the class and methods in a way that would be easy to extend with additional features in the future. - Test the class thoroughly with different scenarios to ensure correctness and robustness.","solution":"class BudgetTracker: def __init__(self): self.categories = {} self.projections = {} def add_transaction(self, category: str, amount: float, type: str) -> None: if not category: raise ValueError(\\"Category name cannot be empty.\\") if type not in [\\"income\\", \\"expense\\"]: raise ValueError(\\"Type must be either \'income\' or \'expense\'.\\") if category not in self.categories: self.categories[category] = 0.0 if type == \\"income\\": self.categories[category] += amount elif type == \\"expense\\": self.categories[category] -= amount def get_balance(self, category: str) -> float: if category not in self.categories: raise ValueError(f\\"Category \'{category}\' does not exist.\\") return self.categories[category] def total_income(self) -> float: income = 0.0 for category, balance in self.categories.items(): if balance > 0: income += balance return income def total_expenses(self) -> float: expenses = 0.0 for category, balance in self.categories.items(): if balance < 0: expenses += -balance return expenses def net_balance(self) -> float: return sum(self.categories.values()) def add_projection(self, category: str, projected_income: float, projected_expenses: float) -> None: if not category: raise ValueError(\\"Category name cannot be empty.\\") if category not in self.categories: raise ValueError(f\\"Category \'{category}\' does not exist.\\") self.projections[category] = (projected_income, projected_expenses) def projected_balance(self, category: str, months: int) -> float: if category not in self.projections: raise ValueError(f\\"No projections found for category \'{category}\'.\\") if months <= 0: raise ValueError(\\"Months must be a positive integer.\\") current_balance = self.get_balance(category) projected_income, projected_expenses = self.projections[category] return current_balance + months * (projected_income - projected_expenses)"},{"question":"# String Permutation Checker You are required to implement a function that checks if two given strings are permutations of each other. Two strings are considered to be permutations if one can be rearranged to form the other. Description: Implement a function `are_permutations(str1, str2)` which returns a boolean indicating whether the two input strings are permutations of each other. Input: - `str1`: A string consisting of lower case letters (a-z), with length ranging from 1 to 1000 characters. - `str2`: A string consisting of lower case letters (a-z), with length ranging from 1 to 1000 characters. Output: - Returns `True` if `str1` and `str2` are permutations of each other, `False` otherwise. Constraints: - The lengths of both strings will be between 1 and 1000 characters. - Both strings will consist only of characters from \'a\' to \'z\'. Requirements: - Your implementation must correctly handle edge cases where the strings have different lengths. - The function should efficiently determine if the strings are permutations without unnecessary computations. Additional Details: 1. Consider the case sensitivity where lower case letters should not be treated as upper case. 2. Aim for an optimal solution with a time complexity of O(n) where n is the length of the strings, leveraging suitable data structures. You are provided with a sample input and expected output below for reference: Sample Input: ```python str1 = \\"listen\\" str2 = \\"silent\\" ``` Sample Output: ```python True ``` Sample Input: ```python str1 = \\"hello\\" str2 = \\"billion\\" ``` Sample Output: ```python False ``` Implement the `are_permutations` function accordingly. Starter Code: ```python def are_permutations(str1, str2): # Your code here pass ```","solution":"def are_permutations(str1, str2): Checks if two strings are permutations of each other. Parameters: str1 (string): First string str2 (string): Second string Returns: bool: True if str1 and str2 are permutations of each other, False otherwise if len(str1) != len(str2): return False from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"# Problem Statement You are given two strings, `s1` and `s2`. Implement a function `check_isomorphism(s1: str, s2: str) -> bool` which determines whether the two strings are isomorphic. Two strings are isomorphic if the characters in `s1` can be replaced to get `s2`, such that all occurrences of a character in `s1` map to the same character in `s2`, and no two characters map to the same character. # Function Signature ```python def check_isomorphism(s1: str, s2: str) -> bool: ``` # Input - `s1`: A string that contains only lowercase English letters (a-z). - `s2`: A string that contains only lowercase English letters (a-z). # Output - Return `True` if the strings `s1` and `s2` are isomorphic; otherwise, return `False`. # Constraints - The length of `s1` and `s2` is between `1` and `10^4`. - The characters of the strings are in the range `a-z`. # Example ```python >>> check_isomorphism(\\"egg\\", \\"add\\") True >>> check_isomorphism(\\"foo\\", \\"bar\\") False >>> check_isomorphism(\\"paper\\", \\"title\\") True >>> check_isomorphism(\\"abc\\", \\"bcd\\") True >>> check_isomorphism(\\"ab\\", \\"aa\\") False ``` # Note Ensure to handle edge cases such as strings of different lengths and identical characters mapping to different characters in the other string. # Hints - Use two dictionaries to map characters from `s1` to `s2` and `s2` to `s1`. - Iterate through the characters of the strings and check for mapping consistency.","solution":"def check_isomorphism(s1: str, s2: str) -> bool: Determines whether two strings are isomorphic. Two strings s1 and s2 are isomorphic if the characters in s1 can be replaced to get s2, such that all occurrences of a character in s1 map to the same character in s2, and no two characters map to the same character. Args: s1: A string containing only lowercase English letters. s2: A string containing only lowercase English letters. Returns: bool: True if s1 and s2 are isomorphic, otherwise False. if len(s1) != len(s2): return False mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for char1, char2 in zip(s1, s2): if char1 in mapping_s1_to_s2 and mapping_s1_to_s2[char1] != char2: return False if char2 in mapping_s2_to_s1 and mapping_s2_to_s1[char2] != char1: return False mapping_s1_to_s2[char1] = char2 mapping_s2_to_s1[char2] = char1 return True"},{"question":"# Scenario In a large e-commerce platform, you manage a service that handles promotional pricing for a range of products. The system needs to apply promotional discounts to a range of products based on their categories and price ranges. The discounts are stored in a separate table and must be dynamically applied to calculate the final price for each product in the list. # Task Implement a function `apply_discounts` that calculates the final price for a list of products based on a provided list of discount rules. Each discount rule applies to a specific category and price range. # Function Signature ```python def apply_discounts(products: list, discounts: list) -> list: Calculates final prices for products after applying the appropriate discounts. :param products: List of tuples, each containing (\'category\', \'price\'). :param discounts: List of tuples, each containing (\'category\', \'min_price\', \'max_price\', \'discount_percentage\'). :return: List of final prices for each product in the order they appeared in the input list. ``` # Input - `products`: A list of tuples `products` where each tuple contains two elements: - `\'category\'`: A string representing the product category. - `price`: A float representing the product price. - `discounts`: A list of tuples `discounts` where each tuple contains four elements: - `\'category\'`: A string representing the eligible category for the discount. - `min_price`: A float representing the minimum price threshold for the discount. - `max_price`: A float representing the maximum price threshold for the discount. - `discount_percentage`: An integer representing the discount percentage to apply. # Output Return a list of floats representing the final prices of the products after applying the appropriate discounts. # Constraints - The lengths of `products` and `discounts` will not exceed 10^4. - Prices and discount percentages will be non-negative. - Discount percentages will be between 0 and 100 inclusive. - Each product can have at most one discount applied. # Example ```python products = [ (\'electronics\', 299.99), (\'books\', 19.99), (\'clothing\', 49.99), (\'electronics\', 1099.00) ] discounts = [ (\'electronics\', 100.00, 999.99, 10), (\'electronics\', 1000.00, 1500.00, 15), (\'books\', 0.00, 50.00, 5), (\'clothing\', 0.00, 100.00, 20) ] # Example call final_prices = apply_discounts(products, discounts) # Example output print(final_prices) # Output: [269.991, 18.9905, 39.992, 934.15] ``` # Notes - Ensure the final price is rounded to two decimal places. - Each product will be eligible for at most one discount. If multiple discounts apply, use the first matching one. - Handle edge cases where no discount applies to a product.","solution":"def apply_discounts(products, discounts): final_prices = [] for category, price in products: discount_applied = False for disc_category, min_price, max_price, discount_percentage in discounts: if category == disc_category and min_price <= price <= max_price: discount_amount = (discount_percentage / 100) * price final_price = price - discount_amount final_prices.append(round(final_price, 2)) discount_applied = True break if not discount_applied: final_prices.append(price) return final_prices"},{"question":"# Sliding Window Maximum You are tasked to optimize the performance of a stock price monitoring app by efficiently finding the maximum stock price in a moving window of fixed size. Implement a function `max_in_sliding_window` that supports: 1. **Initializing the input array** containing stock prices. 2. **Processing** a window of size `k` that slides from the start of the array to the end. 3. **Returning the maximum stock price** for each window position. Input and Output Formats * **Initialization**: - Function: `max_in_sliding_window(prices, k)` - Input: `prices`, a list of integers representing stock prices; `k`, an integer representing the window size. - Example: `prices = [1, 3, 5, 2, 8, 6], k = 3` * **Output**: - A list of integers representing the maximum stock price for each window position. - Constraint: `1 <= k <= len(prices)` - Example: Given `prices = [1, 3, 5, 2, 8, 6]` and `k = 3`, the output should be `[5, 5, 8, 8]`. Implementation Requirements 1. Ensure that the maximum computation for each sliding window runs in O(N) time. 2. Handle invalid inputs gracefully (e.g., when `k` is more than the length of the prices list). ```python from collections import deque def max_in_sliding_window(prices, k): if not prices or k <= 0 or k > len(prices): raise ValueError(\\"Invalid input values\\") # Deque to store indices of elements, the front always holds the max element\'s index deq = deque() result = [] for i, price in enumerate(prices): # Remove elements not within the window if deq and deq[0] == i - k: deq.popleft() # Remove elements from the deque smaller than the current element while deq and prices[deq[-1]] < price: deq.pop() deq.append(i) # Start appending results from index k-1 as the first window completes if i >= k - 1: result.append(prices[deq[0]]) return result ``` **Note**: Implement the `max_in_sliding_window` function without any built-in library functions beyond standard collections and data structures.","solution":"from collections import deque def max_in_sliding_window(prices, k): if not prices or k <= 0 or k > len(prices): raise ValueError(\\"Invalid input values\\") # Deque to store indices of elements, the front always holds the max element\'s index deq = deque() result = [] for i, price in enumerate(prices): # Remove elements not within the window if deq and deq[0] == i - k: deq.popleft() # Remove elements from the deque smaller than the current element while deq and prices[deq[-1]] < price: deq.pop() deq.append(i) # Start appending results from index k-1 as the first window completes if i >= k - 1: result.append(prices[deq[0]]) return result"},{"question":"**Context:** You are provided with a class `PalindromeChecker` that is intended to check whether a given string is a palindrome or not. However, the class should not only check for the usual palindromes but should also be able to check for palindromes recursively. Your task is to implement this recursive check. **Objective:** Implement the `is_palindrome_recursive` method in the `PalindromeChecker` class. This method should determine if the provided string is a palindrome using a recursive approach, considering only alphanumeric characters and ignoring cases. **Function Signature:** ```python def is_palindrome_recursive(self, s: str) -> bool: Check recursively if the given string is a palindrome. Args: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. Examples: >>> checker = PalindromeChecker() >>> checker.is_palindrome_recursive(\\"A man, a plan, a canal: Panama\\") True >>> checker.is_palindrome_recursive(\\"race a car\\") False ``` **Constraints:** - The method should ignore non-alphanumeric characters and should not consider case. - You are not allowed to use any helper function other than the recursive one. **Examples:** 1. Checking a palindrome with alphanumeric characters: ```python checker = PalindromeChecker() assert checker.is_palindrome_recursive(\\"A man, a plan, a canal: Panama\\") == True assert checker.is_palindrome_recursive(\\"No lemon, no melon\\") == True ``` 2. Checking a non-palindrome: ```python checker = PalindromeChecker() assert checker.is_palindrome_recursive(\\"race a car\\") == False assert checker.is_palindrome_recursive(\\"hello\\") == False ``` 3. Checking an empty string: ```python checker = PalindromeChecker() assert checker.is_palindrome_recursive(\\"\\") == True ``` 4. Checking a single-character string: ```python checker = PalindromeChecker() assert checker.is_palindrome_recursive(\\"a\\") == True ```","solution":"class PalindromeChecker: def is_palindrome_recursive(self, s: str) -> bool: Check recursively if the given string is a palindrome. Args: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. def recursive_check(s, start, end): while start < end and not s[start].isalnum(): start += 1 while start < end and not s[end].isalnum(): end -= 1 if start >= end: return True if s[start].lower() != s[end].lower(): return False return recursive_check(s, start + 1, end - 1) return recursive_check(s, 0, len(s) - 1)"},{"question":"# Problem Statement You need to build a library management system for handling various book operations efficiently. Your task is to implement a class-based system that allows the addition of books, borrowing, returning, and checking the availability of books. The system should ensure that a book cannot be borrowed if it is already borrowed and properly handles the return process. # Requirements Implement a class `Library` with the following methods: 1. `add_book(self, title: str)`: - Adds a book to the library with the given title. 2. `borrow_book(self, title: str) -> str`: - Allows a user to borrow a book if it is available. - Returns a success message if the book is successfully borrowed. - Returns an appropriate error message if the book is already borrowed or does not exist. 3. `return_book(self, title: str) -> str`: - Allows a user to return a borrowed book. - Returns a success message if the book is successfully returned. - Returns an appropriate error message if the book was not borrowed or does not exist in the library. 4. `is_book_available(self, title: str) -> bool`: - Checks if a book is available for borrowing. - Returns `True` if the book is available, `False` otherwise. # Example ```python library = Library() library.add_book(\\"Python Programming\\") library.add_book(\\"Data Structures\\") print(library.borrow_book(\\"Python Programming\\")) # Output: \\"Book \'Python Programming\' borrowed successfully.\\" print(library.borrow_book(\\"Python Programming\\")) # Output: \\"Book \'Python Programming\' is currently borrowed.\\" print(library.is_book_available(\\"Python Programming\\")) # Output: False print(library.return_book(\\"Python Programming\\")) # Output: \\"Book \'Python Programming\' returned successfully.\\" print(library.is_book_available(\\"Python Programming\\")) # Output: True print(library.borrow_book(\\"Data Structures\\")) # Output: \\"Book \'Data Structures\' borrowed successfully.\\" ``` # Function Signature ```python class Library: def __init__(self): # Initialization code here pass def add_book(self, title: str): # Implementation here pass def borrow_book(self, title: str) -> str: # Implementation here pass def return_book(self, title: str) -> str: # Implementation here pass def is_book_available(self, title: str) -> bool: # Implementation here pass ```","solution":"class Library: def __init__(self): self.books = {} # Dictionary to store books and their status def add_book(self, title: str): if title not in self.books: self.books[title] = True # True means the book is available else: return \\"Book already exists in the library.\\" def borrow_book(self, title: str) -> str: if title not in self.books: return f\\"Book \'{title}\' does not exist in the library.\\" elif self.books[title]: self.books[title] = False # Mark the book as borrowed return f\\"Book \'{title}\' borrowed successfully.\\" else: return f\\"Book \'{title}\' is currently borrowed.\\" def return_book(self, title: str) -> str: if title not in self.books: return f\\"Book \'{title}\' does not exist in the library.\\" elif not self.books[title]: self.books[title] = True # Mark the book as available return f\\"Book \'{title}\' returned successfully.\\" else: return f\\"Book \'{title}\' was not borrowed.\\" def is_book_available(self, title: str) -> bool: return self.books.get(title, False)"},{"question":"# Consecutive Element Remover You are assigned the task of removing consecutive duplicate elements from a given list such that only the first occurrence of each group of consecutive duplicates is preserved. **Function Signature**: ```python def remove_consecutive_duplicates(lst: list) -> list: ``` **Input**: * A list of integers `lst`. **Output**: * Return a list where all consecutive duplicates have been removed. **Constraints**: * The length of `lst` will be between 0 and 10^5, inclusive. * Each element in `lst` will be an integer between -10^9 and 10^9, inclusive. * The function should raise a `TypeError` if `lst` is not a list or contains non-integer elements. **Examples**: * `remove_consecutive_duplicates([1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 4, 5, 6, 6])` should return `[1, 2, 3, 4, 5, 6]` * `remove_consecutive_duplicates([4, 4, 4, 4, 4])` should return `[4]` * `remove_consecutive_duplicates([])` should return `[]` * `remove_consecutive_duplicates([3, 3, 3, 2, 2, 1, 1, 1, 1])` should return `[3, 2, 1]` * `remove_consecutive_duplicates([10, 20, 30, 30, 20, 10, 10])` should return `[10, 20, 30, 20, 10]` **Requirements**: * Ensure that your implementation is efficient and handles all edge cases. * Handle non-list input or lists containing non-integer elements by raising a `TypeError`.","solution":"def remove_consecutive_duplicates(lst: list) -> list: if not isinstance(lst, list): raise TypeError(\\"Input must be a list.\\") if not all(isinstance(i, int) for i in lst): raise TypeError(\\"All elements of the list must be integers.\\") if not lst: return lst result = [lst[0]] for i in range(1, len(lst)): if lst[i] != lst[i - 1]: result.append(lst[i]) return result"},{"question":"# Sorting a List Using Merge Sort You are required to implement the merge sort algorithm to sort a list of integers in non-decreasing order. Your function will recursively divide the list into two halves, sort each half, and then merge the sorted halves into a single sorted list. Function Signature ```python def merge_sort(array: list[int]) -> list[int]: ``` # Input * A list of integers `array` where the length of the list will be `n` (1 ≤ n ≤ 10^5). # Output * Return a new list containing the elements of the input list in non-decreasing order. # Constraints * The integers in the list will be in the range -10^9 to 10^9. # Performance Requirements * Your implementation should run in O(n log n) time complexity. # Example ```python print(merge_sort([38, 27, 43, 3, 9, 82, 10])) # Output: [3, 9, 10, 27, 38, 43, 82] print(merge_sort([5, 2, 9, 1, 5, 6])) # Output: [1, 2, 5, 5, 6, 9] print(merge_sort([-1000000, 1000000, 0])) # Output: [-1000000, 0, 1000000] ``` # Edge Cases to Consider * A list with one element: Should return the same list. * Duplicate elements: Ensure they are correctly handled and placed in the resulting list. * Negative and positive integers: The algorithm should correctly order a mix of both. # Additional Note * The merge sort algorithm should be implemented as a recursive function with base cases for lists of zero or one element. * Helper functions for merging two sorted arrays may simplify the implementation and enhance readability.","solution":"def merge_sort(array): # Base case: arrays with fewer than 2 elements are already sorted if len(array) < 2: return array # Split array into two halves mid = len(array) // 2 left_half = merge_sort(array[:mid]) right_half = merge_sort(array[mid:]) # Merge sorted halves return merge(left_half, right_half) def merge(left, right): sorted_array = [] i = j = 0 # Until we reach the end of either left or right, pick the smallest of both elements and append to sorted_array while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # Append any elements left in either left or right sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array"},{"question":"# Image Compression using K-Means Clustering In this task, you are required to compress an image using the K-Means clustering algorithm. Image compression reduces the amount of data required to represent the image by clustering similar colors together. Problem Statement Write a function `compress_image(image, k)` that performs K-Means clustering on the pixel values of an image to reduce the number of unique colors to `k` clusters. The function should return the compressed image. Input: - `image`: A 3D list or array-like structure representing the image, where each element is a list or array of three integers (R, G, B values). - Dimensions: (height, width, 3) - `k`: An integer representing the number of color clusters. Output: - A 3D list or array-like structure representing the compressed image, with the same dimensions as the input image but with the colors reduced to the k clusters. Constraints: - The dimensions of `image` will be at least 1x1. - Each `R`, `G`, and `B` value will be an integer between 0 and 255. - `k` will be a positive integer not greater than the number of pixels in the image. Example: ```python image = [ [[255, 0, 0], [255, 0, 0], [0, 255, 0], [0, 255, 0]], [[255, 0, 0], [0, 0, 255], [0, 255, 0], [0, 0, 255]], [[255, 0, 0], [0, 255, 0], [0, 0, 255], [0, 0, 255]] ] k = 2 compressed_image = compress_image(image, k) print(\\"Compressed Image:\\", compressed_image) ``` Expected Output: ```python Compressed Image: [[[<R, G, B>], [<R, G, B>], ...], [<R, G, B>], ...] ``` Performance Requirements: The algorithm should complete within a reasonable time for images of up to 1000x1000 pixels and up to 256 color clusters. # Hints - Treat each pixel\'s RGB values as a data point in 3D space. - Use a random initialization method for centroids. - Iterate until the cluster centroids converge or a fixed number of iterations. - Replace each pixel\'s color with its nearest centroid\'s color. # Additional Notes: - You can use libraries for image handling and numerical operations but ensure the clustering is implemented clearly and efficiently. - Ensure the representation of the compressed image maintains the same dimensions as the input image.","solution":"import numpy as np from sklearn.cluster import KMeans def compress_image(image, k): Compress an image using K-Means clustering. Args: image (list): 3D list representing the image (height x width x 3). k (int): Number of clusters for K-Means. Returns: list: Compressed image with the same dimensions. # Convert the image into a 2D array of pixels image_array = np.array(image) h, w, c = image_array.shape pixels = image_array.reshape(-1, c) # Perform K-means clustering kmeans = KMeans(n_clusters=k, random_state=0).fit(pixels) new_pixels = kmeans.cluster_centers_[kmeans.labels_] # Reshape the new pixels back to the original image shape compressed_image = new_pixels.reshape(h, w, c) # Ensure integer type and within bounds [0, 255] return compressed_image.astype(np.uint8).tolist()"},{"question":"# Querying a Type-Safe Tree Structure Objective Implement a class `TypeSafeTree` that manages a tree-like structure where each node can have children only of the same type. The structure should ensure that adding a child of a different type raises a `TypeError`. Expected Input and Output * **Input**: * Initialize the tree with a generic node. * Add children nodes to any existing node in the tree. * **Output**: * Some method to add children. * Some method to verify the type-safety rules are enforced. Constraints and Limitations * Each node must enforce type consistency among its children. * The tree should be able to accommodate any Python object type. * The tree should support basic operations like adding nodes and retrieving nodes by their values. Performance Requirements * Ensure the operations run efficiently for typical tree structures used in computational problems. # Scenario You are developing a hierarchical data model for an organization where each level of the hierarchy can only contain members of the same type. Ensure type safety in a tree-like structure for the organization\'s hierarchy. # Class Requirements The class should implement the following: * **Initialization**: Ensure type consistency of the tree from the root node. * **Methods**: 1. `add_child` - Adds a child node to a given parent node, checks and enforces type consistency. 2. `get_node` - Retrieves a node by its value. 3. `__repr__` - Provides a string representation of the tree for easy debugging and visualization. Implement the `TypeSafeTree` class ensuring type safety is strictly enforced. ```python class Node: def __init__(self, value: Any) -> None: self.value = value self.children = [] def add_child(self, child: \'Node\') -> None: if not self.children: self.children.append(child) elif type(self.children[0].value) is type(child.value): self.children.append(child) else: raise TypeError(\\"All children must be of the same type\\") def __repr__(self, level=0) -> str: ret = \\" \\" * level + repr(self.value) + \\"n\\" for child in self.children: ret += child.__repr__(level + 1) return ret class TypeSafeTree: def __init__(self, root_value: Any) -> None: self.root = Node(root_value) def add_child(self, parent_value: Any, child_value: Any) -> None: parent_node = self.get_node(self.root, parent_value) if parent_node: parent_node.add_child(Node(child_value)) else: raise ValueError(f\\"Parent node with value {parent_value} not found\\") def get_node(self, node: Node, value: Any) -> Node: if node.value == value: return node for child in node.children: found = self.get_node(child, value) if found: return found return None def __repr__(self) -> str: return self.root.__repr__() ``` You can test your implementation with various scenarios to ensure it adheres strictly to the type safety constraints and maintains the integrity of the tree structure.","solution":"class Node: def __init__(self, value): self.value = value self.children = [] def add_child(self, child): if not self.children: self.children.append(child) elif type(self.children[0].value) is type(child.value): self.children.append(child) else: raise TypeError(\\"All children must be of the same type\\") def __repr__(self, level=0): ret = \\" \\" * level + repr(self.value) + \\"n\\" for child in self.children: ret += child.__repr__(level + 1) return ret class TypeSafeTree: def __init__(self, root_value): self.root = Node(root_value) def add_child(self, parent_value, child_value): parent_node = self.get_node(self.root, parent_value) if parent_node: parent_node.add_child(Node(child_value)) else: raise ValueError(f\\"Parent node with value {parent_value} not found\\") def get_node(self, node, value): if node.value == value: return node for child in node.children: found = self.get_node(child, value) if found: return found return None def __repr__(self): return self.root.__repr__()"},{"question":"# N-th Fibonacci Number - Using Matrix Exponentiation Scenario: You are tasked with implementing a high-performance function to calculate the N-th Fibonacci number for a large-scale simulation. The traditional recursive and iterative approaches become inefficient for very large values of N, so you should use matrix exponentiation for an optimized solution. Task: Implement the function `nth_fibonacci(n: int) -> int`, which returns the N-th Fibonacci number using matrix exponentiation. Details: - The 0-th Fibonacci number is 0, and the 1st Fibonacci number is 1. - The N-th Fibonacci number can be defined using matrix exponentiation as follows: - Define the transformation matrix `T` as: ``` | 1 1 | | 1 0 | ``` - The N-th Fibonacci number is the top-left cell of `T^(N-1)`, applied to the initial vector [1, 0] (for N > 0). Input: 1. **n (int)** - the index of the Fibonacci number to obtain, where `n` is a non-negative integer. Output: - **int** - the N-th Fibonacci number. Examples: ```python # Example 1 n = 0 # The 0-th Fibonacci number is 0 print(nth_fibonacci(0)) # Output: 0 # Example 2 n = 1 # The 1st Fibonacci number is 1 print(nth_fibonacci(1)) # Output: 1 # Example 3 n = 10 # The 10th Fibonacci number is 55 print(nth_fibonacci(10)) # Output: 55 # Example 4 n = 50 # A larger example where the 50th Fibonacci number uses matrix exponentiation print(nth_fibonacci(50)) # Output: 12586269025 ``` Constraints: - Ensure that your solution runs efficiently for N up to 10^6. Tips: 1. Construct the base transformation matrix and use matrix exponentiation to compute `T^(N-1)`. 2. Matrix exponentiation can be done in O(log N) time using binary exponentiation. 3. Standard matrix multiplication should be implemented for multiplying matrices during exponentiation.","solution":"def matrix_multiply(A, B): Multiplies two 2x2 matrices A and B. return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_exponentiate(matrix, power): Exponentiates matrix to the given power using binary exponentiation. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power: if power % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) power //= 2 return result def nth_fibonacci(n): Returns the N-th Fibonacci number using matrix exponentiation. if n == 0: return 0 elif n == 1: return 1 T = [[1, 1], [1, 0]] result = matrix_exponentiate(T, n - 1) return result[0][0]"},{"question":"# Circular Buffer Implementation **Context**: A circular buffer, also known as a ring buffer, is a data structure that uses a single fixed-size buffer as if it were connected end-to-end. This structure is particularly useful in embedded systems and real-time applications where managing a continuous stream of data efficiently is crucial. **Problem Statement**: Your task is to complete the implementation of a circular buffer with a fixed capacity. The provided `CircularBuffer` class should support adding elements to the buffer, reading elements, and checking if the buffer is full or empty. You need to implement the `write` and `read` methods, ensuring the buffer\'s circular nature is maintained. Requirements: * Implement the `write` method which adds an element to the end of the buffer. If the buffer is full, the oldest element should be overwritten. * Implement the `read` method which removes and returns the oldest element from the buffer. If the buffer is empty, an exception should be raised. * Ensure that the buffer maintains proper size constraints and handles overwrite behavior correctly. # Function Signature ```python class CircularBuffer: def __init__(self, capacity: int): pass def write(self, data): pass def read(self): pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass ``` # Input & Output * `write(self, data)`: Inputs a single element `data` into the buffer. * `read(self)`: Outputs a single element, which is the oldest in the buffer. * `is_empty(self) -> bool`: Returns `True` if the buffer is empty, else `False`. * `is_full(self) -> bool`: Returns `True` if the buffer is full, else `False`. # Example ```python >>> cb = CircularBuffer(3) >>> cb.write(\'a\') >>> cb.write(\'b\') >>> cb.write(\'c\') >>> cb.is_full() True >>> cb.write(\'d\') >>> cb.read() \'b\' >>> cb.read() \'c\' >>> cb.is_empty() False >>> cb.read() \'d\' >>> cb.is_empty() True >>> cb.read() # This should raise an exception as the buffer is now empty ``` # Constraints * The capacity of the buffer is fixed and defined at the time of initialization. * Represents a real-time circular buffer with efficient time complexity for `read` and `write` operations. * Initializing the buffer with a non-positive capacity should raise an exception.","solution":"class CircularBuffer: def __init__(self, capacity: int): if capacity <= 0: raise ValueError(\\"Capacity must be positive\\") self.capacity = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def write(self, data): if self.is_full(): self.head = (self.head + 1) % self.capacity # Overwrite the oldest data else: self.size += 1 self.buffer[self.tail] = data self.tail = (self.tail + 1) % self.capacity def read(self): if self.is_empty(): raise IndexError(\\"Cannot read from empty buffer\\") data = self.buffer[self.head] self.head = (self.head + 1) % self.capacity self.size -= 1 return data def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity"},{"question":"# Efficient Data Compression Function **Context:** You are working on a system that needs to compress data efficiently before transmitting it over a network. One simple method of compression is run-length encoding (RLE), which compresses sequences of the same value in a list by storing them as pairs of the value and the count. **Task:** Implement the `run_length_encode` function in Python, which performs run-length encoding on a given list of integers. **Function Signature:** ```python def run_length_encode(data: Sequence[int]) -> list[tuple[int, int]]: pass ``` **Input:** * `data` (Sequence[int]): A list of integers to be compressed using run-length encoding. **Output:** * Returns a list of tuples where each tuple contains two integers: the value and the count of consecutive occurrences of that value in the input list. **Constraints:** * The input list `data` can be empty, in which case the function should return an empty list. * The solution should handle edge cases gracefully, such as input lists with a single element or lists without any consecutive repeats. **Performance Requirements:** * The solution should be efficient, ideally with a linear time complexity relative to the input size. **Examples:** ```python >>> run_length_encode([1, 1, 1, 2, 2, 3, 1, 1]) [(1, 3), (2, 2), (3, 1), (1, 2)] >>> run_length_encode([4, 4, 4, 4, 4]) [(4, 5)] >>> run_length_encode([1, 2, 3, 4, 5]) [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)] >>> run_length_encode([]) [] ``` Ensure the implementation is efficient and handles various edge cases correctly. --- For additional context: # Run-Length Encoding (RLE) Run-length encoding is a form of lossless data compression where runs of data (i.e., sequences with the same data value occurring in many consecutive data elements) are stored as a single data value count instead of the original run. This is particularly useful for data with many such runs. For example, the list `[1, 1, 1, 2, 2, 3, 1, 1]` can be represented as `[(1, 3), (2, 2), (3, 1), (1, 2)]`. Ensure the solution is robust and optimally performs the run-length encoding.","solution":"from typing import Sequence, List, Tuple def run_length_encode(data: Sequence[int]) -> List[Tuple[int, int]]: Performs run-length encoding on a given list of integers. Args: data (Sequence[int]): A list of integers to be compressed. Returns: List[Tuple[int, int]]: A list of tuples, each containing a value and its consecutive count. if not data: return [] encoded = [] current_value = data[0] count = 1 for i in range(1, len(data)): if data[i] == current_value: count += 1 else: encoded.append((current_value, count)) current_value = data[i] count = 1 # Append the last run encoded.append((current_value, count)) return encoded"},{"question":"# Question: Evaluate Polynomial Expressions As a data scientist, you often need to evaluate polynomial expressions. Write a function that computes the value of a polynomial for a given set of inputs. Description: The polynomial will be represented as a list of its coefficients. The function should evaluate the polynomial for each element in the given input array. Polynomial Representation: A polynomial of degree n is represented as: [ P(x) = a_n cdot x^n + a_{n-1} cdot x^{n-1} + ... + a_1 cdot x + a_0 ] Where: - (a_0, a_1, ..., a_n) are the coefficients of the polynomial, - Coefficients are given in a list starting from the constant term a_0 to the highest degree term a_n. Function Signature: ```python import numpy as np def evaluate_polynomial(coefficients: list, x_values: np.ndarray) -> np.ndarray: Evaluates a polynomial for each element in the input array. Parameters: coefficients (list): A list of numerical coefficients starting from the constant term to the highest degree term. x_values (np.ndarray): A numpy array of values at which to evaluate the polynomial. Returns: np.ndarray: An array of the polynomial evaluated at each value in the input array. ``` Input: * `coefficients`: A list of numeric values representing the polynomial coefficients. * `x_values`: A numpy array of numeric values at which the polynomial should be evaluated. Output: * A numpy array of the same shape as the input `x_values`, containing the evaluated values of the polynomial. Constraints: * The coefficients list will have at least one element. * The input array will contain only numeric values. * Utilize vectorized operations for performance efficiency. Example: ```python >>> import numpy as np >>> coefficients = [2, 0, 3] # Represents the polynomial 3x^2 + 0x + 2 >>> x_values = np.array([-1, 0, 1, 2]) >>> evaluate_polynomial(coefficients, x_values) array([5, 2, 5, 14]) ``` Implement the `evaluate_polynomial` function according to the above specifications.","solution":"import numpy as np def evaluate_polynomial(coefficients: list, x_values: np.ndarray) -> np.ndarray: Evaluates a polynomial for each element in the input array. Parameters: coefficients (list): A list of numerical coefficients starting from the constant term to the highest degree term. x_values (np.ndarray): A numpy array of values at which to evaluate the polynomial. Returns: np.ndarray: An array of the polynomial evaluated at each value in the input array. return np.polyval(coefficients[::-1], x_values) # Coefficients are reversed for numpy.polyval()"},{"question":"# Problem Statement You are required to implement a function that computes the factorial of an integer `n`. The value of `n` is provided as input and the output should be the computed factorial value. # Detailed Instructions * **Function Name**: `compute_factorial` * **Input**: - `n` - an integer representing the number for which the factorial is to be computed. * **Output**: - Returns an integer which is the factorial of the input number. # Requirements 1. If `n` is less than 0, return -1. 2. Assume the input will always be an integer. 3. The function should be efficient in computing the factorial for larger values within a reasonable time. # Examples ```python >>> compute_factorial(5) 120 >>> compute_factorial(0) 1 >>> compute_factorial(1) 1 >>> compute_factorial(-4) -1 ``` # Constraints * `-10 <= n <= 1000` # Performance Requirements * The function should be efficient in computing the result and must operate within a reasonable time for the upper constraints. Good luck!","solution":"def compute_factorial(n): Computes the factorial of the input integer n. Returns -1 if n is less than 0. if n < 0: return -1 factorial = 1 for i in range(1, n + 1): factorial *= i return factorial"},{"question":"# Problem Statement: You are given a string representing a binary number (i.e., a sequence of \'0\'s and \'1\'s). Write a function `count_flips(binary_string: str) -> int` that determines the minimum number of bit flips needed to make the binary string either all \'0\'s or all \'1\'s. # Function Signature: ```python def count_flips(binary_string: str) -> int: ``` # Input: - A single string `binary_string` consisting of \'0\'s and \'1\'s only. # Output: - Return an integer representing the minimum number of bit flips required. # Constraints: - The length of `binary_string` is between 1 and 10^6 (inclusive). - `binary_string` will always be a non-empty string of \'0\'s and \'1\'s. # Example: ```python assert count_flips(\\"000111\\") == 3 assert count_flips(\\"101010\\") == 3 assert count_flips(\\"1111\\") == 0 assert count_flips(\\"0000\\") == 0 ``` # Notes: - Ensure your implementation handles strings of varying lengths correctly. - Make sure to account for edge cases such as strings with only one type of character (either all \'0\'s or all \'1\'s). # Additional Challenge: - Optimize your implementation to achieve O(n) time complexity, where n is the length of the binary string.","solution":"def count_flips(binary_string: str) -> int: Returns the minimum number of bit flips needed to make the binary string either all \'0\'s or all \'1\'s. # Count the number of \'0\'s and \'1\'s in the string count_0 = binary_string.count(\'0\') count_1 = len(binary_string) - count_0 # Using length and count_0 to find count_1 # The minimum flips required would be to flip the minority group to the majority group return min(count_0, count_1)"},{"question":"# Coding Question: String Permutation Validator **Objective**: Implement a function `is_permutation` to determine if one string is a permutation of another string. **Function Signature**: ```python def is_permutation(str1: str, str2: str) -> bool: pass ``` **Input**: - `str1`: A string consisting of lowercase alphabets. - `str2`: A string consisting of lowercase alphabets. **Output**: - A boolean value `True` if `str1` is a permutation of `str2`, otherwise `False`. **Constraints**: - `0 <= len(str1), len(str2) <= 1000` - The comparison is case-sensitive and whitespace is treated as a character. **Example**: ```python >>> is_permutation(\'abc\', \'bca\') True >>> is_permutation(\'abc\', \'abcd\') False >>> is_permutation(\'listen\', \'silent\') True >>> is_permutation(\'anagram\', \'nagaram\') True >>> is_permutation(\'\', \'\') True # Two empty strings are considered permutations of each other >>> is_permutation(\'a\', \'\') False # Different lengths result in False ``` **Notes**: - A string is a permutation of another if it has the same characters with the exact same frequencies, potentially in a different order. - Consider using data structures like dictionaries to count character frequencies for comparison. **Hint**: Think about how to efficiently compare character counts between the two strings. Sorting both strings and comparing them is one approach, but see if you can achieve this in linear time with appropriate data structures.","solution":"def is_permutation(str1: str, str2: str) -> bool: Determine if one string is a permutation of another string. from collections import Counter # If lengths of the strings are not equal, they cannot be permutations if len(str1) != len(str2): return False # Count the frequency of each character in both strings return Counter(str1) == Counter(str2)"},{"question":"# AVL Tree with Additional Features Scenario: You are required to implement an AVL Tree (a self-balancing binary search tree) with the following enhanced features: 1. **Augmented Traversal**: Provide methods for in-order, pre-order, and post-order traversals. 2. **Height Calculation**: Implement a method to calculate and return the height of the tree. 3. **Find K-th Smallest Element**: Implement a method to find the k-th smallest element in the tree. 4. **Range Sum Query**: Implement a method to return the sum of values within a specified range [L, R]. Task: Implement the `AVLTree` class with the following methods: ```python class AVLTree: class Node: def __init__(self, key: int): self.key = key self.height = 1 self.left = None self.right = None def __init__(self): self.root = None def insert(self, key: int) -> None: # Insert a key into the AVL tree and balance it. def delete(self, key: int) -> None: # Delete a key from the AVL tree and balance it. def in_order_traversal(self) -> List[int]: # Return the in-order traversal of the AVL tree. def pre_order_traversal(self) -> List[int]: # Return the pre-order traversal of the AVL tree. def post_order_traversal(self) -> List[int]: # Return the post-order traversal of the AVL tree. def tree_height(self) -> int: # Return the height of the AVL tree. def kth_smallest(self, k: int) -> int: # Return the k-th smallest element in the AVL tree. def range_sum(self, L: int, R: int) -> int: # Return the sum of all nodes\' values within the range [L, R]. ``` * **Parameters**: - `key`: An integer key to be inserted or deleted from the AVL tree. - `k`: An integer representing the k-th smallest element to find. - `L`: The lower bound of the range for the range sum query. - `R`: The upper bound of the range for the range sum query. * **Returns**: - `in_order_traversal`: A list of integers representing the in-order traversal of the AVL tree. - `pre_order_traversal`: A list of integers representing the pre-order traversal of the AVL tree. - `post_order_traversal`: A list of integers representing the post-order traversal of the AVL tree. - `tree_height`: An integer representing the height of the AVL tree. - `kth_smallest`: An integer representing the k-th smallest element in the AVL tree. - `range_sum`: An integer representing the sum of node values within the range [L, R]. * **Constraints**: - Each method must run in O(log n) or O(n) time complexity where applicable. - The values of `k`, `L`, and `R` lie within the range of the keys present in the tree. - The AVL tree can contain up to (10^5) nodes. * **Example**: ```python # Example usage: tree = AVLTree() tree.insert(20) tree.insert(4) tree.insert(15) tree.insert(70) tree.insert(50) tree.insert(100) print(tree.in_order_traversal()) # Returns: [4, 15, 20, 50, 70, 100] print(tree.pre_order_traversal()) # Returns: [20, 4, 15, 70, 50, 100] print(tree.post_order_traversal()) # Returns: [15, 4, 50, 100, 70, 20] print(tree.tree_height()) # Returns: 3 print(tree.kth_smallest(3)) # Returns: 20 tree.delete(15) print(tree.range_sum(15, 70)) # Returns: 140 ``` Note: - Ensure that each method correctly maintains the AVL tree properties. - The `insert` and `delete` methods should properly balance the tree after modification. - Thoroughly test edge cases, including an empty tree and single-node tree.","solution":"class AVLTree: class Node: def __init__(self, key: int): self.key = key self.height = 1 self.left = None self.right = None def __init__(self): self.root = None def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def insert(self, key: int) -> None: def _insert(node, key): if not node: return self.Node(key) if key < node.key: node.left = _insert(node.left, key) else: node.right = _insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1: if key < node.left.key: return self._right_rotate(node) else: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1: if key > node.right.key: return self._left_rotate(node) else: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node self.root = _insert(self.root, key) def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def delete(self, key: int) -> None: def _delete(node, key): if not node: return node if key < node.key: node.left = _delete(node.left, key) elif key > node.key: node.right = _delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = _delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) >= 0: return self._right_rotate(node) else: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1: if self._get_balance(node.right) <= 0: return self._left_rotate(node) else: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node self.root = _delete(self.root, key) def in_order_traversal(self): def _in_order_traversal(node): return _in_order_traversal(node.left) + [node.key] + _in_order_traversal(node.right) if node else [] return _in_order_traversal(self.root) def pre_order_traversal(self): def _pre_order_traversal(node): return [node.key] + _pre_order_traversal(node.left) + _pre_order_traversal(node.right) if node else [] return _pre_order_traversal(self.root) def post_order_traversal(self): def _post_order_traversal(node): return _post_order_traversal(node.left) + _post_order_traversal(node.right) + [node.key] if node else [] return _post_order_traversal(self.root) def tree_height(self): return self._get_height(self.root) def kth_smallest(self, k: int): def _in_order_traversal_k(node, k): if not node: return [] left = _in_order_traversal_k(node.left, k) if len(left) >= k: return left if len(left) == k - 1: return left + [node.key] return left + [node.key] + _in_order_traversal_k(node.right, k - len(left) - 1) return _in_order_traversal_k(self.root, k)[-1] def range_sum(self, L: int, R: int) -> int: def _range_sum(node, L, R): if not node: return 0 if node.key < L: return _range_sum(node.right, L, R) if node.key > R: return _range_sum(node.left, L, R) return node.key + _range_sum(node.left, L, R) + _range_sum(node.right, L, R) return _range_sum(self.root, L, R)"},{"question":"Matrix Spiral Traversal Optimization You are provided with a function that performs a spiral traversal on a matrix, returning the elements of the matrix in spiral order. Your task is to optimize this function for handling large matrices and edge cases while ensuring the output sequence remains accurate. Task 1. **Function Name**: `optimized_spiral_traversal` 2. **Input**: A 2D list of integers (matrix), with dimensions up to 10^3 x 10^3. 3. **Output**: A list containing the elements of the matrix in spiral order. 4. **Constraints**: - The matrix can be rectangular (not necessarily square). - The matrix can contain negative values, zeros, or positive integers. - The dimensions of the matrix can range from 1x1 to 10^3 x 10^3. Requirements - Handle edge cases effectively. - Optimize for performance when dealing with larger matrices. - Ensure the function\'s time complexity is manageable for the upper limit constraints. Example ```python def optimized_spiral_traversal(matrix: list) -> list: # Your implementation here pass # Example cases print(optimized_spiral_traversal([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ])) # Expected output: [1, 2, 3, 6, 9, 8, 7, 4, 5] print(optimized_spiral_traversal([ [1, 2, 3], [4, 5, 6] ])) # Expected output: [1, 2, 3, 6, 5, 4] print(optimized_spiral_traversal([ [1, 2], [3, 4], [5, 6] ])) # Expected output: [1, 2, 4, 6, 5, 3] print(optimized_spiral_traversal([ [1] ])) # Expected output: [1] print(optimized_spiral_traversal([ [] ])) # Expected output: [] # Larger matrix print(optimized_spiral_traversal([ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ])) # Expected output: [1, 2, 3, 4, 5, 10, 15, 20, 25, 24, 23, 22, 21, 16, 11, 6, 7, 8, 9, 14, 19, 18, 17, 12, 13] ``` You can include unit tests to verify the correctness of your function, especially for edge cases and performance on larger datasets.","solution":"def optimized_spiral_traversal(matrix: list) -> list: if not matrix or not matrix[0]: return [] result = [] rows, cols = len(matrix), len(matrix[0]) left, right, top, bottom = 0, cols - 1, 0, rows - 1 while left <= right and top <= bottom: for col in range(left, right + 1): result.append(matrix[top][col]) top += 1 for row in range(top, bottom + 1): result.append(matrix[row][right]) right -= 1 if top <= bottom: for col in range(right, left - 1, -1): result.append(matrix[bottom][col]) bottom -= 1 if left <= right: for row in range(bottom, top - 1, -1): result.append(matrix[row][left]) left += 1 return result"},{"question":"# Programming Assessment: E-commerce Order Processing You are tasked with extending an existing class `OrderProcessor` to add functionalities for handling bulk orders and optimizing the order processing pipeline. The `OrderProcessor` class processes individual and bulk orders for an e-commerce platform. Scenario The e-commerce platform has seen a surge in bulk orders and wants to optimize the order processing pipeline to handle multiple orders efficiently while ensuring the integrity of the order data. # Task Details: 1. **Function Implementation**: - **Method 1**: Implement a `process_bulk_orders` method within the `OrderProcessor` class that processes a list of order IDs concurrently. - **Method 2**: Implement a `validate_order_data` method within the `OrderProcessor` class that validates order data before processing, ensuring all required fields are present. 2. **Expected Input and Output**: - **process_bulk_orders**: - Input: list of order IDs (List[int]) - Output: dictionary of order IDs and their processing status (Dict[int, str]) - **validate_order_data**: - Input: order data (dict) - Output: True if valid, False otherwise. 3. **Constraints and Limitations**: - Ensure `process_bulk_orders` handles errors gracefully and continues to process other orders if one fails. - Optimize processing using asynchronous programming. 4. **Performance Requirements**: - Efficiently process bulk orders with minimal latency. - Use asynchronous programming to handle the validation and processing of multiple orders concurrently. # Method Signatures: ```python class OrderProcessor: ... @staticmethod async def process_bulk_orders(order_ids: List[int]) -> Dict[int, str]: pass def validate_order_data(self, order_data: dict) -> bool: pass ... ``` # Notes: - Utilize Python’s `asyncio` and `aiohttp` libraries for the `process_bulk_orders` method. - Ensure the `validate_order_data` method checks for required fields such as `order_id`, `customer_id`, and `items`. - Ensure that the class and methods are thoroughly tested. # Example: ```python # Example usage of the validate_order_data method order_processor = OrderProcessor() order_data = {\\"order_id\\": 123, \\"customer_id\\": 456, \\"items\\": [\\"item1\\", \\"item2\\"]} is_valid = order_processor.validate_order_data(order_data) print(f\\"Order data validation result: {is_valid}\\") # Example usage of the process_bulk_orders method order_ids = [123, 456, 789] processing_results = await OrderProcessor.process_bulk_orders(order_ids) for order_id, status in processing_results.items(): print(f\\"Order ID {order_id}: {status}\\") ``` Complete the methods and ensure they work as described.","solution":"import asyncio from typing import List, Dict import aiohttp class OrderProcessor: REQUIRED_FIELDS = [\\"order_id\\", \\"customer_id\\", \\"items\\"] @staticmethod async def process_bulk_orders(order_ids: List[int]) -> Dict[int, str]: async def process_single_order(order_id: int) -> (int, str): # Simulate asynchronous processing of a single order await asyncio.sleep(0.1) # Simulate some IO delay if order_id % 2 == 0: return order_id, \\"Processed Successfully\\" else: return order_id, \\"Failed to Process\\" results = await asyncio.gather( *[process_single_order(order_id) for order_id in order_ids], return_exceptions=True ) return { order_id: (\\"Failed to Process\\" if isinstance(result, Exception) else result[1]) for order_id, result in zip(order_ids, results) } def validate_order_data(self, order_data: dict) -> bool: for field in self.REQUIRED_FIELDS: if field not in order_data: return False return True"},{"question":"# Scenario You are improving a sorting module that includes different algorithms to sort a list of numbers. One of the requirements is to implement an algorithm to find the `k`th smallest element in an unsorted list efficiently. # Problem Statement Implement a Python function called `kth_smallest_element` that finds the `k`th smallest element in an unsorted list of numbers. # Function Signature ```python def kth_smallest_element(nums: list[int], k: int) -> int: ``` # Inputs * `nums`: A list of integers. The list can contain any integer values, both negative and positive. * `k`: An integer representing the position (1-based) of the smallest element to find in the list. The value of `k` is always valid and within the bounds of the list length. # Outputs * An integer representing the `k`th smallest element in the input list. # Constraints * The function must raise a `ValueError` with the message \\"List is empty\\" if the input list is empty. * The function should work for both small and large datasets and should aim for an average time complexity of O(n) using an efficient algorithm such as the Quickselect algorithm. # Example ```python assert kth_smallest_element([7, 10, 4, 3, 20, 15], 3) == 7 assert kth_smallest_element([7, 10, 4, 3, 20, 15], 4) == 10 assert kth_smallest_element([7, 10, 4, 3, 20, 15], 1) == 3 try: kth_smallest_element([], 1) except ValueError as e: assert str(e) == \\"List is empty\\" ``` Implement the `kth_smallest_element` function to meet the given requirements and optimize for performance. Provide sufficient error handling for edge cases. Write clear and concise code, ensuring maintainability and readability.","solution":"def kth_smallest_element(nums: list[int], k: int) -> int: Finds the kth smallest element in an unsorted list of integers using the Quickselect algorithm. :param nums: A list of integers. :param k: An integer representing the 1-based position of the smallest element to find. :return: The kth smallest integer in the list. if not nums: raise ValueError(\\"List is empty\\") def partition(left, right, pivot_index): pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def quickselect(left, right, k_smallest): if left == right: return nums[left] pivot_index = (left + right) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(nums) - 1, k - 1)"},{"question":"**Finding Missing Number from a Sequence** You are given a list of distinct numbers where the numbers are in a certain range but one number is missing from the sequence. Your task is to identify the missing number. **Function Signature**: ```python def find_missing_number(nums: list[int]) -> int: pass ``` **Input**: - `nums`: A list of `n` distinct integers, where each integer ranges from `1` to `n+1`, but one number is missing. **Output**: - An integer representing the missing number from the sequence. **Constraints**: - The length of `nums` list is `n` where `1 <= n <= 1000`. **Example**: ```python >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([2, 3, 1, 5]) 4 ``` **Explanation**: 1. For the first example: - The numbers range from `1` to `6` but `3` is missing from the sequence. 2. For the second example: - The numbers range from `1` to `5`, and `4` is missing from the sequence. **Approach**: 1. The sum of the first `n+1` natural numbers can be calculated using the formula `((n+1) * (n+2)) / 2`. 2. Calculate the sum of the given list of numbers. 3. The missing number will be the difference between the expected sum of the first `n+1` natural numbers and the actual sum of the given list. **Edge Cases**: - The smallest possible case where `n` is `1`. - All numbers except the smallest (`1`) or the largest (`n+1`) in the range are present. **Performance Requirements**: - The solution should be optimal with linear time complexity O(n) and constant space complexity O(1). **Scenarios**: - This problem can be likened to identifying a missing inventory item from a sequential list or detecting missing data in a numerical dataset.","solution":"def find_missing_number(nums: list[int]) -> int: Given a list of distinct numbers where the numbers are in a certain range but one number is missing, the function returns the missing number. Args: nums (list[int]): The list of n numbers ranging from 1 to n+1 with one number missing. Returns: int: The missing number in the sequence. n = len(nums) expected_sum = (n + 1) * (n + 2) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Array Flattening Function Scenario: You are assigned to enhance the data processing capabilities of a web application by implementing a function that deals with nested arrays. This function should take an arbitrarily nested list of integers and return a single, flat list containing all the integers in the original nested lists in the correct order. Task: Implement a Python function `flatten_array(nested_list: list) -> list` that takes a list which can contain arbitrarily nested lists of integers and returns a flat list of integers. Function Requirements: * **Input**: * `nested_list` (list): A list which can contain integers and/or other lists of integers nested at any depth. * **Output**: * Returns a single, flat list containing all the integers from the nested lists. * **Constraints**: * The input list `nested_list` may contain integers and other nested lists. * The order of the elements in the output list must match the order of their appearance in the input nested list. * **Performance Requirements**: * The function should be efficient, but does not need to meet specific performance constraints. Example Usage: ```python assert flatten_array([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_array([[[1], 2], 3]) == [1, 2, 3] assert flatten_array([1, [2, [3]], 4, [[5, 6]]]) == [1, 2, 3, 4, 5, 6] ``` Additional Scenarios & Edge Cases to Consider: * Empty nested lists: ```python assert flatten_array([[], [1, [], [2, []]]]) == [1, 2] ``` * List with no nesting: ```python assert flatten_array([1, 2, 3, 4]) == [1, 2, 3, 4] ``` * Deeply nested lists: ```python assert flatten_array([1, [2, [3, [4, [5]]]]]) == [1, 2, 3, 4, 5] ``` Implement the function `flatten_array` to fulfill these requirements.","solution":"def flatten_array(nested_list): Flattens an arbitrarily nested list of integers into a single list of integers. Args: nested_list (list): A list which can contain integers and/or other lists Returns: list: A flat list containing all the integers from the nested_list flat_list = [] def flatten(element): if isinstance(element, list): for item in element: flatten(item) else: flat_list.append(element) flatten(nested_list) return flat_list"},{"question":"# Matrix Multiplication with Strassen\'s Algorithm You are provided with a basic implementation of matrix multiplication. Your task is to enhance the existing functionality by adding an efficient multiplication method using Strassen\'s algorithm. Additionally, implement a method to compare the performance of Strassen\'s algorithm with the conventional matrix multiplication approach. # Instructions: 1. Implement the function `strassen_matrix_multiply(A, B)` to multiply two n x n matrices using Strassen\'s algorithm. 2. Implement the function `traditional_matrix_multiply(A, B)` for traditional matrix multiplication. 3. Create a function `compare_methods(A, B)` that multiplies the matrices A and B using both methods and prints the time taken by each method. # Input: * Two n x n matrices A and B. # Output: * The product matrix of A and B using Strassen\'s algorithm. * The product matrix of A and B using traditional multiplication. * The performance comparison results for both methods. # Constraints: * Assume n is a power of 2 for simplicity. * You may use the `numpy` library for matrix operations and time comparison. # Example: ```python A = np.array([[1, 2], [3, 4]]) B = np.array([[5, 6], [7, 8]]) result, _ = strassen_matrix_multiply(A, B) print(result) # Should output the product matrix result2, _ = traditional_matrix_multiply(A, B) print(result2) # Should output the same product matrix compare_methods(A, B) # Should print the time comparison ``` # Function Signature: ```python def strassen_matrix_multiply(A: np.ndarray, B: np.ndarray) -> np.ndarray: pass def traditional_matrix_multiply(A: np.ndarray, B: np.ndarray) -> np.ndarray: pass def compare_methods(A: np.ndarray, B: np.ndarray): pass # Usage Example A = np.array([[1, 2], [3, 4]]) B = np.array([[5, 6], [7, 8]]) result = strassen_matrix_multiply(A, B) print(result) result2 = traditional_matrix_multiply(A, B) print(result2) compare_methods(A, B) ``` # Note - Make sure to handle cases where n is not a power of 2 by padding the matrices with zeroes. - Ensure your Strassen\'s algorithm implementation is modular and follows the divide-and-conquer approach for clarity and maintainability.","solution":"import numpy as np import time def traditional_matrix_multiply(A, B): Multiplies two matrices using the traditional matrix multiplication method. return np.dot(A, B) def strassen_matrix_multiply(A, B): Multiplies two matrices using Strassen\'s algorithm. n = A.shape[0] if n == 1: return A * B else: # Splitting matrices into quadrants using numpy slicing mid = n // 2 A11, A12, A21, A22 = A[:mid, :mid], A[:mid, mid:], A[mid:, :mid], A[mid:, mid:] B11, B12, B21, B22 = B[:mid, :mid], B[:mid, mid:], B[mid:, :mid], B[mid:, mid:] # Strassen\'s formula M1 = strassen_matrix_multiply(A11 + A22, B11 + B22) M2 = strassen_matrix_multiply(A21 + A22, B11) M3 = strassen_matrix_multiply(A11, B12 - B22) M4 = strassen_matrix_multiply(A22, B21 - B11) M5 = strassen_matrix_multiply(A11 + A12, B22) M6 = strassen_matrix_multiply(A21 - A11, B11 + B12) M7 = strassen_matrix_multiply(A12 - A22, B21 + B22) C11 = M1 + M4 - M5 + M7 C12 = M3 + M5 C21 = M2 + M4 C22 = M1 - M2 + M3 + M6 # Combining the results C = np.zeros((n, n)) C[:mid, :mid] = C11 C[:mid, mid:] = C12 C[mid:, :mid] = C21 C[mid:, mid:] = C22 return C def compare_methods(A, B): Compares the performance of Strassen\'s algorithm and traditional matrix multiplication. start_time = time.time() traditional_result = traditional_matrix_multiply(A, B) traditional_time = time.time() - start_time start_time = time.time() strassen_result = strassen_matrix_multiply(A, B) strassen_time = time.time() - start_time print(f\\"Traditional multiplication time: {traditional_time:.6f} seconds\\") print(f\\"Strassen\'s algorithm time: {strassen_time:.6f} seconds\\") return traditional_result, strassen_result # Example Usage A = np.array([[1, 2], [3, 4]]) B = np.array([[5, 6], [7, 8]]) traditional_result = traditional_matrix_multiply(A, B) print(traditional_result) strassen_result = strassen_matrix_multiply(A, B) print(strassen_result) compare_methods(A, B)"},{"question":"# Scenario You are working on an application that requires the conversion of strings into \\"CamelCase\\". The task involves transforming a given sentence where words are separated by spaces into a single string where each word starts with a capital letter and the spaces are removed. # Problem Write a function `to_camel_case(sentence: str) -> str` that takes a sentence as input and returns a string in \\"CamelCase\\". # Input * `sentence` (str): A sentence with words separated by spaces. The sentence will consist of only lowercase and uppercase English letters and spaces. It will always be a non-empty string. # Output * `str`: The resulting string in \\"CamelCase\\". # Constraints 1. The input sentence will always have at least one word. 2. There will be no leading or trailing spaces in the sentence. 3. Spaces will be used to separate words. # Examples 1. `to_camel_case(\\"hello world\\")` should return `\\"HelloWorld\\"`. 2. `to_camel_case(\\"convert this to camel case\\")` should return `\\"ConvertThisToCamelCase\\"`. 3. `to_camel_case(\\"Example Text Here\\")` should return `\\"ExampleTextHere\\"`. # Implementation Implement your solution based on the analysis above: ```python def to_camel_case(sentence: str) -> str: :param sentence: Input sentence to convert to CamelCase :type sentence: str :return: Converted CamelCase string Tests: >>> to_camel_case(\\"hello world\\") \'HelloWorld\' >>> to_camel_case(\\"convert this to camel case\\") \'ConvertThisToCamelCase\' >>> to_camel_case(\\"Example Text Here\\") \'ExampleTextHere\' words = sentence.split() return \'\'.join(word.capitalize() for word in words) if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def to_camel_case(sentence: str) -> str: Converts a given sentence into CamelCase. :param sentence: Input sentence to convert to CamelCase :type sentence: str :return: Converted CamelCase string words = sentence.split() return \'\'.join(word.capitalize() for word in words)"},{"question":"# Question: Implement In-Place Quick Sort You have been provided with a basic version of the quick sort algorithm that sorts numbers from a given collection. However, the current logic is neither efficient nor correctly implements the quick sort as theoretically defined. Objective Re-implement the quick sort algorithm correctly by following the fundamental principles and optimize its performance. Expected Input and Output * **Input**: A list of integers. ```python [int, int, ..., int] ``` * **Output**: A sorted list of integers in ascending order. ```python [int, int, ..., int] ``` Constraints * The input list will have at most 100,000 elements. * Each integer in the list will fit within the 32-bit signed integer range: [−2³¹, 2³¹ − 1]. Performance Requirements * Time complexity: O(n log n) on average, O(n²) in the worst case * Space complexity: O(log n) due to recursion stack Scenario Imagine you are a software engineer working on a data processing module of a real-time analytics application. This sorting function needs to be highly efficient as it frequently sorts large datasets before further processing. # Your Task: Write a Python function `quick_sort_inplace` that takes a list of integers and returns a sorted list in ascending order. ```python def quick_sort_inplace(collection): :param collection: list of integers :return: sorted list of integers # Implement your in-place quick sort logic here pass ``` **Note**: Do not import any library for sorting. Concentrate on the quick sort algorithm principles, not Python\'s built-in sort functions or any other sort algorithm. **Example**: ```python >>> quick_sort_inplace([3, 1, 4, 1, 5, 9, 2, 6]) [1, 1, 2, 3, 4, 5, 6, 9] ```","solution":"def quick_sort_inplace(collection): Sorts a list of integers in ascending order using the quick sort algorithm. :param collection: list of integers :return: sorted list of integers def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursion(arr, low, high): if low < high: pivot_index = partition(arr, low, high) quick_sort_recursion(arr, low, pivot_index - 1) quick_sort_recursion(arr, pivot_index + 1, high) # The quick sort function will call the recursive function quick_sort_recursion(collection, 0, len(collection) - 1) return collection"},{"question":"# Task: Efficiently Counting Frequent Elements in Large Datasets As a software engineer working with big data analytics, you are tasked with developing an efficient algorithm to identify the most frequent elements in a large dataset of integers. # Problem Statement You are given an array of integers and need to implement an algorithm to find the top k most frequent elements. Given the vast size of the dataset, it\'s crucial to optimize both time and space complexity. # Requirements * Implement a function `top_k_frequent_elements` that takes an array of integers and an integer k as input, and returns a list of the k most frequent elements. * Optimize the time complexity to better than O(n log n), where n is the number of elements in the array. * Minimize space complexity as efficiently as possible given the constraints. # Constraints * The array length is between 1 and 1,000,000. * The integer values range between -10^6 and 10^6. * 1 ≤ k ≤ the number of unique elements in the array. # Input Format * `nums` (List[int]): The list of integers. * `k` (int): The number of top frequent elements to return. # Output Format * `List[int]`: A list of the k most frequent elements. # Example ```python def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: # Your optimized code here print(top_k_frequent_elements([1,1,1,2,2,3], 2)) # Output: [1, 2] print(top_k_frequent_elements([1], 1)) # Output: [1] print(top_k_frequent_elements([3,3,4,2,4,4,3,2,2,2], 3)) # Output: [2, 3, 4] ``` # Considerations 1. Analyze the problem to identify a way to keep track of element frequencies efficiently. 2. Consider utilizing data structures that support efficient insertion and retrieval, such as heaps. 3. Ensure that your implementation can handle edge cases and large input sizes effectively.","solution":"from collections import Counter import heapq from typing import List def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements from the given list of integers. # Step 1: Create a hash map to count the frequency of each element count = Counter(nums) # Step 2: Use a heap to extract the top k elements # We use a min-heap (of size k) to keep track of the top k elements efficiently heap = [] for num, freq in count.items(): if len(heap) < k: heapq.heappush(heap, (freq, num)) else: if freq > heap[0][0]: heapq.heappushpop(heap, (freq, num)) # Extract elements from the heap top_k_elements = [num for freq, num in heap] return top_k_elements"},{"question":"Task Question Creation for Coding Assessment # [Question 2]: # Binary Tree Level Order Traversal Given a binary tree, implement a function to return the level order traversal of its nodes\' values. (i.e., from left to right, level by level). Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: TreeNode) -> List[List[int]]: pass ``` Input * `root` (TreeNode): The root node of the binary tree to traverse. Output * Returns a list of lists, where each list contains the values of the nodes at that level. Constraints * The number of nodes in the tree is in the range [0, 2000]. * -1000 <= Node.val <= 1000 Example ```python # Example 1: input: root = [3, 9, 20, None, None, 15, 7] output: [[3], [9, 20], [15, 7]] # Example 2: input: root = [1, 2, 3, 4, 5] output: [[1], [2, 3], [4, 5]] # Example 3: input: root = [] output: [] ``` Notes - The input in the examples is in Level Order Form serialization used commonly for binary trees in coding challenges, where `None` indicates the absence of nodes. - Ensure that your solution handles edge cases, such as an empty tree (`root` is `None`).","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = [root] while queue: level_size = len(queue) level_nodes = [] for i in range(level_size): current = queue.pop(0) level_nodes.append(current.val) if current.left: queue.append(current.left) if current.right: queue.append(current.right) result.append(level_nodes) return result"},{"question":"# File System Directory Size Calculation Overview In this task, you are to implement a function that calculates the total size of a directory, including all its subdirectories and files. Each directory can contain files and subdirectories. The size of a directory is defined as the sum of the sizes of the files it contains, as well as the sizes of all files in its subdirectories, recursively. Problem Statement Write a function `directory_size(directory: dict) -> int` that takes a nested dictionary representing the directory structure and returns the total size of the directory in bytes. Each key in the dictionary is either a filename (with integer values representing file sizes) or a subdirectory (with another dictionary as the value). Input - `directory`: A dictionary where: - Keys are strings that represent filenames or directory names. - Values are either integers (representing file sizes in bytes) or nested dictionaries (representing subdirectories). Output - The total size of the directory in bytes (integer). Constraints - The directory structure will contain at least one file. - File sizes will be positive integers. - The overall depth of the nested directories will not exceed 10. Performance Ensure that your implementation efficiently calculates the directory size. Example ```python from typing import Dict, Any def directory_size(directory: Dict[str, Any]) -> int: total_size = 0 for key, value in directory.items(): if isinstance(value, int): total_size += value elif isinstance(value, dict): total_size += directory_size(value) return total_size # Example Test Cases assert directory_size({ \\"file1.txt\\": 100, \\"subdir1\\": { \\"file2.txt\\": 200, \\"file3.txt\\": 300, \\"subdir2\\": { \\"file4.txt\\": 400 } }, \\"file5.txt\\": 500 }) == 1500 assert directory_size({ \\"root\\": { \\"file1\\": 10, \\"dirA\\": { \\"file2\\": 20, \\"dirB\\": { \\"file3\\": 30, \\"file4\\": 40 } } }, \\"file5\\": 50 }) == 150 ``` Implement the `directory_size` function to ensure that the given test cases pass and it correctly calculates the size of the directory recursively.","solution":"from typing import Dict, Any def directory_size(directory: Dict[str, Any]) -> int: Calculates the total size of a directory, including all nested subdirectories and files. :param directory: A dictionary representing the directory structure. :return: The total size of the directory in bytes. total_size = 0 for value in directory.values(): if isinstance(value, int): total_size += value elif isinstance(value, dict): total_size += directory_size(value) return total_size"},{"question":"# Binary Tree Mirror Image Challenge Scenario You are required to write a program that constructs a binary tree and creates a mirror image of that tree. The mirror image of a binary tree is another binary tree with left and right children of all non-leaf nodes interchanged. Task Implement a class named `BinaryTree` with the following requirements: Class: `BinaryTree` 1. **Attributes**: * `root` (TreeNode): Root node of the binary tree, which is initially `None`. 2. **Methods**: * `__init__(self)`: Constructor that initializes an empty binary tree. * `insert(self, value)`: Inserts a value into the binary tree. * `make_mirror(self)`: Creates and returns the mirror image of the binary tree. * `inorder_traversal(self, node)`: Performs inorder traversal of the binary tree. 3. **Class: `TreeNode`** * Represents a node in the binary tree. * **Attributes**: - `value` (int): The value of the node. - `left` (TreeNode): The left child node. - `right` (TreeNode): The right child node. Constraints and Limitations * Ensure that the binary tree supports at least basic integer node values. * The tree should be constructed in level order insertion to facilitate creation. Input and Output Formats * Use the following methods for interaction with the binary tree: ```python class BinaryTree: class TreeNode: def __init__(self, value): # Initialize TreeNode with value, left, and right def __init__(self): # Initialize an empty binary tree with root None def insert(self, value): # Insert value into the tree in level order def make_mirror(self): # Create and return the mirror image of the binary tree def inorder_traversal(self, node): # Perform and return inorder traversal of the binary tree ``` Example ```python # Create a binary tree bt = BinaryTree() # Insert values into the tree bt.insert(1) bt.insert(2) bt.insert(3) bt.insert(4) bt.insert(5) # Perform inorder traversal of the original tree print(bt.inorder_traversal(bt.root)) # Output: [4, 2, 5, 1, 3] # Create and get mirror image of the tree mirror_root = bt.make_mirror() # Perform inorder traversal of the mirror image tree print(bt.inorder_traversal(mirror_root)) # Output: [3, 1, 5, 2, 4] ``` Ensure your implementation correctly handles the insertion and mirror creation of the binary tree, and that the tree nodes are properly rearranged in the mirror image.","solution":"class BinaryTree: class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None def insert(self, value): new_node = self.TreeNode(value) if self.root is None: self.root = new_node return queue = [self.root] while queue: node = queue.pop(0) if node.left is None: node.left = new_node break else: queue.append(node.left) if node.right is None: node.right = new_node break else: queue.append(node.right) def make_mirror(self): def mirror(node): if node is None: return None new_node = self.TreeNode(node.value) new_node.left = mirror(node.right) new_node.right = mirror(node.left) return new_node return mirror(self.root) def inorder_traversal(self, node): result = [] if node: result.extend(self.inorder_traversal(node.left)) result.append(node.value) result.extend(self.inorder_traversal(node.right)) return result"},{"question":"# Fibonacci Sequence Calculator Objective Implement a function `calculate_fibonacci` that generates the first `n` terms of the Fibonacci sequence. Function Signature ```python def calculate_fibonacci(n: int) -> list[int]: ``` Input Parameters * `n` (int): The number of terms in the Fibonacci sequence to generate. Output * Return a list of integers representing the Fibonacci sequence. Constraints * `n` should be a non-negative integer. If `n` is 0, the function should return an empty list. Example ```python >>> calculate_fibonacci(5) [0, 1, 1, 2, 3] >>> calculate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> calculate_fibonacci(0) [] ``` Explanation * The first example computes the first 5 terms of the Fibonacci sequence: [0, 1, 1, 2, 3]. * The second example computes the first 10 terms: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]. * The third example returns an empty list since `n` is 0. Notes * Handle edge cases such as `n` being 0 properly. * Ensure the function efficiently computes the sequence, considering potential performance issues for large values of `n`. * The Fibonacci sequence starts with 0 and 1. Subsequent terms are the sum of the previous two terms.","solution":"def calculate_fibonacci(n: int) -> list[int]: Generates the first n terms of the Fibonacci sequence. Args: n : int : The number of terms in the Fibonacci sequence to generate Returns: list[int] : A list containing the first n terms of the Fibonacci sequence if n <= 0: return [] fib_sequence = [0, 1] if n == 1: return [0] for i in range(2, n): next_term = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_term) return fib_sequence[:n]"},{"question":"# Evaluate Arithmetic Expression Using a Stack Your task is to evaluate a given arithmetic expression in Reverse Polish Notation (RPN). RPN is a mathematical notation in which every operator follows all of its operands. The given expression string is a space-separated sequence of tokens. # Function Signature ```python def evaluate_rpn(expression: str) -> int: pass ``` # Input * A string `expression` representing a valid Reverse Polish Notation expression. Tokens are separated by a single space. # Output * Return an integer representing the evaluation result of the expression. # Constraints * The expression will be a valid RPN expression. * The length of `expression` will not exceed 10^4. * The expression contains integers and operators `+`, `-`, `*`, `/`. * Division between two integers should truncate toward zero. # Example ```python expr1 = \\"2 1 + 3 *\\" print(evaluate_rpn(expr1)) # Output: 9 expr2 = \\"4 13 5 / +\\" print(evaluate_rpn(expr2)) # Output: 6 expr3 = \\"10 6 9 3 + -11 * / * 17 + 5 +\\" print(evaluate_rpn(expr3)) # Output: 22 ``` # Explanation * In the first example, the RPN expression \\"2 1 + 3 *\\" translates to ((2 + 1) * 3) = 9. * In the second example, \\"4 13 5 / +\\" translates to (4 + (13 / 5)) = 4 + 2 = 6. * In the third example, \\"10 6 9 3 + -11 * / * 17 + 5 +\\" translates to (((10 * (6 / ((9 + 3) * -11))) + 17) + 5) = 22. # Explanation of Approach Use a stack to handle the computation. Iterate through each token in the given RPN expression: * If the token is a number, push it onto the stack. * If the token is an operator, pop the necessary number of operands from the stack, apply the operator, and push the result back onto the stack. * At the end of the iteration, the stack will contain one element, which is the evaluation result.","solution":"def evaluate_rpn(expression: str) -> int: def operate(op, a, b): if op == \'+\': return a + b elif op == \'-\': return a - b elif op == \'*\': return a * b elif op == \'/\': return int(a / b) # Ensure division truncates towards zero stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() stack.append(operate(token, a, b)) else: stack.append(int(token)) return stack[0]"},{"question":"# Question You are tasked to write a function that reads and summarizes information from a JSON file representing a collection of books. Each book entry in the collection includes data such as title, author, genre, and year of publication. The function should group books by their genres and calculate the number of books and the average year of publication for each genre. # Function Specification **Function Signature** ```python def summarize_books(file_path: str) -> Dict[str, Tuple[int, float]]: pass ``` **Input** - `file_path` (string): The file path of the JSON file containing book entries. **JSON Structure** The JSON file contains a list of book dictionaries with the following format: ```json [ {\\"title\\": \\"Book Title 1\\", \\"author\\": \\"Author 1\\", \\"genre\\": \\"Genre1\\", \\"year\\": 2001}, {\\"title\\": \\"Book Title 2\\", \\"author\\": \\"Author 2\\", \\"genre\\": \\"Genre2\\", \\"year\\": 2005}, ... ] ``` **Output** - Returns a dictionary where: - The keys are genres (strings). - The values are tuples containing: - The number of books (int) for the genre. - The average year of publication (float) of the books in the genre. **Constraints** - Assume the input JSON file is well-formed and each book has the required fields. - Handle cases where certain genres might have very few book entries. # Example Given the following JSON file content: ```json [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author 1\\", \\"genre\\": \\"Fiction\\", \\"year\\": 2010}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author 2\\", \\"genre\\": \\"Fiction\\", \\"year\\": 2015}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author 3\\", \\"genre\\": \\"Science\\", \\"year\\": 2000} ] ``` ```python summary = summarize_books(\\"books.json\\") print(summary) # Output: {\\"Fiction\\": (2, 2012.5), \\"Science\\": (1, 2000.0)} ``` # Instructions 1. Familiarize yourself with reading JSON files in Python using the `json` module. 2. Implement the `summarize_books` function to read the JSON file and process its contents as described. 3. Ensure the function handles different genres and calculates the counts and averages correctly. 4. Test the function with various JSON file contents to ensure accuracy and robustness.","solution":"import json from typing import Dict, Tuple def summarize_books(file_path: str) -> Dict[str, Tuple[int, float]]: Summarizes books by genre, calculating the number of books and the average year of publication. with open(file_path, \'r\') as file: books = json.load(file) genre_summary = {} for book in books: genre = book[\\"genre\\"] year = book[\\"year\\"] if genre not in genre_summary: genre_summary[genre] = {\\"count\\": 0, \\"total_year\\": 0} genre_summary[genre][\\"count\\"] += 1 genre_summary[genre][\\"total_year\\"] += year summary = {genre: (details[\\"count\\"], details[\\"total_year\\"] / details[\\"count\\"]) for genre, details in genre_summary.items()} return summary"},{"question":"# Problem Statement: **Kth Smallest Element in Matrix** Given a matrix of size `n x n` where each row and each column is sorted in ascending order, find the kth smallest element in the matrix. # Function Signature: ```python def kth_smallest(matrix: list, k: int) -> int: ``` # Input: - `matrix`: A list of lists of integers representing an `n x n` matrix, where every row and column is sorted in ascending order. - `k`: An integer representing the position of the smallest element to find in the matrix (1-indexed). # Output: - An integer, which is the kth smallest element in the given matrix. # Constraints: - `1 <= n <= 300` - `matrix` is an `n x n` matrix - Elements in the matrix are integers in the range of `[-10^9, 10^9]` - `1 <= k <= n^2` # Example: ```python assert kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8) == 13 assert kth_smallest([[-5]], 1) == -5 assert kth_smallest([[1, 2, 3], [2, 3, 4], [3, 4, 5]], 5) == 3 ``` # Implementation Requirements: 1. The solution must be optimized to run efficiently for matrices up to the size of 300x300. 2. Consider the use of binary search in combination with a min-heap or other suitable data structures to find the kth smallest element efficiently. 3. Focus on minimizing both time and space complexity while adhering to the problem constraints. # Scenario: You are given a large dataset represented as a sorted matrix, and you need to quickly retrieve the kth smallest element. This problem tests your capability to implement and understand optimized search algorithms and data structures suitable for handling large, sorted datasets. # Constraints to Consider: - Ensure that your implementation correctly handles edge cases, such as `k` being 1 (smallest element) or `k` being `n^2` (largest element). - Ensure robust handling of potentially large input data within the given constraints.","solution":"import heapq def kth_smallest(matrix: list, k: int) -> int: Returns the kth smallest element in the matrix. Params: matrix: A list of lists of integers, where each row and column is sorted in ascending order. k: An integer representing the position of the smallest element to find in the matrix (1-indexed). Returns: An integer, which is the kth smallest element in the given matrix. n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract the min k times for _ in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"# Fruit Basket Weight Calculation You are given a list of fruits, each represented by a dictionary containing the name of the fruit and its weight in grams. Write a function `fruit_basket_weight(fruits: list[dict]) -> int` that computes the total weight of the fruits in the basket. Input - A list of dictionaries `fruits`, where each dictionary has: - A key `\\"name\\"` representing the name of the fruit (a string). - A key `\\"weight\\"` representing the weight of the fruit in grams (an integer). Output - An integer representing the total weight of all the fruits in the basket. Constraints 1. 1 <= len(fruits) <= 10,000 2. The value for `\\"name\\"` in a fruit dictionary is a string with a maximum length of 20 characters. 3. The value for `\\"weight\\"` in a fruit dictionary is an integer between 1 and 1,000 grams. Example ```python >>> fruit_basket_weight([{\\"name\\": \\"apple\\", \\"weight\\": 150}, {\\"name\\": \\"banana\\", \\"weight\\": 120}, {\\"name\\": \\"peach\\", \\"weight\\": 180}]) 450 >>> fruit_basket_weight([{\\"name\\": \\"kiwi\\", \\"weight\\": 80}]) 80 >>> fruit_basket_weight([]) 0 >>> fruit_basket_weight([{\\"name\\": \\"orange\\", \\"weight\\": 200}, {\\"name\\": \\"grape\\", \\"weight\\": 50}, {\\"name\\": \\"mango\\", \\"weight\\": 300}, {\\"name\\": \\"apple\\", \\"weight\\": 150}, {\\"name\\": \\"banana\\", \\"weight\\": 120}]) 820 ``` # Notes - Your solution should correctly handle edge cases, such as an empty list or lists with a single fruit. - Aim to process the input in an optimal manner in terms of time complexity.","solution":"def fruit_basket_weight(fruits): Computes the total weight of all the fruits in the basket. Args: fruits (list): A list of dictionaries, each containing the name and weight of a fruit. Returns: int: The total weight of all the fruits. return sum(fruit[\'weight\'] for fruit in fruits)"},{"question":"# Coding Question: Implement a Basic Text Editor with Undo Functionality Objective: Implement a class that simulates a simple text editor with the ability to insert text, delete text, and undo the last operations. Requirements: * **Class Signature**: ```python class TextEditor: def __init__(self): pass def insert(self, text: str) -> None: pass def delete(self, count: int) -> None: pass def get_content(self) -> str: pass def undo(self) -> None: pass ``` * **Methods**: - `__init__`: Initializes an empty text editor. - `insert(text: str)`: Appends the given `text` to the current content. - `delete(count: int)`: Deletes the last `count` characters from the current content. - `get_content() -> str`: Returns the current content of the text editor. - `undo()`: Reverts the last operation (insert or delete). If there are no operations to undo, it should do nothing. * **Constraints**: - The text editor should handle operations in the order they are added. - The `insert` and `delete` operations need to be undoable. - The text will contain only Latin alphabet letters and spaces. Scenario: You are tasked with building a component for a minimal text editor application that supports basic text manipulation and undo functionality. The users should be able to type and delete text, as well as revert their last change if necessary. Examples: 1. **Example 1**: ```python editor = TextEditor() editor.insert(\\"hello\\") editor.insert(\\" world\\") output = editor.get_content() ``` **Output**: ```python \\"hello world\\" ``` 2. **Example 2**: ```python editor = TextEditor() editor.insert(\\"hello\\") editor.delete(3) output = editor.get_content() ``` **Output**: ```python \\"he\\" ``` 3. **Example 3**: ```python editor = TextEditor() editor.insert(\\"hello\\") editor.delete(3) editor.undo() output = editor.get_content() ``` **Output**: ```python \\"hello\\" ``` 4. **Example 4**: ```python editor = TextEditor() editor.insert(\\"hello\\") editor.delete(6) output = editor.get_content() ``` **Output**: ```python \\"\\" ``` Hints: * Use a stack or list to keep track of the operations performed. * Consider how to store information needed to undo each type of operation. * Carefully manage the boundaries for insert and delete operations to handle edge cases gracefully.","solution":"class TextEditor: def __init__(self): self.content = \\"\\" self.history = [] def insert(self, text: str) -> None: self.history.append((\'insert\', text)) self.content += text def delete(self, count: int) -> None: deleted_text = self.content[-count:] self.history.append((\'delete\', deleted_text)) self.content = self.content[:-count] def get_content(self) -> str: return self.content def undo(self) -> None: if not self.history: return last_action, last_text = self.history.pop() if last_action == \'insert\': self.content = self.content[:-len(last_text)] elif last_action == \'delete\': self.content += last_text"},{"question":"# Graph Shortest Path Challenge **Context:** Graph algorithms are a fundamental aspect of computer science. One common problem is finding the shortest path between nodes in a weighted graph. In this problem, you are required to implement the Dijkstra\'s algorithm to find the shortest path from a source node to all other nodes in the graph. **Task:** Implement a function `dijkstra(graph: List[List[int]], source: int) -> List[int]` that computes the shortest path from the source node to all other nodes. **Specifications:** 1. **Function Signature:** - `def dijkstra(graph: List[List[int]], source: int) -> List[int]` 2. **Constraints:** - The graph is represented by an adjacency matrix, where `graph[i][j]` represents the weight of the edge from node `i` to node `j`. - If there is no edge between nodes `i` and `j`, `graph[i][j]` should be `float(\'inf\')`. - `0 <= source < n` where `n` is the number of nodes in the graph. - The graph does not contain negative weight edges. 3. **Expected Time Complexity:** - The implementation should be efficient, ideally O((n^2) for the unoptimized approach, or O((n + E) * log(n)) if using a priority queue). **Example Usage:** ```python graph = [ [0, 1, 4, float(\'inf\'), float(\'inf\'), float(\'inf\')], [1, 0, 4, 2, 7, float(\'inf\')], [4, 4, 0, 3, 5, float(\'inf\')], [float(\'inf\'), 2, 3, 0, 4, 6], [float(\'inf\'), 7, 5, 4, 0, 7], [float(\'inf\'), float(\'inf\'), float(\'inf\'), 6, 7, 0] ] source = 0 print(dijkstra(graph, source)) # Output: [0, 1, 4, 3, 7, 9] ``` Ensure your implementation handles all edge cases such as graphs with disconnected nodes and scenarios where the source node is isolated. **Performance Requirements:** - Dijkstra\'s algorithm should efficiently compute the shortest path based on the provided adjacency matrix representation of the graph.","solution":"from typing import List import heapq def dijkstra(graph: List[List[int]], source: int) -> List[int]: Computes the shortest path from the source node to all other nodes in a weighted graph. Args: graph: List of lists representing the adjacency matrix of the graph. source: The source node from which to calculate the shortest paths. Returns: List of shortest distances from the source node to every other node. n = len(graph) dist = [float(\'inf\')] * n dist[source] = 0 priority_queue = [(0, source)] # stores pairs of (distance, node) while priority_queue: current_dist, u = heapq.heappop(priority_queue) # Skip processing if the popped distance is not the shortest found so far if current_dist > dist[u]: continue # Iterate through all neighbors of u for v in range(n): if graph[u][v] != float(\'inf\'): distance_through_u = current_dist + graph[u][v] # If a shorter path to v is found if distance_through_u < dist[v]: dist[v] = distance_through_u heapq.heappush(priority_queue, (distance_through_u, v)) return dist"},{"question":"# Decode the Sensor Signals You are given a list of sensor signal data from a monitoring system. Each signal entry consists of a string with alternating characters denoting the signal type and value. Your task is to process this list of signals and compute the summary for each signal type. # Requirements: 1. **Function Signature**: ```python def summarize_signals(signals: list[str]) -> dict[str, int]: ``` 2. **Inputs**: * `signals`: A list of signal strings where each character in the string alternates between a signal type (an uppercase letter) and a numeric value (0-9). 3. **Outputs**: * Return a dictionary where the keys are the signal types and the values are the total sums of their corresponding numeric values across all signal strings. # Constraints: 1. The signal strings will only contain printable ASCII characters. 2. The length of each signal string will be at least 2 and will always have an even length. 3. There will not be more than 1000 signal strings in the list. 4. Signal types will always be uppercase letters (A-Z). 5. Numeric values will always be digits (0-9). # Example: ```python >>> signals = [\\"A2B3C4\\", \\"A1B2C3\\", \\"D5E2\\"] >>> summary = summarize_signals(signals) >>> summary {\'A\': 3, \'B\': 5, \'C\': 7, \'D\': 5, \'E\': 2} ``` # Explanation: - For the signal string \\"A2B3C4\\": - Add 2 to signal type \'A\' - Add 3 to signal type \'B\' - Add 4 to signal type \'C\' - For the signal string \\"A1B2C3\\": - Add 1 to signal type \'A\' (total for \'A\' becomes 2 + 1 = 3) - Add 2 to signal type \'B\' (total for \'B\' becomes 3 + 2 = 5) - Add 3 to signal type \'C\' (total for \'C\' becomes 4 + 3 = 7) - For the signal string \\"D5E2\\": - Add 5 to signal type \'D\' - Add 2 to signal type \'E\' # Implementation Tips: - Traverse each signal string two characters at a time, collecting the signal type and value. - Use a dictionary to keep track of the sum of values for each signal type. - Initialize the dictionary with default values if a signal type is encountered for the first time.","solution":"def summarize_signals(signals: list[str]) -> dict[str, int]: summary = {} for signal in signals: for i in range(0, len(signal), 2): signal_type = signal[i] signal_value = int(signal[i+1]) if signal_type in summary: summary[signal_type] += signal_value else: summary[signal_type] = signal_value return summary"},{"question":"# Inventory Management System You are required to implement a basic inventory management system for a small store. The system should be able to handle adding new items, updating stock quantities, and calculating the total value of the current inventory. **Problem Statement** Write a class `InventoryManagement` with the following methods: ```python class InventoryManagement: def __init__(self): Initialize the inventory management system with an empty dictionary. pass def add_item(self, item_name: str, cost_price: float, sell_price: float, quantity: int): Add a new item to the inventory. :param item_name: str, name of the new item :param cost_price: float, cost price of the item :param sell_price: float, selling price of the item :param quantity: int, quantity in stock pass def update_stock(self, item_name: str, quantity: int): Update stock quantity of an existing item. :param item_name: str, name of the item to update :param quantity: int, quantity to be added to the stock pass def calculate_inventory_value(self) -> float: Calculate and return the total value of the current inventory based on cost price. :return: float, total value of the inventory pass ``` # Detailed Requirements 1. **Adding Items**: - `add_item` method should insert a new item into the inventory dictionary with the provided details (`item_name`, `cost_price`, `sell_price`, `quantity`). 2. **Updating Stock**: - `update_stock` method should update the quantity of an existing item by adding the new quantity to the current stock. 3. **Calculating Inventory Value**: - `calculate_inventory_value` should return the total value of all items in the inventory based on their cost price and current stock quantities. # Constraints - All parameters will be valid and within reasonable commercial ranges. # Example Usage: ```python inventory = InventoryManagement() # Adding items inventory.add_item(\\"Laptop\\", 1000.00, 1500.00, 10) inventory.add_item(\\"Smartphone\\", 500.00, 800.00, 25) # Updating stock inventory.update_stock(\\"Laptop\\", 5) # Laptop stock becomes 15 # Calculating inventory value inventory.calculate_inventory_value() # Should return 1000*15 + 500*25 ``` # Considerations - Edge cases where an item to be updated does not exist in the inventory (you can assume it will always exist). - Ensure floating point arithmetic is handled correctly (you can use `round` method to return values up to two decimal places if needed). Feel free to ask any questions for further clarifications!","solution":"class InventoryManagement: def __init__(self): Initialize the inventory management system with an empty dictionary. self.inventory = {} def add_item(self, item_name: str, cost_price: float, sell_price: float, quantity: int): Add a new item to the inventory. :param item_name: str, name of the new item :param cost_price: float, cost price of the item :param sell_price: float, selling price of the item :param quantity: int, quantity in stock self.inventory[item_name] = { \\"cost_price\\": cost_price, \\"sell_price\\": sell_price, \\"quantity\\": quantity } def update_stock(self, item_name: str, quantity: int): Update stock quantity of an existing item. :param item_name: str, name of the item to update :param quantity: int, quantity to be added to the stock if item_name in self.inventory: self.inventory[item_name][\\"quantity\\"] += quantity def calculate_inventory_value(self) -> float: Calculate and return the total value of the current inventory based on cost price. :return: float, total value of the inventory total_value = 0.0 for item in self.inventory.values(): total_value += item[\\"cost_price\\"] * item[\\"quantity\\"] return round(total_value, 2)"},{"question":"# Alternating Character Deletion In a binary string (a string composed only of characters \'0\' and \'1\'), some characters need to be deleted to ensure there are no two consecutive characters with the same value. In other words, in the resulting string, every adjacent pair of characters must be different. Implement a function `min_deletions_to_alternate(s: str) -> int` that: 1. Takes a string `s` composed of characters \'0\' and \'1\'. 2. Returns the minimum number of deletions required to ensure no two consecutive characters in the string are identical. **Requirements**: - **Input**: A string `s` of length 1 to 10^5 composed only of characters \'0\' and \'1\'. - **Output**: An integer representing the minimum number of deletions needed. **Additional Constraints**: - Raise a `ValueError` if the input string contains any character other than \'0\' or \'1\'. - Ensure the function operates efficiently to handle the largest possible input size. ```python def min_deletions_to_alternate(s: str) -> int: Calculate the minimum number of deletions needed to make the binary string alternate. Args: s (str): A binary string composed of \'0\' and \'1\' Returns: int: Minimum number of deletions required to alternate the characters Raises: ValueError: If input string contains characters other than \'0\' and \'1\' pass ``` # Example Cases: 1. `min_deletions_to_alternate(\\"010101\\")` should return `0` because the string is already alternating. 2. `min_deletions_to_alternate(\\"0000\\")` should return `3` because deleting any three \'0\'s results in a single \'0\', which is alternating. 3. `min_deletions_to_alternate(\\"0110\\")` should return `1` because deleting one \'1\' results in \\"010\\" or deleting the \'0\' results in \\"111\\", both of which are alternating. 4. `min_deletions_to_alternate(\\"1100\\")` should return `2` because deleting either two \'1\'s or two \'0\'s results in either \\"00\\" or \\"11\\", which is alternating. Write the implementation of the function `min_deletions_to_alternate` while considering edge cases and ensuring optimal performance.","solution":"def min_deletions_to_alternate(s: str) -> int: Calculate the minimum number of deletions needed to make the binary string alternate. Args: s (str): A binary string composed of \'0\' and \'1\' Returns: int: Minimum number of deletions required to alternate the characters Raises: ValueError: If input string contains characters other than \'0\' and \'1\' if not all(c in \'01\' for c in s): raise ValueError(\\"The input string must contain only \'0\' and \'1\'\\") deletions = 0 prev_char = s[0] for current_char in s[1:]: if current_char == prev_char: deletions += 1 else: prev_char = current_char return deletions"},{"question":"**[Question 2]: Unique Character Substrings** You are asked to implement a function that finds the maximum length of a substring with unique characters from a given string. This type of operation is crucial for developing algorithms where identifying substrings with specific properties are a requirement, such as data compression or pattern matching. # Input Format: * A single string `s` consisting of only ASCII printable characters. # Output Format: * An integer representing the length of the longest substring in the input string where all characters are unique. # Constraints: * The length of the string `s` will not exceed `10^5`. # Example: ```python def max_unique_substring_length(s): # Your implementation here print(max_unique_substring_length(\\"abcabcbb\\")) # Output: 3 print(max_unique_substring_length(\\"bbbbb\\")) # Output: 1 print(max_unique_substring_length(\\"pwwkew\\")) # Output: 3 print(max_unique_substring_length(\\"!@#123456\\")) # Output: 9 ``` # Performance Requirements: * The algorithm should run in O(n) time complexity where n is the length of the string. # Scenario Consider you are building a software which requires frequent analysis of large text data to find patterns in user inputs. You need to identify the longest sequence of unique characters to optimize memory storage for unique sequences or for detecting anomalies in texts. Implement the function `max_unique_substring_length` to find the desired length of the unique character substring efficiently.","solution":"def max_unique_substring_length(s): Returns the length of the longest substring with all unique characters. :param s: Input string. :type s: str :return: Length of the longest substring with unique characters. :rtype: int char_index_map = {} max_length = 0 left = 0 for right in range(len(s)): if s[right] in char_index_map: left = max(left, char_index_map[s[right]] + 1) char_index_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Website Log Analyzer **Problem Statement**: Design a function to analyze a website\'s access logs and generate a report of the most frequently accessed URLs. The logs are represented as a list of strings, where each string is a log entry containing a timestamp and a URL. Your task is to identify the top `k` most frequently accessed URLs within a specified time range. **Function Signature** ```python def analyze_logs(logs: list[str], start_time: str, end_time: str, k: int) -> list[str]: pass ``` **Input**: - `logs`: a list of strings where each entry follows the format `\\"YYYY-MM-DD HH:MM:SS URL\\"`. - `start_time`: a string representing the start of the time range in the format `\\"YYYY-MM-DD HH:MM:SS\\"`. - `end_time`: a string representing the end of the time range in the format `\\"YYYY-MM-DD HH:MM:SS\\"`. - `k`: an integer representing the number of top URLs to return. **Output**: - Returns a list of the `k` most frequently accessed URLs within the specified time range. **Constraints**: - The length of `logs` will be between 1 and 10^5. - The length of `start_time` and `end_time` will be exactly 19 characters. - The value of `k` will be between 1 and the number of unique URLs. # Example ```python logs = [ \\"2023-10-01 10:00:00 /home\\", \\"2023-10-01 10:05:00 /contact\\", \\"2023-10-01 10:10:00 /home\\", \\"2023-10-01 10:15:00 /home\\", \\"2023-10-01 10:20:00 /about\\", \\"2023-10-01 10:25:00 /contact\\", \\"2023-10-01 10:30:00 /home\\" ] start_time = \\"2023-10-01 10:00:00\\" end_time = \\"2023-10-01 10:20:00\\" k = 2 analyze_logs(logs, start_time, end_time, k) # returns [\'/home\', \'/contact\'] ``` **Notes**: - URL accesses outside the specified time range should be ignored. - If multiple URLs have the same frequency, return them in any order. - Ensure efficient processing to handle large number of log entries. **Explanation**: The function takes the logs, a specified time range, and a number `k`, and returns the `k` most frequently accessed URLs within that time range.","solution":"from collections import Counter from datetime import datetime def analyze_logs(logs: list[str], start_time: str, end_time: str, k: int) -> list[str]: Returns the k most frequently accessed URLs in the specified time range. Args: logs: list of log strings in the format \'YYYY-MM-DD HH:MM:SS URL\'. start_time: start of the time range in the format \'YYYY-MM-DD HH:MM:SS\'. end_time: end of the time range in the format \'YYYY-MM-DD HH:MM:SS\'. k: number of top URLs to return. Returns: list of the k most frequently accessed URLs within the specified time range. start_datetime = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_datetime = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") url_counter = Counter() for log in logs: log_parts = log.split() timestamp_str = \\" \\".join(log_parts[:2]) url = log_parts[2] timestamp = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") if start_datetime <= timestamp <= end_datetime: url_counter[url] += 1 # Get the k most common URLs most_common_urls = [url for url, count in url_counter.most_common(k)] return most_common_urls"},{"question":"# Question: Implement Depth-limited Search and Breadth-limited Search Algorithms You are required to implement two search algorithms: Depth-limited Search (DLS) and Breadth-limited Search (BLS). These algorithms are variations of Depth-first Search (DFS) and Breadth-first Search (BFS) respectively, with an added constraint on the maximum depth or breadth to limit the search space. Specifically: 1. **Implement the `depth_limited_search` function** that performs a Depth-first Search up to a specified depth limit. 2. **Implement the `breadth_limited_search` function** that performs a Breadth-first Search up to a specified breadth limit. **Function Signatures**: ```python def depth_limited_search(graph: dict, start: str, goal: str, depth_limit: int) -> list[str]: pass def breadth_limited_search(graph: dict, start: str, goal: str, breadth_limit: int) -> list[str]: pass ``` **Input**: - `graph`: A dictionary representing the graph, where the keys are node identifiers and the values are lists of adjacent nodes. - `start`: The start node identifier. - `goal`: The goal node identifier. - `depth_limit`: The maximum depth to search in the DLS algorithm. - `breadth_limit`: The maximum breadth to search in the BLS algorithm. **Output**: Both functions should return: - A list of nodes representing the path from the `start` node to the `goal` node if such a path is found within the given depth or breadth limit. - An empty list if no path is found within the limits. **Constraints**: - Handle graphs that might contain cycles. - Ensure that the search terminates correctly if the limits are exceeded. - The function should handle the case where the `start` node is the same as the `goal` node correctly. Example: ```python graph = { \'A\': [\'B\', \'C\', \'D\'], \'B\': [\'E\', \'F\'], \'C\': [\'G\'], \'D\': [\'H\'], \'E\': [], \'F\': [], \'G\': [], \'H\': [] } path_dls = depth_limited_search(graph, \'A\', \'G\', 3) # Should return a valid path like [\'A\', \'C\', \'G\'] if the path is within depth 3 path_bls = breadth_limited_search(graph, \'A\', \'H\', 2) # Should return a valid path like [\'A\', \'D\', \'H\'] if the path is within breadth 2 ``` Ensure you test your implementation with various graph structures, depth limits, and breadth limits to validate its correctness and efficiency.","solution":"def depth_limited_search(graph, start, goal, depth_limit): Performs a Depth-limited Search from start to goal within the specified depth limit. Returns a list of nodes representing the path from start to goal if found within the depth limit. def dls(node, goal, depth): if depth == 0 and node == goal: return [node] if depth > 0: for neighbor in graph.get(node, []): path = dls(neighbor, goal, depth - 1) if path: return [node] + path return None if start == goal: return [start] result = dls(start, goal, depth_limit) return result if result else [] def breadth_limited_search(graph, start, goal, breadth_limit): Performs a Breadth-limited Search from start to goal within the specified breadth limit. Returns a list of nodes representing the path from start to goal if found within the breadth limit. if start == goal: return [start] queue = [(start, [start])] level = 0 while queue: level += 1 if level > breadth_limit: break next_queue = [] for node, path in queue: for neighbor in graph.get(node, []): if neighbor == goal: return path + [neighbor] next_queue.append((neighbor, path + [neighbor])) queue = next_queue return []"},{"question":"# Coding Assessment Question Scenario & Context You are working as a software developer for a company that needs to perform statistical analysis on their inventory data. The data includes the prices of various items stored in a warehouse. Your task is to compute two different types of averages based on the provided list of item prices. Problem Statement Implement two functions `calculate_mean` and `calculate_median` that compute the arithmetic mean and the median of a list of item prices respectively. 1. **calculate_mean**: This function should compute the arithmetic mean of the given list of prices. 2. **calculate_median**: This function should compute the median of the given list of prices. Function Specifications 1. **calculate_mean** function: - **Input**: - `prices` (List[float]): A list of prices of items in dollars. - **Output**: - (float): The arithmetic mean of the prices. - **Constraints**: - The list must contain at least one price. - All prices must be non-negative floats. - **Error Handling**: - Raise an error if the list is empty. - Raise an error if any price is negative. 2. **calculate_median** function: - **Input**: - `prices` (List[float]): A list of prices of items in dollars. - **Output**: - (float): The median of the prices. - **Constraints**: - The list must contain at least one price. - All prices must be non-negative floats. - **Error Handling**: - Raise an error if the list is empty. - Raise an error if any price is negative. # Example ```python # Example 1 calculate_mean([10.5, 20.0, 30.75]) # Output: 20.416666666666668 # Example 2 calculate_median([10.5, 20.0, 30.75]) # Output: 20.0 # Example 3 calculate_median([15.0, 25.0, 35.0, 45.0]) # Output: 30.0 ``` Note * Ensure the results are accurate up to two decimal places if needed. * Ensure to raise appropriate errors where necessary. * You can make use of the `statistics` module from Python\'s standard library.","solution":"from statistics import mean, median def calculate_mean(prices): Compute the arithmetic mean of the given list of prices. Args: prices (List[float]): A list of prices of items in dollars. Returns: float: The arithmetic mean of the prices. Raises: ValueError: If the list is empty or contains negative prices. if not prices: raise ValueError(\\"The list of prices is empty.\\") for price in prices: if price < 0: raise ValueError(\\"Price list contains negative values.\\") return mean(prices) def calculate_median(prices): Compute the median of the given list of prices. Args: prices (List[float]): A list of prices of items in dollars. Returns: float: The median of the prices. Raises: ValueError: If the list is empty or contains negative prices. if not prices: raise ValueError(\\"The list of prices is empty.\\") for price in prices: if price < 0: raise ValueError(\\"Price list contains negative values.\\") return median(prices)"},{"question":"# Detect and Remove Cycle in a Singly Linked List **Context**: In a singly linked list, a cycle occurs when a node\'s next pointer points to a previous node in the list, creating a loop. Your task is to detect whether a cycle exists in a given singly linked list. If a cycle is detected, remove the cycle to make the list linear. # Task Write a function `detect_and_remove_cycle` that detects a cycle in a singly linked list and removes it if found. If no cycle exists, the function should return `None`. You may use the following class structure and method signatures: ```python class Node: def __init__(self, data: Any, next_node: Node = None) -> None: self.data = data self.next_node = next_node class LinkedList: def __init__(self) -> None: self.head = None def insert_tail(self, data: Any) -> None: new_node = Node(data) if not self.head: self.head = new_node return temp = self.head while temp.next_node: temp = temp.next_node temp.next_node = new_node def detect_and_remove_cycle(linked_list: LinkedList) -> Optional[Node]: # Your implementation here return ``` # Input * `linked_list`: A LinkedList instance that may or may not contain a cycle. # Output * Return the node (Node instance) where the cycle starts, or `None` if no cycle exists. # Constraints * You are not allowed to modify the node\'s data to remove the cycle. * O(n) time complexity and O(1) additional space complexity is preferred. * Consider edge cases such as empty lists or lists with single nodes. # Example ```python linked_list = LinkedList() linked_list.insert_tail(1) linked_list.insert_tail(2) linked_list.insert_tail(3) linked_list.insert_tail(4) # Creating a cycle for testing linked_list.head.next_node.next_node.next_node.next_node = linked_list.head.next_node cycle_node = detect_and_remove_cycle(linked_list) if cycle_node: print(cycle_node.data) # Output should be 2, where the cycle starts else: print(\\"No cycle detected\\") # After removing the cycle, the list should be linear temp = linked_list.head while temp: print(temp.data, end=\\" -> \\") temp = temp.next_node # Expected output: 1 -> 2 -> 3 -> 4 -> ``` Ensure your implementation is thorough and covers all edge cases effectively.","solution":"class Node: def __init__(self, data, next_node=None): self.data = data self.next_node = next_node class LinkedList: def __init__(self): self.head = None def insert_tail(self, data): new_node = Node(data) if not self.head: self.head = new_node return temp = self.head while temp.next_node: temp = temp.next_node temp.next_node = new_node def detect_and_remove_cycle(linked_list): slow = linked_list.head fast = linked_list.head # Detecting cycle using Floyd’s Cycle-Finding Algorithm while fast is not None and fast.next_node is not None: slow = slow.next_node fast = fast.next_node.next_node if slow == fast: break else: # No cycle detected return None # Finding the start of the cycle slow = linked_list.head while slow != fast: slow = slow.next_node fast = fast.next_node # \'slow\' and \'fast\' now point to the start of the cycle # Removing the cycle cycle_start_node = slow prev = None temp = slow while True: prev = temp temp = temp.next_node if temp == cycle_start_node: break prev.next_node = None return cycle_start_node"},{"question":"# Problem: Inverted Index Creation for Search Optimization In a text mining application, you often need to quickly find all occurrences of a specific term in a collection of documents. One efficient way of doing this is by using an inverted index. An inverted index is a data structure that maps terms (words) to their respective occurrences in a collection of documents. Your task is to write a function to build an inverted index from a given list of documents. Write the following function: 1. `create_inverted_index(documents: list) -> dict`: - Given a list of documents, where each document is represented as a string, this function should return a dictionary representing the inverted index. The keys of the dictionary should be individual terms (words) found in the documents, and the value for each key should be a set of document indices where the term appears. # Input and Output Format Function `create_inverted_index` - **Input**: A list of strings `documents`, where each string represents a document. (1 ≤ len(documents) ≤ 10^4, 1 ≤ len(document) ≤ 10^3) - **Output**: A dictionary where each key is a term (word) and the corresponding value is a set of integers representing indices of the documents that contain the term. # Constraints - The function should handle documents with various cases (uppercase, lowercase) seamlessly. Treat words as case-insensitive. - Ignore punctuation and other non-alphanumeric characters when identifying words. - Assume that words are separated by spaces. # Example: ```python >>> documents = [\\"The quick brown fox\\", \\"jumps over the lazy dog\\", \\"and the cow jumps over the moon\\"] >>> create_inverted_index(documents) { \'the\': {0, 1, 2}, \'quick\': {0}, \'brown\': {0}, \'fox\': {0}, \'jumps\': {1, 2}, \'over\': {1, 2}, \'lazy\': {1}, \'dog\': {1}, \'and\': {2}, \'cow\': {2}, \'moon\': {2} } ``` # Additional Notes - Ensure to efficiently build the inverted index, considering both the number of documents and the length of each document. - Take care of edge cases like empty documents (represent them as empty strings). - Optimize the function to handle large inputs within the constraints. Points to consider: - Implement a method to clean and tokenize the text by removing punctuation and converting it to lowercase. - Utilize appropriate data structures to ensure efficient lookups and updates to the inverted index.","solution":"import re from collections import defaultdict def create_inverted_index(documents): Create an inverted index from a list of documents. Parameters: documents (list): List of documents where each document is a string. Returns: dict: An inverted index where keys are terms (words) and values are sets of document indices. inverted_index = defaultdict(set) for index, document in enumerate(documents): # Normalize and tokenize the document words = re.findall(r\'bw+b\', document.lower()) for word in words: inverted_index[word].add(index) return dict(inverted_index)"},{"question":"# Problem Statement: You are given a list of integers representing the heights of buildings in a city. All buildings are positioned in a straight line (defined by their indices in the list) and the goal is to install the least number of streetlights such that every building is illuminated. Each streetlight can illuminate all buildings up to `distance` units away from its position (both to the left and the right). # Function Signature: ```python def min_streetlights(building_heights: List[int], distance: int) -> int: pass ``` # Input: - `building_heights`: a list of integers (1 <= len(building_heights) <= 10^5, 1 <= building_heights[i] <= 10^4). - `distance`: an integer representing the maximum illumination distance (1 <= distance <= len(building_heights)). # Output: - An integer representing the minimum number of streetlights required to illuminate all buildings on the street. # Example: ```python assert min_streetlights([3, 2, 1, 4, 3], 1) == 3 assert min_streetlights([6, 5, 3, 2, 8, 9], 2) == 2 ``` # Constraints: - The solution should handle large arrays efficiently due to the constraint on the number of buildings. - Address scenarios where the optimal placement of streetlights affects the number needed. # Considerations: - Devise an algorithm to place streetlights in such a manner that maximizes their coverage. - Ensure the solution is optimized for both time and space complexity, taking into account the linear arrangement of buildings and the coverage distance appropriately. - Handle edge cases, such as when each building must have its own streetlight due to minimal distance coverage.","solution":"def min_streetlights(building_heights, distance): This function calculates the minimum number of streetlights needed to illuminate all buildings. Each streetlight can cover buildings up to \'distance\' units away on either side of its position. n = len(building_heights) i = 0 streetlights_count = 0 while i < n: # Place the streetlight at the furthest building it can cover to the right streetlight_pos = min(i + distance, n) # Move left from this position to place a streetlight while streetlight_pos > i and not (i <= streetlight_pos - distance <= n - 1 and streetlight_pos - (distance if streetlight_pos - distance >= 0 else 0) >= 0): streetlight_pos -= 1 # Increment counter and set next building to the position outside current streetlight coverage streetlights_count += 1 i = streetlight_pos + distance return streetlights_count"},{"question":"**Problem Statement**: You are tasked with designing a function to simulate an “undo” and “redo” feature in a text editor. The text editor supports basic operations: typing text, deleting text, and operations for undo and redo. **Function Signature**: ```python def text_editor(operations: list[tuple[str, str]], undo: str, redo: str) -> str: ``` **Input**: * `operations` (list of tuples): Each tuple contains an operation and an associated string (if applicable). The operations can be: - `\'TYPE\'` (string): Type the provided string at the end of the current text. - `\'DELETE\'` (integer): Delete the last `n` characters of the current text. * `undo` (string): The keyword for the undo operation. * `redo` (string): The keyword for the redo operation. **Output**: * A string representing the final state of the text after performing all the operations with possible undo and redo operations. **Example**: ```python operations = [ (\'TYPE\', \'hello\'), (\'TYPE\', \' world\'), (\'DELETE\', \'5\'), (\'TYPE\', \'Python\'), (\'UNDO\', \'1\'), (\'REDO\', \'1\') ] undo = \'UNDO\' redo = \'REDO\' result = text_editor(operations, undo, redo) print(result) # Output: \'hello world\' ``` **Detailed Steps**: 1. `TYPE text` appends `text` to the current text content. 2. `DELETE n` removes the last `n` characters from the current text. 3. `UNDO` undoes the most recent operation that changed the text, restoring the text to its previous state. 4. `REDO` redoes the most recently undone operation, reapplying the most recently undone operation if there is an available operation to redo. **Constraints**: * All strings and integers in the operations are valid. * `UNDO` can only undo operations that actually modified the text (i.e., `TYPE`, `DELETE`). * `REDO` can only redo operations that were previously undone. * The `UNDO` and `REDO` operations can be called multiple times in a sequence but should only affect operations that directly changed the text content. * Typing and deleting should be treated as a single atomic operation for undoing and redoing purposes. ```python def text_editor(operations, undo, redo): text = \\"\\" history = [] undone = [] for operation, param in operations: if operation == \'TYPE\': history.append(text) text += param undone.clear() elif operation == \'DELETE\': history.append(text) text = text[:-int(param)] undone.clear() elif operation == undo: if history: undone.append(text) text = history.pop() elif operation == redo: if undone: history.append(text) text = undone.pop() return text ``` This function maintains the sequence of operations with undo and redo capabilities in a text editor. It uses the `history` to keep track of previous states and `undone` to track undone actions, ensuring an accurate final state based on the given operations.","solution":"def text_editor(operations, undo, redo): text = \\"\\" history = [] undone = [] for operation, param in operations: if operation == \'TYPE\': history.append(text) text += param undone.clear() elif operation == \'DELETE\': history.append(text) text = text[:-int(param)] undone.clear() elif operation == undo: if history: undone.append(text) text = history.pop() elif operation == redo: if undone: history.append(text) text = undone.pop() return text"},{"question":"**Context**: You are given a list of integers where every element appears twice except for one. Your task is to find the single element that appears only once. # Task: Implement a function `find_single_number(nums: list) -> int` that receives a list and returns the single element that appears only once. # Detailed Steps: 1. Iterate through the list of integers. 2. Use a method that achieves an optimal time complexity to identify the unique element. 3. Return the single number that appears only once in the list. # Input: * `nums`: A list of integers, where every integer appears exactly twice, except for one. # Output: * Returns an integer representing the single number that appears once in the list. # Constraints: * The length of the list will be at least 1 and at most 10^5. * Each element in the list appears twice except for one, which appears only once. # Example: ```python def find_single_number(nums: list) -> int: # Your implementation here # Usage result = find_single_number([2, 2, 1]) print(result) # Expected output: 1 result = find_single_number([4, 1, 2, 1, 2]) print(result) # Expected output: 4 ``` # Performance Requirements: * Your solution should achieve an O(n) runtime complexity using constant space complexity O(1).","solution":"def find_single_number(nums: list) -> int: Finds the single element in the list that appears only once. Args: nums (list): List of integers where every element appears twice except for one. Returns: int: The single number that appears only once in the list. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Coding Assessment Question Problem Statement: You are required to implement a function that simulates the behavior of a 2-input exclusive OR (XOR) gate. An XOR gate returns true (1) if exactly one of the inputs is true (1), and false (0) otherwise. This function should handle binary inputs (0 and 1) only. Functional Requirements: - Implement a function `xor_gate` that takes two integer inputs `input_1` and `input_2`, each of which is either 0 or 1. - Return 1 if exactly one of the inputs is true; otherwise, return 0. Input: - Two integer inputs, `input_1` and `input_2`, where each is either 0 or 1: `xor_gate(input_1: int, input_2: int) -> int` Output: - An integer, the result of the XOR operation on the inputs. Example: ```python >>> xor_gate(0, 0) 0 >>> xor_gate(1, 0) 1 >>> xor_gate(1, 1) 0 ``` Constraints: - The inputs must be either 0 or 1. - If an input is not a binary value, your function should raise a `ValueError`. Notes: - Ensure the function checks the validity of inputs and raises an appropriate error if the values are outside the expected range.","solution":"def xor_gate(input_1, input_2): Simulates a 2-input XOR gate. Parameters: - input_1: int (either 0 or 1) - input_2: int (either 0 or 1) Returns: - int: 1 if exactly one of the inputs is 1, otherwise 0 Raises: - ValueError: if input_1 or input_2 is not 0 or 1 if input_1 not in {0, 1} or input_2 not in {0, 1}: raise ValueError(\\"Inputs must be 0 or 1\\") return input_1 ^ input_2"},{"question":"# Scenario Imagine you are part of a development team building a library management system. One key functionality is to determine which books are overdue for return and calculate the fine for each overdue book based on the number of overdue days. # Task Write a Python function, `calculate_overdue_fines()`, that takes a list of dictionaries representing borrowed books and their due dates, and returns a list of dictionaries with the book details and their respective overdue fines. # Requirements 1. **Function Signature**: ```python def calculate_overdue_fines(borrowed_books: list[dict[str, str]], current_date: str) -> list[dict[str, int | str]]: ``` 2. **Input**: - `borrowed_books`: A list of dictionaries where each dictionary contains the following keys: * `Title`: Title of the book. * `Borrower`: Name of the person who borrowed the book. * `Due Date`: The due date of the book in the format `\'YYYY-MM-DD\'`. - `current_date`: A string representing the current date in the format `\'YYYY-MM-DD\'`. 3. **Output**: A list of dictionaries where each dictionary contains the following keys: * `Title`: Title of the overdue book. * `Borrower`: Name of the borrower. * `Days Overdue`: Number of days the book is overdue. * `Fine ()`: The calculated fine amount in dollars. The fine is 0.50 per overdue day. 4. **Constraints**: * Only books with a due date before the current date are considered overdue. * Assume all dates are valid and correctly formatted. * The function should handle an empty list of borrowed books by returning an empty list. # Example ```python borrowed_books = [ {\'Title\': \'1984\', \'Borrower\': \'Alice\', \'Due Date\': \'2023-09-15\'}, {\'Title\': \'To Kill a Mockingbird\', \'Borrower\': \'Bob\', \'Due Date\': \'2023-10-01\'}, {\'Title\': \'The Great Gatsby\', \'Borrower\': \'Charlie\', \'Due Date\': \'2023-09-05\'} ] current_date = \'2023-10-10\' expected_output = [ {\'Title\': \'1984\', \'Borrower\': \'Alice\', \'Days Overdue\': 25, \'Fine ()\': 12.5}, {\'Title\': \'The Great Gatsby\', \'Borrower\': \'Charlie\', \'Days Overdue\': 35, \'Fine ()\': 17.5} ] ``` # Additional Guidelines * Make use of Python\'s `datetime` module to handle date calculations. * Ensure the function is efficient and includes error handling for robustness. * Write a few test cases to validate your implementation, including edge cases (e.g., no overdue books).","solution":"from datetime import datetime def calculate_overdue_fines(borrowed_books, current_date): Calculate overdue fines for books. Parameters: borrowed_books (list): List of dictionaries with keys \'Title\', \'Borrower\', \'Due Date\'. current_date (str): The current date in the format \'YYYY-MM-DD\'. Returns: list: List of dictionaries with keys \'Title\', \'Borrower\', \'Days Overdue\', \'Fine ()\' for overdue books. current_date = datetime.strptime(current_date, \'%Y-%m-%d\') fines_list = [] fine_per_day = 0.50 for book in borrowed_books: due_date = datetime.strptime(book[\'Due Date\'], \'%Y-%m-%d\') if due_date < current_date: days_overdue = (current_date - due_date).days fine = days_overdue * fine_per_day fines_list.append({ \'Title\': book[\'Title\'], \'Borrower\': book[\'Borrower\'], \'Days Overdue\': days_overdue, \'Fine ()\': fine }) return fines_list"},{"question":"Batch File Renaming # Problem Statement You have a collection of files in a directory, each with a unique name. You need to implement a function `batch_rename_files` that takes a list of filenames and a common prefix. Your function should return a new list of filenames where each original filename is renamed by prefixing it with the provided common prefix followed by an underscore \'_\'. For example, if the prefix is \\"image\\" and one of the files is named \\"photo.jpg\\", the new filename should be \\"image_photo.jpg\\". If the input list of filenames is empty, return an empty list. Ensure filenames and prefix are non-empty strings and contain no spaces. # Function Signature ```python def batch_rename_files(filenames: list, prefix: str) -> list: pass ``` # Input * `filenames`: a list of strings, where each string is a filename (1 <= len(filenames) <= 1000). * `prefix`: a non-empty string (prefix will have between 1 and 100 characters) with no spaces. # Output * Return a list of strings with the new batch-renamed filenames. * Raise a `ValueError` if any filename or the prefix is invalid (i.e., if they contain spaces or are empty). # Constraints * Ensure filenames and prefix are non-empty and contain no spaces. * Input list and prefix should be validated and appropriate exceptions raised for invalid inputs (`ValueError`). # Examples ```python >>> batch_rename_files([\\"photo.jpg\\", \\"document.txt\\", \\"song.mp3\\"], \\"image\\") [\'image_photo.jpg\', \'image_document.txt\', \'image_song.mp3\'] >>> batch_rename_files([\\"report.docx\\"], \\"project\\") [\'project_report.docx\'] >>> batch_rename_files([], \\"file\\") [] >>> batch_rename_files([\\"file1\\", \\"file2\\"], \\"\\") Traceback (most recent call last): ... ValueError: Prefix must be a non-empty string with no spaces >>> batch_rename_files([\\" file1\\", \\"file2\\"], \\"project\\") Traceback (most recent call last): ... ValueError: Filenames must be non-empty strings with no spaces ``` # Explanation In the first example, the prefix \\"image\\" is added to each filename by appending an underscore \'_\': * \\"photo.jpg\\" becomes \\"image_photo.jpg\\" * \\"document.txt\\" becomes \\"image_document.txt\\" * \\"song.mp3\\" becomes \\"image_song.mp3\\" In the second example, the prefix \\"project\\" is added to the single filename \\"report.docx\\": * \\"report.docx\\" becomes \\"project_report.docx\\" In the third example, since the input list is empty, the output is an empty list. If any of the input validations fail, a `ValueError` is raised with the appropriate message.","solution":"def batch_rename_files(filenames: list, prefix: str) -> list: Renames files by prefixing each filename with the provided prefix followed by an underscore \'_\'. Args: filenames (list): A list of strings, where each string is a filename. prefix (str): A non-empty string with no spaces to prefix each filename. Returns: list: A list of strings with the new batch-renamed filenames. Raises: ValueError: If any filename or the prefix is invalid (i.e., if they contain spaces or are empty). if not prefix or \' \' in prefix: raise ValueError(\\"Prefix must be a non-empty string with no spaces.\\") if not all(filenames) or any(\' \' in filename for filename in filenames): raise ValueError(\\"Filenames must be non-empty strings with no spaces.\\") return [f\\"{prefix}_{filename}\\" for filename in filenames]"},{"question":"# Fibonacci Number Calculation Problem Statement: You are required to compute the Fibonacci sequence up to a specified integer `n` using dynamic programming. Detailed Description: The Fibonacci numbers are a sequence where each number is the sum of the two preceding ones, starting from 0 and 1. The sequence typically starts as: 0, 1, 1, 2, 3, 5, 8, ... The recursive formula to compute the n-th Fibonacci number ( F(n) ) is given by: [ F(n) = F(n-1) + F(n-2) ] With base cases: [ F(0) = 0 ] [ F(1) = 1 ] You need to implement a function that computes this sequence using the recursive relationship above with dynamic programming to optimize the calculations. Function Signature: ```python def fibonacci_numbers(upper_limit: int) -> list[int]: # Your code here ``` Input/Output: * **Input**: * `upper_limit` (int): The non-negative upper limit up to which the Fibonacci numbers will be computed. * **Output**: * A list of integers containing the Fibonacci numbers from index 0 to `upper_limit`. Constraints: * The input `upper_limit` will be a non-negative integer within the feasible range of computation for a list (up to about 100 for large recursion depth). * Mention any constraint checks as needed (e.g., valid input range). Example: ```python print(fibonacci_numbers(5)) # Output: [0, 1, 1, 2, 3, 5] print(fibonacci_numbers(2)) # Output: [0, 1, 1] print(fibonacci_numbers(-1)) # Output: ValueError: Limit for the Fibonacci sequence must be ≥ 0 ``` Implementation Notes: * Ensure that your solution raises a `ValueError` with a relevant message for negative inputs. * Aim to ensure that your computations handle up to reasonably large inputs effectively, considering the constraints of nested loops for dynamic programming. * Include examples and edge cases in docstrings and comments.","solution":"def fibonacci_numbers(upper_limit: int) -> list[int]: Computes the Fibonacci sequence up to the upper_limit using dynamic programming. Args: upper_limit (int): The non-negative upper limit up to which the Fibonacci numbers will be computed. Returns: list[int]: A list of integers containing the Fibonacci numbers from index 0 to upper_limit. Raises: ValueError: If the upper_limit is negative. if upper_limit < 0: raise ValueError(\\"Limit for the Fibonacci sequence must be >= 0\\") if upper_limit == 0: return [0] elif upper_limit == 1: return [0, 1] fib_sequence = [0, 1] for i in range(2, upper_limit + 1): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"# Coding Question - Fraction to Recurring Decimal In a recent bug report, a user has raised an issue with the system that handles converting fractions to decimal representations. The user mentions that the output for fractions results in infinitely repeating decimals for certain divisors. To address this, you are tasked with implementing a function that converts a fraction to its decimal representation, accurately handling repeating parts. # Scenario Your task is to develop a function that takes two integers representing the numerator and denominator of a fraction and returns its decimal representation as a string. If the decimal representation has repeating parts, enclose the repeating sequence in parentheses. # Task 1. Implement the `fraction_to_decimal` function according to the given specification. 2. Handle cases where the result is a repeating decimal efficiently and clearly identify the repeating sequence. # Function Signature ```python def fraction_to_decimal(numerator: int, denominator: int) -> str: pass ``` # Input * `numerator`: An integer, representing the numerator of the fraction. * `denominator`: An integer, representing the denominator of the fraction. # Output * Return the decimal representation of the fraction as a string. # Constraints * `-2^31 <= numerator, denominator <= 2^31 - 1` * The denominator will never be zero. # Example ```python assert fraction_to_decimal(1, 2) == \\"0.5\\" assert fraction_to_decimal(2, 3) == \\"0.(6)\\" assert fraction_to_decimal(4, 333) == \\"0.(012)\\" assert fraction_to_decimal(1, 5) == \\"0.2\\" assert fraction_to_decimal(22, 7) == \\"3.(142857)\\" assert fraction_to_decimal(-50, 8) == \\"-6.25\\" ``` # Additional Notes * Handle both positive and negative values for numerator and denominator. * Ensure that the function can identify and correctly format repeating decimal sequences. * Aim for a solution that clearly distinguishes between terminating and repeating decimals. * Maintain the efficiency of the algorithm while properly managing any edge cases.","solution":"def fraction_to_decimal(numerator: int, denominator: int) -> str: if numerator == 0: return \\"0\\" result = [] if (numerator < 0) ^ (denominator < 0): result.append(\\"-\\") num = abs(numerator) den = abs(denominator) # Integral part result.append(str(num // den)) remainder = num % den if remainder == 0: return \\"\\".join(result) # Fractional part result.append(\\".\\") remainder_map = {} while remainder != 0: if remainder in remainder_map: result.insert(remainder_map[remainder], \\"(\\") result.append(\\")\\") break remainder_map[remainder] = len(result) remainder *= 10 result.append(str(remainder // den)) remainder %= den return \\"\\".join(result)"},{"question":"# Zero Matrix Transformation You have been assigned to implement a function that modifies a given matrix by setting its entire row and column to zero if an element in the matrix is zero. This problem often appears in scenarios where we need to neutralize certain variable effects in data tables or matrices. **Your function** `zero_matrix(matrix: List[List[int]]) -> None` must transform the input `matrix` in place. If an element is zero, you must set the whole row and column to zeros. Function Signature: ```python from typing import List def zero_matrix(matrix: List[List[int]]) -> None: pass ``` # Input * A two-dimensional list `matrix` consisting of `m` rows and `n` columns, with each element `matrix[i][j]` being an integer (`matrix[i][j]` might be zero or non-zero). # Output * The function does not return anything. Modify the input `matrix` in place. # Constraints * Do not use additional 2D arrays or matrices for storage. * Try to limit additional space usage as much as possible, ideally to O(1) extra space besides the input matrix. * The function should efficiently handle matrices up to the size of 1000x1000. # Example Scenarios 1. `matrix = [[1, 2, 3], [4, 0, 6], [7, 8, 9]]` should transform `matrix` to `[[1, 0, 3], [0, 0, 0], [7, 0, 9]]`. 2. `matrix = [[0, 2, 3], [4, 5, 6], [7, 8, 9]]` should transform `matrix` to `[[0, 0, 0], [0, 5, 6], [0, 8, 9]]`. # Edge Cases 1. A matrix with no zeros should remain unchanged. 2. A matrix where all elements in a row or a column are zeros should remain zeros. 3. Large matrices should be handled within the performance constraints. Requirements: - **Performance**: Efficiently handle matrix transformations for large matrices (up to 1000x1000). - **In-place Modification**: Modify the input matrix directly without using additional 2D arrays for intermediate storage. Implement the function and ensure it meets the requirements.","solution":"from typing import List def zero_matrix(matrix: List[List[int]]) -> None: Modifies the input matrix such that any row and column containing a zero will have all their elements set to zero. The transformation is done in place. if not matrix: return m, n = len(matrix), len(matrix[0]) rows, cols = set(), set() # First pass: record the zero rows and columns for i in range(m): for j in range(n): if matrix[i][j] == 0: rows.add(i) cols.add(j) # Second pass: set the rows and columns to zero for i in range(m): for j in range(n): if i in rows or j in cols: matrix[i][j] = 0"},{"question":"# Merge Strategy Implementation In this task, you will implement a merge strategy commonly used in data processing and analysis applications. Scenario: You are working on a data integration project that requires you to merge two lists of data records. Each record is represented by a dictionary and contains a unique identifier and other attributes. Your task is to merge these two lists based on the unique identifier, combining the records\' attributes. Objective: Implement a function `merge_records_by_id` that takes two lists of records and merges them based on a unique identifier. If a record with the same identifier exists in both lists, the resulting record should combine all unique attributes from both records. If attributes with the same key exist in both records, the value from the second list should override the value from the first list. # Specifications: 1. Function: * `merge_records_by_id` - Takes two lists of records and merges them based on a unique identifier. The function should handle merging of attributes and ensure no duplicate records based on the identifier. 2. Input/Output Formats: * **Input**: * Two lists of records, where each record is represented as a dictionary containing key-value pairs. Each record has a key `\'id\'` representing a unique identifier. * **Output**: * A single list of merged records, with no duplicate identifiers. Attributes from the second list override those from the first list if they conflict. Constraints: * The `\'id\'` field in each record is unique within its own list. * The lists can be of different lengths. * The lists and records can be empty. Function Signature: ```python def merge_records_by_id(list1: list, list2: list) -> list: pass ``` # Example Usage: ```python list1 = [ {\'id\': 1, \'name\': \'Alice\', \'age\': 30}, {\'id\': 2, \'name\': \'Bob\', \'age\': 25}, ] list2 = [ {\'id\': 2, \'name\': \'Robert\', \'city\': \'New York\'}, {\'id\': 3, \'name\': \'Charlie\', \'age\': 35, \'city\': \'San Francisco\'}, ] result = merge_records_by_id(list1, list2) # Output: [ # {\'id\': 1, \'name\': \'Alice\', \'age\': 30}, # {\'id\': 2, \'name\': \'Robert\', \'age\': 25, \'city\': \'New York\'}, # {\'id\': 3, \'name\': \'Charlie\', \'age\': 35, \'city\': \'San Francisco\'} # ] ``` # Guidelines: * Ensure that the function handles records with varying attributes. * Efficiently merge the lists, considering both time and space complexity. * Existing records in the first list must not be modified directly but instead be considered as the basis for merging. # Implementation Hints: * Utilize a dictionary for intermediate storage to efficiently check for and merge records based on the identifier. * Handle potential edge cases, such as empty input lists or records with different sets of attributes. Implement the `merge_records_by_id` function to meet the given requirements and ensure it performs accurately with the provided example and constraints.","solution":"def merge_records_by_id(list1: list, list2: list) -> list: Merges two lists of records based on unique identifier \'id\'. If the same \'id\' exists in both lists, attributes from list2 override those in list1. record_map = {} # Add all records from list1 to the map for record in list1: record_map[record[\'id\']] = record.copy() # Merge records from list2, overriding the attributes if the id matches for record in list2: if record[\'id\'] in record_map: record_map[record[\'id\']].update(record) else: record_map[record[\'id\']] = record.copy() # Convert the record map back to a list of records return list(record_map.values())"},{"question":"# Question: Merge K Sorted Arrays You are given `k` sorted arrays. Write a function that merges these arrays into a single sorted array. Function Signature: ```python def merge_k_sorted_arrays(arrays: List[List[int]]) -> List[int]: pass ``` # Input: - `arrays`: A list of `k` sorted arrays, where each array is a list of integers. # Output: - Returns a single list containing all the integers from the input arrays, sorted in non-decreasing order. # Constraints: - The total number of elements across all arrays does not exceed (10^6). - Each array is already sorted in non-decreasing order. # Example: ```python arrays = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] print(merge_k_sorted_arrays(arrays)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Explanation: In the given example, there are 3 arrays: 1. [1, 4, 7] 2. [2, 5, 8] 3. [3, 6, 9] When merged, the resulting array should be: [1, 2, 3, 4, 5, 6, 7, 8, 9].","solution":"from heapq import heappush, heappop from typing import List def merge_k_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merges k sorted arrays into a single sorted array. # A min heap to store each element along with the respective array index and element index min_heap = [] # Initialize the heap with the first element of each array for i, arr in enumerate(arrays): if arr: # Ensuring the array is not empty heappush(min_heap, (arr[0], i, 0)) result = [] while min_heap: val, arr_idx, ele_idx = heappop(min_heap) result.append(val) # If there\'s more elements in the same array, push the next element to the heap if ele_idx + 1 < len(arrays[arr_idx]): next_tuple = (arrays[arr_idx][ele_idx + 1], arr_idx, ele_idx + 1) heappush(min_heap, next_tuple) return result"},{"question":"# Matrix Path Minimum Sum **Context**: You have been tasked with developing an algorithm to find the minimum path sum in a grid. This algorithm is essential for a mobile robot navigating a warehouse with defined grid paths, where it seeks to minimize the energy consumption required to reach its destination. **Task**: Implement a function `min_path_sum(grid: List[List[int]]) -> int` that calculates the minimum sum of all numbers along a path from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. **Requirements**: 1. Develop an algorithm that iterates through the grid to compute the minimum path sum. 2. Ensure your solution efficiently handles grids of various sizes. 3. Handle edge cases such as empty grids or grids with only one row or column. **Input**: * A two-dimensional list `grid` of integers, where `1 <= len(grid), len(grid[0]) <= 200` and `0 <= grid[i][j] <= 100`. **Output**: * An integer representing the minimum path sum from the top-left corner to the bottom-right corner. **Constraints**: * You can only move either down or to the right at any point in time. * The grid will only contain non-negative integers. **Performance**: * Aim for an optimal solution with respect to both time and space complexity. **Example**: ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(grid)) # Output: 7 ``` **Explanation**: The path with the minimum sum is `1 -> 3 -> 1 -> 1 -> 1`, which totals 7. **Edge Cases**: - `min_path_sum([])` should return 0. - `min_path_sum([[0]])` should return 0. Use the above requirements and constraints to develop your solution. Consider different grid configurations to ensure comprehensive handling of diverse input scenarios.","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Question: Implement a Custom Stack with Enhanced Functionalities You are tasked with implementing a custom stack class `AdvancedStack` that extends the basic functionality of a stack by adding some enhanced features, including getting the minimum, maximum, and mean value of the elements currently in the stack. **Class Definition**: `AdvancedStack` **Methods**: 1. `push(value: int) -> None`: Push an integer onto the stack. 2. `pop() -> int`: Remove and return the top element from the stack. If the stack is empty, raise an `IndexError` with a message \\"pop from empty stack\\". 3. `top() -> int`: Return the top element of the stack without removing it. If the stack is empty, raise an `IndexError` with a message \\"top from empty stack\\". 4. `get_min() -> int`: Return the minimum value in the stack. If the stack is empty, raise an `IndexError` with a message \\"min from empty stack\\". 5. `get_max() -> int`: Return the maximum value in the stack. If the stack is empty, raise an `IndexError` with a message \\"max from empty stack\\". 6. `get_mean() -> float`: Return the mean (average) of values in the stack. If the stack is empty, raise an `IndexError` with a message \\"mean from empty stack\\". **Input**: - Each method call is made sequentially to the `AdvancedStack` object. **Output**: - The type of each output is defined by the method\'s return type. # Example ```python stack = AdvancedStack() stack.push(3) stack.push(5) stack.push(1) print(stack.get_min()) # Output: 1 print(stack.get_max()) # Output: 5 print(stack.get_mean()) # Output: 3.0 print(stack.top()) # Output: 1 print(stack.pop()) # Output: 1 print(stack.get_min()) # Output: 3 print(stack.get_mean()) # Output: 4.0 ``` # Performance Requirements: - Each operation should run in O(1) average time complexity. Implement the `AdvancedStack` class ensuring you handle all edge cases and return accurate results.","solution":"class AdvancedStack: def __init__(self): self.stack = [] self.min_stack = [] self.max_stack = [] self.total = 0 def push(self, value: int) -> None: self.stack.append(value) self.total += value if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() self.total -= value if value == self.min_stack[-1]: self.min_stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() return value def top(self) -> int: if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.stack: raise IndexError(\\"min from empty stack\\") return self.min_stack[-1] def get_max(self) -> int: if not self.stack: raise IndexError(\\"max from empty stack\\") return self.max_stack[-1] def get_mean(self) -> float: if not self.stack: raise IndexError(\\"mean from empty stack\\") return self.total / len(self.stack)"},{"question":"# Linked List Palindrome Check Problem Statement You are provided with a singly linked list data structure. Your task is to implement a method that checks if the linked list is a palindrome. A palindrome is a sequence that reads the same backward as forward. Requirements Implement the following method in the `LinkedList` class: ```python def is_palindrome(self) -> bool: Check if the linked list is a palindrome. Returns: bool: True if the linked list is a palindrome, False otherwise. Example: >>> ll = LinkedList() >>> ll.append(1) >>> ll.append(2) >>> ll.append(3) >>> ll.append(2) >>> ll.append(1) >>> ll.is_palindrome() True >>> ll = LinkedList() >>> ll.append(1) >>> ll.append(2) >>> ll.is_palindrome() False ``` Your implementation must: - Use O(n) time complexity to determine if the linked list is a palindrome. - Use O(1) additional space complexity, i.e., do not use additional data structures that grow with the input size. Input and Output - **Input**: No direct input. The linked list is constructed using the `append` method before calling `is_palindrome`. - **Output**: Boolean value indicating if the linked list is a palindrome. Constraints - Your implementation should handle linked lists with up to 10^5 nodes. - Optimize your method to handle large linked lists efficiently. Performance Requirements - Minimize the number of traversals of the linked list to achieve the palindrome check. - Ensure the solution works within the given space complexity constraint. Example ```python >>> ll = LinkedList() >>> ll.append(1) >>> ll.append(2) >>> ll.append(3) >>> ll.append(2) >>> ll.append(1) >>> print(ll.is_palindrome()) # Output: True >>> ll = LinkedList() >>> ll.append(1) >>> ll.append(2) >>> print(ll.is_palindrome()) # Output: False ``` # Note - You may need to modify the linked list during your check but ensure it is restored to its original state after the method completes.","solution":"class Node: def __init__(self, value=0, next_node=None): self.value = value self.next = next_node class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def is_palindrome(self) -> bool: if self.head is None or self.head.next is None: return True # Find the middle of the linked list slow = fast = self.head prev_of_slow = None while fast and fast.next: fast = fast.next.next prev_of_slow = slow slow = slow.next # For odd sized list, fast will not be None middle_node = None if fast: middle_node = slow slow = slow.next # Split the list into two halves and reverse the second half second_half = slow prev_of_slow.next = None # Terminate the first half second_half = self.reverse(second_half) # Check if the two halves are palindromes result = self.compare_lists(self.head, second_half) # Restore the list second_half = self.reverse(second_half) if middle_node: prev_of_slow.next = middle_node middle_node.next = second_half else: prev_of_slow.next = second_half return result def reverse(self, head): prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def compare_lists(self, head1, head2): while head1 and head2: if head1.value != head2.value: return False head1 = head1.next head2 = head2.next return True"},{"question":"# Question: K-Complete Subarrays Context: A `k-complete` subarray is defined as an array that contains exactly `k` distinct integers. Given an array of `n` integers and an integer `k`, your task is to calculate the number of subarrays that are `k-complete`. Objective: You need to implement a function `count_k_complete_subarrays` that will find the number of `k-complete` subarrays in the given array. Function Signature: ```python def count_k_complete_subarrays(arr: list[int], k: int) -> int: pass ``` Parameters: * `arr` (list[int]): A list of `n` integers (1 ≤ n ≤ 10^5). * `k` (int): The number of distinct integers that define a `k-complete` subarray (1 ≤ k ≤ n). Returns: * `int`: The count of subarrays in `arr` that contain exactly `k` distinct integers. Example: ```python assert count_k_complete_subarrays([1, 2, 1, 2, 3], 2) == 7 assert count_k_complete_subarrays([1, 2, 1, 3, 4], 3) == 3 ``` Explanation: In the first example, the subarrays of `arr` that contain exactly 2 distinct integers are: `[1,2]`, `[2,1]`, `[1,2]`, `[2,1,2]`, `[1,2,1]`, `[2,1,2,3]`, and `[3,4]`. Constraints: * Ensure your function performs efficiently within the provided limits. * Optimize for time complexity using appropriate data structures.","solution":"def count_k_complete_subarrays(arr, k): from collections import defaultdict def at_most_k_distinct(arr, k): count = defaultdict(int) i = 0 total_k_complete = 0 for j in range(len(arr)): if count[arr[j]] == 0: k -= 1 count[arr[j]] += 1 while k < 0: count[arr[i]] -= 1 if count[arr[i]] == 0: k += 1 i += 1 total_k_complete += j - i + 1 return total_k_complete return at_most_k_distinct(arr, k) - at_most_k_distinct(arr, k-1)"},{"question":"Coding Assessment Question # Scenario A network of computers can be represented as a matrix where the value at position `(i, j)` indicates a direct transmission time between two connected computers `i` and `j`. If there is no direct connection between two computers, the value is represented as `float(\'inf\')`. Your task is to write a function that calculates the shortest transmission times between all pairs of computers in the network using the Floyd-Warshall algorithm. # Problem Design a function `floyd_warshall(matrix: list[list[float]]) -> list[list[float]]` to calculate the shortest transmission times between all pairs of computers in the network. 1. The input `matrix` will be a square matrix where the value at position `(i, j)` indicates the direct transmission time between computer `i` and computer `j`. 2. If there is no direct connection between two computers, the value at that position will be `float(\'inf\')`. 3. The direct transmission time from a computer to itself is zero. Example ```python def floyd_warshall(matrix: list[list[float]]) -> list[list[float]]: pass # Examples network_matrix = [ [0, 3, float(\'inf\'), 5], [2, 0, float(\'inf\'), 4], [float(\'inf\'), 1, 0, float(\'inf\')], [float(\'inf\'), float(\'inf\'), 2, 0] ] shortest_paths = floyd_warshall(network_matrix) print(shortest_paths) # Output: # [ # [0, 3, 7, 5], # [2, 0, 6, 4], # [3, 1, 0, 5], # [5, 3, 2, 0] # ] ``` # Constraints * The input matrix will always be non-empty and square (i.e., NxN dimensions). * The transmission times will be non-negative or `float(\'inf\')` for no direct connection. * The value from a computer to itself will always be zero. # Function Signature ```python def floyd_warshall(matrix: list[list[float]]) -> list[list[float]]: pass ``` # Considerations 1. **Correctness**: Ensure the algorithm correctly handles paths through intermediate nodes and yields the shortest paths. 2. **Efficiency**: Optimize for time complexity, considering the O(N^3) nature of the Floyd-Warshall algorithm. 3. **Robustness**: Ensure the function works correctly for varying sizes of network matrices.","solution":"def floyd_warshall(matrix): Perform the Floyd-Warshall algorithm to find the shortest paths between all pairs of nodes. n = len(matrix) dist = [row[:] for row in matrix] # Create a copy of the matrix for the distances # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"# Question: Merge and Sort Two Lists You are tasked with writing a function to: 1. **Merge** two sorted lists into a single sorted list without using any built-in sorting methods. Function Requirements: `merge_and_sort` Your function needs to: - Accept two lists `list1` and `list2`, where each list is sorted in ascending order. - Merge these lists into one single list sorted in ascending order. # Input: - `list1` (list of int): A sorted list of integers. - `list2` (list of int): Another sorted list of integers. # Output: - (list of int): A single list containing all elements from both input lists, sorted in ascending order. # Constraints: - Each list can contain between 0 to 1000 elements. - Each element in the lists is an integer between -10^6 and 10^6. # Example: ```python assert merge_and_sort([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_and_sort([0, 10, 20], [-5, 5, 25]) == [-5, 0, 5, 10, 20, 25] assert merge_and_sort([], [2, 3, 4]) == [2, 3, 4] assert merge_and_sort([1, 2, 3], []) == [1, 2, 3] ``` # Solution Skeleton Here is a skeleton code for you to complete: ```python def merge_and_sort(list1: list[int], list2: list[int]) -> list[int]: result = [] i = j = 0 # Merge the lists while i < len(list1) and j < len(list2): if list1[i] < list2[j]: result.append(list1[i]) i += 1 else: result.append(list2[j]) j += 1 # Add any remaining elements from list1 while i < len(list1): result.append(list1[i]) i += 1 # Add any remaining elements from list2 while j < len(list2): result.append(list2[j]) j += 1 return result # Test your implementation if __name__ == \\"__main__\\": assert merge_and_sort([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_and_sort([0, 10, 20], [-5, 5, 25]) == [-5, 0, 5, 10, 20, 25] assert merge_and_sort([], [2, 3, 4]) == [2, 3, 4] assert merge_and_sort([1, 2, 3], []) == [1, 2, 3] ``` This question tests your ability to merge two sorted lists into one sorted list without using any built-in sorting functions, ensuring your solution maintains the input lists\' order. The example tests verify the correct implementation of the merging logic.","solution":"def merge_and_sort(list1, list2): result = [] i, j = 0, 0 # Merge process while i < len(list1) and j < len(list2): if list1[i] < list2[j]: result.append(list1[i]) i += 1 else: result.append(list2[j]) j += 1 # Collect remaining elements from list1 while i < len(list1): result.append(list1[i]) i += 1 # Collect remaining elements from list2 while j < len(list2): result.append(list2[j]) j += 1 return result"},{"question":"# Context A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Fermat\'s Little Theorem states that if `p` is a prime number and `a` is an integer not divisible by `p`, then `a^(p-1) ≡ 1 (mod p)`. Given an integer `n`, we want to find all prime numbers less than or equal to `n` and check Fermat\'s Little Theorem for verified prime numbers. This problem involves generating prime numbers and performing modular exponentiation efficiently. # Task Implement a function `fermat_little_theorem_verification` that verifies Fermat\'s Little Theorem for all prime numbers less than or equal to the given integer `n`. 1. **Function Signature**: ```python def fermat_little_theorem_verification(n: int) -> List[int]: pass ``` 2. **Parameters**: - `n`: An integer greater than 1. 3. **Returns**: - A list of prime numbers less than or equal to `n` for which Fermat\'s Little Theorem holds true. # Constraints - `n` will be an integer between 2 and 10^4. - The implementation should be efficient in terms of time and space complexity. # Example Consider the following input: ```python fermat_little_theorem_verification(10) ``` The function should return `[2, 3, 5, 7]`, as these are the prime numbers less than or equal to 10 that satisfy Fermat\'s Little Theorem. For input `n = 10`, we will have: - Primes less than or equal to 10: `[2, 3, 5, 7]` - We check Fermat\'s Little Theorem for each prime `p`: - For `p = 2`, the check is trivial as only 1 is checked. - For `p = 3`, 2^2 ≡ 1 (mod 3). - For `p = 5`, 2^4 ≡ 1 (mod 5), 3^4 ≡ 1 (mod 5), and 4^4 ≡ 1 (mod 5). - For `p = 7`, 2^6 ≡ 1 (mod 7), 3^6 ≡ 1 (mod 7), 4^6 ≡ 1 (mod 7), 5^6 ≡ 1 (mod 7), and 6^6 ≡ 1 (mod 7). # Implementation Details 1. Use the Sieve of Eratosthenes to generate all prime numbers up to `n`. 2. For each prime number `p`, verify Fermat\'s Little Theorem by checking if `a^(p-1) ≡ 1 (mod p)` for `1 <= a < p`. 3. Return the list of primes that satisfy the theorem. ```python from typing import List def fermat_little_theorem_verification(n: int) -> List[int]: def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return [p for p in range(limit + 1) if is_prime[p]] def is_fermat_prime(p: int) -> bool: for a in range(1, p): if pow(a, p-1, p) != 1: return False return True primes = sieve_of_eratosthenes(n) verified_primes = [p for p in primes if is_fermat_prime(p)] return verified_primes ``` This additional question aligns with the style, complexity, and scope of the provided sample question related to polynomial interpolation and Gaussian elimination. It covers prime number generation, modular arithmetic, and theorem verification, which are fundamental concepts in number theory and algorithmic problem-solving.","solution":"from typing import List def fermat_little_theorem_verification(n: int) -> List[int]: def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return [p for p in range(limit + 1) if is_prime[p]] def is_fermat_prime(p: int) -> bool: for a in range(1, p): if pow(a, p-1, p) != 1: return False return True primes = sieve_of_eratosthenes(n) verified_primes = [p for p in primes if is_fermat_prime(p)] return verified_primes"},{"question":"# Problem: Sum of Unique Primes You are tasked with calculating the sum of unique prime numbers within a provided range. Your function must identify all prime numbers between two given integers and compute their sum, ensuring that each prime number is counted only once. **Objective**: Write a function `sum_of_unique_primes(start: int, end: int) -> int` that returns the sum of all unique prime numbers within the inclusive range from `start` to `end`. **Function Signature**: `def sum_of_unique_primes(start: int, end: int) -> int:` **Input**: - `start` (integer): The beginning of the range (0 ≤ start ≤ 10^6). - `end` (integer): The end of the range (0 ≤ end ≤ 10^6, `start` ≤ `end`). **Output**: - An integer representing the sum of all unique prime numbers within the specified range. **Constraints**: - The range [start, end] is inclusive. - Each prime number should be counted only once. - If there are no prime numbers in the specified range, return 0. **Examples**: ```python print(sum_of_unique_primes(10, 20)) # Output: 60 (Primes are 11, 13, 17, 19) print(sum_of_unique_primes(1, 10)) # Output: 17 (Primes are 2, 3, 5, 7) print(sum_of_unique_primes(15, 16)) # Output: 0 (No primes in this range) ``` **Detailed Explanation**: 1. Generate a list of prime numbers up to `end` using an efficient algorithm (such as the Sieve of Eratosthenes). 2. Iterate through the range [start, end] and sum any number that is identified as a prime. 3. Ensure each prime number within the specified range is counted once. 4. Return the total sum of these unique primes. **Requirements**: - Use optimal algorithms for prime generation and checking to handle large inputs efficiently. - Ensure your solution performs well even at the upper boundaries of the input constraints.","solution":"def sum_of_unique_primes(start: int, end: int) -> int: def sieve_of_eratosthenes(n): is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 is_prime[0], is_prime[1] = False, False # 0 and 1 are not primes return is_prime if start > end: return 0 is_prime = sieve_of_eratosthenes(end) prime_sum = sum(i for i in range(start, end + 1) if is_prime[i]) return prime_sum"},{"question":"# Problem Statement You are tasked with implementing a function that computes the product of all the integers in a given list except for the number at each index. The objective is to return a new list where each element at index `i` of the new list is the product of all the numbers in the original list except the one at `i`. # Function Signature ```python def product_except_self(nums: List[int]) -> List[int]: This function takes a list of integers and returns a list such that each element at index i of the output list is the product of all the numbers in the original list except the one at i. :param nums: A list of integers. :returns: A list of integers representing the product of all elements except self. ``` # Input - `nums` (List[int]): A list of integers. The length of the list can vary from 1 to 10^5. # Output - The function must return a list of integers representing the product of all elements in `nums` except for the number at each corresponding index. # Constraints - The algorithm should run in O(n) time complexity and use O(n) space complexity without using division. - Handle edge cases where the list has zeros appropriately. # Examples ```python assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] assert product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] assert product_except_self([1, 0]) == [0, 1] assert product_except_self([2, 0, 3, 4]) == [0, 24, 0, 0] assert product_except_self([1, 2]) == [2, 1] ``` # Notes - The function should be able to handle cases with one or more zeroes in the list. - Consider the use of auxiliary arrays or variables to keep track of the product of elements to ensure efficiency. - Ensure that the function handles both small and large lists effectively.","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: This function takes a list of integers and returns a list such that each element at index i of the output list is the product of all the numbers in the original list except the one at i. :param nums: A list of integers. :returns: A list of integers representing the product of all elements except self. length = len(nums) if length == 1: return [0] # If there\'s only one element, we can\'t produce a product except self. left_products = [0] * length right_products = [0] * length result = [0] * length left_products[0] = 1 for i in range(1, length): left_products[i] = nums[i - 1] * left_products[i - 1] right_products[length - 1] = 1 for i in range(length - 2, -1, -1): right_products[i] = nums[i + 1] * right_products[i + 1] for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"# Problem Statement Write a function that processes a string containing a mathematical expression with nested parentheses and sums all the integer values within all parentheses. The function should handle multiple levels of nested parentheses and discard any non-numeric characters. # Requirements 1. Implement a function `sum_nested_parentheses(expression: str) -> int` that returns the sum of all integer values inside the nested parentheses. 2. The function should correctly handle an empty string or a string without any parentheses by returning 0. 3. Properly manage cases with unmatched or misordered parentheses by raising an appropriate exception. 4. Any non-numeric characters (except the parentheses) should be ignored. # Function Signature Complete the function `sum_nested_parentheses` adhering to the following signature: ```python def sum_nested_parentheses(expression: str) -> int: pass ``` # Input and Output * **Input**: A string `expression` containing integers, other characters, and nested parentheses. * The length of `expression` is between `0` and `10^6`. * **Output**: An integer representing the sum of all the values found within parentheses. # Constraints * The function should return `0` for an empty string or no matching parentheses. * The function should raise a `ValueError` if the parentheses are unmatched or misordered. # Example ```python >>> expression = \\"(12)(34)\\" >>> sum_nested_parentheses(expression) 46 >>> expression = \\"(12(34)56)\\" >>> sum_nested_parentheses(expression) 102 >>> expression = \\"abc(11(de3f456)78)xyz\\" >>> sum_nested_parentheses(expression) 548 >>> expression = \\"(1(2(3(4)5(6)7(8)9)10)11)\\" >>> sum_nested_parentheses(expression) 66 >>> expression = \\"no_numbers_here\\" >>> sum_nested_parentheses(expression) 0 >>> expression = \\"(12(34)\\" >>> sum_nested_parentheses(expression) Traceback (most recent call last): ... ValueError: Unmatched or misordered parentheses ``` # Notes * The focus is on correctly parsing and summing integers within a string containing nested parentheses. * Ensure proper management of exceptions for robust error handling.","solution":"def sum_nested_parentheses(expression: str) -> int: stack = [] current_number = \'\' total_sum = 0 for char in expression: if char == \'(\': if current_number: stack[-1] += int(current_number) current_number = \'\' stack.append(0) elif char == \')\': if not stack: raise ValueError(\\"Unmatched or misordered parentheses\\") if current_number: stack[-1] += int(current_number) current_number = \'\' num_to_add = stack.pop() if stack: stack[-1] += num_to_add else: total_sum += num_to_add elif char.isdigit(): current_number += char else: if current_number: if stack: stack[-1] += int(current_number) current_number = \'\' if stack: raise ValueError(\\"Unmatched or misordered parentheses\\") return total_sum"},{"question":"# Pattern Matching for Anagrams You are required to implement a function `find_anagrams(word: str, candidates: list[str]) -> list[str]` that finds all anagrams of a given word from a list of candidate words. An anagram of a word is a rearrangement of its letters to form a different word. # Function Signature ```python def find_anagrams(word: str, candidates: list[str]) -> list[str]: pass ``` # Input - `word`: a string representing the word for which you need to find anagrams. - `candidates`: a list of strings where each string represents a candidate word that may be an anagram of the given word. # Output - Return a list of strings where each string is an anagram of the given word from the candidates list. # Constraints - The input word and candidate words are case insensitive. - Exclude the original word itself if it appears in the candidates list. - Return the anagrams in the same order they appear in the candidates list. # Examples ```python >>> find_anagrams(\\"listen\\", [\\"enlists\\", \\"google\\", \\"inlets\\", \\"banana\\"]) [\\"inlets\\"] >>> find_anagrams(\\"evil\\", [\\"vile\\", \\"live\\", \\"veil\\", \\"villain\\"]) [\\"vile\\", \\"live\\", \\"veil\\"] >>> find_anagrams(\\"play\\", [\\"lap\\", \\"paly\\", \\"lay\\", \\"pyal\\"]) [\\"paly\\", \\"pyal\\"] >>> find_anagrams(\\"night\\", [\\"thing\\", \\"ghtnin\\", \\"thin\\", \\"hitgn\\"]) [\\"thing\\", \\"hitgn\\"] >>> find_anagrams(\\"star\\", [\\"stars\\", \\"rasta\\", \\"staar\\"]) [] ``` # Explanation - The first example returns \\"inlets\\" as it is the only anagram of \\"listen\\" in the list. - The second example returns \\"vile\\", \\"live\\", and \\"veil\\" as anagrams of \\"evil\\". - The third example returns \\"paly\\" and \\"pyal\\" as anagrams of \\"play\\". - The fourth example returns \\"thing\\" and \\"hitgn\\" as anagrams of \\"night\\". - The fifth example returns an empty list because there are no valid anagrams. # Implementation Details - Use sorting or a character count technique to determine if two words are anagrams. - Handle edge cases where no anagrams are found or the input list is empty.","solution":"def find_anagrams(word: str, candidates: list[str]) -> list[str]: Finds all anagrams of a given word from a list of candidate words. Parameters: - word: str - the word to find anagrams for - candidates: list[str] - list of candidate words to check against Returns: - list[str] - list of anagrams from the candidates # Normalize the input word by sorting its characters sorted_word = sorted(word.lower()) anagrams = [] for candidate in candidates: # Check if the candidate is not the same as the input word and if it is an anagram if candidate.lower() != word.lower() and sorted(candidate.lower()) == sorted_word: anagrams.append(candidate) return anagrams"},{"question":"**Scenario:** You are part of a software engineering team that works on developing personalized health and fitness applications. One of your projects involves analyzing the performance of athletes based on heart rate and activity data collected through wearable devices. Your goal is to implement a system that processes this data to extract insightful metrics. **Problem Statement:** Implement a Python function that calculates the average heart rate per activity period, given a list of heart rate measurements recorded alongside corresponding epochs. # Function Specification ```python def calculate_average_heart_rate( heart_rates: List[int], epochs: List[str]) -> Dict[str, float]: Computes the average heart rate for each unique epoch. :param heart_rates: List of integers representing heart rate measurements. :param epochs: List of strings representing epochs associated with each heart rate. :return: Dictionary where keys are epochs and values are the average heart rate for that epoch. :raises ValueError: If the lengths of heart_rates and epochs do not match. pass ``` # Input - `heart_rates` - A list of integers representing heart rate measurements. - `epochs` - A list of strings where each string represents an epoch (time period or activity session). # Output - A dictionary where keys are the unique epochs and values are the average heart rate for the corresponding epoch. # Constraints - Both `heart_rates` and `epochs` will have the same length. - The input lists will contain at least one element. - Raise a `ValueError` if the lengths of `heart_rates` and `epochs` do not match. # Example ```python # Sample Input heart_rates = [90, 85, 88, 92, 87, 78, 96, 83] epochs = [\\"Morning Run\\", \\"Morning Run\\", \\"Morning Run\\", \\"Lunch Walk\\", \\"Lunch Walk\\", \\"Workout\\", \\"Workout\\", \\"Workout\\"] # Expected Output output = { \\"Morning Run\\": 87.66666666666667, \\"Lunch Walk\\": 89.5, \\"Workout\\": 85.66666666666667 } print(calculate_average_heart_rate(heart_rates, epochs) == output) # Should print True ``` # Notes - Ensure the function handles input validation, including checking that the lengths of the input lists match. - Use built-in Python collections and functions to efficiently compute the average heart rates. - Be mindful of performance when dealing with larger datasets, even though the inputs are guaranteed to be non-empty and of reasonable size.","solution":"from typing import List, Dict def calculate_average_heart_rate(heart_rates: List[int], epochs: List[str]) -> Dict[str, float]: Computes the average heart rate for each unique epoch. :param heart_rates: List of integers representing heart rate measurements. :param epochs: List of strings representing epochs associated with each heart rate. :return: Dictionary where keys are epochs and values are the average heart rate for that epoch. :raises ValueError: If the lengths of heart_rates and epochs do not match. if len(heart_rates) != len(epochs): raise ValueError(\\"The lengths of heart_rates and epochs must match\\") epoch_heart_rate_map = {} for rate, epoch in zip(heart_rates, epochs): if epoch not in epoch_heart_rate_map: epoch_heart_rate_map[epoch] = [] epoch_heart_rate_map[epoch].append(rate) average_heart_rate_per_epoch = {epoch: sum(rates) / len(rates) for epoch, rates in epoch_heart_rate_map.items()} return average_heart_rate_per_epoch"},{"question":"# Problem: Detect Cycles in a Directed Graph using DFS You are tasked with implementing an algorithm to detect cycles in a directed graph using Depth-First Search (DFS). # Function Signature ```python def detect_cycle(num_nodes: int, edges: list[tuple[int, int]]) -> bool: Parameters: - num_nodes : int : the number of nodes (vertices) in the graph - edges : list of tuples : each tuple is of the form (u, v) where `u` and `v` are directed nodes connected by an edge from `u` to `v` Returns: - bool : True if there is at least one cycle in the graph, otherwise False ``` # Input Format - `num_nodes`: The number of nodes in the graph (0 < num_nodes <= 1000). - `edges`: A list of tuples, where each tuple (u, v) represents a directed edge from node u to node v. The list can have up to 10000 edges. # Output Format - A boolean value. Return `True` if the graph contains at least one cycle; otherwise, return `False`. # Constraints - The graph can be disconnected. - No node is self-connected, i.e., (u, u) is not a valid edge. - There can be multiple edges between the same nodes. # Performance Requirements - The solution should efficiently handle up to 1000 nodes and 10000 edges. # Scenario Imagine you are working on a task scheduling system where tasks are represented as nodes and dependencies between tasks are represented as directed edges in a graph. Your objective is to detect if there is a circular dependency in the task list, which would mean that the tasks cannot be completed. # Example ```python num_nodes = 4 edges = [(0, 1), (1, 2), (2, 0), (3, 2)] # Expected output: # True (There is a cycle: 0 -> 1 -> 2 -> 0) ``` Implement the function to solve the problem described.","solution":"def detect_cycle(num_nodes: int, edges: list[tuple[int, int]]) -> bool: def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in adjacency_list[node]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False adjacency_list = {i: [] for i in range(num_nodes)} for (u, v) in edges: adjacency_list[u].append(v) visited = [False] * num_nodes rec_stack = [False] * num_nodes for node in range(num_nodes): if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Problem Statement Write a function called `longest_word` that finds the longest word in a given list of strings. If there are multiple words with the maximum length, return the first one encountered. You need to adhere to the following requirements: 1. **Input**: - A list of strings. Each string is guaranteed to contain only alphabetic characters and is non-empty. - The list itself is non-empty. 2. **Output**: - A single string which is the longest word in the list. 3. **Constraints**: - The function should have a time complexity of O(n), where n is the number of words in the list times the length of the longest word. - If the list is empty or if any of the strings are non-alphabetic or empty, raise a `ValueError` with the message \\"Invalid input\\". # Function Signature: ```python def longest_word(words: list) -> str: pass ``` # Examples: ```python >>> longest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) \\"banana\\" >>> longest_word([\\"dog\\", \\"elephant\\", \\"frog\\", \\"hippopotamus\\"]) \\"hippopotamus\\" >>> longest_word([\\"ant\\", \\"bee\\", \\"cat\\", \\"dog\\", \\"eel\\"]) \\"cat\\" >>> longest_word([\\"\\"]) Traceback (most recent call last): ... ValueError: Invalid input >>> longest_word([\\"apple123\\", \\"pear\\"]) Traceback (most recent call last): ... ValueError: Invalid input ``` # Additional Notes: - Ensure your solution efficiently handles the search for the longest word. - Pay attention to edge cases, such as strings containing non-alphabetic characters or empty strings. - You may assume the input list itself is non-empty and contains at least one valid word if not explicitly stated otherwise.","solution":"def longest_word(words: list) -> str: Returns the longest word in the list. If multiple words have the longest length, the first one encountered is returned. if not words: raise ValueError(\\"Invalid input\\") # Check each word for alphabetic characters only and non-empty strings for word in words: if not word.isalpha(): raise ValueError(\\"Invalid input\\") # Initialize the longest word tracking longest = words[0] # Find the longest word for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"# Coding Assessment Question: Scenario: You are required to implement a function that determines if a given string can be rearranged to form a palindrome. This function will be useful in assessing the potential for a string to be arranged in a symmetrical sequence. Function Specification: Write a function `can_form_palindrome(input_string: str) -> bool` that checks if the given string can be rearranged into a palindrome. Input: * `input_string`: a string consisting of lowercase letters. Output: * Returns `True` if the input string can be rearranged to form a palindrome, otherwise returns `False`. Constraints: * Raise a `ValueError` if `input_string` contains non-lowercase alphabetic characters. Performance Requirements: * The implementation should aim for linear time complexity, ideally O(n), where n is the length of the input string. Examples: ```python >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"AaBbCc\\") Traceback (most recent call last): ... ValueError: Input must contain only lowercase alphabetic characters >>> can_form_palindrome(\\"a1b2\\") Traceback (most recent call last): ... ValueError: Input must contain only lowercase alphabetic characters ``` Ensure that your function correctly identifies strings that can be rearranged into palindromes, handles edge cases appropriately, and validates the input string to contain only lowercase alphabetic characters.","solution":"def can_form_palindrome(input_string: str) -> bool: Determines if the given string can be rearranged into a palindrome. Args: input_string (str): The input string consisting of lowercase letters. Returns: bool: True if the input string can be rearranged to form a palindrome, otherwise False. Raises: ValueError: If the input_string contains non-lowercase alphabetic characters. if not all(\'a\' <= c <= \'z\' for c in input_string): raise ValueError(\\"Input must contain only lowercase alphabetic characters\\") from collections import Counter # Count the frequency of each character char_count = Counter(input_string) # Check the number of characters with odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # It\'s possible to form a palindrome if there\'s at most one character with an odd count return odd_count <= 1"},{"question":"# Task: Implement a Recursive Fibonacci Function with Memoization Problem Statement You are required to write a function that calculates the N-th Fibonacci number using recursion. To optimize the performance, implement memoization to avoid redundant calculations. Function Signature ```python def fibonacci(n: int, memo: dict[int, int] = None) -> int: pass ``` Input - `n` (int): An integer representing the position in the Fibonacci sequence. Output - An integer representing the N-th Fibonacci number. Constraints 1. `0 <= n <= 50` 2. If `n` is supplied as a negative number, raise a `ValueError` with the message \\"Input must be a non-negative integer.\\" Example ```python >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(-5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer ``` Requirements - Implement the function using recursion. - Use a memoization technique to store previously computed Fibonacci numbers. - Ensure the function handles edge cases such as `n = 0` or `n = 1` efficiently. - Raise appropriate error messages for invalid inputs. # Question Explanation The goal of this task is to evaluate the candidate\'s ability to: - Implement recursive functions. - Use memoization for optimization. - Handle input validation and error cases.","solution":"def fibonacci(n: int, memo: dict[int, int] = None) -> int: if memo is None: memo = {} if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n in memo: return memo[n] if n == 0: return 0 elif n == 1: return 1 else: memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo) return memo[n]"},{"question":"# Coding Assessment Question Write a function `check_palindromic_permutation(s: str) -> bool` that checks if any permutation of the characters in the input string is a palindrome. # Input - `s` (string): A string consisting of lower-case alphabetic characters. (1 ≤ len(s) ≤ 100,000) # Output - Return a boolean `True` if any permutation of the string can form a palindrome, otherwise return `False`. # Constraints: - Ensure the solution is efficient and can handle the upper limits of input size. - The computation should be optimized to run in linear time with respect to the length of the string. # Example: ```python def check_palindromic_permutation(s: str) -> bool: from collections import Counter count = Counter(s) odd_count = sum(1 for val in count.values() if val % 2 != 0) return odd_count <= 1 print(check_palindromic_permutation(\\"civic\\")) # Output: True print(check_palindromic_permutation(\\"ivicc\\")) # Output: True print(check_palindromic_permutation(\\"hello\\")) # Output: False print(check_palindromic_permutation(\\"aabbcc\\")) # Output: True ``` # Explanation: - A string can form a palindrome if at most one character occurs an odd number of times. - The function leverages a dictionary (or `Counter` from collections) to count the frequency of each character. - By verifying the count of characters that appear an odd number of times, the function determines whether a palindromic permutation is possible.","solution":"def check_palindromic_permutation(s: str) -> bool: from collections import Counter count = Counter(s) odd_count = sum(1 for val in count.values() if val % 2 != 0) return odd_count <= 1"},{"question":"# Task You are tasked with designing a function that normalizes a given dictionary based on the descriptions provided below. # Function Signature ```python def normalize_dict(data: dict) -> dict: ``` # Input * **data** (dict): A dictionary where the keys are strings and the values are either integers, floats, strings that represent valid numbers, or nested dictionaries following the same structure. # Output * Returns a dictionary where all values are normalized. - Integers and floats remain unchanged. - Numeric strings are converted to their appropriate numeric type. - Nested dictionaries are recursively normalized. # Constraints 1. The input dictionary may contain nested dictionaries up to an arbitrary depth. 2. The function should handle the cases where the values are a mix of numeric strings, integers, floats, and nested dictionaries. # Examples ```python assert normalize_dict({\\"a\\": 1, \\"b\\": \\"2\\", \\"c\\": {\\"d\\": \\"3.5\\", \\"e\\": \\"4\\"}}) == {\\"a\\": 1, \\"b\\": 2, \\"c\\": {\\"d\\": 3.5, \\"e\\": 4}} assert normalize_dict({\\"key1\\": \\"7\\", \\"key2\\": {\\"nestedKey1\\": \\"8.0\\", \\"nestedKey2\\": -5}}) == {\\"key1\\": 7, \\"key2\\": {\\"nestedKey1\\": 8.0, \\"nestedKey2\\": -5}} assert normalize_dict({\\"x\\": {\\"y\\": {\\"z\\": \\"100\\"}}}) == {\\"x\\": {\\"y\\": {\\"z\\": 100}}} assert normalize_dict({\\"value\\": \\"not a number\\"}) == {\\"value\\": \\"not a number\\"} ``` # Explanation Create a function named `normalize_dict` that: 1. Iterates over the keys and values of the input dictionary. 2. Converts values that are numeric strings to their corresponding integer or float type. 3. Recursively normalizes nested dictionaries. 4. Leaves values that are neither strings nor nested dictionaries unchanged. Non-numeric strings should remain as strings. The function should handle various levels of nested dictionaries and convert only the numeric strings. Non-numeric values should remain as they are.","solution":"def normalize_value(value): Normalizes a single value. Converts numeric strings to int or float. if isinstance(value, str): try: if \'.\' in value: return float(value) else: return int(value) except ValueError: return value return value def normalize_dict(data: dict) -> dict: Recursively normalizes a dictionary, converting numeric strings to appropriate numeric types. normalized_data = {} for key, value in data.items(): if isinstance(value, dict): normalized_data[key] = normalize_dict(value) else: normalized_data[key] = normalize_value(value) return normalized_data"},{"question":"# String Compression: Run-Length Encoding Implement a function `run_length_encoding(s: str) -> str` that takes a string `s` and returns a new string representing the run-length encoding of `s`. The run-length encoding of a string is generated by replacing sequences of the same character with that character followed by the count of repetitions. Inputs: * `s`: A non-empty string where 1 ≤ len(s) ≤ 100,000. Outputs: * A string representing the run-length encoded form of `s`. Constraints: * The input string will contain only lowercase English letters (a-z). Example Usage: ```python assert run_length_encoding(\\"aaabbcccc\\") == \\"a3b2c4\\" assert run_length_encoding(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert run_length_encoding(\\"abcd\\") == \\"a1b1c1d1\\" assert run_length_encoding(\\"zzzzzz\\") == \\"z6\\" ``` # Requirements: * Your algorithm should efficiently process the input string with a time complexity of (O(n)). * Make sure the implementation handles both short and very long input strings within the allowed constraint limits. # Task: 1. Implement the `run_length_encoding` function following the specified guidelines. 2. Ensure to cover edge cases and verify your solution using multiple test scenarios.","solution":"def run_length_encoding(s: str) -> str: Returns the run-length encoded string of input string s. if not s: return \\"\\" encoded_str = [] current_char = s[0] count = 1 for i in range(1, len(s)): if s[i] == current_char: count += 1 else: encoded_str.append(current_char + str(count)) current_char = s[i] count = 1 # Add the last character group encoded_str.append(current_char + str(count)) return \'\'.join(encoded_str)"},{"question":"# Coding Problem You are tasked with implementing a `WordBreakSolver` class to determine if a given string can be segmented into a space-separated sequence of one or more dictionary words. The dictionary of words will be provided as input to the class methods. Specifications 1. **Class Structure**: Implement the `WordBreakSolver` class with the following methods: - `__init__(self, wordDict: List[str]) -> None` - `setDictionary(self, wordDict: List[str]) -> None` - `canBreak(self, s: str) -> bool` 2. **Functionality**: - `__init__(self, wordDict: List[str])`: Initializes the solver with a given dictionary of words. - `setDictionary(self, wordDict: List[str]) -> None`: Sets or updates the dictionary of words. - `canBreak(self, s: str) -> bool`: Determines if the input string `s` can be segmented into one or more dictionary words. Returns `True` if possible; otherwise, returns `False`. 3. **Constraints**: - The length of the string `s` will be in the range `[1, 300]`. - The length of the word dictionary will be in the range `[1, 1000]`. - Each word in the dictionary will have a length in the range `[1, 20]`. - All characters in the input string `s` and the dictionary are lowercase English letters. 4. **Performance Requirements**: - The `canBreak` method should have a time complexity of O(n^2), where `n` is the length of the string `s`. Example Usage ```python wordDict = [\\"leetcode\\", \\"leet\\", \\"code\\"] solver = WordBreakSolver(wordDict) assert solver.canBreak(\\"leetcode\\") == True assert solver.canBreak(\\"leetco\\") == False solver.setDictionary([\\"apple\\", \\"pen\\"]) assert solver.canBreak(\\"applepenapple\\") == True solver.setDictionary([\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) assert solver.canBreak(\\"catsandog\\") == False ``` Notes * You may import and use any standard Python modules if necessary. * Ensure that your solution handles edge cases such as empty strings or dictionaries while adhering to constraints.","solution":"from typing import List class WordBreakSolver: def __init__(self, wordDict: List[str]) -> None: self.wordDict = set(wordDict) # Using a set for O(1) look-ups def setDictionary(self, wordDict: List[str]) -> None: self.wordDict = set(wordDict) def canBreak(self, s: str) -> bool: n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in self.wordDict: dp[i] = True break return dp[n]"},{"question":"# Context You are developing a web server that processes a large number of requests. One of the requirements is to track the number of unique users that access the server daily. A unique user is identified by a unique user ID. # Task Implement a Python function that, given a list of user IDs (strings) representing requests to the server, returns the count of unique users. Your function should efficiently handle the input, ensuring fast identification of unique IDs for large datasets. # Requirements - Function Name: `count_unique_users` - **Input**: A list of strings where each string represents a user ID. - **Output**: An integer representing the number of unique user IDs. - **Constraints**: - The number of user IDs in the list can be up to 10^6. - Each user ID is a non-empty string composed of alphanumeric characters. # Example ```python # Example usage user_ids = [\'user1\', \'user2\', \'user3\', \'user1\', \'user2\'] print(count_unique_users(user_ids)) # Output should be: 3 user_ids = [\'alpha\', \'beta\', \'gamma\', \'beta\', \'alpha\'] print(count_unique_users(user_ids)) # Output should be: 3 user_ids = [\'id_123\', \'id_234\', \'id_345\', \'id_123\'] print(count_unique_users(user_ids)) # Output should be: 3 ``` # Notes: - Make sure to handle cases such as an empty list gracefully, returning 0 in such scenarios. - Consider the efficiency of your solution for large lists, aiming for O(n) time complexity if possible. **Implement the Function Below:** ```python def count_unique_users(user_ids): # your code here ```","solution":"def count_unique_users(user_ids): Returns the count of unique user IDs in the input list. unique_users = set(user_ids) return len(unique_users)"},{"question":"# Question: You are tasked with implementing a simplified version of a scheduler that schedules tasks based on priority. Each task must have a priority and a list of dependent tasks that must be completed before it can be executed. You will use topological sorting to determine the order in which tasks should be executed, ensuring that dependencies are respected. Requirements: 1. Implement the class `Task` to represent a task with a priority and a list of dependent tasks. 2. Implement the function `schedule_tasks` to return the task execution order using topological sorting. 3. Use a priority queue to ensure that tasks with higher priorities are executed first when multiple tasks are available to be scheduled. Input: - `tasks`: list of `Task` objects (each task has a unique `name`, an `int` priority, and a list of dependent tasks as `names`) - Each `Task` class should have the following structure: ```python class Task: def __init__(self, name: str, priority: int, dependencies: list): self.name = name self.priority = priority self.dependencies = dependencies ``` Output: - List of strings (names of the tasks ordered by their execution schedule) # Constraints: - 1 <= `len(tasks)` <= 10^5 - Task names are unique strings - Task priorities are integers, where a higher value means higher priority - Task dependencies form a directed acyclic graph (DAG) # Example: ```python tasks = [ Task(\'a\', 3, []), Task(\'b\', 1, [\'a\']), Task(\'c\', 2, [\'a\']), Task(\'d\', 4, [\'b\', \'c\']) ] assert schedule_tasks(tasks) == [\'a\', \'c\', \'b\', \'d\'] tasks = [ Task(\'task1\', 5, []), Task(\'task2\', 6, [\'task1\']), Task(\'task3\', 4, []), Task(\'task4\', 3, [\'task3\', \'task2\']) ] assert schedule_tasks(tasks) == [\'task2\', \'task1\', \'task4\', \'task3\'] ``` # Notes: - The function should handle cases where there are no tasks appropriately by returning an empty list. - If there are multiple tasks with no dependencies, the task with the highest priority should be executed first. - The solution should efficiently manage the scheduling using topological sorting and prioritization. # Implementation: Implement the `Task` class and `schedule_tasks` function in Python, ensuring that dependencies and priorities are handled correctly.","solution":"from heapq import heappush, heappop from collections import defaultdict, deque class Task: def __init__(self, name: str, priority: int, dependencies: list): self.name = name self.priority = priority self.dependencies = dependencies def schedule_tasks(tasks): # Create a graph and indegree counter graph = defaultdict(list) indegree = defaultdict(int) task_dict = {} for task in tasks: task_dict[task.name] = task indegree[task.name] = 0 # Initialize indegree for all tasks # Build the graph and compute the indegrees for task in tasks: for dep in task.dependencies: graph[dep].append(task.name) indegree[task.name] += 1 # Use a min-heap with inverted priorities to get the highest priority task first min_heap = [] for task in tasks: if indegree[task.name] == 0: heappush(min_heap, (-task.priority, task.name)) # Result list to store the ordered tasks result = [] while min_heap: current_priority, current_name = heappop(min_heap) result.append(current_name) for neighbor in graph[current_name]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: heappush(min_heap, (-task_dict[neighbor].priority, neighbor)) return result"},{"question":"# Coding Question Objective Write a Python function to find the k-th smallest element in a row-wise and column-wise sorted 2D matrix. # Function Signature ```python def kth_smallest(matrix: [[int]], k: int) -> int: Returns the k-th smallest element in a sorted 2D matrix. ``` # Input * A 2D list `matrix` where each row and column is sorted in ascending order. * An integer `k` representing the position of the smallest element to find (1-indexed). # Output * Return the k-th smallest element in the given matrix. # Constraints * `1 <= len(matrix) <= 200` * `1 <= len(matrix[0]) <= 200` * `-10000 <= matrix[i][j] <= 10000` * `1 <= k <= len(matrix) * len(matrix[0])` # Examples ```python print(kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8)) # 13 print(kth_smallest([[1, 2], [1, 3]], 2)) # 1 print(kth_smallest([[1, 2], [3, 4]], 3)) # 3 print(kth_smallest([[5]], 1)) # 5 ``` Requirements - Implement the function considering all edge case scenarios discussed. - Make sure your algorithm is efficient, aiming for O(n * log(max_element - min_element)) or better. - Include a main block to read input matrix and k-value, then print the k-th smallest element.","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in a row-wise and column-wise sorted 2D matrix. Parameters: matrix (list of list of int): The sorted matrix. k (int): The position of the smallest element to find (1-indexed). Returns: int: The k-th smallest element in the matrix. # Flatten the matrix into a list of tuples (value, row, column) min_heap = [(matrix[row][0], row, 0) for row in range(len(matrix))] heapq.heapify(min_heap) # Extract-min k-1 times for _ in range(k - 1): val, r, c = heapq.heappop(min_heap) if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"# Problem Statement Implement a class `ListProcessor` that provides utility functions to process and manipulate lists of integers. The class should include the following methods: 1. `remove_duplicates(self, lst: List[int]) -> List[int]` 2. `merge_sorted_lists(self, lst1: List[int], lst2: List[int]) -> List[int]` 3. `find_kth_largest(self, lst: List[int], k: int) -> int` # Class and Method Specifications 1. remove_duplicates(self, lst: List[int]) -> List[int] * Removes all duplicate elements from a given list while maintaining the original order. * **Input**: A list of integers. * **Output**: A list of integers with duplicates removed. Example: ```python >>> processor = ListProcessor() >>> processor.remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] ``` 2. merge_sorted_lists(self, lst1: List[int], lst2: List[int]) -> List[int] * Merges two sorted lists into one sorted list. * **Input**: Two lists of integers, each sorted in non-decreasing order. * **Output**: A single list of integers sorted in non-decreasing order. Example: ```python >>> processor = ListProcessor() >>> processor.merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] ``` 3. find_kth_largest(self, lst: List[int], k: int) -> int * Finds the k-th largest element in a list. * **Input**: - A list of integers. - An integer `k` where 1 ≤ k ≤ len(lst). * **Output**: The k-th largest element in the list. Example: ```python >>> processor = ListProcessor() >>> processor.find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 ``` # Constraints * All provided lists are non-empty. * Element values in the lists are between `-10^9` and `10^9`. * The value of k is a valid integer within the range of the list length.","solution":"from typing import List class ListProcessor: def remove_duplicates(self, lst: List[int]) -> List[int]: Removes all duplicate elements from a given list while maintaining the original order. Parameters: lst (List[int]): A list of integers. Returns: List[int]: A list of integers with duplicates removed. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result def merge_sorted_lists(self, lst1: List[int], lst2: List[int]) -> List[int]: Merges two sorted lists into one sorted list. Parameters: lst1 (List[int]): A sorted list of integers. lst2 (List[int]): Another sorted list of integers. Returns: List[int]: A single sorted list of integers. merged_list = [] i, j = 0, 0 while i < len(lst1) and j < len(lst2): if lst1[i] < lst2[j]: merged_list.append(lst1[i]) i += 1 else: merged_list.append(lst2[j]) j += 1 while i < len(lst1): merged_list.append(lst1[i]) i += 1 while j < len(lst2): merged_list.append(lst2[j]) j += 1 return merged_list def find_kth_largest(self, lst: List[int], k: int) -> int: Finds the k-th largest element in a list. Parameters: lst (List[int]): A list of integers. k (int): The k-th largest element to find, where 1 ≤ k ≤ len(lst). Returns: int: The k-th largest element in the list. return sorted(lst, reverse=True)[k-1]"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase letters and an integer `k`. You need to determine if you can form a palindrome by rearranging the string `s` exactly `k` times. Each rearrangement allows you to move each character to a different position, but you cannot change the characters themselves. # Function Signature ```python def can_form_palindrome(s: str, k: int) -> bool: pass ``` # Input * A string `s` consisting of lowercase letters (1 <= len(s) <= 1000): The string to evaluate. * An integer `k` (0 <= k <= 1000): The exact number of rearrangements allowed. # Output * A boolean: True if it is possible to form a palindrome by rearranging the string exactly `k` times, otherwise False. # Example ```python >>> can_form_palindrome(\\"aabb\\", 1) True >>> can_form_palindrome(\\"abcd\\", 0) False >>> can_form_palindrome(\\"aabbcc\\", 3) True ``` # Constraints - If rearranging `s` exactly `k` times allows it to form a palindrome, return True. Otherwise, return False. # Note - A palindrome reads the same forward and backward. - The function should determine the necessary conditions for a rearranged string to be a palindrome and check if `k` operations allow achieving this arrangement.","solution":"def can_form_palindrome(s: str, k: int) -> bool: from collections import Counter # Counter to count occurrences of each character char_counts = Counter(s) # Count the number of characters that have an odd count odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # Minimum rearrangements to form a palindrome is zero if odd_count <= 1 # Minimum rearrangements to form a palindrome is odd_count // 2 otherwise min_rearrangements = max(0, odd_count // 2) # We need exactly k rearrangements return k >= min_rearrangements"},{"question":"Question: Sliding Window Maximum # Context You are developing an analytics tool for real-time streaming data. A common task is to find the maximum value in a sliding window of fixed size that moves from the beginning to the end of a given list of numbers. # Task Write a function `sliding_window_maximum(nums, k)` that takes an array of integers and an integer k, and returns a list of the maximum values in each sliding window of size k. # Implementation Details Function Signature ```python def sliding_window_maximum(nums: list[int], k: int) -> list[int]: pass ``` Input * `nums`: A list of integers representing the input data stream. * The length of the list will be between 1 and 1,000,000. * `k`: An integer representing the size of the sliding window. * The value of `k` will be between 1 and the length of `nums`. Output * A list of integers, where each element is the maximum value in the corresponding sliding window. Constraints * The solution should have a time complexity of O(n), where n is the length of the input list. * This requires using a data structure like a deque to maintain the window of maximum values. # Example Input ```python nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 ``` Output ```python [3, 3, 5, 5, 6, 7] ``` Explanation 1. The sliding window `[1, 3, -1]` has a maximum of `3`. 2. The sliding window `[3, -1, -3]` has a maximum of `3`. 3. The sliding window `[-1, -3, 5]` has a maximum of `5`. 4. The sliding window `[-3, 5, 3]` has a maximum of `5`. 5. The sliding window `[5, 3, 6]` has a maximum of `6`. 6. The sliding window `[3, 6, 7]` has a maximum of `7`. # Note * Ensure your solution efficiently maintains the maximum value as the window slides. * Think about how you will remove elements that are no longer in the window and add new elements. * Consider edge cases like when `nums` contains identical elements or when `k` equals the length of `nums`.","solution":"from collections import deque def sliding_window_maximum(nums: list[int], k: int) -> list[int]: if not nums: return [] deq = deque() result = [] for i in range(len(nums)): # Remove elements not within the sliding window while deq and deq[0] < i - k + 1: deq.popleft() # Remove elements from the deque smaller than the current element while deq and nums[deq[-1]] < nums[i]: deq.pop() # Add current element at the end of the deque deq.append(i) # The first element in the deque is the maximum of the current window if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"# Problem Create a function that simulates a simplified version of the \\"flatten\\" process on a nested list of integers. The goal is to convert a potentially nested list into a flat list containing all the integers in the same order they appear in the original nested structure. # Function Signature ```python def flatten_list(nested_list: list) -> list[int]: ... ``` # Input * `nested_list`: A nested list of integers where the level of nesting can go up to 5. Each sublist or element within `nested_list` will either be an integer or another list of integers. # Output * Returns a flat list of integers in the order they appear in the original nested structure. # Constraints 1. You should handle nesting levels up to 5. 2. The function should be efficient in terms of both time and space complexity given the level constraint. 3. The input list can be empty or contain only nested empty lists. 4. The function should be able to handle cases with duplicated integers, non-uniform nesting, and should preserve the order of elements. # Example ```python assert flatten_list([1, [2, [3, 4, [5]], 6], 7]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_list([[[1], 2], 3, [4, [5, 6]]]) == [1, 2, 3, 4, 5, 6] assert flatten_list([]) == [] assert flatten_list([[], [[], []], [[[], [42]]]]) == [42] assert flatten_list([[[[[[]]]]]]) == [] ``` # Detailed Explanation 1. **Initialization**: Begin with an empty list to hold the result. 2. **Recursive Flattening**: Write a helper function that recursively navigates through elements/lists in the input `nested_list`. 3. **Depth Handling**: The recursive function should effectively handle up to 5 levels of nesting. 4. **Appending Values**: Whenever an integer is encountered, add it to the result list. When a list is encountered, recursively process its elements.","solution":"def flatten_list(nested_list: list) -> list[int]: Flattens a nested list of integers into a single list of integers. flat_list = [] def flatten(sublist): for item in sublist: if isinstance(item, list): flatten(item) else: flat_list.append(item) flatten(nested_list) return flat_list"},{"question":"# Breadth-First Search (BFS) Traversal Given a connected and undirected graph, implement the Breadth-First Search (BFS) algorithm to traverse the graph starting from a given start node. Write a function `bfs_traversal(num_nodes: int, edges: list[tuple[int, int]], start_node: int) -> list[int]` that returns the order in which the nodes are visited. Function Signature ```python def bfs_traversal(num_nodes: int, edges: list[tuple[int, int]], start_node: int) -> list[int]: ``` # Input - `num_nodes`: An integer `V` (2 ≤ V ≤ 10^5) representing the number of nodes in the graph. - `edges`: A list of tuples `(u, v)` `(0 ≤ u < v < V)` representing the edges of the graph, where `u` and `v` are nodes connected by an edge. - `start_node`: An integer `start_node` (0 ≤ start_node < V) representing the starting node for the BFS traversal. # Output - Return a list of integers representing the order in which the nodes are visited in the BFS traversal. # Constraints - The graph is guaranteed to be connected. - There will be no self-loops (edges from a node to itself). - All nodes are reachable from the start node. # Example ```python # Example 1 num_nodes = 4 edges = [(0, 1), (1, 2), (2, 3), (0, 2)] start_node = 0 result = bfs_traversal(num_nodes, edges, start_node) assert result == [0, 1, 2, 3] or result == [0, 2, 1, 3] # Example 2 num_nodes = 3 edges = [(0, 1), (1, 2)] start_node = 0 result = bfs_traversal(num_nodes, edges, start_node) assert result == [0, 1, 2] ``` # Performance Requirements - The solution should be efficient and handle graphs with up to 10^5 nodes and 10^5 edges.","solution":"from collections import deque, defaultdict def bfs_traversal(num_nodes, edges, start_node): Perform BFS traversal on the graph. Parameters: num_nodes (int): Number of nodes in the graph. edges (list[tuple[int, int]]): List of edges in the graph. start_node (int): Starting node for the BFS traversal. Returns: list[int]: List of nodes in the order they were visited. # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Initialize BFS visited = [False] * num_nodes queue = deque([start_node]) visited[start_node] = True bfs_order = [] while queue: node = queue.popleft() bfs_order.append(node) for neighbor in adj_list[node]: if not visited[neighbor]: queue.append(neighbor) visited[neighbor] = True return bfs_order"},{"question":"# Binary Search Tree Height Calculation and Elements Count Context You are given the task to develop and use a `BinarySearchTree` class to perform some fundamental operations. This question aims to test your understanding of binary search tree construction and basic manipulations. Problem Statement 1. **Height Calculation**: Implement a method `get_height(self) -> int` that calculates the height of the binary search tree. * **Input**: None. * **Output**: Return an integer representing the height of the tree. An empty tree\'s height is defined as -1. 2. **Element Count**: Implement a method `count_elements(self) -> int` that counts the total number of elements (nodes) in the binary search tree. * **Input**: None. * **Output**: Return an integer representing the total number of elements in the tree. # Implementation Details * Implement the following two methods inside the `BinarySearchTree` class provided: ```python class BinarySearchTreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key: int): Inserts a new node with the specified key into the BST. if self.root is None: self.root = BinarySearchTreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, root, key): if root is None: return BinarySearchTreeNode(key) if key < root.val: root.left = self._insert_recursive(root.left, key) else: root.right = self._insert_recursive(root.right, key) return root def get_height(self) -> int: # Your implementation here def count_elements(self) -> int: # Your implementation here ``` # Example Usage ```python bst = BinarySearchTree() values = [10, 5, 20, 3, 7, 15, 30] for value in values: bst.insert(value) print(bst.get_height()) # Should print: 2 (root level 0, child level 1, grandchild level 2) print(bst.count_elements()) # Should print: 7 (total number of nodes) ``` * **Constraints**: - Tree node values will be integers. - You can assume that no duplicate values will be inserted into the tree. * **Submission Requirements**: - The `get_height` method should return the height of the tree as an integer. - The `count_elements` method should return the total count of nodes as an integer. Explain your approach after implementing the above methods briefly.","solution":"class BinarySearchTreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key: int): Inserts a new node with the specified key into the BST. if self.root is None: self.root = BinarySearchTreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, root, key): if root is None: return BinarySearchTreeNode(key) if key < root.val: root.left = self._insert_recursive(root.left, key) else: root.right = self._insert_recursive(root.right, key) return root def get_height(self) -> int: Calculates the height of the binary search tree. def _height(node): if node is None: return -1 left_height = _height(node.left) right_height = _height(node.right) return 1 + max(left_height, right_height) return _height(self.root) def count_elements(self) -> int: Counts the total number of elements (nodes) in the binary search tree. def _count(node): if node is None: return 0 return 1 + _count(node.left) + _count(node.right) return _count(self.root) # Brief Explanation: # - The get_height function uses a recursive approach to find the height of the tree. The height of a node is defined as 1 plus the maximum height of its left and right children. If the node is None, it returns -1 (base case for empty subtrees). # - The count_elements function also uses a recursive approach to count the total nodes in the tree. It sums up 1 for the current node and calls itself recursively for both left and right children. If the node is None, it returns 0 (base case for empty subtrees)."},{"question":"# Data Cleaning and Filtering on CSV File You are given a CSV file containing information about various products in a store. Your task is to write a function to clean and filter the data based on specific criteria and generate an output file with the cleaned data. Problem Statement Implement the function `clean_and_filter_products(input_file_path: str, output_file_path: str) -> None` which will: 1. Read the input CSV file given by `input_file_path`. 2. Remove any rows that have missing values in the columns `\'product_name\'`, `\'category\'`, or `\'price\'`. 3. Filter out products that belong to the categories `\'out-of-stock\'` or `\'discontinued\'`. 4. Ensure that the remaining products are sorted in ascending order based on their `\'price\'`. 5. Write the cleaned and filtered data to the new CSV file specified by `output_file_path`. Input and Output Formats * **Input**: * `input_file_path` (string): A string representing the path to the input CSV file. * `output_file_path` (string): A string representing the path to the output CSV file. * **Output**: * None. The function should write the cleaned and filtered data to `output_file_path`. Constraints: * The CSV file can have a varying number of columns, but the required columns (`product_name`, `category`, `price`) will always be present. * The \'price\' column will contain only numeric values (integers or floats). * The function should handle large files efficiently. Example Suppose the input CSV file contains the following data: | product_name | category | price | description | |--------------|-------------|-------|-----------------------| | Widget A | available | 10.99 | A basic widget. | | Widget B | out-of-stock| 8.99 | This widget is out. | | Gadget C | discontinued| 12.99 | No longer available. | | Widget D | available | 9.99 | Slightly better widget| The cleaned and filtered CSV file should contain: | product_name | category | price | description | |--------------|-----------|-------|---------------------| | Widget D | available | 9.99 | Slightly better widget| | Widget A | available | 10.99 | A basic widget. | ```python # Example usage clean_and_filter_products(\'input_products.csv\', \'output_products.csv\') ```","solution":"import pandas as pd def clean_and_filter_products(input_file_path: str, output_file_path: str) -> None: # Read the CSV file df = pd.read_csv(input_file_path) # Remove rows with NaNs in \'product_name\', \'category\', or \'price\' df = df.dropna(subset=[\'product_name\', \'category\', \'price\']) # Filter out products in \'out-of-stock\' or \'discontinued\' categories df = df[~df[\'category\'].isin([\'out-of-stock\', \'discontinued\'])] # Sort by \'price\' in ascending order df = df.sort_values(by=\'price\') # Write the cleaned and filtered data to the output CSV file df.to_csv(output_file_path, index=False)"},{"question":"Book Arrangement You are managing a digital library system where books are arranged on a shelf. Each book has a unique identifier, and you need to ensure that the books are arranged in the correct order according to their ID numbers. Write a function `reorder_books(book_ids: List[int]) -> List[int]` that reorders the given list of book IDs in non-decreasing order. # Input - `book_ids` (1 ≤ len(book_ids) ≤ 10^5) - a list of integers representing the book IDs. Each book ID is a positive integer within the range [1, 10^9]. # Output - The function should return a list of book IDs sorted in non-decreasing order. # Examples ```python >>> reorder_books([3, 1, 4, 1, 5, 9, 2, 6, 5]) [1, 1, 2, 3, 4, 5, 5, 6, 9] >>> reorder_books([10, 20, 3, 1]) [1, 3, 10, 20] >>> reorder_books([5]) [5] >>> reorder_books([]) [] ``` # Guidelines - Use an efficient sorting algorithm provided by your programming language\'s standard library to sort the list. - Aim for a time complexity of O(n log n) to handle the upper constraint efficiently. - Ensure the function handles both small and large lists effectively without running into performance issues.","solution":"from typing import List def reorder_books(book_ids: List[int]) -> List[int]: Returns the list of book IDs sorted in non-decreasing order. :param book_ids: List of integers representing book IDs. :return: List of integers sorted in non-decreasing order. return sorted(book_ids)"},{"question":"# Problem Statement You are tasked with creating a function that processes financial transaction logs for suspicious activities. Suspicious activities are defined as transactions where the amount exceeds 10,000. The function should take a list of transaction records, identify the suspicious ones, and log the information including the transaction ID and the associated message. # Function Signature ```python def log_suspicious_transactions(transactions: list[dict[str, any]]) -> list[str]: Given a list of transaction records, identify suspicious transactions and log their information. Parameters: transactions: A list of dictionaries where each dictionary represents a transaction record and contains the keys \'transaction_id\', \'amount\', and \'description\'. Returns: A list of strings, each containing the transaction ID and a message indicating the suspicious activity. pass ``` # Requirements 1. **Input**: A list of transaction records. Each transaction record is a dictionary that includes: - \'transaction_id\': A unique identifier for the transaction (string). - \'amount\': The amount of the transaction (float). - \'description\': A short description of the transaction (string). 2. **Output**: A list of strings, each containing the transaction ID and a message indicating if the transaction is suspicious. If a transaction is suspicious (i.e., the amount is over 10,000), the message should indicate this fact. 3. **Constraints**: - Each transaction record is assumed to be well-formed as described. - The function should handle an empty list of transactions gracefully. - Avoid using global variables. - Do not use any external logging libraries for this purpose. # Performance Requirements Your implementation should: 1. Process at least 1,000 transactions within a reasonable time frame (e.g., under 1 second). 2. Utilize efficient list and dictionary operations to minimize time complexity. # Example ```python transactions = [ {\'transaction_id\': \'TX123\', \'amount\': 5000.0, \'description\': \'Utility bill payment\'}, {\'transaction_id\': \'TX124\', \'amount\': 20000.0, \'description\': \'Car purchase\'}, {\'transaction_id\': \'TX125\', \'amount\': 300.0, \'description\': \'Grocery shopping\'} ] result = log_suspicious_transactions(transactions) # Example \'result\': # [\'Transaction ID: TX124, Message: Suspicious transaction detected (amount exceeds 10,000).\'] ``` # Evaluation Criteria 1. **Correctness**: Properly identify and log all suspicious transactions. 2. **Efficiency**: The function should return results promptly without excessive delay. 3. **Robustness**: Effectively handle edge cases such as empty lists and variations in the transaction record amounts.","solution":"def log_suspicious_transactions(transactions): Given a list of transaction records, identify suspicious transactions and log their information. Parameters: transactions: A list of dictionaries where each dictionary represents a transaction record and contains the keys \'transaction_id\', \'amount\', and \'description\'. Returns: A list of strings, each containing the transaction ID and a message indicating the suspicious activity. suspicious_logs = [] for transaction in transactions: if transaction[\'amount\'] > 10000.0: suspicious_logs.append( f\\"Transaction ID: {transaction[\'transaction_id\']}, Message: Suspicious transaction detected (amount exceeds 10,000).\\" ) return suspicious_logs"},{"question":"# String Anagram Detection Assessment Background You have been given the task to detect whether two given strings are anagrams of each other. An anagram of a string is another string that contains the same characters, only the order of characters can be different. Task Your task is to implement a function: 1. `are_anagrams(string1: str, string2: str) -> bool`: Determines if the two given strings are anagrams of each other. Details: - The `string1` and `string2` are strings that can include only alphabetic characters (both uppercase and lowercase). - The comparison should be case-insensitive, meaning \'A\' and \'a\' are considered the same. - Both input strings are guaranteed to be non-empty. Input - `string1`: A string containing the first string to compare. - `string2`: A string containing the second string to compare. Output - For `are_anagrams`: A boolean value that returns `True` if the strings are anagrams, otherwise `False`. Examples ```python assert are_anagrams(\'Listen\', \'Silent\') == True assert are_anagrams(\'Triangle\', \'Integral\') == True assert are_anagrams(\'Apple\', \'Pabble\') == False ``` Requirements - Determine if two strings are anagrams, ignoring case differences. - Implement the function to perform in linear time complexity, O(n), where n is the length of the strings. Constraints - The strings will contain only alphabetic characters. - Strings length: 1 ≤ length of string1, string2 ≤ 10^5","solution":"def are_anagrams(string1: str, string2: str) -> bool: Determines if two given strings are anagrams of each other. Parameters: string1 (str): The first string for comparison. string2 (str): The second string for comparison. Returns: bool: True if the strings are anagrams, False otherwise. from collections import Counter # Convert both strings to lower case for case-insensitive comparison string1 = string1.lower() string2 = string2.lower() # Initialize counters for both strings counter1 = Counter(string1) counter2 = Counter(string2) # Compare counters return counter1 == counter2"},{"question":"# Text Analysis for Sentiment Classification In this task, you are required to implement a basic sentiment analysis tool. The tool should classify text input into either \\"positive\\", \\"negative\\", or \\"neutral\\" based on the occurrence of keywords. **Task**: 1. Implement a function to perform sentiment analysis: - `def sentiment_analysis(text: str) -> str:` 2. The function should: - Determine the sentiment by counting the number of positive and negative keywords in the text. - Return: - \\"positive\\" if the number of positive keywords exceeds the number of negative keywords. - \\"negative\\" if the number of negative keywords exceeds the number of positive keywords. - \\"neutral\\" if both counts are equal or no keywords are found. 3. Handle potential edge cases (e.g., empty strings, mixed cases, punctuation). **Function Signature**: ```python def sentiment_analysis(text: str) -> str: # your implementation here ``` # Expected Input and Output: * **Input Format**: - `text`: A string containing the text to be analyzed. * **Output Format**: - A string representing the sentiment (\\"positive\\", \\"negative\\", \\"neutral\\"). # Keywords: - **Positive Keywords**: [\\"good\\", \\"happy\\", \\"joy\\", \\"excellent\\", \\"fortunate\\", \\"delightful\\", \\"positive\\"] - **Negative Keywords**: [\\"bad\\", \\"sad\\", \\"pain\\", \\"terrible\\", \\"unfortunate\\", \\"horrible\\", \\"negative\\"] # Example Usage: ```python assert sentiment_analysis(\\"I had a good and happy day.\\") == \\"positive\\" assert sentiment_analysis(\\"This terrible weather makes me feel sad.\\") == \\"negative\\" assert sentiment_analysis(\\"It\'s just an ordinary day.\\") == \\"neutral\\" assert sentiment_analysis(\\"\\") == \\"neutral\\" assert sentiment_analysis(\\"Good good bad bad\\") == \\"neutral\\" ``` # Notes: - Ensure the text analysis is case-insensitive. - Consider punctuation and special characters that may affect keyword matching. - Implement efficient methods for text processing and keyword search.","solution":"import re def sentiment_analysis(text: str) -> str: positive_keywords = [\\"good\\", \\"happy\\", \\"joy\\", \\"excellent\\", \\"fortunate\\", \\"delightful\\", \\"positive\\"] negative_keywords = [\\"bad\\", \\"sad\\", \\"pain\\", \\"terrible\\", \\"unfortunate\\", \\"horrible\\", \\"negative\\"] # Normalize the text by converting it to lowercase text = text.lower() # Remove punctuation text = re.sub(r\'[^ws]\', \'\', text) # Split the text into words words = text.split() # Count occurrences of positive and negative keywords positive_count = sum(word in positive_keywords for word in words) negative_count = sum(word in negative_keywords for word in words) # Determine the sentiment based on keyword counts if positive_count > negative_count: return \\"positive\\" elif negative_count > positive_count: return \\"negative\\" else: return \\"neutral\\""},{"question":"Problem Statement You are tasked with implementing a function that flattens a nested dictionary. A nested dictionary is a dictionary that can contain dictionaries as its values, and your function should produce a new dictionary where the keys are the dot-separated paths to the original keys. # Function Signature ```python def flatten_dict(d: dict, parent_key: str = \'\', sep: str = \'.\') -> dict: ``` # Input - `d`: A dictionary that may contain dictionaries as its values. - `parent_key` (optional): A string representing the prefix for the keys. Default is an empty string. - `sep` (optional): A string used to separate the keys. Default is a period (\'.\'). # Output - Returns a dictionary where the keys are the dot-separated paths to the original keys. # Constraints - The input dictionary will have at most 100 nested levels. - Keys in the dictionary are strings. - Values in the dictionary can be either other dictionaries or any primitive data type (integer, string, float, etc.). # Example ```python d = { \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": 2 }, \\"e\\": 3 }, \\"f\\": 4 } print(flatten_dict(d)) # Output: {\'a.b.c\': 1, \'a.b.d\': 2, \'a.e\': 3, \'f\': 4} d = { \\"key1\\": { \\"keyA\\": 1, \\"keyB\\": { \\"keyC\\": 2 } }, \\"key2\\": 3 } print(flatten_dict(d)) # Output: {\'key1.keyA\': 1, \'key1.keyB.keyC\': 2, \'key2\': 3} ``` # Note - The function `flatten_dict` should be able to handle dictionaries of arbitrary depth. - The dot-separators in the keys of the output dictionary represent the path taken to get to the original value in the nested structure.","solution":"def flatten_dict(d, parent_key=\'\', sep=\'.\'): Flattens a nested dictionary. Parameters: d (dict): The dictionary to flatten. parent_key (str): The prefix for the keys in the flattened dictionary. sep (str): The separator to use between keys. Returns: dict: A new dictionary with flattened keys. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"# Data Synchronization Service Implementation Scenario: You are developing a data synchronization service that ensures consistency across multiple nodes in a distributed system. The service should allow nodes to register themselves, report their current data state (as checksums), and request synchronization to the latest state from the master node. The master node maintains the authoritative state of the system. Requirements: 1. **Node Registration**: Implement a method for nodes to register with the master node. 2. **State Reporting**: Implement a method for nodes to report their checksums to the master node. 3. **Synchronization**: Implement a method for nodes to request and receive the latest data state if their checksum is outdated. Input & Output: * **Function Signatures**: ```python class DataSyncService: def __init__(self, master_state: str): # Initialize the service with the master node\'s current state pass def register_node(self, node_id: str) -> None: # Register a new node with the given ID pass def report_state(self, node_id: str, checksum: str) -> None: # Nodes report their current data state (checksum) pass def synchronize(self, node_id: str) -> str: # Nodes request synchronization, return the master state if out of sync pass ``` * **Constraints**: * `master_state` should be a string representing the authoritative data checksum. * Each `node_id` should be unique and a string identifier. * Checksums reported by nodes are also strings. * If a node\'s reported checksum matches the master\'s, no action is needed. * If a node\'s reported checksum differs from the master\'s, return the latest `master_state`. * **Error Messages**: * Raise `ValueError` with message \\"Node not registered\\" if a node attempts to report state or synchronize before registration. Example: ```python # Example usage: service = DataSyncService(master_state=\\"abc123\\") # Register nodes service.register_node(\\"node1\\") service.register_node(\\"node2\\") # Report states service.report_state(\\"node1\\", \\"abc123\\") service.report_state(\\"node2\\", \\"def456\\") # Synchronize nodes # Node 1 is up-to-date assert service.synchronize(\\"node1\\") == \\"abc123\\" # Node 2 needs synchronization assert service.synchronize(\\"node2\\") == \\"abc123\\" ``` Implementation Details: Provide your implementation for the `DataSyncService` class following the specifications and requirements provided.","solution":"class DataSyncService: def __init__(self, master_state: str): # Initialize the service with the master node\'s current state self.master_state = master_state self.nodes = {} def register_node(self, node_id: str) -> None: # Register a new node with the given ID self.nodes[node_id] = None def report_state(self, node_id: str, checksum: str) -> None: # Nodes report their current data state (checksum) if node_id not in self.nodes: raise ValueError(\\"Node not registered\\") self.nodes[node_id] = checksum def synchronize(self, node_id: str) -> str: # Nodes request synchronization, return the master state if out of sync if node_id not in self.nodes: raise ValueError(\\"Node not registered\\") if self.nodes[node_id] != self.master_state: return self.master_state return self.master_state"},{"question":"# String Permutation Check You are to implement a function that checks if one string is a permutation of another string. This will test your skills in string manipulation, sorting, and array handling. **Function Signature:** ```python def is_permutation(s1: str, s2: str) -> bool: ``` **Input:** - `s1`, `s2`: Two strings consisting of lower-case alphabetical letters. (Length: 0 <= len(s1), len(s2) <= 10^5) **Output:** - A boolean value indicating whether `s1` is a permutation of `s2`. **Constraints:** - You must handle both empty string cases efficiently. - Consider time complexity in your solution. **Performance Requirements:** - The function should ideally operate in O(n log n) time or better, where n is the length of the longest string. # Scenario Imagine you are developing a feature for a text processing application that checks for anagrams. This function will be a core utility to verify if two given strings are permutations of each other, which is a common requirement for many text-related functionalities. # Example ```python >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"abc\\", \\"abcd\\") False >>> is_permutation(\\"a\\", \\"a\\") True >>> is_permutation(\\"\\", \\"\\") True >>> is_permutation(\\"abcd\\", \\"dcba\\") True ``` **Note:** This task will evaluate your ability to deal with string comparisons and sorting algorithms, ensuring optimal performance for larger inputs.","solution":"def is_permutation(s1: str, s2: str) -> bool: Checks if one string is a permutation of another string. :param s1: First string :param s2: Second string :return: True if s1 is a permutation of s2, otherwise False # If lengths of the strings are not equal, they cannot be permutations if len(s1) != len(s2): return False # Sort both strings and compare the results return sorted(s1) == sorted(s2)"},{"question":"# Question You are tasked with implementing a function that performs string pattern matching using the Knuth-Morris-Pratt (KMP) algorithm. The function should return the starting index of the first occurrence of the pattern in the given text, or -1 if the pattern is not found. Function Signature ```python def kmp_search(pattern: str, text: str) -> int: pass ``` Input - `pattern`: A string representing the pattern to search for. - `text`: A string in which the pattern search is to be performed. Output - An integer representing the starting index of the first occurrence of the pattern in the text, or -1 if the pattern is not found. Constraints - The length of the pattern and text can vary from 1 to (10^5). - The text can include any character from the ASCII table. Examples - `kmp_search(\\"abc\\", \\"abcabcabc\\")` should return `0` - `kmp_search(\\"is\\", \\"This is a test\\")` should return `2` - `kmp_search(\\"aaa\\", \\"aaa\\")` should return `0` - `kmp_search(\\"abcd\\", \\"abc\\")` should return `-1` Additional Notes - You must implement the KMP algorithm which involves creating a partial match table (prefix table) to facilitate the search. - Ensure the function handles edge cases, such as an empty pattern or text gracefully. Performance Requirements - Your solution should run in O(n + m) time complexity, where n is the length of the text and m is the length of the pattern.","solution":"def kmp_search(pattern: str, text: str) -> int: Perform KMP search for the pattern in the given text and return the index of the first occurrence. If the pattern is not found, return -1. if not pattern: return 0 if text else -1 if not text: return -1 def compute_lps(pattern): length = 0 lps = [0] * len(pattern) i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) i = j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): return i - j elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Array Pair Sum Problem Context You are given an array of integers and a target integer. Your task is to find all unique pairs of integers within the array that sum up to the target integer. Task Implement a function `find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]`. The function should take a list of integers `arr` and an integer `target`, and return a list of tuples, where each tuple represents a unique pair of integers that add up to the target integer. Input and Output Formats * **Input**: A list of integers, `arr` (1 <= len(arr) <= 1000 and -10^9 <= arr[i] <= 10^9 for each integer arr[i]), and an integer `target` (-10^9 <= target <= 10^9). * **Output**: A list of tuples, each containing a unique pair of integers from `arr` that sum to `target`. Each pair should be in the form `(x, y)`, with `x <= y`. The list of tuples should be sorted in ascending order by the first element of the tuple, and within each tuple `(x, y)`, `x` should be less than or equal to `y`. Constraints * The length of the list will be at least 1 and at most 1000. * The integers in the list and the target can be both positive and negative. * Each pair `(x, y)` should be unique. Example ```python assert find_pairs_with_sum([1, 5, 7, -1, 5], 6) == [(1, 5), (-1, 7)] assert find_pairs_with_sum([5, -5, -10, 4, -3, 7, -5, 3], 0) == [(-5, 5), (-3, 3)] ``` # Performance Requirements * The solution should efficiently find all unique pairs even with the upper limit of the input size. * Aim for a time complexity better than O(n^2), ideally O(n log n) or O(n) with appropriate data structures. Notes * Ensure that pairs `(x, y)` and `(y, x)` are considered the same and only one should be included in the output. * Consider utilizing hashing or sorting techniques to identify and store the pairs efficiently.","solution":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(list(pairs))"},{"question":"# Coding Assessment Problem: You are tasked with designing a system that processes movie reviews. Each review consists of a comment and a rating. The rating is an integer between 1 and 5. Your task is to identify the movies with the highest average rating and list them. In case of ties (multiple movies having the same average rating), all should be included in the result. # Problem Statement **Objective**: Write a function `top_rated_movies(reviews: List[Tuple[str, int]]) -> List[str]` that returns a list of movies with the highest average rating. # Input and Output: * **Input**: * `reviews` - A list of tuples where each tuple represents a movie and its rating. The first element of the tuple is a string (the movie title), and the second element is an integer (the rating). * **Output**: * A list of strings representing the titles of the movies with the highest average rating. The list should be sorted in alphabetical order. # Constraints: * The length of the `reviews` list will not exceed (10^6). * All movie titles are case-sensitive (e.g., \\"Movie A\\" is distinct from \\"movie a\\"). * The list of reviews can be empty, in which case the function should return an empty list. # Example: ```python def test_top_rated_movies(): reviews = [ (\\"Movie A\\", 5), (\\"Movie B\\", 4), (\\"Movie A\\", 4), (\\"Movie B\\", 5), (\\"Movie C\\", 2) ] assert top_rated_movies(reviews) == [\\"Movie A\\", \\"Movie B\\"] reviews = [ (\\"Movie X\\", 4), (\\"Movie Y\\", 3), (\\"Movie X\\", 4), (\\"Movie Z\\", 4), (\\"Movie Y\\", 4) ] assert top_rated_movies(reviews) == [\\"Movie X\\", \\"Movie Y\\"] ``` # Requirements: 1. **Function Implementation**: Implement the required function with the provided signature. 2. **Optimal Calculation**: Ensure the calculations for the average rating and retrieval of movies with the highest average rating are performed efficiently. 3. **Edge Cases**: Handle cases where there are ties in average ratings or where there are no reviews. Happy coding!","solution":"from typing import List, Tuple def top_rated_movies(reviews: List[Tuple[str, int]]) -> List[str]: if not reviews: return [] movie_ratings = {} for movie, rating in reviews: if movie not in movie_ratings: movie_ratings[movie] = [0, 0] # [sum of ratings, number of ratings] movie_ratings[movie][0] += rating movie_ratings[movie][1] += 1 max_avg_rating = -1 top_movies = [] for movie, (total_rating, count) in movie_ratings.items(): average_rating = total_rating / count if average_rating > max_avg_rating: max_avg_rating = average_rating top_movies = [movie] elif average_rating == max_avg_rating: top_movies.append(movie) return sorted(top_movies)"},{"question":"# Question: Implement a Memory-Efficient Matrix Transpose Function You are required to implement a memory-efficient function that transposes a given matrix. The function should handle large matrices without unnecessary use of additional memory space. Requirements 1. **Function Name**: memory_efficient_transpose 2. **Input**: A 2D list (list of lists) representing the matrix. 3. **Output**: The transposed version of the input matrix as a 2D list. Constraints 1. The function should not use external libraries such as NumPy. 2. Avoid creating a new matrix with the same dimensions as the input for storing intermediate values. 3. Handle both square and non-square matrices efficiently. Example ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> memory_efficient_transpose(matrix) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> matrix = [ ... [1, 2], ... [3, 4], ... [5, 6] ... ] >>> memory_efficient_transpose(matrix) [[1, 3, 5], [2, 4, 6]] ``` Guidelines - Implement the function with time complexity O(n * m), where n and m are the number of rows and columns in the input matrix respectively. - Attempt to minimize auxiliary memory usage.","solution":"def memory_efficient_transpose(matrix): Transposes the given matrix in a memory-efficient way if not matrix: return [] # Get the dimensions of the matrix rows = len(matrix) columns = len(matrix[0]) # Initialize the transposed matrix with the correct dimensions transposed = [[None] * rows for _ in range(columns)] # Perform the transpose operation for i in range(rows): for j in range(columns): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Problem Statement: You are tasked with creating a command-line tool that allows users to encrypt and decrypt text using the Caesar cipher. The Caesar cipher is a type of substitution cipher where each letter in the plaintext is shifted a certain number of places down or up the alphabet. Implement a Python function `caesar_cipher(text: str, shift: int, mode: str) -> str` which: 1. Encrypts or decrypts the given text using the specified shift value. 2. The `mode` parameter determines whether the function should perform encryption or decryption. - If `mode` is `\\"encrypt\\"`, the function should shift each letter in the text forward by the shift value. - If `mode` is `\\"decrypt\\"`, the function should shift each letter in the text backward by the shift value. 3. The function should preserve the case of the letters and leave non-alphabetic characters unchanged. Constraints * The `shift` value will be a non-negative integer. * The `mode` parameter will be either `\\"encrypt\\"` or `\\"decrypt\\"`. * The input `text` can include alphabetic characters and non-alphabetic characters (such as digits, spaces, punctuation). * The function should handle both uppercase and lowercase letters correctly. Inputs and Outputs * **Input**: - `text` (str) - the string to be encrypted or decrypted. - `shift` (int) - the number of places to shift each letter. - `mode` (str) - the mode of operation, either `\\"encrypt\\"` or `\\"decrypt\\"`. * **Output**: - A string representing the encrypted or decrypted text. Example: ```python caesar_cipher(\\"Hello, World!\\", 3, \\"encrypt\\") ``` This should return: ``` \\"Khoor, Zruog!\\" ``` ```python caesar_cipher(\\"Khoor, Zruog!\\", 3, \\"decrypt\\") ``` This should return: ``` \\"Hello, World!\\" ```","solution":"def caesar_cipher(text: str, shift: int, mode: str) -> str: def shift_char(c, shift_amount): if c.isalpha(): base = ord(\'A\') if c.isupper() else ord(\'a\') return chr((ord(c) - base + shift_amount) % 26 + base) return c if mode == \\"decrypt\\": shift = -shift result = \'\'.join(shift_char(c, shift) for c in text) return result"},{"question":"# Coding Assessment Question Context: Given a list of integers, you need to determine if it is possible to partition the array into two subsets such that the sum of elements in both subsets is the same. This problem is commonly known as the \\"Partition Problem\\" and is a well-known problem in computer science related to dynamic programming and subset sum problem. Task: Write a Python function `can_partition(nums: List[int]) -> bool` that determines if the input list can be partitioned into two subsets with equal sums. 1. **Function Signature**: ```python def can_partition(nums: List[int]) -> bool: ``` 2. **Input**: - `nums` (a list of integers): A list of non-negative integers. 3. **Output**: - Returns `True` if the array can be partitioned into two subsets with equal sums, otherwise `False`. 4. **Constraints**: - The length of `nums` is in the range `[1, 200]` - Elements of `nums` are in the range `[0, 100]` - The solution should have an efficient time complexity, optimal solutions would be those that run in pseudo-polynomial time. Examples: ```python # Example 1 assert can_partition([1, 5, 11, 5]) == True # Can be partitioned into [1, 5, 5] and [11] # Example 2 assert can_partition([1, 2, 3, 5]) == False # Cannot be partitioned into two subsets with equal sums # Example 3 assert can_partition([1, 2, 5]) == False # Cannot be partitioned since two subsets with equal sums do not exist ``` Notes: - You may use dynamic programming to solve this problem efficiently. - Verify all edge cases, for instance, a list with a single element cannot be partitioned. - If the total sum of the array is odd, it\'s immediately not possible to partition into two equal subsets. - Consider helper functions to cleanly implement the dynamic programming approach, where needed. This question assesses your understanding of dynamic programming and subset sum problem-solving approaches in Python.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) # If total sum is odd, it\'s not possible to partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 # DP approach similar to subset sum problem dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"# String Compression Context String compression is a technique used to reduce the size of a string by encoding repeated characters. A basic form of string compression uses the count of repeated characters to compress the string. Task You are required to write a Python function that compresses a given string by replacing sequences of the same character with that character followed by the count of its occurrences. If the compressed string is not smaller than the original string, return the original string. Input - A single string consisting of alphanumeric characters. Output - A compressed version of the string or the original string if the compressed version is not shorter. Constraints - The input string will have at least one character and at most 10,000 characters. - The string will only consist of uppercase and lowercase English letters and digits. Examples ```python >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" >>> compress_string(\\"aabbcc\\") \\"aabbcc\\" >>> compress_string(\\"aabbccc\\") \\"a2b2c3\\" ``` Explanation 1. In the first example, the string \\"aabcccccaaa\\" becomes \\"a2b1c5a3\\" which is shorter than the original, so the compressed string is returned. 2. For the second example, the string \\"abcdef\\" has no repeating characters, so the compressed version would be the same as the original. 3. Similarly, \\"aabbcc\\" doesn\'t become shorter when compressed, so the original string is returned. 4. In the fourth example, \\"a2b2c3\\" is shorter than the original \\"aabbccc\\", thus the compressed string \\"a2b2c3\\" is returned. Function Signature ```python def compress_string(s: str) -> str: pass ```","solution":"def compress_string(s: str) -> str: compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \\"\\".join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Problem Statement Your task is to implement a text processing function that extracts all email addresses from a block of text. An email address is defined as a sequence of characters that matches a specific pattern: one or more characters before the \\"@\\" symbol, followed by a domain name that includes at least one dot. # Problem Description Given a string containing multiple lines of text, identify all email addresses within the text. Email addresses may appear anywhere in the text, and there may be multiple email addresses on a single line or across multiple lines. # Requirements * Implement the function `extract_emails(text: str) -> List[str]`. * Extract all unique email addresses found in the provided text. * Return a list of email addresses, sorted in the order they appear in the text. # Input * `text` - A string containing multiple lines of text. ```python text = \\"Please contact us at support@example.com for further assistance.nYou can also reach out to hr@company.com or sales@service.org for specific inquiries.\\" ``` # Output * Return a list of unique email addresses found in the text, sorted in the order they appear. # Constraints * The length of the text should not exceed (10^4) characters. * An email address is defined as a sequence of characters before the \\"@\\" symbol, followed by a domain name that includes at least one dot. * Characters allowed in the local part (before the \\"@\\") are letters, numbers, dots, underscores, and hyphens. * Characters allowed in the domain part (after the \\"@\\") are letters, numbers, dots, and hyphens. # Function Signature ```python from typing import List def extract_emails(text: str) -> List[str]: pass ``` # Example Input ```python text = \\"Dear John, please send the report to manager@office.com and cc to lead@office.com. For HR related queries, contact hr@office.com.\\" ``` Output ```python [\\"manager@office.com\\", \\"lead@office.com\\", \\"hr@office.com\\"] ```","solution":"import re from typing import List def extract_emails(text: str) -> List[str]: Extract all unique email addresses from the given text and return them in the order they appear. # Regular expression pattern to extract email addresses pattern = re.compile(r\'b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}b\') # Find all occurrences of the pattern emails = pattern.findall(text) # Return emails in the order they appear, keeping the order and uniqueness seen = set() result = [] for email in emails: if email not in seen: seen.add(email) result.append(email) return result"},{"question":"# Question: Prefix-Free Binary Codes Checker Given an array of binary strings, implement a function `is_prefix_free(codes)` that determines whether the array represents a prefix-free set of codes. A set of binary strings is prefix-free if no string is a prefix of another string in the set. Implement the function: ```python def is_prefix_free(codes): pass ``` # Input/Output Input * `codes`: a list of binary strings with length between 1 and 1000, where each string has a length between 1 and 100. Output * Returns a boolean value indicating whether the array is prefix-free or not. # Constraints * All binary strings in the list will only contain characters \'0\' and \'1\'. * The number of strings, as well as their lengths, ensure input within manageable performance requirements. # Example ```python assert is_prefix_free([\'10\', \'0\', \'111\']) == True assert is_prefix_free([\'101\', \'10\', \'1011\']) == False assert is_prefix_free([\'01\', \'010\', \'011\']) == False ``` # Notes 1. A prefix-free set means no string is a prefix of another, i.e., for any `codes[i]` and `codes[j]` where `i != j`, `codes[j]` should not start with `codes[i]`. 2. Consider using data structures that can facilitate efficient prefix checking. This question evaluates understanding of string manipulation and efficient searching techniques, appropriate for intermediate-level coding interviews.","solution":"def is_prefix_free(codes): Determines if a set of binary strings is prefix-free. # Sort the list of binary strings codes.sort() # Compare each string with the next one in the sorted list for i in range(len(codes) - 1): if codes[i] == codes[i + 1][:len(codes[i])]: return False return True"},{"question":"# Task: Implement a function in Python to perform a level-order traversal (breadth-first traversal) on a binary tree and return a list of values of the nodes in the order they are visited. # Function Signature: ```python def level_order_traversal(root: None | BinaryTreeNode) -> list[int]: ``` # Input Parameter: - `root`: The root node of the binary tree to traverse (`BinaryTreeNode` or `None`). # Output: - Return a list of integers representing the values of the nodes in the level-order traversal order. # Constraints: - The values of the nodes are integers. - The number of nodes in the binary tree can be up to 10,000. - The binary tree may be empty, in which case the output should be an empty list. # Examples: ```python # Example 1: # 1 # / # 2 3 # / # 4 5 # level_order_traversal(root) should return [1, 2, 3, 4, 5] # Example 2: # 1 # / # 2 3 # # 4 # level_order_traversal(root) should return [1, 2, 3, 4] # Example 3: # An empty tree (i.e., root is None) # level_order_traversal(None) should return [] def level_order_traversal_example(): # Example 1 root1 = BinaryTreeNode(1) insert(root1, 2) insert(root1, 3) insert(root1, 4) insert(root1, 5) assert level_order_traversal(root1) == [1, 2, 3, 4, 5] # Example 2 root2 = BinaryTreeNode(1) root2.left_child = BinaryTreeNode(2) root2.right_child = BinaryTreeNode(3) root2.left_child.right_child = BinaryTreeNode(4) assert level_order_traversal(root2) == [1, 2, 3, 4] # Example 3 assert level_order_traversal(None) == [] level_order_traversal_example() ```","solution":"from collections import deque class BinaryTreeNode: def __init__(self, value: int = 0, left: \'BinaryTreeNode\' = None, right: \'BinaryTreeNode\' = None): self.value = value self.left = left self.right = right def level_order_traversal(root: None or BinaryTreeNode) -> list[int]: if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"# Coding Assessment Question Context In a grid, a knight piece from chess moves in an \\"L\\" shape. This means it can move to the following positions from any given point `(x, y)`: - `(x + 2, y + 1)`, `(x + 2, y - 1)` - `(x - 2, y + 1)`, `(x - 2, y - 1)` - `(x + 1, y + 2)`, `(x + 1, y - 2)` - `(x - 1, y + 2)`, `(x - 1, y - 2)` Task Implement a function `knight_reachable` that determines if a knight can move from the top-left corner `(0, 0)` to the bottom-right corner `(n-1, n-1)` in an `n x n` grid. Function Signature ```python def knight_reachable(n: int) -> bool: ``` Input - `n` (integer): The size of the grid. `1 <= n <= 100`. Output - A boolean value `True` if the knight can reach the bottom-right corner from the top-left corner, otherwise `False`. Example - Input: `n = 5` - Output: `True` - Explanation: The knight can move in \\"L\\" shapes and navigate through the grid to reach the bottom-right corner. Constraints - Ensure that your solution efficiently determines the reachability within the given grid size constraints. Requirements * **Edge Cases**: Handle cases where `n = 1` and `n = 2` properly. * **Performance**: The function should be optimized so it runs efficiently for large grids up to size `100 x 100`. Write a well-tested function to verify if the knight can reach the destination. Ensure your implementation is robust and handles all edge cases.","solution":"from collections import deque def knight_reachable(n): if n == 1: return True moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] def is_within_bounds(x, y): return 0 <= x < n and 0 <= y < n queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() for dx, dy in moves: nx, ny = x + dx, y + dy if (nx, ny) == (n-1, n-1): return True if is_within_bounds(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"# Coding Assessment Question Context You have been provided with an implementation that reads text data from a file and analyzes the frequency of words. The task is to improve the code efficiency and add functionality to filter out common stopwords. Task Your objective is to optimize the existing code for performance and extend its functionality to ignore common stopwords. You need to address the following improvements: 1. **Efficient Data Reading**: Enhance the code to read large text files efficiently without consuming excessive memory. 2. **Stopwords Filtering**: Implement a mechanism to filter out common stopwords from the analysis. 3. **Case-Insensitive Matching**: Ensure that the word frequency analysis is case-insensitive. Function Signature ```python def analyze_word_frequency(file_path: str, stopwords: set): Analyze word frequency in the provided text file. Parameters: file_path (str): The path to the input text file. stopwords (set): A set of words to be ignored during analysis. Output: Your function should print the ten most frequent words (excluding stopwords) and their respective counts. ``` Input * **file_path (str)**: The file path to the text document. * **stopwords (set)**: A set of words to be excluded from the frequency analysis. Output * The function should print the ten most frequent words in the text (ignoring common stopwords) along with their counts. Constraints * Handle large text files efficiently. * Make sure the word frequency analysis is case-insensitive. * Ensure the code is robust against missing files or directory errors. Example ```python # Example stopwords set stopwords = {\'the\', \'is\', \'in\', \'and\', \'to\', \'a\'} # Call the function with a file path and stopwords set analyze_word_frequency(file_path=\'sample.txt\', stopwords=stopwords) ``` **Expected Outcome**: The function should output the ten most frequent non-stopword words in the provided text file and their counts. It should handle large files and be case-insensitive while ensuring performance optimization. Good luck!","solution":"import os import collections def analyze_word_frequency(file_path: str, stopwords: set): Analyze word frequency in the provided text file. Parameters: file_path (str): The path to the input text file. stopwords (set): A set of words to be ignored during analysis. Output: Your function should print the ten most frequent words (excluding stopwords) and their respective counts. def read_file_in_chunks(file_path, chunk_size=1024*1024): Generator to read a file chunk by chunk. with open(file_path, \'r\') as file: while True: chunk = file.read(chunk_size) if not chunk: break yield chunk if not os.path.isfile(file_path): print(\\"Error: File not found.\\") return word_counter = collections.Counter() for chunk in read_file_in_chunks(file_path): words = chunk.lower().split() filtered_words = [word.strip(\\".,!?;:\\") for word in words if word.strip(\\".,!?;:\\") not in stopwords] word_counter.update(filtered_words) most_common_words = word_counter.most_common(10) for word, count in most_common_words: print(f\\"{word}: {count}\\") # Example stopwords set stopwords = {\'the\', \'is\', \'in\', \'and\', \'to\', \'a\'} # Call the function with a file path and stopwords set (example) # analyze_word_frequency(file_path=\'sample.txt\', stopwords=stopwords)"},{"question":"Coding Question: String Compression You are working on a data optimization problem where you need to compress a given string by using the counts of repeated characters. For instance, the string \\"aaabbc\\" would be compressed to \\"a3b2c1\\". Your task is to write a function to perform this compression. **Problem Statement**: Write a function that compresses the given string by replacing sequences of repeated characters with the character followed by the number of repetitions. Function Signature ```python def compress_string(s: str) -> str: Compresses the input string using character counts. Args: s (str): The input string consisting of lowercase alphabetic characters only. Returns: str: The compressed string with character counts. Raises: ValueError: if the input string contains non-lowercase alphabetic characters. ``` Inputs: |Name | Type | |--------------|-----------| |s | str | Outputs: |Name | Type | |--------------|-----------| |compressed | str | Constraints: 1. The input string will consist of lowercase alphabetic characters only. 2. If the input string contains any non-lowercase alphabetic character, the function should raise a `ValueError`. 3. The output string should be shorter than or equal in length to the original string. Example: ```python >>> compress_string(\\"aaabbc\\") \'a3b2c1\' >>> compress_string(\\"abcd\\") \'a1b1c1d1\' >>> compress_string(\\"\\") \'\' >>> compress_string(\\"aaaAA\\") ValueError: Invalid input. Only lowercase alphabetic characters are allowed. ``` **Note**: Ensure the function handles empty strings correctly by returning an empty string. **Performance Requirements**: * The time complexity should be O(n), where n is the length of the input string. The algorithm should perform a single pass through the input string to calculate counts and construct the compressed string.","solution":"def compress_string(s: str) -> str: Compresses the input string using character counts. Args: s (str): The input string consisting of lowercase alphabetic characters only. Returns: str: The compressed string with character counts. Raises: ValueError: if the input string contains non-lowercase alphabetic characters. if not s: return \\"\\" if not s.islower(): raise ValueError(\\"Invalid input. Only lowercase alphabetic characters are allowed.\\") compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(f\\"{s[i-1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") return \'\'.join(compressed)"},{"question":"# Question: Implement a Function to Merge Two Sorted Lists You need to create a function that merges two sorted lists into a single sorted list. The resulting list should contain all elements from both input lists in sorted order. Function Signature ```python def merge_sorted_lists(list1: list[int | float], list2: list[int | float]) -> list[int | float] ``` Requirements * The function should take two sorted lists as input and return a single sorted list. * The input lists may contain a mix of integers and floats. * Both input lists and the output list should be sorted in non-decreasing order. * If both lists are empty, the result should be an empty list. Input * `list1`: A sorted list of integers or floats. Example: `[1, 3, 5]` * `list2`: A sorted list of integers or floats. Example: `[2, 4, 6]` Output * A single list that contains all elements from `list1` and `list2` in sorted order. Examples ```python assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_lists([-3, 0, 10.5], [-5.5, 0, 5]) == [-5.5, -3, 0, 0, 5, 10.5] assert merge_sorted_lists([1.1, 2.2], [1.1, 2.2]) == [1.1, 1.1, 2.2, 2.2] assert merge_sorted_lists([], []) == [] ``` Constraints * Both input lists should be given in non-decreasing order. * There should be no duplicates within each input list, but duplicates may exist across the two lists. * The implementation should efficiently handle merging, ideally with a time complexity of O(n + m), where n and m are the lengths of `list1` and `list2` respectively. * Memory usage should be kept to a minimum beyond the necessary output list. Additional Information * Make sure your implementation handles edge cases such as empty lists, lists with negative numbers, and lists consisting of purely floats or integers. * You may assume that the input lists are already validated to be sorted in non-decreasing order. ```python def merge_sorted_lists(list1: list[int | float], list2: list[int | float]) -> list[int | float]: merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list # Testing the function with provided examples assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_lists([-3, 0, 10.5], [-5.5, 0, 5]) == [-5.5, -3, 0, 0, 5, 10.5] assert merge_sorted_lists([1.1, 2.2], [1.1, 2.2]) == [1.1, 1.1, 2.2, 2.2] assert merge_sorted_lists([], []) == [] ```","solution":"def merge_sorted_lists(list1: list[int | float], list2: list[int | float]) -> list[int | float]: merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Statement You have been assigned the task of implementing a feature that generates permutations of a given string. A permutation of a string is a rearrangement of its characters. Your function should return all possible unique permutations of the input string in sorted order. Your task is to write a function `generate_permutations` that takes: - `s` (a string, consisting of lowercase alphabets only) The function should return a list of all unique permutations of `s` in lexicographical order. Input: - `s`: str (1 <= len(s) <= 8) Output: - A list of strings representing all unique permutations of `s` in sorted order. Constraints: - The length of `s` should be between 1 and 8 inclusive. - Characters are all lowercase letters. # Examples: 1. `generate_permutations(\\"abc\\")` should return `[\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]`. 2. `generate_permutations(\\"aab\\")` should return `[\\"aab\\", \\"aba\\", \\"baa\\"]`. 3. `generate_permutations(\\"aaa\\")` should return `[\\"aaa\\"]`. # Notes: - Use appropriate libraries or algorithms to handle permutation generation efficiently. - Ensure the output list contains sorted permutations. - Input string `s` will contain only lowercase alphabets with possible repetitions.","solution":"from itertools import permutations def generate_permutations(s): Generates all unique permutations of the input string in sorted order. Parameters: s (str): The input string (1 <= len(s) <= 8) consisting of lowercase alphabets only. Returns: List[str]: Sorted list of unique permutations of the string. # Generate permutations using itertools.permutations all_permutations = set(permutations(s)) # Convert each permutation tuple to a string perm_list = [\'\'.join(p) for p in all_permutations] # Sort the list of permutations perm_list.sort() return perm_list"},{"question":"# Scenario: As an engineer at a logistics company, you are tasked with designing an efficient system for managing truck routes and calculating the shortest path. Each truck route is represented as a weighted, undirected graph where nodes indicate stations and edges indicate direct routes between stations with the corresponding distances. To facilitate tracking and querying of distances between stations, you decide to implement Dijkstra\'s algorithm. # Task: Implement a function that supports the following operation: - **shortest_path(start_station: int, end_station: int) -> int**: Calculate the shortest path from the `start_station` to the `end_station`. If there\'s no path, return -1. # Constraints: - `0 <= station < N`, where `N` is the number of stations. - The number of routes (edges) is up to (E), where (E leq 10^5). - Distances are non-negative integers, and the maximum distance between any two stations is (10^6). # Function Signature: ```python class TruckRoutes: def __init__(self, num_stations: int) -> None: ... def add_route(self, station1: int, station2: int, distance: int) -> None: ... def shortest_path(self, start_station: int, end_station: int) -> int: ... # Example Usage: # routes = TruckRoutes(5) # routes.add_route(0, 1, 10) # routes.add_route(1, 2, 5) # routes.add_route(2, 3, 2) # routes.add_route(3, 4, 1) # print(routes.shortest_path(0, 4)) # Output: 18 # print(routes.shortest_path(1, 3)) # Output: 7 # print(routes.shortest_path(4, 0)) # Output: -1 (no path exists) ``` # Notes: - Ensure that the implementation efficiently calculates shortest paths using Dijkstra\'s algorithm. - Consider edge cases like isolated stations (stations with no connecting routes). - The `add_route()` method should allow adding multiple routes between any two stations. - Optimize for both time and space complexity considering the constraints.","solution":"import heapq class TruckRoutes: def __init__(self, num_stations: int) -> None: self.num_stations = num_stations self.graph = {i: [] for i in range(num_stations)} def add_route(self, station1: int, station2: int, distance: int) -> None: self.graph[station1].append((distance, station2)) self.graph[station2].append((distance, station1)) def shortest_path(self, start_station: int, end_station: int) -> int: if start_station == end_station: return 0 priority_queue = [(0, start_station)] distances = {i: float(\'inf\') for i in range(self.num_stations)} distances[start_station] = 0 while priority_queue: current_distance, current_station = heapq.heappop(priority_queue) if current_distance > distances[current_station]: continue for neighbor_distance, neighbor in self.graph[current_station]: distance = current_distance + neighbor_distance if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end_station] if distances[end_station] != float(\'inf\') else -1"},{"question":"Context: You are provided with a **Graph** class that represents an undirected graph using an adjacency list. Your task is to extend this class by implementing additional methods to analyze the graph properties and metrics, such as finding the shortest path and detecting cycles. This will assess your understanding of graph algorithms and data structures. # Task: 1. Implement a method `shortest_path(self, start: int, end: int) -> List[int]` which returns the shortest path (as a list of nodes) from `start` to `end` using Breadth-First Search (BFS). If no path exists, it should return an empty list. 2. Implement a method `has_cycle(self) -> bool` that detects whether there\'s a cycle in the graph. Use Depth-First Search (DFS) for cycle detection. # Function Signature: ```python def shortest_path(self, start: int, end: int) -> List[int]: Returns the shortest path from start to end using BFS. def has_cycle(self) -> bool: Returns True if the graph contains a cycle, otherwise False. ``` # Input & Output Formats: * The `shortest_path` method takes two integers `start` and `end`, representing the starting and ending nodes, respectively. It returns a list of integers representing the shortest path, or an empty list if no path exists. * The `has_cycle` method takes no arguments and returns a boolean indicating if a cycle is present in the graph. # Constraints: * Graph nodes are labeled with non-negative integers. * The graph can have up to 1000 nodes. * Each node can have up to 100 connections. * Graph can be sparse or dense. # Example: ```python # Initialize Graph graph = Graph({ 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3] }) # Shortest path from 0 to 4 print(graph.shortest_path(0, 4)) # Expected Output: [0, 2, 3, 4] # Detect cycle in the graph print(graph.has_cycle()) # Expected Output: True # Modify graph to remove cycle graph.remove_edge(3, 2) # Recheck cycle detection print(graph.has_cycle()) # Expected Output: False ``` # Performance Requirements: * The `shortest_path` method should execute in O(V + E) where V is the number of vertices and E is the number of edges. * The `ho_cycle` method should also execute in O(V + E). # Notes: * The `shortest_path` method should handle cases where start is equal to end and return [start]. * The `has_cycle` method should accurately detect cycles in both connected and disconnected graphs.","solution":"from collections import deque, defaultdict from typing import List, Dict, Set class Graph: def __init__(self, adj_list: Dict[int, List[int]] = None): self.adj_list = adj_list if adj_list is not None else defaultdict(list) def add_edge(self, u: int, v: int): self.adj_list[u].append(v) self.adj_list[v].append(u) def remove_edge(self, u: int, v: int): self.adj_list[u].remove(v) self.adj_list[v].remove(u) def shortest_path(self, start: int, end: int) -> List[int]: if start == end: return [start] visited = set() queue = deque([(start, [start])]) while queue: node, path = queue.popleft() if node == end: return path visited.add(node) for neighbor in self.adj_list[node]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return [] def has_cycle(self) -> bool: visited = set() def dfs(v: int, parent: int) -> bool: visited.add(v) for neighbor in self.adj_list[v]: if neighbor not in visited: if dfs(neighbor, v): return True elif neighbor != parent: return True return False for vertex in self.adj_list: if vertex not in visited: if dfs(vertex, -1): return True return False"},{"question":"# Problem Statement You need to implement a feature for a simple calendar application that allows users to find out the available slots for meetings. The calendar allows users to book multiple slots in a day, and we want to enable users to see when they can still schedule new meetings. # Objective Implement a function `find_available_slots(schedule, meeting_duration)` that: 1. Finds all available slots of at least the specified duration within the working hours of the day. 2. Returns the available time slots that can accommodate the meeting duration. # Requirements - **Input**: - `schedule`: A list of tuples, where each tuple contains two strings representing the start and end times of a booked slot in the format \\"HH:MM\\". - `meeting_duration`: An integer representing the duration of the meeting in minutes. - **Output**: A list of tuples, where each tuple contains two strings representing the start and end times of the available slots in the format \\"HH:MM\\". If no slots are available, return an empty list. # Constraints - The working hours are from \\"09:00\\" to \\"17:00\\". - The time format is based on a 24-hour clock. - The schedule may contain overlapping slots that need to be merged before finding available slots. - Ensure efficiency in finding available slots and handling any edge cases. # Example Case ```python def find_available_slots(schedule: list[tuple[str, str]], meeting_duration: int) -> list[tuple[str, str]]: # Your implementation here # Example usage schedule = [(\\"09:00\\", \\"10:30\\"), (\\"12:00\\", \\"13:00\\"), (\\"14:00\\", \\"15:00\\")] meeting_duration = 30 available_slots = find_available_slots(schedule, meeting_duration) print(available_slots) ``` **Expected Output**: ```python [(\'10:30\', \'12:00\'), (\'13:00\', \'14:00\'), (\'15:00\', \'17:00\')] ``` # Note - You can assume there are no other events outside of the given schedule within the working hours. - Handle the merging of overlapping slots and edge cases effectively. - Consider using the `datetime` module for handling time-related calculations.","solution":"from datetime import datetime, timedelta def find_available_slots(schedule, meeting_duration): Finds all available slots of at least the specified duration within the working hours of the day. working_start = datetime.strptime(\\"09:00\\", \\"%H:%M\\") working_end = datetime.strptime(\\"17:00\\", \\"%H:%M\\") meeting_duration_delta = timedelta(minutes=meeting_duration) parsed_schedule = [(datetime.strptime(start, \\"%H:%M\\"), datetime.strptime(end, \\"%H:%M\\")) for start, end in schedule] parsed_schedule.sort() merged_schedule = [] for start, end in parsed_schedule: if not merged_schedule or merged_schedule[-1][1] < start: merged_schedule.append((start, end)) else: merged_schedule[-1] = (merged_schedule[-1][0], max(merged_schedule[-1][1], end)) available_slots = [] current_time = working_start for start, end in merged_schedule: if current_time + meeting_duration_delta <= start: available_slots.append((current_time.strftime(\\"%H:%M\\"), start.strftime(\\"%H:%M\\"))) current_time = max(current_time, end) if current_time + meeting_duration_delta <= working_end: available_slots.append((current_time.strftime(\\"%H:%M\\"), working_end.strftime(\\"%H:%M\\"))) return available_slots"},{"question":"# Problem Description You need to implement a function that takes an integer array and reorders its elements to form the largest possible integer. # Requirements 1. **Input**: A list of non-negative integers. 2. **Output**: A string representing the largest possible integer that can be formed by concatenating the elements of the list. # Implementation Implement the `largest_number(nums: List[int]) -> str` function. # Example ```python def largest_number(nums: List[int]) -> str: # Your code here pass # Example Test Case print(largest_number([3, 30, 34, 5, 9])) # Expected Output: \\"9534330\\" ``` # Notes * The output should not contain leading zeros unless the number is `0`. * Consider how to sort the numbers effectively to get the desired result. * Edge cases such as arrays composed of zeros should result in \\"0\\", not several zeros. This problem tests your ability to manipulate and compare string representations of numbers efficiently to achieve the lexicographically largest arrangement.","solution":"from typing import List def largest_number(nums: List[int]) -> str: if not nums: return \\"\\" # Convert integers to strings for easier comparison nums_str = list(map(str, nums)) # Sort strings based on the custom comparator nums_str.sort(key=lambda x: x*10, reverse=True) # Join the sorted strings largest_num = \'\'.join(nums_str) # Edge case: When the largest number is \\"0\\", return \\"0\\" return largest_num if largest_num[0] != \'0\' else \'0\'"},{"question":"# Word Frequency Counter Given a string, your task is to write a function that computes the frequency of each word in the string. The function should return a dictionary where the keys are the words and the values are their corresponding frequencies. Words are defined as continuous sequences of alphanumeric characters, delimited by any non-alphanumeric characters. Task Implement the `word_frequency` function that counts the frequency of each word in a given string: 1. **Normalization**: Convert the string to lowercase to ensure that the word count is case-insensitive. 2. **Splitting**: Split the string into words by identifying alphanumeric sequences. 3. **Counting**: Count the occurrence of each word. Function Signature ```python def word_frequency(text: str) -> dict: pass ``` Input - A string `text` (length: 0 to (10^6) characters). Output - A dictionary where keys are words and values are their frequencies. Constraints - Words should be compared in a case-insensitive manner. - Use of regular expressions is allowed to identify words. Example ```python >>> word_frequency(\\"The quick brown fox jumps over the lazy dog. The quick brown fox!\\") {\'the\': 2, \'quick\': 2, \'brown\': 2, \'fox\': 2, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 1} >>> word_frequency(\\"HELLO WORLD! hello WORLD!\\") {\'hello\': 2, \'world\': 2} >>> word_frequency(\\"\\") {} ``` Performance Your implementation should handle large text inputs efficiently within a reasonable time frame, making use of appropriate data structures for counting and storing word frequencies.","solution":"import re from collections import Counter def word_frequency(text: str) -> dict: Computes the frequency of each word in the input text. Args: text (str): The input string where word frequencies are to be counted. Returns: dict: A dictionary with words as keys and their frequencies as values. # Normalize the text to lowercase text = text.lower() # Find all words using regular expression words = re.findall(r\'bw+b\', text) # Count the frequency of each word word_counts = Counter(words) return dict(word_counts)"},{"question":"# Substring Checker **Objective**: Implement a function to check if one string is a substring of another. **Scenario**: You are building a text editor feature that allows users to search for specific phrases within a document. To achieve this, you need to create a function that determines if a given search string is a substring of a target string. **Function Signature**: ```python def is_substring(search: str, target: str) -> bool: pass ``` **Input**: - `search` (str): The string to search for. This string can contain uppercase and lowercase letters and special characters. - `target` (str): The string in which to search. This string can also contain uppercase and lowercase letters and special characters. **Output**: - Returns a boolean value `True` if `search` is a substring of `target`, otherwise `False`. **Constraints**: - The length of the `search` string will be at most 1,000 characters. - The length of the `target` string will be at most 100,000 characters. - Both strings may include spaces and punctuation marks. **Example**: ```python assert is_substring(\\"world\\", \\"Hello, world!\\") == True assert is_substring(\\"Python\\", \\"Hello, world!\\") == False assert is_substring(\\"world!\\", \\"Hello, world!\\") == True assert is_substring(\\" \\", \\"Hello, world!\\") == True assert is_substring(\\"test\\", \\"This is a simple test case.\\") == True ``` **Guidelines**: - Implement the function using an efficient substring search algorithm. - Consider edge cases where either the `search` or `target` string is empty. **Performance**: - Aim for a time complexity of O(n + m), where n is the length of the `target` string and m is the length of the `search` string.","solution":"def is_substring(search: str, target: str) -> bool: This function checks if `search` is a substring of `target`. Args: search (str): The string to search for. target (str): The string to search in. Returns: bool: True if `search` is found within `target`, else False. return search in target"},{"question":"# Problem Statement Implement a function to sort a list of tuples based on the sum of their elements, while preserving the original tuple order in cases where sums are equal. # Requirements 1. Implement the function `sort_tuples_by_sum(lst: List[Tuple[int, ...]]) -> List[Tuple[int, ...]]`. 2. The function should sort the list of tuples based on the sum of the tuple elements. 3. In case of ties (i.e., tuples with the same sum), their relative order from the input list should be preserved. 4. The function should handle an empty list, returning it unchanged. # Input - A list of tuples of integers (lst) where each tuple can contain 1 to `n` integers and (0 leq n leq 100). # Output - A list of tuples sorted based on the sum of their elements. # Example ```python >>> sort_tuples_by_sum([(1, 2, 3), (4, 1), (2, 2), (1, 1, 1)]) [(1, 1, 1), (2, 2), (4, 1), (1, 2, 3)] >>> sort_tuples_by_sum([(10,), (1, 4, 5), (2, 3), (8, 2)]) [(10,), (2, 3), (8, 2), (1, 4, 5)] >>> sort_tuples_by_sum([]) [] ``` # Constraints - Ensure the solution efficiently handles the maximum input size while preserving the stability of the sort.","solution":"from typing import List, Tuple def sort_tuples_by_sum(lst: List[Tuple[int, ...]]) -> List[Tuple[int, ...]]: Sorts a list of tuples based on the sum of their elements. Args: lst (List[Tuple[int, ...]]): A list of tuples of integers. Returns: List[Tuple[int, ...]]: The list sorted by the sum of tuple elements. return sorted(lst, key=sum)"},{"question":"# Coding Assessment: Implement LRU Cache Simulation Context You are developing a cache management module for a memory-intensive application that employs the Least Recently Used (LRU) policy. In this context, when the cache reaches its memory limit, the least recently used item should be evicted to make space for new items. Your task is to implement an LRU cache simulator that efficiently handles cache operations and returns the expected results based on the LRU policy. Requirements Implement the following class: 1. **class LRUCache**: * **__init__(self, capacity: int)**: * Initializes the cache with a given capacity. * **get(self, key: int) -> int**: * Retrieves the value of the key if it exists in the cache, otherwise returns -1. * **put(self, key: int, value: int) -> None**: * Inserts the value into the cache. If the cache exceeds its capacity, it should invalidate the least recently used item before inserting the new item. Input * You will be provided with a series of cache operations and their values. * Example: ```python capacity = 2 operations = [\\"put\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"get\\"] values = [(1, 1), (2, 2), (1,), (3, 3), (2,), (4, 4), (1,), (3,), (4,)] ``` Output * Your LRUCache class should output the results of the \'get\' operations in order. * Example Result: ```python [1, -1, -1, 3, 4] ``` Example ```python # Example provided inputs: capacity = 2 operations = [\\"put\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"get\\"] values = [(1, 1), (2, 2), (1,), (3, 3), (2,), (4, 4), (1,), (3,), (4,)] # Expected Output: [1, -1, -1, 3, 4] ``` Your implementation should handle all given operations efficiently, ensuring the use of appropriate data structures to maintain the order and access times as expected by the LRU policy. Hints - Consider using a combination of a dictionary and a doubly linked list to maintain the order of items based on usage. - Ensure that the `put` and `get` operations work in constant time, O(1).","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) # Dummy node self.tail = Node(0, 0) # Dummy node self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev = node.prev nxt = node.next prev.next = nxt nxt.prev = prev def _add(self, node): prev = self.tail.prev prev.next = node node.prev = prev node.next = self.tail self.tail.prev = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"Question: Enhancing an Event Handling System with Priority and Time-Based Scheduling # Background You are developing a new feature for an event handling system used in a complex application. The current system processes events based on FIFO (first-in, first-out) order. However, the application now needs to handle events with different priorities and schedule time-based events efficiently. # Task Modify the provided `EventManager` class to: 1. **Implement Priority Handling**: - Allow events to be processed based on their priority. Higher priority events should be processed before lower priority ones. - Events with the same priority should be processed in the order they were added. 2. **Implement Time-Based Scheduling**: - Add a feature to schedule events for future execution at specified timestamps. - Ensure that events scheduled for the future are processed at the right time, considering their priority as well. # Specifications 1. **Priority Handling**: - Implement a method `add_event(event, priority)` to add events with a specific priority. - Events with higher priority (lower numerical value) should be processed first. 2. **Time-Based Scheduling**: - Implement a method `schedule_event(event, timestamp)` to schedule events for future execution at a given timestamp. - The event should be processed only when the current time reaches or surpasses the given timestamp. # Requirements - **Input**: - The `EventManager` class should be instantiated and events can be added using the `add_event` and `schedule_event` methods. - Use `datetime.datetime.now()` to simulate the current system time. - The `process_events()` method should be called periodically to process due events based on their priority and timestamps. - **Output**: - Events should be processed and printed in the correct order, considering both priority and time. - **Constraints**: - The event manager should handle up to 1,000,000 events efficiently. - Ensure that priority and time-based scheduling are handled accurately without significant delays. # Example ```python from datetime import datetime, timedelta import heapq class EventManager: def __init__(self): self.event_queue = [] self.scheduled_events = [] def add_event(self, event, priority): heapq.heappush(self.event_queue, (priority, datetime.now(), event)) def schedule_event(self, event, timestamp): heapq.heappush(self.scheduled_events, (timestamp, event)) def process_events(self): current_time = datetime.now() while self.scheduled_events and self.scheduled_events[0][0] <= current_time: _, event = heapq.heappop(self.scheduled_events) self.add_event(event, 0) while self.event_queue: priority, time_added, event = heapq.heappop(self.event_queue) print(f\\"Processing event: {event}\\") ``` ```python # Example usage: em = EventManager() em.add_event(\\"Low priority event\\", 10) em.add_event(\\"High priority event\\", 1) em.schedule_event(\\"Future event\\", datetime.now() + timedelta(seconds=5)) em.process_events() # Output: Processing event: High priority event # Processing event: Low priority event # After 5 seconds, calling process_events again should process the scheduled event import time time.sleep(5) em.process_events() # Output: Processing event: Future event ``` # Evaluation - Ensure your code processes events in the proper order based on priority and scheduled time. - Efficiently handle and process a large number of events. - Accurately manage both immediate and future events to maintain the correct sequence.","solution":"from datetime import datetime, timedelta import heapq class EventManager: def __init__(self): self.event_queue = [] self.scheduled_events = [] def add_event(self, event, priority): heapq.heappush(self.event_queue, (priority, datetime.now(), event)) def schedule_event(self, event, timestamp): heapq.heappush(self.scheduled_events, (timestamp, 0, event)) def process_events(self): current_time = datetime.now() while self.scheduled_events and self.scheduled_events[0][0] <= current_time: timestamp, _, event = heapq.heappop(self.scheduled_events) self.add_event(event, 0) while self.event_queue: priority, time_added, event = heapq.heappop(self.event_queue) print(f\\"Processing event: {event}\\")"},{"question":"# Problem Statement You are given a `string` which represents the inorder traversal of a binary search tree (BST). The string contains node values of the BST separated by spaces. Implement a function `build_bst_from_inorder_traversal(inorder: str) -> TreeNode` which rebuilds the BST and returns the root node of the tree. Write a function to reconstruct the BST from the given inorder traversal string. The tree must follow the properties of a BST where for any node `n`, all elements in its left subtree are smaller than `n` and all elements in its right subtree are larger than `n`. You may assume that the inorder traversal string does not contain duplicates and the values are valid integers. # Function Signature ```python def build_bst_from_inorder_traversal(inorder: str) -> TreeNode: ``` # Input - `inorder`: A string containing space-separated integers which represents the inorder traversal of a BST. # Output - Return the root node of the reconstructed BST. # Constraints - The length of the inorder string is between `1` and `10^4` characters. - Node values in the string are between `-10^4` and `10^4`. # Example ```python >>> class TreeNode: ... def __init__(self, val=0, left=None, right=None): ... self.val = val ... self.left = left ... self.right = right >>> root = build_bst_from_inorder_traversal(\\"2 5 7 10 12 15 20\\") >>> root.val 10 >>> root.left.val 5 >>> root.right.val 15 >>> root = build_bst_from_inorder_traversal(\\"-10 -3 0 5 9\\") >>> root.val 0 >>> root.left.val -3 >>> root.right.val 9 ``` # Note 1. You may define a helper class `TreeNode` inside the function or assume it\'s defined outside as shown in the examples. 2. The root of the BST should be the median value in the inorder list to potentially minimize the tree height. 3. The helper class `TreeNode` is used to represent the BST nodes. Implement the `build_bst_from_inorder_traversal` function to accurately build the tree and handle all constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_bst_from_inorder_traversal(inorder: str) -> TreeNode: if not inorder: return None inorder_list = list(map(int, inorder.split())) def build_bst_from_sorted_list(nums): if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = build_bst_from_sorted_list(nums[:mid]) root.right = build_bst_from_sorted_list(nums[mid+1:]) return root return build_bst_from_sorted_list(inorder_list)"},{"question":"# Coding Assessment Question Create a function `merge_sort` that implements the Merge Sort algorithm to sort a list of integers. This exercise will test your capability to implement a classic divide-and-conquer sorting technique. The function should handle the entire list as well as subranges of the list defined by `start` and `end` indices. Function Signature ```python def merge_sort(sequence: list, start: int | None = None, end: int | None = None) -> None: pass ``` Input - `sequence` (list of ints): The list to be sorted. - `start` (optional int): The starting index of the list portion to sort. Defaults to zero. - `end` (optional int): The ending index of the list portion to sort. Defaults to the list\'s last index. Output - The function returns `None`. It sorts the list `sequence` in place. Constraints - List may contain up to `10^3` elements. - Elements can be negative or positive integers. - You must ensure in-place sorting without returning the list. Performance Requirements - Expected time complexity: O(n log n) Example ```python seq = [10, 2, 3, 7, 6] merge_sort(seq) print(seq) # Output: [2, 3, 6, 7, 10] seq = [8, 7, 6, 5, 4, 3] merge_sort(seq, 1, 4) print(seq) # Output: [8, 5, 6, 7, 4, 3] seq = [7, 6, 5, 4, 3, 2, 1] merge_sort(seq, start=3) print(seq) # Output: [7, 6, 5, 1, 2, 3, 4] ``` Scenarios to Validate - Sorting an empty list. - Sorting a single-element list. - Sorting portions of the list using `start` and `end` parameters. - Sorting a pre-sorted list. - Sorting a reverse-sorted list.","solution":"def merge_sort(sequence, start=None, end=None): Implements the Merge Sort algorithm to sort a list of integers in place. Parameters: - sequence (list): The list to be sorted. - start (int, optional): The starting index of the list portion to sort. Defaults to 0. - end (int, optional): The ending index of the list portion to sort. Defaults to the list\'s last index. if start is None: start = 0 if end is None: end = len(sequence) - 1 if start < end: # Find the middle point mid = (start + end) // 2 # Recursively sort the first and second halves merge_sort(sequence, start, mid) merge_sort(sequence, mid + 1, end) # Merge the sorted halves merge(sequence, start, mid, end) def merge(sequence, start, mid, end): Merges two halves of a list in sorted order. Parameters: - sequence (list): The list containing the two halves. - start (int): The starting index of the first half. - mid (int): The ending index of the first half (midpoint). - end (int): The ending index of the second half. # Create temporary arrays for the two halves left = sequence[start:mid + 1] right = sequence[mid + 1:end + 1] # Initial indices for the two halves i = 0 j = 0 # Initial index of merged array k = start # Merge the temporary arrays back into sequence while i < len(left) and j < len(right): if left[i] <= right[j]: sequence[k] = left[i] i += 1 else: sequence[k] = right[j] j += 1 k += 1 # Copy the remaining elements of left[], if there are any while i < len(left): sequence[k] = left[i] i += 1 k += 1 # Copy the remaining elements of right[], if there are any while j < len(right): sequence[k] = right[j] j += 1 k += 1"},{"question":"# Problem Statement Write a function that determines if it\'s possible to form a given target string using a list of provided words. You can use each word in the list multiple times and you can concatenate them in any order to form the target string. **Function to Implement** Implement the following function in Python: ```python def can_form_string(target: str, words: List[str]) -> bool: Given a target string and a list of words, determine if it\'s possible to construct the target string by concatenating words from the list. Each word in the list can be used multiple times. :param target: the string to be formed. :param words: list of words that can be used to form the target. :return: True if the target can be formed, False otherwise. ``` Input: - `target` (str): Target string to be formed. - `words` (List[str]): List of words that can be used to form the target string. Output: - Boolean value (True/False) indicating whether the target can be constructed. Constraints: - The length of the target string `1 <= len(target) <= 1000`. - The length of the words list `1 <= len(words) <= 100`. # Example **Example 1:** ```python can_form_string(\'leetcode\', [\'leet\', \'code\', \'le\', \'et\']) ``` **Output:** ``` True ``` **Explanation:** The target string \'leetcode\' can be formed by concatenating \'leet\' and \'code\'. **Example 2:** ```python can_form_string(\'applepie\', [\'apple\', \'pie\', \'pear\', \'applepie\']) ``` **Output:** ``` True ``` **Explanation:** The target string \'applepie\' can be formed by using the word \'applepie\' directly from the list or by concatenating \'apple\' and \'pie\'. **Example 3:** ```python can_form_string(\'coding\', [\'ing\', \'code\']) ``` **Output:** ``` False ``` **Explanation:** The target string \'coding\' cannot be formed by any combination of the words \'ing\', \'code\'.","solution":"from typing import List def can_form_string(target: str, words: List[str]) -> bool: Given a target string and a list of words, determine if it\'s possible to construct the target string by concatenating words from the list. Each word in the list can be used multiple times. :param target: the string to be formed. :param words: list of words that can be used to form the target. :return: True if the target can be formed, False otherwise. # Initialize a DP table where dp[i] will be True if the first i characters of target can be formed dp = [False] * (len(target) + 1) dp[0] = True # Base case, an empty target can be formed without any words for i in range(1, len(target) + 1): for word in words: if i >= len(word) and target[i-len(word):i] == word: dp[i] = dp[i] or dp[i-len(word)] return dp[len(target)]"},{"question":"# Problem Statement Write a function to find the longest word in a given string. The function should consider words to be sequences of letters separated by spaces or punctuation. If there are multiple words with the same maximum length, return the one that appears first in the string. # Function Signature ```python def longest_word(s: str) -> str: ``` # Input * `s` (1 <= len(`s`) <= 1000): a string containing English letters and spaces, along with common punctuation marks (.,!?;:). # Output * Returns a string representing the longest word found in the input string. # Explanation * The function should split the input string into words, taking care to remove any punctuation marks. * It should then identify and return the longest word. If multiple words have the same length, the function should return the first one of those in the order they appear in the string. # Example ```python >>> longest_word(\\"A quick brown fox jumped over the lazy dog.\\") \\"jumped\\" >>> longest_word(\\"To be, or not to be: that is the question.\\") \\"question\\" >>> longest_word(\\"Well, this is a straightforward example!\\") \\"straightforward\\" ``` # Constraints * The function should efficiently handle strings of varying lengths up to the specified limit. # Hints * Use regular expressions to split the string into words while removing punctuation. * Iterate through the list of words to determine the longest one, ensuring you account for the order of appearance.","solution":"import re def longest_word(s: str) -> str: Returns the longest word in the input string s. If there are multiple words with the same maximum length, returns the one that appears first. # Use regular expression to find all words by splitting on non-word characters words = re.findall(r\'bw+b\', s) # Initialize variables to track the longest word max_length = 0 longest = \\"\\" # Iterate through words and update the longest word if necessary for word in words: if len(word) > max_length: max_length = len(word) longest = word return longest"},{"question":"# Coding Assessment Question You are tasked with implementing a function that processes and transforms a sequence of integers according to specific rules, simulating a modified number game. Task **Function:** `play_number_game(sequence: list) -> list` Implement a function that performs the following operations on a list of integers: 1. Traverse the list and for each integer, if it is divisible by 3, replace it with integer and string \\"Fizz\\", and if it is divisible by 5, replace it with integer and string \\"Buzz\\". 2. If the integer is divisible by both 3 and 5, replace it with integer and string \\"FizzBuzz\\". 3. If none of these conditions are met, the integer remains unchanged. - **Input** - `sequence` (list): A list of integers. - **Output** - Returns a transformed list according to the rules specified. - **Constraints** - Elements in `sequence` are integers. - The list `sequence` should not be empty. - **Examples** ```python assert play_number_game([1, 3, 5, 15, 16]) == [1, \\"3 Fizz\\", \\"5 Buzz\\", \\"15 FizzBuzz\\", 16] assert play_number_game([10, 6, 9, 12, 25]) == [\\"10 Buzz\\", \\"6 Fizz\\", \\"9 Fizz\\", \\"12 Fizz\\", \\"25 Buzz\\"] ``` Notes - Ensure that the solution handles edge cases such as very large lists and integers. - Focus on clarity and efficiency of the transformation logic. - Strings should be formatted with integer followed by either \\"Fizz\\", \\"Buzz\\", or \\"FizzBuzz\\" (e.g., \\"3 Fizz\\"). Implement this function carefully to correctly handle all specified transformations and edge cases efficiently.","solution":"def play_number_game(sequence): Transforms the sequence of integers based on the given rules. If an integer is divisible by 3, replace it with \'integer Fizz\'. If it is divisible by 5, replace it with \'integer Buzz\'. If it is divisible by both 3 and 5, replace it with \'integer FizzBuzz\'. Args: sequence (list): A list of integers. Returns: list: A transformed list according to the rules specified. result = [] for num in sequence: if num % 3 == 0 and num % 5 == 0: result.append(f\\"{num} FizzBuzz\\") elif num % 3 == 0: result.append(f\\"{num} Fizz\\") elif num % 5 == 0: result.append(f\\"{num} Buzz\\") else: result.append(num) return result"},{"question":"# Implement and Test a Priority Queue You are tasked with constructing a priority queue using a binary heap and then validating its functionality via unit tests. A priority queue should support insertion of elements and extraction of the highest priority element efficiently. In this context, priorities are represented by integer values, with higher integers denoting higher priorities. Task Requirements 1. **Class Implementation**: - Create a `PriorityQueue` class using a binary heap to manage elements. - Implement methods for insertion (`insert`), extraction of the highest priority (`extract_max`), and getting the maximum element without extraction (`peek_max`). 2. **Unit Tests**: - Design and implement a suite of unit tests to verify the correctness of the `PriorityQueue` class. - Ensure to cover scenarios including insertion, extraction, peeking, and edge cases (e.g., operations on an empty queue). Function Signatures You should implement the following class with methods: 1. `class PriorityQueue: def __init__(self) -> None` 2. `def insert(self, element: int) -> None` 3. `def extract_max(self) -> int` 4. `def peek_max(self) -> int` Additionally, implement the following test function: 5. `def run_tests() -> None` Example ```python class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element: int): self.heap.append(element) self._heapify_up(len(self.heap) - 1) def extract_max(self) -> int: if not self.heap: raise IndexError(\'Extract from empty priority queue\') max_element = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return max_element def peek_max(self) -> int: if not self.heap: raise IndexError(\'Peek from empty priority queue\') return self.heap[0] def _heapify_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] > self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._heapify_up(parent) def _heapify_down(self, index): largest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] > self.heap[largest]: largest = left if right < len(self.heap) and self.heap[right] > self.heap[largest]: largest = right if largest != index: self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index] self._heapify_down(largest) def run_tests(): pq = PriorityQueue() # Test insertion and peek_max pq.insert(10) assert pq.peek_max() == 10, \'Test Failed: peek_max should return 10 after one insertion\' pq.insert(20) assert pq.peek_max() == 20, \'Test Failed: peek_max should return 20 after inserting a higher value\' pq.insert(5) assert pq.peek_max() == 20, \'Test Failed: peek_max should still be 20 after inserting a lower value\' # Test extract_max max_element = pq.extract_max() assert max_element == 20, \'Test Failed: extract_max should return 20 as it is the highest priority\' assert pq.peek_max() == 10, \'Test Failed: peek_max should return 10 after extracting the highest priority\' # Test edge cases pq.extract_max() pq.extract_max() try: pq.peek_max() assert False, \'Test Failed: peek_max on empty priority queue did not raise an IndexError\' except IndexError: pass # Expected behavior try: pq.extract_max() assert False, \'Test Failed: extract_max on empty priority queue did not raise an IndexError\' except IndexError: pass # Expected behavior print(\\"All tests passed!\\") if __name__ == \\"__main__\\": run_tests() ``` Constraints - Ensure optimal time complexity: insertions and extractions must be (O(log n)) on average. - Properly handle attempts to peek or extract from an empty priority queue by raising `IndexError`. - The unit tests must comprehensively cover various scenarios and edge cases. This new question integrates seamlessly with the provided one by maintaining a similar style, complexity, and focus on core programming concepts involving data structures and algorithms.","solution":"class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element: int): self.heap.append(element) self._heapify_up(len(self.heap) - 1) def extract_max(self) -> int: if not self.heap: raise IndexError(\'Extract from empty priority queue\') max_element = self.heap[0] if len(self.heap) > 1: self.heap[0] = self.heap.pop() self._heapify_down(0) else: self.heap.pop() return max_element def peek_max(self) -> int: if not self.heap: raise IndexError(\'Peek from empty priority queue\') return self.heap[0] def _heapify_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] > self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._heapify_up(parent) def _heapify_down(self, index): largest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] > self.heap[largest]: largest = left if right < len(self.heap) and self.heap[right] > self.heap[largest]: largest = right if largest != index: self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index] self._heapify_down(largest)"},{"question":"# Coding Assessment Question **Scenario**: During a project, you encountered a requirement to determine if there is a path that runs through a specific set of points on a 2D grid. While researching pathfinding algorithms, you came across the Depth-First Search (DFS) algorithm. It is useful to gain insights into graph traversal techniques. **Problem Statement**: Implement a function `is_path_exists()` that checks if there exists a path from the top-left corner to the bottom-right corner of a 2D grid. The grid contains open cells (\'0\') and blocked cells (\'1\'). You can move up, down, left, or right, but not diagonally. Function Signature ```python def is_path_exists(grid: list[list[str]]) -> bool: # Implementation here ``` Input & Output Formats - **Input**: A 2D list `grid` where each element is either \'0\' (open cell) or \'1\' (blocked cell). The grid size is ( n times m ) where (1 leq n, m leq 100). - **Output**: A boolean value `True` if there is a path from the top-left corner to the bottom-right corner, otherwise `False`. Constraints - You start at cell (0, 0) and aim to reach cell (n-1, m-1). - The function must use the Depth-First Search (DFS) algorithm. - Proper handling of edge cases is critical. Examples ```python >>> is_path_exists([ [\\"0\\", \\"0\\", \\"1\\", \\"0\\"], [\\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\"], [\\"1\\", \\"0\\", \\"0\\", \\"0\\"] ]) True >>> is_path_exists([ [\\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\"], [\\"1\\", \\"0\\", \\"0\\"] ]) False >>> is_path_exists([[\\"0\\"]]) True >>> is_path_exists([[\\"1\\"]]) False >>> is_path_exists([ [\\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"] ]) True ``` **Note**: Ensure your implementation handles the given edge cases effectively, such as when the start or end points are blocked.","solution":"def is_path_exists(grid): This function checks if there is a path from the top-left corner to the bottom-right corner of a 2D grid using Depth-First Search (DFS) algorithm. rows, cols = len(grid), len(grid[0]) if grid[0][0] == \'1\' or grid[rows-1][cols-1] == \'1\': return False def dfs(x, y): # If out of bounds or cell is blocked or already visited if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] == \'1\': return False # If reach the bottom-right corner if x == rows-1 and y == cols-1: return True # Mark the cell as visited grid[x][y] = \'1\' # Explore all four possible directions if dfs(x+1, y) or dfs(x-1, y) or dfs(x, y+1) or dfs(x, y-1): return True # Unmark the cell if no path found (important if we backtrack) grid[x][y] = \'0\' return False return dfs(0, 0)"},{"question":"# Validating Tic-Tac-Toe End States You are tasked with writing a function to validate the end states of a Tic-Tac-Toe game. The board is a 3x3 grid, and players take turns marking cells in the grid with \'X\' or \'O\'. Your function should determine if a given game board is a valid and complete state, which means either player \'X\' or \'O\' has won or the board is completely filled with no empty cells (indicated by \'.\') remaining. # Requirements: 1. **Implement `is_valid_tictactoe_end_state` method**: This method should check if the given board represents a valid end state. 2. **Check winning conditions**: A player wins if they have marked three consecutive cells in a row, column, or diagonal with their symbol (\'X\' or \'O\'). 3. **Check player turns\' count**: Ensure that the number of \'X\' marks is either equal to or one more than the number of \'O\' marks. # Input: A list of nine characters representing the Tic-Tac-Toe board in row-major order. Each character is either \'X\', \'O\', or \'.\' (representing an empty cell). # Output: A boolean value: `True` if the given board is a valid end state, `False` otherwise. # Constraints: - The input list always contains exactly nine characters. - Each character in the input list belongs to the set {\'X\', \'O\', \'.\'}. # Example: ```python def is_valid_tictactoe_end_state(board: List[str]) -> bool: # Your code here # Example 1: print(is_valid_tictactoe_end_state([\'X\', \'O\', \'X\', \'X\', \'O\', \'.\', \'O\', \'X\', \'O\'])) # Output: True # Example 2: print(is_valid_tictactoe_end_state([\'X\', \'X\', \'X\', \'O\', \'O\', \'.\', \'.\', \'.\', \'.\'])) # Output: True # Example 3: print(is_valid_tictactoe_end_state([\'X\', \'X\', \'X\', \'O\', \'X\', \'.\', \'O\', \'O\', \'O\'])) # Output: False ``` Use the provided function signature and extend its functionality. Ensure your implementation is efficient and handles edge cases properly.","solution":"from typing import List def is_valid_tictactoe_end_state(board: List[str]) -> bool: # Function to check if a list of three cells is a winning line def is_winning_line(line): return line[0] == line[1] == line[2] and line[0] in {\'X\', \'O\'} # Function to count the occurrences of \'X\' and \'O\' on the board def count_symbols(board): x_count = board.count(\'X\') o_count = board.count(\'O\') return x_count, o_count # Check for winning combinations def check_wins(board): winning_lines = [ board[0:3], # Top row board[3:6], # Middle row board[6:9], # Bottom row board[0::3], # Left column board[1::3], # Middle column board[2::3], # Right column board[0::4], # Main diagonal board[2:7:2] # Anti-diagonal ] x_wins = any(is_winning_line(line) and line[0] == \'X\' for line in winning_lines) o_wins = any(is_winning_line(line) and line[0] == \'O\' for line in winning_lines) return x_wins, o_wins # Count \'X\' and \'O\' x_count, o_count = count_symbols(board) # Number of \'X\' marks must be equal to or one more than number of \'O\' marks if x_count != o_count and x_count != o_count + 1: return False # Check for wins x_wins, o_wins = check_wins(board) # Both players cannot win simultaneously if x_wins and o_wins: return False # If \'X\' wins, the counts should be such that \'X\' has one more turn than \'O\' if x_wins and x_count != o_count + 1: return False # If \'O\' wins, the counts should be such that \'X\' has the same number of turns as \'O\' if o_wins and x_count != o_count: return False return True"},{"question":"# Roman Numeral Converter **Objective**: Write a function to convert an integer to its corresponding Roman numeral representation. **Scenario**: You are working on a historical text analysis project that involves converting modern integers into Roman numerals for use in various sections of the software. Roman numerals are represented by combinations of the following symbols: `I, V, X, L, C, D, M`. **Function Signature**: ```python def int_to_roman(num: int) -> str: pass ``` **Input**: - `num` (int): An integer between 1 and 3999 inclusive. **Output**: - Returns a string representing the Roman numeral form of the given integer. **Constraints**: - The input integer `num` will always be within the range from 1 to 3999. - The Roman numeral output should follow standard conventions (e.g., 4 is represented as \\"IV\\" rather than \\"IIII\\"). **Example**: ```python assert int_to_roman(58) == \\"LVIII\\" # 50 + 5 + 3 assert int_to_roman(1994) == \\"MCMXCIV\\" # 1000 + 900 + 90 + 4 assert int_to_roman(2021) == \\"MMXXI\\" # 1000 + 1000 + 10 + 10 + 1 ``` **Guidelines**: - Implement the function using a series of if-elif conditions to match different numeric ranges to their corresponding Roman numeral symbols. - Optimize for readability and maintainability by clearly defining the Roman numeral values and their subtractive combinations (e.g., IV, IX, etc.). **Performance**: - Aim for an O(1) time complexity, as the conversion requires a fixed number of operations irrespective of the input size.","solution":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. The Roman numeral representation follows these values: - M = 1000 - CM = 900 - D = 500 - CD = 400 - C = 100 - XC = 90 - L = 50 - XL = 40 - X = 10 - IX = 9 - V = 5 - IV = 4 - I = 1 val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] symbols = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = [] for i in range(len(val)): while num >= val[i]: num -= val[i] roman_numeral.append(symbols[i]) return \\"\\".join(roman_numeral)"},{"question":"String Compression Algorithm Task # Objective You are tasked with implementing an algorithm to compress a string using the counts of repeated characters. The goal is to shorten the input string by indicating the number of consecutive occurrences of each character. # Problem Statement Write a function `compress_string(input_string: str) -> str` to compress a given string such that consecutive occurrences of the same character are reduced to the character followed by the number of times it appears consecutively. # Implementation Details 1. **Input**: A single string consisting of uppercase and lowercase English letters. 2. **Output**: A compressed string that represents the original string. # Function Signature ```python def compress_string(input_string: str) -> str: pass ``` # Constraints 1. The input string consists of uppercase and lowercase English letters only. 2. The compressed string should only use the counts of characters if doing so shortens the length of the string. 3. If the compressed string is not shorter than the original, the function should return the original string. # Example ```python example1 = \\"aabcccccaaa\\" example2 = \\"abcdef\\" assert compress_string(example1) == \\"a2b1c5a3\\" assert compress_string(example2) == \\"abcdef\\" ``` # Description The function `compress_string` should perform the following operations: 1. Iterate through the input string, identifying consecutive sequences of the same character. 2. Append the character and its count to a result string. 3. If the resulting compressed string is longer than the original string, return the original string instead. # Notes - Consider edge cases such as an empty string input, single character strings, and strings with no consecutive characters. - Ensure that your implementation is efficient and concise. Your implementation will be tested with various input strings to ensure correct compression and efficient performance.","solution":"def compress_string(input_string: str) -> str: if not input_string: return input_string compressed_string = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed_string.append(input_string[i - 1] + str(count)) count = 1 compressed_string.append(input_string[-1] + str(count)) compressed_result = \'\'.join(compressed_string) return compressed_result if len(compressed_result) < len(input_string) else input_string"},{"question":"# Scenario You are working as a software engineer at a company that handles large datasets for statistical analysis. You\'ve been tasked with implementing a function that identifies the top `k` frequently occurring elements in a list. This functionality will be integrated into the company\'s data processing pipeline to quickly sift through millions of entries. # Coding Task Implement a function `top_k_frequent` that finds the `k` most frequently occurring elements in the list. You should ensure that the solution is efficient and handles large inputs gracefully. # Constraints 1. **Inputs**: - `nums`: List of integers, length of the list is between 1 and 10^6. - `k`: Integer such that 1 ≤ k ≤ the number of unique elements in the list. 2. **Outputs**: - Return the result as a list of integers. 3. **Performance**: - Ensure the solution runs efficiently for large datasets. # Example ```python def top_k_frequent(nums: list, k: int) -> list: # implementation required here assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2] assert top_k_frequent([1], 1) == [1] assert top_k_frequent([4, 5, 1, 6, 1, 5, 1, 4, 5, 5], 3) == [5, 1, 4] assert top_k_frequent([1, 2, 3, 4, 4, 4, 5, 5, 5, 5], 2) == [5, 4] ``` # Additional Requirements 1. **Handling Ties**: If there are ties, any order of the tied values is acceptable in the output. 2. Ensure efficient use of data structures to minimize time complexity, such as using hashmaps for counting frequencies and heaps for selecting the top `k` elements. 3. Write clean and well-documented code to help future developers understand the logic.","solution":"from collections import Counter import heapq def top_k_frequent(nums, k): Returns the top k most frequent elements in the list nums. Args: nums (list of int): List of integers where we need to find the most frequent elements. k (int): Number of top frequent elements to return. Returns: list of int: List of top k frequent elements. # Count the frequency of each element in nums count = Counter(nums) # Use a heap to find the top k elements return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"# Coding Assessment Question Context You are given a 2-dimensional grid representing a map where each cell can either be land (`1`) or water (`0`). An island is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Your objective is to calculate the size of the largest island on the map. Task Write a function `largest_island(grid: List[List[int]]) -> int` that returns the size of the largest island in the given grid. Input Format * `grid`: A 2D list of shape `N x M`, where each element is either `0` (water) or `1` (land). Output Format * Return an integer representing the size of the largest island (the number of `1`s connected). Constraints * The grid dimensions `N` (number of rows) and `M` (number of columns) will both be at least 1 and at most 1,000. * The grid will not be empty. Example ```python grid = [ [0, 1, 0, 0, 1], [1, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 1, 1, 0] ] print(largest_island(grid)) # Output: 4 ``` Performance Requirements * The solution should efficiently handle the provided constraints, ideally with a complexity close to O(N*M). Edge Cases to Consider * Grid with no land. * Grid with only one cell being land. * Irregularly shaped islands.","solution":"from typing import List def largest_island(grid: List[List[int]]) -> int: def dfs(grid, row, col, visited): if ( row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0 or visited[row][col] ): return 0 visited[row][col] = True size = 1 # Counting the current cell # Explore all adjacent cells size += dfs(grid, row + 1, col, visited) size += dfs(grid, row - 1, col, visited) size += dfs(grid, row, col + 1, visited) size += dfs(grid, row, col - 1, visited) return size rows = len(grid) cols = len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] max_size = 0 for row in range(rows): for col in range(cols): if grid[row][col] == 1 and not visited[row][col]: island_size = dfs(grid, row, col, visited) max_size = max(max_size, island_size) return max_size"},{"question":"# Order Statistics Implementation Challenge Problem Statement You are tasked with implementing an algorithm to find the k-th smallest element in an unsorted array using the median of medians method to achieve linear time complexity. Your implementation should handle various edge cases and ensure robust performance. Function Specifications ```python def kth_smallest(arr: list, k: int) -> int: Implements the median of medians method to find the k-th smallest element in the array. :param arr: List of integers :param k: An integer representing the position of the smallest element to find (1-based index) :return: The k-th smallest element in the array :raises ValueError: If k is out of the bounds of the array pass # To be implemented by the student ``` Input and Output * **Input**: A list of integers `arr` and an integer `k` representing the 1-based index of the smallest element to find. * **Output**: An integer representing the k-th smallest element in the list. Constraints * The list `arr` can contain duplicates. * The value of `k` is such that ( 1 le k le text{len}(arr) ). Example ```python >>> kth_smallest([3, 6, 2, 7, 5, 1, 4], 4) 4 ``` Edge Cases 1. `k` is less than 1 or greater than the length of the array. 2. The array contains duplicate elements. 3. The array is empty or has a single element. Notes 1. Ensure your program handles edge cases gracefully and provides meaningful error messages when necessary. 2. Test your function with various input sizes and values for `k` to ensure reliability. 3. Use the median of medians method to achieve optimal performance for finding the k-th smallest element, especially on larger arrays.","solution":"def partition(arr, low, high, pivot_index): pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def median_of_medians(arr, low, high): n = high - low + 1 if n < 10: sorted_arr = sorted(arr[low:high+1]) return sorted_arr[n // 2] medians = [] for i in range(low, high+1, 5): group = arr[i:i+5] sorted_group = sorted(group) medians.append(sorted_group[len(sorted_group) // 2]) median_of_medians_value = median_of_medians(medians, 0, len(medians) - 1) return median_of_medians_value def select(arr, low, high, k): while low <= high: pivot_index = low if high - low + 1 > 5: pivot_index = arr.index(median_of_medians(arr, low, high)) pivot_index = partition(arr, low, high, pivot_index) if pivot_index == k: return arr[pivot_index] elif pivot_index > k: high = pivot_index - 1 else: low = pivot_index + 1 def kth_smallest(arr, k): if k < 1 or k > len(arr): raise ValueError(\\"k is out of the bounds of the array\\") return select(arr, 0, len(arr) - 1, k - 1)"},{"question":"# Unique Elements in List Problem Statement Implement a function named `unique_elements` that takes a list of integers and returns a new list containing only the unique elements from the original list, preserving their first occurrence order. Input * A list of integers `input_list`. Output * A list of integers representing the unique elements from the input list, in the order of their first appearance. Function Signature ```python def unique_elements(input_list: list) -> list: pass ``` Constraints * The list can contain any integer, including negative values. * The function should handle lists of length 0 up to 10^4. * The order of elements in the returned list must match their first occurrence in the input list. # Example ```python >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([4, 4, 4, 4]) [4] >>> unique_elements([1, -1, 1, -1, 2]) [1, -1, 2] >>> unique_elements([]) [] >>> unique_elements([1]) [1] ``` Notes * Do not use collections like `set` or `dict` which automatically manage unique elements but do not preserve the order of first occurrence. * Ensure that the function respects the constraints and handles all edge cases, including empty lists and lists containing only duplicate values.","solution":"def unique_elements(input_list: list) -> list: Returns a list of unique elements in the input list, preserving the order of first appearance. seen = set() unique = [] for item in input_list: if item not in seen: unique.append(item) seen.add(item) return unique"},{"question":"# Coding Challenge: Book Recommendations and Reviews Aggregator Your task is to develop a Python script that aggregates book information and user reviews from two APIs: Google Books API and Goodreads API. You are to implement error handling and data aggregation, ensuring a robust response even in cases of partial API failures. Function Signature ```python def get_book_info(isbn: str) -> dict: Fetch book information and user reviews from Google Books API and Goodreads API for a given ISBN. Args: isbn (str): The International Standard Book Number (ISBN) of the book. Returns: dict: Aggregated book information and reviews or an error message in case of an issue. ``` # Instructions 1. **API Responses Integration**: - Retrieve book information and user reviews using the provided API keys (assume the keys are defined as constants in the script). - Assemble the response data into a single dictionary that includes the source of each piece of data. 2. **Error Handling**: - Implement robust error handling to manage scenarios where one or both APIs fail to return data. - Include meaningful error messages for different failure cases: - If no API keys are provided. - Invalid ISBN format. - Network issues / API timeouts. - Partial data retrieval (one API succeeds, another fails). 3. **Optimization**: - Minimize the impact of network latency by handling API requests in parallel. - Add retry logic for transient network issues or API rate-limit errors. 4. **Edge Cases**: - Ensure correct handling when the ISBN is invalid or the APIs return no data. 5. **Testing**: - Write tests covering various scenarios, including valid and invalid ISBNs, network failures, and scenarios where only one API returns valid data. # Constraints - Assume that you have valid API keys for both Google Books API and Goodreads API. - Use Python\'s `requests` library for making HTTP GET requests. ```python import requests import concurrent.futures # Put your API key(s) here GOOGLE_BOOKS_API_KEY = \\"your_google_books_api_key\\" GOODREADS_API_KEY = \\"your_goodreads_api_key\\" GOOGLE_BOOKS_URL_BASE = \\"https://www.googleapis.com/books/v1/volumes\\" GOODREADS_URL_BASE = \\"https://www.goodreads.com/book/isbn\\" def get_book_info(isbn: str) -> dict: # Your implementation here pass if __name__ == \\"__main__\\": from pprint import pprint isbn = input(\\"Enter an ISBN: \\").strip() if isbn: try: book_data = get_book_info(isbn) pprint(book_data) except Exception as e: print(f\\"Error: {e}\\") ``` # Example ```python >>> get_book_info(\\"9780143127741\\") { \\"GoogleBooks\\": { \\"title\\": \\"The Martian\\", \\"authors\\": [\\"Andy Weir\\"], \\"description\\": \\"A novel about an astronaut stranded on Mars.\\" }, \\"Goodreads\\": { \\"average_rating\\": 4.41, \\"reviews\\": [ {\\"user\\": \\"John Doe\\", \\"review\\": \\"Amazing book!\\"}, {\\"user\\": \\"Jane Smith\\", \\"review\\": \\"Couldn\'t put it down.\\"} ] } } ``` Ensure your function handles the specified requirements and runs efficiently.","solution":"import requests import concurrent.futures # Put your API key(s) here GOOGLE_BOOKS_API_KEY = \\"your_google_books_api_key\\" GOODREADS_API_KEY = \\"your_goodreads_api_key\\" GOOGLE_BOOKS_URL_BASE = \\"https://www.googleapis.com/books/v1/volumes\\" GOODREADS_URL_BASE = \\"https://www.goodreads.com/book/isbn\\" def fetch_google_books_data(isbn): try: response = requests.get(f\\"{GOOGLE_BOOKS_URL_BASE}?q=isbn:{isbn}&key={GOOGLE_BOOKS_API_KEY}\\") response.raise_for_status() data = response.json() if \'items\' in data and len(data[\'items\']) > 0: book_info = data[\'items\'][0][\'volumeInfo\'] return { \'title\': book_info.get(\'title\'), \'authors\': book_info.get(\'authors\'), \'description\': book_info.get(\'description\') } return None except Exception as e: return {\\"error\\": str(e)} def fetch_goodreads_data(isbn): try: response = requests.get(f\\"{GOODREADS_URL_BASE}?format=json&isbn={isbn}&key={GOODREADS_API_KEY}\\") response.raise_for_status() data = response.json() return { \'average_rating\': data.get(\'average_rating\'), \'reviews\': data.get(\'reviews\') } except Exception as e: return {\\"error\\": str(e)} def get_book_info(isbn: str) -> dict: if not isbn: return {\\"error\\": \\"Invalid ISBN format\\"} with concurrent.futures.ThreadPoolExecutor() as executor: future_google = executor.submit(fetch_google_books_data, isbn) future_goodreads = executor.submit(fetch_goodreads_data, isbn) google_data = future_google.result() goodreads_data = future_goodreads.result() result = { \\"GoogleBooks\\": google_data, \\"Goodreads\\": goodreads_data } return result"},{"question":"# Problem: Efficient Water Trap Calculation You are given an array `height[]` of non-negative integers where each element represents the height of a column of water. The task is to design an algorithm that computes the maximum amount of water that can be trapped after it rains. # Function Signature ```python def trap_water(height: List[int]) -> int: ``` # Input * A list `height` of non-negative integers representing the height map (0 ≤ len(height) ≤ 100000, 0 ≤ height[i] ≤ 10000). # Output * Return a single integer: the total amount of water that can be trapped. # Examples ```python >>> trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_water([4,2,0,3,2,5]) 9 >>> trap_water([0,0,0,0,0]) 0 ``` # Constraints * Aim for a linear time complexity solution if possible. * Consider both space efficiency and time efficiency in your algorithm design. # Hints 1. Utilize two-pointer technique to keep track of the water level from both ends of the list. 2. The trapped water at each index is determined by the minimum of the highest blocks on the left and right, minus the height at that index. 3. Adjust pointers based on the comparative height of the blocks at current pointers to ensure all potential water traps are accounted for. # Notes * Focus on the core logic required to calculate the maximum water trapped. * This problem requires careful management of indices and conditions to ensure all water trapping scenarios are handled correctly.","solution":"from typing import List def trap_water(height: List[int]) -> int: This function computes the maximum amount of water that can be trapped given a list of column heights. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) trapped_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) trapped_water += max(0, right_max - height[right]) return trapped_water"},{"question":"# Question: Implement Custom Matrix Multiplication Matrix multiplication is a fundamental operation in various computational fields. Your task is to implement matrix multiplication with customized partition sizes for block multiplication. # Objective: Write a function `custom_matrix_multiplication(matrix_a, matrix_b, block_size)` that multiplies two input matrices `matrix_a` and `matrix_b` using block multiplication with a specified `block_size`. # Input: * `matrix_a`: A list of lists representing matrix A with dimensions `m x n`. * `matrix_b`: A list of lists representing matrix B with dimensions `n x k`. * `block_size`: An integer that determines the size of the blocks used for matrix multiplication (e.g., `2`). # Output: * The function should return a new matrix that is the result of multiplying `matrix_a` by `matrix_b`. # Constraints: * The dimensions of the matrices will be such that `m, n, k` are between `1` and `500`. * The elements of the matrices will be integers between `-10^2` and `10^2`. * The `block_size` will be a positive integer and usually a divisor of `n`. # Performance Requirements: * The time complexity should be approximately O(m * n * k). * The space complexity should be O(m * k). # Example: ```python def custom_matrix_multiplication(matrix_a, matrix_b, block_size): pass # Example usage matrix_a = [ [1, 4], [2, 5] ] matrix_b = [ [3, 6], [4, 5] ] block_size = 1 print(custom_matrix_multiplication(matrix_a, matrix_b, block_size)) # Output: [[19, 26], [26, 37]] ``` # Solution Requirements: 1. Your implementation must use block matrix multiplication as described. 2. Implement helper functions for block multiplication and matrix partitioning. 3. Ensure the final implementation handles all edge cases efficiently. 4. Include thorough test cases in your code to demonstrate the correctness and efficiency of your solution. # Additional Context (Optional): Block matrix multiplication is advantageous in optimizing memory access patterns, especially for large matrices, and can be effectively utilized in high-performance computing applications. The `block_size` parameter allows for better cache utilization and improved performance.","solution":"def custom_matrix_multiplication(matrix_a, matrix_b, block_size): Multiplies two matrices matrix_a and matrix_b using block multiplication with a given block_size. # Get matrix dimensions m = len(matrix_a) n = len(matrix_a[0]) k = len(matrix_b[0]) # Initialize the result matrix with zeros matrix_c = [[0 for _ in range(k)] for _ in range(m)] # Perform block matrix multiplication for i in range(0, m, block_size): for j in range(0, k, block_size): for p in range(0, n, block_size): for ii in range(i, min(i + block_size, m)): for jj in range(j, min(j + block_size, k)): for pp in range(p, min(p + block_size, n)): matrix_c[ii][jj] += matrix_a[ii][pp] * matrix_b[pp][jj] return matrix_c"},{"question":"# Problem Statement You are tasked with implementing a **Queue** data structure using a circular buffer (fixed-size array). You must also ensure that all operations are performed efficiently. # Requirements 1. **Implementation Details**: - The queue should be implemented as a class `CircularQueue` using a fixed-size list (array). - The queue should have attributes for `max_size`, `front`, `rear`, and `size`. - The `front` attribute should track the index of the first element. - The `rear` attribute should track the index of the next position where an element can be added. - The `size` attribute should track the number of elements currently in the queue. 2. **Functional Requirements**: Implement the following methods: - `__init__(self, capacity: int) -> None`: Initializes the queue with a fixed capacity. - `enqueue(self, data: T) -> bool`: Adds an element to the rear of the queue. Returns `True` if successful, or `False` if the queue is full. - `dequeue(self) -> T | None`: Removes and returns the element from the front of the queue. Returns `None` if the queue is empty. - `peek(self) -> T | None`: Returns the element at the front of the queue without removing it. Returns `None` if the queue is empty. - `is_empty(self) -> bool`: Returns `True` if the queue is empty, `False` otherwise. - `is_full(self) -> bool`: Returns `True` if the queue is full, `False` otherwise. - `__len__(self) -> int`: Returns the number of elements in the queue. # Input/Output Formats - The `__init__` method should accept an integer `capacity`. - The `enqueue` method should accept a data element of any type `T`. - The `dequeue` and `peek` methods should return an element of type `T` or `None` if the queue is empty. - The `is_empty` and `is_full` methods should return a boolean value. - The `__len__` method should return an integer representing the number of elements in the queue. # Constraints - The queue should handle all operations in constant time O(1). - The capacity of the queue will be a positive integer. - Carefully manage the circular nature of the buffer to ensure efficient use of the array. # Example Usage ```python queue = CircularQueue(5) print(queue.is_empty()) # Output: True print(queue.is_full()) # Output: False queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(len(queue)) # Output: 3 print(queue.peek()) # Output: 1 print(queue.dequeue()) # Output: 1 print(len(queue)) # Output: 2 print(queue.is_empty()) # Output: False print(queue.is_full()) # Output: False queue.enqueue(4) queue.enqueue(5) queue.enqueue(6) print(queue.is_full()) # Output: True print(queue.enqueue(7)) # Output: False ``` # Additional Notes - You may assume any necessary imports and class definitions are provided. - The `__init__` method should initialize the queue with specified capacity and appropriate attributes. - Consider edge cases such as attempts to dequeue from an empty queue or enqueue into a full queue. - Ensure functions handle the circular behavior of the buffer appropriately.","solution":"class CircularQueue: def __init__(self, capacity: int) -> None: self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, data) -> bool: if self.is_full(): return False self.queue[self.rear] = data self.rear = (self.rear + 1) % self.capacity self.size += 1 return True def dequeue(self): if self.is_empty(): return None data = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return data def peek(self): if self.is_empty(): return None return self.queue[self.front] def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity def __len__(self) -> int: return self.size"},{"question":"# Problem Statement You are tasked with implementing a function that finds the first repeated character in a given string. The function should return the first character that appears more than once in the string. If there are no repeated characters, the function should return `None`. # Function Signature ```python def first_repeated_char(s: str) -> str: ``` # Input * A single string `s`. # Output * The first character in the string that appears more than once, or `None` if there are no repeated characters. # Constraints * The input string can be of any length (including empty string). * The input string consists of printable ASCII characters. # Examples ```python first_repeated_char(\\"hello\\") => \'l\' first_repeated_char(\\"swiss\\") => \'s\' first_repeated_char(\\"example\\") => \'e\' first_repeated_char(\\"abcdef\\") => None first_repeated_char(\\"\\") => None first_repeated_char(\\"abba\\") => \'b\' ``` # Additional Information * Handle edge cases such as the empty string and strings with no repeated characters efficiently. * Consider the performance of your solution, especially for long strings. # Implementation Challenge Ensure that your function handles all the constraints effectively and returns the correct output for various edge cases. Provide comments or documentation to explain your approach and how it efficiently identifies the first repeated character in the string.","solution":"def first_repeated_char(s: str) -> str: Returns the first character that appears more than once in the string s. If no such character exists, returns None. seen = set() for char in s: if char in seen: return char seen.add(char) return None"},{"question":"Coding Assessment Question You are assigned to create a system for managing configurations in a scalable web application. You need to design a function to update configuration settings stored in a JSON file while ensuring data integrity and providing rollback capability in case of any errors. # Function Signature ```python def update_config(config_file: str, settings: dict) -> bool: ``` # Objective Modify the provided `update_json_config` function to create `update_config` that: 1. Takes `config_file` and `settings` as parameters. 2. Reads the current configuration from a JSON file. 3. Updates the configuration with the provided `settings`. 4. Implements rollback to the original configuration in case of any errors during the update process. 5. Returns `True` if the update is successful; otherwise, returns `False`. # Input/Output Format * **Input**: * `config_file` (str): The path to the JSON configuration file. * `settings` (dict): A dictionary containing the new settings to be updated in the configuration file. * **Output**: * `True` if the update is successful; otherwise, `False`. # Constraints * Ensure that the configuration file is valid JSON both before and after the update. * Rollback to the original configuration if any error occurs during the update process. * Handle file I/O errors and JSON encoding/decoding errors gracefully. # Context This function will be part of a larger configuration management system where settings can be dynamically updated. Reliable error handling and rollback mechanisms are essential to prevent configurations from becoming corrupt during updates. # Performance Requirements * Efficiently manage file reads and writes to minimize potential data corruption during the update process. * Ensure the function handles large configuration files effectively without significant performance degradation. # Implementation Notes * Use the `json` module for reading and writing JSON data. * Consider using file operations such as temporary files or backup files to facilitate rollback. * Properly handle exceptions to ensure the system remains robust. Design and implement the `update_config` function based on the above requirements.","solution":"import json import os import shutil def update_config(config_file: str, settings: dict) -> bool: Update the configuration settings stored in a JSON file while ensuring data integrity and providing rollback capability in case of any errors. Args: - config_file (str): The path to the JSON configuration file. - settings (dict): A dictionary containing the new settings to be updated in the configuration file. Returns: - bool: True if the update is successful, False otherwise. backup_file = config_file + \\".bak\\" try: # Create a backup of the original configuration file shutil.copy2(config_file, backup_file) # Read the current configuration from the file with open(config_file, \'r\') as file: config = json.load(file) # Update the configuration with the new settings config.update(settings) # Write the updated configuration back to the file with open(config_file, \'w\') as file: json.dump(config, file, indent=4) return True except (IOError, json.JSONDecodeError) as e: # If any error occurs, restore the original configuration file from the backup if os.path.exists(backup_file): shutil.copy2(backup_file, config_file) return False finally: # Clean up the backup file if os.path.exists(backup_file): os.remove(backup_file)"},{"question":"# Context You are given a binary tree and need to navigate and manipulate the tree to perform specific tasks efficiently. This requires a strong understanding of data structures, particularly trees, and involves efficient traversal and manipulation techniques. # Problem Statement Given the root of a binary tree, write a function `max_sum_path(root: Optional[TreeNode]) -> List[int]` that returns the path with the maximum sum of node values from the root to a leaf node. If there are multiple paths with the same maximum sum, return any of them. # Input * `root` - The root of the binary tree. The tree nodes follow the class definition `TreeNode(val=0, left=None, right=None)`, where `val` is the value of the node, and `left` and `right` are references to the left and right child nodes, respectively. # Output * Returns a list of integers representing the path with the maximum sum from the root to a leaf node. # Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * The value of each node is an integer in the range `[-10^4, 10^4]`. # Example ```python # Given binary tree: # 10 # / # 5 15 # / # 3 8 20 # Represented as: root = TreeNode( val=10, left=TreeNode( val=5, left=TreeNode(val=3), right=TreeNode(val=8) ), right=TreeNode( val=15, right=TreeNode(val=20) ) ) print(max_sum_path(root)) # Output: [10, 15, 20] # Given binary tree: # 1 # / # 2 3 # Represented as: root = TreeNode( val=1, left=TreeNode(val=2), right=TreeNode(val=3) ) print(max_sum_path(root)) # Output: [1, 3] or [1, 2] ``` # Function Signature ```python def max_sum_path(root: Optional[TreeNode]) -> List[int]: pass ``` # Hints 1. Consider using a depth-first search (DFS) approach to explore all paths from the root to the leaf nodes. 2. Keep track of the current path and its sum during traversal, updating the maximum sum path when a higher sum is found. 3. Ensure to handle edge cases, such as when the tree is empty.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_path(root: Optional[TreeNode]) -> List[int]: if not root: return [] def dfs(node): if not node: return (0, []) if not node.left and not node.right: return (node.val, [node.val]) left_sum, left_path = dfs(node.left) right_sum, right_path = dfs(node.right) if left_sum > right_sum: return (node.val + left_sum, [node.val] + left_path) else: return (node.val + right_sum, [node.val] + right_path) _, max_path = dfs(root) return max_path"},{"question":"# Financial Transaction Anomaly Detector You are tasked with developing a function to detect anomalies in financial transaction logs. An anomaly is defined as any transaction amount that exceeds a specified threshold compared to the average of previous transactions. # Objective: Write a function `detect_anomalies(transactions: List[int], threshold: float) -> List[bool]` that takes a list of transaction amounts (integers) and a threshold (float), and returns a list of boolean values indicating whether each transaction is an anomaly. # Requirements: 1. The function should mark the first transaction as `False` (no previous transactions to compare). 2. A transaction is considered an anomaly if it is greater than the average of all previous transactions plus the threshold. 3. Ensure your function handles edge cases like an empty list or zero threshold gracefully. # Constraints: 1. `1 <= len(transactions) <= 10^5` - The list can contain up to 100,000 transactions. 2. `0 <= transactions[i] <= 10^6` - Each transaction amount can be up to 1,000,000. 3. `0 <= threshold <= 10^6` - The threshold can be up to 1,000,000. # Example: ```python >>> detect_anomalies([100, 200, 300, 250, 1000], 100.0) [False, False, True, False, True] >>> detect_anomalies([50, 60, 55, 500], 50.0) [False, False, False, True] ``` # Hints: - Keep track of the running sum and count of transactions to efficiently compute the average. - Consider edge cases such as very small or very large threshold values.","solution":"from typing import List def detect_anomalies(transactions: List[int], threshold: float) -> List[bool]: if not transactions: return [] result = [False] running_sum = transactions[0] running_count = 1 for i in range(1, len(transactions)): avg = running_sum / running_count if transactions[i] > avg + threshold: result.append(True) else: result.append(False) running_sum += transactions[i] running_count += 1 return result"},{"question":"**Anagram Checker** Given two strings `s1` and `s2`, implement a function `are_anagrams(s1: str, s2: str) -> bool` that checks whether the two strings are anagrams of each other. # Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: ``` # Input * `s1` (str): A string consisting of lowercase and/or uppercase letters (1 ≤ length of `s1` ≤ 1000). * `s2` (str): A string consisting of lowercase and/or uppercase letters (1 ≤ length of `s2` ≤ 1000). # Output * Returns `True` if `s1` and `s2` are anagrams, `False` otherwise. # Constraints * The function should be case-insensitive, meaning \'A\' and \'a\' are considered the same character. * Ignore any spaces. # Examples ```python >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"Triangle\\", \\"Integral\\") True >>> are_anagrams(\\"Apple\\", \\"Pabble\\") False >>> are_anagrams(\\"A gentleman\\", \\"Elegant man\\") True ``` # Scenario Imagine you are developing a tool for linguists to analyze text samples. One common operational need is to determine whether two phrases consist of exactly the same characters, ignoring spaces and case differences. This task helps in linguistic pattern recognition and textual analysis by identifying anagrams. # Assessment Criteria * Correctness: The solution should correctly identify whether the two input strings are anagrams. * Efficiency: The solution should be able to handle the given constraints promptly. * Code Quality: The solution should be clear, concise, and maintainable.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Check whether two strings are anagrams of each other. Args: s1 (str): First string. s2 (str): Second string. Returns: bool: True if the strings are anagrams, False otherwise. # Remove spaces and lower the case s1 = s1.replace(\\" \\", \\"\\").lower() s2 = s2.replace(\\" \\", \\"\\").lower() # Check if sorted characters of both strings are equal return sorted(s1) == sorted(s2)"},{"question":"# Quadratic Equation Roots Objective You are given a function that calculates the roots of a quadratic equation of the form: [ ax^2 + bx + c = 0 ] The quadratic equation has the following solutions for the roots: [ x = frac{-b pm sqrt{b^2 - 4ac}}{2a} ] You have to implement a function `quadratic_roots` which, given the coefficients `a`, `b`, and `c`, computes the roots of the quadratic equation. Function Signature ```python def quadratic_roots(a: float, b: float, c: float) -> tuple[float, float]: ``` Parameters - `a`: Coefficient of ( x^2 ) (cannot be zero). - `b`: Coefficient of ( x ). - `c`: Constant term. Returns - A tuple containing two float values representing the roots of the quadratic equation. The roots should be returned in increasing order. Constraints - If `a` is zero, raise a `ValueError` with the message `\\"Coefficient \'a\' cannot be zero\\"`. - The roots should be real. If the discriminant ( b^2 - 4ac ) is negative, raise a `ValueError` with the message `\\"Complex roots are not supported\\"`. Examples ```python >>> quadratic_roots(1, -3, 2) (1.0, 2.0) >>> quadratic_roots(1, 2, 1) (-1.0, -1.0) >>> quadratic_roots(2, 5, 3) (-1.5, -1.0) >>> quadratic_roots(0, 2, -4) Traceback (most recent call last): ... ValueError: Coefficient \'a\' cannot be zero >>> quadratic_roots(4, 2, 5) Traceback (most recent call last): ... ValueError: Complex roots are not supported ``` Implement the function `quadratic_roots` using the above guidelines and constraints.","solution":"import math def quadratic_roots(a: float, b: float, c: float) -> tuple[float, float]: if a == 0: raise ValueError(\\"Coefficient \'a\' cannot be zero\\") discriminant = b**2 - 4*a*c if discriminant < 0: raise ValueError(\\"Complex roots are not supported\\") root1 = (-b + math.sqrt(discriminant)) / (2*a) root2 = (-b - math.sqrt(discriminant)) / (2*a) return (min(root1, root2), max(root1, root2))"},{"question":"# Task: You need to write a class called `UniqueIdGenerator` that generates unique IDs based on a prefix and a numerical counter. This class should also be capable of validating if a given ID is part of the generated sequence. # Requirements: - Implement a class that tracks the last generated ID and uses this to generate the next in sequence. - Ensure the methods are efficient and handle edge cases appropriately. # Detailed Function Requirements: 1. **`generate_id(prefix: str) -> str`**: Generates a unique ID with the given prefix. * **Input**: `prefix` - a string value that will be the prefix in the generated ID. * **Output**: A new unique ID string that combines the prefix and a numerical counter. * **Constraints**: Prefix must be a non-empty string. 2. **`validate_id(prefix: str, id: str) -> bool`**: Validates if the given ID is part of the sequence generated by the `generate_id` method. * **Input**: `prefix` - the prefix of the ID to validate, `id` - the full ID string to validate. * **Output**: Boolean `True` if the ID is valid, `False` otherwise. * **Constraints**: Prefix and ID must be non-empty strings. 3. **`change_counter(new_counter: int) -> None`**: Resets the internal counter to the given value. * **Input**: `new_counter` - the new value for the internal counter. * **Output**: None. * **Constraints**: `new_counter` must be a non-negative integer. # Constraints: - The generated IDs must be unique across different calls to `generate_id`, even if multiple prefixes are used. - The `validate_id` method should work efficiently and must return whether an ID could have been generated by previous calls to `generate_id`. - The counter should start at 1 and increment by 1 for each new ID generated. # Example Usage: ```python generator = UniqueIdGenerator() print(generator.generate_id(\\"USER\\")) # Output: \\"USER1\\" print(generator.generate_id(\\"USER\\")) # Output: \\"USER2\\" print(generator.generate_id(\\"ORDER\\")) # Output: \\"ORDER1\\" print(generator.validate_id(\\"USER\\", \\"USER1\\")) # Output: True print(generator.validate_id(\\"USER\\", \\"USER3\\")) # Output: False print(generator.validate_id(\\"ORDER\\", \\"ORDER1\\")) # Output: True generator.change_counter(100) print(generator.generate_id(\\"USER\\")) # Output: \\"USER100\\" ``` # Note: Your implementation should ensure that IDs are unique and sorted by the numerical suffix based on the counter. The `validate_id` method must accurately verify the IDs regardless of the prefix used.","solution":"class UniqueIdGenerator: def __init__(self): self.prefix_counters = {} def generate_id(self, prefix: str) -> str: if not prefix: raise ValueError(\\"Prefix must be a non-empty string.\\") if prefix not in self.prefix_counters: self.prefix_counters[prefix] = 1 else: self.prefix_counters[prefix] += 1 return f\\"{prefix}{self.prefix_counters[prefix]}\\" def validate_id(self, prefix: str, id: str) -> bool: if not prefix or not id: raise ValueError(\\"Prefix and ID must be non-empty strings.\\") if not id.startswith(prefix): return False counter_part = id[len(prefix):] if not counter_part.isdigit(): return False counter = int(counter_part) return 1 <= counter <= self.prefix_counters.get(prefix, 0) def change_counter(self, new_counter: int) -> None: if new_counter < 0: raise ValueError(\\"Counter must be a non-negative integer.\\") for prefix in self.prefix_counters: self.prefix_counters[prefix] = new_counter - 1"},{"question":"# Factorial Digit Sum You are required to implement a function `factorial_digit_sum(n: int | str, precision: int = 0) -> int | float` that computes the factorial of a given non-negative integer `n` and then returns the sum of its digits. Optionally, if a precision value is provided, the function should return the result as a float rounded to the specified number of decimal places. # Function Signature ```python def factorial_digit_sum(n: int | str, precision: int = 0) -> int | float: pass ``` # Input - `n`: an integer or string representing a non-negative integer whose factorial is to be calculated. - `precision`: an optional integer representing the number of decimal places to round the resulting sum of digits. # Output - Return an integer representing the sum of the digits of the factorial of `n` if `precision` is 0. - Return a float representing the sum of the digits, rounded to the specified number of decimal places if `precision` is greater than 0. # Constraints - If `n` is negative or not a valid integer representation, return 0. - If `precision` is not a valid non-negative integer, treat it as 0. - Handle large values of `n` efficiently. # Examples ```python >>> factorial_digit_sum(5) 3 >>> factorial_digit_sum(\\"10\\") 27 >>> factorial_digit_sum(100) 648 >>> factorial_digit_sum(100, 2) 648.0 >>> factorial_digit_sum(-3) 0 >>> factorial_digit_sum(\\"abc\\") 0 ``` # Explanation - The first example computes the factorial of 5 (120) and returns the sum of its digits (1 + 2 + 0 = 3). - The second example computes the factorial of 10 (3628800) and returns the sum of its digits (3 + 6 + 2 + 8 + 8 + 0 + 0 = 27). - The third example computes the factorial of 100 and returns the sum of its digits which is a larger value (648). - The fourth example is similar to the third but with a precision of 2, resulting in a float representation. - The fifth and sixth examples handle invalid inputs gracefully, returning 0. Write a robust solution considering edge cases and ensuring efficiency.","solution":"import math def factorial_digit_sum(n: int | str, precision: int = 0) -> int | float: # Ensure n is a valid non-negative integer try: n = int(n) if n < 0: return 0 except (ValueError, TypeError): return 0 # Ensure precision is a valid non-negative integer try: precision = int(precision) if precision < 0: precision = 0 except (ValueError, TypeError): precision = 0 # Compute the factorial fact = math.factorial(n) # Compute the sum of the digits of the factorial digit_sum = sum(int(digit) for digit in str(fact)) # Return the result as per the precision if precision == 0: return digit_sum else: return round(digit_sum, precision)"},{"question":"# Min-Heap Using Doubly Linked List Implement a Min-Heap data structure using a Doubly Linked List in Python. The goal is to maintain the heap property, where each parent node is less than or equal to its child nodes, while utilizing a doubly linked list for the underlying storage. Implement a class `MinHeapDLL` with the following methods: 1. **Constructor**: Initializes the Min-Heap with an empty doubly linked list. 2. **`insert`:** Inserts a new value into the heap, maintaining the heap property. 3. **`extract_min`:** Removes and returns the smallest value from the heap while maintaining the heap property. 4. **`get_min`:** Returns the smallest value without removing it from the heap. Requirements: - Ensure that all heap operations (`insert`, `extract_min`, and `get_min`) are implemented efficiently. - Utilize a doubly linked list for node storage and maintain the heap property through appropriate operations. - Avoid using built-in heap functions or libraries like `heapq`. # Implementation Details: ```python class ListNode: def __init__(self, value): self.value = value self.prev = None self.next = None class MinHeapDLL: def __init__(self) -> None: Initializes the Min-Heap with an empty doubly linked list. self.head = None self.size = 0 def insert(self, value: int) -> None: Inserts a new value into the heap, maintaining the heap property. Parameters: value (int): The value to be inserted into the heap. # Your implementation goes here. pass def extract_min(self) -> int: Removes and returns the smallest value from the heap while maintaining the heap property. Returns: int: The smallest value in the heap. # Your implementation goes here. pass def get_min(self) -> int: Returns the smallest value without removing it from the heap. Returns: int: The smallest value in the heap. # Your implementation goes here. pass ``` Example Use: ```python heap = MinHeapDLL() heap.insert(10) heap.insert(5) heap.insert(1) print(heap.get_min()) # Output should be 1 print(heap.extract_min()) # Output should be 1 print(heap.extract_min()) # Output should be 5 ``` # Constraints: - The values inserted in the heap will be integers. - The heap operations will be called in such an order to ensure that `extract_min` is never called on an empty heap. # Performance: - Ensure that insert and extract_min operations are efficient despite using a doubly linked list.","solution":"class ListNode: def __init__(self, value): self.value = value self.prev = None self.next = None class MinHeapDLL: def __init__(self) -> None: Initializes the Min-Heap with an empty doubly linked list. self.head = None self.size = 0 def insert(self, value: int) -> None: Inserts a new value into the heap, maintaining the heap property. Parameters: value (int): The value to be inserted into the heap. new_node = ListNode(value) if self.head is None: self.head = new_node else: current = self.head while current: if value < current.value: # Insert before current new_node.next = current new_node.prev = current.prev if new_node.prev: new_node.prev.next = new_node else: self.head = new_node current.prev = new_node break elif current.next is None: # Insert at the end current.next = new_node new_node.prev = current break current = current.next self.size += 1 def extract_min(self) -> int: Removes and returns the smallest value from the heap while maintaining the heap property. Returns: int: The smallest value in the heap. if not self.head: raise IndexError(\\"extract_min from empty heap\\") min_value = self.head.value self.head = self.head.next if self.head: self.head.prev = None self.size -= 1 return min_value def get_min(self) -> int: Returns the smallest value without removing it from the heap. Returns: int: The smallest value in the heap. if not self.head: raise IndexError(\\"get_min from empty heap\\") return self.head.value"},{"question":"# Coding Assessment Question **Problem Statement:** You are provided with a basic graph implementation in Python, which supports adding vertices and edges. Your task is to extend this implementation to include additional functionality for depth-first search (DFS) algorithm and cycle detection in the graph. Requirements: 1. **Depth-First Search (DFS)**: Implement a function `depth_first_search` that performs a depth-first search given a starting vertex. It should return a list of vertices in the order they are visited. 2. **Cycle Detection**: Implement a function `has_cycle` which checks if the graph contains any cycles. This function should return `True` if a cycle is detected and `False` otherwise. Input: - A list of tuples representing the edges of the graph. - A starting vertex for the DFS function. Output: - For `depth_first_search`, a list of vertices in the order they are visited during the DFS traversal. - For `has_cycle`, a boolean indicating whether a cycle exists in the graph. Constraints: - The input list of edges will contain at most 10^4 elements. - The graph is represented as an undirected graph with unique vertices. Function Signatures: ```python class Graph: def __init__(self): # Initialize the graph pass def add_edge(self, vertex1: int, vertex2: int) -> None: ... def depth_first_search(graph: Graph, start_vertex: int) -> list[int]: ... def has_cycle(graph: Graph) -> bool: ... # Example Usage: # graph = Graph() # edges = [(0, 1), (1, 2), (2, 0), (1, 3)] # for v1, v2 in edges: # graph.add_edge(v1, v2) # print(depth_first_search(graph, 0)) # Expected DFS output from vertex 0 # print(has_cycle(graph)) # Expected cycle detection output ``` --- **Example:** ```python class Graph: def __init__(self): self.graph = defaultdict(list) def add_edge(self, vertex1: int, vertex2: int) -> None: self.graph[vertex1].append(vertex2) self.graph[vertex2].append(vertex1) def depth_first_search(graph: Graph, start_vertex: int) -> list[int]: visited = set() result = [] def dfs(vertex): if vertex not in visited: visited.add(vertex) result.append(vertex) for neighbor in graph.graph[vertex]: dfs(neighbor) dfs(start_vertex) return result def has_cycle(graph: Graph) -> bool: def cycle_check(v, visited, parent): visited.add(v) for neighbor in graph.graph[v]: if neighbor not in visited: if cycle_check(neighbor, visited, v): return True elif parent is not None and neighbor != parent: return True return False visited = set() for vertex in graph.graph: if vertex not in visited: if cycle_check(vertex, visited, None): return True return False # Test graph = Graph() edges = [(0, 1), (1, 2), (2, 0), (1, 3)] for v1, v2 in edges: graph.add_edge(v1, v2) print(depth_first_search(graph, 0)) # Expected DFS output from vertex 0 print(has_cycle(graph)) # Expected cycle detection output (True) ``` You are expected to design the `depth_first_search` method to traverse the graph efficiently and the `has_cycle` method to ensure the accurate detection of cycles within the graph.","solution":"from collections import defaultdict class Graph: def __init__(self): self.graph = defaultdict(list) def add_edge(self, vertex1: int, vertex2: int) -> None: self.graph[vertex1].append(vertex2) self.graph[vertex2].append(vertex1) def depth_first_search(graph: Graph, start_vertex: int) -> list[int]: visited = set() result = [] def dfs(vertex): if vertex not in visited: visited.add(vertex) result.append(vertex) for neighbor in graph.graph[vertex]: dfs(neighbor) dfs(start_vertex) return result def has_cycle(graph: Graph) -> bool: def cycle_check(v, visited, parent): visited.add(v) for neighbor in graph.graph[v]: if neighbor not in visited: if cycle_check(neighbor, visited, v): return True elif parent is not None and neighbor != parent: return True return False visited = set() for vertex in graph.graph: if vertex not in visited: if cycle_check(vertex, visited, None): return True return False"},{"question":"# Age Calculator Enhancements Context: You are developing a feature in a health-monitoring application that calculates the exact age of a user in various time units given their birthdate. The existing implementation handles basic units like years and months, but needs enhancement to incorporate more precise calculations, taking into account leap years and variable month lengths. Requirements: 1. Enhance the `calculate_age` function to: * **Account for leap years**: Correctly compute the age considering the exact number of days in each year. * **Handle variable month lengths**: Adjust for month lengths, including 28, 30 and 31 days cases. 2. Extend the function to support additional output age units: * **Weeks** (1 week = 7 days). * **Hours** (1 hour = 60 minutes). 3. Maintain accuracy in input date handling, ensuring the function remains efficient (linear complexity relative to the time span). Implementation: Update the `calculate_age` function and relevant date handling mechanisms to include these more precise calculations and handle the additional units. # Function Signature: ```python from datetime import date def calculate_age(birthdate: date, unit: str) -> float: pass ``` # Input/Output Specifications: * **Input**: * `birthdate` (date): The birthdate of the user in `YYYY-MM-DD` format. * `unit` (str): The unit in which the age should be returned. Case insensitive. * **Output**: * (float): The age in the specified unit rounded to two decimal places. # Constraints: * Birthdate must be a valid date-formatted string. * Unit must be one of the valid units: \'years\', \'months\', \'days\', \'weeks\', \'hours\'. # Examples: ```python from datetime import date assert calculate_age(date(2000, 1, 1), \'years\') == 23.75 assert calculate_age(date(2020, 1, 1), \'months\') == 46.0 assert calculate_age(date(2015, 6, 15), \'days\') == 3038.0 assert calculate_age(date(1990, 7, 20), \'weeks\') == 1744.0 assert calculate_age(date(1985, 12, 25), \'hours\') == 332136.0 ```","solution":"from datetime import date, datetime def calculate_age(birthdate: date, unit: str) -> float: Calculates the age of a user in the specified units (years, months, days, weeks, hours). Handles leap years and variable length of months. today = datetime.now().date() delta = today - birthdate if unit.lower() == \'years\': age_in_years = delta.days / 365.25 # Considering leap years return round(age_in_years, 2) elif unit.lower() == \'months\': age_in_months = delta.days / 30.4375 # Average days in a month considering leap years return round(age_in_months, 2) elif unit.lower() == \'days\': return round(delta.days, 2) elif unit.lower() == \'weeks\': age_in_weeks = delta.days / 7 return round(age_in_weeks, 2) elif unit.lower() == \'hours\': age_in_hours = delta.days * 24 return round(age_in_hours, 2) else: raise ValueError(\\"Unsupported unit. Choose from \'years\', \'months\', \'days\', \'weeks\', \'hours\'.\\")"},{"question":"In the context of data compression, you are developing a tool that uses the Run-Length Encoding (RLE) algorithm to compress strings. RLE is a simple form of data compression where consecutive occurrences of the same character are stored as a single character and its count. For example, the string \\"aaabbbcc\\" would be compressed to \\"a3b3c2\\". # Task Implement the function `compress_rle` that takes a string and returns its run-length encoded form. Additionally, implement the function `decompress_rle` that takes a run-length encoded string and returns the original string. Function Signature ```python def compress_rle(text: str) -> str: # Implement this function def decompress_rle(text: str) -> str: # Implement this function ``` Input Format * A single string `text` of length `n` for both compression and decompression. Output Format * For `compress_rle`, return a string that represents the run-length encoded form of the input text. * For `decompress_rle`, return the original string from the run-length encoded input. Constraints * 1 ≤ n ≤ 10^5 * The `text` will consist of only uppercase English letters. Example ```python text = \\"AAABBBCCDAA\\" compressed = compress_rle(text) print(compressed) # Output: \\"A3B3C2D1A2\\" encoded_text = \\"A3B3C2D1A2\\" decompressed = decompress_rle(encoded_text) print(decompressed) # Output: \\"AAABBBCCDAA\\" ``` Additional Constraints * Ensure that your implementation handles edge cases such as a single character string and strings with no consecutive repeating characters. # Notes * Optimize your code to handle large text sizes efficiently. * Aim for linear time complexity in your implementations.","solution":"def compress_rle(text: str) -> str: if not text: return \\"\\" compressed = [] current_char = text[0] count = 1 for i in range(1, len(text)): if text[i] == current_char: count += 1 else: compressed.append(f\\"{current_char}{count}\\") current_char = text[i] count = 1 compressed.append(f\\"{current_char}{count}\\") return \'\'.join(compressed) def decompress_rle(text: str) -> str: decompressed = [] i = 0 while i < len(text): char = text[i] count = \\"\\" i += 1 while i < len(text) and text[i].isdigit(): count += text[i] i += 1 decompressed.append(char * int(count)) return \'\'.join(decompressed)"},{"question":"# Coding Assessment Question Context: You are working on a file storage application, and part of the functionality includes generating a unique identifier for each user-uploaded file. To achieve this, you need to implement a system that can generate and validate these unique identifiers. Task: Implement the functions `generate_file_id` and `validate_file_id` to create and verify unique identifiers for files. The unique file IDs should be generated using a combination of the current timestamp and a random component to ensure uniqueness. Requirements: 1. **Function Signatures**: ```python def generate_file_id() -> str: def validate_file_id(file_id: str) -> bool: ``` 2. **Function Descriptions**: * `generate_file_id`: This function should create and return a unique file ID. The ID should be a string composed of the current timestamp (in milliseconds) followed by a hyphen and a randomly generated UUID (version 4). * `validate_file_id`: This function should take a file ID string as input and return `True` if the format of the ID is valid, otherwise return `False`. 3. **Constraints**: * The current timestamp should be in milliseconds. * The random component should be a version 4 UUID. * The generated file ID should be in the format `timestamp-uuid`, where `timestamp` is an integer representing the number of milliseconds since the Unix epoch and `uuid` is the random UUID. * The validation function should ensure that both the timestamp and UUID are correctly formatted. 4. **Performance Requirements**: * Generation of file IDs should be efficient and capable of producing unique IDs even under high load. * Validation should accurately and quickly assess the correctness of the file ID format. Example Usage: ```python file_id = generate_file_id() print(file_id) # Example: \\"1633024807123-550e8400-e29b-41d4-a716-446655440000\\" is_valid = validate_file_id(file_id) print(is_valid) # Expected Output: True ``` Hints: * Use the `time` module to get the current timestamp in milliseconds. * Use the `uuid` module to generate a version 4 UUID. * Perform string splitting and format checking to validate the structure of the file ID. Good luck!","solution":"import time import uuid def generate_file_id() -> str: Generates a unique file ID consisting of the current timestamp in milliseconds and a version 4 UUID, separated by a hyphen. timestamp = int(time.time() * 1000) unique_id = uuid.uuid4() return f\\"{timestamp}-{unique_id}\\" def validate_file_id(file_id: str) -> bool: Validates the format of the given file ID. The file ID must consist of a timestamp in milliseconds followed by a hyphen and a version 4 UUID. parts = file_id.split(\'-\') if len(parts) != 6: return False if not parts[0].isdigit(): return False timestamp = parts[0] uuid_part = \\"-\\".join(parts[1:]) try: uuid_obj = uuid.UUID(uuid_part, version=4) except ValueError: return False return str(uuid_obj) == uuid_part"},{"question":"# Group Photo Arrangement You are tasked with arranging a group photo for a company event. The participants in the photo need to be arranged in rows and columns such that the photo appears visually balanced. Specifically, taller individuals should not obscure shorter individuals directly behind them. Given the heights of the participants, create a solution to determine an arrangement of participants so that no participant has a taller individual standing in front of them in the same column. # Function Definition You need to implement the function: ```python def arrange_photo(heights: list[int], rows: int, cols: int) -> list[list[int]]: ``` # Input - `heights`: A list of integers, where each integer represents the height of a participant. Assumption: The list has exactly `rows * cols` elements. - `rows`: An integer, the number of rows in the photo arrangement. - `cols`: An integer, the number of columns in the photo arrangement. # Output - Returns a 2D list of integers representing the arranged photo, where each sub-list is a row and contains the heights of participants in that row. # Constraints - 1 <= `rows, cols` <= 100 - Assumption: `heights` contains exactly `rows * cols` elements. - Each height will be a distinct positive integer. # Example ```python heights = [150, 160, 165, 170, 155, 180, 175, 185] rows = 2 cols = 4 print(arrange_photo(heights, rows, cols)) # Output: [[150, 155, 160, 165], [170, 175, 180, 185]] ``` # Context Arranging individuals for a group photo in a way that ensures no one is obscured by someone taller directly in front of them involves not just sorting but also strategically positioning participants. This problem is relevant in logistics, event planning, and any situation requiring organized spatial arrangements.","solution":"def arrange_photo(heights: list[int], rows: int, cols: int) -> list[list[int]]: # Sort the heights in ascending order sorted_heights = sorted(heights) # Initialize the 2D list for the arranged photo arranged_photo = [] # Fill the 2D list row-wise with the sorted heights for i in range(rows): row = sorted_heights[i*cols:(i+1)*cols] arranged_photo.append(row) return arranged_photo"},{"question":"# Problem Statement Implement a code analysis tool that detects and counts the number of functions implemented in a given Python script. A function is defined by the presence of the `def` keyword followed by the function name and its parameters. # Function Signature ```python def count_functions_in_script(script: str) -> int: ``` # Input: * `script`: A string, representing the entire content of a Python script. # Output: * An integer representing the number of functions defined in the script. # Constraints: * Functions can be defined inside other functions (nested functions). * Ignore comments and strings that might contain the keyword `def`. * The script will not have any syntax errors and will be properly indented. # Requirements: 1. The function should accurately count both top-level and nested function definitions. 2. The tool should ignore any instances of `def` that are within comments or string literals. # Example Usage: ```python script = def outer_function(): def inner_function(): pass return inner_function def another_function(param): print(param) functions_count = count_functions_in_script(script) print(f\\"Number of functions: {functions_count}\\") ``` This should return `3` because there are three functions defined: `outer_function`, `inner_function`, and `another_function`. # Notes: * Use regular expressions or other appropriate methods to identify function definitions accurately. * Consider both single-line and multi-line strings when parsing the script content. * Ensure the solution handles edge cases such as no functions defined or scripts that are empty. # Evaluation Criteria: * Correctness: Accurately counting all function definitions in the given script. * Robustness: Proper handling of nested functions and ignoring false positives in comments and strings. * Efficiency: Reasonable time and space complexity for parsing the script. # Bonus: * Extend the tool to also count the number of classes defined in the script. * Provide a detailed report of the names and line numbers of each function definition.","solution":"import re def count_functions_in_script(script: str) -> int: Counts the number of functions in a given Python script. Args: script (str): The contents of a Python script. Returns: int: The number of functions defined in the script. # Remove comments script = re.sub(r\'#.*\', \'\', script) # Remove strings script = re.sub(r\'(\'\'\'(.*?)\'\'\'|\\"\\"\\"(.*?)\\"\\"\\"|\'(.*?)\'|\\"(.*?)\\")\', \'\', script, flags=re.DOTALL) # Find all function definitions functions = re.findall(r\'bdefbs+w+s*(\', script) return len(functions)"},{"question":"# Problem Statement: Fraction Simplifier You are required to design a function that simplifies a given fraction to its lowest terms. This involves reducing the numerator and the denominator by their greatest common divisor (GCD). **Context and Functions:** A fraction is composed of two integers, a numerator `n` and a denominator `d`. To simplify a fraction, you divide both the numerator and the denominator by their greatest common divisor (GCD). The GCD of two numbers can be found using the Euclidean algorithm: 1. GCD of `a` and `b` is `b` if `b` is 0. 2. Otherwise, it is GCD of `b` and `a % b`. **Tasks**: 1. **Implement the function `gcd(a: int, b: int) -> int`.** * The function should calculate and return the greatest common divisor of `a` and `b`. * If either `a` or `b` is less than zero, consider their absolute values for computation. **Example**: ```python >>> gcd(48, 18) 6 >>> gcd(-48, 18) 6 ``` 2. **Implement the function `simplify_fraction(numerator: int, denominator: int) -> Tuple[int, int]`.** * The function should simplify the given fraction `numerator/denominator` and return a tuple (simplified_numerator, simplified_denominator). * Ensure that it raises a `ValueError` if the denominator is zero. * If the fraction simplifies to a negative number, the returned fraction should have the negative sign in the numerator. **Example**: ```python >>> simplify_fraction(42, 56) (3, 4) >>> simplify_fraction(-42, 56) (-3, 4) >>> simplify_fraction(42, -56) (-3, 4) >>> simplify_fraction(42, 0) Traceback (most recent call last): ... ValueError: Denominator must not be zero ``` **Input Constraints**: - ( -10^7 leq numerator leq 10^7 ) - ( -10^7 leq denominator leq 10^7 ) **Assumptions**: - Both `numerator` and `denominator` are integers. - Users may enter negative values for numerator and/or denominator. Your implementation should be robust and handle edge cases such as zero or negative inputs appropriately.","solution":"from typing import Tuple def gcd(a: int, b: int) -> int: Calculate the greatest common divisor (GCD) of two integers using the Euclidean algorithm. a, b = abs(a), abs(b) while b: a, b = b, a % b return a def simplify_fraction(numerator: int, denominator: int) -> Tuple[int, int]: Simplify a fraction given by its numerator and denominator. Return a tuple (simplified_numerator, simplified_denominator). Raise a ValueError if the denominator is zero. if denominator == 0: raise ValueError(\\"Denominator must not be zero\\") divisor = gcd(numerator, denominator) simplified_numerator = numerator // divisor simplified_denominator = denominator // divisor # Ensuring the negative sign is in the numerator if simplified_denominator < 0: simplified_numerator = -simplified_numerator simplified_denominator = -simplified_denominator return simplified_numerator, simplified_denominator"},{"question":"# Problem Statement You are required to develop a new geometric class called `Circle`, which represents a circle on a 2D surface. A `Circle` is a specific type of `Shape` and should adhere to the following requirements: 1. **Initialization**: A circle is initialized with a radius, ensuring the radius is a positive number. 2. **Circumference Calculation**: Implement a method to calculate the circumference of the circle. 3. **Area Calculation**: Implement a method to calculate the area of the circle. 4. **Error Handling**: Ensure that invalid configurations (where the radius is non-positive) are caught and appropriate errors are raised. # Implementation Details - Create a `Circle` class that: - Inherits from the `Shape` class. - Ensures the radius is a valid positive number. - Implement the `circumference` and `area` methods. # Input & Output Formats - **Input**: The circle will be initialized with a radius. - `Circle(radius: float)` - **Output**: - `circumference()` method should return a float representing the circumference of the circle. - `area()` method should return a float representing the area of the circle. # Constraints - The radius must be a positive numeric value. # Example ```python # Assume the Shape class and other dependencies are implemented as defined in the provided snippets. c = Circle(5) print(c.circumference()) # Expected output: 31.41592653589793 print(c.area()) # Expected output: 78.53981633974483 c_invalid = Circle(-2) # Should raise ValueError: Invalid radius for a circle. ``` # Performance Requirements - Ensure the implementation is efficient in terms of validating the radius and computing the circumference and area. - Raise appropriate errors for invalid input.","solution":"import math class Shape: pass class Circle(Shape): def __init__(self, radius): if radius <= 0: raise ValueError(\\"Invalid radius for a circle. The radius must be a positive number.\\") self.radius = radius def circumference(self): return 2 * math.pi * self.radius def area(self): return math.pi * self.radius**2"},{"question":"# Coding Assessment Question Binary Search Trees (BST) are fundamental data structures for efficient searching, insertion, and deletion operations. They are widely used in applications like database indexing, expression parsing, and constraint solving. **Objective**: Implement a function to convert a given Binary Search Tree (BST) into a circular doubly-linked list (CDLL) in-place, while maintaining the order of elements and demonstrating your solution by traversing and printing the resulting linked list. Requirements: 1. **BST to CDLL Conversion**: * Implement a function to convert a BST to a CDLL where each node points to its predecessor and successor in sorted order. * Ensure the head of the list points to the smallest element, and the tail\'s next pointer points to the head of the list. 2. **Traversal and Validation**: * Implement a function to traverse the resulting CDLL and print each element to validate the conversion. * Ensure the traversal covers the entire list, looping back to the head of the list at the end. Function Signature ```python class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None self.prev = None # For CDLL previous pointer self.next = None # For CDLL next pointer def bst_to_cdll(root: TreeNode) -> TreeNode: # Implement the BST to CDLL conversion logic pass def print_cdll(head: TreeNode) -> None: # Implement the traversal and printing logic pass ``` Example Usage: ```python # Example BST creation root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.right = TreeNode(6) # Convert BST to CDLL head = bst_to_cdll(root) # Print elements of the CDLL print_cdll(head) # Output: 1 2 3 4 5 6 (and then back to 1) ``` Constraints: 1. Each node\'s value should be a unique integer. 2. The BST is binary, where the left child is less than the parent and the right child is greater than the parent. 3. Ensure the function handles edge cases like an empty tree or a tree with a single node. 4. The space complexity should be O(1) (in-place conversion). Context: This task involves transforming a foundational data structure (BST) to a different form (CDLL) that maintains sorted order and allows circular traversal, demonstrating the ability to manipulate and traverse complex data structures in-place.","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None self.prev = None # For CDLL previous pointer self.next = None # For CDLL next pointer def bst_to_cdll(root: TreeNode) -> TreeNode: # Helper function to concatenate two circular doubly linked lists def concatenate(left: TreeNode, right: TreeNode) -> TreeNode: if not left: return right if not right: return left left_last = left.prev right_last = right.prev left_last.next = right right.prev = left_last right_last.next = left left.prev = right_last return left # Recursive function to convert BST to circular doubly linked list def bst_to_cdll_rec(node: TreeNode) -> TreeNode: if not node: return None left_cdll = bst_to_cdll_rec(node.left) right_cdll = bst_to_cdll_rec(node.right) # Make a single node circular doubly linked list node.prev = node node.next = node combined = concatenate(left_cdll, node) combined = concatenate(combined, right_cdll) return combined return bst_to_cdll_rec(root) def print_cdll(head: TreeNode) -> None: if not head: return current = head while True: print(current.value, end=\' \') current = current.next if current == head: break print()"},{"question":"# Coding Assessment Question You are working on a high-frequency trading application that processes a constant stream of price quotes for various stocks. Your current implementation records each quote and allows you to retrieve the highest and lowest prices for a particular stock over a specific time range. However, the current solution lacks performance optimizations and does not handle all edge cases effectively. Your task is to: 1. Optimize the current data structures and algorithms underlying the price recording and retrieval functions to handle a large volume of data efficiently. 2. Implement additional functionality to calculate the average price of a stock over a given time range. 3. Refactor existing functions to incorporate error handling, especially for edge cases such as empty data sets or non-existent stock symbols. Expected Input and Output **Function 1**: `def record_quote(stock_symbol: str, price: float, timestamp: int) -> None`: Record a new price quote for a given stock. - **Input**: - `stock_symbol` (str): The ticker symbol of the stock. - `price` (float): The quoted price of the stock. - `timestamp` (int): The time of the quote in epoch seconds. - **Output**: None **Function 2**: `def get_high_low_price(stock_symbol: str, start_time: int, end_time: int) -> tuple[float, float | None]`: Retrieve the highest and lowest prices for a stock within a specified time range. - **Input**: - `stock_symbol` (str): The ticker symbol of the stock. - `start_time` (int): The start of the time range in epoch seconds. - `end_time` (int): The end of the time range in epoch seconds. - **Output**: - A tuple containing the highest price (float) and the lowest price (float) in the given range, or `None` if there are no quotes in the range. **Function 3**: `def get_average_price(stock_symbol: str, start_time: int, end_time: int) -> float | None`: Calculate the average price of a stock within a specified time range. - **Input**: - `stock_symbol` (str): The ticker symbol of the stock. - `start_time` (int): The start of the time range in epoch seconds. - `end_time` (int): The end of the time range in epoch seconds. - **Output**: The average price (float) for the stock in the given time range, or `None` if there are no quotes in the range. # Constraints - Ensure all data is efficiently indexed and retrievable, given a high rate of incoming price quotes. - Implement robust error handling for scenarios such as invalid time ranges and missing stock symbols. - Optimize the solution to handle large datasets without performance degradation.","solution":"from collections import defaultdict from typing import List, Tuple, Optional class StockQuotes: def __init__(self): self.quotes = defaultdict(list) # store quotes in a dictionary def record_quote(self, stock_symbol: str, price: float, timestamp: int) -> None: if stock_symbol and isinstance(stock_symbol, str) and isinstance(price, (int, float)) and isinstance(timestamp, int): self.quotes[stock_symbol].append((timestamp, price)) self.quotes[stock_symbol].sort() def get_high_low_price(self, stock_symbol: str, start_time: int, end_time: int) -> Optional[Tuple[Optional[float], Optional[float]]]: if stock_symbol not in self.quotes or start_time > end_time: return None relevant_quotes = [price for time, price in self.quotes[stock_symbol] if start_time <= time <= end_time] if not relevant_quotes: return (None, None) return (max(relevant_quotes), min(relevant_quotes)) def get_average_price(self, stock_symbol: str, start_time: int, end_time: int) -> Optional[float]: if stock_symbol not in self.quotes or start_time > end_time: return None relevant_quotes = [price for time, price in self.quotes[stock_symbol] if start_time <= time <= end_time] if not relevant_quotes: return None return sum(relevant_quotes) / len(relevant_quotes)"},{"question":"# Problem Statement You are tasked with implementing a simplified version of a text editor\'s undo/redo functionality. This functionality allows users to revert and reapply their most recent text manipulations, which is crucial for efficient text editing. # Functionality to Implement You need to complete the `TextEditor` class which supports the following operations: 1. **Type a character**: Adds a character to the end of the current text. 2. **Undo**: Reverts the last operation (typing a character). 3. **Redo**: Reapplies the last undone operation (typing a character). # Implementation Detail 1. **Class Signature**: ```python class TextEditor: def __init__(self): # Implement the constructor def type_character(self, char: str) -> None: # Implement this method def undo(self) -> None: # Implement this method def redo(self) -> None: # Implement this method def get_text(self) -> str: # Implement this method ``` 2. **Methods**: - `type_character(self, char: str) -> None`: Receives a single character and appends it to the current text. - `undo(self) -> None`: Reverts the last type operation. If there is no operation to undo, do nothing. - `redo(self) -> None`: Reapplies the last undone operation. If there is no operation to redo, do nothing. - `get_text(self) -> str`: Returns the current state of the text as a string. # Example Usage ```python editor = TextEditor() editor.type_character(\'a\') editor.type_character(\'b\') editor.type_character(\'c\') print(editor.get_text()) # Output: \'abc\' editor.undo() print(editor.get_text()) # Output: \'ab\' editor.redo() print(editor.get_text()) # Output: \'abc\' editor.undo() editor.undo() print(editor.get_text()) # Output: \'a\' editor.redo() print(editor.get_text()) # Output: \'ab\' ``` # Constraints - Only valid single lowercase alphabetic characters (\'a\' to \'z\') will be given to `type_character`. - Operations will be performed in a sequence where `type_character`, `undo`, and `redo` are called multiple times. - The total number of operations will not exceed 10^5. # Notes - The intent is to simulate a real-world text editor\'s undo/redo feature. - Ensure optimal handling of the operations under the given constraints. - Handle edge cases such as multiple undo operations when there are no actions to undo, or multiple redo operations when there are no actions to redo. # Testing - Test the class with a variety of sequences to ensure the `undo` and `redo` operations behave correctly under various conditions. - Validate edge cases, such as performing undo/redo on an empty text or trying to redo without any prior undo operations.","solution":"class TextEditor: def __init__(self): self.text = [] self.undo_stack = [] self.redo_stack = [] def type_character(self, char: str) -> None: self.text.append(char) self.undo_stack.append((\\"type\\", char)) self.redo_stack = [] # Clear the redo stack when a new character is typed def undo(self) -> None: if self.undo_stack: action, char = self.undo_stack.pop() if action == \\"type\\": self.redo_stack.append((\\"undo_type\\", char)) self.text.pop() def redo(self) -> None: if self.redo_stack: action, char = self.redo_stack.pop() if action == \\"undo_type\\": self.text.append(char) self.undo_stack.append((\\"type\\", char)) def get_text(self) -> str: return \'\'.join(self.text)"},{"question":"# Sentiment Analysis of Customer Reviews Your task is to develop a function to perform basic sentiment analysis on a collection of customer reviews. The function should categorize each review as \'positive\', \'negative\', or \'neutral\' based on the presence of certain keywords. # Requirements: 1. **Input**: A list of strings, each representing a customer review. 2. **Output**: A list of the same length, where each element is the sentiment category (\'positive\', \'negative\', or \'neutral\') of the corresponding review. 3. **Function Implementation**: Write a function `categorize_reviews(reviews: list[str]) -> list[str]`. # Constraints: 1. Define at least the following keywords: * Positive: [\\"good\\", \\"great\\", \\"excellent\\", \\"amazing\\", \\"fantastic\\"] * Negative: [\\"bad\\", \\"terrible\\", \\"awful\\", \\"poor\\", \\"horrible\\"] 2. A review is considered \'positive\' if it contains any of the positive keywords, \'negative\' if it contains any of the negative keywords, and \'neutral\' if it contains none of these keywords. 3. Keywords are case-insensitive. 4. Handle empty reviews gracefully by categorizing them as \'neutral\'. # Example: ```python def categorize_reviews(reviews: list[str]) -> list[str]: # Your implementation # Test case reviews = [ \\"The product was excellent and the service was fantastic.\\", \\"Terrible experience, the quality was awful.\\", \\"Good value for money.\\", \\"Not what I expected, but okay.\\" ] sentiments = categorize_reviews(reviews) print(sentiments) # Output: [\'positive\', \'negative\', \'positive\', \'neutral\'] ``` # Scenario: Imagine you are part of a team developing a tool to automatically analyze customer feedback for a large e-commerce platform. Your function should quickly and accurately assess the sentiment of each review to help categorize and prioritize customer service responses. Consider optimizing your code to handle a large volume of reviews efficiently. # Notes: - Implement comprehensive edge case handling. - Take into account common variations in language and spelling within the same sentiment category. - Ensure the solution is efficient enough for real-world usage with potentially high input volume.","solution":"def categorize_reviews(reviews: list[str]) -> list[str]: Categorizes each review as \'positive\', \'negative\', or \'neutral\'. positive_keywords = [\\"good\\", \\"great\\", \\"excellent\\", \\"amazing\\", \\"fantastic\\"] negative_keywords = [\\"bad\\", \\"terrible\\", \\"awful\\", \\"poor\\", \\"horrible\\"] def categorize(review): review_lower = review.lower() for word in positive_keywords: if word in review_lower: return \'positive\' for word in negative_keywords: if word in review_lower: return \'negative\' return \'neutral\' return [categorize(review) for review in reviews] # Example usage: reviews = [ \\"The product was excellent and the service was fantastic.\\", \\"Terrible experience, the quality was awful.\\", \\"Good value for money.\\", \\"Not what I expected, but okay.\\" ] sentiments = categorize_reviews(reviews) print(sentiments) # Output: [\'positive\', \'negative\', \'positive\', \'neutral\']"},{"question":"# Question Write a Python function `password_strength(password: str) -> int` that calculates the strength of a given password based on the following rules: - A password is considered strong if it has a length of at least 8 characters. - It contains at least one uppercase letter. - It contains at least one lowercase letter. - It contains at least one digit. The function should return an integer representing the strength of the password: - 0 if the password does not meet any of the criteria. - 1 if it meets one of the criteria. - 2 if it meets two of the criteria. - 3 if it meets three of the criteria. - 4 if it meets all four of the criteria. # Input - A string `password` representing the password to evaluate (1 ≤ len(password) ≤ 100). # Output - Return an integer representing the strength of the password based on the defined criteria. # Example ```python >>> password_strength(\\"Password123\\") 4 >>> password_strength(\\"Password\\") 3 >>> password_strength(\\"password123\\") 3 >>> password_strength(\\"PASSWORD123\\") 3 >>> password_strength(\\"12345678\\") 2 >>> password_strength(\\"pass\\") 1 >>> password_strength(\\"\\") 0 ``` # Explanation - For \\"Password123\\", the password meets all four criteria. - For \\"Password\\", it meets three criteria (length >= 8, at least one uppercase letter, at least one lowercase letter), thus the strength is 3. - For \\"password123\\", it meets length >= 8, at least one lowercase letter, and at least one digit, thus the strength is 3. - For \\"PASSWORD123\\", it meets length >= 8, at least one uppercase letter, and at least one digit, thus the strength is 3. - For \\"12345678\\", it meets length >= 8 and at least one digit, thus the strength is 2. - For \\"pass\\", it only meets at least one lowercase letter, thus the strength is 1. - For an empty string, it meets none of the criteria, thus the strength is 0. # Constraints 1. The length of the password string should be taken into consideration first. 2. Ensure the function efficiently checks for each criterion without repeating unnecessary calculations. 3. Aim for clarity and simplicity in the code to handle a wide variety of input cases.","solution":"def password_strength(password: str) -> int: Calculates the strength of a given password based on defined criteria. :param password: The password string to evaluate :return: An integer representing the strength of the password strength = 0 if len(password) >= 8: strength += 1 if any(char.isupper() for char in password): strength += 1 if any(char.islower() for char in password): strength += 1 if any(char.isdigit() for char in password): strength += 1 return strength"},{"question":"# Check if a Number is a Power of Two As a software engineer, you often find yourself needing to optimize operations involving numbers. One common need is to verify if a given number is a power of two. This is particularly useful in scenarios such as memory allocation, data alignment, and algorithm optimizations. Write a function `is_power_of_two` that checks if a given non-negative integer is a power of two. # Function Signature ```python def is_power_of_two(number: int) -> bool: pass ``` # Constraints 1. The function should only accept non-negative integers. 2. The function should not use loops or recursion. 3. The function should be efficient and concise. # Input * One non-negative integer. # Output * A boolean value: `True` if the input number is a power of two, `False` otherwise. # Example ```python assert is_power_of_two(1) == True assert is_power_of_two(2) == True assert is_power_of_two(16) == True assert is_power_of_two(18) == False assert is_power_of_two(0) == False # Invalid cases (should raise a TypeError) try: is_power_of_two(4.5) except TypeError: pass try: is_power_of_two(\'4\') except TypeError: pass try: is_power_of_two(-1) except ValueError: pass ``` # Description Implement the function `is_power_of_two` that: 1. Takes in one integer. 2. Checks if the number is a power of two using bitwise operations. 3. Validates input and raises appropriate exceptions for invalid cases. # Hints 1. A number is a power of two if it has exactly one bit set to `1` in its binary representation. 2. Use the property: `(number & (number - 1)) == 0` to check for powers of two. 3. Ensure the number is positive to avoid false positives for zero or negative inputs.","solution":"def is_power_of_two(number: int) -> bool: Check if a given number is a power of two. Parameters: number (int): The number to check. Returns: bool: True if the number is a power of two, False otherwise. Raises: TypeError: If the input is not an integer. ValueError: If the input is a negative integer. if not isinstance(number, int): raise TypeError(\\"Input must be an integer.\\") if number < 0: raise ValueError(\\"Input must be a non-negative integer.\\") return number > 0 and (number & (number - 1)) == 0"},{"question":"# Coding Assessment Question Scenario You\'ve been assigned to develop a file system monitoring tool that effectively tracks file sizes and supports fast retrieval of the smallest file size within a given range. You decide to use a Segment Tree to facilitate efficient operations. Task Implement the `build_segment_tree` and `range_min_query` functions to construct a Segment Tree for a given list of file sizes and efficiently retrieve the minimum file size for specified ranges. Function Definitions 1. **build_segment_tree**: * **Input**: A list of integers representing file sizes. * **Output**: A list representing the constructed Segment Tree. * **Constraints**: - The input list may be empty. - The values may be negative, zero, or positive. 2. **range_min_query**: * **Input**: - A Segment Tree list generated from `build_segment_tree`. - Two integers (`start`, `end`) representing the range for the query. - The original list size, which is used to manage segment tree indexing. * **Output**: An integer representing the minimum value in the range `[start, end]`. * **Constraints**: - Ensure the bounds are within the valid range. - Handle cases where the bounds are invalid. Sample Usage ```python segment_tree = build_segment_tree([4, 2, 5, 1, 6, 3, 2]) assert range_min_query(segment_tree, 1, 4, 7) == 1 assert range_min_query(segment_tree, 3, 6, 7) == 1 segment_tree = build_segment_tree([7, 3, 8, 6]) assert range_min_query(segment_tree, 0, 2, 4) == 3 assert range_min_query(segment_tree, 1, 3, 4) == 3 ``` # Requirements * Implement the core algorithm as described. * Validate inputs to ensure error handling for edge cases such as empty lists and invalid query bounds. * Use efficient and optimal methods to achieve the desired performance. Constraints * Maximum length of the list ( n leq 10^5 ). * Ensure your implementation handles both small and large inputs effectively.","solution":"def build_segment_tree(arr): Build a Segment Tree from the given array and return the tree if not arr: return [] n = len(arr) segment_tree = [0] * (2 * n) # Initialize leaves of segment tree for i in range(n): segment_tree[n + i] = arr[i] # Build the segment tree by calculating parents for i in range(n - 1, 0, -1): segment_tree[i] = min(segment_tree[2 * i], segment_tree[2 * i + 1]) return segment_tree def range_min_query(segment_tree, start, end, n): Perform a range minimum query on the Segment Tree if not segment_tree or start < 0 or end >= n or start > end: return float(\'inf\') # Translate range to leaf indices start += n end += n min_val = float(\'inf\') while start <= end: if start % 2 == 1: min_val = min(min_val, segment_tree[start]) start += 1 if end % 2 == 0: min_val = min(min_val, segment_tree[end]) end -= 1 start //= 2 end //= 2 return min_val"},{"question":"# Problem Statement You are tasked with implementing the `first_repeating_element_index` function. This function finds the first element that repeats in the list and returns its index. If no element repeats, the function should return -1. # Function Signature ```python def first_repeating_element_index(arr: list[int]) -> int: pass ``` # Input * **arr**: A list of integers. * The list can contain both positive and negative integers. # Output * Return the index of the first repeating element. Return -1 if no repeating element is found. # Constraints * 0 <= len(arr) <= 10^6 * -10^9 <= arr[i] <= 10^9 # Requirements * Implement the `first_repeating_element_index` function to efficiently handle the constraints. # Example Usage ```python arr = [10, 5, 3, 4, 3, 5, 6] print(first_repeating_element_index(arr)) # Expected output: 1 arr = [1, 2, 3, 4, 5] print(first_repeating_element_index(arr)) # Expected output: -1 arr = [] print(first_repeating_element_index(arr)) # Expected output: -1 arr = [5, 5, 3, 4, 3, 5, 6] print(first_repeating_element_index(arr)) # Expected output: 0 arr = [1, 2, 3, 4, 1, 2, 3, 4] print(first_repeating_element_index(arr)) # Expected output: 0 ``` # Additional Information Testing should include: * Empty list * List with all unique elements * List with multiple repeating elements at different positions * Very large lists to assess performance","solution":"def first_repeating_element_index(arr: list[int]) -> int: Finds the index of the first repeating element in the list. Returns -1 if no repeating element is found. seen = {} for idx, val in enumerate(arr): if val in seen: return seen[val] else: seen[val] = idx return -1"},{"question":"# Context In a movie recommendations application, users can have multiple favorite genres, and we\'re tasked with creating a system to keep track of the most popular genres among users. To handle this, we\'ll implement a class that maintains a count of genre preferences and allows us to efficiently query the most popular genre at any given time. # Task Implement the `GenreTracker` class. Method Details 1. **`add_genre(self, user_id: int, genre: str) -> None`**: * Adds a genre to the user\'s list of favorite genres. * Updates the popularity count of the genre. 2. **`remove_genre(self, user_id: int, genre: str) -> None`**: * Removes a genre from the user\'s list of favorite genres. * Updates the popularity count of the genre. 3. **`get_most_popular(self) -> str | None`**: * Returns the genre with the highest popularity count. * If there is a tie, returns any one of the most popular genres. # Requirement Ensure your implementation of the `GenreTracker` class: * **Handles edge cases**: such as when a user adds or removes the same genre multiple times consecutively. * **Maintains efficiency**: especially when dealing with large numbers of users and genres. * **Produces correct results**: reflecting the real-time most popular genre. # Input and Output * Input: * User interactions through method calls: adding or removing a genre to/from a user\'s favorites. * Output: * A string representing the most popular genre based on the current state. # Example ```python G = GenreTracker() G.add_genre(1, \\"action\\") G.add_genre(2, \\"comedy\\") G.add_genre(3, \\"action\\") G.add_genre(4, \\"drama\\") print(G.get_most_popular()) # Output: \\"action\\" G.remove_genre(1, \\"action\\") print(G.get_most_popular()) # Output: \\"comedy\\" or \\"action\\" G.remove_genre(2, \\"comedy\\") print(G.get_most_popular()) # Output: \\"action\\" ``` # Constraints * Number of users: (1 leq |users| leq 10^5) * Length of each genre string: (1 leq text{length of genre} leq 50) * Number of operations (method calls): (1 leq text{number of operations} leq 10^6) **Note**: Ensure that your class handles updates and queries efficiently, considering both the number of users and genres.","solution":"from collections import defaultdict class GenreTracker: def __init__(self): self.user_genres = defaultdict(set) self.genre_count = defaultdict(int) self.most_popular_genre = None def _update_most_popular_genre(self): if not self.genre_count: self.most_popular_genre = None else: max_count = max(self.genre_count.values()) self.most_popular_genre = next((genre for genre, count in self.genre_count.items() if count == max_count), None) def add_genre(self, user_id: int, genre: str) -> None: if genre not in self.user_genres[user_id]: self.user_genres[user_id].add(genre) self.genre_count[genre] += 1 max_count = self.genre_count[self.most_popular_genre] if self.most_popular_genre else -1 if self.genre_count[genre] > max_count: self.most_popular_genre = genre def remove_genre(self, user_id: int, genre: str) -> None: if genre in self.user_genres[user_id]: self.user_genres[user_id].remove(genre) self.genre_count[genre] -= 1 if self.genre_count[genre] == 0: del self.genre_count[genre] if genre == self.most_popular_genre: self._update_most_popular_genre() def get_most_popular(self) -> str | None: return self.most_popular_genre"},{"question":"# Coding Assessment Question Problem Statement You are required to implement a function that takes a list of strings and returns an integer representing the number of strings that are palindromes. A palindrome is a word that reads the same forward and backward, ignoring case and non-alphanumeric characters. Function Signature ```python def count_palindromic_strings(strings: list) -> int: pass ``` Input - A list `strings` containing strings, where each string may include alphabets, digits, and punctuation marks. The list may contain up to 1000 strings. Output - An integer representing the count of palindromic strings in the input list. Constraints - Each string in the input list will not exceed 100 characters in length. Example Usage ```python assert count_palindromic_strings([\\"racecar\\", \\"Madam\\", \\"hello\\", \\"A man, a plan, a canal: Panama\\"]) == 3 assert count_palindromic_strings([\\"Not a palindrome\\", \\"12321\\", \\"Was it a car or a cat I saw?\\"]) == 2 assert count_palindromic_strings([\\"No lemon, no melon!\\", \\"Palindrome\\", \\"Level\\", \\"Refer\\"]) == 3 ``` Notes - Ensure that your function ignores case and non-alphanumeric characters while checking for palindromes. - The function should efficiently process the input list, aiming for a time complexity of O(m*n) where m is the number of strings and n is the average length of each string.","solution":"def count_palindromic_strings(strings: list) -> int: import re def is_palindrome(s: str) -> bool: s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() return s == s[::-1] count = 0 for string in strings: if is_palindrome(string): count += 1 return count"},{"question":"# Problem Statement You are given a class `MatrixOperations` that performs specific matrix-related calculations. Your task is to extend this class by implementing two additional methods: 1. `is_symmetric(self) -> bool` 2. `rotate_90_clockwise(self) -> List[List[int]]` 1. The method `is_symmetric` should determine if the matrix is symmetric. A matrix is symmetric if it is equal to its transpose. **Input**: - No input (other than `self`). **Output**: - (bool): Returns `True` if the matrix is symmetric, otherwise `False`. 2. The method `rotate_90_clockwise` should rotate the matrix 90 degrees clockwise and return the resulting matrix. **Input**: - No input (other than `self`). **Output**: - (List[List[int]]): A new matrix representing the rotated version. # Constraints * You may assume the matrix only contains integer values. * The matrix will be a square matrix (n x n). * The constraints for inputs are as follows: - Matrix size is up to 300 x 300. - Matrix values are between -10^9 and 10^9. # Example: ```python # Example usage of the methods: matrix_m = MatrixOperations([[1, 2, 3], [2, 5, 6], [3, 6, 9]]) # Method: is_symmetric() print(matrix_m.is_symmetric()) # Output should be True # Method: rotate_90_clockwise() print(matrix_m.rotate_90_clockwise()) # Output should be [[3, 6, 9], [2, 5, 6], [1, 2, 3]] matrix_n = MatrixOperations([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Method: is_symmetric() print(matrix_n.is_symmetric()) # Output should be False # Method: rotate_90_clockwise() print(matrix_n.rotate_90_clockwise()) # Output should be [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` You need to add the above methods in the given `MatrixOperations` class and ensure all the provided examples work correctly.","solution":"from typing import List class MatrixOperations: def __init__(self, matrix: List[List[int]]): self.matrix = matrix def is_symmetric(self) -> bool: n = len(self.matrix) for i in range(n): for j in range(i, n): if self.matrix[i][j] != self.matrix[j][i]: return False return True def rotate_90_clockwise(self) -> List[List[int]]: n = len(self.matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n-1-i] = self.matrix[i][j] return rotated"},{"question":"# Palindrome Sentences You are tasked with creating a function that checks if a given sentence is a palindrome. A sentence is considered a palindrome if it reads the same backward as forward when non-alphanumeric characters are ignored, and case is not considered. Implement the function to validate such sentences. **Function Signature**: ```python def is_palindrome_sentence(sentence: str) -> bool: pass ``` # Constraints and Rules 1. **Ignore Non-Alphanumeric Characters**: - Consider only letters and digits while reversing the sentence. - Characters such as spaces, punctuation marks, etc., should be ignored. 2. **Case Insensitivity**: - The function should treat uppercase and lowercase letters as equally. # Expected Input and Output Formats **Input**: - A string `sentence` representing the sentence to be checked. **Output**: - A boolean value `True` if the sentence is a palindrome, otherwise `False`. # Performance Requirements - The function should run in O(n) time complexity, where n is the length of the sentence string. # Example ```python assert is_palindrome_sentence(\\"A man, a plan, a canal, Panama!\\") == True assert is_palindrome_sentence(\\"Random non-palindrome sentence.\\") == False ```","solution":"def is_palindrome_sentence(sentence: str) -> bool: Returns True if the given sentence is a palindrome when ignoring non-alphanumeric characters and considering case insensitivity. # Filter out non-alphanumeric characters and convert to lower case filtered = \'\'.join(char.lower() for char in sentence if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered == filtered[::-1]"},{"question":"# Implementing List Manipulation Functions You are required to implement several fundamental list manipulation functions. Ensure they handle edge cases effectively and produce the correct results. # Reverse List Implement a function `reverse_list(lst: list) -> list` that reverses the input list. - **Input**: A list `lst`. - **Output**: The reversed list `lst`. # List Rotation Implement a function `rotate_list(lst: list, k: int) -> list` that rotates the list to the right by `k` places. - **Input**: A list `lst` and an integer `k` representing the number of places to rotate. - **Output**: The rotated list. - **Constraint**: If `k` is greater than the length of the list, it should be reduced to `k % len(lst)`. # Remove Duplicates Implement a function `remove_duplicates(lst: list) -> list` that removes duplicate elements from a list. - **Input**: A list `lst`. - **Output**: The list with duplicates removed. - **Constraint**: Maintain the original order of elements. # Finding Common Elements Implement a function `common_elements(lst1: list, lst2: list) -> list` that finds common elements between two lists. - **Input**: Two lists `lst1` and `lst2`. - **Output**: The list of common elements. - **Constraint**: Maintain the order of `lst1`. # Examples ```python # Example for reverse list lst1 = [1, 2, 3, 4, 5] assert reverse_list(lst1) == [5, 4, 3, 2, 1] # Example for list rotation assert rotate_list(lst1, 2) == [4, 5, 1, 2, 3] # Example for removing duplicates lst2 = [1, 2, 2, 3, 4, 4, 5] assert remove_duplicates(lst2) == [1, 2, 3, 4, 5] # Example for finding common elements lst3 = [1, 3, 4, 5] assert common_elements(lst1, lst3) == [1, 3, 4, 5] ```","solution":"def reverse_list(lst): Returns the reversed list. return lst[::-1] def rotate_list(lst, k): Rotates the list to the right by k places. if not lst: return [] k = k % len(lst) return lst[-k:] + lst[:-k] def remove_duplicates(lst): Removes duplicate elements from the list while maintaining the original order. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result def common_elements(lst1, lst2): Finds common elements between two lists while maintaining the order of lst1. set2 = set(lst2) return [item for item in lst1 if item in set2]"},{"question":"Introduction: In the world of competitive coding and algorithm analysis, the concept of **Dynamic Programming (DP)** serves as a powerful tool to solve optimization problems by breaking them down into simpler subproblems. One classic example is the **Longest Increasing Subsequence (LIS)** problem. Problem: You need to enhance the implementation of the Longest Increasing Subsequence algorithm by including the **Patience Sorting** technique, which uses a combination of binary search and greedy approach to optimize the performance. # Task: 1. Implement the LIS algorithm in the class `LongestIncreasingSubsequence` that uses Patience Sorting for calculating the length of the longest increasing subsequence. 2. Optimize the algorithm to run in `O(n log n)` time complexity, where `n` is the length of the input sequence. # Input/Output Format: * **Input**: - `sequence`: A list of integers representing the sequence of numbers. * **Output**: - An integer representing the length of the longest increasing subsequence. # Constraints: 1. The sequence will consist of integers. 2. `1 <= len(sequence) <= 10^5` 3. The integers can be positive, negative, or zero. # Example: ```python sequence = [10, 9, 2, 5, 3, 7, 101, 18] lis_calculator = LongestIncreasingSubsequence(sequence) print(lis_calculator.calculate_lis()) # Output should be 4 ``` # Evaluation Criteria: 1. **Correctness**: The implemented algorithm must correctly compute the length of the longest increasing subsequence. 2. **Efficiency**: The algorithm should perform efficiently for large sequences (up to 100,000 elements). 3. **Code Quality**: Solutions should maintain readability, modularity, and proper documentation of code and optimization techniques.","solution":"import bisect class LongestIncreasingSubsequence: def __init__(self, sequence): self.sequence = sequence def calculate_lis(self): if not self.sequence: return 0 # \'tails\' will hold the minimum possible tail value for all increasing subsequences of length i+1 tails = [] for num in self.sequence: # Find the insertion position of num in tails using binary search pos = bisect.bisect_left(tails, num) # If num is larger than any element in tails if pos == len(tails): tails.append(num) # Replace the corresponding position in tails else: tails[pos] = num return len(tails)"},{"question":"**Find the Missing Element in an Arithmetic Sequence** **Problem Statement**: You are given an arithmetic sequence of integers, but one element is missing in the sequence. Implement a function to find the missing element in the sequence. An arithmetic sequence is defined as a sequence of numbers with a common difference `d` between consecutive terms. The function should return the missing integer. **Function Signature**: ```python def find_missing_element(sequence: List[int]) -> int: ``` **Input**: - A list of integers `sequence`, representing the arithmetic sequence with one missing element. **Output**: - An integer which is the missing element in the sequence. **Constraints**: - The sequence will have at least 3 elements (including the missing element) and at most 10^6 elements. - The length of the list `sequence` is guaranteed to be at least 2. - The common difference `d` can be positive, negative, or zero. **Examples**: ```python assert find_missing_element([1, 4, 7, 10, 16]) == 13 assert find_missing_element([2, 4, 8, 10, 12]) == 6 assert find_missing_element([5, 10, 20, 25]) == 15 assert find_missing_element([-3, -1, 1, 5, 7]) == 3 ``` **Edge Cases**: - The sequence contains positive, negative or zero values. - The common difference `d` is zero, so all numbers in the sequence would be the same if no element was missing. **Hint**: - Calculate the expected sum of the first n terms of the arithmetic sequence using the formula for the sum of an arithmetic series. - Subtract the actual sum of the given sequence from the expected sum to find the missing element. ```python def find_missing_element(sequence: List[int]) -> int: n = len(sequence) + 1 # Including the missing element total_sum = (n * (sequence[0] + sequence[-1])) // 2 actual_sum = sum(sequence) return total_sum - actual_sum ```","solution":"from typing import List def find_missing_element(sequence: List[int]) -> int: Finds the missing element in an arithmetic sequence n = len(sequence) + 1 # Calculate the common difference d using the first two elements d = (sequence[-1] - sequence[0]) // (len(sequence)) expected_sum = (n * (sequence[0] + sequence[0] + (n-1) * d)) // 2 actual_sum = sum(sequence) return expected_sum - actual_sum"},{"question":"# Real-Time Weather Data Aggregator Context You have been tasked with creating a real-time weather data aggregator which fetches weather data from multiple sources, processes the data to provide an average temperature, and stores the results in a database. This task involves API interactions, data processing, and database handling. Task 1. **Fetch Weather Data**: Implement the `WeatherDataAggregator` class that fetches weather data from three different APIs. You can assume the APIs return the following JSON format: ```json { \\"temperature\\": float, \\"humidity\\": int } ``` 2. **Average Temperature Calculation**: Once the data is fetched, calculate the average temperature. 3. **Database Insert**: Insert the aggregated data into a SQLite database. Your database should contain the following columns: - `timestamp` (DATETIME) - `average_temperature` (REAL) - `average_humidity` (INTEGER) Ensure to handle connection pooling and error handling appropriately. Function Signatures Implement the following methods in your class: ```python class WeatherDataAggregator: def fetch_weather_data(self) -> List[Dict[str, Any]]: Fetch weather data from the three mock APIs. Returns: List of dictionaries containing temperature and humidity data. ... def calculate_average(self, weather_data: List[Dict[str, Any]]) -> Dict[str, Any]: Calculate the average temperature and humidity from the fetched data. Args: weather_data: List of dictionaries containing temperature and humidity data. Returns: Dictionary containing the average temperature and humidity. ... def insert_data_to_db(self, average_data: Dict[str, Any]) -> None: Insert the average weather data into the SQLite database. Args: average_data: Dictionary containing the average temperature and humidity. ... def aggregate_and_store(self) -> None: Main method to fetch, calculate and store the weather data. ... ``` Constraints - Assume that the weather data APIs are available at the following endpoints: - `https://api.weather1.com/data` - `https://api.weather2.com/data` - `https://api.weather3.com/data` - Use the `requests` module to fetch data from these APIs. - Implement appropriate error handling for scenarios where an API request fails. - Ensure the average calculation ignores any missing data due to failed API requests. Example Suppose the following data is returned by the APIs: ```plaintext API 1: {\\"temperature\\": 20.0, \\"humidity\\": 70} API 2: {\\"temperature\\": 22.0, \\"humidity\\": 65} API 3: {\\"temperature\\": 18.0, \\"humidity\\": 60} ``` The calculated average should be: ```plaintext Average Temperature: 20.0 Average Humidity: 65 ``` And this data should be stored in the SQLite database along with the current timestamp. Example usage: ```python aggregator = WeatherDataAggregator() aggregator.aggregate_and_store() ``` By following these steps, when you run the aggregation, it should fetch data from the three APIs, calculate the average temperature and humidity, and store the results in your SQLite database with a timestamp.","solution":"import requests import sqlite3 from datetime import datetime from typing import List, Dict, Any class WeatherDataAggregator: def fetch_weather_data(self) -> List[Dict[str, Any]]: urls = [ \\"https://api.weather1.com/data\\", \\"https://api.weather2.com/data\\", \\"https://api.weather3.com/data\\" ] weather_data = [] for url in urls: try: response = requests.get(url) response.raise_for_status() data = response.json() weather_data.append(data) except requests.RequestException as e: print(f\\"Error fetching data from {url}: {e}\\") return weather_data def calculate_average(self, weather_data: List[Dict[str, Any]]) -> Dict[str, Any]: if not weather_data: return {\\"average_temperature\\": None, \\"average_humidity\\": None} total_temp = 0.0 total_humidity = 0 count = 0 for data in weather_data: if \'temperature\' in data and \'humidity\' in data: total_temp += data[\'temperature\'] total_humidity += data[\'humidity\'] count += 1 if count == 0: return {\\"average_temperature\\": None, \\"average_humidity\\": None} average_temperature = total_temp / count average_humidity = total_humidity / count return {\\"average_temperature\\": average_temperature, \\"average_humidity\\": average_humidity} def insert_data_to_db(self, average_data: Dict[str, Any]) -> None: conn = sqlite3.connect(\'weather_data.db\') cursor = conn.cursor() cursor.execute(\'\'\'CREATE TABLE IF NOT EXISTS weather_data ( timestamp DATETIME, average_temperature REAL, average_humidity INTEGER)\'\'\') timestamp = datetime.now() cursor.execute(\'\'\'INSERT INTO weather_data (timestamp, average_temperature, average_humidity) VALUES (?, ?, ?)\'\'\', (timestamp, average_data[\'average_temperature\'], average_data[\'average_humidity\'])) conn.commit() conn.close() def aggregate_and_store(self) -> None: weather_data = self.fetch_weather_data() average_data = self.calculate_average(weather_data) self.insert_data_to_db(average_data)"},{"question":"# Binary Search Tree (BST) Implementation with Subtree Sum Calculation You are tasked with extending the binary search tree (BST) code provided above to include a method to calculate the sum of all node values within a specified subtree. You should implement the necessary methods to support this new functionality. # Requirements: 1. Modify the `BST` class to include a method for subtree sum calculation. 2. Ensure that the method can handle invalid subtree inputs graciously (e.g., non-existing nodes). 3. Integrate the subtree sum calculation seamlessly into the existing BST operations (insert, delete, search). 4. Provide appropriate documentation and tests for your implementation. # Additional Details: - The BST nodes are defined with integer values. - You should not use additional external libraries beyond built-in Python modules. - Subtree sum calculation should operate efficiently, even for larger trees (e.g., depth greater than 10). # Input Format: You will receive: * A list of `operations` where each operation is a tuple containing the operation name (one of {\\"insert\\", \\"delete\\", \\"search\\", \\"subtree_sum\\"}) and its corresponding argument(s). # Output Format: The BST should: * Perform the sequence of operations and return results accordingly. For `subtree_sum`, return the sum of the subtree rooted at the specified node. For `search`, return whether the value exists in the BST (True or False). For `insert` and `delete`, no return value is needed. # Example Usage: ```python # Define the Node class class Node: def __init__(self, value): self.value = value self.left = None self.right = None # Define the BST class with the required methods class BST: def __init__(self): self.root = None def insert(self, value): # Insert implementation here def delete(self, value): # Delete implementation here def search(self, value): # Search implementation here def subtree_sum(self, node_value): # Subtree sum implementation here def _subtree_sum_helper(self, node): # Helper method to calculate subtree sum # Example usage: bst = BST() operations = [ (\\"insert\\", 5), (\\"insert\\", 3), (\\"insert\\", 8), (\\"insert\\", 2), (\\"insert\\", 4), (\\"insert\\", 7), (\\"delete\\", 3), (\\"search\\", 4), (\\"subtree_sum\\", 8) ] results = [] for operation, value in operations: if operation == \\"insert\\": bst.insert(value) elif operation == \\"delete\\": bst.delete(value) elif operation == \\"search\\": results.append(bst.search(value)) elif operation == \\"subtree_sum\\": results.append(bst.subtree_sum(value)) print(results) # Expected: [True, 15] assuming the inputs are processed in sequence ``` Implement the `BST` class with the necessary modifications for subtree sum calculation and handling.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left: self._insert(node.left, value) else: node.left = Node(value) else: if node.right: self._insert(node.right, value) else: node.right = Node(value) def delete(self, value): self.root = self._delete(self.root, value) def _delete(self, node, value): if node is None: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def search(self, value): return self._search(self.root, value) def _search(self, node, value): if node is None: return False if node.value == value: return True elif value < node.value: return self._search(node.left, value) else: return self._search(node.right, value) def subtree_sum(self, node_value): node = self._find(self.root, node_value) if node: return self._subtree_sum_helper(node) else: return 0 def _find(self, node, value): if node is None or node.value == value: return node if value < node.value: return self._find(node.left, value) return self._find(node.right, value) def _subtree_sum_helper(self, node): if node is None: return 0 return node.value + self._subtree_sum_helper(node.left) + self._subtree_sum_helper(node.right)"},{"question":"# Decision Tree Classifier from Scratch **Problem Statement**: Implement a Decision Tree Classifier from scratch in Python. Your task is to understand and implement the key components and functionalities of the Decision Tree algorithm. Demonstrate your coding proficiency by writing correct, optimized, and tested code. Components to Implement: 1. **Gini Impurity**: Calculate the Gini impurity of a dataset. 2. **Best Split**: Determine the best feature and threshold to split the data to minimize Gini impurity. 3. **Decision Tree**: Combine the above pieces to recursively split data and create a tree based on minimizing impurity. Requirements: 1. Implement the functions `gini_impurity()`, `best_split()`, and `decision_tree()` as described. 2. Ensure your implementation can handle edge cases and overfitting by setting a maximum depth. Input and Output: 1. **Input**: * `X` (np.ndarray): Feature matrix. * `y` (np.ndarray): Target labels. * `max_depth` (int): Maximum depth of the tree. 2. **Output**: * `tree` (dict): The trained Decision Tree model represented as a nested dictionary. Examples: ```python # Sample Inputs X = np.array([[2.0, 3.0], [1.0, 2.0], [3.0, 4.0], [4.0, 5.0], [1.5, 1.8]]) y = np.array([1, 0, 1, 0, 0]) max_depth = 3 # Call the decision tree function tree = decision_tree(X, y, max_depth) # Expected Output (format the output to match the example) print(f\\"Trained Decision Tree: {tree}\\") ``` Ensure your solution works for the sample input and appropriately handles a variety of real-world datasets, considering overfitting, edge scenarios, and result accuracy. Constraints: 1. You must adhere to the essential properties of each function. 2. Highly optimized solutions are preferred. 3. Test your implementation thoroughly using multiple test cases and edge scenarios.","solution":"import numpy as np def gini_impurity(y): Calculate the Gini impurity for a list of labels y. _, counts = np.unique(y, return_counts=True) prob = counts / len(y) return 1 - np.sum(prob**2) def best_split(X, y): Find the best feature and threshold to split on to minimize Gini impurity. best_gini = float(\\"inf\\") best_idx = 0 best_thr = 0 for idx in range(X.shape[1]): thresholds, classes = zip(*sorted(zip(X[:, idx], y))) num_left = [0] * len(np.unique(y)) num_right = counts = np.bincount(classes) for i in range(1, len(y)): c = classes[i-1] num_left[c] += 1 num_right[c] -= 1 gini_left = 1.0 - sum((num_left[x] / i) ** 2 for x in range(len(np.unique(y)))) gini_right = 1.0 - sum((num_right[x] / (len(y) - i)) ** 2 for x in range(len(np.unique(y)))) gini = (i * gini_left + (len(y) - i) * gini_right) / len(y) if thresholds[i] == thresholds[i - 1]: continue if gini < best_gini: best_gini = gini best_idx = idx best_thr = (thresholds[i] + thresholds[i - 1]) / 2 return best_idx, best_thr def decision_tree(X, y, max_depth, depth=0): Recursively builds the decision tree based on the best splits. num_samples_per_class = [np.sum(y == i) for i in np.unique(y)] most_common_class = np.argmax(num_samples_per_class) # Check the terminating conditions if max_depth == depth or len(np.unique(y)) == 1: return most_common_class # Find the best split idx, thr = best_split(X, y) # Split the data left_indices = X[:, idx] < thr right_indices = X[:, idx] >= thr left_tree = decision_tree(X[left_indices], y[left_indices], max_depth, depth + 1) right_tree = decision_tree(X[right_indices], y[right_indices], max_depth, depth + 1) return {\'feature_index\': idx, \'threshold\': thr, \'left\': left_tree, \'right\': right_tree}"},{"question":"**Scenario**: You are developing a web-based service that provides a text-based toy programming language interpreter. One of the simplest and most versatile commands in this language is the `repeat` command, which allows users to execute a portion of code a number of times. Given its importance, you need to implement the `repeat` functionality effectively. **Task**: Write a function `repeat_code(code: str, n: int) -> str` that simulates the execution of the `repeat` command in your toy programming language. The function should repeatedly execute a block of code a specified number of times. # Constraints 1. The input string `code` will have a maximum length of 1000 characters. 2. The number of repetitions `n` will be a positive integer between 1 and 1000. 3. The `code` block should be assumed to be a simple string. # Requirements 1. Ensure that the implementation handles edge cases, such as empty code strings. 2. Provide error handling for potential issues (e.g., invalid repetition values). # Expected Input and Output Format * **repeat_code(code: str, n: int) -> str** - **Input**: `code = \\"print(\'Hello\')n\\"`, `n = 3` - **Output**: `\\"print(\'Hello\')nprint(\'Hello\')nprint(\'Hello\')n\\"` - **Input**: `code = \\"x += 1n\\"`, `n = 4` - **Output**: `\\"x += 1nx += 1nx += 1nx += 1n\\"` # Performance 1. The solution should be efficient, running in linear time relative to the input string length and the number of repetitions.","solution":"def repeat_code(code: str, n: int) -> str: Returns the input code string repeated n times. Parameters: code (str): The input code block to be repeated. n (int): The number of times to repeat the code block. Returns: str: The concatenated string of the repeated code blocks. if not isinstance(code, str): raise TypeError(\\"code must be a string\\") if not isinstance(n, int) or n <= 0: raise ValueError(\\"n must be a positive integer\\") return code * n"},{"question":"**Problem Statement:** Write a function `evaluate_math_expression(expression: str) -> float` that takes a string representing a basic mathematical expression and returns the evaluated result as a float. The expression may include addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). The input expression could have extra spaces between numbers and operators which should be ignored, and the division should handle potential division by zero by raising a `ZeroDivisionError` with an appropriate message. # Input: - A string `expression` representing a basic mathematical expression that may have extra spaces. # Output: - A float representing the evaluated result of the expression. # Constraints: - The function should handle expressions up to 1000 characters long. - Ensure input sanitization and error handling. # Examples: ```python >>> evaluate_math_expression(\' 3 + 5 \') 8.0 >>> evaluate_math_expression(\'10 / 2\') 5.0 >>> evaluate_math_expression(\'10 + 2 * 3\') 16.0 >>> evaluate_math_expression(\'100 / 0\') Traceback (most recent call last): ... ZeroDivisionError: Division by zero encountered in the expression >>> evaluate_math_expression(\'- 10 - 5 + 3\') -12.0 ```","solution":"def evaluate_math_expression(expression: str) -> float: Evaluates a basic mathematical expression and returns the result as a float. Args: expression (str): The mathematical expression as a string. Returns: float: The evaluated result of the expression. Raises: ZeroDivisionError: If a division by zero occurs. try: # Removing white spaces expression = expression.replace(\\" \\", \\"\\") # Evaluating the expression result = eval(expression) return float(result) except ZeroDivisionError: raise ZeroDivisionError(\'Division by zero encountered in the expression\')"},{"question":"# Coding Assessment Question Context: You need to build a functionality that interprets a given string representing a mathematical expression and evaluates it. Problem Statement: Write a function `evaluate_expression` that takes a string representing a mathematical expression and evaluates its value. The expression can include integers, the operators `+`, `-`, `*`, `/`, and parentheses `()`. The division should perform integer division. ```python def evaluate_expression(expression: str) -> int: Evaluate the given mathematical expression string and return the resulting integer. The division should result in integer division. pass ``` Input: - `expression`: A string representing a mathematical expression containing integers, operators (`+`, `-`, `*`, `/`), and parentheses `()`. Output: - Return an integer that is the result of the evaluated expression. Constraints: - The length of the input string is between 1 and 1000. - The expression is guaranteed to be valid. Performance Requirements: - Ensure efficient parsing and calculation; aim for O(n) time complexity where n is the length of the expression. Examples: 1. `evaluate_expression(\\"2+3*4-5\\")` should return `9`. 2. `evaluate_expression(\\"(2+3)*(5-3)\\")` should return `10`. 3. `evaluate_expression(\\"14/(2+1)\\")` should return `4`. 4. `evaluate_expression(\\"2+3-4+5/2*3\\")` should return `7`. Notes: - Consider operator precedence: `*` and `/` have higher precedence than `+` and `-`. - Use appropriate data structures (like stacks) to handle the operators\' precedence and parentheses. - Handle integer division correctly, flooring the result where necessary.","solution":"def evaluate_expression(expression: str) -> int: Evaluate the given mathematical expression string and return the resulting integer. The division should result in integer division. def compute(operators, operands): right = operands.pop() left = operands.pop() operator = operators.pop() if operator == \'+\': operands.append(left + right) elif operator == \'-\': operands.append(left - right) elif operator == \'*\': operands.append(left * right) elif operator == \'/\': operands.append(int(left / right)) precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} operators = [] operands = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif expression[i] in precedence: while (operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[expression[i]]): compute(operators, operands) operators.append(expression[i]) elif expression[i] == \'(\': operators.append(expression[i]) elif expression[i] == \')\': while operators[-1] != \'(\': compute(operators, operands) operators.pop() i += 1 while operators: compute(operators, operands) return operands[0]"},{"question":"# Single Source Shortest Path Problem with Dijkstra\'s Algorithm You are tasked with implementing a function to solve the Single Source Shortest Path Problem using Dijkstra\'s algorithm. Given a list of edges representing a graph and a source vertex, your function should return a list of the shortest distances from the source vertex to all other vertices. Input - `edges`: A list of tuples where each tuple represents an edge in the format `(u, v, w)` indicating an edge from vertex `u` to vertex `v` with weight `w`. (1 ≤ length of `edges` ≤ (10^5); 0 ≤ `u`, `v` < (10^5); 1 ≤ `w` ≤ (10^3)). - `n`: An integer representing the number of vertices in the graph. (1 ≤ `n` ≤ (10^5)) - `source`: An integer representing the source vertex from which to calculate distances. (0 ≤ `source` < `n`) Output - A list of integers representing the shortest distances from the source vertex to each of the other vertices. If a vertex is not reachable from the source, the distance is represented as infinity (float(\'inf\')). Constraints - The graph is represented as an adjacency list and the number of vertices and edges is large, requiring efficient processing. - If a vertex has no incoming edges, assume its distance from the source is infinity unless it\'s the source itself. Example ```python edges = [ (0, 1, 4), (0, 2, 1), (1, 3, 1), (2, 1, 2), (2, 3, 5), (3, 4, 3) ] n = 5 source = 0 print(dijkstra(edges, n, source)) # Possible output: [0, 3, 1, 4, 7] ``` **Function Signature** ```python def dijkstra(edges: list[tuple[int, int, int]], n: int, source: int) -> list[int]: pass ``` Instructions 1. Define the function `dijkstra` using the provided signature. 2. Implement Dijkstra\'s algorithm to find the shortest paths from the source vertex. 3. Ensure that your function handles edge cases, such as disconnected graphs, isolated nodes, etc. 4. Optimize the solution to ensure it performs efficiently for large input sizes.","solution":"import heapq from collections import defaultdict def dijkstra(edges, n, source): # Create adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) # Initialize the distances and priority queue dist = [float(\'inf\')] * n dist[source] = 0 priority_queue = [(0, source)] # (distance, vertex) while priority_queue: current_dist, u = heapq.heappop(priority_queue) # If we find a larger distance in queue than known, skip if current_dist > dist[u]: continue # Explore the neighbors for v, weight in graph[u]: distance = current_dist + weight # Only consider this new path if it\'s better if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist"},{"question":"# Coding Assessment Question: Implement a Transport Layer Security (TLS) Session Key Exchange Simulator You are tasked with simulating a simplified version of a TLS session key exchange between a client and a server. **Context**: In this cryptographic protocol, clients and servers exchange a symmetric session key using asymmetric encryption. The client generates a session key, encrypts it using the server\'s public key, and sends it to the server, which then decrypts it using its private key. **Instructions**: 1. **Function 1**: Implement `generate_session_key`. 2. **Function 2**: Implement `encrypt_key`. 3. **Function 3**: Implement `decrypt_key`. # Function Definitions: 1. `generate_session_key(length: int) -> str`: * **Input**: * `length`: An integer representing the desired length of the session key in bytes. * **Output**: * Returns a random hexadecimal string of the specified length. 2. `encrypt_key(session_key: str, public_key: str) -> str`: * **Input**: * `session_key`: A string containing the session key to be encrypted. * `public_key`: A string representing the server\'s public key. * **Output**: * Returns the encrypted session key as a hexadecimal string. 3. `decrypt_key(encrypted_key: str, private_key: str) -> str`: * **Input**: * `encrypted_key`: A string containing the encrypted session key. * `private_key`: A string representing the server\'s private key. * **Output**: * Returns the decrypted session key. # Specifications: * Use the RSA encryption/decryption mechanism with provided public and private keys. * RSA encryption should use a large prime number modulus. * The public key and private key will be simulated as simple strings for brevity. * The length of the session key will be a positive integer representing the number of bytes (1 byte = 2 hex digits). # Constraints: * All strings will be ASCII. * The encryption and decryption mechanisms should use basic RSA principles but you do not need to follow the full protocol. * The session key length will not exceed 32 bytes. # Example: ```python import rsa # Assume we have an RSA library for these operations. # Generate keys (simulated key pair for ease of implementation) (public_key, private_key) = rsa.newkeys(512) # Generate a session key of 16 bytes session_key = generate_session_key(16) print(session_key) # Expected Output: 32-character hex string (e.g., \'a1b2c3d4e5f6...\') # Encrypt the session key encrypted_key = encrypt_key(session_key, public_key) print(encrypted_key) # Expected Output: Encrypted hex string # Decrypt the session key decrypted_key = decrypt_key(encrypted_key, private_key) print(decrypted_key) # Expected Output: Same 32-character hex string as session_key ``` Good luck, and showcase your ability to simulate key exchange protocols while handling encryption and decryption logic effectively!","solution":"import rsa def generate_session_key(length: int) -> str: Returns a random hexadecimal string of the specified length. :param length: Integer representing the desired length of the session key in bytes. # Generate random bytes and convert to hexadecimal string return rsa.randnum.read_random_bits(length * 8).hex() def encrypt_key(session_key: str, public_key) -> str: Encrypts the session key using the provided public key. :param session_key: String containing the session key to be encrypted. :param public_key: Public key for encryption. # Convert the session key from hex to bytes session_key_bytes = bytes.fromhex(session_key) # Encrypt the session key with RSA encrypted_key = rsa.encrypt(session_key_bytes, public_key) # Convert encrypted key to hexadecimal string return encrypted_key.hex() def decrypt_key(encrypted_key: str, private_key) -> str: Decrypts the encrypted key using the provided private key. :param encrypted_key: String containing the encrypted session key. :param private_key: Private key for decryption. # Convert the encrypted key from hex to bytes encrypted_key_bytes = bytes.fromhex(encrypted_key) # Decrypt the session key with RSA decrypted_key_bytes = rsa.decrypt(encrypted_key_bytes, private_key) # Convert decrypted key to hexadecimal string return decrypted_key_bytes.hex()"},{"question":"# Problem Statement You are tasked with creating a function that calculates the transpose of a given matrix. The function should handle edge cases and be optimized for efficiency. Assume you have a matrix represented as a 2D list. Your task is to write a function `transpose_matrix` that takes a 2D list and returns its transpose. # Input and Output Format * **Input**: A 2D list `matrix` of integers, where `matrix[i][j]` represents the value at position `(i, j)` in the matrix. - `matrix` will have dimensions `H x W`, where H is the height (number of rows) and W is the width (number of columns). * **Output**: A 2D list, representing the transpose of the input matrix. # Constraints - The dimensions of the matrix are such that `1 <= H, W <= 10^3`. - Each matrix element is an integer. # Example ```python # Example input matrix = [ [1, 2, 3], [4, 5, 6] ] # Example output transposed = [ [3, 6], [2, 5], [1, 4] ] ``` # Task Implement the function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` to calculate the transpose of the input matrix. ```python from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: # Implement your function here pass # Example usage matrix = [ [1, 2, 3], [4, 5, 6] ] print(transpose_matrix(matrix)) # Output should be # [ # [1, 4], # [2, 5], # [3, 6] # ] ```","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the given matrix. # Using zip and list comprehensions return [list(row) for row in zip(*matrix)]"},{"question":"# Question: Implement a Stack with Min Tracking You are required to implement a stack data structure that supports the following operations: - `push(x)`: Pushes the element `x` onto the stack. - `pop()`: Removes the element on the top of the stack. - `top()`: Retrieves the element on the top of the stack. - `get_min()`: Retrieves the minimum element in the stack. All the operations must be done in O(1) time complexity. Function Signatures ```python class MinStack: def __init__(self): pass def push(self, x: int) -> None: pass def pop(self) -> None: pass def top(self) -> int: pass def get_min(self) -> int: pass ``` Input * For `push(x)`: An integer `x`, with constraint (-10^5 leq x leq 10^5). * `pop()`, `top()`, and `get_min()` should not take any arguments. * Use only standard stack operations and data structures. Output * For `push(x)` and `pop()`: No output is required. * For `top()`: Return an integer, the element on the top of the stack. * For `get_min()`: Return an integer, the minimum element in the stack. Constraints Each method (push, pop, top, get_min) should operate in O(1) time. Examples ```python # Example 1: min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Output: -3 min_stack.pop() print(min_stack.top()) # Output: 0 print(min_stack.get_min()) # Output: -2 # Example 2: min_stack = MinStack() min_stack.push(1) min_stack.push(2) min_stack.push(-1) print(min_stack.get_min()) # Output: -1 min_stack.pop() print(min_stack.get_min()) # Output: 1 # Example 3: min_stack = MinStack() min_stack.push(2) print(min_stack.top()) # Output: 2 print(min_stack.get_min()) # Output: 2 min_stack.pop() print(min_stack.get_min()) # Should raise an error or handle empty stack appropriately ```","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] raise IndexError(\\"top from empty stack\\") def get_min(self) -> int: if self.min_stack: return self.min_stack[-1] raise IndexError(\\"get_min from empty stack\\")"},{"question":"# Binary Classification with Logistic Regression You are provided with a dataset consisting of binary classification tasks where each data point has multiple features and a binary label (0 or 1). Your task is to implement a function using `LogisticRegression` from `scikit-learn` to classify the data points. **Function Implementation:** 1. **Function Signature**: `def logistic_regression_classifier(data: dict) -> float:` 2. **Input**: The input will be a dictionary with two keys, - `data`: A list of lists where each inner list represents the features of a data point. - `target`: A list of binary labels corresponding to each list of features in `data`. 3. **Process**: * Split the dataset into training and testing sets using an 80-20 ratio for training and testing respectively. * Train the Logistic Regression classifier using the training dataset. * Predict the labels for the test dataset. * Evaluate the model performance using accuracy score. 4. **Output**: A float representing the accuracy score of the Logistic Regression model on the test dataset. **Constraints**: * Ensure to standardize the data before training the model. * Utilize an appropriate solver for the Logistic Regression to ensure convergence. * Evaluate the model performance using the accuracy score. **Example**: ```python >>> data = { ... \\"data\\": [ ... [5.1, 3.5, 1.4, 0.2], ... [4.9, 3.0, 1.4, 0.2], ... # Add more feature sets ... ], ... \\"target\\": [0, 0, # Add more binary labels ... ] ... } >>> logistic_regression_classifier(data) 0.95 # Example output representing accuracy score of the model ``` **Note**: The example provided is based on the Iris dataset where the task is in a binary class setting. This function should be adaptable to any binary classification problem by using appropriate preprocessing and model evaluation techniques. Good luck, and ensure your solution is tested across multiple datasets to validate its performance!","solution":"from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.preprocessing import StandardScaler from sklearn.metrics import accuracy_score def logistic_regression_classifier(data: dict) -> float: Train a logistic regression classifier and return the accuracy on test set. Parameters: - data (dict): Contains \\"data\\" (list of lists of features) and \\"target\\" (list of binary labels) Returns: - float: Accuracy score of the logistic regression model on the test set # Extract features and target from the data dictionary X = data[\\"data\\"] y = data[\\"target\\"] # Split the data into training and testing sets using an 80-20 split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Standardize the features scaler = StandardScaler() X_train = scaler.fit_transform(X_train) X_test = scaler.transform(X_test) # Train the logistic regression model model = LogisticRegression(solver=\'lbfgs\', max_iter=1000) model.fit(X_train, y_train) # Predict the labels for the test set y_pred = model.predict(X_test) # Calculate the accuracy score accuracy = accuracy_score(y_test, y_pred) return accuracy"},{"question":"# Context: In data processing and machine learning, dealing with series of numbers, such as the Fibonacci sequence, is common. Generating the n-th Fibonacci number efficiently is important for performance in many algorithms and simulations. # Problem Statement: Write a function `fib` that computes the n-th Fibonacci number efficiently. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 The function should be optimized for large values of n up to 10,000 using an iterative approach. # Function Signature: ```python def fib(n: int) -> int: ``` # Input: - `n`: an integer representing the position in the Fibonacci sequence (0 <= n <= 10,000). # Output: - Returns an integer which is the n-th Fibonacci number. # Constraints: - Ensure your solution runs efficiently for large values of n. - The function should handle edge cases like n = 0 or n = 1 correctly. # Example: ```python >>> fib(0) 0 >>> fib(1) 1 >>> fib(10) 55 >>> fib(100) 354224848179261915075 ``` # Additional Information: Consider using an iterative approach to avoid the overhead of recursion and to maintain efficiency. Given the constraints, the use of memoization or iterative methods is recommended to manage large calculations within the acceptable runtime limits.","solution":"def fib(n: int) -> int: Computes the n-th Fibonacci number using an iterative approach. Args: n (int): The position in the Fibonacci sequence (0 <= n <= 10,000). Returns: int: The n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Scenario You have been tasked with developing a software component for a delivery service that operates drones to deliver packages. The delivery area is represented by a 2D grid where each cell can either be free (0) or contain an obstacle (1). Drones can only fly over free cells at their current altitude and can change altitude only at certain cells marked with a `2`. The goal is to find the shortest path for a drone from a given start position to a target position, keeping altitude changes minimal. Problem Statement Write a program to implement an A* algorithm to find the shortest path in a grid from a given start position to a target position, considering both distance and altitude change costs. The algorithm needs to ensure that the path avoids obstacles and optimally uses altitude changes. The costs for moving to a neighboring cell and changing altitude are provided. Function Signature ```python def a_star_altitude(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int], move_cost: int, altitude_change_cost: int) -> Union[List[Tuple[int, int]], None]: pass ``` Input - `grid`: A 2D list representing the grid, where each cell is either `0` (free), `1` (obstacle), or `2` (change in altitude allowed). - `start`: A tuple `(y, x)` representing the starting cell. - `goal`: A tuple `(y, x)` representing the goal cell. - `move_cost`: An integer representing the cost to move to a neighboring free cell. - `altitude_change_cost`: An integer representing the additional cost to change altitude at cells marked as `2`. Output - A list of tuples representing the path from the start to the goal (inclusive), or `None` if no path exists. - The path should include the cells in order from the start to the goal cell. Constraints - The grid will be a non-empty 2D list of integers (0, 1, or 2). - There will always be at least one free cell in the grid. - `start` and `goal` will always be within the bounds of the grid and will be free cells (`0`). - You may assume there is at least one valid path between `start` and `goal`. Example ```python grid = [ [0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 2, 1, 0], [0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 2, 0, 0, 0], [0, 0, 0, 0, 1, 2, 0], [0, 0, 0, 0, 1, 0, 0] ] start = (0, 0) goal = (6, 6) move_cost = 1 altitude_change_cost = 2 print(a_star_altitude(grid, start, goal, move_cost, altitude_change_cost)) # Expected Output: [(0, 0), (0, 1), (0, 2), ... , (6, 6)] ``` # Notes - Ensure your solution handles common edge cases, such as the start being the same as the goal or the path being surrounded by obstacles. - Your algorithm should effectively manage the tradeoff between distance and altitude change costs to find the optimal path. - Consider both heuristic distance and altitude changes in your A* algorithm to evaluate the cost of moving to neighboring cells effectively.","solution":"from typing import List, Tuple, Union from heapq import heappush, heappop def a_star_altitude(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int], move_cost: int, altitude_change_cost: int) -> Union[List[Tuple[int, int]], None]: rows, cols = len(grid), len(grid[0]) def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(position: Tuple[int, int]) -> List[Tuple[int, int]]: directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] neighbors = [] for d in directions: ni, nj = position[0] + d[0], position[1] + d[1] if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] != 1: neighbors.append((ni, nj)) return neighbors open_set = [(0, start)] g_score = {start: 0} f_score = {start: heuristic(start, goal)} came_from = {} while open_set: current_cost, current = heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for neighbor in get_neighbors(current): tentative_g_score = g_score[current] + move_cost if grid[neighbor[0]][neighbor[1]] == 2: tentative_g_score += altitude_change_cost if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heappush(open_set, (f_score[neighbor], neighbor)) return None"},{"question":"# Primorial Number Calculation To assess your understanding of number theory and efficient algorithm implementation, your task is to write a function that calculates the \\"primorial\\" of a given positive integer ( n ). The primorial of ( n ), denoted as ( n# ), is the product of the first ( n ) prime numbers. For example: - The primorial of 3 (denoted as 3#) is ( 2 * 3 * 5 = 30 ). - The primorial of 5 (denoted as 5#) is ( 2 * 3 * 5 * 7 * 11 = 2310 ). # Function Signature ```python def primorial(n: int) -> int: ``` # Parameters - `n` (int): A positive integer indicating the number of prime numbers whose product should be computed. Must be greater than or equal to 1. # Returns - `int`: The primorial of the given integer ( n ). # Constraints - ( 1 leq n leq 10 ) # Notes - A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. - Ensure the function is efficient and can handle the computation within a reasonable time frame for the given constraints. # Usage Example ```python >>> primorial(1) 2 >>> primorial(3) 30 >>> primorial(5) 2310 ``` Implement the function to compute the primorial of the given integer ( n ) efficiently. Consider using a prime-generating algorithm to find the first ( n ) prime numbers.","solution":"def primorial(n: int) -> int: Calculate the primorial of n, which is the product of the first n prime numbers. def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 result = 1 for prime in primes: result *= prime return result"},{"question":"Coding Assessment Question **Scenario**: As a software developer, you often need to process a collection of tasks where each task has different priorities. A priority queue is a suitable data structure that helps manage and retrieve tasks based on their priority efficiently. Priority queues are typically implemented using heaps due to their optimal performance in such operations. **Task**: Implement a min-heap-based priority queue class with methods to insert a new task with a priority, remove the task with the highest priority (minimum value), and retrieve the task with the highest priority without removing it. # Function Signature ```python class MinHeapPriorityQueue: def __init__(self): Initialize an empty priority queue. self.heap = [] def insert(self, priority, task): Insert a new task with the given priority into the priority queue. Parameters: priority (int): The priority of the task. task (str): The task to be inserted. Returns: None pass def remove_min(self): Remove and return the task with the highest priority (minimum value). Returns: str: The task with the highest priority. Raises: IndexError: If the priority queue is empty. pass def get_min(self): Retrieve (but do not remove) the task with the highest priority. Returns: str: The task with the highest priority. Raises: IndexError: If the priority queue is empty. pass ``` # Requirements 1. **`__init__`**: - Initializes an empty priority queue. 2. **`insert(priority, task)`**: - **Input**: An integer `priority` and a string `task`. - **Output**: None. - **Constraints**: - The task must be added in such a way that the min-heap properties are maintained. 3. **`remove_min()`**: - **Output**: The string task with the highest priority. - **Constraints**: - If the priority queue is empty, raise an `IndexError`. 4. **`get_min()`**: - **Output**: The string task with the highest priority. - **Constraints**: - If the priority queue is empty, raise an `IndexError`. # Example ```python pq = MinHeapPriorityQueue() pq.insert(1, \\"Task 1\\") pq.insert(3, \\"Task 3\\") pq.insert(2, \\"Task 2\\") assert pq.get_min() == \\"Task 1\\" assert pq.remove_min() == \\"Task 1\\" assert pq.remove_min() == \\"Task 2\\" assert pq.remove_min() == \\"Task 3\\" try: pq.remove_min() except IndexError: print(\\"Priority queue is empty.\\") # Expected exception ``` # Constraints - **Time Complexity**: The solution should maintain logarithmic time complexity for insertion and deletion. - **Space Complexity**: Minimize the additional memory usage. # Note - Ensure your implementation adheres to the min-heap properties. - Document any assumptions made or specific conditions handled.","solution":"import heapq class MinHeapPriorityQueue: def __init__(self): Initialize an empty priority queue. self.heap = [] def insert(self, priority, task): Insert a new task with the given priority into the priority queue. Parameters: priority (int): The priority of the task. task (str): The task to be inserted. Returns: None heapq.heappush(self.heap, (priority, task)) def remove_min(self): Remove and return the task with the highest priority (minimum value). Returns: str: The task with the highest priority. Raises: IndexError: If the priority queue is empty. if not self.heap: raise IndexError(\\"Priority queue is empty.\\") return heapq.heappop(self.heap)[1] def get_min(self): Retrieve (but do not remove) the task with the highest priority. Returns: str: The task with the highest priority. Raises: IndexError: If the priority queue is empty. if not self.heap: raise IndexError(\\"Priority queue is empty.\\") return self.heap[0][1]"},{"question":"# Problem Statement You need to implement a function that takes an encoded string and returns its decoded version. The string will be encoded using a basic run-length encoding scheme where consecutive characters are represented by a single character followed by the number of times it appears consecutively. # Requirements Function Signature ```python def decode_run_length(encoded_str: str) -> str: ``` Functionality Description - The function should accept one parameter: * `encoded_str` (str): The string to be decoded. - The function should return the decoded string where each character in the encoded string appears exactly the number of times specified. # Constraints 1. The `encoded_str` must be a non-empty string composed of pairs of characters and digits. 2. Each character will be followed by a digit indicating the number of times it should appear. # Error Handling 1. Raise a `ValueError` if `encoded_str` is not a string. 2. Raise a `ValueError` if the string format is incorrect (not alternating characters and digits). # Performance Requirements - Implement the function such that it operates with linear time complexity, O(n), where n is the length of `encoded_str`. - Ensure the function uses O(n) additional space. # Example Usage ```python >>> decode_run_length(\\"a5b3c2\\") \'aaaaabbbcc\' >>> decode_run_length(\\"x1y2z4\\") \'xyyzzzz\' >>> decode_run_length(\\"z9\\") \'zzzzzzzzz\' >>> decode_run_length(\\"x1y1z1\\") \'xyz\' ``` In addition, ensure that the function properly raises exceptions on incorrect inputs: ```python >>> decode_run_length(123) Traceback (most recent call last): ... ValueError: Expected string as input, found <class \'int\'> >>> decode_run_length(\\"a5b3c\\") Traceback (most recent call last): ... ValueError: Invalid encoded string format, make sure it alternates characters and digits ``` Implement the function to handle these requirements and error situations accurately. --- # Solution: ```python def decode_run_length(encoded_str: str) -> str: if not isinstance(encoded_str, str): raise ValueError(f\\"Expected string as input, found {type(encoded_str).__name__}\\") decoded_str = [] i = 0 n = len(encoded_str) while i < n: if not encoded_str[i].isalpha() or (i + 1 >= n or not encoded_str[i + 1].isdigit()): raise ValueError(\\"Invalid encoded string format, make sure it alternates characters and digits\\") char = encoded_str[i] count = int(encoded_str[i + 1]) decoded_str.append(char * count) i += 2 return \'\'.join(decoded_str) ``` This function should correctly decode the run-length encoded string while handling various edge cases as detailed above.","solution":"def decode_run_length(encoded_str: str) -> str: if not isinstance(encoded_str, str): raise ValueError(f\\"Expected string as input, found {type(encoded_str).__name__}\\") decoded_str = [] i = 0 n = len(encoded_str) while i < n: if not encoded_str[i].isalpha() or (i + 1 >= n or not encoded_str[i + 1].isdigit()): raise ValueError(\\"Invalid encoded string format, make sure it alternates characters and digits\\") char = encoded_str[i] count = int(encoded_str[i + 1]) decoded_str.append(char * count) i += 2 return \'\'.join(decoded_str)"},{"question":"# Data Structures & Algorithms You are developing a software system for managing a library\'s book collection. One of the features is to efficiently search for books based on title keywords. You need to implement a data structure that supports adding new books, removing books, and searching for books by title keywords. Each book is represented by a unique id, a title, and an author\'s name. Task: Implement a class `Library` which provides the following methods: 1. `add_book(book_id: int, title: str, author: str) -> None`: Adds a new book to the library. If a book with the same id already exists, it should update the book\'s title and author. 2. `remove_book(book_id: int) -> bool`: Removes the book with the given id. Returns `True` if the book was successfully removed, `False` if the book id was not found. 3. `search_books(keyword: str) -> list[tuple[int, str, str]]`: Searches for books that contain the keyword in their title (case-insensitive) and returns a list of tuples. Each tuple contains the book\'s id, title, and author. Requirements: * Each method should handle invalid or missing input appropriately. * Optimize the search method to handle large collections efficiently. * Ensure the class maintains consistent and accurate data at all times. Constraints: * Book titles and author names only contain alphanumeric characters and spaces. * Book ids are unique positive integers. * The library can hold up to 10,000 books. Example: ```python library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") library.add_book(3, \\"Great Expectations\\", \\"Charles Dickens\\") print(library.search_books(\\"great\\")) # Output: [(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"), (3, \\"Great Expectations\\", \\"Charles Dickens\\")] library.remove_book(1) print(library.search_books(\\"great\\")) # Output: [(3, \\"Great Expectations\\", \\"Charles Dickens\\")] ``` Note: Consider using appropriate data structures to achieve efficient search, add, and remove operations.","solution":"class Library: def __init__(self): self.books = {} self.title_index = {} def add_book(self, book_id: int, title: str, author: str) -> None: if book_id in self.books: # Updating the existing book, so we need to remove old title from index old_title = self.books[book_id][0] self._remove_from_title_index(book_id, old_title) self.books[book_id] = (title, author) self._add_to_title_index(book_id, title) def remove_book(self, book_id: int) -> bool: if book_id not in self.books: return False title, _ = self.books.pop(book_id) self._remove_from_title_index(book_id, title) return True def search_books(self, keyword: str) -> list[tuple[int, str, str]]: keyword = keyword.lower() result = [] for title, book_ids in self.title_index.items(): if keyword in title: for book_id in book_ids: result.append((book_id, *self.books[book_id])) return result def _add_to_title_index(self, book_id, title): title = title.lower() if title not in self.title_index: self.title_index[title] = set() self.title_index[title].add(book_id) def _remove_from_title_index(self, book_id, title): title = title.lower() if title in self.title_index: self.title_index[title].discard(book_id) if not self.title_index[title]: del self.title_index[title]"},{"question":"# Question: Implement Huffman Coding Algorithm with Priority Queue **Background:** Huffman Coding is an algorithm used for lossless data compression. It assigns variable-length codes to input characters, with shorter codes assigned to more frequent characters. The algorithm builds a binary tree called the Huffman tree, where the paths to the leaves represent the codes for the characters. **Task:** Implement the Huffman Coding algorithm in Python using a priority queue to ensure the most frequent nodes are processed first. **Function Signature:** ```python class Node: def __init__(self, frequency: int, character: str = \'\') -> None: # Initialization function for a Node object class HuffmanCoding: def __init__(self) -> None: # Initialization function for HuffmanCoding object def build_huffman_tree(self, data: str) -> Node: # Builds the Huffman Tree and returns the root node def generate_codes(self, root: Node) -> dict[str, str]: # Generates and returns the Huffman codes from the tree def encode(self, data: str) -> str: # Encodes the input data string using the Huffman codes def decode(self, encoded_data: str) -> str: # Decodes the encoded data string using the Huffman Tree ``` **Expected Input and Output Formats:** - `Node(frequency: int, character: str = \'\')`: initializes a node with a given frequency and optional character. - `HuffmanCoding()`: initializes the HuffmanCoding object. - `build_huffman_tree(data: str) -> Node`: builds the Huffman Tree from the input string `data` and returns the root node of the tree. - `generate_codes(root: Node) -> dict[str, str]`: generates a dictionary of Huffman codes from the given Huffman Tree. - `encode(data: str) -> str`: encodes the input string `data` using the generated Huffman codes and returns the encoded string. - `decode(encoded_data: str) -> str`: decodes the input string `encoded_data` using the Huffman Tree and returns the original string. **Constraints:** 1. The input string will have a length between 1 and 10000. 2. The characters in the input string will be printable ASCII characters with frequencies between 1 and 95. 3. The encoded string will be a valid Huffman encoded string based on the input data. **Performance Requirements:** The solution should handle encoding and decoding efficiently, utilizing a time complexity of O(n log n) for building the Huffman tree and generating codes, where n is the length of the input string. **Example:** ```python data = \\"this is an example for huffman encoding\\" huffman = HuffmanCoding() huffman_tree_root = huffman.build_huffman_tree(data) huffman_codes = huffman.generate_codes(huffman_tree_root) encoded_data = huffman.encode(data) decoded_data = huffman.decode(encoded_data) print(encoded_data) # Expected output: A binary string representing the encoded data print(decoded_data) # Expected output: \\"this is an example for huffman encoding\\" ``` Implement the missing methods in the `Node` and `HuffmanCoding` classes to complete the Huffman Coding algorithm, including using a priority queue for efficiency.","solution":"import heapq class Node: def __init__(self, frequency, character=\'\'): self.frequency = frequency self.character = character self.left = None self.right = None # Define comparators for the priority queue def __lt__(self, other): return self.frequency < other.frequency class HuffmanCoding: def __init__(self): self.codes = {} self.reverse_mapping = {} def build_huffman_tree(self, data): if not data: return None frequency = {} for char in data: if char not in frequency: frequency[char] = 0 frequency[char] += 1 priority_queue = [Node(frequency[char], char) for char in frequency] heapq.heapify(priority_queue) while len(priority_queue) > 1: node1 = heapq.heappop(priority_queue) node2 = heapq.heappop(priority_queue) merged = Node(node1.frequency + node2.frequency) merged.left = node1 merged.right = node2 heapq.heappush(priority_queue, merged) return priority_queue[0] def generate_codes_helper(self, root, current_code): if root is None: return if root.character != \'\': self.codes[root.character] = current_code self.reverse_mapping[current_code] = root.character self.generate_codes_helper(root.left, current_code + \\"0\\") self.generate_codes_helper(root.right, current_code + \\"1\\") def generate_codes(self, root): current_code = \\"\\" self.generate_codes_helper(root, current_code) return self.codes def encode(self, data): encoded_text = \\"\\" for char in data: encoded_text += self.codes[char] return encoded_text def decode(self, encoded_data): current_code = \\"\\" decoded_text = \\"\\" for bit in encoded_data: current_code += bit if current_code in self.reverse_mapping: character = self.reverse_mapping[current_code] decoded_text += character current_code = \\"\\" return decoded_text"},{"question":"**Context**: Imagine you are developing a task scheduler that manages the execution of tasks with various priorities. Each task has a priority level, and the scheduler needs to execute tasks based on their priorities. **Task**: Implement a `TaskScheduler` class that uses a heap data structure to manage task execution order. Your implementation should include functions to `add_task`, `remove_task`, and `get_task` to add, remove, and retrieve the highest priority task, respectively. # Function Signature ```python class TaskScheduler: def __init__(self): pass def add_task(self, task_id: int, priority: int) -> None: pass def remove_task(self, task_id: int) -> bool: pass def get_task(self) -> int: pass ``` # Requirements 1. **Constructor**: Initialize the task scheduler. 2. **Add Task Function**: Add a new task with a given `task_id` and `priority`. If the task_id already exists, update its priority. 3. **Remove Task Function**: Remove a task identified by the `task_id`. Return `True` if removal is successful, `False` if the task is not found. 4. **Get Task Function**: Return the `task_id` of the highest priority task (the highest priority value). If there are multiple tasks with the same priority, return any one of them. Return `-1` if no tasks are present. # Constraints - Task IDs and priorities are integers. - Handle up to `10^6` tasks. - Tasks have priorities ranging from `-10^6` to `10^6`. - The system should maintain an average time complexity of O(log n) for addition and removal operations. # Example ```python # Initialize the task scheduler scheduler = TaskScheduler() # Add tasks with various priorities scheduler.add_task(1, 5) scheduler.add_task(2, 3) scheduler.add_task(3, 9) # Get the highest priority task assert scheduler.get_task() == 3 # Remove a task assert scheduler.remove_task(3) is True # Get the next highest priority task assert scheduler.get_task() == 1 # Remove a non-existent task assert scheduler.remove_task(4) is False # Add a new task with a higher priority scheduler.add_task(4, 10) assert scheduler.get_task() == 4 ``` **Note**: Ensure your implementation handles edge cases such as adding multiple tasks with the same priority, removing tasks from an empty scheduler, and updating task priorities efficiently.","solution":"import heapq class TaskScheduler: def __init__(self): self.heap = [] self.task_map = {} self.counter = 0 def add_task(self, task_id: int, priority: int) -> None: if task_id in self.task_map: # If the task_id already exists, remove it first before adding the updated one self.remove_task(task_id) entry = (-priority, self.counter, task_id) self.task_map[task_id] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_task(self, task_id: int) -> bool: if task_id not in self.task_map: return False entry = self.task_map.pop(task_id) # Mark entry as removed by setting task_id to None self.heap[self.heap.index(entry) if entry in self.heap else 0] = (-entry[0], entry[1], None) heapq.heapify(self.heap) return True def get_task(self) -> int: while self.heap: priority, count, task_id = heapq.heappop(self.heap) if task_id is not None: heapq.heappush(self.heap, (priority, count, task_id)) return task_id return -1"},{"question":"# Question: Implement a K-Nearest Neighbors (KNN) Classifier Your task is to implement the `KNNClassifier` class, which classifies new observations based on the k-nearest neighbors algorithm. The classifier should support various distance metrics, including Euclidean and Manhattan distances. Requirements: 1. Create a `KNNClassifier` class with the following methods: - `__init__(self, k=3, distance_metric=\\"euclidean\\")`: Initialize the classifier with a specified number of neighbors `k` and a distance metric. - `fit(self, X, y)`: Store the training data (`X`) and labels (`y`). - `predict(self, X_test)`: Predict the labels for the given list of test observations `X_test`. 2. Implement the distance calculations: - Euclidean distance: ( sqrt{sum (x_i - y_i)^2} ) - Manhattan distance: ( sum |x_i - y_i| ) 3. During prediction, for each test observation: - Calculate distances to all training data. - Identify the k-nearest training observations. - Assign the most common class among the k-nearest neighbors as the prediction. 4. Include appropriate validation checks for the parameters. Input: - Training observations: A list of ndarrays representing the feature vectors of the training data. - Training labels: An ndarray of integers representing the class labels of the training data. - Test observations: A list of ndarrays representing new data points to classify. Output: - Predicted labels for the test observations: A list of integers representing the predicted class for each test observation. Constraints: - Inputs to the `fit` method can have up to 10,000 observations with up to 100 features each. - Inputs to the `predict` method must be the same dimensionality as the observations used in `fit`. # Example: ```python # Define your K-Nearest Neighbors Classifier here. # Initialize the KNNClassifier knn = KNNClassifier(k=3, distance_metric=\\"euclidean\\") # Fit the KNN with training data observations = [ np.asarray([0, 1]), np.asarray([0, 2]), np.asarray([1, 1]), np.asarray([1, 2]) ] classes = np.asarray([1, 1, -1, -1]) knn.fit(observations, classes) # Predict new observations new_observations = [ np.asarray([0, 0]), np.asarray([2, 3]) ] print(knn.predict(new_observations)) # Expected output: [1, -1] (example) ``` Ensure your code meets these requirements and passes the provided example tests.","solution":"import numpy as np from collections import Counter class KNNClassifier: def __init__(self, k=3, distance_metric=\\"euclidean\\"): if not isinstance(k, int) or k <= 0: raise ValueError(\\"k must be a positive integer\\") if distance_metric not in (\\"euclidean\\", \\"manhattan\\"): raise ValueError(\\"distance_metric must be either \'euclidean\' or \'manhattan\'\\") self.k = k self.distance_metric = distance_metric def fit(self, X, y): self.X_train = np.array(X) self.y_train = np.array(y) def predict(self, X_test): X_test = np.array(X_test) predictions = [] for x_test in X_test: distances = [] for x_train in self.X_train: if self.distance_metric == \\"euclidean\\": distance = np.sqrt(np.sum((x_test - x_train) ** 2)) elif self.distance_metric == \\"manhattan\\": distance = np.sum(np.abs(x_test - x_train)) distances.append(distance) sorted_indices = np.argsort(distances) k_nearest_labels = self.y_train[sorted_indices[:self.k]] most_common = Counter(k_nearest_labels).most_common(1)[0][0] predictions.append(most_common) return predictions"},{"question":"# Coding Assessment Question Context: You are tasked with developing a function that identifies the first occurrence of a specific substring pattern within a given text. This problem is based on the idea of string matching algorithms and is similar to the well-known Knuth-Morris-Pratt (KMP) algorithm. Task: Write a Python function `find_substring_pattern(text: str, pattern: str) -> int` that locates the starting index of the first occurrence of the specified substring pattern within the provided text. If the pattern does not exist within the text, the function should return -1. 1. **Function Signature**: ```python def find_substring_pattern(text: str, pattern: str) -> int: ``` 2. **Input**: - `text` (a str): The main text in which you need to locate the pattern. - `pattern` (a str): The substring pattern you are searching for within the text. 3. **Output**: - Returns the starting index (0-based) of the first occurrence of the pattern within the text if it exists. Otherwise, returns -1. 4. **Constraints**: - The function should efficiently handle text lengths up to 100,000 characters. - The pattern length can vary from 1 to 1000 characters. - The text and pattern consist of only lowercase English letters. 5. **Performance Requirement**: - Your solution should have a time complexity of O(n + m), where n is the length of the text and m is the length of the pattern. Examples: ```python # Example 1 assert find_substring_pattern(\\"abdabcababc\\", \\"abc\\") == 3 # Example 2 assert find_substring_pattern(\\"abcdefg\\", \\"hij\\") == -1 # Example 3 assert find_substring_pattern(\\"aaaaaaa\\", \\"aa\\") == 0 # Example 4 assert find_substring_pattern(\\"mississippi\\", \\"issip\\") == 4 ``` Notes: - Implementing a helper function to build a partial match table (LPS array) is encouraged to optimize the pattern search. - The solution should handle edge cases such as an empty text or pattern gracefully, adhering to the constraints. - Ensure the efficiency and readability of your code through proper commenting and structuring.","solution":"def build_lps(pattern): Builds the Longest Prefix Suffix (LPS) array used in the KMP algorithm. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def find_substring_pattern(text, pattern): Finds the starting index of the first occurrence of the pattern in the text using the KMP algorithm. if not pattern: return 0 if text else -1 if not text: return -1 lps = build_lps(pattern) i = j = 0 # indices for text and pattern while i < len(text): if text[i] == pattern[j]: i += 1 j += 1 if j == len(pattern): return i - j elif i < len(text) and text[i] != pattern[j]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Coding Assessment Question You are tasked with optimizing a text search algorithm. The goal is to efficiently find the first occurrence of a pattern in a given text using the Rabin-Karp algorithm. This algorithm uses hashing to find any one of the set of pattern strings in a text. # Requirements 1. Implement a function `rabin_karp_search(pattern: str, text: str, prime: int = 101) -> int` such that: - `pattern`: The substring you are searching for within the text. - `text`: The string in which you are searching for the pattern. - `prime`: A prime number used as the base for hashing, with a default value of 101. 2. The function should return the index of the first occurrence of the pattern in the text. If the pattern is not found, return -1. 3. Your implementation should optimize the following: - Efficient hashing and comparison to handle large texts and patterns. - Proper management of hash collisions. - Ensure the function works correctly for edge cases, such as when the text or pattern is empty. # Example Input and Output ```python >>> rabin_karp_search(\\"test\\", \\"this is a test string\\") 10 >>> rabin_karp_search(\\"abc\\", \\"xyzabcdef\\") 3 >>> rabin_karp_search(\\"abcd\\", \\"efghijklmnopqrstuvwxyz\\") -1 ``` # Constraints - You may assume `pattern` and `text` consist only of lowercase English letters. - The length of the pattern and text will be within the range [0, 10^6]. **Note**: Focus on the efficiency of the algorithm and ensure your hash function is robust to handle various inputs effectively. --- This question tests your understanding of string matching algorithms and your ability to implement an efficient text search using the Rabin-Karp algorithm. It involves knowledge of hashing techniques and managing collisions, crucial for effective text processing.","solution":"def rabin_karp_search(pattern: str, text: str, prime: int = 101) -> int: m = len(pattern) n = len(text) if m == 0 or n == 0 or m > n: return -1 d = 256 # Number of characters in the input alphabet # Calculate the hash value of the pattern and the first window of text p_hash = 0 # Hash value for pattern t_hash = 0 # Hash value for text h = 1 # The value of h would be \\"pow(d, M-1) % prime\\" for i in range(m-1): h = (h * d) % prime # Calculate the hash value of pattern and first window of text for i in range(m): p_hash = (d * p_hash + ord(pattern[i])) % prime t_hash = (d * t_hash + ord(text[i])) % prime # Slide the pattern over text one by one for i in range(n - m + 1): # Check the hash values of current window of text and pattern # If the hash values match then only check for characters one by one if p_hash == t_hash: # Check for characters one by one match = True for j in range(m): if text[i + j] != pattern[j]: match = False break if match: return i # Calculate hash value for next window of text: Remove leading digit, # add trailing digit if i < n - m: t_hash = (d * (t_hash - ord(text[i]) * h) + ord(text[i + m])) % prime # We might get negative value of t_hash, converting it to positive if t_hash < 0: t_hash = t_hash + prime return -1"},{"question":"# Problem Statement: You are tasked with creating a function that generates possible permutations of a given input string. This involves backtracking and understanding how to manage recursion to build up potential combinations of characters from the provided string. # Function Definition Implement a function `generate_permutations(s: str) -> List[str]` that computes all unique permutations of the string `s`. # Input - `s`: A string containing distinct characters. # Output - A list of strings, where each string is a unique permutation of the input string `s`. # Constraints - The length of the string ( |s| ) is between 1 and 8 inclusive. - The string contains only distinct lowercase English letters (a-z). # Examples ```python # Example 1: >>> generate_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] # Example 2: >>> generate_permutations(\\"a\\") [\'a\'] # Example 3: >>> generate_permutations(\\"ab\\") [\'ab\', \'ba\'] ``` # Notes - Ensure the output list is in lexicographical order to match the given examples. - Utilize backtracking to generate the permutations efficiently. - Document any edge cases in comments and ensure the function handles them gracefully. - Consider time complexity and optimization, but prioritize clarity and correctness for the given problem constraints. # Example Usage ```python def generate_permutations(s: str) -> List[str]: # Base case for recursion: a single character string returns itself if len(s) == 1: return [s] # List to hold the result permutations permutations = [] # Iterate over all characters in the string for i, char in enumerate(s): # Permute the rest of the string after removing the current character for perm in generate_permutations(s[:i] + s[i+1:]): # Append the current character to the front of each permutation generated permutations.append(char + perm) # Return the sorted list of permutations to ensure consistent order return sorted(permutations) # Test cases print(generate_permutations(\\"abc\\")) # [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] print(generate_permutations(\\"a\\")) # [\'a\'] print(generate_permutations(\\"ab\\")) # [\'ab\', \'ba\'] ```","solution":"from typing import List def generate_permutations(s: str) -> List[str]: Generate all unique permutations of the string `s`. :param s: A string containing distinct characters. :return: A list of unique permutations of the string `s`. # Base case for recursion: a single character string returns itself if len(s) == 1: return [s] # List to hold the result permutations permutations = [] # Iterate over all characters in the string for i, char in enumerate(s): # Permute the rest of the string after removing the current character for perm in generate_permutations(s[:i] + s[i+1:]): # Append the current character to the front of each permutation generated permutations.append(char + perm) # Return the sorted list of permutations to ensure consistent order return sorted(permutations)"},{"question":"# Scenario You work as a backend developer for an application that handles social media activity for users. One of your tasks is to implement a function that determines the most frequent words used in users\' comments, excluding commonly used stop words. The comments are stored in a list, and you need to process this list to find the top `k` most frequent words. # Task Write a function `top_k_frequent_words(comments: List[str], k: int) -> List[str]` that returns the `k` most frequent words from the provided list of comments, excluding a predefined set of stop words. # Input Format * `comments`: A list of strings where each string represents a user\'s comment. * `k`: An integer representing the number of top frequent words to return. # Output Format * Return a list of the `k` most frequent words in descending order of frequency. If there is a tie in frequency, sort the words lexicographically. # Constraints * The list `comments` contains at most (10^4) comments and each comment contains at most (10^3) characters. * Words consist of lowercase English letters. * Stop words are predefined and include common words such as \\"the\\", \\"is\\", \\"at\\", etc. # Example ```python def top_k_frequent_words(comments, k): stop_words = {\\"the\\", \\"is\\", \\"at\\", \\"of\\", \\"on\\", \\"and\\", \\"a\\", \\"to\\"} word_count = {} for comment in comments: words = comment.split() for word in words: if word not in stop_words: word_count[word] = word_count.get(word, 0) + 1 sorted_words = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) return [word for word, count in sorted_words[:k]] comments = [ \\"the quick brown fox jumps over the lazy dog\\", \\"the quick blue fox\\", \\"quick brown quick\\", \\"a quick brown animal\\", \\"fox jumps high\\" ] k = 3 print(top_k_frequent_words(comments, k)) # Output: [\'quick\', \'brown\', \'fox\'] ```","solution":"from typing import List def top_k_frequent_words(comments: List[str], k: int) -> List[str]: stop_words = {\\"the\\", \\"is\\", \\"at\\", \\"of\\", \\"on\\", \\"and\\", \\"a\\", \\"to\\"} word_count = {} for comment in comments: words = comment.split() for word in words: if word not in stop_words: word_count[word] = word_count.get(word, 0) + 1 sorted_words = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) return [word for word, count in sorted_words[:k]]"},{"question":"Problem Statement You are tasked with creating a function that mimics the behaviour of an exclusive OR (XOR) gate over a series of binary inputs. For an XOR gate, the output is true if an odd number of its inputs are true. Design a function `xor_gate(inputs: List[int]) -> int` that performs the following operations: * Accepts a list of binary integers (0 or 1). * Returns 1 if the number of 1s in the list is odd. * Returns 0 if the number of 1s in the list is even. # Input * A list of integers (either 0 or 1), where the length of the list is in the range 1 to 10^5. # Output * An integer, either 0 or 1, representing the result of the XOR operation over the input list. # Constraints * Ensure the input list is processed efficiently to handle the upper limit constraints effectively. # Example Input: ```python inputs = [0, 1, 1, 0, 1] ``` Output: ```python 1 ``` Explanation: There are three 1s in the list, which is an odd number, so the result is 1 (true). Input: ```python inputs = [1, 1, 1, 1] ``` Output: ```python 0 ``` Explanation: There are four 1s in the list, which is an even number, so the result is 0 (false). # Additional Requirements * Aim for an O(n) time complexity and O(1) space complexity where n is the number of elements in the input list.","solution":"def xor_gate(inputs): Mimic an XOR gate over a series of binary inputs. Returns 1 if the number of 1s in the list is odd, otherwise returns 0. return sum(inputs) % 2"},{"question":"# Coding Question: COVID-19 Data Analysis Context You are tasked with creating a function to analyze COVID-19 case data from a public API. This API returns a JSON response containing various data points related to COVID-19 cases for different countries. Task Implement a function `get_country_data(country: str) -> dict` that takes a country name as input and returns a dictionary with COVID-19 statistics for the specified country. The dictionary should contain the following keys: \\"confirmed\\", \\"deaths\\", and \\"recovered\\". Your function should gracefully handle edge cases including invalid country names and network errors. Input * `country` - A string representing the name of the country to fetch data for (e.g., \\"India\\", \\"USA\\"). Output * A dictionary containing the COVID-19 statistics for the specified country. Constraints * Handle HTTP errors and invalid country names gracefully by providing appropriate error messages or default values. * Ensure that the JSON parsing accounts for missing or incomplete data fields. Performance Requirements * The function should make efficient network calls, aiming to keep the API usage minimal. * Your solution should aim for O(1) space complexity as much as possible. Example Usage ```python # Example of calling the get_country_data function data = get_country_data(\\"India\\") print(f\\"Confirmed: {data[\'confirmed\']}, Deaths: {data[\'deaths\']}, Recovered: {data[\'recovered\']}\\") ``` Additional Information * You can use third-party libraries such as `requests` which is already imported in the provided code snippet. * The API endpoint to fetch the data is `\\"https://api.covid19api.com/dayone/country/\\"` * Ensure necessary error handling for unpredictable scenarios such as connection issues or invalid API responses. ```python import requests def get_country_data(country: str) -> dict: url = f\\"https://api.covid19api.com/dayone/country/{country}\\" try: response = requests.get(url) response.raise_for_status() data = response.json() if not data: raise ValueError(f\\"No data available for country: {country}\\") # Extract the latest data point latest_data = data[-1] return { \\"confirmed\\": latest_data.get(\\"Confirmed\\", \\"N/A\\"), \\"deaths\\": latest_data.get(\\"Deaths\\", \\"N/A\\"), \\"recovered\\": latest_data.get(\\"Recovered\\", \\"N/A\\"), } except requests.RequestException as e: print(f\\"Error fetching data: {e}\\") return {\\"confirmed\\": \\"N/A\\", \\"deaths\\": \\"N/A\\", \\"recovered\\": \\"N/A\\"} except ValueError as e: print(e) return {\\"confirmed\\": \\"N/A\\", \\"deaths\\": \\"N/A\\", \\"recovered\\": \\"N/A\\"} ```","solution":"import requests def get_country_data(country: str) -> dict: url = f\\"https://api.covid19api.com/dayone/country/{country}\\" try: response = requests.get(url) response.raise_for_status() data = response.json() if not data: raise ValueError(f\\"No data available for country: {country}\\") # Extract the latest data point latest_data = data[-1] return { \\"confirmed\\": latest_data.get(\\"Confirmed\\", \\"N/A\\"), \\"deaths\\": latest_data.get(\\"Deaths\\", \\"N/A\\"), \\"recovered\\": latest_data.get(\\"Recovered\\", \\"N/A\\"), } except requests.RequestException as e: print(f\\"Error fetching data: {e}\\") return {\\"confirmed\\": \\"N/A\\", \\"deaths\\": \\"N/A\\", \\"recovered\\": \\"N/A\\"} except ValueError as e: print(e) return {\\"confirmed\\": \\"N/A\\", \\"deaths\\": \\"N/A\\", \\"recovered\\": \\"N/A\\"}"},{"question":"# Problem Statement You are asked to implement a function that simulates the movement of a robot on a grid. The robot can move in four directions: up, down, left, or right. The grid is filled with obstacles the robot cannot pass through. Your task is to determine if the robot can reach its destination from its starting position. The function will take the following input parameters: 1. **grid**: A list of strings representing the grid, where \'S\' is the starting position, \'D\' is the destination, \'O\' represents an obstacle, and \'.\' represents free space. 2. **start**: A tuple representing the starting coordinates (row, column). 3. **destination**: A tuple representing the destination coordinates (row, column). # Input Format - `grid`: a list of strings of size n (1 ≤ n ≤ 1000) where each string has a length of m (1 ≤ m ≤ 1000). - `start`: a tuple (start_row, start_column) where 0 ≤ start_row < n and 0 ≤ start_column < m. - `destination`: a tuple (dest_row, dest_column) where 0 ≤ dest_row < n and 0 ≤ dest_column < m. # Output Format - Return a boolean value, `True` if the robot can reach the destination, `False` otherwise. # Constraints - Ensure that your function is efficient and can handle grids of the maximum possible size. - The robot can only move one cell at a time in up, down, left, or right direction. # Function Signature ```python def can_reach_destination(grid: List[str], start: Tuple[int, int], destination: Tuple[int, int]) -> bool: pass ``` # Example Input ```python grid = [ \\"S....\\", \\"..O..\\", \\"O....\\", \\".....\\", \\"...D.\\" ] start = (0, 0) destination = (4, 3) ``` Output ```python True ``` # Notes - Assume that there is exactly one \'S\' and one \'D\' in the grid. - The robot cannot move diagonally. - Implement an efficient search algorithm, such as Breadth-First Search (BFS), to find the path from the start to the destination. # Additional Notes - The grid cells that the robot visits to reach the destination can vary, depending on the algorithm implemented. The important aspect is whether or not there is a valid path.","solution":"from typing import List, Tuple from collections import deque def can_reach_destination(grid: List[str], start: Tuple[int, int], destination: Tuple[int, int]) -> bool: n = len(grid) m = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right visited = [[False for _ in range(m)] for _ in range(n)] queue = deque([start]) visited[start[0]][start[1]] = True while queue: x, y = queue.popleft() if (x, y) == destination: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] != \'O\': queue.append((nx, ny)) visited[nx][ny] = True return False"},{"question":"# Linked List Cycle Detection Scenario: You are working as a software engineer for a company developing high-performance computing solutions. One day, you receive a task to improve the reliability of certain graph-based systems. One critical component is ensuring that linked lists processed by these systems do not contain cycles, as cycles could lead to infinite loops and system crashes. Task: Your task is to implement a function to detect cycles in a singly linked list. You should use Floyd’s Tortoise and Hare algorithm, which uses two pointers to efficiently find a cycle if it exists. # Class and Function to Implement: 1. **`ListNode`**: * **Attributes**: * `val` (int): Value of the node. * `next` (`ListNode`): Pointer to the next node. 2. **`has_cycle(head)`**: * **Input**: * `head` (`ListNode`): The head node of the linked list. * **Output**: * A boolean value indicating whether the linked list contains a cycle (`True`) or not (`False`). # Constraints: * The number of nodes in the linked list can be between 0 and 10^4. * The value of each node (`val`) can be any integer. # Example: ```python # Example usage and expected outputs # Create nodes node1 = ListNode(3) node2 = ListNode(2) node3 = ListNode(0) node4 = ListNode(-4) # Link nodes to form a cycle: 3 -> 2 -> 0 -> -4 -> (back to node 2) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # Test has_cycle function print(has_cycle(node1)) # Output: True # Form a list without a cycle: 1 -> 2 node5 = ListNode(1) node6 = ListNode(2) node5.next = node6 node6.next = None print(has_cycle(node5)) # Output: False ``` Your implementation should efficiently detect the presence of a cycle in the linked list. Ensure you handle edge cases, such as empty lists or lists with a single node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head): Detect if the linked list has a cycle using Floyd\'s Tortoise and Hare algorithm. :param head: ListNode, the head of the linked list :return: bool, True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head.next # start fast one step ahead to simplify the loop logic while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"# Prefix Matching Search Query You are provided with a list of words and a prefix. Your task is to find all words in the list that start with the given prefix. Input 1. A list of strings `word_list` representing the collection of words. 2. A string `prefix` representing the prefix to search for. Output A list of strings containing all words from `word_list` that start with `prefix`. The order of the output list should match the order of the original `word_list`. Constraints * `1 <= len(word_list) <= 10^4` * `1 <= len(word_list[i]) <= 100` * `1 <= len(prefix) <= 100` * Words in `word_list` contain only lowercase English letters. Example ```python word_list = [\\"apple\\", \\"banana\\", \\"apricot\\", \\"blueberry\\", \\"cherry\\", \\"avocado\\"] prefix = \\"ap\\" # Expected output: [\'apple\', \'apricot\'] ``` Function Signature ```python def find_words_with_prefix(word_list: list[str], prefix: str) -> list[str]: pass ``` # Notes * Aim for an efficient solution that minimizes the number of unnecessary comparisons. * Consider edge cases like an empty word list or a prefix that does not match any words in the list.","solution":"def find_words_with_prefix(word_list: list[str], prefix: str) -> list[str]: Returns a list of words from word_list that start with the given prefix. :param word_list: List of words to search from :param prefix: The prefix to match :return: List of words starting with the given prefix return [word for word in word_list if word.startswith(prefix)]"},{"question":"# Coding Assessment Question **Title**: Implement Circular Array Rotation **Objective**: Implement a function to perform circular array rotation and return an element from a specific position after the rotation. **Context**: Given an array, you need to rotate its elements to the right by a certain number of steps. After rotating, you should be able to provide the value of the array at a specified position. **Task**: Write a function `circular_array_rotation` to rotate an array and then retrieve the element at a given position. # Requirements Function Definition ```python def circular_array_rotation(a: list[int], k: int, queries: list[int]) -> list[int]: Rotate the array a to the right by k steps and return the values at specified indexes. Args: a (list[int]): The array to be rotated. k (int): The number of rotations. queries (list[int]): The positions to retrieve the element from after the rotation. Returns: list[int]: A list of elements from the specified positions after the rotation. pass ``` # Constraints and Input: 1. **Array**: `a`, an array of integers where 1 <= len(a) <= 10^5. 2. **Rotations**: `k`, the number of rotations where 0 <= k <= 10^5. 3. **Queries**: `queries`, a list of integers where 1 <= len(queries) <= 10^5 and each element is a valid index of the array after the rotation. Examples: **Example 1** ```python a = [3, 8, 9, 7, 6] k = 3 queries = [0, 1, 2, 3, 4] result = circular_array_rotation(a, k, queries) print(result) # Output should be [9, 7, 6, 3, 8] ``` **Example 2** ```python a = [1, 2, 3] k = 2 queries = [0, 1, 2] result = circular_array_rotation(a, k, queries) print(result) # Output should be [2, 3, 1] ``` # Performance Requirements: - The solution should run efficiently, handling the maximum constraints for both array size and number of rotations gracefully. # Assumptions: - You can assume valid inputs are provided. - If k is larger than the length of the array, use k modulo len(a) to find the effective number of rotations.","solution":"def circular_array_rotation(a: list[int], k: int, queries: list[int]) -> list[int]: Rotate the array \'a\' to the right by \'k\' steps and return the values at specified indexes. Args: a (list[int]): The array to be rotated. k (int): The number of rotations. queries (list[int]): The positions to retrieve the element from after the rotation. Returns: list[int]: A list of elements from the specified positions after the rotation. n = len(a) # Effective number of rotations k = k % n # Rotated array rotated_array = a[-k:] + a[:-k] # List to hold the results result = [rotated_array[q] for q in queries] return result"},{"question":"# Coding Assessment Question Scenario You are tasked with generating a specific type of numeric sequence that involves unique permutations of digits in a given range. Specifically, your task is to find the k-th smallest unique permutation of digits within a specified range. Task Write a function that returns the k-th smallest unique permutation of digits from a given range [1, n]. Function Signature ```python def find_kth_permutation(n: int, k: int) -> str: ``` Input * An integer `n` (1 ≤ n ≤ 9) which specifies the range of digits from 1 to n (inclusive). * An integer `k` (1 ≤ k ≤ n!) representing the position of the permutation in lexicographic order. Output * A string representing the k-th smallest permutation of the digits in the specified range. Constraints * The digits in the permutation should be unique and range from 1 to n. * You should consider permutations in lexicographic order. Example ```python assert find_kth_permutation(3, 3) == \\"213\\" assert find_kth_permutation(4, 9) == \\"2314\\" assert find_kth_permutation(4, 1) == \\"1234\\" assert find_kth_permutation(2, 2) == \\"21\\" ``` Notes * Ensure your solution handles edge cases such as when `k` is the largest possible value within the factorial limits of `n`. * The function should compute results efficiently to handle the upper bounds of the input values. This question tests your understanding of permutations and efficient computation of lexicographic orders, similar to the complexity presented in the existing set of questions.","solution":"from math import factorial def find_kth_permutation(n: int, k: int) -> str: # Create a list of digits from 1 to n digits = list(range(1, n + 1)) # Resultant k-th permutation result = [] # Decrement k by 1 to handle zero-based index k -= 1 # Compute the k-th permutation using the factorial number system representation for i in range(n, 0, -1): # Determine the index of the current digit fact = factorial(i - 1) index = k // fact k %= fact # Append the digit at the index to the result and remove it from the list result.append(str(digits.pop(index))) # Join the result list to form the final permutation string return \'\'.join(result)"},{"question":"# Coding Question: Reverse a Subsection of a Linked List **Scenario**: You are tasked with developing a feature for a text editor that processes linked lists of characters. One of the functionalities required is to reverse a subsection of the linked list. This involves reversing the nodes within a specified portion of the list. **Problem Statement**: Implement a method `reverse_subsection` within the Node class that takes two indices, `m` and `n`, and reverses the nodes from position `m` to `n` in a given linked list. The positions are 1-based indices. # Requirements: - **Input**: - A singly linked list represented by its head node of type `Node`. - Two integers, `m` and `n`, where 1 ≤ m ≤ n ≤ length of the list. - **Output**: - The head of the modified linked list with the specified subsection reversed. # Constraints: 1. Each node contains a character and a reference to the next node. 2. The linked list is non-empty, and the indices `m` and `n` are valid. # Function Signature: ```python class Node: def reverse_subsection(self, m: int, n: int) -> \'Node\': pass ``` # Implementation in the Node Class: Your implementation should be part of the `Node` class and handle various cases robustly, including: - List where `m` equals `n` (no change to the list). - List where the entire list is reversed. - List with portions outside the specified bounds left unchanged. # Examples: 1. **Example 1**: ```python # Creating a linked list: a -> b -> c -> d -> e head = Node(\'a\') head.next = Node(\'b\') head.next.next = Node(\'c\') head.next.next.next = Node(\'d\') head.next.next.next.next = Node(\'e\') # Reversing from position 2 to 4: a -> d -> c -> b -> e reversed_head = head.reverse_subsection(2, 4) assert reversed_head.val == \'a\' assert reversed_head.next.val == \'d\' assert reversed_head.next.next.val == \'c\' assert reversed_head.next.next.next.val == \'b\' assert reversed_head.next.next.next.next.val == \'e\' ``` 2. **Example 2**: ```python # Creating a linked list: p -> q -> r head = Node(\'p\') head.next = Node(\'q\') head.next.next = Node(\'r\') # Reversing entire list: r -> q -> p reversed_head = head.reverse_subsection(1, 3) assert reversed_head.val == \'r\' assert reversed_head.next.val == \'q\' assert reversed_head.next.next.val == \'p\' ``` **Note**: Consider carefully managing pointers to handle the partial reversal within the list. Pay special attention to edge cases such as reversing portions at the beginning or end of the list. This new question aligns with the original set by focusing on linked list manipulation, requiring a good understanding of pointers and list traversal techniques, while providing a unique problem that tests similar coding skills.","solution":"class Node: def __init__(self, val: str, next: \'Node\' = None): self.val = val self.next = next def reverse_subsection(self, m: int, n: int) -> \'Node\': if m == n: return self dummy = Node(0) dummy.next = self prev = dummy # Step 1: Traverse the list to reach the node right before the subsection to be reversed for _ in range(m - 1): prev = prev.next # Step 2: Start reversing the subsection reverse_start = prev.next then = reverse_start.next for _ in range(n - m): reverse_start.next = then.next then.next = prev.next prev.next = then then = reverse_start.next return dummy.next def print_list(head: Node) -> str: result = [] current = head while current: result.append(current.val) current = current.next return \'->\'.join(result)"},{"question":"# Problem Scenario You are tasked with developing a simple memory management system for a limited-size cache. The system should efficiently store and retrieve data items using the Least Recently Used (LRU) eviction policy. # Task: Implement a class `LRUCache` that will store key-value pairs with a specified maximum capacity. The cache should support efficient get and set operations while maintaining the LRU policy. # Key Requirements: 1. Initialize the cache with a given capacity. 2. Retrieve a value using a key (get operation). 3. Insert or update a key-value pair (set operation). # Specifications: 1. **Class**: `LRUCache` 2. **Methods**: * `__init__(self, capacity: int)`: Initializes the LRU cache with the specified maximum capacity. * `get(self, key: int) -> int`: Retrieves the value associated with the specified key. Returns -1 if the key does not exist in the cache. * `set(self, key: int, value: int)`: Inserts or updates the key-value pair in the cache. If the cache exceeds the maximum capacity, it should remove the least recently used item. 3. **Input/Output**: * The `__init__` method takes an integer `capacity` representing the maximum number of items the cache can hold. * The `get` method takes an integer `key` and returns the corresponding integer `value` or -1 if the key is not present. * The `set` method takes an integer `key` and an integer `value`. # Constraints: * The capacity is a positive integer. * Key is an integer, and value is an integer. # Example: ```python # Example Usage cache = LRUCache(2) cache.set(1, 1) cache.set(2, 2) print(cache.get(1)) # returns 1 cache.set(3, 3) # evicts key 2 print(cache.get(2)) # returns -1 (not found) cache.set(4, 4) # evicts key 1 print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 ``` # Notes: * Ensure that both get and set operations have an average time complexity of O(1). * You may use any suitable data structure(s) to maintain the order of usage and manage the cache efficiently.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def set(self, key: int, value: int): if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Coding Assessment Question Context You are tasked with implementing a utility function that processes a list of strings. Each string in the list consists of a combination of words and numbers. Your goal is to sort the list such that all the strings with only words (alphabetical characters) come before any string that contains any numeric character. Within each category, the strings should be sorted lexicographically. Objective Implement the function `sort_strings(strings: list[str]) -> list[str]` that sorts the list following the described criteria. Input/Output Format - **Input**: A list of strings, `strings`, where each string can contain words, numbers, or a mix of both. - **Output**: A list of strings sorted according to the problem requirements. Constraints - `0 <= len(strings) <= 10^4` - Each string can have a length between 1 and 100 characters. - Strings will contain lowercase letters and digits. Example ```python >>> sort_strings([\\"apple\\", \\"banana1\\", \\"6oranges\\", \\"3grapes\\", \\"banana\\", \\"grape10\\"]) [\'apple\', \'banana\', \'3grapes\', \'6oranges\', \'banana1\', \'grape10\'] >>> sort_strings([\\"zoo\\", \\"amazing2\\", \\"awesome\\", \\"cool1\\", \\"best\\"]) [\'awesome\', \'best\', \'zoo\', \'amazing2\', \'cool1\'] >>> sort_strings([]) [] >>> sort_strings([\\"onlywords\\", \\"1234\\", \\"with2numbers\\"]) [\'onlywords\', \'1234\', \'with2numbers\'] ``` Requirements 1. Implement the function such that it correctly distinguishes between purely alphabetical strings and mixed strings containing digits. 2. The solution should handle edge cases, including empty lists and varied string lengths and content. 3. Ensure the function sorts the strings efficiently to handle the upper constraint limits effectively.","solution":"def sort_strings(strings: list[str]) -> list[str]: Sorts a list of strings such that all alphabetic strings come before numeric ones. Within each category, strings are sorted lexicographically. alpha_strings = sorted([s for s in strings if s.isalpha()]) mixed_strings = sorted([s for s in strings if not s.isalpha()]) return alpha_strings + mixed_strings"},{"question":"# Scenario You are working on a software project where you need to efficiently manage a large number of tasks that have dependencies. To address this requirement, you decide to implement a solution using Topological Sort, which can be utilized to determine a valid order of executing tasks given their dependencies. # Task Implement a function that performs Topological Sort on a directed acyclic graph (DAG). Given the number of tasks and their dependencies, return a list of tasks in a valid execution order. # Specifications 1. **Input:** * **num_tasks:** An integer representing the number of tasks. * **dependencies:** A list of tuples where each tuple `(a, b)` indicates that task `a` must be completed before task `b`. 2. **Output:** * A list of integers representing a valid order of tasks respecting the given dependencies. # Constraints * 1 ≤ num_tasks ≤ 10,000 * 0 ≤ len(dependencies) ≤ 100,000 * Dependencies form a directed acyclic graph. # Requirements 1. Implement the function to perform Topological Sort on the given tasks and dependencies. 2. Ensure your solution handles cycles gracefully by indicating infeasibility when detected. 3. Your solution should prioritize efficiency and handle large task sets and dependencies smoothly. # Example ```python def topological_sort(num_tasks, dependencies): # Your implementation here pass num_tasks = 6 dependencies = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)] result = topological_sort(num_tasks, dependencies) print(result) # Output should be one of the valid topological sorts, for example: [5, 4, 2, 3, 1, 0] ``` # Note Ensure thorough handling of edge cases such as tasks with no dependencies and detection of impossible scenarios due to cycles. Validate your solution with multiple test cases to ensure correctness and efficiency.","solution":"from collections import defaultdict, deque def topological_sort(num_tasks, dependencies): Perform Topological Sort on a directed acyclic graph (DAG) represented by tasks and dependencies. :param num_tasks: int - Number of tasks :param dependencies: List[Tuple[int, int]] - List of dependencies (a, b) which means task \'a\' must be completed before task \'b\' :return: List[int] - A valid topological order of tasks # Initialize in-degree array and adjacency list in_degree = [0] * num_tasks adj_list = defaultdict(list) # Build the graph for u, v in dependencies: adj_list[u].append(v) in_degree[v] += 1 # Queue for tasks with no incoming edges zero_in_degree_queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) topological_order = [] while zero_in_degree_queue: current_task = zero_in_degree_queue.popleft() topological_order.append(current_task) # Reduce the in-degree of adjacent tasks for neighbour in adj_list[current_task]: in_degree[neighbour] -= 1 if in_degree[neighbour] == 0: zero_in_degree_queue.append(neighbour) # Check if there was a cycle if len(topological_order) == num_tasks: return topological_order else: return [] # Cycle detected"},{"question":"# Expense Report Analyzer Context In business operations, analyzing expense reports is crucial for maintaining a company\'s budget. Given a list of expenses for various categories, you will implement a set of functions that can: 1. Calculate the total expenditure. 2. Find the category with the highest expenditure. 3. Filter expenses above a certain amount. Tasks 1. **Implement the `calculate_total` function**: - **Input**: A dictionary where keys are strings representing expense categories and values are lists of floats representing expenses. - **Output**: A float representing the total expenditure across all categories. 2. **Implement the `highest_expenditure_category` function**: - **Input**: A dictionary where keys are strings representing expense categories and values are lists of floats representing expenses. - **Output**: A string representing the category with the highest total expenditure. 3. **Implement the `filter_expenses` function**: - **Input**: A dictionary where keys are strings representing expense categories and values are lists of floats representing expenses. An additional parameter `threshold` is a float indicating the minimum expense amount to filter. - **Output**: A dictionary with the same structure as the input but only including expenses greater than or equal to the `threshold`. Example ```python # Example expense report expenses = { \\"Travel\\": [120.50, 85.00, 45.75], \\"Office Supplies\\": [15.99, 22.50, 30.00], \\"Entertainment\\": [200.00, 150.00, 175.25], \\"Meals\\": [50.00, 60.25] } # calculate_total examples print(calculate_total(expenses)) # should return 955.24 # highest_expenditure_category examples print(highest_expenditure_category(expenses)) # should return \'Entertainment\' # filter_expenses examples print(filter_expenses(expenses, 50.00)) # should return {\'Travel\': [120.50, 85.00], \'Office Supplies\': [], \'Entertainment\': [200.00, 150.00, 175.25], \'Meals\': [50.00, 60.25]} print(filter_expenses(expenses, 100.00)) # should return {\'Travel\': [120.50], \'Office Supplies\': [], \'Entertainment\': [200.00, 150.00, 175.25], \'Meals\': []} ``` Constraints: 1. Expense amounts are assumed to be non-negative. 2. You should return a new filtered dictionary for the `filter_expenses` function. 3. Consider edge cases such as empty categories or no expenses exceeding the threshold. 4. The input dictionary can contain an arbitrary number of categories, but each list of expenses within them will not exceed 100 items. Performance Requirement: Your solution should handle typical uses efficiently, but optimal performance for very large inputs is not critical given realistic expense report sizes and lengths.","solution":"def calculate_total(expenses): Calculate the total expenditure across all categories. Parameters: expenses (dict): A dictionary where keys are categories and values are lists of expenses. Returns: float: The total expenditure. total = 0 for category in expenses: total += sum(expenses[category]) return total def highest_expenditure_category(expenses): Find the category with the highest total expenditure. Parameters: expenses (dict): A dictionary where keys are categories and values are lists of expenses. Returns: str: The category with the highest expenditure. highest_category = None highest_sum = 0 for category, amounts in expenses.items(): category_sum = sum(amounts) if category_sum > highest_sum: highest_sum = category_sum highest_category = category return highest_category def filter_expenses(expenses, threshold): Filter the expenses above a certain amount. Parameters: expenses (dict): A dictionary where keys are categories and values are lists of expenses. threshold (float): The minimum expense amount to filter. Returns: dict: A dictionary with expenses filtered by the threshold. filtered_expenses = {category: [amount for amount in amounts if amount >= threshold] for category, amounts in expenses.items()} return filtered_expenses"},{"question":"**Tree Height Calculation with Recursion** You need to implement a function to calculate the height of a binary tree. As a quick refresher, the height of a binary tree is defined as the number of edges on the longest path from the root node to a leaf node. # Input Format: * A binary tree node class definition as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * A root node of a binary tree: ```python def tree_height(root: TreeNode) -> int: ``` # Output Format: * An integer representing the height of the binary tree. # Constraints: * The number of nodes in the binary tree can be between `0` and `10^4`. * The value of each node can be any integer. # Example: ```python # Example binary tree: # # 3 # / # 9 20 # / # 15 7 # root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(tree_height(root)) # Output: 2 ``` # Performance Requirements: * The function should use recursion efficiently, with a time complexity of O(n). # Scenario Imagine that you are developing a software tool for analyzing various properties of binary trees, such as height, balancing, and traversal. The current task is to provide an accurate calculation of the height of a given binary tree. Implement the function `tree_height` to meet the requirements and satisfy the above test cases. Consider that the height of an empty tree is -1. **Tip:** Look out for edge cases such as an empty tree and single-node tree, and ensure your function handles these cases properly.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def tree_height(root: TreeNode) -> int: if not root: return -1 left_height = tree_height(root.left) right_height = tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Context In data analysis, the mode is the value that appears most frequently in a dataset. It is a measure of central tendency that can help understand the most typical value in a distribution. If there are multiple such values, the dataset is multimodal, and it\'s common practice to return all modes sorted in ascending order. # Problem You are required to implement a function `find_modes(nums: list[int | float]) -> list[float]` that accepts a list of numeric values and returns the modes of the dataset sorted in ascending order. # Detailed Requirements 1. **Finding the Mode**: - Count the frequency of each number in the list. - Identify the number(s) with the highest frequency. 2. **Multiple Modes**: - If there is more than one mode, return all of them in ascending order. 3. **Edge Case Handling**: - If the list is empty, your function should raise a `ValueError` with the message \\"The list cannot be empty.\\" 4. **Return Value**: A list of the mode(s) in ascending order. # Function Signature ```python def find_modes(nums: list[int | float]) -> list[float]: ``` # Example ```python >>> find_modes(nums=[4, 1, 2, 3, 2]) [2.0] >>> find_modes(nums=[1, 2, 2, 3, 3]) [2.0, 3.0] >>> find_modes(nums=[-2, -7, -10, 9, 8, 4, -7, 45]) [-7.0] >>> find_modes(nums=[0, 0, 0, 1, 1, 1, 2, 2, 2]) [0.0, 1.0, 2.0] >>> find_modes(nums=[]) Traceback (most recent call last): ... ValueError: The list cannot be empty. ``` # Constraints 1. The input list can have at most 10^5 elements. 2. The elements will be integers or floats. # Notes - Implement frequency counting efficiently, ensuring the solution can handle large datasets. - Ensure the function appropriately handles and returns multiple modes when applicable.","solution":"from collections import Counter def find_modes(nums: list[int | float]) -> list[float]: Finds and returns the mode(s) from a list of numbers. If there are multiple modes, they are returned in ascending order. Parameters: nums (list[int | float]): A list of integer or float numbers. Returns: list[float]: A list of the mode(s) in ascending order. Raises: ValueError: If the input list is empty. if not nums: # Check if the list is empty raise ValueError(\\"The list cannot be empty.\\") # Count the frequency of each number in the list freq_counter = Counter(nums) # Determine the highest frequency max_freq = max(freq_counter.values()) # Find all numbers with the highest frequency modes = [num for num, freq in freq_counter.items() if freq == max_freq] # Return the sorted list of modes return sorted(modes)"},{"question":"# Task Scheduling Problem Problem Statement You are given a list of N tasks, each with a specific execution time, and M machines. Each machine can perform any task. Your goal is to determine the minimum possible time to complete all tasks by optimally assigning the tasks to the machines. Write a function `min_completion_time` that takes the following inputs: * `task_times`: A list where each element represents the execution time required for that task. * `total_machines`: An integer representing the total number of machines (M). The function should return an integer representing the minimum possible time to complete all tasks. Input Format * `task_times`: List of integers where each element represents the execution time of a task. * `total_machines`: Integer representing the total number of machines. Output Format * An integer representing the minimum possible time to complete all tasks. Constraints * 1 <= M <= 15 * 1 <= N <= 20 * 1 <= task_times[i] <= 1000 Example ```python def min_completion_time(task_times, total_machines): # Implementation goes here. # Example usage: task_times = [2, 3, 7, 10, 4] total_machines = 3 print(min_completion_time(task_times, total_machines)) # Output: 10 ``` **Explanation**: For the given example, the tasks can be distributed such that the total time taken is minimized to 10 minutes. One possible optimal assignment could be: - Machine 1: [2, 3, 4] -> Total time: 9 - Machine 2: [7] -> Total time: 7 - Machine 3: [10] -> Total time: 10 The longest time any one machine takes is 10 minutes, which is the optimal completion time.","solution":"from itertools import combinations def min_completion_time(task_times, total_machines): def can_complete_in_time(mid): Helper function to check if tasks can be completed within `mid` time with the given number of machines. current_loads = [0] * total_machines # Distribute tasks naively but ensuring we do not surpass mid time for task in task_times: min_load_index = current_loads.index(min(current_loads)) if current_loads[min_load_index] + task > mid: return False current_loads[min_load_index] += task return True task_times.sort(reverse=True) # Optimization: start with largest tasks left, right = max(task_times), sum(task_times) answer = right while left <= right: mid = (left + right) // 2 if can_complete_in_time(mid): answer = mid right = mid - 1 else: left = mid + 1 return answer"},{"question":"# Problem Statement: # Context: Evaluating the performance of different data structures is a common task in programming. One such data structure is the deque (double-ended queue), which allows insertion and deletion of elements from both ends efficiently. **Purpose**: Implement a function that models a sequence of operations on a deque and returns the resulting sequence of elements. # Task: Write a function `process_deque_operations(operations: List[Tuple[str, int]]) -> List[int]` that takes in a list of operations (each represented as a tuple) and performs them on an initially empty deque. Each operation is either a push at the beginning (\'push_front\'), push at the end (\'push_back\'), pop at the beginning (\'pop_front\'), or pop at the end (\'pop_back\') along with an integer value (for push operations only). - For \'push_front\' and \'push_back\', insert the given integer at the corresponding end of the deque. - For \'pop_front\' and \'pop_back\', remove and return the element from the corresponding end of the deque. Ignore the operation if the deque is empty at the time of the pop operation. # Input: - A list of operations (`operations`), where each operation is a tuple comprising a string and an optional integer: (\'push_front\', int), (\'push_back\', int), (\'pop_front\', int), or (\'pop_back\'). # Output: - A list of integers representing the deque\'s state after processing all the operations in order. # Constraints: - The total number of operations (`len(operations)`) is between 1 and 100,000. - The integer values for push operations are within the 32-bit signed integer range. - The operations are performed sequentially in the order they appear in the list. # Example: ```python >>> process_deque_operations([(\'push_back\', 1), (\'push_front\', 2), (\'push_back\', 3), (\'pop_front\',), (\'pop_back\',)]) [1, 3] # Explanation: The sequence of operations on the deque is as follows: # 1. push_back(1): deque becomes [1] # 2. push_front(2): deque becomes [2, 1] # 3. push_back(3): deque becomes [2, 1, 3] # 4. pop_front(): deque becomes [1, 3] (2 is removed) # 5. pop_back(): deque becomes [1] (3 is removed) ``` **Note**: Use an efficient data structure for the deque to ensure that the operations are performed in O(1) time. Python\'s `collections.deque` can be used for this purpose. Ensure proper handling of the deque for robust and error-free execution.","solution":"from collections import deque from typing import List, Tuple def process_deque_operations(operations: List[Tuple[str, int]]) -> List[int]: d = deque() for operation in operations: if operation[0] == \'push_front\': d.appendleft(operation[1]) elif operation[0] == \'push_back\': d.append(operation[1]) elif operation[0] == \'pop_front\': if len(d) > 0: d.popleft() elif operation[0] == \'pop_back\': if len(d) > 0: d.pop() return list(d)"},{"question":"# Longest Common Subsequence You are given two strings `s1` and `s2`. Write a function `longest_common_subsequence` that finds the length of the longest common subsequence (LCS) between the two strings. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. For example, \\"abc\\", \\"abg\\", \\"bdf\\", \\"aeg\\", \\"acefg\\", .. etc are subsequences of \\"abcdefg\\". Input * `s1`: A string of length `1 <= len(s1) <= 1000` * `s2`: A string of length `1 <= len(s2) <= 1000` Output * An integer representing the length of the longest common subsequence between `s1` and `s2`. Constraints * The solution should be efficient in terms of time complexity. Example ```python >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 ``` Implementation Note Your function should properly handle cases where there is no common subsequence (e.g., when `s1` and `s2` have no characters in common). Consider using dynamic programming to achieve an optimal solution.","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence between s1 and s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# AVL Tree Implementation You are required to implement and extend the functionality of an AVL Tree in Python. An AVL tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes. You have been provided with classes `Node` and `AVLTree`. Your task is to implement the following additional functionality for the AVLTree class: 1. **Search**: Implement a method `search(self, value)` that searches for a given value in the AVL tree and returns the node containing this value. If the value is not found, return `None`. 2. **Delete**: Implement a method `delete(self, value)` that deletes a node containing the given value from the AVL tree while maintaining the AVL property. 3. **Find Min**: Implement a method `find_min(self)` that finds and returns the node with the minimum value in the AVL tree. If the tree is empty, return `None`. Your implementation must ensure that the AVL tree property is maintained, and be efficient. Pay special attention to edge cases such as when the tree is empty or when inserting/deleting nodes could cause rotations. **Input Format**: - `search(self, value)` - an integer. - `delete(self, value)` - an integer. - `find_min(self)` - no input. **Output Format**: - `search(self, value)` - a Node object or `None`. - `delete(self, value)` - `None`. - `find_min(self)` - a Node object or `None`. **Constraints**: - All values in the AVL tree are unique. - The operations should ensure the tree remains balanced after each insertion and deletion. **Example**: ```python # Create a new AVLTree avl = AVLTree() # Insert elements avl.insert(30) avl.insert(20) avl.insert(40) avl.insert(10) # Search for an element node = avl.search(20) # Should return the node containing value 20 # Find the minimum element min_node = avl.find_min() # Should return the node containing value 10 # Delete an element avl.delete(20) ``` Write your solution and perform appropriate tests to ensure all methods work as expected.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.key = key self.height = 1 class AVLTree: def get_height(self, node): return node.height if node else 0 def get_balance(self, node): return self.get_height(node.left) - self.get_height(node.right) if node else 0 def right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) return x def left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def insert(self, root, key): if not root: return Node(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def search(self, root, key): if root is None or root.key == key: return root if key < root.key: return self.search(root.left, key) return self.search(root.right, key) def find_min(self, root): current = root while current.left is not None: current = current.left return current def delete(self, root, key): if not root: return root elif key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.find_min(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def insert_value(self, key): self.root = self.insert(self.root, key) def search_value(self, key): return self.search(self.root, key) def find_min_value(self): return self.find_min(self.root) if self.root else None def delete_value(self, key): self.root = self.delete(self.root, key) def __init__(self): self.root = None"},{"question":"# Coding Assessment Question: **Scenario**: Dr. A wants to design a machine learning model to fit a set of data points. However, he doesn\'t want to use traditional polynomial fitting techniques; instead, he wants to create a custom function to approximate the curve. To achieve this, he decides to use the Genetic Algorithm to find the best parameters of his custom equation that minimizes the error difference between the predicted and actual values. **Task**: Implement the Genetic Algorithm to find the optimal parameters for Dr. A\'s custom equation. **Function Signature**: ```python def genetic_algorithm_fit( data: List[Tuple[float, float]], equation: Callable[[float, List[float]], float], generations: int, population_size: int, mutation_rate: float, crossover_rate: float, parameter_range: List[Tuple[float, float]], num_parameters: int) -> List[float]: Args: data: List of tuples, where each tuple contains the x and y coordinates of the data points. equation: The custom equation function to fit the data, accepting an x value and a list of parameters, returning the predicted y value. generations: The number of generations to run the genetic algorithm. population_size: The number of individuals in the population. mutation_rate: The probability of a gene mutation in offspring. crossover_rate: The probability of crossover between pairs of individuals. parameter_range: A list of tuples specifying the minimum and maximum range for each parameter. num_parameters: The number of parameters in the equation. Returns: A list of the optimal parameters that minimize the error between the predicted and actual y values. pass ``` **Input**: 1. `data`: A list of tuples containing the x and y coordinates of the data points to fit. 2. `equation`: A callable function representing the custom equation, accepting an x value and a list of parameters. 3. `generations`: The number of generations to run the algorithm. 4. `population_size`: The number of individuals in the population. 5. `mutation_rate`: A float representing the mutation probability. 6. `crossover_rate`: A float representing the crossover probability. 7. `parameter_range`: A list of tuples containing the minimum and maximum values for each parameter. 8. `num_parameters`: The number of parameters in the custom equation. **Output**: * A list of the optimal parameters for the custom equation: * The list should contain the values of the parameters that minimize the error between the predicted and actual y values. **Constraints**: * `generations` > `0` * `population_size` > `1` * `0` <= `mutation_rate` <= `1` * `0` <= `crossover_rate` <= `1` * `len(parameter_range)` == `num_parameters` **Example:** ``` data = [(0, 1), (1, 3), (2, 7), (3, 13), (4, 21)] equation = lambda x, params: params[0] * x**2 + params[1] * x + params[2] generations = 100 population_size = 20 mutation_rate = 0.01 crossover_rate = 0.7 parameter_range = [(-10, 10), (-10, 10), (-10, 10)] num_parameters = 3 ``` **Example Call:** ```python result = genetic_algorithm_fit( data=[(0, 1), (1, 3), (2, 7), (3, 13), (4, 21)], equation=lambda x, params: params[0] * x**2 + params[1] * x + params[2], generations=100, population_size=20, mutation_rate=0.01, crossover_rate=0.7, parameter_range=[(-10, 10), (-10, 10), (-10, 10)], num_parameters=3 ) print(result) # Expected output could be: [1, 1, 1] ``` **Note**: Ensure your implementation handles the constraints efficiently and leverages the genetic algorithm principles to approximate the curve fitting. The example provided is a simple quadratic equation, but the algorithm should work for any specified equation and parameter range.","solution":"import random from typing import List, Tuple, Callable def genetic_algorithm_fit( data: List[Tuple[float, float]], equation: Callable[[float, List[float]], float], generations: int, population_size: int, mutation_rate: float, crossover_rate: float, parameter_range: List[Tuple[float, float]], num_parameters: int) -> List[float]: def initialize_population() -> List[List[float]]: population = [] for _ in range(population_size): individual = [random.uniform(*parameter_range[i]) for i in range(num_parameters)] population.append(individual) return population def fitness(individual: List[float]) -> float: total_error = 0 for x, y in data: predicted_y = equation(x, individual) total_error += (y - predicted_y) ** 2 return total_error def crossover(parent1: List[float], parent2: List[float]) -> List[float]: crossover_point = random.randint(1, num_parameters - 1) return parent1[:crossover_point] + parent2[crossover_point:] def mutate(individual: List[float]) -> List[float]: mutated_individual = individual[:] for i in range(num_parameters): if random.random() < mutation_rate: mutated_individual[i] = random.uniform(*parameter_range[i]) return mutated_individual def select(population: List[List[float]]) -> List[List[float]]: weights = [1 / fitness(ind) for ind in population] selected_individuals = random.choices(population, weights, k=population_size//2) return selected_individuals population = initialize_population() for _ in range(generations): selected_individuals = select(population) offspring = [] while len(offspring) < population_size: if random.random() < crossover_rate: parent1, parent2 = random.sample(selected_individuals, 2) child = crossover(parent1, parent2) else: parent = random.choice(selected_individuals) child = parent child = mutate(child) offspring.append(child) population = offspring best_individual = min(population, key=fitness) return best_individual"},{"question":"# Context You are given a list of integers, where each integer represents a genomic sequence value. A genomic sequence lookup table provides the corresponding amino acid for each sequence value. However, the lookup table is unsorted, and frequent searches result in inefficient lookups. # Task Refactor the search mechanism by utilizing a more efficient data structure to map genomic sequences to amino acids and perform searches optimally. # Requirements 1. Implement a class `GenomicLookup` which initializes with a given list of tuples, where each tuple consists of a genomic sequence value and its corresponding amino acid. 2. Implement the methods – `build_lookup_table(data)`, `fetch_amino_acid(sequence)`, and `all_sequences()`. 3. The `build_lookup_table(data)` method should build an efficient data structure, such as a hash map, for quick lookups. 4. The `fetch_amino_acid(sequence)` method should utilize the efficient data structure to return the corresponding amino acid for a given genomic sequence in O(1) average time complexity. 5. The `all_sequences()` method should return a list of all genomic sequence values available in the lookup table. # Input/Output - The `build_lookup_table(data)` method takes a list of tuples `(sequence, amino_acid)` and builds the lookup table. - The `fetch_amino_acid(sequence)` method takes an integer genomic sequence value and returns the corresponding amino acid as a string. If the sequence is not found, return \\"Not found\\". - The `all_sequences()` method returns a list of all genomic sequence values. # Example ```python data = [(101, \'Methionine\'), (103, \'Valine\'), (107, \'Leucine\')] lookup = GenomicLookup() lookup.build_lookup_table(data) print(lookup.fetch_amino_acid(103)) # Output: Valine print(lookup.fetch_amino_acid(108)) # Output: Not found print(lookup.all_sequences()) # Output: [101, 103, 107] ``` # Notes * Focus on the efficiency of searching operations. * Make sure the data structure used is optimal for the given context and handles collisions effectively if using a hash map.","solution":"class GenomicLookup: def __init__(self): self.lookup_table = {} def build_lookup_table(self, data): Builds a lookup table from a list of tuples (sequence, amino_acid). :param data: List[Tuple[int, str]] self.lookup_table = {sequence: amino_acid for sequence, amino_acid in data} def fetch_amino_acid(self, sequence): Fetches the amino acid corresponding to a given genomic sequence. :param sequence: int :return: str return self.lookup_table.get(sequence, \\"Not found\\") def all_sequences(self): Returns a list of all genomic sequences available in the lookup table. :return: List[int] return list(self.lookup_table.keys())"},{"question":"# Problem Description Write a function `topKFrequent(nums: List[int], k: int) -> List[int]` that returns the `k` most frequent elements from the list `nums`. The return order should be based on the frequency of elements, with the highest frequency first. If multiple elements have the same frequency, you may return them in any order. To ensure the solution\'s efficiency, aim for a time complexity of O(n log k). **Input Constraints** - `1 ≤ nums.length ≤ 10^5` - `k` is always a valid integer in the range `[1, number of unique elements in nums]` - Elements in `nums` can be both positive and negative integers. They are not limited to a specific range. **Output Description** - Implement the specified function. - The function should return the `k` most frequent elements. **Example Input** ```python nums = [1, 1, 1, 2, 2, 3] k = 2 ``` **Example Output** ```python [1, 2] ``` **Example Input** ```python nums = [1, 2, 3, 4, 4, 4, 5, 5, 5, 5] k = 1 ``` **Example Output** ```python [5] ``` **Detailed Instructions** 1. Create the function `topKFrequent` which takes a list of integers `nums` and an integer `k`. 2. Count the frequency of each element in `nums`. 3. Use an efficient algorithm to find the `k` most frequent elements. 4. Return the list of `k` elements sorted by their frequency in descending order.","solution":"from collections import Counter import heapq from typing import List def topKFrequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements from the list nums. # Count the frequency of each element in nums count = Counter(nums) # Use a heap to get the k elements with the highest frequency # heapq.nlargest to extract top k elements based on frequency return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"# Coding Assessment Question Problem Statement: Write a Python function `binary_search_range(arr: List[int], target: int) -> Tuple[int, int]` that returns a tuple containing the start and end indices of a target value within a sorted list using binary search. If the target does not exist in the list, return `(-1, -1)`. Requirements: * **Input Format**: * `arr` (List[int]): A sorted list of integers. * `target` (int): The value to search for. * **Output Format**: * `(start_index, end_index)`: A tuple containing the start and end indices of the target value. * **Constraints**: * The input list can have up to `10^5` elements. * Each element and the target value can range from `-10^9` to `10^9`. * **Performance**: * Your solution should run in O(log n) time complexity. Example: ```python >>> binary_search_range([1, 2, 2, 2, 3, 4], 2) (1, 3) >>> binary_search_range([1, 2, 2, 2, 3, 4], 1) (0, 0) >>> binary_search_range([1, 2, 3, 4, 5], 6) (-1, -1) >>> binary_search_range([], 3) (-1, -1) >>> binary_search_range([2, 2, 2, 2, 2], 2) (0, 4) ``` Hints: 1. Utilize binary search to find the leftmost (first) occurrence of the target. 2. Utilize binary search to find the rightmost (last) occurrence of the target. 3. Consider writing two helper functions `find_first(arr: List[int], target: int) -> int` and `find_last(arr: List[int], target: int) -> int` for this purpose. Edge Cases: 1. The input list is empty; should return `(-1, -1)`. 2. The target value is not present in the list; should return `(-1, -1)`. 3. All elements are the same as the target value; should return the indices of the first and last elements. Implement your function below: ```python from typing import List, Tuple def binary_search_range(arr: List[int], target: int) -> Tuple[int, int]: def find_first(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_last(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] <= target: left = mid + 1 else: right = mid - 1 return right start = find_first(arr, target) end = find_last(arr, target) if start <= end: return start, end else: return -1, -1 ```","solution":"from typing import List, Tuple def binary_search_range(arr: List[int], target: int) -> Tuple[int, int]: def find_first(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_last(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] <= target: left = mid + 1 else: right = mid - 1 return right start = find_first(arr, target) end = find_last(arr, target) if start < len(arr) and arr[start] == target: return start, end else: return -1, -1"},{"question":"# Skill Level Evaluation: Sorting Algorithm Efficiency **Scenario**: As part of a project, a software development company is required to analyze large datasets efficiently. They need an algorithm that can analyze the performance of different sorting techniques (such as bubble sort, merge sort, and quick sort) based on various input sizes. **Task**: Write a program that accepts multiple lists of integers and returns a dictionary indicating the time taken to sort each list using different sorting algorithms. Measure the execution time for each sorting method applied to each list. **Input**: - A list of integer lists, each to be sorted using the specified algorithms. **Output**: - A dictionary where the keys are the names of the sorting algorithms and the values are lists of floats representing the time taken (in seconds) to sort each corresponding input list. **Constraints**: - All input lists can have a maximum of 100,000 integers. - Include at least bubble sort, merge sort, and quick sort in your implementations. - Execution time must be measured precisely; consider using `time.time()` for resolution in seconds. **Performance Requirements**: - Ensure that the implementations of the sorting algorithms are efficient and accurate within their respective algorithmic complexity. **Function Signature**: ```python import time def compare_sorts(lists: list[list[int]]) -> dict[str, list[float]]: pass ``` **Example**: ```python # Test with multiple lists of integers lists = [ [5, 2, 9, 1, 5, 6], [3, 0, -2, 4, 8, 7, 6, 5], [10, 20, 30, 40, 50, 10, 20] ] result = compare_sorts(lists) # Sample output (exact time values may vary) print(result) # Output: # { # \'bubble_sort\': [0.0001, 0.0002, 0.0001], # \'merge_sort\': [0.00005, 0.0001, 0.00006], # \'quick_sort\': [0.00004, 0.00009, 0.00005] # } ```","solution":"import time def bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr def quick_sort(arr): if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def compare_sorts(lists): results = { \'bubble_sort\': [], \'merge_sort\': [], \'quick_sort\': [] } for arr in lists: # Bubble Sort start_time = time.time() bubble_sort(arr.copy()) results[\'bubble_sort\'].append(time.time() - start_time) # Merge Sort start_time = time.time() merge_sort(arr.copy()) results[\'merge_sort\'].append(time.time() - start_time) # Quick Sort start_time = time.time() quick_sort(arr.copy()) results[\'quick_sort\'].append(time.time() - start_time) return results"},{"question":"# Binary Tree Mirroring You are required to enhance the `BinaryTree` class by implementing a method to create a mirror image of the tree. In a mirrored binary tree, the left and right children of all nodes are swapped. Requirements: 1. Implement a `mirror` method in the `BinaryTree` class. This method will convert the given binary tree to its mirror image. 2. Additionally, implement a `preorder_traversal` method that returns a list of elements in preorder sequence (root, left, right) to verify the mirrored tree structure. Expected Input and Output: - Input: A binary tree where each node contains an integer value. - Output: The binary tree should be modified in place to its mirror image. The `preorder_traversal` method should then be used to check the new structure. Constraints: - Each node in the binary tree has either 0, 1, or 2 children. - The input binary tree can be empty. Performance Requirements: - The `mirror` method should run in (O(N)) time complexity, where (N) is the number of nodes in the tree. - The `preorder_traversal` method should also run in (O(N)) time complexity. # Example: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self): self.root = None def mirror(self): self._mirror_helper(self.root) def _mirror_helper(self, node): if node is None: return node.left, node.right = node.right, node.left self._mirror_helper(node.left) self._mirror_helper(node.right) def preorder_traversal(self): return self._preorder_helper(self.root, []) def _preorder_helper(self, node, result): if node: result.append(node.val) self._preorder_helper(node.left, result) self._preorder_helper(node.right, result) return result # Example Usage tree = BinaryTree() tree.root = Node(1) tree.root.left = Node(2) tree.root.right = Node(3) tree.root.left.left = Node(4) tree.root.left.right = Node(5) tree.mirror() print(tree.preorder_traversal()) # Output: [1, 3, 2, 5, 4] ``` Implement the methods `mirror` and `preorder_traversal` in the `BinaryTree` class to fulfill the above requirements.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self): self.root = None def mirror(self): Converts the tree to its mirror image. self._mirror_helper(self.root) def _mirror_helper(self, node): if node is None: return # Swap left and right children node.left, node.right = node.right, node.left # Recursively mirror the subtrees self._mirror_helper(node.left) self._mirror_helper(node.right) def preorder_traversal(self): Returns the list of elements in preorder sequence (root, left, right). return self._preorder_helper(self.root, []) def _preorder_helper(self, node, result): if node: result.append(node.val) self._preorder_helper(node.left, result) self._preorder_helper(node.right, result) return result # Example Usage tree = BinaryTree() tree.root = Node(1) tree.root.left = Node(2) tree.root.right = Node(3) tree.root.left.left = Node(4) tree.root.left.right = Node(5) tree.mirror() print(tree.preorder_traversal()) # Output: [1, 3, 2, 5, 4]"}]'),S={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},F={class:"card-container"},R={key:0,class:"empty-state"},L=["disabled"],z={key:0},D={key:1};function P(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",R,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",z,"See more"))],8,L)):u("",!0)])}const Y=c(S,[["render",P],["__scopeId","data-v-b0b75a6d"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/45.md","filePath":"library/45.md"}'),j={name:"library/45.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,U as default};
