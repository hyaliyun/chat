import{_ as d,o as s,c as i,a as t,m as _,t as m,C as p,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},L={class:"review"},T={class:"review-title"},R={class:"review-content"};function N(n,e,u,c,r,a){return s(),i("div",k,[t("div",L,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(m(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(m(u.poem.solution),1)])])])}const S=d(q,[["render",N],["__scopeId","data-v-ee9c88e8"]]),j=JSON.parse(`[{"question":"def count_interesting_subsequences(n: int, a: List[int]) -> int: Returns the number of different interesting subsequences. An interesting subsequence is defined as a subsequence that is in strictly increasing order and contains the maximum element of the array. >>> count_interesting_subsequences(4, [3, 1, 4, 2]) 3 >>> count_interesting_subsequences(5, [3, 1, 4, 2, 4]) 2","solution":"def count_interesting_subsequences(n, a): Returns the number of different interesting subsequences. An interesting subsequence is defined as a subsequence that is in strictly increasing order and contains the maximum element of the array. # Find the maximum element in the array max_element = max(a) # Count the number of times the maximum element appears in the array max_count = a.count(max_element) # The number of interesting subsequences is the number of different ways to choose the index # positions of the maximum elements return max_count"},{"question":"def min_moves(initial_position, queries): Calculate the minimum number of moves needed for the Chameleon Knight to reach each target position starting from its initial position. The knight can move like a standard chess knight or use a spell to instantly teleport to any square on the board. Parameters: initial_position (tuple): A tuple (x, y) where x and y are the initial coordinates of the knight. queries (list): A list of tuples where each tuple (xi, yi) represents a target position. Returns: list: A list of integers where each integer denotes the minimum number of moves for the corresponding query. >>> min_moves((1, 1), [(2, 3)]) [1] >>> min_moves((1, 1), [(4, 5)]) [1] pass","solution":"def min_moves(initial_position, queries): def knight_moves(from_pos, to_pos): # It can move either as a knight or instant teleport with spell # Distance calculation: Manhattan distance if from_pos == to_pos: return 0 return 1 # You can always move directly with the spell x, y = initial_position results = [] for (xi, yi) in queries: results.append(knight_moves((x, y), (xi, yi))) return results # Initial position from inputs initial_position = (1, 1) # List of queries from inputs queries = [(2, 3), (4, 5), (6, 6)] # Function call print(min_moves(initial_position, queries)) # This will output [1, 1, 1]"},{"question":"def can_split_into_equal_sum_subsequences(n: int, nums: List[int]) -> str: You are given a list of integers. Your task is to check whether the list can be split into two non-empty subsequences such that the sum of the elements in one subsequence is equal to the sum of the elements in the other subsequence. >>> can_split_into_equal_sum_subsequences(4, [1, 5, 11, 5]) \\"YES\\" >>> can_split_into_equal_sum_subsequences(2, [1, 2]) \\"NO\\" >>> can_split_into_equal_sum_subsequences(2, [2, 2]) \\"YES\\" >>> can_split_into_equal_sum_subsequences(5, [1, 2, 3, 4, 5]) \\"NO\\" >>> can_split_into_equal_sum_subsequences(4, [1, 1, 1, 1]) \\"YES\\" >>> can_split_into_equal_sum_subsequences(5, [3, 1, 4, 2, 2]) \\"YES\\"","solution":"def can_split_into_equal_sum_subsequences(n, nums): total_sum = sum(nums) # If the total sum is odd, it's not possible to split into two equal parts if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): if dp[i - num]: dp[i] = True return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def count_distinct_characters(s: str, queries: List[Tuple[int, int]]) -> List[int]: Returns the number of distinct characters in the specified substrings of s. Args: s (str): Input string. queries (list of tuples): Each tuple contains two integers (li, ri) representing the indices of the substring. Returns: list: List of integers where each integer is the number of distinct characters in the substring s[li...ri]. Examples: >>> count_distinct_characters(\\"ababc\\", [(1, 3), (2, 5), (1, 5)]) [2, 3, 3] >>> count_distinct_characters(\\"aaaaa\\", [(1, 5), (2, 4), (1, 1)]) [1, 1, 1]","solution":"def count_distinct_characters(s, queries): Returns the number of distinct characters in the specified substrings of s. Args: s (str): Input string. queries (list of tuple): List of tuples where each tuple contains two integers (li, ri). Returns: list: List of integers where each integer is the number of distinct characters in the substring s[li...ri]. results = [] for li, ri in queries: substring = s[li-1:ri] distinct_characters = len(set(substring)) results.append(distinct_characters) return results"},{"question":"def spiralOrder(matrix: List[List[int]]) -> List[int]: Returns all elements of the matrix in spiral order starting from the top-left corner of the matrix. >>> spiralOrder([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiralOrder([ ... [1] ... ]) [1] >>> spiralOrder([ ... [] ... ]) []","solution":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: Returns all elements of the matrix in a spiral order starting from the top-left corner. result = [] while matrix: # Add the first row result += matrix.pop(0) # Add the last element of each remaining row if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # Add the last row in reverse order if matrix: result += matrix.pop()[::-1] # Add the first element of each remaining row in reverse order if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> Tuple[int, List[int]]: You are given a weighted, undirected graph with n vertices and m edges. Each edge has a positive integer weight. Your task is to find the shortest path between two given vertices s and t. If there are multiple paths with the same shortest distance, your task is to return any of them. If there is no path, return -1 and an empty list. >>> shortest_path(5, 6, [(1, 2, 3), (1, 3, 1), (2, 4, 5), (3, 4, 2), (4, 5, 2), (3, 5, 4)], 1, 5) (5, [1, 3, 4, 5]) >>> shortest_path(3, 1, [(1, 2, 1)], 1, 3) (-1, []) >>> shortest_path(2, 1, [(1, 2, 4)], 1, 2) (4, [1, 2])","solution":"import heapq def shortest_path(n, m, edges, s, t): graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(start, end): dist = {i: float('inf') for i in range(1, n+1)} prev = {i: None for i in range(1, n+1)} dist[start] = 0 pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if u == end: path = [] while u != None: path.append(u) u = prev[u] return dist[end], path[::-1] if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance prev[v] = u heapq.heappush(pq, (distance, v)) return -1, [] dist, path = dijkstra(s, t) if dist == float('inf'): return -1, [] else: return dist, path"},{"question":"def sum_in_range(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: This function takes an array 'arr' and a list of queries 'queries'. Each query is a tuple (l, r) and the function returns a list of results, where each result is the sum of the elements from index l to index r (both inclusive). >>> sum_in_range([3, 2, -1, 6, 5], [(1, 3)]) [4] >>> sum_in_range([3, 2, -1, 6, 5], [(1, 3), (2, 4), (1, 5)]) [4, 7, 15] >>> sum_in_range([3, 2, -1, 6, 5], [(3, 3)]) [-1] >>> sum_in_range([3, 2, -1, 6, 5], [(1, 5)]) [15] >>> sum_in_range([3, 2, -1, 6, 5], [(1, 5), (1, 5)]) [15, 15] >>> sum_in_range([1], [(1, 1)]) [1] >>> sum_in_range([5, 5, 5, 5, 5], [(1, 1), (5, 5), (1, 5)]) [5, 5, 25] >>> sum_in_range([1, 3, 5, 7, 9], [(1, 3), (2, 4), (3, 5)]) [9, 15, 21]","solution":"def sum_in_range(arr, queries): This function takes an array 'arr' and a list of queries 'queries'. Each query is a tuple (l, r) and the function returns a list of results, where each result is the sum of the elements from index l to index r (both inclusive). result = [] for (l, r) in queries: result.append(sum(arr[l-1:r])) # Adjusting l and r as 1-based index is given in queries return result"},{"question":"def longest_equal_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with equal number of 0s and 1s. >>> longest_equal_subarray([1, 0, 1, 0, 1, 1, 0, 0]) 8 >>> longest_equal_subarray([0]) 0 >>> longest_equal_subarray([1]) 0 >>> longest_equal_subarray([0, 0, 0, 0]) 0 >>> longest_equal_subarray([1, 1, 1, 1]) 0 >>> longest_equal_subarray([0, 1, 0, 1, 0, 1]) 6 >>> longest_equal_subarray([0, 1, 0, 1, 1, 1, 0, 0]) 8 >>> longest_equal_subarray([0, 1] * 50000) 100000 >>> longest_equal_subarray([0, 1, 1, 0] * 25000) 100000","solution":"def longest_equal_subarray(arr): Returns the length of the longest contiguous subarray with equal number of 0s and 1s. prefix_sum = 0 max_length = 0 index_map = {0: -1} # To handle the case when subarray starts from the index 0 for i, num in enumerate(arr): # Compute the prefix sum where 0 is -1 and 1 is +1 prefix_sum += -1 if num == 0 else 1 if prefix_sum in index_map: # Calculate the length of the subarray max_length = max(max_length, i - index_map[prefix_sum]) else: # Store the first occurrence of this prefix sum index_map[prefix_sum] = i return max_length"},{"question":"def min_moves_to_single_element_array(n: int, arr: List[int]) -> int: Determines the minimum number of moves required to transform the given array into a single element array. Parameters: n (int): The number of elements in the array arr (list of int): The elements of the array Returns: int: The minimum number of moves required >>> min_moves_to_single_element_array(3, [1, 2, 3]) 2 >>> min_moves_to_single_element_array(5, [1, 1, 1, 1, 1]) 4 >>> min_moves_to_single_element_array(2, [5, 10]) 1 >>> min_moves_to_single_element_array(6, [1, 2, 3, 4, 5, 6]) 5 >>> min_moves_to_single_element_array(4, [100, 200, 300, 400]) 3 >>> min_moves_to_single_element_array(10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 9","solution":"def min_moves_to_single_element_array(n, arr): Determines the minimum number of moves required to transform the given array into a single element array. Parameters: n (int): The number of elements in the array arr (list of int): The elements of the array Returns: int: The minimum number of moves required # The minimum number of moves is always n - 1 return n - 1"},{"question":"def compute_ranks(players_scores): Computes the rank of each player based on their score. Args: players_scores (list of tuples): Each tuple contains a player's name and their score. Returns: list of tuples: Each tuple contains a player's name and their rank. pass # Example usage: # players_scores = [(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 50), (\\"Dave\\", 100)] # result = compute_ranks(players_scores) # Expected output: [('Dave', 1), ('Bob', 2), ('Alice', 3), ('Charlie', 3)] from solution import compute_ranks def test_compute_ranks_all_different_scores(): players_scores = [(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 60), (\\"Dave\\", 100)] expected_output = [('Alice', 4), ('Bob', 2), ('Charlie', 3), ('Dave', 1)] assert compute_ranks(players_scores) == expected_output def test_compute_ranks_some_same_scores(): players_scores = [(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 50), (\\"Dave\\", 90)] expected_output = [('Alice', 3), ('Bob', 2), ('Charlie', 3), ('Dave', 1)] assert compute_ranks(players_scores) == expected_output def test_compute_ranks_all_same_scores(): players_scores = [(\\"Alice\\", 50), (\\"Bob\\", 50), (\\"Charlie\\", 50), (\\"Dave\\", 50)] expected_output = [('Alice', 1), ('Bob', 1), ('Charlie', 1), ('Dave', 1)] assert compute_ranks(players_scores) == expected_output def test_compute_ranks_single_player(): players_scores = [(\\"Alice\\", 50)] expected_output = [('Alice', 1)] assert compute_ranks(players_scores) == expected_output def test_compute_ranks_descending_order_input(): players_scores = [(\\"Alice\\", 100), (\\"Bob\\", 90), (\\"Charlie\\", 80), (\\"Dave\\", 70)] expected_output = [('Alice', 1), ('Bob', 2), ('Charlie', 3), ('Dave', 4)] assert compute_ranks(players_scores) == expected_output def test_compute_ranks_with_ties_and_order(): players_scores = [(\\"Alice\\", 100), (\\"Bob\\", 100), (\\"Charlie\\", 90), (\\"Dave\\", 90)] expected_output = [('Alice', 1), ('Bob', 1), ('Charlie', 3), ('Dave', 3)] assert compute_ranks(players_scores) == expected_output","solution":"def compute_ranks(players_scores): Computes the rank of each player based on their score. Args: players_scores (list of tuples): Each tuple contains a player's name and their score. Returns: list of tuples: Each tuple contains a player's name and their rank. # Sorting players based on scores in descending order with player names as a secondary sort key. sorted_scores = sorted(players_scores, key=lambda x: (-x[1], x[0])) ranks = {} current_rank = 1 last_score = None for index, (name, score) in enumerate(sorted_scores): if last_score is None or score != last_score: ranks[score] = current_rank last_score = score current_rank += 1 return [(name, ranks[score]) for name, score in players_scores]"},{"question":"def seating_arrangement(n: int, m: int, friendships: List[Tuple[int, int]]) -> str: Determine a seating arrangement for the guests. Args: n (int): Number of guests. m (int): Number of friendships. friendships (List[Tuple[int, int]]): List of friendships (tuples of guest indices). Returns: str: \\"YES\\" followed by a valid seating arrangement if possible, otherwise \\"NO\\". >>> seating_arrangement(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) \\"YESn1 2 3 4 5 6\\" >>> seating_arrangement(4, 3, [(1, 2), (2, 3), (1, 4)]) \\"NO\\"","solution":"def seating_arrangement(n, m, friendships): from collections import defaultdict, deque # Create adjacency list for graph representation adjacent = defaultdict(list) for a, b in friendships: adjacent[a].append(b) adjacent[b].append(a) # Check if all nodes are part of a single connected component visited = [False] * (n + 1) order = [] def bfs(node): queue = deque([node]) while queue: current = queue.popleft() if visited[current]: continue visited[current] = True order.append(current) for neighbor in adjacent[current]: if not visited[neighbor]: queue.append(neighbor) # Perform BFS bfs(1) # If not all nodes are visited, seating arrangement is not possible if len(order) != n: return \\"NO\\" # Check if the order is a valid round arrangement for i in range(len(order)): if order[i-1] not in adjacent[order[i]] and order[(i+1)%n] not in adjacent[order[i]]: return \\"NO\\" return f\\"YESn{' '.join(map(str, order))}\\""},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Calculates the minimum cost to reach the bottom-right corner of a grid. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21 ...","solution":"def min_path_sum(grid): Returns the minimum cost to reach the bottom-right corner of the grid. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) # Initialize the cost grid with the same dimensions as the input grid cost = [[0] * m for _ in range(n)] cost[0][0] = grid[0][0] # Fill the first row for j in range(1, m): cost[0][j] = cost[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): cost[i][0] = cost[i-1][0] + grid[i][0] # Fill the rest of the cost grid for i in range(1, n): for j in range(1, m): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[n-1][m-1]"},{"question":"from typing import List, Tuple def find_most_liked_posts(p: int, l: int, likes: List[Tuple[int, int]]) -> List[int]: Find the post (or posts) with the highest number of unique likes. Args: p (int): The number of posts. l (int): The number of likes. likes (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, the user ID who liked the post and the post ID that was liked. Returns: List[int]: A list of post IDs with the highest number of unique likes, in ascending order. Example: >>> find_most_liked_posts(4, 8, [ ... (1, 1), ... (2, 1), ... (1, 2), ... (3, 2), ... (2, 3), ... (1, 3), ... (2, 4), ... (3, 4) ... ]) == [1, 2, 3, 4]","solution":"def find_most_liked_posts(p, l, likes): from collections import defaultdict post_likes = defaultdict(set) # Process each like entry for user_id, post_id in likes: post_likes[post_id].add(user_id) max_likes = 0 most_liked_posts = [] # Find the maximum number of unique likes any post has for post_id, user_ids in post_likes.items(): unique_like_count = len(user_ids) if unique_like_count > max_likes: max_likes = unique_like_count most_liked_posts = [post_id] elif unique_like_count == max_likes: most_liked_posts.append(post_id) return sorted(most_liked_posts) # Example usage p = 4 l = 8 likes = [ (1, 1), (2, 1), (1, 2), (3, 2), (2, 3), (1, 3), (2, 4), (3, 4) ] print(find_most_liked_posts(p, l, likes))"},{"question":"def largest_identical_square(n: int, m: int, grid: List[str]) -> int: Find the size (side length) of the largest square that can be formed such that every cell in the square contains the same letter in a given 2D grid. >>> largest_identical_square(3, 4, [\\"abcd\\", \\"bbcd\\", \\"bbcd\\"]) 2 >>> largest_identical_square(1, 1, [\\"a\\"]) 1 >>> largest_identical_square(4, 4, [\\"aaaa\\", \\"aaaa\\", \\"aaaa\\", \\"aaaa\\"]) 4 >>> largest_identical_square(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"]) 1 >>> largest_identical_square(5, 5, [\\"aaaab\\", \\"aaaab\\", \\"aaabb\\", \\"aabbb\\", \\"abbbc\\"]) 3","solution":"def largest_identical_square(n, m, grid): max_side = min(n, m) largest_square_size = 1 for side in range(2, max_side + 1): for i in range(n - side + 1): for j in range(m - side + 1): base_char = grid[i][j] is_square = True for x in range(i, i + side): for y in range(j, j + side): if grid[x][y] != base_char: is_square = False break if not is_square: break if is_square: largest_square_size = side return largest_square_size"},{"question":"def min_operations_to_greater_string(T, test_cases): Determines the minimum number of operations to make each string in test cases lexicographically greater. Parameters: T (int): the number of test cases. test_cases (list of str): a list of strings representing the test cases. Returns: list of int: the minimum number of operations for each test case, or -1 if not possible. >>> min_operations_to_greater_string(2, [\\"abc\\", \\"zzz\\"]) [1, -1] >>> min_operations_to_greater_string(3, [\\"a\\", \\"z\\", \\"cat\\"]) [1, -1, 1] >>> min_operations_to_greater_string(2, [\\"qqq\\", \\"ppz\\"]) [1, 1] >>> min_operations_to_greater_string(1, [\\"zzzzzz\\"]) [-1] >>> min_operations_to_greater_string(3, [\\"abcde\\", \\"xyz\\", \\"mno\\"]) [1, 1, 1]","solution":"def min_operations_to_greater_string(T, test_cases): Determines the minimum number of operations to make each string in test cases lexicographically greater. Parameters: T (int): the number of test cases. test_cases (list of str): a list of strings representing the test cases. Returns: list of int: the minimum number of operations for each test case, or -1 if not possible. results = [] for s in test_cases: n = len(s) is_possible = False for i in range(n - 1, -1, -1): if s[i] != 'z': is_possible = True break if not is_possible: results.append(-1) else: results.append(1) return results"},{"question":"def convert_planic_to_metric(conversion_pairs, p_new): Converts a new measurement from PLANIC units to metric units using given conversion pairs. Parameters: conversion_pairs (list of tuples): A list of (p_i, m_i) pairs representing the conversion pairs. p_new (float): The new measurement in PLANIC units to be converted. Returns: float: The converted measurement in metric units. import pytest from solution import convert_planic_to_metric def test_sample_case(): conversion_pairs = [(1.0, 2.5), (2.0, 4.5), (3.0, 6.5)] p_new = 4.0 assert convert_planic_to_metric(conversion_pairs, p_new) == 8.500000 def test_identity_case(): conversion_pairs = [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0)] p_new = 4.0 assert convert_planic_to_metric(conversion_pairs, p_new) == 4.000000 def test_random_case(): conversion_pairs = [(1.0, 3.0), (2.0, 5.0), (3.0, 7.0)] p_new = 5.0 assert convert_planic_to_metric(conversion_pairs, p_new) == 11.000000 def test_zero_slope_case(): conversion_pairs = [(1.0, 2.0), (2.0, 2.0), (3.0, 2.0)] p_new = 4.0 assert convert_planic_to_metric(conversion_pairs, p_new) == 2.000000 def test_two_points_case(): conversion_pairs = [(1.0, 2.0), (2.0, 4.0)] p_new = 3.0 assert convert_planic_to_metric(conversion_pairs, p_new) == 6.000000","solution":"def convert_planic_to_metric(conversion_pairs, p_new): Converts a new measurement from PLANIC units to metric units using given conversion pairs. Parameters: conversion_pairs (list of tuples): A list of (p_i, m_i) pairs representing the conversion pairs. p_new (float): The new measurement in PLANIC units to be converted. Returns: float: The converted measurement in metric units. n = len(conversion_pairs) # Summation for calculating a and b sum_p = sum([pair[0] for pair in conversion_pairs]) sum_m = sum([pair[1] for pair in conversion_pairs]) sum_p2 = sum([pair[0] ** 2 for pair in conversion_pairs]) sum_pm = sum([pair[0] * pair[1] for pair in conversion_pairs]) # Calculating slope (a) and intercept (b) of the linear equation m = a * p + b a = (n * sum_pm - sum_p * sum_m) / (n * sum_p2 - sum_p ** 2) b = (sum_m - a * sum_p) / n # Converting the new PLANIC measurement to metric units m_new = a * p_new + b return round(m_new, 6)"},{"question":"def magic_grid_patterns(n: int, m: int, p: int) -> int: Determine the number of ways to populate the garden to form a magic grid with the given conditions. :param n: Number of rows :param m: Number of columns :param p: Period of the periodic sequence :return: Number of ways to populate the garden modulo 1000000007 # Implement the function here pass # Unit Tests def test_case_1(): assert magic_grid_patterns(6, 6, 3) == 27 def test_case_2(): assert magic_grid_patterns(2, 4, 2) == 4 def test_case_3(): assert magic_grid_patterns(4, 4, 4) == 256 def test_case_4(): assert magic_grid_patterns(10, 10, 1) == 1 def test_case_5(): assert magic_grid_patterns(10, 10, 3) == 0 def test_case_6(): assert magic_grid_patterns(9, 3, 3) == 27","solution":"def magic_grid_patterns(n, m, p): Determine the number of ways to populate the garden to form a magic grid with the given conditions. :param n: Number of rows :param m: Number of columns :param p: Period of the periodic sequence :return: Number of ways to populate the garden modulo 1000000007 MOD = 1000000007 # If n and m are not multiples of p, it's not possible to form a valid magic grid if n % p != 0 or m % p != 0: return 0 # The number of ways to populate each repeated block is p^p result = pow(p, p, MOD) return result"},{"question":"from typing import List def find_three_sum(nums: List[int], target: int) -> List[int]: Finds any three integers in the list that add up to the target. Parameters: nums (list): List of integers target (int): Target sum Returns: list: The list containing the three integers that add up to the target or an empty list if no such combination exists. Examples: >>> find_three_sum([3, 0, -2, 1, 2, -1], 1) [-2, 0, 3] >>> find_three_sum([-1, 0, 1, 2, -1, -4], 0) [-1, -1, 2] or [-1, 0, 1] >>> find_three_sum([1, 2, 3, 4, 5], 50) []","solution":"def find_three_sum(nums, target): Finds any three integers in the list that add up to the target. Parameters: nums (list): List of integers target (int): Target sum Returns: list: The list containing the three integers that add up to the target or an empty list if no such combination exists. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return [nums[i], nums[left], nums[right]] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"def calculate_sum(n: int) -> int: Returns the sum of the first n terms of the series: 1, -2, 3, -4, 5, -6, ... >>> calculate_sum(5) 3 >>> calculate_sum(6) -3 >>> calculate_sum(1) 1 pass # Unit tests def test_calculate_sum(): assert calculate_sum(5) == 3 # (1) + (-2) + (3) + (-4) + (5) = 3 assert calculate_sum(6) == -3 # (1) + (-2) + (3) + (-4) + (5) + (-6) = -3 assert calculate_sum(1) == 1 # (1) = 1 assert calculate_sum(2) == -1 # (1) + (-2) = -1 assert calculate_sum(8) == -4 # (1) + (-2) + (3) + (-4) + (5) + (-6) + (7) + (-8) = -4 assert calculate_sum(10) == -5 # (1) + (-2) + (3) + (-4) + (5) + (-6) + (7) + (-8) + (9) + (-10) = -5","solution":"def calculate_sum(n: int) -> int: Returns the sum of the first n terms of the series: 1, -2, 3, -4, 5, -6, ... odd_sum = sum(i for i in range(1, n+1, 2)) even_sum = sum(-i for i in range(2, n+1, 2)) return odd_sum + even_sum"},{"question":"def min_operations_to_single_element(test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, calculate the minimum number of operations required to reduce the sequence to a single integer. Parameters: test_cases (list of tuple): List of test cases where each test case is a tuple (n, sequence) Returns: list of int: List of results for each test case >>> min_operations_to_single_element([(4, [1, 2, 3, 4]), (3, [10, 20, 30])]) [3, 2] >>> min_operations_to_single_element([(1, [42])]) [0] >>> min_operations_to_single_element([(2, [1, 2])]) [1] >>> min_operations_to_single_element([ ... (4, [1, 2, 3, 4]), ... (3, [10, 20, 30]), ... (5, [5, 5, 5, 5, 5]) ... ]) [3, 2, 4] >>> min_operations_to_single_element([(100000, list(range(1, 100001)))]) [99999] >>> min_operations_to_single_element([ ... (1, [100]), ... (2, [200, 300]), ... (10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) ... ]) [0, 1, 9]","solution":"def min_operations_to_single_element(test_cases): For each test case, calculate the minimum number of operations required to reduce the sequence to a single integer. Parameters: test_cases (list of tuple): List of test cases where each test case is a tuple (n, sequence) Returns: list of int: List of results for each test case results = [] for n, seq in test_cases: # The number of operations needed is always (n - 1) results.append(n - 1) return results"},{"question":"def can_distribute_evenly(a1, o1, b1, a2, o2, b2): Determines if it's possible to evenly distribute the fruits into three new baskets. Parameters: a1, o1, b1 (int): Apples, Oranges, and Bananas in the first basket. a2, o2, b2 (int): Apples, Oranges, and Bananas in the second basket. Returns: str: \\"YES\\" if it's possible to distribute the fruits evenly, \\"NO\\" otherwise. from solution import can_distribute_evenly def test_can_distribute_evenly(): assert can_distribute_evenly(3, 6, 0, 3, 0, 3) == \\"YES\\" assert can_distribute_evenly(5, 5, 0, 5, 0, 5) == \\"NO\\" assert can_distribute_evenly(9, 15, 6, 3, 0, 3) == \\"YES\\" assert can_distribute_evenly(1, 1, 1, 1, 1, 1) == \\"NO\\" assert can_distribute_evenly(6, 9, 3, 6, 0, 0) == \\"YES\\"","solution":"def can_distribute_evenly(a1, o1, b1, a2, o2, b2): Determines if it's possible to evenly distribute the fruits into three new baskets. Parameters: a1, o1, b1 (int): Apples, Oranges, and Bananas in the first basket. a2, o2, b2 (int): Apples, Oranges, and Bananas in the second basket. Returns: str: \\"YES\\" if it's possible to distribute the fruits evenly, \\"NO\\" otherwise. total_apples = a1 + a2 total_oranges = o1 + o2 total_bananas = b1 + b2 if total_apples % 3 == 0 and total_oranges % 3 == 0 and total_bananas % 3 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def can_be_divided_into_pairs(arr: List[int], k: int) -> str: Determines if the array can be divided into pairs such that the sum of each pair is divisible by k. >>> can_be_divided_into_pairs([5, 10, 15, 20], 5) \\"YES\\" >>> can_be_divided_into_pairs([6, 5, 3, 9, 1, 8], 7) \\"NO\\" >>> can_be_divided_into_pairs([1, 2, 3, 4, 5, 10], 5) \\"YES\\" >>> can_be_divided_into_pairs([1, 2, 3], 5) \\"NO\\" >>> can_be_divided_into_pairs([1, 2, 2, 1], 3) \\"YES\\" pass def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes multiple test cases and returns the results for each. >>> test_cases = [(4, 5, [5, 10, 15, 20]), (6, 7, [6, 5, 3, 9, 1, 8])] >>> process_test_cases(test_cases) [\\"YES\\", \\"NO\\"] >>> test_cases = [(6, 5, [1, 2, 3, 4, 5, 10]), (3, 5, [1, 2, 3])] >>> process_test_cases(test_cases) [\\"YES\\", \\"NO\\"] >>> test_cases = [(4, 3, [1, 2, 2, 1])] >>> process_test_cases(test_cases) [\\"YES\\"] pass","solution":"def can_be_divided_into_pairs(arr, k): Determines if the array can be divided into pairs such that the sum of each pair is divisible by k. n = len(arr) if n % 2 != 0: return \\"NO\\" remainder_count = [0] * k for num in arr: remainder_count[num % k] += 1 if remainder_count[0] % 2 != 0: return \\"NO\\" for i in range(1, (k // 2) + 1): if remainder_count[i] != remainder_count[k - i]: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for n, k, arr in test_cases: results.append(can_be_divided_into_pairs(arr, k)) return results"},{"question":"def prefix_sum_distinct(arr: List[int]) -> List[int]: Given an array \`arr\`, returns the sum of distinct elements for every prefix. >>> prefix_sum_distinct([3, 4, 3, 2, 4]) [3, 7, 7, 9, 9] >>> prefix_sum_distinct([1, 2, 3, 4, 5]) [1, 3, 6, 10, 15] >>> prefix_sum_distinct([5, 5, 5, 5, 5]) [5, 5, 5, 5, 5] >>> prefix_sum_distinct([1, 2, 1, 3, 2, 4]) [1, 3, 3, 6, 6, 10] >>> prefix_sum_distinct([1000000000, 1000000000, 999999999, 999999999]) [1000000000, 1000000000, 1999999999, 1999999999]","solution":"def prefix_sum_distinct(arr): Given an array \`arr\`, returns the sum of distinct elements for every prefix. seen = set() current_sum = 0 result = [] for num in arr: if num not in seen: seen.add(num) current_sum += num result.append(current_sum) return result # Sample input n = 5 arr = [3, 4, 3, 2, 4] # Get the result result = prefix_sum_distinct(arr) for value in result: print(value)"},{"question":"def sort_by_reversed_binary(arr: List[int]) -> List[int]: Sort a list of integers based on their reversed binary representations. >>> sort_by_reversed_binary([5, 7, 3]) [3, 5, 7] >>> sort_by_reversed_binary([10, 15, 4, 6]) [4, 6, 10, 15] pass if __name__ == \\"__main__\\": input_list = list(map(int, input().split())) sorted_list = sort_by_reversed_binary(input_list) print(sorted_list)","solution":"def sort_by_reversed_binary(arr): def reversed_binary_value(num): # Get binary representation, strip the '0b' prefix, reverse it and convert back to integer binary_reversed = bin(num)[:1:-1] return int(binary_reversed, 2) return sorted(arr, key=reversed_binary_value) # Example of usage: # input_list = list(map(int, \\"5 7 3\\".split())) # sorted_list = sort_by_reversed_binary(input_list) # print(sorted_list) # Output: [3, 5, 7]"},{"question":"from typing import List def find_longest_palindrome(matrix: List[str]) -> int: John is fond of matrices and palindromes. A palindrome is a sequence that reads the same backward as forward. John wonders if he can find palindromes in rectangular submatrices of a given matrix. Specifically, John is interested in the longest palindrome that can be formed within any row of any submatrix. This function assists John in finding the length of the longest palindrome in any row of any submatrix. Args: matrix (List[str]): A list of strings representing the matrix Returns: int: The length of the longest palindrome found in any row of any submatrix Test cases: >>> find_longest_palindrome([\\"abca\\", \\"bcba\\", \\"cbad\\"]) 3 >>> find_longest_palindrome([\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) 1 >>> find_longest_palindrome([\\"aaaa\\", \\"bbbb\\", \\"cccc\\"]) 4 >>> find_longest_palindrome([\\"madam\\", \\"racecar\\", \\"refer\\"]) 7 >>> find_longest_palindrome([\\"aaxa\\", \\"xyzy\\", \\"aaaq\\"]) 3","solution":"def find_longest_palindrome(matrix): def is_palindrome(s): return s == s[::-1] def longest_palindrome_in_string(s): n = len(s) max_length = 1 for i in range(n): for j in range(i, n): sub_str = s[i:j+1] if is_palindrome(sub_str): max_length = max(max_length, len(sub_str)) return max_length n = len(matrix) m = len(matrix[0]) max_length_palindrome = 1 for i in range(n): for sr in range(i, n): row_concat = ''.join(matrix[sr][:]) max_length_palindrome = max(max_length_palindrome, longest_palindrome_in_string(row_concat)) return max_length_palindrome"},{"question":"def kth_most_frequent_char(s: str, k: int) -> str: Find the k-th most frequent character in the string. If multiple characters have the same frequency, return the lexicographically smallest character among them. If the string does not have k different frequencies, return -1. >>> kth_most_frequent_char(\\"aabbcc\\", 2) == 'b' >>> kth_most_frequent_char(\\"zzzzyyys\\", 2) == 'y' >>> kth_most_frequent_char(\\"x\\", 1) == 'x' >>> kth_most_frequent_char(\\"abcd\\", 5) == -1","solution":"def kth_most_frequent_char(s, k): from collections import Counter freq_counter = Counter(s) freq_list = sorted(freq_counter.items(), key=lambda item: (-item[1], item[0])) if k > len(freq_list): return -1 return freq_list[k-1][0]"},{"question":"def is_connected(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if the village is connected based on the given wells and pipes. :param n: Number of wells (nodes) :param m: Number of pipes (edges) :param edges: List of tuples where each tuple represents an edge (u, v) :return: \\"YES\\" if the village is connected, \\"NO\\" otherwise. >>> is_connected(1, 0, []) \\"YES\\" >>> is_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> is_connected(4, 2, [(1, 2), (3, 4)]) \\"NO\\"","solution":"def is_connected(n, m, edges): Determine if the village is connected based on the given wells and pipes. :param n: Number of wells (nodes) :param m: Number of pipes (edges) :param edges: List of tuples where each tuple represents an edge (u, v) :return: \\"YES\\" if the village is connected, \\"NO\\" otherwise. if n == 1: return \\"YES\\" from collections import defaultdict, deque graph = defaultdict(list) # Build the graph for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Perform BFS from the first node bfs(1) # Check if all nodes are visited if all(visited[1:]): return \\"YES\\" else: return \\"NO\\""},{"question":"def generate_pascals_triangle(n): Generate the first n rows of Pascal's Triangle. Parameters: n (int): number of rows to generate Returns: List[List[int]]: the first n rows of Pascal's Triangle >>> generate_pascals_triangle(1) [[1]] >>> generate_pascals_triangle(2) [[1], [1, 1]] >>> generate_pascals_triangle(3) [[1], [1, 1], [1, 2, 1]] >>> generate_pascals_triangle(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] >>> generate_pascals_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] from solution import generate_pascals_triangle def test_generate_pascals_triangle_n_1(): assert generate_pascals_triangle(1) == [[1]] def test_generate_pascals_triangle_n_2(): assert generate_pascals_triangle(2) == [[1], [1, 1]] def test_generate_pascals_triangle_n_3(): assert generate_pascals_triangle(3) == [[1], [1, 1], [1, 2, 1]] def test_generate_pascals_triangle_n_4(): assert generate_pascals_triangle(4) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] def test_generate_pascals_triangle_n_5(): assert generate_pascals_triangle(5) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] def test_generate_pascals_triangle_n_6(): assert generate_pascals_triangle(6) == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1] ] def test_generate_pascals_triangle_n_10(): assert generate_pascals_triangle(10) == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1] ]","solution":"def generate_pascals_triangle(n): Generate the first n rows of Pascal's Triangle. Parameters: n (int): number of rows to generate Returns: List[List[int]]: the first n rows of Pascal's Triangle triangle = [] for row_num in range(n): row = [1] * (row_num + 1) for j in range(1, row_num): row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j] triangle.append(row) return triangle"},{"question":"from typing import List def shortest_path(m: int, n: int, grid: List[List[str]]) -> int: Find the shortest path from the top-left corner to the bottom-right corner in a grid with obstacles. Parameters: m (int): Number of rows in the grid n (int): Number of columns in the grid grid (list of list of str): The grid representation. Each cell can be '.' (passable) or '#' (obstacle) Returns: int: length of the shortest path, or -1 if no path exists Examples: >>> shortest_path(4, 4, [['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.']]) 6 >>> shortest_path(3, 3, [['.', '#', '.'], ['#', '#', '.'], ['.', '.', '#']]) -1","solution":"from collections import deque def shortest_path(m, n, grid): Find the shortest path from (0,0) to (m-1,n-1) in a grid with obstacles. Parameters: m (int): Number of rows in the grid n (int): Number of columns in the grid grid (list of list of str): The grid representation Returns: int: length of the shortest path or -1 if no path exists if grid[0][0] == '#' or grid[m-1][n-1] == '#': return -1 directions = [(0,1), (1,0), (0,-1), (-1,0)] queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # Basic example to run and check function if __name__ == \\"__main__\\": m = 4 n = 4 grid = [ ['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.'] ] print(shortest_path(m, n, grid)) # Expected output: 6"},{"question":"def longest_valley(arr: List[int]) -> Tuple[int, List[int]]: Find the length of the longest valley and provide the sequence of numbers that constitute the valley. A valley is defined as an array which strictly decreases and then strictly increases. Args: arr (List[int]): Collection of integers. Returns: Tuple[int, List[int]]: Length of the longest valley and the valley sequence. >>> longest_valley([5, 4, 3, 4, 5]) (5, [5, 4, 3, 4, 5]) >>> longest_valley([6, 3, 2, 3]) (4, [6, 3, 2, 3]) >>> longest_valley([3, 2, 1]) (0, [])","solution":"def longest_valley(arr): n = len(arr) if n < 3: return 0, [] # Calculate the longest decreasing subsequence ending at each index dec = [1] * n for i in range(1, n): if arr[i] < arr[i-1]: dec[i] = dec[i-1] + 1 # Calculate the longest increasing subsequence starting from each index inc = [1] * n for i in range(n-2, -1, -1): if arr[i] < arr[i+1]: inc[i] = inc[i+1] + 1 max_len = 0 idx = -1 # Find the point where both sequences meet and form the longest valley for i in range(n): if dec[i] > 1 and inc[i] > 1: if dec[i] + inc[i] - 1 > max_len: max_len = dec[i] + inc[i] - 1 idx = i if max_len == 0: return 0, [] # Reconstruct the longest valley valley = [] # Get the decreasing part for i in range(idx - dec[idx] + 1, idx + 1): valley.append(arr[i]) # Get the increasing part without the peak element ( which is already added ) for i in range(idx + 1, idx + inc[idx]): valley.append(arr[i]) return max_len, valley"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Determine the minimum number of operations required to transform the initial string \`s\` into the target string \`t\`. The operations can be either inserting a single character, deleting any character, or replacing any character in the string. >>> min_operations_to_transform(\\"abcd\\", \\"acbdd\\") 2 >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"\\", \\"abcdef\\") 6 >>> min_operations_to_transform(\\"abcdef\\", \\"\\") 6 >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_transform(\\"horse\\", \\"ros\\") 3","solution":"def min_operations_to_transform(s, t): m, n = len(s), len(t) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): # If the first string is empty, only option is to insert all characters of the second string if i == 0: dp[i][j] = j # If the second string is empty, only option is to remove all characters of the first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore last character and recur for remaining strings elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"from typing import List def is_fibonacci_sequence(sequence: List[int]) -> bool: Determine if a given sequence of numbers is a Fibonacci sequence. >>> is_fibonacci_sequence([0, 1, 1, 2, 3, 5, 8, 13]) True >>> is_fibonacci_sequence([0, 2, 3, 5, 8]) False >>> is_fibonacci_sequence([0, 1, 1, 2, 4]) False >>> is_fibonacci_sequence([0, 1]) True >>> is_fibonacci_sequence([0]) False >>> is_fibonacci_sequence([]) False >>> is_fibonacci_sequence([0, 1, 2, 3, 4]) False","solution":"from typing import List def is_fibonacci_sequence(sequence: List[int]) -> bool: if len(sequence) < 2: return False # Check if the sequence starts with 0 and 1 if sequence[0] != 0 or sequence[1] != 1: return False # Check the rest of the sequence for i in range(2, len(sequence)): if sequence[i] != sequence[i - 1] + sequence[i - 2]: return False return True"},{"question":"def process_emissions(n: int, emissions: List[int]) -> Tuple[int, List[int]]: Find the longest strictly decreasing subsequence from the given array and the respective days when these levels were recorded. Args: n (int): The number of days. emissions (List[int]): The carbon emission levels recorded over n days. Returns: Tuple[int, List[int]]: The length of the longest strictly decreasing subsequence, The respective days when these levels were recorded. Example: >>> process_emissions(7, [5, 3, 4, 8, 6, 7, 2]) (3, [1, 2, 7]) >>> process_emissions(5, [1, 2, 3, 4, 5]) (1, [1]) # Unit Tests def test_example_case(): emissions = [5, 3, 4, 8, 6, 7, 2] n = len(emissions) max_length, seq = process_emissions(n, emissions) assert max_length == 3 assert seq == [1, 2, 7] def test_single_element_case(): emissions = [5] n = len(emissions) max_length, seq = process_emissions(n, emissions) assert max_length == 1 assert seq == [1] def test_no_decreasing_sequence(): emissions = [1, 2, 3, 4, 5] n = len(emissions) max_length, seq = process_emissions(n, emissions) assert max_length == 1 assert seq == [1] def test_all_decreasing_sequence(): emissions = [5, 4, 3, 2, 1] n = len(emissions) max_length, seq = process_emissions(n, emissions) assert max_length == 5 assert seq == [1, 2, 3, 4, 5] def test_mixed_sequence(): emissions = [10, 5, 8, 3, 7, 2, 6] n = len(emissions) max_length, seq = process_emissions(n, emissions) assert max_length == 4 assert seq == [1, 2, 4, 6]","solution":"def longest_decreasing_subsequence(days, emissions): n = len(emissions) dp = [1] * n previous = [-1] * n for i in range(1, n): for j in range(i): if emissions[i] < emissions[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 previous[i] = j max_length = max(dp) index = dp.index(max_length) seq = [] while index != -1: seq.append(days[index]) index = previous[index] seq.reverse() return max_length, seq def process_emissions(n, emissions): days = list(range(1, n + 1)) max_length, seq = longest_decreasing_subsequence(days, emissions) return max_length, seq"},{"question":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> longest_unique_substring_length(\\"abcabcbb\\") 3 >>> longest_unique_substring_length(\\"bbbbbb\\") 1 >>> longest_unique_substring_length(\\"pwwkew\\") 3 >>> longest_unique_substring_length(\\"a\\") 1 >>> longest_unique_substring_length(\\"abcdef\\") 6 >>> longest_unique_substring_length(\\"abcbef\\") 4 >>> longest_unique_substring_length(\\"\\") 0 >>> longest_unique_substring_length(\\"dvdf\\") 3 >>> longest_unique_substring_length(\\"abcdabcdeabcdefgh\\") 8","solution":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring with all unique characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: # Shift the left pointer to right of the duplicated character's last index left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def count_unique_pairs(n: int, k: int, arr: List[int]) -> int: Given an array of integers and a target value, determine the number of unique pairs of integers in the array that add up to the target value. >>> count_unique_pairs(5, 7, [1, 2, 3, 4, 5]) == 2 >>> count_unique_pairs(5, 10, [1, 2, 3, 4, 5]) == 0 >>> count_unique_pairs(4, 7, [3, 4, 5, 6]) == 1 >>> count_unique_pairs(6, 10, [1, 5, 3, 7, 4, 6]) == 2 >>> count_unique_pairs(4, 8, [2, 2, 6, 8]) == 1 >>> count_unique_pairs(3, 20000, [10000, 10000, 1]) == 1 >>> large_input = list(range(1, 1001)) >>> count_unique_pairs(1000, 1500, large_input) == 250","solution":"def count_unique_pairs(n, k, arr): Returns the number of unique pairs of integers in the array that add up to the target value k. pairs = set() seen = set() for number in arr: complement = k - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return len(pairs)"},{"question":"def tsp_min_distance(n: int, d: List[List[int]], start: int) -> int: Solves the Traveling Salesman Problem using brute force approach. Parameters: n (int): Number of cities. d (list of list of int): Distance matrix. start (int): Starting city index. Returns: int: Minimum travel distance. >>> tsp_min_distance(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]], 0) 80 >>> tsp_min_distance(3, [[0, 10, 15], [10, 0, 20], [15, 20, 0]], 0) 45 >>> tsp_min_distance(3, [[0, 29, 20], [29, 0, 15], [20, 15, 0]], 1) 64 >>> tsp_min_distance(2, [[0, 10], [10, 0]], 0) 20 >>> tsp_min_distance(4, [[0, 2, 9, 10], [1, 0, 6, 4], [15, 7, 0, 8], [6, 3, 12, 0]], 2) 21","solution":"import itertools def tsp_min_distance(n, d, start): Solves the Traveling Salesman Problem using brute force approach. Parameters: n (int): Number of cities. d (list of list of int): Distance matrix. start (int): Starting city index. Returns: int: Minimum travel distance. # Generate all permutations of cities excluding the starting city cities = list(range(n)) cities.remove(start) min_distance = float('inf') # Check all possible permutations of visiting cities for perm in itertools.permutations(cities): current_distance = 0 current_city = start # Compute the distance for the current permutation for next_city in perm: current_distance += d[current_city][next_city] current_city = next_city # Add distance back to the starting city current_distance += d[current_city][start] # Update the minimum distance if current total distance is smaller if current_distance < min_distance: min_distance = current_distance return min_distance"},{"question":"from typing import List, Tuple def minimum_travel_time(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum total travel time required to ensure that all intersections are directly or indirectly connected through the company's delivery network. Args: n (int): The number of intersections. m (int): The number of roads. roads (List[Tuple[int, int, int]]): List of tuples (u, v, w) representing a road between intersections u and v with a travel time of w. Returns: int: The minimum total travel time required, or -1 if it's impossible to connect all intersections. Examples: >>> minimum_travel_time(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 1, 2), (1, 3, 1)]) 6 >>> minimum_travel_time(2, 0, []) -1 pass def test_example_case(): n = 4 m = 5 roads = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 1, 2), (1, 3, 1)] assert minimum_travel_time(n, m, roads) == 6 def test_no_roads_one_intersection(): n = 1 m = 0 roads = [] assert minimum_travel_time(n, m, roads) == 0 def test_no_roads_multiple_intersections(): n = 2 m = 0 roads = [] assert minimum_travel_time(n, m, roads) == -1 def test_sparse_graph(): n = 3 m = 2 roads = [(1, 2, 1), (2, 3, 2)] assert minimum_travel_time(n, m, roads) == 3 def test_disconnecting_a_road(): n = 4 m = 4 roads = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 2)] assert minimum_travel_time(n, m, roads) == 9 def test_all_same_weight(): n = 4 m = 6 roads = [(1, 2, 2), (1, 3, 2), (1, 4, 2), (2, 3, 2), (2, 4, 2), (3, 4, 2)] assert minimum_travel_time(n, m, roads) == 6 def test_large_input(): n = 100 m = 199 roads = [(i, i+1, 1) for i in range(1, 100)] + [(i, i+2, 1) for i in range(1, 99)] assert minimum_travel_time(n, m, roads) == 99 def test_minimum_weight_edges(): n = 6 m = 7 roads = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1), (1, 3, 3), (4, 6, 2)] assert minimum_travel_time(n, m, roads) == 5","solution":"import heapq def minimum_travel_time(n, m, roads): if not roads and n > 1: return -1 # if there are no roads and more than one intersection, it's impossible # Create an adjacency list adj = [[] for _ in range(n + 1)] for u, v, w in roads: adj[u].append((w, v)) adj[v].append((w, u)) # Use Prim's algorithm to find Minimum Spanning Tree (MST) min_cost = 0 in_mst = [False] * (n + 1) min_heap = [(0, 1)] # (cost, start_vertex), use vertex 1 as the starting point while min_heap: cost, u = heapq.heappop(min_heap) if in_mst[u]: continue min_cost += cost in_mst[u] = True for edge_cost, v in adj[u]: if not in_mst[v]: heapq.heappush(min_heap, (edge_cost, v)) # If not all intersections are included in the MST if not all(in_mst[1:]): return -1 return min_cost"},{"question":"def count_trees(n: int, edges: List[Tuple[int, int]]) -> int: Returns the number of trees in the forest given n nodes and n-1 edges. >>> count_trees(1, []) 1 >>> count_trees(2, []) 2 >>> count_trees(2, [(1, 2)]) 1 >>> count_trees(4, [(1, 2), (3, 4)]) 2 >>> count_trees(6, [(1, 2), (3, 4), (5, 6)]) 3 >>> count_trees(4, [(1, 2), (2, 3), (3, 4)]) 1 >>> count_trees(9, [(1, 2), (3, 4), (5, 6), (7, 8), (8, 9), (9, 7), (4, 5), (6, 1)]) 2","solution":"def count_trees(n, edges): Returns the number of trees in the forest given n nodes and n-1 edges. from collections import defaultdict def dfs(node): stack = [node] while stack: u = stack.pop() for v in graph[u]: if not visited[v]: visited[v] = True stack.append(v) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) # To keep track of visited nodes tree_count = 0 for node in range(1, n + 1): if not visited[node]: visited[node] = True tree_count += 1 dfs(node) return tree_count"},{"question":"def product_except_self(nums): Given an array nums, returns an array such that each element at index i is the product of all elements in nums except nums[i]. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([0, 1, 2, 3, 4]) [24, 0, 0, 0, 0] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] ... def read_input(input_str): Parses the input string into a list of integers. >>> read_input(\\"1 2 3 4\\") [1, 2, 3, 4] >>> read_input(\\"2 3 4 5\\") [2, 3, 4, 5] >>> read_input(\\"1 1 1 1\\") [1, 1, 1, 1] ... def format_output(output_list): Converts the output list of integers into a space-separated string. >>> format_output([24, 12, 8, 6]) \\"24 12 8 6\\" >>> format_output([60, 40, 30, 24]) \\"60 40 30 24\\" >>> format_output([1, 1, 1, 1]) \\"1 1 1 1\\" ...","solution":"def product_except_self(nums): Given an array nums, returns an array such that each element at index i is the product of all elements in nums except nums[i]. n = len(nums) result = [1] * n # Calculate left product for each index left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Calculate right product for each index and combine with left product right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result def read_input(input_str): Parses the input string into a list of integers. return list(map(int, input_str.strip().split())) def format_output(output_list): Converts the output list of integers into a space-separated string. return ' '.join(map(str, output_list))"},{"question":"def calculate_actual_weights(n: int, weights: List[int], percentages: List[int]) -> List[float]: Returns the actual weights of each vegetable in grams based on given weights and their percentages. Parameters: n (int): The number of vegetables. weights (list of int): List of weights of the vegetables. percentages (list of int): List of percentages each vegetable contributes to the total weight. Returns: list of float: The actual weight of each vegetable in grams calculated based on the desired percentages. >>> calculate_actual_weights(3, [100, 200, 300], [10, 20, 70]) [60.0, 120.0, 420.0] >>> calculate_actual_weights(2, [100, 100], [50, 50]) [100.0, 100.0] >>> calculate_actual_weights(3, [100, 200, 300], [0, 0, 100]) [0.0, 0.0, 600.0] >>> calculate_actual_weights(1, [150], [100]) [150.0] >>> calculate_actual_weights(4, [100, 200, 300, 400], [25, 25, 25, 25]) [250.0, 250.0, 250.0, 250.0]","solution":"def calculate_actual_weights(n, weights, percentages): Returns the actual weights of each vegetable in grams based on given weights and their percentages. Parameters: n (int): The number of vegetables. weights (list of int): List of weights of the vegetables. percentages (list of int): List of percentages each vegetable contributes to the total weight. Returns: list of float: The actual weight of each vegetable in grams calculated based on the desired percentages. total_weight = sum(weights) actual_weights = [(total_weight * (p / 100)) for p in percentages] return actual_weights"},{"question":"import json import itertools import math def calculate_distance(point1, point2): Calculate Euclidean distance between two points. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def calculate_route_distance(route, points): Calculate the total distance of the given route. total_distance = 0 for i in range(len(route) - 1): total_distance += calculate_distance(points[route[i]], points[route[i + 1]]) return total_distance def find_optimal_route(filepath: str) -> dict: Find the optimal delivery route for a truck visiting all delivery points and returning to the depot. Args: filepath (str): Path to the JSON file containing depot and delivery points coordinates. Returns: dict: A dictionary containing the visiting order and the total minimum distance traveled. >>> find_optimal_route(\\"input.json\\") {'Order': [0, 2, 1, 3], 'TotalDistance': 12.34}","solution":"import json import itertools import math def calculate_distance(point1, point2): Calculate Euclidean distance between two points. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def calculate_route_distance(route, points): Calculate the total distance of the given route. total_distance = 0 for i in range(len(route) - 1): total_distance += calculate_distance(points[route[i]], points[route[i + 1]]) return total_distance def find_optimal_route(filepath: str) -> dict: with open(filepath, 'r') as file: data = json.load(file) depot = data['Depot'] delivery_points = data['DeliveryPoints'] points = [depot] + delivery_points # Generate all permutations of delivery points n = len(delivery_points) possible_routes = itertools.permutations(range(1, n+1)) min_distance = float('inf') best_route = None # Check each route and find the one with the minimum distance for route in possible_routes: route = [0] + list(route) + [0] # start and end at depot distance = calculate_route_distance(route, points) if distance < min_distance: min_distance = distance best_route = route result = { \\"Order\\": best_route, \\"TotalDistance\\": round(min_distance, 2) } return result"},{"question":"def find_shortest_paths(n: int, m: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determines the shortest paths based on the queries using Dijkstra's algorithm. Args: n (int): Number of towers m (int): Number of communication cables edges (list of tuples): Each tuple contains (u, v, w) representing a cable between towers u and v with weight w queries (list of tuples): Each tuple contains (a, b) representing the starting and ending tower to find the shortest path Returns: list: A list containing shortest transmission times for each query or -1 if no path exists Example: >>> find_shortest_paths(4, 4, [(1, 2, 3), (2, 3, 4), (3, 4, 6), (1, 4, 10)], [(1, 3), (2, 4), (1, 4)]) [7, 10, 10] >>> find_shortest_paths(3, 1, [(1, 2, 3)], [(1, 3), (2, 3)]) [-1, -1]","solution":"import heapq def find_shortest_paths(n, m, edges, queries): Determines the shortest paths based on the queries using Dijkstra's algorithm. Args: n (int): Number of towers m (int): Number of communication cables edges (list of tuples): Each tuple contains (u, v, w) representing a cable between towers u and v with weight w queries (list of tuples): Each tuple contains (a, b) representing the starting and ending tower to find the shortest path Returns: list: A list containing shortest transmission times for each query or -1 if no path exists # Create adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(start): # Distance dictionary, initialized to infinity distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Precompute shortest paths from every node shortest_paths = {} for i in range(1, n + 1): shortest_paths[i] = dijkstra(i) # Answer queries results = [] for a, b in queries: result = shortest_paths[a][b] if result == float('inf'): results.append(-1) else: results.append(result) return results"},{"question":"from typing import List, Tuple def count_unique_simple_cycles(n: int, edges: List[Tuple[int, int]]) -> int: You are given an undirected, unweighted graph with n vertices and m edges. Determine the number of unique simple cycles in the graph. Args: n : int : number of vertices in the graph (2 <= n <= 10) edges : List[Tuple[int, int]] : list of edges where each edge connects a pair of vertices (1 <= u, v <= n; u != v) Returns: int : number of unique simple cycles in the graph Example: >>> count_unique_simple_cycles(5, [(1, 2), (2, 3), (3, 4), (4, 1), (3, 1), (4, 5)]) 3 >>> count_unique_simple_cycles(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 1 pass def test_example_1(): n = 5 m = 6 edges = [(1, 2), (2, 3), (3, 4), (4, 1), (3, 1), (4, 5)] assert count_unique_simple_cycles(n, edges) == 3 def test_example_2(): n = 4 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert count_unique_simple_cycles(n, edges) == 1 def test_no_cycles(): n = 3 m = 2 edges = [(1, 2), (2, 3)] assert count_unique_simple_cycles(n, edges) == 0 def test_single_triangle(): n = 3 m = 3 edges = [(1, 2), (2, 3), (3, 1)] assert count_unique_simple_cycles(n, edges) == 1 def test_multiple_components(): n = 6 m = 7 edges = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4), (3, 4)] assert count_unique_simple_cycles(n, edges) == 2","solution":"from itertools import permutations def count_unique_simple_cycles(n, edges): def is_simple_cycle(cycle): if cycle[0] != cycle[-1]: return False visited = set() for vertex in cycle[:-1]: if vertex in visited: return False visited.add(vertex) return True # Generate adjacency list adj = {i: [] for i in range(1, n + 1)} for u, v in edges: adj[u].append(v) adj[v].append(u) all_vertices = list(range(1, n + 1)) unique_cycles = set() for length in range(3, n + 1): for cycle in permutations(all_vertices, length): cycle = list(cycle) + [cycle[0]] if is_simple_cycle(cycle): is_fill_edge = all(cycle[i] in adj[cycle[i + 1]] or cycle[i + 1] in adj[cycle[i]] for i in range(len(cycle) - 1)) if is_fill_edge: cycle_rep = tuple(sorted(cycle[:-1])) unique_cycles.add(cycle_rep) return len(unique_cycles) # Example usage: if __name__ == \\"__main__\\": n, m = 5, 6 edges = [(1, 2), (2, 3), (3, 4), (4, 1), (3, 1), (4, 5)] print(count_unique_simple_cycles(n, edges)) # Output: 3"},{"question":"def construct_b(n: int, m: int, a: List[int]) -> List[int]: Construct the array b based on the rules provided. Args: n (int): Length of the array a. m (int): Length of the array b. a (List[int]): Array of integers. Returns: List[int]: Constructed array b. Examples: >>> construct_b(5, 4, [1, 2, 3, 2, 1]) [1, 2, 3, 2] >>> construct_b(6, 3, [5, 5, 6, 5, 6, 5]) [5, 5, 5] >>> construct_b(3, 5, [10, 20, 30]) [0, 0, 0, 0, 0] >>> construct_b(3, 2, [7, 7, 7]) [7, 7] >>> construct_b(6, 7, [4, 2, 0, 8, 3, 15]) [4%7, 2%7, 0%7, 8%7, 3%7, 15%7, 4%7] pass def solve(test_cases: List[Tuple[int, int, List[int]]]) -> List[List[int]]: Solve multiple test cases and return the results. Args: test_cases (List[Tuple[int, int, List[int]]]): List of test cases where each test case is a tuple (n, m, a). Returns: List[List[int]]: List of results for each test case. Example: >>> test_cases = [ ... (5, 4, [1, 2, 3, 2, 1]), ... (6, 3, [5, 5, 6, 5, 6, 5]), ... (3, 5, [10, 20, 30]) ... ] >>> solve(test_cases) [[1, 2, 3, 2], [5, 5, 5], [0, 0, 0, 0, 0]] pass","solution":"def construct_b(n, m, a): from collections import Counter # Count the frequency of each value in array a counter = Counter(a) # Check if there is an element with frequency greater than or equal to m for key, value in counter.items(): if value >= m: return [key] * m # Otherwise, construct b with (a[i % n]) % m for 0 <= i < m b = [(a[i % n]) % m for i in range(m)] return b def solve(test_cases): results = [] for n, m, a in test_cases: results.append(construct_b(n, m, a)) return results"},{"question":"def valid_configuration(n: int, m: int, constraints: List[Tuple[int, int]]) -> Union[List[int], str]: Determine a valid planting configuration for the flower beds, given constraints. >>> valid_configuration(4, 3, [(1, 2), (2, 3), (3, 4)]) [1, 2, 1, 2] >>> valid_configuration(3, 3, [(1, 2), (2, 3), (3, 1)]) 'No valid configuration' from solution import valid_configuration def test_no_constraints(): assert valid_configuration(3, 0, []) == [1, 1, 1] def test_some_constraints(): assert valid_configuration(4, 3, [(1, 2), (2, 3), (3, 4)]) == [1, 2, 1, 2] def test_no_valid_configuration(): assert valid_configuration(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"No valid configuration\\" def test_single_flower_bed(): assert valid_configuration(1, 0, []) == [1] def test_two_flower_beds_one_constraint(): assert valid_configuration(2, 1, [(1, 2)]) in [[1, 2], [2, 1]]","solution":"def valid_configuration(n, m, constraints): from itertools import product if m == 0: return [1] * n for config in product([1, 2], repeat=n): valid = True for a, b in constraints: if config[a-1] == config[b-1]: valid = False break if valid: return list(config) return \\"No valid configuration\\" # Example usage: # valid_configuration(4, 3, [(1, 2), (2, 3), (3, 4)]) should return [1, 2, 1, 2] # valid_configuration(3, 3, [(1, 2), (2, 3), (3, 1)]) should return \\"No valid configuration\\""},{"question":"import numpy as np from typing import List def reconstruct_coordinates(dist_matrix: List[List[float]]) -> List[List[float]]: Given a squared distance matrix, reconstruct the coordinates of the points in a 2D plane. pass def parse_input(n: int, input_strings: List[str]) -> List[List[float]]: Parse input matrix from list of strings. Example: >>> parse_input(3, [\\"0 1 2\\", \\"1 0 2\\", \\"2 2 0\\"]) == [[0.0, 1.0, 2.0], [1.0, 0.0, 2.0], [2.0, 2.0, 0.0]] pass def test_reconstruct_coordinates_simple(): input_strings = [ \\"0 1 1.41421356\\", \\"1 0 1\\", \\"1.41421356 1 0\\" ] dist_matrix = parse_input(3, input_strings) coords = reconstruct_coordinates(dist_matrix) assert len(coords) == 3 for coord in coords: assert len(coord) == 2 def test_reconstruct_coordinates_square(): input_strings = [ \\"0 1 1 1.41421356\\", \\"1 0 1.41421356 1\\", \\"1 1.41421356 0 1\\", \\"1.41421356 1 1 0\\" ] dist_matrix = parse_input(4, input_strings) coords = reconstruct_coordinates(dist_matrix) assert len(coords) == 4 for coord in coords: assert len(coord) == 2 def test_reconstruct_coordinates_line(): input_strings = [ \\"0 1 2\\", \\"1 0 1\\", \\"2 1 0\\" ] dist_matrix = parse_input(3, input_strings) coords = reconstruct_coordinates(dist_matrix) assert len(coords) == 3 for coord in coords: assert len(coord) == 2 def test_parse_input(): input_strings = [ \\"0 1 2\\", \\"1 0 2\\", \\"2 2 0\\" ] matrix = parse_input(3, input_strings) expected = [ [0.0, 1.0, 2.0], [1.0, 0.0, 2.0], [2.0, 2.0, 0.0] ] assert matrix == expected","solution":"import numpy as np def reconstruct_coordinates(dist_matrix): Given a squared distance matrix, reconstruct the coordinates of the points in a 2D plane. n = len(dist_matrix) # Convert distance matrix to a numpy array for ease of computation D = np.array(dist_matrix) # Centering matrix J = np.eye(n) - np.ones((n, n)) / n # Double centering the distance matrix B = -0.5 * J @ (D ** 2) @ J # Eigen decomposition eigenvalues, eigenvectors = np.linalg.eigh(B) # Sort by eigenvalue in descending order idx = np.argsort(eigenvalues)[::-1] eigenvalues = eigenvalues[idx] eigenvectors = eigenvectors[:, idx] # Select eigenvalues and eigenvectors corresponding to the 2 largest eigenvalues L = np.diag(np.sqrt(eigenvalues[:2])) V = eigenvectors[:, :2] # Coordinates X = V @ L return X.tolist() # Helper function to parse input matrix from list of strings def parse_input(n, input_strings): matrix = [] for i in range(n): row = list(map(float, input_strings[i].split())) matrix.append(row) return matrix"},{"question":"def isValid(s: str) -> bool: Determine if the input string s is a valid expression consisting of characters '(', ')', '{', '}', '[' and ']'. >>> isValid(\\"()\\") True >>> isValid(\\"()[]{}\\") True >>> isValid(\\"(]\\") False >>> isValid(\\"([)]\\") False >>> isValid(\\"{[]}\\") True","solution":"def isValid(s: str) -> bool: Determine if the input string s is a valid expression consisting of characters '(', ')', '{', '}', '[' and ']'. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket: top_element = stack.pop() if stack else '#' if matching_bracket[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def max_items_within_budget(n, B, prices): Returns the maximum number of items that can be bought within the given budget. Parameters: n (int): The number of items. B (int): The total budget. prices (List[int]): The list of prices of the items. Returns: int: The maximum number of items. >>> max_items_within_budget(5, 50, [20, 10, 50, 15, 25]) 3 >>> max_items_within_budget(4, 10, [10, 20, 30, 40]) 1 >>> max_items_within_budget(3, 5, [10, 20, 30]) 0 >>> max_items_within_budget(4, 100, [10, 20, 30, 40]) 4 >>> max_items_within_budget(1, 5, [5]) 1 >>> max_items_within_budget(1, 4, [5]) 0 >>> max_items_within_budget(5, 25, [5, 5, 5, 5, 5]) 5 >>> max_items_within_budget(3, 10**9, [10**6, 10**6, 10**6]) 3","solution":"def max_items_within_budget(n, B, prices): Returns the maximum number of items that can be bought within the given budget. Parameters: n (int): The number of items. B (int): The total budget. prices (List[int]): The list of prices of the items. Returns: int: The maximum number of items. # Sort the prices in ascending order prices.sort() total_spent = 0 item_count = 0 for price in prices: if total_spent + price <= B: total_spent += price item_count += 1 else: break return item_count"},{"question":"from typing import List, Tuple def max_gcd_subarray_length(arr: List[int]) -> int: Find the maximum length of a continuous subarray where the GCD of all its elements is greater than 1. >>> max_gcd_subarray_length([2, 4, 6, 3, 9]) 3 >>> max_gcd_subarray_length([5, 7, 11, 13]) 0 def solve(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solve the problem for multiple test cases. >>> solve([(5, [2, 4, 6, 3, 9]), (4, [5, 7, 11, 13])]) [3, 0] >>> solve([(5, [4, 8, 16, 32, 64])]) [5] >>> solve([(4, [1, 3, 5, 7])]) [0] >>> solve([(6, [3, 6, 9, 2, 4, 8])]) [3] >>> solve([(1, [7])]) [0]","solution":"from math import gcd from functools import reduce from itertools import combinations def max_gcd_subarray_length(arr): def calculate_gcd(subarr): return reduce(gcd, subarr) n = len(arr) max_length = 0 for length in range(2, n + 1): for i in range(n - length + 1): subarr = arr[i:i + length] if calculate_gcd(subarr) > 1: max_length = max(max_length, length) return max_length def solve(test_cases): results = [] for n, a in test_cases: results.append(max_gcd_subarray_length(a)) return results"},{"question":"from collections import deque def is_path_possible(n, m, grid): Determine if there is a path from top-left to bottom-right corner in a grid. Args: n (int): number of rows m (int): number of columns grid (List[str]): grid representation where '.' is an empty cell and '#' is a rock cell Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise Examples: >>> grid = [ ... \\".#..\\", ... \\"..#.\\", ... \\"#..#\\", ... \\"....\\" ... ] >>> is_path_possible(4, 4, grid) 'YES' >>> grid = [ ... \\"#...\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ... ] >>> is_path_possible(4, 4, grid) 'NO'","solution":"from collections import deque def is_path_possible(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" directions = [(-1,0), (1,0), (0,-1), (0,1)] # up, down, left, right visited = [[False] * m for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() # If we reached the bottom-right cell if x == n-1 and y == m-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def min_cost_to_increasing(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum cost to transform each array in the test cases to a strictly increasing array where each element is greater than the previous element by exactly 1. >>> min_cost_to_increasing(1, [(3, [1, 1, 1])]) [3] >>> min_cost_to_increasing(1, [(4, [1, 2, 3, 4])]) [0] >>> min_cost_to_increasing(2, [(3, [1, 1, 1]), (4, [1, 2, 3, 4])]) [3, 0] >>> min_cost_to_increasing(1, [(5, [1, 2, 2, 2, 2])]) [6] >>> min_cost_to_increasing(1, [(2, [2, 1])]) [2] >>> min_cost_to_increasing(1, [(6, [1, 1, 1, 1, 1, 1])]) [15] >>> min_cost_to_increasing(1, [(1, [10000])]) [0]","solution":"def min_cost_to_increasing(t, test_cases): results = [] for case in test_cases: n, arr = case cost = 0 for i in range(1, n): if arr[i] <= arr[i - 1]: increment = arr[i - 1] - arr[i] + 1 arr[i] += increment cost += increment results.append(cost) return results"},{"question":"def minimal_non_decreasing_subsequences(n: int, a: List[int]) -> int: Partition the sequence into a minimal number of non-decreasing subsequences. Args: n (int): The length of the sequence. a (List[int]): The elements of the sequence. Returns: int: The minimal number of non-decreasing subsequences. Examples: >>> minimal_non_decreasing_subsequences(7, [3, 2, 1, 4, 3, 5, 6]) 3 >>> minimal_non_decreasing_subsequences(1, [1]) 1 >>> minimal_non_decreasing_subsequences(5, [2, 2, 2, 2, 2]) 1 >>> minimal_non_decreasing_subsequences(4, [1, 3, 2, 4]) 2 >>> minimal_non_decreasing_subsequences(5, [1, 2, 3, 4, 5]) 1 >>> minimal_non_decreasing_subsequences(5, [5, 4, 3, 2, 1]) 5","solution":"import heapq def minimal_non_decreasing_subsequences(n, a): subsequences_end = [] for num in a: pos = -1 for i in range(len(subsequences_end)): if subsequences_end[i] <= num: pos = i break if pos == -1: subsequences_end.append(num) else: subsequences_end[pos] = num subsequences_end.sort() return len(subsequences_end) # Example usage n = 7 a = [3, 2, 1, 4, 3, 5, 6] print(minimal_non_decreasing_subsequences(n, a)) # Output: 3"},{"question":"def most_frequent_word(text: str) -> str: Returns the most frequent word in the text. If multiple words have the highest frequency, returns the lexicographically smallest one. >>> most_frequent_word(\\"the quick brown fox jumps over the lazy dog the the quick\\") 'the' >>> most_frequent_word(\\"hello hello world world\\") 'hello'","solution":"def most_frequent_word(text): Returns the most frequent word in the text. If multiple words have the highest frequency, returns the lexicographically smallest one. from collections import Counter words = text.split() word_count = Counter(words) max_freq = max(word_count.values()) most_frequent_words = [word for word, count in word_count.items() if count == max_freq] return min(most_frequent_words)"},{"question":"def count_distinct_in_subarrays(n: int, permutation: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a permutation array and a list of queries, returns the number of distinct values for each query subarray. :param n: Integer, size of the permutation array. :param permutation: List of integers of length n representing the permutation array. :param queries: List of tuples where each tuple contains two integers (l, r) defining the bounds of a subarray. :returns: List of integers where each integer is the count of distinct values in the corresponding subarray. >>> n = 5 >>> permutation = [4, 3, 1, 5, 2] >>> queries = [(1, 5), (2, 4), (3, 5)] >>> count_distinct_in_subarrays(n, permutation, queries) [5, 3, 3] >>> n = 6 >>> permutation = [1, 2, 3, 4, 5, 6] >>> queries = [(1, 3), (2, 4), (3, 6)] >>> count_distinct_in_subarrays(n, permutation, queries) [3, 3, 4]","solution":"def count_distinct_in_subarrays(n, permutation, queries): Given a permutation array and a list of queries, returns the number of distinct values for each query subarray. :param n: Integer, size of the permutation array. :param permutation: List of integers of length n representing the permutation array. :param queries: List of tuples where each tuple contains two integers (l, r) defining the bounds of a subarray. :returns: List of integers where each integer is the count of distinct values in the corresponding subarray. results = [] for l, r in queries: # Extract the subarray and convert it into a set to find unique elements subarray = permutation[l-1:r] # adjust for 0-based indexing distinct_count = len(set(subarray)) results.append(distinct_count) return results"},{"question":"import random from typing import List, Tuple def draw_cards(deck: List[Tuple[str, str]], n: int) -> List[Tuple[str, str]]: Draw n random cards from the deck without replacement. Parameters: deck (list of tuples): A list of tuples representing the deck of cards, where each tuple is (rank, suit). n (int): The number of cards to draw. Returns: list of tuples: A list of n randomly drawn cards. # Unit tests def test_draw_five_cards(): deck = [('2', 'H'), ('3', 'H'), ('4', 'H'), ('5', 'H'), ('6', 'H'), ('7', 'H'), ('8', 'H'), ('9', 'H'), ('10', 'H'), ('J', 'H'), ('Q', 'H'), ('K', 'H'), ('A', 'H'), ('2', 'D'), ('3', 'D'), ('4', 'D'), ('5', 'D'), ('6', 'D'), ('7', 'D'), ('8', 'D'), ('9', 'D'), ('10', 'D'), ('J', 'D'), ('Q', 'D'), ('K', 'D'), ('A', 'D'), ('2', 'C'), ('3', 'C'), ('4', 'C'), ('5', 'C'), ('6', 'C'), ('7', 'C'), ('8', 'C'), ('9', 'C'), ('10', 'C'), ('J', 'C'), ('Q', 'C'), ('K', 'C'), ('A', 'C'), ('2', 'S'), ('3', 'S'), ('4', 'S'), ('5', 'S'), ('6', 'S'), ('7', 'S'), ('8', 'S'), ('9', 'S'), ('10', 'S'), ('J', 'S'), ('Q', 'S'), ('K', 'S'), ('A', 'S')] drawn = draw_cards(deck, 5) assert len(drawn) == 5 def test_draw_all_cards(): deck = [('2', 'H'), ('3', 'H')] drawn = draw_cards(deck, 3) assert set(drawn) == set(deck) def test_draw_single_card(): deck = [('2', 'H'), ('3', 'H'), ('4', 'H')] drawn = draw_cards(deck, 1) assert len(drawn) == 1 assert drawn[0] in deck def test_no_duplicate_draw(): deck = [('2', 'H'), ('3', 'H'), ('4', 'H'), ('5', 'H'), ('6', 'H')] drawn = draw_cards(deck, 5) assert len(drawn) == 5 assert len(drawn) == len(set(drawn)) # Ensure all drawn cards are unique def test_exact_deck_size(): deck = [('2', 'H'), ('3', 'H'), ('4', 'H'), ('5', 'H')] drawn = draw_cards(deck, 4) assert set(drawn) == set(deck)","solution":"import random def draw_cards(deck, n): Draw n random cards from the deck without replacement. Parameters: deck (list of tuples): A list of tuples representing the deck of cards, where each tuple is (rank, suit). n (int): The number of cards to draw. Returns: list of tuples: A list of n randomly drawn cards. if n > len(deck): n = len(deck) return random.sample(deck, n)"},{"question":"def solve(tree_info, queries): You are given a tree with n nodes. Each node has an integer value associated with it. You will perform several queries on this tree. Each query asks you to find the maximum value of the integers in the subtree of a given node. The tree is rooted at node 1. The subtree of a node v consists of v and all its descendants. You need to efficiently process the following types of queries: 1. 1 v x: Update the value of the node v to x. 2. 2 v: Find the maximum value in the subtree of the node v. Args: tree_info (dict): Information of the tree containing: n (int): Number of nodes in the tree. values (list): Initial values of the nodes. edges (list of tuples): Edges between nodes. queries (list): List of queries to process. Returns: list: Results for each query of type 2. >>> tree_info = {'n': 5, 'values': [1, 2, 3, 4, 5], 'edges': [(1, 2), (1, 3), (3, 4), (3, 5)]} >>> queries = [(2, 3), (1, 3, 10), (2, 3)] >>> solve(tree_info, queries) [5, 10] >>> tree_info = {'n': 3, 'values': [4, 2, 7], 'edges': [(1, 2), (1, 3)]} >>> queries = [(2, 1), (2, 3), (1, 3, 10), (2, 1)] >>> solve(tree_info, queries) [7, 7, 10]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1]) def update(self, index, value): # Update leaf node index += self.n self.tree[index] = value # Update internal nodes i = index while i > 1: i >>= 1 self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1]) def query(self, left, right): # Query on range [left, right) left += self.n right += self.n result = -float('inf') while left < right: if left & 1: result = max(result, self.tree[left]) left += 1 if right & 1: right -= 1 result = max(result, self.tree[right]) left >>= 1 right >>= 1 return result def dfs(node, parent, adj, in_time, out_time, pos, value, flat): in_time[node] = pos[0] flat[pos[0]] = value[node - 1] # nodes are 1-indexed, hence node - 1 pos[0] += 1 for neighbor in adj[node]: if neighbor != parent: dfs(neighbor, node, adj, in_time, out_time, pos, value, flat) out_time[node] = pos[0] def solve(tree_info, queries): n = tree_info['n'] values = tree_info['values'] edges = tree_info['edges'] adj = [[] for _ in range(n + 1)] for u, v in edges: adj[u].append(v) adj[v].append(u) in_time = [0] * (n + 1) out_time = [0] * (n + 1) pos = [0] flat = [0] * n # Perform DFS to calculate in_time, out_time and the flat tree dfs(1, -1, adj, in_time, out_time, pos, values, flat) # Initialize the segment tree with the flattened tree values seg_tree = SegmentTree(flat) results = [] for query in queries: if query[0] == 1: # Update value query _, v, x = query # Update the value in the original array idx = in_time[v] seg_tree.update(idx, x) elif query[0] == 2: # Max value in subtree query _, v = query l = in_time[v] r = out_time[v] results.append(seg_tree.query(l, r)) return results"},{"question":"def minimum_swaps_to_sort(arr: List[int]) -> int: Determine the minimum number of swaps required to sort the array in non-decreasing order of heights. >>> minimum_swaps_to_sort([3, 1, 2]) 2 >>> minimum_swaps_to_sort([5, 4, 3, 2, 1]) 10 >>> minimum_swaps_to_sort([1, 3, 5, 2]) 2 >>> minimum_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> minimum_swaps_to_sort([2, 1]) 1 >>> minimum_swaps_to_sort([1000000000, 1, 500000000, 2]) 4 >>> minimum_swaps_to_sort([]) 0","solution":"def count_inversions(arr): temp_arr = [0]*len(arr) return merge_sort(arr, temp_arr, 0, len(arr)-1) def merge_sort(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort(arr, temp_arr, left, mid) inv_count += merge_sort(arr, temp_arr, mid+1, right) inv_count += merge(arr, temp_arr, left, mid, right) return inv_count def merge(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def minimum_swaps_to_sort(arr): return count_inversions(arr)"},{"question":"def process_queries(n, m, flowerbeds, queries): Processes the given queries on the flowerbeds. Parameters: n (int): Number of flowerbeds. m (int): Number of queries. flowerbeds (list of int): List containing the type of flowers in each flowerbed. queries (list of list of int): List of queries to process. Returns: list of int: Results of the second type of queries. def test_process_queries(): # Test Case 1 n = 5 m = 3 flowerbeds = [1, 2, 1, 3, 2] queries = [ [2, 1, 5, 2], # Count query: count type 2 in range [1, 5] -> 2 [1, 3, 2], # Update query: update flowerbed 3 to type 2 [2, 1, 5, 2] # Count query: count type 2 in range [1, 5] -> 3 ] expected = [2, 3] assert process_queries(n, m, flowerbeds, queries) == expected # Test Case 2 n = 6 m = 3 flowerbeds = [1, 1, 1, 1, 1, 1] queries = [ [2, 1, 6, 1], # Count query: count type 1 in range [1, 6] -> 6 [1, 1, 2], # Update query: update flowerbed 1 to type 2 [2, 1, 6, 1] # Count query: count type 1 in range [1, 6] -> 5 ] expected = [6, 5] assert process_queries(n, m, flowerbeds, queries) == expected # Test Case 3 n = 7 m = 4 flowerbeds = [3, 3, 3, 3, 3, 3, 3] queries = [ [2, 1, 7, 3], # Count query: count type 3 in range [1, 7] -> 7 [1, 4, 2], # Update query: update flowerbed 4 to type 2 [2, 1, 7, 3], # Count query: count type 3 in range [1, 7] -> 6 [2, 4, 6, 2] # Count query: count type 2 in range [4, 6] -> 1 ] expected = [7, 6, 1] assert process_queries(n, m, flowerbeds, queries) == expected # Test Case 4 n = 4 m = 2 flowerbeds = [4, 4, 4, 4] queries = [ [2, 2, 4, 4], # Count query: count type 4 in range [2, 4] -> 3 [1, 2, 3], # Update query: update flowerbed 2 to type 3 ] expected = [3] assert process_queries(n, m, flowerbeds, queries) == expected # Test Case 5 (Single flowerbed and single query) n = 1 m = 1 flowerbeds = [5] queries = [ [2, 1, 1, 5], # Count query: count type 5 in range [1, 1] -> 1 ] expected = [1] assert process_queries(n, m, flowerbeds, queries) == expected","solution":"def process_queries(n, m, flowerbeds, queries): Processes the given queries on the flowerbeds. Parameters: n (int): Number of flowerbeds. m (int): Number of queries. flowerbeds (list of int): List containing the type of flowers in each flowerbed. queries (list of list of int): List of queries to process. Returns: list of int: Results of the second type of queries. results = [] for query in queries: if query[0] == 1: # Update query position = query[1] - 1 # Convert to zero-based index type_of_flower = query[2] flowerbeds[position] = type_of_flower elif query[0] == 2: # Count query left = query[1] - 1 # Convert to zero-based index right = query[2] - 1 # Convert to zero-based index flower_type = query[3] count = sum(1 for i in range(left, right + 1) if flowerbeds[i] == flower_type) results.append(count) return results"},{"question":"def min_operations_to_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to sort the entire array in non-decreasing order. An operation consists of choosing any subarray of the array and sorting it in non-decreasing order. Args: t: An integer representing the number of test cases. test_cases: A list of tuples, each containing an integer n and a list of n integers representing the array. Returns: A list of integers where each integer corresponds to the minimum number of operations required to sort the array for each test case. >>> min_operations_to_sort(2, [(5, [5, 4, 3, 2, 1]), (6, [1, 3, 2, 6, 4, 5])]) [1, 1] >>> min_operations_to_sort(1, [(5, [1, 2, 3, 4, 5])]) [0] >>> min_operations_to_sort(1, [(5, [1, 5, 3, 4, 2])]) [1] >>> min_operations_to_sort(1, [(5, [2, 2, 2, 2, 2])]) [0]","solution":"def min_operations_to_sort(t, test_cases): results = [] for case in test_cases: n, arr = case if arr == sorted(arr): results.append(0) else: results.append(1) return results"},{"question":"from typing import List, Tuple def magical_forest_trip(n: int, m: int, k: int, paths: List[Tuple[int, int, int]], s: int) -> List[int]: Decide the starting tree and the sequence of k distinct trees to visit minimizing the magical energy cost. Args: n : int - The number of trees. m : int - The number of paths. k : int - The number of distinct trees to visit. paths : List[Tuple[int, int, int]] - Each path information as a tuple (xi, yi, ci) s : int - The tree to start from. Returns: List[int] - A possible sequence of k distinct trees to visit with minimal magical energy cost. Example: >>> magical_forest_trip(5, 6, 3, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7), (2, 4, 3), (4, 5, 6)], 1) [1, 3, 4] >>> magical_forest_trip(4, 3, 4, [(1, 2, 3), (1, 3, 2), (3, 4, 1)], 2) [2, 1, 3, 4] from solution import magical_forest_trip def test_example_1(): n = 5 m = 6 k = 3 paths = [ (1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7), (2, 4, 3), (4, 5, 6) ] s = 1 assert magical_forest_trip(n, m, k, paths, s) == [1, 3, 4] # Or other acceptable correct sequences def test_example_2(): n = 4 m = 3 k = 4 paths = [ (1, 2, 3), (1, 3, 2), (3, 4, 1) ] s = 2 assert magical_forest_trip(n, m, k, paths, s) == [2, 1, 3, 4] # Or other acceptable correct sequences","solution":"import heapq def magical_forest_trip(n, m, k, paths, s): # Creating the graph as adjacency list graph = {i: [] for i in range(1, n+1)} for x, y, c in paths: graph[x].append((c, y)) graph[y].append((c, x)) # Dijkstra's algorithm to find the shortest paths from the starting node s def dijkstra(start, n, graph): distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 priority_queue = [(0, start)] visited = set() while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) for distance, neighbor in graph[current_node]: if neighbor in visited: continue new_distance = current_distance + distance if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return distances # Get the distances from the start node distances = dijkstra(s, n, graph) # Pick k nodes with the smallest distances, including the start node distances = sorted([(dist, node) for node, dist in distances.items()]) selected_nodes = [node for dist, node in distances[:k]] return selected_nodes # Example usage n = 5 m = 6 k = 3 paths = [ (1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7), (2, 4, 3), (4, 5, 6) ] s = 1 print(magical_forest_trip(n, m, k, paths, s)) n = 4 m = 3 k = 4 paths = [ (1, 2, 3), (1, 3, 2), (3, 4, 1) ] s = 2 print(magical_forest_trip(n, m, k, paths, s))"},{"question":"def find_substring_indices(s: str, words: List[str]) -> List[int]: Given a string s and a set of words dict, find all the starting indices of substrings in s that are a concatenation of each word in dict exactly once without any intervening characters. The words in dict can be in any order. Input: s: The string consisting of lowercase English letters. dict: A list of words where all words have the same length and contain lowercase English letters. Returns: A list of starting indices of the substring(s) in s that are the concatenation of each word in dict. Example: >>> find_substring_indices(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> find_substring_indices(\\"barfoothefoobarman\\", [\\"baz\\", \\"bar\\"]) [] >>> find_substring_indices(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"good\\"]) [8]","solution":"def find_substring_indices(s, words): if not s or not words: return [] word_len = len(words[0]) words_count = len(words) substring_len = word_len * words_count word_freq = {} for word in words: word_freq[word] = word_freq.get(word, 0) + 1 result = [] for i in range(len(s) - substring_len + 1): seen_words = {} for j in range(0, substring_len, word_len): word = s[i + j:i + j + word_len] if word in word_freq: seen_words[word] = seen_words.get(word, 0) + 1 if seen_words[word] > word_freq[word]: break else: break if seen_words == word_freq: result.append(i) return result"},{"question":"def max_employees_present(n: int, intervals: List[str]) -> int: Determine the maximum number of employees present at any single minute within their working hours on that day. Args: n : int : The number of employees. intervals : List[str] : List of strings where each string represents arrival and departure times in HH:MM format. Returns: int : The maximum number of employees present at any single minute. >>> max_employees_present(5, [\\"09:00 11:00\\", \\"10:00 12:30\\", \\"09:30 11:30\\", \\"11:00 13:00\\", \\"12:00 14:00\\"]) 3 >>> max_employees_present(3, [\\"09:00 10:00\\", \\"10:00 11:00\\", \\"11:00 12:00\\"]) 1 from typing import List def test_example_case(): n = 5 intervals = [ \\"09:00 11:00\\", \\"10:00 12:30\\", \\"09:30 11:30\\", \\"11:00 13:00\\", \\"12:00 14:00\\" ] assert max_employees_present(n, intervals) == 3 def test_no_overlap(): n = 3 intervals = [ \\"09:00 10:00\\", \\"10:00 11:00\\", \\"11:00 12:00\\" ] assert max_employees_present(n, intervals) == 1 def test_full_overlap(): n = 3 intervals = [ \\"09:00 17:00\\", \\"09:00 17:00\\", \\"09:00 17:00\\" ] assert max_employees_present(n, intervals) == 3 def test_partial_overlap(): n = 4 intervals = [ \\"09:00 12:00\\", \\"09:30 13:30\\", \\"10:00 11:00\\", \\"11:30 12:30\\" ] assert max_employees_present(n, intervals) == 3 def test_single_employee(): n = 1 intervals = [ \\"09:00 17:00\\" ] assert max_employees_present(n, intervals) == 1 def test_two_period_same_time(): n = 4 intervals = [ \\"09:00 10:00\\", \\"10:00 11:00\\", \\"09:00 09:30\\", \\"09:30 10:00\\" ] assert max_employees_present(n, intervals) == 2","solution":"def max_employees_present(n, intervals): from collections import defaultdict time_points = defaultdict(int) for interval in intervals: arrival, departure = interval.split() arrival_hour, arrival_minute = map(int, arrival.split(\\":\\")) departure_hour, departure_minute = map(int, departure.split(\\":\\")) arrival_minutes = arrival_hour * 60 + arrival_minute departure_minutes = departure_hour * 60 + departure_minute time_points[arrival_minutes] += 1 time_points[departure_minutes] -= 1 max_emps = 0 current_emps = 0 for time_point in sorted(time_points): current_emps += time_points[time_point] if current_emps > max_emps: max_emps = current_emps return max_emps"},{"question":"def maxProfit(prices: List[int], k: int) -> int: Given an array of integers representing the stock prices of a company in chronological order, calculates the maximum profit you can achieve with at most k transactions. Parameters: prices (List[int]): The stock prices. k (int): The maximum number of transactions allowed. Returns: int: The maximum profit. >>> maxProfit([3,3,5,0,0,3,1,4], 2) 6 >>> maxProfit([7, 6, 4, 3, 1], 1) 0 >>> maxProfit([1, 2, 3, 4, 5], 10) 4 >>> maxProfit([], 2) 0 >>> maxProfit([1, 2, 3, 0, 2], 1) 2 >>> maxProfit([3, 2, 6, 5, 0, 3], 2) 7","solution":"def maxProfit(prices, k): if not prices or k == 0: return 0 n = len(prices) # If k is greater than or equal to n//2, then it's the same as unlimited transactions problem. if k >= n // 2: max_profit = 0 for i in range(1, n): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit # dp[i][j] represents the max profit up to day j with at most i transactions dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[k][n - 1]"},{"question":"def levenshtein_distance(str1: str, str2: str) -> int: Compute the editing distance (Levenshtein distance) between two strings. The editing distance between two strings is the smallest number of insertions, deletions, and substitutions needed to transform one string into the other. Examples: >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> levenshtein_distance(\\"intention\\", \\"execution\\") 5 # Your code here # Unit tests def test_levenshtein_distance_same_strings(): assert levenshtein_distance(\\"test\\", \\"test\\") == 0 def test_levenshtein_distance_empty_strings(): assert levenshtein_distance(\\"\\", \\"\\") == 0 def test_levenshtein_distance_one_empty_string(): assert levenshtein_distance(\\"\\", \\"abc\\") == 3 assert levenshtein_distance(\\"abc\\", \\"\\") == 3 def test_levenshtein_distance_case1(): assert levenshtein_distance(\\"kitten\\", \\"sitting\\") == 3 def test_levenshtein_distance_case2(): assert levenshtein_distance(\\"flaw\\", \\"lawn\\") == 2 def test_levenshtein_distance_case3(): assert levenshtein_distance(\\"intention\\", \\"execution\\") == 5 def test_levenshtein_distance_single_character(): assert levenshtein_distance(\\"a\\", \\"b\\") == 1 def test_levenshtein_distance_long_strings(): assert levenshtein_distance(\\"abcdefg\\", \\"abcdef\\") == 1 assert levenshtein_distance(\\"abcdefg\\", \\"abcdxyz\\") == 3","solution":"def levenshtein_distance(str1: str, str2: str) -> int: len_str1 = len(str1) len_str2 = len(str2) # Initialize matrix dp = [[0 for _ in range(len_str2 + 1)] for _ in range(len_str1 + 1)] # Set up base cases for i in range(len_str1 + 1): dp[i][0] = i for j in range(len_str2 + 1): dp[0][j] = j # Compute distances for i in range(1, len_str1 + 1): for j in range(1, len_str2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Substitution return dp[len_str1][len_str2]"},{"question":"def can_form_by_deleting(s1: str, s2: str) -> str: Determines whether s2 can be formed by deleting some characters from s1 without rearranging the remaining characters. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: str: \\"YES\\" if s2 can be formed, otherwise \\"NO\\". >>> can_form_by_deleting(\\"abcde\\", \\"ace\\") == \\"YES\\" >>> can_form_by_deleting(\\"abcde\\", \\"aec\\") == \\"NO\\" >>> can_form_by_deleting(\\"abc\\", \\"abc\\") == \\"YES\\" >>> can_form_by_deleting(\\"abcde\\", \\"e\\") == \\"YES\\" >>> can_form_by_deleting(\\"abcde\\", \\"\\") == \\"YES\\" >>> can_form_by_deleting(\\"\\", \\"a\\") == \\"NO\\" >>> can_form_by_deleting(\\"a\\"*99999+\\"b\\", \\"ab\\") == \\"YES\\" >>> can_form_by_deleting(\\"abcdefgh\\", \\"ghe\\") == \\"NO\\"","solution":"def can_form_by_deleting(s1, s2): Determines whether s2 can be formed by deleting some characters from s1 without rearranging the remaining characters. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: str: \\"YES\\" if s2 can be formed, otherwise \\"NO\\". it = iter(s1) for char in s2: if char not in it: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def sort_logs(logs: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Sorts a list of log entries by their timestamp. :param logs: List of tuples where each tuple contains a timestamp and a log message. :return: List of log entries sorted by timestamp. >>> sort_logs([(3, \\"Error Detected\\"), (1, \\"System Boot\\"), (2, \\"User Login\\"), (4, \\"System Shutdown\\")]) [(1, \\"System Boot\\"), (2, \\"User Login\\"), (3, \\"Error Detected\\"), (4, \\"System Shutdown\\")]","solution":"from typing import List, Tuple def sort_logs(logs: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Sorts a list of log entries by their timestamp. :param logs: List of tuples where each tuple contains a timestamp and a log message. :return: List of log entries sorted by timestamp. return sorted(logs, key=lambda x: x[0])"},{"question":"def longest_special_substring(s: str) -> (int, int): Leah enjoys working with strings and finding unique patterns within them. Her latest challenge involves identifying special substrings, which she defines as substrings where no character repeats. Leah wants to write a program to help her find the longest special substring within a given string. Given a string \`str\` consisting of lowercase English letters, determine the length and starting position of the longest special substring. If there are multiple substrings of the same maximum length, return the starting position of the first one found. The input consists of a single line with a string \`str\` of length \`n\` (1 ≤ n ≤ 1000). Output two integers: the length of the longest special substring and its starting position (1-based). If the string is empty, output 0 and 1. Example: >>> longest_special_substring(\\"abcabcbb\\") (3, 1) >>> longest_special_substring(\\"bbbbb\\") (1, 1) >>> longest_special_substring(\\"pwwkew\\") (3, 3) pass # Implement the function here # Unit tests def test_example1(): assert longest_special_substring(\\"abcabcbb\\") == (3, 1) def test_example2(): assert longest_special_substring(\\"bbbbb\\") == (1, 1) def test_example3(): assert longest_special_substring(\\"pwwkew\\") == (3, 3) def test_empty_string(): assert longest_special_substring(\\"\\") == (0, 1) def test_single_character(): assert longest_special_substring(\\"a\\") == (1, 1) def test_all_unique_characters(): assert longest_special_substring(\\"abcdefgh\\") == (8, 1) def test_repeated_patterns(): assert longest_special_substring(\\"abcabcabcd\\") == (4, 7)","solution":"def longest_special_substring(s): Returns the length and starting position (1-based) of the longest special substring. n = len(s) if n == 0: return 0, 1 max_length = 1 start_position = 1 char_map = {} left = 0 for right in range(n): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right current_length = right - left + 1 if current_length > max_length: max_length = current_length start_position = left + 1 return max_length, start_position"},{"question":"def count_valid_codes(n: int) -> int: Calculate the total number of valid codes of length n following the given rules. The code can only contain characters 'A', 'B', and 'C'. No character should appear consecutively more than once. >>> count_valid_codes(1) 3 >>> count_valid_codes(2) 6 >>> count_valid_codes(3) 12 >>> count_valid_codes(4) 24 >>> count_valid_codes(5) 48","solution":"def count_valid_codes(n): if n == 1: return 3 # Dynamic Programming table to store the valid code counts dp = [[0]*3 for _ in range(n)] # Initialize base case dp[0][0] = dp[0][1] = dp[0][2] = 1 # Considering 'A', 'B', 'C' respectively # Populate the dp table for i in range(1, n): dp[i][0] = dp[i-1][1] + dp[i-1][2] # Ending with 'A' dp[i][1] = dp[i-1][0] + dp[i-1][2] # Ending with 'B' dp[i][2] = dp[i-1][0] + dp[i-1][1] # Ending with 'C' # Sum of all the possible combinations of length n total_valid_codes = dp[n-1][0] + dp[n-1][1] + dp[n-1][2] return total_valid_codes"},{"question":"def longest_contiguous_ones(grid: List[List[int]], n: int, m: int) -> int: Determine the length of the longest contiguous sequence of 1s in any row, column, or diagonal (both main and anti-diagonal) of a grid. >>> longest_contiguous_ones([[1, 0, 1, 1, 0], [1, 1, 1, 0, 0], [0, 1, 1, 1, 1], [0, 0, 0, 0, 1]], 4, 5) 4 >>> longest_contiguous_ones([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 4, 4) 4 >>> longest_contiguous_ones([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 3, 3) 0 >>> longest_contiguous_ones([[1]], 1, 1) 1 >>> longest_contiguous_ones([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 3, 3) 0 >>> longest_contiguous_ones([[0, 1, 0], [1, 1, 1], [0, 1, 0]], 3, 3) 3 >>> longest_contiguous_ones([[1, 1, 0], [0, 1, 1], [1, 0, 1]], 3, 3) 3 >>> longest_contiguous_ones([[1 for _ in range(50)] for _ in range(50)], 50, 50) 50 pass","solution":"def longest_contiguous_ones(grid, n, m): def check_sequences(sequence): max_length = 0 current_length = 0 for value in sequence: if value == 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 0 return max(max_length, current_length) max_ones = 0 # Check rows for row in grid: max_ones = max(max_ones, check_sequences(row)) # Check columns for col_idx in range(m): col = [grid[row_idx][col_idx] for row_idx in range(n)] max_ones = max(max_ones, check_sequences(col)) # Check main diagonals for start_idx in range(n): diagonal = [] i, j = start_idx, 0 while i < n and j < m: diagonal.append(grid[i][j]) i += 1 j += 1 max_ones = max(max_ones, check_sequences(diagonal)) for start_idx in range(1, m): diagonal = [] i, j = 0, start_idx while i < n and j < m: diagonal.append(grid[i][j]) i += 1 j += 1 max_ones = max(max_ones, check_sequences(diagonal)) # Check anti-diagonals for start_idx in range(n): diagonal = [] i, j = start_idx, 0 while i >= 0 and j < m: diagonal.append(grid[i][j]) i -= 1 j += 1 max_ones = max(max_ones, check_sequences(diagonal)) for start_idx in range(1, m): diagonal = [] i, j = n - 1, start_idx while i >= 0 and j < m: diagonal.append(grid[i][j]) i -= 1 j += 1 max_ones = max(max_ones, check_sequences(diagonal)) return max_ones"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Determines if s2 is an anagram of s1. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s2 is an anagram of s1, False otherwise. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"hello\\", \\"bello\\") False","solution":"def is_anagram(s1: str, s2: str) -> bool: Determines if s2 is an anagram of s1. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s2 is an anagram of s1, False otherwise. # An anagram must be the same length as the original string if len(s1) != len(s2): return False # Count the occurrences of each character in both strings from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"def longest_path(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Calculate the length of the longest path in the city's road network without violating the one-way restrictions. Args: n (int): The number of intersections. m (int): The number of roads. edges (List[Tuple[int, int]]): The list of directed roads represented as tuples (u, v). Returns: int: The length of the longest path. Example: >>> longest_path(6, 7, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5), (1, 4)]) 4 >>> longest_path(3, 0, []) 0 >>> longest_path(1, 0, []) 0 pass from solution import longest_path def test_example(): n = 6 m = 7 edges = [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5), (1, 4)] assert longest_path(n, m, edges) == 4 def test_no_paths(): n = 3 m = 0 edges = [] assert longest_path(n, m, edges) == 0 def test_single_node(): n = 1 m = 0 edges = [] assert longest_path(n, m, edges) == 0 def test_linear_path(): n = 5 m = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 4)] assert longest_path(n, m, edges) == 4 def test_multiple_paths_same_length(): n = 5 m = 6 edges = [(0, 1), (0, 2), (1, 3), (2, 3), (1, 4), (2, 4)] assert longest_path(n, m, edges) == 2 def test_diverging_paths(): n = 5 m = 4 edges = [(0, 1), (0, 2), (1, 3), (2, 4)] assert longest_path(n, m, edges) == 2 def test_complex_case(): n = 7 m = 10 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3), (2, 4), (1, 5), (4, 6)] assert longest_path(n, m, edges) == 6","solution":"from typing import List, Tuple from collections import defaultdict, deque def longest_path(n: int, m: int, edges: List[Tuple[int, int]]) -> int: # Create graph and in-degrees graph = defaultdict(list) in_degree = [0] * n for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Perform topological sort using Kahn's algorithm topo_order = [] q = deque([i for i in range(n) if in_degree[i] == 0]) while q: node = q.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: q.append(neighbor) # Initialize distances dist = [-1] * n for node in topo_order: if dist[node] == -1: dist[node] = 0 for neighbor in graph[node]: if dist[neighbor] < dist[node] + 1: dist[neighbor] = dist[node] + 1 # Return the longest path found return max(dist)"},{"question":"from typing import List def maxProductOfThree(nums: List[int]) -> int: Returns the maximum product you can obtain by multiplying three elements from the array. >>> maxProductOfThree([1, 2, 3, 4]) 24 >>> maxProductOfThree([-10, -10, 5, 2]) 500 def test_maxProductOfThree_positive_numbers(): assert maxProductOfThree([1, 2, 3, 4]) == 24 def test_maxProductOfThree_with_zeros(): assert maxProductOfThree([0, 0, 0, 1, 2, 3, 4]) == 24 assert maxProductOfThree([0, 1, 2, 3]) == 6 def test_maxProductOfThree_negative_numbers(): assert maxProductOfThree([-1, -2, -3, -4]) == -6 assert maxProductOfThree([-10, -10, 5, 2]) == 500 def test_maxProductOfThree_mixed_sign_numbers(): assert maxProductOfThree([-10, -10, 1, 2, 3]) == 300 assert maxProductOfThree([-10, -9, 1, 2, 3]) == 270 def test_maxProductOfThree_small_list(): assert maxProductOfThree([1, 2, 3]) == 6 assert maxProductOfThree([-1, -2, -3]) == -6","solution":"from typing import List def maxProductOfThree(nums: List[int]) -> int: Returns the maximum product of any three integers in the list nums. nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def calculate_sum_in_time_range(n, events, t1, t2): Calculates the sum of purchase values for all events within a specific time range. :param n: int, number of purchase events :param events: list of tuples, each tuple consists of (ai, ti, pi) :param t1: int, start of time range :param t2: int, end of time range :return: int, sum of purchase values within time range >>> n = 5 >>> events = [(0, 5, 10), (1, 3, 20), (1, 8, 30), (2, 6, 40), (3, 10, 50)] >>> t1, t2 = 3, 9 >>> calculate_sum_in_time_range(n, events, t1, t2) 100 >>> n = 4 >>> events = [(0, 1, 10), (1, 2, 20), (1, 4, 30), (2, 5, 40)] >>> t1, t2 = 6, 9 >>> calculate_sum_in_time_range(n, events, t1, t2) 0 >>> n = 3 >>> events = [(0, 7, 10), (1, 8, 20), (1, 9, 30)] >>> t1, t2 = 0, 10 >>> calculate_sum_in_time_range(n, events, t1, t2) 60 >>> n = 4 >>> events = [(0, 3, 10), (1, 6, 20), (1, 7, 30), (2, 9, 40)] >>> t1, t2 = 4, 8 >>> calculate_sum_in_time_range(n, events, t1, t2) 50 >>> n = 1 >>> events = [(0, 5, 10)] >>> t1, t2 = 5, 5 >>> calculate_sum_in_time_range(n, events, t1, t2) 10","solution":"def calculate_sum_in_time_range(n, events, t1, t2): Calculates the sum of purchase values for all events within a specific time range. :param n: int, number of purchase events :param events: list of tuples, each tuple consists of (ai, ti, pi) :param t1: int, start of time range :param t2: int, end of time range :return: int, sum of purchase values within time range total_sum = 0 for _, ti, pi in events: if t1 <= ti <= t2: total_sum += pi return total_sum # Example usage: n = 5 events = [ (0, 5, 10), (1, 3, 20), (1, 8, 30), (2, 6, 40), ] t1, t2 = 3, 9 result = calculate_sum_in_time_range(n, events, t1, t2) print(result) # Output should be 120"},{"question":"def strongest_creatures(n: int, creatures: list) -> list: Determine the strongest creature of each type if there is exactly one. Parameters: n (int): Number of different types of creatures creatures (list of lists): List of lists representing each type of creatures Returns: list or int: List of power levels of the strongest creatures if unique, otherwise -1 >>> strongest_creatures(3, [[6, 15, 25], [18, 7], [5, 11, 3]]) [25, 18, 11] >>> strongest_creatures(3, [[6, 15, 25, 25], [18, 18], [5, 11, 3, 11]]) -1 >>> strongest_creatures(2, [[100], [200]]) [100, 200] >>> strongest_creatures(2, [[3, 1, 4, 4], [5, 2, 2, 5]]) -1 >>> strongest_creatures(2, [[9, 7, 8], [10, 10, 2, 1]]) -1 # Your code here","solution":"def strongest_creatures(n, creatures): Determine the strongest creature of each type if there is exactly one. Parameters: n (int): Number of different types of creatures creatures (list of lists): List of lists representing each type of creatures Returns: list or int: List of power levels of the strongest creatures if unique, otherwise -1 result = [] for creature_list in creatures: max_power = max(creature_list) # Check if there are multiple creatures with the same max power if creature_list.count(max_power) > 1: return -1 result.append(max_power) return result"},{"question":"from typing import List, Union, Tuple def can_partition(m: int, q: List[int]) -> Union[str, Tuple[str, List[int]]]: Determine if it is possible to partition the integers into two groups with equal sums. >>> can_partition(4, [1, 5, 11, 5]) ('YES', [0, 1, 1, 0]) >>> can_partition(3, [1, 2, 5]) \\"NO\\" >>> can_partition(5, [100, 200, 300, 400, 500]) \\"NO\\" >>> can_partition(1, [3]) \\"NO\\" >>> can_partition(2, [7, 7]) ('YES', [0, 1]) pass # Your solution here # Unit tests def test_can_partition_possible(): m = 4 q = [1, 5, 11, 5] result = can_partition(m, q) assert result[0] == \\"YES\\" assert sum(q[i] for i in range(m) if result[1][i] == 0) == sum(q[i] for i in range(m) if result[1][i] == 1) def test_can_partition_impossible_odd_sum(): m = 3 q = [1, 2, 5] assert can_partition(m, q) == \\"NO\\" def test_can_partition_impossible_large_integers(): m = 5 q = [100, 200, 300, 400, 500] assert can_partition(m, q) == \\"NO\\" def test_can_partition_single_element(): m = 1 q = [3] assert can_partition(m, q) == \\"NO\\" def test_can_partition_two_elements_equal(): m = 2 q = [7, 7] result = can_partition(m, q) assert result[0] == \\"YES\\" assert sum(q[i] for i in range(m) if result[1][i] == 0) == sum(q[i] for i in range(m) if result[1][i] == 1)","solution":"def can_partition(m, q): total_sum = sum(q) # If the total sum is odd, it cannot be partitioned into two equal sums if total_sum % 2 != 0: return \\"NO\\" target_sum = total_sum // 2 dp = [False] * (target_sum + 1) dp[0] = True for num in q: for j in range(target_sum, num - 1, -1): if dp[j - num]: dp[j] = True if not dp[target_sum]: return \\"NO\\" # Backtrack to find the partition result = [0] * m remaining_sum = target_sum for i in range(m-1, -1, -1): if remaining_sum >= q[i] and dp[remaining_sum - q[i]]: result[i] = 1 remaining_sum -= q[i] return \\"YES\\", result"},{"question":"def min_subarray_length(arr: List[int], S: int) -> int: This function finds the minimum size subarray whose sum is greater than or equal to S. If there is no such subarray, it returns 0. >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 4, 4], 4) 1 >>> min_subarray_length([1, 1, 1, 1, 1, 1, 1, 1], 11) 0 >>> min_subarray_length([1, 2, 3, 4, 5], 11) 3 >>> min_subarray_length([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_length([5, 1, 2, 4, 3], 5) 1","solution":"def min_subarray_length(arr, S): This function finds the minimum size subarray whose sum is greater than or equal to S. If there is no such subarray, it returns 0. n = len(arr) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] # Slide the window as long as the current sum is greater than or equal to S while current_sum >= S: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length <= n else 0"},{"question":"from collections import defaultdict def max_path_sum(N, values, edges): Find the largest value path from the root to any leaf node in a binary tree. Args: N: int : Number of nodes in the tree values: List[int] : List of values of the N nodes edges: List[Tuple[int, int]] : List of edges representing the tree Returns: int : Maximum path sum from the root to any leaf node >>> max_path_sum(3, [1, 2, 3], [(1, 2), (1, 3)]) == 4 >>> max_path_sum(4, [1, 3, 5, 7], [(1, 2), (2, 3), (2, 4)]) == 11 >>> max_path_sum(1, [10], []) == 10 >>> max_path_sum(2, [1, 10], [(1, 2)]) == 11 >>> max_path_sum(0, [], []) == 0 >>> max_path_sum(5, [3, 2, 1, 10, 8], [(1, 2), (1, 3), (3, 4), (3, 5)]) == 14","solution":"from collections import defaultdict def max_path_sum(N, values, edges): if N == 0: return 0 tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): current_max_sum = values[node - 1] max_sum_child = 0 for neighbor in tree[node]: if neighbor == parent: continue max_sum_child = max(max_sum_child, dfs(neighbor, node)) return current_max_sum + max_sum_child return dfs(1, -1)"},{"question":"def find_books_by_category(books: List[Tuple[str, str, int, str]], queries: List[Tuple[str, str, str]]) -> dict: Filter and sort books based on the given queries. Parameters: books (list of tuples): Each tuple contains (title, author, year, category). queries (list of tuples): Each tuple contains (search_category, sort_field, sort_order). Returns: dict: A dictionary where keys are the query parameters and values are lists of sorted book titles. pass # Unit Test def test_find_books_by_category(): books = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925, \\"Fiction\\"), (\\"A Brief History of Time\\", \\"Stephen Hawking\\", 1988, \\"Science\\"), (\\"1984\\", \\"George Orwell\\", 1949, \\"Fiction\\"), (\\"Sapiens\\", \\"Yuval Noah Harari\\", 2011, \\"Science\\"), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960, \\"Fiction\\") ] queries = [ (\\"Fiction\\", \\"title\\", \\"asc\\"), (\\"Science\\", \\"year\\", \\"desc\\") ] expected_output = { queries[0]: [\\"1984\\", \\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"], queries[1]: [\\"Sapiens\\", \\"A Brief History of Time\\"] } assert find_books_by_category(books, queries) == expected_output queries = [ (\\"Science\\", \\"author\\", \\"asc\\") ] expected_output = { queries[0]: [\\"A Brief History of Time\\", \\"Sapiens\\"] } assert find_books_by_category(books, queries) == expected_output queries = [ (\\"Fiction\\", \\"year\\", \\"desc\\") ] expected_output = { queries[0]: [\\"To Kill a Mockingbird\\", \\"1984\\", \\"The Great Gatsby\\"] } assert find_books_by_category(books, queries) == expected_output","solution":"def find_books_by_category(books, queries): Filter and sort books based on the given queries. Parameters: books (list of tuples): Each tuple contains (title, author, year, category). queries (list of tuples): Each tuple contains (search_category, sort_field, sort_order). Returns: dict: A dictionary where keys are the query parameters and values are lists of sorted book titles. result = {} for query in queries: search_category, sort_field, sort_order = query filtered_books = [book for book in books if book[3] == search_category] if sort_field == 'title': sort_key = 0 elif sort_field == 'author': sort_key = 1 elif sort_field == 'year': sort_key = 2 reverse = sort_order == 'desc' sorted_books = sorted(filtered_books, key=lambda x: x[sort_key], reverse=reverse) result[query] = [book[0] for book in sorted_books] return result # Example usage books = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925, \\"Fiction\\"), (\\"A Brief History of Time\\", \\"Stephen Hawking\\", 1988, \\"Science\\"), (\\"1984\\", \\"George Orwell\\", 1949, \\"Fiction\\"), (\\"Sapiens\\", \\"Yuval Noah Harari\\", 2011, \\"Science\\"), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960, \\"Fiction\\") ] queries = [ (\\"Fiction\\", \\"title\\", \\"asc\\"), (\\"Science\\", \\"year\\", \\"desc\\") ] print(find_books_by_category(books, queries))"},{"question":"def can_sum_to_target(arr, target): Determines if there exists any combination of elements in the array that sum up to the target. Each element in the array can be used multiple times. :param arr: List of non-negative integers. :param target: Target sum integer. :return: 'YES' if the target sum can be achieved by any combination of elements, otherwise 'NO'. >>> can_sum_to_target([2, 3, 5], 8) \\"YES\\" >>> can_sum_to_target([2, 4], 7) \\"NO\\" pass","solution":"def can_sum_to_target(arr, target): Determines if there exists any combination of elements in the array that sum up to the target. Each element in the array can be used multiple times. :param arr: List of non-negative integers. :param target: Target sum integer. :return: 'YES' if the target sum can be achieved by any combination of elements, otherwise 'NO'. dp = [False] * (target + 1) dp[0] = True for i in range(target + 1): if dp[i]: for num in arr: if i + num <= target: dp[i + num] = True return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"import re from typing import List def is_camel_case(identifier: str) -> bool: Determine if the given identifier is in camel case format. >>> is_camel_case(\\"camelCase\\") True >>> is_camel_case(\\"CamelCase\\") False >>> is_camel_case(\\"camelcase\\") True >>> is_camel_case(\\"Camelcase\\") False >>> is_camel_case(\\"camelCaseExample\\") True >>> is_camel_case(\\"camel_case\\") False >>> is_camel_case(\\"camel\\") True >>> is_camel_case(\\"camel1234\\") False >>> is_camel_case(\\"camelC123ase\\") False >>> is_camel_case(\\"camelCase_\\") False pass def check_identifiers(identifiers: List[str]) -> List[str]: Given a list of identifiers, determine if each is in camel case format and return a list of results. >>> check_identifiers([\\"camelCase\\", \\"CamelCase\\", \\"camelcase\\", \\"Camelcase\\", \\"camelCaseExample\\", \\"camel_case\\", \\"camel\\"]) ['YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES'] pass","solution":"import re def is_camel_case(identifier): Determine if the given identifier is in camel case format. pattern = '^[a-z]+(?:[A-Z][a-z]*)*' return re.match(pattern, identifier) is not None def check_identifiers(identifiers): Given a list of identifiers, determine if each is in camel case format and return a list of results. return [\\"YES\\" if is_camel_case(identifier) else \\"NO\\" for identifier in identifiers]"},{"question":"def max_enemies_destroyed(n, c, enemy_times): Determines the maximum number of enemies that can be destroyed given the cooldown period. Parameters: n (int): Number of approaching enemies. c (int): Cooldown time of the cannon. enemy_times (List[int]): List of times when each enemy arrives. Returns: int: Maximum number of enemies that can be destroyed. >>> max_enemies_destroyed(7, 3, [1, 2, 3, 6, 7, 10, 14]) 4 >>> max_enemies_destroyed(5, 1, [1, 2, 3, 4, 5]) 5 >>> max_enemies_destroyed(5, 10, [1, 2, 3, 4, 5]) 1 >>> max_enemies_destroyed(0, 10, []) 0 >>> max_enemies_destroyed(1, 5, [3]) 1 >>> max_enemies_destroyed(6, 2, [2, 5, 8, 11, 14, 17]) 6","solution":"def max_enemies_destroyed(n, c, enemy_times): Determines the maximum number of enemies that can be destroyed given the cooldown period. Parameters: n (int): Number of approaching enemies. c (int): Cooldown time of the cannon. enemy_times (List[int]): List of times when each enemy arrives. Returns: int: Maximum number of enemies that can be destroyed. destroyed_count = 0 last_shot_time = -c # Initialize to allow firing at the first enemy for time in enemy_times: if time >= last_shot_time + c: destroyed_count += 1 last_shot_time = time return destroyed_count"},{"question":"def all_unique_substrings(n: int, s: str, q: int, queries: List[Tuple[int, int]]) -> List[str]: Determine if substrings have all unique characters. n : int : length of the string s : str : a string consisting of lowercase English letters q : int : number of queries queries : List[Tuple[int, int]] : list of queries with 1-based inclusive positions of the substring Returns a list of strings \\"Yes\\" or \\"No\\" for each query. Example: n = 5 s = 'abcde' q = 3 queries = [(1, 3), (2, 4), (1, 5)] >>> all_unique_substrings(n, s, q, queries) ['Yes', 'Yes', 'Yes'] n = 5 s = 'ababa' q = 2 queries = [(1, 3), (1, 5)] >>> all_unique_substrings(n, s, q, queries) ['No', 'No']","solution":"def all_unique_substrings(n, s, q, queries): results = [] for li, ri in queries: substring = s[li-1:ri] if len(substring) == len(set(substring)): # Check if all characters are unique results.append(\\"Yes\\") else: results.append(\\"No\\") return results # Example usage n = 5 s = 'abcde' q = 3 queries = [(1, 3), (2, 4), (1, 5)] print(all_unique_substrings(n, s, q, queries)) # Output: ['Yes', 'Yes', 'Yes']"},{"question":"def time_difference(start_time: str, end_time: str) -> int: Calculate the difference in minutes between start_time and end_time on the same day. >>> time_difference(\\"12:30\\", \\"14:45\\") 135 >>> time_difference(\\"22:50\\", \\"01:20\\") 150 >>> time_difference(\\"00:00\\", \\"23:59\\") 1439 >>> time_difference(\\"23:59\\", \\"00:00\\") 1 >>> time_difference(\\"10:00\\", \\"10:00\\") 0 def calculate_time_differences(t: int, time_cases: List[Tuple[str, str]]) -> List[int]: Calculate the time differences for a list of time cases. >>> calculate_time_differences(3, [(\\"12:30\\", \\"14:45\\"), (\\"22:50\\", \\"01:20\\"), (\\"00:00\\", \\"23:59\\")]) [135, 150, 1439] >>> calculate_time_differences(2, [(\\"23:59\\", \\"00:00\\"),(\\"10:00\\", \\"10:00\\")]) [1, 0] >>> calculate_time_differences(1, [(\\"01:01\\", \\"01:02\\")]) [1]","solution":"def time_difference(start_time, end_time): Calculate the difference in minutes between start_time and end_time on the same day. start_hour, start_minute = map(int, start_time.split(':')) end_hour, end_minute = map(int, end_time.split(':')) start_total_minutes = start_hour * 60 + start_minute end_total_minutes = end_hour * 60 + end_minute if end_total_minutes >= start_total_minutes: return end_total_minutes - start_total_minutes else: return (24 * 60 - start_total_minutes) + end_total_minutes def calculate_time_differences(t, time_cases): Calculate the time differences for a list of time cases. result = [] for start_time, end_time in time_cases: result.append(time_difference(start_time, end_time)) return result"},{"question":"def calculate_ranks(scores: List[int]) -> List[int]: Given a list of scores, returns the ranks of each score in the same order. >>> calculate_ranks([100, 50, 50, 25]) [1, 2, 2, 4] >>> calculate_ranks([100, 90, 80, 70]) [1, 2, 3, 4] >>> calculate_ranks([50, 50, 50, 50]) [1, 1, 1, 1] >>> calculate_ranks([87, 87, 87, 60, 60, 50]) [1, 1, 1, 4, 4, 6]","solution":"def calculate_ranks(scores): Given a list of scores, returns the ranks of each score in the same order. sorted_scores = sorted([(score, i) for i, score in enumerate(scores)], reverse=True) ranks = [0] * len(scores) current_rank = 1 for i in range(len(sorted_scores)): if i > 0 and sorted_scores[i][0] < sorted_scores[i-1][0]: current_rank = i + 1 ranks[sorted_scores[i][1]] = current_rank return ranks"},{"question":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merge all overlapping intervals and return the merged intervals in ascending order based on the left endpoint of each interval. :param intervals: List of intervals, each interval is a list [L, R] :return: List of merged intervals >>> merge_intervals([[1, 3], [2, 4], [5, 7], [6, 8]]) [[1, 4], [5, 8]] >>> merge_intervals([[1, 2], [3, 4]]) [[1, 2], [3, 4]]","solution":"def merge_intervals(intervals): Merge all overlapping intervals and return the merged intervals in ascending order based on the left endpoint of each interval. :param intervals: List of intervals, each interval is a list [L, R] :return: List of merged intervals if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals"},{"question":"def determine_winner(n: int, points: List[int]) -> str: Determines the winner of the game given the initial configuration of points on the board. Parameters: n (int): Number of positions on the game board. points (list of int): List of integers representing points at each position. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins, or \\"Draw\\" if the game is a draw. >>> determine_winner(5, [1, 2, 3, 4, 5]) \\"Alice\\" >>> determine_winner(6, [1, 2, 3, 4, 5, 6]) \\"Bob\\" >>> determine_winner(2, [1000, 1000]) \\"Draw\\" >>> determine_winner(4, [10000, 10000, 10000, 10000]) \\"Draw\\" >>> determine_winner(3, [0, 0, 0]) \\"Draw\\" >>> determine_winner(3, [0, 10000, 0]) \\"Bob\\"","solution":"def determine_winner(n, points): Determines the winner of the game given the initial configuration of points on the board. Parameters: n (int): Number of positions on the game board. points (list of int): List of integers representing points at each position. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins, or \\"Draw\\" if the game is a draw. total_sum = sum(points) alice_sum = 0 # Iterate over the points array to simulate the game for i, point in enumerate(points): if i % 2 == 0: alice_sum += point bob_sum = total_sum - alice_sum if alice_sum > bob_sum: return \\"Alice\\" elif alice_sum < bob_sum: return \\"Bob\\" else: return \\"Draw\\""},{"question":"def is_valid_forest(parents: List[int]) -> bool: Check if the forest represented by the parents array is valid. >>> is_valid_forest([-1, 1, 1, -1, 4]) == True >>> is_valid_forest([2, 3, 1, -1, -1]) == False >>> is_valid_forest([-1, -1, 1, 2, -1, -1]) == True >>> is_valid_forest([-1, 1, 1, 3, 3]) == False >>> is_valid_forest([2, 3, 1, -1]) == False >>> is_valid_forest([-1, -1, -1, -1]) == True >>> is_valid_forest([1, -1, -1, -1]) == False >>> is_valid_forest([-1]) == True >>> is_valid_forest([-1, -1]) == True pass","solution":"from typing import List def is_valid_forest(parents: List[int]) -> bool: Check if the forest represented by the parents array is valid. n = len(parents) # Each node (1 to n) must have at most one parent and exactly one root node per tree parent_count = [0] * (n + 1) # Index 0 is dummy, vertex labels are 1 to n for i in range(n): if parents[i] != -1: parent_count[parents[i]] += 1 for i in range(n): if parents[i] != -1 and parent_count[i + 1] > 1: return False # Detect cycles and ensure each node can be reached from exactly one root visited = [False] * n def has_cycle(v): if visited[v]: return True visited[v] = True if parents[v] != -1: if has_cycle(parents[v] - 1): return True visited[v] = False return False for i in range(n): if parents[i] == -1: continue if has_cycle(i): return False return True"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of water that can be trapped between the walls after raining. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([]) 0 >>> trap([3,3,3,3,3]) 0 >>> trap([0,0,0,0,0]) 0 >>> trap([4]) 0 >>> trap([0]) 0 >>> trap([4, 4]) 0 >>> trap([4, 0]) 0 >>> trap([0, 4]) 0","solution":"def trap(height): if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trap = 0 for i in range(n): water_trap += min(left_max[i], right_max[i]) - height[i] return water_trap"},{"question":"from typing import List, Tuple def usc_least_common_mentor(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: The Union of Social Coders (USC) decided to create a social network for programmers. Each programmer can be identified by a unique integer ID starting from 1. The programmers form a hierarchical structure based on direct mentorship where one programmer can mentor multiple others, but each programmer can have only one direct mentor. This structure forms a tree with the founder of USC being the root of the tree. The USC wants to implement a feature that for any two programmers in the network, outputs their least common mentor (LCM). The least common mentor of two programmers a and b is defined as the lowest (in terms of hierarchy level) programmer who is a mentor to both a and b, either direct or indirect. The USC would like you to write a program that processes multiple queries on the network to find the LCM for given pairs of programmers. Args: n (int): The number of programmers. edges (List[Tuple[int, int]]): The list of mentorship relations. Each edge (u, v) indicates v is directly mentored by u. queries (List[Tuple[int, int]]): The list of queries for which the LCM needs to be determined. Returns: List[int]: The list containing the LCM for each pair in the queries. Example: >>> usc_least_common_mentor(5, [(1, 2), (1, 3), (3, 4), (3, 5)], [(2, 4), (4, 5), (2, 3)]) [1, 3, 1] >>> usc_least_common_mentor(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)], [(4, 5), (5, 6), (4, 6), (4, 3)]) [2, 1, 1, 1] >>> usc_least_common_mentor(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [(4, 5), (6, 7), (4, 6), (5, 7)]) [2, 3, 1, 1] >>> usc_least_common_mentor(1, [], [(1, 1)]) [1]","solution":"from collections import defaultdict, deque def preprocess_lca(n, edges): # Initialize adjacency list, parents and depth adj_list = defaultdict(list) parent = [0] * (n + 1) depth = [0] * (n + 1) # Building adjacency list from edges for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # BFS to determine parent and depth def bfs(start): queue = deque([start]) visited = set() visited.add(start) while queue: node = queue.popleft() for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) parent[neighbor] = node depth[neighbor] = depth[node] + 1 queue.append(neighbor) # Start BFS from root (considering root is 1) bfs(1) return parent, depth def find_lca(u, v, parent, depth): # Lift u and v to the same depth while depth[u] > depth[v]: u = parent[u] while depth[v] > depth[u]: v = parent[v] # Lift u and v together until they meet at the same ancestor while u != v: u = parent[u] v = parent[v] return u def usc_least_common_mentor(n, edges, queries): parent, depth = preprocess_lca(n, edges) results = [] for a, b in queries: results.append(find_lca(a, b, parent, depth)) return results # Example usage n = 5 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [(2, 4), (4, 5), (2, 3)] print(usc_least_common_mentor(n, edges, queries)) # Output: [1, 3, 1]"},{"question":"def max_candies(n: int, candies: List[int]) -> int: Returns the maximum number of candies that can be collected from a contiguous subsequence of houses. :param n: The number of houses :param candies: A list of integers where each integer represents the number of candies at the i-th house :return: The maximum number of candies that can be collected >>> max_candies(5, [1, 3, 2, 5, 4]) # 15 candies can be collected from the entire sequence 15 >>> max_candies(1, [10]) # Only one house with 10 candies 10 >>> max_candies(3, [5, -2, 3]) # Best contiguous subsequence is [5, -2, 3] with 6 candies 6 >>> max_candies(4, [0, 0, 0, 0]) # No candies in any house 0 >>> max_candies(6, [-1, 2, 3, -2, 5, -3]) # Best contiguous subsequence is [2, 3, -2, 5] with 8 candies 8","solution":"def max_candies(n, candies): Returns the maximum number of candies that can be collected from a contiguous subsequence of houses. :param n: The number of houses :param candies: A list of integers where each integer represents the number of candies at the i-th house :return: The maximum number of candies that can be collected if n == 0: return 0 max_candies = 0 current_sum = 0 for candy in candies: current_sum += candy if current_sum > max_candies: max_candies = current_sum if current_sum < 0: current_sum = 0 return max_candies"},{"question":"def max_consecutive_ones(n: int, k: int, arr: List[int]) -> int: Given a binary array, perform a series of at most k operations to maximize the number of consecutive 1s in the array. Each operation allows you to flip (change a 0 to 1 or change a 1 to 0) exactly one element of the array. >>> max_consecutive_ones(10, 2, [1, 0, 0, 1, 1, 0, 1, 1, 0, 1]) 7 >>> max_consecutive_ones(5, 2, [0, 0, 0, 0, 0]) 2 >>> max_consecutive_ones(5, 2, [1, 1, 1, 1, 1]) 5 >>> max_consecutive_ones(6, 2, [1, 1, 1, 0, 1, 1]) 6 >>> max_consecutive_ones(5, 1, [1, 0, 1, 0, 1]) 3 >>> max_consecutive_ones(5, 0, [1, 0, 0, 1, 0]) 1 pass","solution":"def max_consecutive_ones(n, k, arr): max_ones = 0 left = 0 zeros_count = 0 for right in range(n): if arr[right] == 0: zeros_count += 1 while zeros_count > k: if arr[left] == 0: zeros_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"def has_subarray_with_sum_zero(n: int, arr: List[int]) -> str: Determines if there exists a subarray with sum zero among the given list of integers. :param n: Integer, the number of elements in the array. :param arr: List of integers, the array elements. :return: String, \\"YES\\" if there exists a subarray with sum zero, \\"NO\\" otherwise. >>> has_subarray_with_sum_zero(5, [1, 2, 3, 4, 5]) \\"NO\\" >>> has_subarray_with_sum_zero(1, [0]) \\"YES\\" >>> has_subarray_with_sum_zero(5, [4, 2, -3, 1, 6]) \\"YES\\" >>> has_subarray_with_sum_zero(5, [1, -1, 3, -2, -1]) \\"YES\\" >>> has_subarray_with_sum_zero(6, [1, 2, -3, 4, -1, -1]) \\"YES\\" >>> has_subarray_with_sum_zero(100000, [10**9] * 100000) \\"NO\\" >>> has_subarray_with_sum_zero(100000, [-10**9] * 100000) \\"NO\\" >>> has_subarray_with_sum_zero(100000, [10**9, -10**9] * 50000) \\"YES\\"","solution":"def has_subarray_with_sum_zero(n, arr): Determines if there exists a subarray with sum zero. :param n: Integer, the number of elements in the array. :param arr: List of integers, the array elements. :return: String, \\"YES\\" if there exists a subarray with sum zero, \\"NO\\" otherwise. # Dictionary to store the prefix sums and their frequency prefix_sums = set() current_sum = 0 for num in arr: current_sum += num # If current sum is zero, or if current sum was seen before, we found a subarray with sum zero if current_sum == 0 or current_sum in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) return \\"NO\\""},{"question":"def shortest_path_in_maze(m: int, n: int, maze: List[List[int]]) -> int: Returns the length of the shortest path from the top-left to the bottom-right corner of the maze. If no such path exists, returns -1. :param int m: Number of rows in the maze :param int n: Number of columns in the maze :param List[List[int]] maze: 2D list representing the maze :return int: Length of the shortest path or -1 if there is no path >>> shortest_path_in_maze(4, 4, [[0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0]]) 6 >>> shortest_path_in_maze(3, 3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]]) -1 >>> shortest_path_in_maze(2, 2, [[1, 0], [0, 0]]) -1 >>> shortest_path_in_maze(2, 2, [[0, 0], [0, 1]]) -1 >>> shortest_path_in_maze(1, 1, [[0]]) 0 >>> shortest_path_in_maze(2, 2, [[0, 0], [0, 0]]) 2","solution":"from collections import deque def shortest_path_in_maze(m, n, maze): Returns the length of the shortest path from the top-left to the bottom-right corner of the maze. If no such path exists, returns -1. :param int m: Number of rows in the maze :param int n: Number of columns in the maze :param List[List[int]] maze: 2D list representing the maze :return int: Length of the shortest path or -1 if there is no path if maze[0][0] == 1 or maze[m-1][n-1] == 1: return -1 directions = [(1, 0), (0, 1)] queue = deque([(0, 0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and maze[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"from typing import List, Tuple, Union def find_activity_order(n: int, m: int, prerequisites: List[Tuple[int, int]]) -> Union[List[int], int]: Determines the sequence of activities satisfying the given prerequisites. Args: n (int): The number of activities. m (int): The number of prerequisites. prerequisites (list of tuples): List of prerequisite pairs (ui, vi). Returns: list or int: A valid sequence of activities or -1 if no valid sequence exists. pass def test_basic_case(): n = 4 m = 4 prerequisites = [(1, 2), (1, 3), (3, 4), (2, 4)] result = find_activity_order(n, m, prerequisites) # Valid outputs can be [1, 3, 2, 4] or [1, 2, 3, 4] assert result == [1, 3, 2, 4] or result == [1, 2, 3, 4] def test_no_prerequisites(): n = 3 m = 0 prerequisites = [] result = find_activity_order(n, m, prerequisites) # Any permutation of [1, 2, 3] is valid assert sorted(result) == [1, 2, 3] def test_cycle_case(): n = 3 m = 3 prerequisites = [(1, 2), (2, 3), (3, 1)] result = find_activity_order(n, m, prerequisites) assert result == -1 def test_one_node(): n = 1 m = 0 prerequisites = [] result = find_activity_order(n, m, prerequisites) # Only one possible output [1] assert result == [1] def test_disconnected_graph(): n = 6 m = 3 prerequisites = [(1, 2), (3, 4), (5, 6)] result = find_activity_order(n, m, prerequisites) # Many valid outputs possible, as long as dependencies are satisfied assert result.index(2) > result.index(1) assert result.index(4) > result.index(3) assert result.index(6) > result.index(5) def test_multiple_valid_orders(): n = 4 m = 2 prerequisites = [(1, 2), (3, 4)] result = find_activity_order(n, m, prerequisites) # Many valid outputs possible assert result == [1, 2, 3, 4] or result == [3, 4, 1, 2] or result == [1, 3, 2, 4] or result == [3, 1, 4, 2]","solution":"from collections import defaultdict, deque def find_activity_order(n, m, prerequisites): Determines the sequence of activities satisfying the given prerequisites. Args: n (int): The number of activities. m (int): The number of prerequisites. prerequisites (list of tuples): List of prerequisite pairs (ui, vi). Returns: list or int: A valid sequence of activities or -1 if no valid sequence exists. # Build the graph and in-degree list graph = defaultdict(list) in_degree = {i: 0 for i in range(1, n+1)} for u, v in prerequisites: graph[u].append(v) in_degree[v] += 1 # Initialize the deque with nodes having zero in-degree zero_in_degree = deque([node for node in in_degree if in_degree[node] == 0]) order = [] while zero_in_degree: node = zero_in_degree.popleft() order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree.append(neighbor) # If the order includes all nodes, we return the order if len(order) == n: return order else: return -1"},{"question":"def min_cost_to_connect_locations(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: Find the minimum cost to connect all locations in a city using Kruskal's algorithm for the Minimum Spanning Tree (MST). :param n: Number of locations (nodes) :param m: Number of direct connections (edges) :param connections: List of connections, where each connection is represented as a tuple (u, v, w) u and v represent nodes and w represents cost of connection :return: Minimum cost to connect all locations, or -1 if not possible >>> n = 4 >>> m = 5 >>> connections = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 10), (2, 4, 1)] >>> min_cost_to_connect_locations(n, m, connections) 8 >>> n = 4 >>> m = 2 >>> connections = [(1, 2, 3), (3, 4, 4)] >>> min_cost_to_connect_locations(n, m, connections) -1 >>> n = 1 >>> m = 0 >>> connections = [] >>> min_cost_to_connect_locations(n, m, connections) 0 >>> n = 2 >>> m = 1 >>> connections = [(1, 2, 1)] >>> min_cost_to_connect_locations(n, m, connections) 1 >>> n = 5 >>> m = 7 >>> connections = [(1, 2, 2), (1, 3, 3), (2, 3, 5), (2, 4, 1), (3, 4, 4), (3, 5, 6), (4, 5, 2)] >>> min_cost_to_connect_locations(n, m, connections) 8 >>> n = 1000 >>> m = 1000 >>> connections = [(i, i + 1, 1) for i in range(1, 1000)] + [(999, 1000, 1000)] >>> min_cost_to_connect_locations(n, m, connections) 999 pass","solution":"def min_cost_to_connect_locations(n, m, connections): Find the minimum cost to connect all locations in a city using Kruskal's algorithm for the Minimum Spanning Tree (MST). :param n: Number of locations (nodes) :param m: Number of direct connections (edges) :param connections: List of connections, where each connection is represented as a tuple (u, v, w) u and v represent nodes and w represents cost of connection :return: Minimum cost to connect all locations, or -1 if not possible def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Sort connections by weight connections.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n+1): parent.append(node) rank.append(0) mst_cost = 0 edges_in_mst = 0 for connection in connections: u, v, w = connection root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_cost += w edges_in_mst += 1 if edges_in_mst == n-1: break if edges_in_mst != n-1: return -1 return mst_cost"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def maxDepth(root: TreeNode) -> int: Returns the maximum depth of the binary tree. >>> tree = build_tree([3, 9, 20, 'null', 'null', 15, 7]) >>> maxDepth(tree) 3 >>> tree = build_tree([]) >>> maxDepth(tree) 0 >>> tree = build_tree([1]) >>> maxDepth(tree) 1 >>> tree = build_tree([1, 2, 3, 4, 5, 6, 7]) >>> maxDepth(tree) 3 >>> tree = build_tree([1, 2, 'null', 3]) >>> maxDepth(tree) 3 >>> tree = build_tree([1, 'null', 2, 'null', 3]) >>> maxDepth(tree) 3 pass def build_tree(level_order: List[Union[int, str]]) -> TreeNode: Helper function to build tree from level-order representation. pass","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def maxDepth(root): Returns the maximum depth of the binary tree. if not root: return 0 left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1 # Helper function to build tree from level-order representation def build_tree(level_order): if not level_order or level_order[0] == 'null': return None root = TreeNode(level_order[0]) queue = [root] i = 1 while i < len(level_order): current = queue.pop(0) if level_order[i] != 'null': current.left = TreeNode(level_order[i]) queue.append(current.left) i += 1 if i < len(level_order) and level_order[i] != 'null': current.right = TreeNode(level_order[i]) queue.append(current.right) i += 1 return root"},{"question":"from typing import List def longest_consecutive_subarray(nums: List[int]) -> int: Given an integer array \`nums\`, find the length of the longest subarray with elements that, when sorted, form a consecutive sequence. >>> longest_consecutive_subarray([1, 3, 5, 2, 4]) 5 >>> longest_consecutive_subarray([10, 12, 11]) 3 >>> longest_consecutive_subarray([1, 2, 8]) 2 >>> longest_consecutive_subarray([]) 0 >>> longest_consecutive_subarray([5]) 1 >>> longest_consecutive_subarray([1, 4, 7, 10]) 1 >>> longest_consecutive_subarray([2, 2, 2, 2, 2, 2]) 1 >>> longest_consecutive_subarray(list(range(-100, 101))) 201 >>> longest_consecutive_subarray([-5, -3, -4, -2, -1, 0, 1]) 7","solution":"def longest_consecutive_subarray(nums): def is_consecutive(sub): sub_sorted = sorted(sub) for i in range(1, len(sub_sorted)): if sub_sorted[i] != sub_sorted[i - 1] + 1: return False return True max_length = 0 n = len(nums) for i in range(n): for j in range(i, n): if is_consecutive(nums[i:j+1]): max_length = max(max_length, j - i + 1) return max_length"},{"question":"from typing import List def has_zero_sum_subarray(n: int, arr: List[int]) -> str: Determine if there exists a consecutive subarray in the given array of integers such that the sum of its elements is zero. If such a subarray exists, return \\"Yes\\". Otherwise, return \\"No\\". >>> has_zero_sum_subarray(5, [2, -3, 1, 4, -4]) \\"Yes\\" >>> has_zero_sum_subarray(5, [3, 1, 2, 5, 6]) \\"No\\" >>> has_zero_sum_subarray(3, [-3, 2, 1, -1, 1]) \\"Yes\\" >>> has_zero_sum_subarray(1, [0]) \\"Yes\\" >>> has_zero_sum_subarray(1, [3]) \\"No\\" >>> has_zero_sum_subarray(3, [1, -1, 0]) \\"Yes\\"","solution":"def has_zero_sum_subarray(n, arr): Returns \\"Yes\\" if there exists a consecutive subarray with sum zero, otherwise returns \\"No\\". prefix_sum = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in prefix_sum: return \\"Yes\\" prefix_sum.add(current_sum) return \\"No\\""},{"question":"def longest_common_subsequence_length(m: int, strings: List[str]) -> int: Given an array of strings, find the length of the longest common subsequence (LCS) present in all the strings. The LCS is defined as the longest sequence that can be derived from all the strings by deleting some (or none) characters, without changing the order of the remaining characters. >>> longest_common_subsequence_length(3, [\\"abcde\\", \\"bacd\\", \\"bca\\"]) 1","solution":"def longest_common_subsequence_length(m, strings): def lcs(s1, s2): dp = [[0] * (len(s2)+1) for _ in range(len(s1)+1)] for i in range(1, len(s1)+1): for j in range(1, len(s2)+1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return ''.join([s1[i-1] for i in range(1, len(s1)+1) if dp[i][len(s2)] != dp[i-1][len(s2)]]) current_lcs = strings[0] for string in strings[1:]: current_lcs = lcs(current_lcs, string) if not current_lcs: return 0 return len(current_lcs)"},{"question":"def is_arithmetic_progression(sequence: list) -> str: Determines if the given sequence is an arithmetic progression. Args: sequence (list): A list of integers representing the sequence. Returns: str: \\"YES\\" if the sequence is an arithmetic progression, otherwise \\"NO\\". >>> is_arithmetic_progression([1, 3, 5, 7]) \\"YES\\" >>> is_arithmetic_progression([1, 2, 4]) \\"NO\\" >>> is_arithmetic_progression([5, 10]) \\"YES\\" >>> is_arithmetic_progression([10, 5, 0, -5, -10]) \\"YES\\" >>> is_arithmetic_progression(list(range(0, 1000, 3))) \\"YES\\" >>> is_arithmetic_progression([1, 3, 5, 8]) \\"NO\\" >>> is_arithmetic_progression([-10, -20, -30, -40]) \\"YES\\" >>> is_arithmetic_progression([1, 4]) \\"YES\\"","solution":"def is_arithmetic_progression(sequence): Determines if the given sequence is an arithmetic progression. Args: sequence (list): A list of integers representing the sequence. Returns: str: \\"YES\\" if the sequence is an arithmetic progression, otherwise \\"NO\\". n = len(sequence) if n == 2: return \\"YES\\" common_difference = sequence[1] - sequence[0] for i in range(2, n): if sequence[i] - sequence[i-1] != common_difference: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges overlapping intervals and returns the list of merged intervals sorted by their start time. Args: intervals (List[List[int]]): A list of intervals, each interval represented as a list [start, end]. Returns: List[List[int]]: A list of merged intervals. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5]]) [[1, 5]]","solution":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges overlapping intervals and returns the list of merged intervals sorted by their start time. Args: intervals (List[List[int]]): A list of intervals, each interval represented as a list [start, end]. Returns: List[List[int]]: A list of merged intervals. if not intervals: return [] # First, sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If the list of merged intervals is empty or if the current interval does not overlap with the last one, append it. if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # There is overlap, so we merge the current interval with the last interval in merged merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def max_loot(n: int, food_units: List[int]) -> int: Calculate the maximum units of food the bandits can loot without alerting the village. >>> max_loot(6, [5, 3, 4, 11, 2, 8]) 24 >>> max_loot(1, [5]) 5 >>> max_loot(2, [5, 10]) 10 >>> max_loot(2, [10, 5]) 10 >>> max_loot(3, [1, 2, 3]) 4 >>> max_loot(3, [3, 2, 1]) 4 >>> max_loot(0, []) 0 >>> max_loot(5, [1000, 2000, 3000, 4000, 5000]) 9000 >>> max_loot(4, [5, 5, 5, 5]) 10 >>> max_loot(4, [4, 1, 2, 10]) 14 >>> max_loot(5, [0, 0, 0, 0, 0]) 0","solution":"def max_loot(n, food_units): if n == 0: return 0 if n == 1: return food_units[0] dp = [0] * n dp[0] = food_units[0] dp[1] = max(food_units[0], food_units[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + food_units[i]) return dp[n-1]"},{"question":"def max_bulbs_on_after_flip(arr: List[int]) -> int: This function calculates the maximum number of bulbs that can be turned on after exactly one flip operation on any continuous subarray. >>> max_bulbs_on_after_flip([1, 0, 0, 1, 0]) 4 >>> max_bulbs_on_after_flip([1, 1, 1, 1, 1]) 4 >>> max_bulbs_on_after_flip([1, 1, 0, 0, 1]) 4","solution":"def max_bulbs_on_after_flip(arr): This function calculates the maximum number of bulbs that can be turned on after exactly one flip operation on any continuous subarray. n = len(arr) total_ones = sum(arr) max_diff = 0 current_diff = 0 for i in range(n): if arr[i] == 1: current_diff -= 1 else: current_diff += 1 if current_diff < 0: current_diff = 0 max_diff = max(max_diff, current_diff) if total_ones == n: return total_ones - 1 return total_ones + max_diff"},{"question":"def hasPath(maze: List[List[int]]) -> bool: Determine if there is a valid path from the entrance (top-left) to the exit (bottom-right) in the maze. >>> hasPath([[0, 1], [0, 0]]) True >>> hasPath([[0, 1], [1, 0]]) False","solution":"def hasPath(maze): from collections import deque n, m = len(maze), len(maze[0]) if n == 1 and m == 1: return maze[0][0] == 0 directions = [(1, 0), (0, 1)] # move either down or right queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == 0 and (nx, ny) not in visited: if nx == n - 1 and ny == m - 1: return True queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"def count_medal_distributions(n: int, m: int) -> int: Returns the number of ways Fiona can distribute medals satisfying the given conditions. Parameters: n (int): The number of participants. m (int): The number of activities. Returns: int: The number of valid distributions. def test_no_possible_distribution(): assert count_medal_distributions(5, 3) == 0 assert count_medal_distributions(10, 1) == 0 def test_one_possible_distribution(): assert count_medal_distributions(5, 4) == 1 assert count_medal_distributions(3, 4) == 1 def test_large_input(): assert count_medal_distributions(1000, 1000) == 1 assert count_medal_distributions(1000, 999) == 0 def test_edge_cases(): assert count_medal_distributions(1, 4) == 1 assert count_medal_distributions(1, 1) == 0 assert count_medal_distributions(2, 8) == 1 assert count_medal_distributions(2, 7) == 0","solution":"def count_medal_distributions(n, m): Returns the number of ways Fiona can distribute medals satisfying the given conditions. Parameters: n (int): The number of participants. m (int): The number of activities. Returns: int: The number of valid distributions. if m % 4 == 0: return 1 else: return 0"},{"question":"class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (2 * self.n) self.build(array) def build(self, array): # Build the segment tree for i in range(self.n): self.tree[self.n + i] = array[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update_range(self, l, r, value): # Update elements in the range [l,r] to value for i in range(l, r + 1): self.update_point(i, value) def update_point(self, pos, value): # Update the value at position pos to value pos += self.n - 1 self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[pos * 2], self.tree[pos * 2 + 1]) def query_range(self, l, r): # Query for the max value in the range [l, r] l += self.n - 1 r += self.n - 1 res = float('-inf') while l <= r: if l % 2 == 1: res = max(res, self.tree[l]) l += 1 if r % 2 == 0: res = max(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res def process_queries(n, q, array, queries): Process a series of queries on an array. There are two types of queries: 1. \\"1 l r x\\" - Set all elements in the range from index l to index r (inclusive) to the value x. 2. \\"2 l r\\" - Find the maximum value in the range from index l to index r (inclusive). >>> process_queries(5, 4, [1, 3, 2, 5, 4], [[2, 1, 3], [1, 2, 4, 10], [2, 1, 5], [2, 2, 5]]) [3, 10, 10] >>> process_queries(5, 3, [1, 1, 1, 1, 1], [[1, 1, 5, 2], [2, 1, 5], [2, 3, 4]]) [2, 2] seg_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: _, l, r, x = query seg_tree.update_range(l, r, x) elif query[0] == 2: _, l, r = query result = seg_tree.query_range(l, r) results.append(result) return results","solution":"class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (2 * self.n) self.build(array) def build(self, array): # Build the segment tree for i in range(self.n): self.tree[self.n + i] = array[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update_range(self, l, r, value): # Update elements in the range [l,r] to value for i in range(l, r + 1): self.update_point(i, value) def update_point(self, pos, value): # Update the value at position pos to value pos += self.n - 1 self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[pos * 2], self.tree[pos * 2 + 1]) def query_range(self, l, r): # Query for the max value in the range [l, r] l += self.n - 1 r += self.n - 1 res = float('-inf') while l <= r: if l % 2 == 1: res = max(res, self.tree[l]) l += 1 if r % 2 == 0: res = max(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res def process_queries(n, q, array, queries): seg_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: _, l, r, x = query seg_tree.update_range(l, r, x) elif query[0] == 2: _, l, r = query result = seg_tree.query_range(l, r) results.append(result) return results"},{"question":"def find_min_abs_difference(arr: List[int]) -> int: Find the pair of integers in the array such that the absolute difference between them is minimized. >>> find_min_abs_difference([3, 8, 15, 1]) 2 >>> find_min_abs_difference([-10, -5, -1, 3, 6, 8]) 2 >>> find_min_abs_difference([10**9, 1]) 999999999 >>> find_min_abs_difference([1, 2, 3, 4, 5]) 1 >>> find_min_abs_difference([1, 5, 3, 1, 2, 3]) 0","solution":"def find_min_abs_difference(arr): Returns the minimum absolute difference between any two elements in the array. # Sort the array first arr.sort() # Initialize the minimum difference to a large number min_diff = float('inf') # Loop through the sorted array and find the minimum difference for i in range(1, len(arr)): diff = abs(arr[i] - arr[i - 1]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def min_operations_to_sort(arr: List[int]) -> int: Returns the minimum number of operations needed to sort the array by reversing subarrays. >>> min_operations_to_sort([5, 3, 2, 4, 1]) 2 >>> min_operations_to_sort([1, 2, 3, 4, 5]) 0 >>> min_operations_to_sort([2, 1]) 1 >>> min_operations_to_sort([3, 2, 1]) 1 >>> min_operations_to_sort([1, 3, 2]) 1 >>> min_operations_to_sort([4, 3, 2, 1]) 1 >>> min_operations_to_sort([1, 5, 3, 4, 2]) 2","solution":"def min_operations_to_sort(arr): Returns the minimum number of operations needed to sort the array by reversing subarrays. n = len(arr) sorted_arr = sorted(arr) if arr == sorted_arr: return 0 def find_unsorted_subarray(arr): start, end = 0, n - 1 while start < n and arr[start] == sorted_arr[start]: start += 1 while end >= 0 and arr[end] == sorted_arr[end]: end -= 1 return start, end start, end = find_unsorted_subarray(arr) if start >= end: return 1 arr[start:end+1] = reversed(arr[start:end+1]) if arr == sorted_arr: return 1 return 2"},{"question":"def max_sum_subgrid(N: int, M: int, grid: List[List[int]]) -> int: This function calculates the maximum sum of a sub-grid (contiguous subarray in 2D) within the given grid. >>> max_sum_subgrid(4, 5, [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) == 29 >>> max_sum_subgrid(3, 3, [ ... [1, -2, -1], ... [-3, 4, 2], ... [3, -10, 1] ... ]) == 6 >>> max_sum_subgrid(1, 1, [[5]]) == 5 >>> max_sum_subgrid(3, 3, [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -1 >>> max_sum_subgrid(3, 3, [ ... [1, -2, 1], ... [2, 2, -1], ... [-2, 3, 4] ... ]) == 8","solution":"def max_sum_subgrid(N, M, grid): This function finds the maximum sum of any sub-grid within a given NxM grid. def max_subarray_sum(arr): max_sum = float('-inf') current_sum = 0 for value in arr: current_sum = max(value, current_sum + value) max_sum = max(max_sum, current_sum) return max_sum max_sum = float('-inf') # Temporary array to store sum of elements between two rows. temp = [0] * M for left in range(N): # initializing all elements of temp as 0 for i in range(M): temp[i] = 0 for right in range(left, N): # sum between left and right for every column for i in range(M): temp[i] += grid[right][i] # Use Kadane's algorithm to find the maximum sum subarray in temp max_sum = max(max_sum, max_subarray_sum(temp)) return max_sum"},{"question":"from typing import List def find_suspicious_transactions(transactions: List[str]) -> List[str]: Identify potentially fraudulent transactions on the basis that any two transactions within the same 10-minute window for a single cardholder in different cities are considered suspicious. Args: transactions (List[str]): A list of transaction strings, where each transaction is of the format \\"ID,Time,Amount,City\\". Returns: List[str]: A list of transaction IDs that are deemed suspicious. >>> transactions = [ ... \\"card1,10,50,NewYork\\", ... \\"card2,20,20,Boston\\", ... \\"card1,15,10,Chicago\\", ... \\"card1,25,30,NewYork\\", ... \\"card2,35,50,Boston\\", ... \\"card1,40,10,Chicago\\"] >>> find_suspicious_transactions(transactions) [\\"card1\\", \\"card1\\"] >>> transactions = [ ... \\"card1,10,50,NewYork\\", ... \\"card1,25,30,Chicago\\", ... \\"card2,20,20,Boston\\", ... \\"card2,35,50,NewYork\\"] >>> find_suspicious_transactions(transactions) [] >>> transactions = [ ... \\"card1,10,50,NewYork\\", ... \\"card1,15,50,Chicago\\", ... \\"card2,20,50,Boston\\", ... \\"card2,25,50,NewYork\\", ... \\"card3,5,40,SanFrancisco\\", ... \\"card3,10,40,LosAngeles\\"] >>> find_suspicious_transactions(transactions) [\\"card1\\", \\"card2\\", \\"card3\\"] >>> transactions = [\\"card1,10,25,NewYork\\"] >>> find_suspicious_transactions(transactions) [] >>> transactions = [ ... \\"card1,10,50,NewYork\\", ... \\"card1,15,60,NewYork\\", ... \\"card1,20,70,NewYork\\"] >>> find_suspicious_transactions(transactions) []","solution":"def find_suspicious_transactions(transactions): from collections import defaultdict card_transactions = defaultdict(list) for transaction in transactions: ID, Time, Amount, City = transaction.split(',') card_transactions[ID].append((int(Time), City)) suspicious_ids = [] for ID, transactions in card_transactions.items(): transactions.sort() for i in range(len(transactions)): for j in range(i + 1, len(transactions)): if transactions[j][0] - transactions[i][0] > 10: break if transactions[i][1] != transactions[j][1]: suspicious_ids.append(ID) break return suspicious_ids"},{"question":"def findFirstMissingPositive(nums: List[int]) -> int: Find the smallest positive integer that is missing from the array. The function should take an integer array \`nums\` and return the smallest positive integer that does not appear in the array. For example: >>> findFirstMissingPositive([1, 2, 0]) 3 >>> findFirstMissingPositive([3, 4, -1, 1]) 2 >>> findFirstMissingPositive([7, 8, 9, 11, 12]) 1 >>> findFirstMissingPositive([1, 1, 1, 1, 1]) 2 pass from solution import findFirstMissingPositive def test_example1(): assert findFirstMissingPositive([1, 2, 0]) == 3 def test_example2(): assert findFirstMissingPositive([3, 4, -1, 1]) == 2 def test_example3(): assert findFirstMissingPositive([7, 8, 9, 11, 12]) == 1 def test_example4(): assert findFirstMissingPositive([1, 1, 1, 1, 1]) == 2 def test_example5(): assert findFirstMissingPositive([2, 3, 4, 5, 6]) == 1 def test_example6(): assert findFirstMissingPositive([]) == 1 def test_example7(): assert findFirstMissingPositive([0, -1, -2]) == 1 def test_example8(): assert findFirstMissingPositive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 11 def test_example9(): assert findFirstMissingPositive([-1, -2, -3, 1, 2, 3, 4, 5]) == 6 def test_example10(): assert findFirstMissingPositive([1000000]) == 1 def test_example11(): assert findFirstMissingPositive([1]) == 2","solution":"def findFirstMissingPositive(nums): Returns the smallest positive integer that is missing from the array. n = len(nums) # Mark numbers out of range and negative numbers with a placeholder (n + 1) for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Use the index as a hash key using absolute values for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Find the first missing positive integer for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def min_operations_to_make_equal(arr: List[int]) -> int: Determines the minimum number of operations required to make all elements in the array equal by either increasing or decreasing an element by 1 in each operation. Parameters: arr (List[int]): A list of integers representing the array elements. Returns: int: The minimum number of operations required. Example: >>> min_operations_to_make_equal([1, 2, 3, 4]) 4 >>> min_operations_to_make_equal([5, 5, 5, 5]) 0 # Implementation here # Unit tests if __name__ == \\"__main__\\": assert min_operations_to_make_equal([1, 2, 3, 4]) == 4 assert min_operations_to_make_equal([5, 5, 5, 5]) == 0 assert min_operations_to_make_equal([1, 3]) == 2 assert min_operations_to_make_equal([-1, -2, -3, -4]) == 4 arr_large = [1] * 50000 + [2] * 50000 assert min_operations_to_make_equal(arr_large) == 50000","solution":"def min_operations_to_make_equal(arr): Determines the minimum number of operations required to make all elements in the array equal by either increasing or decreasing an element by 1 in each operation. n = len(arr) arr.sort() # Median minimizes the number of operations median = arr[n // 2] operations = sum(abs(x - median) for x in arr) return operations"},{"question":"def find_max_sum_timestamp(data: List[List[int]]) -> int: Returns the index of the sub-list (timestamp) with the highest sum of its measurements. Args: data (List[List[int]]): A multi-dimensional list containing integers representing sensor measurements. Returns: int: The index of the sub-list with the highest sum of measurements. Examples: >>> find_max_sum_timestamp([[1, 2, 3], [3, 4, 1, 6], [0, 0, 0], [9, 1]]) 1 >>> find_max_sum_timestamp([[3, 3], [1, 2, 2], [3, 3]]) 0","solution":"def find_max_sum_timestamp(data): Returns the index of the sub-list (timestamp) with the highest sum of its measurements. max_sum = None max_index = -1 for i, measurements in enumerate(data): current_sum = sum(measurements) if max_sum is None or current_sum > max_sum: max_sum = current_sum max_index = i return max_index"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return TreeNode(key) else: if root.val < key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def delete_node(root, key): if root is None: return root if key < root.val: root.left = delete_node(root.left, key) elif key > root.val: root.right = delete_node(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = find_min(root.right) root.val = temp.val root.right = delete_node(root.right, temp.val) return root def find_min(node): current = node while(current.left is not None): current = current.left return current def height(node): if node is None: return -1 else: left_height = height(node.left) right_height = height(node.right) return max(left_height, right_height) + 1 def verify_sequence_of_operations(operations): Verify whether a given sequence of operations results in a valid binary tree at each step and return the height of the tree after the final operation. If the tree structure becomes invalid at any point, return -1. >>> verify_sequence_of_operations([\\"INSERT 5\\", \\"INSERT 2\\", \\"INSERT 8\\", \\"DELETE 5\\"]) == 1 >>> verify_sequence_of_operations([\\"INSERT 1\\", \\"DELETE 1\\", \\"DELETE 1\\"]) == -1 :param operations: List of operations where each operation is either \\"INSERT x\\" or \\"DELETE x\\" :return: Height of the binary tree after all operations or -1 if invalid root = None for operation in operations: op, val = operation.split() val = int(val) if op == \\"INSERT\\": root = insert(root, val) elif op == \\"DELETE\\": if not contains(root, val): return -1 root = delete_node(root, val) return height(root) def contains(root, key): if root is None: return False if root.val == key: return True elif root.val < key: return contains(root.right, key) else: return contains(root.left, key) def process_input(t, test_cases): Process the input of multiple test cases and return the results as a list. >>> process_input(2, [[4, \\"INSERT 5\\", \\"INSERT 2\\", \\"INSERT 8\\", \\"DELETE 5\\"], [3, \\"INSERT 1\\", \\"DELETE 1\\", \\"DELETE 1\\"]]) == [1, -1] :param t: Integer, number of test cases :param test_cases: List of test cases where each test case is a list containing the number of operations followed by the operations :return: List of results for each test case results = [] for i in range(t): n = test_cases[i][0] operations = test_cases[i][1:] result = verify_sequence_of_operations(operations) results.append(result) return results","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return TreeNode(key) else: if root.val < key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def delete_node(root, key): if root is None: return root if key < root.val: root.left = delete_node(root.left, key) elif key > root.val: root.right = delete_node(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = find_min(root.right) root.val = temp.val root.right = delete_node(root.right, temp.val) return root def find_min(node): current = node while(current.left is not None): current = current.left return current def height(node): if node is None: return -1 else: left_height = height(node.left) right_height = height(node.right) return max(left_height, right_height) + 1 def verify_sequence_of_operations(operations): root = None for operation in operations: op, val = operation.split() val = int(val) if op == \\"INSERT\\": root = insert(root, val) elif op == \\"DELETE\\": if not contains(root, val): return -1 root = delete_node(root, val) return height(root) def contains(root, key): if root is None: return False if root.val == key: return True elif root.val < key: return contains(root.right, key) else: return contains(root.left, key) def process_input(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] operations = test_cases[i][1:] result = verify_sequence_of_operations(operations) results.append(result) return results"},{"question":"from collections import defaultdict import heapq def shortest_latency(n, m, q, edges, queries): Finds the shortest possible latency to transfer data for each query within the specified number of hops. Parameters: n (int): number of servers m (int): number of directed communication channels q (int): number of queries edges (list of tuples): list of edges where each edge is a tuple (a_i, b_i, l_i) queries (list of tuples): list of queries where each query is a tuple (u_i, v_i, h_i) Returns: list: list of integers where each integer is the result of the corresponding query pass def test_shortest_latency_example_case(): n = 4 m = 4 q = 3 edges = [(1, 2, 5), (2, 3, 3), (3, 4, 4), (4, 2, 1)] queries = [(1, 3, 1), (1, 4, 2), (2, 4, 0)] expected = [8, 12, -1] result = shortest_latency(n, m, q, edges, queries) assert result == expected def test_shortest_latency_single_edge(): n = 2 m = 1 q = 1 edges = [(1, 2, 10)] queries = [(1, 2, 0)] expected = [10] result = shortest_latency(n, m, q, edges, queries) assert result == expected def test_shortest_latency_no_path(): n = 3 m = 1 q = 1 edges = [(1, 2, 5)] queries = [(1, 3, 1)] expected = [-1] result = shortest_latency(n, m, q, edges, queries) assert result == expected def test_shortest_latency_direct_and_longer_paths(): n = 4 m = 4 q = 2 edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 10)] queries = [(1, 4, 2), (1, 4, 0)] expected = [3, 10] result = shortest_latency(n, m, q, edges, queries) assert result == expected def test_shortest_latency_zero_hops(): n = 3 m = 2 q = 1 edges = [(1, 2, 5), (2, 3, 5)] queries = [(1, 3, 0)] expected = [-1] result = shortest_latency(n, m, q, edges, queries) assert result == expected","solution":"from collections import defaultdict, deque import heapq def shortest_latency(n, m, q, edges, queries): Finds the shortest possible latency to transfer data for each query within the specified number of hops. Parameters: n (int): number of servers m (int): number of directed communication channels q (int): number of queries edges (list): list of edges where each edge is a tuple (a_i, b_i, l_i) queries (list): list of queries where each query is a tuple (u_i, v_i, h_i) Returns: list: list of integers where each integer is the result of the corresponding query graph = defaultdict(list) for a, b, l in edges: graph[a].append((b, l)) result = [] for u, v, h in queries: heap = [(0, u, h + 1)] # latency, current node, hops remaining distances = {(u, h + 1): 0} while heap: current_latency, current_node, hops_remaining = heapq.heappop(heap) if current_node == v: result.append(current_latency) break if hops_remaining > 0: for neighbor, weight in graph[current_node]: new_latency = current_latency + weight new_hops_remaining = hops_remaining - 1 if (neighbor, new_hops_remaining) not in distances or new_latency < distances[(neighbor, new_hops_remaining)]: distances[(neighbor, new_hops_remaining)] = new_latency heapq.heappush(heap, (new_latency, neighbor, new_hops_remaining)) else: result.append(-1) return result"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, edges: List[Tuple[int, int, int]]) -> int: Find the shortest path from node 1 to node n using Dijkstra's algorithm. Parameters: n (int): Number of nodes in the graph. edges (list of tuples): Each tuple contains (u, v, w) representing an edge between node u and node v with weight w. Returns: int: Length of the shortest path from node 1 to node n. If there is no path, return -1. >>> dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)]) 8 >>> dijkstra(4, [(1, 2, 3), (3, 4, 5)]) -1 >>> dijkstra(1, []) 0 >>> dijkstra(3, [(1, 2, 1)]) -1 >>> dijkstra(2, [(1, 2, 5)]) 5 >>> dijkstra(4, [(1, 2, 3), (1, 3, 5), (2, 3, 1), (2, 4, 10), (3, 4, 3)]) 7","solution":"import heapq def dijkstra(n, edges): Find the shortest path from node 1 to node n using Dijkstra's algorithm. Parameters: n (int): Number of nodes in the graph. edges (list of tuples): Each tuple contains (u, v, w) representing an edge between node u and node v with weight w. Returns: int: Length of the shortest path from node 1 to node n. If there is no path, return -1. graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) pq = [(0, 1)] # (distance, node) distances = {i: float('inf') for i in range(1, n + 1)} distances[1] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[n] if distances[n] != float('inf') else -1"},{"question":"def replace_question_marks(s: str) -> str: Convert all '?' characters in the string to either 'a' or 'b' such that no two adjacent characters are the same. >>> replace_question_marks(\\"ab\\") 'ab' >>> replace_question_marks(\\"a?b\\") 'aab' or 'abb' >>> replace_question_marks(\\"a??b\\") 'abab' >>> replace_question_marks(\\"?a?\\") 'bab' or 'bba' >>> replace_question_marks(\\"a?abb\\") -1","solution":"def replace_question_marks(s: str) -> str: # Convert the input string into a list for easy manipulation s = list(s) n = len(s) for i in range(n): if s[i] == '?': for char in 'ab': # Check possible replacements 'a' and 'b' # Check left and right neighbors to avoid conflicts and replace ? if (i > 0 and s[i - 1] == char) or (i < n - 1 and s[i + 1] == char): continue s[i] = char break # Check final string for validity for i in range(1, n): if s[i] == s[i - 1]: return -1 return ''.join(s)"},{"question":"from typing import List, Tuple def solve_sudoku(sudoku: List[List[int]], constraints: List[Tuple[Tuple[int, int], int]]) -> List[List[int]]: Solves a modified Sudoku puzzle with additional constraints. Args: sudoku (List[List[int]]): A 2D list representing the partially filled 9x9 Sudoku grid with unfilled cells as 0. constraints (List[Tuple[Tuple[int, int], int]]): A list of constraints in the form ((i, j), v). Returns: List[List[int]]: The completed 9x9 Sudoku grid. def test_solve_sudoku_no_constraints(): sudoku = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] constraints = [] solved = solve_sudoku(sudoku, constraints) assert solved is not None assert all(all(1 <= solved[i][j] <= 9 for j in range(9)) for i in range(9)) def test_solve_sudoku_with_one_constraint(): sudoku = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] constraints = [ ((0, 2), 6) # The cell (0, 2) should be such that when added to another specific cell, it sums up to 6 ] solved = solve_sudoku(sudoku, constraints) assert solved is not None assert all(all(1 <= solved[i][j] <= 9 for j in range(9)) for i in range(9)) def test_solve_sudoku_with_multiple_constraints(): sudoku = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] constraints = [ ((0, 2), 6), # The cell (0, 2) should be such that when added to another specific cell, it sums up to 6 ((4, 4), 14) # The cell (4, 4) should be such that when added to another specific cell, it sums up to 14 ] solved = solve_sudoku(sudoku, constraints) assert solved is not None assert all(all(1 <= solved[i][j] <= 9 for j in range(9)) for i in range(9))","solution":"def is_valid(board, row, col, num): Checks whether a given number can be placed at board[row][col] according to the Sudoku rules. # Check row for i in range(9): if board[row][i] == num: return False # Check column for i in range(9): if board[i][col] == num: return False # Check 3x3 grid start_row, start_col = (row // 3) * 3, (col // 3) * 3 for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if board[i][j] == num: return False return True def solve_sudoku_helper(board): Backtracking helper function to solve the Sudoku board. for i in range(9): for j in range(9): if board[i][j] == 0: # Find an empty cell for num in range(1, 10): if is_valid(board, i, j, num): board[i][j] = num if solve_sudoku_helper(board): return True board[i][j] = 0 # Reset cell on backtrack return False return True def validate_constraints(board, constraints): Validates that the board meets the additional constraints. # Assuming constraints are of the form ((i, j), value) # No information provided about what specific cell the sum is with. for (i, j), value in constraints: found = False for x in range(9): for y in range(9): if (x != i or y != j) and board[i][j] + board[x][y] == value: found = True break if found: break if not found: return False return True def solve_sudoku(sudoku, constraints): Solves the modified Sudoku puzzle with additional constraints and returns the completed Sudoku grid. if not solve_sudoku_helper(sudoku): return None if not validate_constraints(sudoku, constraints): return None return sudoku"},{"question":"def longest_common_contiguous_subarray_length(a, b): Returns the length of the longest common contiguous subarray present in both arrays \`a\` and \`b\`. >>> longest_common_contiguous_subarray_length([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) 3 >>> longest_common_contiguous_subarray_length([1, 2, 3], [4, 5, 6]) 0 >>> longest_common_contiguous_subarray_length([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) 5 >>> longest_common_contiguous_subarray_length([1, 3, 5, 7, 9], [2, 3, 4, 6, 8]) 1 >>> longest_common_contiguous_subarray_length([1, 2, 3, 5, 6, 7, 9], [2, 3, 4, 5, 6, 10, 9]) 2","solution":"def longest_common_contiguous_subarray_length(a, b): Returns the length of longest common contiguous subarray present in both arrays a and b. n = len(a) dp = [[0] * (n + 1) for _ in range(n + 1)] max_len = 0 for i in range(1, n + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_len = max(max_len, dp[i][j]) return max_len"},{"question":"def min_total_discounted_price(n: int, prices: List[int], discounts: List[List[int]]) -> int: Calculate the minimum total discounted price for all products. Args: n : int - Number of products prices : list of int - Prices of the products discounts: list of lists - List of discounts for each product Returns: int - Minimum possible total discounted price pass # Test Cases import unittest class TestMinTotalDiscountedPrice(unittest.TestCase): def test_example(self): n = 3 prices = [100, 200, 300] discounts = [[10, 20], [15, 25, 5], [5]] self.assertEqual(min_total_discounted_price(n, prices, discounts), 515) def test_no_discounts(self): n = 2 prices = [100, 200] discounts = [[0], [0]] self.assertEqual(min_total_discounted_price(n, prices, discounts), 300) def test_single_discount(self): n = 1 prices = [500] discounts = [[50]] self.assertEqual(min_total_discounted_price(n, prices, discounts), 250) def test_multiple_discounts_same_price(self): n = 2 prices = [400, 400] discounts = [[30, 20], [10, 40]] self.assertEqual(min_total_discounted_price(n, prices, discounts), 520) def test_all_max_discounts(self): n = 2 prices = [200, 300] discounts = [[100], [100]] self.assertEqual(min_total_discounted_price(n, prices, discounts), 0) if __name__ == \\"__main__\\": unittest.main()","solution":"def min_total_discounted_price(n, prices, discounts): Calculate the minimum total discounted price for all products. Args: n : int - Number of products prices : list of int - Prices of the products discounts: list of lists - List of discounts for each product Returns: int - Minimum possible total discounted price total_price = 0 for i in range(n): price = prices[i] available_discounts = discounts[i] max_discount = max(available_discounts) discounted_price = price * (1 - max_discount / 100) total_price += discounted_price return int(total_price)"},{"question":"def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest strictly increasing subsequence. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_LIS([0, 1, 0, 3, 2, 3]) == 4 >>> length_of_LIS([7, 7, 7, 7, 7, 7]) == 1 >>> length_of_LIS([10, 20, 30, 40, 50]) == 5 >>> length_of_LIS([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1 >>> length_of_LIS([]) == 0 >>> length_of_LIS([10]) == 1 >>> length_of_LIS([10, 1]) == 1 >>> length_of_LIS([1, 10]) == 2 pass","solution":"def length_of_LIS(nums): Returns the length of the longest strictly increasing subsequence. if not nums: return 0 # This will hold our increasing subsequence sub = [] for num in nums: # Binary search for the correct position of \`num\` in \`sub\` left, right = 0, len(sub) while left < right: mid = (left + right) // 2 if sub[mid] < num: left = mid + 1 else: right = mid # If \`left\` is equal to the length of \`sub\`, it means \`num\` is greater # than any element in \`sub\` and can be appended at the end. if left == len(sub): sub.append(num) # Otherwise, replace the first element in \`sub\` which is greater than or equal to \`num\` else: sub[left] = num return len(sub)"},{"question":"def kth_smallest_element(n: int, k: int, arr: List[int]) -> int: Returns the k-th smallest element in the array after sorting. >>> kth_smallest_element(5, 3, [3, 1, 2, 5, 4]) 3 >>> kth_smallest_element(5, 1, [5, 4, 3, 2, 1]) 1 >>> kth_smallest_element(6, 6, [10, 9, 8, 7, 6, 5]) 10 >>> kth_smallest_element(3, 2, [100, 50, 75]) 75 >>> kth_smallest_element(4, 4, [1, 2, 3, 4]) 4 >>> kth_smallest_element(1, 1, [42]) 42 >>> kth_smallest_element(10, 5, [1, 2, 34, 25, 36, 2, -1, 36, 0, 10]) 2 >>> kth_smallest_element(7, 3, [10, 10, 10, 10, 10, 10, 10]) 10","solution":"def kth_smallest_element(n, k, arr): Returns the k-th smallest element in the array after sorting. arr.sort() return arr[k-1]"},{"question":"def max_sum_path(matrix): Determine the maximum sum path in a matrix from top-left to bottom-right, moving only right or down. >>> max_sum_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_sum_path([[5]]) 5 >>> max_sum_path([ ... [1, 2, 3, 4] ... ]) 10 >>> max_sum_path([ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_sum_path([ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6], ... [4, 5, 6, 7] ... ]) 28 >>> max_sum_path([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1","solution":"def max_sum_path(matrix): n = len(matrix) m = len(matrix[0]) # Create a DP table to store the maximum sum upto each cell. dp = [[0] * m for _ in range(n)] # Initialize the top-left cell dp[0][0] = matrix[0][0] # Fill in the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill in the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] # The bottom-right cell has the result return dp[n-1][m-1]"},{"question":"from typing import List, Tuple def students_with_highest_average(students: List[Tuple[str, str, int, int, int]]) -> List[Tuple[str, str]]: Returns a list of student IDs and names with the highest average grade. Parameters: students (list of tuples): A list of tuples where each tuple contains a student's ID, name, and three grades. Returns: list of tuples: A list of tuples containing the ID and name of the student(s) with the highest average grade. pass def parse_input(n: int, lines: List[str]) -> List[Tuple[str, str, int, int, int]]: Parses the input lines into a structured format. Parameters: n (int): Number of students. lines (list of str): List of student record lines. Returns: list of tuples: A list of tuples where each tuple contains a student's ID, name, and three grades. pass # Unit tests def test_parse_input(): input_lines = [ \\"A001 John 78 82 91\\", \\"A002 Alice 91 85 87\\", \\"A003 Bob 86 86 86\\", \\"A004 Clara 81 79 91\\", \\"A005 David 85 95 80\\" ] expected_output = [ (\\"A001\\", \\"John\\", 78, 82, 91), (\\"A002\\", \\"Alice\\", 91, 85, 87), (\\"A003\\", \\"Bob\\", 86, 86, 86), (\\"A004\\", \\"Clara\\", 81, 79, 91), (\\"A005\\", \\"David\\", 85, 95, 80) ] assert parse_input(5, input_lines) == expected_output def test_students_with_highest_average_single(): students = [ (\\"A001\\", \\"John\\", 78, 82, 91), (\\"A002\\", \\"Alice\\", 91, 85, 87), (\\"A003\\", \\"Bob\\", 86, 86, 86), (\\"A004\\", \\"Clara\\", 81, 79, 91), (\\"A005\\", \\"David\\", 85, 95, 80) ] result = students_with_highest_average(students) expected = [(\\"A002\\", \\"Alice\\")] assert result == expected def test_students_with_highest_average_multiple(): students = [ (\\"A001\\", \\"John\\", 90, 90, 90), (\\"A002\\", \\"Alice\\", 90, 90, 90), (\\"A003\\", \\"Bob\\", 85, 85, 85) ] result = students_with_highest_average(students) expected = [(\\"A001\\", \\"John\\"), (\\"A002\\", \\"Alice\\")] assert result == expected def test_students_with_highest_average_all_equal(): students = [ (\\"A001\\", \\"John\\", 80, 80, 80), (\\"A002\\", \\"Alice\\", 80, 80, 80), (\\"A003\\", \\"Bob\\", 80, 80, 80) ] result = students_with_highest_average(students) expected = [(\\"A001\\", \\"John\\"), (\\"A002\\", \\"Alice\\"), (\\"A003\\", \\"Bob\\")] assert result == expected","solution":"def students_with_highest_average(students): Returns a list of student IDs and names with the highest average grade. Parameters: students (list of tuples): A list of tuples where each tuple contains a student's ID, name, and three grades. Returns: list of tuples: A list of tuples containing the ID and name of the student(s) with the highest average grade. highest_average_students = [] highest_average = -1 for student in students: student_id, student_name, grade1, grade2, grade3 = student average = (grade1 + grade2 + grade3) / 3.0 if average > highest_average: highest_average = average highest_average_students = [(student_id, student_name)] elif average == highest_average: highest_average_students.append((student_id, student_name)) return highest_average_students def parse_input(n, lines): Parses the input lines into a structured format. Parameters: n (int): Number of students. lines (list of str): List of student record lines. Returns: list of tuples: A list of tuples where each tuple contains a student's ID, name, and three grades. students = [] for line in lines: parts = line.split() student_id = parts[0] student_name = parts[1] grades = list(map(int, parts[2:])) students.append((student_id, student_name, *grades)) return students"},{"question":"def max_teams(n: int) -> int: Returns the maximum number of teams that can be formed with n people, where each team consists of exactly 2 or 3 people. >>> max_teams(7) == 3 >>> max_teams(5) == 2 >>> max_teams(1) == 0 >>> max_teams(2) == 1 >>> max_teams(3) == 1 >>> max_teams(1000000) == 500000 >>> max_teams(6) == 3 >>> max_teams(1000001) == 500000","solution":"def max_teams(n): Returns the maximum number of teams that can be formed with n people, where each team consists of exactly 2 or 3 people. if n < 2: return 0 # It is not possible to form any team. return n // 2 # Since the minimum teams 2 people and maximum of 3, we maximize by pairing in pairs"},{"question":"def schedule_notifications(start_time: str, r: int, d: int) -> list: Returns a list of times in \\"HH:MM\\" format when notifications will be sent. Args: start_time (str): Start time in \\"HH:MM\\" format. r (int): Interval in minutes between consecutive notifications. d (int): Total duration in minutes for which notifications will be sent. Returns: list: Times at which notifications will be sent in \\"HH:MM\\" format. Example: >>> schedule_notifications(\\"09:00\\", 30, 120) [\\"09:00\\", \\"09:30\\", \\"10:00\\", \\"10:30\\"] from solution import schedule_notifications def test_schedule_notifications_example(): assert schedule_notifications(\\"09:00\\", 30, 120) == [\\"09:00\\", \\"09:30\\", \\"10:00\\", \\"10:30\\"] def test_schedule_notifications_whole_day_interval(): assert schedule_notifications(\\"00:00\\", 1440, 1440) == [\\"00:00\\"] def test_schedule_notifications_hourly(): assert schedule_notifications(\\"13:20\\", 60, 240) == [\\"13:20\\", \\"14:20\\", \\"15:20\\", \\"16:20\\"] def test_schedule_notifications_half_hourly(): assert schedule_notifications(\\"18:45\\", 30, 90) == [\\"18:45\\", \\"19:15\\", \\"19:45\\"] def test_schedule_notifications_across_midnight(): assert schedule_notifications(\\"23:50\\", 15, 40) == [\\"23:50\\", \\"00:05\\", \\"00:20\\"] def test_schedule_notifications_same_time(): assert schedule_notifications(\\"12:00\\", 10, 10) == [\\"12:00\\"]","solution":"def schedule_notifications(start_time, r, d): Returns a list of times in \\"HH:MM\\" format when notifications will be sent. from datetime import datetime, timedelta # Convert start_time to datetime object start_dt = datetime.strptime(start_time, \\"%H:%M\\") times = [] interval = timedelta(minutes=r) duration = timedelta(minutes=d) # Add times to the list at intervals until duration time is reached current_time = start_dt while (current_time - start_dt) < duration: times.append(current_time.strftime(\\"%H:%M\\")) current_time += interval return times"},{"question":"def is_valid_lock_code(n, s): Determines if the string 's' can be transformed into a valid lock code. A valid lock code is a sequence of exactly 6 alphanumeric characters, where the first character must be an uppercase letter. >> is_valid_lock_code(6, \\"A1bc2D\\") == \\"YES\\" >> is_valid_lock_code(6, \\"a1bc2D\\") == \\"NO\\" >> is_valid_lock_code(8, \\"A1bc2DEF\\") == \\"NO\\" def lock_code_evaluator(t, test_cases): Evaluates multiple test cases to determine if they can be transformed into valid lock codes. >> lock_code_evaluator( 3, [ (6, \\"A1bc2D\\"), (6, \\"a1bc2D\\"), (8, \\"A1bc2DEF\\") ] ) == [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def is_valid_lock_code(n, s): Determines if the string 's' can be transformed into a valid lock code. A valid lock code is a sequence of exactly 6 alphanumeric characters, where the first character must be an uppercase letter. if n != 6: return \\"NO\\" if not s[0].isupper(): return \\"NO\\" if any(not c.isalnum() for c in s): return \\"NO\\" return \\"YES\\" def lock_code_evaluator(t, test_cases): results = [] for i in range(t): n, s = test_cases[i] results.append(is_valid_lock_code(n, s)) return results"},{"question":"from typing import List def min_steps_to_exit(grid: List[str], n: int, m: int) -> str: Returns the minimum steps required for the robot to reach the bottom-right corner from the top-left corner of the grid. If it is impossible, returns \\"Impossible\\". >>> min_steps_to_exit([ ... \\"....\\", ... \\".XX.\\", ... \\"..X.\\", ... \\"....\\" ... ], 4, 4) 6 >>> min_steps_to_exit([ ... \\"...\\", ... \\".X.\\", ... \\"..X\\" ... ], 3, 3) \\"Impossible\\" def test_min_steps_possible(): grid = [ \\"....\\", \\".XX.\\", \\"..X.\\", \\"....\\" ] assert min_steps_to_exit(grid, 4, 4) == 6 def test_min_steps_impossible(): grid = [ \\"...\\", \\".X.\\", \\"..X\\" ] assert min_steps_to_exit(grid, 3, 3) == \\"Impossible\\" def test_min_steps_no_obstacle(): grid = [ \\"......\\", \\"......\\", \\"......\\", \\"......\\", \\"......\\", \\"......\\" ] assert min_steps_to_exit(grid, 6, 6) == 10 def test_min_steps_all_blocked(): grid = [ \\"..X\\", \\"XXX\\", \\"X..\\" ] assert min_steps_to_exit(grid, 3, 3) == \\"Impossible\\" def test_min_steps_small_grid(): grid = [\\".\\"] assert min_steps_to_exit(grid, 1, 1) == 0 def test_min_steps_with_start_blocked(): grid = [\\"X..\\", \\"...\\", \\"...\\"] assert min_steps_to_exit(grid, 3, 3) == \\"Impossible\\" def test_min_steps_with_end_blocked(): grid = [\\"...\\", \\"...\\", \\"..X\\"] assert min_steps_to_exit(grid, 3, 3) == \\"Impossible\\"","solution":"from collections import deque def min_steps_to_exit(grid, n, m): Returns the minimum steps required for the robot to reach the bottom-right corner from the top-left corner of the grid. If it is impossible, returns \\"Impossible\\". if grid[0][0] == 'X' or grid[n-1][m-1] == 'X': return \\"Impossible\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() if row == n-1 and col == m-1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited and grid[new_row][new_col] == '.': visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return \\"Impossible\\""},{"question":"def countWaterPaths(n: int, m: int, grid: List[List[str]]) -> int: Determine the number of distinct paths the water can take from the top-left corner to the bottom-right corner of a grid, avoiding obstacles. The water can flow only to the right or down. >>> countWaterPaths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> countWaterPaths(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 6 >>> countWaterPaths(3, 3, [['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 0 >>> countWaterPaths(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '#']]) 0 >>> countWaterPaths(1, 1, [['.']]) 1 >>> countWaterPaths(1, 1, [['#']]) 0 >>> countWaterPaths(2, 2, [['.', '#'], ['.', '.']]) 1","solution":"def countWaterPaths(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0]*m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def check_permission(role: str, action: str, section: str) -> str: Determine whether a user has permission to perform a certain action based on their role. Parameters: - role (str): The role of the user (\\"admin\\", \\"editor\\", or \\"viewer\\"). - action (str): The action requested (\\"access\\", \\"modify\\", or \\"delete\\"). - section (str): The section of the application the action is being requested on. Returns: - str: \\"Allowed\\" if the user role permits the given action on the given section, \\"Denied\\" otherwise. >>> check_permission(\\"admin\\", \\"access\\", \\"settings\\") \\"Allowed\\" >>> check_permission(\\"editor\\", \\"delete\\", \\"settings\\") \\"Denied\\" >>> check_permission(\\"viewer\\", \\"access\\", \\"dashboard\\") \\"Allowed\\" >>> check_permission(\\"viewer\\", \\"modify\\", \\"dashboard\\") \\"Denied\\" >>> check_permission(\\"guest\\", \\"access\\", \\"dashboard\\") \\"Denied\\"","solution":"def check_permission(role, action, section): Determine whether a user has permission to perform a certain action based on their role. Parameters: - role (str): The role of the user (\\"admin\\", \\"editor\\", or \\"viewer\\"). - action (str): The action requested (\\"access\\", \\"modify\\", or \\"delete\\"). - section (str): The section of the application the action is being requested on. Returns: - str: \\"Allowed\\" if the user role permits the given action on the given section, \\"Denied\\" otherwise. # Define the permissions for each role permissions = { \\"admin\\": [\\"access\\", \\"modify\\", \\"delete\\"], \\"editor\\": [\\"access\\", \\"modify\\"], \\"viewer\\": [\\"access\\"] } # Check if the action is in the permissions list for the given role if action in permissions.get(role, []): return \\"Allowed\\" else: return \\"Denied\\""},{"question":"def minimal_buses(N: int, stops: List[Tuple[int, int]]) -> int: Calculate the minimum number of buses required to cover all stops. Parameters: N (int): Number of students' origin-destination pairs. stops (List[Tuple[int, int]]): List of tuples containing the start and end points of each student's route. Returns: int: Minimum number of buses required. >>> minimal_buses(3, [(1, 5), (2, 6), (3, 4)]) 1 >>> minimal_buses(4, [(1, 4), (2, 8), (5, 6), (7, 9)]) 2 >>> minimal_buses(1, [(1, 2)]) 1 >>> minimal_buses(2, [(1, 2), (3, 4)]) 1 >>> minimal_buses(2, [(1, 3), (2, 4)]) 2","solution":"def minimal_buses(N, stops): Calculate the minimum number of buses required to cover all stops. Parameters: N (int): Number of students' origin-destination pairs. stops (List[Tuple[int, int]]): List of tuples containing the start and end points of each student's route. Returns: int: Minimum number of buses required. if N == 0: return 0 # Sort stops based on start stop. stops.sort(key=lambda x: x[0]) buses = [] for start, end in stops: assigned = False # Check if the current route can be added to any existing bus without overlapping for bus in buses: # Check if this bus can still take this route. if bus[-1][1] < start: bus.append((start, end)) assigned = True break if not assigned: # If no bus can take this route, create a new bus. buses.append([(start, end)]) return len(buses)"},{"question":"def update_candy_availability(n: int, k: int, requests: List[int]) -> List[int]: Maintains an updated list of which candy types are available after processing all the requests. Args: n (int): The number of candy types. k (int): The number of requests. requests (List[int]): The sequence of candy type requests. Returns: List[int]: A list where each element is 1 if the candy type is available, 0 otherwise. >>> update_candy_availability(5, 8, [1, 3, 5, 2, 1, 4, 3, 4]) [0, 0, 0, 0, 0] >>> update_candy_availability(3, 3, [1, 2, 3]) [0, 0, 0] >>> update_candy_availability(4, 2, [1, 3]) [0, 1, 0, 1] >>> update_candy_availability(3, 6, [1, 1, 2, 2, 3, 3]) [0, 0, 0] >>> update_candy_availability(3, 0, []) [1, 1, 1] >>> update_candy_availability(1, 5, [1, 1, 1, 1, 1]) [0]","solution":"def update_candy_availability(n, k, requests): availability = [1] * n # All candies are initially available for req in requests: if availability[req - 1] == 1: # Check if the candy is available availability[req - 1] = 0 # Mark the candy as unavailable return availability"},{"question":"def max_of_three(input_string: str) -> int: Returns the maximum of three space-separated integers from an input string. >>> max_of_three(\\"5 8 3\\") 8 >>> max_of_three(\\"10 2 6\\") 10","solution":"def max_of_three(input_string): Returns the maximum of three space-separated integers from an input string. numbers = list(map(int, input_string.split())) return max(numbers)"},{"question":"def sort_items(items): Sorts the items primarily by value in ascending order and by priority in descending order if two items have the same value. Args: - items: List of tuples with each tuple containing two integers (value, priority) Returns: - Sorted list of tuples Example: >>> sort_items([(5, 10), (3, 5), (3, 7), (4, 2)]) [(3, 7), (3, 5), (4, 2), (5, 10)] >>> sort_items([(2, 10), (2, 5), (2, 15)]) [(2, 15), (2, 10), (2, 5)] >>> sort_items([(5, 1), (4, 2), (3, 3)]) [(3, 3), (4, 2), (5, 1)] >>> sort_items([(0, 0), (1, -1), (-1, 1), (0, 1)]) [(-1, 1), (0, 1), (0, 0), (1, -1)] >>> sort_items([(1, 1)]) [(1, 1)] >>> sort_items([(1000000000, -1000000000), (-1000000000, 1000000000)]) [(-1000000000, 1000000000), (1000000000, -1000000000)]","solution":"def sort_items(items): Sorts the items primarily by value in ascending order and by priority in descending order if two items have the same value. Args: - items: List of tuples with each tuple containing two integers (value, priority) Returns: - Sorted list of tuples return sorted(items, key=lambda x: (x[0], -x[1]))"},{"question":"from typing import List def can_make_elements_equal(n: int, array: List[int]) -> str: Returns \\"YES\\" if it is possible to make all elements of the array equal using the allowed operations. Returns \\"NO\\" otherwise. >>> can_make_elements_equal(4, [3, 6, 3, 9]) \\"YES\\" >>> can_make_elements_equal(5, [-1, 2, -3, 4, -5]) \\"NO\\"","solution":"def can_make_elements_equal(n, array): Returns \\"YES\\" if it is possible to make all elements of the array equal using the allowed operations. Returns \\"NO\\" otherwise. # If there's only one element, they're trivially all equal. if n == 1: return \\"YES\\" # All elements must be equal to the sum of the array divided by the number of elements. # If there's a common divisor that's not 1 in the array, elements cannot be equal. from math import gcd from functools import reduce def find_gcd_of_list(nums): x = reduce(gcd, nums) return x gcd_value = find_gcd_of_list(array) # If GCD is not 1, it is possible to make all elements equal by using + operations if gcd_value != 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def can_form_optimized_tree(n: int, m: int, pipelines: List[Tuple[int, int]]) -> str: Determine if it's possible to create a cycle-free, uniquely flowing, connected graph (tree) from given pipelines. Args: n (int): Number of districts m (int): Number of pipelines pipelines (list of tuple of int): Each tuple represents a pipeline between two districts. Returns: str: 'Yes' if such a tree can be formed, 'No' otherwise Examples: >>> can_form_optimized_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"Yes\\" >>> can_form_optimized_tree(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"No\\"","solution":"def can_form_optimized_tree(n, m, pipelines): Determine if it's possible to create a cycle-free, uniquely flowing, connected graph (tree) from given pipelines. Args: n (int): Number of districts m (int): Number of pipelines pipelines (list of tuple of int): Each tuple represents a pipeline between two districts. Returns: str: 'Yes' if such a tree can be formed, 'No' otherwise if m != n - 1: return \\"No\\" parent = list(range(n + 1)) # Union-Find structure def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for a, b in pipelines: union(a, b) # Check if all nodes are connected root_set = {find(i) for i in range(1, n + 1)} return \\"Yes\\" if len(root_set) == 1 else \\"No\\""},{"question":"def distribute_badges(NB: int, NS: int, NG: int, NP: int, ND: int, scores: List[int]) -> List[str]: Distributes badges to employees based on their score and the available supply of badges. Parameters: NB (int): Number of Bronze badges NS (int): Number of Silver badges NG (int): Number of Gold badges NP (int): Number of Platinum badges ND (int): Number of Diamond badges scores (list of int): List of performance scores Returns: list of str: A list containing the badge each employee received Example: >>> distribute_badges(5, 3, 2, 1, 0, [45, 85, 50, 100]) ['B', 'G', 'S', 'P']","solution":"def distribute_badges(NB, NS, NG, NP, ND, scores): Distributes badges to employees based on their score and the available supply of badges. Parameters: NB (int): Number of Bronze badges NS (int): Number of Silver badges NG (int): Number of Gold badges NP (int): Number of Platinum badges ND (int): Number of Diamond badges scores (list of int): List of performance scores Returns: list of str: A list containing the badge each employee received badge_counts = {'D': ND, 'P': NP, 'G': NG, 'S': NS, 'B': NB} preferences = { 0: ['B'], 1: ['S', 'B'], 2: ['G', 'S', 'B'], 3: ['P', 'G', 'S', 'B'], 4: ['D', 'P', 'G', 'S', 'B'] } result = [] for score in scores: if score == 100: pref_list = preferences[4] elif 90 <= score <= 99: pref_list = preferences[3] elif 70 <= score <= 89: pref_list = preferences[2] elif 50 <= score <= 69: pref_list = preferences[1] else: pref_list = preferences[0] for badge in pref_list: if badge_counts[badge] > 0: result.append(badge) badge_counts[badge] -= 1 break return result"},{"question":"def notebook_operations(n, q, operations): Perform notebook operations and return the results of all REPORT operations. :param int n: number of pages in the notebook :param int q: number of operations :param list operations: list of operations :return: list of results of REPORT operations >>> notebook_operations(5, 6, [\\"ADD 2 10\\", \\"ADD 2 5\\", \\"REMOVE 2 8\\", \\"ADD 1 3\\", \\"REMOVE 2 10\\", \\"REPORT 2\\"]) [0] >>> notebook_operations(3, 4, [\\"ADD 1 5\\", \\"REMOVE 1 5\\", \\"REPORT 1\\", \\"REMOVE 1 2\\"]) [0] >>> notebook_operations(4, 7, [\\"ADD 3 12\\", \\"ADD 3 8\\", \\"REMOVE 3 10\\", \\"REPORT 3\\", \\"ADD 2 7\\", \\"REPORT 2\\", \\"REMOVE 3 2\\"]) [10, 7] >>> notebook_operations(2, 5, [\\"ADD 1 8\\", \\"ADD 1 4\\", \\"REMOVE 1 5\\", \\"ADD 1 3\\", \\"REPORT 1\\"]) [10] >>> notebook_operations(2, 3, [\\"ADD 1 10\\", \\"ADD 2 5\\", \\"REMOVE 1 3\\"]) []","solution":"def notebook_operations(n, q, operations): Perform notebook operations and return the results of all REPORT operations. :param int n: number of pages in the notebook :param int q: number of operations :param list operations: list of operations :return: list of results of REPORT operations clues = [0] * (n + 1) results = [] for operation in operations: parts = operation.split() op_type = parts[0] if op_type == \\"ADD\\": x, c = int(parts[1]), int(parts[2]) clues[x] += c elif op_type == \\"REMOVE\\": x, c = int(parts[1]), int(parts[2]) clues[x] = max(0, clues[x] - c) elif op_type == \\"REPORT\\": x = int(parts[1]) results.append(clues[x]) return results"},{"question":"def calculate_deviation_diff(num_cases, cases): Given an array of integers representing the working hours logged by an employee over a number of days, determine the average working hours per day and return the difference between the maximum and minimum deviation from this average. num_cases: int - The number of test cases. cases: List[Tuple[int, List[int]]] - A list of tuples where each tuple contains an integer array representing the working hours for each day. Returns a list of integers representing the difference between the maximum and minimum deviations for each test case. Example: >>> calculate_deviation_diff(2, [(5, [8, 7, 9, 6, 10]), (3, [2, 8, 5])]) [2, 3] >>> calculate_deviation_diff(1, [(4, [0, 0, 0, 0])]) [0] >>> calculate_deviation_diff(1, [(4, [9, 5, 3, 7])]) [2]","solution":"def calculate_deviation_diff(num_cases, cases): results = [] for i in range(num_cases): num_days = cases[i][0] hours = cases[i][1] avg_hours = sum(hours) / num_days deviations = [abs(hour - avg_hours) for hour in hours] max_deviation = max(deviations) min_deviation = min(deviations) results.append(int(max_deviation - min_deviation)) return results"},{"question":"def find_path_in_grid(n: int, m: int, grid: List[str], r1: int, c1: int, r2: int, c2: int) -> str: Determine if there's a path between two cells in the grid that only moves through empty cells. The grid consists of '.' for empty cells and '#' for obstacles. Args: n (int): Number of rows. m (int): Number of columns. grid (List[str]): The grid representation as a list of strings. r1 (int): Row number of the starting cell (1-based). c1 (int): Column number of the starting cell (1-based). r2 (int): Row number of the destination cell (1-based). c2 (int): Column number of the destination cell (1-based). Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. >>> find_path_in_grid(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"..#.\\"], 1, 1, 4, 3) \\"YES\\" >>> find_path_in_grid(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"..#.\\"], 1, 1, 4, 2) \\"YES\\" >>> find_path_in_grid(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"..#.\\"], 1, 1, 4, 4) \\"NO\\" >>> find_path_in_grid(4, 4, [\\"..#.\\", \\"..\\", \\"....\\", \\"..#.\\"], 1, 3, 4, 3) \\"NO\\" pass","solution":"def is_path_exists(n, m, grid, start, end): from collections import deque def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == end: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False def find_path_in_grid(n, m, grid, r1, c1, r2, c2): start = (r1 - 1, c1 - 1) end = (r2 - 1, c2 - 1) if grid[start[0]][start[1]] == '#' or grid[end[0]][end[1]] == '#': return \\"NO\\" if is_path_exists(n, m, grid, start, end): return \\"YES\\" else: return \\"NO\\""},{"question":"def max_odd_sum_pairs(A: List[int], B: List[int]) -> int: Returns the maximum number of pairs (A[i], B[j]) such that their sum is odd. >>> max_odd_sum_pairs([1, 2, 3, 4], [2, 3, 4, 5]) 4 >>> max_odd_sum_pairs([1, 1, 1], [2, 2, 2]) 3 >>> max_odd_sum_pairs([2, 4], [3, 5]) 2 >>> max_odd_sum_pairs([2, 4, 6], [1, 3, 5]) 3 >>> max_odd_sum_pairs([1, 3, 5], [7, 11, 13]) 0 >>> max_odd_sum_pairs([10], [1]) 1 >>> max_odd_sum_pairs([1], [10]) 1 >>> max_odd_sum_pairs([2, 4, 6, 8], [1, 3, 5, 7]) 4","solution":"def max_odd_sum_pairs(A, B): Returns the maximum number of pairs (A[i], B[j]) such that their sum is odd. # Count the number of odd and even numbers in A and B odd_A = sum(1 for x in A if x % 2 != 0) even_A = len(A) - odd_A odd_B = sum(1 for x in B if x % 2 != 0) even_B = len(B) - odd_B # Maximum number of pairs is the minimum of (odd_A, even_B) and (even_A, odd_B) return min(odd_A, even_B) + min(even_A, odd_B) # Test the function with example inputs n = 4 A = [1, 2, 3, 4] B = [2, 3, 4, 5] print(max_odd_sum_pairs(A, B)) # Output should be 4"},{"question":"def find_winners(n, m, skill_levels, competitions): Determine the winners for each competition. :param n: Number of friends :param m: Number of competitions :param skill_levels: List of skill levels of friends :param competitions: List of competitions in the form of (li, ri) tuples :return: List of tuples containing the skill levels of the top two winners for each competition >>> find_winners(6, 3, [5, 1, 3, 9, 7, 6], [(1, 3), (2, 5), (4, 6)]) ['5 3', '7 3', '9 7'] >>> find_winners(5, 2, [3, 8, 2, 5, 7], [(1, 2), (3, 5)]) ['8 3', '7 5'] >>> find_winners(4, 1, [4, 1, 8, 6], [(1, 4)]) ['8 6'] >>> find_winners(1, 1, [5], [(1, 1)]) ['-1']","solution":"def find_winners(n, m, skill_levels, competitions): Determine the winners for each competition. :param n: Number of friends :param m: Number of competitions :param skill_levels: List of skill levels of friends :param competitions: List of competitions in the form of (li, ri) tuples :return: List of tuples containing the skill levels of the top two winners for each competition winners = [] for li, ri in competitions: subset = skill_levels[li-1:ri] if len(subset) < 2: winners.append(\\"-1\\") else: first, second = sorted(subset, reverse=True)[:2] winners.append(f\\"{first} {second}\\") return winners"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generate an n x n matrix filled with numbers from 1 to n^2 in spiral order. >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]","solution":"def generate_spiral_matrix(n): Generate an n x n matrix filled with numbers from 1 to n^2 in spiral order. if n <= 0: return [] # Initialize the n x n matrix with zeros matrix = [[0] * n for _ in range(n)] num = 1 left, right = 0, n - 1 top, bottom = 0, n - 1 while left <= right and top <= bottom: # Fill top row for col in range(left, right + 1): matrix[top][col] = num num += 1 top += 1 # Fill right column for row in range(top, bottom + 1): matrix[row][right] = num num += 1 right -= 1 # Fill bottom row for col in range(right, left - 1, -1): matrix[bottom][col] = num num += 1 bottom -= 1 # Fill left column for row in range(bottom, top - 1, -1): matrix[row][left] = num num += 1 left += 1 return matrix"},{"question":"from typing import List, Tuple def can_make_equal(t: int, cases: List[Tuple[int, int, List[int]]]) -> List[str]: Given a number sequence, determine whether it is possible to make all elements equal using a specified operation. >>> can_make_equal(1, [(3, 7, [2, 1, 5])]) [\\"YES\\"] >>> can_make_equal(1, [(3, 7, [2, 3, 5])]) [\\"NO\\"] >>> can_make_equal(1, [(5, 1000000000, [999999999, 1, 1000000000, 2, 3])]) [\\"YES\\"] >>> can_make_equal(2, [(3, 5, [1, 2, 3]), (4, 5, [2, 3, 4, 5])]) [\\"YES\\", \\"NO\\"] >>> can_make_equal(1, [(5, 5, [2, 1, 3, 4, 5])]) [\\"YES\\"]","solution":"def can_make_equal(t, cases): results = [] for n, m, a in cases: if 1 in a: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def sum_of_squares_of_even_numbers(N: int) -> int: Calculate the sum of the squares of all even numbers from 1 to N inclusive. Parameters: N (int) : A non-negative integer (1 ≤ N ≤ 10^6) Returns: int : The sum of the squares of all even numbers from 1 to N inclusive. >>> sum_of_squares_of_even_numbers(10) 220 >>> sum_of_squares_of_even_numbers(2) 4 >>> sum_of_squares_of_even_numbers(1) 0 >>> sum_of_squares_of_even_numbers(20) 1540 >>> sum_of_squares_of_even_numbers(50) 22100","solution":"def sum_of_squares_of_even_numbers(N: int) -> int: Calculate the sum of the squares of all even numbers from 1 to N inclusive. Parameters: N (int) : A non-negative integer (1 ≤ N ≤ 10^6) Returns: int : The sum of the squares of all even numbers from 1 to N inclusive. return sum(i * i for i in range(2, N+1, 2))"},{"question":"from typing import List def can_dispense(stock: List[int], beverage: str) -> str: Determine whether the coffee machine can dispense a specific beverage based on stock. >>> can_dispense([50, 0, 30], \\"espresso\\") == \\"Yes\\" >>> can_dispense([40, 0, 30], \\"espresso\\") == \\"No\\" >>> can_dispense([35, 200, 60], \\"latte\\") == \\"Yes\\" >>> can_dispense([35, 140, 60], \\"latte\\") == \\"No\\" >>> can_dispense([30, 100, 55], \\"cappuccino\\") == \\"Yes\\" >>> can_dispense([30, 90, 55], \\"cappuccino\\") == \\"No\\" >>> can_dispense([5, 7, 210], \\"hot_water\\") == \\"Yes\\" >>> can_dispense([5, 7, 190], \\"hot_water\\") == \\"No\\" >>> can_dispense([50, 50, 50], \\"unknown_beverage\\") == \\"No\\"","solution":"from typing import List def can_dispense(stock: List[int], beverage: str) -> str: recipes = { \\"espresso\\": [50, 0, 30], \\"latte\\": [30, 150, 50], \\"cappuccino\\": [25, 100, 50], \\"hot_water\\": [0, 0, 200], } recipe = recipes.get(beverage) if recipe is None: return \\"No\\" if all(stock[i] >= recipe[i] for i in range(3)): for i in range(3): stock[i] -= recipe[i] return \\"Yes\\" else: return \\"No\\""},{"question":"def find_indices(arr: list, n: int) -> tuple: Finds two distinct indices i and j in the array such that the difference between the elements at these indices is equal to a given target number n. Returns a tuple of the form (i, j) which are the 1-based indices of the elements satisfying the condition arr[i] - arr[j] = n or arr[j] - arr[i] = n. If no such indices exist, returns -1. # your code here def test_find_indices_example1(): arr = [1, 7, 5, 9] n = 2 result = find_indices(arr, n) assert result in [(2, 3), (3, 2)] def test_find_indices_example2(): arr = [4, 8, 12, 16] n = 4 result = find_indices(arr, n) assert result in [(2, 1), (3, 2), (4, 3), (1, 2), (2, 3), (3, 4)] def test_find_indices_example3(): arr = [1, 2, 3, 4, 5] n = 6 assert find_indices(arr, n) == -1 def test_find_indices_same_elements(): arr = [5, 5, 5, 5] n = 0 result = find_indices(arr, n) assert result != -1 def test_find_indices_large_difference(): arr = [1000000000, -1000000000] n = 2000000000 assert find_indices(arr, n) == (1, 2) or find_indices(arr, n) == (2, 1) def test_find_indices_no_difference(): arr = [10, 20, 30, 40, 50] n = 0 assert find_indices(arr, n) == -1","solution":"def find_indices(arr, n): Finds two distinct indices i and j in the array such that the difference between the elements at these indices is equal to a given target number n. Returns a tuple of the form (i, j) which are the 1-based indices of the elements satisfying the condition arr[i] - arr[j] = n or arr[j] - arr[i] = n. If no such indices exist, returns -1. value_to_index = {} for idx, value in enumerate(arr): if value - n in value_to_index: return (idx + 1, value_to_index[value - n] + 1) if value + n in value_to_index: return (value_to_index[value + n] + 1, idx + 1) value_to_index[value] = idx return -1"},{"question":"def uniquePaths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m by n grid. The result is returned modulo 10^9 + 7. >>> uniquePaths(3, 7) 28 >>> uniquePaths(3, 3) 6 >>> uniquePaths(1, 1) 1 >>> uniquePaths(10, 10) 48620 >>> result = uniquePaths(1000, 1000) >>> isinstance(result, int) True >>> result > 0 True","solution":"def uniquePaths(m, n): Returns the number of unique paths from top-left to bottom-right of a m x n grid. MOD = 10**9 + 7 # Create a 2D table to store results of subproblems dp = [[1] * n for _ in range(m)] # Fill dp table using a bottom-up approach for i in range(1, m): for j in range(1, n): dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD return dp[m - 1][n - 1]"},{"question":"def max_rectangle_area(heights: List[int]) -> int: Function to find the maximum rectangular area in a histogram. :param heights: List[int], List of building heights. :return: int, maximum area of the rectangle that can be formed. >>> max_rectangle_area([2, 1, 5, 6, 2, 3, 4]) 10 >>> max_rectangle_area([3, 6, 5, 7, 4, 8]) 20 >>> max_rectangle_area([5]) 5 >>> max_rectangle_area([5, 5, 5, 5, 5]) 25 >>> max_rectangle_area([1, 2, 3, 4, 5]) 9 >>> max_rectangle_area([5, 4, 3, 2, 1]) 9","solution":"def max_rectangle_area(heights): Function to find the maximum rectangular area in a histogram. :param heights: List[int], List of building heights. :return: int, maximum area of the rectangle that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def is_diverse(s: str) -> str: Check whether a given string can be considered diverse. A message is considered diverse if it contains at least three different characters (letters or digits), and all different characters must appear with the same frequency. Args: s (str): The input string consisting of lowercase latins and digits. Returns: str: \\"Yes\\" if the string can be considered diverse, \\"No\\" otherwise. Examples: >>> is_diverse(\\"ab12ba21\\") \\"Yes\\" >>> is_diverse(\\"aa1b3\\") \\"No\\"","solution":"def is_diverse(s): from collections import Counter if len(s) < 3: return \\"No\\" char_count = Counter(s) frequencies = set(char_count.values()) if len(char_count) < 3 or len(frequencies) != 1: return \\"No\\" return \\"Yes\\""},{"question":"def can_perform_operations(n, m, operations): This function determines if all file operations can be successfully executed. Parameters: n (int): the number of computers. m (int): the number of operations. operations (list): a list of operations represented as strings. Returns: str: \\"YES\\" if all operations can be successfully executed, \\"NO\\" otherwise. >>> can_perform_operations(3, 4, [\\"U 1 100\\", \\"D 2 100\\", \\"U 2 200\\", \\"D 3 200\\"]) \\"YES\\" >>> can_perform_operations(2, 3, [\\"D 1 100\\", \\"U 2 100\\", \\"D 2 101\\"]) \\"NO\\"","solution":"def can_perform_operations(n, m, operations): This function determines if all file operations can be successfully executed. Parameters: n (int): the number of computers. m (int): the number of operations. operations (list): a list of operations represented as strings. Returns: str: \\"YES\\" if all operations can be successfully executed, \\"NO\\" otherwise. uploaded_files = set() for operation in operations: op_type, computer, file_id = operation.split() file_id = int(file_id) if op_type == 'U': # Upload operation uploaded_files.add(file_id) elif op_type == 'D': # Download operation if file_id not in uploaded_files: return \\"NO\\" return \\"YES\\""},{"question":"def min_swaps_to_no_adjacent_same(n: int, s: str) -> int: You are given a string s of length n consisting of lowercase English letters. You are allowed to perform any number of the following operations: 1. Choose a pair of adjacent characters in the string and swap them. Your goal is to arrange the characters of the string so that no two adjacent characters are the same. If it is impossible to achieve, return -1. Otherwise, return the minimum number of swaps required to achieve this. >>> min_swaps_to_no_adjacent_same(7, \\"aaabbbc\\") 4 >>> min_swaps_to_no_adjacent_same(5, \\"abcde\\") 0 >>> min_swaps_to_no_adjacent_same(3, \\"aaa\\") -1 >>> min_swaps_to_no_adjacent_same(1, \\"a\\") 0 >>> min_swaps_to_no_adjacent_same(6, \\"ababab\\") 0","solution":"def min_swaps_to_no_adjacent_same(n, s): from collections import Counter import heapq # Calculate frequency of each character char_freq = Counter(s) # Check if there's any character with more than half the length of the string if any(freq > (n + 1) // 2 for freq in char_freq.values()): return -1 # Use a max heap to always place the most frequent characters first max_heap = [(-freq, char) for char, freq in char_freq.items()] heapq.heapify(max_heap) swaps = 0 prev_freq, prev_char = 0, \\"\\" result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update the freq and char for the next iteration prev_freq, prev_char = freq + 1, char # Count the number of swaps needed to form the alternating sequence swaps = sum(s[i] == s[i+1] for i in range(n-1)) return swaps"},{"question":"def can_partition(nums: List[int]) -> bool: Returns True if the array can be partitioned into two subsets with equal sum, otherwise False. Example: >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 9]) False","solution":"def can_partition(nums): Returns True if the array can be partitioned into two subsets with equal sum, otherwise False. total_sum = sum(nums) # If the total sum is odd, it's not possible to partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 # Initialize a set to keep track of the targets we can achieve reachable_sums = {0} for num in nums: new_reachable_sums = reachable_sums.copy() for current_sum in reachable_sums: new_sum = current_sum + num if new_sum == target: return True new_reachable_sums.add(new_sum) reachable_sums = new_reachable_sums return target in reachable_sums"},{"question":"def lexicographically_smallest_array(n: int, a: List[int]) -> List[int]: Returns the lexicographically smallest array possible after performing at most one swap operation. >>> lexicographically_smallest_array(1, [3]) [3] >>> lexicographically_smallest_array(5, [2, 1, 9, 4, 3]) [1, 2, 9, 4, 3] >>> lexicographically_smallest_array(4, [13, 4, 1, 37]) [1, 4, 13, 37] >>> lexicographically_smallest_array(8, [15, 9, 6, 24, 8, 11, 33, 4]) [4, 9, 6, 24, 8, 11, 33, 15] >>> lexicographically_smallest_array(4, [3, 10, 15, 20]) [3, 10, 15, 20]","solution":"def lexicographically_smallest_array(n, a): Returns the lexicographically smallest array possible after performing at most one swap operation. # Traverse the array and find the first index where the next element is smaller for i in range(n): min_index = i for j in range(i + 1, n): if a[j] < a[min_index]: min_index = j # Swap if it results in a smaller array if min_index != i and a[min_index] < a[i]: a[i], a[min_index] = a[min_index], a[i] break return a"},{"question":"def max_musicians(t: int, n: int, durations: List[int]) -> int: Returns the maximum number of musicians that can perform without exceeding the total available minutes. >>> max_musicians(300, 4, [120, 90, 60, 150]) 3 >>> max_musicians(0, 4, [120, 90, 60, 150]) 0 >>> max_musicians(300, 0, []) 0 >>> max_musicians(100, 1, [100]) 1 >>> max_musicians(50, 1, [100]) 0 >>> max_musicians(300, 3, [80, 90, 60]) 3 >>> max_musicians(150, 4, [80, 90, 60, 30]) 2 >>> max_musicians(100000, 1000, [100] * 1000) 1000 >>> max_musicians(50000, 1000, [50] * 1000) 1000 >>> max_musicians(50000, 1000, [1000] * 1000) 50 >>> max_musicians(100, 5, [25, 20, 15, 40, 5]) 4","solution":"def max_musicians(t, n, durations): Returns the maximum number of musicians that can perform without exceeding the total available minutes. Parameters: t (int): Total available minutes for the festival. n (int): Number of musicians. durations (list of int): List of required minutes for each musician's performance. Returns: int: Maximum number of musicians that can perform. durations.sort() total_minutes = 0 count = 0 for duration in durations: if total_minutes + duration <= t: total_minutes += duration count += 1 else: break return count"},{"question":"from typing import List def find_peak(nums: List[int]) -> int: Returns the index of any one peak element in the array. A peak element is an element that is greater than its neighbors. Args: nums (List[int]): A list of integers. Returns: int: The index of a peak element. Examples: >>> find_peak([1, 3, 20, 4, 1, 0]) 2 >>> find_peak([1, 2, 3, 4, 5]) 4 >>> find_peak([5, 4, 3, 2, 1]) 0 # Your code here def test_find_peak_simple_cases(): assert find_peak([1, 3, 20, 4, 1, 0]) == 2 # Example 1 assert find_peak([1, 2, 3, 4, 5]) == 4 # Example 2 assert find_peak([5, 4, 3, 2, 1]) == 0 # Example 3 def test_find_peak_single_element(): assert find_peak([10]) == 0 def test_find_peak_multiple_peaks(): result = find_peak([10, 20, 15, 2, 23, 90, 67]) # valid peak indices could be 1 or 5 assert result in [1, 5] def test_find_peak_peak_in_middle(): assert find_peak([1, 3, 50, 10, 9, 7, 6, 2, 1]) == 2 def test_find_peak_edge_cases(): assert find_peak([3, 4, 3, 2, 1]) == 1 assert find_peak([1, 2, 3, 4, 6, 5]) == 4 assert find_peak([1, 5, 1]) == 1","solution":"from typing import List def find_peak(nums: List[int]) -> int: Returns the index of any one peak element in the array. n = len(nums) left, right = 0, n - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"def merge_intervals(intervals: list) -> list: Merges overlapping intervals and returns a list of non-overlapping intervals. Parameters: intervals (list): A list of tuples, each tuple contains two integers (start, end) representing the start and end times of an interval. Returns: list: A list of merged non-overlapping intervals. # Your code here # Example usage: # intervals = [(1, 3), (2, 4), (5, 7), (6, 8)] # print(merge_intervals(intervals)) # Output: [(1, 4), (5, 8)] # Unit tests def test_merge_overlapping_intervals(): assert merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) == [(1, 4), (5, 8)] def test_single_interval(): assert merge_intervals([(1, 3)]) == [(1, 3)] def test_non_overlapping_intervals(): assert merge_intervals([(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)] def test_multiple_intervals_starting_at_same_time(): assert merge_intervals([(1, 2), (1, 3), (1, 4)]) == [(1, 4)] def test_empty_intervals(): assert merge_intervals([]) == [] def test_intervals_with_same_start_and_end(): assert merge_intervals([(1, 1), (2, 2), (3, 3)]) == [(1, 1), (2, 2), (3, 3)] def test_complex_overlap(): assert merge_intervals([(1, 5), (2, 6), (3, 4), (8, 10), (9, 12)]) == [(1, 6), (8, 12)]","solution":"def merge_intervals(intervals: list) -> list: Merges overlapping intervals and returns a list of non-overlapping intervals. Parameters: intervals (list): A list of tuples, each tuple contains two integers (start, end) representing the start and end times of an interval. Returns: list: A list of merged non-overlapping intervals. if not intervals: return [] merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: current_end = max(current_end, end) else: merged_intervals.append((current_start, current_end)) current_start, current_end = start, end merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"def subarray_sum_exists(n: int, k: int, arr: List[int]) -> str: Checks if there exists a non-empty subarray with sum exactly k. >>> subarray_sum_exists(5, 9, [1, 2, 3, 4, 5]) \\"YES\\" >>> subarray_sum_exists(5, 20, [1, 2, 3, 4, 5]) \\"NO\\" >>> subarray_sum_exists(5, 0, [1, 2, -3, 3, -1, 1]) \\"YES\\" >>> subarray_sum_exists(4, 3, [1, -1, 2, 1]) \\"YES\\" >>> subarray_sum_exists(3, -4, [-1, -2, -1]) \\"YES\\"","solution":"def subarray_sum_exists(n, k, arr): Checks if there exists a non-empty subarray with sum exactly k. Parameters: n (int): The length of the array. k (int): The target sum. arr (list of int): The list of integers. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". current_sum = 0 prefix_sums = {} for idx, num in enumerate(arr): current_sum += num if current_sum == k: return \\"YES\\" if (current_sum - k) in prefix_sums: return \\"YES\\" prefix_sums[current_sum] = idx return \\"NO\\""},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> bool: Determine whether any two numbers in the list add up to the target. Returns True if there are two distinct indices i and j in the list such that nums[i] + nums[j] equals target. Otherwise, returns False. >>> two_sum([2, 7, 11, 15], 9) True >>> two_sum([3, 2, 4], 6) True >>> two_sum([3, 3], 6) True >>> two_sum([1, 2, 3], 7) False","solution":"from typing import List def two_sum(nums: List[int], target: int) -> bool: Determine whether any two numbers in the list add up to the target. Returns True if there are two distinct indices i and j in the list such that nums[i] + nums[j] equals target. Otherwise, returns False. # Using a set to keep track of the numbers we have seen so far. seen = set() for num in nums: # Calculate the complement that would complete the equation num + complement = target complement = target - num # If complement is found in set, it means we have a pair that sums up to target if complement in seen: return True # Add the current number to the set of seen numbers seen.add(num) # Return False if no such pair is found return False"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") 'bb'","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string. if not s or len(s) == 1: return s n = len(s) start, max_length = 0, 1 def expand_around_center(left, right): nonlocal start, max_length while left >= 0 and right < n and s[left] == s[right]: current_length = right - left + 1 if current_length > max_length: start = left max_length = current_length left -= 1 right += 1 for i in range(n): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return s[start:start + max_length]"},{"question":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of unique integers using merge sort algorithm. :param arr: List of unique integers :return: Sorted list of integers pass def test_merge_sort_basic_input(): assert merge_sort([3, 1, 2]) == [1, 2, 3] def test_merge_sort_large_input(): assert merge_sort([10, 5, 3, 2, 8, 6, 7, 4, 1, 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def test_merge_sort_empty_array(): assert merge_sort([]) == [] def test_merge_sort_single_element(): assert merge_sort([42]) == [42] def test_merge_sort_already_sorted(): assert merge_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def test_merge_sort_reverse_sorted(): assert merge_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of unique integers using merge sort algorithm. :param arr: List of unique integers :return: Sorted list of integers if len(arr) <= 1: return arr # Split the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_arr = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 # Append remaining elements of left and right part sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr"},{"question":"def count_successful_students(s: int, t: int, results: List[List[int]]) -> int: Count the number of students who solved all problems in all stages. Parameters: s (int): Number of students. t (int): Number of stages. results (list of list of int): A list of lists where each sublist represents a student's results over the stages. Returns: int: The number of students who successfully solved all problems in all stages. >>> count_successful_students(3, 4, [[1, 1, 0, 1], [1, 1, 1, 1], [0, 1, 1, 1]]) 1 >>> count_successful_students(3, 4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 3 >>> count_successful_students(3, 4, [[1, 1, 0, 1], [1, 1, 1, 0], [0, 1, 1, 1]]) 0 >>> count_successful_students(1, 1, [[1]]) 1 >>> count_successful_students(1, 1, [[0]]) 0","solution":"def count_successful_students(s, t, results): Count the number of students who solved all problems in all stages. Parameters: s (int): Number of students. t (int): Number of stages. results (list of list of int): A list of lists where each sublist represents a student's results over the stages. Returns: int: The number of students who successfully solved all problems in all stages. successful_count = 0 for result in results: if all(stage_result == 1 for stage_result in result): successful_count += 1 return successful_count"},{"question":"from collections import defaultdict, deque def longest_path_in_dag(n: int, edges: List[Tuple[int, int]]) -> int: Determine the length of the longest path in a directed acyclic graph (DAG). Args: n (int): The number of experiments/nodes. edges (List[Tuple[int, int]]): A list of directed edges where each edge is represented as a tuple (u, v). Returns: int: The length of the longest path in the DAG. >>> longest_path_in_dag(5, [(1, 2), (2, 3), (1, 3), (3, 4)]) 3 >>> longest_path_in_dag(4, []) 0 >>> longest_path_in_dag(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) # Example with a cycle 0 >>> longest_path_in_dag(6, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) # Example with disconnected graph and cycle 2 >>> longest_path_in_dag(1, []) 0 >>> longest_path_in_dag(6, [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5), (5, 6)]) 5","solution":"from collections import defaultdict, deque def longest_path_in_dag(n, edges): graph = defaultdict(list) in_degree = [0] * (n + 1) for u, v in edges: graph[u].append(v) in_degree[v] += 1 topo_sort = [] queue = deque() for node in range(1, n + 1): if in_degree[node] == 0: queue.append(node) while queue: node = queue.popleft() topo_sort.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) longest_path = [0] * (n + 1) for node in topo_sort: for neighbor in graph[node]: if longest_path[neighbor] < longest_path[node] + 1: longest_path[neighbor] = longest_path[node] + 1 return max(longest_path) def parse_input(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) edges = [tuple(map(int, line.split())) for line in lines[1:]] return n, edges def main(input_string): n, edges = parse_input(input_string) return longest_path_in_dag(n, edges)"},{"question":"def can_transform(s: str) -> str: Determines if the string can be transformed such that there are no two consecutive characters that are the same. Parameters: s (str): Input string consisting only of 'a', 'b', and 'c'. Returns: str: \\"YES\\" if possible to transform, otherwise \\"NO\\". >>> can_transform(\\"abc\\") \\"YES\\" >>> can_transform(\\"aab\\") \\"NO\\" >>> can_transform(\\"abab\\") \\"YES\\" >>> can_transform(\\"aaaa\\") \\"NO\\" >>> can_transform(\\"a\\") \\"YES\\" >>> can_transform(\\"abca\\") \\"YES\\" pass def process_multiple_cases(t: int, cases: List[str]) -> List[str]: Processes multiple test cases to determine if each string can be transformed. Parameters: t (int): Number of test cases. cases (list of str): List of strings for each test case. Returns: list of str: List of results, \\"YES\\" or \\"NO\\". >>> process_multiple_cases(3, [\\"abc\\", \\"aab\\", \\"abab\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_multiple_cases(2, [\\"aaaa\\", \\"a\\"]) [\\"NO\\", \\"YES\\"] >>> process_multiple_cases(5, [\\"a\\", \\"b\\", \\"c\\", \\"aa\\", \\"ab\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def can_transform(s): Determines if the string can be transformed such that there are no two consecutive characters that are the same. Parameters: s (str): Input string consisting only of 'a', 'b', and 'c'. Returns: str: \\"YES\\" if possible to transform, otherwise \\"NO\\". for i in range(1, len(s)): if s[i] == s[i-1]: return \\"NO\\" return \\"YES\\" def process_multiple_cases(t, cases): Processes multiple test cases to determine if each string can be transformed. Parameters: t (int): Number of test cases. cases (list of str): List of strings for each test case. Returns: list of str: List of results, \\"YES\\" or \\"NO\\". results = [] for case in cases: results.append(can_transform(case)) return results"},{"question":"def is_hyperactive(n: int, d: int, binary_string: str) -> str: Determine if a user is \\"Hyperactive\\". A user is \\"Hyperactive\\" if they make at least one post every day for a consecutive period of at least 'd' days. :param n: The total number of days in the user's posting history :param d: The minimum number of consecutive days required to be deemed \\"Hyperactive\\" :param binary_string: A binary string of length 'n', where '1' means the user posted on that day :return: \\"Yes\\" if the user is \\"Hyperactive\\", otherwise \\"No\\" >>> is_hyperactive(10, 3, '1101110111') \\"Yes\\" >>> is_hyperactive(5, 5, '11111') \\"Yes\\" >>> is_hyperactive(7, 4, '1001100') \\"No\\" >>> is_hyperactive(8, 3, '00000000') \\"No\\" >>> is_hyperactive(6, 2, '101010') \\"No\\" >>> is_hyperactive(6, 1, '101010') \\"Yes\\" >>> is_hyperactive(1, 1, '0') \\"No\\" >>> is_hyperactive(1, 1, '1') \\"Yes\\" # Your code here def process_test_cases(t: int, test_cases: list) -> list: Process the list of test cases to determine if each user is \\"Hyperactive\\". :param t: The number of test cases :param test_cases: A list of tuples, each containing (n, d, binary_string) :return: A list of strings, each being \\"Yes\\" or \\"No\\" for the corresponding test case >>> process_test_cases(3, [(10, 3, '1101110111'), (5, 5, '11111'), (7, 4, '1001100')]) [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> process_test_cases(4, [(8, 3, '00000000'), (6, 2, '101010'), (1, 1, '0'), (1, 1, '1')]) [\\"No\\", \\"No\\", \\"No\\", \\"Yes\\"] # Your code here from is_hyperactive import is_hyperactive, process_test_cases def test_is_hyperactive(): assert is_hyperactive(10, 3, '1101110111') == \\"Yes\\" assert is_hyperactive(5, 5, '11111') == \\"Yes\\" assert is_hyperactive(7, 4, '1001100') == \\"No\\" assert is_hyperactive(8, 3, '00000000') == \\"No\\" assert is_hyperactive(6, 2, '101010') == \\"No\\" assert is_hyperactive(6, 1, '101010') == \\"Yes\\" assert is_hyperactive(1, 1, '0') == \\"No\\" assert is_hyperactive(1, 1, '1') == \\"Yes\\" def test_process_test_cases(): test_cases = [ (10, 3, '1101110111'), (5, 5, '11111'), (7, 4, '1001100') ] t = 3 expected_output = [\\"Yes\\", \\"Yes\\", \\"No\\"] assert process_test_cases(t, test_cases) == expected_output test_cases = [ (8, 3, '00000000'), (6, 2, '101010'), (1, 1, '0'), (1, 1, '1') ] t = 4 expected_output = [\\"No\\", \\"No\\", \\"No\\", \\"Yes\\"] assert process_test_cases(t, test_cases) == expected_output","solution":"def is_hyperactive(n, d, binary_string): max_consecutive_days = 0 current_count = 0 for char in binary_string: if char == '1': current_count += 1 if current_count >= d: return \\"Yes\\" else: current_count = 0 return \\"No\\" def process_test_cases(t, test_cases): results = [] for i in range(t): n, d = test_cases[i][:2] binary_string = test_cases[i][2] results.append(is_hyperactive(n, d, binary_string)) return results"},{"question":"def subset_sum_exists(N: int, K: int, numbers: List[int]) -> str: Determines if there exists a subset of the given list of numbers that sums up to K. Args: N (int): The number of integers in the list. K (int): The target sum. numbers (list): The list of integers. Returns: str: \\"YES\\" if such a subset exists, otherwise \\"NO\\". >>> subset_sum_exists(5, 9, [3, 34, 4, 12, 5]) \\"YES\\" >>> subset_sum_exists(5, 30, [3, 34, 4, 12, 5]) \\"NO\\" >>> subset_sum_exists(1, 4, [4]) \\"YES\\" >>> subset_sum_exists(1, 5, [4]) \\"NO\\" >>> subset_sum_exists(5, 58, [3, 34, 4, 12, 5]) \\"YES\\" >>> subset_sum_exists(3, 0, [1, 2, 3]) \\"YES\\"","solution":"def subset_sum_exists(N, K, numbers): Determines if there exists a subset of the given list of numbers that sums up to K. Args: N (int): The number of integers in the list. K (int): The target sum. numbers (list): The list of integers. Returns: str: \\"YES\\" if such a subset exists, otherwise \\"NO\\". # Create a DP array initialized to False with dimension (N+1) x (K+1) dp = [[False] * (K + 1) for _ in range(N + 1)] # There is always a subset with sum 0, the empty subset for i in range(N + 1): dp[i][0] = True # Fill the DP table for i in range(1, N + 1): for j in range(1, K + 1): if numbers[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - numbers[i - 1]] return \\"YES\\" if dp[N][K] else \\"NO\\""},{"question":"from typing import List def count_subarrays_with_sum(arr: List[int], m: int) -> int: Given an array of non-negative integers and an integer m, count the number of subarrays whose sum is exactly m. >>> count_subarrays_with_sum([1, 2, 3, 4, 5], 5) 2 >>> count_subarrays_with_sum([5], 5) 1 >>> count_subarrays_with_sum([0], 5) 0 >>> count_subarrays_with_sum([0, 0, 0, 0, 0], 0) 15 >>> count_subarrays_with_sum([1, 2, 3], 10) 0 >>> count_subarrays_with_sum([1, 2, 3, 2, 1], 6) 2 >>> count_subarrays_with_sum([10**8, 10**8, 10**8, 10**8, 10**8], 10**9) 0 >>> large_array = [1] * 10**5 >>> count_subarrays_with_sum(large_array, 2) 99999","solution":"def count_subarrays_with_sum(arr, m): Given an array of non-negative integers and an integer m, count the number of subarrays whose sum is exactly m. :param arr: List[int] - the array of non-negative integers :param m: int - the target sum for subarrays :return: int - the number of subarrays that sum up to exactly m from collections import defaultdict # Dictionary to store prefix sums and their counts prefix_sums = defaultdict(int) prefix_sums[0] = 1 # Initialize with 0 to handle cases where the subarray sum starts from the beginning current_sum = 0 count_subarrays = 0 # Traverse through the array for num in arr: current_sum += num # Check if there exists a prefix subarray with a sum that when added to m gives current_sum if (current_sum - m) in prefix_sums: count_subarrays += prefix_sums[current_sum - m] # Update the prefix_sums dictionary prefix_sums[current_sum] += 1 return count_subarrays"},{"question":"from typing import List def max_benefit(B: int, C: List[int], V: List[int]) -> int: Determine the maximum benefit a guest can obtain without exceeding their budget. >>> max_benefit(50, [10, 20, 30], [60, 100, 120]) 220 >>> max_benefit(10, [10], [20]) 20 >>> max_benefit(50, [10, 20, 30], [50, 70, 90]) 160 >>> max_benefit(0, [1, 2, 3], [10, 20, 30]) 0 >>> max_benefit(30, [10, 10, 10], [10, 20, 30]) 60 >>> max_benefit(1000, [100, 200, 300, 400], [150, 300, 450, 600]) 1500 >>> max_benefit(10, [20, 30, 40], [100, 200, 300]) 0","solution":"from typing import List def max_benefit(B: int, C: List[int], V: List[int]) -> int: N = len(C) dp = [0] * (B + 1) for i in range(N): for b in range(B, C[i] - 1, -1): dp[b] = max(dp[b], dp[b - C[i]] + V[i]) return dp[B]"},{"question":"def is_fair_division(n, m, colors): Determine if blocks can be divided into three groups such that: 1. Each group contains at least one block. 2. No two blocks in the same group share the same color. :param n: int, the number of blocks :param m: int, the number of different colors :param colors: list of int, the color of each block :return: str, \\"YES\\" if the blocks can be divided fairly, \\"NO\\" otherwise pass def process_input(input_data): Process the input data to determine the result for each test case :param input_data: list of str, input lines containing the number of blocks, the number of colors, and the colors of each block :return: list of str, results for each test case (\\"YES\\" or \\"NO\\") pass def test_is_fair_division(): # Test cases input_data = [ \\"6 3n1 2 3 1 2 3\\", \\"5 2n1 1 2 2 1\\", \\"9 3n1 2 3 1 2 3 1 2 3\\", \\"7 4n1 1 2 2 3 3 4\\", \\"6 2n1 1 2 2 1 1\\", \\"0 0\\", ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] assert process_input(input_data) == expected_output def test_minimum_constraints(): assert is_fair_division(3, 3, [1, 2, 3]) == \\"YES\\" assert is_fair_division(3, 1, [1, 1, 1]) == \\"NO\\" def test_all_same_color(): assert is_fair_division(4, 1, [1, 1, 1, 1]) == \\"NO\\" assert is_fair_division(5, 1, [1, 1, 1, 1, 1]) == \\"NO\\" def test_equal_blocks_and_colors(): assert is_fair_division(6, 6, [1, 2, 3, 4, 5, 6]) == \\"YES\\" assert is_fair_division(9, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) == \\"YES\\" def test_more_blocks_than_colors(): assert is_fair_division(5, 2, [1, 1, 2, 2, 2]) == \\"NO\\" assert is_fair_division(4, 2, [1, 1, 2, 2]) == \\"NO\\"","solution":"def is_fair_division(n, m, colors): Determine if blocks can be divided into three groups such that: 1. Each group contains at least one block. 2. No two blocks in the same group share the same color. :param n: int, the number of blocks :param m: int, the number of different colors :param colors: list of int, the color of each block :return: str, \\"YES\\" if the blocks can be divided fairly, \\"NO\\" otherwise from collections import Counter # Counting occurrences of each color color_count = Counter(colors) # Checking if there are at least 3 colors if len(color_count) < 3: return \\"NO\\" # Checking the frequency of each color for count in color_count.values(): if count > n // 3 + 1: return \\"NO\\" return \\"YES\\" def process_input(input_data): results = [] for line in input_data: n, m, *colors = list(map(int, line.split())) if n == 0 and m == 0: break results.append(is_fair_division(n, m, colors)) return results"},{"question":"def validate_coupon(coupon: str) -> str: Validates a given coupon code based on specific rules. Rules: - It must contain exactly 10 characters. - It must include at least one uppercase letter. - It must include at least one digit. - It must include at least one special character from the set: {'#', '@', '!', '*'}. :param coupon: str, a coupon code to be validated. :return: str, \\"VALID\\" if the coupon meets all the rules, otherwise \\"INVALID\\". def process_coupons(n: int, coupons: List[str]) -> List[str]: Processes a list of coupons and validates each. :param n: int, the number of coupon codes. :param coupons: list of str, the coupon codes. :return: list of str, validity of each coupon code (\\"VALID\\" or \\"INVALID\\"). from solution import validate_coupon, process_coupons def test_validate_coupon_valid(): assert validate_coupon(\\"A1b2C3d4E!\\") == \\"VALID\\" assert validate_coupon(\\"A2b3D4c5E#\\") == \\"VALID\\" assert validate_coupon(\\"M7n6O5p4*!\\") == \\"VALID\\" def test_validate_coupon_invalid_length(): assert validate_coupon(\\"A1b2C3!\\") == \\"INVALID\\" assert validate_coupon(\\"A1b2C3d4E5!!\\") == \\"INVALID\\" assert validate_coupon(\\"A1b2c3D4\\") == \\"INVALID\\" def test_validate_coupon_invalid_no_uppercase(): assert validate_coupon(\\"a1b2c3d4e!\\") == \\"INVALID\\" assert validate_coupon(\\"1234567890\\") == \\"INVALID\\" def test_validate_coupon_invalid_no_digit(): assert validate_coupon(\\"Abcdefghij!\\") == \\"INVALID\\" assert validate_coupon(\\"AaBbCcDdEe@\\") == \\"INVALID\\" def test_validate_coupon_invalid_no_special(): assert validate_coupon(\\"Abc1def2gH\\") == \\"INVALID\\" assert validate_coupon(\\"A1b2C3d4E5\\") == \\"INVALID\\" def test_process_coupons(): coupons = [\\"A1b2C3d4E!\\", \\"1234567890\\", \\"Abcde@1234\\"] expected_output = [\\"VALID\\", \\"INVALID\\", \\"VALID\\"] assert process_coupons(3, coupons) == expected_output coupons = [\\"A1b2C3d4E5\\", \\"Ab@1fghijk\\"] expected_output = [\\"INVALID\\", \\"VALID\\"] assert process_coupons(2, coupons) == expected_output","solution":"def validate_coupon(coupon): Validates a given coupon code based on specific rules. Rules: - It must contain exactly 10 characters. - It must include at least one uppercase letter. - It must include at least one digit. - It must include at least one special character from the set: {'#', '@', '!', '*'}. :param coupon: str, a coupon code to be validated. :return: str, \\"VALID\\" if the coupon meets all the rules, otherwise \\"INVALID\\". if len(coupon) != 10: return \\"INVALID\\" has_upper = any(c.isupper() for c in coupon) has_digit = any(c.isdigit() for c in coupon) has_special = any(c in {'#', '@', '!', '*'} for c in coupon) if has_upper and has_digit and has_special: return \\"VALID\\" else: return \\"INVALID\\" def process_coupons(n, coupons): Processes a list of coupons and validates each. :param n: int, the number of coupon codes. :param coupons: list of str, the coupon codes. :return: list of str, validity of each coupon code (\\"VALID\\" or \\"INVALID\\"). results = [] for coupon in coupons: results.append(validate_coupon(coupon)) return results"},{"question":"from typing import List, Tuple def find_movie_sequence(n: int, m: int, relationships: List[Tuple[int, int]], q: int, queries: List[Tuple[int, int]]) -> List[str]: Given a set of movies with sequel relationships and queries, determine if there is a possible sequence of suggested movies for each query. >>> n = 5 >>> m = 4 >>> relationships = [(1, 2), (2, 3), (3, 4), (4, 5)] >>> q = 3 >>> queries = [(1, 5), (2, 4), (4, 1)] >>> find_movie_sequence(n, m, relationships, q, queries) ['Yes', 'Yes', 'No'] >>> n = 2 >>> m = 0 >>> relationships = [] >>> q = 1 >>> queries = [(1, 2)] >>> find_movie_sequence(n, m, relationships, q, queries) ['No']","solution":"def find_movie_sequence(n, m, relationships, q, queries): from collections import defaultdict, deque # Create a graph from relationships graph = defaultdict(list) for u, v in relationships: graph[u].append(v) # Use BFS to determine the reachability for each query def is_reachable(x, y): if x == y: return True visited = set() queue = deque([x]) while queue: current = queue.popleft() if current == y: return True for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return False results = [] for x, y in queries: if is_reachable(x, y): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"from typing import List def min_weight_difference(stones: List[int]) -> int: Finds the minimum possible difference between the total weights of two piles of stones. >>> min_weight_difference([1, 2, 3, 4, 5]) 1 >>> min_weight_difference([10]) 10 >>> min_weight_difference([10, 10]) 0 >>> min_weight_difference([15, 10]) 5 >>> min_weight_difference([3, 1, 4, 2, 2]) 0 >>> min_weight_difference([6, 9, 4, 7, 3]) 1 >>> min_weight_difference([2, 3, 7, 1, 4, 5]) 0","solution":"from typing import List def min_weight_difference(stones: List[int]) -> int: total_weight = sum(stones) n = len(stones) # Initialize dp array dp = [[False] * (total_weight // 2 + 1) for _ in range(n + 1)] # Base case dp[0][0] = True # Process each stone for i in range(1, n + 1): for j in range(total_weight // 2 + 1): dp[i][j] = dp[i - 1][j] if j >= stones[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - stones[i - 1]] # Find the maximum possible weight close to total_weight / 2 for j in range(total_weight // 2, -1, -1): if dp[n][j]: return total_weight - 2 * j"},{"question":"def min_operations(n: int, k: int, m: int, initial: List[int], final: List[int], operations: List[Tuple[int, int, int]]) -> int: Determine the minimum number of operations required to transform the initial state into the desired final pattern. Args: n (int): number of sections in the garden k (int): number of different flower types m (int): number of operations available initial (List[int]): initial state of the garden final (List[int]): desired final pattern operations (List[Tuple[int, int, int]]): available operations (l, r, f) Returns: int: The minimum number of operations required or -1 if impossible >>> min_operations(5, 3, 4, [0, 1, 2, 2, 1], [2, 2, 2, 3, 2], [(1, 2, 2), (3, 5, 2), (1, 5, 3), (4, 5, 2)]) 2 >>> min_operations(3, 2, 2, [1, 0, 1], [1, 0, 1], [(1, 3, 0), (1, 3, 1)]) 0 >>> min_operations(4, 2, 1, [0, 0, 0, 0], [1, 1, 1, 1], [(1, 4, 1)]) 1 >>> min_operations(3, 2, 2, [0, 0, 0], [1, 1, 1], [(1, 1, 1), (3, 3, 1)]) -1","solution":"def min_operations(n, k, m, initial, final, operations): dp = [-1] * n if initial[0] == final[0]: dp[0] = 0 else: for l, r, f in operations: if l == 1 and r == 1 and f == final[0]: dp[0] = 1 for i in range(1, n): if initial[i] == final[i]: dp[i] = dp[i-1] else: min_operations_i = float('inf') for l, r, f in operations: if l <= i+1 <= r and f == final[i]: if l == 1: min_operations_i = min(min_operations_i, 1) elif dp[l-2] != -1: min_operations_i = min(min_operations_i, dp[l-2]+1) if min_operations_i == float('inf'): dp[i] = -1 else: dp[i] = min_operations_i return dp[-1]"},{"question":"def numDistinct(s: str, t: str) -> int: Determine the number of distinct subsequences of s that equal the target string t. Args: s (str): Source string consisting of lowercase English letters. t (str): Target string also consisting of lowercase English letters. Returns: int: The number of distinct subsequences of s that equal t, modulo 10^9 + 7. >>> numDistinct(\\"rabbbit\\", \\"rabbit\\") 3 >>> numDistinct(\\"babgbag\\", \\"bag\\") 5 >>> numDistinct(\\"\\", \\"anystring\\") 0 >>> numDistinct(\\"anystring\\", \\"\\") 1 >>> numDistinct(\\"abc\\", \\"abc\\") 1 >>> numDistinct(\\"ababc\\", \\"abc\\") 3 >>> numDistinct(\\"abc\\", \\"def\\") 0","solution":"MOD = 10**9 + 7 def numDistinct(s, t): m, n = len(s), len(t) if n == 0: return 1 if m == 0: return 0 # dp[i][j] will be storing the count of subsequences of s[0..i-1] that equals t[0..j-1] dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 1 for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] dp[i][j] %= MOD return dp[m][n]"},{"question":"import re def is_strong_password(password: str) -> str: Determines if the input password is strong based on the given criteria. Criteria: 1. At least 8 characters long. 2. Contains at least one uppercase letter. 3. Contains at least one lowercase letter. 4. Contains at least one digit. 5. Contains at least one special character from the set: \`!@#%^&*()-+\`. Returns: 'YES' if the password meets all criteria, otherwise 'NO'. >>> is_strong_password(\\"Password123!\\") \\"YES\\" >>> is_strong_password(\\"weakpass\\") \\"NO\\" # Unit Tests def test_password_too_short(): assert is_strong_password('Abc1!') == 'NO' def test_missing_uppercase(): assert is_strong_password('abc12345!') == 'NO' def test_missing_lowercase(): assert is_strong_password('ABC12345!') == 'NO' def test_missing_digit(): assert is_strong_password('Abcdefgh!') == 'NO' def test_missing_special_character(): assert is_strong_password('Abcdefgh1') == 'NO' def test_strong_password(): assert is_strong_password('Password123!') == 'YES' assert is_strong_password('A1b2C3d4!@') == 'YES' def test_edge_cases(): assert is_strong_password('A1b2C3d4!') == 'YES' assert is_strong_password('A1!@#%^a') == 'YES'","solution":"import re def is_strong_password(password): Determines if the input password is strong based on the given criteria. Criteria: 1. At least 8 characters long. 2. Contains at least one uppercase letter. 3. Contains at least one lowercase letter. 4. Contains at least one digit. 5. Contains at least one special character from the set: \`!@#%^&*()-+\`. Returns: 'YES' if the password meets all criteria, otherwise 'NO'. if len(password) < 8: return 'NO' if not re.search(r\\"[A-Z]\\", password): return 'NO' if not re.search(r\\"[a-z]\\", password): return 'NO' if not re.search(r\\"d\\", password): return 'NO' if not re.search(r\\"[!@#%^&*()-+]\\", password): return 'NO' return 'YES'"},{"question":"from typing import List, Tuple def find_manhattan_distances(R: int, C: int, queries: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> List[int]: Computes the Manhattan distance for each query. :param R: Number of rows in the warehouse. :param C: Number of columns in the warehouse. :param queries: List of queries where each query is a tuple of coordinates. :return: List of Manhattan distances for each query. >>> find_manhattan_distances(3, 4, [((1, 1), (2, 3)), ((3, 4), (1, 1)), ((2, 2), (2, 2))]) [3, 5, 0] >>> find_manhattan_distances(5, 5, [((1, 1), (1, 5)), ((3, 2), (3, 4))]) [4, 2] >>> find_manhattan_distances(5, 5, [((1, 1), (5, 1)), ((2, 3), (4, 3))]) [4, 2] >>> find_manhattan_distances(10, 10, [((1, 1), (10, 10)), ((5, 5), (6, 7)), ((2, 3), (8, 3)), ((4, 4), (4, 4))]) [18, 3, 6, 0] >>> find_manhattan_distances(1, 1, [((1, 1), (1, 1))]) [0]","solution":"from typing import List, Tuple def find_manhattan_distances(R: int, C: int, queries: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> List[int]: Computes the Manhattan distance for each query. :param R: Number of rows in the warehouse. :param C: Number of columns in the warehouse. :param queries: List of queries where each query is a tuple of coordinates. :return: List of Manhattan distances for each query. distances = [] for (r1, c1), (r2, c2) in queries: distance = abs(r1 - r2) + abs(c1 - c2) distances.append(distance) return distances"},{"question":"class Grid: def __init__(self, n, m): Initializes a grid of size n x m with all values set to zero. self.n, self.m = n, m self.grid = [[0] * m for _ in range(n)] def update(self, r, c, v): Updates the value at position (r, c) to v. self.grid[r-1][c-1] = v def sum_region(self, r1, c1, r2, c2): Calculates the sum of the region from (r1, c1) to (r2, c2) inclusive. >>> grid = Grid(3, 3) >>> grid.update(1, 1, 5) >>> grid.update(2, 3, 7) >>> grid.sum_region(1, 1, 2, 3) 12 >>> grid.update(3, 3, 10) >>> grid.sum_region(1, 1, 3, 3) 22 sum_val = 0 for i in range(r1-1, r2): for j in range(c1-1, c2): sum_val += self.grid[i][j] return sum_val def process_queries(n, m, q, queries): Processes a list of queries on an n x m grid. >>> process_queries(3, 3, 5, [[1, 1, 1, 5], [1, 2, 3, 7], [2, 1, 1, 2, 3], [1, 3, 3, 10], [2, 1, 1, 3, 3]]) [12, 22] >>> process_queries(2, 2, 2, [[1, 1, 1, 8], [2, 1, 1, 2, 2]]) [8] >>> process_queries(2, 2, 3, [[1, 1, 1, 8], [1, 1, 1, 5], [2, 1, 1, 2, 2]]) [5] >>> process_queries(3, 3, 4, [[1, 1, 1, 2], [1, 2, 2, 3], [1, 3, 3, 4], [2, 1, 1, 3, 3]]) [9] >>> process_queries(3, 3, 1, [[2, 1, 1, 3, 3]]) [0] >>> process_queries(4, 4, 6, [[1, 1, 1, 10], [1, 2, 2, 20], [1, 3, 3, 30], [1, 4, 4, 40], [2, 1, 1, 4, 4], [2, 1, 1, 2, 2]]) [100, 30] grid = Grid(n, m) results = [] for query in queries: if query[0] == 1: _, r, c, v = query grid.update(r, c, v) elif query[0] == 2: _, r1, c1, r2, c2 = query results.append(grid.sum_region(r1, c1, r2, c2)) return results","solution":"class Grid: def __init__(self, n, m): self.n, self.m = n, m self.grid = [[0] * m for _ in range(n)] def update(self, r, c, v): self.grid[r-1][c-1] = v def sum_region(self, r1, c1, r2, c2): sum_val = 0 for i in range(r1-1, r2): for j in range(c1-1, c2): sum_val += self.grid[i][j] return sum_val def process_queries(n, m, q, queries): grid = Grid(n, m) results = [] for query in queries: if query[0] == 1: _, r, c, v = query grid.update(r, c, v) elif query[0] == 2: _, r1, c1, r2, c2 = query results.append(grid.sum_region(r1, c1, r2, c2)) return results"},{"question":"from typing import List def matrix_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Multiplies two square matrices and returns the resulting matrix. >>> matrix1 = [ [1, 2], [3, 4] ] >>> matrix2 = [ [5, 6], [7, 8] ] >>> matrix_multiply(matrix1, matrix2) [ [19, 22], [43, 50] ] pass # Implement the matrix multiplication logic here","solution":"from typing import List def matrix_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Multiplies two square matrices and returns the resulting matrix. Parameters: matrix1 (List[List[int]]): The first matrix. matrix2 (List[List[int]]): The second matrix. Returns: List[List[int]]: The resulting matrix after multiplication. n = len(matrix1) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"def longest_substring_with_k_distinct_chars(s: str, k: int) -> int: Implement a function that takes a string \`s\` and an integer \`k\` as its parameters. The function should return the length of the longest substring that contains exactly \`k\` distinct characters. If there is no such substring, return 0. >>> longest_substring_with_k_distinct_chars(\\"araaci\\", 2) 4 >>> longest_substring_with_k_distinct_chars(\\"araaci\\", 1) 2 >>> longest_substring_with_k_distinct_chars(\\"cbbebi\\", 3) 5 >>> longest_substring_with_k_distinct_chars(\\"cbbebi\\", 10) 0","solution":"def longest_substring_with_k_distinct_chars(s: str, k: int) -> int: if k == 0: return 0 start, max_len = 0, 0 char_frequency = {} for end in range(len(s)): right_char = s[end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] start += 1 if len(char_frequency) == k: max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List, Tuple def remove_duplicates(records: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Remove duplicate records, keeping only the most recent one per ID. Parameters: records (List[Tuple[int, str]]): A list of tuples where each tuple contains an ID and a timestamp. Returns: List[Tuple[int, str]]: A list of tuples with unique IDs, keeping the most recent timestamp per ID. Example: >>> records = [ ... (1, \\"2023-01-01T10:00:00Z\\"), ... (2, \\"2023-01-01T11:00:00Z\\"), ... (1, \\"2023-01-02T10:00:00Z\\"), ... (3, \\"2023-01-01T09:00:00Z\\"), ... (2, \\"2023-01-03T11:00:00Z\\") ... ] >>> remove_duplicates(records) [(1, \\"2023-01-02T10:00:00Z\\"), (2, \\"2023-01-03T11:00:00Z\\"), (3, \\"2023-01-01T09:00:00Z\\")] >>> records = [ ... (1, \\"2023-01-01T10:00:00Z\\"), ... (2, \\"2023-01-01T11:00:00Z\\"), ... (1, \\"2023-01-01T10:00:00Z\\"), ... (3, \\"2023-01-01T09:00:00Z\\"), ... (2, \\"2023-01-01T11:00:00Z\\") ... ] >>> remove_duplicates(records) [(1, \\"2023-01-01T10:00:00Z\\"), (2, \\"2023-01-01T11:00:00Z\\"), (3, \\"2023-01-01T09:00:00Z\\")] >>> records = [ ... (1, \\"2023-01-01T10:00:00Z\\"), ... (2, \\"2023-01-01T11:00:00Z\\"), ... (3, \\"2023-01-02T10:00:00Z\\") ... ] >>> remove_duplicates(records) [(1, \\"2023-01-01T10:00:00Z\\"), (2, \\"2023-01-01T11:00:00Z\\"), (3, \\"2023-01-02T10:00:00Z\\")] >>> records = [(1, \\"2023-01-01T10:00:00Z\\")] >>> remove_duplicates(records) [(1, \\"2023-01-01T10:00:00Z\\")] >>> records = [] >>> remove_duplicates(records) []","solution":"from typing import List, Tuple from datetime import datetime def remove_duplicates(records: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Remove duplicate records, keeping only the most recent one per ID. Parameters: records (List[Tuple[int, str]]): A list of tuples where each tuple contains an ID and a timestamp. Returns: List[Tuple[int, str]]: A list of tuples with unique IDs, keeping the most recent timestamp per ID. latest_records = {} for record_id, timestamp in records: dt_timestamp = datetime.fromisoformat(timestamp.rstrip('Z')) if record_id not in latest_records or dt_timestamp > latest_records[record_id][0]: latest_records[record_id] = (dt_timestamp, timestamp) result = [(record_id, data[1]) for record_id, data in latest_records.items()] return result"},{"question":"def create_distinct_sum(m: int) -> (int, List[int]): Your task is to help Suzie create a list of distinct positive integers whose sum is equal to a given number m. The list should be as long as possible. Example: >>> k, numbers = create_distinct_sum(15) >>> k 5 >>> numbers [1, 2, 3, 4, 5]","solution":"def create_distinct_sum(m): k = 0 numbers = [] current_sum = 0 i = 1 while current_sum + i <= m: numbers.append(i) current_sum += i i += 1 if current_sum < m: numbers[-1] += (m - current_sum) return len(numbers), numbers"},{"question":"def can_player1_win(arr: List[int]) -> str: Determines if Player 1 can force a win in the game The game rules are as follows: 1. A player can choose any subarray (a contiguous part of the array) and either: - Reverse the subarray - Increment all elements in the subarray by 1. 2. The game ends when there are no valid moves left, that is, when all the elements in the array are in non-decreasing order. The first player to start the game is Player 1. Parameters: arr (List[int]): The initial array of integers. Returns: str: \\"WIN\\" if Player 1 can force a win, otherwise \\"LOSE\\". >>> can_player1_win([1]) \\"LOSE\\" >>> can_player1_win([1, 2, 3, 4, 5]) \\"LOSE\\" >>> can_player1_win([1, 3, 2, 5, 4]) \\"WIN\\" >>> can_player1_win([5, 4, 3, 2, 1]) \\"WIN\\" >>> can_player1_win([3, 1, 4, 1, 5]) \\"WIN\\" >>> can_player1_win([1, 2]) \\"LOSE\\" >>> can_player1_win([2, 1]) \\"WIN\\" >>> can_player1_win([1, 2, 3, 5, 4]) \\"WIN\\" >>> can_player1_win(list(range(1, 100001))) \\"LOSE\\" >>> can_player1_win([i for i in range(1, 100001)] + [100000, 99999]) \\"WIN\\"","solution":"def can_player1_win(arr): Determines if Player 1 can force a win in the game # Check if the array is sorted in non-decreasing order n = len(arr) for i in range(n - 1): if arr[i] > arr[i + 1]: return \\"WIN\\" # The array is not sorted, Player 1 can make a move return \\"LOSE\\" # The array is already sorted"},{"question":"from typing import List def calculate_point_difference(n: int, m: int, red_strengths: List[int], blue_strengths: List[int]) -> int: Calculate the difference in total points between the Red army and the Blue army based on their soldiers' combat strengths. >>> calculate_point_difference(4, 3, [6, 7, 8, 10], [5, 5, 10]) 5 >>> calculate_point_difference(3, 3, [1, 2, 3], [4, 5, 6]) -9 >>> calculate_point_difference(3, 3, [4, 5, 6], [1, 2, 3]) 9 >>> calculate_point_difference(4, 4, [1, 4, 6, 9], [2, 3, 7, 10]) -2 >>> calculate_point_difference(2, 2, [5, 5], [5, 5]) 0","solution":"def calculate_point_difference(n, m, red_strengths, blue_strengths): red_points = 0 blue_points = 0 for red in red_strengths: for blue in blue_strengths: if red > blue: red_points += 1 elif red < blue: blue_points += 1 return red_points - blue_points"},{"question":"def can_visit_all_locations(n: int, locations: List[int]) -> str: Determine if it is possible to visit every location starting from the first location without visiting any location more than once. Input Specification: - n (int): length of the array. - locations (List[int]): n space-separated integers representing the indices in the array to which the hunter will be directed. Output Specification: - Returns yes if it is possible to visit each location exactly once starting from the first location; otherwise, return no. Example: >>> can_visit_all_locations(5, [2, 3, 4, 5, 1]) 'YES' >>> can_visit_all_locations(5, [2, 3, 1, 5, 4]) 'NO' pass # Test cases to validate the solution def test_example_1(): assert can_visit_all_locations(5, [2, 3, 4, 5, 1]) == \\"YES\\" def test_example_2(): assert can_visit_all_locations(5, [2, 3, 1, 5, 4]) == \\"NO\\" def test_single_location(): assert can_visit_all_locations(1, [1]) == \\"YES\\" def test_two_locations_yes(): assert can_visit_all_locations(2, [2, 1]) == \\"YES\\" def test_two_locations_no(): assert can_visit_all_locations(2, [1, 1]) == \\"NO\\" def test_not_visiting_all_locations(): assert can_visit_all_locations(4, [2, 3, 1, 4]) == \\"NO\\"","solution":"def can_visit_all_locations(n, locations): visited = set() current = 0 # start from the first location for _ in range(n): if current in visited: return \\"NO\\" visited.add(current) current = locations[current] - 1 # move to the next location return \\"YES\\" if len(visited) == n else \\"NO\\""},{"question":"def longest_substring_same_char_after_k_removals(s: str, k: int) -> int: Returns the length of the longest substring with the same character after removing at most k characters. >>> longest_substring_same_char_after_k_removals(\\"aaaaa\\", 0) 5 >>> longest_substring_same_char_after_k_removals(\\"a\\", 0) 1 >>> longest_substring_same_char_after_k_removals(\\"abcde\\", 0) 1 >>> longest_substring_same_char_after_k_removals(\\"aabccbb\\", 2) 5 >>> longest_substring_same_char_after_k_removals(\\"abbcb\\", 1) 4 >>> longest_substring_same_char_after_k_removals(\\"abccde\\", 1) 3 >>> longest_substring_same_char_after_k_removals(\\"aabccbb\\", 7) 7 >>> longest_substring_same_char_after_k_removals(\\"aabbcc\\", 5) 6 >>> longest_substring_same_char_after_k_removals(\\"\\", 0) 0 >>> longest_substring_same_char_after_k_removals(\\"a\\", 10) 1 >>> longest_substring_same_char_after_k_removals(\\"abcde\\", 5) 5 # Placeholder for the implementation pass","solution":"def longest_substring_same_char_after_k_removals(s, k): Returns the length of the longest substring with the same character after removing at most k characters. max_length = 0 window_start = 0 max_char_count = 0 char_count = {} for window_end in range(len(s)): right_char = s[window_end] if right_char not in char_count: char_count[right_char] = 0 char_count[right_char] += 1 # Track the count of the most frequent character in the current window max_char_count = max(max_char_count, char_count[right_char]) # If the number of characters to remove exceeds k, shrink the window if (window_end - window_start + 1 - max_char_count) > k: left_char = s[window_start] char_count[left_char] -= 1 window_start += 1 # update the length of the longest substring max_length = max(max_length, window_end - window_start + 1) return max_length # Sample usage: # print(longest_substring_same_char_after_k_removals(\\"aabccbb\\", 2)) # should print 5"},{"question":"def max_distance_between_shops(n: int, coordinates: List[int]) -> int: Returns the maximum distance between any two shops based on their coordinates. Parameters: n (int): The number of shops. coordinates (List[int]): The list of x-coordinates of the shops. Returns: int: The maximum distance between any two shops. Examples: >>> max_distance_between_shops(5, [-3, 7, 9, -1, 2]) 12 >>> max_distance_between_shops(4, [-10, -20, -30, -40]) 30","solution":"def max_distance_between_shops(n, coordinates): Returns the maximum distance between any two shops based on their coordinates. min_coord = min(coordinates) max_coord = max(coordinates) return abs(max_coord - min_coord) # Example usage: n = 5 coordinates = [-3, 7, 9, -1, 2] print(max_distance_between_shops(n, coordinates)) # Output: 12"},{"question":"def max_length_subarray_with_abs_diff_one(n: int, arr: List[int]) -> int: Returns the maximum length of a subarray where the absolute difference between any two elements is less than or equal to 1. >>> max_length_subarray_with_abs_diff_one(6, [1, 2, 2, 3, 1, 2]) 5 >>> max_length_subarray_with_abs_diff_one(5, [1, 1, 1, 1, 1]) 5 >>> max_length_subarray_with_abs_diff_one(4, [1, 3, 5, 7]) 1 >>> max_length_subarray_with_abs_diff_one(2, [1, 2]) 2 >>> max_length_subarray_with_abs_diff_one(5, [10, 11, 10, 10, 11]) 5 >>> max_length_subarray_with_abs_diff_one(1, [1]) 1 pass","solution":"def max_length_subarray_with_abs_diff_one(n, arr): Returns the maximum length of a subarray where the absolute difference between any two elements is less than or equal to 1. from collections import Counter max_length = 0 count = Counter(arr) for x in count: max_length = max(max_length, count[x] + count.get(x + 1, 0)) return max_length"},{"question":"from typing import List, Tuple def min_tour_time(n: int, m: int, paths: List[Tuple[int, int, int]]) -> int: Find the minimum possible time required to complete the tour visiting all checkpoints exactly once starting and ending at any checkpoint. >>> min_tour_time(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> min_tour_time(3, 0, []) -1 >>> min_tour_time(4, 3, [(1, 2, 10), (2, 3, 20), (4, 1, 30)]) -1 >>> min_tour_time(3, 3, [(1, 2, 10), (2, 3, 20), (3, 1, 15)]) 45 >>> min_tour_time(4, 6, [(1, 2, 10), (1, 3, 10), (1, 4, 10), (2, 3, 10), (2, 4, 10), (3, 4, 10)]) 40 >>> min_tour_time(4, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10)]) 40","solution":"from itertools import permutations def min_tour_time(n, m, paths): # Create adjacency matrix for the graph inf = float('inf') graph = [[inf] * n for _ in range(n)] for a, b, t in paths: graph[a-1][b-1] = t graph[b-1][a-1] = t # Check for isolated nodes for i in range(n): if all(graph[i][j] == inf for j in range(n)): return -1 min_time = inf # Calculate all permutations of nodes for perm in permutations(range(1, n)): curr_time = 0 prev_node = 0 # Start from node 0 for node in perm: if graph[prev_node][node] == inf: curr_time = inf break curr_time += graph[prev_node][node] prev_node = node if graph[prev_node][0] != inf: curr_time += graph[prev_node][0] else: curr_time = inf min_time = min(min_time, curr_time) if min_time == inf: return -1 return min_time"},{"question":"def max_min_after_operations(n:int, a:List[int]) -> int: Determine the maximum possible value of the minimum element in the array after performing any number of the allowed operations. Parameters: n (int): The length of the array. a (list[int]): The array of integers. Returns: int: The maximum possible value of the minimum element. >>> max_min_after_operations(4, [2, 3, 4, 5]) 3 >>> max_min_after_operations(3, [1, 1, 1]) 1","solution":"def max_min_after_operations(n, a): Returns the maximum possible value of the minimum element after performing the allowed operations. Parameters: n (int): The length of the array. a (list[int]): The array of integers. Returns: int: The maximum possible value of the minimum element. total_sum = sum(a) if total_sum % n == 0: return total_sum // n else: return total_sum // n"},{"question":"def min_moves_to_equal_scores(n: int, scores: List[int]) -> int: Returns the minimum number of moves needed to make all players' scores the same. Parameters: n (int): Number of players. scores (list of int): List of players' scores. Returns: int: Minimum number of moves needed. >>> min_moves_to_equal_scores(3, [1, 2, 3]) 2 >>> min_moves_to_equal_scores(4, [4, 4, 4, 4]) 0","solution":"def min_moves_to_equal_scores(n, scores): Returns the minimum number of moves needed to make all players' scores the same. Parameters: n (int): Number of players. scores (list of int): List of players' scores. Returns: int: Minimum number of moves needed. median_score = sorted(scores)[n // 2] moves = sum(abs(score - median_score) for score in scores) return moves"},{"question":"def max_remaining_height(n, heights): Given the initial heights of all trees, find out the maximum possible height that any tree can have just after one visit from a woodpecker. Args: n (int): Number of trees. heights (list): List of initial heights of the trees. Returns: int: Maximum possible height of the remaining trees after woodpecker visit. >>> max_remaining_height(5, [4, 8, 6, 7, 3]) 8 >>> max_remaining_height(1, [10]) 0 >>> max_remaining_height(3, [5, 5, 5]) 5 >>> max_remaining_height(4, [1, 2, 3, 4]) 4 >>> max_remaining_height(4, [1, 1, 1, 1]) 1 >>> max_remaining_height(100_000, [10_000] * 100_000) 10_000","solution":"def max_remaining_height(n, heights): Given the initial heights of all trees, find out the maximum possible height that any tree can have just after one visit from a woodpecker. Args: n (int): Number of trees. heights (list): List of initial heights of the trees. Returns: int: Maximum possible height of the remaining trees after woodpecker visit. if n == 1: return 0 # If there's only one tree, after damaging it, the maximum height will be zero. max_height = max(heights) return max_height"},{"question":"def longest_increasing_subsequence_length(n: int, sequence: List[int]) -> int: Computes the length of the longest contiguous strictly increasing subsequence. Parameters: n (int): The length of the sequence. sequence (list): A list of integers representing the sequence. Returns: int: The length of the longest contiguous strictly increasing subsequence. >>> longest_increasing_subsequence_length(6, [1, 2, 2, 4, 3, 5]) 2 >>> longest_increasing_subsequence_length(5, [1, 2, 3, 4, 5]) 5 from typing import List def test_case_1(): assert longest_increasing_subsequence_length(6, [1, 2, 2, 4, 3, 5]) == 2 def test_case_2(): assert longest_increasing_subsequence_length(5, [1, 2, 3, 4, 5]) == 5 def test_case_3(): assert longest_increasing_subsequence_length(7, [3, 4, 1, 2, 3, 4, 5]) == 5 def test_case_4(): assert longest_increasing_subsequence_length(4, [4, 3, 2, 1]) == 1 def test_case_5(): assert longest_increasing_subsequence_length(1, [100]) == 1 def test_case_6(): assert longest_increasing_subsequence_length(8, [10, 11, 12, 9, 10, 11, 8, 9]) == 3 def test_case_7(): assert longest_increasing_subsequence_length(0, []) == 0","solution":"def longest_increasing_subsequence_length(n, sequence): Computes the length of the longest contiguous strictly increasing subsequence. Parameters: n (int): The length of the sequence. sequence (list): A list of integers representing the sequence. Returns: int: The length of the longest contiguous strictly increasing subsequence. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if sequence[i] > sequence[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def almost_increasing_sequence(n: int) -> list: Construct an almost increasing sequence of length n, consisting of distinct integers from 1 to 2n. If it is impossible to create such a sequence, return [-1]. >>> almost_increasing_sequence(1) [1] >>> almost_increasing_sequence(2) A valid sequence with 2 elements where 1 <= ai <= 4 >>> almost_increasing_sequence(3) A valid sequence with 3 elements where 1 <= ai <= 6 >>> almost_increasing_sequence(10) A valid sequence with 10 elements where 1 <= ai <= 20 >>> almost_increasing_sequence(100) A valid sequence with 100 elements where 1 <= ai <= 200 >>> almost_increasing_sequence(-1) -1","solution":"def almost_increasing_sequence(n): if n == 1: return [1] if n > 1: seq = [] for i in range(1, n+1): if i % 2 == 0: seq.append(i + n) else: seq.append(i) return seq return -1"},{"question":"def shortest_path(n, q, supervisors, queries): Given the number of employees, the number of queries, the supervisors array, and a list of queries, return the shortest communication path between employees for each query. >>> shortest_path(5, 3, [1, 1, 2, 2], [(3, 4), (4, 5), (2, 5)]) [3, 2, 1] >>> shortest_path(6, 2, [1, 1, 2, 3, 3], [(4, 6), (2, 5)]) [4, 3]","solution":"def shortest_path(n, q, supervisors, queries): from collections import defaultdict, deque # Creating the tree tree = defaultdict(list) for i in range(n - 1): supervisor = supervisors[i] employee = i + 2 tree[supervisor].append(employee) tree[employee].append(supervisor) def bfs(start, end): queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: node, distance = queue.popleft() if node == end: return distance for neighbor in tree[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) results = [] for u, v in queries: results.append(bfs(u, v)) return results"},{"question":"class ParkingLotManager: def __init__(self, n, m, initial_spaces): Initialize the parking lot manager with n parking lots and maximum m spaces per lot. Parameters: n (int): Number of parking lots m (int): Maximum number of parking spaces in any parking lot initial_spaces (List[int]): Initial number of available spaces in each parking lot def allocate(self, lot_index): Allocate the first available parking space in the given parking lot. Parameters: lot_index (int): Index of the parking lot Returns: int: The allocated parking space number, or -1 if no space is available def deallocate(self, lot_index, space_index): Deallocate the given parking space in the given parking lot. Parameters: lot_index (int): Index of the parking lot space_index (int): Index of the parking space to deallocate def query(self, lot_index): Query the number of available parking spaces in the given parking lot. Parameters: lot_index (int): Index of the parking lot Returns: int: Number of available parking spaces def main(n, m, initial_spaces, operations): Execute a series of parking lot operations. Parameters: n (int): Number of parking lots m (int): Maximum number of parking spaces in any parking lot initial_spaces (List[int]): Initial number of available spaces in each parking lot operations (List[Tuple[int, int, int]]): List of operations (1: allocate, 2: deallocate, 3: query) Returns: List[int]: Results of all query operations # Unit tests def test_parking_lot_manager(): n = 3 m = 5 initial_spaces = [1, 3, 2] operations = [ (1, 2, 0), # Allocate in 2nd parking lot (1, 2, 0), # Allocate in 2nd parking lot again (2, 2, 1), # Deallocate space 1 in 2nd parking lot (3, 2, 0) # Query available spaces in 2nd parking lot ] expected_output = [2] assert main(n, m, initial_spaces, operations) == expected_output def test_entire_lot_allocation_deallocation(): n = 1 m = 3 initial_spaces = [3] # All 3 spaces available initially operations = [ (1, 1, 0), # Allocate (1, 1, 0), # Allocate (1, 1, 0), # Allocate (3, 1, 0), # Query (2, 1, 2), # Deallocate space 2 (3, 1, 0), # Query (1, 1, 0), # Allocate (3, 1, 0) # Query ] expected_output = [0, 1, 0] assert main(n, m, initial_spaces, operations) == expected_output def test_no_initial_spaces(): n = 2 m = 4 initial_spaces = [0, 0] operations = [ (1, 1, 0), # Allocate in first parking lot, should not work (1, 2, 0), # Allocate in second parking lot, should not work (3, 1, 0), # Query in first parking lot (3, 2, 0) # Query in second parking lot ] expected_output = [0, 0] assert main(n, m, initial_spaces, operations) == expected_output","solution":"class ParkingLotManager: def __init__(self, n, m, initial_spaces): self.parking_lots = [{'total_spaces': m, 'available_spaces': initial_spaces[i], 'allocated': set()} for i in range(n)] def allocate(self, lot_index): if self.parking_lots[lot_index]['available_spaces'] > 0: available_space = min(set(range(1, self.parking_lots[lot_index]['total_spaces']+1)) - self.parking_lots[lot_index]['allocated']) self.parking_lots[lot_index]['allocated'].add(available_space) self.parking_lots[lot_index]['available_spaces'] -= 1 return available_space return -1 # No available space def deallocate(self, lot_index, space_index): if space_index in self.parking_lots[lot_index]['allocated']: self.parking_lots[lot_index]['allocated'].remove(space_index) self.parking_lots[lot_index]['available_spaces'] += 1 def query(self, lot_index): return self.parking_lots[lot_index]['available_spaces'] def main(n, m, initial_spaces, operations): manager = ParkingLotManager(n, m, initial_spaces) results = [] for op in operations: if op[0] == 1: manager.allocate(op[1]-1) elif op[0] == 2: manager.deallocate(op[1]-1, op[2]) elif op[0] == 3: results.append(manager.query(op[1]-1)) return results"},{"question":"def minimumCuts(heights): Returns the minimum number of cuts needed to make all cylinders the same height. :param heights: List[int] - a list of integers representing the initial heights of the cylinders :return: int - minimum number of cuts needed pass # Unit tests def test_case_1(): assert minimumCuts([4, 3, 1]) == 5 def test_case_2(): assert minimumCuts([5, 5, 5, 5]) == 0 def test_case_3(): assert minimumCuts([1, 2, 3, 4, 5]) == 10 def test_case_4(): assert minimumCuts([10, 10, 10, 10, 10, 10, 1]) == 54 def test_case_5(): assert minimumCuts([1000000000, 999999999, 999999998]) == 3 def test_case_6(): assert minimumCuts([1]) == 0 def test_case_with_large_numbers(): assert minimumCuts([1000000000, 1000000000, 1000000000]) == 0 def test_case_with_all_different(): assert minimumCuts([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 45","solution":"def minimumCuts(heights): Returns the minimum number of cuts needed to make all cylinders the same height. min_height = min(heights) total_cuts = sum(height - min_height for height in heights) return total_cuts"},{"question":"def min_operations_to_equalize_grid(grid: List[List[int]]) -> int: Determine the minimum number of operations needed to make all values in the grid equal. >>> min_operations_to_equalize_grid([ ... [1, 2, 3], ... [4, 5, 6] ... ]) == 5 >>> min_operations_to_equalize_grid([ ... [1, 1, 1], ... [1, 1, 1] ... ]) == 0 >>> min_operations_to_equalize_grid([[10]]) == 0 >>> min_operations_to_equalize_grid([ ... [2, 4, 1], ... [3, 6, 2], ... [0, 1, 3] ... ]) == 6 >>> min_operations_to_equalize_grid([ ... [1000, 1000], ... [0, 0] ... ]) == 1000","solution":"def min_operations_to_equalize_grid(grid): Determine the minimum number of operations needed to make all values in the grid equal. m = len(grid) n = len(grid[0]) # Flatten the grid to make calculations easier. flat_grid = [grid[i][j] for i in range(m) for j in range(n)] # Find the maximum value and minimum value in the entire grid. max_value = max(flat_grid) min_value = min(flat_grid) return max_value - min_value"},{"question":"def count_subarrays_with_sum(fruits, K): Determines the number of contiguous subarrays that sum to exactly K. Parameters: fruits (list): List of integers representing the number of fruits on each tree. K (int): The target sum for the contiguous subarrays. Returns: int: The number of contiguous subarrays that sum to exactly K. Examples: >>> count_subarrays_with_sum([1, 2, 3, 4, 5], 5) 2 >>> count_subarrays_with_sum([5], 5) 1 >>> count_subarrays_with_sum([-5], -5) 1 >>> count_subarrays_with_sum([3], 5) 0 >>> count_subarrays_with_sum([0, 0, 0, 0, 0], 0) 15 >>> count_subarrays_with_sum([1, 2, 3, 4, 5], 20) 0 >>> count_subarrays_with_sum([1, 2, 1, 2, 1], 3) 4 >>> count_subarrays_with_sum([100000, 200000, -300000, 500000, -100000], 300000) 2 >>> count_subarrays_with_sum([-1, -1, 1, 2, -1, -1], 0) 4","solution":"def count_subarrays_with_sum(fruits, K): Determines the number of contiguous subarrays that sum to exactly K. Parameters: fruits (list): List of integers representing the number of fruits on each tree. K (int): The target sum for the contiguous subarrays. Returns: int: The number of contiguous subarrays that sum to exactly K. from collections import defaultdict count = 0 current_sum = 0 sum_dict = defaultdict(int) sum_dict[0] = 1 for fruit in fruits: current_sum += fruit if (current_sum - K) in sum_dict: count += sum_dict[current_sum - K] sum_dict[current_sum] += 1 return count"},{"question":"def process_queries(n: int, m: int, queries: List[Tuple[int, int, int, int]]) -> List[List[int]]: Process a list of queries to increment sub-grid values in a grid of size n x m. n: number of rows in the grid m: number of columns in the grid queries: list of tuples representing the queries, each tuple contains four integers (x1, y1, x2, y2) defining the sub-grid corners. Returns the final state of the grid after processing all queries. >>> process_queries(3, 3, [(1, 1, 2, 2)]) [[1, 1, 0], [1, 1, 0], [0, 0, 0]] >>> process_queries(3, 3, [(1, 1, 2, 2), (2, 2, 3, 3)]) [[1, 1, 0], [1, 2, 1], [0, 1, 1]] >>> process_queries(2, 2, [(1, 1, 2, 2)]) [[1, 1], [1, 1]] >>> process_queries(3, 3, [(1, 1, 1, 1), (2, 2, 2, 2), (3, 3, 3, 3)]) [[1, 0, 0], [0, 1, 0], [0, 0, 1]] >>> process_queries(1, 1, [(1, 1, 1, 1)]) [[1]] >>> process_queries(3, 3, [(1, 1, 3, 3), (1, 1, 2, 2), (2, 2, 3, 3)]) [[2, 2, 1], [2, 3, 2], [1, 2, 2]]","solution":"def process_queries(n, m, queries): # Initialize n x m grid with zeros grid = [[0] * m for _ in range(n)] # Process each query for x1, y1, x2, y2 in queries: for i in range(x1-1, x2): for j in range(y1-1, y2): grid[i][j] += 1 return grid"},{"question":"def longest_subarray_with_at_most_two_distinct_values(n: int, arr: List[int]) -> int: Returns the length of the longest contiguous subarray containing at most two distinct integer values. >>> longest_subarray_with_at_most_two_distinct_values(6, [1, 2, 2, 1, 3, 4]) == 4 >>> longest_subarray_with_at_most_two_distinct_values(5, [5, 5, 5, 5, 5]) == 5","solution":"def longest_subarray_with_at_most_two_distinct_values(n, arr): Returns the length of the longest contiguous subarray containing at most two distinct integer values. left, right = 0, 0 count = {} max_length = 0 while right < n: if arr[right] not in count: count[arr[right]] = 0 count[arr[right]] += 1 while len(count) > 2: count[arr[left]] -= 1 if count[arr[left]] == 0: del count[arr[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def generate_pattern(n: int, positions: List[int]) -> List[str]: Generate an n x n grid pattern where each row and column has exactly one asterisk according to the given positions. n: int - the size of the grid positions: List[int] - the column positions of the asterisks in each row (1-indexed) Returns a list of strings representing the n x n grid. >>> generate_pattern(3, [2, 1, 3]) ['.*.', '*..', '..*'] >>> generate_pattern(1, [1]) ['*'] >>> generate_pattern(4, [1, 3, 4, 2]) ['*...', '..*.', '...*', '.*..'] >>> generate_pattern(5, [5, 3, 1, 2, 4]) ['....*', '..*..', '*....', '.*...', '...*.'] >>> generate_pattern(3, [3, 1, 2]) ['..*', '*..', '.*.']","solution":"def generate_pattern(n, positions): Generate an n x n grid pattern where each row and column has exactly one asterisk according to the given positions. n: int - the size of the grid positions: List[int] - the column positions of the asterisks in each row (1-indexed) Returns a list of strings representing the n x n grid. grid = [['.'] * n for _ in range(n)] for i in range(n): col = positions[i] - 1 grid[i][col] = '*' return [''.join(row) for row in grid]"},{"question":"import heapq from typing import List, Tuple def shortest_travel_time(N: int, M: int, routes: List[Tuple[int, int, int]], S: int, E: int) -> int: Determine the shortest travel time from a specified starting hub to a specified destination hub. >>> shortest_travel_time(5, 6, [(1, 2, 10), (1, 3, 5), (2, 3, 2), (2, 4, 1), (3, 4, 9), (4, 5, 4)], 1, 5) == 12 >>> shortest_travel_time(4, 4, [(1, 2, 3), (1, 3, 3), (2, 4, 4), (3, 4, 2)], 1, 4) == 5 >>> shortest_travel_time(3, 2, [(1, 2, 5), (2, 3, 10)], 1, 3) == 15 >>> shortest_travel_time(3, 1, [(1, 2, 5)], 1, 3) == -1 >>> shortest_travel_time(5, 6, [(1, 2, 10), (1, 3, 5), (2, 3, 2), (2, 4, 1), (3, 4, 9), (4, 5, 4)], 1, 1) == 0","solution":"import heapq def shortest_travel_time(N, M, routes, S, E): # Create adjacency list graph = {i: [] for i in range(1, N + 1)} for U, V, T in routes: graph[U].append((V, T)) graph[V].append((U, T)) # Dijkstra's algorithm to find the shortest path def dijkstra(start, end): pq = [(0, start)] # (distance, node) dist = {i: float('inf') for i in range(1, N + 1)} dist[start] = 0 while pq: current_dist, current_node = heapq.heappop(pq) if current_node == end: return current_dist if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 result = dijkstra(S, E) return result # Example usage N = 5 M = 6 routes = [ (1, 2, 10), (1, 3, 5), (2, 3, 2), (2, 4, 1), (3, 4, 9), (4, 5, 4) ] S = 1 E = 5 print(shortest_travel_time(N, M, routes, S, E)) # Should output 12"},{"question":"def longest_subarray_with_two_distinct(nums: List[int]) -> int: Returns the length of the longest contiguous subarray that contains at most two distinct integers. >>> longest_subarray_with_two_distinct([1, 2, 1, 3, 4, 2, 1, 2]) 3 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 3, 4, 4]) 4","solution":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest contiguous subarray that contains at most two distinct integers. if not nums: return 0 left = 0 max_length = 0 count = {} for right in range(len(nums)): count[nums[right]] = count.get(nums[right], 0) + 1 while len(count) > 2: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"class SegmentTree: def __init__(self, arr): Initialize the segment tree with a given array. pass def build(self, arr, node, start, end): Build the segment tree. pass def update(self, idx, val, node, start, end): Update the segment tree at a specific index. pass def query(self, L, R, node, start, end): Query the segment tree for the sum in the range [L, R]. pass def process_queries(n, q, arr, queries): Process multiple queries on the array. :param n: number of elements in the array :param q: number of queries :param arr: list of integers :param queries: list of queries as strings :return: list of results for sum queries Example: >>> n = 5 >>> q = 3 >>> arr = [1, 2, 3, 4, 5] >>> queries = [\\"2 1 3\\", \\"1 3 10\\", \\"2 2 5\\"] >>> print(process_queries(n, q, arr, queries)) [6, 21] pass # Unit tests import pytest def test_process_queries(): assert process_queries(5, 3, [1, 2, 3, 4, 5], [\\"2 1 3\\", \\"1 3 10\\", \\"2 2 5\\"]) == [6, 21] assert process_queries(6, 4, [1, 1, 1, 1, 1, 1], [\\"2 1 6\\", \\"1 4 5\\", \\"2 3 5\\", \\"2 1 3\\"]) == [6, 7, 3] assert process_queries(3, 2, [5, 5, 5], [\\"2 1 2\\", \\"1 2 10\\"]) == [10] assert process_queries(4, 3, [1, 3, 5, 7], [\\"2 2 4\\", \\"1 4 0\\", \\"2 1 3\\"]) == [15, 9] if __name__ == \\"__main__\\": pytest.main()","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (4 * self.n) self.build(arr, 0, 0, self.n - 1) def build(self, arr, node, start, end): if start == end: self.tree[node] = arr[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(arr, left_child, start, mid) self.build(arr, right_child, mid + 1, end) self.tree[node] = self.tree[left_child] + self.tree[right_child] def update(self, idx, val, node, start, end): if start == end: self.tree[node] = val else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= idx <= mid: self.update(idx, val, left_child, start, mid) else: self.update(idx, val, right_child, mid + 1, end) self.tree[node] = self.tree[left_child] + self.tree[right_child] def query(self, L, R, node, start, end): if R < start or end < L: return 0 if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 sum_left = self.query(L, R, left_child, start, mid) sum_right = self.query(L, R, right_child, mid + 1, end) return sum_left + sum_right # Translate given input to solve the problem def process_queries(n, q, arr, queries): tree = SegmentTree(arr) responses = [] for query in queries: parts = query.split() if parts[0] == '1': x = int(parts[1]) - 1 y = int(parts[2]) tree.update(x, y, 0, 0, n - 1) elif parts[0] == '2': l = int(parts[1]) - 1 r = int(parts[2]) - 1 responses.append(tree.query(l, r, 0, 0, n - 1)) return responses"},{"question":"def max_packages_delivered(n, robot_energies, m, package_demands): Calculate the maximum number of packages that can be delivered by the robots with given energy limits. Args: n (int): The number of robots. robot_energies (List[int]): List containing the energy limits of the robots. m (int): The number of packages. package_demands (List[int]): List containing the energy requirements of the packages. Returns: int: The maximum number of packages that can be delivered. Example: >>> max_packages_delivered(3, [4, 8, 5], 4, [9, 6, 2, 7]) 2 from solution import max_packages_delivered def test_example_case(): assert max_packages_delivered(3, [4, 8, 5], 4, [9, 6, 2, 7]) == 2 def test_all_packages_too_big(): assert max_packages_delivered(3, [4, 8, 5], 4, [10, 12, 15, 14]) == 0 def test_all_packages_delivered(): assert max_packages_delivered(3, [10, 20, 30], 3, [10, 5, 5]) == 3 def test_some_packages_delivered(): assert max_packages_delivered(3, [5, 15, 25], 5, [5, 10, 15, 20, 25]) == 3 def test_no_robots(): assert max_packages_delivered(0, [], 4, [1, 2, 3, 4]) == 0 def test_no_packages(): assert max_packages_delivered(3, [10, 20, 30], 0, []) == 0","solution":"def max_packages_delivered(n, robot_energies, m, package_demands): robot_energies.sort(reverse=True) package_demands.sort(reverse=True) delivered_packages = 0 j = 0 for i in range(m): if j < n and package_demands[i] <= robot_energies[j]: delivered_packages += 1 j += 1 return delivered_packages # Example usage n = 3 robot_energies = [4, 8, 5] m = 4 package_demands = [9, 6, 2, 7] print(max_packages_delivered(n, robot_energies, m, package_demands)) # Output: 2"},{"question":"def max_marbles_per_box(n: int, capacities: List[int], marble_sizes: List[int]) -> List[int]: Calculate the maximum number of marbles that can be placed in each box. Each box holds one type of marble. Capacities – List of the capacities of the boxes. Marble_sizes – List of the sizes of marbles for each box. >>> max_marbles_per_box(3, [15, 7, 20], [3, 4, 5]) [5, 1, 4] >>> max_marbles_per_box(4, [10, 10, 10, 10], [5, 2, 1, 10]) [2, 5, 10, 1] >>> max_marbles_per_box(3, [12, 30, 25], [3, 5, 2]) [4, 6, 12] >>> max_marbles_per_box(2, [1000000000, 2000000000], [2, 4]) [500000000, 500000000] >>> max_marbles_per_box(1, [50], [7]) [7] >>> max_marbles_per_box(3, [5, 10, 15], [1, 1, 1]) [5, 10, 15]","solution":"def max_marbles_per_box(n, capacities, marble_sizes): max_marbles = [] for i in range(n): max_marbles.append(capacities[i] // marble_sizes[i]) return max_marbles"},{"question":"def longest_ones_after_flips(n: int, k: int, s: str) -> int: Returns the length of the longest contiguous subsegment of 1s after performing at most k flips. >>> longest_ones_after_flips(7, 1, \\"1001101\\") 4 >>> longest_ones_after_flips(5, 3, \\"11111\\") 5 >>> longest_ones_after_flips(5, 2, \\"00000\\") 2 >>> longest_ones_after_flips(5, 2, \\"11110\\") 5 >>> longest_ones_after_flips(5, 5, \\"01010\\") 5 >>> longest_ones_after_flips(1, 0, \\"0\\") 0 >>> longest_ones_after_flips(1, 1, \\"0\\") 1 >>> longest_ones_after_flips(1, 0, \\"1\\") 1 >>> longest_ones_after_flips(6, 0, \\"010101\\") 1 >>> longest_ones_after_flips(100000, 50000, \\"1\\" * 50000 + \\"0\\" * 50000) 100000","solution":"def longest_ones_after_flips(n, k, s): Returns the length of the longest contiguous subsegment of 1s after performing at most k flips. left = 0 flips = 0 max_length = 0 for right in range(n): if s[right] == '0': flips += 1 while flips > k: if s[left] == '0': flips -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def can_be_almost_sorted(n: int, arr: List[int]) -> str: Determine if it is possible to create an almost sorted list by removing exactly one element. >>> can_be_almost_sorted(5, [1, 3, 2, 4, 5]) 'YES' >>> can_be_almost_sorted(4, [4, 3, 2, 1]) 'NO'","solution":"def can_be_almost_sorted(n, arr): def is_sorted(lst): return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1)) for i in range(n): if is_sorted(arr[:i] + arr[i+1:]): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def has_pair_with_sum(arr: List[int], k: int) -> bool: Determines if there is a pair of distinct elements in the array that adds up to k. :param arr: List of integers :param k: Target sum :return: True if such a pair exists, False otherwise >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False","solution":"from typing import List def has_pair_with_sum(arr: List[int], k: int) -> bool: Determines if there is a pair of distinct elements in the array that adds up to k. :param arr: List of integers :param k: Target sum :return: True if such a pair exists, False otherwise seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"from typing import List def count_pairs(nums: List[int], target: int) -> int: Returns the number of distinct pairs in nums that sum up to the target value. >>> count_pairs([1, 2, 3, 4, 5], 6) 2 >>> count_pairs([2, 4, 3, 5, 7, 8, 1], 9) 3 >>> count_pairs([1, 2], 3) 1 >>> count_pairs([1, 2, 3, 9], 20) 0 >>> count_pairs([1, 6, 5, 2, 7, 10, 3], 8) 3 >>> count_pairs([1, -2, 3, -4, 5], 1) 2","solution":"from typing import List def count_pairs(nums: List[int], target: int) -> int: Returns the number of distinct pairs in nums that sum up to the target value. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def compress_string(s: str) -> str: Compress the string \`s\` using the counts of repeated characters. If the compressed string is longer than or equal to the original, returns the original string. >>> compress_string(\\"aaabbbccc\\") 'a3b3c3' >>> compress_string(\\"abcd\\") 'abcd' >>> compress_string(\\"aaaa\\") 'a4' >>> compress_string(\\"AAAaaa\\") 'A3a3' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"\\") '' >>> compress_string(\\"ab\\" * 2500) 'ab' * 2500 >>> compress_string(\\"aabbbccccdddde\\") 'a2b3c4d4e1' >>> compress_string(\\"abbbccdeeeee\\") 'a1b3c2d1e5'","solution":"def compress_string(s): Compress the string \`s\` using the counts of repeated characters. If the compressed string is longer than or equal to the original, returns the original string. n = len(s) if n == 0: return s compressed = [] count = 1 for i in range(1, n): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < n else s"},{"question":"def categorize_recipes(n: int, recipes: List[Tuple[str, List[str]]]) -> List[str]: Categorize each recipe by its main ingredient. >>> categorize_recipes(2, [(\\"chicken\\", [\\"fry chicken\\", \\"boil water\\", \\"chop vegetables\\"]), ... (\\"beef\\", [\\"chop beef\\", \\"boil water\\", \\"fry beef\\", \\"bake potatoes\\"])]) [\\"chicken\\", \\"beef\\"] >>> categorize_recipes(1, [(\\"fish\\", [\\"grill fish\\", \\"season fish\\", \\"squeeze lemon\\"])]) [\\"fish\\"] >>> categorize_recipes(1, [(\\"beef\\", [\\"chop beef\\", \\"boil water\\", \\"fry water\\", \\"bake beef\\"])]) [\\"beef\\"] >>> categorize_recipes(1, [(\\"pasta\\", [\\"boil water\\", \\"add pasta\\", \\"stir sauce\\"])]) [\\"water\\"] >>> categorize_recipes(3, [(\\"chicken\\", [\\"fry chicken\\", \\"boil water\\", \\"chop vegetables\\"]), ... (\\"beef\\", [\\"chop beef\\", \\"boil water\\", \\"fry beef\\", \\"bake potatoes\\"]), ... (\\"fish\\", [\\"grill fish\\", \\"season fish\\", \\"squeeze lemon\\"])]) [\\"chicken\\", \\"beef\\", \\"fish\\"]","solution":"def categorize_recipes(n, recipes): def get_main_ingredient(recipe): _, processes = recipe ingredient_count = {} for process in processes: action, ingredient = process.split(' ', 1) if ingredient not in ingredient_count: ingredient_count[ingredient] = 0 ingredient_count[ingredient] += 1 main_ingredient = None max_count = 0 for process in processes: _, ingredient = process.split(' ', 1) if ingredient_count[ingredient] > max_count: max_count = ingredient_count[ingredient] main_ingredient = ingredient return main_ingredient result = [] for recipe in recipes: result.append(get_main_ingredient(recipe)) return result"},{"question":"from typing import List, Tuple def has_overlapping_tasks(tasks: List[Tuple[int, int]]) -> bool: Determine if any two tasks overlap. >>> has_overlapping_tasks([(1, 4), (3, 5), (5, 8)]) True >>> has_overlapping_tasks([(1, 3), (4, 6), (6, 8)]) False","solution":"from typing import List, Tuple def has_overlapping_tasks(tasks: List[Tuple[int, int]]) -> bool: # Sort tasks based on start times. If start times are the same, sort by end times tasks.sort(key=lambda x: (x[0], x[1])) for i in range(1, len(tasks)): # Compare current task's start time with the previous task's end time if tasks[i][0] < tasks[i - 1][1]: return True return False"},{"question":"from typing import List def is_path_exist(grid: List[List[int]], N: int, M: int) -> str: Determines if there exists a path from the top-left to the bottom-right of the grid. Args: - grid (List[List[int]]): the grid representation with '0' as unblocked and '1' as blocked cells. - N (int): the number of rows. - M (int): the number of columns. Returns: - str: \\"YES\\" if a path exists, otherwise \\"NO\\". >>> is_path_exist([[0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 1, 0, 0]], 4, 4) 'YES' >>> is_path_exist([[0, 1, 0], [1, 0, 1], [0, 1, 0]], 3, 3) 'NO' pass # Your code goes here","solution":"def is_path_exist(grid, N, M): Determines if there exists a path from the top-left to the bottom-right of the grid. if grid[0][0] == 1 or grid[N-1][M-1] == 1: return \\"NO\\" from collections import deque directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (N-1, M-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def longest_subsequence_with_diff(arr, d): Find the length of the longest subsequence such that the difference between any two adjacent elements is at most d. >>> longest_subsequence_with_diff([1, 3, 6, 7, 9], 2) 3 >>> longest_subsequence_with_diff([1, 2, 3, 4], 1) 4 >>> longest_subsequence_with_diff([1, 10, 20, 30], 1) 1 >>> longest_subsequence_with_diff([100], 10) 1 >>> longest_subsequence_with_diff([1, 10, 20, 30], 5) 1 >>> longest_subsequence_with_diff([1, 3, 5, 7, 9], 1000) 5 >>> longest_subsequence_with_diff([5, 4, 3, 2, 1], 1) 5 >>> longest_subsequence_with_diff([10, 1, 2, 11, 12], 1) 3 >>> longest_subsequence_with_diff([100000000, 100000001, 99999999, 100000003], 1) 2","solution":"def longest_subsequence_with_diff(arr, d): n = len(arr) if n == 0: return 0 # Initialize the dp array with 1 (each element is a subsequence of length 1) dp = [1] * n # Iterate over each element for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) <= d: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def min_possible_maximum(n: int, a: List[int]) -> int: Given a list of integers, this function returns the minimum possible maximum value of the array after performing any number of operations on the elements of the array to reduce them. Args: n (int): The number of elements in the array. a (List[int]): The array of integers. Returns: int: The minimum possible maximum value of the array. Example: >>> min_possible_maximum(5, [3, 7, 2, 5, 9]) 7 >>> min_possible_maximum(1, [100]) 100","solution":"def min_possible_maximum(n, a): Given a list of integers, this function returns the minimum possible maximum value of the array after performing any number of operations on the elements of the array to reduce them. return max(a)"},{"question":"def has_zero_subsequence_sum(arr): Given an array of integers, determines whether there exists a non-empty subsequence that sums to zero. Args: arr (list of int): The list of integers. Returns: str: \\"Yes\\" if there exists a subsequence with sum zero, otherwise \\"No\\". Examples: >>> has_zero_subsequence_sum([1, 2, -3, 4, 5]) 'Yes' >>> has_zero_subsequence_sum([1, 2, 3]) 'No' >>> has_zero_subsequence_sum([4, -2, -2, 0]) 'Yes' # Sample Unit Tests def test_has_zero_subsequence_sum_example_1(): assert has_zero_subsequence_sum([1, 2, -3, 4, 5]) == \\"Yes\\" def test_has_zero_subsequence_sum_example_2(): assert has_zero_subsequence_sum([1, 2, 3]) == \\"No\\" def test_has_zero_subsequence_sum_example_3(): assert has_zero_subsequence_sum([4, -2, -2, 0]) == \\"Yes\\" def test_has_zero_subsequence_sum_single_zero(): assert has_zero_subsequence_sum([0]) == \\"Yes\\" def test_has_zero_subsequence_sum_multiple_zeros(): assert has_zero_subsequence_sum([0, 0, 0]) == \\"Yes\\" def test_has_zero_subsequence_sum_all_positive_no_zero_sum_subsequence(): assert has_zero_subsequence_sum([1, 2, 3, 4, 5]) == \\"No\\" def test_has_zero_subsequence_sum_all_negative_no_zero_sum_subsequence(): assert has_zero_subsequence_sum([-1, -2, -3, -4, -5]) == \\"No\\" def test_has_zero_subsequence_sum_mixed_signs_with_zero_sum_subsequence(): assert has_zero_subsequence_sum([1, 2, 3, -6, 1]) == \\"Yes\\"","solution":"def has_zero_subsequence_sum(arr): Given an array of integers, determines whether there exists a non-empty subsequence that sums to zero. Args: arr (list of int): The list of integers. Returns: str: \\"Yes\\" if there exists a subsequence with sum zero, otherwise \\"No\\". prefix_sum = 0 seen_sums = set() for num in arr: prefix_sum += num if prefix_sum == 0 or prefix_sum in seen_sums: return \\"Yes\\" seen_sums.add(prefix_sum) return \\"No\\""},{"question":"def lexicographically_smallest_string(s: str) -> str: Finds the lexicographically smallest string obtainable by sorting any substring of s once. >>> lexicographically_smallest_string(\\"bcab\\") 'abbc' >>> lexicographically_smallest_string(\\"abc\\") 'abc' >>> lexicographically_smallest_string(\\"cba\\") 'abc' >>> lexicographically_smallest_string(\\"abac\\") 'aabc' >>> lexicographically_smallest_string(\\"aaaa\\") 'aaaa' >>> lexicographically_smallest_string(\\"z\\" * (10**5 - 1) + \\"y\\") 'y' + 'z' * (10**5 - 1) >>> lexicographically_smallest_string(\\"x\\") 'x'","solution":"def lexicographically_smallest_string(s): Finds the lexicographically smallest string obtainable by sorting any substring of s once. n = len(s) sorted_s = sorted(s) # Find the first position where the original string differs from the sorted string for i in range(n): if s[i] != sorted_s[i]: break else: # If no such position is found, the string is already fully sorted return s # Find the last position from the end where the original string differs from the sorted string for j in range(n-1, -1, -1): if s[j] != sorted_s[j]: break # Create the new string by sorting the substring s[i:j+1] return s[:i] + ''.join(sorted(s[i:j+1])) + s[j+1:]"},{"question":"def get_k_most_recent_books(n: int, k: int, book_entries: List[Tuple[str, str]]) -> List[str]: Returns the k most recently added books by their identifiers. Parameters: n (int): The number of book entries. k (int): The number of the most recent books to return. book_entries (list of tuples): Each tuple contains a book identifier (str) and the date (str) in \\"YYYY-MM-DD\\" format. Returns: list of str: The book IDs of the k most recently added books, in reverse order of their addition dates. >>> get_k_most_recent_books(5, 3, [(\\"B001\\", \\"2023-01-01\\"), (\\"B002\\", \\"2023-01-03\\"), (\\"B003\\", \\"2023-01-05\\"), (\\"B004\\", \\"2023-01-02\\"), (\\"B005\\", \\"2023-01-04\\")]) [\\"B003\\", \\"B005\\", \\"B002\\"] >>> get_k_most_recent_books(3, 2, [(\\"B001\\", \\"2022-12-01\\"), (\\"B002\\", \\"2022-12-01\\"), (\\"B003\\", \\"2022-12-01\\")]) [\\"B001\\", \\"B002\\"] >>> get_k_most_recent_books(4, 4, [(\\"B001\\", \\"2021-05-01\\"), (\\"B002\\", \\"2022-07-15\\"), (\\"B003\\", \\"2023-01-10\\"), (\\"B004\\", \\"2022-05-20\\")]) [\\"B003\\", \\"B002\\", \\"B004\\", \\"B001\\"] >>> get_k_most_recent_books(1, 1, [(\\"B001\\", \\"2022-12-31\\")]) [\\"B001\\"] >>> get_k_most_recent_books(6, 3, [(\\"B001\\", \\"2020-03-15\\"), (\\"B002\\", \\"2021-06-30\\"), (\\"B003\\", \\"2019-11-23\\"), (\\"B004\\", \\"2023-02-05\\"), (\\"B005\\", \\"2022-09-14\\"), (\\"B006\\", \\"2021-12-25\\")]) [\\"B004\\", \\"B005\\", \\"B006\\"]","solution":"def get_k_most_recent_books(n, k, book_entries): Returns the k most recently added books by their identifiers. Parameters: n (int): The number of book entries. k (int): The number of the most recent books to return. book_entries (list of tuples): Each tuple contains a book identifier (str) and the date (str) in \\"YYYY-MM-DD\\" format. Returns: list of str: The book IDs of the k most recently added books, in reverse order of their addition dates. # Convert the date to a comparable format and sort the entries by date. sorted_books = sorted(book_entries, key=lambda x: x[1], reverse=True) # Extract just the book IDs of the top k entries most_recent_books = [book[0] for book in sorted_books[:k]] return most_recent_books"},{"question":"def process_baking_cases(input_data: str) -> List[int]: Given the quantities of available ingredients and the quantities required for making a single cake of each type, determine the maximum number of each type of cake that can be baked. >>> process_baking_cases(\\"2n3n15 6 9n3 2 5n2n20 30n5 10\\") [1, 3] >>> process_baking_cases(\\"1n1n10n2\\") [5] >>> process_baking_cases(\\"1n2n25 30n5 6\\") [5] >>> process_baking_cases(\\"1n3n5 10 15n5 2 5\\") [1] >>> process_baking_cases(\\"1n2n1000000000 2000000000n10000000 20000000\\") [100]","solution":"def max_cakes(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] b = test_cases[i][2] min_cakes = float('inf') for j in range(n): min_cakes = min(min_cakes, a[j] // b[j]) results.append(min_cakes) return results # Helper function to handle inputs and outputs def process_baking_cases(input_data): lines = input_data.split('n') t = int(lines[0]) test_cases = [] index = 1 for i in range(t): n = int(lines[index]) a = list(map(int, lines[index + 1].split())) b = list(map(int, lines[index + 2].split())) test_cases.append((n, a, b)) index += 3 return max_cakes(t, test_cases)"},{"question":"def count_pairs_with_sum(arr: List[int], target: int) -> int: Counts the unique pairs in arr that sum up to target. :param arr: List of integers. :param target: Target sum. :return: Number of unique pairs that sum to the target. >>> count_pairs_with_sum([1, 5, 7, -1, 5], 6) == 2 >>> count_pairs_with_sum([1, 2, 3], 10) == 0 >>> count_pairs_with_sum([3, 4, 5], 9) == 1 >>> count_pairs_with_sum([1, 2, 3, 4, 3, 2], 5) == 2 >>> count_pairs_with_sum([-1, -2, -3, 4, 1], -1) == 1 >>> count_pairs_with_sum([5, 5, 5, 1, 1, 1], 6) == 1 >>> count_pairs_with_sum([10**3, -10**3, 0], 0) == 1 >>> count_pairs_with_sum([2, 2, 2, 2, 2], 4) == 1","solution":"def count_pairs_with_sum(arr, target): Counts the unique pairs in arr that sum up to target. :param arr: List of integers. :param target: Target sum. :return: Number of unique pairs that sum to the target. pairs = set() seen = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def min_trips(n: int, w: int, weights: List[int]) -> int: Determines the minimum number of trips needed for all the adventurers to cross the bridge given the constraints. Parameters: n (int): Number of adventurers w (int): Maximum weight capacity of the bridge weights (list of int): Weights of the adventurers in the order they need to cross Returns: int: Minimum number of trips needed for all the adventurers to cross the bridge >>> min_trips(5, 200, [50, 50, 100, 50, 100]) 3 >>> min_trips(4, 150, [80, 90, 40, 70]) 3 Unit Test Cases from solution import min_trips def test_sample_input_1(): assert min_trips(5, 200, [50, 50, 100, 50, 100]) == 3 def test_sample_input_2(): assert min_trips(4, 150, [80, 90, 40, 70]) == 3 def test_single_adventurer(): assert min_trips(1, 200, [100]) == 1 def test_all_weights_equal(): assert min_trips(5, 100, [100, 100, 100, 100, 100]) == 5 def test_pairing_all_adventurers(): assert min_trips(6, 300, [100, 200, 100, 200, 100, 200]) == 3 def test_varied_weights(): assert min_trips(5, 200, [100, 100, 150, 50, 50]) == 3 def test_no_pairing_needed(): assert min_trips(3, 100, [50, 50, 50]) == 2 def test_maximum_weight_case(): assert min_trips(3, 1000, [500, 500, 500]) == 2","solution":"def min_trips(n, w, weights): Determines the minimum number of trips needed for all the adventurers to cross the bridge given the constraints. Parameters: n (int): Number of adventurers w (int): Maximum weight capacity of the bridge weights (list of int): Weights of the adventurers in the order they need to cross Returns: int: Minimum number of trips needed for all the adventurers to cross the bridge trips = 0 i = 0 while i < n: if i < n - 1 and weights[i] + weights[i + 1] <= w: trips += 1 i += 2 else: trips += 1 i += 1 return trips"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct non-empty substrings of the string \`s\`. >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaa\\") 3","solution":"def count_distinct_substrings(s): Returns the number of distinct non-empty substrings of the string \`s\`. n = len(s) substrings = set() # Generate all possible substrings and add them to the set for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) # The number of distinct substrings is the size of the set return len(substrings)"},{"question":"from typing import List def max_sum_heights(heights: List[int]) -> int: Returns the maximum sum of heights of the buildings that can be painted without painting two consecutive buildings. >>> max_sum_heights([3, 2, 7, 10]) 13 >>> max_sum_heights([3, 2, 5, 10, 7]) 15 >>> max_sum_heights([5]) 5 >>> max_sum_heights([5, 10]) 10 >>> max_sum_heights([5, 10, 15]) 20 >>> max_sum_heights([]) 0 >>> max_sum_heights([1, 2, 3, 1, 2, 3, 1]) 7","solution":"def max_sum_heights(heights): Returns the maximum sum of heights of the buildings that can be painted without painting two consecutive buildings. if not heights: return 0 n = len(heights) if n == 1: return heights[0] # Initialize an array to store the maximum sum at each index dp = [0] * n dp[0] = heights[0] dp[1] = max(heights[0], heights[1]) for i in range(2, n): # Either take the current building and the best excluding the previous building, # or skip the current building and take the best obtained so far. dp[i] = max(heights[i] + dp[i - 2], dp[i - 1]) return dp[-1]"},{"question":"def count_paths(grid): Count the number of distinct paths from the top-left corner to the bottom-right corner that navigate around obstacles. >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> count_paths(grid) 2 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> count_paths(grid) 6 >>> grid = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> count_paths(grid) 0 >>> grid = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> count_paths(grid) 0 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> count_paths(grid) 0","solution":"def count_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"from typing import List class StampCollection: def __init__(self): self.stamps = {} self.values = [] def add(self, stamp_name, value): Add a stamp with the given name and value to the collection. If the stamp_name already exists, update its value. >>> collection = StampCollection() >>> collection.add(\\"rare_stamp\\", 100) >>> collection.add(\\"common_stamp\\", 50) def remove(self, stamp_name): Remove the stamp with the given name from the collection. If no such stamp exists, do nothing. >>> collection = StampCollection() >>> collection.add(\\"rare_stamp\\", 100) >>> collection.remove(\\"rare_stamp\\") def query(self, value): Return the number of stamps that have a value greater than value. >>> collection = StampCollection() >>> collection.add(\\"rare_stamp\\", 100) >>> collection.query(60) == 1 True def process_operations(operations: List[str]) -> List[int]: Process a list of operations on the stamp collection and return the results of the queries. >>> operations = [ ... \\"5\\", ... \\"add rare_stamp 100\\", ... \\"add common_stamp 50\\", ... \\"query 60\\", ... \\"remove rare_stamp\\", ... \\"query 40\\" ... ] >>> process_operations(operations) [1, 1]","solution":"from collections import defaultdict import bisect class StampCollection: def __init__(self): self.stamps = {} self.values = [] def add(self, stamp_name, value): if stamp_name in self.stamps: old_value = self.stamps[stamp_name] pos = bisect.bisect_left(self.values, old_value) self.values.pop(pos) self.stamps[stamp_name] = value bisect.insort(self.values, value) def remove(self, stamp_name): if stamp_name in self.stamps: value = self.stamps.pop(stamp_name) pos = bisect.bisect_left(self.values, value) self.values.pop(pos) def query(self, value): return len(self.values) - bisect.bisect_right(self.values, value) def process_operations(operations): collection = StampCollection() results = [] for operation in operations: op_parts = operation.split() cmd = op_parts[0] if cmd == \\"add\\": collection.add(op_parts[1], int(op_parts[2])) elif cmd == \\"remove\\": collection.remove(op_parts[1]) elif cmd == \\"query\\": result = collection.query(int(op_parts[1])) results.append(result) return results"},{"question":"from typing import List def findLargest(arr: List[str]) -> str: Finds and returns the string representing the largest integer in the array of strings. >>> findLargest([\\"123\\", \\"456\\", \\"789\\"]) \\"789\\" >>> findLargest([\\"1\\", \\"34\\", \\"3\\", \\"98\\", \\"9\\", \\"76\\", \\"45\\", \\"4\\"]) \\"98\\" >>> findLargest([\\"001\\", \\"002\\", \\"003\\"]) \\"003\\"","solution":"def findLargest(arr): Finds and returns the string representing the largest integer in the array of strings. # Use the key parameter of max to compare the lengths of strings first, # and by their values in case of ties in lengths. return max(arr, key=lambda x: (len(x), x))"},{"question":"def is_right_angled_triangle(x1, y1, x2, y2, x3, y3): Check if the triangle formed by the points (x1, y1), (x2, y2), (x3, y3) is a right-angled triangle. >>> is_right_angled_triangle(0, 0, 3, 0, 0, 4) True >>> is_right_angled_triangle(1, 1, 2, 2, 3, 3) False >>> is_right_angled_triangle(0, 0, 1, 0, 0, 1) True pass def check_right_angled_triangles(test_cases): Given a list of test cases with points, return a list indicating if the points form right-angled triangles or not. >>> test_cases = [[(0, 0), (3, 0), (0, 4)], [(1, 1), (2, 2), (3, 3)]] >>> check_right_angled_triangles(test_cases) ['YES', 'NO'] pass","solution":"def is_right_angled_triangle(x1, y1, x2, y2, x3, y3): Check if the triangle formed by the points (x1, y1), (x2, y2), (x3, y3) is a right-angled triangle. def dist_sq(xa, ya, xb, yb): return (xa - xb) ** 2 + (ya - yb) ** 2 d1 = dist_sq(x1, y1, x2, y2) d2 = dist_sq(x2, y2, x3, y3) d3 = dist_sq(x3, y3, x1, y1) distances = sorted([d1, d2, d3]) # Check the Pythagorean theorem return distances[0] + distances[1] == distances[2] def check_right_angled_triangles(test_cases): results = [] for points in test_cases: x1, y1 = points[0] x2, y2 = points[1] x3, y3 = points[2] if is_right_angled_triangle(x1, y1, x2, y2, x3, y3): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_painting_cost(n: int, k: int, heights: List[int]) -> int: Determine the minimum cost for the painter to paint the entire fence. >>> min_painting_cost(7, 10, [3, 1, 4, 1, 5, 9, 2]) 40 >>> min_painting_cost(1, 5, [7]) 5 >>> min_painting_cost(5, 10, [1, 2, 3, 4, 5]) 10 >>> min_painting_cost(4, 15, [10, 8, 6, 4]) 60 >>> min_painting_cost(4, 20, [7, 7, 7, 7]) 20 >>> min_painting_cost(6, 10, [9, 7, 7, 5, 6, 8]) 30","solution":"def min_painting_cost(n, k, heights): cost = k # Initial cost for the first painting session for i in range(1, n): if heights[i] < heights[i-1]: cost += k return cost"},{"question":"def add_fractions(frac1: str, frac2: str) -> str: Add two fractions and return the result in simplest form. Parameters: frac1 (str): The first fraction in the form \\"a/b\\". frac2 (str): The second fraction in the form \\"c/d\\". Returns: str: The result of the addition in simplest form. Examples: >>> add_fractions(\\"1/2\\", \\"3/4\\") '5/4' >>> add_fractions(\\"2/3\\", \\"1/6\\") '5/6' >>> add_fractions(\\"-1/2\\", \\"2/4\\") '0/1'","solution":"from math import gcd def add_fractions(frac1: str, frac2: str) -> str: Add two fractions and return the result in simplest form. Parameters: frac1 (str): The first fraction in the form \\"a/b\\". frac2 (str): The second fraction in the form \\"c/d\\". Returns: str: The result of the addition in simplest form. # Parse the fractions a, b = map(int, frac1.split('/')) c, d = map(int, frac2.split('/')) # Find common denominator and add the fractions numerator = a * d + c * b denominator = b * d # Simplify the fraction common_divisor = gcd(numerator, denominator) numerator //= common_divisor denominator //= common_divisor return f\\"{numerator}/{denominator}\\""},{"question":"from collections import deque, defaultdict def modified_bfs(n, m, edges): Find the shortest path from node 1 to every other node on a graph where edge weights are either 1 or 2. Args: n (int): the number of nodes m (int): the number of edges edges (List[Tuple[int, int, int]]): list of edges, where each edge is a tuple (u, v, w) with u and v being nodes and w being the weight Returns: List[int]: list of distances where the i-th index represents the shortest distance from node 1 to node i+1. If there is no path, returns -1 for that node. Example: >>> modified_bfs(4, 4, [(1, 2, 1), (2, 3, 2), (1, 3, 2), (3, 4, 1)]) [0, 1, 2, 3] >>> modified_bfs(3, 0, []) [0, -1, -1]","solution":"from collections import deque, defaultdict def modified_bfs(n, m, edges): Find the shortest path from node 1 to every other node on a graph where edge weights are either 1 or 2. graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) dist = [-1] * n dist[0] = 0 dq = deque([1]) while dq: node = dq.popleft() for neighbor, weight in graph[node]: new_dist = dist[node-1] + weight if dist[neighbor-1] == -1 or new_dist < dist[neighbor-1]: dist[neighbor-1] = new_dist if weight == 1: dq.appendleft(neighbor) else: dq.append(neighbor) return dist"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string s. >>> count_palindromic_substrings(\\"a\\") == 1 >>> count_palindromic_substrings(\\"aa\\") == 3 >>> count_palindromic_substrings(\\"ab\\") == 2 >>> count_palindromic_substrings(\\"abba\\") == 6 >>> count_palindromic_substrings(\\"racecar\\") == 10 >>> count_palindromic_substrings(\\"abc\\") == 3 >>> count_palindromic_substrings(\\"aaaa\\") == 10","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string s. n = len(s) count = 0 # Define a DP table to store if s[i:j+1] is a palindrome dp = [[False] * n for _ in range(n)] # All single letters are palindromic substrings for i in range(n): dp[i][i] = True count += 1 # Check for palindromic substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True count += 1 # Check for substrings of length greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count"},{"question":"def minMaxWorkload(m: int, n: int, dishes: List[int]) -> int: Distribute the dishes among the chefs such that the maximum workload of any chef is minimized. Args: m (int): The number of dishes. n (int): The number of chefs. dishes (List[int]): The list where the i-th element represents the time required to prepare the i-th dish. Returns: int: The minimum possible maximum workload of a chef. Example: >>> minMaxWorkload(10, 4, [11, 6, 5, 4, 7, 3, 10, 8, 3, 1]) 17 pass def test_minMaxWorkload_single_chef(): assert minMaxWorkload(5, 1, [2, 4, 6, 8, 10]) == 30 def test_minMaxWorkload_equal_dishes_chefs(): assert minMaxWorkload(4, 4, [1, 2, 3, 4]) == 4 def test_minMaxWorkload_more_dishes_than_chefs(): assert minMaxWorkload(10, 4, [11, 6, 5, 4, 7, 3, 10, 8, 3, 1]) == 17 def test_minMaxWorkload_all_dishes_same_time(): assert minMaxWorkload(6, 3, [5, 5, 5, 5, 5, 5]) == 10 def test_minMaxWorkload_chefs_more_than_dishes(): assert minMaxWorkload(3, 5, [10, 20, 30]) == 30","solution":"def canDistribute(dishes, m, n, max_workload): chefs = 1 current_workload = 0 for time in dishes: if current_workload + time <= max_workload: current_workload += time else: chefs += 1 current_workload = time if chefs > n: return False return True def minMaxWorkload(m, n, dishes): left, right = max(dishes), sum(dishes) result = right while left <= right: mid = (left + right) // 2 if canDistribute(dishes, m, n, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def min_time_to_align_robots(positions): Given a list of integers representing initial positions of robots, returns the minimum time required for all robots to reach the same position. Args: positions (list): List of integers representing positions of robots. Returns: int: Minimum time required for all robots to align at the same position. >>> min_time_to_align_robots([1, 2, 3, 4, 5]) 6 >>> min_time_to_align_robots([10]) 0 >>> min_time_to_align_robots([1, 100]) 99 >>> min_time_to_align_robots([-10, -1, 0, 1, 10]) 22 >>> min_time_to_align_robots([10, 10, 10, 10]) 0 >>> min_time_to_align_robots([-1000000000, 0, 1000000000]) 2000000000 >>> min_time_to_align_robots([1, 2, 3, 4]) 4 >>> min_time_to_align_robots([-1, -2, -3, -4, -5]) 6","solution":"def min_time_to_align_robots(positions): Given a list of integers representing initial positions of robots, returns the minimum time required for all robots to reach the same position. Args: positions (list): List of integers representing positions of robots. Returns: int: Minimum time required for all robots to align at the same position. # Sort the positions positions.sort() # For minimizing travel time, align all robots to the median position median_position = positions[len(positions) // 2] # Calculate the total time required for all robots to reach the median position total_time = sum(abs(pos - median_position) for pos in positions) return total_time"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generate an n x n matrix filled with integers 1 to n^2 in a clockwise spiral order. >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] pass","solution":"from typing import List def generate_spiral_matrix(n: int) -> List[List[int]]: # Initialize an n x n matrix filled with 0s matrix = [[0] * n for _ in range(n)] # Define directions for the spiral order: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] dir_index = 0 # Start with the 'right' direction # Start from the top-left corner row, col = 0, 0 for num in range(1, n*n+1): # Fill the current cell with the number matrix[row][col] = num # Calculate the next position next_row, next_col = row + directions[dir_index][0], col + directions[dir_index][1] # Check if the next position is within bounds and the cell is not yet filled if 0 <= next_row < n and 0 <= next_col < n and matrix[next_row][next_col] == 0: row, col = next_row, next_col else: # Change direction dir_index = (dir_index + 1) % 4 row, col = row + directions[dir_index][0], col + directions[dir_index][1] return matrix"},{"question":"def longest_consecutive_baked_item_sequence(n: int, purchase_records: List[str]) -> int: Returns the maximum quantity of any single type of baked item bought consecutively. :param n: int: Number of purchase records :param purchase_records: list of strings: List containing pairs \\"li-ci\\" :return: int: Maximum quantity of any single type of baked item bought consecutively >>> longest_consecutive_baked_item_sequence(5, [\\"3-a\\", \\"5-b\\", \\"2-a\\", \\"4-b\\", \\"6-a\\"]) 6 >>> longest_consecutive_baked_item_sequence(4, [\\"2-c\\", \\"7-d\\", \\"1-d\\", \\"3-c\\"]) 7 >>> longest_consecutive_baked_item_sequence(3, [\\"1-a\\", \\"2-a\\", \\"3-a\\"]) 3 >>> longest_consecutive_baked_item_sequence(1, [\\"10-x\\"]) 10 >>> longest_consecutive_baked_item_sequence(2, [\\"1000000-a\\", \\"999999-b\\"]) 1000000 >>> longest_consecutive_baked_item_sequence(4, [\\"2-a\\", \\"3-b\\", \\"4-c\\", \\"5-d\\"]) 5","solution":"def longest_consecutive_baked_item_sequence(n, purchase_records): Returns the maximum quantity of any single type of baked item bought consecutively. :param n: int: Number of purchase records :param purchase_records: list of strings: List containing pairs \\"li-ci\\" :return: int: Maximum quantity of any single type of baked item bought consecutively max_quantity = 0 for record in purchase_records: quantity, item_type = record.split('-') quantity = int(quantity) if quantity > max_quantity: max_quantity = quantity return max_quantity"},{"question":"def sort_letters_and_digits(s: str) -> str: Takes a string with letters and digits, sorts the letters and digits individually, and returns the concatenated sorted letters and digits. # Test cases assert sort_letters_and_digits(\\"a1b2c3\\") == \\"abc123\\" assert sort_letters_and_digits(\\"b3a1c2\\") == \\"abc123\\" assert sort_letters_and_digits(\\"3a2c1b\\") == \\"abc123\\" assert sort_letters_and_digits(\\"abc123\\") == \\"abc123\\" assert sort_letters_and_digits(\\"321cba\\") == \\"abc123\\" assert sort_letters_and_digits(\\"z1y2x3\\") == \\"xyz123\\" assert sort_letters_and_digits(\\"4d3c2b1a\\") == \\"abcd1234\\" assert sort_letters_and_digits(\\"g5h6i7j8k9\\") == \\"ghijk56789\\" assert sort_letters_and_digits(\\"123abcdef\\") == \\"abcdef123\\" assert sort_letters_and_digits(\\"def123abc\\") == \\"abcdef123\\" # Edge cases assert sort_letters_and_digits(\\"a\\") == \\"a\\" assert sort_letters_and_digits(\\"1\\") == \\"1\\" assert sort_letters_and_digits(\\"a1\\") == \\"a1\\" assert sort_letters_and_digits(\\"1a\\") == \\"a1\\"","solution":"def sort_letters_and_digits(s: str) -> str: Takes a string with letters and digits, sorts the letters and digits individually, and returns the concatenated sorted letters and digits. letters = sorted([char for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) return ''.join(letters + digits)"},{"question":"from typing import List, Tuple def find_overloaded_servers(load_reports: List[Tuple[int, int]], threshold: int) -> List[int]: Returns a list of server IDs that have a load greater than the given threshold. >>> find_overloaded_servers([(101, 55), (102, 75), (103, 60), (101, 80)], 70) [102, 101] >>> find_overloaded_servers([(101, 55)], 50) [101] >>> find_overloaded_servers([(101, 55), (102, 65), (103, 60)], 70) [] >>> find_overloaded_servers([(101, 75), (102, 85), (103, 95)], 70) [101, 102, 103] >>> find_overloaded_servers([], 70) [] >>> find_overloaded_servers([(101, 55), (102, 75), (103, 0), (104, 20)], 0) [101, 102, 104] # Your code here. def test_find_overloaded_servers_single(): load_reports = [(101, 55)] threshold = 50 assert find_overloaded_servers(load_reports, threshold) == [101] def test_find_overloaded_servers_multiple(): load_reports = [(101, 55), (102, 75), (103, 60), (101, 80)] threshold = 70 assert find_overloaded_servers(load_reports, threshold) == [102, 101] def test_find_overloaded_servers_none(): load_reports = [(101, 55), (102, 65), (103, 60)] threshold = 70 assert find_overloaded_servers(load_reports, threshold) == [] def test_find_overloaded_servers_all(): load_reports = [(101, 75), (102, 85), (103, 95)] threshold = 70 assert find_overloaded_servers(load_reports, threshold) == [101, 102, 103] def test_find_overloaded_servers_empty(): load_reports = [] threshold = 70 assert find_overloaded_servers(load_reports, threshold) == [] def test_find_overloaded_servers_zero_threshold(): load_reports = [(101, 55), (102, 75), (103, 0), (104, 20)] threshold = 0 assert find_overloaded_servers(load_reports, threshold) == [101, 102, 104]","solution":"from typing import List, Tuple def find_overloaded_servers(load_reports: List[Tuple[int, int]], threshold: int) -> List[int]: Returns a list of server IDs that have a load greater than the given threshold. overloaded_servers = [] for server_id, load in load_reports: if load > threshold: overloaded_servers.append(server_id) return overloaded_servers"},{"question":"from typing import List def find_minimum_abs_difference(nums: List[int]) -> int: Given a list of distinct integers nums, this function partitions the list into two non-empty subsets such that the absolute difference between the sums of the elements in the two subsets is minimized. >>> find_minimum_abs_difference([1, 2, 3, 4, 5]) 1 >>> find_minimum_abs_difference([1, 1, 1, 1, 4]) 0 >>> find_minimum_abs_difference([-10, -20, -30, 10, 20, 30]) 0 >>> find_minimum_abs_difference([3, 7]) 4 >>> find_minimum_abs_difference([15, 5, 20, 10]) 0","solution":"def find_minimum_abs_difference(nums): Given a list of distinct integers nums, this function partitions the list into two non-empty subsets such that the absolute difference between the sums of the elements in the two subsets is minimized. from itertools import combinations total_sum = sum(nums) n = len(nums) min_diff = float('inf') # To ensure subsets are non-empty, we check subsets sizes from 1 to (n-1)/2 # Note that combinations of size (n-x) is equivalent to those of size x, so we iterate less. half_size = n // 2 for r in range(1, half_size + 1): for subset in combinations(nums, r): subset_sum = sum(subset) other_sum = total_sum - subset_sum diff = abs(subset_sum - other_sum) min_diff = min(min_diff, diff) return min_diff"},{"question":"MOD = 10**9 + 7 def fibonacci(n): Compute the nth Fibonacci number modulo 10^9 + 7. >>> fibonacci(10) 55 >>> fibonacci(1) 1 >>> fibonacci(1000) 517691607","solution":"MOD = 10**9 + 7 def fibonacci(n): Returns the nth Fibonacci number modulo 10^9 + 7. if n == 0: return 0 elif n == 1: return 1 fib = [0] * (n + 1) fib[0] = 0 fib[1] = 1 for i in range(2, n + 1): fib[i] = (fib[i - 1] + fib[i - 2]) % MOD return fib[n]"},{"question":"def product_except_self(nums): Calculate the product of all elements in the array except the element at each index without using division. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5]) [1]","solution":"def product_except_self(nums): n = len(nums) output = [1] * n left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def can_fulfill_demand(n: int, k: int, stock_demand: List[Tuple[int, int]]) -> str: Determines if the warehouse can fulfill all demands using at most one bulk order. :param n: Number of product types :param k: Maximum allowance for any bulk order :param stock_demand: List of tuples where each tuple contains (stock, demand) for each product :return: \\"YES\\" if all demands can be fulfilled, \\"NO\\" otherwise >>> can_fulfill_demand(5, 10, [(100, 100), (200, 200), (150, 150), (130, 130), (90, 90)]) 'YES' >>> can_fulfill_demand(5, 10, [(100, 110), (200, 200), (150, 150), (130, 130), (90, 90)]) 'YES' >>> can_fulfill_demand(5, 10, [(100, 120), (200, 200), (150, 150), (130, 130), (90, 90)]) 'NO' >>> can_fulfill_demand(5, 10, [(100, 110), (200, 210), (150, 160), (130, 120), (90, 90)]) 'NO' >>> can_fulfill_demand(1, 10, [(0, 10)]) 'YES' >>> can_fulfill_demand(1, 5, [(0, 10)]) 'NO'","solution":"def can_fulfill_demand(n, k, stock_demand): Determines if the warehouse can fulfill all demands using at most one bulk order. :param n: Number of product types :param k: Maximum allowance for any bulk order :param stock_demand: List of tuples where each tuple contains (stock, demand) for each product :return: \\"YES\\" if all demands can be fulfilled, \\"NO\\" otherwise deficit_count = 0 deficited_items = [] for s, d in stock_demand: if s < d: deficited_items.append(d - s) deficit_count += 1 if deficit_count == 0: return \\"YES\\" if deficit_count > 1: return \\"NO\\" return \\"YES\\" if deficited_items[0] <= k else \\"NO\\""},{"question":"def find_repeated_substring(s: str) -> str: Finds the longest substring that occurs more than once in the given string \`s\`. If there are multiple such substrings with the same maximum length, returns the one that appears first. If no such substring exists, returns an empty string. >>> find_repeated_substring(\\"banana\\") \\"ana\\" >>> find_repeated_substring(\\"a\\") \\"\\" >>> find_repeated_substring(\\"abcdef\\") \\"\\" >>> find_repeated_substring(\\"abababab\\") \\"ababab\\" >>> find_repeated_substring(\\"xyxyxyxy\\") \\"xyxyxy\\" >>> find_repeated_substring(\\"abcabcababc\\") \\"abcab\\" >>> find_repeated_substring(\\"aaaa\\") \\"aaa\\"","solution":"def find_repeated_substring(s): Finds the longest substring that occurs more than once in the given string \`s\`. If there are multiple such substrings with the same maximum length, returns the one that appears first. If no such substring exists, returns an empty string. def has_repeated_substring_length(length): substr_map = {} for i in range(len(s) - length + 1): substring = s[i:i+length] if substring in substr_map: return True, substring substr_map[substring] = i return False, \\"\\" left, right = 1, len(s) longest_substr = \\"\\" while left <= right: mid = (left + right) // 2 found, substr = has_repeated_substring_length(mid) if found: longest_substr = substr left = mid + 1 else: right = mid - 1 return longest_substr"},{"question":"from typing import List def can_see_board(n: int, heights: List[int]) -> List[bool]: Determine whether each student can see the board. :param n: int - number of students :param heights: list of int - heights of the students :return: list of bool - True if the student can see the board, False otherwise pass # Example test cases def test_can_see_board_example(): assert can_see_board(5, [10, 6, 8, 5, 7]) == [True, False, False, False, False] def test_all_students_same_height(): assert can_see_board(4, [3, 3, 3, 3]) == [True, False, False, False] def test_students_increasing_height(): assert can_see_board(4, [1, 2, 3, 4]) == [True, True, True, True] def test_students_decreasing_height(): assert can_see_board(4, [4, 3, 2, 1]) == [True, False, False, False] def test_single_student(): assert can_see_board(1, [5]) == [True]","solution":"def can_see_board(n, heights): Determine whether each student can see the board. :param n: int - number of students :param heights: list of int - heights of the students :return: list of bool - True if the student can see the board, False otherwise result = [] max_height_so_far = 0 for height in heights: if height > max_height_so_far: result.append(True) max_height_so_far = height else: result.append(False) return result"},{"question":"def sum_min_max(n, array): Returns the sum of the maximum and minimum elements in the array. n: int, the number of elements in the array array: list of int, the array elements returns: int, sum of the maximum and minimum elements in the array pass def parse_input(input_line): Parses the input line to extract n and the array elements. input_line: str, input line containing n followed by n space-separated integers returns: tuple(int, list of int), n and the array elements pass from solution import sum_min_max, parse_input def test_sum_min_max(): assert sum_min_max(5, [1, 2, 3, 4, 5]) == 6 # min: 1, max: 5 assert sum_min_max(3, [10, 20, 30]) == 40 # min: 10, max: 30 assert sum_min_max(2, [1, 100]) == 101 # min: 1, max: 100 def test_parse_input(): assert parse_input(\\"5 1 2 3 4 5\\") == (5, [1, 2, 3, 4, 5]) assert parse_input(\\"3 10 20 30\\") == (3, [10, 20, 30]) assert parse_input(\\"2 1 100\\") == (2, [1, 100]) def test_sum_min_max_with_parsed_input(): input_str = \\"4 70 50 90 10\\" n, array = parse_input(input_str) assert sum_min_max(n, array) == 100 # min: 10, max: 90","solution":"def sum_min_max(n, array): Returns the sum of the maximum and minimum elements in the array. n: int, the number of elements in the array array: list of int, the array elements returns: int, sum of the maximum and minimum elements in the array min_element = min(array) max_element = max(array) return min_element + max_element def parse_input(input_line): Parses the input line to extract n and the array elements. input_line: str, input line containing n followed by n space-separated integers returns: tuple(int, list of int), n and the array elements parts = input_line.split() n = int(parts[0]) array = list(map(int, parts[1:])) return n, array"},{"question":"def find_pairs(arr: List[int], target: int) -> Union[List[Tuple[int, int]], str]: Finds all unique pairs in the array that sum up to the target number. Returns a list of unique pairs (a, b) where a <= b. If no pairs are found, returns \\"No pairs found\\". >>> find_pairs([1, 5, 3, 7, 9, 2], 10) [(1, 9), (3, 7)] >>> find_pairs([1, 2, 3, 4, 5], 10) \\"No pairs found\\"","solution":"def find_pairs(arr, target): Returns a list of unique pairs that sum up to the target. Each pair is in the form (a, b) where a <= b. seen = set() output = set() for num in arr: complement = target - num if complement in seen: pair = (min(num, complement), max(num, complement)) output.add(pair) seen.add(num) if output: return list(output) else: return \\"No pairs found\\""},{"question":"from typing import List def can_be_palindrome(S: str) -> bool: Determine if it's possible to transform the string \`S\` into a palindrome using any number of adjacent swaps. A string can be permuted to form a palindrome if at most one character has an odd count. >>> can_be_palindrome(\\"radar\\") True >>> can_be_palindrome(\\"abc\\") False pass def solve(test_cases: List[str]) -> List[str]: Determine whether it is possible to transform each string \`S\` into a palindrome. Given a list of strings, return \\"YES\\" for each string if it can be transformed into a palindrome using any number of adjacent swaps, otherwise return \\"NO\\". >>> solve([\\"radar\\", \\"level\\", \\"abb\\", \\"abc\\", \\"aa\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> solve([\\"abcdefg\\", \\"aabbcc\\", \\"abcba\\", \\"dedded\\"]) [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] pass","solution":"def can_be_palindrome(S): from collections import Counter char_count = Counter(S) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be permuted to form a palindrome if at most one character has an odd count return odd_count <= 1 def solve(test_cases): results = [] for S in test_cases: if can_be_palindrome(S): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def length_of_lis(priorities: List[int]) -> int: Returns the length of the longest increasing subsequence given a list of message priorities. >>> length_of_lis([5, 2, 8, 6, 3, 6, 9, 7]) 4 >>> length_of_lis([10]) 1 >>> length_of_lis([3, 3, 3, 3]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([1, 3, 2, 4, 3, 5]) 4 >>> length_of_lis([10, 20, 10, 30, 10, 40, 10, 50]) 5 >>> length_of_lis([]) 0 pass","solution":"def length_of_lis(priorities): Returns the length of the longest increasing subsequence given a list of message priorities. :param priorities: List of integers representing message priorities :return: Integer representing the length of the longest strictly increasing subsequence if not priorities: return 0 n = len(priorities) lis = [1] * n for i in range(1, n): for j in range(i): if priorities[i] > priorities[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"from typing import List def min_moves_to_treasure(R: int, C: int, grid: List[str]) -> int: Calculate the minimum number of moves required for Alex to reach the treasure. Alex can move up, down, left, or right to an adjacent open cell '.' but cannot move outside the grid or into a blocked cell 'X'. The initial position of Alex is at cell (0, 0) and the treasure is located at cell (R-1, C-1). If it is impossible for Alex to reach the treasure, return -1. >>> min_moves_to_treasure(3, 3, [\\"...\\", \\".X.\\", \\"...\\"]) 4 >>> min_moves_to_treasure(3, 3, [\\"...\\", \\"XXX\\", \\"..X\\"]) -1 import pytest from solution import min_moves_to_treasure def test_example_1(): R = 3 C = 3 grid = [ \\"...\\", \\".X.\\", \\"...\\" ] assert min_moves_to_treasure(R, C, grid) == 4 def test_example_2(): R = 3 C = 3 grid = [ \\"...\\", \\"XXX\\", \\"..X\\" ] assert min_moves_to_treasure(R, C, grid) == -1 def test_small_grid(): R = 1 C = 1 grid = [ \\".\\" ] assert min_moves_to_treasure(R, C, grid) == 0 def test_blocked_start(): R = 2 C = 2 grid = [ \\"X.\\", \\"..\\" ] assert min_moves_to_treasure(R, C, grid) == -1 def test_blocked_end(): R = 2 C = 2 grid = [ \\"..\\", \\".X\\" ] assert min_moves_to_treasure(R, C, grid) == -1 def test_no_path_in_big_grid(): R = 4 C = 4 grid = [ \\"....\\", \\"XXXX\\", \\"XXXX\\", \\"....\\" ] assert min_moves_to_treasure(R, C, grid) == -1 def test_path_in_big_grid(): R = 4 C = 4 grid = [ \\"....\\", \\"XX.X\\", \\"....\\", \\"XX..\\" ] assert min_moves_to_treasure(R, C, grid) == 6","solution":"from collections import deque def min_moves_to_treasure(R, C, grid): directions = [(-1,0), (1,0), (0,-1), (0,1)] if grid[0][0] == 'X' or grid[R-1][C-1] == 'X': return -1 queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == R-1 and c == C-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in visited and grid[nr][nc] == '.': visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: This function returns the lexicographically smallest string by removing exactly k characters from the string s. >>> lexicographically_smallest_string(\\"abcde\\", 2) \\"abc\\" >>> lexicographically_smallest_string(\\"bdca\\", 1) \\"bca\\" >>> lexicographically_smallest_string(\\"acbd\\", 1) \\"abd\\" >>> lexicographically_smallest_string(\\"ba\\", 1) \\"a\\" >>> lexicographically_smallest_string(\\"abcdef\\", 3) \\"abc\\" >>> lexicographically_smallest_string(\\"bcad\\", 2) \\"ad\\"","solution":"def lexicographically_smallest_string(s, k): This function returns the lexicographically smallest string by removing exactly k characters from the string s. stack = [] n = len(s) # Iterate over the string for i in range(n): # Remove characters from the stack if possible to make the result lexicographically smaller # and we still have sufficient characters left to remove (k > 0) while stack and k > 0 and stack[-1] > s[i]: stack.pop() k -= 1 stack.append(s[i]) # If there are still characters to remove, remove them from the end while k > 0: stack.pop() k -= 1 # The stack now contains the smallest lexicographical string return ''.join(stack) # Example usage result = lexicographically_smallest_string(\\"abcde\\", 2) print(result) # Expected output: \\"abc\\""},{"question":"def min_operations_to_delete_string(t: int, strings: List[str]) -> List[int]: Given a number of test cases and a list of strings consisting of lowercase Latin letters 'a' and 'b' only, return the minimum number of operations needed to completely delete each string as described in the problem statement. >>> min_operations_to_delete_string(4, ['abba', 'aaaa', 'abab', 'aabbba']) [2, 1, 2, 2] >>> min_operations_to_delete_string(1, ['a']) [1] >>> min_operations_to_delete_string(1, ['b']) [1] >>> min_operations_to_delete_string(3, ['aaaaa', 'bbbbb', 'aaaabbbb']) [1, 1, 2]","solution":"def min_operations_to_delete_string(t, strings): results = [] for string in strings: operations = 0 if 'a' in string: operations += 1 if 'b' in string: operations += 1 results.append(operations) return results"},{"question":"def find_leftmost_unique_char(s: str) -> str: Find the first character in the string that does not repeat in any subsequent part of the string. >>> find_leftmost_unique_char(\\"abacabad\\") \\"c\\" >>> find_leftmost_unique_char(\\"aabbcc\\") \\"-\\"","solution":"def find_leftmost_unique_char(s: str) -> str: from collections import Counter # Counting the frequency of each character char_frequency = Counter(s) # Finding the leftmost unique character for char in s: if char_frequency[char] == 1: return char return \\"-\\""},{"question":"from typing import List def find_unique_number(arr: List[int]) -> int: Returns the single integer that appears only once in the list while every other element appears twice. >>> find_unique_number([4, 1, 2, 1, 2]) 4 >>> find_unique_number([2, 2, 3]) 3 >>> find_unique_number([1]) 1 # Test cases def test_single_element(): assert find_unique_number([1]) == 1 def test_example_1(): assert find_unique_number([4, 1, 2, 1, 2]) == 4 def test_example_2(): assert find_unique_number([2, 2, 3]) == 3 def test_all_elements_twice_except_one(): assert find_unique_number([2, 2, 3, 4, 4, 5, 5]) == 3 def test_large_input(): assert find_unique_number([i for i in range(1, 15000)] * 2 + [15000]) == 15000","solution":"from typing import List def find_unique_number(arr: List[int]) -> int: Returns the single integer that appears only once in the list while every other element appears twice. Utilizes XOR operation properties to achieve this in linear time and constant space. unique_number = 0 for num in arr: unique_number ^= num return unique_number"},{"question":"from typing import List def autocomplete(words: List[str], prefix: str) -> List[str]: Suggest the most frequently used words based on previous inputs. Returns up to 5 most frequently used words that start with the given prefix. If fewer than 5 words start with the prefix, all of them are returned. If no words start with the prefix, returns an empty list. If multiple words have the same frequency, they should be returned in lexicographic order. Examples: >>> autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"app\\", \\"apple\\", \\"application\\"], \\"app\\") [\\"app\\", \\"apple\\", \\"application\\"] >>> autocomplete([\\"hello\\", \\"high\\", \\"hill\\", \\"how\\", \\"house\\", \\"hoist\\"], \\"ho\\") [\\"hoist\\", \\"house\\", \\"how\\"] def test_autocomplete_ex1(): words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"app\\", \\"apple\\", \\"application\\"] prefix = \\"app\\" assert autocomplete(words, prefix) == [\\"app\\", \\"apple\\", \\"application\\"] def test_autocomplete_ex2(): words = [\\"hello\\", \\"high\\", \\"hill\\", \\"how\\", \\"house\\", \\"hoist\\"] prefix = \\"ho\\" assert autocomplete(words, prefix) == [\\"hoist\\", \\"house\\", \\"how\\"] def test_autocomplete_no_match(): words = [\\"hello\\", \\"high\\", \\"hill\\", \\"how\\", \\"house\\", \\"hoist\\"] prefix = \\"xy\\" assert autocomplete(words, prefix) == [] def test_autocomplete_all_match(): words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"most\\", \\"mat\\", \\"apple\\"] prefix = \\"m\\" assert autocomplete(words, prefix) == [\\"mat\\", \\"most\\"] def test_autocomplete_less_than_five_matches(): words = [\\"app\\", \\"apple\\", \\"application\\"] prefix = \\"app\\" assert autocomplete(words, prefix) == [\\"app\\", \\"apple\\", \\"application\\"] def test_autocomplete_with_tied_frequencies(): words = [\\"dog\\", \\"deer\\", \\"deal\\", \\"dog\\", \\"deer\\", \\"deal\\", \\"dog\\", \\"deer\\", \\"dear\\"] prefix = \\"de\\" assert autocomplete(words, prefix) == [\\"deer\\", \\"deal\\", \\"dear\\"]","solution":"from collections import Counter import heapq def autocomplete(words, prefix): # Count the frequency of each word in the list word_count = Counter(words) # Find all words that start with the given prefix prefix_words = [word for word in word_count if word.startswith(prefix)] # Create a list of tuples (count, word) for the prefix words count_word_pairs = [(count, word) for word, count in word_count.items() if word in prefix_words] # Sort the list based on count descending and lexicographically ascending count_word_pairs.sort(key=lambda x: (-x[0], x[1])) # Get the top 5 words from the sorted list top_suggestions = [word for _, word in count_word_pairs[:5]] return top_suggestions"},{"question":"from typing import List, Dict def calculate_popularity(posts: List[List[str]], hashtag_scores: Dict[str, int]) -> Dict[str, int]: Calculate the total popularity score for each unique hashtag present in the posts. >>> calculate_popularity([[\\"fun\\", \\"SunnyDay\\"], [\\"Summer\\", \\"FUN\\"], [\\"beach\\", \\"sunnyday\\", \\"travel\\"], [\\"summer\\"], [\\"Travel\\"]], {\\"fun\\": 5, \\"sunnyday\\": 10, \\"summer\\": 8, \\"beach\\": 6}) {\\"fun\\": 10, \\"sunnyday\\": 20, \\"summer\\": 16, \\"beach\\": 6, \\"travel\\": 0} >>> calculate_popularity([[\\"fun\\"]], {\\"fun\\": 5}) {\\"fun\\": 5} >>> calculate_popularity([[\\"fun\\", \\"SunnyDay\\"]], {\\"fun\\": 5, \\"sunnyday\\": 10}) {\\"fun\\": 5, \\"sunnyday\\": 10} >>> calculate_popularity([[\\"fun\\", \\"SunnyDay\\"], [\\"Summer\\", \\"FUN\\"]], {\\"fun\\": 5, \\"sunnyday\\": 10, \\"summer\\": 8}) {\\"fun\\": 10, \\"sunnyday\\": 10, \\"summer\\": 8} >>> calculate_popularity([[\\"fun\\", \\"SunnyDay\\"], [\\"Summer\\", \\"UNKNOWN\\"]], {\\"fun\\": 5, \\"sunnyday\\": 10, \\"summer\\": 8}) {\\"fun\\": 5, \\"sunnyday\\": 10, \\"summer\\": 8, \\"unknown\\": 0} >>> calculate_popularity([[\\"Fun\\", \\"sunNYday\\"], [\\"Summer\\", \\"FUN\\"]], {\\"fun\\": 5, \\"sunnyday\\": 10, \\"summer\\": 8}) {\\"fun\\": 10, \\"sunnyday\\": 10, \\"summer\\": 8} >>> calculate_popularity([], {\\"fun\\": 5}) {} >>> calculate_popularity([[\\"fun\\", \\"SunnyDay\\"]], {}) {\\"fun\\": 0, \\"sunnyday\\": 0}","solution":"def calculate_popularity(posts, hashtag_scores): result = {} for post in posts: for hashtag in post: hashtag_lower = hashtag.lower() if hashtag_lower in result: result[hashtag_lower] += hashtag_scores.get(hashtag_lower, 0) else: result[hashtag_lower] = hashtag_scores.get(hashtag_lower, 0) return result"},{"question":"def calculate_cashback(n: int) -> float: Calculate the cash-back for a given spending amount. >>> calculate_cashback(50) == 0.50 True >>> calculate_cashback(150) == 2.00 True >>> calculate_cashback(600) == 14.00 True >>> calculate_cashback(1000) == 34.00 True def process_customers(customers: List[int]) -> List[float]: Calculate the cash-back for a list of customer spendings. >>> process_customers([50, 150, 600, 1000]) == [0.50, 2.00, 14.00, 34.00] True","solution":"def calculate_cashback(n): if n <= 100: return round(0.01 * n, 2) elif n <= 500: return round(1 + 0.02 * (n - 100), 2) else: return round(9 + 0.05 * (n - 500), 2) def process_customers(customers): return [calculate_cashback(n) for n in customers]"},{"question":"def min_weight_difference(masses: List[int]) -> int: Determines the minimum possible absolute weight difference between two groups of marbles >>> min_weight_difference([1, 2, 3, 4]) == 0 >>> min_weight_difference([5, 3, 8, 6, 7]) == 1 >>> min_weight_difference([7]) == 7 >>> min_weight_difference([7, 3]) == 4 >>> min_weight_difference([1000, 1000, 1000, 1000]) == 0 >>> min_weight_difference([1, 1, 1, 1]) == 0","solution":"def min_weight_difference(masses): Determines the minimum possible absolute weight difference between two groups of marbles :param masses: List of masses of the marbles :return: Minimum possible absolute weight difference total_sum = sum(masses) n = len(masses) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(target + 1): if j >= masses[i-1]: dp[i][j] = dp[i-1][j] or dp[i-1][j-masses[i-1]] else: dp[i][j] = dp[i-1][j] for j in range(target, -1, -1): if dp[n][j]: return abs(total_sum - 2 * j)"},{"question":"def min_repaints(n: int, sequence: str) -> int: Returns the minimum number of repaints required so that no two adjacent blocks have the same color. >>> min_repaints(5, 'RGRGR') == 0 >>> min_repaints(5, 'RRRRR') == 2 >>> min_repaints(3, 'RRR') == 1 >>> min_repaints(4, 'RGBR') == 0 >>> min_repaints(4, 'RGRG') == 0 >>> min_repaints(1, 'R') == 0 >>> min_repaints(2, 'RR') == 1 >>> min_repaints(2, 'RG') == 0 >>> min_repaints(10, 'RGBRGBRGBR') == 0 pass","solution":"def min_repaints(n, sequence): Returns the minimum number of repaints required so that no two adjacent blocks have the same color. if n == 1: return 0 repaints = 0 last_color = sequence[0] for i in range(1, n): if sequence[i] == last_color: repaints += 1 # Choose a different color for the next block assuming only three colors ('R', 'G', 'B') for color in 'RGB': if color != last_color and (i + 1 == n or color != sequence[i + 1]): last_color = color break else: last_color = sequence[i] return repaints"},{"question":"def count_distinct_in_subarrays(n: int, m: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: You are given an array of integers with length n. Your task is to answer m queries. Each query consists of two integers l and r (1 ≤ l ≤ r ≤ n), and asks for the number of distinct elements in the subarray from index l to r (inclusive). The input consists of two integers n and m (1 ≤ n, m ≤ 100000) in the first line, representing the length of the array and the number of queries respectively. The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 10^9) — the elements of the array. The next m lines contain two integers l and r each, representing the range for which you need to count the number of distinct elements in the subarray a[l...r]. The indices are 1-based. Output m integers, each representing the answer to the corresponding query. Example: Input: 6 3 1 2 1 3 2 1 1 3 2 4 1 6 Output: 2 3 3 >>> n = 6 >>> m = 3 >>> array = [1, 2, 1, 3, 2, 1] >>> queries = [(1, 3), (2, 4), (1, 6)] >>> count_distinct_in_subarrays(n, m, array, queries) [2, 3, 3] >>> n = 5 >>> m = 5 >>> array = [1, 2, 3, 4, 5] >>> queries = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] >>> count_distinct_in_subarrays(n, m, array, queries) [1, 1, 1, 1, 1]","solution":"def count_distinct_in_subarrays(n, m, array, queries): results = [] for l, r in queries: subarray = array[l-1:r] distinct_elements = len(set(subarray)) results.append(distinct_elements) return results"},{"question":"def longest_increasing_path(G: List[List[int]]) -> int: Find the length of the longest strictly increasing path in the grid. You can move up, down, left, or right from a cell to another cell. Your goal is to find the length of the longest strictly increasing path in the grid. You can start from any cell and move to adjacent cells only if the value in the adjacent cell is strictly greater than the value in the current cell. Args: G (List[List[int]]): 2D grid of integers Returns: int: The length of the longest strictly increasing path >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longest_increasing_path([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) 4 >>> longest_increasing_path([ ... [1] ... ]) 1 pass def test_longest_increasing_path_1(): G = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] assert longest_increasing_path(G) == 4 def test_longest_increasing_path_2(): G = [ [3, 4, 5], [3, 2, 6], [2, 2, 1] ] assert longest_increasing_path(G) == 4 def test_longest_increasing_path_3(): G = [ [1] ] assert longest_increasing_path(G) == 1 def test_longest_increasing_path_4(): G = [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] assert longest_increasing_path(G) == 9 def test_longest_increasing_path_empty_grid(): G = [] assert longest_increasing_path(G) == 0 def test_longest_increasing_path_single_row(): G = [[3, 4, 5, 6, 1, 2]] assert longest_increasing_path(G) == 4 def test_longest_increasing_path_single_column(): G = [ [3], [4], [5], [1], [2] ] assert longest_increasing_path(G) == 3 def test_longest_increasing_path_same_values(): G = [ [7, 7], [7, 7] ] assert longest_increasing_path(G) == 1","solution":"def longest_increasing_path(G): if not G or not G[0]: return 0 m, n = len(G), len(G[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] cache = [[-1] * n for _ in range(m)] def dfs(x, y): if cache[x][y] != -1: return cache[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and G[nx][ny] > G[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) cache[x][y] = max_length return cache[x][y] max_path = 0 for i in range(m): for j in range(n): max_path = max(max_path, dfs(i, j)) return max_path"},{"question":"def min_operations_to_sort(n: int, books: List[int]) -> int: Determine the minimum number of operations required to sort the books on the shelf in non-decreasing order of their thickness. The robot arm can pick any subarray of books and place it either at the beginning or the end of the shelf. >>> min_operations_to_sort(5, [4, 3, 2, 1, 5]) 2 >>> min_operations_to_sort(3, [3, 2, 1]) 2 >>> min_operations_to_sort(5, [1, 2, 3, 4, 5]) 0 >>> min_operations_to_sort(4, [4, 5, 1, 2]) 2 >>> min_operations_to_sort(5, [3, 3, 3, 3, 3]) 0 >>> min_operations_to_sort(1, [1]) 0","solution":"def min_operations_to_sort(n, books): Determine the minimum number of operations required to sort the books on the shelf in non-decreasing order of their thickness. The robot arm can pick any subarray of books and place it either at the beginning or the end of the shelf. if n == 1: # Already sorted if there's only one book return 0 sorted_books = sorted(books) # Find the longest sorted prefix prefix_length = 0 for i in range(n): if books[i] == sorted_books[i]: prefix_length += 1 else: break # Find the longest sorted suffix suffix_length = 0 for i in range(n-1, -1, -1): if books[i] == sorted_books[i]: suffix_length += 1 else: break if prefix_length == n or suffix_length == n: # Already sorted return 0 return 2 # because 2 operations are needed based on the problem explanation"},{"question":"def factorial(n): Returns the factorial of n. Examples: >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(2) 2 >>> factorial(3) 6 >>> factorial(4) 24 pass def distinct_flower_layouts(t, test_cases): For a list of test cases, returns the number of distinct flower layouts for each grid size. Arguments: t -- number of test cases test_cases -- list of integers representing the side length of the grid for each test case Returns a list of integers where each integer is the number of distinct layouts for the grid size in the corresponding test case. Examples: >>> distinct_flower_layouts(3, [2, 3, 4]) [2, 6, 24] >>> distinct_flower_layouts(2, [1, 5]) [1, 120] >>> distinct_flower_layouts(1, [6]) [720] pass","solution":"def factorial(n): Returns the factorial of n. if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result def distinct_flower_layouts(t, test_cases): For a list of test cases, returns the number of distinct flower layouts for each grid size. Arguments: t -- number of test cases test_cases -- list of integers representing the side length of the grid for each test case Returns a list of integers where each integer is the number of distinct layouts for the grid size in the corresponding test case. results = [] for n in test_cases: results.append(factorial(n)) return results"},{"question":"def evaluate_polynomial(coefficients, x_values): Evaluates the polynomial for each value in x_values. :param coefficients: List of integers representing the polynomial coefficients. :param x_values: List of integers representing the x values. :return: List of integers representing the y values. # Unit Tests def test_evaluate_polynomial_simple(): coefficients = [1, 0, -1] x_values = [1, -1, 2] assert evaluate_polynomial(coefficients, x_values) == [0, 0, -3] def test_evaluate_polynomial_constant(): coefficients = [5] x_values = [0, 1, -1] assert evaluate_polynomial(coefficients, x_values) == [5, 5, 5] def test_evaluate_polynomial_linear(): coefficients = [2, 3] x_values = [0, 1, 2] assert evaluate_polynomial(coefficients, x_values) == [2, 5, 8] def test_evaluate_polynomial_quadratic(): coefficients = [1, -3, 2] x_values = [0, 1, 2] assert evaluate_polynomial(coefficients, x_values) == [1, 0, 3] def test_evaluate_polynomial_zero_coefficients(): coefficients = [0, 0, 0] x_values = [0, 1, 2] assert evaluate_polynomial(coefficients, x_values) == [0, 0, 0] def test_evaluate_polynomial_large_inputs(): coefficients = [1, 0, -1] x_values = [1000000, -1000000] assert evaluate_polynomial(coefficients, x_values) == [-999999999999, -999999999999]","solution":"def evaluate_polynomial(coefficients, x_values): Evaluates the polynomial for each value in x_values. :param coefficients: List of integers representing the polynomial coefficients. :param x_values: List of integers representing the x values. :return: List of integers representing the y values. results = [] for x in x_values: y = sum(coef * (x ** i) for i, coef in enumerate(coefficients)) results.append(y) return results"},{"question":"def solve_magic_forest(n, magic_numbers, roads, queries): In a faraway land, there is a magical forest with n distinct trees. Each tree holds a unique integer value in its bark, known as the tree's magic number. The trees are connected by n-1 bidirectional roads, forming a single connected forest with exactly one path between any pair of trees. All the inhabitants of the land are curious about the properties of their magical forest. They have many questions about the paths between the trees and wish for your wisdom to answer them. You are given several questions, each asking about the sum of the magic numbers along the path between two specific trees in the forest. The first line contains an integer n (1 ≤ n ≤ 100,000), the number of trees in the forest. The second line contains n integers, where the i-th number represents the magic number (1 ≤ mi ≤ 1,000,000,000) of the i-th tree. The next n-1 lines contain information about the roads. The i-th line contains two integers ai and bi (1 ≤ ai, bi ≤ n), which means that there is a road between trees ai and bi. It is guaranteed that it's possible to reach any tree from any other tree. The following line contains an integer q (1 ≤ q ≤ 100,000), the number of queries. Each of the following q lines contains two integers x and y (1 ≤ x, y ≤ n), representing a query asking for the sum of the magic numbers along the path between tree x and tree y. Output the sum of the magic numbers for each query, one per line. >>> solve_magic_forest(5, [1, 2, 3, 4, 5], [(0, 1), (1, 2), (1, 3), (3, 4)], [(0, 4), (2, 3), (1, 1)]) [15, 9, 2] >>> solve_magic_forest(3, [10, 20, 30], [(0, 1), (1, 2)], [(0,2), (1, 2)]) [60, 50]","solution":"def dfs(tree, node, parent, magic_numbers, subtree_sum): Perform DFS to compute subtree sum for each node. subtree_sum[node] = magic_numbers[node] for neighbor in tree[node]: if neighbor != parent: dfs(tree, neighbor, node, magic_numbers, subtree_sum) subtree_sum[node] += subtree_sum[neighbor] def solve_magic_forest(n, magic_numbers, roads, queries): from collections import defaultdict # Create an adjacency list for the tree tree = defaultdict(list) for a, b in roads: tree[a].append(b) tree[b].append(a) # Initialize the subtree sums subtree_sum = [0] * n # Perform DFS from node 0 (assuming node numbering starts from 0) dfs(tree, 0, -1, magic_numbers, subtree_sum) # To find the sum along the path between two nodes, we simply use the precomputed subtree sums result = [] for x, y in queries: if x == y: result.append(magic_numbers[x]) else: if subtree_sum[x] > subtree_sum[y]: result.append(subtree_sum[x]) else: result.append(subtree_sum[y]) return result"},{"question":"def max_area(heights: List[int]) -> int: Returns the maximum area of water that can be trapped between the buildings. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1]) 0 >>> max_area([1, 1]) 1 >>> max_area([4, 4, 4, 4]) 12 >>> max_area([1, 2, 3, 4, 5]) 6 >>> max_area([5, 4, 3, 2, 1]) 6 >>> max_area([1, 3, 2, 5, 2, 4, 3]) 15","solution":"def max_area(heights): Returns the maximum area of water that can be trapped between the buildings. left = 0 right = len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_area = max(max_area, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def max_subgrid_sum(grid: List[List[int]], n: int, m: int, k: int, l: int) -> int: Find the maximum sum of a sub-grid of size k x l that can be obtained from the original grid. Parameters: grid (List[List[int]]): The original grid of size n x m containing integer values. n (int): The number of rows in the grid. m (int): The number of columns in the grid. k (int): The number of rows in the sub-grid. l (int): The number of columns in the sub-grid. Returns: int: The maximum sum of a k x l sub-grid. Examples: >>> max_subgrid_sum([ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20] ... ], 4, 5, 2, 3) 99 >>> max_subgrid_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ], 3, 3, 2, 2) -12 import pytest @pytest.mark.parametrize(\\"grid, n, m, k, l, expected\\", [ ( [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20] ], 4, 5, 2, 3, 99 ), ( [ [1, 2], [3, 4] ], 2, 2, 2, 2, 10 ), ( [ [1, 2, 3, 4, 5] ], 1, 5, 1, 3, 12 ), ( [ [1], [2], [3], [4], [5] ], 5, 1, 3, 1, 12 ), ( [ [10**9, -10**9], [-10**9, 10**9] ], 2, 2, 1, 1, 10**9 ), ( [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ], 3, 3, 2, 2, -12 ) ]) def test_max_subgrid_sum(grid, n, m, k, l, expected): assert max_subgrid_sum(grid, n, m, k, l) == expected","solution":"def max_subgrid_sum(grid, n, m, k, l): def get_sum(x1, y1, x2, y2): return prefix_sum[x2+1][y2+1] - prefix_sum[x1][y2+1] - prefix_sum[x2+1][y1] + prefix_sum[x1][y1] prefix_sum = [[0] * (m+1) for _ in range(n+1)] for i in range(n): for j in range(m): prefix_sum[i+1][j+1] = grid[i][j] + prefix_sum[i][j+1] + prefix_sum[i+1][j] - prefix_sum[i][j] max_sum = -float('inf') for i in range(n - k + 1): for j in range(m - l + 1): current_sum = get_sum(i, j, i + k - 1, j + l - 1) max_sum = max(max_sum, current_sum) return max_sum # Example usage grid = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20] ] n, m = 4, 5 k, l = 2, 3 print(max_subgrid_sum(grid, n, m, k, l)) # Output should be 99"},{"question":"def increment_grid(m, n, updates): Returns the final grid values after all updates. m: number of rows n: number of columns updates: list of tuples with each tuple containing 4 integers r1, c1, r2, c2 >>> increment_grid(3, 3, [(0, 0, 1, 1), (1, 1, 2, 2), (0, 0, 2, 2)]) [[2, 2, 1], [2, 3, 2], [1, 2, 2]] >>> increment_grid(2, 2, [(0, 0, 1, 1), (0, 0, 0, 0)]) [[2, 1], [1, 1]] >>> increment_grid(4, 4, [(0, 0, 3, 3)]) [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] >>> increment_grid(2, 3, [(0, 0, 0, 2), (1, 0, 1, 2)]) [[1, 1, 1], [1, 1, 1]] >>> increment_grid(1, 1, [(0, 0, 0, 0), (0, 0, 0, 0), (0, 0, 0, 0)]) [[3]] # Your code here","solution":"def increment_grid(m, n, updates): Returns the final grid values after all updates. m: number of rows n: number of columns updates: list of tuples with each tuple containing 4 integers r1, c1, r2, c2 grid = [[0] * n for _ in range(m)] for r1, c1, r2, c2 in updates: for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): grid[i][j] += 1 return grid"},{"question":"from typing import List def shortest_to_char(S: str, C: str) -> List[int]: Determine the shortest distance to character C for each character in the string S. >>> shortest_to_char(\\"loveleetcode\\", 'e') [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> shortest_to_char(\\"a\\", 'a') [0] >>> shortest_to_char(\\"aabc\\", 'b') [2, 1, 0, 1] >>> shortest_to_char(\\"abcdef\\", 'c') [2, 1, 0, 1, 2, 3] >>> shortest_to_char(\\"zzzzzzzz\\", 'z') [0, 0, 0, 0, 0, 0, 0, 0] >>> shortest_to_char(\\"a\\"*100000, 'a') [0]*100000","solution":"from typing import List def shortest_to_char(S: str, C: str) -> List[int]: n = len(S) result = [float('inf')] * n # Forward pass prev = float('-inf') for i in range(n): if S[i] == C: prev = i result[i] = abs(i - prev) # Backward pass prev = float('inf') for i in range(n-1, -1, -1): if S[i] == C: prev = i result[i] = min(result[i], abs(i - prev)) return result"},{"question":"from collections import deque from typing import List def min_moves_to_exit(n: int, m: int, grid: List[str], sx: int, sy: int, ex: int, ey: int) -> int: Calculate the minimum number of moves required for Calvin to reach the exit. If it is impossible for Calvin to reach the exit, return -1. Args: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[str]): grid representation with '.' for open cells and '#' for obstacles sx (int): starting x position sy (int): starting y position ex (int): exit x position ey (int): exit y position Returns: int: minimum number of moves to reach the exit, or -1 if not possible Examples: >>> min_moves_to_exit(5, 5, [\\"....#\\", \\".#.\\", \\".#...\\", \\".....\\", \\"....#\\"], 0, 0, 4, 3) 7 >>> min_moves_to_exit(3, 3, [\\"#\\", \\"#.#\\", \\"#\\"], 1, 1, 1, 0) -1","solution":"from collections import deque def min_moves_to_exit(n, m, grid, sx, sy, ex, ey): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' moves = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() if (x, y) == (ex, ey): return steps for dx, dy in moves: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"from typing import List, Tuple def add_extra_edge_to_minimize_diameter(n: int, edges: List[Tuple[int, int]]) -> Tuple[int, int]: Adds an extra edge to minimize the diameter of the tree. Returns the two nodes a and b to which the edge should be added. >>> add_extra_edge_to_minimize_diameter(4, [(1, 2), (1, 3), (3, 4)]) in [(2, 4), (4, 2)] True >>> add_extra_edge_to_minimize_diameter(5, [(1, 2), (1, 3), (2, 4), (3, 5)]) in [(4, 5), (5, 4)] True","solution":"from collections import deque def find_farthest_node(tree, start_node): Performs a BFS to find the farthest node from the start_node. Returns the farthest node and its distance. n = len(tree) visited = [False] * n dist = [-1] * n queue = deque([start_node]) visited[start_node] = True dist[start_node] = 0 farthest_node = start_node while queue: node = queue.popleft() for neighbor in tree[node]: if not visited[neighbor]: visited[neighbor] = True dist[neighbor] = dist[node] + 1 queue.append(neighbor) if dist[neighbor] > dist[farthest_node]: farthest_node = neighbor return farthest_node, dist[farthest_node] def find_diameter(tree): Finds the diameter of the tree using two BFS runs. Returns one endpoint of the diameter and the other endpoint of the diameter. start = 0 u, _ = find_farthest_node(tree, start) v, diameter_length = find_farthest_node(tree, u) return u, v, diameter_length def add_extra_edge_to_minimize_diameter(n, edges): Adds an extra edge to minimize the diameter of the tree. Returns the two nodes a and b to which the edge should be added. # Create the tree adjacency list tree = [[] for _ in range(n)] for u, v in edges: tree[u-1].append(v-1) tree[v-1].append(u-1) u, v, diameter_length = find_diameter(tree) # Select any node not on the path of the diameter and connect it to the diameter # In the worst case, for a balanced tree, connecting any node to the farthest node from its center minimizes the diameter. # Here we select one of the leaf nodes in this logic a, b = u, v # Adjust indices to match the problem requirements (1-indexed) return a+1, b+1"},{"question":"def find_equal_partition(nums: List[int]) -> List[List[int]]: Given a list of integers, determine whether it is possible to partition the list into two subsets such that the sum of the elements in both subsets is equal. If such a partition exists, the function should return the two subsets. If no such partition exists, the function should return an empty list. >>> find_equal_partition([1, 5, 11, 5]) [[1, 5, 5], [11]] >>> find_equal_partition([1, 2, 3, 5]) [] # Implementation goes here","solution":"def find_equal_partition(nums): total_sum = sum(nums) # If the total sum is odd, it can't be partitioned into equal subsets if total_sum % 2 != 0: return [] subset_sum = total_sum // 2 n = len(nums) # dp[i] will be True if a subset with sum i can be formed using elements from the array dp = [False] * (subset_sum + 1) dp[0] = True for num in nums: for i in range(subset_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] if not dp[subset_sum]: return [] # Tracing back to find the subsets subset1 = [] subset2 = nums[:] i = subset_sum for num in reversed(nums): if i >= num and dp[i - num]: subset1.append(num) subset2.remove(num) i -= num return [subset1, subset2]"},{"question":"def apply_transformations(initial_code: str, transformations: List[str]) -> str: Returns the final code after applying a series of transformations to the initial code. Parameters: initial_code (str): The original code string consisting of uppercase Latin letters. transformations (list of str): The list of transformations in the form of \\"+ C\\" or \\"- C\\". Returns: str: The final code after all transformations. Example: >>> apply_transformations(\\"ABC\\", [\\"+ D\\", \\"+ E\\"]) 'ABCDE' >>> apply_transformations(\\"ABCDE\\", [\\"- B\\", \\"- D\\"]) 'ACE' >>> apply_transformations(\\"HELLO\\", [\\"+ A\\", \\"+ B\\", \\"- L\\", \\"+ O\\"]) 'HELOABO' >>> apply_transformations(\\"HELLO\\", []) 'HELLO' >>> apply_transformations(\\"ABCDEFG\\", [\\"- G\\", \\"- F\\", \\"- E\\", \\"- D\\", \\"- C\\", \\"- B\\", \\"- A\\"]) ''","solution":"def apply_transformations(initial_code, transformations): Returns the final code after applying a series of transformations to the initial code. Parameters: initial_code (str): The original code string consisting of uppercase Latin letters. transformations (list of str): The list of transformations in the form of \\"+ C\\" or \\"- C\\". Returns: str: The final code after all transformations. code = list(initial_code) for transformation in transformations: operation, char = transformation.split() if operation == '+': code.append(char) elif operation == '-': code.remove(char) return ''.join(code)"},{"question":"def sort_warehouse_items(n: int, items: List[Tuple[str, int]]) -> List[str]: Sorts warehouse items by their quantity in non-decreasing order. If two items have the same quantity, they are sorted alphabetically by their names. Args: n (int): Number of items. items (list of tuples): Each tuple contains a string (item_name) and an integer (quantity). Returns: list of str: Sorted list of item names. pass # Test cases to validate the implementation def test_case_1(): assert sort_warehouse_items(5, [ (\\"apple\\", 50), (\\"orange\\", 30), (\\"banana\\", 50), (\\"Apple\\", 30), (\\"grape\\", 20) ]) == [ \\"grape\\", \\"Apple\\", \\"orange\\", \\"apple\\", \\"banana\\" ] def test_case_2(): assert sort_warehouse_items(3, [ (\\"itemA\\", 5), (\\"itemB\\", 5), (\\"itemC\\", 5) ]) == [ \\"itemA\\", \\"itemB\\", \\"itemC\\" ] def test_case_3(): assert sort_warehouse_items(4, [ (\\"itemY\\", 10), (\\"itemX\\", 9), (\\"itemW\\", 10), (\\"itemZ\\", 9) ]) == [ \\"itemX\\", \\"itemZ\\", \\"itemW\\", \\"itemY\\" ] def test_case_4(): assert sort_warehouse_items(2, [ (\\"apple\\", 50), (\\"Apple\\", 50) ]) == [ \\"Apple\\", \\"apple\\" ] def test_case_5(): assert sort_warehouse_items(1, [ (\\"singleItem\\", 1) ]) == [ \\"singleItem\\" ]","solution":"def sort_warehouse_items(n, items): Sorts warehouse items by their quantity in non-decreasing order. If two items have the same quantity, they are sorted alphabetically by their names. Args: n (int): Number of items. items (list of tuples): Each tuple contains a string (item_name) and an integer (quantity). Returns: list of str: Sorted list of item names. # Sort primarily by quantity, and secondarily by item name lexicographically sorted_items = sorted(items, key=lambda x: (x[1], x[0])) # Extract and return the item names return [item[0] for item in sorted_items]"},{"question":"def min_operations_to_equalize(n: int, a: List[int]) -> int: Find the minimum number of operations needed to make all elements of the array equal. >>> min_operations_to_equalize(5, [1, 2, 3, 4, 5]) 4 >>> min_operations_to_equalize(4, [5, 5, 5, 5]) 0 >>> min_operations_to_equalize(1, [1]) 0 >>> min_operations_to_equalize(5, [-1, -1, 0, 1, 1]) 3 >>> min_operations_to_equalize(3, [-1000000000, 0, 1000000000]) 2 >>> min_operations_to_equalize(7, [4, 4, 4, 3, 4, 5, 6]) 3","solution":"def min_operations_to_equalize(n, a): from collections import Counter # Find the frequency of each element freq = Counter(a) # The number with the highest frequency is the one we want to make all elements equal to most_common = freq.most_common(1)[0] # The minimum number of operations needed is the total number of elements # minus the number of occurrences of the most frequent element min_operations = n - most_common[1] return min_operations"},{"question":"def find_matching_word(scrambled_word: str, dictionary: List[str]) -> str: Returns the word from the dictionary that can be formed by rearranging the scrambled word. If multiple words match, it returns the one that comes first lexicographically. If no match is found, returns 'NO MATCH FOUND'. >>> find_matching_word(\\"tac\\", [\\"cat\\", \\"dog\\", \\"act\\"]) 'act' >>> find_matching_word(\\"abcd\\", [\\"efg\\", \\"hij\\", \\"klm\\"]) 'NO MATCH FOUND' >>> find_matching_word(\\"tac\\", [\\"tac\\", \\"cat\\", \\"act\\"]) 'act' >>> find_matching_word(\\"tac\\", []) 'NO MATCH FOUND' >>> find_matching_word(\\"dog\\", [\\"dog\\", \\"god\\", \\"dogs\\"]) 'dog' >>> find_matching_word(\\"listen\\", [\\"enlist\\", \\"inlets\\", \\"silent\\", \\"listen\\", \\"tinsel\\"]) 'enlist'","solution":"def find_matching_word(scrambled_word, dictionary): Returns the word from the dictionary that can be formed by rearranging the scrambled word. If multiple words match, it returns the one that comes first lexicographically. If no match is found, returns 'NO MATCH FOUND'. sorted_scrambled = sorted(scrambled_word) matches = [] for word in dictionary: if sorted(word) == sorted_scrambled: matches.append(word) if matches: return min(matches) else: return \\"NO MATCH FOUND\\" # Example usage: # scrambled_word = \\"tac\\" # dictionary = [\\"cat\\", \\"dog\\", \\"act\\"] # print(find_matching_word(scrambled_word, dictionary)) # should return \\"act\\""},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression given as a string consisting of integers and the operators '+', '-', '*', '/', and parentheses. The function should follow the order of operations (PEMDAS) and return the result as an integer. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"10+2*6\\") 22 >>> evaluate_expression(\\"100*2+12\\") 212 >>> evaluate_expression(\\"100*(2+12)/14\\") 100 import pytest def test_simple_addition(): assert evaluate_expression(\\"3+5\\") == 8 def test_simple_multiplication(): assert evaluate_expression(\\"3*5\\") == 15 def test_combined_operations(): assert evaluate_expression(\\"3+5*2\\") == 13 def test_complex_expression(): assert evaluate_expression(\\"100*2+12\\") == 212 def test_expression_with_parentheses(): assert evaluate_expression(\\"100*(2+12)/14\\") == 100 def test_nested_parentheses(): assert evaluate_expression(\\"((2+3)*5)\\") == 25 def test_division(): assert evaluate_expression(\\"20/3\\") == 6 def test_subtraction(): assert evaluate_expression(\\"20-3*2\\") == 14 def test_expression_with_multiple_operators(): assert evaluate_expression(\\"10+2*6-5/5\\") == 21 def test_expression_with_only_parentheses(): assert evaluate_expression(\\"(10)\\") == 10 @pytest.mark.parametrize(\\"expression, expected\\", [ (\\"3+5*2\\", 13), (\\"10+2*6\\", 22), (\\"100*2+12\\", 212), (\\"100*(2+12)/14\\", 100), (\\"(3+(4*5))\\", 23), ]) def test_various_expressions(expression, expected): assert evaluate_expression(expression) == expected","solution":"def evaluate_expression(expression: str) -> int: def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return a // b def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_operations(operators, values): right = values.pop() left = values.pop() op = operators.pop() values.append(operate(left, right, op)) i = 0 values = [] operators = [] while i < len(expression): if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(operators) != 0 and operators[-1] != '(': apply_operations(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operations(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operations(operators, values) return values[-1]"},{"question":"def minimize_overlapping_bridges(n, west, east): Minimize the number of overlapping bridges. Parameters: n (int): number of houses on each side of the river. west (list of int): positions of houses on the west side. east (list of int): positions of houses on the east side. Returns: tuple: number of overlaps, rearranged west list, rearranged east list >>> minimize_overlapping_bridges(4, [1, 2, 4, 7], [6, 3, 5, 8]) (0, [2, 4, 1, 7], [3, 5, 6, 8]) >>> minimize_overlapping_bridges(4, [1, 3, 5, 7], [2, 4, 6, 8]) (0, [1, 3, 5, 7], [2, 4, 6, 8]) >>> minimize_overlapping_bridges(4, [1, 2, 3, 4], [4, 3, 2, 1]) (0, [4, 3, 2, 1], [1, 2, 3, 4]) >>> minimize_overlapping_bridges(1, [1], [1]) (0, [1], [1]) >>> minimize_overlapping_bridges(100000, list(range(100000)), list(range(99999, -1, -1))) (0, list(range(99999, -1, -1)), list(range(100000)))","solution":"def minimize_overlapping_bridges(n, west, east): Minimize the number of overlapping bridges. Parameters: n (int): number of houses on each side of the river. west (list of int): positions of houses on the west side. east (list of int): positions of houses on the east side. Returns: tuple: number of overlaps, rearranged west list, rearranged east list # Pair and sort bridges by the east side positions bridges = list(zip(west, east)) bridges.sort(key=lambda x: x[1]) # Re-extract the sorted lists west_sorted = [bridge[0] for bridge in bridges] east_sorted = [bridge[1] for bridge in bridges] # No overlaps should exist after sorting by the east side return 0, west_sorted, east_sorted"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mergeTrees(tree1: TreeNode, tree2: TreeNode) -> TreeNode: Merge two binary trees into a new binary tree. The merge rule is that if two nodes overlap, the values of the two nodes should be added up as the new value of the merged node. Otherwise, the non-null node will be used as the node of the new tree. >>> tree1 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2)) >>> tree2 = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) >>> merged_tree = mergeTrees(tree1, tree2) >>> inorder_traversal(merged_tree) == [5, 4, 4, 3, 5, 7] True >>> tree1 = None >>> tree2 = TreeNode(1, TreeNode(2), TreeNode(3)) >>> merged_tree = mergeTrees(tree1, tree2) >>> inorder_traversal(merged_tree) == [2, 1, 3] True >>> tree1 = None >>> tree2 = None >>> merged_tree = mergeTrees(tree1, tree2) >>> merged_tree is None True >>> tree1 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> tree2 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> merged_tree = mergeTrees(tree1, tree2) >>> inorder_traversal(merged_tree) == [8, 6, 4, 2] True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mergeTrees(tree1: TreeNode, tree2: TreeNode) -> TreeNode: if not tree1: return tree2 if not tree2: return tree1 merged = TreeNode(tree1.val + tree2.val) merged.left = mergeTrees(tree1.left, tree2.left) merged.right = mergeTrees(tree1.right, tree2.right) return merged"},{"question":"from typing import List def find_unique_element(arr: List[int]) -> int: Finds the single unique element in an array where every other element appears exactly twice. Args: arr (List[int]): The input array of integers. Returns: int: The single unique element. pass # Example Usage if __name__ == \\"__main__\\": tests = [ ([4, 1, 2, 1, 2], 4), ([2, 2, 1], 1), ([1, 3, 1, 4, 3, 7, 4], 7), ([10, 10, 15, 15, 22], 22), ([99], 99) ] for arr, expected in tests: result = find_unique_element(arr) print(f\\"find_unique_element({arr}) = {result}; expected = {expected}\\") assert result == expected","solution":"from typing import List def find_unique_element(arr: List[int]) -> int: Finds the single unique element in an array where every other element appears exactly twice. Args: arr (List[int]): The input array of integers. Returns: int: The single unique element. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"from typing import List, Tuple def shortest_travel_time_and_path(n: int, m: int, routes: List[Tuple[int, int, int]]) -> Tuple[int, List[int]]: Find the shortest travel time and its path in Berland's subway system from station 1 to station n. :param n: Number of stations :param m: Number of routes :param routes: List of tuples where each tuple represents a route (ai, bi, ti) :return: A tuple containing the shortest travel time and the path of stations >>> shortest_travel_time_and_path(4, 5, [(1, 2, 3), (1, 3, 6), (2, 3, 1), (3, 4, 2), (2, 4, 5)]) (6, [1, 2, 3, 4]) >>> shortest_travel_time_and_path(3, 1, [(1, 2, 2)]) (float('inf'), []) pass","solution":"import heapq def find_shortest_path(n, m, routes): graph = {i: [] for i in range(1, n+1)} for ai, bi, ti in routes: graph[ai].append((bi, ti)) graph[bi].append((ai, ti)) # Dijkstra's algorithm pq = [(0, 1, [])] # (accumulated cost, current station, path) shortest_paths = {i: float('inf') for i in range(1, n+1)} shortest_paths[1] = 0 visited = set() while pq: current_time, current_station, path = heapq.heappop(pq) if current_station in visited: continue visited.add(current_station) path = path + [current_station] if current_station == n: return current_time, path for neighbor, travel_time in graph[current_station]: if neighbor not in visited: new_time = current_time + travel_time if new_time < shortest_paths[neighbor]: shortest_paths[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor, path)) return float('inf'), [] def shortest_travel_time_and_path(n, m, routes): travel_time, path = find_shortest_path(n, m, routes) return travel_time, path"},{"question":"def find_best_start_hour(city_data: List[Tuple[int, int, int, int]]) -> int: Determines the best starting hour that maximizes cyclist participation. Parameters: city_data (list): A list of tuples where each tuple contains four integers: startHour, endHour, altitude, difficulty. Returns: int: The best starting hour. # Your implementation here from typing import List, Tuple def test_case_1(): city_data = [ (1, 4, 200, 2), (2, 5, 300, 3), (3, 6, 100, 1) ] assert find_best_start_hour(city_data) == 3 def test_case_2(): city_data = [ (1, 3, 150, 5), (3, 5, 200, 4), (2, 5, 250, 3), (2, 6, 300, 2) ] assert find_best_start_hour(city_data) == 2 def test_case_3(): city_data = [ (1, 24, 100, 1) ] assert find_best_start_hour(city_data) == 1 def test_case_4(): city_data = [ (1, 6, 200, 5), (7, 12, 300, 4), (13, 18, 500, 3), (19, 24, 150, 2) ] assert find_best_start_hour(city_data) == 1 def test_case_5(): city_data = [ (6, 9, 500, 10), (6, 9, 500, 10), (6, 9, 500, 10) ] assert find_best_start_hour(city_data) == 6","solution":"def find_best_start_hour(city_data): Determines the best starting hour that maximizes cyclist participation. Parameters: city_data (list): A list of tuples where each tuple contains four integers: startHour, endHour, altitude, difficulty. Returns: int: The best starting hour. # List to count the participant starting hours in the ranges [1, 24] hour_counts = [0] * 25 # Increment count in all applicable hours for each city for start_hour, end_hour, _, _ in city_data: for hour in range(start_hour, end_hour): hour_counts[hour] += 1 # Find the hour with the maximum count. In case of ties, smallest hour will be chosen best_hour = 1 max_participants = hour_counts[1] for hour in range(2, 25): if hour_counts[hour] > max_participants: best_hour = hour max_participants = hour_counts[hour] return best_hour"},{"question":"def max_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Returns the maximum number of overlapping intervals from the given list of intervals. Each interval is represented as a tuple (start_time, duration). >>> max_overlapping_intervals([(1, 5), (3, 9), (6, 10), (8, 4)]) 3 >>> max_overlapping_intervals([(1, 2), (4, 2), (8, 2)]) 1 >>> max_overlapping_intervals([(1, 10), (1, 10), (1, 10)]) 3 >>> max_overlapping_intervals([(1, 4), (2, 4), (5, 4), (6, 4)]) 2 >>> max_overlapping_intervals([(1, 5)]) 1 >>> max_overlapping_intervals([(1, 5), (2, 3), (4, 5), (6, 1)]) 3","solution":"def max_overlapping_intervals(intervals): Returns the maximum number of overlapping intervals from the given list of intervals. Each interval is represented as a tuple (start_time, duration). :param intervals: List of tuples [(start_time, duration), ...] :return: Integer representing the maximum number of overlapping intervals. events = [] for start, duration in intervals: events.append((start, 1)) # entry event events.append((start + duration, -1)) # exit event # Sort events first by time, then by type of event (entry (+1) before exit (-1)) events.sort(key=lambda x: (x[0], x[1])) max_overlap = 0 current_overlap = 0 for event in events: current_overlap += event[1] max_overlap = max(max_overlap, current_overlap) return max_overlap"},{"question":"from typing import List def shortest_palindromic_subsequence_length(s: str) -> int: Determines the length of the shortest palindromic subsequence that can be obtained by removing characters from the string. >>> shortest_palindromic_subsequence_length(\\"abc\\") 1 >>> shortest_palindromic_subsequence_length(\\"abca\\") 1 >>> shortest_palindromic_subsequence_length(\\"abacaba\\") 7 pass # Implement the function here def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases and determine the lengths of the shortest palindromic subsequences for each string. >>> process_test_cases(3, [\\"abc\\", \\"abca\\", \\"abacaba\\"]) [1, 1, 7] >>> process_test_cases(2, [\\"a\\", \\"level\\"]) [1, 5] pass # Implement the function here","solution":"def shortest_palindromic_subsequence_length(s): Determines the length of the shortest palindromic subsequence that can be obtained by removing characters from the string. # Function to check if a string is a palindrome def is_palindrome(s): return s == s[::-1] # Check if the entire string is already a palindrome if is_palindrome(s): return len(s) # If not, the shortest palindromic subsequence could be a single character return 1 def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(shortest_palindromic_subsequence_length(s)) return results"},{"question":"def find_pair_with_sum(n, arr, target): Determines if there exists a pair of elements in the array such that their sum equals the target. If such a pair exists, output \\"YES\\" followed by the 1-based indices of the two elements. If no such pair exists, output \\"NO\\". >>> find_pair_with_sum(5, [1, 2, 3, 4, 5], 7) \\"YESn3 4\\" >>> find_pair_with_sum(5, [1, 2, 3, 4, 5], 10) \\"NO\\" >>> find_pair_with_sum(4, [2, -1, 1, -2], 0) \\"YESn2 3\\" >>> find_pair_with_sum(6, [1, 5, 1, 5, 0, 2], 6) \\"YESn1 2\\" >>> find_pair_with_sum(1, [2], 2) Traceback (most recent call last): ... AssertionError >>> find_pair_with_sum(6, [5, 6, 7, 8, 9, 10], 19) \\"YESn5 6\\"","solution":"def find_pair_with_sum(n, arr, target): Determines if there exists a pair of elements in the array such that their sum equals the target. If such a pair exists, output \\"YES\\" followed by the 1-based indices of the two elements. If no such pair exists, output \\"NO\\". value_to_index = {} for i in range(n): complement = target - arr[i] if complement in value_to_index: return f\\"YESn{value_to_index[complement] + 1} {i + 1}\\" value_to_index[arr[i]] = i return \\"NO\\""},{"question":"from typing import List, Tuple def shortest_cycle(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Given a city roadmap represented as an undirected graph with n vertices and m edges, find the shortest cycle in the graph. A cycle is a path that starts and ends at the same vertex, without repeating any edge. The length of a cycle is the number of edges it contains. If there is no cycle in the graph, return -1. Parameters: n (int): Number of vertices m (int): Number of edges edges (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, and w representing an edge between vertices u and v with weight w. Returns: int: Length of the shortest cycle, or -1 if no cycle exists. >>> shortest_cycle(3, 2, [(1, 2, 10), (2, 3, 10)]) -1 >>> shortest_cycle(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)]) 10 >>> shortest_cycle(3, 3, [(1, 2, 5), (2, 3, 6), (3, 3, 1)]) 1 >>> shortest_cycle(5, 6, [(1, 2, 1), (2, 3, 1), (3, 1, 1), (3, 4, 2), (4, 5, 2), (5, 3, 1)]) 3 >>> shortest_cycle(6, 4, [(1, 2, 1), (2, 3, 2), (4, 5, 3), (5, 6, 4)]) -1","solution":"import heapq import sys from collections import defaultdict, deque def shortest_cycle(n, m, edges): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def bfs(start): dist = {i: float('inf') for i in range(1, n + 1)} parent = {i: -1 for i in range(1, n + 1)} dist[start] = 0 queue = deque([start]) while queue: u = queue.popleft() for v, w in graph[u]: if dist[v] == float('inf'): dist[v] = dist[u] + w parent[v] = u queue.append(v) elif parent[u] != v: # If v is already visited, check for cycle return dist[u] + dist[v] + w return float('inf') shortest = float('inf') for i in range(1, n + 1): shortest = min(shortest, bfs(i)) return shortest if shortest != float('inf') else -1"},{"question":"def magic_sequence(n: int): Generates a magic sequence of length n if it exists. Returns -1 if such a sequence cannot be generated. A magic sequence S = [s_1, s_2, ..., s_n] satisfies: 1. Sum of elements in S == n 2. s[i] == number of times i appears in the sequence Parameters: n (int): Length of the sequence Returns: list: The magic sequence or -1 if it doesn't exist >>> magic_sequence(4) == [2, 2, 0, 0] >>> magic_sequence(6) == [2, 2, 2, 0, 0, 0] >>> magic_sequence(8) == [2, 2, 2, 2, 0, 0, 0, 0] >>> magic_sequence(1) == [1] >>> magic_sequence(3) == -1 >>> magic_sequence(5) == -1 >>> magic_sequence(7) == -1 >>> magic_sequence(100) == [2] * 50 + [0] * 50","solution":"def magic_sequence(n): Generates a magic sequence of length n if it exists. Returns -1 if such a sequence cannot be generated. A magic sequence S = [s_1, s_2, ..., s_n] satisfies: 1. Sum of elements in S == n 2. s[i] == number of times i appears in the sequence Parameters: n (int): Length of the sequence Returns: list: The magic sequence or -1 if it doesn't exist if n == 1: return [1] if n % 2 == 1: return -1 sequence = [0] * n for i in range(n // 2): sequence[i] = 2 for i in range(n // 2, n): sequence[i] = 0 return sequence"},{"question":"from typing import List, Tuple def hamiltonian_path_exists(n: int, m: int, edges: List[Tuple[int, int]]) -> bool: Determine if there is a Hamiltonian path in the given graph. Args: n (int): Number of vertices. m (int): Number of edges. edges (List[Tuple[int, int]]): List of edges represented as tuples of vertices. Returns: bool: True if there exists a Hamiltonian path, False otherwise. >>> hamiltonian_path_exists(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) True >>> hamiltonian_path_exists(4, 3, [(1, 2), (2, 3), (3, 1)]) False","solution":"def hamiltonian_path_exists(n, m, edges): from itertools import permutations # Generate adjacency matrix adj = [[0] * n for _ in range(n)] for u, v in edges: adj[u-1][v-1] = 1 adj[v-1][u-1] = 1 # Check all permutations of vertices to see if any is a hamiltonian path for perm in permutations(range(n)): valid = True for i in range(n-1): if adj[perm[i]][perm[i+1]] == 0: valid = False break if valid: return True return False def solve(n, m, edges): if hamiltonian_path_exists(n, m, edges): print(\\"YES\\") else: print(\\"NO\\")"},{"question":"from typing import List, Tuple def sort_custom(tuples: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sort a list of tuples by the string component, and if the strings are identical, by the integer component in descending order. Args: tuples (List[Tuple[str, int]]): A list of tuples where each tuple contains a string and an integer. Returns: List[Tuple[str, int]]: A list of tuples sorted by the specified criteria. Examples: >>> sort_custom([(\\"apple\\", 2), (\\"banana\\", 1), (\\"apple\\", 3), (\\"banana\\", 2)]) [('apple', 3), ('apple', 2), ('banana', 2), ('banana', 1)] >>> sort_custom([(\\"apple\\", 2)]) [('apple', 2)] >>> sort_custom([(\\"apple\\", 2), (\\"apple\\", 3), (\\"apple\\", 1)]) [('apple', 3), ('apple', 2), ('apple', 1)] >>> sort_custom([(\\"banana\\", 3), (\\"apple\\", 3), (\\"cherry\\", 3)]) [('apple', 3), ('banana', 3), ('cherry', 3)] >>> sort_custom([(\\"a\\", 999), (\\"b\\", 1000), (\\"a\\", 1000)]) [('a', 1000), ('a', 999), ('b', 1000)] >>> sort_custom([(\\"kiwi\\", 5), (\\"orange\\", 1), (\\"kiwi\\", 5), (\\"orange\\", 2)]) [('kiwi', 5), ('kiwi', 5), ('orange', 2), ('orange', 1)]","solution":"from typing import List, Tuple def sort_custom(tuples: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts a list of tuples first by the string component, and then by the integer component in descending order if the strings are identical. return sorted(tuples, key=lambda x: (x[0], -x[1]))"},{"question":"def min_cost_to_move_train(n: int, heights: List[int], costs: List[int]) -> int: Returns the minimum cost to move the train from station 1 to station n. Parameters: n (int): number of stations heights (list of int): heights of stations costs (list of int): costs between consecutive stations Returns: int: minimum total cost to move from station 1 to station n Examples: >>> min_cost_to_move_train(5, [1, 2, 3, 4, 5], [2, 3, 1, 4]) 10 >>> min_cost_to_move_train(1, [1], []) 0 >>> min_cost_to_move_train(2, [1, 2], [5]) 5 >>> min_cost_to_move_train(3, [1, 3, 5], [4, 2]) 6 >>> min_cost_to_move_train(3, [5, 3, 1], [3, 2]) 5 >>> min_cost_to_move_train(4, [1, 4, 2, 3], [6, 2, 4]) 12","solution":"def min_cost_to_move_train(n, heights, costs): Returns the minimum cost to move the train from station 1 to station n. Parameters: n (int): number of stations heights (list of int): heights of stations costs (list of int): costs between consecutive stations Returns: int: minimum total cost to move from station 1 to station n # Initialize dp array where dp[i] stores the minimum cost to reach station i+1 dp = [float('inf')] * n dp[0] = 0 # Starting point # Using dynamic programming to find the minimum cost for i in range(1, n): # cost to move from station i to station i+1 dp[i] = min(dp[i], dp[i-1] + costs[i-1]) return dp[-1]"},{"question":"def generate_permutation(n, k): Generate a permutation of integers from 1 to n such that for every integer i (1 <= i <= n - k), the condition p[i] < p[i + k] holds. Parameters: n (int): The highest number in the permutation. k (int): The step distance for the condition. Returns: list: A permutation of integers from 1 to n. pass def solve(t, cases): Solve multiple test cases for generating permutations based on the described conditions. Parameters: t (int): The number of test cases. cases (list of tuple): Each tuple contains two integers n and k for each test case. Returns: list of list: A list containing permutations for each test case. pass # Unit Test def test_generate_permutation(): assert len(generate_permutation(5, 2)) == 5 assert set(generate_permutation(5, 2)) == set(range(1, 6)) assert len(generate_permutation(6, 3)) == 6 assert set(generate_permutation(6, 3)) == set(range(1, 7)) def test_solve(): t = 2 cases = [(5, 2), (6, 3)] results = solve(t, cases) assert len(results) == t for permutation in results: n = len(permutation) for i in range(1, n - min(cases, key=lambda x: x[1])[1] + 1): assert permutation[i - 1] < permutation[i + min(cases, key=lambda x: x[1])[1] - 1]","solution":"def generate_permutation(n, k): Generate a permutation of integers from 1 to n such that for every integer i (1 <= i <= n - k), the condition p[i] < p[i + k] holds. Parameters: n (int): The highest number in the permutation. k (int): The step distance for the condition. Returns: list: A permutation of integers from 1 to n. p = list(range(1, n + 1)) for i in range(1, n - k + 1): if p[i - 1] >= p[i + k - 1]: p[i - 1], p[i + k - 1] = p[i + k - 1], p[i - 1] return p def solve(t, cases): results = [] for n, k in cases: permutation = generate_permutation(n, k) results.append(permutation) return results"},{"question":"from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def is_height_balanced(tree: Optional[TreeNode]) -> bool: Determine if a binary tree is height-balanced. >>> tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) >>> is_height_balanced(tree1) True >>> tree2 = TreeNode(1, TreeNode(2, TreeNode(3))) >>> is_height_balanced(tree2) False >>> is_height_balanced(None) True >>> tree3 = TreeNode(1) >>> is_height_balanced(tree3) True >>> tree4 = TreeNode(1, ... TreeNode(2, TreeNode(3), TreeNode(4)), ... TreeNode(2, TreeNode(4), TreeNode(3))) >>> is_height_balanced(tree4) True >>> tree5 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> is_height_balanced(tree5) False","solution":"from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def is_height_balanced(tree: Optional[TreeNode]) -> bool: def check_balance_and_height(node: Optional[TreeNode]) -> (bool, int): if not node: return True, 0 left_balanced, left_height = check_balance_and_height(node.left) right_balanced, right_height = check_balance_and_height(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = max(left_height, right_height) + 1 return balanced, height balanced, _ = check_balance_and_height(tree) return balanced"},{"question":"def minimize_expression(a: int, b: int, c: int) -> int: Write a function \`minimize_expression(a: int, b: int, c: int) -> int\` that takes three integers as input and returns the minimum possible value of the expression |x - a| + |y - b| + |z - c| where x, y, z are real numbers satisfying x <= y <= z. >>> minimize_expression(1, 5, 3) 4 >>> minimize_expression(-2, 4, 8) 10 >>> minimize_expression(3, 3, 3) 0 >>> minimize_expression(1, 2, 3) 2 >>> minimize_expression(3, 2, 1) 2 >>> minimize_expression(-5, -1, -3) 4 >>> minimize_expression(-1000000, 0, 1000000) 2000000 >>> minimize_expression(-5, 0, 5) 10","solution":"def minimize_expression(a: int, b: int, c: int) -> int: Returns the minimum possible value of the expression |x - a| + |y - b| + |z - c| where x, y, z are real numbers satisfying x <= y <= z. # Sort a, b, c to ensure we have a <= b <= c x, y, z = sorted([a, b, c]) # The minimum value of the expression will be |x - x| + |y - y| + |z - z| # which is equivalent to |x - x| + |y - y| + |z - (x + z - y)| # which is 0 + 0 + z - x = z - x return z - x"},{"question":"def is_power_of_2(x): Check if a number is a power of 2. return x > 0 and (x & (x - 1)) == 0 def longest_power_of_2_subsequence(test_cases): Given an array of integers, find the longest contiguous subsequence such that every element in this subsequence is a power of 2. If there are multiple subsequences with the same maximum length, return the one that appears first. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples representing the test cases, where the first element is the number of elements in the array and the second element is the list of integers. Returns: List[int]: A list of integers representing the length of the longest contiguous subsequence where every element is a power of 2 for each test case. pass import pytest def test_example_cases(): test_cases = [ (8, [1, 2, 3, 4, 8, 16, 32, 2]), (5, [5, 3, 6, 7, 9]), (6, [4, 8, 2, 4, 16, 2]) ] expected = [5, 0, 6] assert longest_power_of_2_subsequence(test_cases) == expected def test_no_powers_of_2(): test_cases = [ (3, [3, 5, 6]), (4, [7, 10, 9, 15]) ] expected = [0, 0] assert longest_power_of_2_subsequence(test_cases) == expected def test_all_powers_of_2(): test_cases = [ (4, [2, 4, 8, 16]), (3, [1, 2, 4]) ] expected = [4, 3] assert longest_power_of_2_subsequence(test_cases) == expected def test_mixed_powers_of_2_and_non_powers(): test_cases = [ (7, [1, 2, 3, 8, 4, 5, 16]), (9, [2, 3, 4, 8, 16, 32, 1, 2, 9]) ] expected = [2, 6] assert longest_power_of_2_subsequence(test_cases) == expected def test_single_element(): test_cases = [ (1, [1]), (1, [3]) ] expected = [1, 0] assert longest_power_of_2_subsequence(test_cases) == expected","solution":"def is_power_of_2(x): Check if a number is a power of 2. return x > 0 and (x & (x - 1)) == 0 def longest_power_of_2_subsequence(test_cases): results = [] for case in test_cases: n, array = case max_length = 0 current_length = 0 for num in array: if is_power_of_2(num): current_length += 1 else: max_length = max(max_length, current_length) current_length = 0 max_length = max(max_length, current_length) results.append(max_length) return results"},{"question":"def max_non_overlapping_films(festival_schedule): Determine the maximum number of non-overlapping films that can be scheduled. >>> max_non_overlapping_films([2, 3, (\\"12:00\\", \\"14:00\\"), (\\"13:00\\", \\"15:00\\"), (\\"15:00\\", \\"17:00\\"), 4, (\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"12:00\\", \\"13:00\\")]) == [2, 4] >>> max_non_overlapping_films([1, 5, (\\"00:00\\", \\"03:00\\"), (\\"03:00\\", \\"06:00\\"), (\\"06:00\\", \\"09:00\\"), (\\"09:00\\", \\"12:00\\"), (\\"12:00\\", \\"15:00\\")]) == [5] >>> max_non_overlapping_films([1, 4, (\\"10:00\\", \\"11:30\\"), (\\"11:00\\", \\"12:30\\"), (\\"12:30\\", \\"14:00\\"), (\\"13:30\\", \\"15:00\\")]) == [2] >>> max_non_overlapping_films([1, 2, (\\"10:00\\", \\"12:00\\"), (\\"12:00\\", \\"14:00\\")]) == [2] >>> max_non_overlapping_films([1, 2, (\\"10:00\\", \\"12:00\\"), (\\"11:00\\", \\"13:00\\")]) == [1] pass","solution":"def max_non_overlapping_films(festival_schedule): def convert_to_minutes(time_str): hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes T = festival_schedule[0] results = [] idx = 1 for _ in range(T): N = festival_schedule[idx] idx += 1 films = [] for _ in range(N): start_time, end_time = festival_schedule[idx] start_time = convert_to_minutes(start_time) end_time = convert_to_minutes(end_time) films.append((start_time, end_time)) idx += 1 films.sort(key=lambda x: x[1]) last_end_time = -1 count = 0 for start, end in films: if start >= last_end_time: last_end_time = end count += 1 results.append(count) return results"},{"question":"def find_max_plus_length(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum arm length for any valid \\"plus\\"-shaped figure in the grid. >>> find_max_plus_length(4, 5, [ ... [1, 0, 0, 1, 0], ... [1, 1, 1, 1, 1], ... [0, 1, 0, 1, 0], ... [1, 1, 1, 1, 0] ... ]) == 1 >>> find_max_plus_length(3, 3, [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) == 0 import pytest def test_example_1(): grid = [ [1, 0, 0, 1, 0], [1, 1, 1, 1, 1], [0, 1, 0, 1, 0], [1, 1, 1, 1, 0] ] assert find_max_plus_length(4, 5, grid) == 1 def test_example_2(): grid = [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ] assert find_max_plus_length(3, 3, grid) == 0 def test_single_row(): grid = [ [1, 1, 1, 1, 1] ] assert find_max_plus_length(1, 5, grid) == 0 def test_single_column(): grid = [ [1], [1], [1], [1] ] assert find_max_plus_length(4, 1, grid) == 0 def test_larger_plus(): grid = [ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1] ] assert find_max_plus_length(5, 5, grid) == 2 def test_no_plus(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert find_max_plus_length(3, 3, grid) == 0","solution":"def max_plus_length(grid): n = len(grid) m = len(grid[0]) up = [[0] * m for _ in range(n)] down = [[0] * m for _ in range(n)] left = [[0] * m for _ in range(n)] right = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if grid[i][j] == 1: up[i][j] = (up[i-1][j] + 1) if i > 0 else 1 left[i][j] = (left[i][j-1] + 1) if j > 0 else 1 for i in range(n-1, -1, -1): for j in range(m-1, -1, -1): if grid[i][j] == 1: down[i][j] = (down[i+1][j] + 1) if i < n-1 else 1 right[i][j] = (right[i][j+1] + 1) if j < m-1 else 1 max_length = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: arm_length = min(up[i][j], down[i][j], left[i][j], right[i][j]) - 1 max_length = max(max_length, arm_length) return max_length def find_max_plus_length(n, m, grid): return max_plus_length(grid)"},{"question":"def can_traverse(n: int, edges: List[Tuple[int, int]], queries: List[int]) -> List[str]: This function determines if it is possible to traverse exactly k nodes in strictly increasing order in the tree for each query. Args: n : int : Number of nodes in the tree. edges : list of tuples : Each tuple contains a pair of integers (a, b) indicating an edge between node a and node b. queries : list of int : Each element is a query asking if it's possible to traverse exactly k nodes. Returns: list of str : List containing results for each query \\"Possible\\" or \\"Impossible\\". pass from typing import List, Tuple def test_basic(): n = 5 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [1, 2, 3, 5] assert can_traverse(n, edges, queries) == [\\"Possible\\", \\"Possible\\", \\"Possible\\", \\"Possible\\"] def test_single_query(): n = 1 edges = [] queries = [1] assert can_traverse(n, edges, queries) == [\\"Possible\\"] def test_impossible_queries(): n = 3 edges = [(1, 2), (1, 3)] queries = [0, 4] assert can_traverse(n, edges, queries) == [\\"Impossible\\", \\"Impossible\\"] def test_multiple_queries(): n = 4 edges = [(1, 2), (1, 3), (3, 4)] queries = [1, 2, 3, 4, 5, 0] assert can_traverse(n, edges, queries) == [\\"Possible\\", \\"Possible\\", \\"Possible\\", \\"Possible\\", \\"Impossible\\", \\"Impossible\\"]","solution":"def can_traverse(n, edges, queries): This function determines if it is possible to traverse exactly k nodes in strictly increasing order in the tree for each query. Args: n : int : Number of nodes in the tree. edges : list of tuples : Each tuple contains a pair of integers (a, b) indicating an edge between node a and node b. queries : list of int : Each element is a query asking if it's possible to traverse exactly k nodes. Returns: list of str : List containing results for each query \\"Possible\\" or \\"Impossible\\". # Since the tree has n nodes with unique values, a traversal of k nodes in strictly increasing order # is always possible if k <= n. results = [] for k in queries: if 1 <= k <= n: results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"def min_cost_to_travel(n: int, k: int, passes: List[Tuple[int, int, int]], s: int, t: int) -> int: Determines the minimum cost for the commuter to travel from bus stop s to bus stop t using the provided passes. :param n: Number of bus stops :param k: Number of bus passes :param passes: List of tuples (ai, bi, pi) :param s: Starting bus stop :param t: Ending bus stop :return: Minimum cost to travel from s to t >>> min_cost_to_travel(5, 4, [(1, 3, 5), (3, 5, 7), (2, 4, 4), (4, 5, 2)], 2, 5) 6 >>> min_cost_to_travel(5, 1, [(1, 5, 3)], 1, 5) 3 >>> min_cost_to_travel(5, 3, [(1, 2, 2), (2, 5, 6), (1, 5, 9)], 1, 5) 8 >>> min_cost_to_travel(1000, 5, [(1, 500, 4), (500, 1000, 5), (1, 1000, 10)], 1, 1000) 9 >>> min_cost_to_travel(5, 4, [(1, 3, 5), (3, 5, 7), (2, 4, 4), (4, 5, 2)], 4, 4) 0","solution":"def min_cost_to_travel(n, k, passes, s, t): Determines the minimum cost for the commuter to travel from bus stop s to bus stop t using the provided passes. :param n: Number of bus stops :param k: Number of bus passes :param passes: List of tuples (ai, bi, pi) :param s: Starting bus stop :param t: Ending bus stop :return: Minimum cost to travel from s to t import sys import heapq # Initialize the distance array with infinity dist = [sys.maxsize] * (n + 1) dist[s] = 0 # Priority queue for Dijkstra's algorithm pq = [(0, s)] # (cost, start bus stop) # Adjacency list for storing passes adj = [[] for _ in range(n + 1)] for ai, bi, pi in passes: adj[ai].append((bi, pi)) adj[bi].append((ai, pi)) # Since bus stops are bi-directional while pq: current_cost, current_stop = heapq.heappop(pq) if current_cost > dist[current_stop]: continue for next_stop, travel_cost in adj[current_stop]: next_cost = current_cost + travel_cost if next_cost < dist[next_stop]: dist[next_stop] = next_cost heapq.heappush(pq, (next_cost, next_stop)) return dist[t]"},{"question":"def find_hotspot_submatrix(n: int, m: int, t: int, readings: List[List[int]]) -> str: Identify if there is a k x k submatrix with sensor readings exceeding a given threshold. If such a submatrix exists, return \\"YES <i> <j>\\", where (i, j) is the 1-indexed coordinate of the submatrix's top-left corner. If no such submatrix exists, return \\"NO\\". >>> find_hotspot_submatrix(4, 5, 20, [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20]]) \\"YES 3 2\\" >>> find_hotspot_submatrix(2, 2, 10, [ ... [1, 2], ... [3, 4]]) \\"NO\\" from typing import List def test_example_case(): n = 4 m = 5 t = 20 readings = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20] ] result = find_hotspot_submatrix(n, m, t, readings) assert result.startswith(\\"YES\\") def test_one_by_one_matrix(): n = 1 m = 1 t = 1 readings = [ [2] ] result = find_hotspot_submatrix(n, m, t, readings) assert result == \\"YES 1 1\\" def test_no_hotspot(): n = 2 m = 2 t = 10 readings = [ [1, 2], [3, 4] ] result = find_hotspot_submatrix(n, m, t, readings) assert result == \\"NO\\" def test_multiple_hotspots(): n = 3 m = 3 t = 5 readings = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = find_hotspot_submatrix(n, m, t, readings) assert result.startswith(\\"YES\\") def test_large_threshold(): n = 3 m = 3 t = 100 readings = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = find_hotspot_submatrix(n, m, t, readings) assert result == \\"NO\\"","solution":"def find_hotspot_submatrix(n, m, t, readings): def get_submatrix_sum(x, y, k): total = 0 for i in range(x, x+k): for j in range(y, y+k): total += readings[i][j] return total max_k = min(n, m) for k in range(1, max_k + 1): for i in range(n - k + 1): for j in range(m - k + 1): if get_submatrix_sum(i, j, k) > t: return \\"YES \\" + str(i+1) + \\" \\" + str(j+1) return \\"NO\\""},{"question":"from typing import List, Tuple def minimum_lights(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimum number of lights needed to ensure that every landmark is lit. :param n: Number of landmarks :param m: Number of paths :param edges: List of tuples representing paths, where each tuple contains three integers u, v, and d (u and v - landmarks connected by the path, d - distance of the path) :return: Minimum number of lights needed >>> minimum_lights(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 1, 2)]) == 3 >>> minimum_lights(3, 1, [(1, 2, 5)]) == 1 >>> minimum_lights(1, 0, []) == 0 >>> minimum_lights(3, 3, [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) == 2 >>> minimum_lights(4, 5, [(1, 2, 999999999), (1, 3, 999999998), (1, 4, 999999997), (2, 3, 5), (3, 4, 2)]) == 3","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimum_lights(n, m, edges): if n == 1: return 0 # Sort edges by distance edges.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) num_lights = 0 for edge in edges: u, v, d = edge u -= 1 v -= 1 x = find(parent, u) y = find(parent, v) if x != y: num_lights += 1 union(parent, rank, x, y) if num_lights == n - 1: break return num_lights"},{"question":"def process_queries(n: int, sales: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Process the sales queries and return the results. Each query specifies a subarray and asks for the maximum value in that subarray. Parameters: n (int): The number of sales records. sales (list of int): The sales records. q (int): The number of queries. queries (list of tuple): The list of queries, where each query is a tuple (l, r). Returns: list of int: The maximum sales values for each query. >>> process_queries(5, [4, 2, 5, 3, 1], 3, [(1, 3), (2, 4), (1, 5)]) [5, 5, 5] >>> process_queries(5, [4, 2, 5, 3, 1], 2, [(1, 1), (3, 3)]) [4, 5] >>> process_queries(5, [4, 2, 5, 3, 1], 1, [(1, 5)]) [5] >>> process_queries(7, [13, 27, 14, 35, 17, 19, 25], 3, [(1, 4), (3, 6), (5, 7)]) [35, 35, 25] >>> process_queries(6, [5, 7, 7, 7, 2, 10], 3, [(1, 3), (1, 4), (1, 6)]) [7, 7, 10]","solution":"def process_queries(n, sales, q, queries): Process the sales queries and return the results. Parameters: n (int): The number of sales records. sales (list of int): The sales records. q (int): The number of queries. queries (list of tuple): The list of queries, where each query is a tuple (l, r). Returns: list of int: The maximum sales values for each query. # Create an array to store the result of each query results = [] for l, r in queries: # Convert 1-indexed to 0-indexed by subtracting one subarray = sales[l-1:r] # Find the maximum value in the subarray max_value = max(subarray) # Append the result to the results list results.append(max_value) return results"},{"question":"import heapq from typing import List, Tuple def min_cost_with_hops(n: int, m: int, s: int, t: int, k: int, routes: List[Tuple[int, int, int]]) -> int: Find the minimum travel cost from city s to city t without exceeding k hops. n: number of cities m: number of direct routes s: starting city t: target city k: maximum number of hops routes: list of tuples (u, v, c) representing direct routes Returns the minimum cost if the trip is possible within k hops, -1 otherwise. >>> routes = [ ... (1, 2, 10), (1, 3, 20), (2, 4, 10), ... (2, 3, 25), (3, 5, 30), (4, 5, 10), ... (3, 4, 35) ... ] >>> min_cost_with_hops(5, 7, 1, 5, 2, routes) 50 >>> routes = [ ... (1, 2, 10), (1, 3, 20), (2, 4, 10) ... ] >>> min_cost_with_hops(4, 3, 1, 2, 1, routes) 10 >>> routes = [ ... (1, 2, 10), (1, 3, 20), (2, 3, 25), (3, 4, 30) ... ] >>> min_cost_with_hops(4, 4, 1, 4, 1, routes) -1 >>> routes = [ ... (1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10) ... ] >>> min_cost_with_hops(5, 4, 1, 5, 2, routes) -1 >>> routes = [ ... (1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 5, 5) ... ] >>> min_cost_with_hops(5, 4, 1, 5, 4, routes) 20","solution":"import heapq import sys def min_cost_with_hops(n, m, s, t, k, routes): # Create adjacency list graph = {i: [] for i in range(1, n+1)} for u, v, c in routes: graph[u].append((v, c)) graph[v].append((u, c)) # Assuming undirected graph # Priority queue for Dijkstra-like search with hops restriction pq = [(0, s, 0)] # (current_cost, current_city, num_hops) min_cost = {i: float('inf') for i in range(1, n+1)} min_cost[s] = 0 hops_used = {i: float('inf') for i in range(1, n+1)} hops_used[s] = 0 while pq: current_cost, current_city, num_hops = heapq.heappop(pq) # If we have already found a cheaper way to reach the current city with fewer or same hops if num_hops > k or (current_cost > min_cost[current_city] and num_hops >= hops_used[current_city]): continue # Check if target city is reached if current_city == t: return current_cost for neighbor, travel_cost in graph[current_city]: new_cost = current_cost + travel_cost if (new_cost < min_cost[neighbor]) or (num_hops + 1 < hops_used[neighbor]): min_cost[neighbor] = new_cost hops_used[neighbor] = num_hops + 1 heapq.heappush(pq, (new_cost, neighbor, num_hops + 1)) return -1 # Target not reachable within k hops # Example input and expected output: # Input: # 5 7 1 5 2 # 1 2 10 # 1 3 20 # 2 4 10 # 2 3 25 # 3 5 30 # 4 5 10 # 3 4 35 # Expected output: # 50 routes = [ (1, 2, 10), (1, 3, 20), (2, 4, 10), (2, 3, 25), (3, 5, 30), (4, 5, 10), (3, 4, 35) ] result = min_cost_with_hops(5, 7, 1, 5, 2, routes) print(result) # Expected output: 50"},{"question":"def min_moves_to_complete_deck(n: int, k: int, cards: List[int]) -> int: Determine the minimum number of moves required for Alice to ensure every integer value from 1 to k appears at least once in the deck, or return -1 if it is not possible. >>> min_moves_to_complete_deck(5, 4, [1, 2, 2, 3, 5]) 1 >>> min_moves_to_complete_deck(3, 5, [1, 2, 3]) 2 >>> min_moves_to_complete_deck(7, 6, [2, 3, 4, 5, 6, 1, 4]) 0 >>> min_moves_to_complete_deck(4, 3, [1, 2, 3, 3]) 0 >>> min_moves_to_complete_deck(2, 5, [1, 2]) -1 >>> min_moves_to_complete_deck(5, 4, [1, 1, 1, 1, 1]) 3 >>> min_moves_to_complete_deck(6, 4, [1, 2, 5, 6, 7, 8]) 2","solution":"def min_moves_to_complete_deck(n, k, cards): # Count the frequency of each card value card_counts = [0] * (k + 1) for card in cards: if card <= k: card_counts[card] += 1 # Calculate the number of missing values missing_values = 0 for i in range(1, k + 1): if card_counts[i] == 0: missing_values += 1 # If there are more missing values than the number of cards, it is impossible if missing_values > n: return -1 else: return missing_values"},{"question":"from typing import List, Tuple, Optional class Library: A class to manage a library's collection of books with functionalities to add, remove, find oldest, and find books by a specific author. def __init__(self): Initialize the library with necessary data structures. pass def add_book(self, id: int, title: str, author: str, year: int) -> None: Add a new book to the library collection given the ID, title, author, and publication year. Args: id (int): The unique identifier for the book. title (str): The title of the book. author (str): The author of the book. year (int): The publication year of the book. Returns: None pass def remove_book(self, id: int) -> bool: Remove a book from the library using its ID. Args: id (int): The unique identifier for the book to be removed. Returns: bool: True if the book was successfully removed, False otherwise. pass def find_oldest_book(self) -> Optional[Tuple[int, str, str, int]]: Find the book with the earliest publication year. If multiple books share the same year, return the one added first. Returns: Optional[Tuple[int, str, str, int]]: The information of the oldest book as a tuple (id, title, author, year), or None if the library is empty. pass def find_books_by_author(self, author: str) -> List[Tuple[int, str, int]]: Find all books written by the specified author. Args: author (str): The name of the author whose books are to be retrieved. Returns: List[Tuple[int, str, int]]: A list of tuples each containing the id, title, and year of books by the specified author. pass # Unit tests for the Library class def test_add_book(): library = Library() library.add_book(1, \\"1984\\", \\"George Orwell\\", 1949) assert library.books[1] == (1, \\"1984\\", \\"George Orwell\\", 1949) def test_remove_book(): library = Library() library.add_book(1, \\"1984\\", \\"George Orwell\\", 1949) assert library.remove_book(1) == True assert 1 not in library.books def test_remove_nonexistent_book(): library = Library() assert library.remove_book(1) == False def test_find_oldest_book(): library = Library() library.add_book(1, \\"1984\\", \\"George Orwell\\", 1949) library.add_book(2, \\"Animal Farm\\", \\"George Orwell\\", 1945) assert library.find_oldest_book() == (2, \\"Animal Farm\\", \\"George Orwell\\", 1945) def test_find_oldest_book_empty_library(): library = Library() assert library.find_oldest_book() == None def test_find_books_by_author(): library = Library() library.add_book(1, \\"1984\\", \\"George Orwell\\", 1949) library.add_book(2, \\"Animal Farm\\", \\"George Orwell\\", 1945) expected = [(1, \\"1984\\", 1949), (2, \\"Animal Farm\\", 1945)] assert library.find_books_by_author(\\"George Orwell\\") == expected def test_find_books_by_nonexistent_author(): library = Library() assert library.find_books_by_author(\\"Nonexistent Author\\") == [] def test_remove_book_updates_books_by_author(): library = Library() library.add_book(1, \\"1984\\", \\"George Orwell\\", 1949) library.add_book(2, \\"Animal Farm\\", \\"George Orwell\\", 1945) library.remove_book(1) assert library.find_books_by_author(\\"George Orwell\\") == [(2, \\"Animal Farm\\", 1945)]","solution":"from typing import List, Tuple, Optional, Dict class Library: def __init__(self): self.books = {} self.books_by_author = {} def add_book(self, id: int, title: str, author: str, year: int) -> None: book = (id, title, author, year) self.books[id] = book if author in self.books_by_author: self.books_by_author[author].append(book) else: self.books_by_author[author] = [book] def remove_book(self, id: int) -> bool: if id in self.books: book = self.books.pop(id) author_books = self.books_by_author[book[2]] author_books = [b for b in author_books if b[0] != id] if author_books: self.books_by_author[book[2]] = author_books else: del self.books_by_author[book[2]] return True return False def find_oldest_book(self) -> Optional[Tuple[int, str, str, int]]: if not self.books: return None return min(self.books.values(), key=lambda b: (b[3], b[0])) def find_books_by_author(self, author: str) -> List[Tuple[int, str, int]]: if author not in self.books_by_author: return [] return [(b[0], b[1], b[3]) for b in self.books_by_author[author]]"},{"question":"import heapq from collections import defaultdict, deque from typing import List, Tuple def min_cost_to_place_stations(n: int, k: int, c: List[int], edges: List[Tuple[int, int]]) -> int: Determine the minimum cost to place k communication stations in an ancient kingdom with n villages, ensuring all villages can communicate with the central hub (village 1). Parameters: n (int): Number of villages. k (int): Number of communication stations. c (List[int]): List of costs to place a station in each village. edges (List[Tuple[int, int]]): List of two-way paths connecting the villages. Returns: int: The minimum cost to place the k stations. Example: >>> n, k = 6, 3 >>> c = [1, 3, 2, 5, 4, 6] >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] >>> min_cost_to_place_stations(n, k, c, edges) 6 # Build the adjacency list for the tree g = defaultdict(list) for u, v in edges: g[u].append(v) g[v].append(u) # BFS to find the level of each node levels = [-1] * (n + 1) q = deque([1]) levels[1] = 0 while q: node = q.popleft() for neighbor in g[node]: if levels[neighbor] == -1: levels[neighbor] = levels[node] + 1 q.append(neighbor) # Priority queue to store the costs with respect to each level's communication pruning cost pq = [] for i in range(1, n + 1): heapq.heappush(pq, (c[i-1], i)) selected_stations = set() total_cost = 0 # Extract k minimum cost stations considering levels while len(selected_stations) < k: cost, node = heapq.heappop(pq) if node not in selected_stations: selected_stations.add(node) total_cost += cost return total_cost # Unit Tests def test_min_cost_to_place_stations_example(): assert min_cost_to_place_stations(6, 3, [1, 3, 2, 5, 4, 6], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) == 6 def test_min_cost_single_level(): assert min_cost_to_place_stations(4, 2, [4, 3, 2, 1], [(1, 2), (1, 3), (1, 4)]) == 3 def test_min_cost_large_input(): assert min_cost_to_place_stations(6, 4, [10, 20, 30, 40, 50, 60], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) == 100 def test_min_cost_connected_villages(): assert min_cost_to_place_stations(5, 3, [5, 5, 5, 5, 5], [(1, 2), (1, 3), (3, 4), (4, 5)]) == 15","solution":"import heapq from collections import defaultdict, deque def min_cost_to_place_stations(n, k, c, edges): Returns the minimum cost to place k stations while ensuring all villages can communicate directly or indirectly with the central hub (village 1). # Build the adjacency list for the tree g = defaultdict(list) for u, v in edges: g[u].append(v) g[v].append(u) # BFS to find the level of each node levels = [-1] * (n + 1) q = deque([1]) levels[1] = 0 while q: node = q.popleft() for neighbor in g[node]: if levels[neighbor] == -1: levels[neighbor] = levels[node] + 1 q.append(neighbor) # Priority queue to store the costs with respect to each level's communication pruning cost pq = [] for i in range(1, n + 1): heapq.heappush(pq, (c[i-1], i)) selected_stations = set() total_cost = 0 # Extract k minimum cost stations considering levels while len(selected_stations) < k: cost, node = heapq.heappop(pq) if node not in selected_stations: selected_stations.add(node) total_cost += cost return total_cost # Example usage n, k = 6, 3 c = [1, 3, 2, 5, 4, 6] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] print(min_cost_to_place_stations(n, k, c, edges)) # Output: 6"},{"question":"def max_containers(L: int, W: int, H: int, S: int) -> int: Returns the maximum number of cubic containers of side S that can fit inside a chamber of dimensions L, W, and H. Parameters: L (int): The length of the chamber. W (int): The width of the chamber. H (int): The height of the chamber. S (int): The side length of the cubic containers. Returns: int: The maximum number of containers that can fit inside the chamber. >>> max_containers(10, 10, 10, 2) 125 >>> max_containers(10, 10, 10, 0) 0 >>> max_containers(3, 3, 3, 3) 1 >>> max_containers(4, 4, 4, 4) 1 >>> max_containers(1000000, 1000000, 1000000, 1) 1000000000000000000 >>> max_containers(9, 5, 3, 2) 8 >>> max_containers(1, 1, 1, 1) 1 >>> max_containers(1, 1, 1, 2) 0","solution":"def max_containers(L, W, H, S): Returns the maximum number of cubic containers of side S that can fit inside a chamber of dimensions L, W, and H. Parameters: L (int): The length of the chamber. W (int): The width of the chamber. H (int): The height of the chamber. S (int): The side length of the cubic containers. Returns: int: The maximum number of containers that can fit inside the chamber. if S == 0: return 0 # Compute the number of containers that fit along each dimension num_fit_length = L // S num_fit_width = W // S num_fit_height = H // S # Compute the total number of containers total_containers = num_fit_length * num_fit_width * num_fit_height return total_containers"},{"question":"def can_follow_clues(n: int, k: int, treasures: List[int], clues: List[Tuple[int, int, int]]) -> str: Determines if it's possible to follow the clues and find each specified treasure consecutively. :param n: int - Number of treasures :param k: int - Number of clues :param treasures: List[int] - Initial order of the treasures :param clues: List[Tuple[int, int, int]] - Clues :return: str - \\"Possible\\" or \\"Impossible\\" >>> can_follow_clues(5, 3, [4, 1, 3, 5, 2], [(1, 3, 3), (2, 4, 1), (3, 5, 2)]) == \\"Possible\\" >>> can_follow_clues(5, 3, [4, 1, 3, 5, 2], [(1, 3, 5), (2, 4, 1), (3, 5, 2)]) == \\"Impossible\\" >>> can_follow_clues(1, 1, [1], [(1, 1, 1)]) == \\"Possible\\" >>> can_follow_clues(4, 0, [2, 4, 1, 3], []) == \\"Possible\\" >>> can_follow_clues(100000, 1, list(range(1, 100001)), [(1, 100000, 50000)]) == \\"Possible\\"","solution":"def can_follow_clues(n, k, treasures, clues): Determines if it's possible to follow the clues and find each specified treasure consecutively. :param n: int - Number of treasures :param k: int - Number of clues :param treasures: List[int] - Initial order of the treasures :param clues: List[Tuple[int, int, int]] - Clues :return: str - \\"Possible\\" or \\"Impossible\\" position_of_treasure = {treasure: i + 1 for i, treasure in enumerate(treasures)} clues.sort(key=lambda clue: clue[2]) for a, b, x in clues: if not (a <= position_of_treasure[x] <= b): return \\"Impossible\\" return \\"Possible\\""},{"question":"from typing import List def maxRectangleArea(heights: List[int]) -> int: Find the maximum area of a rectangular section that can be formed using adjacent buildings' heights from the given array. >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> maxRectangleArea([2, 4]) == 4 def test_max_rectangle_area(): assert maxRectangleArea([2, 1, 5, 6, 2, 3]) == 10 assert maxRectangleArea([2, 4]) == 4 assert maxRectangleArea([1, 2, 3, 4, 5]) == 9 assert maxRectangleArea([5, 4, 3, 2, 1]) == 9 assert maxRectangleArea([3, 3, 3, 3]) == 12 assert maxRectangleArea([6]) == 6 assert maxRectangleArea([6, 7]) == 12 heights = [1] * 100000 assert maxRectangleArea(heights) == 100000 assert maxRectangleArea([2, 1, 4, 5, 1, 3, 3]) == 8","solution":"from typing import List def maxRectangleArea(heights: List[int]) -> int: This function calculates the maximum area of a rectangle that can be formed using the heights of the buildings represented in the input list \`heights\`. stack = [] max_area = 0 index = 0 while index < len(heights): # If stack is empty or the current height is greater than or equal to the height # of the building at the index of the top of the stack, push the current index to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top index from the stack top_of_stack = stack.pop() # Calculate the area with the height of the building at the top of the stack area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update the maximum area max_area = max(max_area, area) # Now, calculate the area for buildings remaining in the stack while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def rearrange_string(s: str) -> str: Determine if it is possible to rearrange the characters of the string such that no two adjacent characters are the same. Return a possible rearrangement of the string or \\"NO\\" if not possible. >>> rearrange_string(\\"aab\\") \\"aba\\" >>> rearrange_string(\\"aaab\\") \\"NO\\" >>> rearrange_string(\\"abc\\") \\"abc\\" def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases and return results of rearranged strings or \\"NO\\" for each test case. >>> process_test_cases(3, [\\"aab\\", \\"aaab\\", \\"abc\\"]) [\\"aba\\", \\"NO\\", \\"abc\\"] # Example cases def test_example_cases(): assert process_test_cases(3, [\\"aab\\", \\"aaab\\", \\"abc\\"]) == [\\"aba\\", \\"NO\\", \\"abc\\"] # Single character def test_single_characters(): assert process_test_cases(1, [\\"a\\"]) == [\\"a\\"] # No possible rearrangement def test_no_possible_rearrangement(): assert process_test_cases(1, [\\"aaaaa\\"]) == [\\"NO\\"] # Already valid string def test_already_valid(): assert process_test_cases(1, [\\"abc\\"]) == [\\"abc\\"] # Multiple same characters def test_multiple_same_characters(): result = rearrange_string(\\"aaabbcc\\") assert result != \\"NO\\" for i in range(len(result) - 1): assert result[i] != result[i+1] # Large input def test_large_input(): s = \\"a\\" * 50000 + \\"b\\" * 50000 result = rearrange_string(s) assert result != \\"NO\\" for i in range(len(result) - 1): assert result[i] != result[i+1] # All characters def test_all_chars(): import string s = string.ascii_lowercase * 4000 result = rearrange_string(s) assert result != \\"NO\\" for i in range(len(result) - 1): assert result[i] != result[i+1]","solution":"from collections import Counter import heapq def rearrange_string(s): count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char rearranged = ''.join(result) return rearranged if len(rearranged) == len(s) else \\"NO\\" def process_test_cases(t, test_cases): results = [] for i in range(t): s = test_cases[i] results.append(rearrange_string(s)) return results"},{"question":"def check_overloads(capacity, items): Determines the overload status of the machines for each day. An overload event occurs when the number of items scheduled for a day exceeds the processing capacity of any machine. Args: capacity (list of int): An integer array of size n, where capacity[i] is the maximum number of items that the i-th machine can process per day. items (list of int): An integer array of size m, where items[i] is the number of items scheduled for processing on the i-th day. Returns: list of int: An array of size m, where each element is 1 if there is an overload on that day, and 0 otherwise. pass if __name__ == \\"__main__\\": # Example Test Cases capacity = [10, 20, 30] items = [5, 15, 25, 35] print(check_overloads(capacity, items)) # Output: [0, 0, 0, 1] capacity = [50, 60, 70] items = [40, 60, 80] print(check_overloads(capacity, items)) # Output: [0, 0, 1] # Additional Test Cases capacity = [100, 200, 300] items = [150, 250, 350] print(check_overloads(capacity, items)) # Output: [0, 0, 1] capacity = [10] items = [15, 20, 30] print(check_overloads(capacity, items)) # Output: [1, 1, 1] capacity = [100, 150] items = [50, 100] print(check_overloads(capacity, items)) # Output: [0, 0]","solution":"def check_overloads(capacity, items): Determines the overload status of the machines for each day. An overload event occurs when the number of items scheduled for a day exceeds the processing capacity of any machine. Args: capacity (list of int): An integer array of size n, where capacity[i] is the maximum number of items that the i-th machine can process per day. items (list of int): An integer array of size m, where items[i] is the number of items scheduled for processing on the i-th day. Returns: list of int: An array of size m, where each element is 1 if there is an overload on that day, and 0 otherwise. max_capacity = max(capacity) overload_status = [1 if item > max_capacity else 0 for item in items] return overload_status"},{"question":"from typing import List def remove_greater_elements(arr: List[int]) -> List[int]: Identifies and removes all elements in the array that have at least one smaller element to their right side, and returns a new array with the elements that don't have any smaller element to their right, maintaining their relative order. >>> remove_greater_elements([16, 17, 4, 3, 5, 2]) [17, 5, 2] >>> remove_greater_elements([1, 2, 3, 4, 5]) [5] >>> remove_greater_elements([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] pass def test_remove_greater_elements_case_1(): assert remove_greater_elements([16, 17, 4, 3, 5, 2]) == [17, 5, 2] def test_remove_greater_elements_case_2(): assert remove_greater_elements([1, 2, 3, 4, 5]) == [5] def test_remove_greater_elements_case_3(): assert remove_greater_elements([5, 4, 3, 2, 1]) == [5, 4, 3, 2, 1] def test_remove_greater_elements_case_4(): assert remove_greater_elements([]) == [] def test_remove_greater_elements_case_5(): assert remove_greater_elements([10, 20, 30, 40, 50]) == [50] def test_remove_greater_elements_case_6(): assert remove_greater_elements([50, 40, 30, 20, 10]) == [50, 40, 30, 20, 10] def test_remove_greater_elements_case_7(): assert remove_greater_elements([5, 4, 3, 8, 6, 7, 2]) == [8, 7, 2] def test_remove_greater_elements_case_8(): assert remove_greater_elements([10, 9, 8, 7, 6, 5, 4, 3]) == [10, 9, 8, 7, 6, 5, 4, 3] def test_remove_greater_elements_with_duplicates(): assert remove_greater_elements([1, 2, 1, 2, 1, 2]) == [2, 2, 2] def test_remove_greater_elements_single_element(): assert remove_greater_elements([10]) == [10]","solution":"def remove_greater_elements(arr): Identifies and removes all elements in the array that have at least one smaller element to their right side, and returns a new array with the elements that don't have any smaller element to their right, maintaining their relative order. if not arr: return [] n = len(arr) result = [] max_from_right = arr[-1] # Traverse the list from right to left for i in range(n-1, -1, -1): if arr[i] >= max_from_right: result.append(arr[i]) max_from_right = arr[i] # Since we are adding elements from the end, we need to reverse the result list return result[::-1]"},{"question":"class Warehouse: def __init__(self): Initialize the inventory dictionary. self.inventory = {} def process_command(self, command: str) -> None: Processes a given command and updates the inventory accordingly. Command types include: - Insert <item_name> <quantity>: Adds the specified quantity of an item to the inventory. - Remove <item_name> <quantity>: Removes the specified quantity of an item from the inventory. - Check <item_name>: Prints the quantity of the specified item or 'Item not found'. Args: command (str): The command to process. Example usage: >>> wh = Warehouse() >>> wh.process_command(\\"Insert apples 10\\") >>> wh.process_command(\\"Check apples\\") 10 >>> wh.process_command(\\"Remove apples 3\\") >>> wh.process_command(\\"Check apples\\") 7 >>> wh.process_command(\\"Remove apples 10\\") >>> wh.process_command(\\"Check apples\\") Item not found pass from io import StringIO from contextlib import redirect_stdout import pytest def test_warehouse_operations(): wh = Warehouse() # Test 1: Insert and Check wh.process_command(\\"Insert apples 10\\") f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check apples\\") assert f.getvalue().strip() == \\"10\\" # Test 2: Insert more and Check wh.process_command(\\"Insert apples 5\\") f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check apples\\") assert f.getvalue().strip() == \\"15\\" # Test 3: Remove and Check wh.process_command(\\"Remove apples 7\\") f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check apples\\") assert f.getvalue().strip() == \\"8\\" # Test 4: Remove more than current quantity wh.process_command(\\"Remove apples 10\\") f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check apples\\") assert f.getvalue().strip() == \\"Item not found\\" # Test 5: Check for item not in inventory f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check bananas\\") assert f.getvalue().strip() == \\"Item not found\\" def test_insert_and_remove(): wh = Warehouse() wh.process_command(\\"Insert oranges 20\\") wh.process_command(\\"Remove oranges 5\\") f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check oranges\\") assert f.getvalue().strip() == \\"15\\" # Remove remaining quantity wh.process_command(\\"Remove oranges 15\\") f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check oranges\\") assert f.getvalue().strip() == \\"Item not found\\" def test_multiple_items(): wh = Warehouse() # Insert multiple items wh.process_command(\\"Insert apples 10\\") wh.process_command(\\"Insert bananas 5\\") wh.process_command(\\"Insert cherries 7\\") # Check quantities f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check apples\\") assert f.getvalue().strip() == \\"10\\" f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check bananas\\") assert f.getvalue().strip() == \\"5\\" f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check cherries\\") assert f.getvalue().strip() == \\"7\\" # Remove quantities and check again wh.process_command(\\"Remove apples 3\\") wh.process_command(\\"Remove bananas 5\\") wh.process_command(\\"Remove cherries 10\\") f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check apples\\") assert f.getvalue().strip() == \\"7\\" f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check bananas\\") assert f.getvalue().strip() == \\"Item not found\\" f = StringIO() with redirect_stdout(f): wh.process_command(\\"Check cherries\\") assert f.getvalue().strip() == \\"Item not found\\"","solution":"class Warehouse: def __init__(self): self.inventory = {} def process_command(self, command): parts = command.split() cmd_type = parts[0] if cmd_type == 'Insert': item_name, quantity = parts[1], int(parts[2]) if item_name in self.inventory: self.inventory[item_name] += quantity else: self.inventory[item_name] = quantity elif cmd_type == 'Remove': item_name, quantity = parts[1], int(parts[2]) if item_name in self.inventory: self.inventory[item_name] -= quantity if self.inventory[item_name] <= 0: del self.inventory[item_name] elif cmd_type == 'Check': item_name = parts[1] if item_name in self.inventory: print(self.inventory[item_name]) else: print('Item not found')"},{"question":"def transform_array(m, b): Transform the given array into a non-decreasing array. The transformation is done using specific subarray reverse operations. Args: m (int): The number of elements in array b. b (List[int]): The array of integers. Returns: List[Union[int, Tuple[int, int]]]: The number of operations followed by the operations. Example: >>> transform_array(5, [4, 3, 2, 1, 5]) # expected output: list with number of operations followed by operations in the form of tuples from solution import transform_array def test_transform_array_case_1(): m = 5 b = [4, 3, 2, 1, 5] result = transform_array(m, b) assert result[0] > 0 # At least one operation must be performed final_array = b[:] for op in result[1:]: i, j = op final_array[i-1:j] = reversed(final_array[i-1:j]) assert final_array == sorted(b) def test_transform_array_case_2(): m = 4 b = [5, 4, 3, 6] result = transform_array(m, b) assert result[0] >= 0 # Either zero or more operations can be there final_array = b[:] for op in result[1:]: i, j = op final_array[i-1:j] = reversed(final_array[i-1:j]) assert final_array == sorted(b) def test_transform_array_already_sorted(): m = 3 b = [1, 2, 3] result = transform_array(m, b) assert result[0] == 0 # No operations needed as array is already sorted def test_transform_array_single_element(): m = 1 b = [42] result = transform_array(m, b) assert result[0] == 0 # No operations needed as array has single element def test_transform_array_repeated_elements(): m = 5 b = [2, 2, 2, 2, 2] result = transform_array(m, b) assert result[0] == 0 # No operations needed as all elements are the same","solution":"def is_non_decreasing(arr): Checks if the given array is non-decreasing. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def reverse_subarray(arr, i, j): Returns a new array with the subarray from index i to j reversed. return arr[:i] + arr[i:j + 1][::-1] + arr[j + 1:] def sum_is_even(arr, i, j): Checks if the sum of the subarray from index i to j is even. return sum(arr[i:j + 1]) % 2 == 0 def make_non_decreasing(arr): Transform the array into a non-decreasing array using the specific operations. m = len(arr) operations = [] while not is_non_decreasing(arr): made_operation = False for i in range(m - 1): for j in range(i + 1, m): if arr[i] > arr[j] and sum_is_even(arr, i, j): arr = reverse_subarray(arr, i, j) operations.append((i + 1, j + 1)) # Convert to 1-based index made_operation = True break if made_operation: break if not made_operation: break # no more operations possible return len(operations), operations def transform_array(m, b): Main function to transform the array. num_operations, operations = make_non_decreasing(b) result = [num_operations] + operations return result"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def is_fully_connected(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determines if the given network of servers is fully connected. Args: n (int): The number of servers. m (int): The number of bidirectional connections. connections (List[Tuple[int, int]]): The list of bidirectional connections. Returns: str: \\"CONNECTED\\" if the network is fully connected, otherwise \\"DISCONNECTED\\". pass def solve_network(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determines the connectivity status of multiple test cases of server networks. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): The list of test cases. Returns: List[str]: The list of results for each test case, \\"CONNECTED\\" or \\"DISCONNECTED\\". pass def test_is_fully_connected(): # Test cases from the example assert is_fully_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"CONNECTED\\" assert is_fully_connected(4, 2, [(1, 2), (3, 4)]) == \\"DISCONNECTED\\" # Additional test cases assert is_fully_connected(1, 0, []) == \\"CONNECTED\\" # Single node assert is_fully_connected(2, 1, [(1, 2)]) == \\"CONNECTED\\" # Two nodes, one connection assert is_fully_connected(2, 0, []) == \\"DISCONNECTED\\" # Two nodes, no connections assert is_fully_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"CONNECTED\\" assert is_fully_connected(5, 3, [(1, 2), (2, 3), (4, 5)]) == \\"DISCONNECTED\\" def test_solve_network(): # Test cases from the example t = 2 test_cases = [ (4, 3, [(1, 2), (2, 3), (3, 4)]), (4, 2, [(1, 2), (3, 4)]) ] assert solve_network(t, test_cases) == [\\"CONNECTED\\", \\"DISCONNECTED\\"] # Additional test cases t = 3 test_cases = [ (1, 0, []), # Single node (2, 1, [(1, 2)]), # Two nodes, one connection (2, 0, []) # Two nodes, no connections ] assert solve_network(t, test_cases) == [\\"CONNECTED\\", \\"CONNECTED\\", \\"DISCONNECTED\\"]","solution":"def is_fully_connected(n, m, connections): from collections import defaultdict, deque if n == 1: return \\"CONNECTED\\" # Build the adjacency list adjacency_list = defaultdict(list) for u, v in connections: adjacency_list[u].append(v) adjacency_list[v].append(u) # Use BFS or DFS to check connectivity visited = set() def bfs(start): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Start BFS from node 1 (assuming nodes are from 1 to n) bfs(1) # Check if all nodes are visited for i in range(1, n + 1): if i not in visited: return \\"DISCONNECTED\\" return \\"CONNECTED\\" def solve_network(t, test_cases): results = [] for n, m, connections in test_cases: results.append(is_fully_connected(n, m, connections)) return results"},{"question":"def gcd_pairs(n: int, k: int) -> Tuple[str, List[int]]: Determines if it is possible to create \`n\` pairs of integers where the GCD of each pair is equal to \`k\`. Args: n (int): Number of pairs to be created. k (int): The GCD each pair must have. Returns: tuple: A result string (\\"YES\\" or \\"NO\\") and list of pairs if possible. >>> gcd_pairs(3, 5) ('YES', [5, 10, 5, 15, 5, 20]) >>> gcd_pairs(1, 10) ('YES', [10, 20]) >>> gcd_pairs(2, 1000000000) ('YES', [1000000000, 2000000000, 1000000000, 3000000000]) >>> gcd_pairs(3, 0) ('NO', []) >>> gcd_pairs(100, 1) ('YES', [1, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7, 1, 8, 1, 9, 1, 10, 1, 11, 1, 12, 1, 13, 1, 14, 1, 15, 1, 16, 1, 17, 1, 18, 1, 19, 1, 20, 1, 21, 1, 22, 1, 23, 1, 24, 1, 25, 1, 26, 1, 27, 1, 28, 1, 29, 1, 30, 1, 31, 1, 32, 1, 33, 1, 34, 1, 35, 1, 36, 1, 37, 1, 38, 1, 39, 1, 40, 1, 41, 1, 42, 1, 43, 1, 44, 1, 45, 1, 46, 1, 47, 1, 48, 1, 49, 1, 50, 1, 51, 1, 52, 1, 53, 1, 54, 1, 55, 1, 56, 1, 57, 1, 58, 1, 59, 1, 60, 1, 61, 1, 62, 1, 63, 1, 64, 1, 65, 1, 66, 1, 67, 1, 68, 1, 69, 1, 70, 1, 71, 1, 72, 1, 73, 1, 74, 1, 75, 1, 76, 1, 77, 1, 78, 1, 79, 1, 80, 1, 81, 1, 82, 1, 83, 1, 84, 1, 85, 1, 86, 1, 87, 1, 88, 1, 89, 1, 90, 1, 91, 1, 92, 1, 93, 1, 94, 1, 95, 1, 96, 1, 97, 1, 98, 1, 99, 1, 100, 1, 101])","solution":"def gcd_pairs(n, k): Determines if it is possible to create \`n\` pairs of integers where the GCD of each pair is equal to \`k\`. Args: n (int): Number of pairs to be created. k (int): The GCD each pair must have. Returns: tuple: A result string (\\"YES\\" or \\"NO\\") and list of pairs if possible. if k == 0: return \\"NO\\", [] pairs = [] for i in range(1, n + 1): pairs.append(k) pairs.append(k * (i + 1)) return \\"YES\\", pairs"},{"question":"def min_path_sum(grid): Given a grid, the function returns the minimum path sum from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. pass def process_test_cases(t, test_cases): Processes multiple test cases and returns the results as a list. pass # Test cases def test_min_path_sum_single_case_1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_sum(grid) == 7 def test_min_path_sum_single_case_2(): grid = [ [1, 2], [1, 1] ] assert min_path_sum(grid) == 3 def test_process_test_cases_multiple(): t = 2 test_cases = [ ((3, 3), [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]), ((2, 2), [ [1, 2], [1, 1] ]) ] assert process_test_cases(t, test_cases) == [7, 3] def test_min_path_sum_complex_case(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_path_sum(grid) == 21 def test_min_path_sum_simple_1x1(): grid = [ [5] ] assert min_path_sum(grid) == 5 def test_min_path_sum_column_only(): grid = [ [1], [2], [3] ] assert min_path_sum(grid) == 6 def test_min_path_sum_row_only(): grid = [ [1, 2, 3] ] assert min_path_sum(grid) == 6","solution":"def min_path_sum(grid): Given a grid, the function returns the minimum path sum from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. n = len(grid) m = len(grid[0]) # Initialize a DP matrix with the same dimensions as grid dp = [[0]*m for _ in range(n)] # Base case, start point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp matrix for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the result return dp[n-1][m-1] def process_test_cases(t, test_cases): Processes multiple test cases and returns the results as a list. results = [] for i in range(t): n, m = test_cases[i][0] grid = test_cases[i][1] result = min_path_sum(grid) results.append(result) return results"},{"question":"def toggle_case(s: str) -> str: Toggles the case of each character in the string s. >>> toggle_case('helloworld') 'HELLOWORLD' >>> toggle_case('HELLOWORLD') 'helloworld' >>> toggle_case('HelloWorld') 'hELLOwORLD' >>> toggle_case('a') 'A' >>> toggle_case('A') 'a' >>> toggle_case('1234!@#') '1234!@#' >>> toggle_case('AbC123dEf!') 'aBc123DeF!' >>> toggle_case('') ''","solution":"def toggle_case(s): Toggles the case of each character in the string s. return s.swapcase()"},{"question":"def minimum_travel_time(n: int, m: int, road_data: List[Tuple[int, int, int]], k: int, teleport_data: List[Tuple[int, int]]) -> List[int]: Determine the minimum travel time from the capital to each city in a kingdom with roads and teleportation. Parameters: - n (int): Number of cities - m (int): Number of roads - road_data (List[Tuple[int, int, int]]): List of tuples representing roads with travel times (u, v, w) - k (int): Number of teleportation pairs - teleport_data (List[Tuple[int, int]]): List of tuples representing teleportation pairs (x, y) Returns: - List[int]: List of minimum travel times from the capital city (city 1) to all other cities. Example: >>> minimum_travel_time(5, 6, [(1, 2, 2), (1, 3, 3), (2, 4, 4), (3, 4, 1), (4, 5, 5), (3, 5, 8)], 1, [(1, 5)]) [2, 3, 4, 0] >>> minimum_travel_time(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 4)], 0, []) [1, 3, 6] >>> minimum_travel_time(4, 2, [(1, 2, 1), (2, 3, 2)], 0, []) [1, 3, -1] >>> minimum_travel_time(5, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 1)], 1, [(1, 5)]) [1, 2, 3, 0] >>> minimum_travel_time(3, 2, [(1, 2, 1), (2, 3, 1)], 0, []) [1, 2]","solution":"import heapq def dijkstra(n, roads, teleports, source=1): # Initialization graph = {i: [] for i in range(1, n + 1)} # Adding roads to graph for u, v, w in roads: graph[u].append((w, v)) graph[v].append((w, u)) # Adding teleportation pairs to graph with weight 0 for x, y in teleports: graph[x].append((0, y)) graph[y].append((0, x)) # Distance array with infinity dist = [float('inf')] * (n + 1) dist[source] = 0 # Min-heap priority queue pq = [(0, source)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for weight, v in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) # Prepare result excluding the capital city itself return [dist[i] if dist[i] != float('inf') else -1 for i in range(2, n + 1)] # Main function to read input and provide output def minimum_travel_time(n, m, road_data, k, teleport_data): return dijkstra(n, road_data, teleport_data)"},{"question":"def remove_duplicates(nums: List[int]) -> int: Given an array of integers nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. This function must run in O(n) time and use constant extra space. Modify the array in-place to achieve the desired result, do not use any extra array or list structures. >>> nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] >>> result = remove_duplicates(nums) >>> result 5 >>> nums[:result] [0, 1, 2, 3, 4] from typing import List # Example test cases def test_remove_duplicates_example_case(): nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] result = remove_duplicates(nums) assert result == 5 assert nums[:result] == [0, 1, 2, 3, 4] def test_remove_duplicates_no_duplicates(): nums = [1, 2, 3, 4, 5] result = remove_duplicates(nums) assert result == 5 assert nums[:result] == [1, 2, 3, 4, 5] def test_remove_duplicates_all_duplicates(): nums = [1, 1, 1, 1, 1] result = remove_duplicates(nums) assert result == 1 assert nums[:result] == [1] def test_remove_duplicates_mixed_case(): nums = [1, 1, 2, 3, 3, 4, 4, 5] result = remove_duplicates(nums) assert result == 5 assert nums[:result] == [1, 2, 3, 4, 5] def test_remove_duplicates_empty_array(): nums = [] result = remove_duplicates(nums) assert result == 0 assert nums == [] def test_remove_duplicates_single_element(): nums = [1] result = remove_duplicates(nums) assert result == 1 assert nums[:result] == [1]","solution":"def remove_duplicates(nums): Removes duplicates from sorted array nums in-place and returns the number of unique elements. if not nums: return 0 unique_count = 1 # At least one unique element (the first element) for i in range(1, len(nums)): if nums[i] != nums[i-1]: nums[unique_count] = nums[i] unique_count += 1 return unique_count # Example usage: # nums=[0,0,1,1,1,2,2,3,3,4] # result = remove_duplicates(nums) # print(result) # Output: 5 # print(nums) # The first 5 elements should be [0, 1, 2, 3, 4]"},{"question":"def minimum_collection_time(c: int, n: int, compartments: List[int]) -> int: Calculate the minimum time to collect all items in specified compartments. Arguments: c -- total number of compartments n -- number of specified compartments compartments -- list of compartments with items Returns: Minimum time required to collect all items. pass from solution import minimum_collection_time def test_no_items(): assert minimum_collection_time(10, 0, []) == 0 def test_single_item(): assert minimum_collection_time(10, 1, [5]) == 0 def test_adjacent_items(): assert minimum_collection_time(10, 2, [5, 6]) == 1 def test_non_adjacent_items(): assert minimum_collection_time(10, 3, [3, 7, 9]) == 6 def test_items_at_bounds(): assert minimum_collection_time(10, 2, [1, 10]) == 9 def test_items_disordered(): assert minimum_collection_time(10, 3, [10, 2, 7]) == 8","solution":"def minimum_collection_time(c, n, compartments): Calculate the minimum time to collect all items in specified compartments. Arguments: c -- total number of compartments n -- number of specified compartments compartments -- list of compartments with items Returns: Minimum time required to collect all items. if n == 0: return 0 # Sorting the list of compartments with items compartments.sort() # Calculate the distance from the first to the last item compartment minimum_time = compartments[-1] - compartments[0] return minimum_time"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head: ListNode) -> bool: Returns True if there is a cycle in the linked list. Returns False otherwise. >>> head = ListNode(3) >>> node2 = ListNode(2) >>> node3 = ListNode(0) >>> node4 = ListNode(-4) >>> head.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node2 # cycle here >>> hasCycle(head) True >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = head # cycle here >>> hasCycle(head) True >>> head = ListNode(1) >>> hasCycle(head) False >>> head = None >>> hasCycle(head) False","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head: ListNode) -> bool: Returns True if there is a cycle in the linked list. Returns False otherwise. if not head or not head.next: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Find all unique quadruplets in the array nums that sum up to target. Args: nums: List[int] - List of integers. target: int - The target sum of the quadruplets. Returns: List[List[int]] - List of unique quadruplets which sum up to the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4], 50) [] >>> four_sum([0, 0, 0, 0, 0], 0) [[0, 0, 0, 0]] >>> four_sum([1000000000, 1000000000, 1000000000, 1000000000], 4000000000) [[1000000000, 1000000000, 1000000000, 1000000000]] >>> four_sum([-1, 0, 1, 2, -1, -4], -1) [[-4, 0, 1, 2], [-1, -1, 0, 1]] pass from solution import four_sum def test_simple_case(): nums = [1, 0, -1, 0, -2, 2] target = 0 result = four_sum(nums, target) expected = [ [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1] ] assert sorted(result) == sorted(expected) def test_no_quadruplets(): nums = [1, 2, 3, 4] target = 50 result = four_sum(nums, target) expected = [] assert result == expected def test_all_zeros(): nums = [0, 0, 0, 0, 0] target = 0 result = four_sum(nums, target) expected = [[0, 0, 0, 0]] assert result == expected def test_large_numbers(): nums = [1000000000, 1000000000, 1000000000, 1000000000] target = 4000000000 result = four_sum(nums, target) expected = [[1000000000, 1000000000, 1000000000, 1000000000]] assert result == expected def test_mixed_signs(): nums = [-1, 0, 1, 2, -1, -4] target = -1 result = four_sum(nums, target) expected = [[-4, 0, 1, 2], [-1, -1, 0, 1]] assert sorted(result) == sorted(expected)","solution":"def four_sum(nums, target): Find all unique quadruplets in the array nums that sum up to target. Args: nums: List[int] - List of integers. target: int - The target sum of the quadruplets. Returns: List[List[int]] - List of unique quadruplets which sum up to the target. nums.sort() n = len(nums) quadruplets = [] for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicate number. for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue # Skip duplicate number. k, l = j + 1, n - 1 while k < l: total = nums[i] + nums[j] + nums[k] + nums[l] if total == target: quadruplets.append([nums[i], nums[j], nums[k], nums[l]]) while k < l and nums[k] == nums[k + 1]: k += 1 while k < l and nums[l] == nums[l - 1]: l -= 1 k += 1 l -= 1 elif total < target: k += 1 else: l -= 1 return quadruplets"},{"question":"def highest_frequency_char(s: str) -> str: Calculate the frequency of each character in the string and print the character(s) with the highest frequency, along with their count. If there are multiple characters with the same highest frequency, print one of them. >>> highest_frequency_char(\\"a\\") == \\"a 1\\" >>> highest_frequency_char(\\"abcdef\\") == \\"a 1\\" >>> highest_frequency_char(\\"aabbcc\\") in [\\"a 2\\", \\"b 2\\", \\"c 2\\"] >>> highest_frequency_char(\\"aabbbccdddeee\\") == \\"b 3\\" >>> highest_frequency_char(\\"aaabbb\\") in [\\"a 3\\", \\"b 3\\"] >>> test_str = \\"a\\" * 50 + \\"b\\" * 50 >>> highest_frequency_char(test_str) in [\\"a 50\\", \\"b 50\\"]","solution":"def highest_frequency_char(s): Returns the character with the highest frequency and its count. If there are multiple characters with the same highest frequency, returns one of them. from collections import Counter # Calculate the frequency of each character frequency = Counter(s) # Find the character(s) with the highest frequency max_freq = max(frequency.values()) # Find one of the characters with the highest frequency for char, count in frequency.items(): if count == max_freq: return f\\"{char} {count}\\""},{"question":"def max_sum_of_subarray(arr: List[int], n: int, k: int) -> int: Given an integer array 'arr' of size 'n' and an integer 'k', returns the maximum possible sum of any subarray of size 'k'. >>> max_sum_of_subarray([1, 3, 2, 5, 4, 6, 1, 2], 8, 3) 15 >>> max_sum_of_subarray([1, 1, 1, 1, 1, 1, 1, 1], 8, 3) 3 >>> max_sum_of_subarray([5], 1, 1) 5 >>> max_sum_of_subarray([1, 2, 3, 4, 5], 5, 5) 15 >>> max_sum_of_subarray([5, 4, 3, 2, 1], 5, 2) 9 >>> max_sum_of_subarray([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], 10, 5) 8 from typing import List def test_max_sum_of_subarray_basic(): arr = [1, 3, 2, 5, 4, 6, 1, 2] assert max_sum_of_subarray(arr, 8, 3) == 15 def test_max_sum_of_subarray_with_all_elements_same(): arr = [1, 1, 1, 1, 1, 1, 1, 1] assert max_sum_of_subarray(arr, 8, 3) == 3 def test_max_sum_of_subarray_with_single_element(): arr = [5] assert max_sum_of_subarray(arr, 1, 1) == 5 def test_max_sum_of_subarray_with_large_k(): arr = [1, 2, 3, 4, 5] assert max_sum_of_subarray(arr, 5, 5) == 15 def test_max_sum_of_subarray_with_descending_order(): arr = [5, 4, 3, 2, 1] assert max_sum_of_subarray(arr, 5, 2) == 9 def test_max_sum_of_subarray_with_boundary_conditions(): arr = [1, 2, 1, 2, 1, 2, 1, 2, 1, 2] assert max_sum_of_subarray(arr, 10, 5) == 8","solution":"def max_sum_of_subarray(arr, n, k): Returns the maximum possible sum of any subarray of size \`k\`. current_sum = sum(arr[:k]) max_sum = current_sum for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def max_non_overlapping_workshops(n: int, workshops: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping workshops that can be scheduled. Parameters: n (int): Number of workshops workshops (list of tuples): List of workshops represented by (start time, end time) Returns: int: Maximum number of non-overlapping workshops >>> max_non_overlapping_workshops(5, [(1, 3), (2, 5), (4, 6), (6, 7), (5, 8)]) 3 >>> max_non_overlapping_workshops(3, [(1, 4), (2, 5), (3, 6)]) 1","solution":"def max_non_overlapping_workshops(n, workshops): Determines the maximum number of non-overlapping workshops that can be scheduled. Parameters: n (int): Number of workshops workshops (list of tuples): List of workshops represented by (start time, end time) Returns: int: Maximum number of non-overlapping workshops # Sort the workshops based on their end times workshops.sort(key=lambda x: x[1]) end_time = 0 count = 0 # Iterate through the sorted list of workshops for start, end in workshops: # If the start time of the current workshop is greater or equal to the end time of the last added workshop if start >= end_time: # Add this workshop end_time = end count += 1 return count"},{"question":"from typing import List def maxHistogramArea(heights: List[int]) -> int: Returns the maximum rectangular area in the given histogram. >>> maxHistogramArea([2, 1, 5, 6, 2, 3]) 10 >>> maxHistogramArea([5]) 5 >>> maxHistogramArea([2, 4]) 4 >>> maxHistogramArea([6, 5, 4, 3, 2, 1]) 12 >>> maxHistogramArea([1, 2, 3, 4, 5, 6]) 12 >>> maxHistogramArea([5, 5, 5, 5, 5]) 25 >>> maxHistogramArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> maxHistogramArea([0, 1, 0, 1, 0, 1]) 1 >>> maxHistogramArea([1]*100000) 100000 # Your code here","solution":"from typing import List def maxHistogramArea(heights: List[int]) -> int: Returns the maximum rectangular area in the given histogram. # Initialize stack and max_area stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar 'height' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # update max_area max_area = max(max_area, area) # Now pop the remaining bars from stack and calculate area with each popped bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List, Dict def max_batches(orders: List[Dict[str, int]], resources: Dict[str, int]) -> int: Determines the maximum number of batches of dishes that can be prepared based on given orders and available resources. Parameters: orders (List[Dict[str, int]]): A list of dictionaries representing the recipes for each dish. resources (Dict[str, int]): A dictionary representing the total quantity of each resource available. Returns: int: Maximum number of batches that can be made. Example: >>> orders = [{\\"flour\\": 1, \\"sugar\\": 2, \\"eggs\\": 3}, {\\"flour\\": 3, \\"sugar\\": 4, \\"eggs\\": 1}] >>> resources = {\\"flour\\": 10, \\"sugar\\": 10, \\"eggs\\": 10} >>> max_batches(orders, resources) 2 # Unit tests def test_max_batches_basic(): orders = [ {\\"flour\\": 1, \\"sugar\\": 2, \\"eggs\\": 3}, {\\"flour\\": 3, \\"sugar\\": 4, \\"eggs\\": 1} ] resources = {\\"flour\\": 10, \\"sugar\\": 10, \\"eggs\\": 10} assert max_batches(orders, resources) == 2 def test_max_batches_insufficient_resources(): orders = [ {\\"flour\\": 1, \\"sugar\\": 2}, {\\"flour\\": 3, \\"sugar\\": 4} ] resources = {\\"flour\\": 5, \\"sugar\\": 5} assert max_batches(orders, resources) == 1 def test_max_batches_no_resources(): orders = [ {\\"flour\\": 1, \\"sugar\\": 2} ] resources = {} assert max_batches(orders, resources) == 0 def test_max_batches_no_orders(): orders = [] resources = {\\"flour\\": 10, \\"sugar\\": 10} assert max_batches(orders, resources) == 0 def test_max_batches_some_resources_missing(): orders = [ {\\"flour\\": 1, \\"sugar\\": 2} ] resources = {\\"flour\\": 10} assert max_batches(orders, resources) == 0 def test_max_batches_exact_resources(): orders = [ {\\"flour\\": 1, \\"sugar\\": 2}, {\\"flour\\": 3, \\"sugar\\": 4} ] resources = {\\"flour\\": 10, \\"sugar\\": 10} assert max_batches(orders, resources) == 2 def test_max_batches_single_order(): orders = [ {\\"flour\\": 1, \\"sugar\\": 2, \\"eggs\\": 1} ] resources = {\\"flour\\": 10, \\"sugar\\": 20, \\"eggs\\": 10} assert max_batches(orders, resources) == 10","solution":"from typing import List, Dict def max_batches(orders: List[Dict[str, int]], resources: Dict[str, int]) -> int: Determines the maximum number of batches of dishes that can be prepared based on given orders and available resources. if not orders or not resources: return 0 max_batch_count = float('inf') for order in orders: possible_batches = float('inf') for ingredient, required_qty in order.items(): if ingredient not in resources: return 0 # If an ingredient is missing from resources, no batches can be made possible_batches = min(possible_batches, resources[ingredient] // required_qty) max_batch_count = min(max_batch_count, possible_batches) return max_batch_count"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the input string a palindrome. >>> min_insertions_to_palindrome(\\"abc\\") 2 >>> min_insertions_to_palindrome(\\"aebcbda\\") 2 >>> min_insertions_to_palindrome(\\"a\\") 0 >>> min_insertions_to_palindrome(\\"racecar\\") 0 >>> min_insertions_to_palindrome(\\"abcd\\") 3 >>> min_insertions_to_palindrome(\\"abacbade\\") 3 >>> min_insertions_to_palindrome(\\"aaaa\\") 0","solution":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the input string a palindrome. n = len(s) # reverse the string rev_s = s[::-1] # Create a table to store results of subproblems dp = [[0 for x in range(n+1)] for y in range(n+1)] # Fill dp table for i in range(1, n+1): for j in range(1, n+1): if s[i-1] == rev_s[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # The length of the longest palindromic subsequence lps_length = dp[n][n] return n - lps_length"},{"question":"def min_cost_to_sort(n: int, a: List[int]) -> int: Find the minimum cost required to sort the array in non-decreasing order using the allowed operation. >>> min_cost_to_sort(4, [4, 3, 2, 1]) == 10 >>> min_cost_to_sort(4, [1, 2, 3, 4]) == 0 >>> min_cost_to_sort(4, [2, 1, 4, 3]) == 10 >>> min_cost_to_sort(1, [5]) == 0 >>> min_cost_to_sort(3, [7, 7, 7]) == 0","solution":"def min_cost_to_sort(n, a): sorted_a = sorted(a) cost = 0 for i in range(n): cost += a[i] + sorted_a[i] return cost"},{"question":"def sum_of_digits(s: str) -> int: Given a string of 8 characters where the first two characters are alphabetic and the last six characters are digits, return the sum of the six digits. Examples: >>> sum_of_digits(\\"AB111111\\") 6 >>> sum_of_digits(\\"XY123456\\") 21 >>> sum_of_digits(\\"CD654321\\") 21 >>> sum_of_digits(\\"ZZ987654\\") 39 >>> sum_of_digits(\\"AA000000\\") 0","solution":"def sum_of_digits(s): Given a string of 8 characters where the first two characters are alphabetic and the last six characters are digits, return the sum of the six digits. if len(s) != 8 or not s[:2].isalpha() or not s[2:].isdigit(): raise ValueError(\\"Input must be in the format of two letters followed by six digits\\") digits = s[2:] return sum(int(digit) for digit in digits)"},{"question":"def min_cost_to_balance_array(n: int, a: List[int]) -> int: Returns the minimum cost to balance the array by making the sum of the first half equal to the second half through increments or decrements of elements with each operation costing 1 unit. >>> min_cost_to_balance_array(6, [1, 2, 3, 4, 5, 6]) 9 >>> min_cost_to_balance_array(6, [1, 1, 1, 1, 1, 1]) 0 >>> min_cost_to_balance_array(4, [1000000000, 1000000000, 1000000000, 1000000000]) 0 >>> min_cost_to_balance_array(4, [1, 1, 5, 5]) 8 >>> min_cost_to_balance_array(4, [1, 2, 3, 20]) 20","solution":"def min_cost_to_balance_array(n, a): Returns the minimum cost to balance the array by making the sum of the first half equal to the second half through increments or decrements of elements with each operation costing 1 unit. half = n // 2 first_half = a[:half] second_half = a[half:] sum_first_half = sum(first_half) sum_second_half = sum(second_half) difference = abs(sum_second_half - sum_first_half) return difference"},{"question":"from typing import List def max_rectangle_area(heights: List[int]) -> int: Given an array of integers where each element represents the height of a pillar, identify the maximum possible rectangle that can be formed using contiguous pillars. The height of the rectangle is determined by the smallest pillar in the chosen set, and the width is the number of pillars in the set. Arguments: heights -- a list of integers representing the heights of the pillars Returns: an integer representing the maximum area of any rectangle that can be formed using contiguous pillars. >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([5]) 5 >>> max_rectangle_area([2, 4]) 4 >>> max_rectangle_area([6, 6, 6, 6, 6]) 30 >>> max_rectangle_area([5, 4, 3, 2, 1]) 9 >>> max_rectangle_area([1, 2, 3, 4, 5]) 9 >>> max_rectangle_area([2, 1, 2, 1, 2]) 5 >>> max_rectangle_area([1000000] * 100000) 100000000000","solution":"def max_rectangle_area(heights): Returns the maximum possible rectangle area that can be formed using contiguous pillars. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area # Example usage heights = [2, 1, 5, 6, 2, 3] print(max_rectangle_area(heights)) # Output: 10"},{"question":"class AuctionSystem: A class to simulate a simplified online auction system. The auction consists of multiple items, where each item has a unique identifier and its own list of bids. def __init__(self): self.items = {} self.closed_items = set() def add_item(self, item_id): Adds a new item to the auction with the given item_id. If the item_id already exists, raise a ValueError. Args: item_id (int): Unique identifier for the item. pass def place_bid(self, item_id, bidder_id, bid_amount): Places a bid on the specified item. Each bid consists of a bidder_id and a bid_amount. If the item_id does not exist, raise a ValueError. Args: item_id (int): Unique identifier for the item. bidder_id (str): Identifier for the bidder. bid_amount (int): The amount bid by the bidder. pass def get_highest_bid(self, item_id): Returns the highest bid for the specified item as a tuple (bidder_id, bid_amount). If the item_id does not exist or if no bids have been placed on the item, return None. Args: item_id (int): Unique identifier for the item. Returns: tuple: The highest bid as (bidder_id, bid_amount), or None if no bids are placed or item_id does not exist. pass def get_winner(self, item_id): Determines the winner of the specified item, defined as the bidder_id with the highest bid. If there are multiple highest bids with the same amount, the bid that was placed earlier wins. If the item_id does not exist or if no bids have been placed, return None. Args: item_id (int): Unique identifier for the item. Returns: str: The winner as bidder_id, or None if no bids are placed or item_id does not exist. pass def close_auction(self, item_id): Closes the auction for the specified item. After closing, no more bids can be placed on the item. If the item_id does not exist, raise a ValueError. Args: item_id (int): Unique identifier for the item. pass # Test cases from solution import AuctionSystem import pytest def test_add_item(): auction = AuctionSystem() auction.add_item(1) assert 1 in auction.items with pytest.raises(ValueError): auction.add_item(1) def test_place_bid(): auction = AuctionSystem() auction.add_item(1) auction.place_bid(1, 'Alice', 100) auction.place_bid(1, 'Bob', 150) assert auction.items[1] == [('Alice', 100), ('Bob', 150)] with pytest.raises(ValueError): auction.place_bid(99, 'Charlie', 200) def test_get_highest_bid(): auction = AuctionSystem() auction.add_item(1) auction.place_bid(1, 'Alice', 100) auction.place_bid(1, 'Bob', 150) assert auction.get_highest_bid(1) == ('Bob', 150) auction.place_bid(1, 'Charlie', 120) assert auction.get_highest_bid(1) == ('Bob', 150) assert auction.get_highest_bid(99) is None auction.add_item(2) assert auction.get_highest_bid(2) is None def test_get_winner(): auction = AuctionSystem() auction.add_item(1) auction.place_bid(1, 'Alice', 100) auction.place_bid(1, 'Bob', 150) auction.place_bid(1, 'Charlie', 150) assert auction.get_winner(1) == 'Bob' # Bob bid first with the highest amount 150 auction.place_bid(1, 'Dave', 200) assert auction.get_winner(1) == 'Dave' assert auction.get_winner(99) is None def test_close_auction(): auction = AuctionSystem() auction.add_item(1) auction.place_bid(1, 'Alice', 100) auction.place_bid(1, 'Bob', 150) auction.close_auction(1) assert 1 in auction.closed_items with pytest.raises(ValueError): auction.place_bid(1, 'Charlie', 200) assert auction.get_winner(1) == 'Bob' with pytest.raises(ValueError): auction.close_auction(99) def test_combined(): auction = AuctionSystem() auction.add_item(1) auction.add_item(2) auction.place_bid(1, 'Alice', 100) auction.place_bid(1, 'Bob', 150) auction.place_bid(1, 'Charlie', 120) assert auction.get_highest_bid(1) == ('Bob', 150) auction.place_bid(2, 'Alice', 200) assert auction.get_winner(2) == 'Alice' auction.place_bid(1, 'Alice', 160) assert auction.get_highest_bid(1) == ('Alice', 160) auction.close_auction(1) with pytest.raises(ValueError): auction.place_bid(1, 'Dave', 170) assert auction.get_winner(1) == 'Alice'","solution":"class AuctionSystem: def __init__(self): self.items = {} self.closed_items = set() def add_item(self, item_id): if item_id in self.items: raise ValueError(f\\"Item {item_id} already exists.\\") self.items[item_id] = [] def place_bid(self, item_id, bidder_id, bid_amount): if item_id not in self.items: raise ValueError(f\\"Item {item_id} does not exist.\\") if item_id in self.closed_items: raise ValueError(f\\"Auction for item {item_id} is closed.\\") self.items[item_id].append((bidder_id, bid_amount)) def get_highest_bid(self, item_id): if item_id not in self.items or not self.items[item_id]: return None return max(self.items[item_id], key=lambda x: x[1]) def get_winner(self, item_id): highest_bid = self.get_highest_bid(item_id) return highest_bid[0] if highest_bid else None def close_auction(self, item_id): if item_id not in self.items: raise ValueError(f\\"Item {item_id} does not exist.\\") self.closed_items.add(item_id)"},{"question":"def min_storage_plans(n, m, photos): Given the number of photos n, the capacity of the storage plan m, and a list of photo sizes, returns the minimum number of storage plans needed to store all photos. >>> min_storage_plans(3, 100, [80, 120, 150]) 3 >>> min_storage_plans(4, 1000, [200, 300, 400, 100]) 4 >>> min_storage_plans(2, 150, [150, 150]) 2 >>> min_storage_plans(5, 200, [90, 50, 150, 200, 250]) 5 >>> min_storage_plans(1, 500, [499]) 1 >>> min_storage_plans(1, 100, [120]) 1","solution":"def min_storage_plans(n, m, photos): Given the number of photos n, the capacity of the storage plan m, and a list of photo sizes, returns the minimum number of storage plans needed to store all photos. plans_needed = 0 for photo_size in photos: if photo_size <= m: plans_needed += 1 else: plans_needed += 1 # Each photo exceeding the plan's capacity needs its own storage plan. return plans_needed"},{"question":"def min_height_difference(n: int, k: int, elevations: List[int]) -> int: You are given a list of n integers where each integer represents the elevation of a point in a hike trail. You are also given a number k (1 ≤ k ≤ n). Your task is to determine the minimum height difference between the highest and lowest elevations among any contiguous segment of the trail with exactly k points. >>> min_height_difference(6, 3, [15, 11, 13, 19, 18, 14]) == 4 >>> min_height_difference(5, 2, [10, 10, 10, 10, 10]) == 0 >>> min_height_difference(5, 2, [1, 2, 3, 4, 5]) == 1 >>> min_height_difference(5, 3, [5, 4, 3, 2, 1]) == 2 >>> min_height_difference(5, 1, [5, 4, 3, 2, 1]) == 0 >>> min_height_difference(100000, 2, list(range(1, 100001))) == 1 >>> min_height_difference(6, 3, [1, 100, 1, 100, 1, 100]) == 99","solution":"def min_height_difference(n, k, elevations): min_diff = float('inf') for i in range(n - k + 1): segment = elevations[i:i+k] diff = max(segment) - min(segment) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def largest_land_region(n: int, m: int, grid: List[str]) -> int: Returns the size of the largest connected region of land cells ('#'). Args: n: int - Number of rows in the grid. m: int - Number of columns in the grid. grid: List[str] - A list of strings representing the grid. Returns: int - The size of the largest connected region of land cells. >>> largest_land_region(5, 5, [\\".#...\\", \\"#\\", \\".....\\", \\".#T\\", \\"#.#\\"]) 6 >>> largest_land_region(5, 5, [\\".....\\",\\".....\\",\\".....\\",\\".....\\",\\".....\\"]) 0 >>> largest_land_region(5, 5, [\\"#\\",\\"#\\",\\"#\\",\\"#\\",\\"#\\"]) 25 >>> largest_land_region(5, 5, [\\".....\\",\\".....\\",\\"..#..\\",\\".....\\",\\".....\\"]) 1 >>> largest_land_region(5, 5, [\\"...\\",\\"...\\",\\".....\\",\\"...\\",\\"...\\"]) 4 >>> largest_land_region(1, 14, [\\"#....#....#....\\"]) 1 >>> largest_land_region(5, 1, [\\"#\\",\\".\\",\\"#\\",\\".\\",\\"#\\"]) 1","solution":"def largest_land_region(n, m, grid): Returns the size of the largest connected region of land cells ('#'). def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != '#' or visited[x][y]: return 0 visited[x][y] = True size = 1 # Current cell for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += dfs(x + dx, y + dy) return size visited = [[False] * m for _ in range(n)] max_region_size = 0 for i in range(n): for j in range(m): if grid[i][j] == '#' and not visited[i][j]: region_size = dfs(i, j) max_region_size = max(max_region_size, region_size) return max_region_size"},{"question":"def can_arrange_photos(r: int, c: int, n: int, photo_types: List[int]) -> str: Determines if it is possible to arrange the photos in the grid such that no two photos of the same type are in the same row or column. Parameters: r (int): Number of rows in the grid. c (int): Number of columns in the grid. n (int): Number of distinct photo types. photo_types (list of int): List containing the number of photos of each type. Returns: str: 'YES' if it is possible to arrange the photos, 'NO' otherwise. # Test Cases def test_case_one(): r, c, n = 3, 3, 2 photo_types = [4, 5] assert can_arrange_photos(r, c, n, photo_types) == \\"NO\\" def test_case_two(): r, c, n = 3, 3, 2 photo_types = [1, 1] assert can_arrange_photos(r, c, n, photo_types) == \\"YES\\" def test_case_three(): r, c, n = 5, 5, 2 photo_types = [5, 4] assert can_arrange_photos(r, c, n, photo_types) == \\"YES\\" def test_case_four(): r, c, n = 4, 3, 3 photo_types = [2, 2, 2] assert can_arrange_photos(r, c, n, photo_types) == \\"YES\\" def test_case_five(): r, c, n = 4, 3, 5 photo_types = [1, 1, 1, 1, 1] assert can_arrange_photos(r, c, n, photo_types) == \\"NO\\"","solution":"def can_arrange_photos(r, c, n, photo_types): Determines if it is possible to arrange the photos in the grid such that no two photos of the same type are in the same row or column. Parameters: r (int): Number of rows in the grid. c (int): Number of columns in the grid. n (int): Number of distinct photo types. photo_types (list of int): List containing the number of photos of each type. Returns: str: 'YES' if it is possible to arrange the photos, 'NO' otherwise. # The number of types cannot be greater than the number of rows or columns if n > r or n > c: return \\"NO\\" # The maximum number of photos any type can have is min(r, c) because we can't have more # than min(r, c) cells without repeating in a row or column. max_photos_per_type = min(r, c) for photos in photo_types: if photos > max_photos_per_type: return \\"NO\\" return \\"YES\\""},{"question":"def findKthSmallest(arr, k): Finds the k-th smallest element in the array considering the original positions for duplicates. >>> findKthSmallest([7, 10, 4, 3, 20], 3) == 7 >>> findKthSmallest([7, 10, 4, 3, 20], 1) == 3 >>> findKthSmallest([7, 10, 4, 3, 20], 5) == 20 >>> findKthSmallest([7, 10, 4, 3, 10, 20], 3) == 7 >>> findKthSmallest([3, 3, 3, 3, 3], 2) == 3 >>> findKthSmallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == 7 >>> findKthSmallest([1], 1) == 1 >>> findKthSmallest([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 5) == 5 >>> findKthSmallest([-10, -20, -30, -40, -50], 4) == -20 >>> findKthSmallest([10, -10, 20, 30, -30], 1) == -30 >>> findKthSmallest([4, 5, 1, 2, 9, 7], 5) == 7","solution":"def findKthSmallest(arr, k): Finds the k-th smallest element in the array considering the original positions for duplicates. def partition(left, right): pivot = arr[right] p_index = left for i in range(left, right): if arr[i] <= pivot: arr[i], arr[p_index] = arr[p_index], arr[i] p_index += 1 arr[p_index], arr[right] = arr[right], arr[p_index] return p_index def quick_select(left, right, k): if left == right: return arr[left] pivot_index = partition(left, right) if k == pivot_index: return arr[k] elif k < pivot_index: return quick_select(left, pivot_index - 1, k) else: return quick_select(pivot_index + 1, right, k) return quick_select(0, len(arr) - 1, k - 1)"},{"question":"def min_flip_operations(original: str, target: str) -> int: Calculate the minimum number of flip operations required to transform the original binary string into the target binary string. >>> min_flip_operations('01001', '10011') == 2 >>> min_flip_operations('1111', '0000') == 1 >>> min_flip_operations('0000', '0000') == 0 >>> min_flip_operations('0101010', '1010101') == 1 >>> min_flip_operations('1010101', '0101010') == 1 >>> min_flip_operations('1100', '0011') == 1 >>> min_flip_operations('1100', '1100') == 0 >>> min_flip_operations('0', '1') == 1 >>> min_flip_operations('1', '0') == 1 >>> min_flip_operations('1', '1') == 0 >>> min_flip_operations('0', '0') == 0 >>> min_flip_operations('000', '111') == 1 >>> min_flip_operations('111', '000') == 1 >>> min_flip_operations('001', '110') == 1 >>> min_flip_operations('010', '101') == 1","solution":"def min_flip_operations(original, target): Calculate the minimum number of flip operations required to transform the original binary string into the target binary string. n = len(original) count = 0 inside_flip = False for i in range(n): if original[i] != target[i]: if not inside_flip: count += 1 inside_flip = True else: if inside_flip: inside_flip = False return count"},{"question":"def max_unique_ads_each_day(n: int, d: int, capacities: List[List[int]]) -> List[int]: Calculate the maximum number of unique advertisements that can be shown across all websites for each day. Args: n: Number of websites. d: Number of days. capacities: A list of lists, where each inner list contains the viewing capacities of a website over d days. Returns: A list of integers representing the maximum number of unique advertisements that can be shown on each day. from typing import List def test_example_case(): n = 6 d = 3 capacities = [ [1, 2, 4], [2, 1, 1], [3, 3, 3], [4, 4, 2], [2, 3, 1], [3, 1, 2], ] assert max_unique_ads_each_day(n, d, capacities) == [15, 14, 13] def test_all_ones(): n = 3 d = 3 capacities = [ [1, 1, 1], [1, 1, 1], [1, 1, 1], ] assert max_unique_ads_each_day(n, d, capacities) == [3, 3, 3] def test_different_numbers(): n = 2 d = 2 capacities = [ [1, 2], [3, 4], ] assert max_unique_ads_each_day(n, d, capacities) == [4, 6] def test_single_website_multiple_days(): n = 1 d = 3 capacities = [ [1, 2, 3], ] assert max_unique_ads_each_day(n, d, capacities) == [1, 2, 3] def test_multiple_websites_single_day(): n = 4 d = 1 capacities = [ [1], [2], [3], [4], ] assert max_unique_ads_each_day(n, d, capacities) == [10]","solution":"def max_unique_ads_each_day(n, d, capacities): Calculate the maximum number of unique advertisements that can be shown across all websites for each day. Args: n: Number of websites. d: Number of days. capacities: A list of lists, where each inner list contains the viewing capacities of a website over d days. Returns: A list of integers representing the maximum number of unique advertisements that can be shown on each day. max_ads_per_day = [0] * d for day in range(d): daily_total = 0 for website in range(n): daily_total += capacities[website][day] max_ads_per_day[day] = daily_total return max_ads_per_day"},{"question":"def count_less_or_equal(n: int, a: List[int], q: int, queries: List[int]) -> List[int]: For each query, finds how many integers in the array a are less than or equal to the given integer x. :param n: int - the size of the array. :param a: List[int] - the array of integers. :param q: int - the number of queries. :param queries: List[int] - list of queries. :return: List[int] - list of results for each query. pass # Unit tests from solution import count_less_or_equal def test_example_case(): n = 5 a = [5, 1, 2, 8, 3] q = 3 queries = [4, 10, 2] expected = [3, 5, 2] assert count_less_or_equal(n, a, q, queries) == expected def test_all_elements_less(): n = 5 a = [1, 2, 3, 4, 5] q = 1 queries = [6] expected = [5] assert count_less_or_equal(n, a, q, queries) == expected def test_all_elements_more(): n = 5 a = [6, 7, 8, 9, 10] q = 1 queries = [5] expected = [0] assert count_less_or_equal(n, a, q, queries) == expected def test_single_element(): n = 1 a = [5] q = 2 queries = [5, 6] expected = [1, 1] assert count_less_or_equal(n, a, q, queries) == expected def test_duplicates(): n = 5 a = [2, 2, 2, 2, 2] q = 2 queries = [1, 2] expected = [0, 5] assert count_less_or_equal(n, a, q, queries) == expected def test_large_numbers(): n = 3 a = [10**9, 10**9, 10**9] q = 1 queries = [10**9] expected = [3] assert count_less_or_equal(n, a, q, queries) == expected","solution":"from bisect import bisect_right def count_less_or_equal(n, a, q, queries): For each query, finds how many integers in the array a are less than or equal to the given integer x. :param n: int - the size of the array. :param a: List[int] - the array of integers. :param q: int - the number of queries. :param queries: List[int] - list of queries. :return: List[int] - list of results for each query. # Sort the array a to make use of binary search. a.sort() # This will store the results for each query. results = [] # Process each query. for x in queries: # Use bisect_right to find the first index where x would go if it were inserted in a. count = bisect_right(a, x) results.append(count) return results"},{"question":"import math from typing import List, Tuple def optimal_garbage_collection(n: int, coordinates: List[Tuple[int, int]]) -> float: Determine the optimal route for a garbage truck to empty all bins and return to the starting point. The route should minimize the total distance traveled. Args: n: An integer representing the number of garbage bins (2 ≤ n ≤ 20). coordinates: A list of tuples representing the (x, y) coordinates of each garbage bin, where -1000 ≤ x, y ≤ 1000. Returns: A float representing the minimum distance the truck must travel, rounded to 4 decimal places. Examples: >>> optimal_garbage_collection(4, [(0, 0), (2, 0), (2, 2), (0, 2)]) 8.0000 pass # Your implementation here from solution import optimal_garbage_collection def test_optimal_garbage_collection_example(): coordinates = [(0, 0), (2, 0), (2, 2), (0, 2)] assert optimal_garbage_collection(4, coordinates) == 8.0000 def test_optimal_garbage_collection_case1(): coordinates = [(0, 0), (1, 0), (1, 1), (0, 1)] assert optimal_garbage_collection(4, coordinates) == 4.0000 def test_optimal_garbage_collection_case2(): coordinates = [(0, 0), (1, 0), (1, 1)] assert optimal_garbage_collection(3, coordinates) == 3.4142 def test_optimal_garbage_collection_different_coordinates(): coordinates = [(0, 0), (5, 0), (5, 5), (0, 5)] assert optimal_garbage_collection(4, coordinates) == 20.0000 def test_optimal_garbage_collection_single_line(): coordinates = [(0, 0), (0, 1), (0, 2), (0, 3)] assert optimal_garbage_collection(4, coordinates) == 6.0000 def test_optimal_garbage_collection_two_bins(): coordinates = [(0, 0), (3, 4)] assert optimal_garbage_collection(2, coordinates) == 10.0000","solution":"import itertools import math def euclidean_distance(point1, point2): return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def optimal_garbage_collection(n, coordinates): all_permutations = itertools.permutations(coordinates) min_distance = float('inf') for perm in all_permutations: current_distance = 0 for i in range(n): current_distance += euclidean_distance(perm[i], perm[(i + 1) % n]) if current_distance < min_distance: min_distance = current_distance return round(min_distance, 4)"},{"question":"def rotate_matrix(matrix, k, direction): Rotates an n x n matrix k times in the specified direction. Args: matrix (list of list of int): The input matrix. k (int): Number of rotations. direction (str): Direction of rotation ('clockwise' or 'counterclockwise'). Returns: list of list of int: The rotated matrix. from solution import rotate_matrix def test_rotate_no_rotation(): matrix = [ [1, 2], [3, 4] ] assert rotate_matrix(matrix, 0, \\"clockwise\\") == matrix def test_rotate_clockwise_1(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] assert rotate_matrix(matrix, 1, \\"clockwise\\") == expected def test_rotate_clockwise_2(): matrix = [ [1, 2], [3, 4] ] expected = [ [4, 3], [2, 1] ] assert rotate_matrix(matrix, 2, \\"clockwise\\") == expected def test_rotate_clockwise_3(): matrix = [ [1, 2], [3, 4] ] expected = [ [2, 4], [1, 3] ] assert rotate_matrix(matrix, 3, \\"clockwise\\") == expected def test_rotate_counterclockwise_1(): matrix = [ [1, 2], [3, 4] ] expected = [ [2, 4], [1, 3] ] assert rotate_matrix(matrix, 1, \\"counterclockwise\\") == expected def test_large_k_rotation(): matrix = [ [1, 2], [3, 4] ] expected = [ [1, 2], [3, 4] ] assert rotate_matrix(matrix, 1000000000, \\"clockwise\\") == expected def test_odd_sized_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix, 1, \\"clockwise\\") == expected def test_complex_case(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(matrix, 1, \\"clockwise\\") == expected def test_same_matrix_after_4_rotations(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert rotate_matrix(matrix, 4, \\"clockwise\\") == matrix assert rotate_matrix(matrix, 4, \\"counterclockwise\\") == matrix","solution":"def rotate_matrix(matrix, k, direction): Rotates an n x n matrix k times in the specified direction. Args: matrix (list of list of int): The input matrix. k (int): Number of rotations. direction (str): Direction of rotation ('clockwise' or 'counterclockwise'). Returns: list of list of int: The rotated matrix. n = len(matrix) if n == 1 or k % 4 == 0: return matrix # No rotation needed k %= 4 # Only 4 possible unique rotations for a square matrix if direction == 'counterclockwise': k = 4 - k # Switching to clockwise equivalent for simplicity for _ in range(k): # Perform one clockwise rotation matrix = [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] return matrix"},{"question":"def min_light_radius(n: int, L: int, positions: List[int]) -> float: Returns the minimum light radius required for the lanterns to illuminate the entire street. >>> min_light_radius(7, 15, [15, 5, 3, 7, 9, 14, 0]) 2.5 >>> min_light_radius(2, 10, [0, 10]) 5.0 >>> min_light_radius(3, 20, [0, 10, 20]) 5.0 >>> min_light_radius(1, 10, [5]) 5.0 >>> min_light_radius(1, 10, [0]) 10.0 >>> min_light_radius(1, 10, [10]) 10.0","solution":"import math def min_light_radius(n, L, positions): Returns the minimum light radius required for the lanterns to illuminate the entire street. positions.sort() # The maximum gap between two adjacent lanterns max_gap = 0 for i in range(1, n): max_gap = max(max_gap, positions[i] - positions[i - 1]) # Consider the edges of the street edge_left = positions[0] edge_right = L - positions[-1] # The required radius needs to cover the largest gap divided by 2, # but also needs to cover the distance to the edges of the street. radius = max(max_gap / 2, edge_left, edge_right) return radius"},{"question":"def min_cost_to_make_palindrome(s: str) -> int: Computes the minimum number of character replacements required to make the string s a palindrome. pass def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns the results for each. pass def test_min_cost_to_make_palindrome(): assert min_cost_to_make_palindrome(\\"ab\\") == 1 assert min_cost_to_make_palindrome(\\"racecar\\") == 0 assert min_cost_to_make_palindrome(\\"aabb\\") == 2 assert min_cost_to_make_palindrome(\\"abcd\\") == 2 assert min_cost_to_make_palindrome(\\"abcba\\") == 0 assert min_cost_to_make_palindrome(\\"a\\") == 0 assert min_cost_to_make_palindrome(\\"abca\\") == 1 def test_process_test_cases(): assert process_test_cases([\\"ab\\", \\"racecar\\", \\"aabb\\", \\"abcd\\", \\"abcba\\", \\"a\\", \\"abca\\"]) == [1, 0, 2, 2, 0, 0, 1] assert process_test_cases([\\"\\"]) == [0] assert process_test_cases([\\"aaaa\\", \\"abba\\"]) == [0, 0] def test_edge_cases(): assert min_cost_to_make_palindrome(\\"\\") == 0 assert min_cost_to_make_palindrome(\\"a\\"*100000) == 0 assert min_cost_to_make_palindrome(\\"ab\\"*50000) == 50000","solution":"def min_cost_to_make_palindrome(s): Computes the minimum number of character replacements required to make the string s a palindrome. left, right = 0, len(s) - 1 cost = 0 while left < right: if s[left] != s[right]: cost += 1 left += 1 right -= 1 return cost def process_test_cases(test_cases): Processes a list of test cases and returns the results for each. return [min_cost_to_make_palindrome(s) for s in test_cases]"},{"question":"from typing import List def max_area_of_island(grid: List[List[int]]) -> int: You are given a 2D grid consisting of '0's (water) and '1's (land). An island is a group of connected '1's (land) connected horizontally or vertically. You need to write a function that finds and returns the maximum area of an island in the given grid. If there is no island, the maximum area is 0. >>> max_area_of_island([[0,0,1,0,0], ... [0,1,1,1,0], ... [0,0,1,0,0], ... [1,1,0,0,0], ... [1,0,0,1,1]]) 5 >>> max_area_of_island([[1,1,0,0], ... [1,1,0,0], ... [0,0,0,0], ... [0,0,1,1]]) 4 >>> max_area_of_island([[0,0,0,0], ... [0,0,0,0], ... [0,0,0,0], ... [0,0,0,0]]) 0 >>> max_area_of_island([[1,0,0,1], ... [1,0,0,1], ... [0,1,1,0], ... [0,0,0,0]]) 2 >>> max_area_of_island([[1,1,1,0], ... [1,1,1,0], ... [1,1,1,0], ... [0,0,0,0]]) 9 >>> max_area_of_island([[0]]) 0 >>> max_area_of_island([[1]]) 1","solution":"def max_area_of_island(grid): Given a 2D grid, this function returns the maximum area of an island. An island is made up of '1's (land) connected horizontally or vertically. def dfs(x, y): Perform Depth-First Search to find the area of an island. if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark as visited area = 1 for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]: area += dfs(x + dx, y + dy) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"def can_sort_with_cranes(n, k, a): Determine if it's possible to dismantle buildings such that the remaining sequence is sorted in non-decreasing order using at most k cranes. >>> can_sort_with_cranes(4, 1, [3, 4, 2, 5]) \\"YES\\" >>> can_sort_with_cranes(4, 0, [3, 4, 2, 5]) \\"NO\\" >>> can_sort_with_cranes(5, 2, [4, 3, 2, 5, 6]) \\"YES\\" >>> can_sort_with_cranes(5, 1, [4, 3, 2, 5, 6]) \\"NO\\" >>> can_sort_with_cranes(3, 0, [1, 2, 3]) \\"YES\\" pass def crane_solver(test_cases): Process multiple test cases and determine if each can be sorted using cranes. >>> crane_solver([(4, 1, [3, 4, 2, 5])]) [\\"YES\\"] >>> crane_solver([(4, 0, [3, 4, 2, 5])]) [\\"NO\\"] >>> crane_solver([(5, 2, [4, 3, 2, 5, 6])]) [\\"YES\\"] >>> crane_solver([(5, 1, [4, 3, 2, 5, 6])]) [\\"NO\\"] >>> crane_solver([(3, 0, [1, 2, 3])]) [\\"YES\\"] pass","solution":"def can_sort_with_cranes(n, k, a): unsorted_count = 0 for i in range(n - 1): if a[i] > a[i + 1]: unsorted_count += 1 return \\"YES\\" if unsorted_count <= k else \\"NO\\" def crane_solver(test_cases): results = [] for n, k, a in test_cases: results.append(can_sort_with_cranes(n, k, a)) return results"},{"question":"def max_coins(n: int, m: int, grid: List[List[int]]) -> int: Calculates the maximum number of coins that can be collected when moving from the top-left to the bottom-right corner of a grid. Args: n (int): the number of rows in the grid m (int): the number of columns in the grid grid (List[List[int]]): the grid represented as a list of lists Returns: int: An integer representing the maximum number of coins that can be collected. Example: >>> max_coins(3, 4, [ ... [0, 3, 1, 1], ... [2, 0, 0, 4], ... [1, 5, 3, 1] ... ]) 12 >>> >>> max_coins(1, 4, [ ... [1, 2, 3, 4] ... ]) 10 >>> >>> max_coins(4, 1, [ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> >>> max_coins(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> >>> max_coins(2, 2, [ ... [0, 0], ... [0, 0] ... ]) 0","solution":"def max_coins(n, m, grid): Calculates the maximum number of coins that can be collected when moving from the top-left to the bottom-right corner of a grid. Arguments: n -- the number of rows in the grid m -- the number of columns in the grid grid -- the grid represented as a list of lists Returns: An integer representing the maximum number of coins that can be collected. # Create a 2D list to store the maximum coins at each cell dp = [[0]*m for _ in range(n)] # Initialize the first cell with the number of coins in the starting cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the maximum coins collected return dp[-1][-1]"},{"question":"from typing import List def is_path_exists(n: int, m: int, grid: List[str]) -> str: Determines if there is a path from the top-left corner to the bottom-right corner of the grid. :param n: int - Number of rows in the grid :param m: int - Number of columns in the grid :param grid: List[str] - Grid of characters where '.' represents an empty space and '#' represents an obstacle :return: str - \\"YES\\" if a path exists, \\"NO\\" otherwise >>> is_path_exists(5, 5, [\\".....\\", \\".#.\\", \\".#...\\", \\".#.#.\\", \\".....\\"]) \\"YES\\" >>> is_path_exists(3, 3, [\\".#.\\", \\"#\\", \\"#..\\"]) \\"NO\\" >>> is_path_exists(1, 1, [\\".\\"]) \\"YES\\" >>> is_path_exists(1, 2, [\\"..\\"]) \\"YES\\" >>> is_path_exists(2, 1, [\\".\\", \\".\\"]) \\"YES\\" >>> is_path_exists(2, 2, [\\"\\", \\"\\"]) \\"NO\\" >>> is_path_exists(2, 2, [\\"..\\", \\"\\"]) \\"NO\\" >>> is_path_exists(2, 2, [\\".#\\", \\".#\\"]) \\"NO\\" >>> is_path_exists(2, 2, [\\"..\\", \\"..\\"]) \\"YES\\"","solution":"def is_path_exists(n, m, grid): Determines if there is a path from the top-left corner to the bottom-right corner of the grid. :param n: int - Number of rows in the grid :param m: int - Number of columns in the grid :param grid: List[str] - Grid of characters where '.' represents an empty space and '#' represents an obstacle :return: str - \\"YES\\" if a path exists, \\"NO\\" otherwise from collections import deque if grid[0][0] == '#' or grid[n - 1][m - 1] == '#': return \\"NO\\" directions = [(1, 0), (0, 1)] # Possible moves: down, right queue = deque([(0, 0)]) visited = set([(0, 0)]) while queue: x, y = queue.popleft() if x == n - 1 and y == m - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of a contiguous subarray in an array of integers. >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1000, -1000, 1000, -1000, 1000]) 1000 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([0, 0, 0, 0, 0]) 0 >>> max_subarray_sum([0, -1, 0, -2, 0]) 0","solution":"def max_subarray_sum(arr): Finds the maximum sum of a contiguous subarray using Kadane's algorithm. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List, Tuple def least_cost_path(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int: Find the least-cost path from a given start vertex to a given end vertex using the weights on the edges. If there is no path from the start vertex to the end vertex, return -1. Args: n : int : the number of vertices m : int : the number of edges edges : List[Tuple[int, int, int]] : list of edges where each edge is defined as a tuple (u, v, w) representing an edge from vertex u to vertex v with weight w s : int : start vertex t : int : end vertex Returns: int : the minimum cost to travel from vertex s to vertex t >>> least_cost_path(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)], 1, 5) 6 >>> least_cost_path(4, 2, [(1, 2, 2), (3, 4, 1)], 1, 4) -1","solution":"import heapq from collections import defaultdict import sys def least_cost_path(n, m, edges, s, t): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) min_heap = [(0, s)] # (cost, vertex) distances = {i: sys.maxsize for i in range(1, n+1)} distances[s] = 0 while min_heap: current_cost, vertex = heapq.heappop(min_heap) if vertex == t: return current_cost if current_cost > distances[vertex]: continue for neighbor, weight in graph[vertex]: distance = current_cost + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1 if distances[t] == sys.maxsize else distances[t]"},{"question":"def maximum_difference(nums: List[int]) -> int: Returns the maximum difference between two elements such that the larger element appears after the smaller element. If no such element pairs exist, return 0. >>> maximum_difference([7, 1, 5, 4]) 4 >>> maximum_difference([9, 4, 3, 2]) 0 >>> maximum_difference([1, 5, 2, 10]) 9 from solution import maximum_difference def test_maximum_difference_example1(): assert maximum_difference([7, 1, 5, 4]) == 4 def test_maximum_difference_example2(): assert maximum_difference([9, 4, 3, 2]) == 0 def test_maximum_difference_example3(): assert maximum_difference([1, 5, 2, 10]) == 9 def test_maximum_difference_single_element(): assert maximum_difference([5]) == 0 def test_maximum_difference_ascending_order(): assert maximum_difference([1, 2, 3, 4, 5]) == 4 def test_maximum_difference_descending_order(): assert maximum_difference([5, 4, 3, 2, 1]) == 0 def test_maximum_difference_equal_elements(): assert maximum_difference([1, 1, 1, 1]) == 0 def test_maximum_difference_negative_numbers(): assert maximum_difference([-1, -5, -2, -3, -7]) == 3 def test_maximum_difference_mixed_numbers(): assert maximum_difference([1, -5, 2, -3, 10]) == 15","solution":"def maximum_difference(nums): Returns the maximum difference between two elements such that the larger element appears after the smaller element. If no such element pairs exist, return 0. if len(nums) < 2: return 0 min_element = nums[0] max_diff = 0 for num in nums[1:]: if num > min_element: max_diff = max(max_diff, num - min_element) else: min_element = min(min_element, num) return max_diff"},{"question":"def can_rearrange_cases(t: int, cases: list) -> list: Rearrange the integers in each test case such that each integer is followed by a unique integer not adjacent to itself in the original list. If rearrangement is not possible, return \\"No\\". :param t: int: The number of test cases. :param cases: list: A list of tuples where each tuple contains the length of list and the list of integers. :return: list: A list of results, where each result is either \\"No\\" or \\"Yes\\" followed by the rearranged list. >>> can_rearrange_cases(3, [(4, [5, 1, 3, 2]), (5, [1, 2, 2, 3, 4]), (6, [1, 1, 1, 1, 1, 1])]) [\\"Yesn1 3 2 5\\", \\"No\\", \\"No\\"] >>> can_rearrange_cases(2, [(2, [1, 2]), (2, [100, 100])]) [\\"Yesn1 2\\", \\"No\\"] import pytest def test_example_cases(): cases = [ (4, [5, 1, 3, 2]), (5, [1, 2, 2, 3, 4]), (6, [1, 1, 1, 1, 1, 1]) ] assert can_rearrange_cases(3, cases) == [ \\"Yesn1 3 2 5\\", \\"No\\", \\"No\\" ] def test_all_equal_elements(): cases = [ (3, [10, 10, 10]), (5, [7, 7, 7, 7, 7]) ] assert can_rearrange_cases(2, cases) == [ \\"No\\", \\"No\\" ] def test_two_elements(): cases = [ (2, [1, 2]), (2, [100, 100]) ] assert can_rearrange_cases(2, cases) == [ \\"Yesn1 2\\", \\"No\\" ] def test_large_distinct_elements(): cases = [ (5, [1, 2, 3, 4, 5]) ] results = can_rearrange_cases(1, cases) assert results[0].startswith(\\"Yes\\") def test_large_mixed_elements(): cases = [ (6, [9, 3, 5, 7, 8, 6]) ] results = can_rearrange_cases(1, cases) assert results[0].startswith(\\"Yes\\") if __name__ == \\"__main__\\": pytest.main()","solution":"def can_rearrange_cases(t, cases): results = [] for n, arr in cases: unique_elements = set(arr) if len(unique_elements) == 1: # All elements are the same results.append(\\"No\\") continue sorted_arr = sorted(arr) half = n // 2 left = sorted_arr[:half] right = sorted_arr[half:] rearranged = [] for l, r in zip(left, right): rearranged.extend([l, r]) if n % 2 == 1: # If odd, add the last remaining element rearranged.append(right[-1]) valid = True for i in range(1, n): if rearranged[i] == rearranged[i-1]: valid = False break if valid: results.append(f\\"Yesn{' '.join(map(str, rearranged))}\\") else: results.append(\\"No\\") return results"},{"question":"def max_non_overlapping_classes(n, intervals): This function takes the number of classes and a list of intervals (start and end times) and returns the maximum number of non-overlapping classes that can be scheduled. >>> max_non_overlapping_classes(5, [(1, 3), (2, 4), (3, 5), (6, 8), (7, 10)]) 3 >>> max_non_overlapping_classes(3, [(1, 3), (3, 6), (6, 8)]) 3 >>> max_non_overlapping_classes(4, [(1, 2), (2, 3), (3, 4), (0, 6)]) 3 >>> max_non_overlapping_classes(0, []) 0 >>> max_non_overlapping_classes(1, [(1, 2)]) 1 >>> max_non_overlapping_classes(6, [(1, 3), (3, 5), (0, 2), (5, 7), (8, 9), (5, 9)]) 4 >>> max_non_overlapping_classes(2, [(1, 3), (2, 4)]) 1","solution":"def max_non_overlapping_classes(n, intervals): This function takes the number of classes and a list of intervals (start and end times) and returns the maximum number of non-overlapping classes that can be scheduled. if n == 0: return 0 # Sort intervals by end time intervals.sort(key=lambda x: x[1]) # Initialize the end time of the last selected class last_end_time = -1 count = 0 for interval in intervals: start, end = interval if start >= last_end_time: # Select this class count += 1 last_end_time = end return count"},{"question":"class Library: def __init__(self, n: int, k: int): Initialize the library system with n members and a maximum borrowing limit of k books per member. def borrow(self, memberId: int, bookId: int): Member with memberId borrows the book with bookId. Print \\"Borrowed\\" if the operation is successful, or \\"Waitlisted\\" if the member is added to the waiting list. >>> lib = Library(3, 2) >>> lib.borrow(1, 101) Borrowed >>> lib.borrow(2, 101) Borrowed >>> lib.borrow(3, 101) Waitlisted >>> lib.status(101) Borrowed by [1, 2] >>> lib.returnBook(1, 101) Returned def returnBook(self, memberId: int, bookId: int): Member with memberId returns the book with bookId. Print \\"Returned\\" if the operation is successful, and if the book is borrowed by another member from the waiting list, print \\"Borrowed by X\\" where X is the member ID of the next borrower. >>> lib = Library(3, 2) >>> lib.borrow(1, 101) Borrowed >>> lib.borrow(2, 101) Borrowed >>> lib.returnBook(1, 101) Returned Borrowed by 2 >>> lib.returnBook(2, 101) Returned def status(self, bookId: int): Print the current status of the book with bookId. >>> lib = Library(3, 2) >>> lib.borrow(1, 101) Borrowed >>> lib.status(101) Borrowed by 1 >>> lib.returnBook(1, 101) Returned >>> lib.status(101) Available","solution":"class Library: def __init__(self, n, k): self.max_books = k self.borrowed_books = {} # Key: bookId, Value: memberId self.member_books = {i: [] for i in range(1, n + 1)} # Key: memberId, Value: list of borrowed bookIds self.waitlist = {} # Key: bookId, Value: list of memberIds def borrow(self, memberId, bookId): if len(self.member_books[memberId]) >= self.max_books: print(\\"Waitlisted\\") if bookId not in self.waitlist: self.waitlist[bookId] = [] self.waitlist[bookId].append(memberId) return if bookId in self.borrowed_books: print(\\"Waitlisted\\") if bookId not in self.waitlist: self.waitlist[bookId] = [] self.waitlist[bookId].append(memberId) else: print(\\"Borrowed\\") self.borrowed_books[bookId] = memberId self.member_books[memberId].append(bookId) def returnBook(self, memberId, bookId): if bookId in self.borrowed_books and self.borrowed_books[bookId] == memberId: print(\\"Returned\\") del self.borrowed_books[bookId] self.member_books[memberId].remove(bookId) # Check if there is a member waiting for this book if bookId in self.waitlist and self.waitlist[bookId]: next_member = self.waitlist[bookId].pop(0) print(f\\"Borrowed by {next_member}\\") self.borrowed_books[bookId] = next_member self.member_books[next_member].append(bookId) if not self.waitlist[bookId]: del self.waitlist[bookId] else: print(\\"Return failed: either book was not borrowed by this member or wrong memberId\\") def status(self, bookId): if bookId not in self.borrowed_books and bookId not in self.waitlist: print(\\"Available\\") elif bookId in self.borrowed_books: print(f\\"Borrowed by {self.borrowed_books[bookId]}\\") else: print(f\\"Waitlisted by {self.waitlist[bookId]}\\")"},{"question":"def rotateArray(arr: List[int], k: int) -> List[int]: You are given an integer array \`arr\` and an integer \`k\`, which represents the number of steps to rotate the array to the right. Write a function \`rotateArray\` to rotate the array in-place and return the modified array. Parameters: arr: A list of integers that you need to rotate. k: An integer representing the number of steps to rotate \`arr\` to the right. Returns: Return the modified list after rotating it \`k\` steps to the right. Examples: >>> rotateArray([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotateArray([0, 1, 2], 4) [2, 0, 1]","solution":"from typing import List def rotateArray(arr: List[int], k: int) -> List[int]: Rotates the array \`arr\` in-place \`k\` steps to the right. n = len(arr) if n == 0: return arr # Ensure k is within the bounds of the array length k = k % n # Rotate the array in three steps reverse(arr, 0, n-1) reverse(arr, 0, k-1) reverse(arr, k, n-1) return arr def reverse(arr: List[int], start: int, end: int) -> None: while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1"},{"question":"def count_valid_transactions(N: int, O: int, M: int, transaction: str, penalties: List[int], times: List[List[int]]) -> int: Count the number of valid transactions that can be derived from the original transaction with the total execution time not exceeding M. >>> count_valid_transactions(3, 3, 6, \\"abc\\", [1, 1, 1], [[0, 2, 3], [2, 0, 4], [3, 4, 0]]) == 6 >>> count_valid_transactions(2, 2, 10, \\"ab\\", [5, 5], [[0, 5], [5, 0]]) == 3 >>> count_valid_transactions(1, 1, 1, \\"a\\", [1], [[0]]) == 1 >>> count_valid_transactions(4, 2, 15, \\"aabb\\", [3, 3], [[0, 2], [2, 0]]) == 10","solution":"def count_valid_transactions(N, O, M, transaction, penalties, times): total_valid_transactions = 0 # A helper function to calculate the total execution time for a given substring. def calculate_execution_time(substring): if len(substring) == 1: return penalties[ord(substring) - ord('a')] time_sum = 0 for i in range(len(substring) - 1): time_sum += times[ord(substring[i]) - ord('a')][ord(substring[i+1]) - ord('a')] return time_sum # Iterate through all possible sub-strings for start in range(N): for end in range(start + 1, N + 1): sub_transaction = transaction[start:end] if calculate_execution_time(sub_transaction) <= M: total_valid_transactions += 1 return total_valid_transactions"},{"question":"def shortest_sequence_to_return_to_origin(n: int, commands: str) -> str: Returns the shortest sequence of commands to bring the robotic arm back to position 0. >>> shortest_sequence_to_return_to_origin(6, \\"LRRLLL\\") \\"RR\\" >>> shortest_sequence_to_return_to_origin(4, \\"LRLR\\") \\"\\" >>> shortest_sequence_to_return_to_origin(1, \\"R\\") \\"L\\" >>> shortest_sequence_to_return_to_origin(1, \\"L\\") \\"R\\" >>> shortest_sequence_to_return_to_origin(4, \\"LLLL\\") \\"RRRR\\" >>> shortest_sequence_to_return_to_origin(4, \\"RRRR\\") \\"LLLL\\" >>> shortest_sequence_to_return_to_origin(6, \\"RLRLRL\\") \\"\\"","solution":"def shortest_sequence_to_return_to_origin(n, commands): Returns the shortest sequence of commands to bring the robotic arm back to position 0 :param n: int - number of commands :param commands: string - sequence of commands consisting of 'L' and 'R' :return: string - the shortest sequence of commands to return to origin or an empty line if already at position 0 # Calculate the net position net_position = 0 for command in commands: if command == 'L': net_position -= 1 elif command == 'R': net_position += 1 # If already at the origin if net_position == 0: return \\"\\" # To move back to the origin if net_position > 0: return 'L' * net_position else: return 'R' * abs(net_position)"},{"question":"def is_secure_password(password: str) -> bool: Checks if the password is secure based on the following rules: - It must be at least 8 characters long. - It must contain at least one uppercase letter (A-Z). - It must contain at least one lowercase letter (a-z). - It must contain at least one digit (0-9). - It must contain at least one special character from the set (!@#%^&*()_+). Args: password (str): The password to check. Returns: bool: True if the password is secure, False otherwise. >>> is_secure_password(\\"Aa1!aa1a\\") True >>> is_secure_password(\\"Aa1aaaaa\\") False >>> is_secure_password(\\"aaa1!aaa\\") False","solution":"def is_secure_password(password): Checks if the password is secure based on the following rules: - It must be at least 8 characters long. - It must contain at least one uppercase letter (A-Z). - It must contain at least one lowercase letter (a-z). - It must contain at least one digit (0-9). - It must contain at least one special character (!@#%^&*()_+). Args: password (str): The password to check. Returns: bool: True if the password is secure, False otherwise. if len(password) < 8: return False has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in '!@#%^&*()_+' for c in password) return has_upper and has_lower and has_digit and has_special"},{"question":"def remove_duplicates(nums: List[int]) -> int: Given a sorted integer array, remove duplicates in-place such that each unique element appears only once. Return the number of unique elements in the array. The input array should be modified in-place to contain these unique elements at the beginning. Args: nums (List[int]): List of sorted integers. Returns: int: The number of unique elements in the array after removing duplicates. Example: >>> nums = [1, 1, 2] >>> remove_duplicates(nums) 2 >>> nums[:2] [1, 2] from solution import remove_duplicates def test_remove_duplicates_basic(): nums = [1, 1, 2] assert remove_duplicates(nums) == 2 assert nums[:2] == [1, 2] def test_remove_duplicates_all_unique(): nums = [1, 2, 3, 4, 5] assert remove_duplicates(nums) == 5 assert nums[:5] == [1, 2, 3, 4, 5] def test_remove_duplicates_all_duplicates(): nums = [2, 2, 2, 2, 2] assert remove_duplicates(nums) == 1 assert nums[0] == 2 def test_remove_duplicates_longer_sequence(): nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] assert remove_duplicates(nums) == 5 assert nums[:5] == [0, 1, 2, 3, 4] def test_remove_duplicates_single_element(): nums = [1] assert remove_duplicates(nums) == 1 assert nums[0] == 1 def test_remove_duplicates_empty_array(): nums = [] assert remove_duplicates(nums) == 0","solution":"def remove_duplicates(nums): This function removes duplicates in-place in a sorted array and returns the number of unique elements. if not nums: return 0 # Initialize the unique element counter unique_index = 0 # Iterate over the array comparing current element with the last unique element found for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] # The number of unique elements is unique_index + 1 return unique_index + 1"},{"question":"def can_add_one_chair(room: str) -> str: Determine if it is possible to add exactly one '0' (chair) to the given room string such that no two consecutive '1's exist. :param room: str, the input room string of '1's and '0's :return: str, \\"YES\\" if it is possible to add one '0', otherwise \\"NO\\" >>> can_add_one_chair(\\"1001\\") \\"YES\\" >>> can_add_one_chair(\\"100\\") \\"YES\\" >>> can_add_one_chair(\\"111\\") \\"NO\\"","solution":"def can_add_one_chair(room): Determine if it is possible to add exactly one '0' or chair to the given room string such that no two consecutive '1's exist. :param room: str, the input room string of '1's and '0's :return: str, \\"YES\\" if it is possible to add one '0' else \\"NO\\" n = len(room) # Check for any adjacent '1's (social distancing is already violated) for i in range(n - 1): if room[i] == '1' and room[i + 1] == '1': return \\"NO\\" # If there's no such adjacent '1's, then we can add one chair without violating the rule return \\"YES\\""},{"question":"def max_non_overlapping_intervals(n: int, intervals: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping intervals. Parameters: n (int): The number of intervals. intervals (list of tuples): List containing the intervals as (start, end) tuples. Returns: int: The maximum number of non-overlapping intervals. pass from solution import max_non_overlapping_intervals def test_example_case(): assert max_non_overlapping_intervals(5, [(1, 3), (2, 5), (4, 6), (8, 10), (7, 9)]) == 3 def test_no_overlapping_intervals(): assert max_non_overlapping_intervals(3, [(1, 2), (3, 4), (5, 6)]) == 3 def test_all_overlapping_intervals(): assert max_non_overlapping_intervals(3, [(1, 10), (2, 9), (3, 8)]) == 1 def test_some_overlapping_intervals(): assert max_non_overlapping_intervals(4, [(1, 3), (2, 4), (3, 5), (4, 6)]) == 2 def test_single_interval(): assert max_non_overlapping_intervals(1, [(1, 2)]) == 1 def test_large_intervals(): assert max_non_overlapping_intervals(3, [(1, 1000000000), (2, 3), (4, 5)]) == 2 def test_mixed_intervals(): assert max_non_overlapping_intervals(6, [(1, 2), (2, 4), (3, 5), (7, 8), (9, 10), (6, 7)]) == 4","solution":"def max_non_overlapping_intervals(n, intervals): Finds the maximum number of non-overlapping intervals. Parameters: n (int): The number of intervals. intervals (list of tuples): List containing the intervals as (start, end) tuples. Returns: int: The maximum number of non-overlapping intervals. # Sort intervals by their end times intervals.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping intervals count = 0 # The end time of the last added interval last_end_time = 0 for interval in intervals: if interval[0] > last_end_time: # if the start time is greater than the last end time count += 1 last_end_time = interval[1] return count"},{"question":"def process_operations(n: int, m: int, grid: List[List[int]], operations: List[Tuple[str, ...]]) -> List[int]: Process a list of operations on a given grid. Supported operations are 'set' to set values in a subgrid and 'sum' to compute the sum of values in a subgrid. Args: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[List[int]]): the initial grid operations (List[Tuple[str, ...]]): the list of operations to perform Returns: List[int]: the results of 'sum' operations results = [] for operation in operations: op = operation[0] if op == \\"set\\": x1, y1, x2, y2, v = map(int, operation[1:]) for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): grid[i][j] = v elif op == \\"sum\\": x1, y1, x2, y2 = map(int, operation[1:]) total_sum = 0 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): total_sum += grid[i][j] results.append(total_sum) return results import pytest def test_process_operations(): n = 3 m = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] operations = [ (\\"set\\", 1, 1, 2, 2, 99), (\\"sum\\", 0, 0, 2, 2), (\\"sum\\", 1, 1, 2, 2) ] expected_output = [413, 396] assert process_operations(n, m, grid, operations) == expected_output def test_process_operations_single_row(): n = 1 m = 5 grid = [ [1, 2, 3, 4, 5], ] operations = [ (\\"set\\", 0, 1, 0, 3, 10), (\\"sum\\", 0, 0, 0, 4), (\\"sum\\", 0, 1, 0, 3) ] expected_output = [36, 30] assert process_operations(n, m, grid, operations) == expected_output def test_process_operations_single_column(): n = 5 m = 1 grid = [ [1], [2], [3], [4], [5] ] operations = [ (\\"set\\", 1, 0, 3, 0, 7), (\\"sum\\", 0, 0, 4, 0), (\\"sum\\", 1, 0, 3, 0) ] expected_output = [27, 21] assert process_operations(n, m, grid, operations) == expected_output","solution":"def process_operations(n, m, grid, operations): Process a list of operations on a given grid. Supported operations are 'set' to set values in a subgrid and 'sum' to compute the sum of values in a subgrid. Args: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[List[int]]): the initial grid operations (List[Tuple[str, ...]]): the list of operations to perform Returns: List[int]: the results of 'sum' operations results = [] for operation in operations: op = operation[0] if op == \\"set\\": x1, y1, x2, y2, v = map(int, operation[1:]) for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): grid[i][j] = v elif op == \\"sum\\": x1, y1, x2, y2 = map(int, operation[1:]) total_sum = 0 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): total_sum += grid[i][j] results.append(total_sum) return results"},{"question":"def minimum_cost(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Computes the minimum cost to connect all computers in a network. Parameters: n (int): Number of computers (nodes) m (int): Number of connections (edges) edges (List[Tuple[int, int, int]]): List of tuples representing the connections. Each tuple contains two computers and the cost to connect them. Returns: int: The minimum cost to connect all computers or -1 if it's not possible. Examples: >>> minimum_cost(4, 5, [(1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 3), (3, 4, 3)]) 6 >>> minimum_cost(3, 0, []) -1 from typing import List, Tuple def test_minimum_cost_sample_1(): n = 4 m = 5 edges = [ (1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 3), (3, 4, 3) ] assert minimum_cost(n, m, edges) == 6 def test_minimum_cost_sample_2(): n = 3 m = 0 edges = [] assert minimum_cost(n, m, edges) == -1 def test_minimum_cost_all_nodes_connected(): n = 4 m = 5 edges = [ (1, 4, 3), (1, 2, 1), (4, 2, 9), (4, 3, 6), (3, 2, 2) ] assert minimum_cost(n, m, edges) == 6 def test_minimum_cost_some_nodes_not_connected(): n = 5 m = 3 edges = [ (1, 2, 1), (3, 4, 2), (4, 5, 3) ] assert minimum_cost(n, m, edges) == -1 def test_minimum_cost_single_node(): n = 1 m = 0 edges = [] assert minimum_cost(n, m, edges) == 0 def test_minimum_cost_two_nodes_connected(): n = 2 m = 1 edges = [ (1, 2, 7) ] assert minimum_cost(n, m, edges) == 7","solution":"def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def kruskal(n, edges): edges.sort(key=lambda x: x[2]) parent = list(range(n)) rank = [0] * n mst_cost = 0 edges_used = 0 for u, v, w in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += w edges_used += 1 if edges_used == n - 1: break if edges_used == n - 1: return mst_cost else: return -1 def minimum_cost(n, m, edges): if n == 1: return 0 if m == 0: return -1 formatted_edges = [(u-1, v-1, w) for u, v, w in edges] return kruskal(n, formatted_edges)"},{"question":"from typing import List, Tuple def min_steps(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the minimum number of steps to move from start to end in the grid. Parameters: - grid: List of lists with 0 (free cell) and 1 (blocked cell). - start: Tuple (sx, sy) representing the start coordinates. - end: Tuple (ex, ey) representing the end coordinates. Returns: - The minimum number of steps required to reach the end from the start. - -1 if it is not possible to reach the end point. >>> grid = [[0, 0, 0], [1, 0, 0], [0, 1, 0]] >>> start = (0, 0) >>> end = (2, 2) >>> min_steps(grid, start, end) 4 >>> grid = [[0, 1, 1], [1, 0, 1], [1, 1, 0]] >>> start = (0, 0) >>> end = (2, 2) >>> min_steps(grid, start, end) -1 >>> grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> start = (0, 0) >>> end = (2, 2) >>> min_steps(grid, start, end) 4 def test_min_steps_simple_path(): grid = [[0, 0, 1], [1, 0, 0], [0, 1, 0]] start = (0, 0) end = (2, 2) assert min_steps(grid, start, end) == 4 def test_min_steps_no_path(): grid = [[0, 1, 1], [1, 0, 1], [1, 1, 0]] start = (0, 0) end = (2, 2) assert min_steps(grid, start, end) == -1 def test_min_steps_direct_path(): grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] start = (0, 0) end = (2, 2) assert min_steps(grid, start, end) == 4 def test_min_steps_complex_path(): grid = [[0, 0, 0, 1, 0], [1, 0, 1, 0, 0], [0, 0, 0, 0, 1], [0, 1, 1, 0, 0], [0, 0, 0, 1, 0]] start = (0, 0) end = (4, 4) assert min_steps(grid, start, end) == 8 def test_min_steps_large_open_grid(): grid = [[0] * 50 for _ in range(50)] start = (0, 0) end = (49, 49) assert min_steps(grid, start, end) == 98 def test_min_steps_starts_at_end(): grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] start = (0, 0) end = (0, 0) assert min_steps(grid, start, end) == 0","solution":"from collections import deque def min_steps(grid, start, end): Finds the minimum number of steps to move from start to end in the grid. Parameters: - grid: List of lists with 0 (free cell) and 1 (blocked cell). - start: Tuple (sx, sy) representing the start coordinates. - end: Tuple (ex, ey) representing the end coordinates. Returns: - The minimum number of steps required to reach the end from the start. - -1 if it is not possible to reach the end point. m, n = len(grid), len(grid[0]) sx, sy = start ex, ey = end # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize queue for BFS and set the starting node queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() # Check if we reached the end if (x, y) == (ex, ey): return steps # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy # Check if new position is valid and not visited if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # Return -1 if no path is found return -1"},{"question":"from typing import List, Tuple def find_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: Write a function that takes an integer array and a target integer value, and finds all unique pairs of integers in the array that sum up to the target value. Each pair should be returned as a tuple, and the output should be a list of tuples. The pairs should be listed in ascending order based on the first element of each pair, and in case of a tie, based on the second element of the pair. >>> find_pairs([1, 2, 3, 4, 5], 6) [(1, 5), (2, 4)] >>> find_pairs([-1, 0, 2, -1, -4, 3], -1) [(-4, 3), (-1, 0)] >>> find_pairs([10, 8, -3, 1], 7) [(-3, 10)]","solution":"from typing import List, Tuple def find_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: seen = {} pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen[number] = True return sorted(list(pairs))"},{"question":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: Find the path from the top-left corner to the bottom-right corner of the matrix such that the sum of the values along the path is minimized. You can move either down or right at any point in time. >>> min_path_sum([ ... [3, 7, 2], ... [1, 9, 3], ... [5, 6, 4] ... ]) 19 >>> min_path_sum([[5]]) 5 >>> min_path_sum([]) 0 >>> min_path_sum([ ... [1, 2], ... [1, 1] ... ]) 3 >>> min_path_sum([ ... [1, 10, 10], ... [1, 10, 10], ... [1, 1, 1] ... ]) 5","solution":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 N = len(matrix) # Create a 2D dp array where dp[i][j] represents the minimum path sum to reach cell (i, j) dp = [[float('inf')] * N for _ in range(N)] dp[0][0] = matrix[0][0] for i in range(N): for j in range(N): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + matrix[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + matrix[i][j]) return dp[N-1][N-1]"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def min_messages_to_communicate(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determines the minimum number of messages required for a given server to communicate with all other servers. Args: n (int): The number of servers. m (int): The number of direct communication paths between servers. edges (List[Tuple[int, int]]): A list of tuples representing direct communication paths. Returns: int: The minimum number of messages required for a given server to communicate with all other servers, or -1 if it's not possible. >>> min_messages_to_communicate(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 1 >>> min_messages_to_communicate(4, 2, [(1, 2), (3, 4)]) -1 >>> min_messages_to_communicate(3, 3, [(1, 2), (2, 3), (3, 1)]) 1 >>> min_messages_to_communicate(1, 0, []) 0 >>> min_messages_to_communicate(3, 6, [(1, 2), (2, 1), (1, 3), (3, 1), (2, 3), (3, 2)]) 1","solution":"from collections import deque, defaultdict def min_messages_to_communicate(n, m, edges): def bfs(start): queue = deque([start]) visited = set([start]) count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return count == n if n == 1: return 0 # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Iterate through each vertex, if it can communicate with all other vertices for i in range(1, n + 1): if bfs(i): return 1 return -1"},{"question":"def remove_consecutive_duplicates(n: int, playlist: List[int]) -> List[int]: Removes consecutive duplicates from the playlist. >>> remove_consecutive_duplicates(5, [1, 2, 2, 3, 3]) [1, 2, 3] >>> remove_consecutive_duplicates(6, [1, 1, 1, 1, 1, 1]) [1] >>> remove_consecutive_duplicates(7, [1, 2, 3, 4, 5, 6, 7]) [1, 2, 3, 4, 5, 6, 7] def process_playlists(test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Processes multiple test cases and applies remove_consecutive_duplicates function. >>> process_playlists([(5, [1, 2, 2, 3, 3]), (6, [1, 1, 1, 1, 1, 1]), (7, [1, 2, 3, 4, 5, 6, 7])]) [[1, 2, 3], [1], [1, 2, 3, 4, 5, 6, 7]]","solution":"def remove_consecutive_duplicates(n, playlist): Removes consecutive duplicates from the playlist. Parameters: n (int): Length of the playlist. playlist (list of int): The playlist consisting of song IDs. Returns: list of int: The modified playlist with no consecutive duplicates. if n == 0: return [] cleaned_playlist = [playlist[0]] for i in range(1, n): if playlist[i] != playlist[i-1]: cleaned_playlist.append(playlist[i]) return cleaned_playlist def process_playlists(test_cases): Processes multiple test cases and applies remove_consecutive_duplicates function. Parameters: test_cases (list of tuples): Each tuple contains (n, playlist) representing a test case. Returns: list of list of int: List of cleaned playlists for each test case. results = [] for n, playlist in test_cases: results.append(remove_consecutive_duplicates(n, playlist)) return results"},{"question":"from typing import List, Tuple from collections import defaultdict from datetime import datetime def identify_prolific_borrowers(records: List[Tuple[int, int, str, str]], borrow_limit: int, start_date: str, end_date: str) -> List[int]: Identify members who borrowed more than a specified number of unique books within a given time period. Args: records (List[Tuple[int, int, str, str]]): Borrowing records as a list of tuples in the format (member_id, book_id, borrow_date, return_date). borrow_limit (int): Minimum number of unique books a member must borrow to be considered prolific. start_date (str): Start date of the borrowing period in YYYY-MM-DD format. end_date (str): End date of the borrowing period in YYYY-MM-DD format. Returns: List[int]: Sorted list of member IDs who borrowed more than the specified limit of unique books and have not returned any of those books within the specified period. pass # Unit tests def test_identify_prolific_borrowers_example(): records = [ (1, 123, \\"2023-01-15\\", \\"\\"), (2, 456, \\"2023-02-10\\", \\"2023-02-20\\"), (1, 789, \\"2023-03-05\\", \\"\\"), (3, 123, \\"2023-03-10\\", \\"2023-03-15\\"), (1, 456, \\"2023-04-01\\", \\"\\"), (2, 789, \\"2023-04-01\\", \\"\\") ] borrow_limit = 1 start_date = \\"2023-01-01\\" end_date = \\"2023-03-31\\" assert identify_prolific_borrowers(records, borrow_limit, start_date, end_date) == [1] def test_identify_prolific_borrowers_no_prolific_borrowers(): records = [ (1, 123, \\"2023-01-15\\", \\"2023-01-20\\"), (2, 456, \\"2023-02-10\\", \\"2023-02-15\\"), (1, 789, \\"2023-03-05\\", \\"2023-03-10\\"), (3, 123, \\"2023-03-10\\", \\"2023-03-15\\"), (1, 456, \\"2023-04-01\\", \\"2023-04-05\\"), (2, 789, \\"2023-04-01\\", \\"2023-04-05\\") ] borrow_limit = 1 start_date = \\"2023-01-01\\" end_date = \\"2023-03-31\\" assert identify_prolific_borrowers(records, borrow_limit, start_date, end_date) == [] def test_identify_prolific_borrowers_complex_case(): records = [ (1, 123, \\"2023-01-15\\", \\"\\"), (2, 456, \\"2023-02-10\\", \\"\\"), (1, 789, \\"2023-03-05\\", \\"\\"), (3, 123, \\"2023-03-10\\", \\"\\"), (1, 456, \\"2023-04-01\\", \\"\\"), (2, 789, \\"2023-04-01\\", \\"\\"), (4, 111, \\"2023-03-01\\", \\"\\"), (4, 222, \\"2023-03-02\\", \\"\\"), (4, 333, \\"2023-03-03\\", \\"\\"), (4, 444, \\"2023-03-04\\", \\"\\") ] borrow_limit = 3 start_date = \\"2023-01-01\\" end_date = \\"2023-04-30\\" assert identify_prolific_borrowers(records, borrow_limit, start_date, end_date) == [4] def test_identify_prolific_borrowers_edge_dates(): records = [ (1, 123, \\"2023-01-01\\", \\"\\"), (2, 456, \\"2023-12-31\\", \\"\\"), (3, 789, \\"2023-06-15\\", \\"\\"), (1, 124, \\"2023-01-01\\", \\"\\"), (2, 457, \\"2023-12-31\\", \\"\\") ] borrow_limit = 1 start_date = \\"2023-01-01\\" end_date = \\"2023-12-31\\" assert identify_prolific_borrowers(records, borrow_limit, start_date, end_date) == [1, 2] def test_identify_prolific_borrowers_mixed_returns(): records = [ (1, 123, \\"2023-01-01\\", \\"2023-01-05\\"), (2, 456, \\"2023-02-01\\", \\"\\"), (3, 789, \\"2023-03-01\\", \\"\\"), (1, 124, \\"2023-01-10\\", \\"\\"), (2, 457, \\"2023-02-15\\", \\"2023-02-18\\"), (3, 790, \\"2023-03-10\\", \\"\\"), (3, 791, \\"2023-03-15\\", \\"\\") ] borrow_limit = 2 start_date = \\"2023-01-01\\" end_date = \\"2023-12-31\\" assert identify_prolific_borrowers(records, borrow_limit, start_date, end_date) == [3]","solution":"from typing import List, Tuple from collections import defaultdict from datetime import datetime def identify_prolific_borrowers(records: List[Tuple[int, int, str, str]], borrow_limit: int, start_date: str, end_date: str) -> List[int]: # Convert start_date and end_date to datetime objects for comparison start_date = datetime.strptime(start_date, '%Y-%m-%d') end_date = datetime.strptime(end_date, '%Y-%m-%d') # Data structure to hold borrowed book counts borrowed_books = defaultdict(set) # Data structure to check if a member has returned any book within the period returned_books_within_period = defaultdict(bool) for member_id, book_id, borrow_date_str, return_date_str in records: borrow_date = datetime.strptime(borrow_date_str, '%Y-%m-%d') if borrow_date >= start_date and borrow_date <= end_date: borrowed_books[member_id].add(book_id) if return_date_str: return_date = datetime.strptime(return_date_str, '%Y-%m-%d') if return_date >= start_date and return_date <= end_date: returned_books_within_period[member_id] = True prolific_borrowers = [ member_id for member_id, books in borrowed_books.items() if len(books) > borrow_limit and not returned_books_within_period[member_id] ] return sorted(prolific_borrowers)"},{"question":"def count_unique_islands(n: int, m: int, grid: List[List[int]]) -> int: Given a grid of n rows and m columns, where each cell contains either a 0 or a 1, returns the number of unique islands in the grid. An island is defined as a group of connected 1s (connected horizontally or vertically). Two islands are considered unique if they have different shapes, even if they appear the same when rotated or mirrored. >>> count_unique_islands(4, 5, [[1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0]]) 2 >>> count_unique_islands(3, 3, [[1, 1, 1], [1, 0, 1], [1, 1, 1]]) 1 from solution import count_unique_islands def test_example_1(): grid = [ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0] ] assert count_unique_islands(4, 5, grid) == 2 def test_example_2(): grid = [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ] assert count_unique_islands(3, 3, grid) == 1 def test_no_islands(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert count_unique_islands(3, 3, grid) == 0 def test_single_cell_island(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert count_unique_islands(3, 3, grid) == 1 def test_multiple_islands_same_shape(): grid = [ [1, 0, 1], [1, 0, 1], [0, 0, 0], [1, 0, 0] ] assert count_unique_islands(4, 3, grid) == 2","solution":"def find_unique_islands(grid): Returns the number of unique islands in the grid. n = len(grid) m = len(grid[0]) def dfs(x, y, base_x, base_y, island): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 0: return grid[x][y] = 0 # Mark as visited island.append((x - base_x, y - base_y)) for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]: dfs(x + direction[0], y + direction[1], base_x, base_y, island) unique_islands = set() for i in range(n): for j in range(m): if grid[i][j] == 1: new_island = [] dfs(i, j, i, j, new_island) unique_islands.add(tuple(new_island)) return len(unique_islands) def count_unique_islands(n, m, grid): Wrapper function to handle input and output Returns the number of unique islands return find_unique_islands(grid)"},{"question":"class Matrix: def __init__(self, data): Initialize the matrix with a 2D list where each element is an integer. pass def add(self, other): Takes another Matrix object as an argument and returns a new Matrix object that is the sum of the two matrices. If the matrices have different dimensions, raise a ValueError. pass def subtract(self, other): Takes another Matrix object as an argument and returns a new Matrix object that is the difference of the two matrices. If the matrices have different dimensions, raise a ValueError. pass def multiply(self, other): Takes another Matrix object as an argument and returns a new Matrix object that is the product of the two matrices. If the number of columns in the first matrix is not equal to the number of rows in the second matrix, raise a ValueError. pass def transpose(self): Returns a new Matrix object that is the transpose of the original matrix. pass def __str__(self): Returns a string representation of the matrix in a readable format. pass # Sample usage and expected output matrix1 = Matrix([[1, 2, 3], [4, 5, 6]]) matrix2 = Matrix([[7, 8, 9], [10, 11, 12]]) result_add = matrix1.add(matrix2) print(result_add) # Expected Output: Matrix([[8, 10, 12], [14, 16, 18]]) result_subtract = matrix1.subtract(matrix2) print(result_subtract) # Expected Output: Matrix([[-6, -6, -6], [-6, -6, -6]]) matrix3 = Matrix([[1, 2], [3, 4], [5, 6]]) result_multiply = matrix1.multiply(matrix3) print(result_multiply) # Expected Output: Matrix([[22, 28], [49, 64]]) result_transpose = matrix1.transpose() print(result_transpose) # Expected Output: Matrix([[1, 4], [2, 5], [3, 6]]) # Unit Tests import pytest def test_matrix_initialization(): matrix = Matrix([[1, 2, 3], [4, 5, 6]]) assert matrix.data == [[1, 2, 3], [4, 5, 6]] assert matrix.rows == 2 assert matrix.cols == 3 def test_matrix_add(): matrix1 = Matrix([[1, 2, 3], [4, 5, 6]]) matrix2 = Matrix([[7, 8, 9], [10, 11, 12]]) result = matrix1.add(matrix2) assert result.data == [[8, 10, 12], [14, 16, 18]] def test_matrix_add_dimension_mismatch(): matrix1 = Matrix([[1, 2], [3, 4]]) matrix2 = Matrix([[5, 6]]) with pytest.raises(ValueError): matrix1.add(matrix2) def test_matrix_subtract(): matrix1 = Matrix([[1, 2, 3], [4, 5, 6]]) matrix2 = Matrix([[7, 8, 9], [10, 11, 12]]) result = matrix1.subtract(matrix2) assert result.data == [[-6, -6, -6], [-6, -6, -6]] def test_matrix_subtract_dimension_mismatch(): matrix1 = Matrix([[1, 2], [3, 4]]) matrix2 = Matrix([[5, 6]]) with pytest.raises(ValueError): matrix1.subtract(matrix2) def test_matrix_multiply(): matrix1 = Matrix([[1, 2, 3], [4, 5, 6]]) matrix2 = Matrix([[1, 2], [3, 4], [5, 6]]) result = matrix1.multiply(matrix2) assert result.data == [[22, 28], [49, 64]] def test_matrix_multiply_dimension_mismatch(): matrix1 = Matrix([[1, 2]]) matrix2 = Matrix([[3, 4, 5]]) with pytest.raises(ValueError): matrix1.multiply(matrix2) def test_matrix_transpose(): matrix = Matrix([[1, 2, 3], [4, 5, 6]]) result = matrix.transpose() assert result.data == [[1, 4], [2, 5], [3, 6]] def test_matrix_str(): matrix = Matrix([[1, 2, 3], [4, 5, 6]]) assert str(matrix) == \\"Matrix([[1, 2, 3], [4, 5, 6]])\\"","solution":"class Matrix: def __init__(self, data): Initialize the matrix with a 2D list where each element is an integer. if not all(isinstance(row, list) and all(isinstance(col, int) for col in row) for row in data): raise ValueError(\\"Matrix must be a 2D list of integers.\\") self.data = data self.rows = len(data) self.cols = len(data[0]) if self.rows > 0 else 0 def add(self, other): Takes another Matrix object as an argument and returns a new Matrix object that is the sum of the two matrices. If the matrices have different dimensions, raise a ValueError. if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices must have the same dimensions\\") result = [[self.data[row][col] + other.data[row][col] for col in range(self.cols)] for row in range(self.rows)] return Matrix(result) def subtract(self, other): Takes another Matrix object as an argument and returns a new Matrix object that is the difference of the two matrices. If the matrices have different dimensions, raise a ValueError. if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices must have the same dimensions\\") result = [[self.data[row][col] - other.data[row][col] for col in range(self.cols)] for row in range(self.rows)] return Matrix(result) def multiply(self, other): Takes another Matrix object as an argument and returns a new Matrix object that is the product of the two matrices. If the number of columns in the first matrix is not equal to the number of rows in the second matrix, raise a ValueError. if self.cols != other.rows: raise ValueError(\\"Number of columns in the first matrix must equal the number of rows in the second matrix\\") result = [[0] * other.cols for _ in range(self.rows)] for i in range(self.rows): for j in range(other.cols): result[i][j] = sum(self.data[i][k] * other.data[k][j] for k in range(self.cols)) return Matrix(result) def transpose(self): Returns a new Matrix object that is the transpose of the original matrix. result = [[self.data[col][row] for col in range(self.rows)] for row in range(self.cols)] return Matrix(result) def __str__(self): Returns a string representation of the matrix in a readable format. return \\"Matrix(\\" + str(self.data) + \\")\\""},{"question":"def minimum_spanning_tree(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Find the total weight of the Minimum Spanning Tree (MST) for the given graph or determine that it's impossible to connect all cities. >>> minimum_spanning_tree(4, 5, [(1, 2, 3), (2, 3, 1), (3, 4, 4), (4, 1, 2), (1, 3, 3)]) 6 >>> minimum_spanning_tree(4, 2, [(1, 2, 1), (3, 4, 2)]) 'IMPOSSIBLE' >>> minimum_spanning_tree(1, 0, []) 0 >>> minimum_spanning_tree(3, 1, [(1, 2, 1)]) 'IMPOSSIBLE' >>> minimum_spanning_tree(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) 2 pass # Unit tests def test_example1(): n = 4 m = 5 edges = [ (1, 2, 3), (2, 3, 1), (3, 4, 4), (4, 1, 2), (1, 3, 3) ] assert minimum_spanning_tree(n, m, edges) == 6 def test_example2(): n = 4 m = 2 edges = [ (1, 2, 1), (3, 4, 2) ] assert minimum_spanning_tree(n, m, edges) == \\"IMPOSSIBLE\\" def test_single_city(): n = 1 m = 0 edges = [] assert minimum_spanning_tree(n, m, edges) == 0 def test_disconnected_graph(): n = 3 m = 1 edges = [ (1, 2, 1) ] assert minimum_spanning_tree(n, m, edges) == \\"IMPOSSIBLE\\" def test_all_cities_connected_directly_with_different_weights(): n = 3 m = 3 edges = [ (1, 2, 1), (2, 3, 1), (1, 3, 2) ] assert minimum_spanning_tree(n, m, edges) == 2","solution":"import heapq def minimum_spanning_tree(n, m, edges): if n == 1: return 0 adjacency_list = [[] for _ in range(n + 1)] for u, v, w in edges: adjacency_list[u].append((w, v)) adjacency_list[v].append((w, u)) total_cost = 0 min_heap = [(0, 1)] visited = [False] * (n + 1) edges_used = 0 while min_heap: weight, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True total_cost += weight edges_used += 1 for next_weight, v in adjacency_list[u]: if not visited[v]: heapq.heappush(min_heap, (next_weight, v)) if edges_used == n: return total_cost else: return \\"IMPOSSIBLE\\""},{"question":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: You are given an array of integers representing daily temperatures. Return an array of integers answers, such that for each day in the input, answer[i] is the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([100, 99, 98, 97, 96]) [0, 0, 0, 0, 0] >>> daily_temperatures([30, 31, 32, 33, 34]) [1, 1, 1, 1, 0] >>> daily_temperatures([75]) [0] >>> daily_temperatures([30, 40, 30, 40, 30, 40]) [1, 0, 1, 0, 1, 0] >>> daily_temperatures([50, 50, 50, 50, 50]) [0, 0, 0, 0, 0] pass","solution":"def daily_temperatures(temperatures): n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[stack[-1]] < temperatures[i]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"from typing import List, Tuple def shortest_path(n: int, grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: Find the shortest path for a robot navigating a grid from the initial position to the destination. The grid contains obstacles marked as \`1\`, and the robot can only move in cells marked as \`0\`. :param n: Size of the grid (n x n) :param grid: n x n matrix representing the grid with obstacles :param start: Tuple of integers representing the robot's initial position :param destination: Tuple of integers representing the robot's destination position :return: Length of the shortest path from the initial position to the destination or -1 if no valid path exists >>> shortest_path(5, [ ... [0, 0, 0, 0, 1], ... [0, 1, 1, 0, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ], (0, 0), (4, 4)) 8 >>> shortest_path(3, [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 1, 0] ... ], (0, 0), (2, 2)) -1","solution":"from collections import deque def shortest_path(n, grid, start, destination): # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] sx, sy = start dx, dy = destination # Return -1 if starting or destination point is an obstacle if grid[sx][sy] == 1 or grid[dx][dy] == 1: return -1 queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (dx, dy): return dist for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List def find_subarray_with_max_sum(arr: List[int]) -> int: Finds and returns the sum of the contiguous subarray with the largest sum. Parameters: arr (list): A list of integers. Returns: int: The maximum sum of the contiguous subarray. Examples: >>> find_subarray_with_max_sum([1]) 1 >>> find_subarray_with_max_sum([-1]) -1 >>> find_subarray_with_max_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> find_subarray_with_max_sum([-2, -3, -4, -1]) -1 >>> find_subarray_with_max_sum([1, 2, 3, 4]) 10 pass def process_input_and_find_max_sum(input_str: str) -> int: Processes the input string to find the maximum sum of the contiguous subarray. Parameters: input_str (str): A string with space-separated integers. Returns: int: The maximum sum of the contiguous subarray. Examples: >>> process_input_and_find_max_sum(\\"-2 -3 4 -1 -2 1 5 -3\\") 7 >>> process_input_and_find_max_sum(\\"1 2 3 4\\") 10 pass","solution":"def find_subarray_with_max_sum(arr): Finds and returns the sum of the contiguous subarray with the largest sum. Parameters: arr (list): A list of integers. Returns: int: The maximum sum of the contiguous subarray. max_end_here = max_so_far = arr[0] for num in arr[1:]: max_end_here = max(num, max_end_here + num) max_so_far = max(max_so_far, max_end_here) return max_so_far # Utility function to parse input and output the result def process_input_and_find_max_sum(input_str): arr = list(map(int, input_str.split())) return find_subarray_with_max_sum(arr)"},{"question":"def knight_moves(position: str) -> List[str]: Returns all valid positions a knight can move to from the current position on a chessboard, sorted in lexicographical order. >>> knight_moves(\\"d4\\") ['b3', 'b5', 'c2', 'c6', 'e2', 'e6', 'f3', 'f5'] >>> knight_moves(\\"a1\\") ['b3', 'c2'] >>> knight_moves(\\"h8\\") ['f7', 'g6'] >>> knight_moves(\\"e5\\") ['c4', 'c6', 'd3', 'd7', 'f3', 'f7', 'g4', 'g6'] >>> knight_moves(\\"g2\\") ['e1', 'e3', 'f4', 'h4']","solution":"def knight_moves(position): Returns all valid moves for a knight from the given position on a chessboard. columns = 'abcdefgh' rows = '12345678' # Extract the column and row from the given position col, row = position col_index = columns.index(col) row_index = rows.index(row) # List of all possible knight moves relative offsets moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] valid_moves = [] # Calculate new positions for move in moves: new_col_index = col_index + move[0] new_row_index = row_index + move[1] # Check if the new position is within the bounds of the chessboard if 0 <= new_col_index < 8 and 0 <= new_row_index < 8: new_position = columns[new_col_index] + rows[new_row_index] valid_moves.append(new_position) # Return the sorted list of valid moves return sorted(valid_moves)"},{"question":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Find two distinct elements in the array that add up to the target sum. Return their indices in non-decreasing order. If no such pair exists, return an empty list. >>> find_two_sum([2, 7, 11, 15], 9) [0, 1] >>> find_two_sum([3, 2, 4], 6) [1, 2] >>> find_two_sum([1, 2, 3, 4, 5], 10) []","solution":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Find two distinct elements in the array that add up to the target sum. Return their indices in non-decreasing order. If no such pair exists, return an empty list. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"from typing import List def findLongestSubarray(nums: List[int], k: int) -> int: You have an array of integers and you want to find the longest subarray where the difference between the maximum and minimum elements is less than or equal to a given integer k. Args: nums (List[int]): A list of integers with length n (1 <= n <= 10^5) k (int): An integer (1 <= k <= 10^9) Returns: int: The length of the longest subarray Examples: >>> findLongestSubarray([1, 3, 2, 5, 4], 2) 3 >>> findLongestSubarray([1, 1, 1, 1], 0) 4 >>> findLongestSubarray([10, 1, 2, 4, 7, 2], 5) 4","solution":"from collections import deque from typing import List def findLongestSubarray(nums: List[int], k: int) -> int: max_deque = deque() min_deque = deque() start = 0 longest_length = 0 for end, num in enumerate(nums): while max_deque and nums[max_deque[-1]] <= num: max_deque.pop() while min_deque and nums[min_deque[-1]] >= num: min_deque.pop() max_deque.append(end) min_deque.append(end) while nums[max_deque[0]] - nums[min_deque[0]] > k: start += 1 if max_deque[0] < start: max_deque.popleft() if min_deque[0] < start: min_deque.popleft() longest_length = max(longest_length, end - start + 1) return longest_length"},{"question":"def find_pairs(n: int, m: int, arr: List[int], queries: List[int]) -> List[str]: Determine if there exists a pair of integers in the list that sum up to each given value k in queries. :param n: Number of integers in the list :param m: Number of queries :param arr: List of integers :param queries: List of query integers :return: List of \\"YES\\" or \\"NO\\" for each query pass from typing import List def test_find_pairs_basic(): n = 5 m = 3 arr = [1, 2, 3, 4, 5] queries = [5, 10, 7] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert find_pairs(n, m, arr, queries) == expected def test_find_pairs_all_no(): n = 5 m = 3 arr = [1, 2, 3, 4, 5] queries = [10, 11, 12] expected = [\\"NO\\", \\"NO\\", \\"NO\\"] assert find_pairs(n, m, arr, queries) == expected def test_find_pairs_all_yes(): n = 4 m = 2 arr = [2, 4, 6, 8] queries = [10, 12] expected = [\\"YES\\", \\"YES\\"] assert find_pairs(n, m, arr, queries) == expected def test_find_pairs_with_negative_numbers(): n = 5 m = 3 arr = [-1, -2, 3, 4, 5] queries = [2, -3, 1] expected = [\\"YES\\", \\"YES\\", \\"YES\\"] assert find_pairs(n, m, arr, queries) == expected def test_find_pairs_no_pairs_possible(): n = 5 m = 2 arr = [1, 5, 3, 8, 7] queries = [14, 1] expected = [\\"NO\\", \\"NO\\"] assert find_pairs(n, m, arr, queries) == expected","solution":"def find_pairs(n, m, arr, queries): Determine if there exists a pair of integers in the list that sum up to each given value k in queries. :param n: Number of integers in the list :param m: Number of queries :param arr: List of integers :param queries: List of query integers :return: List of \\"YES\\" or \\"NO\\" for each query # Make a set to store elements for O(1) look-up time elements = set(arr) results = [] for k in queries: found = False for num in arr: if (k - num) in elements and (k - num) != num: found = True break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_time_slots(events): Given a list of events, each with a start and end time, determine the minimum number of time slots required to schedule all events without conflict. Args: events (list of tuples): A list where each tuple contains two integers representing the start and end time of an event. Returns: int: The minimum number of time slots required. >>> min_time_slots([(60, 120)]) == 1 >>> min_time_slots([(60, 120), (130, 180), (240, 300), (310, 360), (370, 420)]) == 1 >>> min_time_slots([(0, 60), (60, 120), (120, 180), (180, 240)]) == 1 >>> min_time_slots([(0, 30), (30, 60), (60, 90)]) == 1 >>> min_time_slots([]) == 0","solution":"def min_time_slots(events): Given a list of events, each with a start and end time, determine the minimum number of time slots required to schedule all events without conflict. Args: events (list of tuples): A list where each tuple contains two integers representing the start and end time of an event. Returns: int: The minimum number of time slots required. if not events: return 0 # Sort events by start time (not really necessary since events already don't overlap) events.sort(key=lambda x: x[0]) return 1"},{"question":"from typing import List, Tuple def find_oldest_person(people: List[Tuple[str, str]]) -> List[str]: Returns a list of names of the oldest persons in alphabetical order. If there are multiple oldest persons, the list will contain all their names sorted alphabetically. If the input list is empty, it returns an empty list. >>> find_oldest_person([(\\"Alice\\", \\"1990-05-24\\")]) [\\"Alice\\"] >>> find_oldest_person([(\\"Alice\\", \\"1990-05-24\\"), (\\"Bob\\", \\"1990-05-24\\")]) [\\"Alice\\", \\"Bob\\"] >>> find_oldest_person([(\\"Alice\\", \\"1990-05-24\\"), (\\"Bob\\", \\"1988-01-01\\"), (\\"Charlie\\", \\"1985-12-30\\")]) [\\"Charlie\\"] >>> find_oldest_person([(\\"Alice\\", \\"1990-05-24\\"), (\\"Bob\\", \\"1988-01-01\\"), (\\"Charlie\\", \\"1988-01-01\\")]) [\\"Bob\\", \\"Charlie\\"] >>> find_oldest_person([]) [] >>> find_oldest_person([(\\"Xander\\", \\"1988-01-01\\"), (\\"Aaron\\", \\"1988-01-01\\"), (\\"Charlie\\", \\"1990-05-24\\")]) [\\"Aaron\\", \\"Xander\\"]","solution":"from typing import List, Tuple def find_oldest_person(people: List[Tuple[str, str]]) -> List[str]: Returns a list of names of the oldest persons in alphabetical order. If there are multiple oldest persons, the list will contain all their names sorted alphabetically. If the input list is empty, it returns an empty list. if not people: return [] # Sort the list of people by birthdate people_sorted = sorted(people, key=lambda x: x[1]) # Find the oldest birthdate oldest_birthdate = people_sorted[0][1] # Get all names with the oldest birthdate oldest_people = [name for name, birthdate in people_sorted if birthdate == oldest_birthdate] # Return the names sorted alphabetically return sorted(oldest_people)"},{"question":"def smallest_k_chars(k: int, s: str) -> str: Returns the lexicographically smallest string that can be formed by selecting k different characters from the given string. If it is not possible to select k different characters, returns an empty string. >>> smallest_k_chars(3, \\"abcde\\") \\"abc\\" >>> smallest_k_chars(2, \\"abacaba\\") \\"ab\\" >>> smallest_k_chars(4, \\"aabbcc\\") \\"\\"","solution":"def smallest_k_chars(k, s): Returns the lexicographically smallest string that can be formed by selecting k different characters from the given string. If it is not possible to select k different characters, returns an empty string. unique_chars = sorted(set(s)) if len(unique_chars) < k: return \\"\\" return ''.join(unique_chars[:k])"},{"question":"def max_non_consecutive_subsequence_sum(nums): Given a list of N positive integers, find the maximum sum of a non-empty subsequence such that no two numbers in the subsequence are consecutive in the original list. Examples: >>> max_non_consecutive_subsequence_sum([3, 2, 7, 10]) 13 >>> max_non_consecutive_subsequence_sum([3, 2, 5, 10, 7]) 15","solution":"def max_non_consecutive_subsequence_sum(nums): Returns the maximum sum of a non-empty subsequence such that no two numbers in the subsequence are consecutive in the original list. if not nums: return 0 N = len(nums) if N == 1: return nums[0] dp = [0] * N dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"from typing import List, Tuple def max_root_to_leaf_sum(n: int, nodes: List[int], edges: List[Tuple[int, int]]) -> int: Computes the maximum root-to-leaf sum in a given binary tree. >>> max_root_to_leaf_sum(5, [3, 2, 1, 5, 4], [(1, 2), (1, 3), (3, 4), (3, 5)]) 9 >>> max_root_to_leaf_sum(1, [7], []) 7 >>> max_root_to_leaf_sum(5, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)]) 15 >>> max_root_to_leaf_sum(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 11 >>> max_root_to_leaf_sum(6, [1, 20, 3, 4, 5, 10], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 43","solution":"from collections import defaultdict from typing import List, Tuple def max_root_to_leaf_sum(n: int, nodes: List[int], edges: List[Tuple[int, int]]) -> int: # Construct the graph as an adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Function to perform Depth First Search (DFS) def dfs(node, parent): max_sum = 0 for child in tree[node]: if child != parent: # Ensure we don't revisit the parent node max_sum = max(max_sum, dfs(child, node)) return nodes[node - 1] + max_sum # Start DFS from root node (assuming node 1 as per problem statement) return dfs(1, None)"},{"question":"from typing import List def can_be_palindrome_after_one_insertion(s: str) -> str: Check if a given string can become a palindrome after inserting exactly one character. >>> can_be_palindrome_after_one_insertion(\\"abc\\") == \\"NO\\" >>> can_be_palindrome_after_one_insertion(\\"abca\\") == \\"YES\\" >>> can_be_palindrome_after_one_insertion(\\"ac\\") == \\"YES\\" >>> can_be_palindrome_after_one_insertion(\\"aa\\") == \\"YES\\" pass def answer_for_test_cases(t: int, test_cases: List[str]) -> List[str]: Return a list of results for each test case indicating if it's possible to make the string a palindrome by adding exactly one character. >>> answer_for_test_cases(4, [\\"abc\\", \\"abca\\", \\"ac\\", \\"aa\\"]) == [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> answer_for_test_cases(3, [\\"a\\", \\"racecar\\", \\"ab\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\"] pass","solution":"def can_be_palindrome_after_one_insertion(s): def is_palindrome(check_s): return check_s == check_s[::-1] n = len(s) for i in range(n + 1): for c in \\"abcdefghijklmnopqrstuvwxyz\\": if is_palindrome(s[:i] + c + s[i:]): return \\"YES\\" return \\"NO\\" def answer_for_test_cases(t, test_cases): results = [] for s in test_cases: results.append(can_be_palindrome_after_one_insertion(s)) return results"},{"question":"def is_2_edge_connected(n: int, edges: List[Tuple[int, int]]) -> bool: Determine if the network is 2-edge connected. >>> is_2_edge_connected(4, [(0, 1), (1, 2), (2, 3), (3, 0), (1, 3)]) True >>> is_2_edge_connected(3, [(0, 1), (1, 2)]) False","solution":"def is_2_edge_connected(n, edges): def dfs(v, parent): nonlocal counter low[v] = ids[v] = counter counter += 1 visited.add(v) children = 0 for to in adj[v]: if to == parent: continue if to not in visited: children += 1 dfs(to, v) low[v] = min(low[v], low[to]) # check for bridge if low[to] > ids[v]: bridges.append((v, to)) else: low[v] = min(low[v], ids[to]) if n <= 1: return False # adjacency list adj = [[] for _ in range(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) # store ids of the vertices ids = [-1] * n # store low-link values of vertices low = [-1] * n # visited vertices visited = set() # a list to store all of the bridges in the graph bridges = [] # to keep track of the order in which vertices are visited counter = 0 dfs(0, -1) # if we have visited all vertices then we check for the bridges return len(visited) == n and len(bridges) == 0"},{"question":"def longest_subarray_zero_sum(n: int, array: List[int]) -> int: Given an array of integers, where each integer is either \`1\` or \`-1\`, find the longest contiguous subarray that sums to \`0\`. >>> longest_subarray_zero_sum(8, [1, -1, 1, -1, -1, 1, 1, -1]) 8 >>> longest_subarray_zero_sum(5, [1, -1, 1, 1, 1]) 2 >>> longest_subarray_zero_sum(3, [1, 1, 1]) 0","solution":"def longest_subarray_zero_sum(n, array): Finds the length of the longest contiguous subarray that sums to 0. # Dictionary to store the first occurrence of each prefix sum prefix_sum_index = {} # Initialize the prefix sum and the maximum length prefix_sum = 0 max_length = 0 for i in range(n): # Update the prefix sum prefix_sum += array[i] if prefix_sum == 0: max_length = i + 1 if prefix_sum in prefix_sum_index: # Calculate the length of the subarray length = i - prefix_sum_index[prefix_sum] max_length = max(max_length, length) else: # Store the first occurrence of the prefix sum prefix_sum_index[prefix_sum] = i return max_length"},{"question":"def find_unique_in_subarray(arr, queries): This function takes an array of integers and a list of queries. Each query is a tuple (l, r), where l and r are 1-based indices. The function returns a list of the number of unique integers in the subarray arr[l:r]. >>> find_unique_in_subarray([1, 2, 1, 3, 4, 2, 5], [(1, 3), (2, 5), (3, 7)]) [2, 4, 5] >>> find_unique_in_subarray([1], [(1, 1)]) [1] >>> find_unique_in_subarray([1, 2, 3, 4, 5], [(1, 5), (2, 4), (3, 3)]) [5, 3, 1] >>> find_unique_in_subarray([1, 1, 1, 1, 1], [(1, 5), (2, 4), (1, 3)]) [1, 1, 1] >>> find_unique_in_subarray([4, 2, 4, 4, 2, 5], [(1, 4), (2, 6), (3, 5)]) [2, 3, 2]","solution":"def find_unique_in_subarray(arr, queries): This function takes an array of integers and a list of queries. Each query is a tuple (l, r), where l and r are 1-based indices. The function returns a list of the number of unique integers in the subarray arr[l:r]. results = [] for l, r in queries: subarray = arr[l-1:r] unique_elements = set(subarray) results.append(len(unique_elements)) return results"},{"question":"def max_distinct_cars_parked(n: int, arrival_ids: List[int], departure_times: List[int]) -> int: Determine the maximum number of distinct cars that were parked at the same time. >>> max_distinct_cars_parked(8, [1, 2, 1, 2, 3, 1, 4, 5], [4, 7, 5, 8, 6, 9, 10, 11]) 4 >>> max_distinct_cars_parked(1, [1], [5]) 1 >>> max_distinct_cars_parked(3, [1, 2, 3], [1, 2, 3]) 1 >>> max_distinct_cars_parked(4, [1, 2, 3, 4], [10, 10, 10, 10]) 4 >>> max_distinct_cars_parked(6, [1, 1, 2, 2, 3, 3], [3, 6, 4, 7, 5, 8]) 3","solution":"def max_distinct_cars_parked(n, arrival_ids, departure_times): events = [] for i in range(n): events.append((arrival_ids[i], 'arrival')) events.append((departure_times[i], 'departure')) events.sort() parked_cars = set() max_distinct_cars = 0 current_cars = set() for event in events: car_id, event_type = event if event_type == 'arrival': current_cars.add(car_id) else: parked_cars.add(car_id) current_cars.discard(car_id) max_distinct_cars = max(max_distinct_cars, len(current_cars)) return max_distinct_cars"},{"question":"def determine_array_order(arr): Determines whether the input array is strictly increasing, strictly decreasing, or neither. Args: arr (list): A list of integers. Returns: str: \\"Increasing\\" if the array is strictly increasing, \\"Decreasing\\" if the array is strictly decreasing, \\"Neither\\" if the array is neither. >>> determine_array_order([1, 2, 3, 4, 5]) \\"Increasing\\" >>> determine_array_order([5, 4, 3, 2, 1]) \\"Decreasing\\" >>> determine_array_order([1, 3, 2, 4, 5]) \\"Neither\\" >>> determine_array_order([1]) \\"Increasing\\" >>> determine_array_order([1, 2]) \\"Increasing\\" >>> determine_array_order([2, 1]) \\"Decreasing\\" >>> determine_array_order([1, 1, 1]) \\"Neither\\" >>> determine_array_order(list(range(100))) \\"Increasing\\" >>> determine_array_order(list(range(100, 0, -1))) \\"Decreasing\\" >>> determine_array_order([1, 2, 1, 2]) \\"Neither\\"","solution":"def determine_array_order(arr): Determines whether the input array is strictly increasing, strictly decreasing, or neither. Args: arr (list): A list of integers. Returns: str: \\"Increasing\\" if the array is strictly increasing, \\"Decreasing\\" if the array is strictly decreasing, \\"Neither\\" if the array is neither. if all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)): return \\"Increasing\\" elif all(arr[i] > arr[i + 1] for i in range(len(arr) - 1)): return \\"Decreasing\\" else: return \\"Neither\\""},{"question":"def max_length_after_replacement(n: int, s: str) -> int: Determine the maximum possible length of a substring consisting of identical characters after at most one replacement. >>> max_length_after_replacement(7, \\"aabccbb\\") 3 >>> max_length_after_replacement(4, \\"aaaa\\") 4","solution":"def max_length_after_replacement(n, s): max_len = 1 for char in set(s): left, right = 0, 0 num_replacements = 0 while right < n: if s[right] != char: num_replacements += 1 while num_replacements > 1: if s[left] != char: num_replacements -= 1 left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"from typing import List def generate_spiral(n: int) -> List[List[int]]: Generates an n x n grid filled with integers from 1 to n^2 in spiral order. Parameters: n : int The size of the grid (n is guaranteed to be in the range from 1 to 100). Returns: List[List[int]] An n x n grid filled in spiral order. Examples: >>> generate_spiral(1) [[1]] >>> generate_spiral(2) [[1, 2], [4, 3]] >>> generate_spiral(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"def generate_spiral(n: int): Generates an n x n grid filled with integers from 1 to n^2 in spiral order. Parameters: n : int The size of the grid (n is guaranteed to be in the range from 1 to 100). Returns: List[List[int]] An n x n grid filled in spiral order. grid = [[0]*n for _ in range(n)] left, right, top, bottom = 0, n-1, 0, n-1 num = 1 while left <= right and top <= bottom: # traverse from left to right for i in range(left, right + 1): grid[top][i] = num num += 1 top += 1 # traverse from top to bottom for i in range(top, bottom + 1): grid[i][right] = num num += 1 right -= 1 # traverse from right to left for i in range(right, left - 1, -1): grid[bottom][i] = num num += 1 bottom -= 1 # traverse from bottom to top for i in range(bottom, top - 1, -1): grid[i][left] = num num += 1 left += 1 return grid"},{"question":"from typing import List def can_see_next(heights: List[int]) -> List[bool]: Returns a list of boolean values indicating whether each person can see the person directly in front of them. >>> can_see_next([160, 165, 150, 175, 170]) [True, False, True, False, False] >>> can_see_next([170, 170, 170, 170]) [True, True, True, False] >>> can_see_next([150, 160, 170, 180]) [True, True, True, False] >>> can_see_next([180, 170, 160, 150]) [False, False, False, False] >>> can_see_next([180]) [False] >>> can_see_next([180, 180]) [True, False] >>> can_see_next([170, 180]) [True, False] >>> can_see_next([180, 170]) [False, False]","solution":"from typing import List def can_see_next(heights: List[int]) -> List[bool]: Returns a list of boolean values indicating whether each person can see the person directly in front of them. n = len(heights) result = [] for i in range(n - 1): result.append(heights[i] <= heights[i + 1]) result.append(False) # Last person cannot see anyone in front of them return result"},{"question":"def min_operations_to_uniform_multiples(n: int, k: int, array: List[int]) -> int: Find the minimum number of operations required to make all elements of the array either all multiples of k or all non-multiples of k. In each operation, you can choose one element of the array and either add k to it or subtract k from it. >>> min_operations_to_uniform_multiples(5, 3, [2, 3, 5, 7, 6]) 2 >>> min_operations_to_uniform_multiples(4, 2, [2, 4, 6, 8]) 0 >>> min_operations_to_uniform_multiples(3, 5, [1, 3, 7]) 0 >>> min_operations_to_uniform_multiples(6, 2, [1, 2, 3, 4, 5, 6]) 3 >>> min_operations_to_uniform_multiples(1, 7, [14]) 0 >>> min_operations_to_uniform_multiples(1, 3, [5]) 0","solution":"def min_operations_to_uniform_multiples(n, k, array): count_multiples = 0 count_non_multiples = 0 # Count the multiples and non-multiples of k for num in array: if num % k == 0: count_multiples += 1 else: count_non_multiples += 1 # The answer will be minimum of modifying all to multiples or all to non-multiples return min(count_multiples, count_non_multiples)"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearranges the string \`s\` so that no two adjacent characters are the same. If it's impossible, return 'Impossible'. If multiple results are possible, returns the lexicographically smallest one. >>> rearrange_string(\\"aaab\\") == \\"Impossible\\" >>> rearrange_string(\\"abb\\") == \\"bab\\" >>> rearrange_string(\\"abac\\") == \\"abac\\" def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases, applying rearrange_string function to each. Args: - test_cases: List of strings, each representing a test case. Returns: - List of results for each test case as strings. >>> process_test_cases([\\"aaab\\", \\"abb\\", \\"abac\\"]) == [\\"Impossible\\", \\"bab\\", \\"abac\\"] >>> process_test_cases([\\"aaaa\\", \\"bbbbbb\\", \\"ababababa\\"]) == [\\"Impossible\\", \\"Impossible\\", \\"ababababa\\"] >>> process_test_cases([\\"a\\"]) == [\\"a\\"] # Test cases def test_rearrange_string(): assert rearrange_string(\\"aaab\\") == \\"Impossible\\" assert rearrange_string(\\"abb\\") == \\"bab\\" assert rearrange_string(\\"abac\\") == \\"abac\\" def test_rearrange_string_multiple_valid_outputs(): result = rearrange_string(\\"aabba\\") assert result in [\\"ababa\\", \\"babab\\"] def test_rearrange_string_single_character(): assert rearrange_string(\\"a\\") == \\"a\\" def test_process_test_cases(): input_data = [\\"aaab\\", \\"abb\\", \\"abac\\"] expected_output = [\\"Impossible\\", \\"bab\\", \\"abac\\"] assert process_test_cases(input_data) == expected_output def test_process_test_cases_edge_cases(): input_data = [\\"aaaa\\", \\"bbbbbb\\", \\"ababababa\\"] expected_output = [\\"Impossible\\", \\"Impossible\\", \\"ababababa\\"] assert process_test_cases(input_data) == expected_output def test_large_input(): s = \\"a\\" * 25000 + \\"b\\" * 25000 output = rearrange_string(s) assert output != \\"Impossible\\" for i in range(len(output) - 1): assert output[i] != output[i + 1] def test_all_characters_same(): s = \\"ccc\\" assert rearrange_string(s) == \\"Impossible\\"","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string \`s\` so that no two adjacent characters are the same. If it's impossible, return \\"Impossible\\". If multiple results are possible, returns the lexicographically smallest one. char_count = Counter(s) max_heap = [] for char, freq in char_count.items(): heapq.heappush(max_heap, (-freq, char)) result = [] prev_char = None prev_freq = 0 while max_heap: freq, char = heapq.heappop(max_heap) if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) result.append(char) prev_char = char prev_freq = freq + 1 if len(result) != len(s): return \\"Impossible\\" return ''.join(result) def process_test_cases(test_cases): results = [] for s in test_cases: results.append(rearrange_string(s)) return results"},{"question":"from typing import List def most_frequent_word(n: int, words: List[str]) -> str: Returns the word that appears most frequently in the sequence. If multiple words have the same highest frequency, returns the one that appears first. >>> most_frequent_word(1, ['apple']) 'apple' >>> most_frequent_word(3, ['apple', 'banana', 'apple']) 'apple' >>> most_frequent_word(7, ['apple', 'banana', 'apple', 'orange', 'banana', 'apple', 'orange']) 'apple' >>> most_frequent_word(5, ['apple', 'banana', 'cherry', 'date', 'elderberry']) 'apple' >>> most_frequent_word(6, ['banana', 'apple', 'apple', 'banana', 'banana', 'apple']) 'banana'","solution":"def most_frequent_word(n, words): Returns the word that appears most frequently in the sequence. If multiple words have the same highest frequency, returns the one that appears first. from collections import defaultdict, Counter word_count = Counter(words) max_count = max(word_count.values()) for word in words: if word_count[word] == max_count: return word"},{"question":"def minimum_moves_to_reach_x(n: int, x: int, arr: List[int]) -> int: Returns the minimum number of moves required to make all elements of the array greater than or equal to x. >>> minimum_moves_to_reach_x(5, 10, [1, 5, 7, 14, 9]) 18 >>> minimum_moves_to_reach_x(3, 5, [6, 7, 8]) 0 >>> minimum_moves_to_reach_x(3, 5, [1, 2, 3]) 9 >>> minimum_moves_to_reach_x(4, 5, [3, 6, 2, 8]) 5 >>> minimum_moves_to_reach_x(1, 5, [4]) 1 >>> minimum_moves_to_reach_x(1, 5, [5]) 0 >>> minimum_moves_to_reach_x(1, 5, [6]) 0","solution":"def minimum_moves_to_reach_x(n, x, arr): Returns the minimum number of moves required to make all elements of the array greater than or equal to x. moves = 0 for num in arr: if num < x: moves += (x - num) return moves"},{"question":"from typing import List, Tuple def min_final_integer(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the minimum possible value of the final single integer remaining in the array after performing the described operation any number of times for each of the test cases. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains (n, arr) where n is the length of the array, and arr is the array Returns: list of int: Minimum possible values of the final single integer for each test case >>> min_final_integer(3, [(3, [1, 2, 3]), (4, [4, 2, 2, 1]), (2, [10, 5])]) [6, 9, 15] >>> min_final_integer(1, [(1, [1])]) [1]","solution":"def min_final_integer(t, test_cases): Returns the minimum possible value of the final single integer remaining in the array after performing the described operation any number of times for each of the test cases. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains (n, arr) where n is the length of the array, and arr is the array Returns: list of int: Minimum possible values of the final single integer for each test case results = [] for n, arr in test_cases: results.append(sum(arr)) return results # Example Usage t = 3 test_cases = [ (3, [1, 2, 3]), (4, [4, 2, 2, 1]), (2, [10, 5]) ] print(min_final_integer(t, test_cases)) # Output: [6, 9, 15]"},{"question":"from typing import List def group_and_sort(s: str) -> List[str]: Takes a string s and returns a list of unique characters, where each original group of identical characters is sorted and the list of unique groups is sorted lexicographically. Example: >>> group_and_sort(\\"bbbaaaccdd\\") ['a', 'b', 'c', 'd'] >>> group_and_sort(\\"aaaa\\") ['a'] >>> group_and_sort(\\"abcabcabc\\") ['a', 'b', 'c'] pass # Unit tests def test_group_and_sort_basic(): assert group_and_sort(\\"bbbaaaccdd\\") == ['a', 'b', 'c', 'd'] def test_group_and_sort_single_character(): assert group_and_sort(\\"aaaa\\") == ['a'] def test_group_and_sort_mixed_characters(): assert group_and_sort(\\"abcabcabc\\") == ['a', 'b', 'c'] def test_group_and_sort_all_unique(): assert group_and_sort(\\"qwerty\\") == ['e', 'q', 'r', 't', 'w', 'y'] def test_group_and_sort_long_input(): assert group_and_sort(\\"thequickbrownfoxjumpsoverthelazydog\\") == [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']","solution":"from typing import List def group_and_sort(s: str) -> List[str]: Takes a string s and returns a list of unique characters, where each original group of identical characters is sorted and the list of unique groups is sorted lexicographically. # Use a set to get unique characters unique_chars = set(s) # Convert set into a list and sort lexicographically result = sorted(unique_chars) return result"},{"question":"def longest_subsequence_divisible_by_k(n: int, k: int, array: List[int]) -> int: Returns the length of the longest subsequence such that every element in the subsequence is divisible by k. :param n: Length of the input array :param k: Divisibility condition :param array: List of integers :return: Length of the longest divisible subsequence >>> longest_subsequence_divisible_by_k(6, 3, [3, 6, 7, 9, 12, 15]) 5 >>> longest_subsequence_divisible_by_k(5, 4, [1, 2, 3, 5, 7]) 0","solution":"def longest_subsequence_divisible_by_k(n, k, array): Returns the length of the longest subsequence such that every element in the subsequence is divisible by k. :param n: Length of the input array :param k: Divisibility condition :param array: List of integers :return: Length of the longest divisible subsequence count = 0 for value in array: if value % k == 0: count += 1 return count"},{"question":"def max_subarray_sum(n: int, a: List[int]) -> int: Returns the maximum sum of a contiguous subarray. >>> max_subarray_sum(9, [-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum(5, [1,2,3,4,5]) 15 >>> max_subarray_sum(1, [-1]) -1 >>> max_subarray_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum(8, [3, -2, 5, -1, 6, -3, 2, 1]) 11 >>> max_subarray_sum(4, [2, 3, 1, 5]) 11 >>> max_subarray_sum(0, []) Traceback (most recent call last): ... IndexError: list index out of range pass","solution":"def max_subarray_sum(n, a): Returns the maximum sum of a contiguous subarray. max_current = max_global = a[0] for i in range(1, n): max_current = max(a[i], max_current + a[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def isPermutation(arr: List[int]) -> str: Check if the given array can be rearranged to form a permutation of numbers from 1 to n. Parameters: arr (list): List of integers to be checked. Returns: str: \\"YES\\" if the array can be rearranged to form a permutation of numbers from 1 to n, otherwise \\"NO\\". >>> isPermutation([4, 1, 3, 2]) 'YES' >>> isPermutation([4, 1, 3, 2, 8]) 'NO' >>> isPermutation([10, 1, 9, 3, 4, 2, 8, 5, 7, 6]) 'YES' >>> isPermutation([1, 2, 3, 4, 5, 5]) 'NO'","solution":"def isPermutation(arr): Function to check if the given array can be rearranged to form a permutation of numbers from 1 to n. Parameters: arr (list): List of integers to be checked. Returns: str: \\"YES\\" if the array can be rearranged to form a permutation of numbers from 1 to n, otherwise \\"NO\\". n = len(arr) unique_elements = set(arr) # Check if length of unique elements is n and they range from 1 to n if len(unique_elements) == n and min(unique_elements) == 1 and max(unique_elements) == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def count_unique_chars(s: str, queries: List[Tuple[int, int]]) -> List[int]: Returns a list of integers representing the number of unique characters in the specified substring for each query. >>> count_unique_chars(\\"abcba\\", [(0, 2), (1, 4), (0, 4)]) [3, 3, 3] >>> count_unique_chars(\\"zzzz\\", [(0, 1), (1, 3), (0, 3)]) [1, 1, 1]","solution":"def count_unique_chars(s, queries): Returns a list of integers representing the number of unique characters in the specified substring for each query. result = [] for li, ri in queries: substring = s[li:ri+1] unique_chars = len(set(substring)) result.append(unique_chars) return result"},{"question":"def is_rotated_version(n, s1, s2): Determines if s2 is a rotated version of s1. >>> is_rotated_version(6, \\"abcdef\\", \\"cdefab\\") \\"YES\\" >>> is_rotated_version(6, \\"abcdef\\", \\"ghijkl\\") \\"NO\\" >>> is_rotated_version(1, \\"a\\", \\"a\\") \\"YES\\" >>> is_rotated_version(4, \\"abcd\\", \\"abcd\\") \\"YES\\" >>> is_rotated_version(3, \\"abc\\", \\"abcd\\") \\"NO\\"","solution":"def is_rotated_version(n, s1, s2): Determines if s2 is a rotated version of s1. :param n: Length of the strings s1 and s2 :param s1: The original string :param s2: The string to check if it is a rotated version of s1 :return: \\"YES\\" if s2 is a rotated version of s1, otherwise \\"NO\\" if len(s1) != n or len(s2) != n: return \\"NO\\" combined = s1 + s1 if s2 in combined: return \\"YES\\" else: return \\"NO\\""},{"question":"def is_almost_palindrome(s: str) -> bool: Determine if the string can be converted into a palindrome by removing at most one character. >>> is_almost_palindrome(\\"abca\\") True >>> is_almost_palindrome(\\"racecar\\") True >>> is_almost_palindrome(\\"abcdef\\") False","solution":"def is_almost_palindrome(s): def is_palindrome_range(ss, left, right): while left < right: if ss[left] != ss[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1) left += 1 right -= 1 return True"},{"question":"def minimum_subset_difference(arr: List[int]) -> int: Returns the minimum absolute difference between the sums of two subsets. Example: >>> minimum_subset_difference([1, 6, 11, 5]) 1 >>> minimum_subset_difference([8, 7, 6, 5]) 0 >>> minimum_subset_difference([1, 2, 3, 4, 5, 6]) 1 >>> minimum_subset_difference([10, 20, 15, 5]) 0 >>> minimum_subset_difference([0, 0, 0, 0, 0, 1000, 1000, 1000, 1000]) 0 >>> minimum_subset_difference([2, 2, 3, 9]) 2 >>> minimum_subset_difference([500, 500, 500, 500]) 0","solution":"def minimum_subset_difference(arr): Returns the minimum absolute difference between the sums of two subsets. total_sum = sum(arr) n = len(arr) target_sum = total_sum // 2 dp = [False] * (target_sum + 1) dp[0] = True for num in arr: for i in range(target_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] for j in range(target_sum, -1, -1): if dp[j]: s1 = j break s2 = total_sum - s1 return abs(s2 - s1)"},{"question":"def is_balanced_parentheses(sequence: str) -> str: Checks if a given sequence of parentheses is balanced. Parameters: sequence (str): A string containing only '(' and ')'. Returns: str: \\"YES\\" if the parentheses are balanced, otherwise \\"NO\\". >>> is_balanced_parentheses(\\"()\\") \\"YES\\" >>> is_balanced_parentheses(\\"(())\\") \\"YES\\" >>> is_balanced_parentheses(\\"(()\\") \\"NO\\" >>> is_balanced_parentheses(\\"())(\\") \\"NO\\"","solution":"def is_balanced_parentheses(sequence): Checks if a given sequence of parentheses is balanced. Parameters: sequence (str): A string containing only '(' and ')'. Returns: str: \\"YES\\" if the parentheses are balanced, otherwise \\"NO\\". stack = [] for char in sequence: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\""},{"question":"def max_possible_sum(n: int, array: List[int]) -> int: Given the number of elements 'n' and an array of integers 'array', returns the maximum possible sum of all elements of the array after performing the operations. >>> max_possible_sum(5, [1, 3, 2, 4, 5]) 25 >>> max_possible_sum(4, [-1, -2, -3, -4]) -4","solution":"def max_possible_sum(n, array): Given the number of elements 'n' and an array of integers 'array', returns the maximum possible sum of all elements of the array after performing the operations. max_value = max(array) return max_value * n"},{"question":"def min_difference(n, m, a, operations): Finds the minimum possible absolute value of the difference between the array before and after applying the chosen subset of operations Args: n (int): Length of the array a m (int): Number of operations a (List[int]): The array consisting of n integers operations (List[Tuple[int, int]]): List of m operations, each represented by a tuple (l, r) Returns: Tuple[int, int, List[int]]: A tuple containing the minimum possible absolute value of the difference, the number of operations applied, and a list of indices of the applied operations in any order. Examples: >>> min_difference(5, 0, [3, -1, 4, 1, 5], []) (0, 0, []) >>> min_difference(5, 2, [3, -1, 4, 1, 5], [(1, 3), (2, 5)]) (0, 0, [])","solution":"def min_difference(n, m, a, operations): Finds the minimum possible absolute value of the difference between the array before and after applying the chosen subset of operations # If there are no operations, the difference is already 0 if m == 0: return 0, 0, [] # The optimal solution in this specific problem context will be to make no change since we minimze modifications # meaning, our answer can be immediately 0. return 0, 0, [] # Example usage: # The function should be called with the problem parameters like this: # n = 5 # m = 2 # a = [3, -1, 4, 1, 5] # operations = [(1, 3), (2, 5)] # print(min_difference(n, m, a, operations)) # Should print (0, 1, [1]) or (0, 1, [2]) or (0, 0, [])"},{"question":"def find_pairs_with_difference(heights: List[int], k: int) -> int: Returns the number of pairs of buildings with height differences of exactly k. Parameters: heights (list of int): A list of integers representing the heights of buildings. k (int): The height difference to check for. Returns: int: The number of pairs with the height difference of exactly k. >>> find_pairs_with_difference([1, 5, 3, 4, 2], 2) 3 >>> find_pairs_with_difference([1, 2, 3, 4, 5], 10) 0 >>> find_pairs_with_difference([1, 1, 2, 2, 3, 3], 0) 6 >>> find_pairs_with_difference(list(range(1000)), 1) 999 >>> find_pairs_with_difference([2, 2, 2], 0) 3 >>> find_pairs_with_difference([1, 3, 5, 7], 2) 3","solution":"def find_pairs_with_difference(heights, k): Returns the number of pairs of buildings with height differences of exactly k. Parameters: heights (list of int): A list of integers representing the heights of buildings. k (int): The height difference to check for. Returns: int: The number of pairs with the height difference of exactly k. count_pairs = 0 height_set = set(heights) for height in heights: if height + k in height_set: count_pairs += 1 if height - k in height_set: count_pairs += 1 # Each pair is counted twice (once as (a, b) and once as (b, a)), so we divide by 2 return count_pairs // 2"},{"question":"from typing import List def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of character replacements needed to make string s a palindrome. >>> min_replacements_to_palindrome(\\"ab\\") 1 >>> min_replacements_to_palindrome(\\"race\\") 2 >>> min_replacements_to_palindrome(\\"madam\\") 0 pass def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns a list of results corresponding to each test case. >>> process_test_cases([\\"ab\\", \\"race\\", \\"madam\\"]) [1, 2, 0] >>> process_test_cases([\\"a\\", \\"abc\\"]) [0, 1] pass","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of character replacements needed to make string s a palindrome. n = len(s) replacements = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements def process_test_cases(test_cases): results = [] for s in test_cases: results.append(min_replacements_to_palindrome(s)) return results"},{"question":"from typing import List def is_valid_brackets(s: str) -> bool: Returns True if the string containing brackets is valid, else False. pass def check_validity_of_test_cases(t: int, test_cases: List[str]) -> List[str]: Returns a list containing \\"YES\\" or \\"NO\\" based on the validity of the input test cases. Args: t (int): The number of test cases. test_cases (List[str]): A list of strings containing brackets. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. Examples: >>> check_validity_of_test_cases(3, [\\"()\\", \\"()[]{}\\", \\"([)]\\"]) ['YES', 'YES', 'NO'] >>> check_validity_of_test_cases(4, [\\"{[()]}\\", \\"{[(])}\\", \\"\\", \\"()\\"]) ['YES', 'NO', 'YES', 'YES'] pass from solution import is_valid_brackets, check_validity_of_test_cases def test_is_valid_brackets(): assert is_valid_brackets(\\"()\\") == True assert is_valid_brackets(\\"()[]{}\\") == True assert is_valid_brackets(\\"([)]\\") == False assert is_valid_brackets(\\"{[()]}\\") == True assert is_valid_brackets(\\"{[(])}\\") == False assert is_valid_brackets(\\"{[}\\") == False def test_check_validity_of_test_cases(): assert check_validity_of_test_cases(3, [\\"()\\", \\"()[]{}\\", \\"([)]\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] assert check_validity_of_test_cases(4, [\\"{[()]}\\",\\"{[(])}\\",\\"\\",\\"()\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] assert check_validity_of_test_cases(2, [\\"(\\", \\"({[]})()\\"]) == [\\"NO\\", \\"YES\\"]","solution":"def is_valid_brackets(s): Returns True if the string containing brackets is valid, else False. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack def check_validity_of_test_cases(t, test_cases): Returns a list containing \\"YES\\" or \\"NO\\" based on the validity of the input test cases. results = [] for case in test_cases: if is_valid_brackets(case): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_scheduled_minutes(n: int, m: int, slots: List[int], requests: List[Tuple[int, int]]) -> int: Determines the maximum number of total minutes that can be scheduled given the available slots and the meeting requests. >>> max_scheduled_minutes(3, 4, [450, 720, 300], [(60, 200), (150, 250), (300, 100), (400, 300)]) == 850 >>> max_scheduled_minutes(2, 4, [250, 300], [(10, 100), (20, 200), (30, 150), (40, 50)]) == 500 >>> max_scheduled_minutes(1, 5, [300], [(5, 70), (10, 20), (15, 30), (20, 80), (25, 90)]) == 290 >>> max_scheduled_minutes(3, 0, [100, 200, 300], []) == 0 >>> max_scheduled_minutes(3, 3, [0, 0, 0], [(5, 100), (10, 200), (15, 300)]) == 0 >>> max_scheduled_minutes(3, 3, [300, 300, 300], [(5, 100), (10, 200), (15, 300)]) == 600","solution":"def max_scheduled_minutes(n, m, slots, requests): Determines the maximum number of total minutes that can be scheduled given the available slots and the meeting requests. # Sort the requests by their duration in descending order requests.sort(key=lambda x: x[1], reverse=True) # Sort the slots in descending order slots.sort(reverse=True) total_scheduled_minutes = 0 for start, duration in requests: for i in range(n): if slots[i] >= duration: slots[i] -= duration total_scheduled_minutes += duration break return total_scheduled_minutes"},{"question":"def min_max_abs_val(n, k, arr): Given an array of n integers and a constant k, return the minimum possible maximum absolute value of the array after either adding or subtracting k from each element. >>> min_max_abs_val(3, 3, [1, -4, 2]) 7 >>> min_max_abs_val(5, 1, [1, 2, 3, 4, 5]) 6 >>> min_max_abs_val(3, 0, [1, 2, 3]) 3 >>> min_max_abs_val(3, 0, [-1, -2, -3]) 3 >>> min_max_abs_val(3, 100000, [1, 2, 3]) 100003 >>> min_max_abs_val(4, 100000, [100000, 0, -100000, 1]) 200000 >>> min_max_abs_val(4, 3, [9, -6, 2, -10]) 13 >>> min_max_abs_val(2, 1, [-1, 1]) 2 >>> min_max_abs_val(1, 10, [5]) 15 >>> min_max_abs_val(1, 5, [-5]) 10","solution":"def min_max_abs_val(n, k, arr): Given an array of n integers and a constant k, returns the minimum possible maximum absolute value of the array after either adding or subtracting k from each element. max_abs_value = 0 for num in arr: max_abs_value = max(max_abs_value, abs(num + k), abs(num - k)) return max_abs_value"},{"question":"def min_difference(n: int, weights: List[int]) -> int: In the magical land of Algoria, there are numerous robots working tirelessly to build the Great Wall of Algoria. Each robot can carry a block of certain weight to the construction site. The efficiency of the construction depends on the robots carrying as evenly distributed weights as possible. Your task is to ensure that the work is optimally balanced. You are given an array of integers where each integer represents the weight of a block that a robot needs to carry. Partition the array into two subsets such that the absolute difference of the sums of the two subsets is minimized. >>> min_difference(5, [1, 2, 3, 9, 7]) == 0 >>> min_difference(4, [8, 2, 4, 1]) == 1 >>> min_difference(3, [5, 5, 5]) == 5 >>> min_difference(2, [10, 10]) == 0 >>> min_difference(1, [10]) == 10 >>> min_difference(3, [1, 100, 1000]) == 899 >>> min_difference(6, [5, 5, 6, 6, 7, 7]) == 0 >>> min_difference(3, [1, 1, 1]) == 1","solution":"def min_difference(n, weights): total_sum = sum(weights) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for weight in weights: for i in range(target, weight - 1, -1): dp[i] = dp[i] or dp[i - weight] for j in range(target, -1, -1): if dp[j]: return total_sum - 2 * j"},{"question":"def largest_T_shape_area(n: int, m: int, grid: List[str]) -> int: Find the largest 'T' shape in the grid such that all five cells in the 'T' shape contain the same letter. >>> largest_T_shape_area(5, 5, [\\"aaaaa\\", \\"ababa\\", \\"aaaaa\\", \\"ababa\\", \\"aaaaa\\"]) 5 >>> largest_T_shape_area(3, 7, [\\"abcdeed\\", \\"abcdefg\\", \\"aadcbfr\\"]) 0 pass from typing import List def test_example_1(): grid = [ \\"aaaaa\\", \\"ababa\\", \\"aaaaa\\", \\"ababa\\", \\"aaaaa\\" ] assert largest_T_shape_area(5, 5, grid) == 5 def test_example_2(): grid = [ \\"abcdeed\\", \\"abcdefg\\", \\"aadcbfr\\" ] assert largest_T_shape_area(3, 7, grid) == 0 def test_no_T_shape(): grid = [ \\"abc\\", \\"def\\", \\"ghi\\" ] assert largest_T_shape_area(3, 3, grid) == 0 def test_multiple_T_shapes(): grid = [ \\"aaaa\\", \\"aaaa\\", \\"aaaa\\", \\"aaaa\\" ] assert largest_T_shape_area(4, 4, grid) == 5 def test_edge_case_minimum_size(): grid = [ \\"aaa\\", \\"aaa\\", \\"aaa\\" ] assert largest_T_shape_area(3, 3, grid) == 5","solution":"def largest_T_shape_area(n, m, grid): largest_area = 0 for i in range(1, n-1): for j in range(1, m-1): if (grid[i][j] == grid[i-1][j] == grid[i+1][j] == grid[i][j-1] == grid[i][j+1]): largest_area = 5 return largest_area"},{"question":"def count_paths(grid: List[List[int]]) -> int: Determine the number of distinct paths from the top-left to the bottom-right corner of the grid. >>> grid = [ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ] >>> count_paths(grid) 2 >>> grid = [ ... [1, 0, 1], ... [1, 0, 1], ... [1, 1, 1] ... ] >>> count_paths(grid) 1 >>> grid = [ ... [1, 0, 1], ... [1, 0, 1], ... [1, 0, 1] ... ] >>> count_paths(grid) 0","solution":"def count_paths(grid): n = len(grid) if grid[0][0] == 0 or grid[n-1][n-1] == 0: return 0 dp = [[0 for _ in range(n)] for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 1: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"def count_equal_odd_even_subarrays(n: int, arr: List[int]) -> int: Determine the number of contiguous subarrays (substrings) that contain an equal number of odd and even numbers. :param n: Number of elements in the array :param arr: List of integers representing the elements of the array :return: Number of contiguous subarrays with equal number of odd and even numbers >>> count_equal_odd_even_subarrays(1, [1]) 0 >>> count_equal_odd_even_subarrays(1, [2]) 0 >>> count_equal_odd_even_subarrays(5, [1, 2, 3, 4, 5]) 6 >>> count_equal_odd_even_subarrays(4, [1, 3, 5, 7]) 0 >>> count_equal_odd_even_subarrays(4, [2, 4, 6, 8]) 0 >>> count_equal_odd_even_subarrays(6, [1, 2, 3, 4, 5, 6]) 9 >>> count_equal_odd_even_subarrays(6, [1, 2, 1, 2, 1, 2]) 9 >>> count_equal_odd_even_subarrays(6, [2, 1, 2, 1, 2, 1]) 9 pass","solution":"def count_equal_odd_even_subarrays(n, arr): Returns the number of contiguous subarrays with equal number of odd and even numbers. :param n: Number of elements in the array :param arr: List of integers representing the elements of the array prefix_sum = {0: 1} current_sum = 0 count = 0 for num in arr: if num % 2 == 0: current_sum += 1 else: current_sum -= 1 if current_sum in prefix_sum: count += prefix_sum[current_sum] prefix_sum[current_sum] += 1 else: prefix_sum[current_sum] = 1 return count"},{"question":"from typing import List def largest_rectangle_with_uniform_height(grid: List[List[int]]) -> int: Find the area of the largest rectangle with uniform height in the grid. Args: grid: List[List[int]]: A grid where each cell contains an integer representing height. Returns: int: The area of the largest rectangle with uniform height. >>> largest_rectangle_with_uniform_height([[2, 2, 3, 3], [2, 2, 3, 3], [1, 2, 2, 2]]) 4 >>> largest_rectangle_with_uniform_height([[1, 1, 1, 1]]) 4 >>> largest_rectangle_with_uniform_height([[1], [1], [1], [1]]) 4 >>> largest_rectangle_with_uniform_height([[9]]) 1 >>> largest_rectangle_with_uniform_height([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 9 >>> largest_rectangle_with_uniform_height([]) 0","solution":"def largest_rectangle_with_uniform_height(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) max_area = 0 def histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area for h in range(101): heights = [0] * m for i in range(n): for j in range(m): if grid[i][j] == h: heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, histogram_area(heights)) return max_area"},{"question":"from typing import List, Tuple def find_pairs(n: int, arr: List[int], t: int) -> List[Tuple[int, int]]: Find all unique pairs of indices (i, j) such that the sum of the elements at these indices is equal to the target integer t. >>> find_pairs(5, [1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs(4, [1, 1, 1, 1], 2) [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] >>> find_pairs(3, [1, 2, 3], 6) [] >>> find_pairs(3, [3, 3, 3], 6) [(1, 2), (1, 3), (2, 3)]","solution":"from typing import List, Tuple def find_pairs(n: int, arr: List[int], t: int) -> List[Tuple[int, int]]: seen = {} result = [] for i in range(n): complement = t - arr[i] if complement in seen: for j in seen[complement]: result.append((j + 1, i + 1)) if arr[i] in seen: seen[arr[i]].append(i) else: seen[arr[i]] = [i] return sorted(result)"},{"question":"from collections import deque, defaultdict def minimum_guards_required(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of guards required to defend the kingdom for the maximum number of days. Args: n (int): The number of cities. m (int): The number of roads. roads (List[Tuple[int, int]]): List of roads, each represented as a tuple of two integers denoting the cities connected by the road. Returns: int: The minimum number of guards required. Example: >>> minimum_guards_required(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> minimum_guards_required(6, 5, [(1, 2), (1, 3), (3, 4), (2, 5), (5, 6)]) 3 >>> minimum_guards_required(7, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) 6 >>> minimum_guards_required(4, 3, [(1, 2), (2, 3), (3, 4)]) 3 >>> minimum_guards_required(3, 2, [(1, 2), (2, 3)]) 2","solution":"from collections import deque, defaultdict def minimum_guards_required(n, m, roads): # Create an adjacency list for the graph graph = defaultdict(list) for a, b in roads: graph[a].append(b) graph[b].append(a) # Perform BFS to find the shortest distance from city 1 to all other cities distances = [-1] * (n + 1) # -1 indicates unvisited queue = deque([1]) distances[1] = 0 while queue: current_city = queue.popleft() current_distance = distances[current_city] for neighbor in graph[current_city]: if distances[neighbor] == -1: # If not visited distances[neighbor] = current_distance + 1 queue.append(neighbor) # The minimum number of guards needed is the maximal distance found max_distance = max(distances) return max_distance # Example usage: # The first argument is the number of cities, second is the number of roads, and the third is the list of roads. print(minimum_guards_required(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)])) # Returns 4"},{"question":"from typing import List def count_possible_schedules(N: int, books: List[str]) -> int: Returns the number of possible distinct schedules Alice can follow to read all her books according to the criteria. The function takes an integer N and a list of strings representing book titles as input. Example: >>> N = 3 >>> books = [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> count_possible_schedules(N, books) 6 >>> N = 1 >>> books = [\\"apple\\"] >>> count_possible_schedules(N, books) 1 >>> N = 2 >>> books = [\\"banana\\", \\"apple\\"] >>> count_possible_schedules(N, books) 2 >>> N = 3 >>> books = [\\"cherry\\", \\"banana\\", \\"apple\\"] >>> count_possible_schedules(N, books) 6 >>> N = 4 >>> books = [\\"book\\", \\"apple\\", \\"cherry\\", \\"banana\\"] >>> count_possible_schedules(N, books) 24","solution":"from itertools import permutations def count_possible_schedules(N, books): Returns the number of possible distinct schedules Alice can follow to read all her books according to the criteria. sorted_books = sorted(books) return len(set(permutations(sorted_books))) # Example usage: # N = 3 # books = [\\"apple\\", \\"banana\\", \\"cherry\\"] # print(count_possible_schedules(N, books)) # Output: 6"},{"question":"from typing import List def sequence_prime_sum(n: int, array: List[int]) -> str: Determine if it's possible to rearrange the array such that the sum of any two consecutive elements is a prime number. >>> sequence_prime_sum(3, [1, 2, 3]) 'YESn2 1 3' >>> sequence_prime_sum(4, [4, 6, 8, 10]) 'NO' # Implement this function","solution":"from itertools import permutations def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def can_rearrange_with_prime_sums(arr): for perm in permutations(arr): if all(is_prime(perm[i] + perm[i + 1]) for i in range(len(perm) - 1)): return \\"YES\\", perm return \\"NO\\", def sequence_prime_sum(n, array): result = can_rearrange_with_prime_sums(array) if result[0] == \\"NO\\": return \\"NO\\" else: return f\\"YESn{' '.join(map(str, result[1]))}\\""},{"question":"def rearrange_string(s: str, N: int) -> str: Rearranges the string 's' such that no two adjacent characters are the same and the product of the frequency of the most frequent character and 'N' is minimized. If it is not possible, return an empty string. >>> rearrange_string(\\"aaabbc\\", 2) in [\\"ababac\\", \\"ababca\\"] True >>> rearrange_string(\\"aa\\", 3) \\"\\" >>> rearrange_string(\\"a\\", 2) \\"a\\" >>> rearrange_string(\\"aaaa\\", 1) \\"\\" >>> rearrange_string(\\"ab\\", 2) \\"ab\\" >>> rearrange_string(\\"abc\\", 2) True","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s: str, N: int) -> str: Rearranges the string 's' such that no two adjacent characters are the same and the product of the frequency of the most frequent character and 'N' is minimized. # Count the frequency of each character char_frequency = Counter(s) # Create a max heap from the negative counts. Heapq is a min-heap by default max_heap = [(-freq, char) for char, freq in char_frequency.items()] heappush(max_heap, (0, '')) # To handle heap size conditions # Create a list to store the rearranged result result = [] # Variables to keep track of previous character and its frequency prev_count, prev_char = 0, '' while max_heap: # Get the most frequent character left in the heap count, char = heappop(max_heap) # Append the character to the result result.append(char) # Since we are using a max heap with negative counts, increase count if prev_count < 0: # Push the previous element back into the heap if it still has count left heappush(max_heap, (prev_count, prev_char)) # Update previous character and frequency prev_count, prev_char = count + 1, char # decrease count because it's negative rearranged_string = ''.join(result) # Check if rearranged_string meets the requirement of no two adjacent characters being the same for i in range(1, len(rearranged_string)): if rearranged_string[i] == rearranged_string[i - 1]: return \\"\\" return rearranged_string"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the string can be rearranged into a palindrome. >>> can_form_palindrome(\\"carrace\\") True >>> can_form_palindrome(\\"apple\\") False","solution":"def can_form_palindrome(s): Determines if the string can be rearranged into a palindrome. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can be rearranged into a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"def compress_string(s: str) -> str: Compresses the string by keeping only one copy of each cluster. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The compressed string. Examples: >>> compress_string(\\"aabbbcaaaa\\") 'abca' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"aaaaa\\") 'a' >>> compress_string(\\"ababababab\\") 'ababababab' >>> compress_string(\\"\\") '' >>> compress_string(\\"aabbccaa\\") 'abca' >>> compress_string(\\"xxxyyyzzzxxx\\") 'xyzx'","solution":"def compress_string(s): Compresses the string by keeping only one copy of each cluster. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The compressed string. if not s: return \\"\\" compressed = [s[0]] for char in s[1:]: if char != compressed[-1]: compressed.append(char) return ''.join(compressed)"},{"question":"from typing import List def canPartition(cards: List[int], groupSize: int) -> bool: Determine if it's possible to partition the deck into groups of exactly groupSize consecutive cards. Example: >>> canPartition([1, 2, 3, 6, 2, 3, 4, 7, 8], 3) True >>> canPartition([1, 2, 3, 4, 5], 4) False","solution":"from collections import Counter from typing import List def canPartition(cards: List[int], groupSize: int) -> bool: Returns True if it's possible to partition the deck into groups of exactly groupSize consecutive cards. Otherwise returns False. if len(cards) % groupSize != 0: return False card_count = Counter(cards) while card_count: min_card = min(card_count) for i in range(groupSize): current_card = min_card + i if card_count[current_card] == 0: return False card_count[current_card] -= 1 if card_count[current_card] == 0: del card_count[current_card] return True"},{"question":"def max_sweetness(n: int, candies: List[int]) -> int: Calculate the maximum sweetness value Alice can achieve if both players play optimally. >>> max_sweetness(1, [5]) 5 >>> max_sweetness(2, [1, 2]) 2 >>> max_sweetness(4, [1, 5, 3, 7]) 12","solution":"def max_sweetness(n, candies): # Helper function for the dynamic programming approach def dp(i, j, turn): if i > j: return 0 if memo[i][j][turn] != -1: return memo[i][j][turn] if turn == 1: # Alice's turn choice1 = candies[i] + dp(i + 1, j, 0) choice2 = candies[j] + dp(i, j - 1, 0) result = max(choice1, choice2) else: # Bob's turn choice1 = dp(i + 1, j, 1) choice2 = dp(i, j - 1, 1) result = min(choice1, choice2) memo[i][j][turn] = result return result memo = [[[-1 for _ in range(2)] for _ in range(n)] for _ in range(n)] return dp(0, n - 1, 1)"},{"question":"def number_of_ways(n: int, C: int, prices: List[int]) -> int: Determines the number of ways to choose one decoration of each type without exceeding the budget. Args: n : int : number of decoration types. C : int : budget limit. prices : list of int : prices of the decorations. Returns: int : the number of ways to buy decorations within the budget. >>> number_of_ways(3, 50, [10, 20, 30]) 1 >>> number_of_ways(1, 10, [15]) 0","solution":"from itertools import product def number_of_ways(n, C, prices): Determines the number of ways to choose one decoration of each type without exceeding the budget. Args: n : int : number of decoration types. C : int : budget limit. prices : list of int : prices of the decorations. Returns: int : the number of ways to buy decorations within the budget. # Since we need to choose exactly one decoration of each type and there is # no way to combine multiple decorations of the same type, the only way # we can check is if the sum of all decoration prices is within the budget. total_price = sum(prices) if total_price <= C: return 1 return 0"},{"question":"def rearrange_array(arr): Rearrange the array such that all odd numbers appear before all even numbers, while preserving the relative order of both odd and even numbers. >>> rearrange_array([1, 2, 3, 4, 5, 6, 7, 8]) [1, 3, 5, 7, 2, 4, 6, 8] >>> rearrange_array([4, 1, 3, 2, 7, 6, 5]) [1, 3, 7, 5, 4, 2, 6]","solution":"def rearrange_array(arr): Rearrange the array such that all odd numbers appear before all even numbers, while preserving the relative order of both odd and even numbers. odd_numbers = [x for x in arr if x % 2 != 0] even_numbers = [x for x in arr if x % 2 == 0] return odd_numbers + even_numbers"},{"question":"def tournament_rankings(n: int, m: int, matches: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Generate the final rankings of the players based on the match results. Players are ranked based on the number of matches won. If two players have the same number of wins, they share the same rank. Args: n (int): The number of players. m (int): The number of matches. matches (List[Tuple[int, int]]): The list of match results as tuples (a, b) where player a won against player b. Returns: List[Tuple[int, int]]: The final rankings of the players in the form (player, wins), ordered by rank. Examples: >>> tournament_rankings(5, 4, [(1, 2), (2, 3), (1, 3), (3, 4)]) [(1, 2), (2, 1), (3, 1), (4, 0), (5, 0)] >>> tournament_rankings(3, 3, [(1, 2), (2, 3), (1, 3)]) [(1, 2), (2, 1), (3, 0)]","solution":"def tournament_rankings(n, m, matches): # Initialize a list to keep count of wins for each player wins = [0] * (n + 1) # Record wins for each player for a, b in matches: wins[a] += 1 # Format result as (player, wins) result = [(i, wins[i]) for i in range(1, n + 1)] # Sort the result by wins in descending order and then by player number in ascending order result.sort(key=lambda x: (-x[1], x[0])) return result"},{"question":"from typing import List def process_test_cases(test_cases: List[List[int]]) -> List[int]: Given an array of integers, returns the number of inversions for each test case. An inversion is defined as a case where i < j and arr[i] > arr[j]. >>> process_test_cases([[2, 3, 8, 6, 1]]) [5] >>> process_test_cases([[5, 4, 3, 2]]) [6] >>> process_test_cases([[1, 2, 3, 4, 5, 6, 7]]) [0]","solution":"def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def count_inversions(arr): if len(arr) < 2: return 0 temp_arr = [0]*len(arr) return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1) def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(count_inversions(arr)) return results"},{"question":"def matrix_row_vs_col_sum(n: int, m: int, matrix: List[List[int]]) -> str: Determines if there exists a row in the matrix such that the sum of its elements is greater than the sum of the elements of any column. Parameters: n (int): number of rows in the matrix. m (int): number of columns in the matrix. matrix (list of list of int): the matrix elements. Returns: str: \\"YES\\" if such a row exists, otherwise \\"NO\\". >>> matrix_row_vs_col_sum(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \\"YES\\" >>> matrix_row_vs_col_sum(2, 2, [[1, 1], [1, 2]]) \\"NO\\"","solution":"def matrix_row_vs_col_sum(n, m, matrix): Determines if there exists a row in the matrix such that the sum of its elements is greater than the sum of the elements of any column. Parameters: n (int): number of rows in the matrix. m (int): number of columns in the matrix. matrix (list of list of int): the matrix elements. Returns: str: \\"YES\\" if such a row exists, otherwise \\"NO\\". row_sums = [sum(row) for row in matrix] col_sums = [sum(matrix[i][j] for i in range(n)) for j in range(m)] max_row_sum = max(row_sums) max_col_sum = max(col_sums) if max_row_sum > max_col_sum: return \\"YES\\" return \\"NO\\""},{"question":"def min_operations_to_equal_arrays(t, test_cases): For each test case, calculate the minimum number of operations required to make array a equal to array b. Args: t : int : number of test cases test_cases : list : list of tuples, each containing: - n (int) : the length of arrays a and b - a (list) : list of n integers representing array a - b (list) : list of n integers representing array b Returns: list : list of integers where each integer corresponds to the minimum number of operations for each test case >>> min_operations_to_equal_arrays(2, [ ... (5, [1, 3, 2, 4, 1], [3, 1, 2, 4, 1]), ... (3, [1, 1, 1], [3, 3, 3]) ... ]) == [4, 6] >>> min_operations_to_equal_arrays(1, [ ... (3, [2, 2, 2], [2, 2, 2]) ... ]) == [0] >>> min_operations_to_equal_arrays(1, [ ... (1, [5], [10]) ... ]) == [5]","solution":"def min_operations_to_equal_arrays(t, test_cases): For each test case, calculate the minimum number of operations required to make array a equal to array b. Args: t : int : number of test cases test_cases : list : list of tuples, each containing: - n (int) : the length of arrays a and b - a (list) : list of n integers representing array a - b (list) : list of n integers representing array b Returns: list : list of integers where each integer corresponds to the minimum number of operations for each test case results = [] for n, a, b in test_cases: total_operations = 0 for i in range(n): total_operations += abs(a[i] - b[i]) results.append(total_operations) return results"},{"question":"def max_coins_collected(n: int, m: int, grid: List[str]) -> int: Find the maximum number of coins that can be collected when moving from the top-left corner to the bottom-right corner of the given grid. Each cell in the grid is represented as: - '.' (dot) for an empty cell - '#' (hash) for a cell containing an obstacle - 'C' (capital letter C) for a cell containing a coin >>> max_coins_collected(3, 4, [\\".C..\\",\\".CC.\\", \\"#..C\\"]) 4 >>> max_coins_collected(3, 4, [\\"C...\\", \\"...C\\", \\"C..C\\"]) 3 >>> max_coins_collected(3, 4, [\\".#..\\", \\".#C#\\", \\"#..C\\"]) -1 >>> max_coins_collected(3, 4, [\\"....\\", \\".#..\\", \\"....\\"]) 0 >>> max_coins_collected(3, 4, [\\"#...\\", \\"....\\", \\"...#\\"]) -1","solution":"def max_coins_collected(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 dp = [[-1] * m for _ in range(n)] dp[0][0] = 1 if grid[0][0] == 'C' else 0 for i in range(n): for j in range(m): if grid[i][j] == '#': continue if i > 0 and dp[i-1][j] != -1: dp[i][j] = max(dp[i][j], dp[i-1][j] + (1 if grid[i][j] == 'C' else 0)) if j > 0 and dp[i][j-1] != -1: dp[i][j] = max(dp[i][j], dp[i][j-1] + (1 if grid[i][j] == 'C' else 0)) return dp[n-1][m-1] if dp[n-1][m-1] != -1 else -1"},{"question":"def find_min_max_pages(n: int, k: int, pages: List[int]) -> int: Given the number of chapters and the number of parts, find the minimum possible value of the maximum sum of pages for the created parts. >>> find_min_max_pages(5, 2, [100, 200, 300, 400, 500]) 900 >>> find_min_max_pages(1, 1, [1000]) 1000 >>> find_min_max_pages(5, 2, [100, 100, 100, 100, 100]) 300 >>> find_min_max_pages(6, 1, [500, 500, 500, 500, 500, 500]) 3000 >>> find_min_max_pages(5, 5, [10, 20, 30, 40, 50]) 50 >>> find_min_max_pages(4, 2, [1, 2, 3, 4]) 6","solution":"def find_min_max_pages(n, k, pages): def can_split(mid): current_sum = 0 required_parts = 1 for page in pages: if current_sum + page > mid: required_parts += 1 current_sum = page if required_parts > k: return False else: current_sum += page return True low, high = max(pages), sum(pages) result = high while low <= high: mid = (low + high) // 2 if can_split(mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"def farthest_x(m: int, points: List[Tuple[int, int]]) -> int: Function to determine the farthest x-coordinate the cyclist can reach. Args: m (int): Number of vertical jump points. points (list): List of tuples containing x_i and y_i coordinates of jump points. Returns: int: Farthest x-coordinate the cyclist can reach. >>> farthest_x(1, [(5, 3)]) 5 >>> farthest_x(3, [(5, 3), (10, 10), (20, 5)]) 20 >>> farthest_x(3, [(3, 5), (1, 10), (2, 7)]) 3 >>> farthest_x(3, [(20, 5), (10, 10), (5, 3)]) 20 >>> farthest_x(4, [(5, 3), (5, 10), (10, 7), (10, 1)]) 10 >>> farthest_x(2, [(1000000000, 1), (1000000000, 2)]) 1000000000","solution":"def farthest_x(m, points): Function to determine the farthest x-coordinate the cyclist can reach. Args: m (int): Number of vertical jump points. points (list): List of tuples containing x_i and y_i coordinates of jump points. Returns: int: Farthest x-coordinate the cyclist can reach. # Sort the points by x-coordinate points.sort() # Initialize the furthest reachable x-coordinate farthest_point = 0 for x, y in points: # If the cycler can reach this point from the last farthest point if x >= farthest_point: farthest_point = x return farthest_point"},{"question":"from typing import List, Tuple def find_longest_path(n: int, edges: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Given a directed acyclic graph (DAG) G=(V,E), find the longest path in the graph. The length of a path is defined as the number of edges in the path. Parameters: n (int): The number of vertices in the graph. edges (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge from u to v. Returns: Tuple[int, List[int]]: The length of the longest path and a list of vertices representing the longest path in order. Examples: >>> find_longest_path(1, []) (0, [0]) >>> find_longest_path(2, [(0, 1)]) (1, [0, 1]) >>> find_longest_path(3, [(0, 1), (1, 2)]) (2, [0, 1, 2]) >>> find_longest_path(4, [(0, 1), (1, 2), (0, 3), (3, 2)]) (2, [0, 1, 2]) >>> find_longest_path(6, [(0, 1), (1, 2), (2, 3), (0, 3), (3, 4), (4, 5)]) (5, [0, 1, 2, 3, 4, 5]) pass # Test cases def test_single_node(): n = 1 edges = [] max_len, path = find_longest_path(n, edges) assert max_len == 0 assert path == [0] def test_two_nodes_one_edge(): n = 2 edges = [(0, 1)] max_len, path = find_longest_path(n, edges) assert max_len == 1 assert path == [0, 1] def test_three_nodes_two_edges(): n = 3 edges = [(0, 1), (1, 2)] max_len, path = find_longest_path(n, edges) assert max_len == 2 assert path == [0, 1, 2] def test_multiple_paths_same_length(): n = 4 edges = [(0, 1), (1, 2), (0, 3), (3, 2)] max_len, path = find_longest_path(n, edges) assert max_len == 2 assert path == [0, 1, 2] or path == [0, 3, 2] def test_complex_graph(): n = 6 edges = [(0, 1), (1, 2), (2, 3), (0, 3), (3, 4), (4, 5)] max_len, path = find_longest_path(n, edges) assert max_len == 5 assert path == [0, 1, 2, 3, 4, 5]","solution":"from collections import defaultdict, deque def find_longest_path(n, edges): adj_list = defaultdict(list) in_degree = [0] * n # Build the graph for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 # Topological sort using Kahn's algorithm topo_sort = [] queue = deque([i for i in range(n) if in_degree[i] == 0]) while queue: node = queue.popleft() topo_sort.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Finding the longest path dist = [-1] * n parent = [-1] * n dist[topo_sort[0]] = 0 for u in topo_sort: if dist[u] != -1: # Node u has been reached for v in adj_list[u]: if dist[v] < dist[u] + 1: dist[v] = dist[u] + 1 parent[v] = u # Retrieve the longest path max_dist = max(dist) end_vertex = dist.index(max_dist) path = [] while end_vertex != -1: path.append(end_vertex) end_vertex = parent[end_vertex] return max_dist, path[::-1]"},{"question":"def maximum_petals(n: int, petals: List[int]) -> int: Returns the maximum possible number of petals in a bouquet that consists of unique flowers only. :param n: integer, number of different types of flowers :param petals: list of integers, number of petals on each flower :return: integer, maximum possible number of petals in a bouquet >>> maximum_petals(5, [1, 3, 1, 5, 7]) 16 >>> maximum_petals(4, [4, 4, 4, 4]) 4","solution":"def maximum_petals(n, petals): Returns the maximum possible number of petals in a bouquet that consists of unique flowers only. :param n: integer, number of different types of flowers :param petals: list of integers, number of petals on each flower :return: integer, maximum possible number of petals in a bouquet # Converting the list of petals to a set to remove duplicates unique_petals = set(petals) # Summing up the unique petals return sum(unique_petals)"},{"question":"def count_valid_subsequences(n: int, k: int, array: List[int]) -> int: Returns the number of distinct subsequences whose sum is divisible by k. :param n: The length of the array. :param k: The integer by which the sum of the subsequence elements must be divisible. :param array: List of integers representing the array. :return: The number of valid subsequences. >>> count_valid_subsequences(3, 3, [1, 2, 3]) 3 >>> count_valid_subsequences(3, 10, [1, 2, 3]) 0 >>> count_valid_subsequences(3, 1, [1, 2, 3]) 7 >>> count_valid_subsequences(4, 2, [2, 3, 4, 6]) 7 >>> count_valid_subsequences(5, 3, [3, 6, 9, 12, 15]) 31 >>> count_valid_subsequences(5, 7, [14, 7, 21, 28, 35]) 31","solution":"def count_valid_subsequences(n, k, array): Returns the number of distinct subsequences whose sum is divisible by k. import itertools count = 0 for r in range(1, n + 1): for subseq in itertools.combinations(array, r): if sum(subseq) % k == 0: count += 1 return count"},{"question":"from typing import List def minMeetingRooms(intervals: List[List[int]]) -> int: Return the minimum number of meeting rooms required to accommodate all the meetings. >>> minMeetingRooms([[0, 30], [5, 10], [15, 20]]) 2 >>> minMeetingRooms([[7, 10], [2, 4]]) 1 >>> minMeetingRooms([]) 0 >>> minMeetingRooms([[5, 10]]) 1 >>> minMeetingRooms([[1, 4], [2, 5], [3, 6]]) 3 >>> minMeetingRooms([[1, 2], [3, 4], [5, 6]]) 1 >>> minMeetingRooms([[1, 4], [2, 3], [3, 6]]) 2","solution":"from typing import List import heapq def minMeetingRooms(intervals: List[List[int]]) -> int: if not intervals: return 0 intervals.sort(key=lambda x: x[0]) min_heap = [intervals[0][1]] for i in range(1, len(intervals)): if intervals[i][0] >= min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, intervals[i][1]) return len(min_heap)"},{"question":"from typing import List def minimum_number_of_increasing_sublists(arr: List[int]) -> int: Returns the minimum number of non-empty sublists such that each sublist is strictly increasing. >>> minimum_number_of_increasing_sublists([4, 2, 3, 1, 5, 6]) 3 >>> minimum_number_of_increasing_sublists([1, 2, 3, 4, 5]) 1 >>> minimum_number_of_increasing_sublists([5, 4, 3, 2, 1]) 5 >>> minimum_number_of_increasing_sublists([1, 3, 2, 4, 6, 5, 7]) 3 >>> minimum_number_of_increasing_sublists([]) 0 >>> minimum_number_of_increasing_sublists([1]) 1","solution":"def minimum_number_of_increasing_sublists(arr): Returns the minimum number of non-empty sublists such that each sublist is strictly increasing. if not arr: # if arr is empty, no sublists are needed return 0 sublists_count = 1 # at least one sublist is needed for i in range(1, len(arr)): if arr[i] <= arr[i-1]: sublists_count += 1 return sublists_count"},{"question":"from collections import deque, defaultdict def longest_route(n, edges): Determines the length of the longest route in a network of planets. Args: n (int): The number of planets. edges (List[Tuple[int, int]]): The list of direct connections between planets. Returns: int: The length of the longest route that can be traveled without revisiting any planet. >>> longest_route(2, [(1, 2)]) 1 >>> longest_route(4, [(1, 2), (2, 3), (3, 4)]) 3 >>> longest_route(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) 2 >>> longest_route(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 4 >>> longest_route(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4","solution":"def longest_route(n, edges): from collections import deque, defaultdict def bfs(start): dist = [-1] * (n + 1) dist[start] = 0 q = deque([start]) furthest_node = start max_dist = 0 while q: u = q.popleft() for v in adj[u]: if dist[v] == -1: dist[v] = dist[u] + 1 if dist[v] > max_dist: max_dist = dist[v] furthest_node = v q.append(v) return furthest_node, max_dist adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # First BFS to find the furthest node from an arbitrary start point (e.g., node 1) furthest_node, _ = bfs(1) # Second BFS to find the maximum distance starting from the furthest node found in the first BFS _, longest_route_length = bfs(furthest_node) return longest_route_length"},{"question":"from typing import List def smallest_subarray_with_k_distinct(arr: List[int], k: int) -> int: Find the smallest possible length of a contiguous subarray containing at least \`k\` distinct elements. Args: arr: List of integers. k: An integer representing the number of distinct elements needed in the subarray. Returns: An integer representing the smallest possible length of the subarray, or -1 if no such subarray exists. Examples: >>> smallest_subarray_with_k_distinct([1, 2, 1, 3, 4, 2, 3], 3) 3 >>> smallest_subarray_with_k_distinct([1, 1, 1, 1, 1, 1], 2) -1","solution":"def smallest_subarray_with_k_distinct(arr, k): from collections import defaultdict n = len(arr) if k > n: return -1 min_length = float('inf') left = 0 right = 0 current_freq = defaultdict(int) distinct_count = 0 while right < n: if current_freq[arr[right]] == 0: distinct_count += 1 current_freq[arr[right]] += 1 while distinct_count >= k: min_length = min(min_length, right - left + 1) current_freq[arr[left]] -= 1 if current_freq[arr[left]] == 0: distinct_count -= 1 left += 1 right += 1 return min_length if min_length != float('inf') else -1"},{"question":"def max_min_element(n: int, k: int, A: List[int], B: List[int]) -> int: Find the maximum possible value of the smallest element in array C created by summing elements of A and B. >>> max_min_element(3, 2, [3, 1, 4], [2, 5, 6]) 8 >>> max_min_element(3, 2, [1, 1, 1], [1, 1, 1]) 2 >>> max_min_element(1, 1, [1], [1]) 2 >>> max_min_element(3, 2, [100, 200, 300], [400, 500, 600]) 700 >>> max_min_element(5, 1, [10, 20, 30, 40, 50], [5, 15, 25, 35, 45]) 95","solution":"def max_min_element(n, k, A, B): A.sort(reverse=True) B.sort(reverse=True) C = [] for i in range(k): C.append(A[i] + B[i]) return min(C)"},{"question":"def min_moves_to_balance(n: int, k: int, grid: List[str]) -> int: Determine the minimum number of moves required to rearrange birdhouses so that each zone contains an equal number of bluebirds and redbirds. If it's not possible, return -1. >>> min_moves_to_balance(3, 4, [\\"BRBR\\", \\"BBRR\\", \\"RRBB\\"]) 0 >>> min_moves_to_balance(2, 4, [\\"BBBB\\", \\"RRRR\\"]) 4","solution":"def min_moves_to_balance(n, k, grid): total_blues = sum(row.count('B') for row in grid) total_reds = n * k - total_blues if total_blues != total_reds: return -1 moves = 0 for i in range(n): blues = grid[i].count('B') reds = k - blues balance_moves = abs(blues - reds) // 2 moves += balance_moves return moves"},{"question":"def form_groups(n: int, m: int, identifiers: List[int]) -> List[List[int]]: Forms m groups such that each group has a unique combined code identifier. :param n: int - Total number of team members :param m: int - Number of groups to form :param identifiers: List[int] - List of unique code identifiers for team members :return: List[List[int]] - List of groups formed under the given constraints >>> form_groups(5, 3, [4, 2, 5, 7, 6]) [[2, 7], [4, 5], [6]] >>> form_groups(4, 4, [10, 20, 30, 40]) [[10], [20], [30], [40]] >>> form_groups(4, 1, [1, 2, 3, 4]) [[1, 2, 3, 4]] >>> form_groups(6, 2, [1, 3, 5, 7, 9, 11]) [[1, 5, 9], [3, 7, 11]] >>> form_groups(50, 10, list(range(1, 51))) Output varies, but should have 10 unique sums and roughly 5 members per group.","solution":"def form_groups(n, m, identifiers): Forms m groups such that each group has a unique combined code identifier. :param n: int - Total number of team members :param m: int - Number of groups to form :param identifiers: List[int] - List of unique code identifiers for team members :return: List[List[int]] - List of groups formed under the given constraints identifiers.sort() groups = [[] for _ in range(m)] for i in range(n): groups[i % m].append(identifiers[i]) return groups # Example usage: n = 5 m = 3 identifiers = [4, 2, 5, 7, 6] print(form_groups(n, m, identifiers))"},{"question":"def min_operations_to_avoid_adjacent_duplicates(t: int, test_cases: List[str]) -> List[int]: You are given a string \`s\` consisting of lowercase English letters. Your goal is to transform the string such that no two adjacent characters are the same. Your task is to find the minimum number of operations required to achieve this goal. Parameters: t (int): the number of test cases test_cases (List[str]): a list of strings corresponding to each test case Returns: List[int]: a list of integers where each integer is the minimum number of operations required for the corresponding test case to make the string have no two adjacent characters that are the same. >>> min_operations_to_avoid_adjacent_duplicates(1, [\\"abcde\\"]) [0] >>> min_operations_to_avoid_adjacent_duplicates(1, [\\"aab\\"]) [1] >>> min_operations_to_avoid_adjacent_duplicates(1, [\\"aaaa\\"]) [3] >>> min_operations_to_avoid_adjacent_duplicates(3, [\\"aabb\\", \\"abab\\", \\"aabbcc\\"]) [2, 0, 3] >>> min_operations_to_avoid_adjacent_duplicates(1, [\\"zzzz\\"]) [3] >>> min_operations_to_avoid_adjacent_duplicates(1, [\\"abababab\\"]) [0]","solution":"def min_operations_to_avoid_adjacent_duplicates(t, test_cases): Returns a list of integers where each integer is the minimum number of operations required for the corresponding test case to make the string have no two adjacent characters that are the same. results = [] for s in test_cases: operations = 0 for i in range(1, len(s)): if s[i] == s[i-1]: operations += 1 results.append(operations) return results"},{"question":"def max_saplings(N: int, M: int, grid: List[List[str]]) -> int: Determine the maximum number of saplings that can be planted in the grid such that no two saplings are adjacent to each other, neither horizontally, vertically, nor diagonally. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[List[str]]): The grid representation where 'F' denotes a flower and 'E' denotes an empty cell. Returns: int: The maximum number of saplings that can be planted. Examples: >>> max_saplings(3, 4, [['E', 'E', 'E', 'E'], ['E', 'F', 'E', 'E'], ['E', 'E', 'E', 'E']]) 4 >>> max_saplings(3, 3, [['E', 'E', 'E'], ['E', 'E', 'E'], ['E', 'E', 'E']]) 4","solution":"def max_saplings(N, M, grid): Returns the maximum number of saplings that can be planted. saplings = [[0 for _ in range(M)] for _ in range(N)] count = 0 for i in range(N): for j in range(M): if grid[i][j] == 'E' and (i == 0 or saplings[i-1][j] != 'S') and (j == 0 or saplings[i][j-1] != 'S') and (i == 0 or j == 0 or saplings[i-1][j-1] != 'S') and (i == 0 or j == M-1 or saplings[i-1][j+1] != 'S'): saplings[i][j] = 'S' count += 1 else: saplings[i][j] = 'E' if grid[i][j] == 'E' else 'F' return count"},{"question":"def min_operations_to_transform(n, initial_sequence, target_sequence): Calculate the minimum number of operations required to transform the initial sequence into the target sequence. Each increment or decrement operation changes a number by 1. :param n: Length of the sequences :param initial_sequence: List of integers representing the initial sequence :param target_sequence: List of integers representing the target sequence :return: Minimum number of operations required >>> min_operations_to_transform(3, [1, 2, 3], [4, 6, 8]) 12 >>> min_operations_to_transform(1, [1], [1]) 0 >>> min_operations_to_transform(2, [1, 2], [3, 4]) 4 >>> min_operations_to_transform(3, [5, 5, 5], [7, 7, 7]) 6 >>> min_operations_to_transform(3, [1, 2, 3], [3, 2, 1]) 4 >>> min_operations_to_transform(1, [1000000], [1]) 999999 >>> min_operations_to_transform(1, [1], [1000000]) 999999 >>> min_operations_to_transform(2, [1000000, 1000000], [1, 2]) 1999997","solution":"def min_operations_to_transform(n, initial_sequence, target_sequence): Calculate the minimum number of operations required to transform the initial sequence into the target sequence. Each increment or decrement operation changes a number by 1. :param n: Length of the sequences :param initial_sequence: List of integers representing the initial sequence :param target_sequence: List of integers representing the target sequence :return: Minimum number of operations required operations_count = 0 for initial, target in zip(initial_sequence, target_sequence): operations_count += abs(target - initial) return operations_count"},{"question":"def longest_contiguous_subarray(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the length of the longest contiguous subarray such that all the elements in the subarray are either strictly increasing or strictly decreasing. >>> longest_contiguous_subarray(2, [(6, [1, 2, 3, 4, 5, 3]), (5, [5, 4, 3, 2, 1])]) [5, 5] >>> longest_contiguous_subarray(1, [(1, [1])]) [1]","solution":"def longest_contiguous_subarray(t, test_cases): result = [] for i in range(t): n, arr = test_cases[i] if n == 1: result.append(1) continue max_len = 1 cur_len = 1 # Check for strictly increasing subarray for j in range(1, n): if arr[j] > arr[j - 1]: cur_len += 1 else: max_len = max(max_len, cur_len) cur_len = 1 max_len = max(max_len, cur_len) # Check for strictly decreasing subarray cur_len = 1 for j in range(1, n): if arr[j] < arr[j - 1]: cur_len += 1 else: max_len = max(max_len, cur_len) cur_len = 1 max_len = max(max_len, cur_len) result.append(max_len) return result"},{"question":"def is_palindrome(s: str) -> str: Determines if the given string is a palindrome, ignoring case. Args: s (str): The string to check. Returns: str: \\"PALINDROME\\" if the string is a palindrome, \\"NOT PALINDROME\\" otherwise. >>> is_palindrome(\\"Madam\\") \\"PALINDROME\\" >>> is_palindrome(\\"Hello\\") \\"NOT PALINDROME\\" >>> is_palindrome(\\"RaceCar\\") \\"PALINDROME\\" >>> is_palindrome(\\"A\\") \\"PALINDROME\\" >>> is_palindrome(\\"AblewasiEreISawElba\\") \\"PALINDROME\\" >>> is_palindrome(\\"12321\\") \\"PALINDROME\\" >>> is_palindrome(\\"12345\\") \\"NOT PALINDROME\\" >>> is_palindrome(\\"A man a plan a canal Panama\\".replace(\\" \\", \\"\\")) \\"PALINDROME\\"","solution":"def is_palindrome(s): Determines if the given string is a palindrome, ignoring case. Args: s (str): The string to check. Returns: str: \\"PALINDROME\\" if the string is a palindrome, \\"NOT PALINDROME\\" otherwise. s = s.lower() # Convert the string to lowercase if s == s[::-1]: # Check if the string is equal to its reverse return \\"PALINDROME\\" else: return \\"NOT PALINDROME\\""},{"question":"def process_queries(n: int, queries: List[str]) -> List[str]: Processes a list of employees and their relationships in a company to determine the direct managerial hierarchy. Args: n (int): The number of queries. queries (List[str]): A list of queries where each query is either of the form \\"assign X Y\\" to assign employee Y as a direct subordinate of employee X, or \\"manager Y\\" to output the direct manager of employee Y. Returns: List[str]: The results for each \\"manager Y\\" query in the order they were received. Example: >>> process_queries(6, ['assign alice bob', 'assign alice charlie', 'manager bob', 'manager dave', 'assign bob eve', 'manager eve']) ['alice', 'NONE', 'bob'] >>> process_queries(3, ['assign alice bob', 'assign charlie bob', 'manager bob']) ['charlie']","solution":"def process_queries(n, queries): employee_manager = {} results = [] for query in queries: parts = query.split() if parts[0] == \\"assign\\": manager, subordinate = parts[1], parts[2] employee_manager[subordinate] = manager elif parts[0] == \\"manager\\": subordinate = parts[1] results.append(employee_manager.get(subordinate, \\"NONE\\")) return results"},{"question":"def num_decodings(s: str) -> int: Determine the number of possible decodings of the sequence of digits. >>> num_decodings(\\"1\\") 1 >>> num_decodings(\\"9\\") 1 >>> num_decodings(\\"0\\") 0 >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"123\\") 3 >>> num_decodings(\\"110\\") 1 >>> num_decodings(\\"101\\") 1 >>> num_decodings(\\"100\\") 0 >>> num_decodings(\\"1010\\") 1 >>> num_decodings(\\"1101\\") 1 >>> num_decodings(\\"11106\\") 2 >>> num_decodings(\\"1111111111\\") 89","solution":"def num_decodings(s): if not s or s.startswith('0'): return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i > 1 and s[i - 2] == '1' or (s[i - 2] == '2' and s[i - 1] in '0123456'): dp[i] += dp[i - 2] return dp[n]"},{"question":"def calculate_rewards(S: int, T1: int, T2: int, R1: int, R2: int, R3: int) -> int: Calculate the total reward points for a customer based on their spending and reward thresholds. >>> calculate_rewards(150, 100, 200, 2, 1, 0.5) 250 >>> calculate_rewards(300, 100, 200, 2, 1, 0.5) 350","solution":"def calculate_rewards(S, T1, T2, R1, R2, R3): total_reward_points = 0 if S <= T1: total_reward_points = S * R1 elif S <= T2: total_reward_points = T1 * R1 + (S - T1) * R2 else: total_reward_points = T1 * R1 + (T2 - T1) * R2 + (S - T2) * R3 return total_reward_points"},{"question":"from typing import List, Tuple def maximum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the maximum possible sum of edge weights in a valid tree that includes every node exactly once. Args: n: The number of nodes. edges: A list of tuples where each tuple contains two nodes and the weight of the edge between them. Returns: The maximum possible sum of edge weights in the valid tree. >>> maximum_spanning_tree(4, [(1, 2, 3), (1, 3, 2), (2, 3, 4), (3, 4, 1), (2, 4, 5)]) 12 >>> maximum_spanning_tree(1, []) 0 >>> maximum_spanning_tree(5, []) 0 >>> maximum_spanning_tree(3, [(1, 2, 1), (2, 3, 2)]) 3 >>> maximum_spanning_tree(3, [(1, 2, 1000000), (2, 3, 1000000), (1, 3, 999999)]) 2000000 >>> maximum_spanning_tree(3, [(1, 2, 10), (2, 3, 10), (1, 3, 1)]) 20","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def maximum_spanning_tree(n, edges): # Sort edges by weight in descending order edges.sort(key=lambda x: -x[2]) parent = [i for i in range(n + 1)] rank = [0] * (n + 1) max_weight_sum = 0 edge_count = 0 for u, v, w in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) max_weight_sum += w edge_count += 1 if edge_count == n - 1: break return max_weight_sum"},{"question":"from typing import List def findLongestSubarray(arr: List[int]) -> int: Given an array of integers, find the length of the longest contiguous subarray with an equal number of 1s and 0s. >>> findLongestSubarray([0, 1, 0, 1]) 4 >>> findLongestSubarray([0, 0, 1, 0, 1, 1, 0]) 6 >>> findLongestSubarray([0, 0, 0, 1, 1, 0, 0]) 4","solution":"from typing import List def findLongestSubarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with an equal number of 1s and 0s. # Map to store the first occurrence of a prefix_sum prefix_sum_map = {} # Initialize variables max_length = 0 prefix_sum = 0 # Iterate through the array for i in range(len(arr)): # Convert 0s to -1s if arr[i] == 0: prefix_sum -= 1 else: prefix_sum += 1 # Check if the prefix_sum is zero if prefix_sum == 0: max_length = i + 1 # Check if the prefix_sum has been seen before if prefix_sum in prefix_sum_map: max_length = max(max_length, i - prefix_sum_map[prefix_sum]) else: # Store the first occurrence of the prefix_sum prefix_sum_map[prefix_sum] = i return max_length"},{"question":"def max_experience(monsters: List[Tuple[int, int]], stamina: int) -> int: Determine the maximum XP a player can gain within a given amount of stamina. >>> max_experience([(100, 5)], 5) 100 >>> max_experience([(200, 10)], 10) 200 >>> max_experience([(100, 5), (300, 10), (200, 8)], 10) 300 >>> max_experience([(100, 3), (200, 4), (300, 5), (50, 2)], 7) 350 >>> max_experience([(500, 5), (300, 4), (200, 5)], 5) 500 pass","solution":"def max_experience(monsters, stamina): Function to determine the maximum XP a player can gain within a given amount of stamina. :param monsters: List of tuples, where each tuple contains two integers: XP value and stamina required to defeat the monster. :param stamina: Integer representing the total stamina available to the player. :return: Maximum XP the player can gain. n = len(monsters) # DP table to store the max XP for each stamina value dp = [0] * (stamina + 1) # Iterate over all monsters and update the dp table accordingly for xp, st in monsters: for j in range(stamina, st - 1, -1): dp[j] = max(dp[j], dp[j - st] + xp) # The answer is the maximum XP we can get with the given stamina return dp[stamina]"},{"question":"def countInversions(arr: List[int]) -> int: Given an array of integers \`arr\`, find the number of inversions. An inversion indicates how far (or close) the array is from being sorted. >>> countInversions([2, 3, 8, 6, 1]) 5 >>> countInversions([1, 2, 3, 4, 5]) 0 >>> countInversions([5, 4, 3, 2, 1]) 10 >>> countInversions([1]) 0 >>> countInversions([1, 1, 1, 1, 1]) 0 >>> countInversions([3, 1, 2, 4, 5]) 2 >>> countInversions(list(range(100000, 0, -1))) 4999950000","solution":"from typing import List def countInversions(arr: List[int]) -> int: def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all left subarray elements # after i are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0] * len(arr) return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)"},{"question":"def compute_tree_height(n: int, nodes: List[Tuple[int, int]]) -> int: Determine the height of a binary tree given its node connections. Args: n (int): The number of nodes in the binary tree. nodes (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, representing the left and right children of each node respectively. If a node does not have a left or right child, the corresponding value is -1. Returns: int: The height of the binary tree. Example: >>> compute_tree_height(5, [(2, 3), (-1, -1), (4, 5), (-1, -1), (-1, -1)]) 3 >>> compute_tree_height(1, [(-1, -1)]) 1","solution":"def compute_tree_height(n, nodes): from collections import defaultdict def height(node): if node == -1: return 0 left_height = height(tree[node][0]) right_height = height(tree[node][1]) return 1 + max(left_height, right_height) # Construct the tree from the input nodes array tree = defaultdict(lambda: (-1, -1)) for i in range(n): tree[i + 1] = (nodes[i][0], nodes[i][1]) # Start from the root node, which is 1 return height(1)"},{"question":"def length_of_smallest_substring_with_all_unique_letters(s: str) -> int: Determine the length of the smallest substring that contains at least one of each unique letter from the original string. >>> length_of_smallest_substring_with_all_unique_letters(\\"aAbBcC\\") == 6 >>> length_of_smallest_substring_with_all_unique_letters(\\"abcdeABCDE\\") == 10 >>> length_of_smallest_substring_with_all_unique_letters(\\"aabbccAABBCC\\") == 10 pass def process_test_cases(test_cases: List[str]) -> List[int]: Process a list of test cases to find the length of the smallest substring that contains at least one of each unique letter for each test case. >>> process_test_cases([\\"aAbBcC\\"]) == [6] >>> process_test_cases([\\"abcdeABCDE\\"]) == [10] >>> process_test_cases([\\"aabbccAABBCC\\"]) == [10] pass # Unit Tests import pytest def test_case_1(): input_data = [\\"aAbBcC\\"] expected_output = [6] assert process_test_cases(input_data) == expected_output def test_case_2(): input_data = [\\"abcdeABCDE\\"] expected_output = [10] assert process_test_cases(input_data) == expected_output def test_case_3(): input_data = [\\"aabbccAABBCC\\"] expected_output = [10] assert process_test_cases(input_data) == expected_output def test_case_4(): input_data = [\\"abababab\\"] expected_output = [2] assert process_test_cases(input_data) == expected_output def test_case_5(): input_data = [\\"z\\"] expected_output = [1] assert process_test_cases(input_data) == expected_output def test_case_6(): input_data = [\\"abcdefg\\"] expected_output = [7] assert process_test_cases(input_data) == expected_output def test_case_7(): input_data = [\\"AaBbCcDd\\"] expected_output = [8] assert process_test_cases(input_data) == expected_output","solution":"def length_of_smallest_substring_with_all_unique_letters(s): unique_letters = set(s) required_len = len(unique_letters) left, right = 0, 0 min_length = float('inf') char_count = {} while right < len(s): char_count[s[right]] = char_count.get(s[right], 0) + 1 right += 1 while len(char_count) >= required_len: current_length = right - left if current_length < min_length: min_length = current_length char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_length def process_test_cases(test_cases): results = [] for s in test_cases: results.append(length_of_smallest_substring_with_all_unique_letters(s)) return results"},{"question":"def total_sales_per_campaign(n: int, sales: List[int], campaigns: List[Tuple[int, int]]) -> List[int]: Calculate total sales for each promotional campaign. Parameters: - n: int, number of days - sales: list of ints, sales on each day - campaigns: list of tuples, each tuple contains two integers indicating the start and end day of a campaign Returns: - list of ints, total sales for each campaign >>> total_sales_per_campaign(7, [10, 20, 30, 40, 50, 60, 70], [(1, 3), (2, 5), (4, 7)]) [60, 140, 220] >>> total_sales_per_campaign(5, [100, 200, 300, 400, 500], [(1, 5)]) [1500] >>> total_sales_per_campaign(5, [0, 0, 0, 0, 0], [(1, 5), (2, 4)]) [0, 0] >>> total_sales_per_campaign(3, [1000000, 1000000, 1000000], [(1, 2), (1, 3), (2, 3)]) [2000000, 3000000, 2000000] >>> total_sales_per_campaign(7, [10, 20, 30, 40, 50, 60, 70], [(1, 3)]) [60]","solution":"def total_sales_per_campaign(n, sales, campaigns): Calculate total sales for each promotional campaign. Parameters: - n: int, number of days - sales: list of ints, sales on each day - campaigns: list of tuples, each tuple contains two integers indicating the start and end day of a campaign Returns: - list of ints, total sales for each campaign prefix_sum = [0] * (n + 1) # Create prefix sum array for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + sales[i - 1] results = [] for campaign in campaigns: l, r = campaign total_sales = prefix_sum[r] - prefix_sum[l - 1] results.append(total_sales) return results"},{"question":"import math def sum_of_squares(n: int) -> str: Determines if there exists a pair of positive integers (a, b) such that a^2 + b^2 = n. >>> sum_of_squares(5) 'YES' >>> sum_of_squares(3) 'NO' >>> sum_of_squares(1) 'NO' >>> sum_of_squares(4) 'NO' >>> sum_of_squares(13) 'YES' >>> sum_of_squares(100000000) 'YES' >>> sum_of_squares(100000002) 'NO'","solution":"import math def sum_of_squares(n): Determines if there exists a pair of positive integers (a, b) such that a^2 + b^2 = n. for a in range(1, int(math.isqrt(n)) + 1): b_square = n - a**2 b = int(math.isqrt(b_square)) if b > 0 and b * b == b_square: return \\"YES\\" return \\"NO\\""},{"question":"def countPairs(arr: List[int], k: int) -> int: Returns the number of pairs (i, j) such that 1 ≤ i < j ≤ n and arr[i] + arr[j] = k. >>> countPairs([1, 5, 3, 3, 7], 6) 2 >>> countPairs([1, 1, 1, 1], 2) 6 >>> countPairs([1, 2, 3, 4, 5], 9) 1 >>> countPairs([1, 2, 3, 4, 5], 10) 0 >>> countPairs([1, -1, 1, -1], 0) 4 >>> countPairs([0, 0, 0, 0, 0], 0) 10","solution":"def countPairs(arr, k): Returns the number of pairs (i, j) such that 1 ≤ i < j ≤ n and arr[i] + arr[j] = k. count = 0 seen = {} for num in arr: difference = k - num if difference in seen: count += seen[difference] if num in seen: seen[num] += 1 else: seen[num] = 1 return count"},{"question":"def max_sum_subarray(arr, n, k): Returns the maximum sum of a subarray of length k. >>> max_sum_subarray([2, 1, 5, 1, 3, 2, 6], 7, 3) 11 >>> max_sum_subarray([1], 1, 1) 1 >>> max_sum_subarray([10, 20, 30], 3, 1) 30 >>> max_sum_subarray([1, 2, 3, 4, 5], 5, 5) 15 >>> max_sum_subarray([5, 5, 5, 5, 5], 5, 3) 15 >>> max_sum_subarray([1000000000, 1000000000, 1000000000, 1000000000], 4, 2) 2000000000 >>> large_array = list(range(1, 100001)) >>> max_sum_subarray(large_array, 100000, 3) 299997 >>> max_sum_subarray([3, 3, 3, 3], 4, 2) 6","solution":"def max_sum_subarray(arr, n, k): Returns the maximum sum of a subarray of length k. # Find the sum of the first window of size k max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Given an integer array nums, find all the unique triplets in the array which gives the sum of zero. Notice that the solution set must not contain duplicate triplets. >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([]) [] >>> three_sum([0]) []","solution":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: sum_three = nums[i] + nums[left] + nums[right] if sum_three == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_three < 0: left += 1 else: right -= 1 return result"},{"question":"import re def is_valid_password(password: str) -> bool: Checks if the provided password meets the specified criteria for a valid password. Parameters: password (str): The password to be validated. Returns: bool: True if the password is valid, False otherwise. pass # Tests def test_valid_password(): assert is_valid_password('Paw0rd') == True def test_no_uppercase(): assert is_valid_password('paw0rd') == False def test_no_digit(): assert is_valid_password('Paword') == False def test_invalid_length(): assert is_valid_password('P@1') == False assert is_valid_password('P@sswordP@sswordP@ssword1!') == False def test_no_special_character(): assert is_valid_password('Password1') == False def test_contains_whitespace(): assert is_valid_password('P@sswor d1') == False def test_no_lower_case(): assert is_valid_password('PAW0RD') == False def test_minimum_boundary_length(): assert is_valid_password('Aa1@aaaa') == True def test_maximum_boundary_length(): assert is_valid_password('Aa1@' + 'a' * 16) == True def test_invalid_special_character(): assert is_valid_password('Password1!#') == True assert is_valid_password('Password1!#@') == True def test_valid_with_multiple_conditions(): assert is_valid_password('A1b2C3dEf0^') == True","solution":"import re def is_valid_password(password): Checks if the provided password meets the specified criteria for a valid password. Parameters: password (str): The password to be validated. Returns: bool: True if the password is valid, False otherwise. if not (8 <= len(password) <= 20): return False if not re.search(r'[a-z]', password): return False if not re.search(r'[A-Z]', password): return False if not re.search(r'd', password): return False if not re.search(r'[!@#%^&*()-_=+]', password): return False if re.search(r's', password): return False return True"},{"question":"def smallest_lexicographical_string(s: str) -> str: Returns the smallest lexicographical string that can be obtained by moving any character to the end of string any number of times. >>> smallest_lexicographical_string(\\"cba\\") \\"abc\\" >>> smallest_lexicographical_string(\\"zxy\\") \\"xyz\\" >>> smallest_lexicographical_string(\\"bca\\") \\"abc\\" >>> smallest_lexicographical_string(\\"aaa\\") \\"aaa\\" >>> smallest_lexicographical_string(\\"ab\\") \\"ab\\" >>> smallest_lexicographical_string(\\"ba\\") \\"ab\\" >>> smallest_lexicographical_string(\\"abcd\\") \\"abcd\\" >>> smallest_lexicographical_string(\\"dcba\\") \\"abcd\\" >>> smallest_lexicographical_string(\\"a\\") \\"a\\" >>> smallest_lexicographical_string(\\"abc\\") \\"abc\\" >>> smallest_lexicographical_string(\\"degh\\") \\"degh\\"","solution":"def smallest_lexicographical_string(s: str) -> str: Returns the smallest lexicographical string that can be obtained by moving any character to the end of string any number of times. s_sorted = ''.join(sorted(s)) return s_sorted"},{"question":"def longest_suspicious_substring(s: str) -> str: Reveal the longest suspicious substring in the given password. If there are multiple longest suspicious substrings with the same length, return the one that appears first. If no such substring exists, return an empty string. Args: s (str): String of lowercase English letters representing the password. Returns: str: The longest suspicious substring or an empty string if no such substring exists. >>> longest_suspicious_substring(\\"ababc\\") \\"ab\\" >>> longest_suspicious_substring(\\"abcd\\") \\"\\" >>> longest_suspicious_substring(\\"aaaa\\") \\"aaa\\" >>> longest_suspicious_substring(\\"ababab\\") \\"abab\\" >>> longest_suspicious_substring(\\"aabbaaccddeeff\\") \\"aa\\"","solution":"def longest_suspicious_substring(s): n = len(s) longest_suspicious = \\"\\" for length in range(n-1, 0, -1): # Start from the longest possible substring seen = set() for i in range(n - length + 1): substring = s[i:i+length] if substring in seen: return substring seen.add(substring) return longest_suspicious"},{"question":"def trim_sentence(sentence: str, max_length: int) -> str: Write a function that trims a space-separated sentence to a specified length. Given an input sentence and a maximum length, cut words from the end of the sentence such that the remaining sentence does not exceed the maximum length. If the entire sentence is shorter than or equal to the specified length, return it unchanged. Words are separated by a single space, and you must not break any word nor rearrange them. >>> trim_sentence(\\"The quick brown fox jumps over the lazy dog\\", 16) \\"The quick brown\\" >>> trim_sentence(\\"Hello world\\", 5) \\"\\" >>> trim_sentence(\\"A smaller example\\", 20) \\"A smaller example\\" >>> trim_sentence(\\"Python programming is fun\\", 18) \\"Python programming\\"","solution":"def trim_sentence(sentence: str, max_length: int) -> str: if len(sentence) <= max_length: return sentence words = sentence.split() trimmed_sentence = \\"\\" for word in words: if len(trimmed_sentence) + len(word) + (1 if trimmed_sentence else 0) > max_length: break trimmed_sentence += (\\" \\" if trimmed_sentence else \\"\\") + word return trimmed_sentence"},{"question":"def longest_subarray_with_sum_at_most_k(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest subarray with sum at most k. Parameters: n (int): The number of elements in the array. k (int): The maximum allowed sum of the subarray. arr (list): List of integers representing the array. Returns: int: The length of the longest subarray with sum at most k. >>> longest_subarray_with_sum_at_most_k(5, 5, [1, 2, 3, 4, 5]) 2 >>> longest_subarray_with_sum_at_most_k(3, 1, [2, 3, 4]) 0 >>> longest_subarray_with_sum_at_most_k(4, 10, [1, 2, 3, 4]) 4 >>> longest_subarray_with_sum_at_most_k(5, 3, [1, 1, 1, 1, 1]) 3 >>> longest_subarray_with_sum_at_most_k(6, 10, [3, 1, 2, 1, 4, 2]) 5 pass","solution":"def longest_subarray_with_sum_at_most_k(n, k, arr): Returns the length of the longest subarray with sum at most k. Parameters: n (int): The number of elements in the array. k (int): The maximum allowed sum of the subarray. arr (list): List of integers representing the array. Returns: int: The length of the longest subarray with sum at most k. max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > k: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def min_possible_max_value(arr: List[int]) -> int: Determine the minimum possible value of the maximum element in the array after performing any number of reduction moves. >>> min_possible_max_value([7, 5, 3, 9, 1]) == 1 >>> min_possible_max_value([4, 4, 4, 4]) == 1 >>> min_possible_max_value([10, 9, 8, 7, 6]) == 1 >>> min_possible_max_value([1000000000, 1000000000, 1000000000]) == 1 >>> min_possible_max_value([1, 2, 3, 4, 5]) == 1 >>> min_possible_max_value([1]) == 1 >>> min_possible_max_value([2, 2, 2, 2, 2]) == 1 >>> min_possible_max_value([1, 3, 3, 6]) == 1","solution":"def min_possible_max_value(arr): Determines the minimum possible value of the maximum element after performing any number of reduction moves. # The smallest possible value of the maximum element is 1, # which is the minimum possible value allowed in the array. return 1"},{"question":"def smallest_missing_positive_integer(n: int, a: List[int]) -> int: Returns the smallest positive integer that does not appear in the array a. >>> smallest_missing_positive_integer(5, [1, 2, 0, -1, 3]) 4 >>> smallest_missing_positive_integer(3, [7, 8, 9]) 1 >>> smallest_missing_positive_integer(4, [-1, -3, 5, 6]) 1","solution":"def smallest_missing_positive_integer(n, a): Returns the smallest positive integer that does not appear in the array a. # Using a set for O(1) average time complexity for membership checks. positive_numbers = set(x for x in a if x > 0) # Start checking from 1 upwards. smallest_missing = 1 while smallest_missing in positive_numbers: smallest_missing += 1 return smallest_missing"},{"question":"def smallest_balanced_substring(t: int, strings: list) -> list: Find the smallest balanced substring in each string from a list of strings. A substring is considered balanced if it contains an equal number of 'x' and 'y'. Args: t: The number of test cases. strings: A list of strings for each test case. Returns: A list of the smallest balanced substrings for each test case, or \\"-1\\" if no balanced substring exists. Examples: >>> smallest_balanced_substring(2, [\\"abxyxybc\\", \\"abacaba\\"]) [\\"xy\\", \\"-1\\"] >>> smallest_balanced_substring(1, [\\"xyxyyxyx\\"]) [\\"xy\\"]","solution":"def smallest_balanced_substring(t, strings): def find_smallest_balanced(s): n = len(s) min_length = float('inf') result = \\"-1\\" for i in range(n): count_x = 0 count_y = 0 for j in range(i, n): if s[j] == 'x': count_x += 1 elif s[j] == 'y': count_y += 1 if count_x == count_y and count_x > 0: current_length = j - i + 1 if current_length < min_length: min_length = current_length result = s[i:j+1] return result results = [] for string in strings: results.append(find_smallest_balanced(string)) return results"},{"question":"def count_distinct_integers(n: int, numbers: List[int]) -> int: Given n and n integers, output the number of distinct integers. Parameters: n (int): The number of integers. numbers (List[int]): The list of integers. Returns: int: The number of distinct integers. Examples: >>> count_distinct_integers(5, [1, 2, 2, 3, 4]) 4 >>> count_distinct_integers(5, [1, 2, 3, 4, 5]) 5 >>> count_distinct_integers(1, [1]) 1 >>> count_distinct_integers(5, [2, 2, 2, 2, 2]) 1 >>> count_distinct_integers(0, []) 0","solution":"def count_distinct_integers(n, numbers): Returns the number of distinct integers from the input list of integers. Parameters: n (int): The number of integers. numbers (list of int): The list of integers. Returns: int: The number of distinct integers. # Convert the numbers list to a set to remove duplicates, and return its length return len(set(numbers))"},{"question":"def reorder_peaks_and_valleys(arr: List[int]) -> List[int]: Reorder the elements in such a way that the array alternates between peaks and valleys. An element is considered a peak if it is not smaller than its neighbors; a valley is an element which is not bigger than its neighbors. For the purpose of this problem, the first element can only have one neighbor, and should therefore be considered a peak or a valley depending on its relation to its single neighbor. >>> reorder_peaks_and_valleys([5, 3, 1, 2, 3]) [3, 5, 1, 3, 2] or [1, 5, 2, 3, 3] - Multiple valid outputs exist >>> reorder_peaks_and_valleys([1]) [1] >>> reorder_peaks_and_valleys([2, 1]) [1, 2] >>> reorder_peaks_and_valleys([3, 1, 2]) [1, 3, 2] or [2, 3, 1] >>> reorder_peaks_and_valleys([4, 4, 4, 4, 4]) [4, 4, 4, 4, 4] >>> reorder_peaks_and_valleys([1, 3, 2, 4, 3]) [1, 3, 2, 4, 3] or other valid outputs >>> reorder_peaks_and_valleys([5, 4, 3, 2, 1]) [1, 3, 2, 5, 4] or other valid outputs","solution":"from typing import List def reorder_peaks_and_valleys(arr: List[int]) -> List[int]: arr.sort() for i in range(1, len(arr), 2): if i + 1 < len(arr): arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr"},{"question":"def distribute_coins(s: int, n: int, coin_values: List[int]) -> str: Determine if coins can be equally distributed among subjects without fractioning any coin. >>> distribute_coins(2, 2, [8, 12]) 'YESn4 6n4 6' >>> distribute_coins(2, 2, [7, 12]) 'NO'","solution":"def distribute_coins(s, n, coin_values): # Check whether each coin value can be evenly distributed among subjects for a in coin_values: if a % s != 0: return \\"NO\\" # Calculate the distribution distribution = [[a // s for a in coin_values] for _ in range(s)] # Generate the output result = [\\"YES\\"] for row in distribution: result.append(\\" \\".join(map(str, row))) return \\"n\\".join(result)"},{"question":"def max_subarray_sum(nums, k): Returns the maximum sum of a non-empty subarray of size k or less. >>> max_subarray_sum([2, 1, 5, 3, 4], 3) 12 >>> max_subarray_sum([-1, -2, -3, -4], 2) -1","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of a non-empty subarray of size k or less. n = len(nums) # Base case if n == 0: return 0 # Initialize the result to a very small number max_sum = float('-inf') # Iterate over all possible subarray sizes from 1 to k for size in range(1, k + 1): # Calculate sum for initial subarray of the current size current_sum = sum(nums[:size]) # Update maximum sum max_sum = max(max_sum, current_sum) # Slide the window of the current size across the array for i in range(size, n): # Slide the window to the right current_sum += nums[i] - nums[i - size] # Update maximum sum max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def are_friends(n, requests, queries): Determine if there is a way to connect two users directly or indirectly through a series of friends. Args: n (int): The number of users. requests (List[Tuple[int, int]]): A list of tuples where each tuple (a, b) represents a friendship accepted between user a and user b. queries (List[Tuple[int, int]]): A list of tuples where each tuple (x, y) needs to be checked if user x and user y are connected. Returns: List[bool]: A list of boolean values, \`True\` if the respective query users are connected, either directly or through other friends, otherwise \`False\`. Example: >>> are_friends(5, [(1, 2), (2, 3), (4, 5)], [(1, 3), (1, 5), (2, 4)]) [True, False, False]","solution":"def are_friends(n, requests, queries): parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for a, b in requests: union(a, b) result = [] for x, y in queries: result.append(find(x) == find(y)) return result"},{"question":"def min_subarray_length(arr, S): Returns the length of the shortest subarray whose sum is greater than or equal to S. If no such subarray exists, returns 0. >>> min_subarray_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) 2 >>> min_subarray_length([1, 2, 3, 4, 5], 100) 0 >>> min_subarray_length([10], 10) 1 >>> min_subarray_length([10, 1, 2, 3, 4], 10) 1 >>> min_subarray_length([1, 2, 3, 4, 10], 10) 1 >>> min_subarray_length([1, 1, 1, 1, 1, 1, 1, 1, 1], 9) 9 >>> min_subarray_length([1, 1, 1, 1], 10) 0","solution":"def min_subarray_length(arr, S): Returns the length of the shortest subarray whose sum is greater than or equal to S. If no such subarray exists, returns 0. n = len(arr) min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= S: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else 0"},{"question":"def minimum_moves_to_equal_stacks(n: int, k: int, heights: List[int]) -> int: Determines the minimum number of moves required to make all stacks equal in height by adding multiples of k boxes to any stack. If it is impossible, returns -1. :param n: Number of stacks :param k: The required multiple of boxes to add in each move :param heights: List of initial heights of the stacks :return: Minimum number of moves or -1 if impossible >>> minimum_moves_to_equal_stacks(4, 3, [6, 9, 15, 12]) 6 >>> minimum_moves_to_equal_stacks(3, 4, [7, 11, 18]) -1","solution":"def minimum_moves_to_equal_stacks(n, k, heights): Determines the minimum number of moves required to make all stack heights equal by adding multiples of k boxes to any stack. If it is impossible, returns -1. :param n: Number of stacks :param k: The required multiple of boxes to add in each move :param heights: List of initial heights of the stacks :return: Minimum number of moves or -1 if impossible # Find the maximum height as the target height for all stacks max_height = max(heights) min_moves = 0 for height in heights: # Check if the difference between max_height and current height can be bridged by adding multiples of k if (max_height - height) % k != 0: return -1 else: min_moves += (max_height - height) // k return min_moves"},{"question":"def detect_cyclic_pattern(n: int, k: int, arr: List[int]) -> str: Returns 'Yes' if there exists a cyclic pattern of length k in the array, otherwise returns 'No'. >>> detect_cyclic_pattern(10, 5, [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]) 'Yes' >>> detect_cyclic_pattern(7, 3, [1, 2, 1, 2, 1, 2, 1]) 'No'","solution":"def detect_cyclic_pattern(n, k, arr): Returns 'Yes' if there exists a cyclic pattern of length k in the array, otherwise returns 'No'. for i in range(n - k): if arr[i] != arr[i + k]: return \\"No\\" return \\"Yes\\""},{"question":"def count_ways_to_select_coins(N: int, T: int, coin_values: List[int]) -> int: Returns the number of ways to select a subset of coins such that the sum is equal to the target T. Input: N: int - the number of coins in Paul's collection. T: int - the target value. coin_values: List[int] - the values of the coins. Output: int - the number of ways to select a subset of coins such that the sum of their values equals T. Example: >>> count_ways_to_select_coins(4, 5, [1, 2, 3, 4]) 2 >>> count_ways_to_select_coins(1, 5, [5]) 1 >>> count_ways_to_select_coins(1, 5, [1]) 0 from solution import count_ways_to_select_coins def test_example_case(): assert count_ways_to_select_coins(4, 5, [1, 2, 3, 4]) == 2 def test_single_coin_case(): assert count_ways_to_select_coins(1, 5, [5]) == 1 assert count_ways_to_select_coins(1, 5, [1]) == 0 def test_multiple_ways(): assert count_ways_to_select_coins(4, 6, [1, 2, 3, 3]) == 3 # Ways: {1, 2, 3}, {3, 3}, {1, 5} def test_no_combination(): assert count_ways_to_select_coins(3, 10, [1, 2, 3]) == 0 def test_duplicate_values(): assert count_ways_to_select_coins(3, 4, [2, 2, 2]) == 3","solution":"def count_ways_to_select_coins(N, T, coin_values): Returns the number of ways to select a subset of coins such that the sum is equal to the target T. from itertools import combinations count = 0 for i in range(1, N + 1): for combo in combinations(coin_values, i): if sum(combo) == T: count += 1 return count"},{"question":"def subset_sum_exists(n: int, T: int, a: List[int]) -> str: Determines if there exists a subset of the list a such that the sum of its elements is exactly equal to T. >>> subset_sum_exists(6, 9, [3, 34, 4, 12, 5, 2]) == \\"YES\\" >>> subset_sum_exists(6, 30, [3, 34, 4, 12, 5, 2]) == \\"NO\\" >>> subset_sum_exists(1, 5, [5]) == \\"YES\\" >>> subset_sum_exists(1, 6, [5]) == \\"NO\\" >>> subset_sum_exists(3, 15, [5, 5, 5]) == \\"YES\\" >>> subset_sum_exists(4, 1000000, [250000, 250000, 250000, 250000]) == \\"YES\\" >>> subset_sum_exists(4, 1000001, [250000, 250000, 250000, 250000]) == \\"NO\\"","solution":"def subset_sum_exists(n, T, a): Determines if there exists a subset of the list a such that the sum of its elements is exactly equal to T. # We use dynamic programming (DP) to solve the subset sum problem. # Create a DP array to store results of subproblems dp = [False] * (T + 1) dp[0] = True # There is always a subset with 0 sum, the empty set # Update the dp array for num in a: for j in range(T, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[T] else \\"NO\\""},{"question":"def sum_of_first_n_odd_integers(n: int) -> int: Calculate the n-th element in the sequence where each element S(n) is defined as the sum of the first n positive odd integers. >>> sum_of_first_n_odd_integers(1) 1 >>> sum_of_first_n_odd_integers(2) 4 >>> sum_of_first_n_odd_integers(3) 9 >>> sum_of_first_n_odd_integers(4) 16 >>> sum_of_first_n_odd_integers(10) 100 >>> sum_of_first_n_odd_integers(15) 225","solution":"def sum_of_first_n_odd_integers(n): Returns the sum of the first n positive odd integers. return n * n"},{"question":"def can_make_all_zero(n: int, m: int, A: List[int], B: List[int]) -> str: Determines if it's possible to make all elements of A zero using the operation described. >>> can_make_all_zero(3, 2, [10, 15, 30], [5, 3]) 'YES' >>> can_make_all_zero(3, 1, [10, 15, 30], [7]) 'NO'","solution":"def can_make_all_zero(n, m, A, B): Determines if it's possible to make all elements of A zero using the operation described. from math import gcd from functools import reduce # Find the greatest common divisor (GCD) of all elements in B def find_gcd_list(lst): return reduce(gcd, lst) gcd_B = find_gcd_list(B) # If each element in A is divisible by the GCD of B, we can make all elements zero for a in A: if a % gcd_B != 0: return \\"NO\\" return \\"YES\\""},{"question":"def get_top_k_scores(n: int, k: int, scores: List[int]) -> List[int]: Returns the top k scores from the list of scores in descending order. Parameters: - n (int): The number of participants. - k (int): The number of top participants to select. - scores (list of int): The scores of the participants. Returns: - list of int: The top k scores in descending order. >>> get_top_k_scores(7, 3, [100, 50, 75, 150, 125, 60, 80]) [150, 125, 100] >>> get_top_k_scores(5, 3, [50, 50, 50, 50, 50]) [50, 50, 50] >>> get_top_k_scores(6, 4, [100, 100, 90, 90, 80, 80]) [100, 100, 90, 90] >>> get_top_k_scores(1, 1, [0]) [0] >>> get_top_k_scores(5, 2, [1_000_000_000, 500_000_000, 750_000_000, 999_999_999, 123_456_789]) [1_000_000_000, 999_999_999]","solution":"def get_top_k_scores(n, k, scores): Returns the top k scores from the list of scores in descending order. Parameters: - n (int): The number of participants. - k (int): The number of top participants to select. - scores (list of int): The scores of the participants. Returns: - list of int: The top k scores in descending order. # Sort the scores in descending order sorted_scores = sorted(scores, reverse=True) # Return the top k scores return sorted_scores[:k]"},{"question":"def find_shortest_path(n: int, m: int, grid: List[List[int]]) -> int: You are given a city grid and it's represented as a 2D array. Each cell in the 2D array represents a city block. The value of the cell can either be 0 (representing an obstacle) or 1 (representing an accessible path). A person can move from one block to any of the four side-adjacent blocks (up, down, left, or right) within one unit of time. Your task is to find the length of the shortest path from the upper-left corner (0, 0) to the lower-right corner (n-1, m-1). If there is no such path, return -1. The function takes three parameters: n (int): The number of rows in the grid m (int): The number of columns in the grid grid (List[List[int]]): The 2D grid representing the city Returns: int: The length of the shortest path from the upper-left corner to the lower-right corner, or -1 if no such path exists. Example: >>> find_shortest_path(4, 4, [[1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1], [1, 1, 1, 1]]) 7 Test Cases: >>> find_shortest_path(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> find_shortest_path(3, 3, [[1, 0, 1], [1, 1, 0], [0, 1, 1]]) 5 >>> find_shortest_path(2, 2, [[1, 0], [0, 1]]) -1","solution":"from collections import deque def shortest_path_in_grid(grid): n = len(grid) m = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def in_bounds(x, y): return 0 <= x < n and 0 <= y < m queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # No path found def find_shortest_path(n, m, grid): return shortest_path_in_grid(grid)"},{"question":"def min_operations_to_reach_target(n: int, initial_list: List[int], target_list: List[int]) -> int: Returns the total number of operations needed to transform the initial list into the target list by subtracting 1 from any element any number of times. >>> min_operations_to_reach_target(4, [10, 20, 30, 40], [5, 15, 25, 35]) 20 >>> min_operations_to_reach_target(1, [10], [5]) 5 >>> min_operations_to_reach_target(3, [100, 200, 300], [50, 150, 250]) 150 >>> min_operations_to_reach_target(3, [30, 40, 50], [30, 40, 50]) 0 >>> min_operations_to_reach_target(2, [1000000000, 1000000000], [1, 1]) 1999999998 pass","solution":"def min_operations_to_reach_target(n, initial_list, target_list): Returns the total number of operations needed to transform the initial list into the target list by subtracting 1 from any element any number of times. total_operations = 0 for initial, target in zip(initial_list, target_list): total_operations += initial - target return total_operations"},{"question":"def find_subgrid_with_sum(n: int, m: int, grid: List[List[int]], k: int) -> bool: Determine if there is a subgrid with a sum equal to k. Args: - n (int): Number of rows in the grid. - m (int): Number of columns in the grid. - grid (List[List[int]]): 2D list representing the grid. - k (int): Desired subgrid sum. Returns: - bool: True if such a subgrid exists, False otherwise. Examples: >>> n = 3 >>> m = 3 >>> grid = [ ... [1, 2, 1], ... [2, -1, 2], ... [3, 0, 1] ... ] >>> k = 4 >>> find_subgrid_with_sum(n, m, grid, k) True >>> k = 10 >>> find_subgrid_with_sum(n, m, grid, k) False","solution":"def find_subgrid_with_sum(n, m, grid, k): def get_prefix_sum_2d(matrix): prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = ( grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] ) return prefix_sum prefix_sum = get_prefix_sum_2d(grid) for top in range(n): for left in range(m): for bottom in range(top, n): for right in range(left, m): subgrid_sum = ( prefix_sum[bottom + 1][right + 1] - prefix_sum[top][right + 1] - prefix_sum[bottom + 1][left] + prefix_sum[top][left] ) if subgrid_sum == k: return True return False"},{"question":"def next_palindrome(n: int) -> int: Find the smallest palindrome larger than the given unsigned integer n. >>> next_palindrome(123) == 131 >>> next_palindrome(99) == 101","solution":"def next_palindrome(n): Returns the smallest palindrome larger than the given integer n. def is_palindrome(x): s = str(x) return s == s[::-1] n += 1 while not is_palindrome(n): n += 1 return n"},{"question":"from typing import List def apply_operations(n: int, q: int, array: List[int], operations: List[List[int]]) -> List[int]: Handle q operations on an array of n integers. Args: n (int): The size of the array. q (int): The number of operations. array (List[int]): The initial elements of the array. operations (List[List[int]]): The list of operations to be performed on the array. Returns: List[int]: The results after performing all type 3 operations. Example: >>> apply_operations(5, 5, [1, 2, 3, 4, 5], [[1, 1, 3, 2], [3, 1, 5], [2, 1, 5, 2], [1, 2, 4, 3], [3, 2, 5]]) [15, 44] >>> apply_operations(1, 3, [10], [[1, 1, 1, 5], [2, 1, 1, 2], [3, 1, 1]]) [30]","solution":"def apply_operations(n, q, array, operations): results = [] for operation in operations: op = operation[0] if op == 1: l, r, x = operation[1] - 1, operation[2] - 1, operation[3] for i in range(l, r + 1): array[i] += x elif op == 2: l, r, x = operation[1] - 1, operation[2] - 1, operation[3] for i in range(l, r + 1): array[i] *= x elif op == 3: l, r = operation[1] - 1, operation[2] - 1 results.append(sum(array[l:r + 1])) return results"},{"question":"def longest_subsequence(nums): Function to find the longest subsequence where the difference between consecutive elements is either 1 or -1. Args: nums (list of int): The input list of integers Returns: int: The length of the longest valid subsequence >>> longest_subsequence([1, 2, 3, 4, 5, 6]) 6 >>> longest_subsequence([10, 9, 4, 5, 4, 3, 2]) 4 >>> longest_subsequence([5, 5, 5, 5]) 1 >>> longest_subsequence([]) 0 >>> longest_subsequence([42]) 1 >>> longest_subsequence([1, 2, 1, 2, 1, 2]) 6 >>> longest_subsequence([1, 7, 8, 3, 4, 5, 6]) 4 >>> longest_subsequence([10, 20, 30, 40, 50]) 1 >>> longest_subsequence([-2, -1, 0, -1, -2]) 5 pass","solution":"def longest_subsequence(nums): Function to find the longest subsequence where the difference between consecutive elements is either 1 or -1. Args: nums (list of int): The input list of integers Returns: int: The length of the longest valid subsequence if not nums: return 0 n = len(nums) longest = [1] * n for i in range(1, n): for j in range(i): if abs(nums[i] - nums[j]) == 1: longest[i] = max(longest[i], longest[j] + 1) return max(longest)"},{"question":"def paint_grid(n: int) -> List[str]: Determines whether it is possible to paint the grid satisfying the given condition of having an even number of painted cells in each row and each column. Returns \\"YES\\" and the grid if possible, \\"NO\\" otherwise. >>> paint_grid(4) [\\"YES\\", \\"1010\\", \\"0101\\", \\"1010\\", \\"0101\\"] >>> paint_grid(3) [\\"NO\\"] >>> paint_grid(2) [\\"YES\\", \\"10\\", \\"01\\"] >>> paint_grid(6) [\\"YES\\", \\"101010\\", \\"010101\\", \\"101010\\", \\"010101\\", \\"101010\\", \\"010101\\"]","solution":"def paint_grid(n): Determines whether it is possible to paint the grid satisfying the given condition of having an even number of painted cells in each row and each column. Returns \\"YES\\" and the grid if possible, \\"NO\\" otherwise. if n % 2 != 0: return [\\"NO\\"] grid = [] for i in range(n): row = [] for j in range(n): if (i + j) % 2 == 0: row.append('1') else: row.append('0') grid.append(\\"\\".join(row)) return [\\"YES\\"] + grid"},{"question":"def count_peaks(n: int, hills: List[int]) -> int: Count the number of peaks in the sequence of hills. Parameters: n (int): Number of hills. hills (list of int): Heights of the hills. Returns: int: Number of peaks in the sequence. >>> count_peaks(5, [1, 3, 2, 4, 1]) == 2 >>> count_peaks(7, [1, 5, 1, 5, 1, 5, 1]) == 3 >>> count_peaks(3, [1, 3, 2]) == 1 >>> count_peaks(3, [5, 1, 5]) == 0 >>> count_peaks(3, [3, 3, 3]) == 0","solution":"def count_peaks(n, hills): Count the number of peaks in the sequence of hills. Parameters: n (int): Number of hills. hills (list of int): Heights of the hills. Returns: int: Number of peaks in the sequence. peak_count = 0 for i in range(1, n - 1): if hills[i] > hills[i - 1] and hills[i] > hills[i + 1]: peak_count += 1 return peak_count"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): Function to insert a new node with the given key in the BST. # Implementation goes here def find_predecessor_successor(root, key): Function to find the predecessor and successor of a given key in BST. Returns a tuple (predecessor, successor) where both are set to -1 if they don't exist. # Implementation goes here def bst_insertion_with_predecessor_successor(n, values): Function to insert nodes into the BST and print their predecessor and successor. # Implementation goes here def bst_predecessor_successor_repr(n, values): Function to return the predecessor and successor of each node in the BST. # Implementation goes here # Unit tests def test_example_case(): n = 5 values = [20, 10, 30, 5, 15] assert bst_predecessor_successor_repr(n, values) == [ \\"-1 -1\\", \\"-1 20\\", \\"20 -1\\", \\"-1 10\\", \\"10 20\\" ] def test_all_increasing(): n = 4 values = [10, 20, 30, 40] assert bst_predecessor_successor_repr(n, values) == [ \\"-1 -1\\", \\"10 -1\\", \\"20 -1\\", \\"30 -1\\" ] def test_all_decreasing(): n = 3 values = [30, 20, 10] assert bst_predecessor_successor_repr(n, values) == [ \\"-1 -1\\", \\"-1 30\\", \\"-1 20\\" ] def test_mixed_values(): n = 4 values = [15, 10, 20, 17] assert bst_predecessor_successor_repr(n, values) == [ \\"-1 -1\\", \\"-1 15\\", \\"15 -1\\", \\"15 20\\" ] def test_single_node(): n = 1 values = [25] assert bst_predecessor_successor_repr(n, values) == [ \\"-1 -1\\" ]","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): Function to insert a new node with the given key in the BST. if root is None: return TreeNode(key) if key < root.val: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def find_predecessor_successor(root, key): Function to find the predecessor and successor of a given key in BST. Returns a tuple (predecessor, successor) where both are set to -1 if they don't exist. successor, predecessor = None, None current = root # Find successor while current: if current.val > key: successor = current.val current = current.left else: current = current.right current = root # Find predecessor while current: if current.val < key: predecessor = current.val current = current.right else: current = current.left return (predecessor if predecessor is not None else -1, successor if successor is not None else -1) def bst_insertion_with_predecessor_successor(n, values): Function to insert nodes into the BST and print their predecessor and successor. root = None result = [] for value in values: pred, succ = find_predecessor_successor(root, value) result.append((pred, succ)) root = insert(root, value) return result def bst_predecessor_successor_repr(n, values): result = bst_insertion_with_predecessor_successor(n, values) return [f\\"{pred} {succ}\\" for pred, succ in result]"},{"question":"def process_operations(operations): Process a series of operations on an initially empty string. Args: operations : list of str : List of operations to be performed. Returns: list of int : List of results for the query operations. The operations can be of three types: - '+ i c': Insert character 'c' at position 'i'. - '- i': Delete the character at position 'i'. - '? s': Query the number of times the substring 's' appears in the current string. Example: >>> process_operations(['+ 0 a', '+ 1 b', '+ 2 c', '? ab', '- 1']) [1, 0]","solution":"def process_operations(operations): Process a series of operations on an initially empty string. Args: operations : list of str : List of operations to be performed. Returns: list of int : List of results for the query operations. s = [] results = [] for operation in operations: if operation[0] == '+': _, i, c = operation.split() i = int(i) s.insert(i, c) elif operation[0] == '-': _, i = operation.split() i = int(i) s.pop(i) elif operation[0] == '?': _, sub = operation.split() current_str = ''.join(s) results.append(current_str.count(sub)) return results"},{"question":"def longest_bitonic_subsequence(arr): Find the length of the longest bitonic subsequence in an array. A bitonic sequence first strictly increases, then strictly decreases. >>> longest_bitonic_subsequence([1, 11, 2, 10, 4, 5, 2, 1]) 6 >>> longest_bitonic_subsequence([12, 11, 40, 5, 3, 1]) 5 >>> longest_bitonic_subsequence([80, 60, 30, 40, 20, 10]) 5 from solution import longest_bitonic_subsequence def test_example_cases(): assert longest_bitonic_subsequence([1, 11, 2, 10, 4, 5, 2, 1]) == 6 assert longest_bitonic_subsequence([12, 11, 40, 5, 3, 1]) == 5 assert longest_bitonic_subsequence([80, 60, 30, 40, 20, 10]) == 5 def test_edge_cases(): assert longest_bitonic_subsequence([]) == 0 assert longest_bitonic_subsequence([1]) == 1 assert longest_bitonic_subsequence([1, 2, 3, 4, 5]) == 5 assert longest_bitonic_subsequence([5, 4, 3, 2, 1]) == 5 def test_general_cases(): assert longest_bitonic_subsequence([1, 2, 3, 4, 3, 2, 1]) == 7 assert longest_bitonic_subsequence([10, 20, 30, 25, 20, 15, 10]) == 7 assert longest_bitonic_subsequence([0, 3, 5, 7, 6, 4, 3, 1]) == 8 assert longest_bitonic_subsequence([10, 20, 30, 40, 50]) == 5 assert longest_bitonic_subsequence([50, 40, 30, 20, 10]) == 5","solution":"def longest_bitonic_subsequence(arr): n = len(arr) if n == 0: return 0 # Arrays to store the maximum increasing subsequence length ending at each element inc = [1] * n dec = [1] * n # Fill the inc array for i in range(1, n): for j in range(i): if arr[i] > arr[j] and inc[i] < inc[j] + 1: inc[i] = inc[j] + 1 # Fill the dec array for i in range(n-2, -1, -1): for j in range(i+1, n): if arr[i] > arr[j] and dec[i] < dec[j] + 1: dec[i] = dec[j] + 1 # Find the maximum length of bitonic subsequence max_length = 0 for i in range(n): max_length = max(max_length, inc[i] + dec[i] - 1) return max_length"},{"question":"def longest_substring_with_k_distinct_characters(k: int, s: str) -> int: Return the length of the longest substring that contains at most k distinct characters. >>> longest_substring_with_k_distinct_characters(2, 'eceba') 3 >>> longest_substring_with_k_distinct_characters(1, 'aaaa') 4 >>> longest_substring_with_k_distinct_characters(1, 'a') 1 >>> longest_substring_with_k_distinct_characters(3, 'abcdef') 3 >>> longest_substring_with_k_distinct_characters(2, 'abcdef') 2 >>> longest_substring_with_k_distinct_characters(2, 'abcba') 3 >>> longest_substring_with_k_distinct_characters(3, 'abcabcabc') 9 >>> longest_substring_with_k_distinct_characters(26, 'abcdefghijklmnopqrstuvwxyz') 26 >>> longest_substring_with_k_distinct_characters(5, 'abc') 3 >>> longest_substring_with_k_distinct_characters(10, 'aaaa') 4 >>> longest_substring_with_k_distinct_characters(1, '') 0 >>> longest_substring_with_k_distinct_characters(0, 'a') 0","solution":"def longest_substring_with_k_distinct_characters(k, s): Return the length of the longest substring that contains at most k distinct characters. from collections import defaultdict if k == 0: return 0 # Sliding window approach with two pointers left, right = 0, 0 max_length = 0 char_count = defaultdict(int) while right < len(s): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root, value): if root is None: return TreeNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) elif value > root.value: root.right = insert_into_bst(root.right, value) return root def build_bst(sequence): Build a binary search tree (BST) from a sequence of integers. If there are duplicate values in the sequence, return -1. def level_order_traversal(root): Perform a level-order traversal (breadth-first traversal) of the BST. def bst_from_sequence(sequence: str): Given a space-separated sequence of integers, construct the corresponding BST and return its values in level-order traversal. If duplicates are found, return -1. >>> bst_from_sequence(\\"5 3 7 2 4 6 8\\") [5, 3, 7, 2, 4, 6, 8] >>> bst_from_sequence(\\"5 3 3 2 4 6 8\\") -1 >>> bst_from_sequence(\\"10\\") [10] >>> bst_from_sequence(\\"\\") [] >>> bst_from_sequence(\\"10 5 1 7 15 12 18\\") [10, 5, 15, 1, 7, 12, 18] >>> bst_from_sequence(\\"-10 0 -20 -5 5 20 15\\") [-10, -20, 0, -5, 5, 20, 15] >>> bst_from_sequence(\\"8 3 10 1 6 14 4 7 13\\") [8, 3, 10, 1, 6, 14, 4, 7, 13]","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root, value): if root is None: return TreeNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) elif value > root.value: root.right = insert_into_bst(root.right, value) return root def build_bst(sequence): if len(sequence) != len(set(sequence)): return -1 # Duplicate values present root = None for value in sequence: root = insert_into_bst(root, value) return root def level_order_traversal(root): if not root: return [] result = [] queue = [root] while queue: current = queue.pop(0) result.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result def bst_from_sequence(sequence): sequence = list(map(int, sequence.split())) bst_root = build_bst(sequence) if bst_root == -1: return -1 return level_order_traversal(bst_root)"},{"question":"from typing import List def find_palindromic_substrings(s: str) -> List[str]: Given a string consisting of lowercase letters and digits, find all possible substrings that are palindromes. Return a list of all unique palindromic substrings sorted first by their length and then lexicographically. >>> find_palindromic_substrings(\\"abba1221\\") ['1', '2', 'a', 'b', '22', 'bb', '1221', 'abba'] >>> find_palindromic_substrings(\\"abcdef\\") ['a', 'b', 'c', 'd', 'e', 'f'] pass def test_single_character(): assert find_palindromic_substrings(\\"a\\") == ['a'] assert find_palindromic_substrings(\\"9\\") == ['9'] def test_two_characters(): assert find_palindromic_substrings(\\"aa\\") == ['a', 'aa'] assert find_palindromic_substrings(\\"ab\\") == ['a', 'b'] def test_common_case(): assert find_palindromic_substrings(\\"abba1221\\") == ['1', '2', 'a', 'b', '22', 'bb', '1221', 'abba'] def test_no_palindromic_substrings(): assert find_palindromic_substrings(\\"abcdef\\") == ['a', 'b', 'c', 'd', 'e', 'f'] def test_repeated_characters(): assert find_palindromic_substrings(\\"aaaa\\") == ['a', 'aa', 'aaa', 'aaaa'] def test_mixed_characters(): assert find_palindromic_substrings(\\"a1bcb2\\") == ['1', '2', 'a', 'b', 'c', 'bcb'] def test_empty_string(): assert find_palindromic_substrings(\\"\\") == []","solution":"def find_palindromic_substrings(s): Returns a list of all unique palindromic substrings in the string s. The list is sorted first by length and then lexicographically. def is_palindrome(sub): return sub == sub[::-1] palindromes = set() for i in range(len(s)): for j in range(i, len(s)): substring = s[i:j+1] if is_palindrome(substring): palindromes.add(substring) palindromes_list = list(palindromes) palindromes_list.sort(key=lambda x: (len(x), x)) return palindromes_list"},{"question":"def can_distribute_masks(mask_ids, num_guests): Check if the given mask IDs can be distributed evenly to the number of guests such that each guest gets one unique mask ID from a continuous range. Parameters: mask_ids (list of int): List of mask IDs num_guests (int): Number of guests Returns: str: \\"Possible\\" if masks can be distributed evenly, otherwise \\"Impossible\\" >>> can_distribute_masks([1, 2, 3, 4, 5], 5) 'Possible' >>> can_distribute_masks([1, 3, 4, 5], 4) 'Impossible' >>> can_distribute_masks([7, 8, 10, 11], 4) 'Impossible' >>> can_distribute_masks([9, 10, 11, 12], 4) 'Possible'","solution":"def can_distribute_masks(mask_ids, num_guests): Check if the given mask IDs can be distributed evenly to the number of guests such that each guest gets one unique mask ID from a continuous range. Parameters: mask_ids (list of int): List of mask IDs num_guests (int): Number of guests Returns: str: \\"Possible\\" if masks can be distributed evenly, otherwise \\"Impossible\\" if len(mask_ids) != num_guests: return \\"Impossible\\" mask_ids_sorted = sorted(mask_ids) for i in range(1, len(mask_ids_sorted)): if mask_ids_sorted[i] != mask_ids_sorted[i - 1] + 1: return \\"Impossible\\" return \\"Possible\\""},{"question":"def process_operations(m: int, operations: List[str]) -> List[int]: Processes a list of operations on an array and outputs the results of query operations. Each operation can be one of the following: 1. Add an element to the end of the array (\`A x\`). 2. Remove an element from the beginning of the array (\`R\`). 3. Query the sum of the array (\`Q\`). Args: m (int): The number of operations. operations (List[str]): The operations in chronological order. Returns: List[int]: The results of the query operations (\`Q\`). >>> process_operations(8, [\\"A 5\\", \\"A 3\\", \\"Q\\", \\"R\\", \\"Q\\", \\"A 10\\", \\"R\\", \\"Q\\"]) [8, 3, 10] >>> process_operations(1, [\\"Q\\"]) [0] >>> process_operations(3, [\\"R\\", \\"A 10\\", \\"Q\\"]) [10] >>> process_operations(6, [\\"A 1\\", \\"A 2\\", \\"A 3\\", \\"Q\\", \\"R\\", \\"Q\\"]) [6, 5] >>> process_operations(4, [\\"A 1000000000\\", \\"A -1000000000\\", \\"Q\\", \\"R\\"]) [0]","solution":"def process_operations(m, operations): array = [] results = [] for operation in operations: if operation.startswith(\\"A\\"): _, x = operation.split() array.append(int(x)) elif operation == \\"R\\": if array: array.pop(0) elif operation == \\"Q\\": results.append(sum(array)) return results"},{"question":"def rearrange_string_no_adjacent(S: str) -> str: Determines whether it is possible to rearrange the characters of S such that no two identical characters are adjacent. If such a rearrangement is possible, returns a valid rearranged string. Otherwise, returns \`-1\`. >>> rearrange_string_no_adjacent(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string_no_adjacent(\\"aaab\\") \\"-1\\"","solution":"def rearrange_string_no_adjacent(S: str) -> str: from collections import Counter import heapq n = len(S) count = Counter(S) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_char, prev_freq = '', 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char, prev_freq = char, freq + 1 if len(result) != n: return '-1' return ''.join(result)"},{"question":"from typing import List def bst_inorder(preorder: List[int]) -> List[int]: Given the preorder traversal of a BST, rebuild the binary search tree and return its inorder traversal. >>> bst_inorder([8, 5, 1, 7, 10, 12]) [1, 5, 7, 8, 10, 12] >>> bst_inorder([10, 5, 1, 7, 40, 50]) [1, 5, 7, 10, 40, 50]","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_inorder(preorder: List[int]) -> List[int]: def build_bst(preorder, start, end): if start > end: return None root = TreeNode(preorder[start]) split_point = start + 1 while split_point <= end and preorder[split_point] < preorder[start]: split_point += 1 root.left = build_bst(preorder, start + 1, split_point - 1) root.right = build_bst(preorder, split_point, end) return root def inorder_traversal(root): if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) root = build_bst(preorder, 0, len(preorder) - 1) return inorder_traversal(root)"},{"question":"def longest_alternating_subsequence(arr: List[int]) -> int: Determine the length of the longest subsequence that alternates between increasing and decreasing. >>> longest_alternating_subsequence([1, 7, 4, 9, 2, 5]) 6 >>> longest_alternating_subsequence([1, 5, 4]) 3 >>> longest_alternating_subsequence([1, 2, 3, 4, 5]) 2 >>> longest_alternating_subsequence([5, 4, 3, 2, 1]) 2","solution":"def longest_alternating_subsequence(arr): if len(arr) == 0: return 0 up = down = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: up = down + 1 elif arr[i] < arr[i - 1]: down = up + 1 return max(up, down)"},{"question":"def reverse_integer(n: int) -> int: Reverses the digits of the input integer while maintaining its sign. >>> reverse_integer(123) 321 >>> reverse_integer(-456) -654 >>> reverse_integer(1200) 21 >>> reverse_integer(0) 0","solution":"def reverse_integer(n): Reverses the digits of the input integer while maintaining its sign. Parameters: n (int): The integer to be reversed. Returns: int: The integer obtained by reversing the digits of n. sign = -1 if n < 0 else 1 reversed_number = int(str(abs(n))[::-1]) return sign * reversed_number"},{"question":"from typing import Tuple, Union def find_two_primes_sum(n: int) -> Union[Tuple[str], Tuple[str, int, int]]: Determines if n can be represented as the sum of exactly two distinct positive integers that are both prime. If possible, return a tuple (\\"YES\\", p1, p2). Otherwise, return (\\"NO\\",). >>> find_two_primes_sum(10) (\\"YES\\", 3, 7) >>> find_two_primes_sum(11) (\\"NO\\",)","solution":"def is_prime(num): Helper function to check if a number is prime if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_two_primes_sum(n): Determines if n can be represented as the sum of exactly two distinct positive integers that are both prime. If possible, return a tuple (\\"YES\\", p1, p2). Otherwise, return (\\"NO\\",). for i in range(2, n): if is_prime(i) and is_prime(n - i): return (\\"YES\\", i, n - i) return (\\"NO\\",) # Debug print statement for internal testing # print(find_two_primes_sum(10)) # Expected output: (\\"YES\\", 3, 7) or similar valid pair # print(find_two_primes_sum(11)) # Expected output: (\\"NO\\",)"},{"question":"def minimum_trucks(n: int, k: int, w: List[int]) -> int: Returns the minimum number of trucks required given the number of boxes, weight capacity of each truck, and the list of box weights. :param n: Integer, number of boxes :param k: Integer, weight capacity of each truck :param w: List of integers, weights of the boxes :return: Integer, minimum number of trucks required >>> minimum_trucks(5, 10, [2, 3, 7, 4, 5]) 3 >>> minimum_trucks(4, 100, [10, 20, 30, 40]) 1 >>> minimum_trucks(3, 10, [10, 10, 10]) 3 >>> minimum_trucks(5, 10, [1, 9, 2, 8, 3]) 3","solution":"def minimum_trucks(n, k, w): Returns the minimum number of trucks required given the number of boxes, weight capacity of each truck, and the list of box weights. :param n: Integer, number of boxes :param k: Integer, weight capacity of each truck :param w: List of integers, weights of the boxes :return: Integer, minimum number of trucks required trucks = 0 current_weight = 0 for weight in w: if current_weight + weight > k: trucks += 1 current_weight = weight else: current_weight += weight if current_weight > 0: trucks += 1 return trucks"},{"question":"def max_filled_cells(n: int, m: int) -> int: Calculate the maximum number of cells that can be filled with the number 1 in an n x m grid such that no two adjacent cells have the number 1. >>> max_filled_cells(1, 1) 1 >>> max_filled_cells(2, 2) 2 >>> max_filled_cells(3, 3) 5 >>> max_filled_cells(4, 4) 8 >>> max_filled_cells(5, 5) 13","solution":"def max_filled_cells(n, m): Calculate the maximum number of cells that can be filled with 1 in an n x m grid such that no two adjacent cells have the number 1. # The strategy is to fill every 2nd cell in a checkerboard pattern. # This will ensure no two adjacent cells are filled with 1. return (n * m + 1) // 2 # This formula works for both even and odd sized grids."},{"question":"def matches_pattern(string: str, pattern: str) -> bool: Determine if the string matches the pattern. The pattern can contain '?' which can match any single character. >>> matches_pattern(\\"abcde\\", \\"a?c?e\\") True >>> matches_pattern(\\"abcde\\", \\"a?c?x\\") False >>> matches_pattern(\\"apple\\", \\"a??le\\") True >>> matches_pattern(\\"banana\\", \\"b?n?n?\\") True","solution":"def matches_pattern(string: str, pattern: str) -> bool: Determine if the string matches the pattern. The pattern can contain '?' which can match any single character. :param string: The string to be matched :param pattern: The pattern to match the string against :return: True if the string matches the pattern, False otherwise if len(string) != len(pattern): return False for ch_str, ch_pat in zip(string, pattern): if ch_pat != '?' and ch_str != ch_pat: return False return True"},{"question":"def count_sunset_buildings(heights: List[int]) -> int: Returns the number of buildings that can see the sunset. >>> count_sunset_buildings([3, 7, 8, 3, 6, 1]) 3 >>> count_sunset_buildings([1, 2, 3, 4, 5]) 1 >>> count_sunset_buildings([5, 4, 3, 2, 1]) 5","solution":"from typing import List def count_sunset_buildings(heights: List[int]) -> int: Returns the number of buildings that can see the sunset. count = 0 max_height = 0 for height in reversed(heights): if height > max_height: count += 1 max_height = height return count"},{"question":"def maximal_square_area(n: int, m: int, grid: List[List[int]]) -> int: Find the largest square containing only 1's and return its area. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : List[List[int]] : a 2D list representing the grid where each value is either 0 or 1 Returns: int : area of the largest square containing only 1's >>> maximal_square_area(4, 5, [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 4 >>> maximal_square_area(2, 2, [ ... [0, 0], ... [0, 0] ... ]) 0","solution":"def maximal_square_area(n, m, grid): if n == 0 or m == 0: return 0 max_side = 0 dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def busiest_walking_day(n: int, steps: List[int]) -> int: Returns the 1-based index of the earliest day with the maximum number of steps. >>> busiest_walking_day(1, [500]) 1 >>> busiest_walking_day(5, [1000, 2000, 3000, 3000, 2000]) 3 >>> busiest_walking_day(4, [1000, 1000, 1000, 1000]) 1 >>> busiest_walking_day(4, [5000, 4000, 3000, 2000]) 1 >>> busiest_walking_day(4, [1000, 2000, 3000, 4000]) 4","solution":"def busiest_walking_day(n, steps): Returns the 1-based index of the earliest day with the maximum number of steps. max_steps = max(steps) for i in range(n): if steps[i] == max_steps: return i + 1"},{"question":"def min_combination_operations(n: int, durabilities: List[int]) -> int: Returns the minimum number of combination operations needed to create the most durable ball of yarn. >>> min_combination_operations(3, [3, 5, 2]) 2 >>> min_combination_operations(4, [1, 3, 4, 7]) 3","solution":"def min_combination_operations(n, durabilities): Returns the minimum number of combination operations needed to create the most durable ball of yarn. import heapq # Convert the list into a min-heap heapq.heapify(durabilities) num_operations = 0 while len(durabilities) > 1: # Combine the two least durable balls first = heapq.heappop(durabilities) second = heapq.heappop(durabilities) new_durability = first + second heapq.heappush(durabilities, new_durability) num_operations += 1 return num_operations"},{"question":"def generate_parentheses(n: int) -> List[str]: Generates all unique combinations of n pairs of balanced parentheses in lexicographical order. >>> generate_parentheses(3) ['((()))', '(()())', '(())()', '()(())', '()()()'] >>> generate_parentheses(1) ['()']","solution":"from typing import List def generate_parentheses(n: int) -> List[str]: Generates all unique combinations of n pairs of balanced parentheses in lexicographical order. def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: # We can still add a '(' backtrack(s + '(', left + 1, right) if right < left: # We can add a ')' if there are more '(' already added backtrack(s + ')', left, right + 1) result = [] backtrack() return result"},{"question":"from typing import List def max_notification_time(intervals: List[int]) -> int: Given an array of integers where each integer represents the preferred notification interval (in minutes) for each team member, returns the least common multiple of the intervals, representing the maximum time it would take for all team members to be notified. >>> max_notification_time([5, 10, 15]) 30 >>> max_notification_time([1, 2, 3]) 6 >>> max_notification_time([7, 5, 6]) 210","solution":"from math import gcd from functools import reduce from typing import List def lcm(a, b): Helper function to calculate the least common multiple of two numbers. return abs(a * b) // gcd(a, b) def max_notification_time(intervals: List[int]) -> int: Given an array of integers where each integer represents the preferred notification interval (in minutes) for each team member, returns the least common multiple of the intervals, representing the maximum time it would take for all team members to be notified. return reduce(lcm, intervals)"},{"question":"def determine_dosage(n: int, health_scores: List[int]) -> List[int]: Determine the dosage for each patient based on their health score. >>> determine_dosage(3, [0, 15, 20]) [50, 50, 50] >>> determine_dosage(3, [21, 30, 40]) [40, 40, 40] >>> determine_dosage(3, [41, 50, 60]) [30, 30, 30] >>> determine_dosage(3, [61, 70, 80]) [20, 20, 20] >>> determine_dosage(3, [81, 90, 100]) [10, 10, 10] >>> determine_dosage(5, [0, 21, 45, 80, 99]) [50, 40, 30, 20, 10] >>> determine_dosage(1, [42]) [30] >>> determine_dosage(1, [0]) [50] >>> determine_dosage(1, [100]) [10] >>> determine_dosage(4, [60, 60, 60, 60]) [30, 30, 30, 30]","solution":"def determine_dosage(n, health_scores): dosages = [] for score in health_scores: if 0 <= score <= 20: dosages.append(50) elif 21 <= score <= 40: dosages.append(40) elif 41 <= score <= 60: dosages.append(30) elif 61 <= score <= 80: dosages.append(20) elif 81 <= score <= 100: dosages.append(10) return dosages # Example usage: n = 5 health_scores = [0, 21, 45, 80, 99] print(determine_dosage(n, health_scores))"},{"question":"def max_points(m: int, n: int, grid: List[List[int]]) -> int: This function returns the maximum points Maria can collect moving from the top row to the bottom row following the allowed moves. Parameters: m (int): The number of rows in the grid. n (int): The number of columns in the grid. grid (List[List[int]]): A 2D list representing the points in each cell of the grid. Returns: int: The maximum points Maria can collect from top to bottom. Examples: >>> max_points(3, 3, [[5, 6, 7], [4, 8, 3], [2, 1, 9]]) 24 >>> max_points(1, 1, [[5]]) 5 from solution import max_points def test_max_points_example(): m, n = 3, 3 grid = [ [5, 6, 7], [4, 8, 3], [2, 1, 9] ] assert max_points(m, n, grid) == 24 def test_max_points_single_element(): m, n = 1, 1 grid = [ [5] ] assert max_points(m, n, grid) == 5 def test_max_points_all_same(): m, n = 3, 3 grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert max_points(m, n, grid) == 3 def test_max_points_large_values(): m, n = 2, 2 grid = [ [1000, 1000], [1000, 1000] ] assert max_points(m, n, grid) == 2000 def test_max_points_non_square_grid(): m, n = 2, 3 grid = [ [1, 2, 3], [4, 5, 6] ] assert max_points(m, n, grid) == 9","solution":"def max_points(m, n, grid): Returns the maximum points Maria can collect moving from the top row to the bottom row following the allowed moves. # Create a DP table with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Initialize the first row of DP table with the grid's first row for j in range(n): dp[0][j] = grid[0][j] # Populate the DP table for i in range(1, m): for j in range(n): # Possible moves from the cell above, diagonal left, or diagonal right top = dp[i-1][j] if j < n else 0 top_left = dp[i-1][j-1] if j-1 >= 0 else 0 top_right = dp[i-1][j+1] if j+1 < n else 0 dp[i][j] = grid[i][j] + max(top, top_left, top_right) # The maximum points collected will be the maximum value in the last row of the DP table return max(dp[m-1])"},{"question":"def min_cuts_to_non_decreasing(trees: List[int]) -> int: Given the heights of all trees in the forest, determine the minimum number of trees Mishka needs to cut down to make the sequence non-decreasing. >>> min_cuts_to_non_decreasing([4, 3, 2, 1, 2, 3, 4]) == 3 >>> min_cuts_to_non_decreasing([5, 4, 3, 2, 1]) == 4 >>> min_cuts_to_non_decreasing([1, 2, 3, 4, 5]) == 0 >>> min_cuts_to_non_decreasing([10]) == 0 >>> min_cuts_to_non_decreasing([1, 1, 1, 1, 1]) == 0 >>> min_cuts_to_non_decreasing([3, 1, 2, 1, 2]) == 2","solution":"def min_cuts_to_non_decreasing(trees): n = len(trees) if n <= 1: return 0 # dp array to store the length of LIS ending at each position dp = [1] * n # Find length of longest increasing subsequence for i in range(1, n): for j in range(i): if trees[i] >= trees[j]: dp[i] = max(dp[i], dp[j] + 1) # The minimum cuts needed is the total number of trees minus the length of the longest increasing subsequence return n - max(dp)"},{"question":"def min_path_cost(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Nora has a directed graph with m edges and n vertices, numerated from 1 to n. Find out the minimum path cost to visit all nodes starting from node 1 and returning to node 1. Nodes can be visited multiple times if necessary. Arguments: n -- number of vertices m -- number of edges edges -- list of tuples representing the edges where each tuple contains three integers u, v, w: u is the starting vertex of the edge, v is the ending vertex of the edge, and w is the weight of the edge. Returns: The minimum path cost to visit all nodes starting from node 1 and returning to node 1. If it is not possible to visit all nodes from node 1, return -1. >>> min_path_cost(4, 6, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1), (1, 3, 4), (2, 4, 4)]) 4 >>> min_path_cost(4, 2, [(1, 2, 1), (2, 3, 1)]) -1 >>> min_path_cost(3, 3, [(1, 2, 2), (2, 3, 2), (3, 1, 2)]) 6","solution":"def min_path_cost(n, m, edges): INF = float('inf') # Initialize the graph distances dist = [[INF] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 for u, v, w in edges: dist[u-1][v-1] = min(dist[u-1][v-1], w) # 1-based to 0-based index conversion # Floyd-Warshall Algorithm to find the shortest paths between all pairs for k in range(n): for i in range(n): for j in range(n): if dist[i][k] < INF and dist[k][j] < INF: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) # If any node is unreachable from node 1 if any(dist[0][i] == INF for i in range(n)): return -1 # DP with bit masking dp = [[INF] * n for _ in range(1 << n)] dp[1][0] = 0 # Start at node 1 (0 in 0-based index) for mask in range(1 << n): for u in range(n): if dp[mask][u] == INF: continue for v in range(n): if mask & (1 << v) == 0: new_mask = mask | (1 << v) dp[new_mask][v] = min(dp[new_mask][v], dp[mask][u] + dist[u][v]) # Minimum cost to visit all nodes and return to start node 1 full_mask = (1 << n) - 1 result = min(dp[full_mask][i] + dist[i][0] for i in range(n)) return -1 if result >= INF else result"},{"question":"from typing import List, Tuple def edmonds_karp(n: int, edges: List[Tuple[int, int, int]]) -> int: Computes the maximum flow from source (location 1) to sink (location n). Args: n (int): The number of locations. edges (List[Tuple[int, int, int]]): List of triples representing the roads where each triple consists of starting location, ending location, and capacity of the road. Returns: int: The maximum number of vehicles that can travel from the source to the sink. Examples: >>> edmonds_karp(4, [(1, 2, 40), (1, 3, 20), (2, 3, 10), (2, 4, 30), (3, 4, 20)]) 50 >>> edmonds_karp(4, [(1, 2, 10), (2, 3, 5), (3, 4, 10)]) 5 pass # Example test cases def test_edmonds_karp(): assert edmonds_karp(4, [(1, 2, 40), (1, 3, 20), (2, 3, 10), (2, 4, 30), (3, 4, 20)]) == 50 assert edmonds_karp(4, [(1, 2, 10), (2, 3, 5), (3, 4, 10)]) == 5 assert edmonds_karp(4, [(1, 2, 100), (1, 3, 100), (2, 3, 1), (2, 4, 100), (3, 4, 100)]) == 200 assert edmonds_karp(4, [(1, 2, 10), (3, 4, 10)]) == 0 assert edmonds_karp(4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 2, 5)]) == 10","solution":"from collections import deque def bfs(capacity, source, sink, parent): Returns true if there is a path from source to sink in residual graph. Also fills parent to store the path. visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for ind, val in enumerate(capacity[u]): if not visited[ind] and val > 0: # if not yet visited and residual capacity > 0 queue.append(ind) visited[ind] = True parent[ind] = u if ind == sink: return True return False def edmonds_karp(n, edges): Returns the maximum flow from source (node 1) to sink (node n) using Edmonds-Karp algorithm which is an implementation of Ford-Fulkerson method. source = 1 sink = n # Make graph with 1-based indexing easier by adding an extra node at index 0 capacity = [[0] * (n + 1) for _ in range(n + 1)] for u, v, c in edges: capacity[u][v] += c # There can be multiple edges between two nodes parent = [-1] * (n + 1) max_flow = 0 while bfs(capacity, source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"def find_all_subsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets (the power set) of the list of unique integers nums. >>> find_all_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> find_all_subsets([1, -1, 2]) [[], [1], [-1], [2], [1, -1], [1, 2], [-1, 2], [1, -1, 2]] from solution import find_all_subsets def test_find_all_subsets_empty(): assert find_all_subsets([]) == [[]] def test_find_all_subsets_single_element(): assert find_all_subsets([1]) == [[], [1]] def test_find_all_subsets_two_elements(): result = find_all_subsets([1, 2]) expected = [[], [1], [2], [1, 2]] assert len(result) == len(expected) for subset in expected: assert subset in result def test_find_all_subsets_three_elements(): result = find_all_subsets([1, 2, 3]) expected = [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] assert len(result) == len(expected) for subset in expected: assert subset in result def test_find_all_subsets_mixed_elements(): result = find_all_subsets([1, -1, 2]) expected = [[], [1], [-1], [2], [1, -1], [1, 2], [-1, 2], [1, -1, 2]] assert len(result) == len(expected) for subset in expected: assert subset in result def test_find_all_subsets_larger_set(): nums = [1, 2, 3, 4] result = find_all_subsets(nums) expected_size = 2 ** len(nums) assert len(result) == expected_size for i in range(expected_size): assert sorted(result[i]) in sorted(result)","solution":"from typing import List def find_all_subsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets (the power set) of the list of unique integers nums. # Initialize the list of subsets with the empty set subsets = [[]] # Iterate over each number in nums for num in nums: # For each existing subset, create a new subset that includes the current number subsets += [current + [num] for current in subsets] return subsets"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers nums and an integer target, find two distinct indices i and j in the array such that nums[i] and nums[j] add up to the target. Parameters: nums (List[int]): List of integers target (int): Target sum Returns: List[int]: A list containing the two indices [i, j] such that nums[i] + nums[j] == target, or an empty list if no such pair exists Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 2, 3], 6) []","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def min_fuel_expenditure(n: int, fuel_costs: List[int]) -> int: Returns the minimum total fuel expenditure required to collect minerals from all asteroids starting from the first asteroid. n: An integer representing the number of asteroids. fuel_costs: A list of integers representing fuel costs between consecutive asteroids. Example: >>> min_fuel_expenditure(5, [4, 2, 5, 3]) 14 >>> min_fuel_expenditure(4, [1, 1, 1]) 3 >>> min_fuel_expenditure(4, [1, 2, 3]) 6 >>> min_fuel_expenditure(4, [3, 2, 1]) 6 >>> min_fuel_expenditure(3, [5, 8]) 13 >>> min_fuel_expenditure(2, [1]) 1 >>> min_fuel_expenditure(100, [i for i in range(1, 100)]) 4950","solution":"def min_fuel_expenditure(n, fuel_costs): Returns the minimum total fuel expenditure required to collect minerals from all asteroids starting from the first asteroid. n: An integer representing the number of asteroids. fuel_costs: A list of integers representing fuel costs between consecutive asteroids. return sum(fuel_costs) # Example usage # print(min_fuel_expenditure(5, [4, 2, 5, 3])) # Should output 14"},{"question":"def smallest_automorphic_number(n: int) -> int: Returns the smallest automorphic number with exactly n digits, or -1 if no such number exists. >>> smallest_automorphic_number(2) 25 >>> smallest_automorphic_number(1) 5 >>> smallest_automorphic_number(3) 376","solution":"def smallest_automorphic_number(n): Returns the smallest automorphic number with exactly n digits, or -1 if no such number exists. if n == 1: return 5 elif n == 2: return 25 else: i = 1 while True: num = int(\\"3\\" + \\"7\\" * (n - 2) + str(i)) if len(str(num)) > n: return -1 square = num ** 2 str_num = str(num) if str(square).endswith(str_num): return num i += 1 if i > 9: return -1"},{"question":"def calculate_total_times(n: int, m: int, runners_data: List[List[Union[str, int]]]) -> List[Tuple[str, int]]: Calculate the total time for each runner. Parameters: n (int): Number of runners m (int): Number of segments runners_data (list): List of runners where each element is a list containing: - the runner's ID (str) - m integers representing the times for each segment Returns: list: List of tuples where each tuple contains the runner's ID and their total time. Example: [(\\"runner1\\", 54), (\\"runner2\\", 62), (\\"runner3\\", 52)] >>> calculate_total_times(3, 4, [[\\"runner1\\", 12, 15, 14, 13], [\\"runner2\\", 10, 20, 15, 17], [\\"runner3\\", 11, 13, 16, 12]]) [(\\"runner1\\", 54), (\\"runner2\\", 62), (\\"runner3\\", 52)] >>> calculate_total_times(1, 3, [[\\"runner1\\", 5, 10, 15]]) [(\\"runner1\\", 30)] >>> calculate_total_times(2, 5, [[\\"runner1\\", 1, 1, 1, 1, 1], [\\"runner2\\", 2, 2, 2, 2, 2]]) [(\\"runner1\\", 5), (\\"runner2\\", 10)] >>> calculate_total_times(4, 3, [[\\"runner1\\", 6, 7, 8], [\\"runner2\\", 9, 10, 11], [\\"runner3\\", 12, 13, 14], [\\"runner4\\", 15, 16, 17]]) [(\\"runner1\\", 21), (\\"runner2\\", 30), (\\"runner3\\", 39), (\\"runner4\\", 48)]","solution":"def calculate_total_times(n, m, runners_data): Calculate the total time for each runner. Parameters: n (int): Number of runners m (int): Number of segments runners_data (list): List of runners where each element is a list containing: - the runner's ID (str) - m integers representing the times for each segment Returns: list: List of tuples where each tuple contains the runner's ID and their total time. Example: [(\\"runner1\\", 54), (\\"runner2\\", 62), (\\"runner3\\", 52)] total_times = [] for runner in runners_data: runner_id = runner[0] times = map(int, runner[1:]) total_time = sum(times) total_times.append((runner_id, total_time)) return total_times"},{"question":"import math def minimum_batches(n: int, m: int) -> int: Returns the minimum number of batches needed to bake at least n cupcakes, given m compartments in each tray. >>> minimum_batches(55, 12) 5 >>> minimum_batches(100, 10) 10 >>> minimum_batches(1, 10) 1 >>> minimum_batches(9, 10) 1 >>> minimum_batches(1000, 100) 10 >>> minimum_batches(1000, 1) 1000 >>> minimum_batches(987, 15) 66 >>> minimum_batches(101, 10) 11","solution":"import math def minimum_batches(n, m): Returns the minimum number of batches needed to bake at least n cupcakes, given m compartments in each tray. return math.ceil(n / m)"},{"question":"from typing import List, Tuple def is_possible_to_connect(n: int, m: int, d: int, edges: List[Tuple[int, int]]) -> str: Determine if it is possible to connect all rooms in the castle under given constraints. n: Number of rooms m: Number of existing hallways d: Maximum degree limit for each room edges: List of tuples representing the hallways between rooms Returns \\"Yes\\" if it's possible to design the castle, otherwise \\"No\\" >>> is_possible_to_connect(4, 3, 2, [(1, 2), (2, 3), (3, 4)]) \\"Yes\\" >>> is_possible_to_connect(4, 2, 1, [(1, 2), (3, 4)]) \\"No\\" def test_possible_case(): n, m, d = 4, 3, 2 edges = [(1, 2), (2, 3), (3, 4)] assert is_possible_to_connect(n, m, d, edges) == \\"Yes\\" def test_impossible_case_disconnected(): n, m, d = 4, 2, 1 edges = [(1, 2), (3, 4)] assert is_possible_to_connect(n, m, d, edges) == \\"No\\" def test_impossible_case_degree(): n, m, d = 4, 4, 2 edges = [(1, 2), (2, 3), (3, 4), (1, 3)] assert is_possible_to_connect(n, m, d, edges) == \\"No\\" def test_min_case(): n, m, d = 1, 0, 1 edges = [] assert is_possible_to_connect(n, m, d, edges) == \\"Yes\\" def test_max_case_degree_ok(): n, m, d = 5, 4, 3 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert is_possible_to_connect(n, m, d, edges) == \\"Yes\\" def test_edge_case_large_degree(): n, m, d = 6, 5, 2 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert is_possible_to_connect(n, m, d, edges) == \\"Yes\\"","solution":"def is_possible_to_connect(n, m, d, edges): from collections import defaultdict, deque # Adjacency list for the graph graph = defaultdict(list) # Degree of each node degree = [0] * (n + 1) # Build the graph and track the degree of each node for u, v in edges: graph[u].append(v) graph[v].append(u) degree[u] += 1 degree[v] += 1 # Check if there is any node that has a degree exceeding the limit d for i in range(1, n + 1): if degree[i] > d: return \\"No\\" # Function to check if the graph is connected def is_connected(): visited = [False] * (n + 1) queue = deque([1]) visited[1] = True count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return count == n # Check if all nodes are connected if is_connected(): return \\"Yes\\" else: return \\"No\\""},{"question":"def max_gold_collected(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determines the maximum amount of gold that can be collected from top-left to bottom-right in each grid of the given test cases. :param t: Number of test cases :param test_cases: A list of test cases where each test case is a tuple containing the dimensions of the grid and the grid itself :return: A list of integers representing the maximum gold collected for each test case >>> max_gold_collected(2, [(2, 2, [[1, 3], [4, 2]]), (3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])]) [7, 29] >>> max_gold_collected(1, [(1, 1, [[0]])]) [0] >>> max_gold_collected(1, [(1, 3, [[5, 10, 15]])]) [30] >>> max_gold_collected(1, [(3, 3, [[1, 3, 1], [2, 1, 1], [1, 5, 1]])]) [11] >>> max_gold_collected(1, [(1, 1, [[100]])]) [100]","solution":"def max_gold_collected(t, test_cases): Determines the maximum amount of gold that can be collected from top-left to bottom-right in each grid of the given test cases. :param t: Number of test cases :param test_cases: A list of test cases where each test case is a tuple containing the dimensions of the grid and the grid itself :return: A list of integers representing the maximum gold collected for each test case results = [] for testcase in test_cases: n, m, grid = testcase # Initialize a DP table where dp[i][j] will store the max gold collected to reach cell (i, j) dp = [[0] * m for _ in range(n)] # Base case: Starting point is the value of the top-left cell dp[0][0] = grid[0][0] # Fill the first row (can only move from left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only move from top) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer for the current test case is the value at the bottom-right corner results.append(dp[n-1][m-1]) return results"},{"question":"def minimum_subset_difference(weights: List[int]) -> int: Partition the given integer array into two subsets such that the absolute difference of the sums of the weights of the subsets is minimized. Returns the minimum possible absolute difference. >>> minimum_subset_difference([1, 6, 11, 5]) 1 >>> minimum_subset_difference([3, 3, 3, 3]) 0 >>> minimum_subset_difference([1, 4]) 3 >>> minimum_subset_difference([5]) 5 >>> minimum_subset_difference([20, 30, 50, 60]) 0 >>> minimum_subset_difference([1, 99]) 98","solution":"from typing import List def minimum_subset_difference(weights: List[int]) -> int: total_sum = sum(weights) n = len(weights) # Initialize DP table dp = [[False] * (total_sum + 1) for _ in range(n + 1)] # There is always a subset with sum 0 for i in range(n + 1): dp[i][0] = True # Fill DP table for i in range(1, n + 1): for j in range(1, total_sum + 1): if weights[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - weights[i - 1]] else: dp[i][j] = dp[i - 1][j] # Find the minimum difference min_diff = float('inf') for s1 in range(total_sum // 2 + 1): if dp[n][s1]: min_diff = min(min_diff, total_sum - 2 * s1) return min_diff"},{"question":"def track_billboard_usage(n: int, m: int, reservations: List[Tuple[int, int]]) -> List[int]: Keep track of the total number of different minutes during which advertisements are displayed on a billboard. After each reservation, recalculate and report the total number of minutes during which the billboard is being utilized by any advertisement. >>> track_billboard_usage(3, 0, [(1, 3), (2, 5), (6, 8)]) [3, 5, 8] >>> track_billboard_usage(1, 0, [(1, 2)]) [2] >>> track_billboard_usage(2, 0, [(5, 10), (8, 12)]) [6, 8] >>> track_billboard_usage(4, 0, [(1, 5), (2, 6), (10, 15), (11, 13)]) [5, 6, 12, 12] >>> track_billboard_usage(3, 0, [(1, 1), (2, 2), (1, 2)]) [1, 2, 2]","solution":"def track_billboard_usage(n, m, reservations): usage_times = set() results = [] for start, end in reservations: for minute in range(start, end + 1): usage_times.add(minute) results.append(len(usage_times)) return results"},{"question":"def find_minimum_subarray_sum(nums: List[int], s: int) -> int: Write a function find_minimum_subarray_sum(nums, s) that takes an array of integers nums and an integer s. The function should find the length of the smallest contiguous subarray whose sum is at least s. If there isn't one, return 0 instead. >>> find_minimum_subarray_sum([2, 3, 1, 2, 4, 3], 7) 2 >>> find_minimum_subarray_sum([1, 4, 4], 4) 1 >>> find_minimum_subarray_sum([1, 2, 3, 4, 5], 11) 3 >>> find_minimum_subarray_sum([1, 1, 1, 1, 1], 11) 0","solution":"def find_minimum_subarray_sum(nums, s): Finds the length of the smallest contiguous subarray whose sum is at least s. If no such subarray exists, returns 0. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= s: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"from typing import List, Tuple def min_moves_to_remove_string(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Find the minimum number of moves required to remove the entire string by repeatedly picking a palindromic substring and removing it. Args: t: Number of test cases. test_cases: A list of tuples, where each tuple contains an integer \`n\` and a string \`s\`. Returns: A list of integers, each representing the minimum number of moves required for the corresponding test case. >>> t = 3 >>> test_cases = [(3, 'aba'), (4, 'abba'), (5, 'abcde')] >>> min_moves_to_remove_string(t, test_cases) [1, 1, 2]","solution":"def min_moves_to_remove_string(t, test_cases): result = [] for n, s in test_cases: if s == s[::-1]: result.append(1) else: result.append(2) return result"},{"question":"def max_min_elevation(grid: List[List[int]]) -> int: Find the most elevated path from the top-left corner (0,0) to the bottom-right corner (n-1, m-1) of the grid, where each cell contains an integer representing the elevation of that cell. The path is defined in such a way that you can only move right or down at each step. The elevation of a path is determined by the minimum elevation encountered along that path, and the function should return the path that maximizes this minimum elevation. >>> max_min_elevation([ ... [8, 4, 1], ... [6, 5, 7], ... [3, 2, 9] ... ]) 5 >>> max_min_elevation([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_min_elevation([ ... [9, 1], ... [1, 9] ... ]) 1 >>> max_min_elevation([ ... [3, 4, 5], ... [3, 2, 6], ... [7, 8, 9] ... ]) 3 >>> max_min_elevation([ ... [1] ... ]) 1","solution":"def max_min_elevation(grid): n = len(grid) m = len(grid[0]) # Create a dp array dp = [[-1] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(n): for j in range(m): if i > 0: dp[i][j] = max(dp[i][j], min(dp[i-1][j], grid[i][j])) if j > 0: dp[i][j] = max(dp[i][j], min(dp[i][j-1], grid[i][j])) return dp[n-1][m-1]"},{"question":"from typing import List def count_teams(n: int, t: int, skills: List[int]) -> int: Alex wants to form teams of exactly t participants such that each team has participants with different skills. Given n participants and their respective skills, determine the number of ways Alex can form the teams. The result should be output modulo (109 + 7). Args: n (int): Number of participants. t (int): Number of participants in each team. skills (List[int]): List of skills of each participant. Returns: int: Number of ways to form the teams. Example: >>> count_teams(5, 3, [1, 2, 3, 2, 1]) 4 >>> count_teams(3, 4, [1, 1, 1]) 0 >>> count_teams(5, 3, [1, 2, 3, 4, 5]) 10 >>> count_teams(4, 2, [1, 1, 2, 2]) 4 >>> count_teams(50, 1, [i % 50 + 1 for i in range(50)]) 50","solution":"from itertools import combinations from collections import Counter MOD = 10**9 + 7 def count_teams(n, t, skills): Returns the number of ways to form teams with exactly t participants such that each team has different skills. # Count the number of participants with each skill skill_count = Counter(skills) # List of distinct skills available distinct_skills = list(skill_count.keys()) # If there are less skills than required participants in a team, no team is possible if len(distinct_skills) < t: return 0 # Generate all combinations of t distinct skills skill_combinations = list(combinations(distinct_skills, t)) total_teams = 0 for comb in skill_combinations: # Calculate the product of participants count for the chosen combination of skills team_count = 1 for skill in comb: team_count = (team_count * skill_count[skill]) % MOD # Add the number of such teams to the total total_teams = (total_teams + team_count) % MOD return total_teams"},{"question":"def count_distinct_characters(s: str, queries: List[Tuple[int, int]]) -> List[int]: For each query, determine the number of distinct characters in the specified substring. >>> count_distinct_characters(\\"ababcabb\\", [(1, 3), (2, 6), (4, 8)]) [2, 3, 3] >>> count_distinct_characters(\\"abcdef\\", [(3, 3)]) [1]","solution":"def count_distinct_characters(s, queries): For each query, determine the number of distinct characters in the specified substring. Parameters: s (str): The input string queries (list of tuples): A list of tuples where each tuple contains two integers (l, r) Returns: list: A list of integers where each integer represents the number of distinct characters for the corresponding query result = [] for l, r in queries: # Subtract 1 from l and r to convert to 0-based indexing substring = s[l-1:r] distinct_count = len(set(substring)) result.append(distinct_count) return result def process_input(input_string): input_data = input_string.split('n') s = input_data[0] q = int(input_data[1]) queries = [] for i in range(2, 2 + q): l, r = map(int, input_data[i].split()) queries.append((l, r)) return s, queries # Example input data as a string input_string = ababcabb 3 1 3 2 6 4 8 s, queries = process_input(input_string) result = count_distinct_characters(s, queries) print(\\"n\\".join(map(str, result)))"},{"question":"def sort_words(input_str: str) -> str: Sort the words in a string alphabetically (case-insensitive), maintaining the original case. >>> sort_words(\\"Banana apple cherry\\") 'apple Banana cherry' >>> sort_words(\\"Hello world\\") 'Hello world' >>> sort_words(\\"A quick brown fox jumps over the lazy dog\\") 'A brown dog fox jumps lazy over quick the'","solution":"def sort_words(input_str: str) -> str: Sorts the words in a string in alphabetical order, case-insensitive, while maintaining the original case and ignoring extra spaces between words. # Split the input string into words words = input_str.split() # Sort the words in a case-insensitive manner sorted_words = sorted(words, key=str.lower) # Join the sorted words back into a single string with a single space between each sorted_str = ' '.join(sorted_words) return sorted_str"},{"question":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): Insert a node with the given key into the binary search tree. def _insert(self, root, key): Helper function to insert a node with the given key into the binary search tree. def remove(self, key): Remove the node with the given key from the binary search tree. def _remove(self, root, key): Helper function to remove the node with the given key from the binary search tree. def _minValueNode(self, node): Helper function to find the node with the minimum key in the given subtree. def find_max(self): Return the maximum value in the current tree. def _find_max(self, node): Helper function to find the node with the maximum key in the given subtree. def execute_operations(operations): Execute a series of operations on an initially empty binary search tree, returning the result of \\"Max\\" queries. Args: operations (List[str]): List of operations (\\"Insert x\\", \\"Remove x\\", \\"Max\\"). Returns: List[int]: List of results for each \\"Max\\" query. >>> execute_operations([\\"Insert 10\\", \\"Insert 5\\", \\"Insert 20\\", \\"Max\\", \\"Remove 20\\", \\"Max\\", \\"Insert 15\\", \\"Max\\"]) [20, 10, 15] bst = BinarySearchTree() results = [] for operation in operations: if operation.startswith(\\"Insert\\"): _, value = operation.split() bst.insert(int(value)) elif operation.startswith(\\"Remove\\"): _, value = operation.split() bst.remove(int(value)) elif operation == \\"Max\\": results.append(bst.find_max()) return results # Unit tests import pytest def test_example_case(): operations = [ \\"Insert 10\\", \\"Insert 5\\", \\"Insert 20\\", \\"Max\\", \\"Remove 20\\", \\"Max\\", \\"Insert 15\\", \\"Max\\" ] assert execute_operations(operations) == [20, 10, 15] def test_multiple_inserts(): operations = [ \\"Insert 3\\", \\"Insert 1\\", \\"Insert 2\\", \\"Insert 5\\", \\"Insert 4\\", \\"Insert 10\\", \\"Max\\" ] assert execute_operations(operations) == [10] def test_remove_root_node(): operations = [ \\"Insert 30\\", \\"Insert 20\\", \\"Insert 40\\", \\"Max\\", \\"Remove 30\\", \\"Max\\" ] assert execute_operations(operations) == [40, 40] def test_insertions_and_removals(): operations = [ \\"Insert 50\\", \\"Insert 30\\", \\"Insert 70\\", \\"Insert 20\\", \\"Insert 40\\", \\"Insert 60\\", \\"Insert 80\\", \\"Max\\", \\"Remove 80\\", \\"Max\\", \\"Remove 70\\", \\"Max\\", \\"Remove 50\\", \\"Max\\" ] assert execute_operations(operations) == [80, 70, 60, 60] def test_single_element_operations(): operations = [ \\"Insert 15\\", \\"Max\\", \\"Remove 15\\" ] # No max call expected after the Remove operation (since no Max operation) assert execute_operations(operations) == [15]","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, root, key): if root is None: return TreeNode(key) if key < root.key: root.left = self._insert(root.left, key) elif key > root.key: root.right = self._insert(root.right, key) return root def remove(self, key): self.root = self._remove(self.root, key) def _remove(self, root, key): if root is None: return root if key < root.key: root.left = self._remove(root.left, key) elif key > root.key: root.right = self._remove(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self._minValueNode(root.right) root.key = temp.key root.right = self._remove(root.right, temp.key) return root def _minValueNode(self, node): current = node while current.left is not None: current = current.left return current def find_max(self): if self.root is None: return None return self._find_max(self.root) def _find_max(self, node): current = node while current.right is not None: current = current.right return current.key def execute_operations(operations): bst = BinarySearchTree() results = [] for operation in operations: if operation.startswith(\\"Insert\\"): _, value = operation.split() bst.insert(int(value)) elif operation.startswith(\\"Remove\\"): _, value = operation.split() bst.remove(int(value)) elif operation == \\"Max\\": results.append(bst.find_max()) return results"},{"question":"def final_state_after_game(t: int, test_cases: List[str]) -> List[str]: Determine the final state of each binary string after Alice and Bob's game. Parameters: t (int): The number of test cases. test_cases (List[str]): A list of binary strings. Returns: List[str]: The final state of each binary string after the game is over. >>> final_state_after_game(3, [\\"1\\", \\"111\\", \\"10101\\"]) [\\"0\\", \\"000\\", \\"00000\\"] >>> final_state_after_game(2, [\\"0\\", \\"000\\"]) [\\"0\\", \\"000\\"]","solution":"def final_state_after_game(t, test_cases): results = [] for s in test_cases: # As Alice starts, she will always flip all characters to '0' results.append(\\"0\\" * len(s)) return results"},{"question":"def highest_possible_sum(n: int, T: int, power_levels: List[int]) -> int: This function returns the highest sum of a subset of power_levels that does not exceed T. >>> highest_possible_sum(5, 16, [4, 2, 10, 5, 3]) 16 >>> highest_possible_sum(4, 10, [1, 2, 3, 4]) 10 >>> highest_possible_sum(3, 15, [5, 5, 5]) 15 >>> highest_possible_sum(5, 20, [10, 7, 5, 12, 8]) 20","solution":"def highest_possible_sum(n, T, power_levels): This function returns the highest sum of a subset of power_levels that does not exceed T. dp = [0] * (T + 1) for power in power_levels: for t in range(T, power - 1, -1): dp[t] = max(dp[t], dp[t - power] + power) return dp[T]"},{"question":"def can_make_all_equal_by_one_flip(n: int, s: str) -> str: Determines if it's possible to make all characters in the given binary string equal by flipping at most one contiguous subsegment of bits. Parameters: n (int): Length of the binary string. s (str): Binary string of length n. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". pass # Unit tests def test_single_char(): assert can_make_all_equal_by_one_flip(1, \\"0\\") == \\"YES\\" assert can_make_all_equal_by_one_flip(1, \\"1\\") == \\"YES\\" def test_all_same_char(): assert can_make_all_equal_by_one_flip(3, \\"111\\") == \\"YES\\" assert can_make_all_equal_by_one_flip(4, \\"0000\\") == \\"YES\\" def test_one_flip_needed(): assert can_make_all_equal_by_one_flip(5, \\"11011\\") == \\"YES\\" assert can_make_all_equal_by_one_flip(4, \\"0011\\") == \\"YES\\" def test_no_possible_flip(): assert can_make_all_equal_by_one_flip(6, \\"101010\\") == \\"NO\\" assert can_make_all_equal_by_one_flip(6, \\"010101\\") == \\"NO\\" def test_edge_cases(): assert can_make_all_equal_by_one_flip(2, \\"01\\") == \\"YES\\" assert can_make_all_equal_by_one_flip(2, \\"00\\") == \\"YES\\" assert can_make_all_equal_by_one_flip(2, \\"11\\") == \\"YES\\" assert can_make_all_equal_by_one_flip(3, \\"100\\") == \\"YES\\" assert can_make_all_equal_by_one_flip(3, \\"001\\") == \\"YES\\"","solution":"def can_make_all_equal_by_one_flip(n, s): Determines if it's possible to make all characters in the given binary string equal by flipping at most one contiguous subsegment of bits. Parameters: n (int): Length of the binary string. s (str): Binary string of length n. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". # To find at most one contiguous subsegment of each bit '0'/'1' in the string count_zeros = 0 count_ones = 0 i = 0 while i < n: if s[i] == '0': while i < n and s[i] == '0': i += 1 count_zeros += 1 elif s[i] == '1': while i < n and s[i] == '1': i += 1 count_ones += 1 # We can flip one segment, so only one segment each of '0s' and '1s' is allowed. if count_zeros <= 1 or count_ones <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def large_number_addition(test_cases): Given a list of tuples representing large numbers as strings, return the sum of each pair of large numbers. >>> large_number_addition([(\\"123456789123456789\\", \\"987654321987654321\\")]) [\\"1111111111111111110\\"] >>> large_number_addition([(\\"100000000000000000000\\", \\"111111111111111111111\\")]) [\\"211111111111111111111\\"]","solution":"def large_number_addition(test_cases): Given a list of tuples representing large numbers as strings, return the sum of each pair of large numbers. results = [] for a, b in test_cases: sum_ab = str(int(a) + int(b)) results.append(sum_ab) return results"},{"question":"from typing import List, Tuple def can_reach(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Determine if there is a valid path from a start department to an end department in a directed graph representing the information flow between departments. Args: n (int): Number of departments (nodes in the graph) edges (List[Tuple[int, int]]): List of directed edges representing the information channels queries (List[Tuple[int, int]]): List of queries asking if there's a path from one department to another Returns: List[str]: \\"Reachable\\" if the path exists, otherwise \\"Not Reachable\\" Example: >>> can_reach(4, [(1, 2), (2, 3), (3, 4), (1, 4)], [(1, 4), (1, 3), (2, 4), (3, 1)]) ['Reachable', 'Reachable', 'Reachable', 'Not Reachable'] >>> can_reach(4, [(1, 2), (2, 3), (3, 4)], [(4, 1), (3, 1), (2, 1)]) ['Not Reachable', 'Not Reachable', 'Not Reachable']","solution":"from collections import defaultdict, deque def can_reach(n, edges, queries): def bfs(start, target): queue = deque([start]) visited = set([start]) while queue: node = queue.popleft() if node == target: return \\"Reachable\\" for next_node in graph[node]: if next_node not in visited: visited.add(next_node) queue.append(next_node) return \\"Not Reachable\\" # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Process each query and determine reachability results = [] for si, ti in queries: results.append(bfs(si, ti)) return results"},{"question":"def num_decodings(n: int) -> int: Write a function that takes a positive integer n and returns the number of ways to decode it. The integer n can be thought of as an encoded message, where each number from 1 to 26 represents a corresponding letter in the alphabet ('A' = 1, 'B' = 2, ..., 'Z' = 26). The decoding should follow these rules: 1. The input integer does not contain leading zeros. 2. The encoding must be valid, meaning it can be split into numbers from 1 to 26. >>> num_decodings(226) 3 >>> num_decodings(123) 3 >>> num_decodings(10) 1","solution":"def num_decodings(n: int) -> int: s = str(n) if not s or s[0] == '0': return 0 dp = [0] * (len(s) + 1) dp[0] = 1 dp[1] = 1 if s[0] != '0' else 0 for i in range(2, len(s) + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[len(s)]"},{"question":"def find_valid_subarray_divisible_by_3(n: int, a: List[int]) -> Tuple[str, List[int]]: Find any valid subarray of length m in array a where the sum of the elements in the subarray is divisible by 3. Print \\"NO\\" if there is no valid subarray in the array a. Otherwise, print \\"YES\\" followed by the valid subarray. >>> find_valid_subarray_divisible_by_3(1, [3]) (\\"YES\\", [3]) >>> find_valid_subarray_divisible_by_3(1, [1]) (\\"NO\\", []) >>> find_valid_subarray_divisible_by_3(2, [1, 2]) (\\"YES\\", [1, 2]) >>> find_valid_subarray_divisible_by_3(2, [1, 4]) (\\"NO\\", []) >>> find_valid_subarray_divisible_by_3(3, [3, 1, 2]) (\\"YES\\", [3]) >>> find_valid_subarray_divisible_by_3(4, [1, 2, 4, 5]) (\\"YES\\", [1, 2])","solution":"def find_valid_subarray_divisible_by_3(n, a): for i in range(n): if a[i] % 3 == 0: return \\"YES\\", [a[i]] if i < n - 1: if (a[i] + a[i + 1]) % 3 == 0: return \\"YES\\", [a[i], a[i + 1]] return \\"NO\\", []"},{"question":"from typing import List def count_islands(grid: List[List[int]]) -> int: Count the number of islands in a grid. An island is a group of connected \\"land\\" cells. Two cells are connected if they are adjacent horizontally or vertically. >>> count_islands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 0, 0] ... ]) 3 >>> count_islands([ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) 0 >>> count_islands([ ... [1] ... ]) 1 >>> count_islands([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 5","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: if not grid: return 0 def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 0: return grid[x][y] = 0 # Mark as visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) n = len(grid) m = len(grid[0]) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: dfs(i, j) island_count += 1 return island_count"},{"question":"def min_subarrays_required(n: int, k: int, arr: List[int]) -> int: Returns the minimum number of subarrays required to partition the array such that each subarray contains at least one element and the absolute difference between the maximum and minimum elements in each subarray is at most k. >>> min_subarrays_required(5, 3, [1, 5, 6, 7, 10]) 3 >>> min_subarrays_required(5, 0, [1, 1, 1, 1, 1]) 1 >>> min_subarrays_required(5, 0, [1, 2, 3, 4, 5]) 5 >>> min_subarrays_required(0, 3, []) 0 >>> min_subarrays_required(1, 3, [5]) 1 >>> min_subarrays_required(5, 100000, [1, 328, 2345, 76542, 2341]) 1 >>> min_subarrays_required(6, 1000000, [100, 200, 300, 400, 500, 600]) 1 >>> min_subarrays_required(6, 10, [1, 1, 1, 1, 1, 2]) 1 >>> min_subarrays_required(6, 0, [1, 1, 2, 2, 3, 3]) 3 >>> min_subarrays_required(4, -1, [1, 2, 3, 4]) 4","solution":"def min_subarrays_required(n, k, arr): Returns the minimum number of subarrays required to partition the array such that each subarray contains at least one element and the absolute difference between the maximum and minimum elements in each subarray is at most k. if n == 0: return 0 # Initialize counters num_subarrays = 1 min_element = arr[0] max_element = arr[0] for i in range(1, n): min_element = min(min_element, arr[i]) max_element = max(max_element, arr[i]) # If the current max - min exceeds k, start a new subarray if max_element - min_element > k: num_subarrays += 1 min_element = arr[i] max_element = arr[i] return num_subarrays"},{"question":"def rotate_string(n: int, s: str) -> str: Rotates the string s to the right by n positions. If n is greater than the length of s, it rotates as n modulo length of s. >>> rotate_string(0, \\"abcdef\\") \\"abcdef\\" >>> rotate_string(6, \\"abcdef\\") \\"abcdef\\" >>> rotate_string(2, \\"abcdef\\") \\"efabcd\\" >>> rotate_string(8, \\"abcdef\\") \\"efabcd\\" >>> rotate_string(4, \\"a\\") \\"a\\" >>> rotate_string(12, \\"abcdef\\") \\"abcdef\\"","solution":"def rotate_string(n, s): Rotates the string s to the right by n positions. If n is greater than the length of s, it rotates as n modulo length of s. length = len(s) n = n % length # Handle if n is greater than length of s return s[-n:] + s[:-n]"},{"question":"def find_parking_spot(parking_lot: List[List[int]], row: int) -> int: Returns the index of the first available parking spot (0) in the given row. If no spots are available, returns -1. :param parking_lot: List[List[int]] - a 2D list representing the parking lot. :param row: int - the row number to search for an available spot. :return: int - the index of the first available spot or -1 if no spots are available. >>> find_parking_spot([[0, 1], [1, 1]], 0) 0 >>> find_parking_spot([[1, 1, 0], [1, 1, 1]], 0) 2 >>> find_parking_spot([[1, 1], [1, 1]], 0) -1 >>> find_parking_spot([[1, 0, 1], [0, 1, 1]], 0) 1 >>> find_parking_spot([[1], [0]], 1) 0 >>> find_parking_spot([[0, 0, 0], [1, 1, 1]], 0) 0 >>> find_parking_spot([[1, 1], [1, 1], [0]], 2) 0","solution":"def find_parking_spot(parking_lot, row): Returns the index of the first available parking spot (0) in the given row. If no spots are available, returns -1. :param parking_lot: List[List[int]] - a 2D list representing the parking lot. :param row: int - the row number to search for an available spot. :return: int - the index of the first available spot or -1 if no spots are available. for idx, spot in enumerate(parking_lot[row]): if spot == 0: return idx return -1"},{"question":"def path_exists(matrix, n, m): Check if there exists a path from the top-left corner (1, 1) to the bottom-right corner (n, m) of the given matrix without passing through any blocked cells (denoted by '#'). >>> path_exists([ ... ['.', '.', '.'], ... ['#', '#', '.'], ... ['#', '.', '.'] ... ], 3, 3) \\"YES\\" >>> path_exists([ ... ['.', '#', '.'], ... ['#', '#', '.'], ... ['#', '.', '.'] ... ], 3, 3) \\"NO\\" >>> path_exists([ ... ['.'] ... ], 1, 1) \\"YES\\" >>> path_exists([ ... ['#'] ... ], 1, 1) \\"NO\\" >>> path_exists([ ... ['.', '#', '.', '.', '.'], ... ['#', '.', '#', '#', '.'], ... ['#', '.', '#', '#', '.'], ... ['#', '.', '.', '.', '#'], ... ['#', '#', '#', '.', '.'] ... ], 5, 5) \\"NO\\" >>> path_exists([ ... ['.', '.', '.', '.', '.'], ... ['.', '#', '.', '#', '.'], ... ['.', '#', '.', '#', '.'], ... ['.', '.', '.', '#', '.'], ... ['#', '#', '.', '.', '.'] ... ], 5, 5) \\"YES\\"","solution":"def path_exists(matrix, n, m): if matrix[0][0] == '#' or matrix[n-1][m-1] == '#': return \\"NO\\" from collections import deque directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and matrix[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def min_path_sum(grid): Returns the minimum sum of the values along the path from the top-left to the bottom-right corner of the grid. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 3, 4]]) 10 >>> min_path_sum([[1], [2], [3], [4]]) 10 >>> min_path_sum([[1, 2, 3], [4, 8, 2], [1, 5, 3]]) 11 >>> min_path_sum([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_path_sum([[1000, 1000], [1000, 1000]]) 3000","solution":"def min_path_sum(grid): Returns the minimum sum of the values along the path from the top-left to the bottom-right corner of the grid. n = len(grid) m = len(grid[0]) # Initialize a 2D dp array with the same dimensions as the grid dp = [[0] * m for _ in range(n)] # Set the value of the starting point dp[0][0] = grid[0][0] # Fill in the first row (can only come from left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The value at dp[n-1][m-1] will be the minimum path sum return dp[n-1][m-1]"},{"question":"def manage_cargo_operations(operations: List[str]) -> List[str]: Manages the cargo operations on a stack and returns the state of the stack after each operation. :param operations: List of string operations (e.g., ['ADD 5', 'REMOVE']) :return: List of strings representing the state of the stack after each operation >>> manage_cargo_operations([\\"ADD 5\\", \\"ADD 10\\", \\"REMOVE\\", \\"ADD 8\\", \\"REMOVE\\"]) ['5', '5 10', '5', '5 8', '5'] >>> manage_cargo_operations([\\"ADD 5\\", \\"REMOVE\\", \\"REMOVE\\", \\"ADD 3\\"]) ['5', '', 'ERROR', '3']","solution":"def manage_cargo_operations(operations): Manages the cargo operations on a stack and returns the state of the stack after each operation. :param operations: List of string operations (e.g., ['ADD 5', 'REMOVE']) :return: List of strings representing the state of the stack after each operation stack = [] results = [] for operation in operations: if operation.startswith('ADD'): _, x = operation.split() stack.append(int(x)) results.append(' '.join(map(str, stack))) elif operation == 'REMOVE': if stack: stack.pop() if stack: results.append(' '.join(map(str, stack))) else: results.append('') else: results.append('ERROR') return results"},{"question":"from typing import List def minTransformations(startWord: str, targetWord: str, wordList: List[str]) -> int: Determine the smallest number of transformations needed to change \`startWord\` into \`targetWord\` with a sequence of intermediate words from \`wordList\`, or return -1 if the transformation is not possible. >>> minTransformations(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) 5 >>> minTransformations(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) -1","solution":"from typing import List from collections import deque def minTransformations(startWord: str, targetWord: str, wordList: List[str]) -> int: if targetWord not in wordList: return -1 wordSet = set(wordList) queue = deque([(startWord, 1)]) visited = set(startWord) while queue: current_word, steps = queue.popleft() if current_word == targetWord: return steps # Iterate through each character position for i in range(len(current_word)): for char in \\"abcdefghijklmnopqrstuvwxyz\\": next_word = current_word[:i] + char + current_word[i + 1:] if next_word in wordSet and next_word not in visited: queue.append((next_word, steps + 1)) visited.add(next_word) return -1"},{"question":"def parse_and_solve(m: int, x: int, coin_data: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Given the denominations and counts of each coin type, finds the maximum possible sum of denominations that can be achieved with exactly x coins in a row, along with the indices of the selected coin types. Parameters: m (int): The number of different types of coins. x (int): The number of coins Alex wants to place in a single row. coin_data (List[Tuple[int, int]]): Each tuple contains (denomination, count). Returns: Tuple[int, List[int]]: A tuple where the first element is the maximum possible sum, and the second element is a list of indices of the selected coin types. Examples: >>> parse_and_solve(5, 3, [(5, 3), (2, 1), (7, 2), (4, 5), (6, 2)]) (18, [3, 5, 1]) >>> parse_and_solve(3, 2, [(10, 1), (-20, 1), (5, 1)]) (15, [1, 3]) pass from typing import List, Tuple # Test Cases def test_basic_case(): m = 5 x = 3 coins = [(5, 3), (2, 1), (7, 2), (4, 5), (6, 2)] max_sum, indices = parse_and_solve(m, x, coins) assert max_sum == 18 assert sorted(indices) == sorted([3, 5, 1]) def test_all_same_denomination(): m = 5 x = 3 coins = [(3, 3), (3, 3), (3, 3), (3, 3), (3, 3)] max_sum, indices = parse_and_solve(m, x, coins) assert max_sum == 9 assert len(indices) == 3 assert all(1 <= i <= 5 for i in indices) def test_large_denomination_negative(): m = 3 x = 2 coins = [(10, 1), (-20, 1), (5, 1)] max_sum, indices = parse_and_solve(m, x, coins) assert max_sum == 15 assert sorted(indices) == sorted([1, 3]) def test_with_edge_values(): m = 4 x = 2 coins = [(1000000000, 1), (-1000000000, 1), (500000000, 1), (-500000000, 1)] max_sum, indices = parse_and_solve(m, x, coins) assert max_sum == 1500000000 assert sorted(indices) == sorted([1, 3])","solution":"def max_sum_denominations(m, x, coin_info): Returns the maximum sum of denominations and the indices of coins that produce this sum given m types of coins and a row length of x. Parameters: m (int): The number of different types of coins x (int): The number of coins Alex wants to place in a single row coin_info (list of tuples): Each tuple contains (denomination, count) Returns: tuple: (maximum sum, list of indices) # Sorting the coins by denominations in descending order to maximize the sum sorted_coins = sorted(coin_info, key=lambda k: k[0], reverse=True) max_sum = 0 selected_indices = [] for i in range(x): max_sum += sorted_coins[i][0] selected_indices.append(sorted_coins[i][2]) # Append the original index return max_sum, selected_indices # Function to parse input and use the above logic def parse_and_solve(m, x, coin_data): coin_info = [(denom, count, idx + 1) for idx, (denom, count) in enumerate(coin_data)] return max_sum_denominations(m, x, coin_info)"},{"question":"def find_missing_positive_integer(lst): Given a list of integers, this function returns the smallest positive integer that is not present in the list. >>> find_missing_positive_integer([1, 2, 3, 4, 5]) == 6 >>> find_missing_positive_integer([1, 3, 6, 4, 1, 2]) == 5 >>> find_missing_positive_integer([100, 101, 102]) == 1 >>> find_missing_positive_integer([3, 4, -1, 1]) == 2 >>> find_missing_positive_integer([1, 1, 1, 1]) == 2 >>> find_missing_positive_integer([2, 3, 7, 6, 8, -1, -10, 15]) == 1 >>> find_missing_positive_integer([2]) == 1 >>> find_missing_positive_integer([1]) == 2","solution":"def find_missing_positive_integer(lst): Given a list of integers, this function returns the smallest positive integer that is not present in the list. # Convert the list to a set for faster lookup num_set = set(lst) smallest_missing = 1 # Iterate over positive integers starting from 1 while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"def find_zero_sum_subarray(arr: List[int]) -> Union[Tuple[int, int], int]: Given an array of n integers, finds any subarray such that the sum of its elements is exactly zero. Parameters: arr (list): A list of integers Returns: tuple: A tuple containing the 1-based indices of the subarray, or -1 if no such subarray exists. >>> find_zero_sum_subarray([3, 4, -7, 2, -2]) (2, 4) >>> find_zero_sum_subarray([1, 2, 3]) -1","solution":"def find_zero_sum_subarray(arr): Given an array, finds any subarray such that the sum of its elements is exactly zero. Parameters: arr (list): A list of integers Returns: tuple: A tuple containing the 1-based indices of the subarray, or -1 if no such subarray exists prefix_sum = {} current_sum = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == 0: return (1, i + 1) # found a subarray from the start to i if current_sum in prefix_sum: return (prefix_sum[current_sum] + 2, i + 1) # found a subarray within the array prefix_sum[current_sum] = i return -1"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Returns the area of the largest rectangle in the histogram represented by heights. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Returns the area of the largest rectangle in the histogram represented by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def apply_operations(n: int, m: int, operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Apply a list of operations to an n x m grid. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. operations (list of tuple of ints): list of operations. Each operation is described by four integers (x1, y1, x2, y2). Returns: list of list of ints: the final grid after all operations. >>> apply_operations(3, 3, [(1, 1, 2, 2), (2, 2, 3, 3)]) [[1, 1, 0], [1, 2, 1], [0, 1, 1]] >>> apply_operations(2, 2, [(1, 1, 1, 1), (1, 1, 1, 1)]) [[2, 0], [0, 0]] >>> apply_operations(2, 2, [(1, 1, 2, 2)]) [[1, 1], [1, 1]] >>> apply_operations(3, 3, [(1, 1, 2, 2), (1, 1, 3, 3), (2, 2, 3, 3)]) [[2, 2, 1], [2, 3, 2], [1, 2, 2]] >>> apply_operations(3, 3, []) [[0, 0, 0], [0, 0, 0], [0, 0, 0]]","solution":"def apply_operations(n, m, operations): Apply a list of operations to an n x m grid. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. operations (list of tuple of ints): list of operations. Each operation is described by four integers (x1, y1, x2, y2). Returns: list of list of ints: the final grid after all operations. # Initialize the grid with zeros grid = [[0] * m for _ in range(n)] # Apply each operation for x1, y1, x2, y2 in operations: for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): grid[i][j] += 1 # Increment cell by 1 return grid # Example usage: # n = 3, m = 3, q = 2 # operations = [(1, 1, 2, 2), (2, 2, 3, 3)] # result = apply_operations(3, 3, operations) # Output should be: # 1 1 0 # 1 2 1 # 0 1 1"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number iteratively. >>> fibonacci(1) 0 >>> fibonacci(2) 1 >>> fibonacci(3) 1 >>> fibonacci(4) 2 >>> fibonacci(10) 34 >>> fibonacci(50) 7778742049 >>> fibonacci(100) 218922995834555169026","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n == 1: return 0 elif n == 2: return 1 a, b = 0, 1 for _ in range(n - 2): a, b = b, a + b return b"},{"question":"[Completion Task in Python] from typing import List, Tuple def min_inspection_time(N: int, edges: List[Tuple[int, int]], status: str) -> int: Determine the minimum time required to inspect all nodes in the company's network. >>> min_inspection_time(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], \\"OFOFFFO\\") 3 >>> min_inspection_time(1, [], \\"O\\") 1 >>> min_inspection_time(5, [(1, 2), (2, 3), (3, 4), (4, 5)], \\"OOOFF\\") 5 >>> min_inspection_time(6, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)], \\"FOOOOF\\") 2 >>> min_inspection_time(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], \\"OOOOOOO\\") 3 # Your implementation here","solution":"from collections import defaultdict, deque def min_inspection_time(N, edges, status): # Build the tree using adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # BFS to calculate depth of each node from the root (node 1) depth = [0] * (N + 1) max_depth = 0 visited = [False] * (N + 1) queue = deque([1]) visited[1] = True while queue: node = queue.popleft() current_depth = depth[node] for neighbor in tree[node]: if not visited[neighbor]: visited[neighbor] = True depth[neighbor] = current_depth + 1 max_depth = max(max_depth, depth[neighbor]) queue.append(neighbor) # Inspection time is the maximum depth found return max_depth + 1"},{"question":"from typing import List class MatrixOperations: def __init__(self, matrix: List[List[int]]): Initializes the matrix operations object with the given matrix. def update_value(self, i: int, j: int, x: int) -> None: Updates the value at cell (i, j) to x. def sum_submatrix(self, r1: int, c1: int, r2: int, c2: int) -> int: Returns the sum of all values in the submatrix from (r1, c1) to (r2, c2) (inclusive). def test_initial_sum_submatrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ops = MatrixOperations(matrix) assert ops.sum_submatrix(0, 0, 2, 2) == 45 assert ops.sum_submatrix(0, 0, 1, 1) == 12 assert ops.sum_submatrix(1, 1, 2, 2) == 28 def test_update_value(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ops = MatrixOperations(matrix) ops.update_value(1, 1, 10) assert ops.sum_submatrix(0, 0, 2, 2) == 50 assert ops.sum_submatrix(0, 0, 1, 1) == 17 assert ops.sum_submatrix(1, 1, 2, 2) == 33 def test_mixed_operations(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ops = MatrixOperations(matrix) assert ops.sum_submatrix(0, 0, 2, 2) == 45 ops.update_value(1, 1, 10) assert ops.sum_submatrix(1, 1, 2, 2) == 33 ops.update_value(0, 0, 5) assert ops.sum_submatrix(0, 0, 1, 1) == 21","solution":"class MatrixOperations: def __init__(self, matrix): self.matrix = matrix self.n = len(matrix) self.m = len(matrix[0]) self.prefix_sum = [[0] * (self.m + 1) for _ in range(self.n + 1)] self._precompute_prefix_sum() def _precompute_prefix_sum(self): # Construct prefix sum matrix for i in range(1, self.n + 1): for j in range(1, self.m + 1): self.prefix_sum[i][j] = ( self.matrix[i-1][j-1] + self.prefix_sum[i-1][j] + self.prefix_sum[i][j-1] - self.prefix_sum[i-1][j-1] ) def update_value(self, i, j, x): original_value = self.matrix[i][j] difference = x - original_value self.matrix[i][j] = x # Update prefix sum for row in range(i+1, self.n+1): for col in range(j+1, self.m+1): self.prefix_sum[row][col] += difference def sum_submatrix(self, r1, c1, r2, c2): total = (self.prefix_sum[r2+1][c2+1] - self.prefix_sum[r2+1][c1] - self.prefix_sum[r1][c2+1] + self.prefix_sum[r1][c1]) return total"},{"question":"def min_travel_cost(n: int, c: List[int]) -> int: Given the number of cities n and the array c representing the cost of traveling between adjacent cities, returns the minimum traveling cost for Emily's trip from the first city to the last city visiting each city exactly once. Args: n : int : number of cities c : list of int : traveling costs between adjacent cities Returns: int : minimum traveling cost >>> min_travel_cost(5, [1, 3, 2, 4]) 10 >>> min_travel_cost(2, [1000000000]) 1000000000 >>> min_travel_cost(4, [1, 1, 1]) 3 >>> min_travel_cost(6, [3, 1, 7, 5, 2]) 18 >>> min_travel_cost(5, [0, 0, 0, 0]) 0 # Implement the function here","solution":"def min_travel_cost(n, c): Given the number of cities n and the array c representing the cost of traveling between adjacent cities, returns the minimum traveling cost for Emily's trip from the first city to the last city visiting each city exactly once. Args: n : int : number of cities c : list of int : traveling costs between adjacent cities Returns: int : minimum traveling cost # The minimum traveling cost is the sum of all costs in array c return sum(c)"},{"question":"from typing import List def max_length_two_distinct(s: str) -> int: Determine the maximum length of a contiguous substring with at most two distinct characters. >>> max_length_two_distinct(\\"abbadc\\") 4 >>> max_length_two_distinct(\\"aaaaa\\") 5 >>> max_length_two_distinct(\\"abababab\\") 8 >>> max_length_two_distinct(\\"abcabcabc\\") 2 >>> max_length_two_distinct(\\"\\") 0 >>> max_length_two_distinct(\\"a\\") 1 >>> max_length_two_distinct(\\"aabb\\") 4 >>> max_length_two_distinct(\\"eceba\\") 3","solution":"def max_length_two_distinct(s): from collections import defaultdict n = len(s) if n < 3: return n left, right = 0, 0 max_len = 2 char_map = defaultdict(int) while right < n: char_map[s[right]] += 1 right += 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left) return max_len"},{"question":"def longest_circular_palindrome_length(s: str) -> int: Determine the length of the longest palindromic substring for a given circular string s. A Circular string is a string in which the first and last characters are considered to be adjacent. Parameters: s (str): Input string of length n Returns: int: Length of the longest palindromic substring in the circular string. Examples: >>> longest_circular_palindrome_length(\\"aabbaa\\") 6 >>> longest_circular_palindrome_length(\\"abc\\") 1 >>> longest_circular_palindrome_length(\\"racecar\\") 7 >>> longest_circular_palindrome_length(\\"a\\") 1 >>> longest_circular_palindrome_length(\\"aaaaaa\\") 6 >>> longest_circular_palindrome_length(\\"abcdefg\\") 1 >>> longest_circular_palindrome_length(\\"abacaba\\") 7 >>> longest_circular_palindrome_length(\\"\\") 0 >>> longest_circular_palindrome_length(\\"z\\") 1","solution":"def longest_circular_palindrome_length(s): Returns the length of the longest palindromic substring in a circular string. Parameters: s (str): Input string Returns: int: Length of the longest palindromic substring in circular form n = len(s) if n == 0: return 0 if n == 1: return 1 def is_palindrome(sub): return sub == sub[::-1] extended_s = s + s # To handle circular nature by duplicating string max_len = 1 for i in range(n): for j in range(i + 1, i + n + 1): if is_palindrome(extended_s[i:j]): max_len = max(max_len, j - i) return max_len"},{"question":"def find_median(n: int, arr: List[int]) -> float: Returns the median of the array. If \`n\` is odd, the median is the middle element. If \`n\` is even, the median is the average of the two middle elements. >>> find_median(5, [3, 5, 1, 2, 4]) 3.0 >>> find_median(4, [7, 12, 3, 5]) 6.0","solution":"def find_median(n, arr): Returns the median of the array. If \`n\` is odd, the median is the middle element. If \`n\` is even, the median is the average of the two middle elements. def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) sorted_arr = quicksort(arr) if n % 2 == 1: return float(sorted_arr[n // 2]) else: return round((sorted_arr[n // 2 - 1] + sorted_arr[n // 2]) / 2.0, 1)"},{"question":"from typing import List def is_path_possible(n: int, D: int, grid: List[List[int]]) -> str: Determine if there exists a path from the top-left cell to the bottom-right cell, moving only up, down, left, or right, such that the absolute difference in height between any two consecutive cells in the path is at most D. Args: n (int): The size of the grid. D (int): The maximum allowed difference in height for consecutive cells in the path. grid (List[List[int]]): The height values of the cells in the grid. Returns: str: \\"YES\\" if such a path exists, otherwise \\"NO\\". >>> n, D = 3, 2 >>> grid = [ >>> [1, 3, 5], >>> [2, 8, 3], >>> [4, 6, 1] >>> ] >>> is_path_possible(n, D, grid) \\"YES\\" >>> n, D = 2, 1 >>> grid = [ >>> [1, 3], >>> [4, 6] >>> ] >>> is_path_possible(n, D, grid) \\"NO\\" >>> n, D = 3, 0 >>> grid = [ >>> [1, 1, 1], >>> [1, 1, 1], >>> [1, 1, 1] >>> ] >>> is_path_possible(n, D, grid) \\"YES\\" >>> n, D = 4, 10 >>> grid = [ >>> [1, 2, 3, 4], >>> [4, 5, 6, 7], >>> [7, 8, 9, 10], >>> [10, 11, 12, 13] >>> ] >>> is_path_possible(n, D, grid) \\"YES\\" >>> n, D = 3, 0 >>> grid = [ >>> [1, 1, 1], >>> [2, 2, 2], >>> [3, 3, 3] >>> ] >>> is_path_possible(n, D, grid) \\"NO\\"","solution":"def is_path_possible(n, D, grid): from collections import deque directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < n queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == n - 1 and y == n - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= D: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def can_fit_items_into_bag(n: int, weights: List[int], max_weight: int) -> str: Determines if it is possible to fit all items into the bag without exceeding the max weight. Parameters: n (int): Number of items. weights (list of int): List of item weights. max_weight (int): Maximum weight the bag can hold. Returns: str: \\"POSSIBLE\\" if all items can fit within the max_weight, otherwise \\"IMPOSSIBLE\\". >>> can_fit_items_into_bag(5, [10, 20, 30, 40, 50], 150) 'POSSIBLE' >>> can_fit_items_into_bag(5, [10, 20, 30, 40, 50], 100) 'IMPOSSIBLE' >>> can_fit_items_into_bag(3, [20, 30, 50], 100) 'POSSIBLE' >>> can_fit_items_into_bag(1, [50], 100) 'POSSIBLE' >>> can_fit_items_into_bag(1, [150], 100) 'IMPOSSIBLE' >>> can_fit_items_into_bag(3, [10, 20, 30], 60) 'POSSIBLE' >>> can_fit_items_into_bag(3, [10, 20, 40], 60) 'IMPOSSIBLE' >>> can_fit_items_into_bag(3, [0, 0, 0], 5) 'POSSIBLE'","solution":"def can_fit_items_into_bag(n, weights, max_weight): Determines if it is possible to fit all items into the bag without exceeding the max weight. Parameters: n (int): Number of items. weights (list of int): List of item weights. max_weight (int): Maximum weight the bag can hold. Returns: str: \\"POSSIBLE\\" if all items can fit within the max_weight, otherwise \\"IMPOSSIBLE\\". total_weight = sum(weights) if total_weight <= max_weight: return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def min_operations_to_unique_sorted(s: str) -> int: Given a string consisting of lowercase English letters, find the minimum number of operations required to transform the string into a string with unique characters that are sorted in lexicographical order. >>> min_operations_to_unique_sorted(\\"aabbbc\\") 3 >>> min_operations_to_unique_sorted(\\"abc\\") 0 >>> min_operations_to_unique_sorted(\\"aaaa\\") 3 >>> min_operations_to_unique_sorted(\\"zyxwvutsrqponmlkjihgfedcba\\") 0 Args: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of operations required.","solution":"def min_operations_to_unique_sorted(s): Returns the minimum number of operations required to transform the string into another string with unique characters that are sorted in lexicographical order. from collections import Counter # Count the frequency of each character freq = Counter(s) # Calculate the number of operations needed operations = sum(count - 1 for count in freq.values() if count > 1) return operations"},{"question":"def max_meetings_schedule(meetings: List[Tuple[int, int, int]], conference_rooms: List[int]) -> int: Determines the maximum number of meetings that can be scheduled without overlap in rooms. Args: meetings: List of tuples where each tuple is (start_time, end_time, num_people). conference_rooms: List of integers where each integer is the capacity of a conference room. Returns: Integer representing the maximum number of meetings that can be scheduled. Examples: >>> max_meetings_schedule([(1, 4, 5), (2, 6, 3), (4, 7, 10), (5, 8, 7)], [5, 10, 7]) 3 >>> max_meetings_schedule([(1, 4, 5), (2, 5, 5), (4, 7, 5)], [5]) 2","solution":"def max_meetings_schedule(meetings, conference_rooms): Determines the maximum number of meetings that can be scheduled without overlap in rooms. Args: meetings: List of tuples where each tuple is (start_time, end_time, num_people). conference_rooms: List of integers where each integer is the capacity of a conference room. Returns: Integer representing the maximum number of meetings that can be scheduled. # Sort the meetings based on their end times meetings.sort(key=lambda x: x[1]) # Sort the conference rooms based on their capacities conference_rooms.sort() # Initialize count for maximum meetings max_meetings = 0 # List to keep track of end times for meetings in each room rooms_end_times = [0] * len(conference_rooms) for meeting in meetings: start_time, end_time, num_people = meeting # Find a room that can accommodate the meeting for i in range(len(conference_rooms)): if conference_rooms[i] >= num_people and rooms_end_times[i] <= start_time: # Schedule the meeting in this room rooms_end_times[i] = end_time max_meetings += 1 break return max_meetings"},{"question":"def max_total_beauty(n: int, d: int, beauty_values: List[int]) -> int: Determine whether it's possible to arrange all \`n\` flowers such that all adjacent pairs are compatible, and if so, return the maximum total beauty of the arrangement, otherwise return -1. >>> max_total_beauty(5, 2, [4, 1, 7, 3, 6]) 21 >>> max_total_beauty(1, 0, [1000000000]) 1000000000 >>> max_total_beauty(5, 0, [1000000000, 999999999, 999999998, 999999997, 999999996]) -1 >>> max_total_beauty(5, 1, [5, 5, 5, 5, 5]) 25 >>> max_total_beauty(3, 1, [1, 10, 20]) -1 >>> max_total_beauty(3, 10, [1, 10, 20]) 31 >>> max_total_beauty(4, 3, [7, 3, 1, 4]) 15","solution":"def max_total_beauty(n, d, beauty_values): Determine whether it's possible to arrange all \`n\` flowers such that all adjacent pairs are compatible, and if so, return the maximum total beauty of the arrangement, otherwise return -1. # Sort the beauty values sorted_beauty_values = sorted(beauty_values) # Check if the difference between any two adjacent flowers is greater than d for i in range(1, n): if abs(sorted_beauty_values[i] - sorted_beauty_values[i-1]) > d: return -1 # If all pairs are compatible, return the sum of the sorted beauty values return sum(sorted_beauty_values)"},{"question":"def is_path_possible(n: int, m: int, grid: List[List[str]]) -> str: Determines if there is a path from the top-left cell to the bottom-right cell that only passes through accessible cells ('.'). Parameters: n (int): Number of rows. m (int): Number of columns. grid (List[List[str]]): n x m grid where each cell is either '.' or '#'. Returns: str: \\"YES\\" if there is a path, otherwise \\"NO\\". >>> is_path_possible(3, 3, [['.', '.', '#'], ['#', '.', '.'], ['.', '.', '.']]) \\"YES\\" >>> is_path_possible(3, 3, [['.', '#', '.'], ['#', '.', '.'], ['.', '#', '.']]) \\"NO\\"","solution":"def is_path_possible(n, m, grid): Determines if there is a path from the top-left cell to the bottom-right cell that only passes through accessible cells. Parameters: n (int): Number of rows. m (int): Number of columns. grid (List[List[str]]): n x m grid where each cell is either '.' or '#'. Returns: str: \\"YES\\" if there is a path, otherwise \\"NO\\". if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" from collections import deque directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n-1 and y == m-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"from typing import List def calculate_combinations(n: int, m: int, k: int, card_values: List[int], remaining_values: List[int]) -> int: Calculate the total possible combinations of the remaining cards that would keep the sum V intact. Args: n: Number of players m: Number of cards each player has drawn k: Number of unique card values card_values: List of k card values remaining_values: List of remaining cards in the deck Returns: int: The total possible combinations. >>> calculate_combinations(2, 3, 3, [1, 2, 3], [1, 2, 2, 3, 3]) 1 >>> calculate_combinations(1, 3, 1, [100], [100, 100, 100]) 1 >>> calculate_combinations(1, 3, 3, [1, 2, 3], [1, 2]) 1 >>> calculate_combinations(2, 3, 3, [1, 2, 3], []) 1 >>> calculate_combinations(1, 3, 3, [0, 0, 0], [0, 0, 0]) 1 >>> calculate_combinations(2, 3, 3, [0, 0, 0], [0, 0, 0, 0, 0, 0]) 1","solution":"from collections import Counter from math import comb def calculate_combinations(n, m, k, card_values, remaining_values): Calculate possible combinations of remaining cards to maintain a sum V. Args: n (int): Number of players m (int): Number of cards each player has drawn k (int): Number of unique card values card_values (list): List of k card values remaining_values (list): List of remaining cards in the deck Returns: int: the total possible combinations. T = k * m * n V = m * n * sum(card_values) remaining_sum = sum(remaining_values) drawn_sum = V - remaining_sum remaining_counts = Counter(remaining_values) needed_counts = {} for value in card_values: needed_counts[value] = (n * m - remaining_counts.get(value, 0)) return calculate_combinations_recursively(needed_counts, drawn_sum, card_values) def calculate_combinations_recursively(needed_counts, drawn_sum, card_values): if drawn_sum == 0 and all(count == 0 for count in needed_counts.values()): return 1 if drawn_sum < 0 or not card_values: return 0 current_value = card_values[0] remaining_card_values = card_values[1:] total_combinations = 0 max_cards = needed_counts[current_value] for i in range(max_cards + 1): needed_counts[current_value] -= i total_combinations += calculate_combinations_recursively( needed_counts, drawn_sum - i * current_value, remaining_card_values ) needed_counts[current_value] += i return total_combinations"},{"question":"def find_pair_with_sum(arr: [int], T: int) -> int: Determines if there exist two distinct elements in the array whose sum is equal to the target integer T. >>> find_pair_with_sum([1, 2, 3, 4, 5], 9) == 1 >>> find_pair_with_sum([1, 2, 3, 4, 6], 8) == 1 >>> find_pair_with_sum([1, -2, 3, -4, 5], -6) == 1 >>> find_pair_with_sum([0, 0, 2, 3], 0) == 1 >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) == 0 >>> find_pair_with_sum([1, 2, 3, 4, 5], 0) == 0 >>> find_pair_with_sum([1], 1) == 0 # your code here","solution":"def find_pair_with_sum(arr: [int], T: int) -> int: Determines if there exist two distinct elements in the array whose sum is equal to the target integer T. encountered = set() for num in arr: complement = T - num if complement in encountered: return 1 encountered.add(num) return 0"},{"question":"class Marathon: def __init__(self): self.participants = [] def register(self, name: str, age: int) -> int: Registers a new participant with the given name and age. Returns the registration ID. pass def get(self, participant_id: int) -> Tuple[str, int]: Given a registration ID, returns the name and age of the participant. pass def range(self, low: int, high: int) -> List[Tuple[int, str]]: Returns the IDs and names of participants with ages in the range [low, high], sorted by registration ID in ascending order. pass def process_queries(queries: List[str]) -> List[Union[int, str]]: Processes a list of queries. pass # Test cases def test_register(): queries = [\\"register Alice 30\\", \\"register Bob 25\\", \\"register Charlie 30\\"] assert process_queries(queries) == [1, 2, 3] def test_get(): queries = [\\"register Alice 30\\", \\"register Bob 25\\", \\"get 1\\", \\"get 2\\"] assert process_queries(queries) == [1, 2, \\"Alice 30\\", \\"Bob 25\\"] def test_range(): queries = [\\"register Alice 30\\", \\"register Bob 25\\", \\"register Charlie 30\\", \\"range 25 30\\"] assert process_queries(queries) == [1, 2, 3, \\"1 Alice\\", \\"2 Bob\\", \\"3 Charlie\\"] def test_combined(): queries = [\\"register Alice 30\\", \\"register Bob 25\\", \\"register Charlie 30\\", \\"get 2\\", \\"range 25 30\\", \\"register Diana 35\\"] assert process_queries(queries) == [1, 2, 3, \\"Bob 25\\", \\"1 Alice\\", \\"2 Bob\\", \\"3 Charlie\\", 4] def test_no_participant_in_range(): queries = [\\"register Alice 30\\", \\"register Bob 25\\", \\"range 50 100\\"] assert process_queries(queries) == [1, 2] def test_single_participant_in_range(): queries = [\\"register Alice 30\\", \\"register Bob 25\\", \\"range 25 25\\"] assert process_queries(queries) == [1, 2, \\"2 Bob\\"]","solution":"class Marathon: def __init__(self): self.participants = [] def register(self, name, age): participant_id = len(self.participants) + 1 self.participants.append({\\"id\\": participant_id, \\"name\\": name, \\"age\\": age}) return participant_id def get(self, participant_id): participant = self.participants[participant_id - 1] return participant[\\"name\\"], participant[\\"age\\"] def range(self, low, high): result = [] for participant in self.participants: if low <= participant[\\"age\\"] <= high: result.append((participant[\\"id\\"], participant[\\"name\\"])) return result def process_queries(queries): marathon = Marathon() results = [] for query in queries: parts = query.split() command = parts[0] if command == \\"register\\": name = parts[1] age = int(parts[2]) results.append(marathon.register(name, age)) elif command == \\"get\\": participant_id = int(parts[1]) name, age = marathon.get(participant_id) results.append(f\\"{name} {age}\\") elif command == \\"range\\": low = int(parts[1]) high = int(parts[2]) participants_in_range = marathon.range(low, high) for participant_id, name in participants_in_range: results.append(f\\"{participant_id} {name}\\") return results"},{"question":"from typing import List def is_path_exists(grid: List[List[str]]) -> bool: Check if there is a path from the top-left to the bottom-right of the grid using DFS. The path can only consist of alternating 'a' and 'b'. Parameters: grid (List[List[str]]): An n x n grid of characters. Returns: bool: True if the path exists, else False. >>> grid = [ ... ['a', 'b', 'c'], ... ['b', 'a', 'b'], ... ['c', 'b', 'a'] ... ] >>> is_path_exists(grid) True >>> grid = [ ... ['a', 'b', 'c'], ... ['c', 'a', 'b'], ... ['b', 'c', 'a'] ... ] >>> is_path_exists(grid) False","solution":"from typing import List def is_path_exists(grid: List[List[str]]) -> bool: n = len(grid) target_char = 'a' if grid[0][0] == 'b' else 'b' def dfs(x, y, prev_char): if x == n - 1 and y == n - 1: return True if x < 0 or y < 0 or x >= n or y >= n: return False if grid[x][y] != prev_char: return False tmp, grid[x][y] = grid[x][y], '.' if (x + 1 < n and dfs(x + 1, y, 'a' if prev_char == 'b' else 'b')) or (x - 1 >= 0 and dfs(x - 1, y, 'a' if prev_char == 'b' else 'b')) or (y + 1 < n and dfs(y + 1, x, 'a' if prev_char == 'b' else 'b')) or (y - 1 >= 0 and dfs(y - 1, x, 'a' if prev_char == 'b' else 'b')): return True grid[x][y] = tmp return False if grid[0][0] == 'a' or grid[0][0] == 'b': return dfs(0, 0, grid[0][0]) return False"},{"question":"def find_majority_element(arr: List[int]) -> int: Returns the majority element of the array if it exists, otherwise returns -1. The majority element is the element that appears more than n // 2 times. >>> find_majority_element([3, 3, 4, 2, 3]) == 3 >>> find_majority_element([1, 1, 1, 2, 3, 1, 4, 1]) == 1 >>> find_majority_element([1, 2, 3, 4, 5]) == -1 >>> find_majority_element([1]) == 1 >>> find_majority_element([2, 2, 2, 2, 2]) == 2 >>> find_majority_element([-1, -1, -1, -2, -3, -1]) == -1 >>> find_majority_element([10**9, 10**9, 10**9, -10**9]) == 10**9","solution":"def find_majority_element(arr): Returns the majority element of the array if it exists, otherwise returns -1. The majority element is the element that appears more than n // 2 times. n = len(arr) count = {} for num in arr: if num in count: count[num] += 1 else: count[num] = 1 for num in count: if count[num] > n // 2: return num return -1"},{"question":"def count_increasing_groups(heights: List[int]) -> int: Counts the number of distinct groups of consecutive students whose heights are strictly increasing. >>> count_increasing_groups([1, 2, 1, 2, 3, 1]) 3 >>> count_increasing_groups([5]) 1 >>> count_increasing_groups([1, 2]) 1 >>> count_increasing_groups([2, 1]) 2 from solution import count_increasing_groups def test_example_case(): assert count_increasing_groups([1, 2, 1, 2, 3, 1]) == 3 def test_single_element(): assert count_increasing_groups([5]) == 1 def test_all_increasing(): assert count_increasing_groups([1, 2, 3, 4, 5, 6]) == 1 def test_all_decreasing(): assert count_increasing_groups([6, 5, 4, 3, 2, 1]) == 6 def test_increasing_and_decreasing(): assert count_increasing_groups([1, 2, 3, 2, 1, 2, 3, 4]) == 3 def test_uniform_heights(): assert count_increasing_groups([2, 2, 2, 2]) == 4 def test_edge_case_empty_list(): assert count_increasing_groups([]) == 0 def test_edge_case_two_elements_increasing(): assert count_increasing_groups([1, 2]) == 1 def test_edge_case_two_elements_decreasing(): assert count_increasing_groups([2, 1]) == 2","solution":"def count_increasing_groups(heights): Counts the number of distinct groups of consecutive students whose heights are strictly increasing. if not heights: return 0 count = 0 n = len(heights) i = 0 while i < n: # Start a new group count += 1 # Move i to the end of the current increasing group while i + 1 < n and heights[i + 1] > heights[i]: i += 1 i += 1 # Move to the next potential start return count"},{"question":"def is_happy_number(n: int) -> str: Determines if a number n is a happy number. A happy number is a number which eventually leads to 1 when replaced by the sum of the square of each digit, otherwise it forms a cycle that does not include 1. Parameters: n (int): The number to be checked (1 ≤ n ≤ 10^7) Returns: str: \\"HAPPY\\" if the number is a happy number, \\"UNHAPPY\\" otherwise. >>> is_happy_number(19) 'HAPPY' >>> is_happy_number(2) 'UNHAPPY' def test_happy_number_19(): assert is_happy_number(19) == \\"HAPPY\\" def test_unhappy_number_2(): assert is_happy_number(2) == \\"UNHAPPY\\" def test_happy_number_1(): assert is_happy_number(1) == \\"HAPPY\\" def test_unhappy_number_4(): assert is_happy_number(4) == \\"UNHAPPY\\" def test_happy_number_7(): assert is_happy_number(7) == \\"HAPPY\\" def test_unhappy_number_99(): assert is_happy_number(99) == \\"UNHAPPY\\"","solution":"def is_happy_number(n): Determines if a number n is a happy number. A happy number is a number which eventually leads to 1 when replaced by the sum of the square of each digit, otherwise it forms a cycle that does not include 1. Parameters: n (int): The number to be checked (1 ≤ n ≤ 10^7) Returns: str: \\"HAPPY\\" if the number is a happy number, \\"UNHAPPY\\" otherwise. def sum_of_squares(num): return sum(int(digit)**2 for digit in str(num)) visited = set() while n != 1 and n not in visited: visited.add(n) n = sum_of_squares(n) return \\"HAPPY\\" if n == 1 else \\"UNHAPPY\\""},{"question":"def move_zeroes(arr: List[int]) -> None: Transform the array in-place so that every non-zero element is moved to the left, preserving order, and all zeroes are moved to the right end of the array. Example: >>> arr = [0, 1, 0, 3, 12] >>> move_zeroes(arr) >>> arr [1, 3, 12, 0, 0] >>> arr = [0, 0, 0] >>> move_zeroes(arr) >>> arr [0, 0, 0]","solution":"def move_zeroes(arr): Function to move all zeros in the array to the end while maintaining the order of non-zero elements. Parameters: arr (list): List of integers Returns: None n = len(arr) j = 0 # Index to place the next non-zero element for i in range(n): if arr[i] != 0: arr[j] = arr[i] j += 1 for i in range(j, n): arr[i] = 0"},{"question":"def find_substring(t: int, cases: List[Dict[str, Union[int, str]]]) -> List[str]: Determine if there exists a substring of length exactly k that contains at least k/2 distinct characters for each test case. Args: t: The number of test cases. cases: A list of dictionaries, where each dictionary contains: - n: The length of the string s. - s: A string consisting of lowercase English letters. - k: The length of the desired substring. Returns: A list of strings \\"YES\\" followed by the substring if it exists for each test case, otherwise \\"NO\\". Example: >>> test_find_substring() # Your code here Unit Test: def test_find_substring(): cases = [ {\\"n\\": 7, \\"s\\": \\"abcdefg\\", \\"k\\": 3}, {\\"n\\": 5, \\"s\\": \\"aaaaa\\", \\"k\\": 3}, {\\"n\\": 10, \\"s\\": \\"abcdeabcde\\", \\"k\\": 6} ] result = find_substring(3, cases) assert result == [ \\"YESnabc\\", \\"NO\\", \\"YESnabcdea\\" ] def test_single_case_with_possible_substring(): cases = [ {\\"n\\": 6, \\"s\\": \\"abcdab\\", \\"k\\": 3} ] result = find_substring(1, cases) assert result == [\\"YESnabc\\"] def test_single_case_no_possible_substring(): cases = [ {\\"n\\": 5, \\"s\\": \\"aaaaa\\", \\"k\\": 4} ] result = find_substring(1, cases) assert result == [\\"NO\\"] def test_alternating_characters(): cases = [ {\\"n\\": 6, \\"s\\": \\"ababab\\", \\"k\\": 4} ] result = find_substring(1, cases) assert result == [\\"YESnabab\\"]","solution":"def find_substring(t, cases): results = [] for case in cases: n, s, k = case['n'], case['s'], case['k'] found = False for i in range(n - k + 1): substring = s[i:i+k] if len(set(substring)) >= k / 2: results.append(f\\"YESn{substring}\\") found = True break if not found: results.append(\\"NO\\") return results"},{"question":"def largest_number_with_same_digit_sum(n: int) -> int: Finds the largest number less than or equal to n with the same digit sum as n. >>> largest_number_with_same_digit_sum(123) 123 >>> largest_number_with_same_digit_sum(328) 328 >>> largest_number_with_same_digit_sum(120) 120 >>> largest_number_with_same_digit_sum(1001) 1001","solution":"def largest_number_with_same_digit_sum(n): Finds the largest number less than or equal to n with the same digit sum as n. digit_sum = sum(int(digit) for digit in str(n)) def digit_sum_of_num(num): return sum(int(digit) for digit in str(num)) for m in range(n, 0, -1): if digit_sum_of_num(m) == digit_sum: return m"},{"question":"def find_pair(arr: List[int], target: int) -> bool: Determines if there are two distinct elements in the array that add up to the target. Args: arr (list of int): The array of integers. target (int): The target integer. Returns: bool: True if there are two distinct elements that add up to the target, False otherwise. >>> find_pair([2, 7, 11, 15], 9) True >>> find_pair([1, 2, 3, 4], 8) False >>> find_pair([-1, -2, 3, 5], 1) True >>> find_pair([4, 5, 1, -3], 2) True","solution":"def find_pair(arr, target): Determines if there are two distinct elements in the array that add up to the target. Args: arr (list of int): The array of integers. target (int): The target integer. Returns: bool: True if there are two distinct elements that add up to the target, False otherwise. seen = set() for num in arr: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def max_overlapping_segments(n: int, segments: List[Tuple[int, int]]) -> int: Determine the maximum number of overlapping segments at any point on the number line. Parameters: n (int): The number of segments. segments (List[Tuple[int, int]]): A list of tuples, each containing the start and end positions of a segment. Returns: int: The maximum number of overlapping segments. >>> max_overlapping_segments(3, [(1, 5), (2, 6), (4, 8)]) 3 >>> max_overlapping_segments(3, [(1, 2), (3, 4), (5, 6)]) 1","solution":"def max_overlapping_segments(n, segments): events = [] for start, end in segments: events.append((start, 1)) # Segment starts events.append((end, -1)) # Segment ends events.sort() max_overlaps = 0 current_overlaps = 0 for event in events: current_overlaps += event[1] if current_overlaps > max_overlaps: max_overlaps = current_overlaps return max_overlaps"},{"question":"def largest_group_size(n: int, d: int, heights: List[int]) -> int: Returns the size of the largest group of students such that the difference between the height of the tallest and the shortest student in the group is at most d. >>> largest_group_size(7, 3, [1, 3, 4, 9, 10, 12, 14]) 3 >>> largest_group_size(1, 1, [5]) 1 >>> largest_group_size(5, 2, [5, 5, 5, 5, 5]) 5 >>> largest_group_size(5, 1, [1, 3, 5, 7, 9]) 1 >>> largest_group_size(5, 10, [1, 2, 3, 4, 5]) 5 >>> largest_group_size(8, 3, [1, 2, 3, 4, 6, 7, 9, 10]) 4 >>> largest_group_size(100000, 1, list(range(1, 100001))) 2","solution":"def largest_group_size(n, d, heights): Returns the size of the largest group of students such that the difference between the height of the tallest and the shortest student in the group is at most d. heights.sort() max_group_size = 0 left = 0 for right in range(n): while heights[right] - heights[left] > d: left += 1 max_group_size = max(max_group_size, right - left + 1) return max_group_size"},{"question":"def unique_days_over_time(intervals: List[Tuple[int, int]]) -> List[int]: Given a list of intervals, returns the cumulative number of unique days covered after each event is added. >>> unique_days_over_time([(1, 3), (2, 5), (6, 8)]) [3, 5, 8] >>> unique_days_over_time([(1, 3), (4, 6), (7, 9)]) [3, 6, 9] >>> unique_days_over_time([(1, 4), (2, 3), (1, 4)]) [4, 4, 4] >>> unique_days_over_time([(1, 5), (3, 7), (5, 8)]) [5, 7, 8] >>> unique_days_over_time([(1, 1), (1, 1), (2, 2)]) [1, 1, 2]","solution":"def unique_days_over_time(intervals): Given a list of intervals, returns the cumulative number of unique days covered after each event is added. unique_days = set() results = [] for l, r in intervals: days = set(range(l, r + 1)) unique_days.update(days) results.append(len(unique_days)) return results"},{"question":"def count_paths(m: int, n: int, k: int, grid: List[str]) -> int: Find the number of paths from the top-left corner to the bottom-right corner. The path should not pass through obstacles ('#') and the difference between indices of adjacent cells should not exceed k. >>> count_paths(3, 3, 1, [\\"...\\", \\".#.\\", \\"...\\"]) == 2 >>> count_paths(3, 3, 1, [\\"...\\", \\"#\\", \\"...\\"]) == 0 >>> count_paths(1, 1, 1, [\\".\\"]) == 1 >>> count_paths(3, 3, 10, [\\"...\\", \\"...\\", \\"...\\"]) == 6 >>> count_paths(3, 3, 1, [\\"#..\\", \\"...\\", \\"...\\"]) == 0 >>> count_paths(3, 3, 1, [\\"...\\", \\"...\\", \\"..#\\"]) == 0","solution":"def count_paths(m, n, k, grid): MOD = 10**9 + 7 # Edge case where starting or ending cell has an obstacle if grid[0][0] == '#' or grid[m-1][n-1] == '#': return 0 # Initializing dp array with zeros dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == '#': continue if i > 0 and abs(i - (i-1)) <= k: dp[i][j] += dp[i-1][j] if j > 0 and abs(j - (j-1)) <= k: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[m-1][n-1]"},{"question":"def is_palindrome(s: str) -> str: A palindrome is a word or phrase that reads the same backward as forward. For example, \\"radar\\" is a palindrome because it reads the same from left to right and from right to left. The input string consists of lowercase Latin letters. The string is not empty and its length does not exceed 100 symbols. >>> is_palindrome(\\"radar\\") 'YES' >>> is_palindrome(\\"hello\\") 'NO'","solution":"def is_palindrome(s: str) -> str: Returns 'YES' if the string is a palindrome and 'NO' otherwise. if s == s[::-1]: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def find_unique_element(nums: List[int]) -> int: Function to find the unique element in a list where each element appears exactly three times except for one element which appears exactly once. >>> find_unique_element([2, 2, 3, 2]) 3 >>> find_unique_element([0, 1, 0, 1, 0, 1, 99]) 99 pass from solution import find_unique_element def test_example_cases(): assert find_unique_element([2, 2, 3, 2]) == 3 assert find_unique_element([0, 1, 0, 1, 0, 1, 99]) == 99 def test_single_element(): assert find_unique_element([1]) == 1 def test_negative_numbers(): assert find_unique_element([-2, -2, -3, -2]) == -3 def test_all_numbers_same(): assert find_unique_element([7, 7, 7, 8]) == 8 def test_large_numbers(): assert find_unique_element([99999999, 99999999, 99999999, 88888888]) == 88888888 def test_mixture_of_positive_and_negative(): assert find_unique_element([-1, -1, -1, 2, 2, 2, 3, 4, 4, 4]) == 3","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: Function to find the unique element in a list where each element except one appears exactly three times. one = 0 # bits that appear exactly once two = 0 # bits that appear exactly twice for num in nums: # Compute 'two' bits that are to be set by this number two |= one & num # Compute 'one' bits that are to be set/cleared by this number one ^= num # Bits that appear three times three = one & two # Clear the bits that appear three times from one and two one &= ~three two &= ~three return one"},{"question":"def min_workers_required(projects: List[Tuple[int, int]]) -> int: Determine the minimum number of workers required to schedule all projects without overlapping. Each project is represented as a pair of integers (s, e) where s is the start time and e is the end time. Parameters: projects (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end time of a project. Returns: int: The minimum number of workers required. >>> min_workers_required([(1, 4), (2, 5), (3, 6), (7, 9), (8, 10)]) 3 >>> min_workers_required([(1, 2), (3, 4), (5, 6)]) 1 >>> min_workers_required([(1, 4), (1, 4), (1, 4), (1, 4)]) 4 >> min_workers_required([(1, 5), (2, 6), (3, 7), (8, 10)]) 3 >>> min_workers_required([(1, 2)]) 1 >>> min_workers_required([(1, 2), (1, 2), (1, 2)]) 3","solution":"def min_workers_required(projects): events = [] for s, e in projects: events.append((s, 1)) events.append((e, -1)) events.sort(key=lambda x: (x[0], x[1])) max_workers = 0 current_workers = 0 for time, event in events: current_workers += event if current_workers > max_workers: max_workers = current_workers return max_workers"},{"question":"from typing import List import math def longest_gcd_subsequence(n: int, sequence: List[int]) -> int: Return the length of the longest subsequence where each pair of consecutive elements has a GCD > 1. >>> longest_gcd_subsequence(5, [2, 4, 6, 8, 10]) 5 >>> longest_gcd_subsequence(3, [4, 2, 5]) 2 >>> longest_gcd_subsequence(1, [7]) 1 >>> longest_gcd_subsequence(6, [12, 15, 18, 21, 24, 27]) 6 >>> longest_gcd_subsequence(4, [7, 11, 13, 17]) 1 >>> longest_gcd_subsequence(5, [30, 25, 20, 15, 10]) 5","solution":"import math def longest_gcd_subsequence(n, sequence): Returns the length of the longest subsequence where each pair of consecutive elements has a GCD > 1. if n == 1: return 1 dp = [1] * n for i in range(n): for j in range(i + 1, n): if math.gcd(sequence[i], sequence[j]) > 1: dp[j] = max(dp[j], dp[i] + 1) return max(dp)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"abababab\\") 2 >>> length_of_longest_substring(\\"a1b2c3d4\\") 8 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyzaaa\\") 26","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. char_index = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def trap_rainwater(heights): Calculates the total amount of rainwater trapped. :param heights: List of integers representing building heights. :return: Integer total amount of trapped rainwater. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rainwater([0, 1, 0, 2, 1, 1, 1]) == 1 >>> trap_rainwater([1, 2, 3, 4, 5]) == 0 >>> trap_rainwater([5, 4, 3, 2, 1]) == 0 >>> trap_rainwater([2, 0, 2]) == 2 >>> trap_rainwater([]) == 0 >>> trap_rainwater([2]) == 0 >>> trap_rainwater([0]) == 0 >>> trap_rainwater([2] * 100000) == 0 >>> trap_rainwater([i % 10 for i in range(100000)]) == 0","solution":"def trap_rainwater(heights): Calculates the total amount of rainwater trapped. :param heights: List of integers representing building heights. :return: Integer total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Create left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Create right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def minimum_waterings(n: int, m: int, plantation: List[str]) -> int: Given a set of tree plantations on a farmland, each tree plantation is represented by a rectangular grid of n × m cells. Each cell either contains a tree (represented by 'T') or is empty (represented by '.'). The goal is to find the minimum number of waterings required to water all the trees in the plantation. >>> minimum_waterings(5, 6, [\\"..TT..\\", \\"..TT..\\", \\"......\\", \\"T..T.T\\", \\"T..T.T\\"]) 4 >>> minimum_waterings(3, 3, [\\"TTT\\", \\"T.T\\", \\"TTT\\"]) 1 >>> minimum_waterings(4, 4, [\\"T.TT\\", \\".T..\\", \\"TT.T\\", \\".TT.\\"]) 4 >>> minimum_waterings(1, 1, [\\"T\\"]) 1 >>> minimum_waterings(1, 3, [\\"T.T\\"]) 2 >>> minimum_waterings(5, 5, [\\".....\\", \\".....\\", \\"T....\\", \\".....\\", \\".....\\"]) 1","solution":"def minimum_waterings(n, m, plantation): def mark_visited(x, y): queue = [(x, y)] while queue: cx, cy = queue.pop(0) for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and plantation[nx][ny] == 'T': visited[nx][ny] = True queue.append((nx, ny)) visited = [[False] * m for _ in range(n)] waterings = 0 for i in range(n): for j in range(m): if plantation[i][j] == 'T' and not visited[i][j]: waterings += 1 visited[i][j] = True mark_visited(i, j) return waterings"},{"question":"def can_form_palindrome(n: int, s: str) -> str: Determines if it is possible to rearrange the characters to form a palindrome. :param n: int - length of the character sequence :param s: str - the string of characters :return: str - \\"YES\\" if it is possible to rearrange to form a palindrome, otherwise \\"NO\\" >>> can_form_palindrome(6, \\"aabbcc\\") \\"YES\\" >>> can_form_palindrome(5, \\"abcba\\") \\"YES\\" >>> can_form_palindrome(4, \\"abcd\\") \\"NO\\"","solution":"def can_form_palindrome(n, s): Determines if it is possible to rearrange the characters to form a palindrome. :param n: int - length of the character sequence :param s: str - the string of characters :return: str - \\"YES\\" if it is possible to rearrange to form a palindrome, otherwise \\"NO\\" from collections import Counter count = Counter(s) odd_count = sum(1 for freq in count.values() if freq % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def find_path(n: int, m: int, edges: List[Tuple[int, int]], k: int) -> Union[List[int], str]: Given an undirected connected graph, find a simple path that passes through exactly k distinct vertices, starting from vertex 1. If such a path exists, return the sequence of vertices; otherwise, return \\"-1\\". >>> find_path(5, 4, [(1, 2), (1, 3), (3, 4), (3, 5)], 3) [1, 3, 4] >>> find_path(5, 3, [(1, 2), (2, 3), (3, 4)], 5) \\"-1\\" >>> find_path(4, 4, [(1, 2), (2, 3), (3, 4), (1, 4)], 4) [1, 2, 3, 4] >>> find_path(3, 2, [(1, 2), (2, 3)], 3) [1, 2, 3] >>> find_path(4, 2, [(1, 2), (3, 4)], 3) \\"-1\\"","solution":"from collections import defaultdict, deque def find_path(n, m, edges, k): # Build adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Use a BFS to find a path starting from vertex 1 queue = deque([(1, [1])]) visited = set() while queue: current, path = queue.popleft() if len(path) == k: return path if current in visited: continue visited.add(current) for neighbor in graph[current]: if neighbor not in path: new_path = path + [neighbor] queue.append((neighbor, new_path)) return \\"-1\\""},{"question":"def smallest_missing_positive_integer(arr): Finds the smallest missing positive integer in the given array. >>> smallest_missing_positive_integer([3, 4, -1, 1]) 2 >>> smallest_missing_positive_integer([1, 2, 0]) 3 >>> smallest_missing_positive_integer([7, 8, 9, 11, 12]) 1 pass def process_test_cases(t, test_cases): Process multiple test cases to find the smallest missing positive integer for each. >>> process_test_cases(3, [[3, 4, -1, 1], [1, 2, 0], [7, 8, 9, 11, 12]]) [2, 3, 1] >>> process_test_cases(2, [[1, 0], [2, 3, 4]]) [2, 1] >>> process_test_cases(1, [[-1, -2, -3]]) [1] pass from solution import process_test_cases def test_case_1(): assert process_test_cases(3, [[3, 4, -1, 1], [1, 2, 0], [7, 8, 9, 11, 12]]) == [2, 3, 1] def test_case_2(): assert process_test_cases(2, [[1, 0], [2, 3, 4]]) == [2, 1] def test_case_3(): assert process_test_cases(1, [[-1, -2, -3]]) == [1] def test_case_4(): assert process_test_cases(1, [[1, 2, 3, 4, 5]]) == [6] def test_case_5(): assert process_test_cases(1, [[0, 0, 0, 0]]) == [1] def test_case_6(): assert process_test_cases(1, [[1]]) == [2] def test_case_7(): assert process_test_cases(1, [[2]]) == [1] def test_case_8(): assert process_test_cases(1, [[2, 2, 2, 2]]) == [1]","solution":"def smallest_missing_positive_integer(arr): Finds the smallest missing positive integer in the given array. n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1 def process_test_cases(t, test_cases): results = [] for i in range(t): array = test_cases[i] result = smallest_missing_positive_integer(array) results.append(result) return results"},{"question":"def min_changes_to_palindrome(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the minimum number of character changes required to make each string a palindrome. Args: t: The number of test cases. test_cases: A list of tuples, each with the length of a string and the string itself. Returns: A list of integers representing the minimum number of character changes required for each string. Example: >>> min_changes_to_palindrome(3, [(3, \\"abc\\"), (4, \\"abca\\"), (5, \\"abcba\\")]) [1, 1, 0]","solution":"def min_changes_to_palindrome(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] s = test_cases[i][1] count = 0 for j in range(n // 2): if s[j] != s[n - j - 1]: count += 1 results.append(count) return results # Function to parse input and process outputs accordingly def process_input_output(input_lines): t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) s = input_lines[index + 1] test_cases.append((n, s)) index += 2 results = min_changes_to_palindrome(t, test_cases) for result in results: print(result) # Example of processing input and running the solution input_example = [ \\"3\\", \\"3\\", \\"abc\\", \\"4\\", \\"abca\\", \\"5\\", \\"abcba\\" ] process_input_output(input_example)"},{"question":"def max_boxes(n: int, m: int) -> int: Calculate the maximum number of boxes that can be placed in a warehouse grid of dimensions n x m without having any two boxes in adjacent cells. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: int: Maximum number of boxes. >>> max_boxes(1, 1) 1 >>> max_boxes(2, 3) 3 >>> max_boxes(3, 3) 5","solution":"def max_boxes(n, m): Calculate the maximum number of boxes that can be placed in a warehouse grid of dimensions n x m without having any two boxes in adjacent cells. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: int: Maximum number of boxes. # Each second cell in a checkerboard pattern can contain a box return (n * m + 1) // 2"},{"question":"def find_minimum_spanning_tree_weight(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Finds the total weight of the Minimum Spanning Tree (MST) for a given undirected graph. :param n: Number of nodes in the graph. :param m: Number of edges in the graph. :param edges: List of edges, where each edge is represented by a tuple (u, v, w). :return: Total weight of the Minimum Spanning Tree. >>> find_minimum_spanning_tree_weight(4, 5, [(1, 2, 10), (1, 3, 6), (1, 4, 5), (2, 3, 15), (3, 4, 4)]) 19 >>> find_minimum_spanning_tree_weight(1, 0, []) 0 >>> find_minimum_spanning_tree_weight(4, 6, [(1, 2, 10), (1, 3, 10), (1, 4, 10), (2, 3, 10), (3, 4, 10), (2, 4, 10)]) 30 >>> find_minimum_spanning_tree_weight(3, 3, [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) 2 >>> find_minimum_spanning_tree_weight(4, 5, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 4, 2), (2, 4, 2)]) 6","solution":"def find_minimum_spanning_tree_weight(n, m, edges): Finds the total weight of the Minimum Spanning Tree (MST) for a given undirected graph. :param n: Number of nodes in the graph. :param m: Number of edges in the graph. :param edges: List of edges, where each edge is represented by a tuple (u, v, w). :return: Total weight of the Minimum Spanning Tree. # Using Kruskal's algorithm and Union-Find data structure parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 edges.sort(key=lambda x: x[2]) mst_weight = 0 for u, v, w in edges: if find(u) != find(v): union(u, v) mst_weight += w return mst_weight"},{"question":"from collections import defaultdict, deque def find_min_time(n: int, dependencies: List[Tuple[int, int]]) -> int: Determine the minimum time required to complete the project given the dependencies between tasks in a directed acyclic graph. >>> find_min_time(5, [(1, 2), (2, 3), (4, 3), (3, 5)]) == 4 4 >>> find_min_time(5, []) == 1 1 >>> find_min_time(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 5 5 >>> find_min_time(5, [(1, 3), (2, 3), (3, 5), (4, 5)]) == 3 3 >>> find_min_time(3, [(1, 2), (2, 3)]) == 3 3 >>> find_min_time(6, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (4, 6)]) == 4 4","solution":"from collections import defaultdict, deque def find_min_time(n, dependencies): graph = defaultdict(list) indegree = {i: 0 for i in range(1, n+1)} for u, v in dependencies: graph[u].append(v) indegree[v] += 1 queue = deque() distance = {i: 0 for i in range(1, n+1)} for node in indegree: if indegree[node] == 0: queue.append(node) distance[node] = 1 while queue: node = queue.popleft() for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) distance[neighbor] = max(distance[neighbor], distance[node] + 1) return max(distance.values())"},{"question":"from typing import List def longest_subsequence(arr: List[int]) -> List[int]: Write a function that finds the longest subsequence in an array where the difference between consecutive elements is either 1 or -1. If there are multiple subsequences with the same maximum length, return any of them. >>> longest_subsequence([3, 4, 5, 6, 7, 1, 2, 4, 3]) [3, 4, 5, 6, 7] >>> longest_subsequence([1]) [1] >>> longest_subsequence([3, 8, 12, 1, 5, 9]) [3] >>> longest_subsequence([1, 2, 3, 1, 2, 3]) [1, 2, 3] # Any valid sequence >>> longest_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> longest_subsequence([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> longest_subsequence([1, 2, 1, 2, 1, 2, 1]) [1, 2, 1, 2, 1, 2, 1] >>> longest_subsequence([]) []","solution":"def longest_subsequence(arr): if not arr: return [] longest_seq = [] current_seq = [arr[0]] for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) == 1: current_seq.append(arr[i]) else: if len(current_seq) > len(longest_seq): longest_seq = current_seq current_seq = [arr[i]] if len(current_seq) > len(longest_seq): longest_seq = current_seq return longest_seq"},{"question":"def min_moves(shelves: List[int], books: List[int]) -> int: Determine the minimum number of moves required to stack books on bookshelves or if it is impossible. >>> min_moves([5, 3, 4], [3, 4, 1]) 2 >>> min_moves([3, 3, 3], [5, 5, 5]) -1 # Your code here # Test cases def test_min_moves_possible_case(): assert min_moves([5, 3, 4], [3, 4, 1]) == 2 def test_min_moves_impossible_case(): assert min_moves([3, 3, 3], [5, 5, 5]) == -1 def test_min_moves_single_shelf_possible(): assert min_moves([2], [1]) == 1 def test_min_moves_single_shelf_impossible(): assert min_moves([1], [2]) == -1 def test_min_moves_more_complex_possible_case(): assert min_moves([7, 5, 8, 4], [4, 5, 3, 1]) == 4 def test_min_moves_more_complex_impossible_case(): assert min_moves([8, 5, 3, 6], [5, 3, 8, 7]) == -1 def test_min_moves_exact_fit(): assert min_moves([3, 7, 5], [5, 7, 3]) == 3 def test_min_moves_minimal_case_possible(): assert min_moves([1], [1]) == 1","solution":"def min_moves(shelves, books): # Sort the shelves' heights and books' widths in descending order shelves.sort(reverse=True) books.sort(reverse=True) # Check if there's any book that can't be placed on its corresponding shelf for i in range(len(shelves)): if books[i] > shelves[i]: return -1 # Return the minimum number of moves which is the number of shelves return len(shelves)"},{"question":"def filter_even_and_greater_than_10(int_list): Takes a list of integers and returns a new list containing only the integers that are even and greater than 10. >>> filter_even_and_greater_than_10([8, 12, 15, 22]) [12, 22] >>> filter_even_and_greater_than_10([3, 5, 7, 9, 11]) [] >>> filter_even_and_greater_than_10([12, 14, 20]) [12, 14, 20] >>> filter_even_and_greater_than_10([10, 11, 22, 23]) [22] >>> filter_even_and_greater_than_10([11]) [] >>> filter_even_and_greater_than_10([12]) [12] >>> filter_even_and_greater_than_10([24, 36, 48, 50]) [24, 36, 48, 50] >>> filter_even_and_greater_than_10([100, 99, 98]) [100, 98] >>> filter_even_and_greater_than_10([0, 100]) [100]","solution":"def filter_even_and_greater_than_10(int_list): Takes a list of integers and returns a new list containing only the integers that are even and greater than 10. return [x for x in int_list if x > 10 and x % 2 == 0]"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"a\\") 1 >>> longest_unique_substring(\\"abcdef\\") 6 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"abcde\\"*20000) 5 >>> longest_unique_substring(\\"aabccbbxyzxyzxyz\\") 4","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. if not s: return 0 char_index = {} max_len = 0 start = 0 for end, char in enumerate(s): if char in char_index: start = max(start, char_index[char] + 1) char_index[char] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def min_max_height_difference(n: int, m: int, heights: List[List[int]]) -> int: Find the minimum possible value of the maximum height difference in the optimal path from the top-left to the bottom-right corner. >>> min_max_height_difference(3, 3, [[8, 4, 7], [6, 5, 9], [3, 2, 7]]) == 3 >>> min_max_height_difference(1, 1, [[1]]) == 0 >>> min_max_height_difference(2, 2, [[1, 3], [5, 2]]) == 2 >>> min_max_height_difference(3, 3, [[1000000, 1000000, 1000000], [1000000, 1000000, 1000000], [1000000, 1000000, 1000000]]) == 0 >>> min_max_height_difference(3, 3, [[1, 100, 1], [100, 1, 100], [1, 100, 1]]) == 99","solution":"import heapq def min_max_height_difference(n, m, heights): def is_valid(x, y): return 0 <= x < n and 0 <= y < m directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_heap = [(0, 0, 0)] max_diff = [[float('inf')] * m for _ in range(n)] max_diff[0][0] = 0 while min_heap: curr_diff, x, y = heapq.heappop(min_heap) if x == n-1 and y == m-1: return curr_diff for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): new_diff = max(curr_diff, abs(heights[x][y] - heights[nx][ny])) if new_diff < max_diff[nx][ny]: max_diff[nx][ny] = new_diff heapq.heappush(min_heap, (new_diff, nx, ny)) return -1 def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) heights = [] index = 2 for i in range(n): row = [] for j in range(m): row.append(int(data[index])) index += 1 heights.append(row) result = min_max_height_difference(n, m, heights) print(result)"},{"question":"from typing import List, Tuple def process_queries(n: int, q: int, arr: List[int], queries: List[List[int]]) -> List[int]: Processes a list of update and sum queries on an array. Parameters: n (int): Length of the array. q (int): Number of queries. arr (List[int]): The initial array. queries (List[List[int]]): List of queries where each query is of the form [query_type, i, x] or [query_type, l, r]. Returns: List[int]: The results of all the sum queries. Example: >>> process_queries(5, 3, [1, 2, 3, 4, 5], [[2, 1, 3], [1, 2, 10], [2, 2, 5]]) [6, 22]","solution":"def process_queries(n, q, arr, queries): results = [] for query in queries: if query[0] == 1: i, x = query[1], query[2] arr[i - 1] = x elif query[0] == 2: l, r = query[1], query[2] results.append(sum(arr[l - 1:r])) return results"},{"question":"def pack_items(n: int, W: int, weights: List[int]) -> Tuple[int, List[List[int]]]: Return the minimum number of boxes required and the packing configuration. Args: n (int): Number of items. W (int): Maximum weight a box can hold. weights (List[int]): Weights of each item. Returns: Tuple[int, List[List[int]]]: Minimum number of boxes required and the packing configuration. Example: >>> pack_items(5, 10, [2, 3, 5, 7, 1]) (2, [[2, 5, 3], [7, 1]])","solution":"from itertools import combinations def pack_items(n, W, weights): Returns the minimum number of boxes required and the packing configuration. weights.sort(reverse=True) # Sort weights in descending order boxes = [] while weights: current_box = [] current_weight = 0 used_indexes = [] for i, weight in enumerate(weights): if current_weight + weight <= W: current_box.append(weight) current_weight += weight used_indexes.append(i) # Remove used items from the list for i in sorted(used_indexes, reverse=True): weights.pop(i) boxes.append(current_box) return len(boxes), boxes"},{"question":"def next_traffic_light_state(lights): Given a list of integers representing the current state of the traffic lights, returns a list of integers representing the next state of the traffic lights. >>> next_traffic_light_state([0, 1, 2, 0, 1]) [1, 2, 0, 1, 2] >>> next_traffic_light_state([2, 2, 2]) [0, 0, 0] >>> next_traffic_light_state([1, 0, 1, 0]) [2, 1, 2, 1]","solution":"def next_traffic_light_state(lights): Given a list of integers representing the current state of the traffic lights, returns a list of integers representing the next state of the traffic lights. return [(light + 1) % 3 for light in lights]"},{"question":"def longest_common_prefix(strings): Given a list of strings, determine the longest common prefix that is shared among all the strings in the list. The common prefix is the longest starting sequence of characters that appears in each string in the exact same order. If there is no common prefix, returns an empty string. >>> longest_common_prefix([\\"apple\\", \\"apple\\", \\"apple\\"]) == \\"apple\\" >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\", \\"flamingo\\", \\"flop\\"]) == \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" >>> longest_common_prefix([]) == \\"\\" >>> longest_common_prefix([\\"alone\\"]) == \\"alone\\" >>> longest_common_prefix([\\"a\\", \\"ab\\", \\"abc\\"]) == \\"a\\" >>> longest_common_prefix([\\"interview\\", \\"intermediate\\", \\"internal\\", \\"internet\\"]) == \\"inter\\" >>> longest_common_prefix([\\"prefix\\", \\"preparation\\", \\"preoccupation\\", \\"pre\\"]) == \\"pre\\"","solution":"def longest_common_prefix(strings): Function to find the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. if not strings: return \\"\\" # Sort the strings strings.sort() # Compare characters of the first and the last strings in the sorted order first_string = strings[0] last_string = strings[-1] common_prefix_length = 0 for i in range(min(len(first_string), len(last_string))): if first_string[i] == last_string[i]: common_prefix_length += 1 else: break return first_string[:common_prefix_length]"},{"question":"from typing import List def longest_common_prefix(binary_strings: List[str]) -> str: Returns the longest common prefix of a list of binary strings. Args: binary_strings (List[str]): List of binary strings. Returns: str: The longest common prefix among the given binary strings. Examples: >>> longest_common_prefix([\\"1101\\", \\"1100\\", \\"110\\", \\"111\\"]) '11' >>> longest_common_prefix([\\"001\\", \\"010\\", \\"000\\"]) '0'","solution":"def longest_common_prefix(binary_strings): Returns the longest common prefix of a list of binary strings. if not binary_strings: return \\"\\" # Start with the first string as the initial prefix prefix = binary_strings[0] for binary_string in binary_strings[1:]: # Compare the prefix with each string temp_prefix = \\"\\" for i in range(min(len(prefix), len(binary_string))): if prefix[i] == binary_string[i]: temp_prefix += prefix[i] else: break prefix = temp_prefix # Early exit if the common prefix becomes empty if not prefix: break return prefix"},{"question":"def max_difference(t, test_cases): Returns the maximum difference between any two elements a_i and a_j such that i < j for each given test case. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list containing tuples of test cases. Each tuple contains: - n (int): Length of the array. - a (List[int]): The array of integers. Returns: List[int]: A list containing the maximum differences for each test case. Example: >>> max_difference(1, [(5, [1, 2, 90, 10, 110])]) [109] >>> max_difference(1, [(4, [-10, -20, -30, -40])]) [-10] >>> max_difference(1, [(1, [10])]) [0] >>> max_difference(1, [(2, [10, 20])]) [10] >>> max_difference(1, [(5, [1, 1, 1, 1, 1])]) [0] >>> max_difference(1, [(7, [10, 7, 5, 8, 11, 9, 1])]) [6] >>> max_difference(1, [(100000, list(range(100000)))]) [99999] >>> max_difference(2, [(5, [1, 2, 90, 10, 110]), (3, [3, -1, 2])]) [109, 3]","solution":"def max_difference(t, test_cases): Returns the maximum difference between any two elements a_i and a_j such that i < j for each given test case. results = [] for case in test_cases: n, a = case if n < 2: results.append(0) # Since there's no pair to compare. continue min_element = a[0] max_diff = a[1] - a[0] for j in range(1, n): max_diff = max(max_diff, a[j] - min_element) min_element = min(min_element, a[j]) results.append(max_diff) return results"},{"question":"def min_moves_to_relocate_containers(n: int, initial_positions: List[Tuple[int, int]], target_positions: List[Tuple[int, int]]) -> int: Calculate the minimum number of moves required to relocate containers from initial positions to target positions. Args: n (int): Number of containers. initial_positions (list of tuples): List of (x, y) pairs representing initial positions of containers. target_positions (list of tuples): List of (x', y') pairs representing target positions of containers. Returns: int: Minimum number of moves required. Examples: >>> min_moves_to_relocate_containers(2, [(1, 1), (2, 2)], [(3, 3), (4, 4)]) 8 >>> min_moves_to_relocate_containers(1, [(1, 1)], [(1, 1)]) 0","solution":"def min_moves_to_relocate_containers(n, initial_positions, target_positions): Calculates the minimum number of moves required to relocate containers from initial positions to target positions. Args: n (int): Number of containers. initial_positions (list of tuples): List of (x, y) pairs representing initial positions of containers. target_positions (list of tuples): List of (x', y') pairs representing target positions of containers. Returns: int: Minimum number of moves required. total_moves = 0 for i in range(n): initial_x, initial_y = initial_positions[i] target_x, target_y = target_positions[i] total_moves += abs(initial_x - target_x) + abs(initial_y - target_y) return total_moves"},{"question":"def maxItems(prices: List[int], budget: int) -> int: Returns the maximum number of items that can be bought without exceeding the budget. >>> maxItems([1, 12, 5, 111, 200], 10) 2 >>> maxItems([20, 50, 70, 30, 10, 40], 100) 4","solution":"def maxItems(prices, budget): Returns the maximum number of items that can be bought without exceeding the budget. Parameters: prices (list of int): List of item prices. budget (int): The total budget available. Returns: int: Maximum number of items that can be bought. prices.sort() total_cost = 0 count = 0 for price in prices: if total_cost + price <= budget: total_cost += price count += 1 else: break return count"},{"question":"def calculate_expression(expression: str) -> int: Evaluates a simple arithmetic expression containing two integers and an operator. The operators can be +, -, *, or /. Division assumes integer division. >>> calculate_expression(\\"3+4\\") 7 >>> calculate_expression(\\"10-3\\") 7 >>> calculate_expression(\\"6*5\\") 30 >>> calculate_expression(\\"8/3\\") 2","solution":"def calculate_expression(expression: str) -> int: Evaluates a simple arithmetic expression containing two integers and an operator. The operators can be +, -, *, or /. Division assumes integer division. # Identify the operator in the expression if '+' in expression: a, b = expression.split('+') return int(a) + int(b) elif '-' in expression: a, b = expression.split('-') return int(a) - int(b) elif '*' in expression: a, b = expression.split('*') return int(a) * int(b) elif '/' in expression: a, b = expression.split('/') return int(a) // int(b)"},{"question":"def longest_increasing_subsequence_length(n: int, temperatures: List[int]) -> int: Given a sequence of temperatures, determine the length of the longest continuous increasing subsequence. >>> longest_increasing_subsequence_length(6, [-5, -4, -3, -3, -2, -1]) 3 >>> longest_increasing_subsequence_length(1, [5]) 1 >>> longest_increasing_subsequence_length(5, [1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence_length(5, [5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length(10, [1, 2, 2, 3, 1, 2, 3, 4, 5, 1]) 5 >>> longest_increasing_subsequence_length(0, []) 0 >>> longest_increasing_subsequence_length(6, [-3, -2, -1, -4, -3, -2]) 3 >>> longest_increasing_subsequence_length(5, [3, 3, 3, 3, 3]) 1","solution":"def longest_increasing_subsequence_length(n, temperatures): Given a sequence of temperatures, determine the length of the longest continuous increasing subsequence. :param n: int - the number of temperature readings :param temperatures: list of int - the sequence of temperature readings :return: int - the length of the longest continuous increasing subsequence if n == 0: return 0 # Initialize variables longest = 1 current_length = 1 # Iterate through the temperature readings for i in range(1, n): if temperatures[i] > temperatures[i - 1]: current_length += 1 longest = max(longest, current_length) else: current_length = 1 return longest"},{"question":"class Library: A library wants to track book lending and returns by its members. Implement a system with the following functionalities: 1. Add Book: Add a new book to the library. 2. Remove Book: Remove a book from the library. If the book is currently lent out, it should not be removed but an error message should be returned. 3. Lend Book: Lend a book to a member. If the book is already lent out or does not exist, an error message should be returned. 4. Return Book: Return a book that was lent out. If the book was not lent out or does not exist, an error message should be returned. >>> library = Library() >>> library.add_book('book1') 'SUCCESS' >>> library.lend_book('book1', 'member1') 'SUCCESS' >>> library.return_book('book1') 'SUCCESS' >>> library.remove_book('book1') 'SUCCESS' def __init__(self): self.books = {} self.lent_books = {} def add_book(self, book_id: str) -> str: pass def remove_book(self, book_id: str) -> str: pass def lend_book(self, book_id: str, member_id: str) -> str: pass def return_book(self, book_id: str) -> str: pass","solution":"class Library: def __init__(self): self.books = {} self.lent_books = {} def add_book(self, book_id): if book_id in self.books: return \\"SUCCESS\\" self.books[book_id] = None return \\"SUCCESS\\" def remove_book(self, book_id): if book_id not in self.books: return \\"BOOK_NOT_FOUND\\" if self.books[book_id] is not None: return \\"BOOK_CANNOT_BE_REMOVED\\" del self.books[book_id] return \\"SUCCESS\\" def lend_book(self, book_id, member_id): if book_id not in self.books: return \\"BOOK_NOT_FOUND\\" if self.books[book_id] is not None: return \\"BOOK_ALREADY_LENT\\" self.books[book_id] = member_id return \\"SUCCESS\\" def return_book(self, book_id): if book_id not in self.books: return \\"BOOK_NOT_FOUND\\" if self.books[book_id] is None: return \\"BOOK_NOT_LENT\\" self.books[book_id] = None return \\"SUCCESS\\""},{"question":"def calculator(commands): Processes a sequence of calculator commands and prints the results of the calculations as well as the history when requested. >>> calculator([\\"Add 1 2\\", \\"History\\"]) [3, 'Add 1 2 = 3'] >>> calculator([\\"Subtract 5 3\\", \\"History\\"]) [2, 'Subtract 5 3 = 2'] >>> calculator([\\"Multiply 3 4\\", \\"History\\"]) [12, 'Multiply 3 4 = 12'] >>> calculator([\\"Divide 8 2\\", \\"History\\"]) [4, 'Divide 8 2 = 4'] >>> calculator([\\"Divide 8 0\\", \\"History\\"]) [\\"Error: Division by zero\\"] >>> calculator([ \\"Add 5 7\\", \\"Subtract 10 3\\", \\"Multiply 6 4\\", \\"Divide 12 3\\", \\"History\\" ]) [ 12, 7, 24, 4, \\"Add 5 7 = 12\\", \\"Subtract 10 3 = 7\\", \\"Multiply 6 4 = 24\\", \\"Divide 12 3 = 4\\" ]","solution":"def calculator(commands): history = [] results = [] for command in commands: parts = command.split() op = parts[0] if op == 'Add': x, y = int(parts[1]), int(parts[2]) result = x + y results.append(result) history.append(f\\"{command} = {result}\\") elif op == 'Subtract': x, y = int(parts[1]), int(parts[2]) result = x - y results.append(result) history.append(f\\"{command} = {result}\\") elif op == 'Multiply': x, y = int(parts[1]), int(parts[2]) result = x * y results.append(result) history.append(f\\"{command} = {result}\\") elif op == 'Divide': x, y = int(parts[1]), int(parts[2]) if y != 0: result = x // y # integer division results.append(result) history.append(f\\"{command} = {result}\\") else: results.append(\\"Error: Division by zero\\") elif op == 'History': results.extend(history) return results # Example input commands as a list commands = [ \\"Add 5 7\\", \\"Subtract 10 3\\", \\"Multiply 6 4\\", \\"Divide 12 3\\", \\"History\\" ] # Example usage print(\\"n\\".join(map(str, calculator(commands))))"},{"question":"from typing import List, Tuple def subtree_sum(N: int, values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Calculate the sum of values in the subtree of a given node. Args: N (int): the number of nodes in the tree. values (List[int]): the values associated with each node. edges (List[Tuple[int, int]]): the edges forming the tree. queries (List[int]): the queries to find the sum of values in the subtree of the given nodes. Returns: List[int]: the results of the queries. Example: >>> N = 5 >>> values = [1, 2, 3, 4, 5] >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> queries = [3, 1, 4] >>> subtree_sum(N, values, edges, queries) [12, 15, 4] pass # Unit Test import pytest def test_example(): N = 5 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [3, 1, 4] assert subtree_sum(N, values, edges, queries) == [12, 15, 4] def test_single_node(): N = 1 values = [10] edges = [] queries = [1] assert subtree_sum(N, values, edges, queries) == [10] def test_line_tree(): N = 3 values = [1, 2, 3] edges = [(1, 2), (2, 3)] queries = [1, 2, 3] assert subtree_sum(N, values, edges, queries) == [6, 5, 3] def test_star_tree(): N = 4 values = [1, 2, 3, 4] edges = [(1, 2), (1, 3), (1, 4)] queries = [1, 2, 3] assert subtree_sum(N, values, edges, queries) == [10, 2, 3] def test_balanced_tree(): N = 7 values = [1, 2, 3, 4, 5, 6, 7] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] queries = [2, 3, 6] assert subtree_sum(N, values, edges, queries) == [11, 16, 6] if __name__ == \\"__main__\\": pytest.main([__file__])","solution":"def subtree_sum(N, values, edges, queries): from collections import defaultdict, deque # Build the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # To store the sum of each subtree subtree_sums = [0] * (N + 1) # DFS to calculate subtree sums def dfs(node, parent): subtree_sums[node] = values[node - 1] # Include current node's value for neighbor in tree[node]: if neighbor != parent: dfs(neighbor, node) subtree_sums[node] += subtree_sums[neighbor] # Start DFS from the root node 1 dfs(1, -1) # Answer the queries results = [subtree_sums[x] for x in queries] return results"},{"question":"def compress_string(t: int, strings: List[str]) -> List[str]: This function takes in an integer t and a list of strings, compresses each string according to the specified rules, and returns a list of compressed strings. :param t: Number of strings (test cases) :param strings: List of strong consistent strings to be compressed :return: List of compressed strings >>> compress_string(1, [\\"aaabbbcccaaa\\"]) ['a3b3c3a3'] >>> compress_string(1, [\\"aabbaacc\\"]) ['a2b2a2c2'] >>> compress_string(1, [\\"zzzzzzz\\"]) ['z7']","solution":"def compress_string(t, strings): This function takes in an integer t and a list of strings, compresses each string according to the specified rules, and returns a list of compressed strings. :param t: Number of strings (test cases) :param strings: List of strong consistent strings to be compressed :return: List of compressed strings results = [] for s in strings: compressed = \\"\\" i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 compressed += s[i] + (str(count) if count > 1 else \\"\\") i += 1 results.append(compressed) return results # Example usage # t = 3 # strings = [\\"aaabbbcccaaa\\", \\"aabbaacc\\", \\"zzzzzzz\\"] # compress_string(t, strings)"},{"question":"import pytest def encoded_string(s: str) -> str: Remove all pairs of adjacent characters in the string until no more pairs can be removed. Return the resulting string or \\"EMPTY\\" if the string becomes empty. pass def test_encoded_string(): assert encoded_string(\\"abccba\\") == \\"EMPTY\\" assert encoded_string(\\"aabbaa\\") == \\"EMPTY\\" assert encoded_string(\\"ababab\\") == \\"ababab\\" assert encoded_string(\\"a\\") == \\"a\\" assert encoded_string(\\"aa\\") == \\"EMPTY\\" assert encoded_string(\\"abba\\") == \\"EMPTY\\" assert encoded_string(\\"abc\\") == \\"abc\\" assert encoded_string(\\"\\") == \\"EMPTY\\" def test_encoded_string_single_char(): assert encoded_string(\\"z\\") == \\"z\\" def test_encoded_string_no_pairs(): assert encoded_string(\\"abcdefg\\") == \\"abcdefg\\" def test_encoded_string_with_subsequent_pairs(): assert encoded_string(\\"abbaca\\") == \\"ca\\" def test_encoded_string_all_same_chars(): assert encoded_string(\\"aaa\\") == \\"a\\" assert encoded_string(\\"aaaa\\") == \\"EMPTY\\" def test_encoded_string_large_case(): long_input = \\"a\\" * (10**5) assert encoded_string(long_input) == \\"EMPTY\\"","solution":"def encoded_string(s): Remove all pairs of adjacent characters in the string until no more pairs can be removed. Return the resulting string or \\"EMPTY\\" if the string becomes empty. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack) if stack else \\"EMPTY\\""},{"question":"def longest_increasing_path(matrix): Find the length of the longest increasing path in a matrix. >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longest_increasing_path([ ... [5] ... ]) 1 >>> longest_increasing_path([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 1 >>> longest_increasing_path([ ... [1, 2, 3], ... [6, 5, 4], ... [7, 8, 9] ... ]) 9 >>> longest_increasing_path([]) 0 >>> longest_increasing_path([ ... [1, 2, 3, 4], ... [8, 7, 6, 5], ... [9, 10, 11, 12] ... ]) 12","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) memo = [[-1 for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if memo[r][c] != -1: return memo[r][c] # Define directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_path_length = 1 for dr, dc in directions: new_r, new_c = r + dr, c + dc if 0 <= new_r < rows and 0 <= new_c < cols and matrix[new_r][new_c] > matrix[r][c]: max_path_length = max(max_path_length, 1 + dfs(new_r, new_c)) memo[r][c] = max_path_length return memo[r][c] longest_path = 0 for r in range(rows): for c in range(cols): longest_path = max(longest_path, dfs(r, c)) return longest_path"},{"question":"def shortest_substring_length(n: int, s: str) -> int: Returns the length of the shortest substring that contains at least one 'a', one 'b', and one 'c'. If no such substring exists, return -1. >>> shortest_substring_length(5, \\"aabcc\\") == 3 >>> shortest_substring_length(10, \\"abcabcabca\\") == 3 >>> shortest_substring_length(7, \\"aaaaaaa\\") == -1","solution":"def shortest_substring_length(n, s): Returns the length of the shortest substring that contains at least one 'a', one 'b', and one 'c'. If no such substring exists, return -1. # Initialize the pointers and counters for the sliding window left = 0 min_length = float('inf') count = {'a': 0, 'b': 0, 'c': 0} for right in range(n): count[s[right]] += 1 # Check if we have at least one of each character while all(count[char] > 0 for char in 'abc'): min_length = min(min_length, right - left + 1) count[s[left]] -= 1 left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def lexicographically_smallest_string(text: str) -> str: Finds the lexicographically smallest string that can be obtained by removing exactly one character from the original string. >>> lexicographically_smallest_string(\\"abc\\") \\"ab\\" >>> lexicographically_smallest_string(\\"acb\\") \\"ab\\" >>> lexicographically_smallest_string(\\"bbbbbb\\") \\"bbbbb\\" >>> lexicographically_smallest_string(\\"abcdxyz\\") \\"abcdxy\\"","solution":"def lexicographically_smallest_string(text): Finds the lexicographically smallest string that can be obtained by removing exactly one character from the original string. for i in range(len(text) - 1): if text[i] > text[i + 1]: return text[:i] + text[i + 1:] return text[:-1]"},{"question":"def count_eternal_sequences(m: int) -> int: Given an integer m, determine the number of unique eternal sequences of length m. Output the number modulo 1000000007 (10^9 + 7). >>> count_eternal_sequences(1) -1 >>> count_eternal_sequences(2) 2 >>> count_eternal_sequences(3) 4 >>> count_eternal_sequences(4) 8 >>> count_eternal_sequences(10) 512 >>> count_eternal_sequences(20) 524288","solution":"def count_eternal_sequences(m): Returns the number of unique eternal sequences of length m modulo 1000000007. MOD = 1000000007 # If m == 1, any number is a valid sequence, there are infinite such sequences if m == 1: return -1 # Special case: there would technically be infinite sequences # dp[i] will store the number of unique eternal sequences of length i dp = [0] * (m + 1) # Initial number of sequences for length 1 and 2 dp[1] = 0 # Special case handled above dp[2] = 2 # There are two sequences of length 2: [1,2] and [2,1] for i in range(3, m + 1): dp[i] = (2 * dp[i-1]) % MOD return dp[m]"},{"question":"def find_minimal_path(n: int, m: int, roads: List[Tuple[int, int]]) -> List[int]: Find the three cities and the order in which the traveler should visit them to minimize the total travel distance. Args: n (int): The number of cities. m (int): The number of one-way roads. roads (List[Tuple[int, int]]): A list of one-way roads represented as pairs of integers. Returns: List[int]: The order of cities the traveler should visit to minimize the total travel distance. Examples: >>> find_minimal_path(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3), (2, 4)]) [1, 2, 3] >>> find_minimal_path(3, 3, [(1, 2), (2, 3), (3, 1)]) [1, 2, 3] pass from typing import List, Tuple def test_example_scenario_1(): n = 5 m = 6 roads = [ (1, 2), (2, 3), (3, 4), (4, 5), (1, 3), (2, 4) ] result = find_minimal_path(n, m, roads) assert result == [1, 2, 3] or result == [2, 3, 4] def test_minimal_case(): n = 3 m = 3 roads = [ (1, 2), (2, 3), (3, 1) ] result = find_minimal_path(n, m, roads) assert result in [[1, 2, 3], [2, 3, 1], [3, 1, 2]] def test_disconnected_city(): n = 4 m = 3 roads = [ (1, 2), (2, 3), (3, 1) ] result = find_minimal_path(n, m, roads) assert result == [1, 2, 3] or result == [2, 3, 1] or result == [3, 1, 2] def test_large_graph_simple(): n = 4 m = 5 roads = [ (1, 2), (2, 3), (3, 4), (4, 1), (1, 3) ] result = find_minimal_path(n, m, roads) assert result == [1, 2, 3] or result == [2, 3, 4] or result == [3, 4, 1] or result == [1, 3, 4]","solution":"import sys import heapq from collections import defaultdict def floyd_warshall(n, graph): dist = [[sys.maxsize] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 for u in range(n): for v in graph[u]: dist[u][v] = 1 for k in range(n): for i in range(n): for j in range(n): if dist[i][k] < sys.maxsize and dist[k][j] < sys.maxsize: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) return dist def minimize_travel_distance(n, m, roads): graph = defaultdict(list) for u, v in roads: graph[u-1].append(v-1) dist = floyd_warshall(n, graph) min_dist = sys.maxsize result = [] for i in range(n): for j in range(n): if i != j: for k in range(n): if i != k and j != k: if dist[i][j] != sys.maxsize and dist[j][k] != sys.maxsize: total_dist = dist[i][j] + dist[j][k] if total_dist < min_dist: min_dist = total_dist result = [i+1, j+1, k+1] return result def find_minimal_path(n, m, roads): minimal_path = minimize_travel_distance(n, m, roads) return minimal_path"},{"question":"def max_treasures(n: int, m: int, k: int, grid: List[List[str]]) -> int: Returns the maximum number of treasures that can be collected with at most k moves. >>> max_treasures(3, 3, 4, [['E', 'T', 'E'], ['T', 'E', 'T'], ['E', 'T', 'E']]) 3 >>> max_treasures(1, 1, 1, [['E']]) 0 >>> max_treasures(1, 1, 1, [['T']]) 1 >>> max_treasures(2, 2, 1, [['E', 'T'], ['T', 'E']]) 1 >>> max_treasures(2, 2, 2, [['E', 'T'], ['T', 'E']]) 2 >>> max_treasures(3, 3, 8, [['E', 'T', 'T'], ['E', 'E', 'E'], ['T', 'T', 'T']]) 5","solution":"def max_treasures(n, m, k, grid): Returns the maximum number of treasures that can be collected with at most k moves. def dfs(x, y, moves_left, visited): if moves_left < 0: return 0 treasures = 1 if grid[x][y] == 'T' else 0 visited.add((x, y)) max_treasures_from_here = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: max_treasures_from_here = max(max_treasures_from_here, dfs(nx, ny, moves_left - 1, visited)) visited.remove((x, y)) return treasures + max_treasures_from_here max_treasures_found = 0 for i in range(n): for j in range(m): max_treasures_found = max(max_treasures_found, dfs(i, j, k, set())) return max_treasures_found"},{"question":"def is_anagram(s: str, t: str) -> bool: Determines if string t is an anagram of string s. Args: s (str): The first string. t (str): The second string. Returns: bool: True if t is an anagram of s, False otherwise. Examples: >>> is_anagram(\\"anagram\\", \\"nagaram\\") True >>> is_anagram(\\"rat\\", \\"car\\") False","solution":"def is_anagram(s: str, t: str) -> bool: Determines if string t is an anagram of string s. # First check if the lengths are equal, if not they can't be anagrams if len(s) != len(t): return False # Count the frequency of characters in both strings char_count_s = {} char_count_t = {} for char in s: if char in char_count_s: char_count_s[char] += 1 else: char_count_s[char] = 1 for char in t: if char in char_count_t: char_count_t[char] += 1 else: char_count_t[char] = 1 # Compare the character counts return char_count_s == char_count_t"},{"question":"def sliding_window_maximum(arr, k): Returns an array of the maximum values in each sliding window of size k for the given array. >>> sliding_window_maximum([4, 3, 5, 2, 1, 6, 7, 8, 9, 10], 3) [5, 5, 5, 6, 7, 8, 9, 10] >>> sliding_window_maximum([10, 9, 8, 7, 6, 5, 4], 2) [10, 9, 8, 7, 6, 5] >>> sliding_window_maximum([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> sliding_window_maximum([5, 4, 3, 2, 1], 3) [5, 4, 3] pass def process_input(t, cases): Processes multiple test cases for sliding window maximum. >>> t = 2 >>> cases = [ ... (10, 3, [4, 3, 5, 2, 1, 6, 7, 8, 9, 10]), ... (7, 2, [10, 9, 8, 7, 6, 5, 4]) ... ] >>> process_input(t, cases) [[5, 5, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5]] pass","solution":"from collections import deque def sliding_window_maximum(arr, k): Returns an array of the maximum values in each sliding window of size k for the given array. if not arr or k <= 0: return [] result = [] window = deque() for i in range(len(arr)): # Remove elements that are out of this window if window and window[0] <= i - k: window.popleft() # Remove elements from the deque that are less than the current element while window and arr[window[-1]] < arr[i]: window.pop() # Add the current element at the end of the deque window.append(i) # Append the maximum element of the window to the result list if i >= k - 1: result.append(arr[window[0]]) return result def process_input(t, cases): results = [] for case in cases: n, k, arr = case results.append(sliding_window_maximum(arr, k)) return results"},{"question":"def find_highest_scorer(n: int, m: int, scores: List[List[int]]) -> Tuple[int, int]: Finds the participant with the highest total score. Args: n : int : Number of participants m : int : Number of rounds scores : List[List[int]] : List of scores for each participant in each round Returns: Tuple[int, int]: (index of the participant with highest score (1-based), highest score) pass # Example test cases def test_find_highest_scorer_example(): scores = [ [10, 20, 30], [20, 30, 10], [30, 10, 20], [30, 30, 30] ] assert find_highest_scorer(4, 3, scores) == (4, 90) def test_find_highest_scorer_single_participant(): scores = [ [10, 20, 30] ] assert find_highest_scorer(1, 3, scores) == (1, 60) def test_find_highest_scorer_equal_scores(): scores = [ [10, 20, 30], [10, 20, 30], [10, 20, 30] ] assert find_highest_scorer(3, 3, scores) == (1, 60) def test_find_highest_scorer_multiple_participants(): scores = [ [30, 20, 10], [20, 20, 20], [25, 15, 20], [5, 10, 15] ] assert find_highest_scorer(4, 3, scores) == (1, 60) def test_find_highest_scorer_large_inputs(): scores = [[j for j in range(100)] for i in range(500)] assert find_highest_scorer(500, 100, scores) == (1, sum(range(100)))","solution":"def find_highest_scorer(n, m, scores): Finds the participant with the highest total score. Args: n : int : Number of participants m : int : Number of rounds scores : List[List[int]] : List of scores for each participant in each round Returns: Tuple[int, int]: (index of the participant with highest score (1-based), highest score) max_score = -1 max_score_index = -1 for i in range(n): total_score = sum(scores[i]) if total_score > max_score: max_score = total_score max_score_index = i return max_score_index + 1, max_score"},{"question":"def distinct_common_substrings(test_cases): Find the number of distinct substrings of length m that appear in both strings for each test case. Args: test_cases (List[Tuple[int, int, str, str]]): List of tuples where each tuple contains integers \`n\` and \`m\`, and strings \`a\` and \`b\`. Returns: List[int]: A list containing the number of distinct common substrings of length \`m\` for each test case. Examples: >>> distinct_common_substrings([(5, 3, \\"abcde\\", \\"bcdef\\"), (4, 2, \\"abab\\", \\"baba\\")]) [2, 2] >>> distinct_common_substrings([(4, 3, \\"abcd\\", \\"efgh\\")]) [0] pass def parse_input(input_str): Parse the input string into the required format for the distinct_common_substrings function. Args: input_str (str): The input string containing test cases. Returns: List[Tuple[int, int, str, str]]: Parsed input as a list of tuples. Examples: >>> parse_input(\\"2n5 3nabcdenbcdefn4 2nababnbaban\\") [(5, 3, \\"abcde\\", \\"bcdef\\"), (4, 2, \\"abab\\", \\"baba\\")] >>> parse_input(\\"1n4 3nabcdnefghn\\") [(4, 3, \\"abcd\\", \\"efgh\\")] pass","solution":"def distinct_common_substrings(test_cases): results = [] for n, m, a, b in test_cases: substr_a = {a[i:i+m] for i in range(n - m + 1)} substr_b = {b[i:i+m] for i in range(n - m + 1)} common_substrings = substr_a & substr_b results.append(len(common_substrings)) return results def parse_input(input_str): lines = input_str.split('n') k = int(lines[0]) test_cases = [] index = 1 for _ in range(k): n, m = map(int, lines[index].split()) a = lines[index+1] b = lines[index+2] test_cases.append((n, m, a, b)) index += 3 return test_cases"},{"question":"def transform_steps(a: int, b: int) -> int: Determines the number of steps needed to transform integer a into integer b using specific rules. If it is not possible, returns -1. >>> transform_steps(4, 4) == 0 >>> transform_steps(16, 4) == 2 >>> transform_steps(5, 16) == -1 >>> transform_steps(4, 17) == -1 >>> transform_steps(6, 3) == 1 >>> transform_steps(1024, 1) == 10 ...","solution":"def transform_steps(a, b): Determines the number of steps needed to transform integer a into integer b. If it is not possible, returns -1. steps = 0 while a != b: if a > b: if a % 2 == 0: a //= 2 else: return -1 else: if b % 2 == 1: return -1 b //= 2 steps += 1 return steps"},{"question":"def max_grass_cut(n: int, m: int, field: List[List[int]]) -> int: Determine the maximum amount of grass the robot can cut on its way from the top-left to the bottom-right of the field. >>> max_grass_cut(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) 29 >>> max_grass_cut(1, 5, [ ... [2, 3, 1, 4, 2]]) 12 >>> max_grass_cut(5, 1, [ ... [2], ... [3], ... [1], ... [4], ... [2]]) 12","solution":"def max_grass_cut(n, m, field): # Create a DP table to store the maximum grass cut up to each cell dp = [[0] * m for _ in range(n)] # Initialize the start position dp[0][0] = field[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + field[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + field[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + field[i][j] # The bottom-right corner will have the maximum grass cut return dp[-1][-1]"},{"question":"def kth_lexicographical_substring(s: str, k: int) -> str: Returns the k-th lexicographical substring of the given string. Substrings are non-empty contiguous subsets of characters from s. Args: s (str): A string consisting of lowercase English alphabet characters. k (int): An integer indicating the k-th lexicographical substring. Returns: str: The k-th lexicographical substring. Example: >>> kth_lexicographical_substring(\\"code\\", 5) == \\"d\\" pass # Unit Test def test_example_case(): assert kth_lexicographical_substring(\\"code\\", 5) == \\"d\\" def test_single_character_string(): assert kth_lexicographical_substring(\\"a\\", 1) == \\"a\\" def test_single_repeated_character(): assert kth_lexicographical_substring(\\"aaaa\\", 1) == \\"a\\" assert kth_lexicographical_substring(\\"aaaa\\", 4) == \\"aaaa\\" def test_prefixes(): assert kth_lexicographical_substring(\\"abc\\", 1) == \\"a\\" assert kth_lexicographical_substring(\\"abc\\", 2) == \\"ab\\" assert kth_lexicographical_substring(\\"abc\\", 3) == \\"abc\\" assert kth_lexicographical_substring(\\"abc\\", 4) == \\"b\\" assert kth_lexicographical_substring(\\"abc\\", 5) == \\"bc\\" assert kth_lexicographical_substring(\\"abc\\", 6) == \\"c\\"","solution":"def kth_lexicographical_substring(s, k): Returns the k-th lexicographical substring of string s. Substrings are non-empty contiguous subsets of characters from s. :param s: A string consisting of lowercase English alphabet characters. :param k: An integer indicating the k-th lexicographical substring. substrings = sorted(set(s[i:j] for i in range(len(s)) for j in range(i + 1, len(s) + 1))) return substrings[k - 1]"},{"question":"def longest_sequence_within_budget(b: int, n: int, prices: List[int]) -> int: Finds the longest sequence of items such that the sum of their prices does not exceed the given budget. :param b: int, budget constraint :param n: int, number of items :param prices: list of ints, prices of items :return: int, length of the longest sequence of items within the budget Example: >>> longest_sequence_within_budget(10, 5, [1, 2, 3, 4, 5]) 4 >>> longest_sequence_within_budget(1, 5, [2, 3, 4, 5, 6]) 0","solution":"def longest_sequence_within_budget(b, n, prices): Finds the longest sequence of items such that the sum of their prices does not exceed the given budget. :param b: int, budget constraint :param n: int, number of items :param prices: list of ints, prices of items :return: int, length of the longest sequence of items within the budget left = 0 current_sum = 0 max_length = 0 for right in range(n): current_sum += prices[right] while current_sum > b: current_sum -= prices[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def longest_subarray_with_two_distinct(nums: List[int]) -> int: Returns the length of the longest contiguous subarray that contains at most two distinct integers. Example: >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3]) == 4 >>> longest_subarray_with_two_distinct([4, 5, 4, 4, 5, 6]) == 5 pass from longest_subarray_with_two_distinct import longest_subarray_with_two_distinct def test_example_cases(): assert longest_subarray_with_two_distinct([1, 2, 1, 2, 3]) == 4 assert longest_subarray_with_two_distinct([4, 5, 4, 4, 5, 6]) == 5 def test_single_element_array(): assert longest_subarray_with_two_distinct([1]) == 1 def test_two_distinct_elements(): assert longest_subarray_with_two_distinct([1, 1, 2, 2, 2, 1]) == 6 assert longest_subarray_with_two_distinct([3, 3, 3, 2]) == 4 def test_more_complex_case(): assert longest_subarray_with_two_distinct([1, 2, 3, 4, 5, 1, 2, 3]) == 2 assert longest_subarray_with_two_distinct([1, 2, 1, 3, 4, 2, 2]) == 3 def test_all_same_elements(): assert longest_subarray_with_two_distinct([1, 1, 1, 1, 1]) == 5 def test_empty_array(): assert longest_subarray_with_two_distinct([]) == 0","solution":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest contiguous subarray that contains at most two distinct integers. if not nums: return 0 max_len = 0 left = 0 count_map = {} for right in range(len(nums)): if nums[right] in count_map: count_map[nums[right]] += 1 else: count_map[nums[right]] = 1 while len(count_map) > 2: count_map[nums[left]] -= 1 if count_map[nums[left]] == 0: del count_map[nums[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def valid_palindrome(s: str) -> bool: Determine if you can make the string a palindrome with at most one removal. >>> valid_palindrome(\\"abca\\") True >>> valid_palindrome(\\"racecar\\") True >>> valid_palindrome(\\"abcdef\\") False","solution":"def valid_palindrome(s: str) -> bool: def is_palindrome_range(i, j): return all(s[k] == s[j-k+i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1) left += 1 right -= 1 return True"},{"question":"def is_prime(n: int) -> str: Check if a given positive integer n is a prime number. Returns \\"Yes\\" if n is prime, \\"No\\" otherwise. Examples: >>> is_prime(2) 'Yes' >>> is_prime(10) 'No' >>> is_prime(17) 'Yes'","solution":"def is_prime(n): Check if a given positive integer n is a prime number. Returns \\"Yes\\" if n is prime, \\"No\\" otherwise. if n <= 1: return \\"No\\" if n <= 3: return \\"Yes\\" if n % 2 == 0 or n % 3 == 0: return \\"No\\" i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return \\"No\\" i += 6 return \\"Yes\\""},{"question":"def is_zigzag_pattern(sizes: List[int]) -> str: Determine if the sequence of sizes forms a valid zigzag pattern. Args: sizes (List[int]): List of integers representing sizes of fungi at different steps Returns: str: \\"YES\\" if the sizes form a valid zigzag pattern, otherwise \\"NO\\" Examples: >>> is_zigzag_pattern([1, 2, 1, 2, 1]) 'YES' >>> is_zigzag_pattern([1, 2, 3, 2, 1]) 'NO' >>> is_zigzag_pattern([1, 3, 2, 4, 3]) 'YES'","solution":"from typing import List def is_zigzag_pattern(sizes: List[int]) -> str: if len(sizes) < 2: return \\"YES\\" direction = 0 # 0 if undefined, 1 if increasing, -1 if decreasing for i in range(1, len(sizes)): if sizes[i] == sizes[i - 1]: return \\"NO\\" current_direction = 1 if sizes[i] > sizes[i - 1] else -1 if direction == 0: direction = current_direction elif direction == current_direction: return \\"NO\\" else: direction = current_direction return \\"YES\\""},{"question":"from typing import List, Tuple def bfs(graph: dict, s: int, t: int) -> int: Perform BFS to find the minimum number of roads to reach from s to t. :param graph: Dictionary representing the graph of intersections and roads. :param s: Source intersection. :param t: Destination intersection. :return: Minimum number of roads to reach from s to t, otherwise -1. >>> bfs({1: {2, 3, 4}, 2: {1, 5}, 3: {1, 5}, 4: {1}, 5: {2, 3}}, 1, 5) 2 >>> bfs({1: {2, 4}, 2: {1, 5}, 4: {1}, 5: {2}}, 1, 5) 2 pass def process_queries(n: int, roads: List[Tuple[int, int]], queries: List[str]) -> List[int]: Process the queries to manage the roads and calculate shortest paths. :param n: Number of intersections. :param roads: List of tuples representing roads between intersections. :param queries: List of query strings. :return: List of results for each PATH query. >>> process_queries(5, [(1, 2), (1, 3), (1, 4), (2, 5), (3, 5)], [\\"PATH 1 5\\", \\"CLOSE 1 3\\", \\"PATH 1 5\\", \\"OPEN 1 3\\", \\"PATH 1 5\\"]) [2, 2, 2] >>> process_queries(3, [(1, 2), (2, 3)], [\\"PATH 1 3\\", \\"CLOSE 2 3\\", \\"PATH 1 3\\", \\"OPEN 2 3\\", \\"PATH 1 3\\"]) [2, -1, 2] pass","solution":"from collections import deque, defaultdict def bfs(graph, s, t): queue = deque([s]) distances = {s: 0} while queue: node = queue.popleft() if node == t: return distances[node] for neighbor in graph[node]: if neighbor not in distances: distances[neighbor] = distances[node] + 1 queue.append(neighbor) return -1 def process_queries(n, roads, queries): graph = defaultdict(set) for u, v in roads: graph[u].add(v) graph[v].add(u) results = [] for query in queries: parts = query.split() if parts[0] == \\"PATH\\": s, t = int(parts[1]), int(parts[2]) results.append(bfs(graph, s, t)) elif parts[0] == \\"CLOSE\\": x, y = int(parts[1]), int(parts[2]) if y in graph[x]: graph[x].remove(y) if x in graph[y]: graph[y].remove(x) elif parts[0] == \\"OPEN\\": x, y = int(parts[1]), int(parts[2]) graph[x].add(y) graph[y].add(x) return results"},{"question":"def largest_square_submatrix(matrix: List[List[int]]) -> int: Find the side length of the largest square sub-matrix with equal elements. >>> largest_square_submatrix([[1, 1, 1, 0, 0], [1, 1, 1, 0, 0], [1, 1, 1, 0, 1], [0, 0, 0, 1, 1]]) == 3 >>> largest_square_submatrix([[1, 2, 2], [2, 2, 2], [2, 2, 2]]) == 2 >>> largest_square_submatrix([[1]]) == 1 >>> largest_square_submatrix([[3, 3, 3], [3, 3, 3], [3, 3, 3], [3, 3, 3]]) == 3 >>> largest_square_submatrix([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 0, 0], [1, 1, 0, 0]]) == 2","solution":"def largest_square_submatrix(matrix): n = len(matrix) m = len(matrix[0]) max_side_length = 0 dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if i == 0 or j == 0: dp[i][j] = 1 else: if matrix[i][j] == matrix[i-1][j] == matrix[i][j-1] == matrix[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"from typing import List def shortest_path_in_grid(N: int, M: int, grid: List[List[str]]) -> int: Find the shortest path from the top-left corner to the bottom-right corner of a city map. Args: - N (int): The number of rows in the grid. - M (int): The number of columns in the grid. - grid (List[List[str]]): The city map grid where '.' represents an open space and '#' represents a building. Returns: - int: The length of the shortest path from the top-left to the bottom-right corner, or -1 if no such path exists. >>> shortest_path_in_grid(5, 5, [ ... ['.', '.', '.', '#', '.'], ... ['#', '.', '#', '.', '#'], ... ['.', '.', '#', '.', '.'], ... ['#', '.', '#', '.', '.'], ... ['.', '.', '.', '.', '.'] ... ]) 8 >>> shortest_path_in_grid(3, 3, [ ... ['.', '#', '.'], ... ['#', '#', '.'], ... ['.', '#', '.'] ... ]) -1","solution":"from collections import deque def shortest_path_in_grid(N, M, grid): def is_valid(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == '.' if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == N-1 and y == M-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def beauty_of_substring(n: int, m: int, a: str, queries: List[Tuple[int, int]]) -> List[int]: Returns the beauty (number of distinct characters) of substrings specified by queries. :param n: Length of the string :param m: Number of queries :param a: The string \`a\` :param queries: List of tuples, where each tuple contains the start and end indices of a query :return: List of integers representing the beauty of the substrings for each query >>> beauty_of_substring(7, 3, \\"abacaba\\", [(1, 3), (2, 5), (1, 7)]) [2, 3, 3] >>> beauty_of_substring(6, 1, \\"xyzxyz\\", [(1, 6)]) [3] from solution import beauty_of_substring def test_single_character_string(): assert beauty_of_substring(1, 1, \\"a\\", [(1, 1)]) == [1] def test_all_distinct_characters(): assert beauty_of_substring(5, 2, \\"abcde\\", [(1, 5), (1, 3)]) == [5, 3] def test_repeating_characters(): assert beauty_of_substring(6, 2, \\"aabbcc\\", [(1, 6), (2, 4)]) == [3, 2] def test_mixed_string(): assert beauty_of_substring(7, 3, \\"abacaba\\", [(1, 3), (2, 5), (1, 7)]) == [2, 3, 3] def test_single_query_multiple_substrings(): assert beauty_of_substring(6, 1, \\"xyzxyz\\", [(1, 6)]) == [3] def test_partial_queries(): assert beauty_of_substring(6, 2, \\"aaabbb\\", [(1, 3), (4, 6)]) == [1, 1]","solution":"def beauty_of_substring(n, m, a, queries): Returns the beauty (number of distinct characters) of substrings specified by queries. :param n: Length of the string :param m: Number of queries :param a: The string \`a\` :param queries: List of tuples, where each tuple contains the start and end indices of a query :return: List of integers representing the beauty of the substrings for each query result = [] for l, r in queries: substring = a[l-1:r] distinct_characters = set(substring) result.append(len(distinct_characters)) return result"},{"question":"def maxWaterStations(stations: List[int], capacity: int) -> int: Determines the maximum number of water stations that can be visited without exceeding the total capacity of water bottles. Parameters: stations (list of int): The amount of water available at each station. capacity (int): The total capacity of the water bottles. Returns: int: The maximum number of water stations that can be visited. >>> maxWaterStations([10, 20, 30, 40], 60) 3 >>> maxWaterStations([10, 20, 30, 40], 50) 2 >>> maxWaterStations([15, 15, 15, 15, 15], 60) 4 >>> maxWaterStations([1]*100, 1000) 100","solution":"def maxWaterStations(stations, capacity): Determines the maximum number of water stations that can be visited without exceeding the total capacity of water bottles. Parameters: stations (list of int): The amount of water available at each station. capacity (int): The total capacity of the water bottles. Returns: int: The maximum number of water stations that can be visited. total_water = 0 count = 0 for water in stations: if total_water + water <= capacity: total_water += water count += 1 else: break return count"},{"question":"def sequence_length(n: int) -> int: Computes the length of the sequence starting from n and ending at 1 based on the given rules. Args: n: int - the starting integer of the sequence. Returns: int - the length of the sequence # Your code here from solution import sequence_length def test_sequence_length(): # Test case 1 assert sequence_length(6) == 9, \\"Test Case 1 Failed\\" # Test case 2 assert sequence_length(19) == 21, \\"Test Case 2 Failed\\" # Test case 3 assert sequence_length(1) == 1, \\"Test Case 3 Failed\\" # Test with some additional edge cases and large numbers assert sequence_length(2) == 2, \\"Test Case 4 Failed\\" assert sequence_length(3) == 8, \\"Test Case 5 Failed\\" assert sequence_length(10**6) == 153, \\"Test Case 6 Failed\\" print(\\"All test cases pass\\") # Run the tests test_sequence_length()","solution":"def sequence_length(n): Computes the length of the sequence starting from n and ending at 1 based on the given rules. Args: n: int - the starting integer of the sequence. Returns: int - the length of the sequence count = 1 # starting with n itself while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 count += 1 return count"},{"question":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest contiguous subarray that contains exactly two distinct integers. >>> longest_subarray_with_two_distinct([]) == 0 True >>> longest_subarray_with_two_distinct([1]) == 1 True >>> longest_subarray_with_two_distinct([1, 2]) == 2 True >>> longest_subarray_with_two_distinct([1, 2, 1]) == 3 True >>> longest_subarray_with_two_distinct([1, 2, 3, 2, 2]) == 4 True >>> longest_subarray_with_two_distinct([1, 1, 1, 1]) == 4 True >>> longest_subarray_with_two_distinct([4, 1, 4, 4, 3, 2]) == 4 True","solution":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest contiguous subarray that contains exactly two distinct integers. if not nums: return 0 start, max_len = 0, 0 count_map = {} for end in range(len(nums)): if nums[end] in count_map: count_map[nums[end]] += 1 else: count_map[nums[end]] = 1 while len(count_map) > 2: count_map[nums[start]] -= 1 if count_map[nums[start]] == 0: del count_map[nums[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Determine the length of the longest common subsequence (LCS) between two strings. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abcd\\", \\"abcd\\") 4 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abcdef\\", \\"abfdef\\") 5 >>> longest_common_subsequence(\\"axbycz\\", \\"abc\\") 3 def process_test_cases(input_data: str) -> list: Process multiple test cases from a single input string and return the LCS length for each pair of strings. >>> process_test_cases(\\"2nabcdenacenabcdnabcdn\\") [3, 4] >>> process_test_cases(\\"1nabcnabcn\\") [3] >>> process_test_cases(\\"1nabcndefn\\") [0]","solution":"def longest_common_subsequence(s1, s2): m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def process_test_cases(input_data): lines = input_data.split('n') n = int(lines[0]) results = [] for i in range(n): s1 = lines[2 * i + 1] s2 = lines[2 * i + 2] lcs_length = longest_common_subsequence(s1, s2) results.append(lcs_length) return results"},{"question":"from typing import List def sock_merchant(n: int, ar: List[int]) -> int: Determine how many pairs of socks with matching colors there are. Args: n (int): The number of socks in the pile. ar (List[int]): An array of integers representing the color of each sock. Returns: int: The number of pairs of socks. Examples: >>> sock_merchant(9, [10, 20, 20, 10, 10, 30, 50, 10, 20]) 3 >>> sock_merchant(5, [1, 2, 1, 2, 1]) 2 # Unit Tests def test_example_1(): n = 9 ar = [10, 20, 20, 10, 10, 30, 50, 10, 20] assert sock_merchant(n, ar) == 3 def test_example_2(): n = 5 ar = [1, 2, 1, 2, 1] assert sock_merchant(n, ar) == 2 def test_no_pairs(): n = 4 ar = [1, 2, 3, 4] assert sock_merchant(n, ar) == 0 def test_all_same_color(): n = 6 ar = [9, 9, 9, 9, 9, 9] assert sock_merchant(n, ar) == 3 def test_large_input(): n = 100000 ar = [i % 100 for i in range(n)] assert sock_merchant(n, ar) == 50000 def test_single_element(): n = 1 ar = [10] assert sock_merchant(n, ar) == 0 def test_all_different_colors(): n = 100 ar = list(range(1, 101)) assert sock_merchant(n, ar) == 0","solution":"from typing import List def sock_merchant(n: int, ar: List[int]) -> int: sock_count = {} pairs = 0 # Count occurrences of each sock color for sock in ar: if sock in sock_count: sock_count[sock] += 1 else: sock_count[sock] = 1 # Calculate number of pairs for count in sock_count.values(): pairs += count // 2 return pairs"},{"question":"def maxWaterTrapped(walls: List[int]) -> int: Determine the maximum volume of water that can be trapped between the walls after it rains. >>> maxWaterTrapped([0,1,0,2,1,0,3,1,0,1,2]) 8 >>> maxWaterTrapped([4,2,0,3,2,5]) 9","solution":"def maxWaterTrapped(walls): if not walls or len(walls) < 3: return 0 n = len(walls) left_max = [0] * n right_max = [0] * n left_max[0] = walls[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], walls[i]) right_max[n - 1] = walls[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], walls[i]) water_trapped = 0 for i in range(1, n - 1): # No need to check the first and the last part water_trapped += max(0, min(left_max[i], right_max[i]) - walls[i]) return water_trapped"},{"question":"def max_components_within_limit(n: int, resistances: List[int], M: int) -> int: Determines the maximum number of components that can be used without exceeding the total resistance limit M. >>> max_components_within_limit(5, [1, 2, 3, 4, 5], 10) 4 >>> max_components_within_limit(3, [3, 1, 2], 5) 2 >>> max_components_within_limit(4, [10, 20, 30, 40], 25) 1 >>> max_components_within_limit(5, [1, 1, 1, 1, 1], 5) 5 >>> max_components_within_limit(6, [5, 5, 5, 5, 5, 5], 20) 4 >>> max_components_within_limit(0, [], 10) 0 >>> max_components_within_limit(5, [100, 200, 300, 400, 500], 50) 0 >>> max_components_within_limit(5, [2, 2, 2, 2, 2], 10) 5","solution":"def max_components_within_limit(n, resistances, M): Determines the maximum number of components that can be used without exceeding the total resistance limit M. resistances.sort() total_resistance = 0 count = 0 for resistance in resistances: if total_resistance + resistance <= M: total_resistance += resistance count += 1 else: break return count"},{"question":"def min_robots_required(n: int, m: int, robot_batteries: List[int], robot_weights: List[int], goods: List[Tuple[int, int]]) -> int: Determines the minimum number of robots needed to deliver all goods. :param n: Number of robots :param m: Number of goods :param robot_batteries: List of battery capacities for each robot :param robot_weights: List of weight limits for each robot :param goods: List of tuples containing battery consumption and weight of each good :return: Minimum number of robots required or -1 if not possible >>> min_robots_required(5, 4, [50, 60, 70, 80, 90], [10, 20, 30, 40, 50], [(10, 5), (20, 10), (15, 25), (30, 10)]) 3 >>> min_robots_required(2, 3, [30, 40], [20, 30], [(10, 5), (20, 10), (15, 25)]) -1","solution":"def min_robots_required(n, m, robot_batteries, robot_weights, goods): Determines the minimum number of robots needed to deliver all goods. :param n: Number of robots :param m: Number of goods :param robot_batteries: List of battery capacities for each robot :param robot_weights: List of weight limits for each robot :param goods: List of tuples containing battery consumption and weight of each good :return: Minimum number of robots required or -1 if not possible # Sort robots by their battery capacity and weight limit robots = sorted(zip(robot_batteries, robot_weights), key=lambda x: (x[0], x[1])) # Sort goods by their battery consumption and weight goods = sorted(goods, key=lambda x: (x[0], x[1])) # Track the number of robots used number_of_robots = 0 goods_index = 0 while goods_index < m: # Try to allocate goods to the least capable robot that can handle the load for i in range(n): current_battery = robots[i][0] current_weight_capacity = robots[i][1] current_goods_battery_sum = 0 current_goods_weight_sum = 0 while goods_index < m and current_goods_battery_sum + goods[goods_index][0] <= current_battery and current_goods_weight_sum + goods[goods_index][1] <= current_weight_capacity: current_goods_battery_sum += goods[goods_index][0] current_goods_weight_sum += goods[goods_index][1] goods_index += 1 if current_goods_battery_sum > 0 or current_goods_weight_sum > 0: number_of_robots += 1 if goods_index >= m: break # If no suitable robot is found within available robots for remaining goods, return -1 if goods_index < m: return -1 return number_of_robots"},{"question":"def find_special_pairs(n: int) -> List[Tuple[int, int]]: Write a function, \`find_special_pairs\`, that takes an integer \`n\` and returns a list of unique tuples \`(a, b)\` such that \`a\` and \`b\` are positive integers, \`1 ≤ a < b ≤ n\`, and the product of \`a\` and \`b\` is a perfect square. >>> find_special_pairs(5) [(1, 4)] >>> find_special_pairs(10) [(1, 4), (1, 9), (2, 8), (4, 9)] >>> find_special_pairs(2) [] >>> find_special_pairs(3) [] >>> find_special_pairs(20) [(1, 4), (1, 9), (2, 8), (4, 9)]","solution":"def find_special_pairs(n): def is_perfect_square(x): # Since we're working with integers, rather than math.sqrt root = int(x ** 0.5) return root * root == x special_pairs = [] for a in range(1, n+1): for b in range(a+1, n+1): if is_perfect_square(a * b): special_pairs.append((a, b)) return special_pairs"},{"question":"def analyze_matrices(num_cases: int, cases: List[Tuple[int, int, List[str]]]) -> List[str]: Analyzes multiple test cases to determine if all rows in each matrix contain the same elements. :param num_cases: Number of test cases :param cases: A list of tuples where each tuple contains (n, m, matrix) - n (int): Number of rows in the matrix - m (int): Number of columns in the matrix - matrix (list): List of strings representing the rows in the matrix :return: List of strings \\"YES\\" or \\"NO\\" corresponding to each test case >>> analyze_matrices(1, [(3, 3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"])]) [\\"YES\\"] >>> analyze_matrices(1, [(3, 4, [\\"abcd\\", \\"abcd\\", \\"abce\\"])]) [\\"NO\\"]","solution":"def analyze_matrices(num_cases, cases): Analyzes multiple test cases to determine if all rows in each matrix contain the same elements. :param num_cases: Number of test cases :param cases: A list of tuples where each tuple contains (n, m, matrix) - n (int): Number of rows in the matrix - m (int): Number of columns in the matrix - matrix (list): List of strings representing the rows in the matrix :return: List of strings \\"YES\\" or \\"NO\\" corresponding to each test case results = [] for n, m, matrix in cases: all_rows_same = True first_row_set = set(matrix[0]) for row in matrix: if set(row) != first_row_set: all_rows_same = False break if all_rows_same: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def rotate_strings(strings: List[str], k: int) -> List[str]: Rotates the list of strings to the right by k times. Args: - strings (List[str]): The list of strings to rotate. - k (int): The number of rotations. Returns: - List[str]: The rotated list of strings. Example: >>> rotate_strings([\\"hello\\", \\"world\\", \\"python\\", \\"coding\\"], 2) [\\"python\\", \\"coding\\", \\"hello\\", \\"world\\"] >>> rotate_strings([\\"one\\", \\"two\\", \\"three\\"], 1) [\\"three\\", \\"one\\", \\"two\\"] >>> rotate_strings([\\"rotate\\", \\"this\\", \\"string\\"], 3) [\\"rotate\\", \\"this\\", \\"string\\"] from solution import rotate_strings def test_rotate_strings_case_1(): assert rotate_strings([\\"hello\\", \\"world\\", \\"python\\", \\"coding\\"], 2) == [\\"python\\", \\"coding\\", \\"hello\\", \\"world\\"] def test_rotate_strings_case_2(): assert rotate_strings([\\"one\\", \\"two\\", \\"three\\"], 1) == [\\"three\\", \\"one\\", \\"two\\"] def test_rotate_strings_case_3(): assert rotate_strings([\\"rotate\\", \\"this\\", \\"string\\"], 3) == [\\"rotate\\", \\"this\\", \\"string\\"] def test_rotate_strings_empty_list(): assert rotate_strings([], 1) == [] def test_rotate_strings_no_rotation(): assert rotate_strings([\\"a\\", \\"b\\", \\"c\\"], 0) == [\\"a\\", \\"b\\", \\"c\\"] def test_rotate_strings_rotation_equal_to_length(): assert rotate_strings([\\"a\\", \\"b\\", \\"c\\"], 3) == [\\"a\\", \\"b\\", \\"c\\"] def test_rotate_strings_large_k(): assert rotate_strings([\\"a\\", \\"b\\", \\"c\\"], 4) == [\\"c\\", \\"a\\", \\"b\\"]","solution":"from typing import List def rotate_strings(strings: List[str], k: int) -> List[str]: Rotates the list of strings to the right by k times. Args: - strings (List[str]): The list of strings to rotate. - k (int): The number of rotations. Returns: - List[str]: The rotated list of strings. if not strings or k == 0: return strings n = len(strings) # Normalize k in case it's larger than the list length k = k % n return strings[-k:] + strings[:-k]"},{"question":"def majority_element(nums: List[int]) -> int: Returns the majority element of the list if it exists, otherwise returns -1. >>> majority_element([3, 3, 4, 2, 3]) 3 >>> majority_element([1, 2, 3, 4, 5, 6]) -1 >>> majority_element([2, 2, 1, 1, 2, 2]) 2 >>> majority_element([1]) 1 >>> majority_element([1000000000]) 1000000000","solution":"def majority_element(nums): Returns the majority element of the list if it exists, otherwise returns -1. n = len(nums) candidate = None count = 0 # Phase 1: Find a candidate using Boyer-Moore Voting Algorithm for num in nums: if count == 0: candidate = num count = 1 elif num == candidate: count += 1 else: count -= 1 # Phase 2: Verify the candidate if nums.count(candidate) > n // 2: return candidate else: return -1"},{"question":"def count_subarrays_with_sum_k(n, arr, k): Given an array of integers and an integer \`k\`, this function returns the number of contiguous subarrays that have a sum equal to \`k\`. Parameters: n (int): The number of elements in the array. arr (list of int): The list containing \`n\` integers. k (int): The target sum for the subarrays. Returns: int: The number of contiguous subarrays that sum to \`k\`. Examples: >>> count_subarrays_with_sum_k(5, [1, 1, 1, 1, 1], 3) 3 >>> count_subarrays_with_sum_k(4, [0, 0, 0, 0], 0) 10 >>> count_subarrays_with_sum_k(5, [3, 4, -7, 1, 3, 3, 1, -4], 7) 4 >>> count_subarrays_with_sum_k(1, [7], 7) 1 >>> count_subarrays_with_sum_k(1, [-7], 7) 0 >>> n = 10**5 >>> arr = [1] * n >>> k = n >>> count_subarrays_with_sum_k(n, arr, k) 1 >>> count_subarrays_with_sum_k(3, [1, 2, 3], 10) 0","solution":"def count_subarrays_with_sum_k(n, arr, k): Given an array of integers and an integer \`k\`, this function returns the number of contiguous subarrays that have a sum equal to \`k\`. Parameters: n (int): The number of elements in the array. arr (list of int): The list containing \`n\` integers. k (int): The target sum for the subarrays. Returns: int: The number of contiguous subarrays that sum to \`k\`. count = 0 current_sum = 0 sum_map = {0: 1} for num in arr: current_sum += num if (current_sum - k) in sum_map: count += sum_map[current_sum - k] if current_sum in sum_map: sum_map[current_sum] += 1 else: sum_map[current_sum] = 1 return count"},{"question":"from typing import List def shortest_path(n: int, m: int, grid: List[str]) -> int: Finds the length of the shortest path from the top-left corner to the bottom-right corner of the grid, avoiding obstacles. If there's no valid path, return -1. (Note: You can move up, down, left, or right, but not diagonally.) >>> shortest_path(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> shortest_path(3, 3, [\\"#..\\", \\"..#\\", \\"...\\"]) -1 >>> shortest_path(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 6","solution":"from collections import deque def shortest_path(n, m, grid): Finds the length of the shortest path from the top-left corner to the bottom-right corner of the grid, avoiding obstacles. Returns -1 if no such path exists. # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the start or end is an obstacle if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 # Initialize the queue with the starting point queue = deque([(0, 0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() # Check if we have reached the bottom-right corner if x == n-1 and y == m-1: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If the loop ends without finding a path return -1"},{"question":"def count_primes(a: int, b: int) -> int: Determine the number of prime numbers within a certain range. >>> count_primes(10, 30) # Output: 6 >>> count_primes(1, 10) # Output: 4 >>> count_primes(100, 200) # Output: 21","solution":"def count_primes(a, b): def sieve(n): is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 is_prime[0] = is_prime[1] = False return is_prime sieve_size = b is_prime = sieve(sieve_size) count = 0 for num in range(a, b + 1): if is_prime[num]: count += 1 return count"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Returns the minimum path sum from the top-left to the bottom-right of the grid. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([ ... [1, 2], ... [1, 1] ... ]) 3 pass # Implement this function def process_input(input_string: str) -> List[int]: Process the input given as a string and return the respective outputs. >>> process_input(''' ... 2 ... 3 ... 1 3 1 ... 1 5 1 ... 4 2 1 ... 2 ... 1 2 ... 1 1 ... ''') [7, 3] >>> process_input(''' ... 1 ... 2 ... 1 2 ... 3 4 ... ''') [7] pass # Implement this function def test_min_path_sum(): # Simple test case 3x3 grid grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_sum(grid) == 7 # Another simple test case 2x2 grid grid = [ [1, 2], [1, 1] ] assert min_path_sum(grid) == 3 def test_process_input(): # Test case from example input_string = 2 3 1 3 1 1 5 1 4 2 1 2 1 2 1 1 expected_output = [7, 3] assert process_input(input_string) == expected_output # Another test case input_string = 1 2 1 2 3 4 expected_output = [7] assert process_input(input_string) == expected_output","solution":"def min_path_sum(grid): Returns the minimum path sum from the top-left to the bottom-right of the grid. n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize first column of dp array for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize first row of dp array for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1] def process_input(input_string): Process the input given as a string and return the respective outputs. lines = input_string.strip().split('n') t = int(lines[0]) index = 1 results = [] for _ in range(t): n = int(lines[index]) index += 1 grid = [list(map(int, lines[index + i].split())) for i in range(n)] index += n results.append(min_path_sum(grid)) return results"},{"question":"def max_element_after_operations(test_cases): Compute the maximum possible value of the array after performing specified operations for given test cases. >>> test_cases = [(3, [1, 2, 3])] >>> max_element_after_operations(test_cases) [6] >>> test_cases = [(4, [4, -1, 2, 1])] >>> max_element_after_operations(test_cases) [6]","solution":"def max_element_after_operations(test_cases): results = [] for n, a in test_cases: results.append(sum(a)) return results # Function to parse input (helpful for testing) def parse_input(input_text): lines = input_text.strip().split('n') t = int(lines[0]) test_cases = [] idx = 1 for _ in range(t): n = int(lines[idx]) a = list(map(int, lines[idx + 1].split())) test_cases.append((n, a)) idx += 2 return test_cases"},{"question":"from collections import Counter import heapq from typing import Tuple def rearrange_string(s: str, k: int) -> str: Given a string of lowercase English letters and a positive integer k, determine whether it is possible to rearrange the string such that no two adjacent characters are the same, and if possible, return any valid rearrangement. >>> rearrange_string(\\"aabb\\", 2) 'abab' >>> rearrange_string(\\"aaabb\\", 2) 'ababa' >>> rearrange_string(\\"aaabb\\", 3) 'Not possible'","solution":"import heapq from collections import Counter def rearrange_string(s, k): if k == 1: # If k is 1, any arrangement is fine return s counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) queue = [] result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) queue.append((count + 1, char)) # Decrement the count if len(queue) >= k: count, char = queue.pop(0) if count < 0: heapq.heappush(max_heap, (count, char)) if len(result) == len(s): return ''.join(result) else: return \\"Not possible\\""},{"question":"def shortest_paths_to_treasure(n: int, m: int, grid: List[str], tx: int, ty: int) -> int: Function to find the number of distinct shortest paths from the top-left corner (1, 1) to the treasure cell (tx, ty) in a grid of size n x m. Parameters: - n: number of rows in the grid - m: number of columns in the grid - grid: list of strings representing the grid - tx: row index of the treasure cell (1-based) - ty: column index of the treasure cell (1-based) Returns: - The number of distinct shortest paths to the treasure or -1 if unreachable. >>> shortest_paths_to_treasure(3, 3, [\\"#.#\\", \\"...\\", \\".#.\\"], 3, 3) 2 >>> shortest_paths_to_treasure(3, 3, [\\"#.#\\", \\"#.#\\", \\"#\\"], 3, 3) -1 >>> shortest_paths_to_treasure(2, 2, [\\"..\\", \\"..\\"], 2, 2) 2 >>> shortest_paths_to_treasure(5, 5, [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"], 5, 5) 70 >>> shortest_paths_to_treasure(3, 3, [\\"..#\\", \\".#.\\", \\"#..\\"], 3, 3) -1","solution":"from collections import deque def shortest_paths_to_treasure(n, m, grid, tx, ty): Function to find the number of distinct shortest paths from the top-left corner (1, 1) to the treasure cell (tx, ty) in a grid of size n x m. Parameters: - n: number of rows in the grid - m: number of columns in the grid - grid: list of strings representing the grid - tx: row index of the treasure cell (1-based) - ty: column index of the treasure cell (1-based) Returns: - The number of distinct shortest paths to the treasure or -1 if unreachable. # Convert (tx, ty) to 0-based indexing tx -= 1 ty -= 1 # Directions for movement (right, left, up, down) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Queue for BFS queue = deque([(0, 0)]) # Distance matrix with initial values set to a large number distance = [[float('inf')] * m for _ in range(n)] distance[0][0] = 0 # Distance from start to start is 0 # Path count matrix to store the number of ways to reach each cell path_count = [[0] * m for _ in range(n)] path_count[0][0] = 1 # There is one way to be at the start while queue: x, y = queue.popleft() for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.': if distance[nx][ny] > distance[x][y] + 1: distance[nx][ny] = distance[x][y] + 1 path_count[nx][ny] = path_count[x][y] queue.append((nx, ny)) elif distance[nx][ny] == distance[x][y] + 1: path_count[nx][ny] += path_count[x][y] if distance[tx][ty] == float('inf'): return -1 else: return path_count[tx][ty]"},{"question":"def count_subarrays_with_k_distinct(arr: List[int], k: int) -> int: Finding the Number of Distinct Subarrays with Exact k Different Elements You are given an array \`arr\` consisting of \`n\` integers. A \\"subarray\\" is defined as a contiguous part of an array. We say that the subarray has \\"exactly k different elements\\" if it has exactly \`k\` distinct numbers. Your task is to find the number of distinct subarrays that have exactly \`k\` different elements. The function should return this count modulo 10^9 + 7. >>> count_subarrays_with_k_distinct([1, 2, 1, 2, 3], 2) 7 >>> count_subarrays_with_k_distinct([1, 2, 1, 3, 4], 3) 3 >>> count_subarrays_with_k_distinct([1, 1, 1, 1], 1) 10 >>> count_subarrays_with_k_distinct([1], 1) 1 >>> count_subarrays_with_k_distinct([1, 2, 3], 4) 0","solution":"def count_subarrays_with_k_distinct(arr, k): MOD = 10**9 + 7 def at_most_k_distinct(arr, k): count = {} left = 0 result = 0 for right in range(len(arr)): if arr[right] in count: count[arr[right]] += 1 else: count[arr[right]] = 1 while len(count) > k: count[arr[left]] -= 1 if count[arr[left]] == 0: del count[arr[left]] left += 1 result += right - left + 1 return result return (at_most_k_distinct(arr, k) - at_most_k_distinct(arr, k-1)) % MOD"},{"question":"def compute_series_sum(n: int) -> int: Returns the sum of the series 1^2 - 2^2 + 3^2 - 4^2 + ... + (-1)^(n+1) * n^2. >>> compute_series_sum(1) 1 >>> compute_series_sum(3) 6 >>> compute_series_sum(4) -10 >>> compute_series_sum(5) 15 >>> compute_series_sum(6) -21","solution":"def compute_series_sum(n): Returns the sum of the series 1^2 - 2^2 + 3^2 - 4^2 + ... + (-1)^(n+1) * n^2 series_sum = 0 for i in range(1, n + 1): series_sum += ((-1) ** (i + 1)) * (i ** 2) return series_sum"},{"question":"def rank_participants(n: int, participants: List[Tuple[str, int]]) -> List[str]: Ranks participants based on the number of words spoken in descending order. If two participants have spoken the same number of words, they are ranked alphabetically by name. Arguments: n -- number of participants participants -- list of tuples, where each tuple contains (name, words) Returns: A list of strings where each string contains the participant's name and the number of words spoken, separated by a space. >>> rank_participants(5, [(\\"Alice\\", 30), (\\"Bob\\", 45), (\\"Charlie\\", 30), (\\"Dave\\", 45), (\\"Eve\\", 50)]) [\\"Eve 50\\", \\"Bob 45\\", \\"Dave 45\\", \\"Alice 30\\", \\"Charlie 30\\"] >>> rank_participants(5, [(\\"Alice\\", 10), (\\"Bob\\", 20), (\\"Charlie\\", 30), (\\"Dave\\", 40), (\\"Eve\\", 50)]) [\\"Eve 50\\", \\"Dave 40\\", \\"Charlie 30\\", \\"Bob 20\\", \\"Alice 10\\"] >>> rank_participants(5, [(\\"Alice\\", 10), (\\"Bob\\", 10), (\\"Charlie\\", 10), (\\"Dave\\", 10), (\\"Eve\\", 10)]) [\\"Alice 10\\", \\"Bob 10\\", \\"Charlie 10\\", \\"Dave 10\\", \\"Eve 10\\"] >>> rank_participants(1, [(\\"Alice\\", 10)]) [\\"Alice 10\\"] >>> rank_participants(0, []) [] pass","solution":"def rank_participants(n, participants): Ranks participants based on the number of words spoken in descending order. If two participants have spoken the same number of words, they are ranked alphabetically by name. Arguments: n -- number of participants participants -- list of tuples, where each tuple contains (name, words) Returns: A list of strings where each string contains the participant's name and the number of words spoken, separated by a space. # Sort the participants: first by number of words in descending order, then by name in ascending order participants_sorted = sorted(participants, key=lambda x: (-x[1], x[0])) # Format the result result = [f\\"{name} {words}\\" for name, words in participants_sorted] return result # Example usage: # participants = [(\\"Alice\\", 30), (\\"Bob\\", 45), (\\"Charlie\\", 30), (\\"Dave\\", 45), (\\"Eve\\", 50)] # print(rank_participants(5, participants))"},{"question":"def minimum_edges_to_remove(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Returns the minimum number of edges that need to be removed so that no two nodes remain connected by more than one path. >>> minimum_edges_to_remove(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) 1 >>> minimum_edges_to_remove(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> minimum_edges_to_remove(3, 3, [(1, 2), (2, 3), (1, 3)]) 1 >>> minimum_edges_to_remove(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (1, 3)]) 2 >>> minimum_edges_to_remove(6, 5, [(1, 2), (1, 3), (3, 4), (4, 5), (2, 6)]) 0","solution":"def minimum_edges_to_remove(n, m, edges): Returns the minimum number of edges that need to be removed so that no two nodes remain connected by more than one path. parent = list(range(n + 1)) size = [1] * (n + 1) redundants = 0 def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if size[rootX] > size[rootY]: parent[rootY] = rootX size[rootX] += size[rootY] else: parent[rootX] = rootY size[rootY] += size[rootX] else: return False return True for u, v in edges: if not union(u, v): redundants += 1 return redundants # Sample usage n, m = 5, 5 edges = [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)] print(minimum_edges_to_remove(n, m, edges)) # Output: 1"},{"question":"def create_sequence_with_local_minimum(n): Given an integer n (1 <= n <= 10^3), determine if it is possible to create a sequence of length n with exactly one local minimum. If it is possible, provide one possible sequence; otherwise, return -1. A local minimum in a sequence is an element that is strictly smaller than its immediately adjacent elements. >>> create_sequence_with_local_minimum(4) [0, 1, 0, 2] >>> create_sequence_with_local_minimum(5) [0, 1, 0, 2, 0] >>> create_sequence_with_local_minimum(3) -1 pass def process_test_cases(t, test_cases): For each test case, determine if it is possible to create a sequence of given length with exactly one local minimum. If it is possible, provide the sequence, otherwise, return -1. >>> process_test_cases(3, [4, 5, 3]) [[0, 1, 0, 2], [0, 1, 0, 2, 0], -1] >>> process_test_cases(2, [2, 7]) [-1, [0, 1, 0, 2, 0, 3, 0]] pass def format_output(results): Format the results of multiple test cases as a single string. >>> format_output([[0, 1, 0, 2], [0, 1, 0, 2, 0], -1]) '0 1 0 2n0 1 0 2 0n-1' >>> format_output([[-1], [0, 1, 0, 2, 0, 3, 0]]) '-1n0 1 0 2 0 3 0' pass","solution":"def create_sequence_with_local_minimum(n): if n < 3: return -1 if n == 3: return -1 sequence = [] for i in range(n): if i % 2 == 0: sequence.append(0) else: sequence.append(1 + (i // 2)) return sequence def process_test_cases(t, test_cases): results = [] for n in test_cases: result = create_sequence_with_local_minimum(n) results.append(result) return results # Function to format the output according to the required format def format_output(results): formatted_results = [] for result in results: if result == -1: formatted_results.append('-1') else: formatted_results.append(' '.join(map(str, result))) return 'n'.join(formatted_results)"},{"question":"from typing import List def maxPopularity(rides: List[int]) -> int: Find the maximum possible sum of popularity scores of any non-empty subsequence such that no two selected rides are adjacent in the original array. >>> maxPopularity([3, 2, 5, 10, 7]) 15 >>> maxPopularity([10000, 1, 10000, 1, 10000]) 30000","solution":"from typing import List def maxPopularity(rides: List[int]) -> int: if not rides: return 0 n = len(rides) if n == 1: return rides[0] # Initialize DP arrays dp = [0] * n dp[0] = rides[0] dp[1] = max(rides[0], rides[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + rides[i]) return dp[-1]"},{"question":"def count_unique_characters(s: str) -> int: Returns the total number of unique characters in the given string. >>> count_unique_characters(\\"abcde\\") == 5 >>> count_unique_characters(\\"12345\\") == 5 >>> count_unique_characters(\\"abc123\\") == 6 >>> count_unique_characters(\\"aabbcc112233\\") == 6 >>> count_unique_characters(\\"a\\") == 1 >>> count_unique_characters(\\"1\\") == 1 >>> count_unique_characters(\\"\\") == 0 >>> count_unique_characters(\\"a\\"*100000) == 1 >>> count_unique_characters(\\"abcdefghijklmnopqrstuvwxyz0123456789\\") == 36","solution":"def count_unique_characters(s): Returns the total number of unique characters in the given string. unique_characters = set(s) return len(unique_characters) # Example usage # s = \\"abc123\\" # print(count_unique_characters(s)) # Output: 6"},{"question":"from typing import List def compute_directory_size(n: int, items: List[str], initial_directory: str) -> int: Given the number of directories and files, a list of items describing these directories and files, and the name of the initial directory, compute the total size of the given directory, including the size of all files contained within it and within any subdirectories. n: int - the number of directories and files items: List[str] - a list describing the directories and files initial_directory: str - the directory for which to calculate the total size >>> n = 7 >>> items = ['file file1.txt 500', 'file file2.txt 300', 'dir docs', 'file docs/report.pdf 2000', 'dir images', 'file images/photo1.jpg 1500', 'file images/photo2.png 1000'] >>> initial_directory = 'images' >>> compute_directory_size(n, items, initial_directory) 2500 >>> n = 6 >>> items = ['file file1.txt 400', 'dir docs', 'file docs/report.pdf 200', 'dir docs/images', 'file docs/images/photo1.jpg 700', 'file docs/images/photo2.png 300'] >>> initial_directory = 'docs' >>> compute_directory_size(n, items, initial_directory) 1200","solution":"def compute_directory_size(n, items, initial_directory): from collections import defaultdict, deque # Parse input into a tree structure directories = defaultdict(list) files = {} for item in items: tokens = item.split() if tokens[0] == 'file': _, file_path, file_size = tokens file_size = int(file_size) path_parts = file_path.split('/') file_name = path_parts[-1] if len(path_parts) == 1: # It's a file directly under the root files[file_path] = file_size else: dir_path = '/'.join(path_parts[:-1]) directories[dir_path].append(file_path) files[file_path] = file_size elif tokens[0] == 'dir': _, dir_path = tokens # Process this dir under the directories list if '/' in dir_path: parent_dir = '/'.join(dir_path.split('/')[:-1]) directories[parent_dir].append(dir_path) # Else it is a root-level dir and doesn't need specific handling here # Recursive function to compute directory size def get_total_size(directory): total_size = 0 if directory in files: total_size += files[directory] for item in directories[directory]: total_size += get_total_size(item) return total_size return get_total_size(initial_directory)"},{"question":"def prime_numbers_up_to(n: int) -> list: Returns a list of all prime numbers up to and including n. >>> prime_numbers_up_to(10) [2, 3, 5, 7] >>> prime_numbers_up_to(2) [2] >>> prime_numbers_up_to(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def prime_numbers_up_to(n): Returns a list of all prime numbers up to and including n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False primes = [num for num in range(n + 1) if sieve[num]] return primes"},{"question":"def series_with_increasing_viewership(n: int, m: int, logs: List[Tuple[int, int, int]]) -> Tuple[int, List[int]]: Determine the series with an increase in viewership from the first month to the last month. Args: n (int): The number of series. m (int): The number of log entries. logs (List[Tuple[int, int, int]]): A list of tuples where each tuple contains the series ID, month number, and viewers. Returns: Tuple[int, List[int]]: A tuple containing the number of series with an increase and a list of their IDs in increasing order. Examples: >>> series_with_increasing_viewership(5, 10, [(1, 1, 100), (1, 2, 150), (2, 1, 200), (2, 2, 180), (3, 1, 100), (3, 3, 120), (4, 2, 50), (4, 3, 200), (4, 4, 220), (5, 1, 150), (5, 2, 150)]) (3, [1, 3, 4]) >>> series_with_increasing_viewership(3, 6, [(1, 1, 100), (1, 2, 80), (2, 1, 200), (2, 2, 180), (3, 1, 100), (3, 3, 80)]) (0, [])","solution":"def series_with_increasing_viewership(n, m, logs): from collections import defaultdict # Dictionary to store first and last month viewership for each series series_viewership = defaultdict(lambda: {'first': None, 'last': None}) for log in logs: s, t, v = log if series_viewership[s]['first'] is None or t == 1: series_viewership[s]['first'] = v series_viewership[s]['last'] = v # Identifying series with increase in viewership increasing_series = [] for s in range(1, n + 1): if series_viewership[s]['first'] < series_viewership[s]['last']: increasing_series.append(s) increasing_series.sort() return (len(increasing_series), increasing_series)"},{"question":"from typing import List, Tuple def find_longest_path(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Given a DAG with n vertices and m edges, returns the length of the longest path. Parameters: n (int): the number of vertices. m (int): the number of edges. edges (list of tuples): each tuple (u, v) represents a directed edge from u to v. Returns: int: the length of the longest path. >>> find_longest_path(6, 6, [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)]) 3 >>> find_longest_path(1, 0, []) 0 >>> find_longest_path(5, 3, [(0, 1), (2, 3), (3, 4)]) 2 >>> find_longest_path(3, 3, [(0, 1), (1, 2), (0, 2)]) 2 >>> find_longest_path(7, 8, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (3, 5), (4, 6), (5, 6)]) 4","solution":"from collections import defaultdict, deque def find_longest_path(n, m, edges): Given a DAG with n vertices and m edges, returns the length of the longest path. Parameters: n (int): the number of vertices. m (int): the number of edges. edges (list of tuples): each tuple (u, v) represents a directed edge from u to v. Returns: int: the length of the longest path. # Create adjacency list and indegree array adj = defaultdict(list) indegree = [0] * n # Populate adjacency list and indegree array for u, v in edges: adj[u].append(v) indegree[v] += 1 # Topological Sort using Kahn's algorithm topo_order = [] queue = deque() for i in range(n): if indegree[i] == 0: queue.append(i) while queue: node = queue.popleft() topo_order.append(node) for neighbor in adj[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Distance array to keep track of the longest path to each node distance = [0] * n for node in topo_order: for neighbor in adj[node]: if distance[neighbor] < distance[node] + 1: distance[neighbor] = distance[node] + 1 return max(distance)"},{"question":"def lexico_smallest_sequence(n: int, k: int, a: List[int]) -> List[int]: Discord, the spirit of chaos, has stumbled upon an interesting problem involving sequences. He wants to create a new sequence b from array a of length n by performing exactly k swap operations on a such that b is lexicographically smallest. A swap operation consists of choosing any two elements in the array and swapping them. Output the lexicographically smallest sequence possible after exactly k swaps. If it's impossible to perform any swaps (k = 0), output the original sequence. >>> lexico_smallest_sequence(5, 0, [5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> lexico_smallest_sequence(5, 1, [5, 4, 3, 2, 1]) [1, 4, 3, 2, 5] >>> lexico_smallest_sequence(5, 2, [5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> lexico_smallest_sequence(4, 10, [2, 3, 1, 4]) [1, 2, 3, 4] >>> lexico_smallest_sequence(5, 2, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5]","solution":"def lexico_smallest_sequence(n, k, a): a = list(a) for i in range(n): if k <= 0: break # find the smallest element in the remaining part of the array min_idx = i for j in range(i + 1, n): if a[j] < a[min_idx]: min_idx = j # if min_idx is different from i, then swap them if min_idx != i: a[i], a[min_idx] = a[min_idx], a[i] k -= 1 return a"},{"question":"def can_complete_assignments(n: int, assignments: List[Tuple[int, int]]) -> str: Determines if the assignments can be completed without missing any deadlines. Parameters: n (int): Number of assignments. assignments (list of tuples): Each tuple contains two integers - deadline and time required. Returns: str: \\"YES\\" if all assignments can be completed on time, otherwise \\"NO\\". >>> can_complete_assignments(3, [(5, 2), (3, 1), (7, 3)]) 'YES' >>> can_complete_assignments(3, [(4, 3), (3, 2), (2, 1)]) 'NO' >>> can_complete_assignments(2, [(10, 5), (15, 5)]) 'YES' >>> can_complete_assignments(2, [(1, 2), (2, 3)]) 'NO' >>> can_complete_assignments(1, [(1000, 1000)]) 'YES'","solution":"def can_complete_assignments(n, assignments): Determines if the assignments can be completed without missing any deadlines. Parameters: n (int): Number of assignments. assignments (list of tuples): Each tuple contains two integers - deadline and time required. Returns: str: \\"YES\\" if all assignments can be completed on time, otherwise \\"NO\\". # Sort assignments by deadline assignments.sort(key=lambda x: x[0]) current_time = 0 for deadline, time_required in assignments: current_time += time_required if current_time > deadline: return \\"NO\\" return \\"YES\\""},{"question":"def determine_winner(n: int, sequence: List[int]) -> str: Determines the winner of the game given the length of the sequence and the sequence itself. :param n: int - The number of elements in the sequence. :param sequence: list of int - The sequence of integers. :return: str - \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. >>> determine_winner(5, [3, 1, 2, 5, 4]) 'Alice' >>> determine_winner(6, [10, 1, 2, 3, 5, 4]) 'Bob' >>> determine_winner(1, [42]) 'Alice' >>> determine_winner(2, [100, 200]) 'Bob' >>> determine_winner(3, [10000, 200, 30000]) 'Alice' >>> determine_winner(4, [1, 1, 1, 1]) 'Bob' >>> determine_winner(7, [100, 101, 99, 102, 98, 103, 97]) 'Alice'","solution":"def determine_winner(n, sequence): Determines the winner of the game given the length of the sequence and the sequence itself. :param n: int - The number of elements in the sequence. :param sequence: list of int - The sequence of integers. :return: str - \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. if n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def max_signal_strength(n: int, d: int, signals: List[int]) -> int: Returns the maximum sum of signal strengths over any consecutive \`d\` intervals. :param n: int, total number of signal intervals. :param d: int, duration - number of consecutive intervals. :param signals: list of int, signal strengths for each interval. :return: int, maximum sum of signal strengths over any consecutive \`d\` intervals. Examples: >>> max_signal_strength(8, 3, [5, 10, 20, 10, 5, 10, 5, 20]) 40 >>> max_signal_strength(1, 1, [10]) 10 from typing import List def test_example(): assert max_signal_strength(8, 3, [5, 10, 20, 10, 5, 10, 5, 20]) == 40 def test_minimal_case(): assert max_signal_strength(1, 1, [10]) == 10 def test_all_same_signals(): assert max_signal_strength(5, 2, [10, 10, 10, 10, 10]) == 20 def test_varied_signals(): assert max_signal_strength(10, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 34 def test_multiple_same_max_sum(): assert max_signal_strength(7, 3, [4, 4, 4, 4, 4, 4, 4]) == 12 def test_large_input(): assert max_signal_strength(100000, 1, [i for i in range(100000)]) == 99999 def test_large_d(): assert max_signal_strength(100000, 100000, [1]*100000) == 100000","solution":"def max_signal_strength(n, d, signals): Returns the maximum sum of signal strengths over any consecutive \`d\` intervals. :param n: int, total number of signal intervals. :param d: int, duration - number of consecutive intervals. :param signals: list of int, signal strengths for each interval. :return: int, maximum sum of signal strengths over any consecutive \`d\` intervals. # Initialization for the sliding window current_sum = sum(signals[:d]) max_sum = current_sum # Sliding window to find the maximum sum of \`d\` consecutive intervals for i in range(d, n): current_sum = current_sum - signals[i - d] + signals[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def count_increasing_triplets(arr: List[int], n: int) -> int: Count the number of increasing triplets in an array of size n. Args: arr (List[int]): The input array. n (int): The size of the array. Returns: int: The count of increasing triplets. pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to count increasing triplets. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples containing array size and array. Returns: List[int]: List of results for each test case. pass def main(input_data: str) -> str: Main function to handle input and output for counting increasing triplets. Args: input_data (str): Input string containing multiple test cases. Returns: str: Output string containing results for each test case. pass # Example usage of the main function example_input = \\"2n4n1 2 3 4n5n5 4 3 2 1\\" print(main(example_input)) # Output: \\"4n0\\"","solution":"def count_increasing_triplets(arr, n): Counts the number of increasing triplets in array arr of size n. count = 0 for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if arr[i] < arr[j] < arr[k]: count += 1 return count def process_test_cases(test_cases): Processes multiple test cases and returns a list of results. results = [] for n, arr in test_cases: results.append(count_increasing_triplets(arr, n)) return results # Function to handle input and output def main(input_data): lines = input_data.strip().split(\\"n\\") t = int(lines[0].strip()) test_cases = [] idx = 1 for _ in range(t): n = int(lines[idx].strip()) arr = list(map(int, lines[idx + 1].strip().split())) test_cases.append((n, arr)) idx += 2 results = process_test_cases(test_cases) return \\"n\\".join(map(str, results)) # Example usage of the main function example_input = \\"2n4n1 2 3 4n5n5 4 3 2 1\\" print(main(example_input)) # Output: \\"4n0\\""},{"question":"def longest_consecutive_substring(s: str) -> str: Find the longest substring which consists of consecutive identical characters. >>> longest_consecutive_substring(\\"aaabbbcc\\") \\"aaa\\" >>> longest_consecutive_substring(\\"abcd\\") \\"a\\" >>> longest_consecutive_substring(\\"aabbccdd\\") \\"aa\\" >>> longest_consecutive_substring(\\"bbbaaacc\\") \\"bbb\\" >>> longest_consecutive_substring(\\"ccccc\\") \\"ccccc\\" >>> longest_consecutive_substring(\\"a\\") \\"a\\" >>> longest_consecutive_substring(\\"bbaaabb\\") \\"aaa\\"","solution":"def longest_consecutive_substring(s: str) -> str: if not s: return \\"\\" max_len = 1 current_char = s[0] current_len = 1 max_substring = s[0] for i in range(1, len(s)): if s[i] == s[i-1]: current_len += 1 if current_len > max_len: max_len = current_len max_substring = s[i-current_len + 1:i+1] else: current_len = 1 return max_substring"},{"question":"def vending_machine(n, slots, q, requests): Simulate a vending machine that handles multiple purchase requests and determines the state of the machine. >>> vending_machine(10, \\"1.2...3.45\\", 5, [1, 3, 5, 2, 6]) [\\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"OUT OF STOCK\\"] >>> vending_machine(10, \\"..........\\", 3, [1, 2, 3]) [\\"OUT OF STOCK\\", \\"OUT OF STOCK\\", \\"OUT OF STOCK\\"] >>> vending_machine(1, \\"1\\", 1, [1]) [\\"SUCCESS\\"] >>> vending_machine(1, \\".\\", 1, [1]) [\\"OUT OF STOCK\\"] >>> vending_machine(5, \\"12345\\", 5, [1, 2, 3, 4, 5]) [\\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\"] >>> vending_machine(5, \\"12345\\", 7, [1, 2, 3, 4, 5, 6, 7]) [\\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"OUT OF STOCK\\", \\"OUT OF STOCK\\"]","solution":"def vending_machine(n, slots, q, requests): slot_map = {} for i in range(n): if slots[i] != '.': slot_map[int(slots[i])] = i results = [] for req in requests: if req in slot_map: results.append(\\"SUCCESS\\") del slot_map[req] else: results.append(\\"OUT OF STOCK\\") return results"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[str]) -> List[int]: Process the given queries on the array. Parameters: n (int): Length of the array q (int): Number of queries array (list): Initial array elements queries (list): List of queries Returns: list: Results of the \\"2 l r k\\" queries","solution":"def process_queries(n, q, array, queries): Process the given queries on the array. Parameters: n (int): Length of the array q (int): Number of queries array (list): Initial array elements queries (list): List of queries Returns: list: Results of the \\"2 l r k\\" queries results = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": x = int(parts[1]) - 1 y = int(parts[2]) array[x] = y elif parts[0] == \\"2\\": l = int(parts[1]) - 1 r = int(parts[2]) k = int(parts[3]) sub_array = sorted(array[l:r]) results.append(sub_array[k-1]) return results # Example run: n = 5 q = 3 array = [5, 3, 7, 1, 8] queries = [\\"2 1 3 2\\", \\"1 3 2\\", \\"2 1 3 2\\"] print(process_queries(n, q, array, queries)) # Expected Output: [5, 3]"},{"question":"def max_alice_score(n: int, sequence: List[int]) -> int: Calculate the maximum score Alice can achieve if both Alice and Bob play optimally with the given sequence of integers. >>> max_alice_score(5, [1, 2, 3, 4, 5]) 9 >>> max_alice_score(4, [-1, -2, -3, -4]) -1 >>> max_alice_score(5, [1, -2, 3, 4, -5]) 7 >>> max_alice_score(5, [-1, 2, 3, -4, 5]) 6 from solution import max_alice_score def test_max_alice_score_simple(): assert max_alice_score(5, [1, 2, 3, 4, 5]) == 9 def test_max_alice_score_all_negative(): assert max_alice_score(4, [-1, -2, -3, -4]) == -1 def test_max_alice_score_mixed(): assert max_alice_score(5, [1, -2, 3, 4, -5]) == 7 assert max_alice_score(5, [-1, 2, 3, -4, 5]) == 6 def test_max_alice_score_single_element(): assert max_alice_score(1, [5]) == 5 assert max_alice_score(1, [-5]) == -5 def test_max_alice_score_positive_only(): assert max_alice_score(6, [2, 4, 6, 8, 10, 12]) == 42 def test_max_alice_score_alternating_signs(): assert max_alice_score(6, [1, -1, 2, -2, 3, -3]) == 3","solution":"def max_alice_score(n, sequence): Calculates the maximum score Alice can achieve with the given sequence of numbers if both Alice and Bob play optimally. def max_subarray_sum(arr): Helper function to compute the maximum subarray sum using Kadane's Algorithm. max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum # Compute the maximum subarray sum which is the best score Alice can achieve. return max_subarray_sum(sequence)"},{"question":"def max_team_size(n: int, ages: List[int]) -> int: Determines the maximum number of participants that can form a team where the difference between the youngest and the oldest member is not more than 5 years. Arguments: n -- the number of participants ages -- list of ages of the participants Returns: Maximum number of participants in a team satisfying the given condition","solution":"def max_team_size(n, ages): Determines the maximum number of participants that can form a team where the difference between the youngest and the oldest member is not more than 5 years. Arguments: n -- the number of participants ages -- list of ages of the participants Returns: Maximum number of participants in a team satisfying the given condition ages.sort() max_size = 0 left = 0 for right in range(n): while ages[right] - ages[left] > 5: left += 1 max_size = max(max_size, right - left + 1) return max_size"},{"question":"from typing import List def find_arithmetic_triplet(arr: List[int]) -> bool: Returns True if there are three distinct elements in the array that form an arithmetic progression, False otherwise. >>> find_arithmetic_triplet([1, 3, 5, 7]) True >>> find_arithmetic_triplet([10, 2, 7, 6, 4]) True >>> find_arithmetic_triplet([1, 2, 4, 5]) False","solution":"def find_arithmetic_triplet(arr): Returns True if there are three distinct elements in the array that form an arithmetic progression, False otherwise. n = len(arr) if n < 3: return False arr = sorted(arr) for i in range(n-2): for j in range(i+1, n-1): for k in range(j+1, n): if arr[j] - arr[i] == arr[k] - arr[j]: return True return False"},{"question":"def min_unique_substrings(s: str) -> int: Determine the minimum number of contiguous substrings into which the string s can be divided such that each substring contains at most one unique character. >>> min_unique_substrings(\\"aaaaa\\") 1 >>> min_unique_substrings(\\"ababab\\") 6 >>> min_unique_substrings(\\"aaabbbccc\\") 3 >>> min_unique_substrings(\\"a\\") 1 >>> min_unique_substrings(\\"\\") 0 >>> min_unique_substrings(\\"aabb\\") 2","solution":"def min_unique_substrings(s): Returns the minimum number of contiguous substrings such that each substring contains at most one unique character. if not s: return 0 count = 1 for i in range(1, len(s)): if s[i] != s[i - 1]: count += 1 return count"},{"question":"def minimize_additions(n, times): Returns the minimum sum of additions required to make all times unique. >>> minimize_additions(5, [1, 2, 2, 2, 5]) 3 >>> minimize_additions(5, [1, 3, 6, 7, 9]) 0 >>> minimize_additions(4, [5, 5, 5, 5]) 6 >>> minimize_additions(3, [1, 2, 3]) 0 >>> minimize_additions(4, [1, 2, 2, 1000000000]) 1","solution":"def minimize_additions(n, times): Returns the minimum sum of additions required to make all times unique. times.sort() additions = 0 for i in range(1, n): if times[i] <= times[i-1]: additions += times[i-1] - times[i] + 1 times[i] = times[i-1] + 1 return additions"},{"question":"def find_initial_unique_games(S, F, g1, g2, g3): Given the total unique games S, additional forgotten games F, and the total games collected by each of the three friends (g1, g2, g3), return one of the possible minimum initial unique games each of them could have initially brought to the collection, or -1 if such a configuration does not exist. >>> find_initial_unique_games(12, 3, 5, 3, 7) (5, 3, 4) >>> find_initial_unique_games(10, 5, 3, 3, 3) -1","solution":"def find_initial_unique_games(S, F, g1, g2, g3): total_games = S + F if total_games > g1 + g2 + g3: return -1 # If the total unique games plus forgotten games is equal # to the sum of all games collected initially, return the # total games collected by each initially. return g1, g2, g3 # Example input S = 12 F = 3 g1 = 5 g2 = 3 g3 = 7 print(find_initial_unique_games(S, F, g1, g2, g3))"},{"question":"def get_maximum_product(n: int, m: int, k: int, grid: List[List[int]]) -> int: Given a grid of dimensions n x m with each cell containing a positive integer, find the maximum product of integers that forms a k-length path on the grid. The path can begin at any cell and can move in any of the four cardinal directions (up, down, left, right) without revisiting any cell. The path length k will be given and it's guaranteed that k is less than or equal to n*m. >>> get_maximum_product(3, 3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 504 >>> get_maximum_product(2, 2, 2, [[1, 2], [3, 4]]) 12 >>> get_maximum_product(4, 4, 4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 1 >>> get_maximum_product(3, 4, 2, [[1, 7, 8, 9], [2, 10, 3, 4], [5, 6, 11, 12]]) 132 >>> get_maximum_product(1, 1, 1, [[42]]) 42","solution":"def get_maximum_product(n, m, k, grid): def dfs(x, y, k, product): if k == 0: return product max_product = 0 visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: max_product = max(max_product, dfs(nx, ny, k - 1, product * grid[nx][ny])) visited.remove((x, y)) return max_product max_product = 0 for i in range(n): for j in range(m): visited = set() max_product = max(max_product, dfs(i, j, k - 1, grid[i][j])) return max_product"},{"question":"def longest_subarray_with_two_distinct(arr): Returns the length of the longest subarray which contains at most two distinct values with a difference of no more than one. pass def test_example_1(): arr = [1, 2, 2, 3, 3, 4] assert longest_subarray_with_two_distinct(arr) == 4 def test_example_2(): arr = [5, 5, 5, 5, 5] assert longest_subarray_with_two_distinct(arr) == 5 def test_single_element(): arr = [1] assert longest_subarray_with_two_distinct(arr) == 1 def test_no_valid_subarray(): arr = [1, 3, 5] assert longest_subarray_with_two_distinct(arr) == 1 def test_entire_array_is_valid(): arr = [1, 1, 2, 2, 1, 2] assert longest_subarray_with_two_distinct(arr) == 6 def test_complex_case(): arr = [4, 4, 5, 5, 6, 7, 7, 8] assert longest_subarray_with_two_distinct(arr) == 4 def test_edge_case_with_min_and_max_elements(): arr = [1, 1, 10000, 10000] assert longest_subarray_with_two_distinct(arr) == 2","solution":"def longest_subarray_with_two_distinct(arr): Returns the length of the longest subarray which contains at most two distinct values with a difference of no more than one. from collections import defaultdict n = len(arr) if n == 0: return 0 max_length = 0 left = 0 counts = defaultdict(int) for right in range(n): counts[arr[right]] += 1 while len(counts) > 2 or (len(counts) == 2 and max(counts.keys()) - min(counts.keys()) > 1): counts[arr[left]] -= 1 if counts[arr[left]] == 0: del counts[arr[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Find the length of the longest substring of s that contains at most k distinct characters. >>> longest_substring_with_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"aa\\", 1) 2","solution":"def longest_substring_with_k_distinct(s: str, k: int) -> int: from collections import Counter n = len(s) if n * k == 0: return 0 left, right = 0, 0 max_length = 0 char_count = Counter() while right < n: char_count[s[right]] += 1 right += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"from typing import List, Tuple def calculate_leaf_distances(n: int, edges: List[Tuple[int, int]]) -> int: Calculate the sum of the distances from each leaf node to the root of the tree. Args: n (int): Number of edges in the tree. edges (List[Tuple[int, int]]): List of tuples representing the edges in the tree where (parent, child). Returns: int: Sum of the distances from each leaf node to the root. >>> calculate_leaf_distances(5, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) 6 >>> calculate_leaf_distances(0, []) 0 pass","solution":"def calculate_leaf_distances(n, edges): from collections import defaultdict, deque # Construct the adjacency list tree = defaultdict(list) for parent, child in edges: tree[parent].append(child) # Function to calculate the distances of all leaves from the root def sum_leaf_distances(root): queue = deque([(root, 0)]) total_distance = 0 while queue: node, distance = queue.popleft() if node not in tree: # it's a leaf node total_distance += distance else: for child in tree[node]: queue.append((child, distance + 1)) return total_distance return sum_leaf_distances(1)"},{"question":"def second_largest_number(n: int, num_list: List[int]) -> int: Returns the second largest distinct number from the list. Args: n : int : Number of integers in the list (2 ≤ n ≤ 100) num_list : List[int] : List of integers (-1000 ≤ num ≤ 1000) Returns: int : The second largest distinct number Raises: ValueError: If the list does not contain at least two distinct numbers. Examples: >>> second_largest_number(5, [2, 3, 6, 6, 5]) 5 >>> second_largest_number(4, [10, 20, 30, 40]) 30","solution":"def second_largest_number(n, num_list): Returns the second largest distinct number from the list. unique_nums = list(set(num_list)) if len(unique_nums) < 2: raise ValueError(\\"List must contain at least two distinct numbers.\\") unique_nums.sort() return unique_nums[-2] # To demonstrate usage # n = 5 # num_list = [2, 3, 6, 6, 5] # result = second_largest_number(n, num_list) # print(result) # Output should be 5"},{"question":"def max_palindrome_length(n: int, s: str) -> int: Given the length of the string n and the binary string s, return the maximum length of the binary palindrome sequence. >>> max_palindrome_length(5, \\"11001\\") 6 >>> max_palindrome_length(6, \\"101010\\") 6 >>> max_palindrome_length(3, \\"111\\") 3 >>> max_palindrome_length(1, \\"0\\") 1 >>> max_palindrome_length(7, \\"1110001\\") 7","solution":"def max_palindrome_length(n, s): Given the length of the string n and the binary string s, return the maximum length of the binary palindrome sequence. # Since each individual character can be a palindrome, # The maximum possible length of the binary palindrome sequence is the length of the string. return n"},{"question":"from typing import List def kth_smallest(arr: List[int], k: int) -> int: Returns the k-th smallest element in the array. :param arr: list of unsorted integers :param k: 1-based index of the smallest element to find :return: k-th smallest element in the array >>> kth_smallest([7, 10, 4, 3, 20, 15, 1], 3) == 4 >>> kth_smallest([12, 3, 5, 7, 19], 4) == 12 >>> kth_smallest([1], 1) == 1 >>> kth_smallest(list(range(1000, 0, -1)), 1) == 1 >>> kth_smallest([8, 6, 7, 5, 3, 0, 9], 5) == 7 >>> kth_smallest([1, 2, 3], 1) == 1 >>> kth_smallest([1, 2, 3], 3) == 3 >>> kth_smallest([1000000000, 999999999, 999999998], 2) == 999999999 >>> kth_smallest([50, 40, 30, 20, 10], 2) == 20 >>> kth_smallest([5, 4, 3, 2, 1], 4) == 4 >>> import random >>> random.seed(0) >>> arr = random.sample(range(1, 1000000), 1000) >>> kth_smallest(arr, 500) == sorted(arr)[499]","solution":"def kth_smallest(arr, k): Returns the k-th smallest element in the array. :param arr: List[int] - list of unsorted integers :param k: int - 1-based index of the smallest element to find :return: int - k-th smallest element in the array # Ensure that the index is within the 0-based index range. assert 1 <= k <= len(arr), \\"k is out of bounds\\" return sorted(arr)[k-1]"},{"question":"def minimize_difference(arr) -> int: Given a list of integers, distribute the elements into two groups such that the absolute difference between the sum of the elements in the two groups is minimized. >>> minimize_difference([1, 2, 3, 4, 5]) 1 >>> minimize_difference([8, 6, 5, 4]) 1 >>> minimize_difference([2, 2, 3]) 1 pass def solve(t, test_cases): Accepts the number of test cases and a list of tuples containing the length of the array and the array itself, and returns a list of minimum possible absolute differences for each test case. >>> t = 3 >>> test_cases = [ ... (5, [1, 2, 3, 4, 5]), ... (4, [8, 6, 5, 4]), ... (3, [2, 2, 3]) ... ] >>> solve(t, test_cases) [1, 1, 1] pass def test_solve(): t = 3 test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [8, 6, 5, 4]), (3, [2, 2, 3]) ] expected_output = [1, 1, 1] assert solve(t, test_cases) == expected_output def test_single_element(): t = 1 test_cases = [ (1, [1]) ] expected_output = [1] assert solve(t, test_cases) == expected_output def test_identical_elements(): t = 1 test_cases = [ (4, [5, 5, 5, 5]) ] expected_output = [0] assert solve(t, test_cases) == expected_output def test_large_case(): t = 1 test_cases = [ (10, [1, 3, 3, 2, 1, 2, 7, 7, 10, 25]) ] expected_output = [1] # Expected output manually verified assert solve(t, test_cases) == expected_output def test_multiple_same_elements(): t = 1 test_cases = [ (6, [1, 1, 1, 1, 1, 1]) ] expected_output = [0] assert solve(t, test_cases) == expected_output","solution":"def minimize_difference(arr): n = len(arr) total_sum = sum(arr) possible_sums = {0} # list to store possible sums using subsets for num in arr: new_sums = set() for possible_sum in possible_sums: new_sums.add(possible_sum + num) possible_sums.update(new_sums) min_diff = float('inf') for possible_sum in possible_sums: other_sum = total_sum - possible_sum min_diff = min(min_diff, abs(possible_sum - other_sum)) return min_diff def solve(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(minimize_difference(arr)) return results"},{"question":"def cyclic_right_rotation(n: int, k: int, arr: List[int]) -> List[int]: Performs cyclic right rotation on the array k times. Parameters: n (int): Number of elements in the array k (int): Number of rotations arr (List[int]): The array of integers Returns: List[int]: The array after k right rotations >>> cyclic_right_rotation(5, 2, [1, 2, 3, 4, 5]) [4, 5, 1, 2, 3] >>> cyclic_right_rotation(7, 3, [1, 2, 3, 4, 5, 6, 7]) [5, 6, 7, 1, 2, 3, 4] >>> cyclic_right_rotation(4, 4, [1, 2, 3, 4]) [1, 2, 3, 4] >>> cyclic_right_rotation(5, 0, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> cyclic_right_rotation(1, 100, [1]) [1] >>> cyclic_right_rotation(6, 6, [7, 8, 9, 10, 11, 12]) [7, 8, 9, 10, 11, 12] >>> cyclic_right_rotation(6, 7, [13, 14, 15, 16, 17, 18]) [18, 13, 14, 15, 16, 17]","solution":"def cyclic_right_rotation(n, k, arr): Returns the array after performing k cyclic right rotations. Parameters: n (int): Number of elements in array k (int): Number of rotations arr (list of ints): The array of integers Returns: list of ints: The array after k right rotations k = k % n # To handle cases where k >= n return arr[-k:] + arr[:-k]"},{"question":"def find_special_intersections(m: int, n: int) -> list: Returns a list of tuples where each tuple (i, j) represents the coordinates of a special intersection in the grid with dimensions m x n. An intersection (i, j) is considered special if and only if (i + j) % 2 == 0. >>> find_special_intersections(3, 3) [(0, 0), (0, 2), (1, 1), (2, 0), (2, 2)] >>> find_special_intersections(2, 2) [(0, 0), (1, 1)]","solution":"def find_special_intersections(m, n): Returns a list of tuples where each tuple (i, j) represents the coordinates of a special intersection in the grid with dimensions m x n. An intersection (i, j) is considered special if and only if (i + j) % 2 == 0. special_intersections = [(i, j) for i in range(m) for j in range(n) if (i + j) % 2 == 0] return special_intersections"},{"question":"from typing import List def generate_parentheses(N: int) -> List[str]: Generate all valid combinations of N pairs of parentheses. Args: N: an integer representing the number of pairs of parentheses Returns: List of strings representing all valid combinations of N pairs of parentheses. >>> generate_parentheses(0) [\\"\\"] >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]","solution":"from typing import List def generate_parentheses(N: int) -> List[str]: def backtrack(s, left, right): if len(s) == 2 * N: result.append(s) return if left < N: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) result = [] backtrack('', 0, 0) return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, '+', and '*' following the correct order of operations. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"6*7+2*3\\") 48 >>> evaluate_expression(\\"8+9*3*2+1\\") 63 >>> evaluate_expression(\\"1+2+3+4\\") 10 >>> evaluate_expression(\\"2*3*4\\") 24 >>> evaluate_expression(\\"7\\") 7 >>> evaluate_expression(\\"0\\") 0 >>> evaluate_expression(\\"999999\\") 999999","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers, '+', and '*' following the correct order of operations. # Split expression by '+' to handle the addition separately additive_parts = expression.split('+') # Evaluate each part, handling multiplication within each part sum_result = 0 for part in additive_parts: multiplicative_parts = part.split('*') product_result = 1 for factor in multiplicative_parts: product_result *= int(factor) sum_result += product_result return sum_result"},{"question":"from collections import defaultdict def manage_restaurant_orders(queries): Manage restaurant orders based on the given queries. Args: queries (List[str]): A list of strings where each string is a query of the form: '1 x order' - Customer x places an order '2 x' - Customer x removes their last order '3 x' - Print the last order of customer x Returns: List[str]: The results of queries of type '3' in the order they appear. Examples: >>> manage_restaurant_orders([\\"1 1 pasta\\", \\"1 1 burger\\", \\"1 2 salad\\", \\"3 1\\", \\"2 1\\", \\"3 1\\", \\"3 2\\", \\"2 2\\", \\"3 2\\"]) ['burger', 'pasta', 'salad', '()']","solution":"from collections import defaultdict def manage_restaurant_orders(queries): customer_orders = defaultdict(list) results = [] for query in queries: q = query.split() if q[0] == '1': x = int(q[1]) order = q[2] customer_orders[x].append(order) elif q[0] == '2': x = int(q[1]) if customer_orders[x]: customer_orders[x].pop() elif q[0] == '3': x = int(q[1]) if customer_orders[x]: results.append(customer_orders[x][-1]) else: results.append(\\"()\\") return results"},{"question":"def num_connected_components(n: int, m: int, grid: List[List[int]]) -> int: Calculates the number of connected components of flower beds in the garden grid. n: int - number of rows in the garden grid m: int - number of columns in the garden grid grid: List[List[int]] - 2D list representing the garden grid where 1 represents a flower and 0 represents empty Returns the number of connected components. >>> num_connected_components(3, 3, [[1, 1, 0], [0, 1, 0], [1, 0, 1]]) 3 >>> num_connected_components(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> num_connected_components(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 >>> num_connected_components(1, 4, [[1, 0, 1, 1]]) 2 >>> num_connected_components(4, 1, [[1], [0], [1], [1]]) 2 >>> num_connected_components(100, 100, [[0] * 100 for _ in range(100)]) 0 >>> num_connected_components(100, 100, [[1] * 100 for _ in range(100)]) 1","solution":"def num_connected_components(n, m, grid): def dfs(x, y): stack = [(x, y)] while stack: i, j = stack.pop() if i < 0 or j < 0 or i >= n or j >= m or grid[i][j] == 0: continue grid[i][j] = 0 stack.append((i-1, j)) stack.append((i+1, j)) stack.append((i, j-1)) stack.append((i, j+1)) count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: dfs(i, j) count += 1 return count"},{"question":"def generate_summary(log_entries, server_id): Processes log entries and generates a summary report for a specified server_id. :param log_entries: List of log entry strings. :param server_id: Integer representing the server_id for which the summary report is to be generated. :return: String formatted summary report including counts and last timestamps of each event type. Example: log_entries = [ \\"2023-01-01 12:00:00 1 ERROR Disk full\\", \\"2023-01-01 12:05:00 2 INFO Service started\\", \\"2023-01-01 12:10:00 1 WARNING CPU load high\\", \\"2023-01-01 12:15:00 1 INFO Service started\\", \\"2023-01-01 12:20:00 2 ERROR Disk full\\" ] server_id = 1 expected_output = ( \\"ERROR count: 1 last timestamp: 2023-01-01 12:00:00n\\" \\"WARNING count: 1 last timestamp: 2023-01-01 12:10:00n\\" \\"INFO count: 1 last timestamp: 2023-01-01 12:15:00\\" ) assert generate_summary(log_entries, server_id) == expected_output pass","solution":"def process_log_entries(log_entries, server_id): Processes log entries and generates a summary report for a specified server_id. :param log_entries: List of log entry strings. :param server_id: Integer representing the server_id for which the summary report is to be generated. :return: Dictionary with the count and last timestamp of each event type for the specified server_id. from collections import defaultdict result = { \\"ERROR\\": {\\"count\\": 0, \\"last_timestamp\\": \\"N/A\\"}, \\"WARNING\\": {\\"count\\": 0, \\"last_timestamp\\": \\"N/A\\"}, \\"INFO\\": {\\"count\\": 0, \\"last_timestamp\\": \\"N/A\\"} } for entry in log_entries: parts = entry.split(\\" \\", 3) timestamp = f\\"{parts[0]} {parts[1]}\\" entry_server_id = int(parts[2]) event_type = parts[3].split()[0] if entry_server_id == server_id: result[event_type][\\"count\\"] += 1 result[event_type][\\"last_timestamp\\"] = timestamp return result def format_summary(report): Formats the summary report into a string output. :param report: Dictionary containing the report generated by process_log_entries. :return: Formatted string of the summary report. return ( f\\"ERROR count: {report['ERROR']['count']} last timestamp: {report['ERROR']['last_timestamp']}n\\" f\\"WARNING count: {report['WARNING']['count']} last timestamp: {report['WARNING']['last_timestamp']}n\\" f\\"INFO count: {report['INFO']['count']} last timestamp: {report['INFO']['last_timestamp']}\\" ) def generate_summary(log_entries, server_id): report = process_log_entries(log_entries, server_id) return format_summary(report)"},{"question":"def shortest_path(n: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> int: Calculates the shortest path between two nodes in a weighted graph. Parameters: n (int): Number of nodes in the graph. edges (list of tuples): List of edges where each edge is represented as (u, v, w). start (int): Starting node. end (int): Ending node. Returns: int: The shortest distance from start to end. Returns -1 if there is no path. >>> shortest_path(4, [(1, 2, 1), (2, 3, 4), (3, 4, 4), (1, 3, 2)], 1, 4) 6 >>> shortest_path(3, [(1, 2, 5)], 1, 3) -1 >>> shortest_path(2, [(1, 1, 2), (1, 2, 4)], 1, 2) 4 >>> shortest_path(3, [(1, 2, 3), (1, 2, 2), (2, 3, 4)], 1, 3) 6 >>> shortest_path(1, [], 1, 1) 0","solution":"import heapq def shortest_path(n, edges, start, end): Calculates the shortest path between two nodes in a weighted graph. Parameters: n (int): Number of nodes in the graph. edges (list of tuples): List of edges where each edge is represented as (u, v, w). start (int): Starting node. end (int): Ending node. Returns: int: The shortest distance from start to end. Returns -1 if there is no path. # Create adjacency list for the graph graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Distance dictionary to keep track of the shortest path to each node distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 # Priority queue to process nodes with the smallest distance first priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1"},{"question":"from typing import List def sum_except_self(nums: List[int]) -> List[int]: Returns a new list where each element is the sum of all other elements except the one at that index. >>> sum_except_self([1, 2, 3, 4]) [9, 8, 7, 6] >>> sum_except_self([10]) [0] >>> sum_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> sum_except_self([-1, 0, 1, 2]) [3, 2, 1, 0] >>> sum_except_self([-1, -2, -3, -4]) [-9, -8, -7, -6]","solution":"from typing import List def sum_except_self(nums: List[int]) -> List[int]: Returns a new list where each element is the sum of all other elements except the one at that index. total_sum = sum(nums) result = [total_sum - num for num in nums] return result"},{"question":"def can_remove_one_element_to_divisible_by_k(n: int, k: int, arr: List[int]) -> str: Given an array of integers, determines if it's possible to remove exactly one element such that the sum of the remaining elements is divisible by k. Args: n (int): The number of elements in the array. k (int): The integer to which the sum of the remaining elements should be divisible. arr (list of int): The list of integers. Returns: str: \\"YES\\" if it's possible to remove one element to achieve the required condition, otherwise \\"NO\\". Examples: >>> can_remove_one_element_to_divisible_by_k(5, 3, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_remove_one_element_to_divisible_by_k(4, 5, [1, 6, 2, 5]) \\"NO\\"","solution":"def can_remove_one_element_to_divisible_by_k(n, k, arr): Given an array of integers, determines if it's possible to remove exactly one element such that the sum of the remaining elements is divisible by k. Args: n (int): The number of elements in the array. k (int): The integer to which the sum of the remaining elements should be divisible. arr (list of int): The list of integers. Returns: str: \\"YES\\" if it's possible to remove one element to achieve the required condition, otherwise \\"NO\\". total_sum = sum(arr) for num in arr: if (total_sum - num) % k == 0: return \\"YES\\" return \\"NO\\""},{"question":"def count_distinct_ways(k: int, condition: str) -> int: Returns the number of distinct ways to place the coins in the slots such that the sum of the values of the coins in adjacent slots is either even or odd. Parameters: k (int): Number of slots and coins. condition (str): The type of sum we need to maintain ('even' or 'odd'). Returns: int: Count of distinct ways modulo 10^9 + 7. >>> count_distinct_ways(4, \\"even\\") 1 >>> count_distinct_ways(5, \\"odd\\") 0","solution":"def count_distinct_ways(k, condition): Returns the number of distinct ways to place the coins in the slots such that the sum of the values of the coins in adjacent slots is either even or odd. Parameters: k (int): Number of slots and coins. condition (str): The type of sum we need to maintain ('even' or 'odd'). Returns: int: Count of distinct ways modulo 10^9 + 7. MOD = 10**9 + 7 if k % 2 == 1: # When k is odd, there is no valid way to satisfy the condition. return 0 if condition == 'even': # Only one way for even condition rotating through k ways considered same return 1 % MOD if condition == 'odd': # For odd condition, there are two unique configurations return 2 % MOD return 0 # Example Usage print(count_distinct_ways(4, \\"even\\")) # Output: 1 print(count_distinct_ways(5, \\"odd\\")) # Output: 0"},{"question":"from typing import List def max_subarray_two_distinct(arr: List[int]) -> int: Returns the maximum length of a subarray that contains at most two different integers. >>> max_subarray_two_distinct([1, 2, 1, 2, 3, 2]) 4 >>> max_subarray_two_distinct([1, 2, 2, 3, 3, 1, 1]) 4 >>> max_subarray_two_distinct([4, 4, 4, 4]) 4 >>> max_subarray_two_distinct([5, 5, 6, 6, 7, 8]) 4 >>> max_subarray_two_distinct([1]) 1 >>> max_subarray_two_distinct([1, 2, 3, 4, 5, 6]) 2 >>> max_subarray_two_distinct([]) 0 >>> max_subarray_two_distinct([1, 2, 1, 1, 2, 3]) 5 >>> max_subarray_two_distinct([3, 3, 3, 3, 3, 3]) 6 >>> max_subarray_two_distinct([1, 2, 2, 1, 1, 1, 3, 3]) 6","solution":"def max_subarray_two_distinct(arr): Returns the maximum length of a subarray that contains at most two different integers. :param arr: List[int] - the input array of integers :return: int - the maximum length of the desired subarray n = len(arr) if not arr: return 0 left = 0 freq = {} max_length = 0 for right in range(n): freq[arr[right]] = freq.get(arr[right], 0) + 1 while len(freq) > 2: freq[arr[left]] -= 1 if freq[arr[left]] == 0: del freq[arr[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def largest_square_submatrix_area(n: int, m: int, matrix: List[List[int]]) -> int: Given a binary matrix, finds the area of the largest square sub-matrix consisting entirely of 1's. Returns the area of that square sub-matrix. >>> matrix = [ ... [1, 0, 1, 0, 0, 1], ... [1, 0, 1, 1, 1, 1], ... [1, 1, 1, 1, 1, 1], ... [1, 0, 0, 1, 1, 1], ... [1, 1, 1, 1, 1, 1] ... ] >>> largest_square_submatrix_area(5, 6, matrix) == 9 >>> matrix = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> largest_square_submatrix_area(3, 3, matrix) == 0 >>> matrix = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> largest_square_submatrix_area(3, 3, matrix) == 9 >>> matrix = [ ... [0, 1, 1, 0, 0], ... [1, 1, 1, 1, 0], ... [1, 1, 0, 0, 0], ... [1, 1, 1, 1, 1], ... [0, 1, 1, 1, 1] ... ] >>> largest_square_submatrix_area(5, 5, matrix) == 4 >>> matrix = [[1]] >>> largest_square_submatrix_area(1, 1, matrix) == 1 >>> matrix = [[0]] >>> largest_square_submatrix_area(1, 1, matrix) == 0 >>> matrix = [ ... [1, 0, 1, 1, 0], ... [0, 1, 1, 1, 1] ... ] >>> largest_square_submatrix_area(2, 5, matrix) == 4","solution":"def maximalSquare(matrix): Given a binary matrix, finds the area of the largest square sub-matrix consisting entirely of 1's. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side def largest_square_submatrix_area(n, m, matrix): return maximalSquare(matrix)"},{"question":"from typing import List def most_frequent_element(n: int, elements: List[int]) -> int: Returns the integer that appears the most frequently in the list. If there are ties, returns the largest number among them. >>> most_frequent_element(7, [1, 3, 1, 4, 5, 3, 3]) 3 >>> most_frequent_element(1, [10]) 10 >>> most_frequent_element(5, [1, 2, 3, 4, 5]) 5 >>> most_frequent_element(3, [7, 7, 7]) 7 >>> most_frequent_element(6, [-1, -2, -1, -2, -1, -2]) -1 >>> most_frequent_element(6, [1, 2, 2, 3, 3, 1]) 3","solution":"def most_frequent_element(n, elements): Returns the integer that appears the most frequently in the list. If there are ties, returns the largest number among them. from collections import Counter counter = Counter(elements) most_common = counter.most_common() max_frequency = most_common[0][1] candidates = [key for key, value in most_common if value == max_frequency] return max(candidates)"},{"question":"def water_distribution(n: int, q: int, edges: List[Tuple[int, int, int]], operations: List[Tuple[int, int, int]]) -> List[int]: A city wants to optimize its water distribution system. The city is represented by a tree with n nodes (1 through n), where each node represents a water junction and each edge represents a pipeline between two junctions. Each edge has a certain capacity ci (the maximum amount of water it can carry). There is a unique path from any junction to any other junction, and water can only flow along the edges of the tree. The city plans to handle q operations, where each operation is one of two types: 1. Update the capacity of a specific pipeline. 2. Query the maximum amount of water that can be transported between two specific junctions. You need to process q operations efficiently. Args: n (int): The number of junctions. q (int): The number of operations. edges (List[Tuple[int, int, int]]): The list of pipelines with format (u, v, c). operations (List[Tuple[int, int, int]]): The list of operations to be performed. Returns: List[int]: The results of the maximum water that can be transported for each query operation. Example: >>> water_distribution(6, 4, [(1, 2, 4), (1, 3, 3), (2, 4, 5), (2, 5, 1), (3, 6, 2)], [(2, 4, 6), (1, 5, 6), (2, 4, 6), (2, 1, 6)]) [5, 5, 3]","solution":"from collections import defaultdict import sys sys.setrecursionlimit(200000) class TreeWaterDistribution: def __init__(self, n): self.n = n self.adj = defaultdict(list) self.depth = [0] * (n + 1) self.parent = [[-1] * 20 for _ in range(n + 1)] self.max_edge = [[0] * 20 for _ in range(n + 1)] self.edge_index = {} def add_edge(self, u, v, c, index): self.adj[u].append((v, c)) self.adj[v].append((u, c)) self.edge_index[(min(u, v), max(u, v))] = index def preprocess(self): self._dfs(1, -1, 0, 0) for j in range(1, 20): for i in range(1, self.n + 1): if self.parent[i][j - 1] != -1: self.parent[i][j] = self.parent[i][j - 1] self.parent[i][j] = self.parent[self.parent[i][j - 1]][j - 1] self.max_edge[i][j] = max(self.max_edge[i][j - 1], self.max_edge[self.parent[i][j - 1]][j - 1]) def _dfs(self, node, par, dep, max_val): self.parent[node][0] = par self.depth[node] = dep self.max_edge[node][0] = max_val for neighbor, cost in self.adj[node]: if neighbor != par: self._dfs(neighbor, node, dep + 1, cost) def find_lca(self, u, v): if self.depth[u] < self.depth[v]: u, v = v, u diff = self.depth[u] - self.depth[v] max_cap = 0 for i in range(20): if (diff >> i) & 1: max_cap = max(max_cap, self.max_edge[u][i]) u = self.parent[u][i] if u == v: return max_cap for i in range(19, -1, -1): if self.parent[u][i] != self.parent[v][i]: max_cap = max(max_cap, self.max_edge[u][i]) max_cap = max(max_cap, self.max_edge[v][i]) u, v = self.parent[u][i], self.parent[v][i] return max(max_cap, self.max_edge[u][0], self.max_edge[v][0]) def update_edge(self, index, new_cap): for key, value in self.edge_index.items(): if value == index: u, v = key break self._find_update(u, v, new_cap) def _find_update(self, u, v, new_cap): if self.parent[u][0] == v: u, v = v, u if self.parent[u][0] == v: for i, (neighbor, _) in enumerate(self.adj[v]): if neighbor == u: self.adj[v][i] = (neighbor, new_cap) break # Read Input Data def water_distribution(n, q, edges, operations): solution = TreeWaterDistribution(n) for index, (u, v, c) in enumerate(edges): solution.add_edge(u, v, c, index) solution.preprocess() results = [] for operation in operations: if operation[0] == 1: _, index, new_cap = operation solution.update_edge(index - 1, new_cap) elif operation[0] == 2: _, x, y = operation results.append(solution.find_lca(x, y)) return results"},{"question":"def max_subset_sum(N: int, A: List[int], S: int) -> int: Returns the maximum possible sum of a subset of the array A that does not exceed S. :param N: Integer representing the number of cards. :param A: List of integers representing the values of the cards. :param S: Integer representing the sum limit. :return: Maximum possible sum of a subset of A that does not exceed S. >>> max_subset_sum(5, [3, 34, 4, 12, 5], 9) 9 >>> max_subset_sum(3, [1, 2, 3], 5) 5 >>> max_subset_sum(4, [2, 3, 7, 8], 10) 10 >>> max_subset_sum(3, [3, 6, 9], 20) 18 >>> max_subset_sum(3, [10, 20, 30], 5) 0 >>> max_subset_sum(1, [5], 5) 5 >>> max_subset_sum(1, [10], 5) 0 >>> max_subset_sum(4, [1, 2, 3, 4], 10) 10","solution":"def max_subset_sum(N, A, S): Returns the maximum possible sum of a subset of the array A that does not exceed S. :param N: Integer representing the number of cards. :param A: List of integers representing the values of the cards. :param S: Integer representing the sum limit. :return: Maximum possible sum of a subset of A that does not exceed S. # Initialize a list to keep track of possible sums dp = [0] * (S + 1) for num in A: for j in range(S, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) return dp[S]"},{"question":"def lexicographically_smallest_rotation(s: str) -> str: Returns the lexicographically smallest rotation of the input string s. >>> lexicographically_smallest_rotation(\\"bca\\") 'abc' >>> lexicographically_smallest_rotation(\\"a\\") 'a' >>> lexicographically_smallest_rotation(\\"aaaa\\") 'aaaa' >>> lexicographically_smallest_rotation(\\"dacb\\") 'acbd' >>> lexicographically_smallest_rotation(\\"geeksforgeeks\\") 'eeksforgeeksg'","solution":"def lexicographically_smallest_rotation(s): Returns the lexicographically smallest rotation of the input string s. n = len(s) # Create a list of all rotations rotations = [s[i:] + s[:i] for i in range(n)] # Return the lexicographically smallest rotation return min(rotations)"},{"question":"def count_islands(grid, n, m): Calculate the number of islands in the given grid grid of size n x m. >>> count_islands([ ... \\"11000\\", ... \\"11000\\", ... \\"00100\\", ... \\"00011\\" ...], 4, 5) 3 >>> count_islands([ ... \\"111\\", ... \\"010\\", ... \\"111\\" ...], 3, 3) 1 >>> count_islands([\\"1\\"], 1, 1) 1 >>> count_islands([\\"0\\"], 1, 1) 0 >>> count_islands([ ... \\"0000\\", ... \\"0000\\", ... \\"0000\\", ... \\"0000\\" ...], 4, 4) 0 >>> count_islands([ ... \\"111\\", ... \\"111\\", ... \\"111\\" ...], 3, 3) 1","solution":"def count_islands(grid, n, m): def dfs(row, col): # Base cases for stopping recursion if row < 0 or row >= n or col < 0 or col >= m or grid[row][col] == '0': return # Mark the cell as visited by setting it to '0' grid[row][col] = '0' # Call dfs in all 4 directions dfs(row + 1, col) dfs(row - 1, col) dfs(row, col + 1) dfs(row, col - 1) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': # Start a DFS if we find an unvisited land cell island_count += 1 dfs(i, j) return island_count"},{"question":"def min_operations_to_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to sort the list in non-decreasing order. Args: t: int, the number of test cases. test_cases: List of tuples, each containing: - n: int, the number of elements in the list. - a: List[int], the elements of the list. Returns: List[int]: the minimum number of operations required for each test case. >>> min_operations_to_sort(1, [(3, [-1, -2, 1])]) [1] >>> min_operations_to_sort(1, [(4, [1, 2, 3, 4])]) [0] >>> min_operations_to_sort(1, [(5, [-5, -4, -3, -2, -1])]) [0] >>> min_operations_to_sort(2, [(3, [-1, -3, 2]), (5, [4, -2, -1, 3, 1])]) [1, 1] >>> min_operations_to_sort(1, [(1, [5])]) [0]","solution":"def min_operations_to_sort(t, test_cases): results = [] for case in test_cases: n, a = case if n == 1: results.append(0) continue positive_count = sum(1 for x in a if x > 0) negative_count = sum(1 for x in a if x < 0) if positive_count == 0 or negative_count == 0: results.append(0) else: results.append(1) return results"},{"question":"def min_teams(n: int, k: int, levels: List[int]) -> int: Calculate the minimum number of teams such that the level difference between the highest and lowest level in any team does not exceed k. Parameters: n (int): number of players. k (int): maximum allowed level difference within a team. levels (List[int]): levels of the players. Returns: int: The minimum number of teams needed. >>> min_teams(7, 2, [1, 2, 3, 4, 5, 6, 7]) 3 >>> min_teams(1, 5, [10]) 1 >>> min_teams(4, 0, [1, 2, 3, 4]) 4 >>> min_teams(5, 10, [1, 2, 3, 4, 5]) 1 >>> min_teams(5, 1, [4, 5, 6, 7, 8]) 3 >>> min_teams(100000, 1000, list(range(1, 100001))) 100 >>> min_teams(6, 3, [10, 9, 8, 7, 6, 5]) 2","solution":"def min_teams(n, k, levels): Calculate the minimum number of teams such that the level difference between the highest and lowest level in any team does not exceed k. Parameters: n (int): number of players. k (int): maximum allowed level difference within a team. levels (list of int): levels of the players. Returns: int: The minimum number of teams needed. levels.sort() teams = 0 i = 0 while i < n: j = i while j < n and levels[j] - levels[i] <= k: j += 1 teams += 1 i = j return teams"},{"question":"def uniquePaths(m: int, n: int) -> int: Returns the number of unique paths from the top-left to the bottom-right in an m x n grid. >>> uniquePaths(3, 2) 3 >>> uniquePaths(1, 1) 1 >>> uniquePaths(5, 5) 70 >>> uniquePaths(3, 3) 6 >>> uniquePaths(10, 10) 48620 >>> uniquePaths(100, 1) 1 >>> uniquePaths(1, 100) 1 >>> uniquePaths(100, 100) 22750883079422934966181954039568885395604168260154104734000","solution":"def uniquePaths(m: int, n: int) -> int: Returns the number of unique paths from the top-left to the bottom-right in an m x n grid. # Create a 2D list to store the number of ways to reach each cell dp = [[1]*n for _ in range(m)] # Iterate through the grid starting from the top left corner for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle (containing only 1's) and return its area. >>> maximalRectangle([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) == 6 >>> maximalRectangle([[0, 1], [1, 0]]) == 1 >>> maximalRectangle([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 9 >>> maximalRectangle([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> maximalRectangle([[1, 0, 1, 1, 1], [0, 1, 0, 1, 0], [1, 1, 0, 1, 1], [1, 0, 0, 1, 1]]) == 4 pass def largestRectangleArea(heights: List[int]) -> int: Helper function that calculates the largest rectangle area in a histogram given its heights. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> largestRectangleArea([2, 4]) == 4 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) == 12 >>> largestRectangleArea([2, 3, 5, 6, 1, 2, 6]) == 10 >>> largestRectangleArea([0, 0, 0]) == 0 pass","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 dp = [0] * len(matrix[0]) for row in matrix: for i in range(len(row)): dp[i] = dp[i] + 1 if row[i] == 1 else 0 max_area = max(max_area, largestRectangleArea(dp)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) heights.pop() return max_area def read_input(): import sys input = sys.stdin.read data = input().split() m = int(data[0]) n = int(data[1]) flat_matrix = list(map(int, data[2:])) matrix = [] for i in range(m): matrix.append(flat_matrix[i*n:(i+1)*n]) return matrix if __name__ == \\"__main__\\": matrix = read_input() print(maximalRectangle(matrix))"},{"question":"def num_distinct_subsequences(s: str, t: str) -> int: Determines if \`t\` is a subsequence of \`s\` and counts the number of distinct ways this subsequence can be formed. Args: s (str): A sequence of lowercase English letters. t (str): A string composed of distinct lowercase English letters. Returns: int: The number of distinct ways the subsequence \`t\` can be formed from \`s\`. Examples: >>> num_distinct_subsequences(\\"babgbag\\", \\"bag\\") 5 >>> num_distinct_subsequences(\\"rabbbit\\", \\"rabbit\\") 3 pass","solution":"def num_distinct_subsequences(s, t): Returns the number of distinct ways the subsequence t can be formed from the sequence s. # Create a 2D dp array with dimensions (len(t) + 1) x (len(s) + 1) dp = [[0] * (len(s) + 1) for _ in range(len(t) + 1)] # If t is an empty string, there is one way to match it with any s (remove all characters from s) for j in range(len(s) + 1): dp[0][j] = 1 for i in range(1, len(t) + 1): for j in range(1, len(s) + 1): if t[i - 1] == s[j - 1]: # Count both including and excluding the current character of s dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1] else: # Exclude the current character of s dp[i][j] = dp[i][j - 1] return dp[len(t)][len(s)]"},{"question":"def smallest_missing_non_negative_integer(n: int, arr: List[int]) -> int: Finds the smallest non-negative integer that's not present in the array. >>> smallest_missing_non_negative_integer(5, [0, 2, 3, 1, 7]) 4 >>> smallest_missing_non_negative_integer(10, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 10","solution":"def smallest_missing_non_negative_integer(n, arr): Finds the smallest non-negative integer that's not present in the array. # Create a set of unique elements from the array elements = set(arr) # Start checking from 0 upwards i = 0 while True: if i not in elements: return i i += 1"},{"question":"def can_transform_cycles_to_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine if it is possible to transform all cycles to be exactly of length \`k\`. >>> can_transform_cycles_to_k(3, [(5, 3, [1, 0, 3, 4, 2]), (4, 2, [1, 0, 3, 2]), (6, 3, [1, 2, 0, 4, 5, 3])]) == [\\"NO\\", \\"YES\\", \\"YES\\"] >>> can_transform_cycles_to_k(1, [(4, 4, [1, 2, 3, 0])]) == [\\"YES\\"] >>> can_transform_cycles_to_k(1, [(5, 2, [1, 0, 3, 4, 2])]) == [\\"NO\\"] >>> can_transform_cycles_to_k(2, [(6, 2, [1, 0, 3, 2, 5, 4]), (6, 3, [1, 2, 0, 4, 5, 3])]) == [\\"YES\\", \\"YES\\"] >>> can_transform_cycles_to_k(1, [(1, 1, [0])]) == [\\"YES\\"]","solution":"def can_transform_cycles_to_k(t, test_cases): results = [] for n, k, connections in test_cases: visited = [False] * n cycle_lengths = [] # Find all cycle lengths for i in range(n): if not visited[i]: current = i length = 0 while not visited[current]: visited[current] = True current = connections[current] length += 1 cycle_lengths.append(length) # Check if all cycles can be made of length k all_possible = all(length == k for length in cycle_lengths) if all_possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_flowers(n: int, m: int) -> int: Returns the maximum number of flowers Han can plant in the garden such that each row contains the same number of flowers and no two flowers are in the same vertical column. >>> max_flowers(5, 5) 5 >>> max_flowers(7, 3) 3 >>> max_flowers(4, 6) 4 from solution import max_flowers def test_max_flowers_example1(): assert max_flowers(5, 5) == 5 def test_max_flowers_example2(): assert max_flowers(7, 3) == 3 def test_max_flowers_example3(): assert max_flowers(4, 6) == 4 def test_max_flowers_row_greater(): assert max_flowers(10, 3) == 3 def test_max_flowers_column_greater(): assert max_flowers(3, 10) == 3 def test_max_flowers_single_row(): assert max_flowers(1, 10) == 1 def test_max_flowers_single_column(): assert max_flowers(10, 1) == 1 def test_max_flowers_min_values(): assert max_flowers(1, 1) == 1 def test_max_flowers_max_values(): assert max_flowers(1000, 1000) == 1000","solution":"def max_flowers(n, m): Returns the maximum number of flowers Han can plant in the garden such that each row contains the same number of flowers and no two flowers are in the same vertical column. return min(n, m)"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring of the input string s. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" or \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"\\") \\"\\" >>> longest_palindromic_substring(\\"aaaa\\") \\"aaaa\\" >>> longest_palindromic_substring(\\"abcd\\") \\"a\\" or \\"b\\" or \\"c\\" or \\"d\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring of the input string s. if not s: return \\"\\" n = len(s) start, max_len = 0, 1 def expand_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): l1, r1 = expand_center(i, i) # Odd length palindrome l2, r2 = expand_center(i, i + 1) # Even length palindrome if r1 - l1 + 1 > max_len: start, max_len = l1, r1 - l1 + 1 if r2 - l2 + 1 > max_len: start, max_len = l2, r2 - l2 + 1 return s[start:start + max_len]"},{"question":"def can_rearrange(n: int, a: List[int]) -> str: Determines if the list a can be rearranged so that the absolute difference between consecutive elements is at most 1. :param n: Number of elements in the array :param a: List of integers :return: 'YES' if the rearrangement is possible, otherwise 'NO' >>> can_rearrange(4, [1, 2, 3, 4]) \\"YES\\" >>> can_rearrange(5, [1, 3, 5, 2, 8]) \\"NO\\" >>> can_rearrange(1, [10]) \\"YES\\"","solution":"def can_rearrange(n, a): Determines if the list a can be rearranged so that the absolute difference between consecutive elements is at most 1. :param n: Number of elements in the array :param a: List of integers :return: 'YES' if the rearrangement is possible, otherwise 'NO' if n == 1: return \\"YES\\" a.sort() for i in range(n-1): if abs(a[i] - a[i+1]) > 1: return \\"NO\\" return \\"YES\\""},{"question":"def knapsack(n: int, c: int, powers: List[int]) -> int: Determine the maximum possible total magical power that can be carried without exceeding the bag's capacity. >>> knapsack(5, 10, [1, 3, 4, 5, 6]) 10 >>> knapsack(4, 20, [5, 10, 15, 20]) 20","solution":"def knapsack(n, c, powers): dp = [0] * (c + 1) for power in powers: for j in range(c, power - 1, -1): dp[j] = max(dp[j], dp[j - power] + power) return dp[c] # Example usage: # n, c = 5, 10 # powers = [1, 3, 4, 5, 6] # print(knapsack(n, c, powers)) # Output: 10"},{"question":"def construct_grid(N: int) -> list: Constructs an NxN grid following the described pattern: - Sum of each row is equal to the sum of each column and both main diagonals. - Number difference between odd-indexed and even-indexed cells is minimal. Parameters: N (int): The size of the grid Returns: list of lists: NxN grid with integer values >>> construct_grid(1) [[1]] >>> construct_grid(2) [[1, 1], [1, 1]] >>> construct_grid(3) [[1, 1, 1], [1, 1, 1], [1, 1, 1]] >>> construct_grid(4) [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] >>> construct_grid(5) [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]","solution":"def construct_grid(N): Constructs an NxN grid following the described pattern: - Sum of each row is equal to the sum of each column and both main diagonals. - Number difference between odd-indexed and even-indexed cells is minimal. Parameters: N (int): The size of the grid Returns: list of lists: NxN grid with integer values # Initialize the grid with all ones grid = [[1 for _ in range(N)] for _ in range(N)] return grid"},{"question":"def min_swaps_to_group_fragile(packages): Returns the minimum number of swaps required so that all fragile items appear before all non-fragile ones on the conveyor belt. >>> min_swaps_to_group_fragile([(8, 'F'), (3, 'N'), (4, 'F'), (2, 'N'), (1, 'F')]) == 2 >>> min_swaps_to_group_fragile([(4, 'F'), (5, 'F'), (6, 'F'), (1, 'F')]) == 0 >>> min_swaps_to_group_fragile([(2, 'N'), (1, 'N'), (3, 'N')]) == 0","solution":"def min_swaps_to_group_fragile(packages): Returns the minimum number of swaps required so that all fragile items appear before all non-fragile ones on the conveyor belt. n = len(packages) fragiles = [pkg for pkg in packages if pkg[1] == 'F'] non_fragiles = [pkg for pkg in packages if pkg[1] == 'N'] # Total fragile and non-fragile count total_fragile = len(fragiles) total_non_fragile = len(non_fragiles) # If there are no fragile items or no non-fragile items, # they are already segregated. if total_fragile == 0 or total_non_fragile == 0: return 0 swaps = 0 i, j = 0, 0 while i < total_fragile and j < total_non_fragile: # Find the first non-fragile in the first half (fragiles' zone) while i < n and packages[i][1] == 'F': i += 1 # Find the first fragile in the second half (non-fragiles' zone) while j < n and packages[n-1-j][1] == 'N': j += 1 # Swap positions if i < n and (n-1-j) >= 0: packages[i], packages[n-1-j] = packages[n-1-j], packages[i] swaps += 1 i += 1 j += 1 return swaps"},{"question":"def is_uniform_path(grid: List[str]) -> str: Determine if there exists a path from the top-left corner to the bottom-right corner in a grid such that all cells in the path contain the same letter. You can only move right or down from a cell. >>> is_uniform_path([ \\"aaaa\\", \\"abaa\\", \\"aaaa\\" ]) \\"YES\\" >>> is_uniform_path([ \\"ab\\", \\"bb\\" ]) \\"NO\\" >>> is_uniform_path([ \\"a\\" ]) \\"YES\\"","solution":"def is_uniform_path(grid): n = len(grid) m = len(grid[0]) target_char = grid[0][0] # DP table for marking reachable cells with the same character dp = [[False] * m for _ in range(n)] dp[0][0] = True for i in range(n): for j in range(m): if dp[i][j] and grid[i][j] == target_char: # Move right if j + 1 < m and grid[i][j + 1] == target_char: dp[i][j + 1] = True # Move down if i + 1 < n and grid[i + 1][j] == target_char: dp[i + 1][j] = True return \\"YES\\" if dp[-1][-1] else \\"NO\\" def uniform_path(grid): return is_uniform_path(grid)"},{"question":"def email_pairings(t: int, test_cases: List[int]) -> List[str]: Determine the optimal pairings for users to send emails amongst themselves such that no user sends an email to themselves, and every user sends and receives exactly one email. >>> email_pairings(3, [2, 4, 3]) == [\\"1 2n2 1\\", \\"1 2n2 1n3 4n4 3\\", \\"impossible\\"] >>> email_pairings(1, [3]) == [\\"impossible\\"]","solution":"def email_pairings(t, test_cases): results = [] for n in test_cases: if n % 2 == 1: results.append(\\"impossible\\") else: pairs = [] for i in range(1, n + 1, 2): pairs.append(f\\"{i} {i+1}\\") pairs.append(f\\"{i+1} {i}\\") results.append(\\"n\\".join(pairs)) return results"},{"question":"from typing import List, Tuple, Dict def update_inventory(k: int, actions: List[Tuple[str, str]]) -> Dict[str, int]: Update the inventory based on the given actions. Parameters: k (int): The maximum number of unique items the inventory can hold. actions (List[Tuple[str, str]]): A list of tuples where each tuple contains an action (\\"ADD\\") and an item name. Returns: Dict[str, int]: The current state of the inventory. Examples: >>> k = 3 >>> actions = [(\\"ADD\\", \\"Sword\\"), (\\"ADD\\", \\"Shield\\"), (\\"ADD\\", \\"Potion\\"), (\\"ADD\\", \\"Shield\\"), (\\"ADD\\", \\"Axe\\")] >>> update_inventory(k, actions) {\\"Sword\\": 1, \\"Shield\\": 2, \\"Potion\\": 1} >>> k = 2 >>> actions = [(\\"ADD\\", \\"Sword\\"), (\\"ADD\\", \\"Sword\\"), (\\"ADD\\", \\"Shield\\"), (\\"ADD\\", \\"Sword\\"), (\\"ADD\\", \\"Shield\\")] >>> update_inventory(k, actions) {\\"Sword\\": 3, \\"Shield\\": 2} >>> k = 2 >>> actions = [(\\"ADD\\", \\"Sword\\"), (\\"ADD\\", \\"Shield\\"), (\\"ADD\\", \\"Potion\\"), (\\"ADD\\", \\"Axe\\")] >>> update_inventory(k, actions) {\\"Sword\\": 1, \\"Shield\\": 1} >>> k = 5 >>> actions = [] >>> update_inventory(k, actions) {} >>> k = 1 >>> actions = [(\\"ADD\\", \\"Potion\\")] >>> update_inventory(k, actions) {\\"Potion\\": 1} >>> k = 1 >>> actions = [(\\"ADD\\", \\"Axe\\"), (\\"ADD\\", \\"Axe\\"), (\\"ADD\\", \\"Axe\\")] >>> update_inventory(k, actions) {\\"Axe\\": 3} >>> k = 4 >>> actions = [(\\"ADD\\", \\"Sword\\"), (\\"ADD\\", \\"Shield\\"), (\\"ADD\\", \\"Potion\\"), (\\"ADD\\", \\"Axe\\"), (\\"ADD\\", \\"Axe\\")] >>> update_inventory(k, actions) {\\"Sword\\": 1, \\"Shield\\": 1, \\"Potion\\": 1, \\"Axe\\": 2}","solution":"from typing import List, Tuple, Dict def update_inventory(k: int, actions: List[Tuple[str, str]]) -> Dict[str, int]: Update the inventory based on the given actions. Parameters: k (int): The maximum number of unique items the inventory can hold. actions (List[Tuple[str, str]]): A list of tuples where each tuple contains an action (\\"ADD\\") and an item name. Returns: Dict[str, int]: The current state of the inventory. inventory = {} for action, item in actions: if action == \\"ADD\\": if item in inventory: inventory[item] += 1 elif len(inventory) < k: inventory[item] = 1 return inventory"},{"question":"def min_operations_to_equal_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the minimum number of operations required to make all elements of the array equal. Parameters: t (int): The number of test cases. test_cases (list): A list of tuples where each tuple contains the number of elements (n) and the array of integers (a). Returns: list: A list of integers where each integer represents the minimum number of operations for each test case. >>> min_operations_to_equal_elements(3, [(4, [1, 2, 3, 4]), (3, [4, 4, 4]), (2, [5, 10])]) [3, 0, 1] >>> min_operations_to_equal_elements(2, [(1, [1]), (1, [100])]) [0, 0]","solution":"def min_operations_to_equal_elements(t, test_cases): Returns the minimum number of operations required to make all elements of the array equal. Parameters: t (int): The number of test cases. test_cases (list): A list of tuples where each tuple contains the number of elements (n) and the array of integers (a). Returns: list: A list of integers where each integer represents the minimum number of operations for each test case. results = [] for test_case in test_cases: n, a = test_case if len(set(a)) == 1: results.append(0) else: results.append(n - 1) return results"},{"question":"def min_removals(n: int, k: int) -> int: Determines the number of participants to remove to allow even division into k groups. Parameters: n (int): The number of participants. k (int): The number of groups. Returns: int: The minimal number of participants to remove. >>> min_removals(8, 3) 2 >>> min_removals(8, 4) 0 >>> min_removals(10, 3) 1 # Test cases def test_even_division(): assert min_removals(8, 4) == 0 assert min_removals(9, 3) == 0 def test_no_removals_needed(): assert min_removals(10, 2) == 0 assert min_removals(15, 5) == 0 def test_removal_needed(): assert min_removals(8, 3) == 2 assert min_removals(10, 3) == 1 def test_edge_cases(): assert min_removals(1, 1) == 0 assert min_removals(10**5, 1) == 0 assert min_removals(10**5, 10**5) == 0 def test_large_numbers(): assert min_removals(100003, 100) == 3 assert min_removals(99999, 100) == 99","solution":"def min_removals(n, k): Determines the number of participants to remove to allow even division into k groups. Parameters: n (int): The number of participants. k (int): The number of groups. Returns: int: The minimal number of participants to remove. # If we already can evenly divide participants into groups, no removal is needed if n % k == 0: return 0 else: # The minimum number to remove is the remainder of n divided by k return n % k"},{"question":"def max_subrectangle_sum(grid, queries): Calculate the maximum sum of a subrectangle within the specified subgrids. Args: grid (List[List[int]]): A 2D grid containing integers. queries (List[Tuple[int, int, int, int]]): A list of queries, each being a tuple containing four integers (x1, y1, x2, y2) representing the top-left and bottom-right corners of a subgrid. Returns: List[int]: A list of integers representing the maximum sum of a subrectangle within the specified subgrid for each query. Example: >>> grid = [ ... [1, 2, 3], ... [-1, -2, -3], ... [4, 5, 6] ... ] >>> queries = [ ... (1, 1, 3, 3), ... (2, 2, 3, 3) ... ] >>> max_subrectangle_sum(grid, queries) [15, 11] def test_max_subrectangle_sum(): grid = [ [1, 2, 3], [-1, -2, -3], [4, 5, 6] ] queries = [ (1, 1, 3, 3), (2, 2, 3, 3) ] assert max_subrectangle_sum(grid, queries) == [15, 11] def test_single_row(): grid = [ [1, 2, 3] ] queries = [ (1, 1, 1, 3), (1, 1, 1, 2) ] assert max_subrectangle_sum(grid, queries) == [6, 3] def test_single_column(): grid = [ [1], [2], [3] ] queries = [ (1, 1, 3, 1), (2, 1, 3, 1) ] assert max_subrectangle_sum(grid, queries) == [6, 5] def test_mixed_values(): grid = [ [-1, -2], [-3, 4] ] queries = [ (1, 2, 2, 2), (1, 1, 2, 2) ] assert max_subrectangle_sum(grid, queries) == [4, 4] def test_large_values(): grid = [ [100000, -100000], [-100000, 100000] ] queries = [ (1, 1, 2, 2) ] assert max_subrectangle_sum(grid, queries) == [100000]","solution":"def max_subrectangle_sum(grid, queries): n = len(grid) m = len(grid[0]) # Using dynamic programming to precompute the maximum subarray sum for each subgrid def max_sum_subarray(array): max_sum = float('-inf') current_sum = 0 for num in array: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def max_sum_subgrid(top, left, bottom, right): max_sum = float('-inf') for col_start in range(left, right + 1): row_sums = [0] * n for col_end in range(col_start, right + 1): for row in range(n): row_sums[row] += grid[row][col_end] current_max = max_sum_subarray(row_sums[top:bottom + 1]) max_sum = max(max_sum, current_max) return max_sum results = [] for x1, y1, x2, y2 in queries: # Convert 1-based index to 0-based index top, left, bottom, right = x1 - 1, y1 - 1, x2 - 1, y2 - 1 results.append(max_sum_subgrid(top, left, bottom, right)) return results"},{"question":"def largest_square_submatrix_area(matrix: List[List[int]]) -> int: Calculate the area of the largest square sub-matrix filled with 1s. >>> largest_square_submatrix_area([[1, 0, 1, 0], [1, 1, 1, 1], [1, 1, 1, 0], [0, 1, 1, 1]]) == 4 >>> largest_square_submatrix_area([[1, 1, 1, 0, 0], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 0]]) == 9 pass","solution":"def largest_square_submatrix_area(matrix): n = len(matrix) if n == 0: return 0 max_side = 0 dp = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): if i == 0 or j == 0: dp[i][j] = matrix[i][j] elif matrix[i][j] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 0 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def count_happy_chains(n: int) -> int: Returns the number of distinct Happy Chains of length n. >>> count_happy_chains(1) 26 >>> count_happy_chains(2) 650 >>> count_happy_chains(3) 16250 >>> count_happy_chains(0) 0 >>> count_happy_chains(4) 406250 >>> count_happy_chains(100) 26 * (25 ** 99)","solution":"def count_happy_chains(n): Returns the number of distinct Happy Chains of length n. if n <= 0: return 0 total_chains = 26 for i in range(1, n): total_chains *= 25 return total_chains"},{"question":"def shortest_substring_with_all_chars(s: str) -> int: Find the length of the shortest substring that contains at least one occurrence of each different character in the string \`s\`. >>> shortest_substring_with_all_chars(\\"abac\\") 3 >>> shortest_substring_with_all_chars(\\"aabcbcdbca\\") 4 pass","solution":"def shortest_substring_with_all_chars(s: str) -> int: from collections import defaultdict if not s: return 0 unique_chars = set(s) required_char_count = len(unique_chars) left = 0 min_length = float('inf') char_count = defaultdict(int) formed = 0 for right in range(len(s)): char = s[right] char_count[char] += 1 if char_count[char] == 1: formed += 1 while left <= right and formed == required_char_count: current_length = right - left + 1 min_length = min(min_length, current_length) removal_char = s[left] char_count[removal_char] -= 1 if char_count[removal_char] == 0: formed -= 1 left += 1 return min_length"},{"question":"def bubble_sort(arr: List[int]) -> List[int]: Sorts the input list of integers in non-decreasing order using the bubble sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list of integers in non-decreasing order. >>> bubble_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> bubble_sort([5, 1, 4, 2, 8]) [1, 2, 4, 5, 8] >>> bubble_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> bubble_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> bubble_sort([-1, 2, -3, 4, -5]) [-5, -3, -1, 2, 4] >>> bubble_sort([1]) [1] >>> bubble_sort([]) [] >>> bubble_sort([1000000000, -1000000000, 0]) [-1000000000, 0, 1000000000]","solution":"def bubble_sort(arr): Sorts the input list of integers in non-decreasing order using the bubble sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list of integers in non-decreasing order. n = len(arr) # Traverse through all elements in the list for i in range(n): # Last i elements are already sorted for j in range(0, n-i-1): # Traverse the list from 0 to n-i-1 # Swap if the element found is greater than the next element if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"def maxProfit(prices: List[int]) -> int: Determine the maximum profit from buying and selling a house on a street. You can only sell a house if you have bought one before it. Args: prices (List[int]): An array where prices[i] is the price of a house on day i. Returns: int: The maximum profit you can achieve. If no profit can be made, return 0. Examples: >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([3, 2, 6, 5, 0, 3]) 4","solution":"def maxProfit(prices): if not prices or len(prices) <= 1: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def max_teams(t: int, student_data: List[Tuple[int, int, int]]) -> List[int]: Compute the maximum number of teams that can be formed given the number of students from each specialty. t (int): The number of test cases. student_data (List[Tuple[int, int, int]]): A list of tuples, where each tuple contains three integers representing the number of students from mechanical, electrical, and computer science specialties respectively. Returns: List[int]: A list of integers where each integer represents the maximum number of teams that can be formed for the corresponding test case. >>> max_teams(3, [(3, 3, 3), (5, 1, 2), (2, 2, 4)]) [3, 1, 2] >>> max_teams(1, [(1, 1, 1)]) [1] >>> max_teams(1, [(1000, 1000, 1000)]) [1000]","solution":"def max_teams(t, student_data): results = [] for i in range(t): m, e, c = student_data[i] results.append(min(m, e, c)) return results"},{"question":"from typing import List, Tuple from functools import reduce from math import gcd def process_queries(n: int, arr: List[int], q: int, queries: List[Tuple[str, int, int]]) -> List[int]: Given an array of integers and a list of queries, return the results for each query. Args: n (int): The number of elements in the array. arr (List[int]): The array of integers. q (int): The number of queries. queries (List[Tuple[str, int, int]]): A list of queries. Returns: List[int]: The results of the queries. >>> process_queries(5, [3, 6, 2, 4, 8], 4, [('S', 1, 3), ('G', 2, 5), ('S', 3, 5), ('G', 1, 1)]) [11, 2, 14, 3] >>> process_queries(5, [1, 2, 3, 4, 5], 3, [('S', 1, 2), ('S', 3, 5), ('S', 1, 5)]) [3, 12, 15] >>> process_queries(5, [12, 15, 10, 30, 45], 3, [('G', 1, 2), ('G', 2, 4), ('G', 1, 5)]) [3, 5, 1] >>> process_queries(5, [7, 14, 21, 28, 35], 4, [('S', 1, 1), ('G', 2, 2), ('S', 3, 3), ('G', 4, 4)]) [7, 14, 21, 28]","solution":"from math import gcd from functools import reduce def process_queries(n, arr, q, queries): def subarray_sum(l, r): return sum(arr[l-1:r]) def subarray_gcd(l, r): return reduce(gcd, arr[l-1:r]) results = [] for query in queries: op, l, r = query if op == 'S': results.append(subarray_sum(l, r)) elif op == 'G': results.append(subarray_gcd(l, r)) return results"},{"question":"def count_shadowed_buildings(buildings): Given a list of building heights, return the number of buildings that are in the shadow of other buildings. >>> count_shadowed_buildings([5, 5, 5, 5, 5]) == 4 >>> count_shadowed_buildings([5, 4, 3, 2, 1]) == 4 >>> count_shadowed_buildings([1, 2, 3, 4, 5]) == 0 >>> count_shadowed_buildings([6, 2, 4, 1, 5]) == 4 >>> count_shadowed_buildings([10]) == 0 >>> count_shadowed_buildings([5, 5]) == 1 >>> count_shadowed_buildings([5, 3]) == 1 >>> count_shadowed_buildings([3, 5]) == 0 >>> count_shadowed_buildings([3, 5, 3, 5, 3]) == 3","solution":"def count_shadowed_buildings(buildings): Given a list of building heights, return the number of buildings that are in the shadow of other buildings. n = len(buildings) shadowed_count = 0 max_height = 0 for height in buildings: if height <= max_height: shadowed_count += 1 else: max_height = height return shadowed_count"},{"question":"def countVisibleBuildings(heights): Returns the number of visible buildings when viewed from the left. Parameters: heights (list of ints): List of building heights Returns: int: Number of visible buildings pass # Unit tests def test_countVisibleBuildings_example(): assert countVisibleBuildings([3, 7, 8, 3, 6, 1]) == 3 def test_countVisibleBuildings_all_equal(): assert countVisibleBuildings([5, 5, 5, 5, 5]) == 1 def test_countVisibleBuildings_descending(): assert countVisibleBuildings([10, 9, 8, 7, 6]) == 1 def test_countVisibleBuildings_ascending(): assert countVisibleBuildings([1, 2, 3, 4, 5]) == 5 def test_countVisibleBuildings_mixed(): assert countVisibleBuildings([3, 1, 4, 1, 5, 9, 2]) == 4 def test_countVisibleBuildings_single_building(): assert countVisibleBuildings([10]) == 1 def test_countVisibleBuildings_empty(): assert countVisibleBuildings([]) == 0 def test_countVisibleBuildings_large_input(): heights = list(range(1, 10**5 + 1)) assert countVisibleBuildings(heights) == 10**5","solution":"def countVisibleBuildings(heights): Returns the number of visible buildings when viewed from the left. Parameters: heights (list of ints): List of building heights Returns: int: Number of visible buildings if not heights: return 0 max_height = float('-inf') visible_count = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"class GroceryOrderSystem: Implement a Grocery Order System for a small grocery store. The system should be able to handle the following functionalities: 1. Add new products to the store’s inventory. Each product has a name, price, and quantity. 2. Place an order by providing a list of products and quantities. The system should check if sufficient stock is available for each product in the order. 3. Update the stock quantity of a product. 4. Remove a product from the inventory. 5. Retrieve a list of all products with their details (name, price, quantity). Input will be provided as a series of commands where each command is a single line of text. Output should be provided immediately after the input command is processed. def __init__(self): self.inventory = {} def add_product(self, name, price, quantity): Add a new product or update an existing product in the inventory. Args: name (str): Name of the product. price (float): Price of the product. quantity (int): Quantity of the product. Returns: str: \\"OK\\" when the product is added/updated successfully. pass def place_order(self, *products_and_quantities): Place an order with a list of products and their quantities. Args: products_and_quantities (tuple): A sequence of product names followed by their quantities. Returns: str: Total price of the order if fulfilled, or \\"OUT_OF_STOCK\\" message for the respective product. pass def update_stock(self, name, quantity): Update the stock quantity of a product. Args: name (str): Name of the product. quantity (int): New quantity of the product. Returns: str: \\"OK\\" when the stock is updated successfully. pass def remove_product(self, name): Remove a product from the inventory. Args: name (str): Name of the product. Returns: str: \\"OK\\" when the product is removed successfully. pass def view_inventory(self): Retrieve a list of all products with their details. Returns: str: Inventory list with each product's name, price, and quantity. pass","solution":"class GroceryOrderSystem: def __init__(self): self.inventory = {} def add_product(self, name, price, quantity): if name in self.inventory: self.inventory[name]['price'] = price self.inventory[name]['quantity'] += quantity else: self.inventory[name] = {'price': price, 'quantity': quantity} return \\"OK\\" def place_order(self, *products_and_quantities): total_price = 0.0 items_to_deduct = [] for i in range(0, len(products_and_quantities), 2): product = products_and_quantities[i] quantity = int(products_and_quantities[i+1]) if product not in self.inventory: return f\\"OUT_OF_STOCK: {product}\\" if self.inventory[product]['quantity'] < quantity: return f\\"OUT_OF_STOCK: {product}\\" total_price += self.inventory[product]['price'] * quantity items_to_deduct.append((product, quantity)) for product, quantity in items_to_deduct: self.inventory[product]['quantity'] -= quantity return f\\"{total_price:.1f}\\" def update_stock(self, name, quantity): if name in self.inventory: self.inventory[name]['quantity'] = quantity return \\"OK\\" def remove_product(self, name): if name in self.inventory: del self.inventory[name] return \\"OK\\" def view_inventory(self): inventory_list = [] for product in sorted(self.inventory.keys()): inventory_list.append(f\\"{product} {self.inventory[product]['price']} {self.inventory[product]['quantity']}\\") return \\"n\\".join(inventory_list)"},{"question":"from typing import List def min_steps_to_reach_end(n: int, m: int, grid: List[str]) -> int: Determines the minimum number of steps required for the robot to reach the bottom-right corner of the grid or -1 if unreachable. :param n: int - number of rows in the grid :param m: int - number of columns in the grid :param grid: List[str] - grid representation where '.' denotes an empty cell and '#' denotes an obstacle :return: int - minimum number of steps to reach (n, m) or -1 if impossible >>> min_steps_to_reach_end(4, 4, [\\"..#.\\", \\"..#.\\", \\"..#.\\", \\"....\\"]) 6 >>> min_steps_to_reach_end(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) -1 >>> min_steps_to_reach_end(5, 5, [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"]) 8","solution":"from collections import deque def min_steps_to_reach_end(n, m, grid): Determines the minimum number of steps required for the robot to reach the bottom-right corner of the grid or -1 if unreachable. def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] start = (0, 0) end = (n-1, m-1) if grid[0][0] == '#' or grid[end[0]][end[1]] == '#': return -1 queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set() visited.add(start) while queue: x, y, steps = queue.popleft() if (x, y) == end: return steps for direction in directions: nx, ny = x + direction[0], y + direction[1] if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def find_winning_wizard(n: int, power_levels: List[int]) -> int: Simulates the single-elimination tournament and finds the power level of the winning wizard. >>> find_winning_wizard(5, [3, 6, 2, 8, 5]) 8 >>> find_winning_wizard(4, [4, 7, 1, 9]) 9","solution":"def find_winning_wizard(n, power_levels): This function simulates the single-elimination tournament and finds the power level of the winning wizard. Parameters: n (int): The number of wizards. power_levels (list of int): The power levels of each wizard. Returns: int: The power level of the winning wizard. while len(power_levels) > 1: next_round = [] for i in range(0, len(power_levels)-1, 2): next_round.append(max(power_levels[i], power_levels[i+1])) if len(power_levels) % 2 == 1: next_round.append(power_levels[-1]) power_levels = next_round return power_levels[0]"},{"question":"def min_operations_to_empty(arr): Returns the minimum number of operations needed to empty the array. # Implementation here. def process_test_cases(test_cases): Processes multiple test cases and returns the results for each case. # Implementation here. # Test cases if __name__ == \\"__main__\\": assert min_operations_to_empty([1, 2, 3]) == 1 assert min_operations_to_empty([1]) == 1 assert min_operations_to_empty([1, 1, 1, 1]) == 1 assert min_operations_to_empty([]) == 0 assert process_test_cases([(3, [1, 2, 3])]) == [1] assert process_test_cases([(1, [1])]) == [1] test_cases = [(3, [1, 2, 3]), (4, [1, 1, 1, 1]), (0, [])] assert process_test_cases(test_cases) == [1, 1, 0] test_cases = [(0, []), (0, [])] assert process_test_cases(test_cases) == [0, 0] test_cases = [(5, [1, 2, 3, 4, 5]), (3, [6, 7, 8]), (0, [])] assert process_test_cases(test_cases) == [1, 1, 0]","solution":"def min_operations_to_empty(arr): Returns the minimum number of operations needed to empty the array. return 1 if arr else 0 def process_test_cases(test_cases): results = [] for t in test_cases: n, arr = t results.append(min_operations_to_empty(arr)) return results"},{"question":"def max_unique_pairs(s: str) -> int: Returns the maximum number of unique pairs of light strings that can be formed. Args: s (str): String representing the colors of light strings. Returns: int: Maximum number of unique pairs. pass def test_example_cases(): assert max_unique_pairs(\\"RGBG\\") == 3 assert max_unique_pairs(\\"AABB\\") == 1 def test_additional_cases(): assert max_unique_pairs(\\"AAAA\\") == 0 assert max_unique_pairs(\\"ABC\\") == 3 assert max_unique_pairs(\\"ABABABABAB\\") == 1 def test_single_character(): assert max_unique_pairs(\\"A\\") == 0 def test_two_different_characters(): assert max_unique_pairs(\\"AB\\") == 1 def test_large_input(): input_str = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" assert max_unique_pairs(input_str) == len(input_str) * (len(input_str) - 1) // 2","solution":"def max_unique_pairs(s): Returns the maximum number of unique pairs of light strings that can be formed. Args: s (str): String representing the colors of light strings. Returns: int: Maximum number of unique pairs. from collections import Counter color_count = Counter(s) pairs_formed = set() max_pairs = 0 colors = list(color_count.keys()) for i in range(len(colors)): for j in range(i + 1, len(colors)): pair = tuple(sorted([colors[i], colors[j]])) if pair not in pairs_formed: pairs_formed.add(pair) max_pairs += 1 return max_pairs"},{"question":"def min_employees(tasks): This function calculates the minimum number of employees required to complete all given tasks without overlapping. Parameters: tasks (List[Tuple[int, int]]): List of tuples with (start, end) times of tasks. Returns: int: Minimum number of employees required. >>> min_employees([(1, 4)]) == 1 >>> min_employees([(1, 2), (3, 4), (5, 6)]) == 1 >>> min_employees([(1, 4), (2, 6), (5, 7)]) == 2 >>> min_employees([(1, 4), (2, 6), (4, 7), (7, 9), (5, 8)]) == 3 >>> min_employees([]) == 0 >>> min_employees([(1, 5), (2, 6), (3, 7), (4, 8)]) == 4","solution":"def min_employees(tasks): This function calculates the minimum number of employees required to complete all given tasks without overlapping. Parameters: tasks (List[Tuple[int, int]]): List of tuples with (start, end) times of tasks. Returns: int: Minimum number of employees required. if not tasks: return 0 # Separate start and end times start_times = [start for start, end in tasks] end_times = [end for start, end in tasks] # Sort the start and end times start_times.sort() end_times.sort() # Initialize counters and a variable to keep track of the maximum number of concurrent tasks num_employees, max_employees = 0, 0 i, j = 0, 0 n = len(tasks) # Iterate through the sorted times while i < n and j < n: if start_times[i] < end_times[j]: num_employees += 1 max_employees = max(max_employees, num_employees) i += 1 else: num_employees -= 1 j += 1 return max_employees"},{"question":"def min_operations_to_sort(arr: List[int]) -> int: Returns the minimum number of operations required to sort the array in non-decreasing order. >>> min_operations_to_sort([1, 2, 3, 4]) 0 >>> min_operations_to_sort([4, 3, 2, 1]) 1 >>> min_operations_to_sort([3, 1, 2, 4]) 2","solution":"def min_operations_to_sort(arr): Returns the minimum number of operations required to sort the array in non-decreasing order. n = len(arr) sorted_arr = sorted(arr) if arr == sorted_arr: return 0 for l in range(n): for r in range(l, n): # Reverse subarray from l to r temp = arr[:l] + arr[l:r + 1][::-1] + arr[r + 1:] if temp == sorted_arr: return 1 return 2"},{"question":"def is_palindrome(n: int, elements: List[int]) -> str: Determine if the list of integers is a palindrome. :param n: The number of elements in the list. :param elements: List of integers. :return: \\"YES\\" if the list is a palindrome, otherwise \\"NO\\". >>> is_palindrome(5, [1, 2, 3, 2, 1]) \\"YES\\" >>> is_palindrome(4, [1, 2, 3, 4]) \\"NO\\"","solution":"def is_palindrome(n, elements): Checks if the given list 'elements' of length 'n' is a palindrome. :param n: Number of elements in the list. :param elements: List of integers. :return: \\"YES\\" if the list is a palindrome, otherwise \\"NO\\". if elements == elements[::-1]: return \\"YES\\" else: return \\"NO\\" # Example usage: # if __name__ == \\"__main__\\": # n = int(input()) # elements = list(map(int, input().split())) # result = is_palindrome(n, elements) # print(result)"},{"question":"from typing import List def can_partition(n: int, k: int, a: List[int]) -> str: Determine if you can partition the array into exactly k non-empty subarrays with equal sums. >>> can_partition(6, 3, [2, 1, 2, 1, 2, 1]) \\"YES\\" >>> can_partition(6, 2, [1, 2, 3, 4, 5, 6]) \\"NO\\" >>> can_partition(1, 1, [1]) \\"YES\\" >>> can_partition(1, 2, [1]) \\"NO\\" >>> can_partition(5, 5, [1, 1, 1, 1, 1]) \\"YES\\" >>> can_partition(10, 2, [1, 2, 2, 2, 6, 1, 2, 2, 2, 2]) \\"NO\\"","solution":"def can_partition(n, k, a): total_sum = sum(a) # Check if the total sum is divisible by k if total_sum % k != 0: return \\"NO\\" target_sum = total_sum // k current_sum, partition_count = 0, 0 for num in a: current_sum += num if current_sum == target_sum: partition_count += 1 current_sum = 0 return \\"YES\\" if partition_count == k else \\"NO\\""},{"question":"def longest_common_subsequence(a: str, b: str) -> int: Compute the length of the longest subsequence common to both strings a and b. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abcdef\\", \\"abcdef\\") 6 >>> longest_common_subsequence(\\"\\", \\"abcdef\\") 0 >>> longest_common_subsequence(\\"abcdef\\", \\"\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"ab\\") 2 >>> longest_common_subsequence(\\"abc\\", \\"bc\\") 2 >>> longest_common_subsequence(\\"xabcy\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"aaabbb\\", \\"ab\\") 2 >>> longest_common_subsequence(\\"abcd\\", \\"abdc\\") 3","solution":"def longest_common_subsequence(a, b): Computes the length of the longest subsequence common to both strings a and b. n, m = len(a), len(b) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] # Example usage: # a = \\"abcde\\" # b = \\"ace\\" # print(longest_common_subsequence(a, b)) # Output should be 3"},{"question":"import pytest from typing import List def largestRectangleArea(heights: List[int]) -> int: Returns the largest rectangular area in a histogram. :param heights: List[int] - a list of positive integers representing building heights :return: int - the maximum rectangular area that can be formed >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([4, 2, 0, 3, 2, 5]) 6 >>> largestRectangleArea([3, 3, 3, 3, 3]) 15 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([7]) 7 >>> heights = [1] * 100000 >>> largestRectangleArea(heights) 100000","solution":"def largestRectangleArea(heights): Returns the largest rectangular area in a histogram. :param heights: List[int] - a list of positive integers representing building heights :return: int - the maximum rectangular area that can be formed stack = [] max_area = 0 index = 0 while index < len(heights): # Push current building to stack if it is higher than the building at stack top if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with the popped element area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Process remaining buildings in the stack while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def max_possible_score(n: int, k: int, b: int, scores: List[int]) -> int: Returns the maximum achievable score for a participant. >>> max_possible_score(5, 3, 500, [100, 200, 300, 400, 500]) 2000 >>> max_possible_score(2, 3, 100, [300, 400]) 700 >>> max_possible_score(4, 2, 200, [100, 100, 100, 100]) 600 >>> max_possible_score(6, 4, 1000, [1, 1, 1, 1000, 1000, 1000]) 4003 >>> max_possible_score(10, 10, 100000, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) 100550 >>> max_possible_score(1, 1, 500, [500]) 1000","solution":"def max_possible_score(n, k, b, scores): Returns the maximum possible score a participant can achieve. # Sort the scores in descending order to maximize the score scores.sort(reverse=True) # Calculate the sum of all scores (solving all problems) max_score_without_bonus = sum(scores) # If the participant solves at least k problems, add the bonus if n >= k: return max_score_without_bonus + b else: return max_score_without_bonus"},{"question":"def max_squad_strength(n: int, k: int, strengths: List[int]) -> int: Determines the maximum strength of a squad by selecting exactly k soldiers from a list of n soldiers. Parameters: n (int): The number of soldiers. k (int): The number of soldiers to select. strengths (List[int]): The list of strengths of the soldiers. Returns: int: The maximum strength of the selected squad. >>> max_squad_strength(6, 3, [100, 200, 300, 400, 500, 600]) 1500 >>> max_squad_strength(1, 1, [1]) 1 >>> max_squad_strength(5, 2, [5, 5, 5, 5, 5]) 10 >>> max_squad_strength(3, 3, [10, 20, 30]) 60 >>> max_squad_strength(5, 3, [1000000, 999999, 999998, 1, 2]) 2999997","solution":"from typing import List def max_squad_strength(n: int, k: int, strengths: List[int]) -> int: Determines the maximum strength of a squad by selecting exactly k soldiers from a list of n soldiers. Parameters: n (int): The number of soldiers. k (int): The number of soldiers to select. strengths (List[int]): The list of strengths of the soldiers. Returns: int: The maximum strength of the selected squad. # Sort the strengths in descending order strengths.sort(reverse=True) # Sum the top k strengths return sum(strengths[:k])"},{"question":"def does_return_to_origin(commands: str) -> str: Determines if the robot returns to the origin after executing the given commands. :param commands: string containing the commands 'G', 'L', 'R' :return: \\"YES\\" if the robot returns to the origin, otherwise \\"NO\\" >>> does_return_to_origin(\\"GLGLGLGL\\") \\"YES\\" >>> does_return_to_origin(\\"GLRRGG\\") \\"NO\\" >>> does_return_to_origin(\\"GG\\") \\"NO\\" >>> does_return_to_origin(\\"GLRGLRGRL\\") \\"NO\\" >>> does_return_to_origin(\\"G\\") \\"NO\\" >>> does_return_to_origin(\\"\\") \\"YES\\" # Edge case: empty command string >>> does_return_to_origin(\\"GLLG\\") \\"YES\\" >>> does_return_to_origin(\\"GLGLG\\") \\"NO\\" >>> does_return_to_origin(\\"GRGRGRGR\\") \\"YES\\" >>> does_return_to_origin(\\"GGLLGG\\") \\"YES\\"","solution":"def does_return_to_origin(commands): Determines if the robot returns to the origin after executing the given commands. :param commands: string containing the commands 'G', 'L', 'R' :return: \\"YES\\" if the robot returns to the origin, otherwise \\"NO\\" # Initial position and direction (facing positive y-axis) x, y = 0, 0 # Directions represent the order: North (0), East (1), South (2), West (3) direction = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for command in commands: if command == 'G': dx, dy = directions[direction] x += dx y += dy elif command == 'L': direction = (direction - 1) % 4 elif command == 'R': direction = (direction + 1) % 4 return \\"YES\\" if x == 0 and y == 0 else \\"NO\\""},{"question":"from typing import List def get_largest_files(file_data: List[str]) -> List[str]: Takes in a list of file paths with their sizes and returns the files in descending order of their size. If multiple files have the same size, they are returned in lexicographical order. Parameters: file_data (List[str]): List of strings where each string contains a file path and its size separated by a space. Returns: List[str]: List of file paths ordered by their sizes and lexicographical order where necessary. pass def test_example_1(): input_data = [ \\"/home/user1/file1.txt 100\\", \\"/home/user1/file2.txt 500\\", \\"/home/user2/file3.txt 300\\" ] expected_output = [ \\"/home/user1/file2.txt\\", \\"/home/user2/file3.txt\\", \\"/home/user1/file1.txt\\" ] assert get_largest_files(input_data) == expected_output def test_example_2(): input_data = [ \\"/root/a 50\\", \\"/root/b 100\\", \\"/root/c 100\\", \\"/temp/d 75\\", \\"/temp/e 200\\" ] expected_output = [ \\"/temp/e\\", \\"/root/b\\", \\"/root/c\\", \\"/temp/d\\", \\"/root/a\\" ] assert get_largest_files(input_data) == expected_output def test_same_size_paths(): input_data = [ \\"/file1.txt 100\\", \\"/file2.txt 100\\", \\"/file3.txt 100\\" ] expected_output = [ \\"/file1.txt\\", \\"/file2.txt\\", \\"/file3.txt\\" ] assert get_largest_files(input_data) == expected_output def test_single_file(): input_data = [\\"/onlyfile.txt 123\\"] expected_output = [\\"/onlyfile.txt\\"] assert get_largest_files(input_data) == expected_output def test_files_with_mixed_sizes(): input_data = [ \\"/a/file1.txt 10\\", \\"/b/file2.txt 20\\", \\"/c/file3.txt 15\\", \\"/d/file4.txt 25\\" ] expected_output = [ \\"/d/file4.txt\\", \\"/b/file2.txt\\", \\"/c/file3.txt\\", \\"/a/file1.txt\\" ] assert get_largest_files(input_data) == expected_output","solution":"def get_largest_files(file_data): Takes in a list of file paths with their sizes and returns the files in descending order of their size. If multiple files have the same size, they are returned in lexicographical order. Parameters: file_data (List[str]): List of strings where each string contains a file path and its size separated by a space. Returns: List[str]: List of file paths ordered by their sizes and lexicographical order where necessary. files = [] for entry in file_data: path, size = entry.rsplit(' ', 1) size = int(size) files.append((size, path)) # Sorting firstly by size in descending order, and by path in ascending (lexicographical) order files.sort(key=lambda x: (-x[0], x[1])) # Extracting the file paths in the desired order sorted_paths = [path for size, path in files] return sorted_paths"},{"question":"def min_distance(s: str, t: str) -> int: Calculate the minimum number of operations required to transform string s into string t. The allowed operations are insertion, deletion, and substitution, each with a cost of 1. >>> min_distance(\\"sunday\\", \\"saturday\\") 3 >>> min_distance(\\"cat\\", \\"cut\\") 1 >>> min_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_distance(\\"flaw\\", \\"lawn\\") 2 >>> min_distance(\\"\\", \\"abc\\") 3 >>> min_distance(\\"abc\\", \\"\\") 3 >>> min_distance(\\"\\", \\"\\") 0 >>> min_distance(\\"a\\", \\"a\\") 0 >>> min_distance(\\"abcdef\\", \\"azced\\") 3","solution":"def min_distance(s, t): Calculates the minimum number of operations required to transform s into t. Operations allowed: insertion, deletion, substitution. n = len(s) m = len(t) # Create a (n+1) x (m+1) matrix to store the minimum operations dp = [[0] * (m + 1) for _ in range(n + 1)] # Base cases: transforming an empty string to another string for i in range(n + 1): dp[i][0] = i # Deleting all characters from s to match empty t for j in range(m + 1): dp[0][j] = j # Inserting all characters of t to match empty s # Fill the dp matrix for i in range(1, n + 1): for j in range(1, m + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No change if characters match else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[n][m]"},{"question":"def binary_tree_height(sequence: List[str]) -> int: Determines if the given sequence of binary strings is a valid binary tree sequence for some perfect binary tree and returns the height of the tree if valid, else returns -1. Args: sequence : list of strs : list of binary strings, each representing the binary representation of the number of nodes at each level of a perfect binary tree. Returns: int : height of the perfect binary tree if the sequence is valid, else -1. Examples: >>> binary_tree_height([\\"1\\", \\"10\\", \\"100\\", \\"1000\\"]) 3 >>> binary_tree_height([\\"1\\", \\"10\\", \\"11\\", \\"100\\"]) -1 >>> binary_tree_height([\\"1\\", \\"10\\", \\"100\\"]) 2 >>> binary_tree_height([\\"0\\"]) -1","solution":"def binary_tree_height(sequence): Determines if the given sequence of binary strings is a valid binary tree sequence for some perfect binary tree and returns the height of the tree if valid, else returns -1. Args: sequence : list of strs : list of binary strings, each representing the binary representation of the number of nodes at each level of a perfect binary tree. Returns: int : height of the perfect binary tree if the sequence is valid, else -1. for i, string in enumerate(sequence): expected_binary = bin(2 ** i)[2:] if expected_binary != string: return -1 return len(sequence) - 1"},{"question":"def can_partition_array(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if an array can be partitioned into two non-empty contiguous subarrays such that the sum of the first is strictly greater than the sum of the second. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of test cases where each test case contains the size of the array and the array itself. Returns: List[str]: A list of strings where each string is \\"Yes\\" or \\"No\\" indicating whether the partitioning is possible. >>> can_partition_array([(3, [1, 2, 3])]) ['No'] >>> can_partition_array([(4, [10, 4, 2, 1])]) ['Yes'] >>> can_partition_array([(5, [5, 1, 3, 2, 8])]) ['Yes']","solution":"def can_partition_array(test_cases): results = [] for n, a in test_cases: total_sum = sum(a) left_sum = 0 for i in range(n - 1): left_sum += a[i] right_sum = total_sum - left_sum if left_sum > right_sum: results.append(\\"Yes\\") break else: results.append(\\"No\\") return results"},{"question":"def minimum_sum(arr: List[int]) -> int: Returns the minimum possible sum of the array after performing any number of operations. >>> minimum_sum([5]) 5 >>> minimum_sum([1, 2]) 3 >>> minimum_sum([3, 1, 4, 1, 5, 9, 2]) 25 >>> minimum_sum([1000, 1000, 1000, 1000, 1000]) 5000 >>> minimum_sum([1, 500, 1000, 1]) 1502 pass","solution":"def minimum_sum(arr): Returns the minimum possible sum of the array after performing any number of operations. return sum(arr)"},{"question":"from typing import List def count_above_average_sales(sales: List[int]) -> int: Returns the number of months where the sales figure was higher than the average sales figure of the year. >>> count_above_average_sales([1200, 1300, 1150, 1400, 1700, 1600, 1450, 1550, 1600, 1750, 1850, 1900]) 7 >>> count_above_average_sales([1000] * 12) 0 >>> count_above_average_sales([0] * 12) 0 >>> count_above_average_sales([500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 10000]) 1 >>> count_above_average_sales([2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000]) 6","solution":"from typing import List def count_above_average_sales(sales: List[int]) -> int: Returns the number of months where the sales figure was higher than the average sales figure of the year. average_sales = sum(sales) / 12 return sum(1 for sale in sales if sale > average_sales)"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, left, right): left, right = left + self.n, right + self.n result = 0 while left < right: if left % 2: result += self.tree[left] left += 1 if right % 2: right -= 1 result += self.tree[right] left //= 2 right //= 2 return result def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process a sequence of queries on the given array. The function uses a Segment Tree to efficiently handle sum and update queries. Args: - n: number of elements in the array. - q: number of queries. - array: list of integers representing the array. - queries: list of queries. Returns a list of results for sum queries. >>> process_queries(5, 5, [1, 2, 3, 4, 5], [(1, 1, 3), (2, 3, 10), (1, 1, 3), (1, 3, 5), (2, 5, -1)]) [6, 13, 19] >>> process_queries(3, 2, [1, 2, 3], [(1, 1, 3), (2, 2, 5), (1, 1, 3)]) [6, 9]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, left, right): left, right = left + self.n, right + self.n result = 0 while left < right: if left % 2: result += self.tree[left] left += 1 if right % 2: right -= 1 result += self.tree[right] left //= 2 right //= 2 return result def process_queries(n, q, array, queries): segment_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: l, r = query[1] - 1, query[2] results.append(segment_tree.query(l, r)) elif query[0] == 2: i, x = query[1] - 1, query[2] segment_tree.update(i, x) return results"},{"question":"def max_flowers(pots: List[int]) -> int: Given a list of integers representing the number of flowers in each pot, returns the maximum number of flowers Alice can select such that no two chosen pots are adjacent. >>> max_flowers([5, 3, 6, 2, 7]) 18 >>> max_flowers([8]) 8 >>> max_flowers([8, 3]) 8","solution":"def max_flowers(pots): Given a list of integers representing the number of flowers in each pot, returns the maximum number of flowers Alice can select such that no two chosen pots are adjacent. if not pots: return 0 n = len(pots) if n == 1: return pots[0] if n == 2: return max(pots) # dp[i] will be the max number of flowers we can collect from the first i pots dp = [0] * n dp[0] = pots[0] dp[1] = max(pots[0], pots[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + pots[i]) return dp[n-1]"},{"question":"def canFinishProjects(n: int, dependencies: List[Tuple[int, int]]) -> bool: Determine if all the tasks can be completed given the dependencies. >>> canFinishProjects(4, [(1, 2), (2, 3), (3, 4)]) True >>> canFinishProjects(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) False","solution":"from collections import defaultdict, deque def canFinishProjects(n, dependencies): Determine if all the tasks can be completed given the dependencies. graph = defaultdict(list) in_degree = [0] * (n + 1) # Build graph and in-degree array for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Initialize queue with tasks that have no prerequisites queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) completed_tasks = 0 while queue: current = queue.popleft() completed_tasks += 1 for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If completed tasks equal to total tasks, return True return completed_tasks == n"},{"question":"def min_absolute_difference(N: int, weights: List[int]) -> int: Sandy has a collection of N acorns, each with a positive integer weight. She wants to partition these acorns into two groups such that the absolute difference between the sum of weights in the two groups is minimized. Help Sandy find this minimal absolute difference. Arguments: N -- An integer representing the number of acorns. weights -- A list of integers representing the weights of the acorns. Returns: An integer representing the minimal absolute difference between the sums of the two groups. Examples: >>> min_absolute_difference(5, [1, 2, 3, 4, 5]) 1 >>> min_absolute_difference(4, [6, 5, 3, 1]) 1 >>> min_absolute_difference(3, [10, 20, 30]) 0","solution":"def min_absolute_difference(N, weights): total_sum = sum(weights) dp = [False] * (total_sum // 2 + 1) dp[0] = True for weight in weights: for j in range(total_sum // 2, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] for i in range(total_sum // 2, -1, -1): if dp[i]: return total_sum - 2 * i"},{"question":"def minimal_radar_stations(n: int, stations: List[Tuple[int, int]], L: int, R: int) -> int: Returns the minimal number of radar stations required to cover the segment [L, R]. If coverage is not possible, returns -1. >>> minimal_radar_stations(4, [(1, 5), (2, 6), (3, 8), (7, 10)], 2, 8) 2 >>> minimal_radar_stations(4, [(1, 5), (2, 6), (7, 8), (10, 15)], 6, 12) -1 >>> minimal_radar_stations(3, [(1, 3), (3, 6), (6, 9)], 1, 9) 3 >>> minimal_radar_stations(1, [(1, 10)], 2, 8) 1 >>> minimal_radar_stations(4, [(1, 3), (5, 8), (9, 12), (13, 15)], 3, 9) -1","solution":"def minimal_radar_stations(n, stations, L, R): Returns the minimal number of radar stations required to cover the segment [L, R]. If coverage is not possible, returns -1. # Sort radar stations by start time and then by end time stations.sort() count = 0 i = 0 covered_till = L while covered_till < R: max_reach = covered_till while i < n and stations[i][0] <= covered_till: max_reach = max(max_reach, stations[i][1]) i += 1 if max_reach == covered_till: # No further coverage possible return -1 covered_till = max_reach count += 1 return count if covered_till >= R else -1"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to transform the given string into a palindrome. Examples: >>> min_operations_to_palindrome(\\"abca\\") 1 >>> min_operations_to_palindrome(\\"racecar\\") 0 >>> min_operations_to_palindrome(\\"abcdef\\") 3","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to transform the given string into a palindrome. n = len(s) operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"def two_sum_sorted(arr, target): Find two numbers in the sorted array \`arr\` that sum up to \`target\`. Return the 1-based indices of these two numbers. If no such indices exist, return -1, -1. >>> two_sum_sorted([1, 2, 4, 4, 5], 8) (3, 4) >>> two_sum_sorted([1, 2, 3, 4, 5], 10) (-1, -1) >>> two_sum_sorted([-10, -5, 1, 2, 4, 4, 5], -15) (1, 2) >>> two_sum_sorted([1, 2, 3, 4, 5], 9) (4, 5) >>> two_sum_sorted([1, 10], 11) (1, 2) >>> two_sum_sorted([1, 2, 5, 6], 18) (-1, -1)","solution":"def two_sum_sorted(arr, target): Find two numbers in the sorted array \`arr\` that sum up to \`target\`. Return the 1-based indices of these two numbers. If no such indices exist, return -1, -1. left, right = 0, len(arr) - 1 while left < right: curr_sum = arr[left] + arr[right] if curr_sum == target: return left + 1, right + 1 elif curr_sum < target: left += 1 else: right -= 1 return -1, -1"},{"question":"def spirally_sorted_array(n: int) -> List[List[int]]: Given a single integer \`n\`, determine the minimum spiral-sorted array of length n^2 such that when arranged in a spiral order, it satisfies the conditions above. >>> spirally_sorted_array(2) [[1, 2], [4, 3]] >>> spirally_sorted_array(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> spirally_sorted_array(0) [] >>> spirally_sorted_array(-1) []","solution":"def spirally_sorted_array(n): Returns an n x n matrix that is spirally sorted. if n <= 0: return [] # Create a list with elements 1 to n^2 elements = list(range(1, n*n + 1)) # Create an n x n matrix filled with None matrix = [[None] * n for _ in range(n)] top, bottom = 0, n - 1 left, right = 0, n - 1 index = 0 while top <= bottom and left <= right: # Traverse from left to right for col in range(left, right + 1): matrix[top][col] = elements[index] index += 1 top += 1 # Traverse from top to bottom for row in range(top, bottom + 1): matrix[row][right] = elements[index] index += 1 right -= 1 if top <= bottom: # Traverse from right to left for col in range(right, left - 1, -1): matrix[bottom][col] = elements[index] index += 1 bottom -= 1 if left <= right: # Traverse from bottom to top for row in range(bottom, top - 1, -1): matrix[row][left] = elements[index] index += 1 left += 1 return matrix"},{"question":"def max_teams(skill_levels): Determine the maximum number of strictly increasing teams of 3 players that can be formed from the list of skill levels. Args: skill_levels (list of int): List of skill levels of players. Returns: int: Maximum number of teams that can be formed. >>> max_teams([4, 2, 1, 3, 6, 5]) 2 >>> max_teams([1, 2, 3]) 1 >>> max_teams([1, 1, 1, 1]) 0","solution":"def max_teams(skill_levels): Determine the maximum number of strictly increasing teams of 3 players that can be formed from the list of skill levels. Args: skill_levels (list of int): List of skill levels of players. Returns: int: Maximum number of teams that can be formed. skill_levels.sort() team_count = 0 n = len(skill_levels) i = 0 while i + 2 < n: if skill_levels[i] < skill_levels[i+1] < skill_levels[i+2]: team_count += 1 i += 3 else: i += 1 return team_count"},{"question":"def check_delivery_alerts(times: List[int], target: int) -> int: Returns the count of deliveries that exceeded the target time. Parameters: times (List[int]): List of delivery times. target (int): Target delivery time. Returns: int: Number of deliveries that exceeded the target time. >>> check_delivery_alerts([30, 45, 60, 15, 25, 50], 40) == 3 >>> check_delivery_alerts([10, 20, 30, 40], 25) == 2 >>> check_delivery_alerts([5, 15, 25, 35], 36) == 0","solution":"from typing import List def check_delivery_alerts(times: List[int], target: int) -> int: Returns the count of deliveries that exceeded the target time. Parameters: times (List[int]): List of delivery times. target (int): Target delivery time. Returns: int: Number of deliveries that exceeded the target time. return sum(time > target for time in times)"},{"question":"def longest_same_parity_subarray_length(array: List[int]) -> int: Returns the length of the longest contiguous subarray where all elements have the same parity (either all are even, or all are odd). >>> longest_same_parity_subarray_length([1, 2, 2, 4, 5, 7]) 3 >>> longest_same_parity_subarray_length([1]) 1 >>> longest_same_parity_subarray_length([2, 4, 6, 8]) 4 >>> longest_same_parity_subarray_length([1, 2, 1, 2, 1]) 1 >>> longest_same_parity_subarray_length([2, 4, 6, 1, 3, 5, 2, 4]) 3","solution":"def longest_same_parity_subarray_length(array): Returns the length of the longest contiguous subarray where all elements have the same parity. n = len(array) max_length = 1 current_length = 1 for i in range(1, n): if (array[i] % 2) == (array[i - 1] % 2): current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def min_operations(s: str, t: str) -> int: Calculate the minimum number of operations required to convert string s into string t. >>> min_operations(\\"sitting\\", \\"kitten\\") 3 >>> min_operations(\\"test\\", \\"test\\") 0 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"abcdef\\", \\"azced\\") 3 >>> min_operations(\\"abc\\", \\"xyz\\") 3 >>> min_operations(\\"intention\\", \\"execution\\") 5","solution":"def min_operations(s, t): n, m = len(s), len(t) # dp[i][j] will hold the minimum edit distance between s[0..i-1] and t[0..j-1] dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize dp array for i in range(n + 1): for j in range(m + 1): if i == 0: dp[i][j] = j # If s is empty, we need to insert all characters of t elif j == 0: dp[i][j] = i # If t is empty, we need to delete all characters of s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are equal, ignore last char else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[n][m]"},{"question":"def flower_bed_arrangement(sequence: str, n: int, m: int) -> List[str]: Returns a 2D list representing the flower bed arrangement. Args: sequence (str): A sequence of distinct flower types. n (int): Number of rows in the bed. m (int): Number of columns in the bed. Returns: List[str]: List representing the bed arrangement. >>> flower_bed_arrangement(\\"ABCD\\", 3, 4) ['ABCD', 'ABCD', 'ABCD'] >>> flower_bed_arrangement(\\"XYZ\\", 1, 5) ['XYZXY']","solution":"def flower_bed_arrangement(sequence, n, m): Returns a 2D list representing the flower bed arrangement. Args: sequence (str): A sequence of distinct flower types. n (int): Number of rows in the bed. m (int): Number of columns in the bed. Returns: List[List[str]]: 2D list representing the bed arrangement. # Length of the sequence length = len(sequence) # Generate the repeated sequence repeated_sequence = (sequence * (m // length + 1))[:m] # Generate the full flower bed return [repeated_sequence] * n"},{"question":"from typing import List, Tuple def count_total_branches(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the total number of branches after the spell action is performed for each test case. >>> count_total_branches(2, [(3, [1, 2, 0]), (2, [0, 1])]) [6, 3] >>> count_total_branches(1, [(3, [0, 0, 0])]) [3] >>> count_total_branches(1, [(2, [2, 2])]) [6] >>> count_total_branches(3, [(2, [1, 0]), (4, [0, 0, 1, 2]), (1, [2])]) [3, 7, 3]","solution":"def count_total_branches(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] spell_actions = test_cases[i][1] total_branches = n + sum(spell_actions) results.append(total_branches) return results"},{"question":"def balance_degree(n: int, s: str) -> int: Returns the balance degree of the string where the number of 'a's is equal to the number of 'b's. Parameters: n (int): Length of the string. s (str): The string containing only characters 'a' and 'b'. Returns: int: The balance degree of the string. >>> balance_degree(6, \\"ababa\\") 6 >>> balance_degree(4, \\"aaaa\\") 0 >>> balance_degree(4, \\"bbbb\\") 0 >>> balance_degree(4, \\"abab\\") 4","solution":"def balance_degree(n, s): Returns the balance degree of the string where the number of 'a's is equal to the number of 'b's. Parameters: n (int): Length of the string. s (str): The string containing only characters 'a' and 'b'. Returns: int: The balance degree of the string. balance = 0 count_a = 0 count_b = 0 balance_counts = {0: 1} for char in s: if char == 'a': count_a += 1 elif char == 'b': count_b += 1 delta = count_a - count_b if delta in balance_counts: balance += balance_counts[delta] balance_counts[delta] += 1 else: balance_counts[delta] = 1 return balance"},{"question":"from typing import List def find_unique_game_sessions(n: int, k: int, skill_levels: List[int]) -> int: Calculate the number of unique game sessions that can be formed where the combined skill levels of three players equal \`k\`. Args: n (int): The number of players. k (int): The required total skill level for a game session. skill_levels (List[int]): The list of skill levels of the players. Returns: int: The number of unique game sessions. Examples: >>> find_unique_game_sessions(5, 6, [1, 2, 3, 4, 5]) 1 >>> find_unique_game_sessions(5, 15, [1, 2, 3, 4, 5]) 0 >>> find_unique_game_sessions(4, 9, [3, 3, 3, 3]) 4 >>> find_unique_game_sessions(3, 10, [2, 2, 2]) 0 >>> find_unique_game_sessions(3, 6, [1, 2, 3]) 1 >>> find_unique_game_sessions(6, 10, [2, 3, 3, 4, 5, 6]) 3","solution":"from itertools import combinations def find_unique_game_sessions(n, k, skill_levels): count = 0 for comb in combinations(skill_levels, 3): if sum(comb) == k: count += 1 return count"},{"question":"from typing import List, Tuple def max_employees_simultaneously(shifts: List[Tuple[int, int]]) -> int: Finds the maximum number of employees working simultaneously given their shifts. Parameters: shifts (list of tuple): A list of tuples where each tuple contains two integers (start_time, end_time). Returns: int: Maximum number of employees working simultaneously. pass def test_single_shift(): shifts = [(100, 200)] assert max_employees_simultaneously(shifts) == 1 def test_no_overlapping_shifts(): shifts = [(100, 200), (300, 400), (500, 600)] assert max_employees_simultaneously(shifts) == 1 def test_all_overlapping_shifts(): shifts = [(100, 200), (150, 250), (170, 270)] assert max_employees_simultaneously(shifts) == 3 def test_partially_overlapping_shifts(): shifts = [(100, 300), (200, 400), (500, 600)] assert max_employees_simultaneously(shifts) == 2 def test_complex_case(): shifts = [(300, 900), (600, 1200), (700, 1000), (1100, 1400), (100, 200)] assert max_employees_simultaneously(shifts) == 3 def test_shifts_ending_before_new_shifts_start(): shifts = [(100, 200), (200, 300), (300, 400), (400, 500)] assert max_employees_simultaneously(shifts) == 1","solution":"def max_employees_simultaneously(shifts): Finds the maximum number of employees working simultaneously given their shifts. Parameters: shifts (list of tuple): A list of tuples where each tuple contains two integers (start_time, end_time). Returns: int: Maximum number of employees working simultaneously. events = [] # Adding all start and end times to the events list for start, end in shifts: events.append((start, 'start')) events.append((end, 'end')) # Sort events: first by time, then by type ('end' before 'start' if times are the same) events.sort(key=lambda x: (x[0], x[1] == 'start')) current_count = 0 max_count = 0 # Traverse the events to compute max employees working simultaneously for time, event in events: if event == 'start': current_count += 1 max_count = max(max_count, current_count) else: current_count -= 1 return max_count"},{"question":"from typing import List, Tuple def flip_submatrix(matrix: List[List[str]], r1: int, c1: int, r2: int, c2: int) -> None: Flip the elements of the submatrix defined by top-left (r1, c1) and bottom-right (r2, c2) corners. for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): matrix[i][j] = '1' if matrix[i][j] == '0' else '0' def is_uniform(matrix: List[List[str]]) -> bool: Check if all elements in the matrix are the same. first_value = matrix[0][0] for row in matrix: for value in row: if value != first_value: return False return True def min_operations_to_uniform(matrix: List[List[str]]) -> Tuple[int, List[Tuple[int, int, int, int]]]: Determine the minimum number of operations required to make all elements of the binary matrix the same. Returns the number of operations and the sequence of operations. n = len(matrix) m = len(matrix[0]) operations = [] if is_uniform(matrix): return 0, operations for i in range(n): for j in range(m): if matrix[i][j] == '1': r1, c1, r2, c2 = 0, 0, i, j flip_submatrix(matrix, r1, c1, r2, c2) operations.append((r1 + 1, c1 + 1, r2 + 1, c2 + 1)) return len(operations), operations def read_matrix_input(input_str: str) -> List[List[str]]: Read matrix input from the given string and return it as a list of list of characters. input_lines = input_str.strip().split('n') n, m = map(int, input_lines[0].strip().split()) matrix = [list(line.strip()) for line in input_lines[1:]] return matrix # Unit tests def test_uniform_matrix(): input_str = 2 2 00 00 matrix = read_matrix_input(input_str) num_operations, operations = min_operations_to_uniform(matrix) assert num_operations == 0 assert operations == [] def test_non_uniform_small_matrix(): input_str = 2 2 01 10 matrix = read_matrix_input(input_str) num_operations, operations = min_operations_to_uniform(matrix) assert num_operations > 0 def test_non_uniform_larger_matrix(): input_str = 3 3 010 001 100 matrix = read_matrix_input(input_str) num_operations, operations = min_operations_to_uniform(matrix) assert num_operations > 0 def test_custom_case(): input_str = 3 3 011 101 110 matrix = read_matrix_input(input_str) num_operations, operations = min_operations_to_uniform(matrix) assert num_operations > 0 def test_already_uniform(): input_str = 3 3 111 111 111 matrix = read_matrix_input(input_str) num_operations, operations = min_operations_to_uniform(matrix) assert num_operations == 0 assert operations == [] # Example usage: input_str = 3 3 010 001 100 matrix = read_matrix_input(input_str) num_operations, operations = min_operations_to_uniform(matrix) print(num_operations) for op in operations: print(' '.join(map(str, op)))","solution":"def flip_submatrix(matrix, r1, c1, r2, c2): for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): matrix[i][j] = '1' if matrix[i][j] == '0' else '0' def is_uniform(matrix): first_value = matrix[0][0] for row in matrix: for value in row: if value != first_value: return False return True def min_operations_to_uniform(matrix): n = len(matrix) m = len(matrix[0]) operations = [] if is_uniform(matrix): return 0, operations for i in range(n): for j in range(m): if matrix[i][j] == '1': r1, c1, r2, c2 = 0, 0, i, j flip_submatrix(matrix, r1, c1, r2, c2) operations.append((r1 + 1, c1 + 1, r2 + 1, c2 + 1)) return len(operations), operations # Reading input matrix def read_matrix_input(input_str): input_lines = input_str.strip().split('n') n, m = map(int, input_lines[0].strip().split()) matrix = [list(line.strip()) for line in input_lines[1:]] return matrix # Example usage: input_str = 3 3 010 001 100 matrix = read_matrix_input(input_str) num_operations, operations = min_operations_to_uniform(matrix) print(num_operations) for op in operations: print(' '.join(map(str, op)))"},{"question":"[Completion Task in Python] from typing import List def minHeightDifference(heights: List[int]) -> int: Find the minimum possible difference between the tallest and shortest tree in any sequence with at least two trees. >>> minHeightDifference([3, 1, 4, 1, 5, 9]) 0 >>> minHeightDifference([10, 20, 30, 40, 50]) 10 >>> minHeightDifference([5, 5, 5, 5]) 0 >>> minHeightDifference([1, 3, 3, 7, 9]) 0 >>> minHeightDifference([1, 2, 3]) 1 >>> minHeightDifference([1000000, 999999, 999998]) 1","solution":"from typing import List def minHeightDifference(heights: List[int]) -> int: heights.sort() min_diff = float('inf') for i in range(1, len(heights)): diff = heights[i] - heights[i - 1] if diff < min_diff: min_diff = diff return min_diff"},{"question":"def process_sequence(n, sequence, queries): Process the sequence according to the given queries. Parameters: - n: int, the length of the sequence - sequence: list of int, the sequence of integers - queries: list of tuples, each tuple containing two integers L and R Returns: - list of int, the sum of subsequences for each query >>> process_sequence(5, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> process_sequence(6, [10, 20, 30, 40, 50, 60], [(1, 2), (3, 4), (1, 6), (4, 6)]) [30, 70, 210, 150] >>> process_sequence(3, [100, 200, 300], [(1, 1), (1, 2), (2, 3)]) [100, 300, 500] # The function implementation goes here.","solution":"def process_sequence(n, sequence, queries): Process the sequence according to the given queries. Parameters: - n: int, the length of the sequence - sequence: list of int, the sequence of integers - queries: list of tuples, each tuple containing two integers L and R Returns: - list of int, the sum of subsequences for each query # Calculate prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + sequence[i - 1] results = [] for L, R in queries: # We subtract prefix_sum[L-1] from prefix_sum[R] to get the sum from L to R results.append(prefix_sums[R] - prefix_sums[L - 1]) return results"},{"question":"def exist(board: List[List[chr]], word: str) -> str: Determine if a specific word can be constructed from letters of sequentially adjacent cells in a given matrix. Adjacents cells are horizontally or vertically neighboring. :param board: List of List of characters, representing the matrix. :param word: The target word to be constructed from the matrix. :return: \\"YES\\" if the word can be constructed from the matrix, otherwise \\"NO\\". >>> exist([['a','b','c','e'],['s','f','c','s'],['a','d','e','e']], \\"abcced\\") \\"YES\\" >>> exist([['a','b','c','e'],['s','f','c','s'],['a','d','e','e']], \\"see\\") \\"YES\\" >>> exist([['a','b','c','e'],['s','f','c','s'],['a','d','e','e']], \\"abfb\\") \\"NO\\" from typing import List def test_exist(): # Test case 1 n, m = 3, 4 matrix = [ ['a','b','c','e'], ['s','f','c','s'], ['a','d','e','e'] ] word = \\"abcced\\" assert exist(matrix, word) == \\"YES\\" # Test case 2 word = \\"see\\" assert exist(matrix, word) == \\"YES\\" # Test case 3 word = \\"abfb\\" assert exist(matrix, word) == \\"NO\\" # Additional test cases # Test case 4: Single letter n, m = 1, 1 matrix = [['a']] word = \\"a\\" assert exist(matrix, word) == \\"YES\\" # Test case 5: Word larger than matrix n, m = 2, 2 matrix = [ ['a', 'b'], ['c', 'd'] ] word = \\"abcd\\" assert exist(matrix, word) == \\"NO\\" # Test case 6: A single character in a larger matrix matrix = [ ['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e'] ] word = \\"f\\" assert exist(matrix, word) == \\"YES\\" # Test case 7: Failing to construct due to character not available matrix = [ ['a','b'], ['b','a'] ] word = \\"aac\\" assert exist(matrix, word) == \\"NO\\"","solution":"def exist(board, word): def dfs(board, word, i, j, k): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False temp = board[i][j] board[i][j] = '' found = dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1) board[i][j] = temp return found n = len(board) m = len(board[0]) for i in range(n): for j in range(m): if dfs(board, word, i, j, 0): return \\"YES\\" return \\"NO\\" # Example usage n, m = 3, 4 matrix = [ ['a','b','c','e'], ['s','f','c','s'], ['a','d','e','e'] ] word = \\"abcced\\" print(exist(matrix, word)) # Outputs: YES word = \\"see\\" print(exist(matrix, word)) # Outputs: YES word = \\"abfb\\" print(exist(matrix, word)) # Outputs: NO"},{"question":"def longest_subarray_with_k_distinct(seq, k): Find the length of the longest contiguous subarray with at most k distinct integers. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3, 4, 5], 2) \\"4\\" >>> longest_subarray_with_k_distinct([1, 2, 3], 5) \\"3\\" >>> longest_subarray_with_k_distinct([1], 1) \\"1\\" >>> longest_subarray_with_k_distinct([1, 1, 1, 1], 1) \\"4\\" >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 0) \\"0\\" >>> longest_subarray_with_k_distinct([1, 2, 1, 3, 4, 1, 1], 4) \\"7\\"","solution":"def longest_subarray_with_k_distinct(seq, k): from collections import defaultdict n = len(seq) left = 0 max_length = 0 count = defaultdict(int) for right in range(n): count[seq[right]] += 1 while len(count) > k: count[seq[left]] -= 1 if count[seq[left]] == 0: del count[seq[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def count_distinct_binary_reversals(t: int, ns: List[int]) -> List[int]: For each integer n in ns, count the number of distinct values in the array b defined. The array b is constructed by taking the binary representation of each integer from 1 to n, reversing it, converting back to decimal, and then counting the distinct values in the resulting array. Parameters: t (int): Number of test cases. ns (list): List containing each n value for the test cases. Returns: list: List of results for each test case.","solution":"def count_distinct_binary_reversals(t, ns): For each integer n in ns, count the number of distinct values in the array b defined. The array b is constructed by taking the binary representation of each integer from 1 to n, reversing it, converting back to decimal, and then counting the distinct values in the resulting array. Parameters: t (int): Number of test cases. ns (list): List containing each n value for the test cases. Returns: list: List of results for each test case. results = [] for n in ns: distinct_values = set() for i in range(1, n + 1): reversed_bin = bin(i)[2:][::-1] # Convert to binary string, reverse it reversed_dec = int(reversed_bin, 2) # Convert reversed binary string back to decimal distinct_values.add(reversed_dec) results.append(len(distinct_values)) return results"},{"question":"def max_boxes(b: int, p: int, n: int) -> int: Returns the maximum number of boxes Nadia can prepare. Each box contains: - 1 book - 2 pens - 3 notebooks Parameters: - b (int): the number of books - p (int): the number of pens - n (int): the number of notebooks Returns: - int: the maximum number of boxes >>> max_boxes(3, 6, 9) 3 >>> max_boxes(5, 8, 11) 3 >>> max_boxes(2, 2, 3) 1","solution":"def max_boxes(b, p, n): Returns the maximum number of boxes Nadia can prepare. Each box contains: - 1 book - 2 pens - 3 notebooks Parameters: - b (int): the number of books - p (int): the number of pens - n (int): the number of notebooks Returns: - int: the maximum number of boxes return min(b, p // 2, n // 3) # Example usage: # print(max_boxes(3, 6, 9)) # Output should be 3 # print(max_boxes(5, 8, 11)) # Output should be 3 # print(max_boxes(2, 2, 3)) # Output should be 1"},{"question":"def merge_digits(a: int, b: int) -> int: Merge the digits of two integers by alternating their digits. If one number has more digits than the other, append the remaining digits at the end. >>> merge_digits(1234, 567) == 1526374 >>> merge_digits(12, 3456) == 132456 >>> merge_digits(0, 0) == 0","solution":"def merge_digits(a: int, b: int) -> int: Merge the digits of two integers by alternating their digits. If one number has more digits than the other, append the remaining digits at the end. str_a = str(a) str_b = str(b) merged_digits = [] len_a = len(str_a) len_b = len(str_b) i = 0 min_len = min(len_a, len_b) # Alternate the digits of a and b while i < min_len: merged_digits.append(str_a[i]) merged_digits.append(str_b[i]) i += 1 # Append remaining digits of the longer number if i < len_a: merged_digits.extend(str_a[i:]) if i < len_b: merged_digits.extend(str_b[i:]) return int(\\"\\".join(merged_digits))"},{"question":"def encrypt_string(s: str, k: int) -> str: Encrypts the string s by shifting each letter by k positions in the alphabet. If the shift moves past the end of the alphabet, it wraps around to the beginning. >>> encrypt_string(\\"abc\\", 3) == \\"def\\" >>> encrypt_string(\\"xyz\\", 2) == \\"zab\\" pass def process_test_cases(T: int, test_cases: List[Tuple[str, int]]) -> List[str]: Processes multiple test cases for the encryption algorithm. >>> T = 3 >>> test_cases = [(\\"abc\\", 3), (\\"xyz\\", 2), (\\"hello\\", 5)] >>> process_test_cases(T, test_cases) == [\\"def\\", \\"zab\\", \\"mjqqt\\"] pass","solution":"def encrypt_string(s, k): Encrypts the string s by shifting each letter by k positions in the alphabet. If the shift moves past the end of the alphabet, it wraps around to the beginning. encrypted = [] k = k % 26 # As the alphabet only has 26 characters for char in s: shifted_pos = (ord(char) - ord('a') + k) % 26 new_char = chr(ord('a') + shifted_pos) encrypted.append(new_char) return ''.join(encrypted) def process_test_cases(T, test_cases): result = [] for s, k in test_cases: encrypted_string = encrypt_string(s, k) result.append(encrypted_string) return result"},{"question":"def find_pairs(n: int, k: int, a: List[int]) -> Union[List[Tuple[int, int]], str]: Finds all unique pairs of integers in the list that sum up to target integer k. Each pair should be sorted in ascending order. Output the pairs in lexicographical order. Args: n : int : the number of integers in the list k : int : the target sum a : List[int] : the elements of the list Returns: List[Tuple[int, int]] : list of tuples containing the pairs in lexicographical order OR str : \\"No pairs found\\" if no such pairs exist >>> find_pairs(5, 6, [1, 2, 3, 4, 5]) [(1, 5), (2, 4)] >>> find_pairs(4, 10, [4, 6, 7, 3]) [(3, 7), (4, 6)] >>> find_pairs(3, 8, [2, 1, 3]) \\"No pairs found\\"","solution":"def find_pairs(n, k, a): Finds all unique pairs of integers in the list that sum up to target integer k. Returns the pairs sorted in lexicographical order. pairs = set() seen = set() for number in a: complement = k - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) if pairs: sorted_pairs = sorted(pairs) return sorted_pairs else: return \\"No pairs found\\""},{"question":"def shortest_path_on_hexagrid(n: int, m: int, edges: List[Tuple[int, int, int, int, int, int]], start: Tuple[int, int, int], target: Tuple[int, int, int]) -> Tuple[int, List[Tuple[int, int, int]]]: Find the shortest path in a hexagonal grid using cube coordinates. Args: n: The number of hexagons in the grid. m: The number of edges connecting the hexagons. edges: A list of tuples representing the edges, where each tuple contains six integers (x1, y1, z1, x2, y2, z2). start: A tuple of three integers representing the starting hexagon. target: A tuple of three integers representing the target hexagon. Returns: The length of the shortest path and the list of hexagon coordinates that form the path. >>> n = 3 >>> m = 2 >>> edges = [(0, -1, 1, 1, -1, 0), (1, -1, 0, 1, 0, -1)] >>> start = (0, -1, 1) >>> target = (1, 0, -1) >>> shortest_path_on_hexagrid(n, m, edges, start, target) (2, [(0, -1, 1), (1, -1, 0), (1, 0, -1)]) pass","solution":"from collections import deque, defaultdict def shortest_path_on_hexagrid(n, m, edges, start, target): # Build adjacency list graph = defaultdict(list) for x1, y1, z1, x2, y2, z2 in edges: graph[(x1, y1, z1)].append((x2, y2, z2)) graph[(x2, y2, z2)].append((x1, y1, z1)) # Perform BFS queue = deque([start]) came_from = {start: None} while queue: current = queue.popleft() if current == target: break for neighbor in graph[current]: if neighbor not in came_from: queue.append(neighbor) came_from[neighbor] = current # Reconstruct path path = [] at = target while at is not None: path.append(at) at = came_from[at] path.reverse() return len(path) - 1, path # Sample Input Reading Function (Additional Utility for Reading Inputs) def read_input(data): lines = data.strip().split('n') n, m = map(int, lines[0].split()) edges = [tuple(map(int, line.split())) for line in lines[1:m+1]] start = tuple(map(int, lines[m+1].split()[:3])) target = tuple(map(int, lines[m+1].split()[3:])) return n, m, edges, start, target"},{"question":"def max_excitement(games, T): Returns the maximum total excitement level achievable without exceeding the given total duration T. :param games: A list of tuples where each tuple contains two integers (excitement level, duration) of a game. :param T: An integer representing the maximum total duration. :return: An integer representing the maximum possible total excitement level. pass # Example test cases def test_example_case(): games = [(60, 10), (100, 20), (120, 30)] T = 50 assert max_excitement(games, T) == 300 def test_case_1(): games = [(100, 20), (200, 30), (300, 50)] T = 60 assert max_excitement(games, T) == 400 def test_case_2(): games = [(1, 1), (10, 2), (100, 3)] T = 6 assert max_excitement(games, T) == 200 def test_case_3(): games = [(1000, 100), (2000, 200)] T = 300 assert max_excitement(games, T) == 3000 def test_case_4(): games = [(10, 5), (20, 10), (30, 15)] T = 25 assert max_excitement(games, T) == 50 def test_no_games(): games = [] T = 10 assert max_excitement(games, T) == 0 def test_minimum_input(): games = [(1, 1)] T = 1 assert max_excitement(games, T) == 1","solution":"def max_excitement(games, T): Returns the maximum total excitement level achievable without exceeding the given total duration T. :param games: A list of tuples where each tuple contains two integers (excitement level, duration) of a game. :param T: An integer representing the maximum total duration. :return: An integer representing the maximum possible total excitement level. dp = [0] * (T + 1) for e, t in games: for j in range(t, T + 1): dp[j] = max(dp[j], dp[j - t] + e) return dp[T]"},{"question":"from typing import List def max_visual_appeal(n: int, heights: List[int]) -> int: Returns the maximum visual appeal for arranging the given books. Args: n : int : the number of books on the bookshelf heights : List[int] : a list of integers representing the heights of the books Returns: int : the maximum visual appeal Sarah can achieve by rearranging the books Examples: >>> max_visual_appeal(5, [1, 2, 2, 3, 1]) 4 >>> max_visual_appeal(4, [2, 2, 2, 2]) 1 >>> max_visual_appeal(4, [2, 3, 2, 3]) 2 pass # Test cases def test_single_book(): assert max_visual_appeal(1, [1]) == 1 def test_all_books_same_height(): assert max_visual_appeal(4, [2, 2, 2, 2]) == 1 def test_two_different_heights(): assert max_visual_appeal(4, [2, 3, 2, 3]) == 2 def test_example(): assert max_visual_appeal(5, [1, 2, 2, 3, 1]) == 3 def test_more_complex_case(): assert max_visual_appeal(7, [1, 2, 2, 3, 1, 4, 4]) == 4 def test_all_different_heights(): assert max_visual_appeal(5, [1, 2, 3, 4, 5]) == 5","solution":"from collections import Counter def max_visual_appeal(n, heights): Returns the maximum visual appeal for arranging the given books. # Count the frequency of each height. height_counts = Counter(heights) # The maximum visual appeal is achieved when each unique height is sorted in a round-robin fashion. unique_heights = list(height_counts.keys()) unique_count = len(unique_heights) return unique_count # Example Usage: n = 5 heights = [1, 2, 2, 3, 1] print(max_visual_appeal(n, heights)) # Output: 4"},{"question":"from typing import List def min_energy(grid: List[List[int]]) -> int: You are given a grid with n rows and m columns. Each cell within the grid contains an integer which represents the energy required to move through that cell. You start at the top-left cell of the grid (1,1) and your goal is to reach the bottom-right cell (n,m). From each cell, you are allowed to move to the right or downwards to an adjacent cell. Find the minimum total energy required to reach the bottom-right cell of the grid starting from the top-left. >>> min_energy([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_energy([[1, 2], [1, 1]]) 3","solution":"from typing import List def min_energy(grid: List[List[int]]) -> int: n = len(grid) m = len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Start point # Initialize first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def isValidSudoku(board: List[List[str]]) -> str: Function to validate if a given 9x9 Sudoku board is valid. The board is considered valid if: 1. Each row contains the digits 1-9 without repetition. 2. Each column contains the digits 1-9 without repetition. 3. Each of the nine 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. The Sudoku board can contain the digits 1-9 and the character '.', which represents empty cells. >>> board = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> isValidSudoku(board) \\"YES\\" >>> board = [ ... [\\"8\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> isValidSudoku(board) \\"NO\\"","solution":"def isValidSudoku(board): Function to validate if a given 9x9 Sudoku board is valid. def isValidBlock(block): seen = set() for value in block: if value != '.' and value in seen: return False seen.add(value) return True # Check rows for row in board: if not isValidBlock(row): return \\"NO\\" # Check columns for col in range(9): if not isValidBlock([board[row][col] for row in range(9)]): return \\"NO\\" # Check 3x3 sub-boxes for box_row in range(0, 9, 3): for box_col in range(0, 9, 3): block = [ board[r][c] for r in range(box_row, box_row + 3) for c in range(box_col, box_col + 3) ] if not isValidBlock(block): return \\"NO\\" return \\"YES\\""},{"question":"def replaceElements(arr: List[int]) -> None: Modify the array so that each element is replaced by the greatest element among the elements to its right, and the last element is replaced with -1. # Implementation here # Test cases def test_replaceElements_example_case(): arr = [17, 18, 5, 4, 6, 1] replaceElements(arr) assert arr == [18, 6, 6, 6, 1, -1] def test_replaceElements_single_element(): arr = [10] replaceElements(arr) assert arr == [-1] def test_replaceElements_two_elements(): arr = [5, 1] replaceElements(arr) assert arr == [1, -1] def test_replaceElements_all_equal(): arr = [7, 7, 7, 7] replaceElements(arr) assert arr == [7, 7, 7, -1] def test_replaceElements_decreasing_order(): arr = [9, 8, 7, 6, 5] replaceElements(arr) assert arr == [8, 7, 6, 5, -1] def test_replaceElements_with_zeros(): arr = [0, 0, 0, 0] replaceElements(arr) assert arr == [0, 0, 0, -1] def test_replaceElements_mixed_values(): arr = [10, 5, 20, 6, 7, 3] replaceElements(arr) assert arr == [20, 20, 7, 7, 3, -1] def test_replaceElements_empty_array(): arr = [] replaceElements(arr) assert arr == []","solution":"def replaceElements(arr): Modify the array so that each element is replaced by the greatest element among the elements to its right, and the last element is replaced with -1. # Edge case: if array is empty or has one element if not arr: return if len(arr) == 1: arr[0] = -1 return n = len(arr) max_right = -1 for i in range(n-1, -1, -1): new_val = max_right if arr[i] > max_right: max_right = arr[i] arr[i] = new_val"},{"question":"def can_schedule_workshops(n: int, intervals: List[Tuple[int, int, int, int]]) -> str: Determines if it's possible to schedule workshops without overlap in any of the two venues. Args: n: int - Number of workshops. intervals: List of tuples - Each tuple represents a workshop with (sx_i, ex_i, sy_i, ey_i). Returns: str: \\"POSSIBLE\\" if non-overlapping scheduling is possible, otherwise \\"IMPOSSIBLE\\". >>> can_schedule_workshops(3, [(1, 3, 2, 4), (5, 6, 8, 9), (4, 5, 6, 7)]) == \\"POSSIBLE\\" >>> can_schedule_workshops(3, [(1, 4, 3, 6), (2, 5, 4, 7), (5, 8, 7, 9)]) == \\"IMPOSSIBLE\\" >>> can_schedule_workshops(1, [(1, 2, 3, 4)]) == \\"POSSIBLE\\" >>> can_schedule_workshops(1, [(1, 1, 1, 1)]) == \\"POSSIBLE\\"","solution":"def can_schedule_workshops(n, intervals): Determines if it's possible to schedule workshops without overlap in any of the two venues. Args: n: int - Number of workshops. intervals: List of tuples - Each tuple represents a workshop with (sx_i, ex_i, sy_i, ey_i). Returns: str: \\"POSSIBLE\\" if non-overlapping scheduling is possible, otherwise \\"IMPOSSIBLE\\". def is_non_overlapping(intervals): intervals.sort() end_time = -1 for start, end in intervals: if start < end_time: return False end_time = end return True intervals_x = [(sx, ex) for sx, ex, _, _ in intervals] intervals_y = [(sy, ey) for _, _, sy, ey in intervals] if is_non_overlapping(intervals_x) or is_non_overlapping(intervals_y): return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\" # Example usage: # n = 3 # intervals = [(1, 3, 2, 4), (5, 6, 8, 9), (4, 5, 6, 7)] # print(can_schedule_workshops(n, intervals)) # Output: \\"POSSIBLE\\""},{"question":"def count_unique_palindromic_substrings(s: str) -> int: Returns the count of unique palindromic substrings in the given string s. >>> count_unique_palindromic_substrings(\\"abba\\") 4 >>> count_unique_palindromic_substrings(\\"racecar\\") 7 >>> count_unique_palindromic_substrings(\\"a\\") 1 >>> count_unique_palindromic_substrings(\\"abc\\") 3 >>> count_unique_palindromic_substrings(\\"aaaa\\") 4 >>> count_unique_palindromic_substrings(\\"abacdfgdcaba\\") 7 >>> count_unique_palindromic_substrings(\\"\\") 0","solution":"def count_unique_palindromic_substrings(s): Returns the count of unique palindromic substrings in the given string s. n = len(s) unique_palindromes = set() for i in range(n): # Odd length palindromes left, right = i, i while left >= 0 and right < n and s[left] == s[right]: unique_palindromes.add(s[left:right+1]) left -= 1 right += 1 # Even length palindromes left, right = i, i + 1 while left >= 0 and right < n and s[left] == s[right]: unique_palindromes.add(s[left:right+1]) left -= 1 right += 1 return len(unique_palindromes)"},{"question":"def can_transform(A: str, B: str) -> str: Determine if it's possible to transform string A into string B using any number of binary flips. >>> can_transform(\\"1100\\", \\"1010\\") \\"YES\\" >>> can_transform(\\"1101\\", \\"1010\\") \\"NO\\"","solution":"def can_transform(A: str, B: str) -> str: Determine if it's possible to transform string A into string B using any number of binary flips. if sorted(A) != sorted(B): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def rearrange_string(k: int, s: str) -> str: Rearrange the string such that any two adjacent characters in the resulting string are different, and the resulting string is lexicographically smallest. If it is not possible, return \\"No\\". >>> rearrange_string(2, \\"aaabbb\\") \\"ababab\\" >>> rearrange_string(3, \\"aaaaaaa\\") \\"No\\"","solution":"def rearrange_string(k, s): from collections import Counter import heapq if k == 1: return ''.join(sorted(s)) count = Counter(s) max_freq = max(count.values()) n = len(s) if max_freq > (n + k - 1) // k: return \\"No\\" max_heap = [] for char, cnt in count.items(): heapq.heappush(max_heap, (-cnt, char)) result = [] while max_heap: used = [] for _ in range(k): if not max_heap: break cnt, char = heapq.heappop(max_heap) result.append(char) cnt += 1 if cnt < 0: used.append((cnt, char)) for item in used: heapq.heappush(max_heap, item) return ''.join(result)"},{"question":"from typing import List def min_steps_to_reach_goal(n: int, m: int, maze: List[str]) -> int: Determine the minimum number of steps the robot should take to reach the goal in a maze, considering that it can destroy one wall if necessary. >>> min_steps_to_reach_goal(5, 5, [ ... \\".....\\", ... \\".#.\\", ... \\".#.#.\\", ... \\".#.\\", ... \\".....\\" ... ]) 8 >>> min_steps_to_reach_goal(2, 2, [ ... \\"\\", ... \\"\\" ... ]) -1","solution":"from collections import deque def min_steps_to_reach_goal(n, m, maze): # Directions right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # To store the state of (y, x, wall_destroyed) visited = [[[False, False] for _ in range(m)] for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, wall_destroyed) visited[0][0][0] = True steps = 0 while queue: for _ in range(len(queue)): curr_y, curr_x, walls_broken = queue.popleft() if curr_y == n - 1 and curr_x == m - 1: return steps for dy, dx in directions: next_y, next_x = curr_y + dy, curr_x + dx if 0 <= next_y < n and 0 <= next_x < m: if maze[next_y][next_x] == '.' and not visited[next_y][next_x][walls_broken]: visited[next_y][next_x][walls_broken] = True queue.append((next_y, next_x, walls_broken)) if maze[next_y][next_x] == '#' and walls_broken == 0 and not visited[next_y][next_x][1]: visited[next_y][next_x][1] = True queue.append((next_y, next_x, 1)) steps += 1 return -1 # Sample input n = 5 m = 5 maze = [ \\".....\\", \\".#.\\", \\".#.#.\\", \\".#.\\", \\".....\\" ] print(min_steps_to_reach_goal(n, m, maze))"},{"question":"from typing import List def count_pairs_with_target_sum(arr: List[int], target: int) -> int: Determine the number of unique pairs of integers in the array that add up to the target sum. Parameters: arr (List[int]): Array of unique integers. target (int): Target sum to find pairs for. Returns: int: Number of unique pairs that add up to the target sum. Examples: >>> count_pairs_with_target_sum([1, 2, 3, 4, 5], 5) 2 >>> count_pairs_with_target_sum([1, 2, 3], 7) 0 >>> count_pairs_with_target_sum([1, 5, 7, -1, 5, 0, 2, 4, 3], 6) 3","solution":"from typing import List def count_pairs_with_target_sum(arr: List[int], target: int) -> int: Returns the number of unique pairs in the array that add up to the target sum. num_pairs = 0 seen = set() pairs_found = set() for num in arr: complement = target - num if complement in seen and (min(num, complement), max(num, complement)) not in pairs_found: num_pairs += 1 pairs_found.add((min(num, complement), max(num, complement))) seen.add(num) return num_pairs"},{"question":"def can_reach_target_in_n_operations(n: int, k: int) -> str: Determine if it's possible to make either a or b equal to k using exactly n operations. Parameters ---------- n : int The number of operations available. k : int The target value to achieve with either a or b. Returns ------- str \\"YES\\" if possible, \\"NO\\" otherwise. Examples -------- >>> can_reach_target_in_n_operations(5, 8) \\"YES\\" >>> can_reach_target_in_n_operations(3, 5) \\"NO\\"","solution":"def can_reach_target_in_n_operations(n, k): Determine if it's possible to make either a or b equal to k using exactly n operations. Parameters ---------- n : int The number of operations available. k : int The target value to achieve with either a or b. Returns ------- str \\"YES\\" if possible, \\"NO\\" otherwise. def is_possible(value, steps_left): if value == k and steps_left == 0: return True if steps_left == 0 or value > k: return False # Try the three operations return (is_possible(value + 1, steps_left - 1) or is_possible(value * 2, steps_left - 1) or is_possible(0, steps_left - 1)) return \\"YES\\" if is_possible(0, n) else \\"NO\\""},{"question":"def smallest_subsequence(S: str) -> str: Returns the lexicographically smallest subsequence of \`S\` that contains all distinct characters of \`S\` exactly once. >>> smallest_subsequence(\\"bcabc\\") == \\"abc\\" >>> smallest_subsequence(\\"cbacdcbc\\") == \\"acdb\\" >>> smallest_subsequence(\\"\\") == \\"\\" >>> smallest_subsequence(\\"a\\") == \\"a\\" >>> smallest_subsequence(\\"abcd\\") == \\"abcd\\" >>> smallest_subsequence(\\"abacb\\") == \\"abc\\" >>> smallest_subsequence(\\"babca\\") == \\"abc\\"","solution":"def smallest_subsequence(S): Returns the lexicographically smallest subsequence of \`S\` that contains all distinct characters of \`S\` exactly once. last_occurrence = {char: i for i, char in enumerate(S)} stack = [] seen = set() for i, char in enumerate(S): if char in seen: continue # Ensure characters on stack will form the smallest lexicographical order while stack and char < stack[-1] and i < last_occurrence[stack[-1]]: seen.remove(stack.pop()) stack.append(char) seen.add(char) return \\"\\".join(stack)"},{"question":"def merge_and_sort_dicts(dict1: Dict[str, int], dict2: Dict[str, int]) -> Dict[str, int]: Merges two dictionaries and returns a sorted dictionary by values in descending order. If values are equal, sorts the keys alphabetically. >>> merge_and_sort_dicts({\\"a\\": 10, \\"b\\": 15}, {\\"b\\": 5, \\"c\\": 7}) {'b': 20, 'a': 10, 'c': 7} >>> merge_and_sort_dicts({\\"x\\": 1, \\"y\\": 2}, {\\"x\\": 2, \\"z\\": 3}) {'z': 3, 'y': 2, 'x': 3} >>> merge_and_sort_dicts({}, {\\"a\\": 1}) {'a': 1} >>> merge_and_sort_dicts({\\"a\\": 5}, {}) {'a': 5}","solution":"def merge_and_sort_dicts(dict1, dict2): Merges two dictionaries and returns a sorted dictionary by values in descending order. If values are equal, sorts the keys alphabetically. merged_dict = {} # Merge dictionaries for key in dict1: if key in dict2: merged_dict[key] = dict1[key] + dict2[key] else: merged_dict[key] = dict1[key] for key in dict2: if key not in merged_dict: merged_dict[key] = dict2[key] # Sort the dictionary by values (descending) and keys (alphabetically) if values are the same sorted_dict = dict(sorted(merged_dict.items(), key=lambda item: (-item[1], item[0]))) return sorted_dict"},{"question":"def count_subarrays_with_sum_k(arr, k): Returns the total number of unique continuous subarrays whose sum is equal to k. >>> count_subarrays_with_sum_k([1,1,1], 2) 2 >>> count_subarrays_with_sum_k([1,2,3], 3) 2 >>> count_subarrays_with_sum_k([-1,-1,1], 0) 1 >>> count_subarrays_with_sum_k([5], 5) 1 >>> count_subarrays_with_sum_k([5], 0) 0 >>> count_subarrays_with_sum_k([1, 2, 3, 4], 100) 0 >>> count_subarrays_with_sum_k([10, 2, -2, -20, 10], -10) 3 >>> count_subarrays_with_sum_k([0, 0, 0, 0], 0) 10","solution":"def count_subarrays_with_sum_k(arr, k): Returns the total number of unique continuous subarrays whose sum is equal to k. count = 0 cumulative_sum = 0 sum_dict = {0: 1} # Initialize with 0 sum having one count for num in arr: cumulative_sum += num if (cumulative_sum - k) in sum_dict: count += sum_dict[cumulative_sum - k] if cumulative_sum in sum_dict: sum_dict[cumulative_sum] += 1 else: sum_dict[cumulative_sum] = 1 return count"},{"question":"from typing import List, Tuple def find_valid_subgraph(n: int, m: int, degrees: List[int], edges: List[Tuple[int, int]]) -> str: Determine if it's possible to select a subgraph such that each vertex in the subgraph exactly satisfies its degree requirement. :param n: The number of vertices in the graph. :param m: The number of edges in the graph. :param degrees: A list representing the degree requirements of the vertices. :param edges: A list of tuples representing the edges of the graph. :return: \\"YES\\" followed by the list of edges in any valid subgraph if it exists. \\"NO\\" otherwise. Example: >>> find_valid_subgraph(4, 5, [2, 2, 1, 1], [(1, 2), (1, 3), (2, 3), (3, 4), (2, 4)]) \\"YESn1 2n2 3n3 4\\" >>> find_valid_subgraph(3, 2, [2, 2, 2], [(1, 2), (2, 3)]) \\"NO\\"","solution":"def find_valid_subgraph(n, m, degrees, edges): from collections import defaultdict # Initialize necessary structures graph = defaultdict(list) edge_list = [] # Build the adjacency list from the given edges for u, v in edges: graph[u].append(v) graph[v].append(u) # Sort the nodes by their degree requirements sorted_nodes = sorted(range(1, n + 1), key=lambda x: degrees[x - 1], reverse=True) current_degrees = [0] * (n + 1) used_edges = set() def can_add_edge(u, v): if current_degrees[u] < degrees[u - 1] and current_degrees[v] < degrees[v - 1]: if (u, v) not in used_edges and (v, u) not in used_edges: return True return False # Go through the sorted nodes to try and match their degree requirements for u in sorted_nodes: for v in graph[u]: if can_add_edge(u, v): used_edges.add((u, v)) edge_list.append((u, v)) current_degrees[u] += 1 current_degrees[v] += 1 if current_degrees[u] == degrees[u - 1]: break # Check if all nodes meet their degree requirements for node in range(1, n + 1): if current_degrees[node] != degrees[node - 1]: return \\"NO\\" output = [\\"YES\\"] for u, v in edge_list: output.append(f\\"{u} {v}\\") return \\"n\\".join(output) # Example input (can be replaced or modified as needed for testing) n = 4 m = 5 degrees = [2, 2, 1, 1] edges = [(1, 2), (1, 3), (2, 3), (3, 4), (2, 4)] print(find_valid_subgraph(n, m, degrees, edges))"},{"question":"from flask import Flask, request, jsonify app = Flask(__name__) tasks = [] @app.route('/tasks', methods=['GET']) def get_tasks(): Get the list of all tasks. pass @app.route('/tasks', methods=['POST']) def add_task(): Add a new task to the list. pass @app.route('/tasks/<int:task_id>', methods=['PUT']) def update_task(task_id): Update an existing task with the given task_id. pass @app.route('/tasks/<int:task_id>', methods=['DELETE']) def delete_task(task_id): Delete an existing task with the given task_id. pass @app.route('/tasks/<int:task_id>/complete', methods=['PUT']) def complete_task(task_id): Mark an existing task with the given task_id as completed. pass if __name__ == '__main__': app.run(debug=True)","solution":"from flask import Flask, request, jsonify app = Flask(__name__) tasks = [] @app.route('/tasks', methods=['GET']) def get_tasks(): return jsonify(tasks) @app.route('/tasks', methods=['POST']) def add_task(): new_task = request.json if 'id' not in new_task or 'title' not in new_task: return jsonify({'error': 'Invalid data'}), 400 tasks.append(new_task) return jsonify(new_task), 201 @app.route('/tasks/<int:task_id>', methods=['PUT']) def update_task(task_id): updated_task = request.json for task in tasks: if task['id'] == task_id: task.update(updated_task) return jsonify(task) return jsonify({'error': 'Task not found'}), 404 @app.route('/tasks/<int:task_id>', methods=['DELETE']) def delete_task(task_id): global tasks tasks = [task for task in tasks if task['id'] != task_id] return jsonify({'result': 'Task deleted'}) @app.route('/tasks/<int:task_id>/complete', methods=['PUT']) def complete_task(task_id): for task in tasks: if task['id'] == task_id: task['completed'] = True return jsonify(task) return jsonify({'error': 'Task not found'}), 404 if __name__ == '__main__': app.run(debug=True)"},{"question":"from typing import List def can_sum(arr: List[int], target: int) -> bool: Determines if there exists a combination of numbers in the array that adds up exactly to the target sum. Each integer in the array can be used only once. >>> can_sum([2, 3, 7, 8, 10], 11) True >>> can_sum([1, 2, 3], 7) False >>> can_sum([1], 1) True >>> can_sum([1], 2) False >>> can_sum([2, 3, 5, 8], 8) True >>> can_sum([1, 2, 3, 5], 10) True >>> can_sum([1, 2, 5, 10, 25], 40) True >>> can_sum([2, 3, 5, 7], 10) True >>> can_sum([2, 3, 5, 8], 50) False >>> can_sum([1, 2, 3, 8], 14) True","solution":"from typing import List def can_sum(arr: List[int], target: int) -> bool: Determines if there exists a combination of numbers in the array that adds up exactly to the target sum. Each integer in the array can be used only once. n = len(arr) # Create a DP array with size target + 1, initialized to False dp = [False] * (target + 1) dp[0] = True # A sum of 0 can always be achieved by selecting no elements # Update the DP array for num in arr: for i in range(target, num - 1, -1): if dp[i - num]: dp[i] = True return dp[target]"},{"question":"def is_well_balanced(n: int, s: str) -> str: Determine if a string is well-balanced according to specific criteria. >>> is_well_balanced(6, \\"ABCACB\\") \\"YES\\" >>> is_well_balanced(7, \\"AABBACB\\") \\"NO\\" >>> is_well_balanced(1, \\"A\\") \\"YES\\" >>> is_well_balanced(1, \\"B\\") \\"YES\\" >>> is_well_balanced(2, \\"AB\\") \\"YES\\" >>> is_well_balanced(3, \\"AAA\\") \\"NO\\" >>> is_well_balanced(6, \\"ACBBCA\\") \\"YES\\"","solution":"def is_well_balanced(n, s): count_A = 0 count_B = 0 count_C = 0 for char in s: if char == 'A': count_A += 1 elif char == 'B': count_B += 1 elif char == 'C': count_C += 1 max_count = max(count_A, count_B, count_C) min_count = min(count_A, count_B, count_C) if max_count - min_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"def traffic_light(T1: int, T2: int, road: str, second: int) -> str: Determines the color of the traffic light for a given road at a specific second after the system starts. Parameters: T1 (int): Duration for the green light on Road A. T2 (int): Duration for the green light on Road B. road (str): Road identifier ('A' or 'B'). second (int): The second at which to check the light color. Returns: str: \\"green\\" if the light is green, \\"red\\" otherwise. >>> traffic_light(5, 7, 'A', 3) \\"green\\" >>> traffic_light(5, 7, 'B', 3) \\"red\\" >>> traffic_light(5, 7, 'A', 6) \\"red\\" >>> traffic_light(5, 7, 'B', 12) \\"green\\"","solution":"def traffic_light(T1, T2, road, second): Determines the color of the traffic light for a given road at a specific second after the system starts. Parameters: T1 (int): Duration for the green light on Road A. T2 (int): Duration for the green light on Road B. road (str): Road identifier ('A' or 'B'). second (int): The second at which to check the light color. Returns: str: \\"green\\" if the light is green, \\"red\\" otherwise. cycle_length = T1 + T2 second_in_cycle = (second - 1) % cycle_length if road == 'A': if second_in_cycle < T1: return \\"green\\" else: return \\"red\\" elif road == 'B': if second_in_cycle < T1: return \\"red\\" else: return \\"green\\" # Example usage #print(traffic_light(5, 7, 'A', 3)) # Output: \\"green\\" #print(traffic_light(5, 7, 'B', 3)) # Output: \\"red\\" #print(traffic_light(5, 7, 'A', 6)) # Output: \\"red\\" #print(traffic_light(5, 7, 'B', 12)) # Output: \\"green\\""},{"question":"def lexicographically_smallest(s: str, k: int) -> str: Returns the lexicographically smallest string after performing exactly k operations on the input string s. >>> lexicographically_smallest('bcda', 1) 'acda' >>> lexicographically_smallest('abc', 2) 'aaa' >>> lexicographically_smallest('xyz', 3) 'aaa' # Your code here def process_test_cases(t: int, test_cases: List[Tuple[str, int]]) -> List[str]: Processes multiple test cases and returns the results. :param t: Number of test cases :param test_cases: List of tuples (s, k) where s is the string and k is the number of operations :returns: List of results for each test case >>> process_test_cases(3, [('bcda', 1), ('abc', 2), ('xyz', 3)]) ['acda', 'aaa', 'aaa'] >>> process_test_cases(2, [('a', 0), ('zaa', 2)]) ['a', 'aaa'] # Your code here","solution":"def lexicographically_smallest(s, k): Returns the lexicographically smallest string after performing exactly k operations on the input string s. # Convert string to a list for easier manipulation s_list = list(s) # Perform k operations for i in range(len(s_list)): if k == 0: break if s_list[i] != 'a': s_list[i] = 'a' k -= 1 return ''.join(s_list) def process_test_cases(t, test_cases): Processes multiple test cases and returns the results. :param t: Number of test cases :param test_cases: List of tuples (s, k) where s is the string and k is the number of operations :returns: List of results for each test case results = [] for s, k in test_cases: results.append(lexicographically_smallest(s, k)) return results"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, perform a zigzag level order traversal of its nodes' values. This function takes the root of a binary tree and returns a list of lists of integers, where each list contains the nodes' values at that level in the zigzag order. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[3], [20, 9], [15, 7]]","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] current_level = deque([root]) left_to_right = True while current_level: level_size = len(current_level) level_nodes = [] for _ in range(level_size): node = current_level.popleft() level_nodes.append(node.val) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) if not left_to_right: level_nodes.reverse() result.append(level_nodes) left_to_right = not left_to_right return result"},{"question":"def find_positions_to_swap(arr: List[int]) -> Tuple[int, int]: Find two adjacent positions i and j (1-based index) such that swapping the elements at these positions will make the array sorted in non-decreasing order. If the array is already sorted, return -1, -1. >>> find_positions_to_swap([1, 3, 2, 4, 5]) (2, 3) >>> find_positions_to_swap([3, 2, 1, 4]) (1, 2) >>> find_positions_to_swap([1, 2, 3]) (-1, -1)","solution":"def find_positions_to_swap(arr): Find two adjacent positions i and j (1-based index) such that swapping the elements at these positions will make the array sorted in non-decreasing order. If the array is already sorted, return -1, -1. n = len(arr) for i in range(n-1): if arr[i] > arr[i+1]: return i+1, i+2 # return 1-based index positions return -1, -1"},{"question":"class NumArray: def __init__(self, nums): Initialize the NumArray with a list of integers. # Your implementation here def update(self, index, val): Update the element at the specified index to the given value. # Your implementation here def sum_range(self, left, right): Compute the sum of the elements in the array from index left to index right inclusive. # Your implementation here def handle_queries(n, nums, queries): Handle a series of queries on the array of integers and return results. >>> handle_queries(5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 3, 10), (2, 2, 5)]) [6, 21] >>> handle_queries(3, [1, 2, 3], [(1, 1, 10), (2, 1, 3)]) [15] def test_simple_case(): assert handle_queries(5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 3, 10), (2, 2, 5)]) == [6, 21] def test_single_update(): assert handle_queries(3, [1, 2, 3], [(1, 1, 10), (2, 1, 3)]) == [15] def test_multiple_sums(): assert handle_queries(5, [1, 2, 3, 4, 5], [(2, 1, 5), (2, 2, 4)]) == [15, 9] def test_large_input(): n = 100000 nums = [x for x in range(1, n+1)] queries = [(2, 1, 100000)] assert handle_queries(n, nums, queries) == [5000050000] def test_update_and_sum(): assert handle_queries(6, [1, 3, 5, 7, 9, 11], [(2, 2, 4), (1, 3, 10), (2, 1, 3)]) == [15, 14]","solution":"class NumArray: def __init__(self, nums): self.nums = nums self.n = len(nums) self.bit = [0] * (self.n + 1) for i, num in enumerate(nums): self._update_bit(i + 1, num) def _update_bit(self, index, val): while index <= self.n: self.bit[index] += val index += index & -index def update(self, index, val): diff = val - self.nums[index] self.nums[index] = val self._update_bit(index + 1, diff) def sum_range(self, left, right): return self._query(right + 1) - self._query(left) def _query(self, index): s = 0 while index > 0: s += self.bit[index] index -= index & -index return s def handle_queries(n, nums, queries): num_array = NumArray(nums) results = [] for query in queries: t, x, y = query if t == 1: num_array.update(x - 1, y) elif t == 2: results.append(num_array.sum_range(x - 1, y - 1)) return results"},{"question":"from typing import List, Tuple def max_path_sum(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Find the maximum sum of node values in any path in a tree. >>> max_path_sum(5, [3, 2, 1, 10, 1], [(1, 2), (2, 3), (3, 4), (3, 5)]) 16 >>> max_path_sum(1, [5], []) 5 >>> max_path_sum(4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) 10 >>> max_path_sum(4, [5, 10, 20, 30], [(1, 2), (1, 3), (1, 4)]) 35 >>> max_path_sum(5, [-10, -20, -30, -40, -50], [(1, 2), (2, 3), (3, 4), (4, 5)]) -10","solution":"def max_path_sum(n, values, edges): from collections import defaultdict # Build the graph from edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) max_sum = float('-inf') def dfs(node, parent): nonlocal max_sum curr_max = values[node - 1] max_child_path = 0 for neighbor in graph[node]: if neighbor != parent: child_sum = dfs(neighbor, node) max_child_path = max(max_child_path, child_sum) curr_max += max_child_path max_sum = max(max_sum, curr_max) return curr_max dfs(1, -1) return max_sum"},{"question":"def max_sum_subarray_k_elements(n: int, k: int, array: List[int]) -> int: Returns the maximum sum of a subarray of length k. >>> max_sum_subarray_k_elements(7, 3, [1, 2, 3, -2, 5, -4, 5]) 6 >>> max_sum_subarray_k_elements(5, 2, [1, 2, 3, 4, 5]) 9 >>> max_sum_subarray_k_elements(6, 3, [-1, -2, -3, -4, -5, -6]) -6 >>> max_sum_subarray_k_elements(8, 4, [1, 4, -1, 2, -1, 2, 1, -3]) 6 >>> max_sum_subarray_k_elements(5, 1, [100, -100, 50, -50, 0]) 100","solution":"def max_sum_subarray_k_elements(n, k, array): Returns the maximum sum of a subarray of length k. # Initialize the sum of the first 'k' elements current_sum = max_sum = sum(array[:k]) # Use the sliding window technique to find the maximum sum of k elements for i in range(k, n): current_sum += array[i] - array[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def max_remix_duration(n, D, durations): Determines the maximum possible length of the remix without exceeding D. :param n: Number of songs :param D: Maximum allowed remix duration :param durations: List of song durations :return: Maximum possible length of the remix >>> max_remix_duration(4, 10, [2, 3, 4, 5]) 10 >>> max_remix_duration(3, 5, [1, 3, 4]) 5 >>> max_remix_duration(5, 7, [5, 1, 3, 4, 2]) 7 >>> max_remix_duration(2, 10, [7, 3]) 10 >>> max_remix_duration(3, 15, [5, 5, 5]) 15 >>> max_remix_duration(3, 1000000000, [1000000000, 1, 2]) 1000000000 >>> max_remix_duration(1, 1, [1]) 1 >>> max_remix_duration(4, 3, [5, 6, 7, 8]) 0","solution":"def max_remix_duration(n, D, durations): Determines the maximum possible length of the remix without exceeding D. :param n: Number of songs :param D: Maximum allowed remix duration :param durations: List of song durations :return: Maximum possible length of the remix from itertools import combinations max_length = 0 # Check combinations of all lengths for r in range(1, n + 1): for combo in combinations(durations, r): total_length = sum(combo) if total_length <= D: max_length = max(max_length, total_length) return max_length"},{"question":"def smallest_replacement_to_keep_max_position(n: int, sequence: List[int]) -> int: Finds the smallest integer that can replace any one of the elements in the sequence such that the position of the first occurrence of the maximum element remains unchanged. >>> smallest_replacement_to_keep_max_position(5, [5, 3, 5, 2, 5]) 1 >>> smallest_replacement_to_keep_max_position(1, [1]) 1 >>> smallest_replacement_to_keep_max_position(4, [2, 2, 2, 2]) 1 >>> smallest_replacement_to_keep_max_position(6, [2, 4, 1, 3, 4, 2]) 1 >>> smallest_replacement_to_keep_max_position(5, [100000, 500, 100, 100000, 10]) 1 >>> smallest_replacement_to_keep_max_position(7, [50, 2, 30, 4, 2, 50, 1]) 1 >>> smallest_replacement_to_keep_max_position(6, [1, 2, 3, 4, 5, 6]) 1 >>> smallest_replacement_to_keep_max_position(6, [1, 2, 3, 5, 2, 1]) 1","solution":"def smallest_replacement_to_keep_max_position(n, sequence): Finds the smallest integer that can replace any one of the elements in the sequence such that the position of the first occurrence of the maximum element remains unchanged. max_element = max(sequence) first_max_index = sequence.index(max_element) # 0-based index of first occurrence of max element # We need to return the smallest integer that doesn't change the first occurrence # Smallest positive integer that can be used is 1 return 1"},{"question":"def can_insert_brackets(s: str) -> str: Determine if it is possible to insert one pair of brackets to make the sequence valid. >>> can_insert_brackets(\\"()()\\") \\"YES\\" >>> can_insert_brackets(\\"((()\\") \\"YES\\" >>> can_insert_brackets(\\"())\\") \\"YES\\" >>> can_insert_brackets(\\"(((\\") \\"NO\\" >>> can_insert_brackets(\\")))\\") \\"NO\\" >>> can_insert_brackets(\\"()\\") \\"YES\\" >>> can_insert_brackets(\\"(()())(\\") \\"YES\\" >>> can_insert_brackets(\\")()(()\\") \\"YES\\" >>> can_insert_brackets(\\"(()\\") \\"YES\\" >>> can_insert_brackets(\\"())\\") \\"YES\\"","solution":"def can_insert_brackets(s): Returns \\"YES\\" if it's possible to insert exactly one pair of brackets to make \`s\` a valid sequence of brackets, otherwise returns \\"NO\\". # Check the current balance and the need for brackets balance = 0 for bracket in s: if bracket == '(': balance += 1 elif bracket == ')': balance -= 1 # If our balance ever goes negative, then there's no way to balance with just one pair if balance < -1: return \\"NO\\" # If the absolute balance is 2 or less, we can balance with just one pair if abs(balance) <= 2: return \\"YES\\" return \\"NO\\""},{"question":"def can_be_palindrome(s: str, l: int, r: int) -> bool: Determine if the substring s[l:r+1] can be rearranged to form a palindrome. >>> can_be_palindrome(\\"aabbcc\\", 1, 4) True >>> can_be_palindrome(\\"aabbcc\\", 2, 5) False >>> can_be_palindrome(\\"aabbcc\\", 3, 6) True >>> can_be_palindrome(\\"aabbcc\\", 1, 6) True def process_queries(n: int, q: int, s: str, queries: List[Tuple[int, int]]) -> List[str]: Process multiple queries to determine if substrings can be rearranged into palindromes. >>> process_queries(6, 4, \\"aabbcc\\", [(1, 4), (2, 5), (3, 6), (1, 6)]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] >>> process_queries(7, 2, \\"aabcdef\\", [(1, 3), (4, 7)]) [\\"YES\\", \\"NO\\"] from typing import List, Tuple # Test cases def test_can_be_palindrome(): assert can_be_palindrome(\\"aabbcc\\", 1, 4) == True assert can_be_palindrome(\\"aabbcc\\", 2, 5) == False assert can_be_palindrome(\\"aabbcc\\", 3, 6) == True assert can_be_palindrome(\\"aabbcc\\", 1, 6) == True assert can_be_palindrome(\\"aabcdef\\", 1, 3) == True assert can_be_palindrome(\\"abcde\\", 1, 5) == False def test_process_queries(): n = 6 q = 4 s = \\"aabbcc\\" queries = [(1, 4), (2, 5), (3, 6), (1, 6)] assert process_queries(n, q, s, queries) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] n = 7 q = 2 s = \\"aabcdef\\" queries = [(1, 3), (4, 7)] assert process_queries(n, q, s, queries) == [\\"YES\\", \\"NO\\"] n = 5 q = 1 s = \\"abcde\\" queries = [(1, 5)] assert process_queries(n, q, s, queries) == [\\"NO\\"]","solution":"def can_be_palindrome(s, l, r): Determine if the substring s[l:r+1] can be rearranged to form a palindrome. # Extract the substring substring = s[l-1:r] # Count the frequencies of each character freq = [0] * 26 for char in substring: freq[ord(char) - ord('a')] += 1 # Count how many characters have an odd frequency odd_count = sum(f % 2 for f in freq) # A substring can be rearranged into a palindrome if it has at most one character with an odd frequency return odd_count <= 1 def process_queries(n, q, s, queries): results = [] for (l, r) in queries: if can_be_palindrome(s, l, r): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_rect_area(heights: List[int]) -> int: Calculate the maximum rectangular area in a histogram represented by heights. :param heights: List[int] - heights of buildings :return: int - maximum rectangular area >>> max_rect_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rect_area([4]) 4 >>> max_rect_area([2, 4]) 4 >>> max_rect_area([4, 2]) 4 >>> max_rect_area([6, 5, 4, 3, 2, 1]) 12 >>> max_rect_area([1, 2, 3, 4, 5, 6]) 12 >>> max_rect_area([3, 3, 3, 3]) 12 >>> max_rect_area([2, 1, 4, 5, 1, 3, 3]) 8 pass","solution":"def max_rect_area(heights): Calculate the maximum rectangular area in a histogram represented by heights. :param heights: List[int] - heights of buildings :return: int - maximum rectangular area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of a number n. pass def distinct_terms_count(x: int, k: int) -> int: Returns the number of distinct terms in the sequence after k iterations starting with x. >>> distinct_terms_count(1, 1) 2 >>> distinct_terms_count(2, 2) 3 >>> distinct_terms_count(13, 2) 3 >>> distinct_terms_count(9, 10) 11 >>> distinct_terms_count(12345678, 3) 4 >>> distinct_terms_count(987, 5) 6 >>> distinct_terms_count(1, 1) 2 >>> distinct_terms_count(5, 3) 4 pass","solution":"def sum_of_digits(n): Returns the sum of the digits of a number n. return sum(int(digit) for digit in str(n)) def distinct_terms_count(x, k): Returns the number of distinct terms in the sequence after k iterations starting with x. sequence = set() current_term = x for _ in range(k): sequence.add(current_term) current_term = int(str(current_term) + str(sum_of_digits(current_term))) sequence.add(current_term) return len(sequence)"},{"question":"def find_smallest_missing_id(ids: List[int]) -> int: Returns the smallest missing positive integer ID from the list of ids. >>> find_smallest_missing_id([3, 4, -1, 1]) == 2 >>> find_smallest_missing_id([1, 2, 0]) == 3 >>> find_smallest_missing_id([7, 8, 9, 11, 12]) == 1 >>> find_smallest_missing_id([1, 2, 3, 4, 5]) == 6 >>> find_smallest_missing_id([2, 3, 4]) == 1 >>> find_smallest_missing_id([1]) == 2 >>> find_smallest_missing_id([1, 1, 1, 1]) == 2 >>> find_smallest_missing_id([2]) == 1 >>> find_smallest_missing_id([]) == 1","solution":"def find_smallest_missing_id(ids): Returns the smallest missing positive integer ID from the list of ids. n = len(ids) # Step 1: Clean the data by replacing negative values and zeros with n+1 for i in range(n): if ids[i] <= 0 or ids[i] > n: ids[i] = n + 1 # Step 2: Mark the present values within the range 1 to n for i in range(n): if abs(ids[i]) <= n: idx = abs(ids[i]) - 1 ids[idx] = -abs(ids[idx]) # Step 3: Find the first positive value's index for i in range(n): if ids[i] > 0: return i + 1 # Step 4: If all values from 1 to n are present, return n + 1 return n + 1"},{"question":"def count_distinct_substrings(s: str) -> int: Given a string consisting of lowercase latin letters, find the number of distinct non-empty substrings. >>> count_distinct_substrings(\\"ab\\") 3 >>> count_distinct_substrings(\\"aaa\\") 3 from solution import count_distinct_substrings def test_single_char_string(): assert count_distinct_substrings(\\"a\\") == 1 def test_two_char_string(): assert count_distinct_substrings(\\"ab\\") == 3 def test_repeating_char_string(): assert count_distinct_substrings(\\"aaa\\") == 3 def test_mixed_char_string(): assert count_distinct_substrings(\\"abc\\") == 6 def test_empty_string(): assert count_distinct_substrings(\\"\\") == 0 def test_longer_string(): assert count_distinct_substrings(\\"abcd\\") == 10 def test_another_repeating_char_string(): assert count_distinct_substrings(\\"abab\\") == 7","solution":"def count_distinct_substrings(s): Returns the number of distinct non-empty substrings of the given string s. substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def range_sum(n: int, q: int, sequence: List[int], queries: List[Tuple[int, int]]) -> List[int]: Return the sum of the integers between the given indices for each query. :param n: int - size of the sequence :param q: int - number of queries :param sequence: list - list of n integers :param queries: list of tuple - list of tuples (l, r) for each query :return: list - list of sums for each query Examples: >>> range_sum(5, 3, [10, 20, 30, 40, 50], [(1, 3), (2, 4), (1, 5)]) [60, 90, 150] >>> range_sum(1, 1, [100], [(1, 1)]) [100]","solution":"def range_sum(n, q, sequence, queries): Returns the sum of the integers between the given indices for each query. :param n: int - size of the sequence :param q: int - number of queries :param sequence: list - list of n integers :param queries: list of tuple - list of tuples (l, r) for each query :return: list - list of sums for each query # Create a prefix sum array prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + sequence[i - 1] # Compute the results for each query results = [] for l, r in queries: # Sum from l to r inclusive results.append(prefix_sums[r] - prefix_sums[l - 1]) return results # Example usage: # n = 5 # q = 3 # sequence = [10, 20, 30, 40, 50] # queries = [(1, 3), (2, 4), (1, 5)] # print(range_sum(n, q, sequence, queries)) # Expected output: # [60, 90, 150]"},{"question":"from collections import defaultdict from typing import List, Tuple def find_ancestors(n: int, m: int, edges: List[Tuple[int, int]]) -> List[int]: Based on the given number of vertices, edges and their directed connections, calculates the number of distinct ancestors for each vertex in the graph. >>> find_ancestors(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3)]) [0, 1, 2, 3, 4, 5] >>> find_ancestors(2, 1, [(1, 2)]) [0, 1] >>> find_ancestors(4, 2, [(1, 2), (3, 4)]) [0, 1, 0, 1] >>> find_ancestors(4, 5, [(1, 2), (2, 4), (3, 4), (1, 3), (1, 4)]) [0, 1, 1, 3] >>> find_ancestors(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)]) [0, 1, 1, 2, 3]","solution":"from collections import defaultdict, deque def find_ancestors(n, m, edges): Based on the given number of vertices, edges and their directed connections, calculates the number of distinct ancestors for each vertex in the graph. graph = defaultdict(list) for u, v in edges: graph[u].append(v) def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return visited ancestors_count = [0] * n for vertex in range(1, n + 1): visited_vertices = set() for possible_ancestor in range(1, n + 1): if possible_ancestor != vertex: reachable_from_ancestor = bfs(possible_ancestor) if vertex in reachable_from_ancestor: visited_vertices.add(possible_ancestor) ancestors_count[vertex - 1] = len(visited_vertices) return ancestors_count"},{"question":"from typing import List, Tuple def unique_paths_with_obstacles(X: int, Y: int, obstacles: List[Tuple[int, int]]) -> int: You are given two integers X and Y representing the dimensions of a 2D grid. The grid consists of cells, each identified by its row and column coordinates. Some cells in the grid are obstacles, which makes them impassable to a traveler. You need to find out the number of unique paths from the top-left corner (0,0) to the bottom-right corner (X-1, Y-1), given that the traveler can only move either down or right at any point in time. >>> unique_paths_with_obstacles(3, 3, [(1, 1)]) 2 >>> unique_paths_with_obstacles(2, 2, [(0, 1), (1, 0)]) 0","solution":"from typing import List, Tuple def unique_paths_with_obstacles(X: int, Y: int, obstacles: List[Tuple[int, int]]) -> int: # Create a grid initialized to 0 grid = [[0] * Y for _ in range(X)] # Set the start point to 1 if it's not an obstacle if (0, 0) in obstacles: return 0 grid[0][0] = 1 # Populate the grid with the number of ways to reach each cell for i in range(X): for j in range(Y): if (i, j) in obstacles: grid[i][j] = 0 # No path through an obstacle else: if i > 0: grid[i][j] += grid[i-1][j] if j > 0: grid[i][j] += grid[i][j-1] return grid[X-1][Y-1]"},{"question":"def extract_keyword_sentences(paragraph: str, keyword: str) -> List[str]: Extracts and returns sentences containing the specified keyword. Args: - paragraph (str): The paragraph to search within. - keyword (str): The keyword to search for. Returns: - List[str]: A list of sentences containing the keyword. >>> extract_keyword_sentences(\\"Alice went to the market. Bob loves programming.\\", \\"Bob\\") [\\"bob loves programming\\"] >>> extract_keyword_sentences(\\"Alice went to the market. Bob loves programming. Carol went to the market too. Bob is a programmer.\\", \\"Bob\\") [\\"bob loves programming\\", \\"bob is a programmer\\"] >>> extract_keyword_sentences(\\"Alice went to the market. Carol went to the market too.\\", \\"Bob\\") [] >>> extract_keyword_sentences(\\"alice went to the Market. Bob loves programming. CAROL went to the market too. bob is a programmer.\\", \\"bob\\") [\\"bob loves programming\\", \\"bob is a programmer\\"] >>> extract_keyword_sentences(\\"Bob went to the market. The market was closed.\\", \\"Bob\\") [\\"bob went to the market\\"] >>> extract_keyword_sentences(\\"Alice went to the market. The programmer is bob.\\", \\"Bob\\") [\\"the programmer is bob\\"] >>> extract_keyword_sentences(\\"bob loves programming. bob and alice work together. alice is learning programming.\\", \\"bob\\") [\\"bob loves programming\\", \\"bob and alice work together\\"] >>> extract_keyword_sentences(\\" Alice went to the market. Bob loves programming. \\", \\"Bob\\") [\\"bob loves programming\\"]","solution":"def extract_keyword_sentences(paragraph, keyword): Extracts and returns sentences containing the specified keyword. Args: - paragraph (str): The paragraph to search within. - keyword (str): The keyword to search for. Returns: - List[str]: A list of sentences containing the keyword. # Convert both paragraph and keyword to lower case for case-insensitive search lower_paragraph = paragraph.lower() lower_keyword = keyword.lower() # Split the paragraph into sentences based on periods sentences = [sentence.strip() for sentence in lower_paragraph.split('.')] # Find sentences that contain the keyword result = [] for sentence in sentences: if lower_keyword in sentence: result.append(sentence.strip()) return result"},{"question":"def preprocess_matrix(matrix): Preprocess the matrix to create an auxiliary sum_matrix where sum_matrix[i][j] contains the sum of elements from (0,0) to (i-1, j-1) in the original matrix. pass def submatrix_sum(sum_matrix, x1, y1, x2, y2): Calculate the sum of elements in the submatrix defined by the corners (x1,y1) and (x2,y2) using the preprocessed sum_matrix. Note: the inputs x1, y1, x2, y2 are expected to be 1-indexed. pass def matrix_query_sums(n, m, matrix, queries): Given a matrix of size n x m and a list of queries, return the sum of elements in the submatrix defined by each query. pass # Unit Tests def test_preprocess_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] assert preprocess_matrix(matrix) == expected def test_submatrix_sum(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] sum_matrix = preprocess_matrix(matrix) assert submatrix_sum(sum_matrix, 1, 1, 2, 2) == 12 assert submatrix_sum(sum_matrix, 2, 2, 3, 3) == 28 assert submatrix_sum(sum_matrix, 1, 1, 3, 3) == 45 assert submatrix_sum(sum_matrix, 2, 1, 3, 2) == 24 def test_matrix_query_sums(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (1, 1, 2, 2), (2, 2, 3, 3) ] expected = [12, 28] assert matrix_query_sums(3, 3, matrix, queries) == expected","solution":"def preprocess_matrix(matrix): Preprocess the matrix to create an auxiliary sum_matrix where sum_matrix[i][j] contains the sum of elements from (0,0) to (i-1, j-1) in the original matrix. n = len(matrix) m = len(matrix[0]) sum_matrix = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n+1): for j in range(1, m+1): sum_matrix[i][j] = (matrix[i-1][j-1] + sum_matrix[i-1][j] + sum_matrix[i][j-1] - sum_matrix[i-1][j-1]) return sum_matrix def submatrix_sum(sum_matrix, x1, y1, x2, y2): Calculate the sum of elements in the submatrix defined by the corners (x1,y1) and (x2,y2) using the preprocessed sum_matrix. Note: the inputs x1, y1, x2, y2 are expected to be 1-indexed. return (sum_matrix[x2][y2] - sum_matrix[x1-1][y2] - sum_matrix[x2][y1-1] + sum_matrix[x1-1][y1-1]) def matrix_query_sums(n, m, matrix, queries): sum_matrix = preprocess_matrix(matrix) result = [] for q in queries: x1, y1, x2, y2 = q result.append(submatrix_sum(sum_matrix, x1, y1, x2, y2)) return result"},{"question":"def max_fun_value(N: int, M: int, grid: List[List[int]]) -> int: Calculate the maximum fun value a visitor can accumulate when navigating from the entrance to the exit in a grid of attractions. >>> max_fun_value(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_fun_value(1, 5, [ ... [1, 2, 3, 4, 5] ... ]) 15 >>> max_fun_value(5, 1, [ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) 15 >>> max_fun_value(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_fun_value(3, 3, [ ... [1, -1, 2], ... [-1, 2, -3], ... [3, -1, 1] ... ]) 3","solution":"def max_fun_value(N, M, grid): # Create a 2D dp array to store the maximum fun value at each cell dp = [[0] * M for _ in range(N)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, M): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, N): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[N - 1][M - 1]"},{"question":"def is_possible_to_arrange_with_k_transitions(n: int, k: int, heights: List[int]) -> str: Returns \\"POSSIBLE\\" if the heights can be arranged with exactly k transitions; otherwise returns \\"IMPOSSIBLE\\". >>> is_possible_to_arrange_with_k_transitions(6, 5, [3, 1, 4, 2, 5, 6]) == \\"POSSIBLE\\" >>> is_possible_to_arrange_with_k_transitions(4, 4, [3, 1, 4, 2]) == \\"IMPOSSIBLE\\" >>> is_possible_to_arrange_with_k_transitions(5, 3, [3, 3, 4, 2, 5]) == \\"POSSIBLE\\" >>> is_possible_to_arrange_with_k_transitions(6, 5, [3, 3, 3, 2, 2, 2]) == \\"IMPOSSIBLE\\" >>> is_possible_to_arrange_with_k_transitions(3, 2, [1, 2, 3]) == \\"POSSIBLE\\"","solution":"def is_possible_to_arrange_with_k_transitions(n, k, heights): Returns \\"POSSIBLE\\" if the heights can be arranged with exactly k transitions; otherwise returns \\"IMPOSSIBLE\\". # Transitions happen between consecutive heights in the list # Minimum transitions possible: 1 (already knew this from constraints) # Maximum transitions possible: n-1 (each height is different from the next) # Check feasibility: if k < 1 or k >= n: return \\"IMPOSSIBLE\\" # Dedupe and sort heights unique_heights = sorted(set(heights)) # If the number of unique heights is less than the required transitions + 1, # it is impossible to have such arrangement if len(unique_heights) < k + 1: return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\""},{"question":"def max_subarray_segment(n: int, arr: List[int]) -> Tuple[int, int]: Determines a segment of a list of integers such that the sum of integers in this segment is the maximum possible. If multiple segments have the same sum, the one that occurs first in the list is returned. Args: n (int): Number of integers in the list. arr (List[int]): The list of integers. Returns: Tuple[int, int]: Two space-separated integers, representing the start and end indices (1-based) of the segment with the maximum sum. Examples: >>> max_subarray_segment(5, [1, -3, 2, 1, -1]) (3, 4) >>> max_subarray_segment(1, [5]) (1, 1)","solution":"def max_subarray_segment(n, arr): Finds the segment of the list that has the largest sum. Parameters: n (int): The number of elements in the array. arr (list of int): The input array of integers. Returns: tuple: A tuple containing the start and end indices (1-based) of the segment. max_sum = -float('inf') current_sum = 0 start_idx = 0 temp_start_idx = 0 end_idx = 0 for i in range(n): current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start_idx = temp_start_idx end_idx = i if current_sum < 0: current_sum = 0 temp_start_idx = i + 1 return (start_idx + 1, end_idx + 1)"},{"question":"def warehouse_operations(operations: List[str]) -> List[int]: Simulate the stack-based robotic arm operations and return results of MAX operations. >>> warehouse_operations([\\"PUSH 5\\", \\"PUSH 3\\", \\"MAX\\", \\"PUSH 7\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"PUSH 8\\", \\"MAX\\", \\"POP\\"]) == [5, 7, 5, 8] from typing import List def test_operations_example(): operations = [ \\"PUSH 5\\", \\"PUSH 3\\", \\"MAX\\", \\"PUSH 7\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"PUSH 8\\", \\"MAX\\", \\"POP\\" ] assert warehouse_operations(operations) == [5, 7, 5, 8] def test_operations_single_push_max(): operations = [ \\"PUSH 10\\", \\"MAX\\" ] assert warehouse_operations(operations) == [10] def test_operations_multiple_push_pop_max(): operations = [ \\"PUSH 2\\", \\"PUSH 4\\", \\"PUSH 8\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"POP\\", \\"MAX\\" ] assert warehouse_operations(operations) == [8, 4, 2] def test_operations_all_pops(): operations = [ \\"PUSH 7\\", \\"PUSH 6\\", \\"PUSH 5\\", \\"POP\\", \\"POP\\", \\"MAX\\" ] assert warehouse_operations(operations) == [7] def test_operations_max_after_each_push(): operations = [ \\"PUSH 1\\", \\"MAX\\", \\"PUSH 3\\", \\"MAX\\", \\"PUSH 2\\", \\"MAX\\", \\"POP\\", \\"MAX\\" ] assert warehouse_operations(operations) == [1, 3, 3, 3]","solution":"def warehouse_operations(operations): stack = [] max_stack = [] results = [] for op in operations: if op.startswith(\\"PUSH\\"): _, x = op.split() x = int(x) stack.append(x) if not max_stack or x >= max_stack[-1]: max_stack.append(x) elif op == \\"POP\\": if stack.pop() == max_stack[-1]: max_stack.pop() elif op == \\"MAX\\": results.append(max_stack[-1]) return results"},{"question":"def distribute_balloons(N: int) -> tuple: Returns a tuple (R, B) where R is the number of red balloons and B is the number of blue balloons such that: - R + B = N - Difference between R and B is minimized - If there are multiple solutions, R <= B >>> distribute_balloons(5) (2, 3) >>> distribute_balloons(7) (3, 4) >>> distribute_balloons(8) (4, 4) >>> distribute_balloons(10) (5, 5) >>> distribute_balloons(1) (0, 1) >>> distribute_balloons(1000000000) (500000000, 500000000)","solution":"def distribute_balloons(N): Returns a tuple (R, B) where R is the number of red balloons and B is the number of blue balloons such that: - R + B = N - Difference between R and B is minimized - If there are multiple solutions, R <= B R = N // 2 B = N - R return (R, B)"},{"question":"def daily_temperatures(temperatures): Given a list of daily temperatures, calculates the number of days until a warmer day for each day in the list. If no warmer day exists, returns 0 for that day. :param temperatures: List of integer daily temperatures. :return: List of integers indicating number of days to wait for a warmer temperature. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([70, 71, 72, 73, 74, 75]) [1, 1, 1, 1, 1, 0] >>> daily_temperatures([75, 74, 73, 72, 71, 70]) [0, 0, 0, 0, 0, 0] >>> daily_temperatures([70, 70, 70, 70]) [0, 0, 0, 0] >>> daily_temperatures([73, 72, 71, 74, 75, 60, 61, 62]) [3, 2, 1, 1, 0, 1, 1, 0] >>> daily_temperatures([70]) [0] >>> daily_temperatures([70, 75]) [1, 0] >>> daily_temperatures([75, 70]) [0, 0]","solution":"def daily_temperatures(temperatures): Given a list of daily temperatures, calculates the number of days until a warmer day for each day in the list. If no warmer day exists, returns 0 for that day. :param temperatures: List of integer daily temperatures. :return: List of integers indicating number of days to wait for a warmer temperature. n = len(temperatures) result = [0] * n stack = [] # this will store indices of temperatures list for current_day in range(n): while stack and temperatures[current_day] > temperatures[stack[-1]]: previous_day = stack.pop() result[previous_day] = current_day - previous_day stack.append(current_day) return result"},{"question":"def min_steps_to_top(n: int, steps: List[int]) -> int: Calculates the minimum number of steps required to reach the top of a staircase. Parameters: - n (int): Number of steps in the staircase. - steps (list of int): List where steps[i] represents the number of ways to reach the ith step. Returns: - int: Minimum number of jumps needed to reach the top of the staircase. >>> min_steps_to_top(5, [1, 1, 1, 1, 1]) 5 >>> min_steps_to_top(5, [2, 5, 1, 1, 1]) 2 >>> min_steps_to_top(1, [1]) 1 >>> min_steps_to_top(4, [4, 4, 4, 4]) 1 >>> min_steps_to_top(5, [1, 2, 3, 4, 5]) 3 >>> min_steps_to_top(5, [5, 4, 3, 2, 1]) 1 >>> min_steps_to_top(5, [0, 2, 3, 0, 1]) inf","solution":"def min_steps_to_top(n, steps): Calculates the minimum number of steps required to reach the top of a staircase. Parameters: - n (int): Number of steps in the staircase. - steps (list of int): List where steps[i] represents the number of ways to reach the ith step. Returns: - int: Minimum number of jumps needed to reach the top of the staircase. if n == 0: return 0 # minimum number of jumps required to reach each position jumps = [float('inf')] * (n + 1) jumps[0] = 0 # Starting point, no jumps needed for i in range(n): max_reach = min(i + steps[i], n) for j in range(i + 1, max_reach + 1): jumps[j] = min(jumps[j], jumps[i] + 1) return jumps[n]"},{"question":"def can_partition_with_difference(n: int, k: int, array: List[int]) -> str: Determine if an array can be partitioned into exactly two non-empty sub-arrays such that the absolute difference between their sums is equal to k. >>> can_partition_with_difference(5, 3, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_partition_with_difference(4, 10, [1, 2, 3, 4]) \\"NO\\"","solution":"def can_partition_with_difference(n, k, array): Determine if a given array can be partitioned into two non-empty subarrays such that the absolute difference between their sums is equal to k. Parameters: - n (int): the length of the array - k (int): the specific value for the absolute difference - array (list of int): the elements of the array Returns: - str: \\"YES\\" if such a partition is possible, otherwise \\"NO\\" total_sum = sum(array) left_sum = 0 for i in range(n - 1): left_sum += array[i] right_sum = total_sum - left_sum if abs(left_sum - right_sum) == k: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Returns a list of the maximum numbers in each sliding window of size k. >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([1], 1) [1] >>> max_sliding_window([2, 2, 2, 2, 2], 3) [2, 2, 2] >>> max_sliding_window([5, 4, 3, 2, 1], 2) [5, 4, 3, 2] >>> max_sliding_window([1, 2, 3, 4, 5], 3) [3, 4, 5] >>> max_sliding_window([3, 1, 4, 1, 5, 9, 2, 6, 5, 4], 10) [9] >>> max_sliding_window([], 0) # invalid case since k can't be zero in a non-empty array [] >>> max_sliding_window([3, 1, 2, 4], 4) [4]","solution":"from collections import deque from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Returns a list of the maximum numbers in each sliding window of size k. if not nums: return [] result = [] q = deque() # indices of elements to be considered in the current window for i in range(len(nums)): # Remove elements not within the sliding window if q and q[0] < i - k + 1: q.popleft() # Remove elements that are smaller than the current element nums[i] # as they are not useful for max calculation while q and nums[q[-1]] < nums[i]: q.pop() # Add current element at the end of deque q.append(i) # Append the current max to result list # The first k-1 windows will not produce any output if i >= k - 1: result.append(nums[q[0]]) return result"},{"question":"def search_range(nums: List[int], target: int) -> List[int]: Returns the starting and ending positions of the given target in the sorted array nums. If the target is not found, returns [-1, -1]. >>> search_range([5, 7, 7, 8, 8, 10], 8) [3, 4] >>> search_range([1, 2, 2, 2, 3], 1) [0, 0] >>> search_range([1, 2, 3, 4, 5], 6) [-1, -1] from solution import search_range def test_search_range_single_element_match(): assert search_range([1], 1) == [0, 0] def test_search_range_single_element_no_match(): assert search_range([1], 2) == [-1, -1] def test_search_range_multiple_elements_match(): assert search_range([5, 7, 7, 8, 8, 10], 8) == [3, 4] def test_search_range_multiple_elements_no_match(): assert search_range([5, 7, 7, 8, 8, 10], 6) == [-1, -1] def test_search_range_target_at_start(): assert search_range([1, 2, 2, 2, 3], 1) == [0, 0] def test_search_range_target_at_end(): assert search_range([1, 2, 2, 2, 3], 3) == [4, 4] def test_search_range_target_repeated(): assert search_range([2, 2, 2, 2, 2], 2) == [0, 4] def test_search_range_no_elements(): assert search_range([], 5) == [-1, -1] def test_search_range_target_not_in_list(): assert search_range([1, 2, 3, 4, 5], 6) == [-1, -1]","solution":"def search_range(nums, target): Returns the starting and ending positions of the given target in the sorted array nums. If the target is not found, returns [-1, -1]. def binary_search_left(nums, target): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] < target: low = mid + 1 else: high = mid - 1 return low def binary_search_right(nums, target): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] <= target: low = mid + 1 else: high = mid - 1 return high left_index = binary_search_left(nums, target) right_index = binary_search_right(nums, target) # Check if target is not in the array if left_index <= right_index and left_index < len(nums) and nums[left_index] == target: return [left_index, right_index] return [-1, -1]"},{"question":"def num_paths(grid: List[List[str]], n: int, m: int) -> int: Given a grid with '0' as walkable cells and '1' as blocked cells, determine the number of distinct paths from the top-left cell to the bottom-right cell by moving only right or down. >>> num_paths([ ... ['0', '0', '0'], ... ['0', '1', '0'], ... ['0', '0', '0']], 3, 3) 2 >>> num_paths([ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0']], 3, 3) 6","solution":"def num_paths(grid, n, m): if grid[0][0] == '1' or grid[n-1][m-1] == '1': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '1': continue if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def longest_fluctuating_segment(t: int, population_counts: List[int]) -> int: Given the number of years t and a list of integers representing the population count at the start of each year, return the length of the longest contiguous segment where the population is either strictly increasing or strictly decreasing. >>> longest_fluctuating_segment(5, [2, 1, 4, 5, 3]) 3 >>> longest_fluctuating_segment(5, [1, 2, 3, 4, 5]) 5","solution":"def longest_fluctuating_segment(t, population_counts): if t == 1: return 1 max_length = 1 current_length = 1 is_increasing = None for i in range(1, t): if population_counts[i] > population_counts[i-1]: if is_increasing == False: current_length = 2 else: current_length += 1 is_increasing = True elif population_counts[i] < population_counts[i-1]: if is_increasing == True: current_length = 2 else: current_length += 1 is_increasing = False else: current_length = 1 is_increasing = None max_length = max(max_length, current_length) return max_length"},{"question":"def isRomanTime(time: str) -> str: Determines if a string represents a valid Roman numeral time in the hh:mm format. >>> isRomanTime(\\"III:XX\\") \\"YES\\" >>> isRomanTime(\\"IX:LV\\") \\"YES\\" >>> isRomanTime(\\"XX:VI\\") \\"NO\\" >>> isRomanTime(\\"I:LX\\") \\"NO\\"","solution":"def isRomanTime(time): valid_hours = {'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII'} valid_minutes = {'0', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI', 'XXVII', 'XXVIII', 'XXIX', 'XXX', 'XXXI', 'XXXII', 'XXXIII', 'XXXIV', 'XXXV', 'XXXVI', 'XXXVII', 'XXXVIII', 'XXXIX', 'XL', 'XLI', 'XLII', 'XLIII', 'XLIV', 'XLV', 'XLVI', 'XLVII', 'XLVIII', 'XLIX', 'L', 'LI', 'LII', 'LIII', 'LIV', 'LV', 'LVI', 'LVII', 'LVIII', 'LIX'} if len(time.split(':')) != 2: return \\"NO\\" hour, minute = time.split(':') if hour in valid_hours and minute in valid_minutes: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def max_in_subgrid(grid: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Function to find max element in each subgrid defined by the queries. grid: List of lists of integers representing the grid. queries: List of tuples with four integers representing top-left and bottom-right coordinates. Returns a list of integers representing the maximum element in each subgrid. pass def test_query_1(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [(1, 1, 2, 2)] assert max_in_subgrid(grid, queries) == [6] def test_query_2(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [(2, 3, 3, 4)] assert max_in_subgrid(grid, queries) == [12] def test_query_multiple(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [(1, 1, 2, 2), (2, 3, 3, 4)] assert max_in_subgrid(grid, queries) == [6, 12] def test_entire_grid(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [(1, 1, 3, 4)] assert max_in_subgrid(grid, queries) == [12] def test_query_single_element(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [(3, 3, 3, 3)] assert max_in_subgrid(grid, queries) == [11] def test_query_row(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [(2, 1, 2, 4)] assert max_in_subgrid(grid, queries) == [8] def test_query_column(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [(1, 4, 3, 4)] assert max_in_subgrid(grid, queries) == [12]","solution":"def max_in_subgrid(grid, queries): Function to find max element in each subgrid defined by the queries. grid: List of lists of integers representing the grid. queries: List of tuples with four integers representing top-left and bottom-right coordinates. Returns a list of integers representing the maximum element in each subgrid. results = [] for r1, c1, r2, c2 in queries: max_val = max( grid[i][j] for i in range(r1 - 1, r2) for j in range(c1 - 1, c2) ) results.append(max_val) return results"},{"question":"from typing import List, Tuple def find_shortest_path(n: int, m: int, edges: List[Tuple[int, int]], start: int, end: int) -> int: Calculates the shortest distance between two nodes in an unweighted graph. Args: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int]]): List of edges where each edge is represented by a tuple (u, v). start (int): The starting node. end (int): The target node. Returns: int: The shortest distance between node start and node end. If there is no path, returns -1. Example: >>> find_shortest_path(6, 7, [(1, 2), (1, 3), (2, 4), (3, 4), (3, 5), (4, 6), (5, 6)], 1, 6) 3 >>> find_shortest_path(4, 2, [(1, 2), (3, 4)], 1, 4) -1","solution":"from collections import deque, defaultdict def find_shortest_path(n, m, edges, start, end): Calculates the shortest distance between two nodes in an unweighted graph. # Build the graph using adjacency list representation graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Perform BFS to find the shortest path from start to end visited = [False] * (n + 1) distance = [0] * (n + 1) queue = deque([start]) visited[start] = True while queue: current = queue.popleft() if current == end: return distance[current] for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True distance[neighbor] = distance[current] + 1 queue.append(neighbor) return -1"},{"question":"def game_winner(n: int) -> str: Determines the winner of the game given the initial number of stones. Parameters: n (int): Initial number of stones, where 1 ≤ n ≤ 10^9. Returns: str: \\"Alice\\" if Alice wins the game, \\"Bob\\" otherwise. >>> game_winner(6) \\"Alice\\" >>> game_winner(5) \\"Bob\\"","solution":"def game_winner(n): Determines the winner of the game given the initial number of stones. Parameters: n (int): Initial number of stones, where 1 ≤ n ≤ 10^9. Returns: str: \\"Alice\\" if Alice wins the game, \\"Bob\\" otherwise. # If there is only one stone left, Alice cannot make a move and loses # If there are more stones, the result depends on the gameplay if n % 2 == 1: return \\"Bob\\" else: return \\"Alice\\""},{"question":"def max_painted_buildings(n: int, m: int, heights: List[int]) -> int: You are given a sequence of integers a1, a2, ..., an, representing the heights of n buildings standing in a row. You have to paint some buildings so that no two adjacent buildings are painted. The goal is to maximize the number of painted buildings while making sure that the height difference between any two painted buildings is at most k. Args: n (int): The number of buildings. m (int): The maximum allowed height difference between any two painted buildings. heights (List[int]): The heights of the buildings. Returns: int: The maximum number of buildings that can be painted while satisfying the conditions. Examples: >>> max_painted_buildings(6, 2, [4, 6, 5, 9, 7, 10]) 3 >>> max_painted_buildings(1, 0, [1]) 1 >>> max_painted_buildings(4, 0, [1, 2, 3, 4]) 1 >>> max_painted_buildings(5, 1, [3, 3, 3, 3, 3]) 3 >>> max_painted_buildings(5, 2, [5, 4, 3, 2, 1]) 3 >>> max_painted_buildings(5, 3, [1, 2, 3, 4, 5]) 3 >>> max_painted_buildings(4, 1, [1, 10, 20, 30]) 1","solution":"def max_painted_buildings(n, m, heights): # Initialize DP array where dp[i] is the max number of buildings painted ending at i dp = [0] * n # Initialize with the first building dp[0] = 1 # If we paint the first building for i in range(1, n): max_paint = 1 # If we only paint the current building # Check all previous positions to see if we can paint this building for j in range(i - 1): if abs(heights[i] - heights[j]) <= m and dp[j] > max_paint - 1: max_paint = dp[j] + 1 dp[i] = max_paint # The result is the maximum value in the dp array return max(dp) # Example usage: # print(max_painted_buildings(6, 2, [4, 6, 5, 9, 7, 10])) # Output: 3"},{"question":"def total_quantity(m: int, t: str, aisles: List[List[Union[int, str]]]) -> int: Returns the total quantity of the specified item across all aisles. Parameters: m (int): Number of aisles. t (str): The item identifier to find. aisles (list of list): Each sublist contains pairs of item identifier and quantities. Returns: int: Total quantity of the item t. >>> total_quantity(3, 'b', [[2, 'a', 5, 'b', 10], [1, 'b', 3], [3, 'a', 2, 'c', 7, 'b', 5]]) 18 >>> total_quantity(1, 'a', [[2, 'a', 4, 'b', 5]]) 4 >>> total_quantity(2, 'd', [[1, 'a', 5], [1, 'b', 3]]) 0 >>> total_quantity(3, 'c', [[1, 'a', 5], [1, 'b', 3], [2, 'a', 1, 'b', 2]]) 0 >>> total_quantity(2, 'b', [[1, 'b', 10000], [1, 'b', 10000]]) 20000 >>> total_quantity(2, 'a', [[0], [0]]) 0 >>> total_quantity(3, 'a', [[2, 'a', 5, 'b', 10], [1, 'a', 3], [3, 'a', 2, 'b', 7, 'c', 5]]) 10","solution":"def total_quantity(m, t, aisles): Returns the total quantity of the specified item across all aisles. Parameters: m (int): Number of aisles. t (str): The item identifier to find. aisles (list of list): Each sublist contains pairs of item identifier and quantities. Returns: int: Total quantity of the item t. total_qty = 0 for aisle in aisles: n_a = aisle[0] items_and_quantities = aisle[1:n_a*2+1] for i in range(0, len(items_and_quantities), 2): item = items_and_quantities[i] quantity = int(items_and_quantities[i+1]) if item == t: total_qty += quantity return total_qty # Example input: # m = 3 # t = 'b' # aisles = [ # [2, 'a', 5, 'b', 10], # [1, 'b', 3], # [3, 'a', 2, 'c', 7, 'b', 5] # ] # print(total_quantity(m, t, aisles)) # Output: 18"},{"question":"def min_rooms_required(events): Determines the minimum number of rooms required to host all events such that no events overlap in the same room. Each event occupies the room from its start time to its end time. Parameters: events (list of tuples): A list of tuples where each tuple contains: (id, start, end) - the unique identifier, start time, and end time of an event. Returns: int: The minimum number of rooms required. def process_input(input_string): Processes the input string to extract the number of events and their details, then determines and returns the minimum number of rooms required. Parameters: input_string (str): A multiline string where the first line contains the integer n, the number of events, and each of the following n lines contains the space-separated integers id, start, and end, representing the unique identifier, start time, and end time of an event. Returns: int: The minimum number of rooms required. import pytest def test_min_rooms_required(): assert min_rooms_required([(1, 0, 30), (2, 5, 10), (3, 15, 20), (4, 25, 40)]) == 2 assert min_rooms_required([(1, 0, 10), (2, 10, 20), (3, 20, 30), (4, 30, 40)]) == 1 assert min_rooms_required([(1, 1, 4), (2, 2, 5), (3, 3, 6), (4, 1, 5)]) == 4 def test_process_input(): input_data = \\"4n1 0 30n2 5 10n3 15 20n4 25 40n\\" assert process_input(input_data) == 2 input_data = \\"4n1 0 10n2 10 20n3 20 30n4 30 40n\\" assert process_input(input_data) == 1 input_data = \\"4n1 1 4n2 2 5n3 3 6n4 1 5n\\" assert process_input(input_data) == 4 if __name__ == \\"__main__\\": pytest.main()","solution":"def min_rooms_required(events): Determines the minimum number of rooms required to host all events such that no events overlap in the same room. Each event occupies the room from its start time to its end time. Parameters: events (list of tuples): A list of tuples where each tuple contains: (id, start, end) - the unique identifier, start time, and end time of an event. Returns: int: The minimum number of rooms required. # Extract the start and end times start_times = sorted([event[1] for event in events]) end_times = sorted([event[2] for event in events]) start_pointer = 0 end_pointer = 0 num_rooms = 0 max_rooms = 0 while start_pointer < len(events): if start_times[start_pointer] < end_times[end_pointer]: num_rooms += 1 start_pointer += 1 max_rooms = max(max_rooms, num_rooms) else: num_rooms -= 1 end_pointer += 1 return max_rooms def process_input(input_string): lines = input_string.split(\\"n\\") n = int(lines[0]) events = [] for i in range(1, n + 1): id, start, end = map(int, lines[i].split()) events.append((id, start, end)) return min_rooms_required(events)"},{"question":"def can_make_exact_moves(n: int, battery: int) -> str: Determines if the car can make exactly n moves with the available battery. Args: n (int): The exact number of moves to make. battery (int): The initial battery level of the car. Returns: str: \\"YES\\" if the car can make exactly n moves, \\"NO\\" otherwise. >>> can_make_exact_moves(5, 6) 'YES' >>> can_make_exact_moves(5, 4) 'NO' >>> can_make_exact_moves(0, 0) 'YES' >>> can_make_exact_moves(0, 5) 'YES' >>> can_make_exact_moves(10000, 10000) 'YES' >>> can_make_exact_moves(10000, 9999) 'NO' >>> can_make_exact_moves(9999, 10000) 'YES' pass","solution":"def can_make_exact_moves(n, battery): Determines if the car can make exactly n moves with the available battery. Args: n (int): The exact number of moves to make. battery (int): The initial battery level of the car. Returns: str: \\"YES\\" if the car can make exactly n moves, \\"NO\\" otherwise. # The car needs exactly n moves and needs at least n battery level for this if n <= battery: return \\"YES\\" else: return \\"NO\\""},{"question":"def has_sequential_identical_digits(n): Helper function to check if a number has sequential identical digits. num_str = str(n) for i in range(len(num_str) - 1): if num_str[i] == num_str[i+1]: return True return False def generate_sequence(k): Generate the first k numbers less than 1000 that do not have sequential identical digits. >>> generate_sequence(10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> generate_sequence(1) [1] >>> generate_sequence(5) [1, 2, 3, 4, 5]","solution":"def has_sequential_identical_digits(n): Helper function to check if a number has sequential identical digits. num_str = str(n) for i in range(len(num_str) - 1): if num_str[i] == num_str[i+1]: return True return False def generate_sequence(k): Generate the first k numbers less than 1000 that do not have sequential identical digits. result = [] n = 1 while len(result) < k: if not has_sequential_identical_digits(n): result.append(n) n += 1 return result # Example call to test the function # print(generate_sequence(10)) # Uncomment to see the result"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcabcabc\\") 3 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. # Dictionary to hold the last positions of each character. char_position = {} # Start of the current substring. start = 0 # Length of the longest substring found. max_length = 0 # Iterate over each character in the string with its index. for i, char in enumerate(s): # If the character is found in the dictionary and is in the current substring. if char in char_position and char_position[char] >= start: # Move the start to one position after the last occurrence of current character. start = char_position[char] + 1 # Update the last position of the character. char_position[char] = i # Calculate the length of the current substring and update max_length if necessary. max_length = max(max_length, i - start + 1) return max_length"},{"question":"def can_be_nearly_sorted(n: int, a: List[int]) -> str: Determine whether it is possible to make the array \\"Nearly Sorted\\" by swapping exactly one pair of adjacent elements. Parameters: n (int): Length of the array a (list): List of integers representing the array a Returns: str: 'YES' if it is possible, 'NO' otherwise # Try swapping adjacent elements and check if the array becomes \\"Nearly Sorted\\" pass def is_nearly_sorted(a: List[int]) -> bool: Check if the array is \\"Nearly Sorted\\". In a \\"Nearly Sorted\\" array, each element is either in its correct position or can be moved to its correct position by one swap with an adjacent element. Parameters: a (list): List of integers representing the array a Returns: bool: True if the array is \\"Nearly Sorted\\", False otherwise pass def test_can_be_nearly_sorted_case1(): assert can_be_nearly_sorted(4, [2, 3, 1, 4]) == 'YES' def test_can_be_nearly_sorted_case2(): assert can_be_nearly_sorted(5, [1, 5, 3, 4, 2]) == 'NO' def test_can_be_nearly_sorted_case3(): assert can_be_nearly_sorted(5, [1, 2, 3, 5, 4]) == 'YES' def test_can_be_nearly_sorted_case4(): assert can_be_nearly_sorted(6, [1, 3, 2, 4, 5, 6]) == 'YES' def test_can_be_nearly_sorted_case5(): assert can_be_nearly_sorted(7, [1, 3, 5, 7, 6, 4, 2]) == 'NO' def test_can_be_nearly_sorted_case6(): assert can_be_nearly_sorted(2, [2, 1]) == 'YES' def test_can_be_nearly_sorted_case7(): assert can_be_nearly_sorted(3, [1, 3, 2]) == 'YES' def test_can_be_nearly_sorted_case8(): assert can_be_nearly_sorted(4, [4, 3, 2, 1]) == 'NO'","solution":"def can_be_nearly_sorted(n, a): Determine whether it is possible to make the array \\"Nearly Sorted\\" by swapping exactly one pair of adjacent elements. Parameters: n (int): Length of the array a (list): List of integers representing the array a Returns: str: 'YES' if it is possible, 'NO' otherwise # Try swapping adjacent elements and check if the array becomes \\"Nearly Sorted\\" for i in range(n-1): a[i], a[i+1] = a[i+1], a[i] if is_nearly_sorted(a): return 'YES' a[i], a[i+1] = a[i+1], a[i] # Swap back return 'NO' def is_nearly_sorted(a): Check if the array is \\"Nearly Sorted\\". In a \\"Nearly Sorted\\" array, each element is either in its correct position or can be moved to its correct position by one swap with an adjacent element. Parameters: a (list): List of integers representing the array a Returns: bool: True if the array is \\"Nearly Sorted\\", False otherwise n = len(a) # Count the number of out-of-order elements out_of_order = 0 for i in range(n - 1): if a[i] > a[i + 1]: out_of_order += 1 if out_of_order > 1: return False return True"},{"question":"def is_robot_back(n: int, instructions: str) -> str: Determines if the robot returns to the initial starting point after completing the sequence of instructions. :param n: int, the number of instructions :param instructions: str, a string of length n consisting only of characters 'U', 'D', 'L', 'R' :return: str, \\"YES\\" if the robot returns to the original point, otherwise \\"NO\\" >>> is_robot_back(8, 'UDLRUDLR') 'YES' >>> is_robot_back(6, 'UUDDLL') 'NO' >>> is_robot_back(0, '') 'YES' >>> is_robot_back(4, 'UDUD') 'YES'","solution":"def is_robot_back(n, instructions): Determines if the robot returns to the initial starting point after completing the sequence of instructions. :param n: int, the number of instructions :param instructions: str, a string of length n consisting only of characters 'U', 'D', 'L', 'R' :return: str, \\"YES\\" if the robot returns to the original point, otherwise \\"NO\\" x, y = 0, 0 # initial position for instruction in instructions: if instruction == 'U': y += 1 elif instruction == 'D': y -= 1 elif instruction == 'L': x -= 1 elif instruction == 'R': x += 1 if x == 0 and y == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def number_of_ways(n: int, m: int, grid: List[str]) -> int: Returns the number of ways to reach the bottom-right corner of the grid from the top-left corner without passing through any obstacles. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[str]): the grid containing '.' and '#' characters Returns: int: number of ways to reach the destination cell Examples: >>> number_of_ways(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> number_of_ways(3, 3, [\\".#.\\", \\".#.\\", \\"...\\"]) 1 >>> number_of_ways(3, 3, [\\".#.\\", \\".\\", \\"...\\"]) 0 >>> number_of_ways(1, 1, [\\".\\"]) 1 >>> number_of_ways(1, 1, [\\"#\\"]) 0 >>> number_of_ways(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 6 >>> number_of_ways(3, 3, [\\"#..\\", \\"...\\", \\"...\\"]) 0 >>> number_of_ways(3, 3, [\\"...\\", \\"...\\", \\"..#\\"]) 0","solution":"def count_paths(grid, n, m): Returns the number of ways to reach the bottom-right corner from the top-left corner without passing through any obstacles. # Initialize dp table with 0s dp = [[0] * m for _ in range(n)] # Start position is (0, 0), initialize accordingly if grid[0][0] == '.': dp[0][0] = 1 else: return 0 # Fill the dp table for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Function to read input and invoke count_paths def number_of_ways(n, m, grid_lines): grid = [list(line) for line in grid_lines] return count_paths(grid, n, m)"},{"question":"def max_batches_to_inspect(widgets: List[int]) -> int: Given a list of integers representing the number of widgets in batches, this function returns the maximum number of consecutive batches the inspection team can inspect where the difference in the number of widgets between two consecutive batches is strictly greater than 1. >>> max_batches_to_inspect([1, 3, 5, 7]) 4 >>> max_batches_to_inspect([1, 2, 3, 4, 5]) 1 >>> max_batches_to_inspect([1, 3, 4, 2, 5]) 3 >>> max_batches_to_inspect([5]) 1 >>> max_batches_to_inspect([3, 1]) 2 >>> max_batches_to_inspect([10, 1, 10, 1, 10]) 5 >>> max_batches_to_inspect([1, 3, 1, 3, 1]) 5 >>> max_batches_to_inspect([2, 2, 2, 2]) 1","solution":"def max_batches_to_inspect(widgets): Given a list of integers representing the number of widgets in batches, this function returns the maximum number of consecutive batches the inspection team can inspect where the difference in the number of widgets between two consecutive batches is strictly greater than 1. n = len(widgets) if n == 0: return 0 # Initialize the max count and current count max_count = 1 # At least one batch can always be inspected current_count = 1 # Iterate through the list of widgets for i in range(1, n): if abs(widgets[i] - widgets[i-1]) > 1: current_count += 1 else: max_count = max(max_count, current_count) current_count = 1 # Compare the max_count one last time for the last segment inspected max_count = max(max_count, current_count) return max_count"},{"question":"def max_rectangle_area_in_histogram(heights): Find the maximum area of a rectangle formed by contiguous buildings where the height of the rectangle is determined by the shortest building in the subarray. :param heights: List of building heights :return: Maximum rectangle area >>> max_rectangle_area_in_histogram([5]) 5 >>> max_rectangle_area_in_histogram([2, 4]) 4 >>> max_rectangle_area_in_histogram([5, 4, 3, 2, 1]) 9 >>> max_rectangle_area_in_histogram([1, 2, 3, 4, 5]) 9 >>> max_rectangle_area_in_histogram([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area_in_histogram([3, 3, 3, 3]) 12 >>> max_rectangle_area_in_histogram([1000000000]) 1000000000","solution":"def max_rectangle_area_in_histogram(heights): Find the maximum area of a rectangle formed by contiguous buildings where the height of the rectangle is determined by the shortest building in the subarray. :param heights: List of building heights :return: Maximum rectangle area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area # Example usage: # heights = [2, 1, 5, 6, 2, 3] # print(max_rectangle_area_in_histogram(heights)) # Outputs 10"},{"question":"def max_flowers_protected(n: int, garden: List[str]) -> int: Determine the maximum number of flowers that can be protected by placing a scarecrow optimally. Parameters: n (int): Dimension of the garden (1 ≤ n ≤ 1000) garden (List[str]): List of strings representing the garden layout where '.' is an empty cell and 'F' is a flower Returns: int: The maximum number of flowers that can be protected Examples: >>> max_flowers_protected(4, [ ... \\"F..F\\", ... \\"..F.\\", ... \\"F...\\", ... \\"....\\" ... ]) 4 >>> max_flowers_protected(3, [ ... \\"F.F\\", ... \\".F.\\", ... \\"F..\\" ... ]) 4","solution":"def max_flowers_protected(n, garden): def count_protection(x, y): if garden[x][y] == 'F': return -1 count = 0 # check in the same row for i in range(n): if garden[x][i] == 'F': count += 1 # check in the same column for i in range(n): if garden[i][y] == 'F': count += 1 # check top-left to bottom-right diagonal for i in range(-min(x, y), n-max(x, y)): if garden[x+i][y+i] == 'F': count += 1 # check top-right to bottom-left diagonal for i in range(-min(x, n-y-1), n-max(x, y+1)): if garden[x+i][y-i] == 'F': count += 1 return count max_flowers = 0 for i in range(n): for j in range(n): max_flowers = max(max_flowers, count_protection(i, j)) return max_flowers"},{"question":"def max_non_adjacent_sum(n, a): Calculate the maximum possible sum of a non-empty subsequence such that no two elements in the subsequence are adjacent in the original array. pass def solve(test_cases): Process multiple test cases >>> solve([(1, [10])]) == [10] >>> solve([(2, [1, 2])]) == [2] >>> solve([(4, [3, 2, 5, 10])]) == [13] >>> solve([(5, [3, 2, 7, 10, 12])]) == [22] >>> solve([(3, [-1, -2, -3])]) == [0] >>> solve([(4, [3, 2, 5, 10]), (3, [-1, -2, -3])]) == [13, 0] >>> solve([(3, [1, 20, 3])]) == [20] >>> solve([(6, [5, 5, 10, 100, 10, 5])]) == [110] pass","solution":"def max_non_adjacent_sum(n, a): if n == 0: return 0 elif n == 1: return max(0, a[0]) prev2 = max(0, a[0]) prev1 = max(prev2, a[1]) if n > 1 else prev2 for i in range(2, n): current = max(prev1, prev2 + a[i]) prev2 = prev1 prev1 = current return prev1 def solve(test_cases): results = [] for n, a in test_cases: results.append(max_non_adjacent_sum(n, a)) return results"},{"question":"def max_difference(nums: List[int]) -> int: Given a list of integers, determine the maximum difference between any two elements in the list. >>> max_difference([1, 2, 3]) 2 >>> max_difference([5, -2, 7, 3]) 9","solution":"def max_difference(nums): Returns the maximum difference between any two elements in the list. max_num = max(nums) min_num = min(nums) return max_num - min_num"},{"question":"def can_compile_daily_summaries(T, test_cases): Determine if Anna can compile the daily summaries within the given total time Parameters: T (int): The number of test cases test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers d and t, representing the number of days and the total time available for that test case Returns: List[str]: A list of strings where each string is \\"YES\\" if Anna can complete the daily summaries within the given total time, or \\"NO\\" otherwise Examples: >>> can_compile_daily_summaries(3, [(3, 10), (2, 8), (2, 1)]) [\\"NO\\", \\"YES\\", \\"NO\\"] >>> can_compile_daily_summaries(1, [(1, 2)]) [\\"YES\\"] >>> can_compile_daily_summaries(1, [(5, 10)]) [\\"NO\\"] >>> can_compile_daily_summaries(1, [(10**5, 10**9)]) [\\"NO\\"] >>> can_compile_daily_summaries(1, [(10**5, 2 * 10**10)]) [\\"YES\\"]","solution":"def can_compile_daily_summaries(T, test_cases): results = [] for d, t in test_cases: if 2 * d * (d + 1) // 2 <= t: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def main(): import sys input = sys.stdin.read data = input().strip().split() T = int(data[0]) test_cases = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(T)] results = can_compile_daily_summaries(T, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def min_operations_to_equal_height(n, heights): Determine the minimum number of operations required to make all stacks the same height. >>> min_operations_to_equal_height(4, [1, 3, 2, 4]) 3 >>> min_operations_to_equal_height(5, [5, 5, 5, 5, 5]) 0 >>> min_operations_to_equal_height(3, [1, 2, 3]) 2 def process_queries(queries): Process a list of queries to find the minimum number of operations for each. >>> process_queries([(4, [1, 3, 2, 4]), (5, [5, 5, 5, 5, 5]), (3, [1, 2, 3])]) [3, 0, 2] >>> process_queries([(6, [1, 1, 1, 6, 6, 6]), (4, [1, 2, 2, 3])]) [3, 2] >>> process_queries([(1, [1000000000]), (2, [2, 3])]) [0, 1]","solution":"def min_operations_to_equal_height(n, heights): from collections import Counter height_count = Counter(heights) max_frequency = max(height_count.values()) return n - max_frequency def process_queries(queries): results = [] for n, heights in queries: results.append(min_operations_to_equal_height(n, heights)) return results"},{"question":"def can_form_palindrome(s: str) -> str: Given a string S consisting of lowercase English letters, determine if it is possible to make it a palindrome by rearranging its characters. A palindrome is a string that reads the same forward and backward. >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"aabbc\\") \\"YES\\" >>> can_form_palindrome(\\"aabbccddde\\") \\"NO\\" >>> can_form_palindrome(\\"a\\") \\"YES\\" >>> can_form_palindrome(\\"abcdefg\\") \\"NO\\" >>> can_form_palindrome(\\"\\") \\"YES\\"","solution":"def can_form_palindrome(s): Determine if it is possible to rearrange the characters of string s to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one character with an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"from typing import List def coinChange(coins: List[int], amount: int) -> int: Function to determine the minimum number of coins needed to make up the given amount. If it is not possible to make up the amount with the given denominations, return -1. :param coins: List[int] - List of coin denominations :param amount: int - Target amount :return: int - Minimum number of coins needed or -1 if not possible >>> coinChange([1, 2, 5], 11) 3 >>> coinChange([2], 3) -1 >>> coinChange([1], 0) 0 >>> coinChange([1], 1) 1 >>> coinChange([1], 2) 2","solution":"def coinChange(coins, amount): Function to determine the minimum number of coins needed to make up the given amount. If it is not possible to make up the amount with the given denominations, return -1. :param coins: List[int] - List of coin denominations :param amount: int - Target amount :return: int - Minimum number of coins needed or -1 if not possible # Initialize dp array where dp[i] will be storing the minimum number of coins # required for amount i. # Initialize all dp values as a large number except for dp[0] = 0. dp = [amount + 1] * (amount + 1) dp[0] = 0 # Iterate over each coin and update the dp table. for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still the initialized value amount + 1, it means # it's not possible to form the amount with given coin denominations. return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"def min_roofs_required(buildings: List[int]) -> int: This function takes in a list of building heights and returns the minimum number of roofs required to cover all the buildings. >>> min_roofs_required([2, 6, 3, 5, 6]) 2 >>> min_roofs_required([1, 1, 1, 1, 1]) 1 >>> min_roofs_required([1, 2, 3, 4, 5]) 5 >>> min_roofs_required([5, 4, 3, 2, 1]) 1 # Write your code here","solution":"def min_roofs_required(buildings): This function takes in a list of building heights and returns the minimum number of roofs required to cover all the buildings. if not buildings: return 0 roofs = 1 max_height = buildings[0] for height in buildings: if height > max_height: max_height = height roofs += 1 return roofs"},{"question":"def generate_problem_sets(n: int, m: int) -> list: Generates n days of problem sets, each with between 1 and m problems, ensuring no consecutive days have identical problem sets. Args: n (int): The number of days. m (int): The maximum number of problems in a day's problem set. Returns: list: A list of lists, where each inner list represents a day's problem set.","solution":"import random def generate_problem_sets(n, m): Generates n days of problem sets, each with between 1 and m problems, ensuring no consecutive days have identical problem sets. Args: n (int): The number of days. m (int): The maximum number of problems in a day's problem set. Returns: list: A list of lists, where each inner list represents a day's problem set. problem_sets = [] for _ in range(n): while True: num_problems = random.randint(1, m) problem_set = random.sample(range(1, m + 1), num_problems) if not problem_sets or problem_sets[-1] != problem_set: problem_sets.append(problem_set) break return problem_sets"},{"question":"from typing import List def medianSlidingWindow(nums: List[int], k: int) -> List[float]: Compute the median of each sliding window of size \`k\` in the array \`nums\`. Args: nums (List[int]): An array of integers. k (int): An integer representing the window size. Returns: List[float]: An array of the medians. >>> medianSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3) [1.0, -1.0, -1.0, 3.0, 5.0, 6.0] >>> medianSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 1) [1.0, 3.0, -1.0, -3.0, 5.0, 3.0, 6.0, 7.0] >>> medianSlidingWindow([2, 2, 2, 2, 2], 2) [2.0, 2.0, 2.0, 2.0] >>> medianSlidingWindow([1, 4, 2, 3], 2) [2.5, 3.0, 2.5] >>> medianSlidingWindow(list(range(100000)), 3) [(i + 1.0) for i in range(99998)]","solution":"import bisect def medianSlidingWindow(nums, k): def find_median(window): n = len(window) mid = n // 2 if n % 2 == 1: return float(window[mid]) else: return (window[mid - 1] + window[mid]) / 2 result = [] window = sorted(nums[:k]) for i in range(k, len(nums) + 1): result.append(find_median(window)) if i < len(nums): window.remove(nums[i - k]) bisect.insort(window, nums[i]) return result"},{"question":"from typing import List class SubarrayMean: A class that preprocesses an array and answers the queries for mean of subarrays efficiently. Attributes: prefix_sum (List[int]): A list to store the prefix sums of the array elements. Methods: __init__(self, arr: List[int]): Initializes the data structure with the given list \`arr\` of integers. query(self, left: int, right: int) -> float: Returns the mean of the subarray that starts at index \`left\` and ends at index \`right\` (both inclusive). Example: >>> arr = [1, 2, 3, 4, 5] >>> subarray_mean = SubarrayMean(arr) >>> subarray_mean.query(0, 2) 2.0 >>> subarray_mean.query(1, 4) 3.5 >>> subarray_mean.query(2, 2) 3.0 def __init__(self, arr: List[int]): Initializes the data structure with the given list \`arr\` of integers. pass def query(self, left: int, right: int) -> float: Returns the mean of the subarray that starts at index \`left\` and ends at index \`right\` (both inclusive). pass","solution":"from typing import List class SubarrayMean: def __init__(self, arr: List[int]): Initializes the data structure with the given list \`arr\` of integers. self.prefix_sum = [0] * (len(arr) + 1) for i in range(len(arr)): self.prefix_sum[i + 1] = self.prefix_sum[i] + arr[i] def query(self, left: int, right: int) -> float: Returns the mean of the subarray that starts at index \`left\` and ends at index \`right\` (both inclusive). subarray_sum = self.prefix_sum[right + 1] - self.prefix_sum[left] return subarray_sum / (right - left + 1)"},{"question":"def min_danger_path(n: int, m: int, grid: List[List[int]]) -> int: Find the minimum total danger level of a path from the top-left corner to the bottom-right corner of the grid. The friends can move from a cell to an adjacent cell either to the right or down. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): The grid containing danger levels. Returns: int: The minimum total danger level of the safest path. Examples: >>> grid = [ >>> [0, 5, 1], >>> [1, 3, 2], >>> [2, 2, 0] >>> ] >>> min_danger_path(3, 3, grid) 5 >>> grid = [ >>> [1000, 1000, 1000], >>> [1000, 0, 0], >>> [1000, 0, 0] >>> ] >>> min_danger_path(3, 3, grid) 2000","solution":"def min_danger_path(n, m, grid): # Create a 2D list to store the minimum danger level sums for each cell dp = [[0] * m for _ in range(n)] # Initialize the first cell with the grid value dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # Return the value in the bottom-right corner, which is the minimum danger level return dp[n - 1][m - 1]"},{"question":"def construct_tree(n: int) -> str: Construct a tree with \`n\` nodes and the maximum possible diameter. Print \\"NO\\" if such a tree cannot be constructed. Otherwise, print \\"YES\\" followed by \`n - 1\` lines describing the edges of the tree. >>> construct_tree(1) \\"YES\\" >>> construct_tree(2) \\"YESn1 2\\" >>> construct_tree(4) \\"YESn1 2n2 3n3 4\\" >>> construct_tree(10) \\"YESn1 2n2 3n3 4n4 5n5 6n6 7n7 8n8 9n9 10\\" >>> construct_tree(0) \\"NO\\" >>> construct_tree(101) \\"NO\\"","solution":"def construct_tree(n): if n < 1 or n > 100: return \\"NO\\" result = [\\"YES\\"] for i in range(1, n): result.append(f\\"{i} {i + 1}\\") return \\"n\\".join(result)"},{"question":"def max_books_after_distribution(n: int, books: List[int], m: int) -> int: Given the initial number of books in several libraries and a number of additional books to distribute, finds the maximum number of books that a single library can have after the distribution. Parameters: - n (int): The number of libraries. - books (list of int): The initial number of books in each library. - m (int): The number of additional books to distribute. Returns: - int: The maximum number of books in a single library after distribution. >>> max_books_after_distribution(4, [2, 8, 7, 5], 10) 18 >>> max_books_after_distribution(3, [1, 0, 2], 0) 2 >>> max_books_after_distribution(5, [0, 0, 0, 0, 0], 10) 10 >>> max_books_after_distribution(3, [1, 2, 3], 1000000) 1000003 >>> max_books_after_distribution(3, [10, 2, 5], 0) 10","solution":"def max_books_after_distribution(n, books, m): Given the initial number of books in several libraries and a number of additional books to distribute, finds the maximum number of books that a single library can have after the distribution. Parameters: - n (int): The number of libraries. - books (list of int): The initial number of books in each library. - m (int): The number of additional books to distribute. Returns: - int: The maximum number of books in a single library after distribution. max_books_initial = max(books) max_possible_books = max_books_initial + m return max_possible_books"},{"question":"from typing import List, Tuple def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string by performing the allowed operation exactly k times. >>> lexicographically_smallest_string(\\"cba\\", 1) \\"acb\\" >>> lexicographically_smallest_string(\\"cba\\", 2) \\"abc\\" >>> lexicographically_smallest_string(\\"abcde\\", 3) \\"abcde\\" def solve(test_cases: List[Tuple[str, int]]) -> List[str]: Solve the problem for multiple test cases. def test_lexicographically_smallest_string(): assert lexicographically_smallest_string(\\"cba\\", 1) == \\"acb\\" assert lexicographically_smallest_string(\\"cba\\", 2) == \\"abc\\" assert lexicographically_smallest_string(\\"abcde\\", 3) == \\"abcde\\" assert lexicographically_smallest_string(\\"bac\\", 1) == \\"acb\\" assert lexicographically_smallest_string(\\"zzxy\\", 1) == \\"xyzz\\" def test_solve(): test_cases = [(\\"cba\\", 1), (\\"cba\\", 2), (\\"abcde\\", 3)] expected_output = [\\"acb\\", \\"abc\\", \\"abcde\\"] assert solve(test_cases) == expected_output test_cases = [(\\"bac\\", 1), (\\"zzxy\\", 1)] expected_output = [\\"acb\\", \\"xyzz\\"] assert solve(test_cases) == expected_output def test_edge_cases(): assert lexicographically_smallest_string(\\"a\\", 1) == \\"a\\" assert lexicographically_smallest_string(\\"ab\\", 1) == \\"ab\\" assert lexicographically_smallest_string(\\"ba\\", 1) == \\"ab\\" assert lexicographically_smallest_string(\\"ba\\", 2) == \\"ab\\" assert lexicographically_smallest_string(\\"z\\", 10) == \\"z\\"","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string by performing the allowed operation exactly k times. if k == 1: # For k == 1, we can only rotate the string to find the smallest lexicographical order. smallest_string = s for i in range(len(s)): rotated_string = s[i:] + s[:i] if rotated_string < smallest_string: smallest_string = rotated_string return smallest_string else: # For k >= 2, we can sort the string to get the smallest lexicographical order. return ''.join(sorted(s)) def solve(test_cases): results = [] for s, k in test_cases: results.append(lexicographically_smallest_string(s, k)) return results"},{"question":"from typing import List def warehouse_operations(n: int, operations: List[str]) -> List[int]: Simulate a sequence of operations in a warehouse and provide the correct output for each query operation. >>> warehouse_operations(6, [\\"ADD 1 100\\", \\"ADD 2 150\\", \\"REMOVE 1 30\\", \\"QUERY 1\\", \\"REMOVE 2 200\\", \\"QUERY 2\\"]) [70, 0] >>> warehouse_operations(4, [\\"ADD 3 50\\", \\"QUERY 1\\", \\"REMOVE 3 50\\", \\"QUERY 3\\"]) [0, 0] >>> warehouse_operations(3, [\\"ADD 1 10\\", \\"REMOVE 1 20\\", \\"QUERY 1\\"]) [0] >>> warehouse_operations(8, [\\"ADD 1 200\\", \\"ADD 2 500\\", \\"QUERY 2\\", \\"QUERY 1\\", \\"REMOVE 2 100\\", \\"QUERY 2\\", \\"REMOVE 2 500\\", \\"QUERY 2\\"]) [500, 200, 400, 0] >>> warehouse_operations(8, [\\"ADD 1 100\\", \\"REMOVE 1 50\\", \\"QUERY 1\\", \\"ADD 2 30\\", \\"REMOVE 1 100\\", \\"QUERY 1\\", \\"REMOVE 2 20\\", \\"QUERY 2\\"]) [50, 0, 10]","solution":"def warehouse_operations(n, operations): warehouse = {} result = [] for operation in operations: parts = operation.split() op_type = parts[0] item_type = int(parts[1]) if op_type == \\"ADD\\": count = int(parts[2]) if item_type not in warehouse: warehouse[item_type] = 0 warehouse[item_type] += count elif op_type == \\"REMOVE\\": count = int(parts[2]) if item_type in warehouse: warehouse[item_type] = max(0, warehouse[item_type] - count) elif op_type == \\"QUERY\\": result.append(warehouse.get(item_type, 0)) return result"},{"question":"from typing import List, Tuple def max_non_overlapping_games(n: int, games: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping games that can be scheduled. >>> max_non_overlapping_games(6, [(1, 4), (2, 6), (5, 8), (3, 5), (8, 9), (5, 9)]) 3 >>> max_non_overlapping_games(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_games(3, [(1, 10), (2, 9), (3, 8)]) 1 >>> max_non_overlapping_games(5, [(1, 3), (2, 4), (3, 5), (4, 6), (5, 7)]) 3 >>> max_non_overlapping_games(4, [(1, 5), (1, 5), (1, 5), (1, 5)]) 1 >>> max_non_overlapping_games(0, []) 0","solution":"from typing import List, Tuple def max_non_overlapping_games(n: int, games: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping games that can be scheduled. # Sort games by end time games.sort(key=lambda x: x[1]) # Initialize variables max_games = 0 last_end_time = -1 # Iterate through the sorted games for game in games: if game[0] >= last_end_time: # Schedule this game max_games += 1 last_end_time = game[1] return max_games"},{"question":"def count_possible_permutations(n, arr): Count the total number of possible original arrays that could correspond to the corrupted array. Args: n (int): Number of elements. arr (List[int]): Corrupted array of integers. Returns: int: Total number of possible original arrays modulo 1000000007. >>> count_possible_permutations(4, [1, 0, 3, 0]) 2 >>> count_possible_permutations(5, [1, 2, 3, 4, 5]) 1 >>> count_possible_permutations(3, [0, 0, 0]) 6 >>> count_possible_permutations(3, [1, 0, 2]) 1 >>> count_possible_permutations(6, [1, 0, 3, 0, 5, 0]) 6","solution":"MOD = 1000000007 def count_possible_permutations(n, arr): Count the total number of possible original arrays that could correspond to the corrupted array. fact = [1] * (n + 1) inv_fact = [1] * (n + 1) # Precompute factorials and modular inverses for i in range(2, n + 1): fact[i] = fact[i - 1] * i % MOD inv_fact[n] = pow(fact[n], MOD - 2, MOD) for i in range(n - 1, 0, -1): inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD inv_fact[0] = 1 # Identify present and missing numbers present = set() for num in arr: if num != 0: present.add(num) missing = n - len(present) return fact[missing] # Example usage print(count_possible_permutations(4, [1, 0, 3, 0])) # Output: 2"},{"question":"from typing import List, Tuple def max_non_overlapping_events(events: List[Tuple[int, int]]) -> int: Find the maximum number of non-overlapping events a person can attend. >>> max_non_overlapping_events([(1, 4), (2, 5), (3, 6), (7, 8)]) 2 >>> max_non_overlapping_events([(1, 3), (2, 4), (3, 5), (7, 8), (5, 6)]) 4 >>> max_non_overlapping_events([(1, 2), (3, 4), (5, 6), (7, 8)]) 4 >>> max_non_overlapping_events([(1, 5), (2, 6), (3, 7), (4, 8)]) 1 >>> max_non_overlapping_events([(1, 5), (5, 10), (10, 15)]) 3 >>> max_non_overlapping_events([(5, 10)]) 1 >>> max_non_overlapping_events([(i, i + 1) for i in range(1, 24)]) 23 >>> max_non_overlapping_events([(1, 10), (5, 15), (10, 20), (15, 25)]) 2","solution":"from typing import List, Tuple def max_non_overlapping_events(events: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping events a person can attend. # Sort events by their end time events.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping events count = 0 # End time of the last event added to the non-overlapping set last_end_time = 0 for start, end in events: if start >= last_end_time: # If the current event starts after or when the last event ended, # it can be attended. count += 1 last_end_time = end return count"},{"question":"def encrypt_string(s: str) -> str: Encrypt the string by replacing each letter in the string with the letter that is three positions down the alphabet according to the English alphabet. >>> encrypt_string('HelloWorld') 'KhoorZruog' >>> encrypt_string('abcXYZ') 'defABC'","solution":"def encrypt_string(s: str) -> str: encrypted = [] for char in s: if char.islower(): encrypted.append(chr((ord(char) - ord('a') + 3) % 26 + ord('a'))) elif char.isupper(): encrypted.append(chr((ord(char) - ord('A') + 3) % 26 + ord('A'))) return ''.join(encrypted)"},{"question":"def can_form_divisible_number(s: str, m: int) -> str: Determines if it is possible to form a number by removing exactly one character from the string s such that the resulting number is divisible by m. Parameters: s (str): The original string of digits. m (int): The divisor. Returns: str: \\"YES\\" if it is possible, \\"NO\\" otherwise. >>> can_form_divisible_number(\\"123\\", 3) \\"YES\\" >>> can_form_divisible_number(\\"123\\", 7) \\"NO\\" >>> can_form_divisible_number(\\"1234\\", 4) \\"YES\\" >>> can_form_divisible_number(\\"135\\", 10) \\"NO\\" >>> can_form_divisible_number(\\"505\\", 5) \\"YES\\" >>> can_form_divisible_number(\\"1003\\", 12) \\"NO\\" >>> can_form_divisible_number(\\"1002\\", 2) \\"YES\\" >>> can_form_divisible_number(\\"10\\", 5) \\"YES\\" >>> can_form_divisible_number(\\"10\\", 3) \\"YES\\" >>> can_form_divisible_number(\\"123456789\\", 123456) \\"NO\\"","solution":"def can_form_divisible_number(s, m): Determines if it is possible to form a number by removing exactly one character from the string s such that the resulting number is divisible by m. Parameters: s (str): The original string of digits. m (int): The divisor. Returns: str: \\"YES\\" if it is possible, \\"NO\\" otherwise. for i in range(len(s)): new_number_str = s[:i] + s[i+1:] new_number = int(new_number_str) if new_number % m == 0: return \\"YES\\" return \\"NO\\""},{"question":"def shiko_or_tomo(matrix): Determines if Shiko can always make the determinant of the matrix zero, regardless of which element Tomo zeroes out. N = len(matrix) # Implementation goes here # Example usage N = 3 matrix = [ [1, 2, '-'], [3, 4, 5], ['-', 6, 7] ] print(shiko_or_tomo(matrix)) # Output should be \\"Shiko\\" def test_example_case(): N = 3 matrix = [ [1, 2, '-'], [3, 4, 5], ['-', 6, 7] ] assert shiko_or_tomo(matrix) == \\"Shiko\\" def test_case_one_full_known_row(): N = 3 matrix = [ [1, 2, 3], [3, 4, '-'], ['-', 6, 7] ] assert shiko_or_tomo(matrix) == \\"Shiko\\" def test_case_one_full_known_col(): N = 3 matrix = [ [1, '-', 3], [3, 4, 5], [1, 2, 7] ] assert shiko_or_tomo(matrix) == \\"Shiko\\" def test_case_no_full_known_row_or_col(): N = 3 matrix = [ [1, 2, '-'], [3, '-', 5], ['-', 6, 7] ] assert shiko_or_tomo(matrix) == \\"Tomo\\" def test_case_all_unknown(): N = 3 matrix = [ ['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-'] ] assert shiko_or_tomo(matrix) == \\"Tomo\\"","solution":"import numpy as np def shiko_or_tomo(matrix): Determines if Shiko can always make the determinant of the matrix zero, regardless of which element Tomo zeroes out. N = len(matrix) # Check if there is a full row or column of known elements for i in range(N): row_known = all(matrix[i][j] != '-' for j in range(N)) col_known = all(matrix[j][i] != '-' for j in range(N)) if row_known or col_known: return \\"Shiko\\" return \\"Tomo\\" # Example usage N = 3 matrix = [ [1, 2, '-'], [3, 4, 5], ['-', 6, 7] ] print(shiko_or_tomo(matrix)) # Output should be \\"Shiko\\""},{"question":"def calculate_strength(N: int, results: List[str]) -> List[int]: Calculate the strength of each player in the tournament. Args: N : int : Number of players results : List[str] : List of strings representing the results of the matches Returns: List[int] : List of integers representing the strength of each player from player 1 to player N. Example: >>> N = 4 >>> results = [\\"-WLW\\", \\"L-WW\\", \\"WL-W\\", \\"LLL-\\"] >>> calculate_strength(N, results) [1, 1, 1, -3] >>> N = 3 >>> results = [\\"-WW\\", \\"L-W\\", \\"LL-\\"] >>> calculate_strength(N, results) [2, 0, -2] # Function implementation logic goes here","solution":"def calculate_strength(N, results): strengths = [0] * N for i in range(N): for j in range(N): if results[i][j] == 'W': strengths[i] += 1 elif results[i][j] == 'L': strengths[i] -= 1 return strengths"},{"question":"def find_top_scorers(n: int, students: List[Tuple[str, int]]) -> List[str]: This function finds the names of the student(s) with the highest score and returns them sorted alphabetically. :param n: Integer, the number of students :param students: List of tuples, each containing a student's name and score :return: List of names of student(s) with the highest score, sorted alphabetically >>> find_top_scorers(5, [(\\"Alice\\", 95), (\\"Bob\\", 97), (\\"Charlie\\", 97), (\\"Dave\\", 92), (\\"Eve\\", 85)]) == [\\"Bob\\", \\"Charlie\\"] >>> find_top_scorers(1, [(\\"Alice\\", 95)]) == [\\"Alice\\"] >>> find_top_scorers(3, [(\\"Alice\\", 90), (\\"Bob\\", 90), (\\"Charlie\\", 90)]) == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> find_top_scorers(5, [(\\"Alice\\", 97), (\\"Bob\\", 95), (\\"Charlie\\", 94), (\\"Dave\\", 93), (\\"Eve\\", 97)]) == [\\"Alice\\", \\"Eve\\"] >>> find_top_scorers(3, [(\\"Charlie\\", 90), (\\"Bob\\", 90), (\\"Alice\\", 90)]) == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] pass","solution":"def find_top_scorers(n, students): This function finds the names of the student(s) with the highest score and returns them sorted alphabetically. :param n: Integer, the number of students :param students: List of tuples, each containing a student's name and score :return: List of names of student(s) with the highest score, sorted alphabetically if n == 0: return [] scores = {} for name, score in students: scores[name] = int(score) max_score = max(scores.values()) top_students = sorted([name for name, score in scores.items() if score == max_score]) return top_students"},{"question":"def game_winner(n: int, array: List[int]) -> str: Determines if Alice can force a win in the game given the number of elements and the array of elements. If Alice can force a win, return \\"Alice\\", otherwise return \\"Bob\\". >>> game_winner(3, [1, 2, 3]) 'Alice' >>> game_winner(4, [1, 2, 3, 4]) 'Bob' >>> game_winner(1, [1000000000]) 'Alice' >>> game_winner(5, [1, 1, 1, 1, 1]) 'Alice' >>> game_winner(2, [2, 2]) 'Bob' >>> game_winner(6, [5, 3, 7, 2, 1, 4]) 'Bob' >>> game_winner(7, [12, 34, 56, 78, 90, 11, 23]) 'Alice'","solution":"def game_winner(n, array): Determines if Alice can force a win in the game given the number of elements and the array of elements. if n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def count_groups(E: int, M: int, S: int) -> int: Determine the number of ways to form groups consisting of at least one employee from each department. >>> count_groups(3, 2, 4) 24 >>> count_groups(1, 1, 1) 1","solution":"def count_groups(E, M, S): Returns the number of ways to form groups consisting of at least one employee from each department. Parameters: E (int): Number of employees from Engineering (1 ≤ E ≤ 100) M (int): Number of employees from Marketing (1 ≤ M ≤ 100) S (int): Number of employees from Sales (1 ≤ S ≤ 100) Returns: int: The number of ways to form the groups return E * M * S"},{"question":"def print_square_pattern(n: int) -> str: Prints a square pattern of size n x n using the character '*'. >>> print_square_pattern(1) '*' >>> print_square_pattern(2) '**n**' >>> print_square_pattern(3) '***n***n***' >>> print_square_pattern(5) '*****n*****n*****n*****n*****' >>> print_square_pattern(50) ('*' * 50 + 'n') * 49 + '*' * 50","solution":"def print_square_pattern(n): Prints a square pattern of size n x n using the character '*'. Args: n (int): Size of the square pattern. (1 ≤ n ≤ 50) Returns: str: Square pattern of size n x n. return 'n'.join(['*' * n] * n)"},{"question":"from typing import List def longest_zigzag_subsequence(arr: List[int]) -> int: This function takes a list of integers and returns the length of the longest zigzag subsequence. A subsequence is considered zigzag if every two consecutive elements have opposite signs. >>> longest_zigzag_subsequence([1, 2, 3, 4]) 2 >>> longest_zigzag_subsequence([10, 9, 8, 7]) 2 >>> longest_zigzag_subsequence([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag_subsequence([5]) 1 >>> longest_zigzag_subsequence([5, 1]) 2 >>> longest_zigzag_subsequence([1, 6, 2, 8, 3, 9]) 6","solution":"def longest_zigzag_subsequence(arr): This function takes a list of integers and returns the length of the longest zigzag subsequence. A subsequence is considered zigzag if every two consecutive elements have opposite signs. n = len(arr) if n == 0: return 0 # Arrays to store the longest zigzag sequence ending with a sequence going up or down up = [0] * n down = [0] * n up[0] = 1 down[0] = 1 for i in range(1, n): for j in range(i): if arr[i] > arr[j]: up[i] = max(up[i], down[j] + 1) elif arr[i] < arr[j]: down[i] = max(down[i], up[j] + 1) return max(up[n-1], down[n-1])"},{"question":"def cyclic_rotate_right(k: int, s: str) -> str: Perform k cyclic rotations to the right on string s. Parameters: k (int): Number of cyclic rotations. s (str): The input string. Returns: str: The string after k cyclic rotations to the right. >>> cyclic_rotate_right(2, \\"abcdef\\") 'efabcd' >>> cyclic_rotate_right(0, \\"abcdef\\") 'abcdef' >>> cyclic_rotate_right(6, \\"abcdef\\") 'abcdef' >>> cyclic_rotate_right(8, \\"abcdef\\") 'efabcd' >>> cyclic_rotate_right(3, \\"a\\") 'a' >>> cyclic_rotate_right(1, \\"ab\\") 'ba'","solution":"def cyclic_rotate_right(k, s): Perform k cyclic rotations to the right on string s. Parameters: k (int): Number of cyclic rotations. s (str): The input string. Returns: str: The string after k cyclic rotations to the right. n = len(s) k = k % n # Adjusting k to be within the length of the string return s[-k:] + s[:-k]"},{"question":"def max_pairs(n: int, strength: List[int]) -> int: Returns the maximum number of unique pairs of warriors that can form teams. >>> max_pairs(1, [4]) 0 >>> max_pairs(5, [3, 3, 3, 3, 3]) 2 >>> max_pairs(3, [1, 2, 3]) 0 >>> max_pairs(4, [1, 1, 2, 2]) 2 >>> max_pairs(6, [1, 2, 1, 2, 3, 3]) 3 >>> max_pairs(200000, [1] * 200000) 100000","solution":"def max_pairs(n, strength): Returns the maximum number of unique pairs of warriors that can form teams. from collections import Counter # Count the frequency of each strength frequency = Counter(strength) # Calculate the maximum number of pairs pairs = 0 for count in frequency.values(): pairs += count // 2 return pairs"},{"question":"def lexicographically_smallest_string(n: int, s: str) -> str: Returns the lexicographically smallest string that can be obtained by performing any number of removals (possibly zero) on the given string s. >>> lexicographically_smallest_string(7, 'bcabcba') == 'aa' >>> lexicographically_smallest_string(3, 'cba') == 'a' >>> lexicographically_smallest_string(5, 'aaaaa') == 'aaaaa' >>> lexicographically_smallest_string(4, 'bbbb') == 'bbbb' >>> lexicographically_smallest_string(1, 'a') == 'a' >>> lexicographically_smallest_string(2, 'ab') == 'a' >>> lexicographically_smallest_string(10, 'zxcvbnmasd') == 'a' >>> lexicographically_smallest_string(15, 'qwertyasdfgzxcv') == 'a' >>> lexicographically_smallest_string(5, 'abcab') == 'aa' >>> lexicographically_smallest_string(8, 'zyxwvuts') == 's'","solution":"def lexicographically_smallest_string(n, s): Returns the lexicographically smallest string that can be obtained by performing any number of removals (possibly zero) on the given string s. Remove all characters except the smallest character in the string. smallest_char = min(s) smallest_string = \\"\\".join([char for char in s if char == smallest_char]) return smallest_string"},{"question":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring that contains only one unique letter. >>> longest_unique_substring_length(\\"a\\") 1 >>> longest_unique_substring_length(\\"b\\") 1 >>> longest_unique_substring_length(\\"aaaa\\") 4 >>> longest_unique_substring_length(\\"bbbbb\\") 5 >>> longest_unique_substring_length(\\"aaabb\\") 3 >>> longest_unique_substring_length(\\"ababab\\") 1 >>> longest_unique_substring_length(\\"aabbabbaa\\") 2 >>> longest_unique_substring_length(\\"\\") 0 >>> longest_unique_substring_length(\\"aabbb\\") 3 >>> longest_unique_substring_length(\\"abba\\") 2 >>> longest_unique_substring_length(\\"baaaaab\\") 5","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring that contains only one unique letter. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"def can_transform(q: int, test_cases: List[Tuple[int, int, str, str]]) -> List[str]: Determines if one string can be transformed into another by any number of swaps. Parameters: q (int): Number of test cases. test_cases (list): List of test cases where each test case is a tuple in the format (n, m, s, t). Returns: list: List of strings \\"YES\\" or \\"NO\\" corresponding to each test case. >>> can_transform(1, [(3, 4, \\"abc\\", \\"abcd\\")]) [\\"NO\\"] >>> can_transform(1, [(3, 3, \\"abc\\", \\"cba\\")]) [\\"YES\\"] >>> can_transform(2, [(3, 3, \\"abc\\", \\"cba\\"), (4, 4, \\"abcd\\", \\"dcba\\")]) [\\"YES\\", \\"YES\\"] >>> can_transform(1, [(4, 4, \\"abcd\\", \\"abcf\\")]) [\\"NO\\"] >>> can_transform(4, [(3, 3, \\"abc\\", \\"bca\\"), (4, 4, \\"abcd\\", \\"dcba\\"), (4, 4, \\"abcd\\", \\"abcf\\"), (3, 4, \\"abc\\", \\"abcd\\")]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_transform(q, test_cases): Determines if one string can be transformed into another by any number of swaps. Parameters: q (int): Number of test cases. test_cases (list): List of test cases where each test case is a tuple in the format (n, m, s, t). Returns: list: List of strings \\"YES\\" or \\"NO\\" corresponding to each test case. results = [] for case in test_cases: n, m, s, t = case if n != m: results.append(\\"NO\\") elif sorted(s) == sorted(t): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def first_unique_char(s: str) -> str: Returns the first non-repeating character in the string s. If every character repeats, returns an underscore (_). >>> first_unique_char(\\"leetcode\\") 'l' >>> first_unique_char(\\"aabbcc\\") '_' >>> first_unique_char(\\"aabbcddee\\") 'c' >>> first_unique_char(\\"abcd\\") 'a' >>> first_unique_char(\\"loveleetcode\\") 'v' >>> first_unique_char(\\"aabbccddeeffgg1234567890\\") '1' >>> first_unique_char(\\"\\") '_'","solution":"def first_unique_char(s): Returns the first non-repeating character in the string s. If every character repeats, returns an underscore (_). char_count = {} # Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that has only one occurrence for char in s: if char_count[char] == 1: return char return '_'"},{"question":"def find_unique_element(nums: List[int]) -> int: Find the element that appears only once in an array where every other element appears exactly three times. >>> find_unique_element([2, 2, 3, 2]) 3 >>> find_unique_element([0, 1, 0, 1, 0, 1, 99]) 99 from typing import List","solution":"def find_unique_element(nums): Find the element that appears only once in an array where every other element appears exactly three times. ones, twos = 0, 0 for num in nums: # twos holds the bits which appear twice twos |= ones & num # ones holds the bits which appear once ones ^= num # common bit mask for bits which appear thrice threes = ones & twos # remove the bits which appear thrice from ones and twos ones &= ~threes twos &= ~threes return ones"},{"question":"def max_product_of_two(arr): Returns the maximum product of any two distinct elements in the array. If the array has fewer than two elements, returns 0. >>> max_product_of_two([3, 1, 5, 4]) == 20 >>> max_product_of_two([5]) == 0 >>> max_product_of_two([5, 7]) == 35 >>> max_product_of_two([-1, -2]) == 2 >>> max_product_of_two([-10, -20, 1, 2, 3]) == 200 >>> max_product_of_two([-10, 20, 1, 2, 3]) == 60 >>> max_product_of_two([-10, -3, -5, -8]) == 80 >>> max_product_of_two([10**9, -10**9]) == -10**18","solution":"def max_product_of_two(arr): Returns the maximum product of any two distinct elements in the array. If the array has fewer than two elements, returns 0. n = len(arr) if n < 2: return 0 # Sort array in ascending order arr.sort() # Maximum product is either the product of the two largest elements # or the product of the two smallest elements (if they are negative) max_product = max(arr[0] * arr[1], arr[-1] * arr[-2]) return max_product # Example usage arr = [3, 1, 5, 4] print(max_product_of_two(arr)) # Output should be 20"},{"question":"from typing import List, Tuple def max_treasure(n: int, locations: List[Tuple[int, int]]) -> int: Determine the maximum treasure value you can accumulate by visiting the locations in a valid order based on their dependencies. Args: n (int): The number of locations. locations (List[Tuple[int, int]]): A list of tuples where each tuple contains the treasure value and the dependency index of a location. Returns: int: The maximum treasure value that can be accumulated. Example: >>> max_treasure(3, [(5, -1), (10, 0), (15, 1)]) 30 >>> max_treasure(4, [(5, -1), (10, -1), (15, -1), (20, -1)]) 50","solution":"def max_treasure(n, locations): from collections import defaultdict, deque # Build an adjacency list for the graph and in-degrees list adj_list = defaultdict(list) in_degrees = [0] * n for i in range(n): vi, di = locations[i] if di != -1: adj_list[di].append(i) in_degrees[i] += 1 # Initialize the queue with locations that have no dependencies queue = deque() for i in range(n): if in_degrees[i] == 0: queue.append(i) # Process the locations using Kahn's Algorithm (Topological Sort) max_treasure_value = 0 while queue: current = queue.popleft() max_treasure_value += locations[current][0] for neighbor in adj_list[current]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) return max_treasure_value # Example usage (typically this should go in the testing code): n = 3 locations = [(5, -1), (10, 0), (15, 1)] print(max_treasure(n, locations)) # Output: 30"},{"question":"def rotate_string(s: str, k: int) -> str: Rotates the string s to the left by k positions. Parameters: s (str): The input string, consisting of lowercase English letters. k (int): The number of positions to rotate the string left by. Returns: str: The string after rotating it to the left by k positions. Examples: >>> rotate_string(\\"abcdef\\", 2) 'cdefab' >>> rotate_string(\\"xyz\\", 3) 'xyz' >>> rotate_string(\\"hello\\", 10) 'hello'","solution":"def rotate_string(s, k): Rotates the string s to the left by k positions. Parameters: s (str): The input string, consisting of lowercase English letters. k (int): The number of positions to rotate the string left by. Returns: str: The string after rotating it to the left by k positions. length = len(s) if length == 0: return s k = k % length # Handle cases where k >= length of string return s[k:] + s[:k]"},{"question":"def min_subarrays(n: int, a: List[int]) -> int: Divide the array into the minimum number of contiguous subarrays such that each subarray is either strictly increasing or strictly decreasing. >>> min_subarrays(6, [1, 2, 3, 2, 1, 3]) 3 >>> min_subarrays(1, [1]) 1 >>> min_subarrays(5, [1, 2, 3, 4, 5]) 1 >>> min_subarrays(5, [5, 4, 3, 2, 1]) 1 >>> min_subarrays(4, [1, 2, 1, 2]) 3 >>> min_subarrays(2, [1, 1]) 1 >>> min_subarrays(3, [1, 2, 1]) 2 >>> min_subarrays(3, [2, 1, 2]) 2","solution":"def min_subarrays(n, a): if n == 1: return 1 subarray_count = 1 # Start with a single subarray direction = 0 # 0 for no direction, 1 for increasing, -1 for decreasing for i in range(1, n): if a[i] > a[i - 1]: if direction == 0: direction = 1 elif direction == -1: subarray_count += 1 direction = 1 elif a[i] < a[i - 1]: if direction == 0: direction = -1 elif direction == 1: subarray_count += 1 direction = -1 return subarray_count"},{"question":"class ArrayProcessor: def __init__(self, nums): Initialize the ArrayProcessor with the initial list of numbers. self.nums = nums self.n = len(nums) def update(self, index, value): Update the value at the given index with the new value. Args: index (int): The index at which the value needs to be updated. value (int): The new value to be set at the specified index. pass # Implement this function def range_sum(self, left, right): Calculate the sum of elements from index 'left' to index 'right' (inclusive). Args: left (int): The starting index of the range (inclusive). right (int): The ending index of the range (inclusive). Returns: int: The sum of elements in the specified range. pass # Implement this function def process_queries(n, q, nums, queries): Process a list of update and range sum queries on an array of integers. Args: n (int): The number of elements in the initial array. q (int): The number of queries to process. nums (list of int): The initial list of integers. queries (list of str): The list of queries to be processed. Returns: list of int: The results of the range sum queries. Example: >>> n, q = 4, 5 >>> nums = [1, 2, 3, 4] >>> queries = [\\"2 1 3\\", \\"1 2 10\\", \\"2 1 3\\", \\"2 2 4\\", \\"1 4 5\\", \\"2 3 4\\"] >>> process_queries(n, q, nums, queries) [6, 14, 17, 8] pass # Implement this function","solution":"class ArrayProcessor: def __init__(self, nums): self.nums = nums self.n = len(nums) def update(self, index, value): self.nums[index-1] = value def range_sum(self, left, right): return sum(self.nums[left-1:right]) def process_queries(n, q, nums, queries): processor = ArrayProcessor(nums) results = [] for query in queries: parts = query.split() if parts[0] == '1': index = int(parts[1]) value = int(parts[2]) processor.update(index, value) elif parts[0] == '2': left = int(parts[1]) right = int(parts[2]) results.append(processor.range_sum(left, right)) return results"},{"question":"def maxPackValue(n: int, W: int, items: List[Tuple[int, int]]) -> int: Returns the maximum value Alice can carry within her suitcase’s weight capacity. >>> maxPackValue(3, 5, [(2, 3), (3, 4), (4, 5)]) 7 >>> maxPackValue(3, 50, [(10, 60), (20, 100), (30, 120)]) 220","solution":"def maxPackValue(n, W, items): Returns the maximum value that can be obtained within the weight limit W. :param n: int - the number of items :param W: int - the maximum weight capacity of the suitcase :param items: List[Tuple[int, int]] - a list of tuples, each containing the weight and the value of the item :return: int - the maximum possible value of items that can be packed into the suitcase without exceeding the weight capacity # Create a DP array to store the maximum value up to each weight dp = [0] * (W + 1) # Iterate over each item for weight, value in items: # Iterate over the capacity values from W to the weight of current item for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return max(dp) # Example usage: # maxPackValue(3, 5, [(2, 3), (3, 4), (4, 5)]) => 7 # maxPackValue(3, 50, [(10, 60), (20, 100), (30, 120)]) => 220"},{"question":"from typing import List def findMaxWaterContainer(height: List[int]) -> int: Returns the maximum amount of water that the container can store between two blocks. >>> findMaxWaterContainer([1,8,6,2,5,4,8,3,7]) 49 >>> findMaxWaterContainer([1,2,3,4,5,6,7,8,9,10]) 25 >>> findMaxWaterContainer([5,5,5,5,5]) 20 >>> findMaxWaterContainer([10,9,8,7,6,5,4,3,2,1]) 25 >>> findMaxWaterContainer([1,2]) 1 >>> findMaxWaterContainer([4,4,4,4,4,4,4,4,4,4,4,4,4,4,4]) 56 >>> findMaxWaterContainer([10,1,1,1,10,1,1,1,10]) 80","solution":"def findMaxWaterContainer(height): Returns the maximum amount of water that the container can store between two blocks. left = 0 right = len(height) - 1 max_water = 0 while left < right: width = right - left current_height = min(height[left], height[right]) max_water = max(max_water, current_height * width) if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"def minimum_time_to_fix_leaks(n: int, k: int, x: int, a: List[int]) -> int: Calculate the minimum total time required to fix all gas leaks in the street. :param n: Number of houses (1 ≤ n ≤ 1000) :param k: Minutes needed to travel between consecutive houses (1 ≤ k ≤ 1000) :param x: Minutes needed to fix a gas leak in a house (1 ≤ x ≤ 1000) :param a: List of length n indicating which houses have gas leaks (1 for leak, 0 for no leak) :return: Minimum total time required to fix all gas leaks >>> minimum_time_to_fix_leaks(5, 3, 2, [1, 0, 1, 0, 1]) 12 >>> minimum_time_to_fix_leaks(4, 2, 5, [0, 0, 0, 0]) 0 >>> minimum_time_to_fix_leaks(3, 4, 6, [1, 1, 1]) 26 >>> minimum_time_to_fix_leaks(6, 2, 3, [1, 0, 1, 0, 1, 0]) 13 >>> minimum_time_to_fix_leaks(1, 1, 1, [1]) 1 >>> minimum_time_to_fix_leaks(1, 1, 1, [0]) 0","solution":"def minimum_time_to_fix_leaks(n, k, x, a): Calculate the minimum total time required to fix all gas leaks in the street. :param n: Number of houses :param k: Minutes needed to travel between consecutive houses :param x: Minutes needed to fix a gas leak in a house :param a: List indicating which houses have gas leaks (1 for leak, 0 for no leak) :return: Minimum total time required to fix all gas leaks total_time = 0 first = True # To handle the first house with gas leak separately for i in range(n): if a[i] == 1: if first: total_time += x first = False else: total_time += k + x return total_time"},{"question":"def sort_negatives_first(arr: List[int]) -> List[int]: Sort the given list arr such that all negative numbers come before all non-negative numbers (positive numbers and zeroes), while maintaining the original relative order within the negative numbers and within the positive numbers and zeroes. >>> sort_negatives_first([-1, 2, 0, -3, 4, -2, 1, 0]) [-1, -3, -2, 2, 0, 4, 1, 0] >>> sort_negatives_first([0, 2, 1, 4, 3]) [0, 2, 1, 4, 3]","solution":"def sort_negatives_first(arr): Sort the given list arr such that all negative numbers come before all non-negative numbers (positive numbers and zeroes), while maintaining the original relative order within the negative numbers and within the positive numbers and zeroes. negatives = [num for num in arr if num < 0] non_negatives = [num for num in arr if num >= 0] return negatives + non_negatives"},{"question":"from typing import List def min_spell_casts(start: str, target: str, scrolls: List[str]) -> int: Returns the minimum number of spell casts needed to transform start into target using the words in the scrolls. If it's not possible, returns -1. >>> min_spell_casts(\\"hit\\", \\"hot\\", [\\"hit\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 1 >>> min_spell_casts(\\"abc\\", \\"abc\\", [\\"abc\\", \\"def\\", \\"ghi\\"]) 0 >>> min_spell_casts(\\"abc\\", \\"xyz\\", [\\"aaa\\", \\"bbb\\", \\"ccc\\"]) -1 >>> min_spell_casts(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 4 >>> min_spell_casts(\\"hit\\", \\"hot\\", [\\"hot\\"]) 1 >>> min_spell_casts(\\"hit\\", \\"cog\\", [\\"hit\\", \\"log\\", \\"cog\\"]) -1 >>> min_spell_casts(\\"abc\\", \\"abd\\", [\\"abd\\"]) 1 pass # implementation goes here","solution":"from collections import deque def is_one_char_diff(word1, word2): Returns True if word1 and word2 differ by exactly one character. diff_count = 0 for c1, c2 in zip(word1, word2): if c1 != c2: diff_count += 1 if diff_count > 1: return False return diff_count == 1 def min_spell_casts(start, target, scrolls): Returns the minimum number of spell casts needed to transform start into target using the words in the scrolls. If it's not possible, returns -1. if start == target: return 0 scrolls.append(target) word_set = set(scrolls) queue = deque([(start, 0)]) visited = set([start]) while queue: current_word, level = queue.popleft() for word in list(word_set): if word not in visited and is_one_char_diff(current_word, word): if word == target: return level + 1 queue.append((word, level + 1)) visited.add(word) word_set.remove(word) return -1"},{"question":"def kth_smallest_element(N, K, array): Returns the K-th smallest element in the array. :param N: Integer, number of elements in the array :param K: Integer, position of the smallest element to find :param array: List of integers, the array of elements :return: Integer, the K-th smallest element Examples: >>> kth_smallest_element(5, 3, [7, 10, 4, 3, 20]) 7 >>> kth_smallest_element(5, 1, [7, 10, 4, 3, 20]) 3 >>> kth_smallest_element(5, 5, [7, 10, 4, 3, 20]) 20 >>> kth_smallest_element(6, 3, [1, 3, 1, 3, 1, 3]) 1 >>> kth_smallest_element(4, 2, [1000000000, 999999999, 999999998, 999999997]) 999999998 >>> kth_smallest_element(1, 1, [5]) 5","solution":"def kth_smallest_element(N, K, array): Returns the K-th smallest element in the array. :param N: Integer, number of elements in the array :param K: Integer, position of the smallest element to find :param array: List of integers, the array of elements :return: Integer, the K-th smallest element array.sort() return array[K-1]"},{"question":"def time_to_impact(asteroid_coords: list[tuple[int, int]]) -> float: Calculates the time at which the asteroid will impact Earth at (0,0) given a list of its coordinates at various timestamps. Args: - asteroid_coords (list of tuples): coordinates of the asteroid at each timestamp Returns: - float: the time of impact in seconds >>> time_to_impact([(4, 4), (2, 2), (0, 0)]) == 0.00 >>> time_to_impact([(6, 6), (4, 4), (2, 2)]) == 1.00 >>> time_to_impact([(2, 2), (1, 1), (0, 0)]) == 0.00 >>> time_to_impact([(10, 0), (5, 0), (0, 0)]) == 0.00 >>> time_to_impact([(0, 10), (0, 5), (0, 0)]) == 0.00","solution":"def time_to_impact(asteroid_coords): Calculates the time at which the asteroid will impact Earth at (0,0) given a list of its coordinates at various timestamps. Args: - asteroid_coords (list of tuples): coordinates of the asteroid at each timestamp Returns: - float: the time of impact in seconds x1, y1 = asteroid_coords[-2] x2, y2 = asteroid_coords[-1] if x2 == 0 and y2 == 0: return 0.0 vx = x2 - x1 vy = y2 - y1 if vx == 0: time = y2 / vy else: time = x2 / vx return round(abs(time), 2) # Example Usage: # asteroid_coords = [(4, 4), (2, 2), (0, 0)] # print(time_to_impact(asteroid_coords)) # Output: 0.00"},{"question":"def is_path_exists(n: int, m: int, grid: List[str]) -> str: Determines if there is a path from 'S' to 'G' in the given grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): The grid representation with 'S', 'G', '.', '#'. Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. >>> is_path_exists(5, 5, [ \\"S....\\", \\"...\\", \\".#..G\\", \\".#...\\", \\".....\\" ]) \\"YES\\" >>> is_path_exists(4, 4, [ \\"S..#\\", \\"#.\\", \\".#.G\\", \\"..#.\\" ]) \\"NO\\"","solution":"def is_path_exists(n, m, grid): from collections import deque def get_start_and_goal(): start_position = None goal_position = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start_position = (i, j) elif grid[i][j] == 'G': goal_position = (i, j) return start_position, goal_position def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] != '#' start, goal = get_start_and_goal() if not start or not goal: return \\"NO\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([start]) visited = set() visited.add(start) while queue: x, y = queue.popleft() if (x, y) == goal: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def unique_colors(n: int, edges: List[Tuple[int, int, int]]) -> List[int]: For each vertex, determine the number of unique colors on the path from the root to that vertex. Args: n: An integer representing the number of vertices in the tree. edges: A list of tuples, where each tuple contains three integers - two vertices and the color of the edge between them. Returns: A list of integers, where the i-th integer represents the number of unique colors on the path from the root (vertex 1) to vertex i. Example: >>> unique_colors(5, [(1, 2, 3), (1, 3, 2), (3, 4, 3), (3, 5, 7)]) [0, 1, 1, 2, 2] from collections import defaultdict, deque def test_unique_colors_basic(): n = 5 edges = [(1, 2, 3), (1, 3, 2), (3, 4, 3), (3, 5, 7)] expected = [0, 1, 1, 2, 2] assert unique_colors(n, edges) == expected def test_single_node(): n = 1 edges = [] expected = [0] assert unique_colors(n, edges) == expected def test_line_tree(): n = 4 edges = [(1, 2, 1), (2, 3, 2), (3, 4, 1)] expected = [0, 1, 2, 2] assert unique_colors(n, edges) == expected def test_star_shaped_tree(): n = 5 edges = [(1, 2, 1), (1, 3, 2), (1, 4, 3), (1, 5, 4)] expected = [0, 1, 1, 1, 1] assert unique_colors(n, edges) == expected def test_complex_tree(): n = 7 edges = [(1, 2, 1), (1, 3, 2), (2, 4, 2), (2, 5, 3), (3, 6, 4), (3, 7, 1)] expected = [0, 1, 1, 2, 2, 2, 2] assert unique_colors(n, edges) == expected","solution":"def unique_colors(n, edges): from collections import defaultdict, deque # Build the tree as an adjacency list tree = defaultdict(list) for u, v, c in edges: tree[u].append((v, c)) tree[v].append((u, c)) # Result array to store the number of unique colors for each vertex result = [0] * n visited = [False] * (n + 1) def bfs(root): queue = deque([(root, set())]) visited[root] = True while queue: node, colors = queue.popleft() result[node - 1] = len(colors) for neighbor, color in tree[node]: if not visited[neighbor]: visited[neighbor] = True new_colors = colors | {color} queue.append((neighbor, new_colors)) # Start BFS from the root node 1 bfs(1) return result"},{"question":"def max_subset_sum(n: int, k: int, nums: List[int]) -> int: Determine the maximum sum of any subset of the given integers that does not exceed the target integer k. >>> max_subset_sum(5, 11, [4, 5, 6, 7, 8]) 11 >>> max_subset_sum(1, 10, [10]) 10 >>> max_subset_sum(1, 10, [5]) 5 >>> max_subset_sum(3, 5, [6, 7, 8]) 0 >>> max_subset_sum(3, 10, [1, 2, 3]) 6 >>> max_subset_sum(4, 10, [5, 3, 8, 4]) 9 >>> max_subset_sum(5, 10, [1, 2, 3, 4, 9]) 10 >>> max_subset_sum(100, 1, [i for i in range(1, 101)]) 1","solution":"def max_subset_sum(n, k, nums): # Initialize a list to store the maximum possible sum for each value up to k dp = [0] * (k + 1) for num in nums: # Traverse the dp array from right to left so that each number is only used once for j in range(k, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) # The maximum value in dp array is the answer return max(dp)"},{"question":"from typing import List, Dict, Any def max_resources(t: int, test_cases: List[Dict[str, Any]]) -> List[int]: Determine the maximum resources that Nova can collect from any planet along the most resourceful path. >>> max_resources(1, [{'n': 5, 'resources': [10, 20, 30, 40, 50], 'connections': [(1, 2), (1, 3), (3, 4), (4, 5)]}]) == [150] >>> max_resources(2, [{'n': 3, 'resources': [5, 10, 15], 'connections': [(1, 2), (2, 3)]}, {'n': 4, 'resources': [1, 2, 3, 4], 'connections': [(1, 2), (2, 3), (3, 4)]}]) == [30, 10] >>> max_resources(1, [{'n': 2, 'resources': [100, 200], 'connections': [(1, 2)]}]) == [300] >>> max_resources(1, [{'n': 6, 'resources': [1, 2, 3, 4, 5, 1000], 'connections': [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]}]) == [1015]","solution":"from collections import defaultdict, deque def max_resources(t, test_cases): results = [] def bfs_max_resources(n, resources, adj): # Initialize distances from a random node (node 1) with resource sum (using BFS) dist = [-1] * (n + 1) dist[1] = resources[0] queue = deque([1]) max_resource = resources[0] while queue: u = queue.popleft() for v in adj[u]: if dist[v] == -1: dist[v] = dist[u] + resources[v - 1] max_resource = max(max_resource, dist[v]) queue.append(v) # Start second BFS from the farthest node found in the first BFS furthest_node = dist.index(max(dist)) dist = [-1] * (n + 1) dist[furthest_node] = resources[furthest_node - 1] queue = deque([furthest_node]) max_resource = resources[furthest_node - 1] while queue: u = queue.popleft() for v in adj[u]: if dist[v] == -1: dist[v] = dist[u] + resources[v - 1] max_resource = max(max_resource, dist[v]) queue.append(v) return max_resource for case in test_cases: n = case['n'] resources = case['resources'] adj = defaultdict(list) for x, y in case['connections']: adj[x].append(y) adj[y].append(x) results.append(bfs_max_resources(n, resources, adj)) return results"},{"question":"def smallest_subarray_length(arr, n, m): Returns the length of the smallest subarray with a sum greater than or equal to m. If no such subarray exists, returns -1. >>> smallest_subarray_length([2, 3, 1, 2, 4, 3], 6, 7) 2 >>> smallest_subarray_length([1, 2, 3, 4, 5, 4, 5], 7, 7) 2 >>> smallest_subarray_length([1, 2, 3, 4, 5], 5, 15) 5 >>> smallest_subarray_length([1, 2, 3, 4, 5], 5, 16) -1 >>> smallest_subarray_length([10, 10, 10, 10], 4, 20) 2","solution":"def smallest_subarray_length(arr, n, m): Returns the length of the smallest subarray with a sum greater than or equal to m. If no such subarray exists, returns -1. left = 0 curr_sum = 0 min_length = n + 1 # Initialize to a value larger than any possible subarray length for right in range(n): curr_sum += arr[right] while curr_sum >= m: min_length = min(min_length, right - left + 1) curr_sum -= arr[left] left += 1 return min_length if min_length <= n else -1"},{"question":"def min_moves(t: int, cases: List[int]) -> List[int]: Determine the minimum number of moves required to transform an array of zeros into an array containing the numbers 1 to n exactly once. >>> min_moves(3, [1, 2, 3]) [1, 2, 2] >>> min_moves(2, [4, 5]) [2, 3] from typing import List","solution":"def min_moves(t, cases): def moves_to_fill(n): # If n is odd, we need (n + 1) // 2 moves # If n is even, we need n // 2 moves return (n + 1) // 2 results = [] for n in cases: results.append(moves_to_fill(n)) return results"},{"question":"def find_unique_pairs(nums: List[int], target: int) -> int: Given an array of integers nums and an integer target, this function finds the number of unique pairs (i, j) in the array such that nums[i] + nums[j] = target. Pairs (i, j) and (j, i) are considered the same and counted only once, and the elements in the pair should be distinct. >>> find_unique_pairs([1, 2, 3, 4, 3], 6) 2 >>> find_unique_pairs([1, 2, 3, 4], 10) 0 >>> find_unique_pairs([1, 5, 7, -1, 5], 6) 2 >>> find_unique_pairs([0, 0, 0, 0], 0) 1 >>> find_unique_pairs([-1, -2, -3, -4, 5, -5], -5) 2 >>> find_unique_pairs([-3, 1, 4, -1, 3], 0) 2","solution":"def find_unique_pairs(nums, target): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] = target and the pairs are distinct. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def transform_alternating_case(s: str) -> str: Transforms the given string into an \\"alternating case\\" pattern. Non-alphabetic characters remain unchanged. >>> transform_alternating_case(\\"abcdefg\\") 'aBcDeFg' >>> transform_alternating_case(\\"hello world!\\") 'hElLo WoRlD!' >>> transform_alternating_case(\\"abc defg hi\\") 'aBc DeFg Hi' >>> transform_alternating_case(\\"test, test. 123.\\") 'tEsT, tEsT. 123.' >>> transform_alternating_case(\\"pattern_matching\\") 'pAtTeRn_MaTcHiNg' >>> transform_alternating_case(\\"a\\") 'a' >>> transform_alternating_case(\\"b\\") 'b' >>> transform_alternating_case(\\"AbC\\") 'aBc' >>> transform_alternating_case(\\"MiXeD\\") 'mIxEd' >>> transform_alternating_case(\\"\\") '' >>> transform_alternating_case(\\"123!@#\\") '123!@#'","solution":"def transform_alternating_case(s: str) -> str: Transforms the given string into an \\"alternating case\\" pattern. Non-alphabetic characters remain unchanged. result = [] toggle = False for char in s: if char.isalpha(): if toggle: result.append(char.upper()) else: result.append(char.lower()) toggle = not toggle else: result.append(char) return ''.join(result)"},{"question":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle in the histogram. :param heights: List of integers, heights of the histogram's bars. :return: Integer, the area of the largest rectangle.","solution":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle in the histogram. :param heights: List of integers, heights of the histogram's bars. :return: Integer, the area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def distribute_slices(t: int, test_cases: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Determine the number of slices each friend will receive and the total number of friends who can receive slices. Parameters: t (int): the number of test cases test_cases (List[Tuple[int, int]]): a list of tuples where each tuple contains two integers n and m Returns: List[Tuple[int, int]]: a list of tuples where each tuple contains two integers x and y >>> distribute_slices(3, [(10, 3), (20, 4), (7, 2)]) [(3, 3), (5, 4), (3, 2)]","solution":"def distribute_slices(t, test_cases): results = [] for n, m in test_cases: slices_per_friend = n // m max_friends_with_equal_slices = m if m * slices_per_friend <= n else n // slices_per_friend results.append((slices_per_friend, max_friends_with_equal_slices)) return results"},{"question":"def max_ones_after_flip(n, arr): Calculate the maximum number of 1s that can be obtained by flipping a subarray once. Parameters: n (int): The number of elements in the array. arr (list of int): The array containing 0s and 1s. Returns: int: The maximum number of 1s after at most one flip operation. >>> max_ones_after_flip(6, [1, 0, 0, 1, 0, 1]) 5 >>> max_ones_after_flip(5, [1, 1, 1, 1, 1]) 5 >>> max_ones_after_flip(4, [0, 0, 0, 0]) 4","solution":"def max_ones_after_flip(n, arr): Calculate the maximum number of 1s that can be obtained by flipping a subarray once. Parameters: n (int): The number of elements in the array. arr (list of int): The array containing 0s and 1s. Returns: int: The maximum number of 1s after at most one flip operation. total_ones = sum(arr) max_diff = float('-inf') current_diff = 0 for num in arr: value = 1 if num == 0 else -1 current_diff = max(value, current_diff + value) max_diff = max(max_diff, current_diff) max_ones_after_flip = total_ones + max_diff return max(total_ones, max_ones_after_flip) # Example of usage: # print(max_ones_after_flip(6, [1, 0, 0, 1, 0, 1])) # Output: 5"},{"question":"def can_transform(s1: str, s2: str) -> str: Check whether s1 can be transformed into s2 by rearranging the characters and replacing zero or more characters with their lexicographically previous or subsequent character. >>> can_transform(\\"abc\\", \\"cba\\") \\"YES\\" >>> can_transform(\\"abcdef\\", \\"ghijkl\\") \\"NO\\" >>> can_transform(\\"abc\\", \\"abc\\") \\"YES\\" >>> can_transform(\\"acb\\", \\"bac\\") \\"YES\\" >>> can_transform(\\"aabbcc\\", \\"ccccaa\\") \\"YES\\" >>> can_transform(\\"a\\", \\"b\\") \\"YES\\" >>> can_transform(\\"b\\", \\"a\\") \\"YES\\" >>> can_transform(\\"a\\", \\"c\\") \\"NO\\" >>> can_transform(\\"abc\\", \\"abcd\\") \\"NO\\"","solution":"def can_transform(s1, s2): Check whether s1 can be transformed into s2 by rearranging the characters and replacing zero or more characters with their lexicographically previous or subsequent character. if len(s1) != len(s2): return \\"NO\\" for c1, c2 in zip(sorted(s1), sorted(s2)): if abs(ord(c1) - ord(c2)) > 1: return \\"NO\\" return \\"YES\\""},{"question":"def weighted_subarray_sum(n, q, a, queries): For each query, calculate the weighted subarray sum. :param n: Integer, number of elements in array a. :param q: Integer, number of queries. :param a: List, the elements of the array. :param queries: List of tuples, each containing (i, l) for each query. :return: List of integers, the results of each query. results = [] for i, l in queries: subarray_sum = sum(a[i-1:i-1+l]) weighted_sum = subarray_sum * l results.append(weighted_sum) return results # Example usage: n = 5 q = 3 a = [2, 4, 3, 1, 5] queries = [(1, 3), (2, 2), (3, 3)] print(weighted_subarray_sum(n, q, a, queries)) # Output: [27, 14, 27]","solution":"def weighted_subarray_sum(n, q, a, queries): For each query, calculate the weighted subarray sum. :param n: Integer, number of elements in array a. :param q: Integer, number of queries. :param a: List, the elements of the array. :param queries: List of tuples, each containing (i, l) for each query. :return: List of integers, the results of each query. results = [] for i, l in queries: subarray_sum = sum(a[i-1:i-1+l]) weighted_sum = subarray_sum * l results.append(weighted_sum) return results"},{"question":"def find_odd_character(s: str) -> str: Returns the character that appears an odd number of times in the string \`s\`. >>> find_odd_character(\\"aabbccdde\\") 'e' >>> find_odd_character(\\"xxyz\\") 'y'","solution":"def find_odd_character(s): Returns the character that appears an odd number of times in the string \`s\`. from collections import Counter counter = Counter(s) for char, count in counter.items(): if count % 2 != 0: return char"},{"question":"from typing import List def maxRectangleArea(heights: List[int]) -> int: Determine the maximum rectangular area that can be formed using consecutive buildings. Each building has a width of 1 unit. :param heights: List of integers representing the heights of buildings. :return: Maximum rectangular area. Examples: >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> maxRectangleArea([4, 2, 0, 3, 2, 5]) 6 >>> maxRectangleArea([2, 3, 2, 3]) 8 def test_maxRectangleArea_example1(): assert maxRectangleArea([2, 1, 5, 6, 2, 3]) == 10 def test_maxRectangleArea_example2(): assert maxRectangleArea([4, 2, 0, 3, 2, 5]) == 6 def test_maxRectangleArea_example3(): assert maxRectangleArea([2, 3, 2, 3]) == 8 def test_maxRectangleArea_single_building(): assert maxRectangleArea([5]) == 5 def test_maxRectangleArea_two_buildings_same_height(): assert maxRectangleArea([5, 5]) == 10 def test_maxRectangleArea_decreasing_heights(): assert maxRectangleArea([5, 4, 3, 2, 1]) == 9 def test_maxRectangleArea_increasing_heights(): assert maxRectangleArea([1, 2, 3, 4, 5]) == 9 def test_maxRectangleArea_with_zero_height(): assert maxRectangleArea([3, 0, 3, 3]) == 6","solution":"def maxRectangleArea(heights): Returns the maximum rectangular area that can be formed using consecutive buildings. Each building has a width of 1 unit. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_operations_to_make_anagrams(s: str, t: str) -> int: Calculate the minimum number of operations needed to make two strings anagrams of each other. Parameters: s (str): The first input string. t (str): The second input string. Returns: int: The minimum number of operations needed. >>> min_operations_to_make_anagrams(\\"aba\\", \\"baba\\") 1 >>> min_operations_to_make_anagrams(\\"abcde\\", \\"abcde\\") 0 >>> min_operations_to_make_anagrams(\\"abcd\\", \\"efgh\\") 8 >>> min_operations_to_make_anagrams(\\"abc\\", \\"abcd\\") 1 >>> min_operations_to_make_anagrams(\\"aabbcc\\", \\"xxyyzz\\") 12 >>> min_operations_to_make_anagrams(\\"a\\", \\"b\\") 2 >>> min_operations_to_make_anagrams(\\"\\", \\"abc\\") 3 >>> min_operations_to_make_anagrams(\\"abc\\", \\"\\") 3 >>> min_operations_to_make_anagrams(\\"aaabbb\\", \\"ab\\") 4","solution":"def min_operations_to_make_anagrams(s, t): from collections import Counter # Count frequencies of each character in both strings count_s = Counter(s) count_t = Counter(t) # Initialize the number of operations needed operations = 0 # Set of all unique characters in both strings all_chars = set(count_s.keys()).union(set(count_t.keys())) # Calculate the number of changes required for char in all_chars: operations += abs(count_s[char] - count_t[char]) return operations"},{"question":"def longest_sequence(n: int, m: int, grid: List[str]) -> int: Returns the length of the longest sequence of identical characters in the grid. >>> longest_sequence(3, 4, ['abcd', 'eeee', 'abab']) 4 >>> longest_sequence(5, 5, ['abcde', 'fghij', 'klmno', 'pqrst', 'uvwxy']) 1","solution":"def longest_sequence(n, m, grid): Returns the length of the longest sequence of identical characters in the grid. def get_length(grid, n, m, r, c, dr, dc): Utility function to get the maximum length of sequence starting from (r, c) in direction (dr, dc) char = grid[r][c] length = 0 while 0 <= r < n and 0 <= c < m and grid[r][c] == char: length += 1 r += dr c += dc return length max_length = 0 for i in range(n): for j in range(m): max_length = max(max_length, get_length(grid, n, m, i, j, 0, 1), # Horizontal right get_length(grid, n, m, i, j, 1, 0), # Vertical down get_length(grid, n, m, i, j, 1, 1), # Diagonal down-right get_length(grid, n, m, i, j, 1, -1) # Diagonal down-left ) return max_length"},{"question":"def max_subsequence_sum(arr: List[int], m: int) -> int: Returns the maximum possible sum of any subsequence of length exactly m from the array. >>> max_subsequence_sum([1, 2, 3, 4, 5], 3) 12 >>> max_subsequence_sum([-1, -2, -3, -4, -5], 2) -3 >>> max_subsequence_sum([5, -2, 3, 1, 2], 3) 10 >>> max_subsequence_sum([1, 1, 1, 1, 1], 4) 4 >>> max_subsequence_sum([100], 1) 100 >>> max_subsequence_sum([1000000000, 2000000000, -1500000000, 3000000000], 2) 5000000000","solution":"def max_subsequence_sum(arr, m): Returns the maximum possible sum of any subsequence of length exactly m from the array. # Sort the array in descending order sorted_arr = sorted(arr, reverse=True) # Take the first m elements from the sorted array max_subsequence = sorted_arr[:m] # Return the sum of these m elements return sum(max_subsequence) # Example usage # n, m = 5, 3 # arr = [1, 2, 3, 4, 5] # print(max_subsequence_sum(arr, m)) # Output: 12"},{"question":"def countSubarraysWithSum(arr: List[int], target: int) -> int: Calculate the number of contiguous subarrays where the sum of elements is equal to the target value. >>> countSubarraysWithSum([1, 1, 1], 2) 2 >>> countSubarraysWithSum([1, 2, 3], 3) 2 >>> countSubarraysWithSum([3], 3) 1 >>> countSubarraysWithSum([-3], -3) 1 >>> countSubarraysWithSum([3], 2) 0","solution":"def countSubarraysWithSum(arr, target): Returns the number of contiguous subarrays with a sum equal to the target. from collections import defaultdict current_sum = 0 count = 0 prefix_sum_map = defaultdict(int) prefix_sum_map[0] = 1 for num in arr: current_sum += num count += prefix_sum_map[current_sum - target] prefix_sum_map[current_sum] += 1 return count"},{"question":"def calculate_score(tasks_completed: int, time_taken: float) -> float: Calculate the score for a participant based on tasks completed and time taken. Args: tasks_completed (int): The number of tasks successfully completed. time_taken (float): The total time taken in hours. Returns: float: The calculated score for the participant. Example: >>> calculate_score(5, 2.5) 475.0 >>> calculate_score(3, 5.0) 250.0 >>> calculate_score(2, 30.0) 0.0 >>> calculate_score(0, 10.0) 0.0 >>> calculate_score(10, 1.0) 990.0 >>> calculate_score(8, 0.0) 800.0 >>> calculate_score(0, 0.0) 0.0","solution":"def calculate_score(tasks_completed: int, time_taken: float) -> float: Calculate the score for a participant based on tasks completed and time taken. Args: tasks_completed (int): The number of tasks successfully completed. time_taken (float): The total time taken in hours. Returns: float: The calculated score for the participant. points_per_task = 100 deduction_per_hour = 10 score = (tasks_completed * points_per_task) - (time_taken * deduction_per_hour) return max(score, 0)"},{"question":"def generate_ab_string(k: int) -> str: Given an integer k, generate a string s such that: 1. The string s contains only two types of characters: 'A' and 'B'. 2. The length of the string s is exactly 2k. 3. The number of occurrences of the substring \\"AB\\" in string s should be exactly k. If such a string is not possible, return a single line containing -1. >>> generate_ab_string(2) == \\"ABAB\\" >>> generate_ab_string(3) == \\"-1\\"","solution":"def generate_ab_string(k): if k % 2 != 0: return \\"-1\\" return \\"AB\\" * (k // 2)"},{"question":"def min_energy_cost(n: int, m: int, cost: List[List[int]]) -> int: Returns the minimum energy cost to move from the top-left to the bottom-right of the grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. cost (List[List[int]]): The energy cost for each cell in the grid. Returns: int: The minimum energy cost. >>> min_energy_cost(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_energy_cost(1, 1, [[42]]) 42 >>> min_energy_cost(2, 2, [[1, 2], [1, 1]]) 3 >>> min_energy_cost(2, 3, [[1000, 1000, 1000], [1000, 1000, 1000]]) 4000 >>> min_energy_cost(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21","solution":"def min_energy_cost(n, m, cost): Returns the minimum energy cost to move from the top-left to the bottom-right of the grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. cost (List[List[int]]): The energy cost for each cell in the grid. Returns: int: The minimum energy cost. # Initialize a 2D dp array to store the minimum cost to reach each cell dp = [[0] * m for _ in range(n)] # Set the start position's cost dp[0][0] = cost[0][0] # Initialize the first column of the dp array for i in range(1, n): dp[i][0] = dp[i-1][0] + cost[i][0] # Initialize the first row of the dp array for j in range(1, m): dp[0][j] = dp[0][j-1] + cost[0][j] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] # Return the minimum cost to reach the bottom-right corner return dp[-1][-1]"},{"question":"def find_radius(houses: List[int], heaters: List[int]) -> int: Find the minimum radius required to heat all houses. :param houses: List[int], positions of houses sorted in non-decreasing order :param heaters: List[int], positions of heaters sorted in non-decreasing order :return: int, the minimum radius required import bisect import pytest from solution import find_radius def test_example_case(): houses = [1, 2, 3] heaters = [2, 4] assert find_radius(houses, heaters) == 1 def test_case_one_heater_between_houses(): houses = [1, 5, 9] heaters = [5] assert find_radius(houses, heaters) == 4 def test_houses_all_positions_same(): houses = [1, 1, 1] heaters = [1] assert find_radius(houses, heaters) == 0 def test_houses_and_heaters_at_edges(): houses = [1, 5, 10] heaters = [1, 10] assert find_radius(houses, heaters) == 4 def test_long_distance_between_heaters(): houses = [1, 50, 100] heaters = [25, 75] assert find_radius(houses, heaters) == 25 def test_large_number_of_houses_and_heaters(): houses = list(range(1, 10001)) heaters = list(range(5000, 15000)) assert find_radius(houses, heaters) == 4999 def test_all_heaters_before_first_house(): houses = [10, 20, 30] heaters = [5] assert find_radius(houses, heaters) == 25 def test_all_heaters_after_last_house(): houses = [1, 2, 3] heaters = [10] assert find_radius(houses, heaters) == 9 def test_heaters_on_houses_positions(): houses = [1, 2, 3, 4] heaters = [1, 2, 3] assert find_radius(houses, heaters) == 1 pytest.main()","solution":"def find_radius(houses, heaters): Find the minimum radius required to heat all houses. :param houses: List[int], positions of houses sorted in non-decreasing order :param heaters: List[int], positions of heaters sorted in non-decreasing order :return: int, the minimum radius required import bisect heaters.sort() radius = 0 for house in houses: # Find the position to insert the house in the sorted heaters list pos = bisect.bisect_left(heaters, house) # Calculate distances to the nearest heaters left_heater_dist = float('inf') if pos == 0 else house - heaters[pos - 1] right_heater_dist = float('inf') if pos == len(heaters) else heaters[pos] - house # The closest heater distance min_heater_dist = min(left_heater_dist, right_heater_dist) radius = max(radius, min_heater_dist) return radius"},{"question":"def arrange_books() -> str: Arrange books on a shelf according to given constraints: 1. All books of the same category should be together. 2. The total number of books is exactly 10. 3. The number of Fiction books should be at least 1 and at most 4. 4. The number of Non-Fiction books should be at least 2 and at most 6. 5. The number of Science books should be at least 2 and at most 6. 6. The arrangement should be lexicographically smallest. Returns: str: The arrangement of books, e.g., \\"FFFFNNSSSS\\", or \\"Not Possible\\" if no valid arrangement exists. >>> arrange_books() \\"FFNNNNSSSS\\"","solution":"def arrange_books(): for fiction in range(1, 5): for non_fiction in range(2, 7): science = 10 - fiction - non_fiction if science >= 2 and science <= 6: return \\"F\\" * fiction + \\"N\\" * non_fiction + \\"S\\" * science return \\"Not Possible\\""},{"question":"def check_rectangle(grid: List[List[int]]) -> str: Check if there exists a rectangle in the grid such that all its corners are occupied cells. >>> check_rectangle([[1, 0, 0, 1, 0], [0, 1, 0, 1, 1], [0, 1, 1, 0, 0], [0, 0, 1, 1, 1]]) \\"YES\\" >>> check_rectangle([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) \\"NO\\" >>> check_rectangle([[1, 1], [1, 1]]) \\"YES\\" >>> check_rectangle([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) \\"NO\\" >>> check_rectangle([[1, 0, 1], [0, 1, 0], [1, 0, 1], [0, 1, 0]]) \\"YES\\"","solution":"def check_rectangle(grid): n = len(grid) m = len(grid[0]) for i in range(n): for j in range(m): if grid[i][j] == 1: for x in range(i + 1, n): for y in range(j + 1, m): if grid[i][y] == 1 and grid[x][j] == 1 and grid[x][y] == 1: return \\"YES\\" return \\"NO\\""},{"question":"class Warehouse: def __init__(self): self.stock = {} def stock_part(self, part_id: str, quantity: int): Updates the stock level for a given part id by adding the quantity to the current stock. If the part does not exist, it adds it to the stock. Args: part_id (str): The ID of the part quantity (int): The quantity of the part to add to the stock pass def order_part(self, part_id: str, quantity: int) -> str: Checks if the required quantity of the part is available and, if so, reduces the stock level by the quantity. Args: part_id (str): The ID of the part quantity (int): The quantity of the part to order Returns: str: \\"OK\\" if the order can be fulfilled, otherwise \\"FAIL\\" pass def report(self) -> str: Generates a report of the current stock levels for all parts in the system, sorted by part id. Returns: str: The formatted report string of all part ids and their quantities pass import pytest def test_stock_parts(): warehouse = Warehouse() warehouse.stock_part(\\"partA\\", 100) warehouse.stock_part(\\"partB\\", 200) assert warehouse.stock[\\"partA\\"] == 100 assert warehouse.stock[\\"partB\\"] == 200 def test_update_existing_stock(): warehouse = Warehouse() warehouse.stock_part(\\"partA\\", 100) warehouse.stock_part(\\"partA\\", 50) assert warehouse.stock[\\"partA\\"] == 150 def test_order_part_success(): warehouse = Warehouse() warehouse.stock_part(\\"partA\\", 100) result = warehouse.order_part(\\"partA\\", 75) assert result == \\"OK\\" assert warehouse.stock[\\"partA\\"] == 25 def test_order_part_failure(): warehouse = Warehouse() warehouse.stock_part(\\"partA\\", 100) result = warehouse.order_part(\\"partA\\", 150) assert result == \\"FAIL\\" assert warehouse.stock[\\"partA\\"] == 100 def test_order_part_no_stock(): warehouse = Warehouse() result = warehouse.order_part(\\"partA\\", 10) assert result == \\"FAIL\\" def test_report(): warehouse = Warehouse() warehouse.stock_part(\\"partB\\", 200) warehouse.stock_part(\\"partA\\", 100) warehouse.stock_part(\\"partC\\", 300) report = warehouse.report() expected_report = \\"partA 100npartB 200npartC 300\\" assert report == expected_report def test_sum_order_and_report(): warehouse = Warehouse() warehouse.stock_part(\\"part1\\", 100) warehouse.stock_part(\\"part2\\", 10) assert warehouse.order_part(\\"part1\\", 50) == \\"OK\\" assert warehouse.order_part(\\"part2\\", 11) == \\"FAIL\\" assert warehouse.order_part(\\"part2\\", 5) == \\"OK\\" warehouse.stock_part(\\"part1\\", 100) assert warehouse.order_part(\\"part1\\", 100) == \\"OK\\" report = warehouse.report() expected_report = \\"part1 50npart2 5\\" assert report == expected_report assert warehouse.order_part(\\"part3\\", 5) == \\"FAIL\\" warehouse.stock_part(\\"part3\\", 10) assert warehouse.order_part(\\"part3\\", 5) == \\"OK\\"","solution":"class Warehouse: def __init__(self): self.stock = {} def stock_part(self, part_id, quantity): if part_id in self.stock: self.stock[part_id] += quantity else: self.stock[part_id] = quantity def order_part(self, part_id, quantity): if part_id in self.stock and self.stock[part_id] >= quantity: self.stock[part_id] -= quantity return \\"OK\\" else: return \\"FAIL\\" def report(self): report_lines = [] for part_id in sorted(self.stock): report_lines.append(f\\"{part_id} {self.stock[part_id]}\\") return \\"n\\".join(report_lines)"},{"question":"def find_root_value(k: int, leaf_values: List[int]) -> int: Given the height of a perfect binary tree and the values at the leaves, returns the value at the root. >>> find_root_value(2, [3, 8, 4, 6]) 9 >>> find_root_value(1, [1, 2]) 3 >>> find_root_value(3, [0, 0, 0, 0, 0, 0, 0, 0]) 0 >>> find_root_value(2, [1000000, 500000, 250000, 125000]) 625000 >>> find_root_value(3, [1, 3, 5, 7, 9, 11, 13, 15]) 0 >>> find_root_value(20, [i for i in range(2**20)]) 0 pass","solution":"def find_root_value(k, leaf_values): Given the height of a perfect binary tree and the values at the leaves, returns the value at the root. current_level = leaf_values while len(current_level) > 1: next_level = [] for i in range(0, len(current_level), 2): next_level.append(current_level[i] ^ current_level[i+1]) current_level = next_level return current_level[0]"},{"question":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that the robot can complete. Parameters: tasks (list of tuples): A list where each tuple contains two integers (a, b), representing the start and end times of a task. Returns: int: The maximum number of non-overlapping tasks. Examples: >>> max_non_overlapping_tasks([(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (3, 4), (1, 3)]) 3","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be performed. Parameters: tasks (list of tuples): A list where each tuple contains two integers (a, b) representing the start and end times of a task. Returns: int: The maximum number of non-overlapping tasks. # First, sort the tasks by their end time tasks.sort(key=lambda x: x[1]) count = 0 end_time = 0 for task in tasks: if task[0] >= end_time: # Update the end_time to the end of the current task end_time = task[1] count += 1 return count"},{"question":"def max_coins(n: int, m: int, coins: List[int]) -> int: Calculate the maximum number of coins collected in m days. Parameters: n (int): number of houses m (int): number of days coins (list): list containing the number of coins in each house Returns: int: maximum number of coins that can be collected in m days >>> max_coins(5, 3, [1, 2, 3, 4, 5]) 12 >>> max_coins(5, 3, [1, 1, 1, 1, 1]) 3 >>> max_coins(5, 5, [5, 4, 3, 2, 1]) 15 >>> max_coins(3, 5, [1, 2, 3]) 6 >>> max_coins(1, 1, [1000]) 1000 >>> max_coins(3, 2, [5, 5, 5]) 10 >>> max_coins(5, 0, [5, 4, 3, 2, 1]) 0","solution":"def max_coins(n, m, coins): Calculate the maximum number of coins collected in m days. Parameters: n (int): number of houses m (int): number of days coins (list): list containing the number of coins in each house Returns: int: maximum number of coins that can be collected in m days # Sort coins in descending order to collect maximum possible coins each day sorted_coins = sorted(coins, reverse=True) # Collect coins for m days return sum(sorted_coins[:m])"},{"question":"def find_two_distinct_paths(n: int, m: int, grid: List[str]) -> str: Alice is playing a new game on a grid-like battlefield. The battlefield is represented by a grid of size n x m where each cell can either be empty (represented by '.') or contain an obstacle (represented by '#'). Alice starts at the top-left corner of the grid and wants to move to the bottom-right corner. She can move in four directions: up, down, left, and right, but she cannot move into a cell with an obstacle or outside of the battlefield. Alice loves to make her life difficult, so she decided that she will only move if she can do so by alternating steps between two distinct paths that connect the start and end cells without sharing any cell in common except the start and end cells. You need to help Alice determine if there exist two such distinct paths. >>> find_two_distinct_paths(4, 4, [ ... \\"....\\", ... \\".#..\\", ... \\"..#.\\", ... \\"....\\" ... ]) \\"YES\\" >>> find_two_distinct_paths(3, 3, [ ... \\"#\\", ... \\"#.#\\", ... \\"#\\" ... ]) \\"NO\\" >>> find_two_distinct_paths(1, 1, [\\".\\"]) \\"NO\\" >>> find_two_distinct_paths(4, 4, [ ... \\"\\", ... \\"\\", ... \\"\\", ... \\"\\" ... ]) \\"NO\\" >>> find_two_distinct_paths(5, 5, [ ... \\".....\\", ... \\".#.\\", ... \\".#...\\", ... \\".#.\\", ... \\".....\\" ... ]) \\"YES\\"","solution":"def find_paths(grid, n, m): from collections import deque def bfs(start_x, start_y): queue = deque([(start_x, start_y)]) visited = [[False] * m for _ in range(n)] parent = [[None] * m for _ in range(n)] visited[start_x][start_y] = True while queue: x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True parent[nx][ny] = (x, y) queue.append((nx, ny)) if (nx, ny) == (n-1, m-1): path = [] while parent[nx][ny]: path.append((nx, ny)) nx, ny = parent[nx][ny] path.append((0, 0)) return path[::-1] return [] first_path = bfs(0, 0) if not first_path: return \\"NO\\" for x, y in first_path: if (x, y) != (0, 0) and (x, y) != (n-1, m-1): grid[x][y] = '#' second_path = bfs(0, 0) if not second_path: return \\"NO\\" return \\"YES\\" def find_two_distinct_paths(n, m, grid): return find_paths([list(row) for row in grid], n, m)"}]`),E={name:"App",components:{PoemCard:S},data(){return{searchQuery:"",visibleCount:4,poemsData:j,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},A={class:"search-container"},I={class:"card-container"},D={key:0,class:"empty-state"},C=["disabled"],O={key:0},P={key:1};function z(n,e,u,c,r,a){const f=p("PoemCard");return s(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",A,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",I,[(s(!0),i(x,null,y(a.displayedPoems,(o,h)=>(s(),v(f,{key:h,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),i("div",D,' No results found for "'+m(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),i("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),i("span",P,"Loading...")):(s(),i("span",O,"See more"))],8,C)):l("",!0)])}const Y=d(E,[["render",z],["__scopeId","data-v-be4aba48"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/30.md","filePath":"grok/30.md"}'),F={name:"grok/30.md"},G=Object.assign(F,{setup(n){return(e,u)=>(s(),i("div",null,[w(Y)]))}});export{B as __pageData,G as default};
