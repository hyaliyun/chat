import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},R={class:"review-title"},j={class:"review-content"};function I(i,e,u,c,a,s){return n(),r("div",q,[t("div",T,[t("div",R,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",j,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const Y=m(k,[["render",I],["__scopeId","data-v-6624bf0c"]]),A=JSON.parse('[{"question":"A conveyor system at a factory transports products represented by an array of integers `products`, where the `i-th` integer denotes the type of product being processed at that position on the conveyor belt. Occasionally, a product needs to be replaced with a new one due to quality control. You are given an integer `k` which denotes the maximum length of the segment of products allowed to be replaced in one operation. Your task is to find the length of the longest subsequence of unique product types that can be achieved by performing at most one operation of replacing up to `k` consecutive products. If no replacement is needed, the length of the subsequence should be the initial distinct product types present. Return the length of the longest subsequence of unique product types after performing the operation.","solution":"def longest_subsequence_with_replacement(products, k): Find the length of the longest subsequence of unique product types that can be achieved by performing at most one operation of replacing up to \'k\' consecutive products. n = len(products) if n == 0: return 0 # Initial count of unique products unique_products = set(products) initial_unique_count = len(unique_products) if k >= n: return initial_unique_count max_length = initial_unique_count # Consider segments of length at most k to replace for i in range(n): replacement_set = set() for j in range(i, min(i + k, n)): replacement_set.add(products[j]) after_replacement_unique_count = len(replacement_set) max_length = max(max_length, after_replacement_unique_count) return max_length"},{"question":"You are given a list of `n` processes, which are to be executed by a single-core CPU. Each process is represented by a tuple `(pid, arrival_time, burst_time)`, where `pid` is the process ID, `arrival_time` is the time at which the process arrives at the CPU, and `burst_time` is the time required by the process for execution. Implement the `CPU` class to simulate a CPU scheduling algorithm. The methods that need to be implemented are: * `CPU()`: Initializes the CPU with an empty process queue. * `void addProcess(int pid, int arrival_time, int burst_time)`: Adds a new process to the CPU queue. * `List<Integer> executeProcesses()`: Executes the processes in the order of their arrival time using the First-Come-First-Serve (FCFS) scheduling algorithm. This method should return a list of process IDs in the order they complete execution. When two processes have the same `arrival_time`, they should be executed based on their `burst_time`, with the process having the shorter `burst_time` being executed first. If two processes have the same `burst_time` as well, they should be executed in the order of their `pid`. The method should handle all processes currently in the CPU queue and simulate the execution in real-time, returning the list of `pid`s in order of their completion.","solution":"class CPU: def __init__(self): self.processes = [] def addProcess(self, pid, arrival_time, burst_time): self.processes.append((pid, arrival_time, burst_time)) def executeProcesses(self): # Sort by arrival_time, then by burst_time, and finally by pid self.processes.sort(key=lambda x: (x[1], x[2], x[0])) execution_order = [process[0] for process in self.processes] return execution_order"},{"question":"You are given an integer array `costs` where `costs[i]` represents the cost of the `i-th` item for a shopping list. You are also given an integer `budget` that represents the maximum amount of money you can spend. You are allowed to pick any number of items from the array such that their total cost does not exceed the given `budget`. Find the maximum number of items you can include in your shopping list without exceeding the budget. Return the maximum number of items you can buy.","solution":"def max_items_within_budget(costs, budget): Returns the maximum number of items that can be bought without exceeding the given budget. :param costs: List of integers representing the costs of the items. :param budget: Integer representing the maximum budget. :return: Integer representing the maximum number of items that can be bought within the budget. costs.sort() count = 0 total_cost = 0 for cost in costs: if total_cost + cost <= budget: total_cost += cost count += 1 else: break return count"},{"question":"You are given a **0-indexed** array of `n` integers `arr`. Your task is to determine the **longest subsequence** of `arr` such that the difference between each pair of **consecutive** elements in the subsequence is an **even** number. Return _the length of the longest such subsequence_. If no such subsequence exists, return `0`.","solution":"def longest_even_diff_subsequence(arr): Returns the length of the longest subsequence such that the difference between each pair of consecutive elements in the subsequence is an even number. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest such subsequence. if not arr: return 0 # Separate all elements by even and odd even_elements = [num for num in arr if num % 2 == 0] odd_elements = [num for num in arr if num % 2 != 0] longest_subseq = max(len(even_elements), len(odd_elements)) return longest_subseq"},{"question":"Given two integers `dividend` and `divisor`, divide two integers **without using multiplication, division, and mod operator**. Return the quotient after dividing `dividend` by `divisor`. The integer division should truncate toward zero, which means losing its fractional part.","solution":"def divide(dividend, divisor): Divide two integers without using multiplication, division, and mod operator. Return the quotient after dividing dividend by divisor. # Handle edge cases for overflow MAX_INT = 2**31 - 1 MIN_INT = -2**31 # Special case for overflow if dividend == MIN_INT and divisor == -1: return MAX_INT negative = (dividend < 0) != (divisor < 0) # Convert both numbers to positive dividend, divisor = abs(dividend), abs(divisor) quotient = 0 while dividend >= divisor: temp, multiple = divisor, 1 while dividend >= (temp << 1): temp <<= 1 multiple <<= 1 dividend -= temp quotient += multiple return -quotient if negative else quotient"},{"question":"You are given a list of integers `nums` representing the number of oranges in each basket and an integer `threshold` representing the maximum number of oranges that can be picked at one time. An orange picker can pick oranges from contiguous baskets such that the total number of oranges picked does not exceed the `threshold`. Return _the maximum number of contiguous baskets from which the orange picker can pick oranges_ without exceeding the `threshold`.","solution":"def max_contiguous_baskets(nums, threshold): Returns the maximum number of contiguous baskets from which the orange picker can pick oranges without exceeding the threshold. max_length = 0 current_sum = 0 left = 0 for right in range(len(nums)): current_sum += nums[right] while current_sum > threshold: current_sum -= nums[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a 2D grid of size `m x n` representing a map of land (`1`) and water (`0`). Write a function that finds the length of the shortest path from a given land cell to another land cell, traversing only through land cells and moving in the four possible directions (up, down, left, right). If no such path exists, return `-1`. The function should handle large grids efficiently. The input includes: 1. A matrix `grid` of integers `1` (land) and `0` (water), where `grid[i][j]` represents the cell at row `i` and column `j`. 2. Two pairs of integers `(start_r, start_c)` and `(end_r, end_c)` indicating the start and end positions, respectively. _Model your solution on optimizing for both space and time complexity._","solution":"from collections import deque def shortest_path(grid, start_r, start_c, end_r, end_c): Finds the length of the shortest path from a given land cell to another land cell. Traverses only through land cells and moving in four possible directions. If no such path exists, returns -1. Parameters: grid (List[List[int]]): The map of land and water. start_r (int): The starting row index. start_c (int): The starting column index. end_r (int): The ending row index. end_c (int): The ending column index. Returns: int: The length of the shortest path, or -1 if no such path exists. if not grid or not grid[0] or grid[start_r][start_c] == 0 or grid[end_r][end_c] == 0: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start_r, start_c, 0)]) # (row, col, distance) visited = set((start_r, start_c)) while queue: r, c, dist = queue.popleft() if r == end_r and c == end_c: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given an array of integers `arr` and a positive integer `k`. Your task is to modify the array by either incrementing or keeping any single element unchanged. The increment operation can be performed any number of times, but each operation has a cost of 1. You need to make all elements in the array divisible by `k` with the smallest possible total cost. Write a function to find the **minimum total cost** required to achieve this. If it\'s impossible to make all elements divisible by `k`, return `-1`.","solution":"def min_cost_to_make_divisible(arr, k): Function to calculate the minimum total cost to make all elements divisible by k. Parameters: arr (list): list of integers. k (int): positive integer. Returns: int: minimum total cost or -1 if it\'s impossible. cost = 0 for num in arr: remainder = num % k if remainder != 0: cost += k - remainder return cost"},{"question":"You are given a list of `words` where each word consists of lowercase alphabetical characters. Write a function that selects and returns all the words that can be typed using letters of only one row on a QWERTY keyboard. The rows of the QWERTY keyboard are as follows: - First row: `\\"qwertyuiop\\"` - Second row: `\\"asdfghjkl\\"` - Third row: `\\"zxcvbnm\\"` Note: The input strings will only contain lowercase letters.","solution":"def find_words_in_one_row(words): Returns a list of words that can be typed using letters of only one row on QWERTY keyboard. first_row = set(\\"qwertyuiop\\") second_row = set(\\"asdfghjkl\\") third_row = set(\\"zxcvbnm\\") def can_be_typed_with_one_row(word, row): return all(char in row for char in word) result = [] for word in words: if can_be_typed_with_one_row(word, first_row) or can_be_typed_with_one_row(word, second_row) or can_be_typed_with_one_row(word, third_row): result.append(word) return result"},{"question":"Given an array `arr` of `n` integers, and an integer `m`, write a function to return the maximum sum of a subarray with length exactly `m`. A **subarray** is a contiguous block of elements from the original array. If it is not possible to find a subarray of length `m`, return `0`.","solution":"def maximum_sum_subarray(arr, m): Returns the maximum sum of a subarray with length exactly m. Parameters: arr (list): A list of integers. m (int): Length of the subarray. Returns: int: The maximum sum of the subarray with length exactly m, or 0 if not possible. n = len(arr) if m > n: return 0 max_sum = float(\'-inf\') current_sum = sum(arr[:m]) for i in range(n - m + 1): if i == 0: max_sum = current_sum else: current_sum = current_sum - arr[i - 1] + arr[i + m - 1] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"> A system is designed to keep track of flight routes between a set of cities. Each route has a start city and a destination city, and there can be multiple routes between the same pair of cities. Implement the `FlightRoutes` class: > > * `FlightRoutes()` Initializes the system with no routes. > * `void addRoute(String startCity, String endCity)` Adds a route from `startCity` to `endCity`. > * `List<String> getDestinations(String startCity)` Returns a list of all destination cities reachable directly from `startCity`. The list of destinations should be sorted lexicographically. > * `boolean hasRoute(String fromCity, String toCity)` Returns true if there is at least one direct route from `fromCity` to `toCity`, and false otherwise.","solution":"class FlightRoutes: def __init__(self): self.routes = {} def addRoute(self, startCity, endCity): if startCity not in self.routes: self.routes[startCity] = [] self.routes[startCity].append(endCity) def getDestinations(self, startCity): if startCity not in self.routes: return [] return sorted(self.routes[startCity]) def hasRoute(self, fromCity, toCity): if fromCity not in self.routes: return False return toCity in self.routes[fromCity]"},{"question":"You are given an array `points` where each element represents the score of a player in a game. The objective is to maximize the points collected by a player, but with the restriction that if a player collects points from a game at index `i`, they cannot collect points from the adjacent games at index `i-1` and `i+1`. Write an algorithm to determine the maximum points a player can collect without violating this restriction. Return the maximum score that can be achieved.","solution":"def max_points(points): if not points: return 0 n = len(points) if n == 1: return points[0] if n == 2: return max(points[0], points[1]) dp = [0] * n dp[0] = points[0] dp[1] = max(points[0], points[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + points[i]) return dp[-1]"},{"question":"You are given a binary tree with `n` nodes. Return a list of length `n`, where the `i-th` entry in the list is the number of nodes that are on the same level as the `i-th node` in a level-order traversal. Each node in the tree has a unique value from `0` to `n-1`, and the tree is represented as an adjacency list where `tree[i]` is a list of the children of node `i`.","solution":"def nodes_on_same_level(tree): from collections import deque if not tree: return [] n = len(tree) level_count = [0] * n level_map = [0] * n queue = deque([0]) level = 0 while queue: level_length = len(queue) for _ in range(level_length): node = queue.popleft() level_map[node] = level queue.extend(tree[node]) level += 1 # Count nodes at each level by summarizing level_map for l in level_map: level_count[l] += 1 # Count nodes at the same level for each node in the tree result = [0] * n for i in range(n): result[i] = level_count[level_map[i]] return result"},{"question":"You are given a binary tree in which each node contains an integer value. Return _the number of uni-value subtrees_. A uni-value subtree means all nodes of the subtree have the same value. *Example:* - Given the following binary tree: ``` 5 / 1 5 / 5 5 5 ``` The result should be 4, as there are four uni-value subtrees: 1. The three leaf nodes with value 5. 2. The subtree with root node 5 and right child 5.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_univalue_subtrees(root): Returns the number of uni-value subtrees. def is_univalue_subtree(node, count): if not node: return True left_is_unival = is_univalue_subtree(node.left, count) right_is_unival = is_univalue_subtree(node.right, count) if left_is_unival and right_is_unival: if (node.left and node.val != node.left.val) or (node.right and node.val != node.right.val): return False count[0] += 1 return True return False count = [0] is_univalue_subtree(root, count) return count[0]"},{"question":"Given an integer array `nums` and an integer `k`, find _the maximum number of consecutive elements in the array that you can replace to make `k` distinct values appear in the same substring_. Return _the length of this maximum substring_.","solution":"def max_consecutive_with_k_distinct(nums, k): Finds the maximum number of consecutive elements in the array that you can replace to make k distinct values appear in the same substring. :param nums: List of integers. :param k: Integer representing the number of distinct values. :return: Length of the maximum substring. from collections import defaultdict if not nums or k == 0: return 0 left = 0 max_len = 0 distinct_count = 0 num_freq = defaultdict(int) for right in range(len(nums)): num_freq[nums[right]] += 1 if num_freq[nums[right]] == 1: distinct_count += 1 while distinct_count > k: num_freq[nums[left]] -= 1 if num_freq[nums[left]] == 0: distinct_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a **0-indexed** integer array `nums` representing the helmet sizes that are available in a sports store. Each size is unique and sorted in ascending order. Customers come to the store to rent a helmet for a single day and will always choose the smallest helmet that is at least as large as their head size. You are given another array `customers` where `customers[i]` is the head size of the ith customer. For each customer, determine the index of the helmet they will rent. If no suitable helmet is available, return `-1`. Return an array of indices representing the helmet each customer rents in the order they appear in the `customers` array.","solution":"def find_helmets_for_customers(nums, customers): def binary_search(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left if left < len(nums) else -1 result = [] for customer in customers: result.append(binary_search(nums, customer)) return result"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to determine if any two distinct elements from the array add up to the target. If there are such elements, return the indices of the two numbers. If there are no such elements, return an empty list. Note that each input would have exactly one solution, and you may not use the same element twice.","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. num_indices = {} for index, num in enumerate(nums): complement = target - num if complement in num_indices: return [num_indices[complement], index] num_indices[num] = index return []"},{"question":"Given an integer `num`, we define a \\"collapsible number\\" as follows: if the number is even, you divide it by 2; if the number is odd, you multiply it by 3 and add 1. Continue this process until the number becomes 1. Write a function that takes an integer `num` and returns the number of steps required to transform `num` into 1 using the above rules.","solution":"def collapsible_number_steps(num): Returns the number of steps required to transform `num` into 1 using the given rules: - If the number is even, divide it by 2. - If the number is odd, multiply it by 3 and add 1. steps = 0 while num != 1: if num % 2 == 0: num //= 2 else: num = num * 3 + 1 steps += 1 return steps"},{"question":"You are given a binary tree in which each node contains an integer value. Write a program that finds the subtree with the maximum sum and returns the sum of that subtree. A subtree is defined as any node and all its descendants. Your solution should implement a helper function to traverse the tree and compute the sum of all subtrees in a single pass to achieve optimal performance.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_max_subtree_sum(root): Finds the subtree with the maximum sum and returns the sum of that subtree. def helper(node): nonlocal max_sum if node is None: return 0 left_sum = helper(node.left) right_sum = helper(node.right) total_sum = node.value + left_sum + right_sum max_sum = max(max_sum, total_sum) return total_sum max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"Given an integer array `nums`, return _the **total amount of water** that can be trapped between the numbers_ after raining. Each element in the array represents a vertical bar\'s height, and the width of each bar is 1.","solution":"def trap(height): Given a list of integers representing heights, calculate the total water that can be trapped after raining. Parameters: height (List[int]): List of non-negative integers representing the height of the bars. Returns: int: The total amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given a number `num` represented as a string, write a function that returns the largest product you can get by deleting exactly one digit from the string. The number will not contain any leading zeros unless it is \\"0\\". You can assume that the input string `num` will always have at least two digits. The function should return the result as an integer. For example, if `num` is \\"123\\", the function should return 23, because removing \'1\' results in 23 which is the largest product of a single digit removal. Similarly, if `num` is \\"2045\\", the function should return 245, because removing \'0\' results in 2045 which is the largest product of a single digit removal.","solution":"def largest_product_by_deleting_one_digit(num): Returns the largest product of the number by deleting exactly one digit. Args: num (str): a string representation of the number Returns: int: the largest product by deleting one digit max_product = 0 n = len(num) for i in range(n): new_number = int(num[:i] + num[i+1:]) max_product = max(max_product, new_number) return max_product"},{"question":"You are given a string `expression` that contains a mix of numbers and operators (`+`, `-`, `*`, `/`). Write a function to evaluate the mathematical expression and return the result as an integer. The integer division should truncate toward zero. You can assume the expression is always valid. All intermediate results will be in the range of a 32-bit signed integer. Implement the function: * `int evaluateExpression(String expression)`: This function should evaluate the given mathematical expression and return the result as an integer.","solution":"def evaluateExpression(expression): Evaluates the given mathematical expression containing +, -, *, and / operators. Integer division should truncate toward zero. def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # Truncate towards zero def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): value = 0 while i < len(expression) and expression[i].isdigit(): value = value * 10 + int(expression[i]) i += 1 values.append(value) i -= 1 elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"You are given a `m x n` 2D grid initialized with zeros. Use the following operations to change the values in the grid: 1. `setUniformValue(r1, r2, c1, c2, value)` - sets all the cells in the subgrid from `(r1, c1)` to `(r2, c2)` to the specified `value`. 2. `querySum(r1, r2, c1, c2)` - returns the sum of all the cells in the subgrid from `(r1, c1)` to `(r2, c2)`. You need to implement the `Grid` class with the following methods: - `__init__(self, m: int, n: int)`: Initializes the grid with `m` rows and `n` columns. - `setUniformValue(self, r1: int, r2: int, c1: int, c2: int, value: int)`: Applies the set operation as described. - `querySum(self, r1: int, r2: int, c1: int, c2: int) -> int`: Returns the sum for the query range as described. Ensure that your implementation can handle these operations efficiently.","solution":"class Grid: def __init__(self, m: int, n: int): Initializes the grid with m rows and n columns. self.grid = [[0] * n for _ in range(m)] self.m = m self.n = n def setUniformValue(self, r1: int, r2: int, c1: int, c2: int, value: int): Sets all the cells in the subgrid from (r1, c1) to (r2, c2) to the specified value. for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): self.grid[i][j] = value def querySum(self, r1: int, r2: int, c1: int, c2: int) -> int: Returns the sum of all the cells in the subgrid from (r1, c1) to (r2, c2). total_sum = 0 for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): total_sum += self.grid[i][j] return total_sum"},{"question":"You are given a list of integers `nums` and an integer `k`. Your task is to split the list into `k` non-empty continuous subarrays in such a way that the largest sum of any subarray is minimized. Return the minimized largest sum among the `k` subarrays.","solution":"def splitArray(nums, k): Split the list into k non-empty continuous subarrays such that the largest sum of any subarray is minimized. Returns the minimized largest sum among the k subarrays. :param nums: List[int] - List of integers :param k: int - Number of subarrays :return: int - Minimized largest sum among the subarrays def can_split(mid): current_sum = 0 required_parts = 1 for num in nums: if current_sum + num > mid: required_parts += 1 current_sum = num if required_parts > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of `n` integers `nums`, representing the number of minutes each task takes to complete. You have `k` identical workers, and each worker can complete at most one task at a time. Determine the minimum amount of total time required to complete all the tasks if you distribute the tasks optimally among the workers. Return the minimum total time required.","solution":"def min_time_to_complete_tasks(nums, k): Determines the minimum time required to complete all tasks given the number of workers. :param nums: List of integers where each integer represents the time a task takes to complete. :param k: Integer representing the number of workers. :return: Minimum total time required to complete all tasks optimally. if not nums: return 0 # Sort the tasks in descending order to assign largest tasks first nums.sort(reverse=True) # Create a list to track the time taken by each worker workers = [0] * k for time in nums: # Assign task to the worker with the least accumulated time workers[0] += time # Re-sort the list of worker times workers.sort() # The total time required is the maximum time any worker takes return max(workers)"},{"question":"You are given an array of integers `nums` and an integer `target`. Implement a function that returns an array containing **all unique combinations** of elements in `nums` where the chosen numbers sum to `target`. Each number in `nums` may only be used once in the combination. The solution set must not contain duplicate combinations, and the combinations can be returned in any order. Implement the function `findCombinations(nums: List[int], target: int) -> List[List[int]]`. Example: ``` Input: nums = [10,1,2,7,6,1,5], target = 8 Output: [ [1,1,6], [1,2,5], [1,7], [2,6] ] ``` Note: - All numbers (including `target`) will be positive integers. - The solution set must not contain duplicate combinations.","solution":"def findCombinations(nums, target): def backtrack(start, target, path): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue backtrack(i+1, target-nums[i], path + [nums[i]]) nums.sort() result = [] backtrack(0, target, []) return result"},{"question":"Given a list of integers representing the heights of bars in a histogram, implement a function `int largestRectangleArea(vector<int>& heights)` that returns the area of the largest rectangle that can be formed within the bounds of the histogram. A histogram is defined by a sequence of bars of different heights, and each bar has a width of 1. Ensure your solution efficiently computes the result even for histograms with a large number of bars.","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed within the histogram represented by heights. stack = [] max_area = 0 heights.append(0) # Append a zero height to handle remaining bars in the stack at the end for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() # Restore the list to its original state return max_area"},{"question":"Given an array of integers `arr`, where every element is present an even number of times except for one element which is present an odd number of times. Find and return the element that is present an odd number of times. You must solve the problem with a linear runtime complexity and constant additional space complexity.","solution":"def find_odd_occurrence(arr): Given an array of integers `arr`, where every element is present an even number of times except for one element which is present an odd number of times, this function returns the element that is present an odd number of times. result = 0 for num in arr: result ^= num return result"},{"question":"You are given a list of integers `nums` representing a sequence of operations. The sequence operates on an initial value of `0`, and each number in the list indicates an operation to be performed on the current value. For positive numbers, add the number to the current value. For negative numbers, subtract the absolute value from the current value. Additionally, a number `0` indicates the reset of the current value to zero. Return _the final value after performing all operations in the list_.","solution":"def process_operations(nums): Processes a list of operations on an initial value of 0. Args: nums (list of int): List of integers representing operations. Returns: int: The final value after performing all operations. current_value = 0 for num in nums: if num == 0: current_value = 0 else: current_value += num return current_value"},{"question":"Given a string `s`, you need to check whether it is possible to rearrange the characters of `s` such that no two adjacent characters are the same. If it is possible, return `true`. Otherwise, return `false`.","solution":"from collections import Counter import heapq def can_rearrange_adjacent_different(s): Checks whether it is possible to rearrange the characters of the string `s` such that no two adjacent characters are the same. # Count the frequency of each character char_counts = Counter(s) # Max heap to get the character with the highest frequency first max_heap = [(-count, char) for char, count in char_counts.items()] heapq.heapify(max_heap) # Variables to store previous character and its count (init with dummy values) prev_count, prev_char = 0, \'\' result = [] while max_heap: # Pop the most frequent character count, char = heapq.heappop(max_heap) result.append(char) # If previous character was used and its count was greater than 0, push it back to the heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update previous character and its count (decrease count) prev_count, prev_char = count + 1, char rearranged = \'\'.join(result) return len(rearranged) == len(s)"},{"question":"You are given a list of non-negative integers `nums`, and you are tasked to form a ring such that each integer in `nums` points to another integer, forming a circular chain. Determine if this ring configuration can be made **palindromic**. A palindromic ring means that reading the numbers in the ring forward or backward results in the same sequence. Return `True` if such a palindromic ring can be formed, otherwise return `False`.","solution":"def can_form_palindromic_ring(nums): Determine if the given list of non-negative integers `nums` can be arranged in a circular manner such that the sequence forms a palindrome. from collections import Counter # Count the frequency of each number num_counts = Counter(nums) # Track the number of elements with odd occurrences odd_count = 0 for count in num_counts.values(): if count % 2 != 0: odd_count += 1 # A palindromic ring is possible if we have at most one odd character count return odd_count <= 1"},{"question":"Given an integer array `arr`, find a contiguous subarray that has the maximum product of its elements. Return the maximum product that can be achieved. The array may contain both positive and negative numbers and you should account for the case where the largest product may be the result of including a negative number multiplied by another negative number. Note: The subarray should not be empty, and the product of the subarray containing only one element is the value of that element itself.","solution":"def max_product_subarray(arr): Returns the maximum product of a contiguous subarray in the given integer array. if not arr: return 0 max_product = min_product = result = arr[0] for num in arr[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"You are given an integer array `heights` where `heights[i]` represents the height of the `i-th` building. You are to find two buildings such that the water trapped between them is maximized. The two buildings trap water according to the formula: * min(heights[i], heights[j]) * (j - i), where `i` and `j` are the indices of the buildings, and `i < j`. Return the maximum amount of water trapped.","solution":"def max_area(heights): Finds the maximum amount of water trapped between two buildings. Heights is a list of integers where each integer represents the height of a building. if len(heights) < 2: return 0 # If less than two buildings, no water can be trapped. left, right = 0, len(heights) - 1 max_water = 0 while left < right: height = min(heights[left], heights[right]) width = right - left current_water = height * width max_water = max(max_water, current_water) # Move the pointers to try and find a better pair if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given an array of integers `arr` and two integers `left` and `right`. A subarray is called “fixed-boundary” if its minimum value is at least `left` and its maximum value is at most `right`. Return the number of fixed-boundary subarrays that exist in the given array. Note: A subarray is a contiguous portion of an array.","solution":"def count_fixed_boundary_subarrays(arr, left, right): Counts the number of fixed-boundary subarrays in the given array. A subarray is considered fixed-boundary if its minimum value is at least `left` and its maximum value is at most `right`. :param arr: List of integers :param left: Integer, minimum value for the subarray :param right: Integer, maximum value for the subarray :return: Integer, the number of fixed-boundary subarrays n = len(arr) count = 0 for i in range(n): min_val, max_val = float(\'inf\'), float(\'-inf\') for j in range(i, n): min_val = min(min_val, arr[j]) max_val = max(max_val, arr[j]) if left <= min_val <= max_val <= right: count += 1 return count"},{"question":"You are given a matrix `grid` of size `m x n` consisting of non-negative integers. Each integer represents the height of a tower located at that position in the grid. The matrix represents a city skyline. A building\'s **shadow** projects to the left, meaning the shadow of a building at position (i, j) in the matrix with height `h` will cover all positions to the left of (i, j) in the same row (up to the boundary or another building of at least the same height). Return _the total area covered by these shadows in the entire grid_.","solution":"def calculate_shadow_area(grid): Returns the total area covered by the shadows in the entire grid. total_shadow_area = 0 for row in grid: max_height = 0 for height in row: if height > max_height: max_height = height total_shadow_area += max_height return total_shadow_area"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house. Each house is arranged in a circle, meaning the first and the last house are adjacent. There is a robber who wants to rob houses but cannot rob two adjacent houses. Determine the maximum amount of money the robber can rob without robbing two adjacent houses. **Note:** - The valid sequence of houses to be robbed can wrap around the end of the list and continue from the start, but the robber cannot rob both the first and last house simultaneously.","solution":"def rob(nums): Returns the maximum amount of money the robber can rob without robbing two adjacent houses. The first and last house are adjacent. if not nums: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums) def rob_linear(houses): prev, curr = 0, 0 for money in houses: prev, curr = curr, max(curr, prev + money) return curr # Calculate two scenarios: without the first house and without the last house return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"Given a linked list, reorder it in such a way that the nodes are rearranged in a specific manner described below: 1. Arrange the nodes such that the first element is followed by the last element, then the second element followed by the second-to-last element, and so on. 2. Specifically, given the linked list `L0 -> L1 -> ... -> Ln-1 -> Ln`, reorder it to: `L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ...` You need to do this in place without altering the values of the nodes (i.e., only node reordering is allowed). The solution should not use extra space for another list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): Reorders the linked list in-place such that: L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ... Arguments: head -- ListNode, the head of the linked list. if not head or not head.next: return # Step 1: Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Step 3: Merge the two halves first, second = head, prev while second.next: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first = tmp1 second = tmp2"},{"question":"You are given an integer array `nums` consisting of `n` positive integers and an integer `limit`. You want to create a subsequence of `nums` such that its sum is less than or equal to `limit` and it has the maximum possible length. Return _the length of the longest possible subsequence_. Note: You are allowed to rearrange the elements of `nums` to form the subsequence.","solution":"def max_length_subsequence(nums, limit): Returns the length of the longest subsequence of nums such that its sum is less than or equal to the limit. nums.sort() current_sum = 0 length = 0 for num in nums: if current_sum + num <= limit: current_sum += num length += 1 else: break return length"},{"question":"You are given an integer array `nums` where each element represents the number of stones in a pile. Two players take turns removing stones from one pile. On each player\'s turn, they must remove at least one stone from the pile but no more stones than the number of stones in that pile. The player who cannot make a move (because all piles are empty) loses. Both players play optimally. Write a function that returns `true` if the first player can force a win, otherwise return `false`.","solution":"def can_first_player_win(nums): Determines if the first player can force a win when both play optimally. The first player can force a win if the XOR of all pile sizes is non-zero. :param nums: List[int], an array of integers representing the number of stones in each pile. :return: bool, True if the first player can force a win, False otherwise. xor_sum = 0 for num in nums: xor_sum ^= num return xor_sum != 0"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of skyscrapers in a city. A new construction company wants to add one more skyscraper. Your task is to determine the **minimum** height of the new skyscraper to ensure it does not block the view. * The new skyscraper should be placed such that all taller skyscrapers can be seen when looking from left to right. * A skyscraper A can see skyscraper B (on its right) if the height of A is greater than or equal to the height of B. Return _the minimum height of the new skyscraper needed to maintain the view condition_.","solution":"def minimum_new_skyscraper_height(heights): Returns the minimum height of the new skyscraper to ensure it does not block the view of any taller skyscrapers. :param heights: List[int] - The heights of the existing skyscrapers. :return: int - The minimum height of the new skyscraper. if not heights: return 1 # In case there are no skyscrapers, return any height greater than 0 tallest_visible_skyscraper = max(heights) # The tallest existing skyscraper return tallest_visible_skyscraper + 1 # The new skyscraper should be at least 1 unit taller than the tallest existing one"},{"question":"Given an integer array `queries` of length `m` and an integer `n`, you have to perform operations on an initially empty array `result` of length `n`. The operations are described by the `queries` array, where each element `queries[i] = [op, k]`: - If `op` is 1, insert the integer `k` to the front of the `result` array. - If `op` is 2, insert the integer `k` to the back of the `result` array. - If `op` is 3, remove the integer `k` from the `result` array if it exists (only the first occurrence if multiple). Return the `result` array after performing all the operations in the `queries` array in order. If an invalid operation is encountered (e.g., removing an element that doesn\'t exist), continue with the next operations.","solution":"def perform_operations(n, queries): Perform operations on an initially empty array `result` of length `n` according to the `queries` array. Each element `queries[i] = [op, k]` describes an operation: - If `op` is 1, insert integer `k` to the front of `result`. - If `op` is 2, insert integer `k` to the back of `result`. - If `op` is 3, remove the integer `k` from `result` if it exists (only the first occurrence if multiple). Args: n (int): Length of the initially empty array `result` (not used in this implementation but kept for context). queries (List[List[int]]): The list of operations to perform. Returns: List[int]: The final `result` array after performing all operations. result = [] for op, k in queries: if op == 1: result.insert(0, k) elif op == 2: result.append(k) elif op == 3: if k in result: result.remove(k) return result"},{"question":"You are given a string `s` containing only lowercase English letters. A good string is a string that doesn\'t have two consecutive characters being the same. Return the minimum number of deletions needed to make `s` a good string.","solution":"def min_deletions_to_make_good_string(s): Returns the minimum number of deletions needed to make string s a good string (no two consecutive characters should be the same). if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"You are given a string `s` and an array `indices` of the same length where `indices[i]` represents the index in the final string where the character at `s[i]` should go. Reconstruct the string by rearranging the characters according to the given `indices` array. Return the reconstructed string.","solution":"def restore_string(s, indices): Reconstructs the string by rearranging the characters according to the given indices array. Parameters: s (str): The original string. indices (list of int): The indices array where indices[i] represents the new index of s[i]. Returns: str: The reconstructed string. # Initialize the resulting list with the same length as the string `s` result = [\'\'] * len(s) # Place each character in the corresponding new index as per `indices` for i, index in enumerate(indices): result[index] = s[i] # Join the list into a string and return return \'\'.join(result)"},{"question":"A tree is a special type of graph that is connected and acyclic. A rooted tree is a tree with a designated root node where every edge either points away from or towards the root. Given an array `parent` where `parent[i]` is the parent of the i-th node (starting at 0), write a function to find the height of the tree. The height of a tree is the length of the longest path from the root to any leaf node. Return _the height of the tree_.","solution":"def tree_height(parent): n = len(parent) if n == 0: # No nodes in the tree return 0 # Create an adjacency list from the parent array from collections import defaultdict tree = defaultdict(list) root = None for i, p in enumerate(parent): if p == -1: root = i # Root node has no parent else: tree[p].append(i) def dfs(node): Depth First Search to calculate the tree height from a given node. if not tree[node]: # If this node has no children return 0 heights = [dfs(child) for child in tree[node]] return 1 + max(heights) return dfs(root)"},{"question":"Given an array of integers representing the heights of `n` buildings on a street, you need to determine the number of buildings that can see the sunset. The buildings are standing in a straight line and the sun sets to the west (to the left). Therefore, a building can see the sunset if and only if all the buildings to the west of it (on its left) are shorter. Write a function `canSeeSunset(heights: List[int]) -> int` that takes a list of building heights and returns the number of buildings that can see the sunset. Your function should return an integer representing the number of buildings that can see the sunset.","solution":"from typing import List def canSeeSunset(heights: List[int]) -> int: Returns the number of buildings that can see the sunset. Only buildings with no taller building to their left can see the sunset. count = 0 max_height = float(\'-inf\') for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"Implement a function that takes two strings `pattern` and `str`. Determine if `str` follows the same pattern as defined by `pattern`. Here, \'follows\' means a **bijective** mapping (i.e., a one-to-one correspondence) between characters in `pattern` and non-empty words in `str`. For example: - `pattern = \\"abba\\", str = \\"dog cat cat dog\\"` should return `true`. - `pattern = \\"abba\\", str = \\"dog cat cat fish\\"` should return `false`. - `pattern = \\"aaaa\\", str = \\"dog cat cat dog\\"` should return `false`. - `pattern = \\"abba\\", str = \\"dog dog dog dog\\"` should return `false`.","solution":"def wordPattern(pattern, string): Determines if the input string follows the same pattern as the input pattern. A bijective mapping between characters in pattern and non-empty words in string must be established. words = string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: if word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"You are given a **0-indexed** array of integers `heights` that represents the heights of students in a class. A student `i` is **taller** than student `j` if `heights[i] > heights[j]`. Count the number of pairs of students `(i, j)` such that `0 <= i < j < heights.length` and the height of student `i` is strictly less than the height of student `j`. Return _the number of valid pairs_.","solution":"def count_valid_pairs(heights): Counts the number of pairs (i, j) such that 0 <= i < j < len(heights) and heights[i] < heights[j]. :param heights: List[int] - List of student heights :return: int - Number of valid pairs count = 0 n = len(heights) for i in range(n): for j in range(i + 1, n): if heights[i] < heights[j]: count += 1 return count"},{"question":"You are given a list of non-negative integers `arr`. Your task is to find the maximum sum of a non-empty subsequence such that no two elements in the subsequence are consecutive in the original list. Return an integer representing the maximum sum. For example, given the list `[3, 2, 5, 10, 7]`, the maximum sum of a non-consecutive subsequence can be `3 + 10 = 13` or `2 + 10 = 12`. Hence, the answer would be `13`.","solution":"def max_non_consecutive_sum(arr): Finds the maximum sum of a non-empty subsequence such that no two elements in the subsequence are consecutive in the original list. Args: arr (list of int): List of non-negative integers. Returns: int: Maximum sum of the non-consecutive subsequence. if not arr: return 0 if len(arr) == 1: return arr[0] n = len(arr) dp = [0] * n # Initialize the dp array dp[0] = arr[0] if n > 1: dp[1] = max(arr[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + arr[i]) return dp[-1]"},{"question":"You are given a binary tree in which each node contains an integer value. Implement the `BSTIterator` class, which represents an iterator over the binary search tree (BST). Your implementation should be able to perform the following operations efficiently: * `BSTIterator(TreeNode root)` Initializes the iterator with the root node of a BST. * `int next()` Returns the next smallest number in the BST. * `boolean hasNext()` Returns `true` if there is a next smallest number in the BST, or `false` otherwise. # Example: ``` BSTIterator iterator = new BSTIterator(root); iterator.next(); // return 3 iterator.next(); // return 7 iterator.hasNext(); // return true iterator.next(); // return 9 iterator.hasNext(); // return true iterator.next(); // return 15 iterator.hasNext(); // return true iterator.next(); // return 20 iterator.hasNext(); // return false ``` # Constraints: - The number of nodes in the tree is in the range `[1, 10^4]`. - The values of the nodes are in the range `[-10^5, 10^5]`. - `next()` and `hasNext()` calls will always be valid and can be called at most `10^4` times combined.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): # Initialize an empty stack and populate it with the leftmost path of the BST self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): # Add all the nodes along the leftmost branch of the tree to the stack while root: self.stack.append(root) root = root.left def next(self) -> int: # Node at the top of the stack is the next smallest element topmost_node = self.stack.pop() # If the node has a right child, add the leftmost branch of the right subtree if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: # Return true if there are elements in the stack return len(self.stack) > 0"},{"question":"A robot is located at the top-left corner of a `m x n` grid (marked \'Start\' at `grid[0][0]`). The robot can move either down or right at any point in time until it reaches the bottom-right corner of the grid (marked \'Finish\' at `grid[m-1][n-1]`). The robot tries to minimize the sum of all numbers along its path. You are given an `m x n` integer grid `grid` representing the cost of each cell. Return the minimum sum of the numbers along the path from `Start` to `Finish`.","solution":"def minPathSum(grid): Returns the minimum sum of the numbers along the path from the top-left corner to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first row for i in range(1, n): grid[0][i] += grid[0][i-1] # Initialize the first column for i in range(1, m): grid[i][0] += grid[i-1][0] # Compute the minimum path sums for the rest of the grid for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"A robot is located at the top-left corner of an `m x n` grid (marked \'Start\' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \'Finish\' in the diagram below). How many possible unique paths are there? An `obstacleGrid` is a 2D array that represents the grid. The value `obstacleGrid[i][j]` is `0` if the cell is empty, and `1` if the cell contains an obstacle. A path is a valid path if and only if it does not go through any obstacles. Given the `obstacleGrid` of size `m x n`, return _the total number of unique paths from the top-left corner to the bottom-right corner_. Your function should return `0` if there is no valid path.","solution":"def unique_paths_with_obstacles(obstacleGrid): Given a grid with obstacles, returns the number of unique paths from the top-left to the bottom-right corner, considering obstacles. if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"Given a list of integers `arr` and an integer `k`, return the maximum **length** of a contiguous subarray `arr[l:r+1]` if the sum of elements in this subarray is less than or equal to `k`. If there\'s no such subarray, return `0`. The subarray must have at least one element.","solution":"def max_length_subarray(arr, k): Find the maximum length of a contiguous subarray with sum less than or equal to k. :param arr: List[int] - List of integers :param k: int - Target sum limit :return: int - Maximum length of such subarray current_sum = 0 start = 0 max_length = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > k and start <= end: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an array of integers `arr`, and an integer `k`, return the number of unique pairs `(i, j)` such that `0 <= i < j < arr.length` and `arr[i] + arr[j] == k`. Two pairs `(i, j)` and `(j, i)` are considered the same and should only be counted once.","solution":"def count_unique_pairs(arr, k): Returns the number of unique pairs (i, j) such that 0 <= i < j < arr.length and arr[i] + arr[j] == k. seen = set() unique_pairs = set() for num in arr: if k - num in seen: unique_pairs.add((min(num, k - num), max(num, k - num))) seen.add(num) return len(unique_pairs)"},{"question":"You are given a **0-indexed** integer array `arr` consisting of `n` non-negative integers. You are also given an integer `k`. Create a function that returns the length of the longest subsequence of `arr` such that the differences between every two consecutive elements of the subsequence are multiples of `k`. A subsequence is derived from an original array by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_subsequence_length(arr, k): Returns the length of the longest subsequence such that the differences between every two consecutive elements of the subsequence are multiples of k. Parameters: arr (list of int): The input list of non-negative integers. k (int): The given integer k. Returns: int: The length of the longest valid subsequence. if not arr: return 0 max_len = 1 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if (arr[i] - arr[j]) % k == 0: dp[i] = max(dp[i], dp[j] + 1) max_len = max(max_len, dp[i]) return max_len"},{"question":"A **robot cleaning freely** is placed on a grid represented by a 2D array, where `0` represents an empty cell and `1` represents a blocked cell. The robot can move freely into any empty cell in four directions (up, down, left, right) without crossing any blocked cell. Given the starting position of the robot as `(startX, startY)` and the target position as `(targetX, targetY)`, return _the minimum number of moves required for the robot to reach the target or_ `-1` _if it is impossible._","solution":"from collections import deque def min_moves(grid, startX, startY, targetX, targetY): Returns the minimum number of moves required for the robot to reach the target or -1 if it is impossible. def is_valid(x, y): Check if the cell (x, y) is valid and can be visited. return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 if not is_valid(startX, startY) or not is_valid(targetX, targetY): return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(startX, startY, 0)]) visited = set((startX, startY)) while queue: x, y, moves = queue.popleft() if (x, y) == (targetX, targetY): return moves for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"You are given a `matrix` of size `m x n` consisting of non-negative integers. Your task is to find the size of the largest square containing only 1\'s and return its area. If there is no such square, return 0. The size of a square is defined as the number of 1\'s that are on the sides of the square.","solution":"def maximalSquare(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given an integer array `heights` representing the heights of students in a class. The array is sorted in non-decreasing order, and each element in `heights` denotes the height of a student. You need to find the maximum number of students that can form a line such that each student is strictly taller than the one before them. However, you can only pick students in their original order. Return the maximum number of students that can form such a line.","solution":"def max_students_in_line(heights): Returns the maximum number of students that can form a line such that each student is strictly taller than the one before them given that you can only pick students in their original order. Parameters: heights (list of int): A list of heights of students in non-decreasing order. Returns: int: The maximum number of students that can form such a line. if not heights: return 0 # The length of the Longest Increasing Subsequence (LIS) n = len(heights) dp = [1] * n for i in range(1, n): for j in range(0, i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a **0-indexed** array `nums` containing `n` integers, and an integer `m`. You can perform the following operation **exactly once**: *Select any two elements `nums[i]` and `nums[j]` (where `i != j`), and swap them*. Return _the maximum possible sum_ of `m` **consecutive** elements after performing the swap.","solution":"def max_sum_after_swap(nums, m): Returns the maximum possible sum of m consecutive elements after performing exactly one swap. n = len(nums) def max_consecutive_sum(arr, m): # Compute the max sum of m consecutive elements in array arr. current_sum = sum(arr[:m]) max_sum = current_sum for i in range(m, len(arr)): current_sum += arr[i] - arr[i - m] max_sum = max(max_sum, current_sum) return max_sum # Calculate the initial max sum of m consecutive elements without any swap. max_sum_no_swap = max_consecutive_sum(nums, m) # Try all possible pairs to swap max_sum_with_swap = max_sum_no_swap # Initialize with no swap scenario for i in range(n): for j in range(i + 1, n): # Swap nums[i] and nums[j] nums[i], nums[j] = nums[j], nums[i] # Calculate the max sum of m consecutive elements with the swap current_max_sum = max_consecutive_sum(nums, m) # Update the overall max sum after swap max_sum_with_swap = max(max_sum_with_swap, current_max_sum) # Swap back to original positions nums[i], nums[j] = nums[j], nums[i] return max_sum_with_swap"},{"question":"You are given a **doubly-linked list** of integers, `head`, where each node contains two additional pointers besides the previous and next pointers: `child` and `partner`, both of which point to another node in the doubly-linked list or `null`. You need to **flatten** the list to a single level doubly-linked list where **all child** and **partner** nodes are integrated into the list following their appearance order in the original list. The flattening should be done in-place without using extra space. Return the head of the flattened list.","solution":"class Node: def __init__(self, val: int, prev: \'Node\' = None, next: \'Node\' = None, child: \'Node\' = None, partner: \'Node\' = None): self.val = val self.prev = prev self.next = next self.child = child self.partner = partner def flatten(head: \'Node\') -> \'Node\': if not head: return head def flatten_recursively(node): current = node last = node while current: next_node = current.next if current.child: child_last = flatten_recursively(current.child) # Connect current node to child current.next = current.child current.child.prev = current # Connect child\'s last to next_node if next_node: child_last.next = next_node next_node.prev = child_last current.child = None last = child_last else: last = current if current.partner: partner_last = flatten_recursively(current.partner) # Connect current node to partner partner_last.next = current.next current.next = current.partner current.partner.prev = current current.partner = None # Ensure the next node points to the correct position after partner if next_node: next_node.prev = partner_last last = partner_last current = next_node return last flatten_recursively(head) return head"},{"question":"You are given an integer array `arr` of size `n`. Consider a subset of elements from `arr` such that the sum of elements in this subset is the greatest possible among all subsets with a sum less than or equal to a given integer `S`. Return the sum of elements in the optimal subset. Note: A subset is a set of elements that can be derived from another set by deleting some or no elements without changing the order of the remaining elements.","solution":"from itertools import combinations def max_subset_sum(arr, S): Finds the maximum sum of a subset of `arr` such that the sum is less than or equal to `S`. Parameters: arr (list of int): The array of integers S (int): The maximum allowable sum of the subset Returns: int: The maximum sum of any subset of `arr` that is <= S. n = len(arr) max_sum = 0 for r in range(n + 1): for subset in combinations(arr, r): subset_sum = sum(subset) if subset_sum <= S: max_sum = max(max_sum, subset_sum) return max_sum"},{"question":"Given an array `nums` of size `n`, return _the maximum sum of any contiguous subarray of length `k`_. If there is no subarray of length `k`, return `0`. The input length will satisfy (1 leq k leq n leq 10^5) and (-10^4 leq nums[i] leq 10^4) for (0 leq i < n).","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of any contiguous subarray of length k. If there is no subarray of length k, return 0. n = len(nums) if k > n: return 0 # Compute the initial sum of the first `k` elements max_sum = current_sum = sum(nums[:k]) # Use a sliding window to find the maximum sum of k-length subarray for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"A string `s` is called happy if it satisfies the following conditions: 1. `s` consists only of letters \'a\', \'b\', and \'c\'. 2. `s` does not contain any of the substrings \\"aaa\\", \\"bbb\\", or \\"ccc\\". Given an integer `n`, return any happy string of length `n`. If there are multiple possible happy strings, you may return any of them.","solution":"def generate_happy_string(n): Returns a happy string of length n. A happy string is a string that consists only of letters \'a\', \'b\', and \'c\' and does not contain any substrings \\"aaa\\", \\"bbb\\", or \\"ccc\\". if n <= 0: return \\"\\" # Initialize the string with \'a\' happy_string = [\'a\'] for i in range(1, n): if happy_string[-1] == \'a\': happy_string.append(\'b\') # If last character was \'a\', append \'b\' elif happy_string[-1] == \'b\': happy_string.append(\'c\') # If last character was \'b\', append \'c\' else: happy_string.append(\'a\') # If last character was \'c\', append \'a\' return \'\'.join(happy_string)"},{"question":"Given a string `s` consisting only of digits, return the largest **even** number that can be formed by rearranging the digits. If no even number can be formed, return an empty string.","solution":"def largest_even_number(s): Returns the largest even number that can be formed by rearranging the digits of the input string s. If no even number can be formed, returns an empty string. digits = sorted(s, reverse=True) # Sort digits in descending order for i in range(len(digits)-1, -1, -1): # Try to find the rightmost even digit if int(digits[i]) % 2 == 0: # Move this even digit to the end even_digit = digits.pop(i) return \'\'.join(digits) + even_digit return \'\'"},{"question":"You are given an unsorted integer array `arr` representing different lengths of ropes. Your task is to connect the ropes into one single rope with the minimum cost. The cost of connecting two ropes is equal to the sum of their lengths. Return _the minimum cost to connect all the ropes into one rope_. Example: Input: `arr = [4, 3, 2, 6]` Output: `29` Explanation: 1. Combine ropes 2 and 3 with a cost of 2 + 3 = 5, new array: [4, 5, 6] 2. Combine ropes 4 and 5 with a cost of 4 + 5 = 9, new array: [9, 6] 3. Combine ropes 9 and 6 with a cost of 9 + 6 = 15, new array: [15] 4. Total cost = 5 + 9 + 15 = 29","solution":"import heapq def min_cost_to_connect_ropes(arr): if not arr: return 0 heapq.heapify(arr) total_cost = 0 while len(arr) > 1: first = heapq.heappop(arr) second = heapq.heappop(arr) cost = first + second total_cost += cost heapq.heappush(arr, cost) return total_cost"},{"question":"Given an array of integers `arr`, partition the array into two subsets such that the difference between the sums of the subsets is minimized. Return the minimum difference.","solution":"def minimum_partition_difference(arr): Finds the minimum difference between the sums of two subsets. :param arr: List of integers :return: Minimum difference between the sums of the subsets total_sum = sum(arr) n = len(arr) dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j"},{"question":"An e-book reader application needs to manage user highlights within books. Each book is represented as a string of words separated by spaces. Users can highlight words, forming multiple non-overlapping contiguous segments of text. The application should support the following operations: 1. **Add Highlight:** Highlight a segment of the book from start index to end index. 2. **Remove Highlight:** Remove a specific highlighted segment. 3. **Get Highlights:** Return all current highlights in the text order. Implement the `EBookReader` class: - `EBookReader(string book)`: Initializes an `EBookReader` object with a given book string. - `void addHighlight(int startIndex, int endIndex)`: Highlights the segment of the book from `startIndex` to `endIndex` (inclusive). If the indices are invalid, the operation should be ignored. - `void removeHighlight(int startIndex, int endIndex)`: Removes the highlighted segment from `startIndex` to `endIndex` (inclusive). If the segment does not exist, the operation should be ignored. - `List<string> getHighlights()`: Returns a list of all highlighted segments in the order they appear in the book. Note: - Indices are 0-based. - Highlighted segments are valid if and only if `0 <= startIndex <= endIndex < length of book`. - Each segment is distinguished and non-overlapping.","solution":"class EBookReader: def __init__(self, book): self.book = book.split() self.highlights = [] def addHighlight(self, startIndex, endIndex): if 0 <= startIndex <= endIndex < len(self.book): for highlight in self.highlights: if not (endIndex < highlight[0] or startIndex > highlight[1]): return # Overlapping highlight self.highlights.append((startIndex, endIndex)) self.highlights.sort() def removeHighlight(self, startIndex, endIndex): for highlight in self.highlights: if highlight[0] == startIndex and highlight[1] == endIndex: self.highlights.remove(highlight) return def getHighlights(self): return [\' \'.join(self.book[start:end+1]) for start, end in self.highlights]"},{"question":"You are given an array of integers `arr` that may contain duplicates. Your task is to find the length of the longest subarray such that each element in this subarray occurs exactly twice. Return the length of such a subarray. A subarray is a contiguous part of an array.","solution":"def longest_subarray_with_two_occurrences(arr): Finds the length of the longest subarray where each element occurs exactly twice. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest subarray where each element occurs exactly twice. from collections import Counter if not arr: return 0 n = len(arr) max_length = 0 # Function to verify if all elements in the subarray occur exactly twice def check_twice(subarr): counter = Counter(subarr) return all(count == 2 for count in counter.values()) # Use sliding window approach to find the maximum length subarray for i in range(n): for j in range(i + 1, n, 2): # Increment by 2 for possible subarray with pairs if check_twice(arr[i:j+1]): max_length = max(max_length, j - i + 1) return max_length"},{"question":"You are given an integer array `arr` representing the daily prices of a stock for `n` consecutive days. Your task is to determine the **maximum profit** you can achieve by making exactly one transaction (i.e., buying one and selling one share of the stock). Note that you cannot sell a stock before you buy one. Return the maximum profit you can achieve. If no profit can be made, return 0.","solution":"def max_profit(arr): Returns the maximum profit that can be achieved from exactly one transaction. :param arr: List[int], list of daily stock prices :return: int, maximum profit if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given an array of integers `nums` and an integer `k`. We call a pair of indices `(i, j)` a good pair if `nums[i] + nums[j]` is a multiple of `k` and `i < j`. Return _the number of good pairs in the array_.","solution":"def count_good_pairs(nums, k): Returns the number of good pairs in the array where the sum of the elements is a multiple of k. Args: nums: List[int] - List of integers. k: int - The divisor. Returns: int - The number of good pairs. count = 0 n = len(nums) # Traverse through all pairs and check the condition for i in range(n): for j in range(i + 1, n): if (nums[i] + nums[j]) % k == 0: count += 1 return count"},{"question":"Given a `m x n` matrix `mat` and an integer `k`, return _the maximum sum of a non-empty rectangular submatrix of_ `mat` _such that the sum is no larger than_ `k`. Implement an efficient algorithm to solve the problem. Consider the following example for better understanding: Example: ``` Input: mat = [[1, 0, 1], [0, -2, 3]] k = 2 Output: 2 Explanation: Because the sum of the submatrix [[-2, 3]] is equal to 1, and 1 <= 2, we return 1. ``` Note that the solution should correctly handle negative numbers and ensure optimal time complexity for large matrices.","solution":"import bisect def max_sum_submatrix(mat, k): Returns the maximum sum of a non-empty rectangular submatrix such that the sum is no larger than k if not mat or not mat[0]: return 0 def max_sum_subarray(arr, k): sorted_prefix_sums = [0] max_subarray_sum = float(\'-inf\') prefix_sum = 0 for num in arr: prefix_sum += num idx = bisect.bisect_left(sorted_prefix_sums, prefix_sum - k) if idx < len(sorted_prefix_sums): max_subarray_sum = max(max_subarray_sum, prefix_sum - sorted_prefix_sums[idx]) bisect.insort(sorted_prefix_sums, prefix_sum) return max_subarray_sum rows, cols = len(mat), len(mat[0]) max_sum = float(\'-inf\') for left in range(cols): row_sums = [0] * rows for right in range(left, cols): for i in range(rows): row_sums[i] += mat[i][right] max_sum = max(max_sum, max_sum_subarray(row_sums, k)) if max_sum == k: return max_sum return max_sum"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of trees in a row. An operation involves choosing an index `i` and increasing the height of the tree at index `i` by `1` unit. You can perform this operation as many times as you want. Your goal is to equalize the heights of all the trees with the minimal number of operations. Return _the minimum number of operations needed to make all the trees have the same height_.","solution":"def min_operations_to_equalize_heights(heights): Returns the minimum number of operations needed to make all the trees equal in height. Parameters: heights (list of int): The heights of the trees in a row. Returns: int: The minimum number of operations needed to make all the trees have the same height. max_height = max(heights) min_operations = sum(max_height - height for height in heights) return min_operations"},{"question":"Given an integer array `nums`, design an algorithm to find three numbers whose product is maximum and return the maximum product. Return _the maximum product of any triplet in the array_.","solution":"def maximum_product_of_triplet(nums): Returns the maximum product of any triplet in the given array. :param nums: List[int] - list of integers :return: int - maximum product of any triplet nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"You are given a 2D integer array `matrix` and an integer `k`. The 2D array represents a grid of integers. You need to find the maximum sum of any submatrix that contains exactly `k` elements. A submatrix is any contiguous block of elements within the matrix. Return the maximum sum of such a submatrix.","solution":"def max_sum_submatrix(matrix, k): Finds the maximum sum of any submatrix that contains exactly k elements. :param matrix: List[List[int]]: 2D integer array. :param k: int: Number of elements the submatrix should contain. :return: int: Maximum sum of such a submatrix. rows = len(matrix) cols = len(matrix[0]) max_sum = float(\'-inf\') # Generate all possible submatrices for r1 in range(rows): for c1 in range(cols): for r2 in range(r1, rows): for c2 in range(c1, cols): # Get all elements in the submatrix (r1, c1) to (r2, c2) elements = [] for r in range(r1, r2+1): for c in range(c1, c2+1): elements.append(matrix[r][c]) # Check if the submatrix contains exactly k elements if len(elements) == k: max_sum = max(max_sum, sum(elements)) return max_sum"},{"question":"You are given a matrix filled with integers where each row and each column is sorted in ascending order. Your task is to implement a function `findElement(matrix, target)` that takes a two-dimensional list `matrix` and an integer `target`, and returns a tuple of two integers representing the position (row, column) of `target` in the matrix, or `(-1, -1)` if the target is not found. You can assume that the integers in the matrix are distinct. * For example, given the matrix `[[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]]` and `target = 5`, the function should return `(1, 1)` as `5` is found at the position (1, 1). * If the target is `20`, the function should return `(-1, -1)` since `20` is not in the matrix.","solution":"def findElement(matrix, target): Finds the position of target in the matrix. Args: matrix: List[List[int]] - a two-dimensional list where each row and column is sorted in ascending order target: int - the integer to find in the matrix Returns: Tuple[int, int] - the position (row, column) of the target in the matrix, or (-1, -1) if not found if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"Given an integer array `heights` representing the heights of students in a line, where each student is standing in line from left to right. A student `i` can see another student `j` to their right if `heights[i] > heights[j]` (strictly taller). Return the number of students in the line who are able to see at least one student immediately to their right.","solution":"def count_visible_students(heights): Returns the number of students who can see at least one student immediately to their right. Parameters: heights (list of int): List of student heights. Returns: int: Number of students who can see at least one student to their right. count = 0 for i in range(len(heights) - 1): if heights[i] > heights[i + 1]: count += 1 return count"},{"question":"Given a list of `n` integers, you need to modify the list to create the lexicographically smallest sequence possible by removing exactly one element from the list. The lexicographically smallest sequence means a sequence that appears first in the dictionary order. If there are multiple valid results, return any of them. Return the newly formed list after removing the required element.","solution":"def lexicographically_smallest_sequence(arr): Returns the lexicographically smallest sequence by removing exactly one element from the list. n = len(arr) for i in range(n - 1): if arr[i] > arr[i + 1]: return arr[:i] + arr[i+1:] # If no such element is found, remove the last element return arr[:-1]"},{"question":"Given an integer array `nums` and an integer `goal`, return the **minimum** number of operations required to make the sum of the array equal to `goal`. In one operation, you can **increment** or **decrement** any element of the array by `1`. You are allowed to perform both positive and negative operations on the same or different elements in a single move. Return the minimum number of operations needed.","solution":"def min_operations(nums, goal): Returns the minimum number of operations to make the sum of the array equal to goal. current_sum = sum(nums) difference = abs(goal - current_sum) return difference"},{"question":"Given a string `s` consisting of lowercase English letters and a word `word`, return _the smallest substring of_ `s` _that contains all the characters of_ `word` _including duplicates in any order_. If there is no such substring, return an empty string `\\"\\"`.","solution":"def min_window_substring(s, word): from collections import Counter, defaultdict word_count = Counter(word) missing_chars = len(word) min_len = float(\'inf\') min_substr = \\"\\" left = 0 counts = defaultdict(int) for right, char in enumerate(s): if word_count[char] > 0: counts[char] += 1 if counts[char] <= word_count[char]: missing_chars -= 1 while missing_chars == 0: if right - left + 1 < min_len: min_len = right - left + 1 min_substr = s[left:right + 1] if word_count[s[left]] > 0: counts[s[left]] -= 1 if counts[s[left]] < word_count[s[left]]: missing_chars += 1 left += 1 return min_substr"},{"question":"You are given a list of `n` positive integers `arr` representing the heights of buildings in a cityscape. Each building spans from `i` to `i+1` and has a height `arr[i]`. The city has a unique skyline when viewed from the left or the right. You need to determine if a building `arr[i]` can \\"see\\" the ocean which is positioned to the right of the buildings (i.e., can see beyond the last building on the right). A building can \\"see\\" the ocean if there are no taller buildings to its right. Write a function `can_see_ocean(arr: List[int]) -> List[bool]` which returns a list of booleans indicating for each building whether it can see the ocean or not. For example: ```python can_see_ocean([3, 2, 3, 4, 1]) ``` The function should return: ```python [False, False, False, True, True] ```","solution":"def can_see_ocean(arr): Determines if a building can see the ocean to its right. :param arr: List of integers representing the heights of buildings. :return: List of booleans indicating if each building can see the ocean. n = len(arr) result = [False] * n max_height_to_right = -1 for i in range(n - 1, -1, -1): if arr[i] > max_height_to_right: result[i] = True max_height_to_right = arr[i] else: result[i] = False return result"},{"question":"You are given a binary tree with `n` nodes labeled from `1` to `n`. Each node has a value assigned to it represented by a **0-indexed** integer array `values`, where `values[i]` is the value of the `i-th` node (0 <= values[i] <= 1). Your task is to prune the tree such that all the nodes with value `0` that do not have a child with a value `1` are removed. Return _the pruned tree in the form of its node values in level-order traversal_. If the root becomes `null` after pruning, return an empty list. The tree is provided as an adjacency list where the **0-indexed** parent array indicates the parent node for each node, except for the root node which has no parent indicated by `-1`.","solution":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None def build_tree(parent, values): n = len(parent) nodes = [TreeNode(values[i]) for i in range(n)] root = None for i in range(n): if parent[i] == -1: root = nodes[i] else: p = nodes[parent[i]] if not p.left: p.left = nodes[i] else: p.right = nodes[i] return root def prune_tree(node): if not node: return None node.left = prune_tree(node.left) node.right = prune_tree(node.right) if node.value == 0 and not node.left and not node.right: return None return node def level_order_traversal(root): if not root: return [] result, queue = [], [root] while queue: node = queue.pop(0) result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def prune_binary_tree(parent, values): root = build_tree(parent, values) root = prune_tree(root) return level_order_traversal(root)"},{"question":"You are given two integer arrays `nums1` and `nums2` of the same length, where `nums1[i]` and `nums2[i]` represent the endpoints of the ith interval. Your task is to merge all possible overlapping intervals and return _the total number of merged intervals_ after processing all the given intervals. An interval `[a, b]` overlaps with another interval `[c, d]` if `a <= d` and `c <= b`.","solution":"def count_merged_intervals(nums1, nums2): Merges overlapping intervals and returns the number of merged intervals. if not nums1 or not nums2 or len(nums1) != len(nums2): return 0 intervals = sorted([(nums1[i], nums2[i]) for i in range(len(nums1))]) merged_intervals = [] for interval in intervals: if not merged_intervals or merged_intervals[-1][1] < interval[0]: merged_intervals.append(interval) else: merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1])) return len(merged_intervals)"},{"question":"Given a 2D grid of size `m x n` and an integer `k`, you need to shift the grid `k` times. In one shift operation: * Move the last element of each row to the front of the next row. * Move the last element of the last row to the front of the first row. Return the 2D grid after performing the shifts.","solution":"def shiftGrid(grid, k): Shifts the grid k times. Parameters: grid (list of lists of int): The 2D grid to be shifted. k (int): The number of shifts. Returns: list of lists of int: The grid after being shifted k times. m, n = len(grid), len(grid[0]) total_elements = m * n # Flatten the grid into a 1D array for easy shifting flat_list = [grid[i][j] for i in range(m) for j in range(n)] # Perform the shift operation on the flattened list k = k % total_elements shifted_flat_list = flat_list[-k:] + flat_list[:-k] # Reform the 1D list back into a 2D grid new_grid = [ shifted_flat_list[i * n:(i + 1) * n] for i in range(m) ] return new_grid"},{"question":"Given a grid of size `n x m` where each cell represents a building block, you are allowed to remove some blocks from the grid. A block at position `(i,j)` can only be removed if there are no blocks directly above it, i.e., all positions `(k,j)` for `k < i` must be empty. You want to determine the maximum score you can achieve by removing blocks. Each block has a score, given by the `n x m` grid `grid`, where `grid[i][j]` is the score of the block at position `(i,j)`. Return _the maximum score possible by removing blocks following the above conditions_.","solution":"def max_score(grid): Returns the maximum score that can be obtained by removing blocks following the given conditions. Parameters: grid (list of list of int): 2D array representing scores of blocks in the grid Returns: int: Maximum score possible if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) max_score = 0 # Iterate through each column for j in range(m): # Accumulate the maximum score from each column for i in range(n): max_score += grid[i][j] return max_score"},{"question":"You are given an m x n matrix `board` containing characters `\'X\'` and `\'O\'`, where `\'X\'` represents a captured region and `\'O\'` represents an uncaptured region. Capture all regions that are 4-directionally surrounded by `\'X\'`. A region is captured when `\'O\'` is surrounded by `\'X\'` on all four sides. Return the modified `board` after capturing all surrounded regions.","solution":"def solve(board): Capture all regions that are 4-directionally surrounded by \'X\'. if not any(board): return m, n = len(board), len(board[0]) save = { (i, j) for k in range(max(m, n)) for i, j in ((0, k), (m-1, k), (k, 0), (k, n-1)) if 0 <= i < m and 0 <= j < n and board[i][j] == \'O\' } while save: i, j = save.pop() board[i][j] = \'S\' save |= {(x, y) for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)) if 0 <= x < m and 0 <= y < n and board[x][y] == \'O\'} board[:] = [[\'XO\'[c == \'S\'] for c in row] for row in board] return board # For testing purposes, so we can inspect the result"},{"question":"You are playing a game where you need to traverse a grid from the top-left corner to the bottom-right corner. The grid is represented by a 2D array `grid[][]`, where each cell can either be empty (represented by `0`) or contain an obstacle (represented by `1`). You can only move to adjacent cells, which are directly to the right, left, up, or down from your current cell. Write an algorithm to determine the number of unique paths from the top-left corner to the bottom-right corner, avoiding obstacles. If there is no valid path, return `0`. The path must not revisit any cell and should avoid cells containing obstacles.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles. m, n = len(grid), len(grid[0]) # Early exit if the start or end node is an obstacle if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize a 2D dp array dp = [[0 for _ in range(n)] for _ in range(m)] # Number of ways to reach the start cell is 1 if it\'s not an obstacle dp[0][0] = 1 # Fill the dp table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # No way to reach or pass through an obstacle else: # Add ways from the left cell (if within bounds) if i > 0: dp[i][j] += dp[i-1][j] # Add ways from the top cell (if within bounds) if j > 0: dp[i][j] += dp[i][j-1] # The answer is the number of ways to reach the bottom-right corner return dp[m-1][n-1]"},{"question":"Given a linked list, write a function to reverse every `k` nodes in the linked list. If the number of nodes is not a multiple of `k`, reverse the remaining nodes as well. The function should return the modified linked list. For example, given `1 -> 2 -> 3 -> 4 -> 5 -> 6` and `k = 2`, the linked list should be modified to `2 -> 1 -> 4 -> 3 -> 6 -> 5`. If `k = 3`, the linked list would be modified to `3 -> 2 -> 1 -> 6 -> 5 -> 4`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): if head is None or k == 1: return head dummy = ListNode(0) dummy.next = head current = dummy nex = dummy pre = dummy count = 0 while current.next is not None: current = current.next count += 1 while count >= k: current = pre.next nex = current.next for _ in range(1, k): current.next = nex.next nex.next = pre.next pre.next = nex nex = current.next pre = current count -= k return dummy.next def list_to_linkedlist(items): if not items: return None head = ListNode(items[0]) current = head for item in items[1:]: current.next = ListNode(item) current = current.next return head def linkedlist_to_list(head): items = [] while head: items.append(head.val) head = head.next return items"},{"question":"You are given an integer array `costs` where `costs[i]` is the cost of hiring the `i-th` worker. You are also given an integer `k`, the number of workers to hire, and an integer `candidates`, the number of candidates from the beginning and end of the array that you can interview before making a hiring decision. You need to hire exactly `k` workers and minimize the total cost of hiring. At each step, you can only interview candidates from the beginning or end of the remaining array. Return _the minimum total cost to hire exactly `k` workers_.","solution":"import heapq def min_cost_to_hire_workers(costs, k, candidates): Returns the minimum total cost to hire exactly k workers. :param costs: List[int] representing the cost of hiring the i-th worker. :param k: int, the number of workers to hire. :param candidates: int, the number of candidates from the beginning and end to interview. :return: int, the minimum total cost to hire exactly k workers. if k == 0 or not costs: return 0 min_heap = [] left_candidates = min(len(costs), candidates) right_candidates = min(len(costs), candidates) for i in range(left_candidates): heapq.heappush(min_heap, (costs[i], i)) for j in range(len(costs) - right_candidates, len(costs)): heapq.heappush(min_heap, (costs[j], j)) total_cost = 0 hired = 0 hired_indices = set() while hired < k: cost, idx = heapq.heappop(min_heap) if idx not in hired_indices: total_cost += cost hired += 1 hired_indices.add(idx) if idx < left_candidates and left_candidates < len(costs): heapq.heappush(min_heap, (costs[left_candidates], left_candidates)) left_candidates += 1 elif idx >= len(costs) - right_candidates and len(costs) - right_candidates > 0: right_candidates -= 1 if right_candidates > 0: heapq.heappush(min_heap, (costs[len(costs) - right_candidates - 1], len(costs) - right_candidates - 1)) return total_cost"},{"question":"You are given an unsorted array of integers `nums` and a positive integer `target`. Write a function that returns the maximum length of a contiguous subarray whose sum is less than or equal to `target`. If there is no such subarray, return `0`.","solution":"def max_length_subarray(nums, target): Returns the maximum length of a contiguous subarray whose sum is less than or equal to target. If there is no such subarray, returns 0. n = len(nums) max_len = 0 current_sum = 0 start = 0 # Start index of the current subarray for end in range(n): current_sum += nums[end] while current_sum > target and start <= end: current_sum -= nums[start] start += 1 if current_sum <= target: max_len = max(max_len, end - start + 1) return max_len"},{"question":"You work for a company that processes large datasets. You are given a list of integers `nums` representing dataset IDs, which may contain duplicates. Your task is to determine if any integer appears **at least three times** in the list. If such an integer exists, return `true`; otherwise, return `false`. Your solution should be efficient, ideally with a linear runtime complexity.","solution":"def contains_three_duplicates(nums): Returns True if any integer appears at least three times in the nums list. Otherwise, returns False. from collections import Counter count = Counter(nums) for value in count.values(): if value >= 3: return True return False"},{"question":"You are given a **0-indexed** integer array `cost` representing the cost of picking each candy from a row of candies, where `cost[i]` is the cost of picking the `i`th candy. You can pick any two candies such that the total cost does not exceed a given integer `budget`. Return _the maximum number of pairs of candies you can pick with the given `budget`_. A candy can be picked at most once from the array.","solution":"def max_candy_pairs(cost, budget): Returns the maximum number of pairs of candies with total cost not exceeding the budget. :param cost: List[int] - the cost of picking each candy :param budget: int - the maximum allowed cost for any pair of candies :return: int - the maximum number of pairs of candies that can be picked n = len(cost) cost.sort() # Sorting to maximize the number of pairs left, right = 0, n - 1 pairs = 0 while left < right: if cost[left] + cost[right] <= budget: pairs += 1 left += 1 right -= 1 else: right -= 1 return pairs"},{"question":"**[Question 4]:** Given an array of integers and an integer `k`, return `true` if there are two distinct indices `i` and `j` in the array such that `nums[i]` is equal to `nums[j]` and the absolute difference between `i` and `j` is at most `k`. Otherwise, return `false`.","solution":"def contains_nearby_duplicate(nums, k): Checks if there are two distinct indices i and j in the array `nums` such that nums[i] == nums[j] and the absolute difference between i and j is at most `k`. Parameters: nums (list of int): The list of integers. k (int): The maximum allowed index difference. Returns: bool: True if such pair of indices exist, False otherwise. num_index_map = {} for index, num in enumerate(nums): if num in num_index_map and index - num_index_map[num] <= k: return True num_index_map[num] = index return False"},{"question":"You are given a **0-indexed** array `costs` where `costs[i]` is the cost of hiring the `i-th` worker. You are also given an integer `k` which represents the number of workers you need to hire, and an integer `c` which represents the maximum number of workers you can fire and replace after initially hiring them. You need to hire exactly `k` workers such that the total cost is minimized, and you are allowed to fire and replace up to `c` workers after the initial hiring to achieve this minimal cost. Describe a function that returns _the **minimum** total cost to hire exactly_ `k` _workers, allowing up to_ `c` _replacements_.","solution":"def min_cost_hire(costs, k, c): Returns the minimum total cost to hire exactly k workers, allowing up to c replacements. :param costs: List of integers representing the cost of hiring each worker. :param k: Integer representing the number of workers to be hired. :param c: Integer representing the maximum number of workers that can be replaced. :return: Integer representing the minimum total cost. costs.sort() n = len(costs) # Calculate the initial cost of hiring the first k workers initial_cost = sum(costs[:k]) if c == 0: return initial_cost # Initialize min_cost to initial_cost for cases where no replacements might be needed min_cost = initial_cost # To minimize the cost, we need to find the optimal workers to replace for i in range(1, c + 1): if k - i < 0 or k - i >= n: break left_to_replace = k - i right_to_keep = n - i current_cost = sum(costs[:left_to_replace]) + sum(costs[-i:]) min_cost = min(min_cost, current_cost) return min_cost"},{"question":"Given an array of integers `arr`, you need to implement a function that finds and returns the length of the longest subarray that contains all unique elements. A subarray is a contiguous part of an array. Ensure that your solution is efficient in terms of time complexity.","solution":"def longest_unique_subarray(arr): Finds the length of the longest subarray that contains all unique elements. :param arr: List of integers :return: Length of the longest subarray with unique elements element_index_map = {} max_length = 0 start = 0 for end in range(len(arr)): if arr[end] in element_index_map: start = max(start, element_index_map[arr[end]] + 1) element_index_map[arr[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a string `s`, return the length of the longest subsequence that appears at least twice as a substring in `s`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_repeated_subsequence_length(s): Returns the length of the longest subsequence that appears at least twice as a substring. n = len(s) dp = [[0] * (n + 1) for _ in range(n + 1)] # Building the dp array for i in range(1, n + 1): for j in range(1, n + 1): if s[i - 1] == s[j - 1] and i != j: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The value at dp[n][n] will be the length of the longest repeating subsequence return dp[n][n]"},{"question":"You are given a **0-indexed** integer array `temperatures` representing daily temperatures over a certain period. The temperature on the `i`th day is `temperatures[i]`. Define a **heat wave** as a consecutive sequence of days where each day\'s temperature is strictly higher than the previous day\'s. Return _the maximum length_ of any heat wave found in the array. If no heat wave exists, return `0`.","solution":"def max_heat_wave_length(temperatures): Returns the maximum length of any heat wave found in the array of temperatures. A heat wave is defined as a consecutive sequence of days where each day\'s temperature is strictly higher than the previous day\'s. If no heat wave exists, returns 0. if not temperatures: return 0 max_length = 0 current_length = 0 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 # Add 1 because the heat wave length includes the starting day return max_length + 1 if max_length > 0 else 0"},{"question":"Given an array of integers `arr`, return the length of the longest contiguous subarray consisting of only even numbers. The elements of the input array are guaranteed to be between -10^6 and 10^6. **Example:** ``` arr = [2, 4, 1, 6, 8] Output: 2 arr = [1, 3, 5, 7] Output: 0 arr = [6, 2, 4, 8, 10] Output: 5 ```","solution":"def longest_even_subarray(arr): Returns the length of the longest contiguous subarray consisting of only even numbers. max_len = 0 current_len = 0 for num in arr: if num % 2 == 0: current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len"},{"question":"You are given a list of integers `nums` and an integer `k`. Your task is to find the maximum length of a contiguous subarray that equals to `k` when summed. If there is no such subarray, return `0`. For example, given `nums = [1, -1, 5, -2, 3]` and `k = 3`, the longest subarray that sums to `3` is `[1, -1, 5, -2]`, and its length is `4`.","solution":"def max_subarray_length(nums, k): Returns the maximum length of a contiguous subarray that sums to k. Args: nums: List[int] - the list of integers. k: int - the target sum for the subarray. Returns: int - the maximum length of the subarray, or 0 if no such subarray exists. cumulative_sum = 0 sum_indices = {0: -1} max_length = 0 for i, num in enumerate(nums): cumulative_sum += num if cumulative_sum - k in sum_indices: max_length = max(max_length, i - sum_indices[cumulative_sum - k]) if cumulative_sum not in sum_indices: sum_indices[cumulative_sum] = i return max_length"},{"question":"You have an integer array `prices` where `prices[i]` represents the price of a financial asset on the i-th day. You are allowed to complete at most one transaction, where a transaction consists of buying the asset on one day and selling it on a later day. Return _the **maximum profit** you can achieve from this transaction_. If no profit is possible, return `0`.","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy and sell transaction. If no profit is possible, returns 0. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given an **m x n** 2D grid of integers representing a matrix, and an integer `target`. Your task is to determine if there is a rectangular sub-matrix within the given matrix such that the sum of all the integers in the sub-matrix is equal to `target`. Return `true` if such a sub-matrix exists, and `false` otherwise. You may assume that the integers in the matrix can be negative, and the size of the matrix is at least `1x1`.","solution":"def submatrix_sum_target(matrix, target): Determines if there is a sub-matrix with a sum equal to the target. Args: matrix: List of lists of integers, representing the 2D grid. target: Integer, the target sum for the sub-matrix. Returns: A boolean indicating whether a sub-matrix exists with sum equal to the target. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) for left in range(cols): row_sum = [0] * rows for right in range(left, cols): for i in range(rows): row_sum[i] += matrix[i][right] if find_subarray_with_sum(row_sum, target): return True return False def find_subarray_with_sum(array, target): Helper function to find if there is a contiguous subarray with a sum equals to target. Args: array: List of integers. target: Integer, the target sum for the subarray. Returns: A boolean indicating whether a subarray exists with sum equal to the target. current_sum = 0 sum_dict = {0: -1} for i, num in enumerate(array): current_sum += num if current_sum - target in sum_dict: return True if current_sum not in sum_dict: sum_dict[current_sum] = i return False"},{"question":"Design a class that simulates a basic file system. Instead of a full-fledged and complex file system, you need to implement the following operations: * `FileSystem()` - Initializes the file system object. * `boolean createPath(String path, int value)` - Creates a new path and associates a value to it if possible and returns `true`. If the parent path doesn\'t exist or the path already exists, returns `false`. * `int get(String path)` - Returns the value associated with the path, or `-1` if the path doesn\'t exist. Your implementation should make sure that: * A path is a valid Unix-like path comprised of one or more components separated by `\\"/\\"`. * Each component should consist of only lowercase English letters. * The input path should not have redundant `\\"/\\"` characters. * The only parent path allowed for a new path `/a/b` will be `/a`. If the parent path `/a` doesn\'t exist, the path `/a/b` cannot be created.","solution":"class FileSystem: def __init__(self): self.paths = {} def createPath(self, path: str, value: int) -> bool: if not path or path == \\"/\\" or path in self.paths: return False parent_path = path.rsplit(\'/\', 1)[0] if parent_path and parent_path not in self.paths and parent_path != \\"/\\": return False self.paths[path] = value return True def get(self, path: str) -> int: return self.paths.get(path, -1)"},{"question":"You are given a list of **0-indexed** strings `words` and a string `chars`. Each string in `words` consists of lowercase English letters, and `chars` is a string of distinct lowercase English letters. You need to form new strings from the strings in `words` by using the characters from `chars` as many times as they appear in `chars`. Return the sum of the lengths of all good strings in `words`. A string is considered good if all characters in the string can be formed using characters from `chars`. Note that each character from `chars` can only be used once per word. For example, if `words = [\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"]` and `chars = \\"atach\\"`, the good strings are \\"cat\\" and \\"hat\\", and the sum of their lengths is 3 + 3 = 6.","solution":"from collections import Counter def count_characters(words, chars): Returns the sum of the lengths of all good strings in words that can be formed using the characters from chars. chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= chars_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"You are given a `0-indexed` integer array `nums` of length `n` consisting of varying integers. Your goal is to determine if you can re-arrange the array to form an arithmetic sequence. An **arithmetic sequence** is an array that satisfies the condition `a, a+d, a+2d, a+3d, ...` where `d` is a non-zero integer. Return _`true` if it\'s possible to re-arrange the array into an arithmetic sequence, otherwise, return `false`._","solution":"def can_make_arithmetic_sequence(nums): Determines if an array can be re-arranged to form an arithmetic sequence. Args: nums (list of int): List of integers. Returns: bool: True if the array can be re-arranged to form an arithmetic sequence, otherwise False. if len(nums) < 2: return True # A sequence with less than 2 elements is trivially an arithmetic sequence nums.sort() difference = nums[1] - nums[0] for i in range(2, len(nums)): if nums[i] - nums[i - 1] != difference: return False return True"},{"question":"You are given a string `S` representing a compressed version of a string where consecutive repeated characters are represented as the character followed by the number of repetitions. For example, the string \\"a3b2\\" would be uncompressed to \\"aaabb\\". Write a function `uncompress` that takes `S` and returns the uncompressed string. If a character appears in `S` without a number following it, it should repeat only once. You can assume that the input string is always valid.","solution":"def uncompress(S): Uncompresses a given compressed string S. Args: S (str): Compressed string where consecutive repeated characters are represented as the character followed by the number of repetitions. Returns: str: The uncompressed string. result = [] i = 0 length = len(S) while i < length: char = S[i] i += 1 count = 0 while i < length and S[i].isdigit(): count = count * 10 + int(S[i]) i += 1 if count == 0: result.append(char) else: result.append(char * count) return \'\'.join(result)"},{"question":"You are given an array called `tasks` where `tasks[i]` represents the time in minutes required to complete the `i-th` task. You need to organize these tasks in pairs such that the sum of the times of the tasks in each pair is as close as possible to a given integer `target`. Write a function to determine the optimal pairing and return their indices as a list of pairs. If multiple pairings yield the same closest sum, return any of them.","solution":"def find_optimal_task_pairs(tasks, target): Finds the optimal pairing of tasks such that the sum of the times of the tasks in each pair is as close as possible to the target. Parameters: tasks (list): A list of integers where tasks[i] is the time in minutes required to complete the i-th task. target (int): The target sum of the times. Returns: list: A list of pairs of indices representing the tasks, where each pair is as close as possible to the target sum. n = len(tasks) indices = list(range(n)) indices.sort(key=lambda i: tasks[i]) # Sort indices based on the tasks\' values result = [] used = [False] * n # To keep track of used tasks for i in range(n): if used[i]: continue min_diff = float(\'inf\') best_pair = None for j in range(i + 1, n): if used[j]: continue sum_pair = tasks[indices[i]] + tasks[indices[j]] diff = abs(sum_pair - target) if diff < min_diff: min_diff = diff best_pair = j if best_pair is not None: used[i] = True used[best_pair] = True result.append((indices[i], indices[best_pair])) return result"},{"question":"You are given a string `s` and a list of strings `words`. Find and return all unique substrings in `s` that are concatenations of each word in `words` exactly once and without any intervening characters. The order of the words in `words` does not matter. The input strings are lowercase English letters. Implement the function `find_concatenation_substrings(s: str, words: List[str]) -> List[int]` that returns a list of starting indices of the concatenation substrings in `s`. For example, given `s = \\"barfoothefoobarman\\"` and `words = [\\"foo\\", \\"bar\\"]`, you should return `[0, 9]` since the substring starting at index 0 is `barfoo` and the substring starting at index 9 is `foobar`. If there are no concatenations that match, return an empty list.","solution":"from typing import List from collections import Counter def find_concatenation_substrings(s: str, words: List[str]) -> List[int]: if not s or not words: return [] word_length = len(words[0]) total_length = len(words) * word_length word_count = Counter(words) result_indices = [] for i in range(len(s) - total_length + 1): seen_words = {} j = i while j < i + total_length: word = s[j:j + word_length] if word in word_count: seen_words[word] = seen_words.get(word, 0) + 1 if seen_words[word] > word_count[word]: break else: break j += word_length if seen_words == word_count: result_indices.append(i) return result_indices"},{"question":"Given a string `expression` containing only one kind of pairing parentheses, determine if the expression is valid. A valid expression is one where every opening parenthesis `(` has a corresponding closing parenthesis `)`, and vice versa, and they are correctly nested. Example cases: - Input: \\"(())\\" - Output: True - Input: \\"(()\\" - Output: False - Input: \\"())(\\" - Output: False","solution":"def is_valid_parentheses(expression): Checks if the input expression has valid parentheses. stack = [] for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"You are given a list of integers `heights` representing the heights of a sequence of buildings. A building can either obtain water from its left neighboring building or its right neighboring building, but with a few conditions. If `heights[i] < heights[i-1]` and `heights[i] < heights[i+1]`, the building at index `i` can collect water only if there is water available from either of its taller neighboring buildings. You need to output the total number of buildings that can collect water from their neighbors given these constraints. Return the number of such buildings that can obtain water from their neighbors.","solution":"def count_water_receiving_buildings(heights): Returns the count of buildings that can collect water from their neighbors given the constraints. if len(heights) < 3: return 0 count = 0 for i in range(1, len(heights) - 1): if heights[i] < heights[i - 1] and heights[i] < heights[i + 1]: count += 1 return count"},{"question":"Consider a function that implements an algorithm to determine if a string `s` can be transformed into a palindrome by rearranging its characters. The function has one input parameter, `s`, which is a non-empty string consisting of lowercase English letters. The purpose of the function is to return **true** if it is possible to rearrange the characters of `s` to form a palindrome, and **false** otherwise. A **palindrome** is a sequence of characters that reads the same backward as forward. Implement the function as specified and return the result.","solution":"from collections import Counter def can_form_palindrome(s): Determines if the string s can be rearranged to form a palindrome. A string can be rearranged into a palindrome if and only if at most one character occurs an odd number of times. Parameters: s (str): A non-empty string consisting of lowercase English letters. Returns: bool: True if s can be rearranged to form a palindrome, False otherwise. # Count the occurrences of each character in the string char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # There can be at most one odd count for the string to be rearranged into a palindrome return odd_count <= 1"},{"question":"Given a string `s` and an integer `k`, determine if `s` can be rearranged such that any two adjacent characters are at least `k` distance apart. If such an arrangement is possible, return `true`. Otherwise, return `false`.","solution":"from collections import Counter import heapq def can_rearrange_string(s: str, k: int) -> bool: Determine if the string s can be rearranged such that any two adjacent characters are at least k distance apart. :param s: The input string :param k: The minimum distance between adjacent same characters :return: True if the rearrangement is possible, False otherwise if k == 0: return True counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) wait_queue = [] res = [] while max_heap: count, char = heapq.heappop(max_heap) res.append(char) count += 1 wait_queue.append((count, char)) if len(wait_queue) >= k: to_reinsert = wait_queue.pop(0) if to_reinsert[0] < 0: heapq.heappush(max_heap, to_reinsert) return len(res) == len(s)"},{"question":"You are given a list of `n` numbers that represent the heights of buildings in a row. You can paint each building in one of the three colors: `Red`, `Green`, or `Blue`. The cost of painting each building with a particular color is represented by an `n x 3` cost matrix where `cost[i][0]`, `cost[i][1]`, and `cost[i][2]` represent the cost of painting the `i`-th building with the color Red, Green, and Blue respectively. You need to paint all buildings such that no two adjacent buildings have the same color. Implement a function `int minCostToPaintBuildings(int[][] cost)` that returns the minimum cost to paint all the buildings under the given constraints.","solution":"def minCostToPaintBuildings(cost): if not cost: return 0 n = len(cost) # Initialize the first row prev_red, prev_green, prev_blue = cost[0] # Iterate over each building from the second one to the last one for i in range(1, n): curr_red = cost[i][0] + min(prev_green, prev_blue) curr_green = cost[i][1] + min(prev_red, prev_blue) curr_blue = cost[i][2] + min(prev_red, prev_green) # Update for the next iteration prev_red, prev_green, prev_blue = curr_red, curr_green, curr_blue # The minimum cost would be the minimum of painting the last building in any of the three colors return min(prev_red, prev_green, prev_blue)"},{"question":"You are given two strings `a` and `b` of the same length. Your task is to find the longest substring that appears in both `a` and `b`. Return _the length of this longest substring_.","solution":"def longest_common_substring_length(a, b): Returns the length of the longest common substring of a and b. n, m = len(a), len(b) dp = [[0] * (m + 1) for _ in range(n + 1)] max_length = 0 for i in range(1, n + 1): for j in range(1, m + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"Given a **binary tree**, return _a **2D list** representing its level order traversal. A level order traversal of a binary tree is a traversal that visits each node level by level from left to right. Each sublist in the returned list should contain the values of the nodes at that particular level in the tree._","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of a binary tree as a 2D list. :param root: TreeNode, the root of the binary tree :return: List[List[int]], a 2D list containing level order traversal if not root: return [] result = [] queue = deque([root]) while queue: level = [] for i in range(len(queue)): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"You are given a string `s` and an integer `k`. The string `s` consists of lower-case English letters and digits. You need to perform an operation either on a letter or on a digit, based on the following conditions: - If it\'s a letter, you need to convert it to an uppercase letter. - If it\'s a digit, you need to increase it by `k`. If the increase causes the digit to surpass \'9\', it should wrap around, starting again from \'0\'. Return the modified string after performing the operations. [Question] 4:","solution":"def modify_string(s, k): Modify the string based on the given conditions. - Convert letters to uppercase. - Increment digits by k, wrapping around if necessary. Args: s (str): the input string consisting of lower-case letters and digits. k (int): the number to add to each digit. Returns: str: the modified string. result = [] for char in s: if char.isdigit(): new_digit = (int(char) + k) % 10 result.append(str(new_digit)) elif char.islower(): result.append(char.upper()) return \\"\\".join(result)"},{"question":"You are given a binary tree represented by its root node. Write a function that returns a list of node values in the tree\'s **preorder* traversal. Preorder traversal is a type of depth-first traversal where nodes are processed in the following order: root, left subtree, right subtree.","solution":"class TreeNode: Definition for a binary tree node. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root): Returns the preorder traversal of the binary tree nodes. def traverse(node): if node: result.append(node.val) traverse(node.left) traverse(node.right) result = [] traverse(root) return result"},{"question":"You are given a list of integers representing the prices of a stock on different days. You need to maximize your profit by choosing a single day to buy one stock and a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. **Function Signature:** ```python def maxProfit(prices: List[int]) -> int: ``` **Constraints:** - The length of prices is at least 2 and at most 10^5. - The prices are represented as non-negative integers and each value is less than or equal to 10^4.","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Returns the maximum profit possible from buying and then selling a stock. :param prices: List[int] - List of stock prices on different days. :return: int - Maximum profit possible. If no profit is possible, returns 0. # Initialize variables to keep track of minimum price and maximum profit min_price = float(\'inf\') max_profit = 0 # Iterate through each price in the list for price in prices: # Update the minimum price if the current price is lower if price < min_price: min_price = price # Calculate potential profit if sold at the current price profit = price - min_price # Update maximum profit if the current profit is higher if profit > max_profit: max_profit = profit return max_profit"},{"question":"You have a `friends` matrix representing a friendship graph, where `friends[i][j]` is 1 if person i and person j are friends, and 0 otherwise. A friend group is a group of people who are all directly or indirectly friends. Your task is to write a function that returns the number of friend groups in the graph. A person can be in exactly one friend group. Each friendship relation is symmetric (i.e., if person i is friends with person j, then person j is friends with person i).","solution":"def findCircleNum(friends): def dfs(node, visited, friends): for neighbor, is_friend in enumerate(friends[node]): if is_friend and neighbor not in visited: visited.add(neighbor) dfs(neighbor, visited, friends) visited = set() friend_groups = 0 for person in range(len(friends)): if person not in visited: dfs(person, visited, friends) friend_groups += 1 return friend_groups"},{"question":"You are given a list of `n` integers representing the heights of buildings in a row. Each building has a width of 1. The goal is to find the largest rectangular area that can be formed within this row by selecting a contiguous group of buildings. The rectangle must be constrained within the row of buildings and its height is defined by the shortest building within the selected group. Write a function `largestRectangleArea(heights: List[int]) -> int` that returns the maximum area of the rectangle that can be formed in the histogram. For example: - Given the list of heights `[2, 1, 5, 6, 2, 3]`, the function should return `10`. The largest rectangle can be formed from buildings with heights `[5, 6]` (2nd and 3rd buildings from the right). - Given the list of heights `[2, 4]`, the function should return `4`. The largest rectangle can be formed from the building with a height `4` (the last building in the list).","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Function to find the largest rectangular area in a histogram represented by heights. stack = [] max_area = 0 index = 0 # Iterate through all buildings in heights while index < len(heights): # If the stack is empty or current building is higher than the building on top of stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top building as the smallest building top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Clean up the remaining buildings in the stack while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a binary search tree (BST), return the sum of values of all nodes with a value in the range [low, high], inclusive. A binary search tree is a binary tree in which each node has at most two children and the left child\'s value is less than the parent\'s value, while the right child\'s value is greater than the parent\'s value. Implement the `Solution` class: * `Solution(TreeNode root)` - Initializes the object with the root of the BST. * `int rangeSumBST(int low, int high)` - Returns the sum of all node values in the given range [low, high], inclusive.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def __init__(self, root: TreeNode): self.root = root def rangeSumBST(self, low: int, high: int) -> int: def dfs(node): if not node: return 0 if node.val < low: return dfs(node.right) if node.val > high: return dfs(node.left) return node.val + dfs(node.left) + dfs(node.right) return dfs(self.root)"},{"question":"You are given two strings `word1` and `word2`. You want to create a merged string where characters from `word1` and `word2` are interleaved in a way that maintains the relative order of characters from both strings. If one string is exhausted before the other, append the rest of the characters from the longer string to the merged string. Return the resultant merged string.","solution":"def merge_alternately(word1, word2): Merge two strings by interleaving their characters. If the lengths of the strings are different, append the remaining characters of the longer string to the result. Parameters: word1 (str): The first string. word2 (str): The second string. Returns: str: The merged string. merged = [] i = 0 # Loop through both strings until the end of the shortest string while i < len(word1) and i < len(word2): merged.append(word1[i]) merged.append(word2[i]) i += 1 # Append any remaining characters from word1 if i < len(word1): merged.append(word1[i:]) # Append any remaining characters from word2 if i < len(word2): merged.append(word2[i:]) return \'\'.join(merged)"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house. The houses are arranged in a circle, which means the first house is the neighbor of the last one. You are a professional robber planning to rob houses along this street, but you cannot rob two adjacent houses at the same time. Implement a function `robCircularHouses(nums)` that returns the maximum amount of money you can rob without alerting the police. Function Signature: ```python def robCircularHouses(nums: List[int]) -> int: ``` # Example: ```python robCircularHouses([2,3,2]) # Output: 3 (Rob houses 1 and 3) robCircularHouses([1,2,3,1]) # Output: 4 (Rob houses 1 and 3 or houses 2 and 4) ```","solution":"from typing import List def robCircularHouses(nums: List[int]) -> int: def robLinearHouses(nums: List[int]) -> int: prev = curr = 0 for num in nums: new_curr = max(curr, prev + num) prev = curr curr = new_curr return curr n = len(nums) if n == 1: return nums[0] return max(robLinearHouses(nums[:-1]), robLinearHouses(nums[1:]))"},{"question":"You are given a string `s` consisting of lowercase English letters and a list of queries. Each query is a triple `(left, right, char)` where `left` and `right` represent start and end indices (inclusive) within the string, and `char` is a character. For each query, determine the number of times the character `char` appears in the substring `s[left:right+1]`. Return a list of integers where each integer corresponds to the result of each query.","solution":"def count_occurrences(s, queries): Counts occurrences of a given character in a given substring for each query. Parameters: s (str): the input string consisting of lowercase English letters queries (list): a list of queries, each a triple (left, right, char) Returns: list: a list of integers where each integer is the result of each query results = [] for left, right, char in queries: results.append(s[left:right+1].count(char)) return results"},{"question":"You are given an **m x n** integer matrix `matrix` with the following rules: - Each row is sorted in **non-decreasing order** from left to right. - Each column is sorted in **non-decreasing order** from top to bottom. Given an integer `target`, write an algorithm to find the position [i, j] of `target` in the matrix, where `i` is the row index and `j` is the column index. If the `target` is not found, return `[-1, -1]`. The algorithm must run in `O(m + n)` time.","solution":"def search_matrix(matrix, target): Searches for the target in a m x n matrix with sorted rows and columns. Returns the position [i, j] of the target if found, otherwise returns [-1, -1]. if not matrix: return [-1, -1] rows, cols = len(matrix), len(matrix[0]) # Start from the top-right corner of the matrix row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return [row, col] elif matrix[row][col] > target: col -= 1 else: row += 1 return [-1, -1]"},{"question":"Given a list of strings `words`, where each word is a combination of lowercase English letters, find and return all the words that can be typed using letters of only one row of an American QWERTY keyboard. Note that the keyboard rows consist of the following letters: - First row: \\"qwertyuiop\\" - Second row: \\"asdfghjkl\\" - Third row: \\"zxcvbnm\\" Example: ``` Input: words = [\\"hello\\", \\"Alaska\\", \\"Dad\\", \\"peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` You can assume that the input list of words will not contain any empty string.","solution":"def findWords(words): Returns the list of words that can be typed using letters of only one row of an American QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = word.lower() if all(char in row1 for char in lower_word) or all(char in row2 for char in lower_word) or all(char in row3 for char in lower_word): result.append(word) return result"},{"question":"Given a **0-indexed** integer array `nums`, find the **minimum** number of moves required to make all elements in the array equal, where a **move** is incrementing a selected element by 1 or decrementing a selected element by 1. Return _the **minimum** number of moves required to make all elements of_ `nums` _equal_.","solution":"def min_moves_to_equal(nums): Returns the minimum number of moves required to make all elements of nums equal. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"Given a list of `n` integers where each integer represents the number of stones in a corresponding pile, you must determine if you can win a hypothetical game. In each turn, a player can remove 1 to 3 stones from any single pile. The player who cannot make a move loses the game. Assume you always play first. Write a function to determine whether you can guarantee a win if both you and your opponent play optimally. Return `True` if you can guarantee a win, otherwise return `False`.","solution":"def can_win_nim(piles): Determines if you can guarantee a win given the piles of stones. Parameters: piles (list of int): List of integers representing the number of stones in piles. Returns: bool: True if you can guarantee a win, False otherwise. # Calculate the total number of stones total_stones = sum(piles) # According to the Nim Game, you can guarantee a win if total number of stones is not multiple of 4 return total_stones % 4 != 0"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting of lowercase letters. Your task is to check if it is possible to transform `s1` into `s2` using exactly one swap between any two characters in `s1`. Implement the function `bool canTransformWithOneSwap(string s1, string s2)` that returns `true` if it is possible to transform `s1` into `s2` with exactly one swap, and `false` otherwise. **Example:** - `canTransformWithOneSwap(\\"bank\\", \\"kanb\\")` returns `true` - `canTransformWithOneSwap(\\"attack\\", \\"defend\\")` returns `false` - `canTransformWithOneSwap(\\"abcd\\", \\"abdc\\")` returns `true` **Note:** - A string `s1` can be transformed into a string `s2` with exactly one swap if there are exactly two positions `i` and `j` such that `s1[i] != s2[i]` and swapping `s1[i]` with `s1[j]` results in `s2`.","solution":"def canTransformWithOneSwap(s1, s2): if len(s1) != len(s2): return False diff = [] for i in range(len(s1)): if s1[i] != s2[i]: diff.append(i) # If there are exactly two indices that are different if len(diff) == 2: i, j = diff # Check if swapping the characters at these two indices will result in s2 return (s1[i] == s2[j] and s1[j] == s2[i]) # If there are not exactly two differences, return False return False"},{"question":"You are given a linked list where each node contains an integer value. Using two pointers, determine if there is a cycle in the linked list. Implement a function `hasCycle` that returns `true` if there is a cycle in the linked list, and `false` if there is no cycle. Note that a linked list cycle means that the linked list has some node that can be reached again by continuously following the `next` pointer. The number of nodes in the list is in the range `[0, 10^4]`, and the values of the nodes are in the range `[-10^5, 10^5]`.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Detects if a linked list has a cycle using Floyd\'s Cycle-Finding Algorithm. :param head: ListNode :return: bool slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"A company wants to send data between two computers over a network. The network is represented as a graph with `n` nodes from `0` to `n - 1` and `m` bidirectional edges. Each edge has a certain time in seconds it takes to transfer a unit of data. You are given a list of `edges`, where each `edges[i] = [u, v, time]` represents a bidirectional edge between node `u` and node `v` that takes `time` seconds to transfer data. Also, two computers are connected to nodes `start` and `end`. Your task is to find the minimum time required to transfer data from the computer connected to `start` to the computer connected to `end`. If it is impossible to transfer the data between the two computers, return `-1`.","solution":"import heapq def network_delay_time(edges, n, start, end): Finds the minimum time required to transfer data from the start node to the end node. Returns -1 if it is impossible to transfer data between the two nodes. # Create an adjacency list representation of the graph graph = {i: [] for i in range(n)} for u, v, time in edges: graph[u].append((v, time)) graph[v].append((u, time)) # Use Dijkstra\'s algorithm to find the shortest path pq = [(0, start)] # Priority queue to store (time, node) pairs min_time = {i: float(\'inf\') for i in range(n)} min_time[start] = 0 while pq: current_time, node = heapq.heappop(pq) if node == end: return current_time if current_time > min_time[node]: continue for neighbor, time in graph[node]: new_time = current_time + time if new_time < min_time[neighbor]: min_time[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor)) return -1 if min_time[end] == float(\'inf\') else min_time[end]"},{"question":"Given a list of integers `arr`, implement a function to find the length of the longest subsequence such that every element in the subsequence is a multiple of the previous one. A subsequence is derived by deleting some or no elements in the list without changing the order of the remaining elements. Return the length of such a longest subsequence you can find.","solution":"def length_of_longest_multiple_subsequence(arr): Returns the length of the longest subsequence such that every element in the subsequence is a multiple of the previous one. n = len(arr) if n == 0: return 0 dp = [1] * n arr.sort() for i in range(1, n): for j in range(i): if arr[i] % arr[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a list of `ingredients` and a list of `orders`, create a function that returns a list of missing ingredients for each order. Each `order` is represented as a list of ingredients needed to complete that order. Your function should take into account the available quantities of each ingredient and determine which orders can be fulfilled and which ingredients are missing for the others. The function should return a list of dictionaries, where each dictionary represents the missing ingredients of an order, with the ingredient names as keys and the missing quantities as values. If an order can be completely fulfilled, the corresponding dictionary should be empty. The lists `ingredients` and `orders` are provided as input.","solution":"def missing_ingredients(ingredients, orders): Returns a list of dictionaries where each dictionary represents the missing ingredients of an order, with the ingredient names as keys and the missing quantities as values. Parameters: ingredients (list of dicts): A list of dictionaries representing the available ingredients and their quantities. orders (list of lists): A list where each element is a list of dictionaries representing the required ingredients and their quantities for an order. Returns: list of dicts: A list where each dictionary represents the missing ingredients for an order. available = {item[\'ingredient\']: item[\'quantity\'] for item in ingredients} result = [] for order in orders: missing = {} for item in order: ing = item[\'ingredient\'] qty = item[\'quantity\'] if ing not in available or available[ing] < qty: missing[ing] = qty - available.get(ing, 0) if not missing: # Deduct the used quantities from the available ones for item in order: ing = item[\'ingredient\'] qty = item[\'quantity\'] available[ing] -= qty result.append(missing) return result"},{"question":"You are given a binary tree with `n` nodes. Each node has a value which is unique and ranges from 1 to `n`. Your task is to find all paths in the tree such that the sum of the values of the nodes in the path equals `sumValue`. A path in the tree is defined as a sequence of nodes starting from any node to any node (including leaf nodes) such that every consecutive pair of nodes in the sequence has an edge between them, and a node cannot appear more than once in the path. Return the total number of such paths. Since the answer may be large, return it modulo `109 + 7`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from collections import defaultdict def pathSum(root, sumValue): Finds the number of paths that sum to a given value in the binary tree. Args: root (TreeNode): The root of the binary tree. sumValue (int): The target sum for the paths. Returns: int: Number of paths summing to the target value, modulo 10^9 + 7. MOD = 10**9 + 7 def dfs(node, target): if not node: return 0 def count_paths_from_node(node, accumulated_sum): if not node: return 0 accumulated_sum += node.val return (accumulated_sum == target) + count_paths_from_node(node.left, accumulated_sum) + count_paths_from_node(node.right, accumulated_sum) return count_paths_from_node(node, 0) + dfs(node.left, target) + dfs(node.right, target) return dfs(root, sumValue) % MOD"},{"question":"Given a **0-indexed** integer array `heights` representing the heights of students in a queue, return _the minimum number of moves required to make the array non-decreasing by only swapping adjacent elements_. A move is defined as swapping two adjacent elements in the array.","solution":"def minimum_moves_to_sort(heights): def merge_sort_and_count(arr, temp_arr, left, right): if left >= right: return 0 mid = (left + right) // 2 inv_count = merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def merge_and_count(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count temp_arr = [0]*len(heights) return merge_sort_and_count(heights, temp_arr, 0, len(heights) - 1)"},{"question":"Design a function to find the minimum number of deletions required in a given string to make it a palindrome. A palindrome is a word that reads the same backward as forward. For example, given the string `abcdba`, the function should return `1`, since deleting \'c\' from the string will make it `abbdba`, which is a palindrome. Another example, given the string `abcdeca`, the function should return `2`, since deleting \'b\' and \'d\' will make it `aceca`, which is a palindrome.","solution":"def min_deletions_to_palindrome(s): Returns the minimum number of deletions required to make the string a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] lps_length = longest_palindromic_subsequence(s) return len(s) - lps_length"},{"question":"You are given a **0-indexed** string `s` which consists of only lowercase English letters. You can perform the following operation any number of times: Choose any character and assign it a new value between \'a\' and \'z\' inclusively, which becomes its **new value** in the string. The goal is to make the string `s` have all distinct characters with the **minimum number of such operations**. Return _the minimum number of operations required_ to make all characters in the string `s` unique.","solution":"def min_operations_to_unique(s): Returns the minimum number of operations required to make all characters in the string s unique. char_count = [0] * 26 # there are 26 lowercase letters for char in s: char_count[ord(char) - ord(\'a\')] += 1 # to keep track of used characters used_chars = set() result = 0 for i in range(26): while char_count[i] > 1: # more than one occurrence for j in range(26): if char_count[j] == 0: # find a character that is not used used_chars.add(j) char_count[j] += 1 break char_count[i] -= 1 result += 1 return result"},{"question":"A sequence of numbers is called an **arithmetic progression** if the difference between any two consecutive terms is the same. Given an array of `n` integers, determine if it can be rearranged to form an arithmetic progression. Return `true` _if the array can be rearranged to form an arithmetic progression, otherwise return `false`_. **Example Input:** ``` arr = [3, 5, 1] ``` **Example Output:** ``` true ``` **Note:** The array `[3, 5, 1]` can be rearranged to `[1, 3, 5]`, which forms an arithmetic progression.","solution":"def can_make_arithmetic_progression(arr): Determine if the array can be rearranged to form an arithmetic progression. :param arr: List[int] - List of integers :return: bool - True if the list can be rearranged to form an arithmetic progression, else False if len(arr) < 2: return True # An array with less than 2 elements is trivially an arithmetic progression arr.sort() diff = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i - 1] != diff: return False return True"},{"question":"You are given a list of non-negative integers `nums` representing the digits of a large integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. Increment the large integer by one and return the resulting list of digits.","solution":"def increment_digits(nums): Increments the large integer represented by the list nums by one. Args: nums (list of int): list of digits representing a number Returns: list of int: list of digits representing the incremented number n = len(nums) for i in range(n - 1, -1, -1): if nums[i] < 9: nums[i] += 1 return nums nums[i] = 0 # If all the digits were 9, the result will be one more digit.. return [1] + nums"},{"question":"You are given a directed graph with `n` vertices and `m` edges, represented as an adjacency list `graph`, where `graph[u]` is a list of vertices `v` such that there is a directed edge from `u` to `v`. Your task is to determine if the graph contains a cycle. Return `true` if there is at least one cycle, and `false` otherwise.","solution":"def is_cyclic(graph): Function to detect if a directed graph contains a cycle. :param graph: adjacency list representation of the graph :return: True if there is a cycle in the graph, False otherwise def dfs(vertex): if rec_stack[vertex]: return True if visited[vertex]: return False visited[vertex] = True rec_stack[vertex] = True for neighbor in graph[vertex]: if dfs(neighbor): return True rec_stack[vertex] = False return False n = len(graph) visited = [False] * n rec_stack = [False] * n for node in range(n): if not visited[node]: if dfs(node): return True return False"},{"question":"You are given a string `s` and an integer `k`. The string `s` is a sentence containing words separated by spaces. Each word contains only lowercase English letters. We want to split the sentence into multiple lines such that each line contains at most `k` characters, and no word is split between two lines. Return _a list of strings representing the split sentence with each string being a line._ If it is not possible to split the sentence according to the above rules, return an empty list.","solution":"def split_sentence(s, k): Splits the sentence s into multiple lines such that each line contains at most k characters, and no word is split between two lines. If it is not possible to split the sentence according to the above rules, return an empty list. Parameters: s (str): The input sentence. k (int): The maximum number of characters per line. Returns: list: A list of strings representing the split sentence with each string being a line. words = s.split() lines = [] current_line = [] for word in words: if len(word) > k: return [] if sum(len(w) for w in current_line) + len(current_line) + len(word) <= k: current_line.append(word) else: lines.append(\' \'.join(current_line)) current_line = [word] if current_line: lines.append(\' \'.join(current_line)) return lines"},{"question":"You are given an array of integers `nums` where `nums[i]` is the value at the `ith` position. You need to design and implement the `RangeFreqQuery` class to support queries that return the frequency of a particular value within a specified range of indices. Implement the following methods: * `RangeFreqQuery(int[] nums)`: Initializes the `RangeFreqQuery` object with the integer array `nums`. * `int query(int left, int right, int value)`: Returns the frequency of `value` in the subarray defined by the indices `[left, right]` (both inclusive). Example: ``` RangeFreqQuery obj = new RangeFreqQuery([1, 4, 2, 4, 4, 3, 1]); int result = obj.query(1, 5, 4); ``` Output: ``` result -> 3 ```","solution":"class RangeFreqQuery: def __init__(self, nums): Initializes the RangeFreqQuery object with the integer array nums. self.nums = nums self.freq_map = {} for idx, num in enumerate(nums): if num not in self.freq_map: self.freq_map[num] = [] self.freq_map[num].append(idx) def query(self, left, right, value): Returns the frequency of value in the subarray defined by the indices [left, right] (both inclusive). if value not in self.freq_map: return 0 indices = self.freq_map[value] count = 0 for idx in indices: if left <= idx <= right: count += 1 return count"},{"question":"You are given a list of `n` integers, and you need to find the maximum product of any three integers in the list. Write a function `maxProductOfThree(nums)` that takes a list of integers `nums` as input and returns the maximum product of any three integers in the list. Example: - Input: `nums = [1, 2, 3, 4]` - Output: `24` Explanation: The maximum product is `4 * 3 * 2 = 24`.","solution":"def maxProductOfThree(nums): Returns the maximum product of any three integers in the list. nums.sort() return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])"},{"question":"A network of servers is represented by a `n x n` matrix `graph` where `graph[i][j]` indicates the time needed to send a message from server `i` to server `j`. A server is able to communicate with another server directly only if there is a direct link between them (i.e., `graph[i][j] > 0`). Your task is to determine the minimum time required for messages from a source server to reach all other servers. Specifically, given a source server `k`, return the minimum time it takes for messages to be distributed from the source to all other servers. If it is impossible to reach one or more servers from the source server, return `-1`. Note that `n` is the number of servers and `0 <= k < n`. The time needed for a message to travel from a server to itself is always `0` (`graph[i][i] = 0`). Also, the network may contain servers which are completely disconnected from others.","solution":"import heapq def network_delay_time(graph, source): Returns the minimum time for messages to be distributed from the source to all other servers. If it is impossible to reach one or more servers, returns -1. Args: graph: List of List for adjacency matrix representation of the network. source: The source server index. Returns: int: Minimum time for message to reach all servers or -1 if not possible. n = len(graph) min_heap = [(0, source)] dist = {i: float(\'inf\') for i in range(n)} dist[source] = 0 while min_heap: time, u = heapq.heappop(min_heap) for v in range(n): if graph[u][v] != 0 and time + graph[u][v] < dist[v]: dist[v] = time + graph[u][v] heapq.heappush(min_heap, (dist[v], v)) max_time = max(dist.values()) return max_time if max_time < float(\'inf\') else -1"},{"question":"You are managing a sports team\'s practice schedule and need to optimize their training sessions. The team practices for `n` days, and each day\'s practice intensity is recorded in an array `intensities`, where `intensities[i]` represents the intensity of practice on the `i-th` day. The coach has decided that for any continuous segment of practice days, the team must have consecutive days where the practice intensities are either strictly increasing or strictly decreasing. To assist with planning, implement a function that returns the length of the longest continuous segment of days that satisfies the coach\'s requirement. Write a method `longestTrainingSegment` with the following signature: ```python def longestTrainingSegment(intensities: List[int]) -> int: ``` This method takes in an array of integer practice intensities and returns an integer representing the length of the longest continuous segment of days with strictly increasing or strictly decreasing intensities.","solution":"from typing import List def longestTrainingSegment(intensities: List[int]) -> int: if not intensities: return 0 max_length = 1 current_length = 1 increasing = None for i in range(1, len(intensities)): if intensities[i] == intensities[i - 1]: current_length = 1 increasing = None elif intensities[i] > intensities[i - 1]: if increasing is None or increasing: current_length += 1 else: current_length = 2 increasing = True else: if increasing is None or not increasing: current_length += 1 else: current_length = 2 increasing = False if current_length > max_length: max_length = current_length return max_length"},{"question":"You are tasked with analyzing a company\'s stock price over a period of `n` days. The daily closing stock prices are stored in a 0-indexed integer array `prices`, where `prices[i]` is the price of the stock on day `i`. You want to determine the maximum profit you can achieve by buying and selling the stock at most twice. However, you must sell the stock before you can buy it again. Write a function that returns the maximum profit you can achieve from these transactions. Here\'s the function signature: ```python def maxProfitWithTwoTransactions(prices: List[int]) -> int: pass ``` You may assume: - The input array `prices` will have at least 1 element. - The stock prices will be positive integers. The function should output the maximum profit that can be achieved with at most two transactions.","solution":"from typing import List def maxProfitWithTwoTransactions(prices: List[int]) -> int: if len(prices) < 2: return 0 # Initialize variables to store the maximum profit up to each day with one and two transactions. n = len(prices) max_profit_one_transaction = [0] * n max_profit_two_transactions = [0] * n # Forward phase: compute max profit for one transaction up to day i. min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) max_profit_one_transaction[i] = max(max_profit_one_transaction[i-1], prices[i] - min_price) # Backward phase: compute max profit for two transactions. max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) max_profit_two_transactions[i] = max(max_profit_two_transactions[i+1], max_price - prices[i] + max_profit_one_transaction[i]) return max(max_profit_two_transactions)"},{"question":"You are given a list of non-negative integers representing the amount of money of each house, and you are a robber planning to rob houses along a street. However, you cannot rob two adjacent houses due to a security system connected between them. Write a function `rob(nums)` that takes in the list of integers `nums` and returns the maximum amount of money you can rob tonight without alerting the police. Example: ```python Input: nums = [2,3,2] Output: 3 Explanation: Rob house 1 (money = 2) and then rob house 3 (money = 2), which results in a total of 3. Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3), which results in a total of 4. ``` **Note:** Your solution should not modify the input list and should run in O(n) time where n is the number of houses.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without robbing two adjacent houses. if not nums: return 0 if len(nums) == 1: return nums[0] def rob_linear(houses): prev, curr = 0, 0 for money in houses: prev, curr = curr, max(curr, prev + money) return curr return max(rob_linear(nums[1:]), rob_linear(nums[:-1]))"},{"question":"You are given a **0-indexed** grid of characters `board` with `m` rows and `n` columns. Each cell in the grid can contain a lowercase letter from \'a\' to \'z\'. A word is defined as a contiguous sequence of characters either horizontally or vertically. Consider you have a list of words called `dictionary` where each word consists of lowercase English letters only. Your task is to determine how many words from the `dictionary` can be found on the `board`. A word can be found on the board if it appears exactly as it is in the list, without rearranging or overlapping with other words. You cannot reuse the same cell in the grid for different words. Return an integer representing the number of words from `dictionary` that can be found on the `board`.","solution":"def find_words(board, dictionary): def search(board, word, row, col, path): if not word: return True if (row < 0 or row >= len(board) or col < 0 or col >= len(board[0]) or word[0] != board[row][col] or (row, col) in path): return False path.add((row, col)) result = (search(board, word[1:], row + 1, col, path) or # down search(board, word[1:], row - 1, col, path) or # up search(board, word[1:], row, col + 1, path) or # right search(board, word[1:], row, col - 1, path)) # left path.remove((row, col)) return result def exist(board, word): for row in range(len(board)): for col in range(len(board[0])): if search(board, word, row, col, set()): return True return False count = 0 for word in dictionary: if exist(board, word): count += 1 return count"},{"question":"Given an integer array `nums` and an integer `k`, return _a sorted array of the `k` most frequent elements._ If there are multiple elements with the same frequency, any order is acceptable.","solution":"from collections import Counter import heapq def top_k_frequent(nums, k): Returns a sorted array of the k most frequent elements in nums. if k == len(nums): return sorted(nums) count = Counter(nums) return sorted([item for item, freq in count.most_common(k)])"},{"question":"Given a string `s`, you are to decode it and return the original string. The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. You may assume that the input string is always valid; no extra white spaces, square brackets are well-formed, etc. Additionally, the input string may contain nested encoding patterns. For example: - Input: `\\"3[a]2[bc]\\"` Output: `\\"aaabcbc\\"` - Input: `\\"3[a2[c]]\\"` Output: `\\"accaccacc\\"` Write a function that decodes such strings.","solution":"def decodeString(s): Decode the encoded string according to the given encoding rule. The encoding rule is k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. :param s: str :return: decoded string after applying the encoding rule stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': # Push the current number and string to the stack stack.append((current_string, current_num)) # Reset the current string and number current_string = \'\' current_num = 0 elif char == \']\': # Pop from the stack and repeat the current_string last_string, repeat_num = stack.pop() current_string = last_string + current_string * repeat_num else: current_string += char return current_string"},{"question":"You are given a list of strings `logs` where each string represents a log written by a user in the format `\\"user_id action timestamp\\"`. The `timestamp` is an integer representing the time when the action was taken. Each user can perform multiple actions, and the list is unsorted. Implement a function `getFirstAction` that returns a dictionary where the key is the `user_id` and the value is the `timestamp` of the first action taken by that user. If the user performed multiple actions at the same earliest time, you can consider any of those actions as the first action. Assume that all `user_id`s are unique and represented as strings, and all `timestamp`s are distinct integers.","solution":"def getFirstAction(logs): Returns the earliest action time for each user from the logs. Args: logs (list): List of logs in the \\"user_id action timestamp\\" format. Returns: dict: A dictionary where the keys are user_ids and the values are the timestamps of the first actions. user_first_action = {} for log in logs: user_id, _, timestamp = log.split() timestamp = int(timestamp) if user_id not in user_first_action or timestamp < user_first_action[user_id]: user_first_action[user_id] = timestamp return user_first_action"},{"question":"You are given an array of integers `nums` and an integer `k`. The array `nums` represents different coin denominations, and `k` represents a target amount of money. Return _the minimum number of coins_ required to make up the amount `k`. If it is not possible to make up the amount with the given coins, return `-1`. You may assume that you have an infinite number of each coin denomination available.","solution":"def coinChange(nums, k): Returns the minimum number of coins required to make up the amount k. If it is not possible to make up the amount, returns -1. # Create a list to store the minimum coins needed for each amount dp = [float(\'inf\')] * (k + 1) dp[0] = 0 # Base case: 0 coins needed to make 0 amount for coin in nums: for x in range(coin, k + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[k] if dp[k] != float(\'inf\') else -1"},{"question":"Given an integer array `nums` where the elements are sorted in ascending order, and an integer `k`, write a function to find the `k` closest elements to a given integer `target`. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred. You must write an algorithm with `O(log n + k)` runtime complexity.","solution":"import heapq from typing import List def find_k_closest_elements(nums: List[int], k: int, target: int) -> List[int]: Finds the k closest elements to the given target in the sorted array nums. Ties are resolved by preferring smaller elements. # Function to calculate the difference between a number and the target. def diff(num): return abs(num - target) # Create a min-heap with tuple of difference and the actual number min_heap = [] for num in nums: heapq.heappush(min_heap, (diff(num), num)) # Extract the k smallest elements based on the difference using min-heap closest_elements = [heapq.heappop(min_heap)[1] for _ in range(k)] # Return the result sorted in ascending order return sorted(closest_elements)"},{"question":"You are given two strings, `s` and `t`. Determine if `s` can be transformed into `t` by reversing any one of its substrings exactly once. Return `true` if it is possible, otherwise, return `false`.","solution":"def can_transform_by_reversing_substring(s, t): Determines if string s can be transformed into string t by reversing any one of its substrings exactly once. if s == t: return True len_s = len(s) # If lengths are not the same, no transformation is possible if len_s != len(t): return False # Try reversing every possible substring in s and see if any of them match t for i in range(len_s): for j in range(i+1, len_s+1): reversed_substring = s[:i] + s[i:j][::-1] + s[j:] if reversed_substring == t: return True return False"},{"question":"Given an integer array `heights` representing the height of each building on a street, and a positive integer `a`, return the maximum number of buildings you can paint such that the difference between the height of the tallest building and the shortest building in the painted subset is no more than `a`.","solution":"def max_buildings_painted(heights, a): Returns the maximum number of buildings that can be painted such that the difference between the height of the tallest building and the shortest building in the painted subset is no more than a. heights.sort() left = 0 max_painted = 0 for right in range(len(heights)): while heights[right] - heights[left] > a: left += 1 max_painted = max(max_painted, right - left + 1) return max_painted"},{"question":"Given a list of non-negative integers `nums`, find and return the length of the longest strictly increasing subsequence. An increasing subsequence is a sequence where each subsequent number is greater than the preceding one, and is not necessarily contiguous. Your solution should have a time complexity better than (O(n^2)).","solution":"def length_of_lis(nums): Finds the length of the longest strictly increasing subsequence in a list of non-negative integers. Args: nums: List of non-negative integers. Returns: Length of the longest strictly increasing subsequence. if not nums: return 0 # array to store our subsequence sub = [] for num in nums: # Find the position in \'sub\' where \'num\' can replace to # keep \'sub\' sorted pos = binary_search(sub, num) # if num is greater than any element in sub if pos == len(sub): sub.append(num) else: sub[pos] = num return len(sub) def binary_search(sub, num): Helper function to perform binary search on the subsequence. Args: sub: List of elements in the current subsequence. num: Element to be placed in the subsequence. Returns: Index where the element should be placed. left, right = 0, len(sub) - 1 while left <= right: mid = (left + right) // 2 if sub[mid] < num: left = mid + 1 else: right = mid - 1 return left"},{"question":"Given a list of words, return the words that can be typed using letters of the alphabet on only one row of a standard QWERTY keyboard. The three rows of the keyboard are: ``` Row 1: \\"qwertyuiop\\" Row 2: \\"asdfghjkl\\" Row 3: \\"zxcvbnm\\" ``` Note that considering the case of the letters is not necessary. You may assume that the input contains only lowercase letters. Implement the function: ```python def find_words(words: List[str]) -> List[str]: ```","solution":"from typing import List def find_words(words: List[str]) -> List[str]: Returns the list of words that can be typed using letters of the alphabet on only one row of a standard QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = set(word.lower()) if lower_word <= row1 or lower_word <= row2 or lower_word <= row3: result.append(word) return result"},{"question":"Given an array of integers `arr`, you are to implement a function that rotates the array to the right by `k` steps, where `k` is a non-negative integer. The array will be modified in-place, meaning you must not use extra space for another array. Return the rotated array.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. :param arr: List of integers to be rotated :param k: Non-negative integer number of steps to rotate the array :return: The rotated array n = len(arr) if n == 0: return arr k = k % n # In case k is larger than n arr[:] = arr[-k:] + arr[:-k] return arr"},{"question":"You are given a string `s` and a string `t` where `t` is a subsequence of `s`. Return the minimum window substring of `s` such that `t` is a subsequence of the window. If there is no such window in `s` that covers all characters in `t`, return an empty string. If there are multiple such minimum-length windows, return the one with the leftmost starting index.","solution":"def min_window_subsequence(s, t): m, n = len(s), len(t) dp = [[-1] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = i for i in range(1, m + 1): for j in range(1, min(i + 1, n + 1)): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = dp[i - 1][j] start, length = 0, float(\'inf\') for i in range(1, m + 1): if dp[i][n] != -1: if i - dp[i][n] < length: start = dp[i][n] length = i - dp[i][n] return s[start:start+length] if length != float(\'inf\') else \\"\\""},{"question":"A group of friends is planning a hiking trip and they need to allocate supplies to carry. Each friend has a carrying capacity and a list of supplies they can carry. You are provided with an integer array `supplies` where `supplies[i]` represents the weight of the `i-th` supply. You are also provided with an integer array `capacity` where `capacity[j]` represents the maximum weight that the `j-th` friend can carry. A friend can carry multiple supplies as long as the total weight does not exceed their capacity. Write a function that returns the **maximum number** of supplies that can be allocated among the friends such that no friend carries more than their maximum capacity. Note that each supply must be carried by exactly one friend or not at all. ```python def max_supplies_allocation(supplies: List[int], capacity: List[int]) -> int: # your code here ```","solution":"from typing import List def max_supplies_allocation(supplies: List[int], capacity: List[int]) -> int: supplies.sort() capacity.sort() supply_pointer, capacity_pointer = 0, 0 allocated_supplies = 0 while supply_pointer < len(supplies) and capacity_pointer < len(capacity): if supplies[supply_pointer] <= capacity[capacity_pointer]: allocated_supplies += 1 supply_pointer += 1 capacity_pointer += 1 return allocated_supplies"},{"question":"You are given an array of non-negative integers representing the heights of columns where each index represents a column and the value at that index is the height of the column. Assume each column has a width of 1. Two columns form a container that holds the highest possible water. Write a function to calculate the maximum amount of water the container can store. You need to return an integer representing this maximum water. The containers cannot be slanted, and the height of water between two columns is limited by the shorter column.","solution":"def max_area(height): Calculate the maximum amount of water a container can store given the heights of the columns. :param height: List[int], heights of the columns :return: int, maximum amount of water that can be stored left = 0 right = len(height) - 1 max_water = 0 while left < right: # Calculate the height and width of the container. current_height = min(height[left], height[right]) current_width = right - left # Calculate the current water amount and update max_water if it\'s greater current_water = current_height * current_width max_water = max(max_water, current_water) # Move the pointers based on which height is shorter if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"Given an integer matrix `grid`, where `grid[i][j]` represents the elevation of a cell `(i, j)`, and an integer `target`, write a function to find the length of the shortest path from the top-left corner to the bottom-right corner. The path must ensure that any elevation difference between two adjacent cells is less than or equal to `target`. You can only move up, down, left, or right. If such a path does not exist, return -1.","solution":"from collections import deque import sys def valid_move(grid, x, y, next_x, next_y, target): Checks if the move from (x, y) to (next_x, next_y) is valid given the target elevation difference. if 0 <= next_x < len(grid) and 0 <= next_y < len(grid[0]) and abs(grid[next_x][next_y] - grid[x][y]) <= target: return True return False def shortest_path(grid, target): Finds the length of the shortest path from the top-left to the bottom-right corner, considering the target elevation difference. If such a path does not exist, returns -1. if not grid: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0,1), (1,0), (0,-1), (-1,0)] # right, down, left, up queue = deque([(0, 0, 0)]) # (x, y, distance) visited = {(0, 0)} while queue: x, y, dist = queue.popleft() if x == rows - 1 and y == cols - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if valid_move(grid, x, y, nx, ny, target) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for `arr = [1,2,3]`, the following are all the permutations of `arr`: `[1,2,3]`, `[1,3,2]`, `[2,1,3]`, `[2,3,1]`, `[3,1,2]`, and `[3,2,1]`. Find the next permutation of `arr`. The replacement must be in place and use only constant extra memory. If such an arrangement is not possible, the function should rearrange `arr` to its first permutation in ascending order. Here’s an example: Given the input array `arr = [1,2,3]`, the function should modify the array to `[1,3,2]`. If the input was `arr = [3,2,1]`, the function should modify the array to `[1,2,3]`.","solution":"def next_permutation(arr): Modifies arr to its next permutation. If no next permutation is possible, rearranges to the lowest possible order (i.e., sorted in ascending order). # Step 1: Find the largest index k such that arr[k] < arr[k + 1] k = len(arr) - 2 while k >= 0 and arr[k] >= arr[k + 1]: k -= 1 if k == -1: # This means the array is in descending order, hence no larger permutation is possible arr.reverse() return # Step 2: Find the largest index l greater than k such that arr[k] < arr[l] l = len(arr) - 1 while arr[k] >= arr[l]: l -= 1 # Step 3: Swap the value of arr[k] with that of arr[l] arr[k], arr[l] = arr[l], arr[k] # Step 4: Reverse the sequence from arr[k + 1] to the end of the array arr[k + 1:] = reversed(arr[k + 1:])"},{"question":"You are given a string `s` and an array of strings `words`. Your task is to determine for each word in `words` if it is a subsequence of `s`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return _an array of booleans where each element corresponds to whether the respective word in_ `words` _is a subsequence of_ `s`.","solution":"def is_subsequence(s, words): Determines if each word in words is a subsequence of the string s. Parameters: s (str): The source string. words (list of str): List of words to check. Returns: list: A list of booleans indicating if each word is a subsequence of s. def check_subsequence(word): it = iter(s) return all(char in it for char in word) return [check_subsequence(word) for word in words]"},{"question":"You are given the `root` of a binary search tree (BST) and an integer `k`. Write a function `findTarget` that returns true if there exist two elements in the BST such that their sum is equal to `k`, or false otherwise. Implement the `findTarget` function as follows: - `bool findTarget(TreeNode* root, int k)` where `TreeNode` is defined as: ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; ``` Example: - Input: `root = [5,3,6,2,4,null,7]`, `k = 9` - Output: `true` The function should efficiently determine whether such a pair of elements exists within the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findTarget(root, k): Returns true if there exist two elements in the BST such that their sum is equal to k. def inorder(node): if not node: return [] return inorder(node.left) + [node.val] + inorder(node.right) values = inorder(root) left, right = 0, len(values) - 1 while left < right: current_sum = values[left] + values[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. In one operation, you can choose any subarray of `nums` and reverse it. Return _the minimum number of operations needed to sort the array in **non-decreasing** order_.","solution":"def min_operations_to_sort(nums): Returns the minimum number of operations needed to sort the array in non-decreasing order. :param nums: List[int] :return: int n = len(nums) start = 0 end = n - 1 # Find the leftmost position where array is unsorted while start < n - 1 and nums[start] <= nums[start + 1]: start += 1 # If array is already sorted if start == n - 1: return 0 # Find the rightmost position where array is unsorted while end > 0 and nums[end] >= nums[end - 1]: end -= 1 # Check the minimum and maximum in the unsorted subarray subarray_min = min(nums[start:end+1]) subarray_max = max(nums[start:end+1]) # Extend the left boundary if needed while start > 0 and nums[start - 1] > subarray_min: start -= 1 # Extend the right boundary if needed while end < n - 1 and nums[end + 1] < subarray_max: end += 1 # Only one subarray reversal needed to sort the array return 1"},{"question":"You are given a 2D grid of characters `grid` where each element is either `\'0\'` (representing water) or `\'1\'` (representing land). An **island** is defined as a group of `\'1\'`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Two islands are considered distinct if and only if they are separated by water. Return the _maximum number of distinct islands in the grid_. An island is considered distinct if and only if its shape is not identical to any other island (i.e., by rotating or flipping).","solution":"def numDistinctIslands(grid): def dfs(x, y, direction, shape): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == \'0\': return grid[x][y] = \'0\' shape.append(direction) dfs(x + 1, y, \'d\', shape) # down dfs(x - 1, y, \'u\', shape) # up dfs(x, y + 1, \'r\', shape) # right dfs(x, y - 1, \'l\', shape) # left shape.append(\'b\') # backtrack unique_shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': shape = [] dfs(i, j, \'o\', shape) # start new island unique_shapes.add(tuple(shape)) return len(unique_shapes)"},{"question":"Given an array of integers `arr`, write a function that returns the length of the longest subarray that contains at most two distinct numbers. A subarray is a contiguous part of an array. The input array must contain at least one element and you should maximize the length of the subarray. **Example:** Input: `arr = [1, 2, 1, 2, 3]` Output: `4` Explanation: The longest subarray with at most two distinct numbers is `[1, 2, 1, 2]`, which has a length of 4.","solution":"def longest_subarray_with_two_distinct(arr): Returns the length of the longest subarray with at most two distinct numbers. if not arr: return 0 left = 0 right = 0 max_len = 0 seen = {} while right < len(arr): if arr[right] in seen: seen[arr[right]] += 1 else: seen[arr[right]] = 1 while len(seen) > 2: seen[arr[left]] -= 1 if seen[arr[left]] == 0: del seen[arr[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"You are given a string `s` containing lowercase alphabet characters. You can perform the following operation any number of times: choose a non-empty substring `t` of `s` and replace all of its characters with its lexicographically smallest character. Your goal is to make the entire string contain only one distinct character. Return _the minimum number of operations required to achieve this goal_. For example, if the string is `s = \\"abac\\"`: - In one operation, you can choose the substring `s[1:] = \\"bac\\"` and replace all characters with \'a\', resulting in `s = \\"aaaa\\"`.","solution":"def min_operations_to_single_char(s): Returns the minimum number of operations required to make the string contain only one distinct character. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Return the length of the string minus the frequency of the most common character return len(s) - max(freq.values())"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to find the number of substrings of `s` that contain exactly one distinct character. Each character in `s` should be treated as a single distinct character substring for this purpose. Return _the total number of such substrings_.","solution":"def count_single_char_substrings(s): Returns the number of substrings that contain exactly one distinct character. n = len(s) total_count = 0 i = 0 while i < n: j = i while j < n and s[j] == s[i]: j += 1 length = j - i total_count += length * (length + 1) // 2 i = j return total_count"},{"question":"You are given an array of integers and a value `k`. Design an algorithm that: * **Inserts** a new integer into the array. * **Finds** the `k-th` largest element in the array after each insertion. Implement the `KthLargest` class: * `KthLargest(int k, int[] nums)` Initializes the object with the integer `k` and the stream of integers `nums`. * `int add(int val)` Appends the integer `val` to the array and returns the `k-th` largest element in the array. For example, if `k=3` and the initial array is `[4, 5, 8, 2]`, and then we add the elements `3, 5, 10, 9, 4`, the `k-th` largest element after each insertion should be `[4, 5, 5, 8, 8]`.","solution":"import heapq class KthLargest: def __init__(self, k, nums): self.k = k self.min_heap = nums heapq.heapify(self.min_heap) while len(self.min_heap) > k: heapq.heappop(self.min_heap) def add(self, val): heapq.heappush(self.min_heap, val) if len(self.min_heap) > self.k: heapq.heappop(self.min_heap) return self.min_heap[0]"},{"question":"You are given a binary tree with `n` nodes. Each node has a value that is either `0` or `1`. Your task is to find the length of the longest path in the binary tree that consists solely of `1s`. The length of a path is represented by the number of edges in the path. Return _the length of the longest path that contains only `1s`_.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_ones_path(root): def dfs(node): if not node: return 0, 0 # returns (global maximum path length, current path length ending at current node) left_global, left_current = dfs(node.left) right_global, right_current = dfs(node.right) current = 0 if node.value == 1: current = max(left_current, right_current) + 1 global_max = max(left_global, right_global, current) return global_max, current global_max, _ = dfs(root) return global_max - 1 if global_max > 0 else 0"},{"question":"You are given a string `s` consisting of lowercase English letters, and a list of queries, where each query is an integer representing an index in the string. For each query, you should determine whether the character at the given index is a vowel (\'a\', \'e\', \'i\', \'o\', \'u\'). Return a list of boolean values, where each boolean corresponds to a query, and is `true` if the character at the specified index is a vowel, and `false` otherwise.","solution":"def is_vowel_query(s, queries): Returns a list of booleans indicating if the character at each index in queries is a vowel. Parameters: s (str): The input string. queries (list of int): List of indices in the string s to check. Returns: list of bool: True if the character at the index is a vowel, False otherwise. vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} result = [] for index in queries: if index < len(s) and s[index] in vowels: result.append(True) else: result.append(False) return result"},{"question":"You are given a binary string `s` consisting of only \'0\'s and \'1\'s. You can flip at most one \'0\' to \'1\' or one \'1\' to \'0\'. Your task is to find _the maximum length of a contiguous subarray of 1s or a contiguous subarray of 0s that can be obtained by performing this operation at most once_. Return the length of such a subarray.","solution":"def max_length_subarray_after_one_flip(s): def max_length_simplified(s, target): max_length = count = prev_count = 0 for char in s: if char == target: count += 1 else: prev_count, count = count, 0 max_length = max(max_length, count + prev_count + 1) return max_length max_length_1s = max_length_simplified(s, \'1\') max_length_0s = max_length_simplified(s, \'0\') return max(max_length_1s, max_length_0s)"},{"question":"You are given a **0-indexed** array `arr` consisting of positive integers. An operation is defined as selecting an element `i` (where `0 <= i < arr.length`) and either incrementing or decrementing `arr[i]` by 1. The operation is applied to make all the elements in the array distinct. Return _the **minimum** number of operations required to make all elements distinct_.","solution":"def min_operations_to_make_unique(arr): Returns the minimum number of operations required to make all elements in \'arr\' distinct. if not arr: return 0 arr.sort() operations = 0 for i in range(1, len(arr)): if arr[i] <= arr[i-1]: needed = arr[i-1] - arr[i] + 1 arr[i] = arr[i-1] + 1 operations += needed return operations"},{"question":"You are given an integer array `nums` where each element is at most 2 steps away from its final sorted position. Write an efficient algorithm to sort the array in ascending order. You should minimize the computational complexity of your solution while ensuring the array is sorted correctly. Return the sorted array.","solution":"def almost_sorted(nums): Sorts an array where each element is at most 2 steps away from its final sorted position. Parameters: nums (list): The input list of integers. Returns: list: A sorted list of integers. # Using insertion sort, as it is efficient for nearly sorted arrays for i in range(1, len(nums)): key = nums[i] j = i - 1 # Move elements of nums[0..i-1] that are greater than key, # to one position ahead of their current position while j >= 0 and key < nums[j]: nums[j + 1] = nums[j] j -= 1 nums[j + 1] = key return nums"},{"question":"You are given a list of integers `nums` representing a list of unsorted numbers. Your task is to find all unique triplets `[nums[i], nums[j], nums[k]]` in the list such that the sum of the triplet is zero, i.e., `nums[i] + nums[j] + nums[k] == 0`. Note that the solution set must not contain duplicate triplets. Return _a list of all unique triplets_ that satisfy the condition.","solution":"def three_sum(nums): Returns a list of all unique triplets in the array that sum up to zero. nums.sort() result = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: summation = nums[i] + nums[left] + nums[right] if summation == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif summation < 0: left += 1 else: right -= 1 return result"},{"question":"You are given a 2D integer array `matrix` of size `m x n`, where each element represents a height at a particular location. A peak element is an element that is strictly greater than its adjacent elements (i.e., top, bottom, left, and right). Return _the coordinates `[r, c]` of **one** peak element in the matrix_. If the matrix contains multiple peaks, return the coordinates of **any** peak.","solution":"def find_peak_grid(matrix): rows, cols = len(matrix), len(matrix[0]) def is_peak(r, c): if r > 0 and matrix[r][c] <= matrix[r-1][c]: return False if r < rows - 1 and matrix[r][c] <= matrix[r+1][c]: return False if c > 0 and matrix[r][c] <= matrix[r][c-1]: return False if c < cols - 1 and matrix[r][c] <= matrix[r][c+1]: return False return True for r in range(rows): for c in range(cols): if is_peak(r, c): return [r, c] return []"},{"question":"You are given a string `sentence` consisting of words separated by spaces. Each word consists of lowercase English letters only. You need to reverse the order of the words in the sentence and return the new sentence maintaining the same number of spaces between the words as in the original sentence. If there are leading or trailing spaces, they should be removed in the final output. Write a function that takes a string `sentence` as input and returns the reversed sentence with the same spacing between words.","solution":"def reverse_words(sentence): Reverses the order of words in the given sentence while maintaining the same spacing between words. Leading or trailing spaces should be removed. Args: sentence (str): The input string containing words separated by spaces. Returns: str: A string with the order of the words reversed and the same spacing maintained. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"Write a function `rotateMatrix` that receives an `n x n` 2D matrix representing an image as an input and rotates the image by 90 degrees (clockwise). You need to modify the input matrix **in-place**. The rotation should be done directly on the matrix provided, without using another matrix. To rotate the matrix, you should: * Transpose the matrix - convert all rows to columns and vice versa. * Reverse each row of the transposed matrix. For example: ``` Input: [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"def rotateMatrix(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. Parameters: matrix (List[List[int]]): The input n x n matrix representing the image. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Write a function that takes an array of integers and an integer k, and returns the k most frequent elements in the array. The returned elements should be in descending order of their frequency. If two elements have the same frequency, the larger number should appear first. Implement the following function: `vector<int> topKFrequent(vector<int>& nums, int k)`.","solution":"from collections import Counter import heapq def topKFrequent(nums, k): Returns the k most frequent elements in the array nums. The elements are returned in descending order of their frequency. If two elements have the same frequency, the larger number appears first. freq = Counter(nums) # Use a max-heap with (-frequency, -num) to get elements sorted properly maxHeap = [(-frequency, -num) for num, frequency in freq.items()] heapq.heapify(maxHeap) top_k_elements = [] for _ in range(k): frequency, num = heapq.heappop(maxHeap) top_k_elements.append(-num) return top_k_elements"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a skyline. Each building has a width of 1. Imagine rain falling vertically and water being trapped between the buildings. Write a function that computes _the total amount of **water** that can be trapped between these buildings._ Return the total amount of water trapped.","solution":"def trap_water(heights): Computes the total amount of water that can be trapped between the buildings. :param heights: List[int] Heights of the buildings :return: int Total amount of trapped water if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane. A point `[xi, yi]` is **dominated** by another point `[xj, yj]` if `xi <= xj` and `yi <= yj` but `[xi, yi] != [xj, yj]`. Find the **maximum number** of points that can be arranged in a chain such that each point in the chain dominates the next point in the chain. Return this maximum number. If no such arrangement is possible, return 1.","solution":"def max_dominated_chain_length(points): Returns the maximum length of a chain of points such that each point in the chain dominates the next point in the chain. if not points: return 0 # Sort points based on x coordinate first, and then by y coordinate points.sort(key=lambda p: (p[0], p[1])) # Initialize the dp array where dp[i] represents the length of the longest dominating chain ending at points[i] dp = [1] * len(points) # Compute the longest dominating chain using dynamic programming for i in range(len(points)): for j in range(i): if points[j][0] <= points[i][0] and points[j][1] <= points[i][1]: dp[i] = max(dp[i], dp[j] + 1) # Return the maximum value in dp, which represents the longest chain length return max(dp)"},{"question":"A company has a **circular** dining table with `n` seats. Some employees have already occupied some seats, and the remaining seats are occupied in the next round. Due to the shape of the table, each employee prefers not to sit adjacent to another employee. However, they also want to maximize the number of people who can sit at the table. You are given a binary string `seats` of length `n` where `seats[i]` is: - `\'1\'` if the `i`-th seat is already occupied - `\'0\'` if the `i`-th seat is vacant Return the maximum number of additional people that can sit at the table without violating the adjacency rule.","solution":"def max_additional_people(seats): seats = list(seats) n = len(seats) if n == 1: return 0 if seats[0] == \'1\' else 1 max_count = 0 for i in range(n): if seats[i] == \'0\': if seats[(i - 1) % n] == \'0\' and seats[(i + 1) % n] == \'0\': seats[i] = \'1\' max_count += 1 true_max = max_count # Reset seats string for edge cases where some seats might be \'01...\' seats = list(seats) count1 = 0 for i in range(n): if seats[i] == \'0\' and seats[(i - 1) % n] == \'0\' and seats[(i + 1) % n] == \'0\': seats[i] = \'1\' count1 += 1 elif seats[i] == \'1\': break seats = list(seats[::-1]) count2 = 0 for i in range(n): if seats[i] == \'0\' and seats[(i - 1) % n] == \'0\' and seats[(i + 1) % n] == \'0\': seats[i] = \'1\' count2 += 1 elif seats[i] == \'1\': break return max(true_max, max(count1, count2)) # Example usage: # max_additional_people(\\"01000100\\") should return 2"},{"question":"Design an algorithm to find all possible combinations of `k` numbers that add up to a target number `n`, given that only numbers from `1` to `9` can be used and each combination should be a unique set of numbers. Return only the unique combinations. Note: - All numbers will be positive integers. - The solution set must not contain duplicate combinations.","solution":"def combination_sum(k, n): Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. def backtrack(start, path, k, n): if k == 0 and n == 0: result.append(path) return for i in range(start, 10): if i > n: break backtrack(i + 1, path + [i], k - 1, n - i) result = [] backtrack(1, [], k, n) return result"},{"question":"Given an array of strings `strings` and an integer `k`, return the `k` most frequent strings. If two strings have the same frequency, order them lexicographically. The answer should be sorted by the frequency from highest to lowest. If multiple strings have the same frequency, they should be sorted in lexicographical (alphabetical) order.","solution":"from collections import Counter from typing import List def top_k_frequent(strings: List[str], k: int) -> List[str]: Return the k most frequent strings from the list. If two strings have the same frequency, they are ordered lexicographically. count = Counter(strings) # Sort primarily by frequency (descending), then alphabetically sorted_strings = sorted(count.keys(), key=lambda x: (-count[x], x)) return sorted_strings[:k]"},{"question":"You are given a list of integers `nums` representing the number of apples on each of `n` consecutive days. You can pick apples only once per day and must wait at least `k` days before picking apples again. Return the maximum number of apples you can pick over the `n` days.","solution":"def max_apples(nums, k): Returns the maximum number of apples that can be picked given the constraints. Parameters: nums (list): List of integers representing apples on consecutive days. k (int): Minimum number of days to wait before picking apples again. Returns: int: Maximum number of apples that can be picked. n = len(nums) max_apples_picked = [0] * n for i in range(n): if i <= k: max_apples_picked[i] = max(nums[:i + 1]) else: max_apples_picked[i] = max(max_apples_picked[i - k - 1] + nums[i], max_apples_picked[i - 1]) return max_apples_picked[-1]"},{"question":"Write a function that takes a string `s` consisting of lowercase English letters and returns the characters that appear in the string in the order of their first appearance. If a character appears more than once consecutively, retain only the first occurrence of that character. For example, for the input `s = \\"aabbccddeeff\\"`, the output should be `\\"abcdef\\"`.","solution":"def remove_consecutive_duplicates(s): Returns a string with consecutive duplicate characters removed. Args: - s (str): Input string consisting of lowercase English letters. Returns: - str: String without consecutive duplicates. if not s: return \\"\\" result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return \\"\\".join(result)"},{"question":"You are given a list of non-negative integers representing the heights of a series of buildings, where each building\'s width is 1. Imagine it has rained, and water is trapped between the buildings. The goal is to compute how much water is trapped by the buildings, given the array of heights. Write a function `int trap(int[] height)` that computes the total volume of water trapped. * For example, given heights `[0,1,0,2,1,0,1,3,2,1,2,1]`, your function should return `6`.","solution":"def trap(height): Computes the total volume of water trapped between buildings. :param height: List[int] - a list of non-negative integers representing building heights :return: int - total volume of trapped water if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate trapped water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given two singly-linked lists `headA` and `headB`. Each of these lists represents a non-negative integer, where the digits are stored in forward order, and each of their nodes contains a single digit. Add the two numbers and return _the sum as a new singly-linked list_.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(headA, headB): Adds two numbers represented by linked lists headA and headB and returns the sum as a new linked list. def linkedListToNumber(head): number = 0 while head: number = number * 10 + head.val head = head.next return number def numberToLinkedList(number): if number == 0: return ListNode(0) prev_node = None for digit in str(number)[::-1]: node = ListNode(int(digit)) node.next = prev_node prev_node = node return prev_node numA = linkedListToNumber(headA) numB = linkedListToNumber(headB) total = numA + numB return numberToLinkedList(total)"},{"question":"Given a list of integers representing the `heights` of a group of students standing in a queue, you are to rearrange this list in such a way that the students are rearranged in non-decreasing order of their heights. Additionally, two students are said to have the same height if the difference between their heights is less than or equal to a given integer `t`. In such cases, these students’ relative order should be preserved as in the original list. Implement the function `rearrangeStudents` that takes a list of integers `heights` and an integer `t`, and returns the rearranged list of heights while following the stated conditions.","solution":"def rearrangeStudents(heights, t): Rearranges students in non-decreasing order of their heights while preserving relative order for students that have the same height within the difference `t`. Args: heights (list of int): List of heights of students. t (int): The tolerance value to consider students having same height. Returns: list of int: List of heights rearranged in the described order. sorted_heights = sorted(heights) rearranged = [] for h in sorted_heights: i = next((i for i, x in enumerate(heights) if abs(x - h) <= t and x == h), None) if i is not None: rearranged.append(heights[i]) heights[i] = float(\'inf\') # Mark this height as processed return rearranged"},{"question":"A **robot** is initially located at position `(0, 0)` on an infinite 2D grid. The robot can move to the left, right, up, or down by exactly one step. The robot is given a sequence of instructions represented by a string `instructions`. Each instruction character can be \'L\', \'R\', \'U\', or \'D\', which stands for left, right, up, and down respectively. The robot might get stuck in a loop from which it can never escape, no matter what instructions follow. This happens if the robot\'s position returns to the starting point `(0, 0)` after following the sequence of instructions. Given a sequence of instructions, determine if the robot will be in a loop from which it can never escape. Return `true` if the robot is in an infinite loop and `false` otherwise.","solution":"def is_robot_in_loop(instructions): Determines if the robot is in an infinite loop. Parameters: instructions (str): String consisting of instructions (\'L\', \'R\', \'U\', \'D\') Returns: bool: True if robot returns to (0, 0), False otherwise # Initial position x, y = 0, 0 # Move the robot according to instructions for instruction in instructions: if instruction == \'L\': x -= 1 elif instruction == \'R\': x += 1 elif instruction == \'U\': y += 1 elif instruction == \'D\': y -= 1 # Check if the robot is back to the initial position return (x == 0 and y == 0)"},{"question":"Given an integer array `arr`, return the sum of the elements between indices `i` and `j` (inclusive), where `0 <= i <= j < len(arr)`. The function you are to implement should be structured with the following signature: ```python def range_sum(arr: List[int], i: int, j: int) -> int: ``` **Example:** ```python arr = [1, 2, 3, 4, 5] i = 1 j = 3 ``` The function should return `2 + 3 + 4 = 9`. **Constraints:** - You must optimize your solution to have a worst-case time complexity of O(1) for each query, by preprocessing the array in O(n) time, where n is the length of the array.","solution":"from typing import List def preprocess_prefix_sums(arr: List[int]) -> List[int]: Preprocess the prefix sums for the given array to enable O(1) range sum queries. prefix_sums = [0] * (len(arr) + 1) for idx in range(1, len(prefix_sums)): prefix_sums[idx] = prefix_sums[idx - 1] + arr[idx - 1] return prefix_sums def range_sum(prefix_sums: List[int], i: int, j: int) -> int: Returns the sum of elements between indices i and j (inclusive) using prefix sums. return prefix_sums[j + 1] - prefix_sums[i]"},{"question":"You are given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive, implying there is at least one duplicate number. Your task is to find that duplicate number. The algorithm should meet the following requirements: 1. You must not modify the array `nums`. 2. You must use only constant `O(1)` extra space. 3. Your runtime complexity should be less than `O(n^2)`. Implement the function `findDuplicate` that takes an array `nums` and returns the duplicate integer.","solution":"def findDuplicate(nums): Finds the duplicate number in the array without modifying the array, using constant extra space and with time complexity less than O(n^2). # Using Floyd\'s Tortoise and Hare (Cycle Detection Algorithm) tortoise = hare = nums[0] while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break # Find the entrance to the cycle tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare"},{"question":"Given a string `s` representing a mathematical expression with positive integers and operators `+`, `-`, `*`, and `/`, return _the result of the expression after evaluating it_. The expression is guaranteed to be well-formed and contains no spaces. The integer division should truncate toward zero. The precedence of the operators is as follows: 1. Multiplication (*) and division (/) have higher precedence than addition (+) and subtraction (-). 2. Operators with the same precedence are evaluated from left to right. **Example:** ``` Input: s = \\"3+2*2\\" Output: 7 Input: s = \\" 3/2 \\" Output: 1 Input: s = \\"3+5 / 2\\" Output: 5 ```","solution":"def evaluate_expression(s: str) -> int: def operate(a, b, op): if op == \'+\': return a + b elif op == \'-\': return a - b elif op == \'*\': return a * b elif op == \'/\': return int(a / b) # Integer division truncating towards zero if not s: return 0 n = len(s) current_num = 0 stack = [] operation = \'+\' i = 0 while i < n: char = s[i] if char.isdigit(): current_num = current_num * 10 + int(char) if char in \\"+-*/\\" or i == n - 1: if operation == \'+\': stack.append(current_num) elif operation == \'-\': stack.append(-current_num) elif operation == \'*\': stack[-1] = stack[-1] * current_num elif operation == \'/\': stack[-1] = int(stack[-1] / current_num) operation = char current_num = 0 i += 1 return sum(stack)"},{"question":"You are given a string `s` which represents a sequence of characters. Your task is to determine if `s` is a valid sequence of brackets. The sequence is considered valid if it satisfies the following rules: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. The valid brackets are `()`, `{}`, and `[]`. Return `true` if the sequence is valid, and `false` otherwise.","solution":"def isValid(s: str) -> bool: Determines if the string s is a valid sequence of brackets. A valid sequence of brackets should have all opening brackets closed by the same type of brackets and should be closed in the correct order. :param s: Input string containing the sequence of brackets. :return: True if the sequence is valid, False otherwise. stack = [] bracket_map = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"Given a list of integers `arr`, write a function to find the longest subarray (contiguous elements) that contains no more than two distinct integers. Return the length of this longest subarray.","solution":"def longest_subarray_with_two_distinct(arr): Returns the length of the longest subarray containing no more than two distinct integers. max_length = 0 start = 0 freq = {} for end in range(len(arr)): if arr[end] in freq: freq[arr[end]] += 1 else: freq[arr[end]] = 1 while len(freq) > 2: freq[arr[start]] -= 1 if freq[arr[start]] == 0: del freq[arr[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a string `s` representing a sequence of characters that may include uppercase and lowercase letters, digits, and special characters. Your task is to determine if `s` is a valid identifier string. A valid identifier string must satisfy the following conditions: 1. It should start with either a letter or an underscore (`_`). 2. All subsequent characters must be letters, digits, or underscores. 3. It should not exceed 32 characters in length. For example: - \\"valid_Identifier1\\" is a valid identifier. - \\"1Invalid\\" is not a valid identifier because it starts with a digit. - \\"invalid@\\" is not a valid identifier because it contains a special character. - \\"ThisIdentifierIsWayTooLongToBeValidBecauseItExceedsTheThirtyTwoCharacterLimit\\" is not a valid identifier due to its length. Return `true` if `s` is a valid identifier string. Return `false` otherwise.","solution":"def is_valid_identifier(s): Determine if the given string s is a valid identifier. A valid identifier string must: 1. Start with either a letter or an underscore. 2. All subsequent characters must be letters, digits, or underscores. 3. Not exceed 32 characters in length. Args: s (str): The string to evaluate as an identifier. Returns: bool: True if s is a valid identifier, False otherwise. if not s: return False if len(s) > 32: return False if not (s[0].isalpha() or s[0] == \'_\'): return False for char in s[1:]: if not (char.isalnum() or char == \'_\'): return False return True"},{"question":"You are given an array of integers `arr` and an integer `k`. A **k-sorted** subarray is defined as a subarray of length `k` where every element is less than or equal to its following element (i.e., the subarray is non-decreasing). Return _the total number of **k-sorted** subarrays_ in the array `arr`.","solution":"def count_k_sorted_subarrays(arr, k): Returns the total number of k-sorted subarrays in the given array. :param arr: List[int] - The array of integers. :param k: int - The length of the subarray. :return: int - The number of k-sorted subarrays. n = len(arr) count = 0 for i in range(n - k + 1): sorted_subarray = True for j in range(i, i + k - 1): if arr[j] > arr[j + 1]: sorted_subarray = False break if sorted_subarray: count += 1 return count"},{"question":"Given an integer array `nums` that contains distinct elements and is sorted in increasing order, your task is to find the length of the shortest subarray which is not sorted in strictly increasing order after potentially changing at most one element of `nums`. Return `0` if the entire array can be sorted in strictly increasing order by changing at most one element.","solution":"def findShortestUnsortedSubarray(nums): Returns the length of the shortest subarray which is not sorted in strictly increasing order after potentially changing at most one element of nums. n = len(nums) if n == 1: return 0 start, end = -1, -1 for i in range(n-1): if nums[i] >= nums[i+1]: start = i break if start == -1: return 0 for i in range(n-1, 0, -1): if nums[i] <= nums[i-1]: end = i break min_sub = min(nums[start:end+1]) max_sub = max(nums[start:end+1]) for i in range(start): if nums[i] > min_sub: start = i break for i in range(n-1, end, -1): if nums[i] < max_sub: end = i break return end - start + 1"},{"question":"Given a 2D grid of size `m x n` consisting of only integers, return the length of the shortest path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` such that you can only move either down or right at any point in time. If there is no path to the bottom-right corner, return `-1`.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner of a 2D grid consisting of only integers, moving only down or right. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0)] queue = deque([(0, 0, 1)]) # (row, col, path_length) visited = set((0, 0)) while queue: r, c, length = queue.popleft() if r == m-1 and c == n-1: return length for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, length + 1)) visited.add((nr, nc)) return -1"},{"question":"Write a function called `stringPartition` that takes an input string `s` and divides it into substrings such that each substring contains distinct characters only. Return the length of each substring as an array. For example, given the input string \\"abac\\", the function should return `[2,2]` because \\"ab\\" contains distinct characters, and \\"ac\\" contains distinct characters.","solution":"def stringPartition(s): Divides the input string s into substrings such that each substring contains distinct characters only. Returns a list of the lengths of each substring. if not s: return [] partitions = [] current_partition = \\"\\" for char in s: if char in current_partition: partitions.append(len(current_partition)) current_partition = char else: current_partition += char # Append the last partition if current_partition: partitions.append(len(current_partition)) return partitions"},{"question":"You are given an array of integers `nums`, where each integer represents a different type of candy, and you are also given an integer `k` which represents the number of candies you can pick. Return the maximum number of different types of candies you can pick if you can select `k` candies from the array. *The input array may contain duplicate integers, and each integer signifies a unique type of candy. You should strive to pick as many different types of candies as possible within the limit of `k` picks.*","solution":"def max_different_types_of_candies(nums, k): Given an array of integers representing different types of candies and an integer k, returns the maximum number of different types of candies you can pick with k picks. Parameters: nums (list of int): List of integers where each integer represents a candy type. k (int): Number of candies you can pick. Returns: int: Maximum number of different types of candies. unique_candies = set(nums) max_unique_types = len(unique_candies) # You can pick at most k different types of candies, but not more than the actual # number of unique types available. return min(max_unique_types, k)"},{"question":"Given an array of integers `arr` and an integer `x`, find all unique triplets in the array which gives the sum of `x`. Each triplet should be in the form (arr[i], arr[j], arr[k]) with `i`, `j`, `k` being distinct indices and `arr[i] + arr[j] + arr[k] = x`. You may return the answer in **any order**.","solution":"def three_sum_unique_triplets(arr, x): Finds all unique triplets in the array that sum up to x. :param arr: List[int] - List of integers :param x: int - Target sum :return: List[Tuple[int, int, int]] - List of unique triplets that sum up to x arr.sort() result = set() for i in range(len(arr) - 2): left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: result.add((arr[i], arr[left], arr[right])) left += 1 right -= 1 elif current_sum < x: left += 1 else: right -= 1 return list(result)"},{"question":"You are given a string containing only brackets (\'(\', \')\', \'{\', \'}\', \'[\', and \']\'). Determine if the input string is valid. An input string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. Return `true` if the input string is valid, otherwise return `false`. Implement an efficient solution with a time complexity of `O(n)` and space complexity of `O(n)`.","solution":"def is_valid_bracket_sequence(s): Returns True if the input string is a valid bracket sequence, otherwise False. Conditions for a valid bracket sequence: - Open brackets must be closed by the same type of brackets. - Open brackets must be closed in the correct order. Args: s (str): A string containing only brackets. Returns: bool: True if the string is a valid bracket sequence, False otherwise. bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} open_brackets = set(bracket_map.values()) stack = [] for char in s: if char in open_brackets: stack.append(char) elif char in bracket_map: if stack and stack[-1] == bracket_map[char]: stack.pop() else: return False else: return False # Invalid character return not stack"},{"question":"You are given an array `arr` of positive integers and an integer `amount`. Each element in `arr` represents a different coin denomination. You need to determine the **fewest number of coins** needed to make up the given `amount`. If that amount of money cannot be made up by any combination of the coins, return `-1`. You may assume that you have an infinite number of each kind of coin available.","solution":"def coin_change(coins, amount): Returns the fewest number of coins needed to make up the given amount. If the amount can\'t be made up by any combination of the coins, returns -1. if amount == 0: return 0 # Initialize the DP array with infinity for all values except the 0th dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"Given a list of integers `nums` representing the number of results each player achieved in a series of rounds, return the maximum number of rounds that any one player participated in. A round is defined as a contiguous subsequence of results where each player\'s results do not decrease. For example, in the list `[4, 3, 5, 5, 6, 7, 8, 2, 4]`, the longest round a player participated in would have a length of 6, corresponding to the subsequence `[3, 5, 5, 6, 7, 8]`.","solution":"def max_rounds(nums): Returns the maximum number of rounds a player participated in. :param nums: List of integers representing results of each player. :return: An integer representing the max length of a contiguous subsequence of non-decreasing results. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] >= nums[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # Check the last subsequence max_length = max(max_length, current_length) return max_length"},{"question":"You are given a string `s` consisting of lowercase English letters and the **underscore** character (`\'_\'`). Your task is to return _the **maximal length** of a substring that contains only letters and does not contain any underscore characters_. This measure includes both distinct letters and their frequencies in the substring.","solution":"def max_length_substring_without_underscore(s): Returns the maximal length of a substring that contains only letters and does not contain any underscore characters. max_length = 0 current_length = 0 for char in s: if char == \'_\': max_length = max(max_length, current_length) current_length = 0 else: current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given an array of integers `arr` consisting of `n` elements. You need to find and return the maximum length of a contiguous subarray such that the absolute difference between any two elements in this subarray is less than or equal to `k`.","solution":"def max_length_subarray(arr, k): Returns the maximum length of a contiguous subarray such that the absolute difference between any two elements in this subarray is less than or equal to k. :param arr: List of integers :param k: Integer threshold for the absolute difference :return: Maximum length of the subarray n = len(arr) if n == 0: return 0 max_len = 1 start = 0 for end in range(1, n): while abs(arr[end] - min(arr[start:end+1])) > k or abs(arr[end] - max(arr[start:end+1])) > k: start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given two integer matrices `A` and `B` of the same size, write a function that returns a new matrix `C` where each element `C[i][j]` is the sum of the products of the corresponding elements from `A` and `B` in their respective row and column sub-matrices. Specifically, each element `C[i][j]` is computed as: ``` C[i][j] = sum(A[i][k] * B[k][j] for all k from 0 to n-1) ``` where `A` and `B` are `m x n` matrices.","solution":"def matrix_multiplication(A, B): Returns the matrix multiplication of A and B. A and B are m x n matrices. The function returns a matrix C where C[i][j] = sum(A[i][k] * B[k][j] for all k from 0 to n-1). m = len(A) n = len(A[0]) p = len(B[0]) # Initialize the result matrix C with zeros C = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): C[i][j] = sum(A[i][k] * B[k][j] for k in range(n)) return C"},{"question":"You are given a string `s` that consists of digits from \'0\' to \'9\' and lowercase alphabets. The goal is to reorder the string such that all the alphabets appear in their original order, but all the digits are placed after all the alphabets. For example, if the string is `\\"a1b2c3\\"`, the reordered string should be `\\"abc123\\"`. Return the reordered string.","solution":"def reorder_string(s): Reorders the string such that all alphabets appear first in their original order, followed by all the digits in their original order. :param s: A string consisting of digits and lowercase alphabets. :return: The reordered string. alphabets = [] digits = [] for char in s: if char.isdigit(): digits.append(char) elif char.isalpha(): alphabets.append(char) return \'\'.join(alphabets) + \'\'.join(digits)"},{"question":"Given a list of integers `nums` and an integer `k`, rotate the list to the right by `k` steps, where `k` is non-negative. The rotation should be performed in-place and the relative order of the elements must be preserved. Implement a function `void rotate(vector<int>& nums, int k)` that modifies the `nums` list according to the described rotation.","solution":"def rotate(nums, k): Rotates the list nums to the right by k steps. Args: nums: List[int] - A list of integers. k: int - The number of steps to rotate the list to the right. n = len(nums) k = k % n # In case k is greater than the length of the list # Reverse the entire list nums.reverse() # Reverse the first k elements nums[:k] = reversed(nums[:k]) # Reverse the rest of the list nums[k:] = reversed(nums[k:])"},{"question":"Given an integer array `nums`, move all 0\'s to the end of the array while maintaining the relative order of the non-zero elements. Implement the function such that it modifies the input array in-place with O(1) extra space. Return the modified array.","solution":"def move_zeroes(nums): Move all 0\'s to the end of the array while maintaining the relative order of the non-zero elements. This function modifies the input array in-place. :param nums: List[int] - The input list of integers. :return: List[int] - The modified list with all zeros moved to the end. # Pointer for the position of the next non-zero element last_non_zero_found_at = 0 # If the current element is not 0, then we need to append it just in front # of last non zero element we found. for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at] = nums[i] last_non_zero_found_at += 1 # After we have finished processing new elements, # all the non-zero elements have been moved to # the front and we need to fill the remaining array with 0\'s. for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0 return nums"},{"question":"Given an array of `n` unique integers, find the **maximum length** of a contiguous subarray where the difference between the minimum and maximum element is at most `k`. A contiguous subarray is a subarray that appears consecutively within the original array. For example, the array `[10, 1, 2, 4, 7, 2]` with `k = 5` has a subarray `[4, 7, 2]` where the difference between the maximum and minimum element is `5`, and the length of this subarray is `3`. Return the length of the longest possible subarray that meets the given condition.","solution":"def max_length_subarray(nums, k): Given an array of `n` unique integers, find the maximum length of a contiguous subarray where the difference between the minimum and maximum element is at most `k`. Parameters: nums (List[int]): List of unique integers. k (int): The allowed difference between maximum and minimum elements. Returns: int: Maximum length of the contiguous subarray. if not nums: return 0 from collections import deque max_deque = deque() # stores indices of the numbers in descending order min_deque = deque() # stores indices of the numbers in ascending order left = 0 # left pointer for the sliding window max_len = 0 for right in range(len(nums)): # Ensure max_deque stores elements in descending order while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() max_deque.append(right) # Ensure min_deque stores elements in ascending order while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() min_deque.append(right) # If the current window does not meet the condition, move the left pointer while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() # Update the maximum length of the valid subarray max_len = max(max_len, right - left + 1) return max_len"},{"question":"Implement a data structure `PhoneDirectory` that manages a pool of phone numbers, where each phone number is an integer in the range [0, maxNumbers - 1]. Your methods should enable efficient phone number allocation, return, and availability checking. Implement the `PhoneDirectory` class: * `PhoneDirectory(int maxNumbers)`: Initializes a `PhoneDirectory` object with a pool of phone numbers ranging from 0 to `maxNumbers - 1`. * `int get()`: Provides an available phone number from the pool. Returns `-1` if no numbers are available. * `bool check(int number)`: Checks if a given number is available or not. Returns `true` if the number is available, otherwise returns `false`. * `void release(int number)`: Recycles or releases a phone number back into the pool of available numbers.","solution":"class PhoneDirectory: def __init__(self, maxNumbers: int): Initialize a phone directory with phone numbers ranging from 0 to maxNumbers - 1 self.available = set(range(maxNumbers)) self.in_use = set() def get(self) -> int: Provide an available phone number. Return -1 if none available. if self.available: number = self.available.pop() self.in_use.add(number) return number return -1 def check(self, number: int) -> bool: Check if a phone number is available or not. return number in self.available def release(self, number: int) -> None: Recycle or release a phone number back to the pool of available numbers. if number in self.in_use: self.in_use.remove(number) self.available.add(number)"},{"question":"You are given a `m x n` matrix where each cell contains a non-negative integer. You start at the top-left cell `(0, 0)` and you want to reach the bottom-right cell `(m-1, n-1)`. You can only move either right or down at any point in time. Write a function to find the path that maximizes the sum of the integers along the path. Return the maximum sum that can be achieved by following an optimal path.","solution":"def maxPathSum(matrix): Function to find the maximum sum path from top-left to bottom-right of a matrix, where you can only move right or down. Args: matrix (List[List[int]]): 2D list containing non-negative integers. Returns: int: Maximum sum achievable. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Create a dp table to store the maximum sums dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] return dp[m - 1][n - 1]"},{"question":"You are given a **0-indexed** string `s` consisting of lowercase English letters. You can change at most one character to any other lowercase English letter. Return _the length of the longest palindrome that can be formed with this constraint_. If no change is needed to form a palindrome, return the length of the original string `s`.","solution":"def longest_palindrome_with_one_change(s): Returns the length of the longest palindrome that can be formed by changing at most one character in the string s. n = len(s) def is_palindrome(string): return string == string[::-1] if is_palindrome(s): return n max_palindrome_length = 0 for i in range(n): # Try changing character at position i to every other character for c in \'abcdefghijklmnopqrstuvwxyz\': if s[i] != c: # make sure there is an actual change new_string = s[:i] + c + s[i+1:] if is_palindrome(new_string): max_palindrome_length = n return max_palindrome_length # If no single change makes it a palindrome, one character change can cover longest non-palindrome part return n - 1 # Example usage: # s = \'abca\' # print(longest_palindrome_with_one_change(s)) # Output should be 4 (change \'c\' to \'b\')"},{"question":"You are given a list of integers `nums`, where each integer represents the number of steps you can move forward or backward in the list. Your goal is to determine if you can reach the end of the list starting from the first position. You can move \'nums[i]\' steps forward or backward from the current position `i`. Return `true` if you can reach the last position of the list, otherwise return `false`.","solution":"def can_reach_end(nums): Determines if you can reach the end of the list starting from the first position. Args: nums: List[int] - A list of integers where each integer represents the number of steps you can move forward or backward. Returns: bool - True if you can reach the last position, otherwise False. n = len(nums) if n == 1: return True visited = set() def dfs(position): if position == n - 1: return True visited.add(position) forward = position + nums[position] backward = position - nums[position] if 0 <= forward < n and forward not in visited and dfs(forward): return True if 0 <= backward < n and backward not in visited and dfs(backward): return True return False return dfs(0)"},{"question":"You are given a list of integers representing the heights of a group of people. Write a function to return the number of ways these people can be arranged in lines such that each line contains people in strictly increasing order of their heights. Each person can appear in only one line. If multiple arrangements exist, count each unique arrangement. For example, given the heights `[1, 2, 3]`, the output should be `5` because the possible arrangements are: - `[1], [2], [3]` - `[1, 2], [3]` - `[1, 3], [2]` - `[2, 3], [1]` - `[1, 2, 3]` Note: Assume that the list of heights is sorted in non-decreasing order. Create a function: ```python def countHeightArrangements(heights: List[int]) -> int: # your code here ```","solution":"from typing import List def countHeightArrangements(heights: List[int]) -> int: n = len(heights) if n == 0: return 1 # Only one way when no people dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): dp[i] = dp[i - 1] * 2 return dp[n]"},{"question":"You are given a list of cities and their respective temperatures recorded during a certain period. Each entry is represented as a tuple, with the first element being the city\'s name and the second element being the temperature recorded. Your task is to create a `TemperatureTracker` class that supports the following two methods: * `TemperatureTracker(List[Tuple[str, int]] records)` - Initializes the object with a list of temperature records. * `double get_average_temperature(String city)` - Returns the average temperature of the given city. If the city has no recorded temperatures, return `0.0`. Implement the `TemperatureTracker` class to manage and process temperature data efficiently.","solution":"class TemperatureTracker: def __init__(self, records): Initializes the TemperatureTracker with a list of temperature records. Each record is a tuple containing a city\'s name and a temperature. :param records: List[Tuple[str, int]] self.records = {} for city, temp in records: if city in self.records: self.records[city].append(temp) else: self.records[city] = [temp] def get_average_temperature(self, city): Returns the average temperature for the given city. If the city has no recorded temperatures, returns 0.0 :param city: str :return: float if city not in self.records or len(self.records[city]) == 0: return 0.0 return sum(self.records[city]) / len(self.records[city])"},{"question":"You are given an array of integers `arr` where each value represents a height. Imagine that the heights represent elevations of a terrain. You are to find the amount of water that could be trapped if it rains. The water trapped at each elevation is determined by the maximum height on its left and right sides. Write a function to calculate the total amount of trapped water. The input array `arr` has at least two elements and all elements are non-negative. Return the total water trapped.","solution":"def trap(height): Calculate the total amount of water that could be trapped after raining. :param height: List[int] representing the height of each elevation. :return: int total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given an integer array `nums` and an integer `k`, you need to return the **maximum sum** of a contiguous subarray of length `k`. If the length of `nums` is less than `k`, return 0.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a contiguous subarray of length k. If the length of nums is less than k, returns 0. if len(nums) < k: return 0 current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` containing lowercase letters and an integer `k`. You need to transform the string into a \\"good\\" string with the following properties: the length of the consecutive segments of characters in the string should not exceed `k`. To achieve this, you are allowed to perform the following operation as many times as necessary: choose any character in the string and replace it with any lowercase English letter. Return _the minimum number of operations required to transform the string into a good string._","solution":"def min_operations_to_good_string(s, k): Returns the minimum number of operations required to transform the string into a good string such that the length of consecutive segments of characters in the string does not exceed k. n = len(s) if k >= n: return 0 min_operations = float(\'inf\') for i in range(n - k + 1): segment = s[i:i + k] char_count = {} for char in segment: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 max_freq = max(char_count.values()) operations_needed = k - max_freq min_operations = min(min_operations, operations_needed) return min_operations"},{"question":"You are given a list of integers `nums` and an integer `target`. A pair of indices (i, j) is considered **good** if `nums[i] + nums[j] == target` and `i < j`. Write a function to return _the number of good pairs_ in the list `nums`. If there are no such pairs, return `0`.","solution":"def count_good_pairs(nums, target): Returns the number of good pairs in the list `nums` such that nums[i] + nums[j] == target and i < j. count = 0 for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: count += 1 return count"},{"question":"You are given a list of non-negative integers representing the amount of money of each house. Each house is arranged in a row, and each house can optionally have a security system installed. The security system forces there to be at least one house between two houses with a system (i.e., no two adjacent houses can have security systems). Given this information, return the maximum amount of money you can collect without triggering the security system.","solution":"def rob(nums): This function calculates the maximum amount of money you can rob without triggering the security system, given that no two adjacent houses can be robbed. :param nums: List[int] - a list of non-negative integers representing the amount of money in each house :return: int - the maximum amount of money that can be robbed if not nums: return 0 if len(nums) == 1: return nums[0] prev1, prev2 = 0, 0 for num in nums: current = max(prev1, prev2 + num) prev2 = prev1 prev1 = current return prev1"},{"question":"Given a string `s` and an array of dictionary words `dict`, return the minimum number of extra characters left over if you concatenate words from the dictionary to form the given string `s`. * Each word in the dictionary can be used multiple times. * You may assume that each word in the dictionary is unique. For example: - If `s = \\"applepenapple\\"` and `dict = [\\"apple\\", \\"pen\\"]`, then you can form the string using all dictionary words without any extra characters. - If `s = \\"catsandog\\"` and `dict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]`, then it is not possible to form the whole string using the given dictionary words, thus leaving at least one extra character.","solution":"def min_extra_characters(s, dict_words): Returns the minimum number of extra characters left over if you concatenate words from the dictionary to form the given string s. def helper(s, dict_words, memo): if s in memo: return memo[s] if not s: return 0 min_till_now = float(\'inf\') for word in dict_words: if s.startswith(word): min_till_now = min(min_till_now, helper(s[len(word):], dict_words, memo)) memo[s] = min_till_now if min_till_now != float(\'inf\') else 1 + helper(s[1:], dict_words, memo) return memo[s] memo = {} return helper(s, dict_words, memo)"},{"question":"You are given a **0-indexed** integer array `nums` sorted in strictly increasing order and an integer `target`. Your task is to find the starting and ending position of a given `target` value in the array. If `target` is not found in the array, return [-1, -1]. Write a function `searchRange` that takes in any number of sorted integer arrays `nums` and the integer `target` and returns a list of lists containing the starting and ending positions for each `nums`.","solution":"def searchRange(nums, target): Returns a list with the starting and ending positions of target in the list nums. If target is not found in nums, returns [-1, -1]. def findStartingIndex(nums, target): index = -1 low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] >= target: high = mid - 1 else: low = mid + 1 if nums[mid] == target: index = mid return index def findEndingIndex(nums, target): index = -1 low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] <= target: low = mid + 1 else: high = mid - 1 if nums[mid] == target: index = mid return index start = findStartingIndex(nums, target) end = findEndingIndex(nums, target) return [start, end]"},{"question":"You are given an array of `n` distinct integers and an integer `k`. Your goal is to determine the `k`-th largest element in the array. This involves sorting the array and finding the correct element at position `k`. Return the `k`-th largest element in the array. Do this without modifying the original array if possible. Use careful consideration of time and space complexity.","solution":"def find_kth_largest(nums, k): Returns the k-th largest element in the array. Args: nums : List[int] - A list of distinct integers k : int - The \\"k-th\\" position to find in terms of largest elements Returns: int - The k-th largest element in the array nums_sorted = sorted(nums, reverse=True) return nums_sorted[k - 1]"},{"question":"You are given a list of non-negative integers `nums`, representing the amount of apples in each basket. You are allowed to remove exactly one basket from the list, after which you need to calculate the maximum number of apples that can be collected from the remaining baskets, such that the collected apples are from consecutive baskets only. Write a function that returns the maximum number of apples that can be collected after removing one basket.","solution":"def max_apples_after_removal(nums): Returns the maximum number of apples that can be collected from consecutive baskets after removing one basket. n = len(nums) # If there is only one basket, removing it will leave us with zero apples. if n == 1: return 0 # Generate prefix sums prefix_sums = [0] * n prefix_sums[0] = nums[0] for i in range(1, n): prefix_sums[i] = prefix_sums[i-1] + nums[i] # Consider removals max_apples = 0 for i in range(n): if i == 0: # Remove the first basket, consider baskets from 1 to n-1 current_apples = prefix_sums[n-1] - prefix_sums[0] elif i == n-1: # Remove the last basket, consider baskets from 0 to n-2 current_apples = prefix_sums[n-2] else: # Remove any middle basket i, consider baskets from 0 to i-1 and i+1 to n-1 current_apples = prefix_sums[i-1] + (prefix_sums[n-1] - prefix_sums[i]) max_apples = max(max_apples, current_apples) return max_apples"},{"question":"Implement a data structure that supports the following operations on a collection of strings. Each string consists only of lowercase letters (\'a\' to \'z\'). The data structure should allow adding new words and finding if a string matches any previously added string where a dot (\'.\') can represent any one letter. Implement the `WordDictionary` class: * `WordDictionary()` Initializes an empty word dictionary. * `void addWord(String word)` Adds a word into the data structure. * `boolean search(String word)` Returns `true` if there is any string in the data structure that matches `word` or else `false`. A word could contain dots `\'.\'` where dots can be matched with any letter.","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: Adds a word into the data structure. self.words.append(word) def search(self, word: str) -> bool: Returns whether there is any word in the data structure that matches the given word. A dot \'.\' can match any letter. import re pattern = \'^\' + word.replace(\'.\', \'[a-z]\') + \'\' for w in self.words: if re.match(pattern, w): return True return False"},{"question":"You are given a list of integers `nums` representing the sizes of different files, and an integer `k` representing the number of drives you have. Each drive can hold as many files as possible, but they cannot exceed the respective capacity `cap`. Your task is to determine the minimum capacity `cap` such that all files can be distributed across the `k` drives without any drive exceeding this capacity. Return _the minimum capacity required for the drives so that all files are distributed accordingly_.","solution":"def minDriveCapacity(nums, k): Returns the minimum capacity required for the drives so that all files are distributed across the k drives without any drive exceeding this capacity. Parameters: nums (List[int]): List of integers representing the sizes of different files. k (int): Number of drives available. Returns: int: Minimum capacity required for the drives. def canDistribute(cap): drives_used = 1 current_capacity = 0 for size in nums: if current_capacity + size > cap: drives_used += 1 current_capacity = size if drives_used > k: return False else: current_capacity += size return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canDistribute(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` and an array of strings `patterns`. Each element in `patterns` represents a \\"*wildcard*\\" pattern where `?` can match any single character, and `*` can match any sequence of characters (including an empty sequence). Write a function that returns the number of patterns that `s` matches. **Note**: - The input string `s` contains only lowercase English letters. - The patterns array contains all patterns with wildcard characters `?` and `*`. - For example, if `s = \\"abcd\\"` and `patterns = [\\"a*d\\", \\"a?c*\\", \\"*b*\\"]`, the matching patterns are `[\\"a*d\\", \\"*b*\\"]`. **Examples**: - Input: `s = \\"abxyzcd\\"`, `patterns = [\\"a*d\\", \\"a?z*\\", \\"*z*d\\"]` Output: `2` - Input: `s = \\"hello\\"`, `patterns = [\\"h?llo\\", \\"he*o\\", \\"h*llo\\"]` Output: `3`","solution":"import fnmatch def count_matching_patterns(s, patterns): Returns the count of patterns that match the input string s. Params: s (str): Input string to be matched against patterns. patterns (list): List of patterns with wildcards. Returns: int: Count of patterns that match the string s. count = 0 for pattern in patterns: if fnmatch.fnmatch(s, pattern): count += 1 return count"},{"question":"You are given an array of integers `arr` and an integer `k`. The array `arr` is rotated at some pivot unknown to you beforehand (for example, `[0, 1, 2, 4, 5, 6, 7]` might become `[4, 5, 6, 7, 0, 1, 2]`). Most importantly, the array does not have duplicates. You need to find the index of the target integer `k` in `arr`. If `k` is not present in the array, return `-1`. Your solution should have a time complexity of O(log n).","solution":"def search_rotated_array(arr, k): Returns the index of the target integer k in the rotated array arr. If k is not present in the array, return -1. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == k: return mid if arr[low] <= arr[mid]: # Left half is sorted if arr[low] <= k < arr[mid]: high = mid - 1 # Target is in the left half else: low = mid + 1 # Target is in the right half else: # Right half is sorted if arr[mid] < k <= arr[high]: low = mid + 1 # Target is in the right half else: high = mid - 1 # Target is in the left half return -1 # Target not found"},{"question":"You are given a string `s` consisting of lowercase letters. You need to create a new string by deleting some characters from `s` such that each character appears an even number of times. Return the length of the longest possible string that can be created.","solution":"def longest_even_length_string(s): Returns the length of the longest string that can be created from \'s\' such that each character appears an even number of times. from collections import Counter # Count frequency of each character in the string freq = Counter(s) longest_len = 0 # Calculate the length of the longest possible string with even frequencies for char, count in freq.items(): longest_len += (count // 2) * 2 return longest_len"},{"question":"You are given a string consisting of lowercase English letters. Your task is to determine if it can be rearranged to form a palindrome. Implement the function `canFormPalindrome(s)` that returns `true` if the characters of the input string can be rearranged to form a palindrome, and `false` otherwise. * For example, if the input string is `\\"civic\\"`, the function should return `true` because `\\"civic\\"` is a palindrome. If the input string is `\\"ivicc\\"`, the function should return `true` because it can be rearranged to `\\"civic\\"`. If the input string is `\\"hello\\"`, the function should return `false` because there is no way to rearrange the letters to form a palindrome.","solution":"def canFormPalindrome(s): Determines if the characters of the input string can be rearranged to form a palindrome. :param s: Input string consisting of lowercase English letters :return: True if the string can be rearranged to form a palindrome, False otherwise from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Check the number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If the odd_count is more than 1, it cannot be rearranged to form a palindrome return odd_count <= 1"},{"question":"You are given a list of non-negative integers representing the amount of gasoline at gas stations in a circular route. Starting at any gas station, you can travel to the next gas station by consuming one unit of gasoline. Determine the starting gas stations from which you can complete the circular route exactly once without running out of gasoline. Return _a **list of indices**_ representing all such starting gas stations.","solution":"def find_starting_gas_stations(gas_stations): Determines the starting gas stations from which the circular route can be completed. Args: gas_stations (list): List of non-negative integers representing gasoline at gas stations. Returns: list: Indices of all starting gas stations from which the circular route can be completed. n = len(gas_stations) start_indices = [] for start in range(n): tank = 0 for i in range(n): tank += gas_stations[(start + i) % n] if tank < 1: break else: start_indices.append(start) return start_indices"},{"question":"Given a collection of intervals on a number line, implement a system to efficiently find the overlapping intervals. Design the `IntervalManager` class: * `IntervalManager()` Initializes an `IntervalManager` object. * `void addInterval(int start, int end)` Adds a new interval [start, end] to the collection. * `List<Interval> findOverlaps(int start, int end)` Returns a list of intervals from the collection that overlap with the interval [start, end]. **Note** that two intervals [a, b] and [c, d] overlap if and only if `a <= d` and `c <= b`.","solution":"class IntervalManager: def __init__(self): self.intervals = [] def add_interval(self, start, end): Adds a new interval [start, end] to the collection. self.intervals.append((start, end)) def find_overlaps(self, start, end): Returns a list of intervals from the collection that overlap with the interval [start, end]. overlaps = [] for (s, e) in self.intervals: if s <= end and start <= e: # Check for overlap overlaps.append((s, e)) return overlaps"},{"question":"You are given two strings, `s1` and `s2`, and you are allowed to perform **one** of the following operations exactly once on `s1`: 1. Insert a character at any position. 2. Remove a character from any position. 3. Replace a character at any position with another character. Return `true` if `s1` can be converted to `s2` by performing exactly one of these operations. Otherwise, return `false`.","solution":"def is_one_edit_distance(s1, s2): Determines if two strings s1 and s2 are one edit distance apart. An edit can be an insertion, deletion, or substitution of a character. len1, len2 = len(s1), len(s2) # If the length difference is more than 1, return False if abs(len1 - len2) > 1: return False # Ensure that s1 is the shorter or equal length string if len1 > len2: s1, s2 = s2, s1 len1, len2 = len2, len1 # Try to find the first differing character for i in range(len1): if s1[i] != s2[i]: if len1 == len2: # If lengths are the same, replace character return s1[i+1:] == s2[i+1:] else: # If lengths are different, insert character in s1 or remove from s2 return s1[i:] == s2[i+1:] # If no differing characters found, must be an insertion at the end return len1 + 1 == len2"},{"question":"Given a list of unique integers `arr` representing the index positions, and a string `s` of the same length, rearrange the string `s` such that the characters are placed in the positions specified by `arr`. Return the rearranged string. Example: - Suppose `arr = [2, 0, 3, 1]` and `s = \\"abcd\\"`. - The character \'a\' from `s` should go to position `2` (0-based indexing), \'b\' should go to position `0`, \'c\' to position `3`, and \'d\' to position `1`. - The result should be `\\"bdac\\"`. You may assume that the given array will always be valid and the length of `arr` and `s` will always be the same.","solution":"def rearrange_string(arr, s): Rearranges the string s according to the index positions specified in arr. Parameters: arr (list): A list of unique integers representing index positions. s (str): A string to be rearranged. Returns: str: A rearranged string. n = len(s) rearranged = [\'\'] * n for i in range(n): rearranged[arr[i]] = s[i] return \'\'.join(rearranged)"},{"question":"Given a string `s`, you need to split `s` into as few strings as possible such that each string is a palindrome. Return the minimum number of splits needed.","solution":"def minPalindromicSplits(s): Returns the minimum number of splits needed such that each substring is a palindrome. n = len(s) # dp[i] will be the minimum cuts needed for a palindromic partition of substring s[0:i+1] dp = [0] * n # pal[i][j] will be true if s[i:j+1] is a palindrome pal = [[False] * n for _ in range(n)] for i in range(n): min_cut = i # Maximum cuts needed initially is the length of substring for j in range(i + 1): if s[j] == s[i] and (i - j <= 2 or pal[j + 1][i - 1]): pal[j][i] = True # If s[j:i+1] is a palindrome, minimize the cut min_cut = 0 if j == 0 else min(min_cut, dp[j - 1] + 1) dp[i] = min_cut return dp[-1]"},{"question":"Given a directed graph, determine if there is a cycle present. The graph is represented by an array of edges where `edges[i] = [ui, vi]` indicates a directed edge from node `ui` to node `vi`. Return `true` if there is a cycle in the graph and `false` otherwise. You can assume that the graph does not contain self-loops and multiple edges between the same pair of nodes.","solution":"def has_cycle(num_nodes, edges): Determine if there is a cycle in the directed graph. :param num_nodes: Number of nodes in the graph. :param edges: List of edges represented as pairs [ui, vi]. :return: True if there is a cycle, False otherwise. from collections import defaultdict, deque # Build adjacency list adj_list = defaultdict(list) indegree = [0] * num_nodes for u, v in edges: adj_list[u].append(v) indegree[v] += 1 # Queue for nodes with no incoming edges (indegree 0) queue = deque([node for node in range(num_nodes) if indegree[node] == 0]) visited = 0 while queue: node = queue.popleft() visited += 1 for neighbor in adj_list[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If visited nodes count is not equal to the number of nodes, there is a cycle return visited != num_nodes"},{"question":"You are given a string `s` and you need to support the following queries: * Determine the character that appears the most frequently in a specified range of the string. * Update a character at a specified position in the string. Implement the `FrequentCharacter` class: * `FrequentCharacter(String s)` Initializes the object with the string `s`. * `char query(int left, int right)` Returns the character that appears most frequently in the substring `s[left:right + 1]`. If there are multiple characters with the same highest frequency, return the lexicographically smallest one. * `void update(int index, char char)` Updates the character at position `index` in the string `s` to `char`. For instance, with an initial string `s = \\"abacad\\"`, `query(0, 2)` should return `\'a\'` because `\'a\'` appears twice in the substring `\\"aba\\"`, more frequently than other characters. If we then `update(1, \'c\')` making the string `\\"accad\\"`, a subsequent `query(2, 4)` should return `\'c\'` for the substring `\\"cad\\"`.","solution":"from collections import Counter class FrequentCharacter: def __init__(self, s): self.s = list(s) # Store string as a list to enable mutable operations def query(self, left, right): Returns the character that appears most frequently in the substring s[left:right + 1]. If there are multiple characters with the same highest frequency, return the lexicographically smallest one. substring = self.s[left:right + 1] count = Counter(substring) # Find the max frequency max_freq = max(count.values()) # Find the lexicographically smallest character with the max frequency result = min([char for char in count if count[char] == max_freq]) return result def update(self, index, char): Updates the character at position index in the string s to char. self.s[index] = char"},{"question":"You are working on a text editor application that supports a special undo feature. The application needs to keep track of the text entered by the user and support undo operations. Implement a class `TextEditor` with the following functionalities: - `TextEditor()`: Initializes the text editor with an empty string. - `void addText(string text)`: Appends the given `text` to the current text in the editor. - `void undo()`: Reverts the text in the editor to the state it was in just before the most recent `addText` operation. If there was no `addText` operation before the undo, the text remains unchanged. - `string getText()`: Returns the current text in the editor. For example: 1. Initialize the text editor: `TextEditor editor = new TextEditor();` 2. Add text \\"hello\\": `editor.addText(\\"hello\\");`, the current text is \\"hello\\". 3. Add text \\" world\\": `editor.addText(\\" world\\");`, the current text is \\"hello world\\". 4. Undo the last add: `editor.undo();`, the current text is \\"hello\\". 5. Get the current text: `editor.getText();`, it should output \\"hello\\".","solution":"class TextEditor: def __init__(self): self.current_text = \\"\\" self.history = [] def addText(self, text): self.history.append(self.current_text) self.current_text += text def undo(self): if self.history: self.current_text = self.history.pop() def getText(self): return self.current_text"},{"question":"You are given an m x n integer grid called `matrix`. Begin traversing `matrix` from the top-left corner in a zigzag pattern, starting by going rightwards. Specifically, reverse the direction alternately for each row (right to left for the first row, left to right for the second row, and so on). Collect all the numbers from this traversal into a single list and return that list. For example, given: ```plaintext matrix = [[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16]] ``` You should return: ```plaintext [1, 2, 3, 4, 8, 7, 6, 5, 9, 10, 11, 12, 16, 15, 14, 13] ```","solution":"def zigzag_traversal(matrix): Perform rightward and leftward zigzag traversal of the given 2D matrix. Args: matrix (list of list of int): The 2D list to traverse. Returns: list of int: The traversal order. m = len(matrix) if m == 0: return [] result = [] for i in range(m): if i % 2 == 0: # Even index rows go rightwards result.extend(matrix[i]) else: # Odd index rows go leftwards result.extend(matrix[i][::-1]) return result"},{"question":"You are given a 2D integer matrix `grid` representing a map where `0` represents water and `1` represents land. An island is a maximal 4-directionally connected group of `1`s. The perimeter of an island is the total length of the boundary of the island. The boundary only touches water or the edge of the grid. Write an algorithm to find the perimeter of the island located in `grid`. It is guaranteed that there is exactly one island in `grid`. Implement the function `int islandPerimeter(int[][] grid)` that returns the perimeter of the island.","solution":"def islandPerimeter(grid): Calculates the perimeter of the island in the given grid. Args: grid (list of list of int): A 2D grid representing the map where 0 represents water and 1 represents land. Returns: int: The perimeter of the island. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Increment perimeter count for each boundary to water or edge perimeter += 4 if r > 0 and grid[r - 1][c] == 1: # check top perimeter -= 2 if c > 0 and grid[r][c - 1] == 1: # check left perimeter -= 2 return perimeter"},{"question":"You are given an array of integers `tasks` where `tasks[i]` represents the CPU time needed to complete the `i-th` task, and an integer `n` representing the cooldown period between two same tasks. Find the minimum time needed to complete all tasks, given that you must wait for at least `n` units of time before executing the same task again. Return the minimum time required to complete all tasks.","solution":"from collections import Counter def minTime(tasks, n): Returns the minimum time required to complete all tasks with cooldown period. if not tasks: return 0 task_counts = Counter(tasks) max_freq = max(task_counts.values()) num_max_freq_tasks = list(task_counts.values()).count(max_freq) part_count = max_freq - 1 part_length = n - (num_max_freq_tasks - 1) empty_slots = part_count * part_length available_tasks = len(tasks) - max_freq * num_max_freq_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"You are given an array of integers `nums` and an integer `k`. Move the first `k` elements to the end of the array in the same order, and shift the remaining elements to the beginning. Return the modified array. Try to do this in-place with O(1) extra space.","solution":"def shift_array(nums, k): Moves the first k elements of the array to the end in the same order, and shifts the remaining elements to the beginning. n = len(nums) if n == 0 or k <= 0 or k >= n: return nums nums[:] = nums[k:] + nums[:k] return nums"},{"question":"Given an array of integers, sort the array in ascending order using the heap sort algorithm. You should not use any built-in sort functions or libraries. Output the sorted array.","solution":"def heapify(arr, n, i): Converts a subtree rooted with node i into a max heap. n is the size of the heap i is the index in arr[] largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[i] < arr[left]: largest = left # See if right child of root exists and is greater than root if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) def heap_sort(arr): Performs heap sort on the input array. n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) return arr"},{"question":"You are given an array of integers `nums` and an integer `target`. Write a function to determine if `nums` can be partitioned into two subsets such that the sum of the elements in both subsets is equal and each subset\'s total is equal to `target`. Return `true` if such a partition exists, otherwise return `false`. Note that each element in the array must be included in exactly one of the two subsets.","solution":"def can_partition(nums, target): Determines if the nums array can be partitioned into two subsets each with a sum equal to the target. total_sum = sum(nums) # Check if total sum is less than twice the target or the sum is odd if total_sum < 2 * target or total_sum % 2 != 0: return False current_target = total_sum // 2 n = len(nums) dp = [False] * (current_target + 1) dp[0] = True for num in nums: for i in range(current_target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[current_target - target]"},{"question":"Given a list of non-negative integers `nums`, arrange them such that they form the largest possible number and return this number as a string. For example, given `[10, 2]`, return `\\"210\\"`. If the result is just 0, ensure your output is \\"0\\".","solution":"from functools import cmp_to_key def largest_number(nums): Arrange numbers to form the largest possible number and return it as a string. # Custom comparator to decide the order based on string concatenation def compare(x, y): if x + y > y + x: return -1 if x + y < y + x: return 1 return 0 # Convert numbers to strings for comparison nums_str = list(map(str, nums)) # Sort using the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Join the sorted strings largest_num = \'\'.join(nums_str) # Handle the case where the number is zero if largest_num[0] == \'0\': return \'0\' return largest_num"},{"question":"A company has employees working on several projects, and each project has a leader. You are given the following information: - A list of `projects` where `projects[i]` is a tuple containing the `project_id` and the `leader_id` of the project. - A list of `subordinates` where `subordinates[j]` is a tuple containing `boss_id` and `employee_id` indicating that `boss_id` is the direct boss of `employee_id`. You need to construct a hierarchy tree and return a JSON-like object representing the entire hierarchy of the company. Each project leader’s subordinates (direct and indirect) should be listed under them. If a project leader is a subordinate to another project leader, they should appear in the hierarchy accordingly. If the data contains a cycle or inconsistency, an error message should be returned. Your task is to implement a function that builds and validates this organizational hierarchy.","solution":"def build_hierarchy(projects, subordinates): from collections import defaultdict def detect_cycle(node, graph, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in graph[node]: if not visited[neighbor]: if detect_cycle(neighbor, graph, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False project_leaders = set([leader_id for project_id, leader_id in projects]) hierarchy = defaultdict(list) subordinates_dict = defaultdict(list) for boss_id, emp_id in subordinates: subordinates_dict[boss_id].append(emp_id) graph = defaultdict(list) for boss_id in subordinates_dict: graph[boss_id].extend(subordinates_dict[boss_id]) for emp_id in subordinates_dict[boss_id]: graph[emp_id] # ensure emp_id in graph visited = {node: False for node in graph} rec_stack = {node: False for node in graph} for node in graph: if not visited[node]: if detect_cycle(node, graph, visited, rec_stack): return \\"Error: Cycle detected in the hierarchy\\" def build_sub_tree(leader_id): sub_tree = {\\"id\\": leader_id, \\"employees\\": []} for emp_id in subordinates_dict[leader_id]: sub_tree[\\"employees\\"].append(build_sub_tree(emp_id)) return sub_tree hierarchy_tree = {\\"company\\": []} for project_id, leader_id in projects: hierarchy_tree[\\"company\\"].append({ \\"project_id\\": project_id, \\"leader\\": build_sub_tree(leader_id) }) return hierarchy_tree"},{"question":"You are given an integer array `arr` and an integer `target`. A **subsequence** of the array is a sequence that can be derived by deleting some or no elements of the array without changing the order of the remaining elements. Return the **minimum length** of a subsequence that sums to `target`. If there is no such subsequence, return `-1`.","solution":"def min_length_subsequence(arr, target): Returns the minimum length of a subsequence that sums to the target. If there is no such subsequence, returns -1. # We will use dynamic programming to solve this problem. from collections import defaultdict # Initialize a dictionary to store the minimum length for each possible sum dp = defaultdict(lambda: float(\'inf\')) dp[0] = 0 # Iterate over each element in the array for num in arr: # Copy the current state of dp to avoid modifying it during iteration current_dp = dp.copy() for curr_sum, length in current_dp.items(): new_sum = curr_sum + num dp[new_sum] = min(dp[new_sum], length + 1) # Check if we have found a subsequence summing to target return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"You are given a binary matrix `mat` of size `m x n`, where `mat[i][j]` is either `0` or `1`. A row or column is filled with `1`s if every element in that row or column is `1`. Return the number of rows and columns that are filled with `1`s. - For example, given `mat = [[1, 1, 0], [1, 1, 1], [1, 1, 1]]`, the output should be `3`, since the second row and third row are filled with `1`s, and the first and second columns are filled with `1`s (but counted once).","solution":"def count_filled_rows_and_columns(mat): Returns the number of rows and columns that are completely filled with 1s. Parameters: mat (list of list of int): The binary matrix Returns: int: Number of rows and columns filled with 1s m = len(mat) n = len(mat[0]) filled_rows = set() filled_columns = set() # Check for filled rows for i in range(m): if all(mat[i][j] == 1 for j in range(n)): filled_rows.add(i) # Check for filled columns for j in range(n): if all(mat[i][j] == 1 for i in range(m)): filled_columns.add(j) return len(filled_rows) + len(filled_columns)"},{"question":"You are given an array of integers `nums` which represents the amount of money of each house in a street. All the houses are arranged in a linear fashion. A robber is planning to rob houses along the street, but he can\'t rob two adjacent houses because it would automatically alert the police. Determine the **maximum amount of money** the robber can rob tonight without alerting the police. Return _this maximum amount_.","solution":"def rob(nums): Returns the maximum amount of money the robber can rob tonight without alerting the police. if not nums: return 0 if len(nums) == 1: return nums[0] rob1, rob2 = 0, 0 for n in nums: new_rob = max(rob1 + n, rob2) rob1, rob2 = rob2, new_rob return rob2"},{"question":"A company is designing a network that connects several servers. The network is represented by a 2D integer array `connections` of length `m` where `connections[i] = [ui, vi]` denotes a bidirectional connection between servers `ui` and `vi`. To ensure that the network can handle increased traffic, they want to determine the **minimal number of connections** required to make all the servers interconnected, if possible. Given the number of servers `n` and the array `connections`, return the minimal number of additional connections needed to fully connect all servers. If it\'s not possible to connect every server, return `-1`.","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def make_connected(n, connections): if len(connections) < n - 1: return -1 parent = list(range(n)) rank = [0] * n for x, y in connections: union(parent, rank, x, y) components = len(set(find(parent, i) for i in range(n))) return components - 1"},{"question":"You are given an array of integers `height` representing the histogram\'s bar height where the width of each bar is `1`. Return the area of the largest rectangle in the histogram. You need an efficient solution with a time complexity of O(n).","solution":"def largestRectangleArea(heights): Calculates the area of the largest rectangle in the histogram represented by heights. Arguments: heights -- list of integers representing the height of histogram bars Returns: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top = stack.pop() if stack: area = heights[top] * (index - stack[-1] - 1) else: area = heights[top] * index max_area = max(max_area, area) while stack: top = stack.pop() if stack: area = heights[top] * (index - stack[-1] - 1) else: area = heights[top] * index max_area = max(max_area, area) return max_area"},{"question":"A railway company is planning a new transportation system. They need a function to find the shortest path between two stations. You are given a number of stations (represented as nodes) and a list of direct routes between them (represented as edges with distances). Each station is numbered from 0 to n-1. Implement a function that takes two integers source and destination (representing the start and end stations), along with a list of edges where each edge is represented as a tuple (u, v, w) indicating there is a direct route from station u to station v with distance w, and returns the shortest distance between the source and destination stations. If there is no path, return -1.","solution":"import heapq def dijkstra_shortest_path(num_stations, edges, source, destination): Finds the shortest distance between the source and destination stations. Parameters: num_stations (int): Number of stations. edges (list of tuples): Each tuple (u, v, w) represents a direct route from station u to station v with distance w. source (int): The starting station. destination (int): The destination station. Returns: int: The shortest distance from source to destination station. If no path, returns -1. graph = {i: [] for i in range(num_stations)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) min_heap = [(0, source)] # (distance, station) distances = {i: float(\'inf\') for i in range(num_stations)} distances[source] = 0 while min_heap: current_distance, current_station = heapq.heappop(min_heap) if current_station == destination: return current_distance for neighbor, weight in graph[current_station]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1 if distances[destination] == float(\'inf\') else distances[destination]"},{"question":"Design a class called `CircularQueue` that represents a circular queue with a fixed size. Implement the following methods: * `CircularQueue(int k)` - Constructor to initialize the queue with a size `k`. * `bool enQueue(int value)` - Adds an item to the rear of the queue. Returns `true` if the operation is successful, `false` otherwise. * `bool deQueue()` - Deletes an item from the front of the queue. Returns `true` if the operation is successful, `false` otherwise. * `int Front()` - Gets the front item from the queue. If the queue is empty, return `-1`. * `int Rear()` - Gets the last item from the queue. If the queue is empty, return `-1`. * `bool isEmpty()` - Checks whether the queue is empty. * `bool isFull()` - Checks whether the queue is full. Implement the `CircularQueue` class such that all methods have an average time complexity of O(1).","solution":"class CircularQueue: def __init__(self, k: int): self.size = k self.queue = [None] * k self.head = -1 self.tail = -1 def enQueue(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value return True def deQueue(self) -> bool: if self.isEmpty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.size return True def Front(self) -> int: if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: return self.head == -1 def isFull(self) -> bool: return (self.tail + 1) % self.size == self.head"},{"question":"Given a string `s` consisting of lowercase letters, you need to remove the outermost parentheses of every primitive string in the primitive decomposition of `s`. A primitive string is defined as a non-empty substring of `s` that can be entirely decomposed into valid pairs of parentheses and is not further decomposable into smaller valid pairs. Return the resulting string after removing the outermost parentheses of every primitive substring.","solution":"def remove_outer_parentheses(s): This function removes the outermost parentheses of every primitive string in the primitive decomposition of the input string. result = [] opened = 0 for char in s: if char == \'(\': if opened > 0: result.append(char) opened += 1 elif char == \')\': if opened > 1: result.append(char) opened -= 1 return \'\'.join(result)"},{"question":"You are given a **0-indexed** integer array `nums` and a target integer `k`. Determine whether there exists a continuous subarray (i.e., a subarray that consists of consecutive elements) whose elements sum up to `k`. If such a subarray exists, return _the length of the longest such subarray_. If there is no such subarray, return `-1`. A subarray is a contiguous part of an array formed by removing zero or more elements from the beginning and/or end of the array without changing the order of the remaining elements.","solution":"def longest_subarray_sum_k(nums, k): Returns the length of the longest continuous subarray whose elements sum up to k. If there is no such subarray, returns -1. sum_indices = {0: -1} # Dictionary to store the first occurrence of each prefix sum prefix_sum = 0 max_len = -1 for i, num in enumerate(nums): prefix_sum += num if prefix_sum - k in sum_indices: max_len = max(max_len, i - sum_indices[prefix_sum - k]) if prefix_sum not in sum_indices: sum_indices[prefix_sum] = i return max_len"},{"question":"Given a **2D grid** of size `m x n` and a list of **instructions**, each instruction represents a point `(x, y)` in the grid. Initially, each point in the grid is set to `0`. For every instruction `(x, y)`, you increment by `1` the value of all cells `(i, j)` such that `0 <= i < x` and `0 <= j < y`. Return _the number of cells in the grid with the maximum integer value after performing all the instructions._","solution":"def max_count(m, n, instructions): Returns the number of cells in the grid with the maximum integer value after performing all the instructions. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. instructions (List[Tuple[int, int]]): List of instructions where each instruction is a point (x, y). Returns: int: Number of cells with the maximum integer value. if not instructions: return m * n x_min = min(x for x, y in instructions) y_min = min(y for x, y in instructions) return x_min * y_min"},{"question":"Given a list of integers, write a function `findSubarrays` that returns all contiguous subarrays whose sum equals a target value. The function should have the following signature: `List<List<Integer>> findSubarrays(int[] nums, int target)`. Each subarray should be represented as a list of integers. The function should return a list of all such subarrays. If no such subarrays exist, return an empty list.","solution":"from typing import List def findSubarrays(nums: List[int], target: int) -> List[List[int]]: Returns all contiguous subarrays whose sum equals the target value. result = [] for start in range(len(nums)): current_sum = 0 for end in range(start, len(nums)): current_sum += nums[end] if current_sum == target: result.append(nums[start:end+1]) return result"},{"question":"You are given a **0-indexed** integer array `heights` of length `n` where `heights[i]` is the height of the `i-th` tree. You want to cut some of the trees down so that the remaining forest forms a strictly increasing sequence of heights from left to right. In each step, you can remove exactly one tree of your choice. Return _the **minimum** number of trees that you need to remove to create a strictly increasing sequence of tree heights._","solution":"def min_removal_for_increasing(heights): Returns the minimum number of trees that need to be removed to form a strictly increasing sequence. if not heights: return 0 n = len(heights) # Create a list to store the length of the longest increasing subsequence that ends with heights[i] lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The length of the longest increasing subsequence max_lis = max(lis) # Minimum number of removals is the total number of trees minus the length of the longest increasing subsequence return n - max_lis"},{"question":"Given two arrays of integers `nums1` and `nums2`, where `nums1` represents the preorder traversal of a binary search tree (BST) and `nums2` represents the inorder traversal of the same BST, construct the binary search tree and return its root. Ensure the constructed tree\'s structure adheres to the properties of a BST and both traversals are valid representations of the same tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder, inorder): Constructs a binary search tree from its preorder and inorder traversals. if not preorder or not inorder: return None # Root is always the first element in preorder traversal root_val = preorder[0] root = TreeNode(root_val) # Find the root element in inorder traversal to divide left and right subtrees root_index_in_inorder = inorder.index(root_val) # Elements to the left of root_index_in_inorder in inorder are the left subtree left_inorder = inorder[:root_index_in_inorder] # Elements to the right of root_index_in_inorder in inorder are the right subtree right_inorder = inorder[root_index_in_inorder + 1:] # Elements in preorder corresponding to left and right inorder left_preorder = preorder[1:1 + len(left_inorder)] right_preorder = preorder[1 + len(left_inorder):] # Recursively build left and right subtrees root.left = buildTree(left_preorder, left_inorder) root.right = buildTree(right_preorder, right_inorder) return root"},{"question":"You are given a 2D integer matrix `grid` of size `m x n` representing a warehouse where `grid[i][j]` indicates the height of the stack of boxes at position `(i, j)`. You need to find the maximum height difference between two adjacent stacks in the warehouse. Two stacks are considered adjacent if they share a common edge. Return _the maximum height difference between two adjacent stacks in the warehouse_.","solution":"def max_height_difference(grid): Returns the maximum height difference between two adjacent stacks in the warehouse. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) max_diff = 0 for i in range(m): for j in range(n): if i > 0: # Check top max_diff = max(max_diff, abs(grid[i][j] - grid[i-1][j])) if i < m - 1: # Check bottom max_diff = max(max_diff, abs(grid[i][j] - grid[i+1][j])) if j > 0: # Check left max_diff = max(max_diff, abs(grid[i][j] - grid[i][j-1])) if j < n - 1: # Check right max_diff = max(max_diff, abs(grid[i][j] - grid[i][j+1])) return max_diff"},{"question":"You are given a list of networks, where each network is represented by an adjacency list of its nodes. Your task is to identify the number of isolated networks. An isolated network is a set of nodes with no connections to any nodes outside their set. Each node is represented as an integer, and an adjacency list is given as a list of lists. Return _the total number of isolated networks present_. **Examples:** ``` Example 1: Input: [[0,1,2], [3,4], [5]] Output: 3 Explanation: There are three isolated networks: {0,1,2}, {3,4}, and {5}. Example 2: Input: [[0,1], [2,3,4], [5,6,7,8]] Output: 3 Explanation: There are three isolated networks: {0,1}, {2,3,4}, and {5,6,7,8}. Example 3: Input: [[1,2,3], [4,5,6,7,8], [9,10]] Output: 3 Explanation: There are three isolated networks: {1,2,3}, {4,5,6,7,8}, and {9,10}. ```","solution":"def count_isolated_networks(networks): Returns the count of isolated networks. Parameters: networks (list of lists): List of adjacency lists representing different networks. Returns: int: Number of isolated networks. return len(networks)"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find two integers in `nums` such that their sum is equal to `target`, and return the indices of these two integers. It\'s guaranteed that there will always be exactly one solution, and you may not use the same element twice. Return the _indices of the two integers in the form of a tuple_.","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the array that add up to the target. :param nums: List of integers :param target: Integer target sum :return: Tuple of two indices num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i"},{"question":"Given a string `s` consisting of lowercase English letters, you are allowed to perform at most one operation where you can replace a single character in the string `s` with any other lowercase English letter. Return _the length of the longest substring with no repeating characters that can be obtained after performing the operation_. If no operation is needed to create such a substring, return the length of the original longest substring with no repeating characters.","solution":"def longest_substring_after_one_change(s: str) -> int: Returns the length of the longest substring with no repeating characters that can be obtained after performing at most one character change. def longest_unique_substring(S): start = 0 max_length = 0 seen = {} for end, char in enumerate(S): if char in seen and seen[char] >= start: start = seen[char] + 1 seen[char] = end max_length = max(max_length, end - start + 1) return max_length max_len = longest_unique_substring(s) for i in range(len(s)): for ch in \'abcdefghijklmnopqrstuvwxyz\': if s[i] != ch: modified_s = s[:i] + ch + s[i+1:] max_len = max(max_len, longest_unique_substring(modified_s)) return max_len"},{"question":"You are given a `rows x cols` matrix representing a field of `0`s and `1`s. A `0` represents a rock and a `1` represents space one can move into. You start at the top-left corner of the matrix and you need to reach the bottom-right corner. You can move up, down, left, or right to an adjacent unvisited cell (cell denoted by `1`). Your task is to write a function that returns the minimum number of steps to reach the bottom-right corner from the top-left corner, or `-1` if it is not possible.","solution":"from collections import deque def min_steps_to_reach_end(mat): Returns the minimum number of steps to reach the bottom-right corner from the top-left corner of the given matrix. Returns -1 if it is not possible. rows = len(mat) cols = len(mat[0]) # Check if the start or end is blocked if mat[0][0] == 0 or mat[rows-1][cols-1] == 0: return -1 # Directions: right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Queue for BFS queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() # If we reach the bottom-right corner if r == rows - 1 and c == cols - 1: return dist # Explore all 4 directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and mat[nr][nc] == 1 and (nr, nc) not in visited: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"A **binary tree** is a tree data structure in which each node has at most two children, referred to as the left child and the right child. Given the root of a binary tree, implement a function to find the **lowest common ancestor** (LCA) of two given nodes in the tree. The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in the tree that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself). Your function should return the LCA node. To solve this problem, implement the `TreeNode` class and the `lowestCommonAncestor` function: - `class TreeNode`: A class representing a node in the binary tree. Each TreeNode has: - An integer `val` representing the value of the node. - A `TreeNode left` pointing to the left child. - A `TreeNode right` pointing to the right child. - `TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)`: A function that takes the root of the binary tree and two nodes `p` and `q`, and returns the LCA node. You may assume that all TreeNode values are unique and both `p` and `q` exist in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root, p, q): Finds the lowest common ancestor of two nodes p and q in a binary tree. if root is None or root == p or root == q: return root left = lowestCommonAncestor(root.left, p, q) right = lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left is not None else right"},{"question":"You are given a string `s` that represents a sentence containing lowercase English letters and spaces. The words in the sentence are separated by a single space. You need to write a function that returns the sentence after reversing the order of the characters in each word while keeping the words in the same order. For example, given the string `\\"hello world\\"`, the output should be `\\"olleh dlrow\\"`. Implement a function: ```python def reverse_words(s: str) -> str: # your code here ``` The function takes a single string `s` as its parameter and returns a new string with each word\'s characters reversed in place but the words in their original order.","solution":"def reverse_words(s: str) -> str: Reverses the characters in each word of the sentence while keeping the words in the same order. Parameters: s (str): The input sentence containing words separated by spaces. Returns: str: The sentence with each word\'s characters reversed. return \' \'.join(word[::-1] for word in s.split())"},{"question":"You are given an array of strings `words` and a dictionary `dict` where each key is a concatenated string of two words from the array `words` and each value is an integer representing the cost to combine those two words. Your goal is to find the minimum cost to form a new word that is the concatenation of all words in `words` array once in the given order. If it is not possible to form such a word using the combinations in the dictionary, return `-1`. The combination can happen in any order and each pair in `dict` can be used multiple times. Return _the minimum cost to form the new word, or_ `-1` _if it cannot be formed_.","solution":"def min_concat_cost(words, dict): Returns the minimum cost to concatenate all words in the given order using the dictionary of pair costs. If it\'s not possible to concatenate all words, returns -1. n = len(words) if n == 0: return 0 dp = [[float(\'inf\')] * n for _ in range(n)] for i in range(n): current_word = words[i] for j in range(i + 1, n): combined = current_word + words[j] if combined in dict: dp[i][j] = dict[combined] dp[j][i] = dict[combined] for k in range(n): for i in range(n): for j in range(n): if dp[i][k] != float(\'inf\') and dp[k][j] != float(\'inf\'): dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]) minimum_cost = sum(dp[i][i + 1] for i in range(n - 1)) return minimum_cost if minimum_cost != float(\'inf\') else -1"},{"question":"**[Question 4]:** Given an array `nums` consisting of **positive** integers, determine if there exists a set of **three distinct elements** such that any permutation of these three elements can be concatenated to form a **palindrome**. Return `true` if such a set exists, otherwise return `false`. A **palindrome** is a sequence that reads the same forward and backward (e.g., `121` or `2332`).","solution":"def can_form_palindrome(nums): Returns True if there exists a set of three distinct elements such that any permutation of these three elements can be concatenated to form a palindrome. from collections import Counter # Count the occurrences of each element counter = Counter(nums) # We want to check for the situation where at least 3 distinct elements exist where: # - One of them appears at least twice, and the other at least once, OR # - One appears at least thrice for key, value in counter.items(): if value >= 3: return True # Any permutation of three identical numbers works (e.g., 111) # Check for at least one pair and one different element count_pairs = close_to_unity = 0 for value in counter.values(): if value >= 2: count_pairs += 1 if value >= 1: close_to_unity += 1 return count_pairs >= 1 and close_to_unity >= 3 # Example usage: # print(can_form_palindrome([2, 2, 3, 4])) # Should return True (since [2, 2, 3] can form 223) # print(can_form_palindrome([1, 2, 3, 4])) # Should return False"},{"question":"You are given two integer arrays `arr1` and `arr2` of sizes `m` and `n` respectively. Your task is to determine if they have the same set of elements, accounting for their frequencies. Specifically, you need to return `true` if `arr1` and `arr2` are permutations of each other (i.e., each unique element appears the same number of times in both arrays), and `false` otherwise. Arrays are considered permutations of each other if they have the same elements with the same frequencies, regardless of the order of elements.","solution":"from collections import Counter def are_permutations(arr1, arr2): Determines if two arrays are permutations of each other. :param arr1: First list of integers :param arr2: Second list of integers :return: True if arr1 and arr2 have the same elements with the same frequencies, False otherwise return Counter(arr1) == Counter(arr2)"},{"question":"You are given a list of integers `arr` representing the heights of buildings in a row. A person is standing at the last building and facing towards the first building. The person can see a building if it is not shorter than any building to their right. Given the list `arr`, return _the number of buildings that the person can see._ Example: - Input: `arr = [4, 2, 3, 1]` - Output: `3` Explanation: - The person can see the building of height `1`, `3`, and `4`. The building of height `2` is not visible because the building of height `3` blocks the view.","solution":"def visible_buildings(arr): Returns the number of buildings a person standing at the last building and facing towards the first building can see. if not arr: return 0 count = 1 # The person can always see the last building max_height = arr[-1] for height in reversed(arr[:-1]): if height >= max_height: count += 1 max_height = height return count"},{"question":"Given two integers `m` and `n`, write a function that returns an `m x n` matrix filled with elements from 1 to `m * n` in spiral order. The spiral order starts from the top-left corner of the matrix and proceeds in a clockwise manner (right, down, left, up, and repeats).","solution":"def generate_spiral_matrix(m, n): Generates an m x n matrix filled with elements from 1 to m * n in spiral order. Args: m (int): Number of rows. n (int): Number of columns. Returns: list: m x n matrix in spiral order. matrix = [[0] * n for _ in range(m)] num = 1 left, right, top, bottom = 0, n - 1, 0, m - 1 while left <= right and top <= bottom: for col in range(left, right + 1): matrix[top][col] = num num += 1 top += 1 for row in range(top, bottom + 1): matrix[row][right] = num num += 1 right -= 1 if top <= bottom: for col in range(right, left - 1, -1): matrix[bottom][col] = num num += 1 bottom -= 1 if left <= right: for row in range(bottom, top - 1, -1): matrix[row][left] = num num += 1 left += 1 return matrix"},{"question":"You are given an array of strings `words` where each word consists of lowercase English letters. Your task is to find the longest chain of words in which every word is a **predecessor** of the next word in the chain. A word `wordA` is a predecessor of another word `wordB` if and only if `wordB` can be formed by inserting exactly one letter into `wordA` without changing the order of the characters. Return _the length of the longest chain of words._","solution":"from collections import defaultdict def longestStrChain(words): Returns the length of the longest chain of words in which each word is a predecessor of the next word in the chain. words.sort(key=len) # Sort words based on their lengths word_dict = defaultdict(int) max_chain_length = 1 for word in words: for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in word_dict: word_dict[word] = max(word_dict[word], word_dict[predecessor] + 1) word_dict[word] = max(word_dict[word], 1) max_chain_length = max(max_chain_length, word_dict[word]) return max_chain_length"},{"question":"Design a data structure that supports the following operations: `insert`, `delete`, and `getRandom`. The `insert(val)` method inserts an item `val` to the data structure if not already present. The `delete(val)` method removes an item `val` from the data structure if present. The `getRandom()` method returns a random element from the current set of elements (each element must have the same probability of being returned). Implement this data structure with optimal time complexities for each function. **Example:** ``` insert(1); // Inserts 1 to the data structure, returns True insert(2); // Inserts 2 to the data structure, returns True getRandom(); // Returns 1 or 2 randomly delete(1); // Removes 1 from the data structure, returns True getRandom(); // Returns 2 ```","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.data = [] self.data_dict = {} def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. if val in self.data_dict: return False self.data_dict[val] = len(self.data) self.data.append(val) return True def delete(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. if val not in self.data_dict: return False index = self.data_dict[val] last_element = self.data[-1] self.data[index] = last_element self.data_dict[last_element] = index self.data.pop() del self.data_dict[val] return True def getRandom(self) -> int: Get a random element from the set. return random.choice(self.data)"},{"question":"You are given an array `numbers` containing **unique** non-negative integers. A **special pair** is defined as two indices `(i, j)` such that `numbers[i]` + `numbers[j]` is equal to some value `k` and `i < j`. Return _the **count** of all such special pairs in the array_.","solution":"def count_special_pairs(numbers, k): Returns the count of all special pairs (i, j) such that numbers[i] + numbers[j] = k and i < j. Args: numbers (list of int): A list of unique non-negative integers. k (int): The target sum value. Returns: int: The count of all special pairs. count = 0 seen = {} for i, num in enumerate(numbers): complement = k - num if complement in seen: count += seen[complement] if num in seen: seen[num] += 1 else: seen[num] = 1 return count"},{"question":"You are given a non-empty `k`-array tree where each node contains a list of integers representing its children. Write a function to determine if the given tree is a **full** `k`-ary tree or not. A **full** `k`-ary tree is a tree where every node has exactly `k` children or is a leaf node (a node with no children). The tree can be ordered or unordered. Return `True` if the tree is a full `k`-ary tree, otherwise return `False`. The nodes and structure of the tree are provided in an adjacency list format where the keys represent nodes and the values are a list of their children. For example, if `tree = { \'A\': [\'B\', \'C\', \'D\'], \'B\': [], \'C\': [], \'D\': [] }`, and `k = 3`, then the output should be `True`.","solution":"def is_full_k_ary_tree(tree, k): Determines if the given tree is a full k-ary tree. Args: tree (dict): The adjacency list representation of the k-ary tree. k (int): The number of children each node must have to not be a leaf. Returns: bool: True if the tree is a full k-ary tree, False otherwise. for node in tree: children = tree[node] if len(children) > 0 and len(children) != k: return False return True"},{"question":"Given a list of strings `words` representing a sentence split into individual words, write a function that will reverse the order of the words while maintaining their original casing. The list `words` does not contain any punctuation and each word only comprises alphabetical characters. Return the reversed list of words as a single string with words separated by a single space. Ensure the input list `words` and output string preserve the original sequence of characters within each word, only altering the overall order of the words.","solution":"def reverse_sentence(words): Reverses the order of words in the given list while maintaining their original casing. :param words: list of strings :return: reversed sentence as a single string with words separated by a space return \' \'.join(reversed(words))"},{"question":"You are given a string `s` consisting of lowercase letters. You need to repeatedly perform the following operation on the string until it becomes empty: 1. Find the lexicographically smallest character in the string and remove it, appending it to the result. 2. If there are multiple occurrences of the smallest character, remove only the first one (leftmost one). Return the final result string after performing all the operations. Note: The lexicographically smallest character is the character with the lowest ASCII value in the string.","solution":"def remove_lexicographically_smallest(s): Returns a new string formed by iteratively removing the lexicographically smallest character from the original string and appending it to the result string until the original string becomes empty. result = [] while s: smallest_char = min(s) index = s.index(smallest_char) result.append(smallest_char) s = s[:index] + s[index+1:] return \'\'.join(result)"},{"question":"You are given a list of `intervals` where each interval is represented by a pair of integers `[start, end]`, and all intervals are non-overlapping and sorted in ascending order by their start times. Write a function to insert a new interval `newInterval` into `intervals`, merging the intervals if necessary. Return the list of merged intervals after the insertion. For example, given `intervals = [[1, 3], [6, 9]]` and `newInterval = [2, 5]`, the function should return `[[1, 5], [6, 9]]`. Write a function that efficiently seeks to achieve this merging in `O(n)` time complexity, where `n` is the number of intervals.","solution":"def insert_intervals(intervals, newInterval): Insert a new interval into the list of non-overlapping intervals, merging if necessary. :param intervals: List of non-overlapping intervals sorted by start times. :param newInterval: A new interval to insert and merge. :return: The list of merged intervals after insertion of the newInterval. merged = [] i, n = 0, len(intervals) # Add all intervals ending before newInterval starts while i < n and intervals[i][1] < newInterval[0]: merged.append(intervals[i]) i += 1 # Merge intervals that overlap with newInterval while i < n and intervals[i][0] <= newInterval[1]: newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i += 1 merged.append(newInterval) # Add the remaining intervals while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"You are given a **0-indexed** integer array `stones` where each element represents the weight of a stone. In each move, you can choose any two stones and smash them together. Suppose the stones have weights `x` and `y` with `x <= y`. The result of this smash is: - If `x == y`, both stones are destroyed. - If `x != y`, the stone with weight `x` is destroyed, and the stone with weight `y` has new weight `y - x`. Continue smashing the stones until there are no more stones to smash. Return _the weight of the last remaining stone_ or `0` if all stones are destroyed.","solution":"import heapq def last_stone_weight(stones): Given a list of integers representing stone weights, return the weight of the last remaining stone or 0 if all stones are destroyed. Args: stones (List[int]): List of stone weights. Returns: int: Weight of the last remaining stone or 0 if all are destroyed. # Convert the list into a max-heap by using negative values stones = [-stone for stone in stones] heapq.heapify(stones) while len(stones) > 1: # Get the two heaviest stones first = -heapq.heappop(stones) second = -heapq.heappop(stones) if first != second: # Push the difference back into the heap heapq.heappush(stones, -(first - second)) return -stones[0] if stones else 0"},{"question":"You are given an array `arr` of positive integers and a target integer `target`. Your task is to insert an operator `+` or `-` between each pair of adjacent elements in the array so as to create an expression whose sum is equal to `target`. Return _a boolean value_ indicating whether it is possible to construct such an expression.","solution":"def can_sum_to_target(arr, target): Given an array of positive integers and a target integer, checks if it is possible to create a sum to target by placing \'+\' or \'-\' between each pair of adjacent elements. def helper(index, current_sum): if index == len(arr): return current_sum == target return helper(index + 1, current_sum + arr[index]) or helper(index + 1, current_sum - arr[index]) return helper(1, arr[0]) if arr else target == 0"},{"question":"A tyrant is asking you to develop a way to monitor all vehicles that pass through a specific checkpoint. Each vehicle that passes through the checkpoint has a unique identifier and timestamp. You need to track the most recent `k` unique vehicle entries within a given timeframe. If a new entry is made within the timeframe and the unique identifier already exists in the tracked entries, update its timestamp instead of adding a duplicate. If the number of unique entries exceeds `k`, remove the oldest entry. Implement the `CheckpointTracker` class with the following methods: * `CheckpointTracker(int k, int t)` Initializes an object of the `CheckpointTracker` class. Here, `k` is the maximum number of unique vehicle entries to track, and `t` is the timeframe within which entries are to be managed. * `void entry(int vehicleId, int timestamp)` Registers a vehicle entry with the given `vehicleId` and `timestamp`. * `List<Integer> getRecentEntries(int currentTime)` Returns a list of vehicle IDs that are within the timeframe when queried from `currentTime`. Only include entries whose timestamps are within the last `t` units of `currentTime`. The methods should ensure that only the most recent `k` unique entries are tracked and older entries are removed when the count exceeds `k`.","solution":"from collections import OrderedDict class CheckpointTracker: def __init__(self, k: int, t: int): Initializes an object of the CheckpointTracker class. :param k: Maximum number of unique vehicle entries to track :param t: Timeframe within which entries are managed self.k = k self.t = t self.entries = OrderedDict() def entry(self, vehicleId: int, timestamp: int): Registers a vehicle entry with the given vehicleId and timestamp. :param vehicleId: Unique identifier for the vehicle :param timestamp: Timestamp of the vehicle entry if vehicleId in self.entries: del self.entries[vehicleId] self.entries[vehicleId] = timestamp if len(self.entries) > self.k: self.entries.popitem(last=False) def getRecentEntries(self, currentTime: int): Returns a list of vehicle IDs that are within the timeframe when queried from currentTime. :param currentTime: The current timestamp used to determine recent entries :return: List of vehicle IDs within the timeframe recent_entries = [vehicleId for vehicleId, timestamp in self.entries.items() if currentTime - timestamp <= self.t] return recent_entries"},{"question":"You are given a data stream input of characters, and you have to implement the class `StreamChecker` that checks if a given string is a suffix of a previously seen sequence of characters. Specifically, implement the `StreamChecker` class to support the following methods: * `StreamChecker(String[] words)`: Initializes the `StreamChecker` object with a list of `words`. * `boolean query(char letter)`: Returns `true` if any prefix of the `query` string formed by appending `letter` to the previous `query` still matches some suffix of any of the input `words`, otherwise returns `false`. The `StreamChecker` class needs to efficiently handle the data stream and ensure that the check operation can be performed in an optimal manner for real-time processing of the input characters.","solution":"class StreamChecker: def __init__(self, words): Initializes the StreamChecker object with a list of words. self.trie = {} self.stream = [] # Build a trie in reverse order (to facilitate checking suffixes) for word in words: node = self.trie for char in reversed(word): if char not in node: node[char] = {} node = node[char] node[\'\'] = True # End of word def query(self, letter): Returns true if any suffix of the query string matches a word in the stream, false otherwise. self.stream.append(letter) node = self.trie # Check the latest character stream in reverse order for char in reversed(self.stream): if char in node: node = node[char] if \'\' in node: return True else: break return False"},{"question":"Implement a function `findRearrangedPalindrome` that, given a string `s`, returns `true` if any permutation of the string is a palindrome, and `false` otherwise. A palindrome is a string that reads the same forward and backward. The function should consider case insensitivity and ignore non-alphanumeric characters. For example: - Input: `\\"A man, a plan, a canal: Panama\\"` - Output: `true` Explanation: One possible permutation is \\"amanaplanacanalpanama\\", which is a palindrome. - Input: `\\"race a car\\"` - Output: `false` Explanation: No permutation of \\"raceacar\\" can be rearranged to form a palindrome.","solution":"def findRearrangedPalindrome(s): Determines if any permutation of the string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if any permutation of the string can form a palindrome, False otherwise. import re from collections import Counter # Remove non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r\'W\', \'\', s).lower() # Count the occurrences of each character char_count = Counter(cleaned_str) # Check palindrome condition: at most one character can have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"You are given an array of integers `nums` representing the number of items in each group. You want to arrange all items into pairs such that each pair contains items from different groups. The pairing can be done in the following way: - Choose one item from group `i` and one item from group `j` (where `i != j`). - Once paired, these two items are removed from their respective groups. Return the _maximum number of such pairs_ that can be formed.","solution":"def max_pairs(nums): Returns the maximum number of pairs that can be formed from different groups. total_items = sum(nums) max_possible_pairs = total_items // 2 return min(max_possible_pairs, sum(nums) - max(nums))"},{"question":"You are given an array of integers `nums` representing scores of different participants in a contest, and an integer `k` representing the number of winners to be selected. Winners are defined as participants with the highest scores, and in case of a tie, all tied participants are considered winners. You need to determine the total number of winners. Return _the count of participants who are considered winners._ If there are multiple participants with scores equal to the `k`th highest score and including them in the winners list would exceed `k`, count all of them as winners.","solution":"def count_winners(nums, k): Returns the count of participants who are considered winners. nums_sorted = sorted(nums, reverse=True) if k >= len(nums): return len(nums) cutoff_score = nums_sorted[k-1] count = 0 for score in nums: if score >= cutoff_score: count += 1 return count"},{"question":"Given a string `s` consisting of lowercase English letters and an integer `n`, construct the lexicographically smallest string that can be obtained by removing exactly `n` characters from `s`. Return the resulting string.","solution":"def remove_n_chars(s, n): Construct the lexicographically smallest string by removing exactly n characters from s. result = [] for char in s: # While there\'s still characters to remove and the last character in result is larger and removable while n > 0 and result and result[-1] > char: result.pop() n -= 1 result.append(char) # If there are still characters to remove, remove from the end return \'\'.join(result[:len(result) - n])"},{"question":"You are given a string `s` consisting of lowercase English letters. A **duplicate character** in the string is a character that appears more than once. You can perform the following operation on the string: choose any duplicate character and remove one occurrence of it from the string. Return the minimum number of operations required so that no duplicate characters remain in the string.","solution":"def min_remove_to_make_unique(s): Returns the minimum number of operations required so that no duplicate characters remain in the string. from collections import Counter counter = Counter(s) operations = 0 for count in counter.values(): if count > 1: operations += count - 1 return operations"},{"question":"Given a string `s` consisting of only the characters `\'(\'` and `\')\'`, calculate the minimum number of insertions needed to make `s` a valid parentheses string. A valid parentheses string must follow these rules: 1. Every opening parenthesis \'(\' must have a corresponding closing parenthesis \')\'. 2. A closing parenthesis \')\' cannot precede an unmatched opening parenthesis \'(\'. Return the minimum number of insertions required to balance the parentheses string.","solution":"def min_insertions_to_balance_parentheses(s): Calculate the minimum number of insertions required to make the parentheses string valid. :param s: String consisting of only \'(\' and \')\' :return: Minimum number of insertions required left_bracket, insertions_needed = 0, 0 for char in s: if char == \'(\': left_bracket += 1 else: if left_bracket == 0: insertions_needed += 1 # Need one \'(\' else: left_bracket -= 1 return insertions_needed + left_bracket"},{"question":"You are given a `m x n` 2D integer matrix `grid` containing non-negative numbers, representing the maximum number of points that can be obtained in each cell. A robot starts at the top-left corner of the matrix and wants to reach the bottom-right corner (both corners are included in the path). The robot can only move either right or down at any point in time. Write a function to return the maximum number of points the robot can collect by the time it reaches the bottom-right corner of the matrix.","solution":"def max_points(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp array to keep track of the maximum points at each cell dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only be reached from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only be reached from the top) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will contain the maximum points return dp[m-1][n-1]"},{"question":"You are given a string `s` consisting of lowercase English letters, where a **run** is a sequence of consecutive repeating characters. Convert the string `s` into a compressed form by replacing each run with the character followed by the length of the run (if the run length is greater than 1). For example, the string `\\"aaabbc\\"` should be compressed to `\\"a3b2c\\"`, and the string `\\"abc\\"` should remain unchanged since none of the characters repeat consecutively. Return the compressed string.","solution":"def compress_string(s): Compresses the input string by replacing consecutive repeating characters with the character followed by the number of times it repeats consecutively (if > 1). Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The compressed string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 # Add the last run compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return \'\'.join(compressed)"},{"question":"You are given a string `s` consisting only of lowercase letters and an array of `queries`. Each query is represented as a list with two elements `[i, j]`, where you are to reverse the substring of `s` that starts at index `i` and ends at index `j`. Return the final string after all the queries have been applied. The given array of queries needs to be processed in the order they appear.","solution":"def reverse_substring(s, queries): Reverses the substrings of `s` as specified by the list of queries. :param s: The original string consisting only of lowercase letters. :param queries: A list of lists, where each list contains two integers [i, j]. :return: The final string after all queries have been applied. s = list(s) # Convert string to list for easier manipulation for i, j in queries: s[i:j+1] = s[i:j+1][::-1] return \'\'.join(s)"},{"question":"You are given a string `s` that consists of lower case English letters and brackets. Reverse the strings in each pair of matching parentheses starting from the innermost one. The result should not contain any brackets. Return the resulting string after all the reversals are applied.","solution":"def reverseParentheses(s): Reverse the strings in each pair of matching parentheses starting from the innermost one. The result should not contain any brackets. stack = [] for char in s: if char == \')\': temp = [] while stack and stack[-1] != \'(\': temp.append(stack.pop()) stack.pop() # pop the \'(\' stack.extend(temp) else: stack.append(char) return \'\'.join(stack)"},{"question":"Write a function that takes an integer array `nums` and an integer `k`, and returns true if there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and the absolute difference between `i` and `j` is at most `k`. The function should have a time complexity of O(n).","solution":"def contains_nearby_duplicate(nums, k): Returns true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and the absolute difference between i and j is at most k. index_map = {} for i, num in enumerate(nums): if num in index_map and i - index_map[num] <= k: return True index_map[num] = i return False"},{"question":"You are given a **matrix** of integers `mat` of size `m x n` and an integer `target`. Your task is to find a **submatrix** such that the **sum** of its elements is equal to `target`. A submatrix is defined as a contiguous block of elements in the matrix. Return _the number of distinct submatrices that sum to `target`_. If no such submatrix exists, return 0.","solution":"def num_submatrix_sum_target(mat, target): from collections import defaultdict m, n = len(mat), len(mat[0]) count = 0 # Calculate the prefix sum for each row for row in mat: for j in range(1, n): row[j] += row[j - 1] # Start point (i) and end point (j) for the columns of the submatrix for start_col in range(n): for end_col in range(start_col, n): submatrix_sum = defaultdict(int) submatrix_sum[0] = 1 current_sum = 0 # Traverse rows and track the sum for row in range(m): current_sum += mat[row][end_col] if start_col > 0: current_sum -= mat[row][start_col - 1] if current_sum - target in submatrix_sum: count += submatrix_sum[current_sum - target] submatrix_sum[current_sum] += 1 return count"},{"question":"You are given a data stream of integers arriving one by one in the form of an array `nums`, and an integer `k`. Implement a system to find the median of the last `k` elements in the stream at any given time while the stream is still being processed. Design a class `MedianFinder`: * `MedianFinder(int k)` Initializes the `MedianFinder` class with the maximum size `k`. * `void addNum(int num)` Adds the integer `num` to the stream. * `double findMedian()` Returns the median of the last `k` elements. If the stream contains fewer than `k` elements, return the median of all elements in the stream.","solution":"import heapq class MedianFinder: def __init__(self, k): self.k = k self.min_heap = [] self.max_heap = [] self.stream = [] def addNum(self, num): self.stream.append(num) if len(self.stream) > self.k: self.stream.pop(0) # Add to the appropriate heap if not self.max_heap or num <= -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) # Balance the heaps if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self): if not self.stream: return None if len(self.stream) < self.k: data = sorted(self.stream) else: data = sorted(self.stream[-self.k:]) n = len(data) if n % 2 == 1: return float(data[n // 2]) else: return (data[n // 2 - 1] + data[n // 2]) / 2.0"},{"question":"You are given an integer array `arr` of length `n`. Write a function that transforms `arr` into its rank array. The rank array is defined as an array of the same length where each element is replaced by its rank. The rank of an element in `arr` is the position of that element in the sorted version of `arr`, starting with rank 1. For example, if `arr = [40, 10, 20, 30]`, the sorted array is `[10, 20, 30, 40]` and the corresponding rank array is `[4, 1, 2, 3]`. Return the rank array of `arr`.","solution":"def array_rank_transform(arr): Transforms the given array into its rank array. Args: arr (list): The input array. Returns: list: The rank array. if not arr: return [] sorted_unique_arr = sorted(set(arr)) rank_map = {value: rank + 1 for rank, value in enumerate(sorted_unique_arr)} return [rank_map[value] for value in arr]"},{"question":"You are given the `root` of a binary search tree, where each node contains an integer value. Design an algorithm to find the **k-th** smallest element in the BST. Your solution should navigate the tree efficiently, aiming for an optimal time complexity. The tree structure must remain unchanged after your function completes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the k-th smallest element in a binary search tree. Parameters: root (TreeNode): The root of the binary search tree. k (int): The rank of the smallest element to find. Returns: int: The k-th smallest element in the BST. def inorder(node): if node is None: return [] return inorder(node.left) + [node.val] + inorder(node.right) # Perform inorder traversal to get elements in sorted order elements = inorder(root) return elements[k - 1]"},{"question":"You are given an integer array `arr`, where each element is distinct and sorted in ascending order. A **mountain array** is defined as an array that: - Has at least three elements. - There exists some `i` with `0 < i < arr.length - 1` such that: - `arr[0] < arr[1] < ... < arr[i]` - `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]` Given an integer `target`, return _the index_ `i` _of `target` in `arr`. If `target` is not found, return `-1`_. You must solve it in `O(log(n))` time complexity.","solution":"def search_in_mountain_array(arr, target): Search for the target value in a mountain array and return its index. If the target is not found, return -1. def find_peak(arr): low, high = 0, len(arr) - 1 while low < high: mid = (low + high) // 2 if arr[mid] < arr[mid + 1]: low = mid + 1 else: high = mid return low def binary_search(arr, target, low, high, asc=True): while low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid if asc: if arr[mid] < target: low = mid + 1 else: high = mid - 1 else: if arr[mid] > target: low = mid + 1 else: high = mid - 1 return -1 peak = find_peak(arr) result = binary_search(arr, target, 0, peak, True) if result != -1: return result return binary_search(arr, target, peak + 1, len(arr) - 1, False)"},{"question":"Given an array of integers `arr`, apply the following operations to transform the array. Perform each operation only once and in the given order: 1. **Reverse the array**: Reverse the entire array. 2. **Change signs**: Multiply each element of the reversed array by -1. 3. **Replace with squares**: Replace each element in the array with its square. Write a function that takes an integer array `arr` as input and returns the transformed array after applying the three operations sequentially. For example, given the array `arr = [1, -2, 3]`, the transformed array should be `[9, 4, 1]`.","solution":"def transform_array(arr): Transforms the array by reversing it, changing signs, and replacing with squares. # Step 1: Reverse the array reversed_arr = arr[::-1] # Step 2: Change signs changed_signs_arr = [-x for x in reversed_arr] # Step 3: Replace with squares transformed_arr = [x ** 2 for x in changed_signs_arr] return transformed_arr"},{"question":"You are given a **0-indexed** array `transactions` where each transaction is a string in the format `\\"YYYY-MM-DD Amount\\"`, within `YYYY` is the year, `MM` is the month, `DD` is the day, and `Amount` represents the transaction amount in dollars, which can be positive or negative. Write a function that returns _the total amount of money spent during weekends (Saturdays and Sundays) across all transactions_.","solution":"from datetime import datetime def total_weekend_spending(transactions): Returns the total amount of money spent during weekends (Saturdays and Sundays) across all transactions. total_spent = 0 for transaction in transactions: date_str, amount = transaction.split() date = datetime.strptime(date_str, \\"%Y-%m-%d\\") if date.weekday() in {5, 6}: # 5 = Saturday, 6 = Sunday total_spent += float(amount) return total_spent"},{"question":"You are given an `n x n` grid representing a maze consisting of empty spaces and walls. Each empty space is represented by a `0`, and each wall is represented by a `1`. You are allowed to move up, down, left, or right from an empty space. Your goal is to determine the minimum number of moves required to get from the top-left corner of the maze (i.e., grid[0][0]) to the bottom-right corner (i.e., grid[n-1][n-1]). If it is not possible, return `-1`.","solution":"from collections import deque def min_moves_maze(grid): Returns the minimum number of moves required to get from the top-left corner to the bottom-right corner of the maze, or -1 if it is not possible. Args: grid (List[List[int]]): The n x n maze grid. Returns: int: Minimum number of moves, or -1 if not possible. n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 directions = [(1, 0), (-1, 0), (0,1), (0, -1)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, d = queue.popleft() if r == n-1 and c == n-1: return d for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, d + 1)) return -1"},{"question":"You are given a **0-indexed** array of integers `nums`, representing the number of stones in a series of stone heaps. You can choose any heap and remove any non-zero number of stones from it. Your goal is to make all heaps contain an **equal** number of stones using the fewest number of operations. In one operation, you can only pick one heap and remove stones from it. Return _the **minimum number** of operations required to make all heaps equal_.","solution":"def min_operations_to_make_equal(nums): Calculate the minimum number of operations to make all heaps equal. Args: nums: List[int] -- A list of integers representing the number of stones in each heap. Returns: int -- The minimum number of operations needed to make all heaps contain the same number of stones. # Sort the array in non-decreasing order nums.sort() # Initialize counters for operations and unique stone counts seen operations = 0 unique_count = 0 # Iterate through the array, counting the unique number of stone heaps seen so far # and adding it to the total number of operations needed. for i in range(1, len(nums)): if nums[i] != nums[i - 1]: unique_count += 1 operations += unique_count return operations"},{"question":"You are given a positive integer `n`. Return an array `ret`, where `ret[i]` denotes the number of `1` bits in the binary representation of the integer `i` for 0 ≤ `i` ≤ `n`. Write an efficient solution with a time complexity lower than O(n log n).","solution":"def countBits(n): Returns an array ret where ret[i] is the number of 1 bits in the binary representation of i for 0 ≤ i ≤ n. ret = [0] * (n + 1) for i in range(1, n + 1): ret[i] = ret[i >> 1] + (i & 1) return ret"},{"question":"Given an array `events` where each `event` is represented as a triplet `events[i] = [startDay_i, endDay_i, value_i]`, your task is to select the maximum number of non-overlapping events such that the sum of their values is maximized. An event `events[i]` overlaps with `events[j]` if `startDay_i <= endDay_j` and `startDay_j <= endDay_i`. Return the maximum sum of values of the selected non-overlapping events.","solution":"def max_value_of_non_overlapping_events(events): from functools import lru_cache # Sort events by their end day (increasing order), and if end days are same, by their start day (increasing order) events.sort(key=lambda x: (x[1], x[0])) @lru_cache(None) def dp(index): if index == len(events): return 0 # Find next non-overlapping event next_index = index + 1 while next_index < len(events) and events[next_index][0] <= events[index][1]: next_index += 1 # Include or exclude the current event include_current = events[index][2] + dp(next_index) exclude_current = dp(index + 1) return max(include_current, exclude_current) return dp(0)"},{"question":"You are given an array `nums` consisting of positive integers, where each integer represents the cost of a hotel stay for one night. A traveler can choose to stay at any hotel but may not stay at adjacent hotels (i.e., no two consecutive elements in the array can be chosen). Write a function that determines the maximum cost the traveler can incur during their trip. Return the maximum total cost. For example, given `nums = [1, 2, 3, 1]`, the function should return `4` because the traveler can choose the hotels with costs `1` and `3` (total cost = 1 + 3 = 4), which is the maximum possible without staying at adjacent hotels.","solution":"def max_cost(nums): Returns the maximum total cost the traveler can incur without staying at adjacent hotels. if not nums: return 0 n = len(nums) if n == 1: return nums[0] prev1 = 0 prev2 = 0 for cost in nums: current = max(prev1, prev2 + cost) prev2 = prev1 prev1 = current return prev1"},{"question":"Given a matrix `grid` consisting of land (`1`) and water (`0`) cells, an island is a maximal group of `1`s connected in the four cardinal directions (vertical or horizontal). You may assume all four edges of the grid are surrounded by water. A closed island is one which is surrounded by water on all sides (including diagonally), except that the water on its border does not count. Return the number of closed islands in the grid. [Question 4]:","solution":"def closed_island(grid): Returns the number of closed islands in the given grid. An island is considered closed if it is surrounded by water on all sides. if not grid: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols: return False if grid[r][c] == 1: return True grid[r][c] = 1 # Mark as visited up = dfs(r - 1, c) down = dfs(r + 1, c) left = dfs(r, c - 1) right = dfs(r, c + 1) return up and down and left and right closed_islands = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 0: if dfs(i, j): closed_islands += 1 return closed_islands"},{"question":"You are given an unsorted integer array `arr` and a number `k`. Find the **k**th smallest element in the array. Note that it is the **k**th smallest element in the sorted order, not the **k**th distinct element. You must implement a solution with a linear time complexity on average. Return _the **k**th smallest element_ in the array `arr`.","solution":"import random def partition(arr, left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # Move all smaller elements to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quickselect(arr, left, right, k_smallest): Returns the k-th smallest element of list within left..right if left == right: # If the list contains only one element, return arr[left] # Return that element # Select a random pivot_index between pivot_index = random.randint(left, right) # Find the pivot position in a sorted list pivot_index = partition(arr, left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return arr[k_smallest] # go left elif k_smallest < pivot_index: return quickselect(arr, left, pivot_index - 1, k_smallest) # go right else: return quickselect(arr, pivot_index + 1, right, k_smallest) def find_kth_smallest(arr, k): return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"Given a **0-indexed** integer array `nums`, return the length of the **smallest subarray** such that the subarray contains at least one occurrence of the **most frequent** element in the whole array. If there are multiple subarrays with the same length, return the length of any of them.","solution":"def findShortestSubArray(nums): from collections import defaultdict # Element occurrence dictionary num_counts = defaultdict(int) # Dictionary to record the first occurrence index of each element first_occurrence = {} degree = 0 shortest_length = float(\'inf\') for i, num in enumerate(nums): if num not in first_occurrence: first_occurrence[num] = i num_counts[num] += 1 if num_counts[num] > degree: degree = num_counts[num] shortest_length = i - first_occurrence[num] + 1 elif num_counts[num] == degree: shortest_length = min(shortest_length, i - first_occurrence[num] + 1) return shortest_length"},{"question":"Given a list of `n` integers representing the heights of buildings, the goal is to determine the maximum area of a rectangle that can be formed within a histogram represented by the buildings\' heights. The width of each building is `1`. The heights of the buildings are given in an integer array `heights` of size `n`. Each `heights[i]` represents the height of the `i`th building. You need to return the maximum area of the rectangle that can be formed using consecutive buildings in the histogram.","solution":"def largest_rectangle_area(heights): Finds the maximum area of a rectangle that can be formed within a histogram represented by the buildings\' heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a string `s` and an integer `k`. You need to construct a new string by selecting `k` characters from `s` and rearranging them such that the new string is lexicographically smallest among all possible selections. Return _the lexicographically smallest string that can be constructed by selecting and rearranging `k` characters from `s`._ For example, if `s = \\"abacb\\"` and `k = 3`, the lexicographically smallest string you can construct by selecting and rearranging 3 characters from `s` is `\\"aab\\"`.","solution":"def lexicographically_smallest(s, k): Construct the lexicographically smallest string by selecting and rearranging k characters from s. :param s: string to select characters from :param k: number of characters to select and rearrange :return: lexicographically smallest string # Sort the characters of the string s_sorted = sorted(s) # Select the first k characters from the sorted list return \\"\\".join(s_sorted[:k])"},{"question":"There is a rectangular grid of size `m x n` (rows x columns) with each cell containing an integer. The person starts at the top-left corner (cell (0,0)) and needs to reach the bottom-right corner (cell (m-1, n-1)). You can only move either down or right at any point in time. Each time you move to a cell, you collect the integer value from that cell (including both the start and ending cells). You cannot step on any cell that contains a negative integer. Write a function that returns the maximum sum of the collected integers possible along any valid path from the top-left to the bottom-right corner. If no valid path exists, return -1.","solution":"def max_path_sum(grid): Returns the maximum sum of integers collected on a valid path from the top-left to the bottom-right corner in a grid where you can only move right or down and cannot step on any cell that contains a negative integer. :param grid: List[List[int]]: The m x n grid :return: int: The maximum sum of collected integers or -1 if no valid path exists m, n = len(grid), len(grid[0]) if grid[0][0] < 0 or grid[m-1][n-1] < 0: return -1 for i in range(m): for j in range(n): if grid[i][j] < 0: grid[i][j] = float(\'-inf\') else: if i == 0 and j == 0: continue if i == 0: # first row, can only come from the left grid[i][j] += grid[i][j-1] elif j == 0: # first column, can only come from above grid[i][j] += grid[i-1][j] else: grid[i][j] += max(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1] if grid[m-1][n-1] != float(\'-inf\') else -1"},{"question":"You are given a grid with `n` rows and `m` columns, represented as a 2D integer array `grid`. Each cell in the grid contains a non-negative integer which represents the cost to enter that cell. You start from the top-left cell (0, 0) and you need to reach the bottom-right cell (n-1, m-1). You can only move either down or right at any point in time. Write an algorithm to find the minimum cost path from the top-left to the bottom-right cell. Implement the function `int minPathSum(int[][] grid)` which takes a 2D integer array `grid` as the input and returns the minimum cost required to reach the bottom-right cell from the top-left cell.","solution":"def minPathSum(grid): Calculates the minimum path sum from top-left to bottom-right in a grid. You can only move either down or right at any point in time. Args: grid (List[List[int]]): 2D list of non-negative integers representing the cost grid Returns: int: Minimum cost to reach the bottom-right cell if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Initialize the cost for the first cell dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the cost for the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the cost for the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Compute the minimum paths for the inner cells for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"You are given an integer `n` representing the number of nodes in a graph labeled from `0` to `n-1`. You are also given a 2D integer array `edges` where `edges[i] = [node1, node2]` represents an undirected edge connecting two nodes in the graph. Write a function `maxConnectedComponents(n, edges)` that returns the size of the largest connected component in the graph. A connected component of a graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph.","solution":"def maxConnectedComponents(n, edges): from collections import defaultdict, deque def bfs(node, visited, graph): queue = deque([node]) visited.add(node) size = 1 while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) visited.add(neighbor) size += 1 return size graph = defaultdict(list) for edge in edges: graph[edge[0]].append(edge[1]) graph[edge[1]].append(edge[0]) visited = set() largest_component = 0 for node in range(n): if node not in visited: component_size = bfs(node, visited, graph) largest_component = max(largest_component, component_size) return largest_component"},{"question":"You are given an array of integers `arr` and an integer `s`, representing a desired sum. Your task is to find all unique **pairs** of integers in the array whose sum is equal to `s`. Each pair should be a tuple of two elements `(a, b)`, where `a < b`. Return _a sorted array of these unique pairs_. For example, if `arr` is `[1, 3, 2, 2, -1]` and `s` is `3`, the pairs `(1, 2)` and `(3, 0)` follow the requirements. Output a list of the pairs in each tuple sorted in ascending order. The pairs themselves should also be sorted in ascending order based on the first number of each pair.","solution":"def find_pairs_with_sum(arr, s): Returns a sorted list of unique pairs (a, b) from arr such that a + b = s and a < b. seen = set() unique_pairs = set() for num in arr: target = s - num if target in seen: pair = (min(num, target), max(num, target)) unique_pairs.add(pair) seen.add(num) return sorted(unique_pairs)"},{"question":"You are given a list of `operations` to be performed on a data structure supporting the following features: 1. `insert(k)`: Insert the integer `k` into the data structure. 2. `erase(k)`: Remove the integer `k` from the data structure if it exists. If `k` is not present, do nothing. 3. `get_max()`: Return the maximum value currently in the data structure. If the data structure is empty, return `-∞` (a large negative number). 4. `get_min()`: Return the minimum value currently in the data structure. If the data structure is empty, return `+∞` (a large positive number). Implement the class `DataStructure` with the following methods: - `void insert(int k)`: Inserts an integer `k`. - `void erase(int k)`: Erases an integer `k` if present. - `int get_max()`: Returns the current maximum value. - `int get_min()`: Returns the current minimum value. The `operations` are given as a list of strings where each string represents an operation in the format `\\"operation_name(argument)\\"`. For example, `\\"insert(5)\\"`, `\\"erase(3)\\"`, `\\"get_max()\\"`, `\\"get_min()\\"`. Your task is to process these operations and return a list of results of all `get_max()` and `get_min()` operations in the order they appear. **Custom Testing:** The test input is provided as a list of operation strings. You need to implement the `DataStructure` class and simulate the operations as described.","solution":"class DataStructure: def __init__(self): Initialize an empty data structure. self.data = [] def insert(self, k): Insert integer k into the data structure. self.data.append(k) self.data.sort() def erase(self, k): Remove integer k from the data structure if it exists. if k in self.data: self.data.remove(k) def get_max(self): Return the maximum value in the data structure. if self.data: return self.data[-1] return float(\'-inf\') def get_min(self): Return the minimum value in the data structure. if self.data: return self.data[0] return float(\'inf\') def process_operations(operations): ds = DataStructure() results = [] for operation in operations: if operation.startswith(\\"insert(\\"): value = int(operation[7:-1]) ds.insert(value) elif operation.startswith(\\"erase(\\"): value = int(operation[6:-1]) ds.erase(value) elif operation == \\"get_max()\\": results.append(ds.get_max()) elif operation == \\"get_min()\\": results.append(ds.get_min()) return results"},{"question":"Given two strings `s1` and `s2`, determine whether `s1` is a scrambled string of `s2`. To scramble strings, you can use the following technique: choose any non-leaf node and swap its two children. For example, given \\"great\\", if we choose the node as \'r\' and swap its children, it becomes \\"rgtae\\", which is one possible scrambled string of \\"great\\". A string\'s children can be further scrambled or not. Several rounds can be performed on each level, resulting in multiple possible scrambled strings. A string is considered a scrambled string of itself. Return `true` if `s1` is a scrambled string of `s2`, and `false` otherwise.","solution":"def is_scramble(s1, s2): Determine if s1 is a scrambled string of s2. if len(s1) != len(s2): return False if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False"},{"question":"You are given an array of strings `words` and a string `pattern`. You should return a list of strings from `words` that match the `pattern`. A word matches the pattern if there exists a permutation of letters such that transforming each letter in the pattern to the corresponding letter in the permutation results in the word. For example, given words `[\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"]` and pattern `\\"abb\\"`, return `[\\"mee\\",\\"aqq\\"]`. The word \\"mee\\" matches the pattern because there is a permutation `{a -> m, b -> e}`. Similarly, \\"aqq\\" matches the pattern with the permutation `{a -> a, b -> q}`. Note that if a word matches the pattern, all occurrences of the same letter should be transformed to the same letter in the permutation.","solution":"def find_and_replace_pattern(words, pattern): def match(word): if len(word) != len(pattern): return False p2w, w2p = {}, {} for p, w in zip(pattern, word): if p in p2w and p2w[p] != w: return False if w in w2p and w2p[w] != p: return False p2w[p] = w w2p[w] = p return True return [word for word in words if match(word)]"},{"question":"You are given a **0-indexed** integer array `nums` containing `n` positive integers where `n` is **even**. Your task is to partition the array into two subarrays `A` and `B` such that both subarrays are non-empty and their lengths are half of `n`. Return _the **minimum** possible absolute difference between the sum of elements in `A` and the sum of elements in `B`._ Note that if multiple partitions yield the same minimum absolute difference, you can return the result obtained from any such partition.","solution":"def min_diff_partition(nums): Returns the minimum possible absolute difference between the sum of elements in two equal length subarrays of nums. from itertools import combinations n = len(nums) half = n // 2 total_sum = sum(nums) possible_sums = set() # Generate all combinations of half length and store their sums for comb in combinations(nums, half): possible_sums.add(sum(comb)) min_diff = float(\'inf\') for s in possible_sums: # Calculate the difference between total_sum and 2 * s (sum of A and sum of B) min_diff = min(min_diff, abs(total_sum - 2 * s)) return min_diff"},{"question":"You are given an array of integers `nums` and an integer `k`. Return the maximum number of unique integers among all possible contiguous subarrays of length `k` in the array. Make sure your solution has a time complexity of O(n).","solution":"def max_unique_integers(nums, k): Returns the maximum number of unique integers among all possible contiguous subarrays of length k in the array. if k > len(nums): return len(set(nums)) from collections import Counter # Initial window window = Counter(nums[:k]) max_unique = len(window) for i in range(k, len(nums)): # Remove the element leaving the window leaving_elem = nums[i - k] window[leaving_elem] -= 1 if window[leaving_elem] == 0: del window[leaving_elem] # Add the new element entering the window new_elem = nums[i] window[new_elem] += 1 # Update the max_unique count max_unique = max(max_unique, len(window)) return max_unique"},{"question":"Given an integer array `arr` and an integer `k`, shift the entire array to the right by `k` steps, where `k` is non-negative. Implement a function that achieves this in-place with O(1) extra space complexity. For example, given `arr = [1,2,3,4,5,6,7]` and `k = 3`, the array should be modified to `[5,6,7,1,2,3,4]`.","solution":"def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 def rotate(arr, k): Rotates the array to the right by k steps in-place. n = len(arr) k = k % n # To handle cases where k > n reverse(arr, 0, n-1) reverse(arr, 0, k-1) reverse(arr, k, n-1)"},{"question":"You are given an array of `n` positive integers `arr` representing a queue, where each element represents the initial number of tasks assigned to a person. A person can complete one task in a fixed unit of time. Every unit of time, the person with the most tasks (or one of them, if there are ties) completes exactly one task. If there are more than one person with the maximum number of tasks, the one with the smallest index completes the task. Return an array representing the state of the queue after all tasks have been completed, where each element indicates the number of tasks remaining for each person in the queue. Example: If `arr` = [3, 2, 1, 4], after the execution, the array would be [0, 0, 0, 0] since all tasks will have been completed.","solution":"def complete_tasks(arr): Simulates the completion of tasks where each unit of time, the person with the most tasks (ties broken by smallest index) completes exactly one task until all tasks are completed. Args: arr (list of int): An array representing the initial number of tasks assigned to each person. Returns: list of int: An array representing the state of the queue after all tasks have been completed. # Copy the list to avoid modifying the input list task_queue = arr[:] while any(task_queue): # Find the person with the most tasks max_tasks = max(task_queue) # Find the leftmost person with the most tasks max_index = task_queue.index(max_tasks) # Complete one task for that person task_queue[max_index] -= 1 return task_queue"},{"question":"Given an integer array `weights` where `weights[i]` represents the weight of the `i-th` object, and an integer `maxLoad` representing the maximum load a single container can carry, you are to pack these objects into containers such that the number of containers used is minimized. Implement a function `int minContainers(int[] weights, int maxLoad)` that returns the minimum number of containers needed. Each container can only carry a total weight of at most `maxLoad`.","solution":"def min_containers(weights, maxLoad): Returns the minimum number of containers needed to carry all weights without exceeding the maxLoad per container. :param weights: List of integer weights :param maxLoad: Integer representing the maximum load per container :return: Integer representing the minimum number of containers needed weights.sort(reverse=True) containers = [] for weight in weights: placed = False for container in containers: if sum(container) + weight <= maxLoad: container.append(weight) placed = True break if not placed: containers.append([weight]) return len(containers)"},{"question":"Given an integer array `arr` of size `n` and an integer `k`, your task is to divide the array into `k` non-empty subarrays in such a way that the maximum sum of the elements in any subarray is minimized. Return the minimum possible value of that maximum sum.","solution":"def split_array_minimize_max_sum(arr, k): Divide an array into k non-empty subarrays such that the maximum sum of the elements in any subarray is minimized. Return the minimum possible value of that maximum sum. def can_split(maximum_sum): current_sum = 0 required_subarrays = 1 for num in arr: if current_sum + num > maximum_sum: required_subarrays += 1 current_sum = num if required_subarrays > k: return False else: current_sum += num return True low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if can_split(mid): high = mid else: low = mid + 1 return low"},{"question":"Given an array of integers `arr` and an integer `x`, return the maximum length of a contiguous subarray that sums to `x`. If there isn\'t one, return `0`.","solution":"def max_subarray_len(arr, x): Returns the maximum length of a contiguous subarray that sums to x. If there isn\'t one, returns 0. prefix_sum = {} cur_sum = 0 max_len = 0 for i in range(len(arr)): cur_sum += arr[i] if cur_sum == x: max_len = i + 1 if cur_sum - x in prefix_sum: max_len = max(max_len, i - prefix_sum[cur_sum - x]) if cur_sum not in prefix_sum: prefix_sum[cur_sum] = i return max_len"},{"question":"Given an array of integers `nums` where `nums[i]` represents the position of the `i-th` token on a number line, and an integer `target`, return `true` if you can arrange the tokens such that the distance between any two adjacent tokens is exactly `target`, or `false` otherwise. You can rearrange the tokens in any order but cannot change their values.","solution":"def can_rearrange_tokens(nums, target): Determine if tokens can be rearranged such that the distance between any two adjacent tokens is exactly `target`. Parameters: nums (list of int): List of token positions. target (int): Target distance between adjacent tokens. Returns: bool: True if tokens can be rearranged such that every two adjacent tokens have a distance of `target`, False otherwise. if len(nums) < 2: return True nums.sort() for i in range(1, len(nums)): if nums[i] - nums[i-1] != target: return False return True"},{"question":"Implement a function `longestUniqueSubstring(s)` that receives a string `s` and returns the length of the longest substring without repeating characters. For instance, given the input `s = \\"pwwkew\\"`, the output should be `3` because the longest substring without repeating characters is `\\"wke\\"`. Write an efficient solution with a linear time complexity.","solution":"def longestUniqueSubstring(s): Returns the length of the longest substring without repeating characters. :param s: String input :return: Length of the longest substring without repeating characters char_index = {} max_length = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"You are given a list of strings `words` and a string `prefix`. Implement a function `filterWordsByPrefix` that returns a list of strings from `words` that start with the given `prefix`. The function should preserve the original order of the strings in `words`. * `filterWordsByPrefix(List<String> words, String prefix)` Initializes with a list of words and a prefix string. * Example: * `words` = [\\"apple\\", \\"apricot\\", \\"banana\\", \\"avocado\\", \\"aardvark\\"] * `prefix` = \\"ap\\" * `filterWordsByPrefix(words, prefix)` should return [\\"apple\\", \\"apricot\\"].","solution":"def filterWordsByPrefix(words, prefix): Returns the list of strings from `words` that start with the given `prefix`. Parameters: words (list of str): List of words to be filtered. prefix (str): Prefix to filter words by. Returns: list of str: Filtered list of words starting with the prefix. return [word for word in words if word.startswith(prefix)]"},{"question":"Given a string `s`, determine if it can be made a palindrome by removing at most one character. A string is a palindrome if it reads the same forward and backward. Compose a function `canFormPalindrome(s)` that takes a string `s` as its parameter and returns a boolean value indicating whether it is possible to make the string a palindrome by removing at most one character.","solution":"def canFormPalindrome(s): Determines if a string can be made a palindrome by removing at most one character. def is_palindrome(st): return st == st[::-1] left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try by removing one character from either end return is_palindrome(s[left + 1:right + 1]) or is_palindrome(s[left:right]) left += 1 right -= 1 return True"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. You are allowed to replace at most `k` characters in the string with any other lowercase alphabet. Return the length of the longest contiguous substring containing only one unique character that can be achieved by performing at most `k` replacements.","solution":"def longest_substring_with_k_replacements(s, k): Returns the length of the longest contiguous substring containing only one unique character that can be achieved with at most k character replacements. max_length = 0 left = 0 counts = {} max_count = 0 for right in range(len(s)): char = s[right] if char in counts: counts[char] += 1 else: counts[char] = 1 max_count = max(max_count, counts[char]) while right - left + 1 - max_count > k: reduce_char = s[left] counts[reduce_char] -= 1 if counts[reduce_char] == 0: del counts[reduce_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a string `s` consisting of lowercase English letters. A duplication operation involves selecting a contiguous substring of `s` and appending it to the end of `s`. For example, if `s = \\"abcde\\"`, selecting substring `bc` and appending it results in `s = \\"abcdebc\\"`. Return the minimum number of duplication operations needed to make `s` a string where there is no substring that occurs more than once. **Note** that a single letter is considered as a valid substring that can be duplicated.","solution":"def min_duplication_operations(s: str) -> int: if not s: return 0 n = len(s) # Check if there are no duplicate substrings in the string def has_no_duplicates(s: str) -> bool: seen = set() for i in range(n): for j in range(i+1, n+1): substring = s[i:j] if substring in seen: return False seen.add(substring) return True # Since a single letter can always be duplicated, we always need at least len(s) operations # This is because to avoid duplication we need each letter to be something unique # therefore the lowest number of operations required is the length of the string return n"},{"question":"Given an integer array `arr`, returns the length of the longest subarray with elements that form a strictly increasing sequence. If no such subarray exists, return 0.","solution":"def longest_increasing_subarray(arr): Returns the length of the longest subarray with elements that form a strictly increasing sequence. if not arr: return 0 max_length = 0 current_length = 1 # The length of the current increasing subarray for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given an integer array `nums` and an integer `target`. You want to form a subarray from `nums` whose sum equals to the `target`. Return the length of the smallest such subarray. If no such subarray exists, return -1. A subarray is a contiguous part of an array.","solution":"def min_subarray_len(nums, target): Returns the length of the smallest subarray that adds up to the target. If no such subarray exists, return -1. n = len(nums) min_length = float(\'inf\') left = 0 sum_ = 0 for right in range(n): sum_ += nums[right] while sum_ >= target: min_length = min(min_length, right - left + 1) sum_ -= nums[left] left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":": Given an integer array `nums`, return _the maximum difference between the largest and smallest values in any contiguous subarray of_ `nums`. If the array contains fewer than 2 elements, return `0`.","solution":"def max_diff_in_contiguous_subarray(nums): if len(nums) < 2: return 0 max_diff = 0 for i in range(len(nums)): current_min = nums[i] current_max = nums[i] for j in range(i, len(nums)): current_min = min(current_min, nums[j]) current_max = max(current_max, nums[j]) max_diff = max(max_diff, current_max - current_min) return max_diff"},{"question":"You are given a **0-indexed** array `nums` of **positive** integers. Your task is to partition the array into **two contiguous subarrays**, such that the sum of the elements in one subarray is equal to the sum of the elements in the other subarray. Return _the **index** at which you can make the cut to achieve such a partition, or `-1` if no such index exists_.","solution":"def partition_index(nums): Returns the index at which the array nums can be partitioned into two contiguous subarrays with equal sums, or -1 if no such partition exists. total_sum = sum(nums) if total_sum % 2 != 0: return -1 left_sum = 0 for i in range(len(nums)): left_sum += nums[i] if left_sum * 2 == total_sum: return i + 1 return -1"},{"question":"Given a linked list, each node contains a single digit representing a non-negative integer. The digits are stored in **reverse order**, such that the 1\'s digit is at the head of the list. Write an algorithm to add two such numbers and return the resulting linked list in the same reverse order format. The input linked lists may contain extra leading zeros in the reversed order, which should be retained in the result.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 is not None or l2 is not None or carry != 0: val1 = l1.val if l1 is not None else 0 val2 = l2.val if l2 is not None else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next return dummy_head.next"},{"question":"Given a rectangular grid consisting of `n` rows and `m` columns, represented as a 2D array `grid`, where each cell contains a non-negative integer representing the cost to travel through that cell, return the minimum travel cost to journey from the top-left cell `(0, 0)` to the bottom-right cell `(n-1, m-1)`. You can only move to the right or down from a cell.","solution":"def min_travel_cost(grid): Returns the minimum travel cost to journey from the top-left to the bottom-right of the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"You are given a string `text` consisting of lowercase English letters and an integer `k`. Rearrange the string such that different characters are at least `k` distance from each other. If it is not possible to rearrange the string in such a way, return an empty string. If there are multiple possible rearrangements, return any of them.","solution":"from collections import Counter import heapq def rearrange_string(text, k): if k <= 1: return text # No need to rearrange counter = Counter(text) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) queue = [] result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((freq + 1, char)) # we use freq + 1 because freq is negative if len(queue) < k: continue # Prepare to push back an element if its k distance has passed front = queue.pop(0) if front[0] < 0: heapq.heappush(max_heap, front) return \'\'.join(result) if len(result) == len(text) else \'\'"},{"question":"You are given an integer array `numbers`. Find the index of the first **peak element** in the array if it exists. A **peak element** is an element that is strictly greater than its neighbors. For the elements at the boundaries of the array, only one neighboring element needs to be considered. Return the index of the first peak element. If there is no peak element, return `-1`.","solution":"def find_first_peak(numbers): Finds the index of the first peak element in the array. A peak element is an element that is strictly greater than its neighbors. For boundary elements, only one neighbor is considered. Parameters: numbers (list): List of integers. Returns: int: The index of the first peak element or -1 if no peak element is found. n = len(numbers) if n == 0: return -1 if n == 1 or numbers[0] > numbers[1]: return 0 if numbers[n-1] > numbers[n-2]: return n-1 for i in range(1, n-1): if numbers[i] > numbers[i-1] and numbers[i] > numbers[i+1]: return i return -1"},{"question":"You are given a list of integers `arr` representing the heights of different buildings and an integer `bricks` representing the amount of bricks you have. You can climb from building `i` to building `i+1` if `arr[i+1] <= arr[i]`. If `arr[i+1] > arr[i]`, you need `arr[i+1] - arr[i]` bricks to do so. Return _the maximum number of buildings you can climb using the given bricks_ starting from the first building.","solution":"def max_buildings_climbed(arr, bricks): Returns the maximum number of buildings that can be climbed using the given bricks. :param arr: List of integers representing heights of buildings. :param bricks: Integer representing the amount of bricks available. :return: Integer representing the maximum number of buildings that can be climbed. n = len(arr) if n == 0: return 0 bricks_used = 0 for i in range(n - 1): if arr[i + 1] > arr[i]: bricks_needed = arr[i + 1] - arr[i] if bricks_used + bricks_needed <= bricks: bricks_used += bricks_needed else: return i + 1 return n"},{"question":"Given an integer array `nums` of length `n`, return an array containing two integers `[num1, num2]` such that: * `0 <= num1 < num2 < n` * The absolute difference `abs(nums[num1] - nums[num2])` is the **maximum** amongst all pairs `(num1, num2)`. If there are multiple pairs with the same maximum difference, return the pair with the smaller `num1` value. If no such pair exists, return `[-1, -1]`.","solution":"def max_absolute_difference_pair(nums): Given an integer array nums of length n, return an array containing two integers [num1, num2] such that: * 0 <= num1 < num2 < n * The absolute difference abs(nums[num1] - nums[num2]) is the maximum amongst all pairs (num1, num2). If there are multiple pairs with the same maximum difference, return the pair with the smaller num1 value. If no such pair exists, return [-1, -1]. if len(nums) < 2: return [-1, -1] n = len(nums) num1, num2 = -1, -1 max_diff = -1 # A loop to go through each pair (i, j) where 0 <= i < j < n for i in range(n - 1): for j in range(i + 1, n): current_diff = abs(nums[i] - nums[j]) if current_diff > max_diff or (current_diff == max_diff and i < num1): num1, num2 = i, j max_diff = current_diff return [num1, num2]"},{"question":"Given a 2D grid of integers of size `m x n`, where each cell represents an elevation map where the integer represents the height of that cell, and the water can flow only to neighboring cells that are lower or equal in height. A cell is said to be connected to an ocean if it can reach either the left or bottom border of the grid, or the right or top border of the grid by flowing through neighboring cells. Return _a 2D list of coordinates representing all the cells where water can both flow to the Atlantic and Pacific ocean._","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) pacific_reachable = [[False] * cols for _ in range(rows)] atlantic_reachable = [[False] * cols for _ in range(rows)] def dfs(x, y, reachable): reachable[x][y] = True directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not reachable[nx][ny] and matrix[nx][ny] >= matrix[x][y]: dfs(nx, ny, reachable) for i in range(rows): dfs(i, 0, pacific_reachable) dfs(i, cols - 1, atlantic_reachable) for j in range(cols): dfs(0, j, pacific_reachable) dfs(rows - 1, j, atlantic_reachable) result = [] for i in range(rows): for j in range(cols): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"Given a **binary search tree (BST)**, write a function to find the **kth smallest element** in the BST. The BST is guaranteed to have at least `k` elements. Implement a solution that has an average time complexity of O(h + k), where `h` is the height of the tree. Return the _kth smallest element_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest element in the BST. def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) elements = inorder_traversal(root) return elements[k - 1]"},{"question":"Given a list of `tasks` where each task represents an integer and a positive integer `interval`, find the minimum number of units of time required to execute all the tasks. Each task must be executed one at a time, and two same tasks must have at least `interval` units of time between them. If the `tasks` list contains multiple instances of the same task, they should respect the interval. All other tasks can be executed in any order, and you can insert idle periods to maintain the interval constraint. Return the minimum time required to complete all tasks. Example: - Input: tasks = [\'A\', \'A\', \'A\', \'B\', \'B\', \'B\'], interval = 2 - Output: 8","solution":"from collections import Counter def task_scheduler(tasks, interval): Returns the minimum number of units of time required to execute all tasks while maintaining the given interval between same tasks. # Generate a frequency count of each task task_counts = Counter(tasks) # Identify the maximum frequency max_frequency = max(task_counts.values()) # Count how many tasks have the maximum frequency max_count = sum(1 for task, count in task_counts.items() if count == max_frequency) # Calculate the intervals intervals_without_last = (max_frequency - 1) * (interval + 1) total_intervals = intervals_without_last + max_count # Return the greater of the total_intervals or the length of tasks (whichever is higher) return max(total_intervals, len(tasks))"},{"question":"You are given a positive integer `n` representing the number of nodes in a **directed acyclic graph (DAG)**. The nodes are numbered from `0` to `n - 1`. You are also given a 2D integer array `edges`, where `edges[i] = [sourcei, targeti]` denotes that there is a directed edge from `sourcei` to `targeti` in the graph. Return _a list of all nodes with no incoming edges, which are the starting points for any path in the DAG. The returned list should be sorted in ascending order_.","solution":"def find_no_incoming_edges_nodes(n, edges): Returns a list of all nodes with no incoming edges in the given DAG. :param n: Number of nodes :param edges: List of edges in the DAG :return: Sorted list of nodes with no incoming edges incoming_count = [0] * n for edge in edges: source, target = edge incoming_count[target] += 1 no_incoming_nodes = [i for i in range(n) if incoming_count[i] == 0] return sorted(no_incoming_nodes)"},{"question":"Given a binary tree, implement a function `isBalanced(TreeNode root)` that determines if the tree is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Your task is to return `True` if the tree is balanced, and `False` otherwise. **Example:** - Given the following tree [3,9,20,null,null,15,7]: ``` 3 / 9 20 / 15 7 ``` - The function should return `True`. - Given the following tree [1,2,2,3,3,null,null,4,4]: ``` 1 / 2 2 / 3 3 / 4 4 ``` - The function should return `False`. _Note:_ Your algorithm should run in O(n) time complexity, where n is the number of nodes in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): Determines if the tree is height-balanced. :param TreeNode root: The root of the binary tree. :return: True if the tree is balanced, False otherwise. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) height = max(left_height, right_height) + 1 balanced = abs(left_height - right_height) <= 1 and left_balanced and right_balanced return height, balanced return check_balance(root)[1]"},{"question":"Given a class schedule with multiple courses, where each course has a start and end time, write a program to find the maximum number of courses a student can attend without overlapping. Implement the `CourseScheduler` class: * `CourseScheduler(int[][] courses)` initializes the object with a 2D array of courses where each course is represented as `[start, end]`. * `int maxCourses()` returns the maximum number of non-overlapping courses a student can attend. Example: ``` int[][] courses = {{1, 3}, {2, 4}, {3, 5}, {6, 7}}; CourseScheduler scheduler = new CourseScheduler(courses); int result = scheduler.maxCourses(); // Output should be 3, as the intervals {1,3}, {3,5}, {6,7} can be attended without overlap. ```","solution":"class CourseScheduler: def __init__(self, courses): Initializes the CourseScheduler with a list of courses. Each course is represented as a list [start, end]. self.courses = courses def maxCourses(self): Returns the maximum number of non-overlapping courses a student can attend. # Sort courses by their end time self.courses.sort(key=lambda x: x[1]) last_end_time = float(\'-inf\') count = 0 for start, end in self.courses: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"Given a list of integers where each element represents the maximum jump length from that position, determine _if you can reach the last index_, starting from the first index. Each jump length must be a non-negative integer.","solution":"def can_jump(nums): Determines if you can reach the last index of the list starting from the first index. :param nums: List of integers where each element represents maximum jump length from that position. :return: True if you can reach the last index, False otherwise. max_reach = 0 for i, num in enumerate(nums): if i > max_reach: return False max_reach = max(max_reach, i + num) return max_reach >= len(nums) - 1"},{"question":"You are given a list of `n` points represented as an array of coordinates `points` where `points[i] = [xi, yi]`. Write a function that returns the minimum cost to connect all points such that each point is connected to at least one other point. The cost to connect two points `[xi, yi]` and `[xj, yj]` is the Manhattan distance between them: |xi - xj| + |yi - yj|. You can implement any algorithm of your choice (e.g., Kruskal\'s or Prim\'s) to find the minimum spanning tree (MST) that connects all the given points. Return the minimum cost to make all points connected.","solution":"import heapq def min_cost_connect_points(points): Returns the minimum cost to connect all points such that each point is connected to at least one other point. The cost to connect two points is the Manhattan distance between them: |xi - xj| + |yi - yj|. def manhattan_distance(point1, point2): return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1]) n = len(points) min_heap = [(0, 0)] # (cost, point index) in_mst = [False] * n min_cost = 0 edges_used = 0 while edges_used < n: cost, i = heapq.heappop(min_heap) if in_mst[i]: continue in_mst[i] = True min_cost += cost edges_used += 1 for j in range(n): if not in_mst[j]: heapq.heappush(min_heap, (manhattan_distance(points[i], points[j]), j)) return min_cost"},{"question":"You are given two integer arrays `arr1` and `arr2` of the same length. Write a function to find the number of positions `i` where `arr1[i]` and `arr2[i]` are both even or both odd. Return the count of such positions.","solution":"def count_matching_even_odd_positions(arr1, arr2): Given two integer arrays arr1 and arr2 of the same length, the function returns the count of positions i where arr1[i] and arr2[i] are both even or both odd. count = 0 for a, b in zip(arr1, arr2): if (a % 2 == 0 and b % 2 == 0) or (a % 2 == 1 and b % 2 == 1): count += 1 return count"},{"question":"A grid is represented by a 2D integer array `grid` of size `m x n`, where each cell can be: - `0` representing an empty cell, - `1` representing a wall, or - `2` representing a teleporter. A robot starts at the top-left corner of the grid and aims to reach the bottom-right corner. The robot can move to adjacent cells in four possible directions: up, down, left, or right. Additionally, if the robot steps onto a teleporter (`2`), it can instantly move to any other cell with a teleporter (`2`). Return the minimum number of steps required for the robot to reach the bottom-right corner from the top-left corner. If it is impossible for the robot to reach the destination, return `-1`.","solution":"from collections import deque, defaultdict def min_steps_to_reach(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 teleports = defaultdict(list) for i in range(m): for j in range(n): if grid[i][j] == 2: teleports[(i, j)].append((i, j)) visited = set() q = deque([(0, 0, 0)]) # (x, y, steps) visited.add((0, 0)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while q: x, y, steps = q.popleft() if (x, y) == (m-1, n-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != 1: visited.add((nx, ny)) q.append((nx, ny, steps + 1)) if grid[nx][ny] == 2: for teleport in teleports: if teleport != (nx, ny) and teleport not in visited: visited.add(teleport) q.append((teleport[0], teleport[1], steps + 2)) return -1"},{"question":"Given an array of integers `nums`, write a function to return `true` if any value appears at least twice in the array, and return `false` if every element is distinct. The solution should have a time complexity of `O(n)` and use `O(n)` extra space.","solution":"def contains_duplicate(nums): Returns True if any value appears at least twice in the array, otherwise False. seen = set() for num in nums: if num in seen: return True seen.add(num) return False"},{"question":"You are given a string `s` representing a paragraph of text and an integer `k`. Return _the **k** most frequent words in the paragraph_ `s` _, sorted by their frequency in descending order. If multiple words have the same frequency, sort them alphabetically. Words are considered case insensitive._","solution":"from collections import Counter import re def k_most_frequent_words(s, k): Returns the k most frequent words in the paragraph s, sorted by their frequency in descending order. If multiple words have the same frequency, sort them alphabetically. Words are case insensitive. Parameters: s (str): The input string. k (int): The number of most frequent words to return. Returns: List[str]: The list of k most frequent words. # Make string lower case to handle case insensitivity s = s.lower() # Use regex to find words words = re.findall(r\'bw+b\', s) # Create a counter of words word_count = Counter(words) # Sort by frequency and then alphabetically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Extract the first k words return [word for word, count in sorted_words[:k]]"},{"question":"You are given a list of `n` strings, `words`, which contains strings of lowercase English letters and \\"/\\" characters. Each string represents a directory path. You need to evaluate the list of `words` and remove the subdirectories, keeping only the unique parent directories. A directory is a subdirectory if it begins with another directory followed by a \\"/\\". For example, in the directory structure: - \\"/a/b/c\\" - \\"/a/b/ca\\" - \\"/a/b/d\\" `\\"/a/b/c\\"` is a subdirectory of `\\"/a/b\\"`, and `\\"/a/b/d\\"` is a subdirectory of `\\"/a/b\\"`, but `\\"/a/b/ca\\"` is not a subdirectory of `\\"/a/b\\"`. Return the list of the unique parent directories sorted in lexicographic order. **Example:** Input: `[\\"/a\\",\\"/a/b\\",\\"/c/d\\",\\"/c/d/e\\",\\"/c/f\\"]` Output: `[\\"/a\\",\\"/c/d\\",\\"/c/f\\"]`","solution":"def remove_subdirectories(words): Removes subdirectories from the list and returns only unique parent directories sorted in lexicographic order. Args: words (List[str]): A list of directory paths. Returns: List[str]: A list of unique parent directories sorted in lexicographic order. words.sort() result = [] for word in words: if not result or not word.startswith(result[-1] + \'/\'): result.append(word) return result"},{"question":"You are working on a text editing application. The application supports multiple documents, each identified by a unique `documentId`. Each document consists of plain text content. You need to implement the `TextEditor` class with the following functionalities: * `TextEditor()` Initializes the text editor. * `int createDocument(String content)` Creates a new document with the given content and associates it with the smallest available integer `documentId` starting from `0`. Returns the `documentId` of the newly created document. * `void deleteDocument(int documentId)` If there is a document associated with `documentId`, deletes the document. * `String readDocument(int documentId, int startIndex, int endIndex)` If there is a document associated with `documentId`, returns the substring of the document\'s content starting at `startIndex` and ending at `min(endIndex, content.length() - 1)` (inclusive). If there is no document associated with `documentId`, returns `\\"-1\\"`. * `void appendContent(int documentId, String additionalContent)` If there is a document associated with `documentId`, appends the `additionalContent` to the document\'s current content. * `void editContent(int documentId, int startIndex, int endIndex, String newContent)` If there is a document associated with `documentId`, replaces the content between `startIndex` and `min(endIndex, content.length() - 1)` (inclusive) with `newContent`. If `startIndex` is greater than `endIndex`, does nothing. If there is no document associated with `documentId`, does nothing. * `int[] searchContent(String query)` Returns an **array of documentIds** where the given `query` string is found within their content. If the query is not found in any document, returns an empty array.","solution":"class TextEditor: def __init__(self): self.documents = {} self.next_document_id = 0 def createDocument(self, content): document_id = self.next_document_id self.documents[document_id] = content self.next_document_id += 1 return document_id def deleteDocument(self, documentId): if documentId in self.documents: del self.documents[documentId] def readDocument(self, documentId, startIndex, endIndex): if documentId in self.documents: content = self.documents[documentId] start = max(0, startIndex) end = min(endIndex, len(content) - 1) return content[start:end + 1] return \\"-1\\" def appendContent(self, documentId, additionalContent): if documentId in self.documents: self.documents[documentId] += additionalContent def editContent(self, documentId, startIndex, endIndex, newContent): if documentId in self.documents: content = self.documents[documentId] if startIndex <= endIndex: start = max(0, startIndex) end = min(endIndex, len(content) - 1) self.documents[documentId] = content[:start] + newContent + content[end + 1:] def searchContent(self, query): result = [] for documentId, content in self.documents.items(): if query in content: result.append(documentId) return result"},{"question":"You are provided with a list of non-negative integers representing an elevation map where the width of each bar is `1`. Write a function to compute how much water it is able to trap after raining. The elevation map is an array of integers where each element represents the elevation at that point. Rainwater will accumulate in the valleys formed between the bars, and the amount of accumulated water will be decided by the height of the shorter bar on either of the valley\'s sides. For example, given the elevation map `[0,1,0,2,1,0,1,3,2,1,2,1]`, your function should return `6` because the spaces at positions 2, 5, 6, 8, 9, and 11 can hold 1, 2, 1, 1, 1, and 0 units of water respectively, summing up to 6 units. Note: The bar at each index represents the height of the elevation at that point, and each unit width can either store `0` or more units of water depending on its height and the heights of the bars adjacent to it.","solution":"def trap(height): Given a list of non-negative integers representing an elevation map, compute how much water it can trap after raining. :param height: List[int] - A list of non-negative integers :return: int - The total amount of trapped rainwater if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given an **nth-order** polynomial represented by an array `coefficients` of length `n + 1`, where the `i-th` element of the array is the coefficient for the `x^i` term of the polynomial. Implement a function that takes this `coefficients` array and a value `x` as input, and returns the value of the polynomial evaluated at `x`. For instance, the array `[1, 0, -2, 3]` represents the polynomial `1 - 2x^2 + 3x^3`. If `x = 2`, the evaluated value would be `1 - 2*(2^2) + 3*(2^3) = 1 - 8 + 24 = 17`. Implement the function: ```python def evaluate_polynomial(coefficients: List[int], x: int) -> int: # Your code here ``` # Example: ```python coefficients = [1, 0, -2, 3] x = 2 print(evaluate_polynomial(coefficients, x)) # Output: 17 ```","solution":"def evaluate_polynomial(coefficients, x): Evaluates an nth-order polynomial at a given x. :param coefficients: List[int] - a list of coefficients for the polynomial where the i-th element is the coefficient for the x^i term. :param x: int - the value at which to evaluate the polynomial. :return: int - the result of the polynomial evaluation at x. n = len(coefficients) result = 0 for i in range(n): result += coefficients[i] * (x ** i) return result"},{"question":"A company wants to assign tasks to its employees. Each employee has a skill value represented by an integer, and each task requires a certain skill level to be completed. You are given an array of integers `employees`, where `employees[i]` represents the skill value of the i-th employee, and another array of integers `tasks`, where `tasks[j]` represents the skill level required for the j-th task. Each employee can complete at most one task, and each task can be assigned to at most one employee. However, an employee can only be assigned a task if their skill level is greater than or equal to the task’s required skill level. Return _the maximum number of tasks that can be assigned_.","solution":"def max_tasks(employees, tasks): Returns the maximum number of tasks that can be assigned to employees based on their skill levels. employees.sort() tasks.sort() employee_index = 0 task_index = 0 count = 0 while employee_index < len(employees) and task_index < len(tasks): if employees[employee_index] >= tasks[task_index]: count += 1 task_index += 1 employee_index += 1 return count"},{"question":"You are given an `n`-ary tree where each node has at most `n` children. Calculate the depth of the tree, which is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. You should write a function that takes the root of the `n`-ary tree and returns its depth. The tree is represented using a Node class, where each Node has a value and a list of children.","solution":"class Node: def __init__(self, value=None, children=None): self.value = value self.children = children if children else [] def get_tree_depth(root): Returns the depth of the n-ary tree. if not root: return 0 max_depth = 0 for child in root.children: max_depth = max(max_depth, get_tree_depth(child)) return max_depth + 1"},{"question":"You are given an array `arr` consisting of n integers. Your task is to implement a function `inversionCount(arr)` that returns the number of inversions in the array. An inversion is defined as a pair of indices `(i, j)` such that `i < j` and `arr[i] > arr[j]`. For example, for the array `[2, 4, 1, 3, 5]`, the function should return `3` because there are three inversions: `(2, 1)`, `(4, 1)`, and `(4, 3)`. Your solution should aim for a time complexity better than O(n^2).","solution":"def merge_and_count(arr, temp_arr, left, mid, right): Helper function to count inversions across subarrays and merge them. i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn\'t exceed mid and j doesn\'t exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all elements left to i in the left subarray # are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): Helper function that utilizes merge sort to count inversions. inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def inversionCount(arr): Function to count the number of inversions in the array. temp_arr = [0]*len(arr) return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)"},{"question":"Given an array of integers `arr` and an integer `target`, return the number of all possible combinations of elements in `arr` that sum up to the `target`. Each element in `arr` can be used as many times as needed. The order of elements in the combinations does not matter. The result may be large, so return it **modulo** `10^9 + 7`.","solution":"def combination_sum(arr, target): MOD = 10**9 + 7 dp = [0] * (target + 1) dp[0] = 1 # There is one way to make the sum 0 (by choosing nothing) for t in range(1, target + 1): for num in arr: if t >= num: dp[t] = (dp[t] + dp[t - num]) % MOD return dp[target]"},{"question":"You are given two strings `word1` and `word2`. You want to construct the longest string that can be formed by merging the two strings such that their relative ordering of characters is maintained. Return _the resulting longest string_ after merging. The resulting string should contain exactly the characters from `word1` and `word2` in the relative order they appear in `word1` and `word2`. If there are multiple solutions, return the lexicographically largest one.","solution":"def largestMerge(word1, word2): Returns the lexicographically largest merge of two strings while preserving their relative ordering. merge = [] i, j = 0, 0 while i < len(word1) and j < len(word2): if word1[i:] > word2[j:]: merge.append(word1[i]) i += 1 else: merge.append(word2[j]) j += 1 # One of them will be empty by the end of the loop merge.append(word1[i:]) merge.append(word2[j:]) return \'\'.join(merge)"},{"question":"You are given a binary tree where each node contains an integer value. A path in the binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear once in the sequence. Your task is to find the length of the longest path where each node in the path has a value that is one more than the previous node in the path. Return the length of this path. For example, in the binary tree: ``` 1 / 2 3 / / 3 2 4 5 ``` The longest consecutive increasing path is [3, 4, 5], so the function should return 3. If no such path exists, return 0.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_path(root): def dfs(node, parent_val, length): if not node: return length if node.val == parent_val + 1: length += 1 else: length = 1 left_length = dfs(node.left, node.val, length) right_length = dfs(node.right, node.val, length) return max(length, left_length, right_length) if not root: return 0 return dfs(root, root.val - 1, 0)"},{"question":"You are given an array of integers `arr` representing the elevation map where `arr[i]` is the elevation at index `i`. The width of each bar is `1`. Compute how much water it can trap after raining. For example, given heights `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the result would be `6`.","solution":"def trap(height): Calculate how much water it can trap after raining given an elevation map. :param height: List[int] representing the elevation at each index. :return: int representing the total units of trapped water. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"Given an integer `num`, return the sum of its digits until only a single digit remains. This is a process sometimes known as repeatedly computing the digital root. For example, if `num = 493193`, then the sequence of transformations would be `493193 ➝ 4 + 9 + 3 + 1 + 9 + 3 = 29 ➝ 2 + 9 = 11 ➝ 1 + 1 = 2`. The final result is `2`, so the function should return `2`.","solution":"def digital_root(num): Returns the digital root of the given number \'num\' by summing its digits repeatedly until only a single digit remains. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"Given an integer array `arr`, return the **length** of the **longest strictly increasing continuous subarray**. For example, if `arr = [1, 3, 5, 4, 7]`, the longest strictly increasing continuous subarray is `[1, 3, 5]` with a length of 3. If there are no increasing subarrays, return 0.","solution":"def longest_increasing_continuous_subarray(arr): Returns the length of the longest strictly increasing continuous subarray. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest strictly increasing continuous subarray. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Given an integer array `digits` representing a non-negative integer, subtract `1` from this integer. The digits are stored such that the most significant digit is at the head of the array, and each element in the array contains a single digit. Return _the resulting array of digits after subtracting `1`_.","solution":"def subtract_one(digits): Subtracts one from a non-negative integer represented as an array of digits. n = len(digits) # Starting from the end of the array for i in range(n-1, -1, -1): if digits[i] > 0: digits[i] -= 1 break else: digits[i] = 9 # Remove leading zero if any, except if the result is zero if digits[0] == 0 and n > 1: digits = digits[1:] return digits"},{"question":"Implement a `CircularQueue` class that simulates a circular queue using a fixed-size array. Your implementation should support the following operations: * `CircularQueue(int k)` Initializes the queue with capacity `k`. * `boolean enqueue(int value)` Inserts an element into the circular queue. Returns `true` if the operation is successful, `false` if the queue is full. * `boolean dequeue()` Removes an element from the circular queue. Returns `true` if the operation is successful, `false` if the queue is empty. * `int Front()` Retrieves the front item from the queue. Returns `-1` if the queue is empty. * `int Rear()` Retrieves the last item from the queue. Returns `-1` if the queue is empty. * `boolean isEmpty()` Checks whether the circular queue is empty. * `boolean isFull()` Checks whether the circular queue is full. The implementation of your `CircularQueue` should ensure that all operations run in `O(1)` time complexity.","solution":"class CircularQueue: def __init__(self, k: int): self.capacity = k self.queue = [None] * k self.head = -1 self.tail = -1 def enqueue(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.capacity self.queue[self.tail] = value return True def dequeue(self) -> bool: if self.isEmpty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.capacity return True def Front(self) -> int: if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: return self.head == -1 def isFull(self) -> bool: return (self.tail + 1) % self.capacity == self.head"},{"question":"Given a string `s` that consists of only digits, you can insert the \'*\' operator between any two digits of `s` to maximize the resulting value. Return the maximum possible value of the string by placing the \'*\' operator optimally. An empty string should return 0. You are guaranteed that the string does not have leading zeros. For example, given `s = \\"123\\"`, you can insert \'*\' to maximize the value: * \\"1 * 2 * 3\\" results in 6. Thus, the maximum possible value would be 6.","solution":"def maximize_value(s): Given a string s that consists of only digits, returns the maximum possible value of the string by placing the \'*\' operator optimally. Parameters: s (str): The input string consisting of only digits. Returns: int: The maximum possible value. if not s: return 0 result = int(s[0]) for i in range(1, len(s)): num = int(s[i]) result *= num return result"},{"question":"Below is the new question that aligns with the provided sample questions in terms of style, complexity, and scope: [Question 4]: Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation.","solution":"def word_break(s, wordDict): Given a string s and a dictionary of strings wordDict, this function adds spaces in s to construct all possible sentences where each word is a valid dictionary word. def backtrack(start): if start == len(s): return [[]] if start in memo: return memo[start] results = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in wordDict: for subsentence in backtrack(end): results.append([word] + subsentence) memo[start] = results return results memo = {} wordDict = set(wordDict) return [\\" \\".join(words) for words in backtrack(0)]"},{"question":"You are given an integer array `height` of length `n` representing the height of buildings in a row. Each building `i` is represented by a vertical line drawn from the point `(i, 0)` to `(i, height[i])`. The width of each building is `1`. A rainwater trapping system has just been installed, and the aim is to calculate the amount of rainwater trapped after raining. Implement a function that returns the total amount of rainwater trapped between these buildings. The function should take the array `height` as an argument and return an integer representing the total rainwater trapped.","solution":"def trap(height): Calculate the total amount of rainwater trapped. :param height: List[int] - List of building heights :return: int - Total amount of rainwater trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given a **directed graph** with `n` nodes and `m` edges, where each node has a unique value from `1` to `n`. The graph is represented by an array `edges`, where `edges[i] = [u, v]` indicates a directed edge from node `u` to node `v`. You are also given an integer `dest`, which represents the destination node, and an integer array `restricted` of unique values (excluding `dest`). Nodes listed in `restricted` are restricted, meaning you cannot visit them. Return _the number of distinct paths from node `1` to node `dest` that do not pass through any restricted nodes_. Each path should be counted only once, even if it has multiple routes to arrive at the destination.","solution":"def count_paths(n, edges, dest, restricted): from collections import defaultdict def dfs(node): if node == dest: return 1 visited.add(node) path_count = 0 for neighbor in graph[node]: if neighbor not in visited and neighbor not in restricted_set: path_count += dfs(neighbor) visited.remove(node) return path_count graph = defaultdict(list) for u, v in edges: graph[u].append(v) restricted_set = set(restricted) visited = set() return dfs(1)"},{"question":"Given a string `s` representing a valid IPv4 address, return `true` if `s` is a valid IPv4 address, or `false` otherwise. A valid IPv4 address consists of four numbers (each between 0-255) separated by dots, and cannot have leading zeros. For example, \\"192.168.1.1\\" and \\"172.16.254.1\\" are valid IPv4 addresses, but \\"256.256.256.256\\" and \\"192.168.1.01\\" are not.","solution":"def is_valid_ipv4_address(s): Returns True if s is a valid IPv4 address, False otherwise. A valid IPv4 address consists of four numbers (each between 0-255) separated by dots, and cannot have leading zeros. parts = s.split(\'.\') # IPv4 address must have exactly 4 parts if len(parts) != 4: return False for part in parts: # Each part must be a number and not empty if not part.isdigit(): return False # Convert part to an integer num = int(part) # Check if each number is between 0 and 255 (inclusive) if not (0 <= num <= 255): return False # Check for leading zeros (part[0] can\'t be \'0\' if part is more than one digit long) if part[0] == \'0\' and len(part) > 1: return False return True"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to determine if the tree is a **height-balanced** binary tree. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Return `true` if the binary tree is height-balanced, and `false` otherwise. A binary tree is represented using a nested dictionary where: - Each node is a dictionary containing the keys \\"value\\", \\"left\\", and \\"right\\". - The value of \\"value\\" is an integer, and \\"left\\" and \\"right\\" are either `null` (representing the absence of a subtree) or a dictionary representing the left and right subtrees, respectively. For example: ```python tree = { \\"value\\": 1, \\"left\\": { \\"value\\": 2, \\"left\\": { \\"value\\": 4, \\"left\\": None, \\"right\\": None }, \\"right\\": { \\"value\\": 5, \\"left\\": None, \\"right\\": None } }, \\"right\\": { \\"value\\": 3, \\"left\\": None, \\"right\\": None } } ``` In this example, the tree is balanced, so your function should return `true`.","solution":"def is_balanced(tree): Determine if a binary tree is height-balanced. :param tree: A nested dictionary representing the binary tree :return: True if the tree is height-balanced, False otherwise def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node[\'left\']) right_height, right_balanced = height_and_balance(node[\'right\']) current_height = max(left_height, right_height) + 1 current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced _, is_bal = height_and_balance(tree) return is_bal"},{"question":"Given two integer arrays `array1` and `array2`, return an array of their **intersection**. Each element in the result must be unique and you may return the result in **any order**. For example, if the two input arrays are `[1, 2, 2, 1]` and `[2, 2]`, the intersection would be `[2]`. If the arrays are `[4, 9, 5]` and `[9, 4, 9, 8, 4]`, the intersection would be `[9, 4]` or `[4, 9]`. Your algorithm should have a time complexity better than O(n * m), where n and m are the lengths of `array1` and `array2` respectively.","solution":"def intersection(array1, array2): Returns an array of the unique intersection elements between array1 and array2. set1 = set(array1) set2 = set(array2) return list(set1.intersection(set2))"},{"question":"You are given a string `s` and a list of strings `words`. Each word in `words` is a unique word that is formed by **concatenating** some suffix of `s` with some prefix of `s`. Return _the number of words in the list `words` that are a valid concatenation of a suffix and a prefix of the string `s`_. **Example:** ``` Input: s = \\"wordformation\\", words = [\\"formation\\", \\"ordwor\\", \\"wordword\\", \\"formationwor\\"] Output: 2 Explanation: The words \\"formation\\" and \\"formationwor\\" match the rule. \\"formation\\" is formed by concatenating the suffix \\"formation\\" and the prefix \\"\\" of the string. \\"formationwor\\" is formed by concatenating the suffix \\"formation\\" and the prefix \\"wor\\" of the string. ```","solution":"def count_valid_concatenations(s, words): Returns the number of words in the list `words` that are valid concatenations of a suffix and a prefix of the string `s`. concatenations = set() n = len(s) # Generate all valid concatenations of a suffix and a prefix for i in range(n + 1): suffix = s[i:] for j in range(n + 1): prefix = s[:j] concatenations.add(suffix + prefix) # Count how many words in `words` are in the set of valid concatenations count = 0 for word in words: if word in concatenations: count += 1 return count"},{"question":"You are given an undirected, weighted graph represented by an integer `n` (the number of vertices), a list of edges `edges`, where each edge is represented by a tuple `(u, v, w)` indicating an edge between vertices `u` and `v` with weight `w`, and an integer `src` representing the source vertex. Write a function to return the shortest paths from the source vertex to every other vertex in the graph. If a vertex is unreachable from the source vertex, denote its path length as `inf`. Return a list where the i-th element represents the shortest path from the source `src` to vertex `i`. Use Dijkstra\'s algorithm to solve this problem.","solution":"import heapq def dijkstra(n, edges, src): Implements Dijkstra\'s algorithm to find the shortest paths from source vertex to all other vertices. Parameters: n (int): The number of vertices edges (list of tuples): Each tuple (u, v, w) represents an edge from vertex u to vertex v with weight w src (int): The source vertex Returns: list: A list where the i-th element is the shortest path from the source to vertex i, or float(\'inf\') if unreachable. graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((w, v)) graph[v].append((w, u)) # Since the graph is undirected dist = [float(\'inf\')] * n dist[src] = 0 pq = [(0, src)] # (distance, node) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for weight, v in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist"},{"question":"You are given a matrix `grid` of integers where each integer represents a different elevation. You are also given an array `path` of integers where each integer represents a specific elevation. Your task is to verify if there exists a path in the grid that matches the given path of elevations. A valid path starts at any cell in the grid and proceeds to any of its four neighboring cells (horizontal or vertical) as long as the cell\'s elevation matches the next element in the path. Note that you can start from any cell and the path must follow the sequence in `path`. Return `true` if such a path exists in the grid, otherwise return `false`.","solution":"def is_path_exist(grid, path): def dfs(x, y, path_index): if path_index == len(path): return True if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != path[path_index]): return False temp, grid[x][y] = grid[x][y], None # mark the cell as visited found = (dfs(x + 1, y, path_index + 1) or dfs(x - 1, y, path_index + 1) or dfs(x, y + 1, path_index + 1) or dfs(x, y - 1, path_index + 1)) grid[x][y] = temp # unmark the cell return found for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == path[0] and dfs(i, j, 0): return True return False"},{"question":"Given a list of `n` non-negative integers representing the time each student would take to individually solve a problem, and an integer `k` representing the number of teams, your task is to divide the students into `k` non-empty teams such that the maximum time taken by the slowest team to solve the problem is minimized. Return the minimized maximum time.","solution":"def minimize_max_time(times, k): def can_divide_with_time_limit(max_time_limit): current_sum = 0 team_count = 1 for time in times: if current_sum + time <= max_time_limit: current_sum += time else: team_count += 1 current_sum = time if team_count > k: return False return True times.sort() low, high = max(times), sum(times) while low < high: mid = low + (high - low) // 2 if can_divide_with_time_limit(mid): high = mid else: low = mid + 1 return low"},{"question":"You are given a matrix `grid` of `m x n` size, where each cell contains an integer value, either `0`, `1`, or `2`. The cells represent: - `0` - an empty cell - `1` - a fresh apple - `2` - a rotten apple Every minute, any fresh apple that is adjacent (up, down, left, right) to a rotten apple will become rotten. Return _the minimum number of minutes that must elapse until no fresh apple remains. If this is not possible, return `-1`._","solution":"from collections import deque def min_minutes_to_rot_apples(grid): rows, cols = len(grid), len(grid[0]) fresh_apples = 0 queue = deque() # Initialize the queue with all already rotten apples and count fresh apples for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c, 0)) # (row, col, minutes) elif grid[r][c] == 1: fresh_apples += 1 # Directions for adjacents (up, down, left, right) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] minutes_elapsed = 0 while queue: r, c, minutes = queue.popleft() minutes_elapsed = max(minutes_elapsed, minutes) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: grid[nr][nc] = 2 fresh_apples -= 1 queue.append((nr, nc, minutes + 1)) return minutes_elapsed if fresh_apples == 0 else -1"},{"question":"You are given a list of integers `tasks` where `tasks[i]` represents the time required to complete the i-th task. Additionally, you are given an integer `k` which represents the number of workers available to complete these tasks. Each worker can only work on one task at a time, and a task cannot be split between workers. Write a function to determine the minimum amount of time required to complete all the tasks, assuming each worker can start working on a new task immediately after finishing the current task. Return the minimum time needed.","solution":"def min_time(tasks, k): Determine the minimum amount of time required to complete all tasks with k workers. if not tasks: return 0 # Binary search for the minimum possible maximum task sum per worker. left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 required_workers, current_sum = 1, 0 for task in tasks: if current_sum + task > mid: required_workers += 1 current_sum = 0 current_sum += task if required_workers > k: left = mid + 1 else: right = mid return left"},{"question":"Given an integer array `nums` representing the score of a player in multiple games, a score is regarded as **outstanding** if it is strictly greater than the median score of the entire list. Your task is to return a list of all outstanding scores from `nums` in ascending order. The median of a list of numbers is the middle element when the elements are sorted in ascending order. If the list contains an even number of elements, the median is the average of the two middle elements. For example, for an input array `nums = [5, 3, 8, 6, 7]`, the median is `6`, and the outstanding scores would be `[7, 8]`. Given a list of integers `nums`, return _a sorted list of outstanding scores_.","solution":"def find_outstanding_scores(nums): Returns a sorted list of scores that are strictly greater than the median score of nums. Args: nums (list of int): List of integer scores. Returns: list of int: Sorted list of outstanding scores. if not nums: return [] nums_sorted = sorted(nums) n = len(nums_sorted) if n % 2 == 1: median = nums_sorted[n // 2] else: median = (nums_sorted[n // 2 - 1] + nums_sorted[n // 2]) / 2 outstanding_scores = [score for score in nums_sorted if score > median] return outstanding_scores"},{"question":"Given an array of integers, where each integer appears exactly twice except for one integer which appears only once, find and return the integer that appears only once. Your solution should have a linear runtime complexity and use constant space.","solution":"def find_unique(arr): Finds the integer that appears exactly once in an array where all other integers appear exactly twice. Args: arr (list): List of integers where each integer appears exactly twice except one integer. Returns: int: The integer that appears exactly once. unique = 0 for num in arr: unique ^= num return unique"},{"question":"You are given a rectangular figure represented by an array of integers where each value represents the height of a building at that index position. In this scenario, it starts to rain and water begins falling on these buildings. Any water trapped between buildings will be held at the top of the shorter building up to the height of neighboring taller buildings. Calculate the total amount of water that will be trapped after it rains. Return the trapped water measured in units.","solution":"def trap_water(heights): Calculate the total amount of trapped water given the heights of buildings. :param heights: List[int] - heights of the buildings :return: int - total trapped water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate total trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"Implement a **Least Recently Used (LRU) Cache**. Your implementation should provide the following functionalities: - `LRUCache(int capacity)`: Initializes the LRU cache with a positive integer capacity. - `int get(int key)`: Returns the value of the `key` if the `key` exists in the cache. Otherwise, returns `-1`. - `void put(int key, int value)`: Updates the value of the `key` if the `key` exists. Otherwise, adds the `key-value` pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The cache should follow the **Least Recently Used** (LRU) policy, which removes the least recently used items first.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. You can perform at most one modification on `nums`, where you can increase or decrease any element by `1`. Return _the length of the longest continuous subarray such that the difference between the maximum and minimum element in this subarray is at most `k`_.","solution":"def longest_subarray(nums, k): from collections import deque max_deque = deque() min_deque = deque() left = 0 result = 0 for right in range(len(nums)): while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() result = max(result, right - left + 1) return result"},{"question":"You are given an integer array `nums` sorted in **non-decreasing** order. Your task is to determine whether there exists a number in the array that is equal to its **index value** (0-based). If such a number exists, return its index. If there are multiple such numbers, return the index of the first occurrence. If there is no such number, return `-1`. Find a solution with time complexity better than O(n).","solution":"def find_magic_index(nums): Returns the index of the number in the array nums which is equal to its index. If multiple such numbers exist, returns the index of the first occurrence. If no such number exists, returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == mid: return mid elif nums[mid] < mid: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Given a string `s`, you need to check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. For example, the string `\\"abab\\"` can be constructed by taking the substring `\\"ab\\"` and appending it twice. Similarly, the string `\\"abcabcabc\\"` can be constructed by taking the substring `\\"abc\\"` and appending it three times. Return `true` if the string matches the above condition, otherwise return `false`.","solution":"def repeatedSubstringPattern(s): Returns True if the string can be constructed by taking a substring of it and appending multiple copies of the substring together. if not s: return False n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"Given an integer array `nums` containing positive integers, return the maximum possible value of an element such that it is the sum of two elements from `nums`. You may use each element of `nums` at most once. For example: - Given `nums = [1, 2, 3, 4]`, the function should return `6` because `3 + 3 = 6` is the maximum sum available within the constraints. - Given `nums = [10, 20, 30, 40, 50]`, the function should return `90` because `40 + 50 = 90` is the highest achievable sum.","solution":"def maximum_sum_of_two(nums): Returns the maximum possible value of an element such that it is the sum of two elements from nums. if len(nums) < 2: return 0 # not enough elements to form a sum of two elements nums.sort() # The largest sum of two distinct elements will be the sum of the two largest elements return nums[-1] + nums[-2]"},{"question":"Given an integer array `nums` sorted in ascending order, convert it to a height-balanced binary search tree (BST). A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Return the root node of the height-balanced BST and ensure that the resulting tree meets the balance criteria. Only implement the method `sortedArrayToBST` in your solution.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(nums): Converts a sorted array to a height-balanced binary search tree. def helper(left, right): if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = helper(left, mid - 1) node.right = helper(mid + 1, right) return node return helper(0, len(nums) - 1)"},{"question":"You are implementing a text editor that supports the following operations: inserting a character, deleting the most recently inserted character, and retrieving the current text. Implement the `TextEditor` class with the following methods: - `TextEditor()` constructs a new text editor instance with initially empty content. - `insert(char c)` inserts the character `c` at the end of the current text. - `delete()` deletes the last character of the current text. If the text is empty, do nothing. - `getContent()` returns the current text in the editor as a string.","solution":"class TextEditor: def __init__(self): Constructs a new TextEditor instance with initially empty content. self.text = [] def insert(self, c): Inserts the character \'c\' at the end of the current text. self.text.append(c) def delete(self): Deletes the last character of the current text. If the text is empty, do nothing. if self.text: self.text.pop() def getContent(self): Returns the current text in the editor as a string. return \'\'.join(self.text)"},{"question":"You are given a 2D list `grid` of size `m x n` representing a maze where `1` represents walls and `0` represents open paths. Determine if there is a path from the top-left corner of the maze `(0, 0)` to the bottom-right corner `(m-1, n-1)`. You can only move up, down, left, or right. Return `true` if such a path exists, and `false` otherwise. Note that you cannot move into walls, and you must stay within the boundaries of the maze.","solution":"def is_path(grid): Determines if there is a path from the top-left to the bottom-right corner of the maze. Args: grid (list of list of int): The maze represented as a 2D list where 1 is a wall and 0 is an open path. Returns: bool: True if there is a path, False otherwise. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right def dfs(x, y): if x == m-1 and y == n-1: return True grid[x][y] = 1 # Mark as visited by setting to 1 (wall) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: if dfs(nx, ny): return True grid[x][y] = 0 # Unmark (backtrack) return False return dfs(0, 0)"},{"question":"You are given an array of integers `nums` and an integer `k`. A **k-pair** is a pair of elements (nums[i], nums[j]) such that `i < j` and `nums[j] - nums[i] == k`. Return the number of unique k-pairs in the array.","solution":"def find_k_pairs(nums, k): Returns the number of unique k-pairs in the array. A k-pair is defined as (nums[i], nums[j]) with i < j and nums[j] - nums[i] == k. count = 0 seen = set(nums) visited = set() for num in nums: if num not in visited: if num + k in seen: count += 1 if num - k in seen: count += 1 visited.add(num) # Divided by 2 since each pair (a, b) and (b, a) might be counted twice return count // 2"},{"question":"A company has multiple projects, each represented by an array of integers where each integer denotes the number of hours required to complete the corresponding task. Each employee can work a maximum number of hours `H` in a week. Given a list of projects `projs`, where each `projs[i]` is an array of task durations for project `i`, your task is to distribute the projects such that every employee only receives a number of tasks whose total duration does not exceed `H` hours intended for them to complete in a week. Return the minimum number of employees required to complete all projects under these constraints.","solution":"import math def min_employees_required(projs, H): Returns the minimum number of employees required to complete all projects under the given constraints. Parameters: projs (list of list of int): List of projects with each project being a list of task durations. H (int): Maximum number of hours an employee can work in a week. Returns: int: Minimum number of employees required. total_hours = sum(sum(proj) for proj in projs) num_employees = math.ceil(total_hours / H) return num_employees"},{"question":"You are managing a network of connected computers in which any computer can connect to any other computer directly or indirectly through other computers. You have a list of connections `(a, b)` where each connection connects two computers `a` and `b`. The goal is to determine the minimal number of connections that need to be added to ensure that every computer in the network is connected to every other computer. If all computers are already connected, return 0. Implement a function `minConnectionsToAdd(connections, n)` where `connections` is a list of tuples representing the direct connections between computers and `n` is the total number of computers in the network.","solution":"def minConnectionsToAdd(connections, n): Returns the minimal number of connections that need to be added to ensure that every computer in the network is connected to every other computer. :param connections: List of tuples (a, b) representing direct connections. :param n: Total number of computers in the network. :return: Minimum number of connections to be added. parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY for a, b in connections: union(a, b) components = len(set(find(i) for i in range(n))) return components - 1"},{"question":"You are given two arrays `arr1` and `arr2` each of length `n` consisting of positive integers. You are required to create a single sorted array from `arr1` and `arr2` containing all the elements from both arrays. However, you can only pick elements alternately from `arr1` and `arr2` start with any of the array. Return the **lexicographically smallest** possible array. In case of picking the same element from both arrays, prefer the element from `arr1`.","solution":"def merge_alternately_lexicographically(arr1, arr2): Merges two arrays alternately to form the lexicographically smallest array. Parameters: arr1 (list of int): The first input array. arr2 (list of int): The second input array. Returns: list of int: The lexicographically smallest possible merged array. n = len(arr1) idx1, idx2 = 0, 0 result = [] while idx1 < n and idx2 < n: if arr1[idx1] < arr2[idx2]: result.append(arr1[idx1]) idx1 += 1 elif arr2[idx2] < arr1[idx1]: result.append(arr2[idx2]) idx2 += 1 else: result.append(arr1[idx1]) idx1 += 1 while idx1 < n: result.append(arr1[idx1]) idx1 += 1 while idx2 < n: result.append(arr2[idx2]) idx2 += 1 return result"},{"question":"You are given a matrix `mat` of integers with dimensions `m x n`. Each cell in the matrix contains either a 0 or a 1. A cell is called “reachable” if it has a path on row or column comprised entirely of 1s that connects it to any edge of the matrix. Return _the number of “reachable” cells in the matrix._","solution":"def is_reachable(mat, i, j, m, n): # Check if cell mat[i][j] is reachable by moving horizontally or vertically to the matrix edge for c in range(n): if mat[i][c] == 1 and any(mat[i][k] == 1 for k in range(c+1)): return True for r in range(m): if mat[r][j] == 1 and any(mat[k][j] == 1 for k in range(r+1)): return True return False def count_reachable_cells(mat): m, n = len(mat), len(mat[0]) count = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and is_reachable(mat, i, j, m, n): count += 1 return count"},{"question":"Given an array of integers `arr` and an integer `k`, return _the maximum average of any subarray of length `k` or more_. The subarray must have at least `k` consecutive elements, and you need to select the subarray which maximizes this average. For example, for the array `[1, 12, -5, -6, 50, 3]` and `k = 4`, the subarray that provides the maximum average is `[12, -5, -6, 50]`, where the average is `12.75`.","solution":"def max_average_subarray(arr, k): Returns the maximum average of any subarray of length k or more. :param arr: List[int] - the input array of integers. :param k: int - the minimum length of subarray. :return: float - the maximum average value. n = len(arr) max_avg = float(\'-inf\') # Calculate the prefix sum array prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] for i in range(n - k + 1): for j in range(i + k, n + 1): subarray_sum = prefix_sums[j] - prefix_sums[i] subarray_len = j - i max_avg = max(max_avg, subarray_sum / subarray_len) return max_avg"},{"question":"Given a matrix of size `n x m` filled with integers, your task is to find a submatrix such that the sum of the elements in the submatrix is divisible by `k`. A submatrix is formed by choosing two rows `r1` and `r2` (1 ≤ r1 ≤ r2 ≤ n) and two columns `c1` and `c2` (1 ≤ c1 ≤ c2 ≤ m), and consists of all elements matrix[i][j] for r1 ≤ i ≤ r2 and c1 ≤ j ≤ c2. Return the maximum sum of such a submatrix. If there is no such submatrix, return 0.","solution":"def maxSubmatrixSumDivisibleByK(matrix, k): Returns the maximum sum of submatrix such that the sum is divisible by k. If there is no such submatrix, returns 0. n = len(matrix) m = len(matrix[0]) if n > 0 else 0 # Function to calculate prefix sums for the matrix def calculate_prefix_sums(matrix): prefix_sums = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n): for j in range(m): prefix_sums[i + 1][j + 1] = (matrix[i][j] + prefix_sums[i + 1][j] + prefix_sums[i][j + 1] - prefix_sums[i][j]) return prefix_sums # Get prefix sums prefix_sums = calculate_prefix_sums(matrix) max_sum = float(\'-inf\') # Iterate over all possible submatrices for r1 in range(1, n + 1): for r2 in range(r1, n + 1): for c1 in range(1, m + 1): for c2 in range(c1, m + 1): submatrix_sum = (prefix_sums[r2][c2] - prefix_sums[r2][c1 - 1] - prefix_sums[r1 - 1][c2] + prefix_sums[r1 - 1][c1 - 1]) if submatrix_sum % k == 0: max_sum = max(max_sum, submatrix_sum) return max_sum if max_sum != float(\'-inf\') else 0 # Example Usage: # matrix = [[1, 2, 3], # [4, 5, 6], # [7, 8, 9]] # k = 3 # print(maxSubmatrixSumDivisibleByK(matrix, k)) # Output should be a maximum sum submatrix divisible by 3"},{"question":"You are given an integer array `height` of length `n`, where each value represents the height of a building. The building heights are provided between **0** and **10,000** inclusive. You are tasked with finding the maximum amount of rainwater that can be trapped between the buildings after it rains. The water is trapped between buildings based on their height, and the width of the buildings is considered to be 1. Calculate and return the maximum amount of rainwater trapped.","solution":"def trap(height): This function computes the maximum amount of rainwater that can be trapped between the buildings. :param height: List[int] :return: int if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given an array of integers `nums`, return the **longest contiguous subarray** that contains only unique elements. If there are multiple such subarrays, return the one that occurs first. For example: - Given `nums = [1, 2, 3, 1, 2, 3, 4, 5]`, the function should return `[1, 2, 3, 4, 5]`. - Given `nums = [5, 5, 5, 5, 5]`, the function should return `[5]`.","solution":"def longest_unique_subarray(nums): Returns the longest contiguous subarray with unique elements. If there are multiple such subarrays, returns the one that occurs first. n = len(nums) if n == 0: return [] max_length = 0 longest_subarray_start = 0 current_subarray_start = 0 element_index_map = {} for i in range(n): if nums[i] in element_index_map and element_index_map[nums[i]] >= current_subarray_start: current_subarray_start = element_index_map[nums[i]] + 1 element_index_map[nums[i]] = i current_length = i - current_subarray_start + 1 if current_length > max_length: max_length = current_length longest_subarray_start = current_subarray_start return nums[longest_subarray_start:longest_subarray_start + max_length]"},{"question":"You are given a string `s` consisting only of letters \'a\' and \'b\'. In one move, you can swap any two characters in the string. Your goal is to make the string a palindrome by swapping the minimum number of pairs of characters. Return _an integer_ representing the minimum number of swaps required to make the string a palindrome. If it is impossible to form a palindrome, return `-1`.","solution":"def min_swaps_to_make_palindrome(s): Returns the minimum number of swaps required to make the string a palindrome. If it is impossible to form a palindrome, returns -1. if not can_form_palindrome(s): return -1 s = list(s) n = len(s) swaps = 0 for i in range(n // 2): left = i right = n - left - 1 while left < right: if s[left] == s[right]: break else: right -= 1 if left == right: s[left], s[left + 1] = s[left + 1], s[left] swaps += 1 right = n - left - 1 for j in range(right, n - left - 1): s[j], s[j + 1] = s[j + 1], s[j] swaps += 1 return swaps def can_form_palindrome(s): Helper function to determine if it is possible to rearrange the string to form a palindrome. from collections import Counter freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) return odd_count <= 1"},{"question":"Implement a system to manage a library of digital books. The system should allow users to **add** new books, **borrow** books, **return** books, and **retrieve** a list of available books. Users can also **rate** books, and the system should be able to provide an **average rating** for any book. Implement the `Library` class: * `Library()` Initializes the object. * `int addBook(String title, String author)` Adds a new book with the given `title` and `author` to the library. The return value is the ID of the book which starts at `1` and is sequentially increasing. * `boolean borrowBook(int userId, int bookId)` Borrows the book with the ID `bookId` for the user with the ID `userId`. Return `true` if the book was successfully borrowed, or `false` if the book is already borrowed. * `void returnBook(int userId, int bookId)` Returns the book with the ID `bookId` to the library only if the user with the ID `userId` has borrowed the book. * `List getAvailableBooks()` Returns a list of all the books that are currently available to borrow, in the order they were added to the library. * `void rateBook(int bookId, int rating)` Rates the book with the ID `bookId` with a score from `1` to `5` only if the book exists and the rating is within the valid range. * `double getAverageRating(int bookId)` Returns the average rating of the book with the ID `bookId`. Return `0.0` if the book has no ratings.","solution":"class Library: def __init__(self): self.books = {} self.book_counter = 1 self.borrowed_books = {} self.ratings = {} self.book_users = {} def addBook(self, title, author): book_id = self.book_counter self.books[book_id] = {\\"title\\": title, \\"author\\": author, \\"borrowed\\": False} self.book_counter += 1 return book_id def borrowBook(self, userId, bookId): if bookId in self.books and not self.books[bookId][\\"borrowed\\"]: self.books[bookId][\\"borrowed\\"] = True self.borrowed_books[bookId] = userId return True return False def returnBook(self, userId, bookId): if bookId in self.borrowed_books and self.borrowed_books[bookId] == userId: self.books[bookId][\\"borrowed\\"] = False del self.borrowed_books[bookId] def getAvailableBooks(self): return [ {\\"id\\": book_id, \\"title\\": book[\\"title\\"], \\"author\\": book[\\"author\\"]} for book_id, book in self.books.items() if not book[\\"borrowed\\"] ] def rateBook(self, bookId, rating): if bookId in self.books and 1 <= rating <= 5: if bookId not in self.ratings: self.ratings[bookId] = [] self.ratings[bookId].append(rating) def getAverageRating(self, bookId): if bookId in self.ratings and self.ratings[bookId]: return sum(self.ratings[bookId]) / len(self.ratings[bookId]) return 0.0"},{"question":"Given an integer array `arr`, partition the array into as few subarrays as possible so that each subarray contains an equal number of distinct integers. Return the minimum number of subarrays needed. For example, given `arr = [1, 2, 3, 1, 2, 3, 4]`, the result would be `2` as we can partition into `[1, 2, 3, 1, 2, 3]` and `[4]`. Each original integer from 1 to 4 appears in either the first or second subarray.","solution":"def min_subarrays_with_equal_distinct(arr): Returns the minimum number of subarrays needed so that each subarray contains an equal number of distinct integers. from collections import Counter # Count the frequency of each element in the array freq = Counter(arr) # The maximum frequency of any element is the number of required subarrays return max(freq.values())"},{"question":"You are given a string `s` and a string `t`. Your task is to determine if `s` can be converted to `t` using an anagram modification operation any number of times. You can pick any two **adjacent** characters in `s` and swap them. Determine whether it is possible to make `s` an anagram of `t` by performing any number of swaps. If it is possible, return `true`; otherwise, return `false`.","solution":"def is_anagram_possible(s, t): Determine if one string can be converted to another by swapping adjacent characters any number of times. :param s: String to be converted :param t: Target string :return: Boolean value indicating if s can be converted to t if sorted(s) == sorted(t): return True return False"},{"question":"You are given an integer `n` representing the total number of people standing in a line and an integer array `heights` of size `n` where `heights[i]` is the height of the `i-th` person in line. A person `i` can see the person `j` standing in front of them if every person between `i` and `j` (exclusive) is shorter than `heights[i]` and `j` is closer to `n-1` than `i`. Return _the number of people who can see at least one person standing in front of them._","solution":"def can_see_in_front(heights): n = len(heights) count = 0 for i in range(n): for j in range(i + 1, n): if heights[j] >= heights[i]: break else: count += 1 return n - count"},{"question":"A delivery service company needs to organize its fleet of delivery vehicles efficiently. Each vehicle can deliver a certain number of packages each hour. You are given an array `deliveryRates` where `deliveryRates[i]` is the number of packages the `ith` vehicle can deliver per hour. You are also given an array `packages`, where `packages[i]` is the number of packages that need to be delivered in the `ith` area. Your goal is to minimize the number of hours required to deliver all packages in all areas, using the available vehicles. A vehicle can only deliver to one area at a time, and once it starts delivering packages to an area, it must complete all deliveries for that area before moving to the next. Return the minimum number of hours needed to complete all deliveries. If it is not possible to deliver all packages, return `-1`.","solution":"def min_delivery_hours(deliveryRates, packages): Returns the minimum number of hours required to deliver all packages in all areas using the available delivery rates of vehicles, or -1 if it is not possible. deliveryRates.sort(reverse=True) # Sort rates in descending order packages.sort(reverse=True) # Sort packages in descending order if len(packages) > len(deliveryRates): return -1 # Not enough vehicles to handle all areas total_hours = 0 for i in range(len(packages)): rate = deliveryRates[i] pckg = packages[i] hours_for_area = (pckg + rate - 1) // rate # Ceil(pckg / rate) total_hours = max(total_hours, hours_for_area) return total_hours"},{"question":"Given a list of integers `nums` and an integer target value `k`, return the number of unique pairs `[num1, num2]` in `nums` such that `num1 + num2 = k`. Two pairs `[num1, num2]` and `[num3, num4]` are considered unique if and only if the multisets of the elements are different, i.e., either `num1 != num3` or `num2 != num4`.","solution":"def count_unique_pairs(nums, k): Returns the number of unique pairs [num1, num2] in nums such that num1 + num2 = k. A pair is considered unique if the elements are different. :param nums: List of integers :param k: Integer target value :return: Number of unique pairs seen = set() pairs = set() for num in nums: complement = k - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return len(pairs)"},{"question":"You are given a string `s` that consists of only digits. Your task is to count the number of ways the string can be partitioned into valid phone numbers. A valid phone number is defined as a contiguous subsequence of exactly 10 digits (a common format for phone numbers). Your function should return the count of all possible valid partitions of the string `s`. Note that overlapping partitions should also be counted. For example, given the input string \\"01234567890123456789\\", there are 11 possible valid partitions, as each set of 10 digits is counted independently. Return an integer representing the number of valid phone numbers partitions.","solution":"def count_phone_numbers(s): Count the number of valid phone number partitions in the string `s`. A valid phone number is defined as a contiguous subsequence of exactly 10 digits. :param s: str, a string consisting of only digits :return: int, the count of all possible valid phone number partitions # A valid phone number has 10 digits phone_number_length = 10 # The number of valid phone numbers in s return max(0, len(s) - phone_number_length + 1)"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. An element of the array is called **a peak** if it is greater than its neighbors. More formally, an element `arr[i]` is a **peak** if `arr[i] > arr[i - 1]` and `arr[i] > arr[i + 1]`. The array is **not** guaranteed to have peaks. Your task is to find **k distinct peak positions** in the array. If there are multiple valid peak positions, you can return any of them. If there are fewer than `k` peak positions, return all the peak positions. Return an array of length at most `k` containing the indices of the selected peak positions in **ascending order**. If there are no peaks, return an empty array. [Note]: Peaks at the ends of the array have only one neighbor to consider: `arr[0]` is a peak if `arr[0] > arr[1]`, and `arr[n-1]` is a peak if `arr[n-1] > arr[n-2]`.","solution":"def find_k_peaks(arr, k): Finds up to k peak positions in the array `arr`. Parameters: - arr: List[int] : The input array of integers - k: int : The number of peak positions to find Returns: - List[int] : A list of at most k peak indices, in ascending order n = len(arr) if n == 0: return [] peaks = [] # Check if the first element is a peak if n > 1 and arr[0] > arr[1]: peaks.append(0) # Check for peaks in the middle of the array for i in range(1, n - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peaks.append(i) # Check if the last element is a peak if n > 1 and arr[n - 1] > arr[n - 2]: peaks.append(n - 1) # Return up to k peaks return peaks[:k]"},{"question":"A city\'s road network is represented as an undirected graph with `n` intersections and `m` roads. Each road has a **positive integer weight** representing the travel time between the two intersections it connects. Given the integer `n`, an array `edges` where each element represents a road with three values `[u, v, w]` (which denotes a road between intersections `u` and `v` with travel time `w`), and two integers `a` and `b` representing the starting and ending intersections respectively, find the **shortest travel time** from intersection `a` to intersection `b`. Return the _**minimum travel time**_ if a path exists, or `-1` if there is no path from `a` to `b`.","solution":"import heapq def shortest_travel_time(n, edges, a, b): Returns the shortest travel time from intersection a to intersection b. :param n: Integer, number of intersections. :param edges: List of lists, each containing three integers [u, v, w] representing a road between intersections u and v with travel time w. :param a: Integer, starting intersection. :param b: Integer, ending intersection. :return: Integer, minimum travel time if a path exists, or -1 if no path exists. graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) min_heap = [(0, a)] # (cost, node) min_time = {i: float(\'inf\') for i in range(n)} min_time[a] = 0 while min_heap: curr_time, u = heapq.heappop(min_heap) if u == b: return curr_time if curr_time > min_time[u]: continue for v, weight in graph[u]: time = curr_time + weight if time < min_time[v]: min_time[v] = time heapq.heappush(min_heap, (time, v)) return -1 if min_time[b] == float(\'inf\') else min_time[b]"},{"question":"Implement a class `MaxStack` that supports the following operations: * `void push(int x)` - Pushes an element x onto the stack. * `int pop()` - Removes and returns the element on the top of the stack. * `int top()` - Returns the element on the top of the stack without removing it. * `int peekMax()` - Returns the maximum element in the stack without removing it. * `int popMax()` - Removes and returns the maximum element in the stack. If there is more than one maximum element, only remove the one that was pushed most recently. Your implementation should support these operations in an efficient manner. Do not use the built-in MaxHeap or PriorityQueue data structures for this problem.","solution":"class MaxStack: def __init__(self): self.stack = [] self.maxStack = [] def push(self, x): self.stack.append(x) if not self.maxStack or x >= self.maxStack[-1]: self.maxStack.append(x) def pop(self): if self.stack: popped_value = self.stack.pop() if popped_value == self.maxStack[-1]: self.maxStack.pop() return popped_value def top(self): if self.stack: return self.stack[-1] def peekMax(self): if self.maxStack: return self.maxStack[-1] def popMax(self): if self.maxStack: max_value = self.maxStack[-1] buffer = [] while self.stack[-1] != max_value: buffer.append(self.stack.pop()) self.stack.pop() self.maxStack.pop() while buffer: self.push(buffer.pop()) return max_value"},{"question":"Your task is to implement a `StringManipulator` class that supports the following operations on a string: 1. **Reverse the string** - Reverses the entire string. 2. **Rotate Left** - Rotates the string to the left by `k` characters. 3. **Rotate Right** - Rotates the string to the right by `k` characters. 4. **Capitalize** - Converts all letters in the string to uppercase. Define the class with the methods `reverse()`, `rotate_left(k)`, `rotate_right(k)`, and `capitalize()`. You are required to keep track of the string\'s current state after each operation, and subsequent operations should work on the updated string. The initial string will be provided at the time of object creation. For example, given the string \\"example\\" and the operations `reverse()`, `rotate_left(2)`, and `capitalize()`, the subsequent states of the string should be \\"elpmaxe\\", \\"pmaxeel\\", and \\"PMAXEEL\\", respectively.","solution":"class StringManipulator: def __init__(self, initial_string): self.string = initial_string def reverse(self): self.string = self.string[::-1] def rotate_left(self, k): k = k % len(self.string) # Handle rotation greater than the length of the string self.string = self.string[k:] + self.string[:k] def rotate_right(self, k): k = k % len(self.string) # Handle rotation greater than the length of the string self.string = self.string[-k:] + self.string[:-k] def capitalize(self): self.string = self.string.upper()"},{"question":"Given a string `s` consisting only of characters `\'a\'`, `\'b\'`, and `\'c\'`, you are allowed to choose any two characters and replace all occurrences of one character with the other. Return the minimum number of operations required to make the string consist of only one distinct character. An operation is defined as choosing a character and replacing it with another character.","solution":"def min_operations_to_uniform_string(s): Return the minimum number of operations required to make the string consist of only one distinct character. Args: s (str): A string consisting only of characters \'a\', \'b\', and \'c\'. Returns: int: Minimum number of operations. # Count the frequency of each character in the string count_a = s.count(\'a\') count_b = s.count(\'b\') count_c = s.count(\'c\') # The minimum operations needed will be the length of the string minus # the maximum count of any single character max_count = max(count_a, count_b, count_c) return len(s) - max_count"},{"question":"There are `n` bulbs arranged in a row, numbered from `1` to `n`. Initially, all the bulbs are turned off. Each bulb can be either turned on or off by toggling its state. An operation is defined as toggling every `i-th` bulb (where `i` is a multiple of the step count `k`). Given the integers `n` and `k`, determine _the number of bulbs that are on after all such operations are performed exactly once_.","solution":"def bulbs_on(n, k): Returns the number of bulbs that are on after toggling every k-th bulb of n bulbs. bulbs = [False] * n # Initialize all bulbs to off (False) for i in range(k - 1, n, k): # Toggle every k-th bulb, index starts from k-1 bulbs[i] = not bulbs[i] # Toggle the bulb return sum(bulb for bulb in bulbs if bulb) # Count the number of bulbs that are on"},{"question":"You are given a linked list where each node contains a unique integer value. Implement a function to reorder the list such that all nodes with even values are positioned after the nodes with odd values. Maintain the relative order of the even and odd nodes. Define the structure of a node and ensure that your implementation handles lists with varying numbers of nodes, including zero, one, or multiple nodes. Return the reordered linked list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reorder_even_after_odd(head: ListNode) -> ListNode: if not head or not head.next: return head odd_dummy = ListNode(0) even_dummy = ListNode(0) odd_tail, even_tail = odd_dummy, even_dummy current = head while current: if current.value % 2 == 0: even_tail.next = current even_tail = even_tail.next else: odd_tail.next = current odd_tail = odd_tail.next current = current.next even_tail.next = None # end the even list odd_tail.next = even_dummy.next # append even list after odd list return odd_dummy.next"},{"question":"You are given an array `arr` and an integer `target`. You need to find the minimum number of elements you need to remove from `arr` so that the sum of the remaining elements is exactly equal to `target`. If it is not possible to obtain the exact sum `target`, return `-1`.","solution":"from itertools import combinations def min_elements_to_remove(arr, target): Returns the minimum number of elements to remove from arr such that the sum of the remaining elements is exactly equal to target. Returns -1 if not possible. n = len(arr) # Iterate over all possible subset sizes for r in range(n + 1): # Check all combinations of elements of size r for subset in combinations(arr, r): # If the sum of the subset is target, return number of elements removed if sum(arr) - sum(subset) == target: return r return -1"},{"question":"You are given a string `s`, which may contain letters and digits. Write a function to reformat the string so that the letters and digits alternate, starting with a letter if there are at least as many letters as digits, and otherwise starting with a digit. If it is not possible to reformat the string in this way, return an empty string. Return the reformatted string if possible.","solution":"def reformat(s): Reformats the string s so that letters and digits alternate, starting with a letter if there are at least as many letters as digits, and otherwise starting with a digit. Returns an empty string if it\'s not possible to reformat in this way. letters = [ch for ch in s if ch.isalpha()] digits = [ch for ch in s if ch.isdigit()] if abs(len(letters) - len(digits)) > 1: return \\"\\" if len(letters) > len(digits): result = \'\'.join([x for y in zip(letters, digits + [\'\']) for x in y]) else: result = \'\'.join([x for y in zip(digits, letters + [\'\']) for x in y]) return result"},{"question":"In a company, there are `n` employees numbered from `1` to `n`. The company has a hierarchical structure represented by a **0-indexed** 2D array `reportees` where `reportees[i] = [manager, employee]` indicates that `employee` directly reports to `manager`. You are given an integer `CEO` representing the employee who is the CEO of the company. A meeting is to be held where the CEO wants to determine the maximum number of levels present in the company hierarchy (including the CEO\'s level as level 1). The employees who report directly to CEO are on level 2, their reportees are on level 3, and so on. Return _the total number of levels in the company hierarchy_.","solution":"def find_max_levels(n, reportees, CEO): from collections import defaultdict, deque # Building the adjacency list for the company\'s hierarchy hierarchy = defaultdict(list) for manager, employee in reportees: hierarchy[manager].append(employee) # Perform BFS to find the maximum number of levels in the hierarchy queue = deque([(CEO, 1)]) # (current_employee, current_level) max_level = 0 while queue: employee, level = queue.popleft() max_level = max(max_level, level) for reportee in hierarchy[employee]: queue.append((reportee, level + 1)) return max_level"},{"question":"Write a function `findElementAfterKSwaps` that takes a list of integers `arr` and an integer `k` as inputs. The function should find the element that ends up at the first position in the list after performing exactly `k` swaps, where in each swap, any two consecutive elements can be exchanged. You need to return this element. If no swaps can be performed or if `k` is zero, return the element initially at the first position. Consider the given list will have at least one element, and `k` will be a non-negative integer.","solution":"def findElementAfterKSwaps(arr, k): Returns the element that ends up at the first position after exactly k swaps, where in each swap any two consecutive elements can be exchanged. if k == 0 or len(arr) == 1: return arr[0] # Ensure k does not exceed the length of the array minus one k = min(k, len(arr) - 1) # Perform k swaps (each swap essentially shifts the first k+1 elements) first_k_elements = arr[:k + 1] first_k_elements.sort() return first_k_elements[0]"},{"question":"You are given a string `s` that contains only lowercase English letters. You need to find the number of distinct substrings (including single character substrings) that can be formed from `s`. A _substring_ is a contiguous sequence of characters within a string. For example, for the string \\"abc\\", the distinct substrings are [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\"]. Given `s`, return the number of distinct substrings that can be formed.","solution":"def distinct_substrings(s): Returns the number of distinct substrings that can be formed from s. n = len(s) substrings = set() for i in range(n): for j in range(i, n): substrings.add(s[i:j+1]) return len(substrings)"},{"question":"You are given a string `text` and an array of strings `words`. You can choose a word from the array `words` and remove it from `text` if it is a substring of `text`. After removing a word, concatenate the remaining parts of the string. You can repeat this operation as many times as you want until no word in `words` is a substring of the remaining `text`. Return _the minimum length of the `text` after performing all possible operations_.","solution":"def min_length_after_removals(text, words): Returns the minimum length of the text after removing all possible words from the words array. while True: initial_length = len(text) for word in words: if word in text: text = text.replace(word, \\"\\") if len(text) == initial_length: break return len(text)"},{"question":"Given an array of integers `arr`, you are tasked with finding the \\"peak element.\\" A peak element is defined as an element that is strictly greater than its neighbors. The array may contain multiple peaks, and if the first or last element is greater than its single neighbor, it is considered a peak. Write a function that returns the index of any one of the peak elements. You must implement an efficient algorithm whose time complexity is better than O(n). The elements in `arr` are not sorted and can contain duplicates. Note: Your solution should work in O(log n) time complexity.","solution":"def find_peak_element(arr): Function to find the index of a peak element. Parameters: arr (list): A list of integers. Returns: int: The index of one of the peak elements. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"Given a string `s`, you need to perform the following operation until `s` becomes empty: Select the smallest lexicographical character from `s` and remove all occurrences of this character. For example, given `s = \\"abaccb\\"`, you would remove \'a\' to get \\"bccb\\", remove \'b\' to get \\"cc\\", and finally remove \'c\' to get an empty string. Your task is to return the list of characters in the order they were removed from the string. (Note: If there are multiple smallest lexicographical characters at any step, remove all occurrences of any one of them but maintain consistency throughout the operation.)","solution":"def remove_smallest_lexicographically(s): Returns the list of characters in the order they were removed from the string by selecting the smallest lexicographical character and removing all its occurrences. removed_chars = [] while s: smallest_char = min(s) removed_chars.append(smallest_char) s = s.replace(smallest_char, \\"\\") return removed_chars"},{"question":"Given a `m x n` matrix `mat` where every row is sorted in **non-decreasing** order, return **all** elements of the matrix in a sorted order. You must not use any built-in sorting functions, and you should aim for a solution with a time complexity better than O(m*n*log(m*n)).","solution":"def sorted_matrix_elements(matrix): Given a m x n matrix where every row is sorted in non-decreasing order, returns all elements of the matrix in a sorted order. Args: matrix (List[List[int]]): The m x n matrix. Returns: List[int]: A sorted list of all elements in the matrix. m = len(matrix) n = len(matrix[0]) def merge_two_sorted_lists(list1, list2): # Auxiliary function to merge two sorted lists. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list # Merge all rows one-by-one. sorted_elements = matrix[0] for row in range(1, m): sorted_elements = merge_two_sorted_lists(sorted_elements, matrix[row]) return sorted_elements"},{"question":"You are given a list of integers `sticks` where each element represents the length of a stick. You are to connect the sticks into one stick. The cost of connecting two sticks is the sum of their lengths. Return _the minimum cost of connecting all the sticks into one_.","solution":"import heapq def connect_sticks(sticks): Returns the minimum cost of connecting all the sticks into one. :param sticks: List[int] - List of the lengths of the sticks :return: int - Minimum cost of connecting all the sticks if not sticks: return 0 heapq.heapify(sticks) total_cost = 0 while len(sticks) > 1: # Pop two smallest sticks first = heapq.heappop(sticks) second = heapq.heappop(sticks) # Cost to connect them cost = first + second # Add the connected stick back to the heap heapq.heappush(sticks, cost) # Accumulate total cost total_cost += cost return total_cost"},{"question":"You are given an array `nums` consisting of integers, and an integer `k`. Your task is to remove exactly `k` elements from the array such that the sum of the remaining elements is maximized. Return the maximum possible sum of the remaining elements after removing `k` elements.","solution":"def max_sum_after_removing_k_elements(nums, k): Returns the maximum possible sum of the remaining elements after removing exactly k elements from the list nums. # Sort the list in non-decreasing order nums.sort() # Sum all elements except the first k elements (because they are the smallest) max_sum = sum(nums[k:]) return max_sum"},{"question":"Given a binary tree, return the values of its nodes obtained by traversing the tree in level-order (breadth-first search). The result should be a list of lists, where each inner list contains the values at a particular level of the tree. **Example:** If the binary tree is: ``` 3 / 9 20 / 15 7 ``` The output should be: ``` [ [3], [9, 20], [15, 7] ] ``` **Note:** - The binary tree is represented by a TreeNode class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - You may assume that the binary tree has at least one node.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root): Returns the level-order traversal of a binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"Given a string `s` containing only the characters \'a\' and \'b\', you can remove any number of characters from `s` to create a new string. The **cost** of removing a character is determined by its position in the original string, starting from 1. Specifically, removing the character at position `i` costs `i` dollars. Your task is to determine the minimum possible cost required to transform the string `s` into a new string that contains no consecutive \'a\'s. Return this minimum cost.","solution":"def min_cost_to_avoid_consecutive_as(s): Given a string s containing only \'a\' and \'b\', returns the minimum cost required to remove characters such that there are no consecutive \'a\'s. Args: s (str): The input string. Returns: int: The minimum cost to achieve the desired string. n = len(s) if n <= 1: return 0 cost = 0 i = 0 while i < n: if s[i] == \'a\': # Find the subsequence of consecutive \'a\'s start = i while i < n and s[i] == \'a\': i += 1 end = i length = end - start if length > 1: # Remove (length - 1) \'a\'s to leave a single \'a\'. remove_count = length - 1 cost += sum(range(start + 2, start + 2 + remove_count)) else: i += 1 return cost"},{"question":"Given a string `s` consisting of only alphabetic characters and spaces, return a new string where the characters appear in reverse order but the positions of spaces remain unchanged. Ensure lowercase and uppercase letters are maintained in their original form (e.g., \'a\' remains \'a\' and \'A\' remains \'A\').","solution":"def reverse_string_preserve_spaces(s): Returns a new string where the characters appear in reverse order but the positions of spaces remain unchanged. # List to collect characters from the input string chars = [] # Collecting non-space characters for char in s: if char != \' \': chars.append(char) # Reverse the list of collected characters chars.reverse() # Index for the reversed characters reversed_char_index = 0 result = [] # Construct the result string by considering the positions of spaces for char in s: if char == \' \': result.append(\' \') else: result.append(chars[reversed_char_index]) reversed_char_index += 1 return \'\'.join(result)"},{"question":"Given an integer array `arr` of size `n`, write a function to determine if there exist three elements `a`, `b`, and `c` in `arr` such that `a + b + c = 0`. Return _true if such a triplet exists and false otherwise_. Note that the elements `a`, `b`, and `c` must be distinct.","solution":"def has_triplet_with_sum_zero(arr): Determines if there exist three elements in the array such that their sum is zero. :param arr: List of integers. :return: True if such a triplet exists, False otherwise. arr.sort() n = len(arr) for i in range(n-2): # Initialize two pointers for the current element arr[i] left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == 0: return True elif current_sum < 0: left += 1 else: right -= 1 return False"},{"question":"Given the head of a singly linked list, reverse the linked list and return the reversed list. Implement the following method: - `ListNode* reverseList(ListNode* head)` Where `ListNode` is a class that represents a node in a singly linked list, containing an integer value and a pointer to the next node.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverseList(head): Reverses the singly linked list. :param head: The head of the singly linked list. :return: The head of the reversed singly linked list. prev = None current = head while current: next_node = current.next # Temporarily store the next node current.next = prev # Reverse the current node\'s pointer prev = current # Move the pointers one position ahead. current = next_node return prev"},{"question":"4. Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the `MinStack` class: - `MinStack()` initializes the stack object. - `void push(int val)` pushes the element `val` onto the stack. - `void pop()` removes the element on the top of the stack. - `int top()` retrieves the top element of the stack. - `int getMin()` retrieves the minimum element in the stack. You must implement a solution with `O(1)` time complexity for each function.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: return self.stack[-1] if self.stack else None def getMin(self) -> int: return self.min_stack[-1] if self.min_stack else None"},{"question":"You are given two strings `s` and `goal` where `goal` is a permutation of `s`. The task is to determine if `s` can be transformed into `goal` using a series of swaps. In one swap, you can pick any two characters in the string `s` and swap them. Return _the minimum number of swaps needed to transform `s` into `goal`._ If it is impossible, return `-1`.","solution":"def min_swaps_to_transform(s, goal): Returns the minimum number of swaps needed to transform string `s` into `goal`. If it is impossible, returns -1. Both `s` and `goal` must be permutations of each other. # If both strings are not permutations of each other, return -1 if sorted(s) != sorted(goal): return -1 # Find the minimum number of swaps needed swaps = 0 s_list = list(s) for i in range(len(s)): if s_list[i] != goal[i]: # Find the position of the correct character for goal[i] for j in range(i + 1, len(s)): if s_list[j] == goal[i]: # Swap the characters to correct position s_list[i], s_list[j] = s_list[j], s_list[i] swaps += 1 break return swaps"},{"question":"Given a binary tree, return the bottom-left value in the last row of the tree. The bottom-left value in the tree is the leftmost value in the tree\'s last row when traversed level by level from left to right.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bottom_left_value(root): from collections import deque queue = deque([root]) while queue: node = queue.popleft() if node.right: queue.append(node.right) if node.left: queue.append(node.left) return node.val"},{"question":"You are given a 1-indexed array of integers `arr` where `arr[i]` represents the length of the ith stick. You need to pick exactly three sticks to form a triangle. A triangle is valid if the sum of the lengths of any two sides is strictly greater than the length of the third side. Find the **maximum perimeter** of a triangle that can be formed with these three sticks. If it is impossible to form any triangle, return `0`.","solution":"def max_perimeter(arr): Finds the maximum perimeter of a triangle that can be formed with three sticks. :param arr: List of integers representing the lengths of the sticks. :return: The maximum perimeter of a valid triangle, or 0 if no valid triangle can be formed. arr.sort(reverse=True) n = len(arr) for i in range(n - 2): if arr[i] < arr[i + 1] + arr[i + 2]: return arr[i] + arr[i + 1] + arr[i + 2] return 0"},{"question":"You are given two strings, `s1` and `s2`, both consisting of lowercase Latin letters. Your task is to determine the minimum number of operations required to convert `s1` into `s2`. The allowed operations are: * Insert a character * Delete a character * Replace a character Return _the minimum number of operations required to transform_ `s1` _into_ `s2`.","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to convert s1 to s2. The allowed operations are insert, delete, and replace a character. len1, len2 = len(s1), len(s2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Initialize the dp array for i in range(len1 + 1): dp[i][0] = i # All deletions for j in range(len2 + 1): dp[0][j] = j # All insertions # Fill the dp array for i in range(1, len1 + 1): for j in range(1, len2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete from s1 dp[i][j - 1], # Insert into s1 dp[i - 1][j - 1] # Replace in s1 ) return dp[len1][len2]"},{"question":"You are given a binary tree represented by a root node `root`, where each node contains a unique integer value. You are also given an integer `x`, and your goal is to determine if there exist two different nodes in the binary tree such that their values sum up to `x`. Write a function to return `True` if such a pair exists, otherwise return `False`. Your function should have the following signature: ```python def find_target(root: Optional[TreeNode], x: int) -> bool: ``` where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def find_target(root: TreeNode, x: int) -> bool: def inorder(node, values): if not node: return inorder(node.left, values) values.add(node.val) inorder(node.right, values) values = set() inorder(root, values) for val in values: if (x - val) in values and (x - val) != val: return True return False"},{"question":"You are given a 0-indexed array `height` where `height[i]` represents the height of the i-th student in a lineup. The task is to move students so that each student sees the student in front of them if and only if they are taller. You can only swap adjacent students. Return the minimum number of swaps required to rearrange the students in a non-decreasing order in height.","solution":"def minimum_swaps(height): Returns the minimum number of swaps required to rearrange the students in non-decreasing order of their heights. :param height: List[int] representing the height of each student. :return: int representing the number of minimum adjacent swaps required. swaps = 0 n = len(height) for i in range(n): for j in range(0, n-i-1): if height[j] > height[j+1]: height[j], height[j+1] = height[j+1], height[j] swaps += 1 return swaps"},{"question":"You are managing a city\'s traffic light system. The traffic lights are represented as an array of strings `lights`. Each string in the array represents the state of a traffic light at a specific intersection and can be one of the following: `\\"Green\\"`, `\\"Yellow\\"`, or `\\"Red\\"`. Your task is to ensure that the traffic flows smoothly according to the following rules: - Traffic should only flow if a light is `\\"Green\\"`. - A traffic light that is `\\"Yellow\\"` will turn to `\\"Red\\"` in the next state. - A traffic light that is `\\"Red\\"` will turn to `\\"Green\\"` in the next state. - A traffic light that is `\\"Green\\"` will turn to `\\"Yellow\\"` in the next state. Given the initial state of the traffic lights, return an array representing the state of all traffic lights after one state transition. The state transitions occur simultaneously for all traffic lights.","solution":"def update_traffic_lights(lights): Update the state of traffic lights based on the given rules. :param lights: List of strings representing the state of each traffic light. :return: List of strings representing the state of traffic lights after one state transition. next_state = [] for light in lights: if light == \\"Green\\": next_state.append(\\"Yellow\\") elif light == \\"Yellow\\": next_state.append(\\"Red\\") elif light == \\"Red\\": next_state.append(\\"Green\\") else: raise ValueError(\\"Invalid traffic light state\\") return next_state"},{"question":"You are given an array of integers `arr` where each element represents a person sitting in a circular arrangement. Each person has two unique neighbors. You need to determine the maximum number of people that can be selected such that no two people selected are direct neighbors. Return _the maximum number of non-neighboring people that can be selected from the array_.","solution":"def max_non_neighboring_selection(arr): Returns the maximum number of non-neighboring people that can be selected from the given circular array. n = len(arr) if n == 0: return 0 elif n == 1: return 1 # Use two arrays to handle circular nature dp1 = [0] * n dp2 = [0] * n # Case 1: Include the first element and exclude the last element dp1[0] = 1 dp1[1] = 1 for i in range(2, n-1): dp1[i] = max(dp1[i-1], dp1[i-2] + 1) # Case 2: Exclude the first element and include the last element dp2[1] = 1 for i in range(2, n): dp2[i] = max(dp2[i-1], dp2[i-2] + 1) return max(dp1[n-2], dp2[n-1])"},{"question":"You are given an array `events` where `events[i] = [starti, endi]` represents an event that starts at `starti` and ends at `endi`. All the values in the array are integers, and each event\'s start is less than or equal to its end. Write a function that returns the maximum number of events that can be attended, assuming you can only attend one event at a time. You can start attending any event at its start time and must finish attending that event before attending another one. If two events overlap exactly, you can attend only one of them.","solution":"def max_events(events): Returns the maximum number of non-overlapping events that can be attended. Parameters: events (List[List[int]]): List of events where each event is represented as [start, end]. Returns: int: Maximum number of events that can be attended. if not events: return 0 # Sort events primarily by end time, secondarily by start time events.sort(key=lambda x: (x[1], x[0])) current_time = 0 events_attended = 0 for start, end in events: if start > current_time: events_attended += 1 current_time = end return events_attended"},{"question":"You are given a string `s` containing only lowercase alphabet characters. A character `c` in the string is considered \\"special\\" if it appears exactly `k` times in `s`, where `k` is a given integer. Return _the list of all unique special characters_ in alphabetical order. If there are no special characters, return _an empty list_. The solution should have a time complexity of `O(n)`, where `n` is the length of the string.","solution":"def find_special_characters(s, k): Returns a list of unique special characters appearing exactly `k` times in the string `s`, sorted in alphabetical order. Parameters: s (str): The input string with only lowercase alphabet characters. k (int): The specified number of appearances to be considered special. Returns: list: A list of unique special characters sorted in alphabetical order. from collections import Counter # Count occurrences of each character character_count = Counter(s) # Find characters appearing exactly k times special_characters = [char for char, count in character_count.items() if count == k] # Return the sorted list of unique special characters return sorted(special_characters)"},{"question":"You are given a string `s` consisting of lower case English letters. A substring of `s` is called a `good` substring if all the characters of the substring are distinct. Return _the **number** of distinct `good` substrings of_ `s`. For example, given `s = \\"abac\\"`, the good substrings are `\\"a\\"`, `\\"b\\"`, `\\"ab\\"`, `\\"bac\\"`, `\\"c\\"`. Therefore, the answer should be `5`.","solution":"def count_good_substrings(s): Returns the number of distinct good substrings of s. A good substring has all distinct characters. n = len(s) good_substrings = set() for i in range(n): seen = set() for j in range(i, n): if s[j] in seen: break seen.add(s[j]) good_substrings.add(s[i:j + 1]) return len(good_substrings)"},{"question":"You are given an integer array `nums` and an integer `k`. A *subarray* is a contiguous non-empty sequence of elements within an array. Write a function to find the number of subarrays whose sum equals `k`. Implement the function `int subarraySum(int[] nums, int k)`. The function should return the total number of subarrays whose sum is equal to `k`.","solution":"def subarraySum(nums, k): Finds the number of subarrays whose sum equals k. :param nums: List of integers :param k: The target sum :return: Number of subarrays whose sum equals k count = 0 current_sum = 0 sum_dict = {0: 1} for num in nums: current_sum += num if current_sum - k in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"Given a string `s` of length `n` consisting of only lowercase English letters, you are required to find the **length** of the **longest substring** without repeating characters. Return that length as an integer.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index = {} max_length = start = 0 for index, char in enumerate(s): if char in char_index and start <= char_index[char]: start = char_index[char] + 1 else: max_length = max(max_length, index - start + 1) char_index[char] = index return max_length"},{"question":"Given a list of integers `nums`, write a function that returns the largest product that can be obtained from any three integers in the list. # Examples **Example 1:** ```plaintext Input: nums = [1, 2, 3] Output: 6 ``` **Example 2:** ```plaintext Input: nums = [1, 2, 3, 4] Output: 24 ``` **Example 3:** ```plaintext Input: nums = [-1, -2, -3, -4] Output: -6 ``` # Note You may assume that the array always has at least three integers.","solution":"def largest_product_of_three(nums): # Sorting the list in ascending order nums.sort() # Maximum of product of the three largest numbers # or product of the two smallest numbers and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"You are given two integer arrays `startTimes` and `endTimes`, where each element in the arrays represents the start and end time of intervals for various events. Both arrays are of the same length. You are also given an integer `queryTime`. Write a function to determine how many events are still ongoing at `queryTime`. An event is considered ongoing if `queryTime` is greater than or equal to its start time and less than or equal to its end time (inclusive). Return the count of such events.","solution":"def count_ongoing_events(startTimes, endTimes, queryTime): Returns the number of events that are ongoing at the given queryTime. :param startTimes: List of start times of the events. :param endTimes: List of end times of the events. :param queryTime: The time at which we are querying the number of ongoing events. :return: The count of ongoing events at queryTime. ongoing_count = 0 for start, end in zip(startTimes, endTimes): if start <= queryTime <= end: ongoing_count += 1 return ongoing_count"},{"question":"You are given a string consisting of lowercase letters and an integer `k`. The string can be modified by removing any number of characters from it. Your task is to determine the length of the longest substring that can be formed in which the number of distinct characters is less than or equal to `k`. Return the length of the longest substring that satisfies the condition.","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. n = len(s) if n == 0 or k == 0: return 0 left, right = 0, 0 max_length = 0 char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 right += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"Given a string `s` consisting of lowercase letters, you are allowed to remove at most one substring of characters that are consecutive and form a palindrome. Return the length of the longest non-palindromic substring that can be obtained after making at most one such removal. A substring is a contiguous sequence of characters within a string, and a palindrome reads the same backward as forward.","solution":"def is_palindrome(s): return s == s[::-1] def longest_non_palindromic_substring_length(s): n = len(s) if not s or n == 1: return 0 if not is_palindrome(s): return n # Since s is a palindrome, the result is n - 1: return n - 1"},{"question":"You are given a **2D grid** of size `m x n` representing a field. Each cell in the grid contains either a `1` (representing land) or a `0` (representing water). You can perform an **unlimited** number of operations, and in each operation, you can convert a `0` (water) cell to a `1` (land) cell. Your task is to determine the **minimum** number of operations required to make the field fully connected, where: - A field is considered fully connected if there is exactly one connected component of `1`s (land cells form a single connected block without any disconnected segments). A cell is considered connected to another cell if they are directly adjacent in one of the four possible directions (left, right, up, down). Return _the **minimum** number of operations needed to make the field fully connected_.","solution":"def num_islands(grid): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != \'1\': return grid[x][y] = \'#\' for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]: dfs(x + dx, y + dy) if not grid: return 0 m, n = len(grid), len(grid[0]) islands = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\': dfs(i, j) islands += 1 return islands def min_operations_to_connect(grid): m, n = len(grid), len(grid[0]) islands = num_islands([row[:] for row in grid]) if islands <= 1: return 0 return islands - 1"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped at each bar of a histogram where the width of each bar is 1. Compute the total amount of rainwater trapped. Each bar\'s width and height determine how much water it can hold, and you should assume it is a histogram with non-zero width. Write a function: ```python def trap(height: List[int]) -> int: ``` that takes a list of integers `height` representing the elevation map and returns the total amount of trapped rainwater after it rains.","solution":"from typing import List def trap(height: List[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Design an autocomplete system that suggests the top 3 products based on a given prefix. Each product has a name and a numerical score. The suggestions should be sorted in descending order by their scores. If multiple products have the same score, the lexicographical order should be used. Implement the `AutocompleteSystem` class: * `AutocompleteSystem(String[] products, int[] scores)` initializes the system with an array of product names and their corresponding scores. * `List<String> top3(String prefix)` returns the top 3 product names that start with the given prefix and are sorted as described above. If there are fewer than 3 products matching the prefix, return all matching product names. For example: ``` AutocompleteSystem([\\"apple\\", \\"app\\", \\"apricot\\"], [5, 3, 7]) Calling top3(\\"ap\\") returns [\\"apricot\\", \\"apple\\", \\"app\\"] ``` Remember to maintain the invariants and constraints as described.","solution":"from typing import List class AutocompleteSystem: def __init__(self, products: List[str], scores: List[int]): Initializes the system with an array of product names and their corresponding scores. self.products = products self.scores = scores self.product_score_pairs = list(zip(products, scores)) def top3(self, prefix: str) -> List[str]: Returns the top 3 product names that start with the given prefix, sorted in descending order by their scores. If multiple products have the same score, the order is determined lexicographically. filtered = [ps for ps in self.product_score_pairs if ps[0].startswith(prefix)] sorted_filtered = sorted(filtered, key=lambda ps: (-ps[1], ps[0])) return [ps[0] for ps in sorted_filtered[:3]]"},{"question":"You are given a binary matrix (a matrix consisting of only 0s and 1s) with `n` rows and `m` columns. The matrix is structured such that all the 1s in each row are grouped together, and they appear before any 0s in the same row. Write an algorithm to find the row that has the maximum number of 1s. Implement a function `int rowWithMaximumOnes(int[][] matrix)` that takes as input a binary matrix `matrix` of size `n x m` and returns an integer representing the index of the row with the maximum number of 1s. If multiple rows have the same number of 1s, return the smallest row index. The function must have a time complexity of `O(n + m)`. Example: Input: ``` matrix = [ [0, 0, 0, 1], [0, 1, 1, 1], [1, 1, 1, 1], [0, 0, 0, 0] ] ``` Output: ``` 2 ```","solution":"def rowWithMaximumOnes(matrix): Returns the index of the row that has the maximum number of 1s. If multiple rows have the same number of 1s, the smallest row index is returned. The time complexity of the algorithm is O(n + m). n = len(matrix) if n == 0: return -1 m = len(matrix[0]) # Variables to keep track of the maximum number of 1s and the corresponding row index maxOnesRowIndex = -1 maxOnesCount = 0 # Start from the top-right corner of the matrix row = 0 col = m - 1 while row < n and col >= 0: if matrix[row][col] == 1: # Move left maxOnesRowIndex = row maxOnesCount = m - col col -= 1 else: # Move down row += 1 return maxOnesRowIndex"},{"question":"You are given a binary tree represented by a list of node values in level-order traversal where `None` represents a missing node. Implement a function that returns the level-order traversal of the binary tree as a list of lists. Each sub-list should contain the values of the tree nodes at each level from left to right. For example, given the input `[3, 9, 20, None, None, 15, 7]`, the function should return `[[3], [9, 20], [15, 7]]`. Note: - The binary tree will always have at least one node.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def list_to_binary_tree(nodes: List[Optional[int]]) -> Optional[TreeNode]: if not nodes: return None n = len(nodes) root = TreeNode(nodes[0]) queue = [(root, 0)] while queue: node, index = queue.pop(0) left_index, right_index = 2 * index + 1, 2 * index + 2 if left_index < n and nodes[left_index] is not None: node.left = TreeNode(nodes[left_index]) queue.append((node.left, left_index)) if right_index < n and nodes[right_index] is not None: node.right = TreeNode(nodes[right_index]) queue.append((node.right, right_index)) return root def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] level_order, queue = [], [root] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.pop(0) current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) level_order.append(current_level) return level_order def get_level_order(nodes: List[Optional[int]]) -> List[List[int]]: root = list_to_binary_tree(nodes) return level_order_traversal(root)"},{"question":"Write a function that takes a **2D matrix** `matrix` and an integer `k` as inputs, where `matrix` is a matrix of integers with `n` rows and `m` columns. Find the `k-th` smallest element in the matrix. Note that the properties of the matrix are: - Each row is sorted in non-decreasing order. - Each column is sorted in non-decreasing order. Return the `k-th` smallest element in the matrix.","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in the given 2D matrix. The matrix has properties: - Each row is sorted in non-decreasing order. - Each column is sorted in non-decreasing order. matrix: List[List[int]] k: int n = len(matrix) min_heap = [] for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) while k: element, r, c = heapq.heappop(min_heap) if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"You are given a string `s` consisting of lowercase Spanish alphabet letters and a pattern string `p` that also consists of lowercase Spanish alphabet letters. Determine if the pattern `p` exists as a subsequence within the string `s`. Return `true` if the pattern is found as a subsequence and `false` otherwise. Note that a subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.","solution":"def is_subsequence(s, p): Determines if the pattern p exists as a subsequence within the string s. Args: s (str): The string to be searched. p (str): The pattern to be found as a subsequence. Returns: bool: True if p is a subsequence of s, False otherwise. iter_s = iter(s) return all(char in iter_s for char in p)"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You can delete any number of characters from the string. Return the length of the longest subsequence that can be obtained that contains all three characters \'a\', \'b\', and \'c\' in that order. Note that the characters do not need to be consecutive in the subsequence.","solution":"def longest_subsequence_length(s): Returns the length of the longest subsequence that contains all three characters \'a\', \'b\', and \'c\' in that order. a_count, b_count, c_count = 0, 0, 0 for char in s: if char == \'a\': a_count += 1 elif char == \'b\': b_count = min(a_count, b_count + 1) elif char == \'c\': c_count = min(b_count, c_count + 1) return c_count"},{"question":"Given a `2D` grid of size `m x n` representing a map where `1` represents land and `0` represents water, return the number of **distinct islands**. An island is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Two islands are considered distinct if and only if one island is not equal to another (reflected versions are considered different). An island is the same as another if and only if they have the same shape, and the shape must be exaclty the same (not considering mirrored and rotated shape). Implement a function `int numDistinctIslands(vector<vector<int>>& grid)` that returns the number of distinct islands.","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the given grid. def dfs(x, y, direction, island_path): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != 1: return grid[x][y] = -1 # Mark as visited island_path.append(direction) # Explore all four directions dfs(x - 1, y, \'U\', island_path) # Up dfs(x + 1, y, \'D\', island_path) # Down dfs(x, y - 1, \'L\', island_path) # Left dfs(x, y + 1, \'R\', island_path) # Right # Mark end of this part of path island_path.append(\'0\') distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: island_path = [] dfs(i, j, \'S\', island_path) # Start DFS from here distinct_islands.add(tuple(island_path)) return len(distinct_islands)"},{"question":"You are given an integer array `arr` of length `n` and an integer `k`. You have to perform `k` operations to maximize the sum of the array. In each operation, you can select one element from the array and increase it by 1. You need to find the maximum possible sum of the array after performing exactly `k` operations. Return _the maximum possible sum of the array_ after performing the operations.","solution":"def maximize_sum(arr, k): Maximizes the sum of the array after performing k operations. In each operation, one array element can be increased by 1. Args: arr (list): List of integers. k (int): Number of operations. Returns: int: The maximum possible sum of the array after k operations. sum_arr = sum(arr) return sum_arr + k"},{"question":"Write a function that takes an array of integers `arr` and a target integer `k`. The goal is to divide the array into **two subarrays** such that the difference in their sums is equal to `k`. Return `true` if such a division is possible, and `false` otherwise. The subarrays do not need to be contiguous, but each element must be used in exactly one of the subarrays.","solution":"def can_divide_array(arr, k): Determines if an array can be divided into two subarrays such that the difference in their sums is equal to k. :param arr: List of integers :param k: Target integer for the difference in sums :return: True if such a division is possible, False otherwise total_sum = sum(arr) # Check if (total_sum - k) can be evenly divided into two parts if (total_sum - k) % 2 != 0: return False target = (total_sum - k) // 2 # Use dynamic programming to determine if there is a subset with sum equal to target dp = [False] * (target + 1) dp[0] = True for num in arr: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"You are given a list of non-negative integers representing the heights of a series of vertical bars, where each integer represents the height of a bar at that index. The bars are placed adjacent to each other, so each pair of bars can potentially trap rainwater between them if there is a taller bar on both the left and right sides. Calculate the maximum amount of water that can be trapped after raining. For example: - Input: `[0,1,0,2,1,0,1,3,2,1,2,1]` - Output: `6` The water trapped is represented by the indices: - Between indices [1, 3] (1 unit) - Between indices [4, 7] (6 units total from smaller units of trapped water between intervening bars).","solution":"def trap(height): Calculate the maximum amount of water that can be trapped after raining. Parameters: height (List[int]): List of non-negative integers representing the height of bars. Returns: int: Maximum amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += max(0, min(left_max[i], right_max[i]) - height[i]) return water_trapped"},{"question":"You are given a string `s` that consists of only digits and returns all possible valid IP address combinations that can be formed by inserting dots into `s`. An IP address consists of four integers (each integer is between 0 and 255) separated by single dots and cannot have leading zeros. For example, \\"25525511135\\" can be converted to the valid IP addresses [\\"255.255.11.135\\", \\"255.255.111.35\\"]. Return the valid IP addresses in any order.","solution":"def restore_ip_addresses(s): Return all possible valid IP address combinations that can be formed by inserting dots into the string `s`. def is_valid(segment): # \'0\' is valid but \'00\' or \'01\' is not. return int(segment) <= 255 and (segment == \\"0\\" or segment[0] != \\"0\\") def backtrack(start=0, path=[]): # If we have 4 segments and we\'re at the end of the string, add to results. if start == len(s) and len(path) == 4: results.append(\\".\\".join(path)) return # If we have 4 segments but haven\'t used up the whole string, return. if len(path) == 4: return # Try all possible splits of the string. for end in range(start + 1, min(start + 4, len(s) + 1)): segment = s[start:end] if is_valid(segment): backtrack(end, path + [segment]) results = [] backtrack() return results"},{"question":"Given the `inorder` and `postorder` traversal of a binary tree, construct the tree and return _its root_. You may assume that the given two traversals are **valid reversals** of a binary tree. In a binary tree: - **Inorder traversal** visits the nodes in the following order: `Left -> Root -> Right`. - **Postorder traversal** visits the nodes in the following order: `Left -> Right -> Root`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(inorder, postorder): Constructs a binary tree from inorder and postorder traversal. :param inorder: List[int], the inorder traversal of the tree :param postorder: List[int], the postorder traversal of the tree :return: TreeNode, the root of the constructed binary tree if not inorder or not postorder: return None # The last element of postorder is the root root_val = postorder.pop() root = TreeNode(root_val) # Find the index of the root in inorder traversal inorder_index = inorder.index(root_val) # Build right and left subtrees root.right = buildTree(inorder[inorder_index+1:], postorder) root.left = buildTree(inorder[:inorder_index], postorder) return root"},{"question":"You are given a list of integers `arr` representing heights of buildings standing in a row. Each building is 1 unit wide. A building can block the view of another building to its right if it is equal to or taller than the building to its right. If a building is blocked by another building, it is not visible. You need to find the number of buildings that are visible when looking from the left side to the right side of the row. Given the list of integers `arr`, return _the **number** of visible buildings_.","solution":"def count_visible_buildings(arr): Given a list of integers representing heights of buildings, returns the number of visible buildings when looking from the left side to the right side of the row. if not arr: return 0 max_height = arr[0] count = 1 # The first building is always visible for height in arr[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"Given a `string` containing only digits, calculate the number of ways to decode it. Each digit (or pair of digits) maps to a letter as follows: \'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\'. For example, the input \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). Return _the total number of ways to decode the string_.","solution":"def num_decodings(s): Calculate the number of ways to decode a string containing only digits to letters. if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) # Base case initialization dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) # Check if single digit decode is possible if 1 <= one_digit <= 9: dp[i] += dp[i-1] # Check if two digits decode is possible if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"You are given a list of strings `words` and a string `characters`. Each string in `words` can only be formed by characters present in `characters`. However, each character in `characters` can only be used once per string formation. Return _the maximum sum of lengths of all words that can be formed using characters from `characters`_. Ensure each string can be fully formed by the given characters and partial formation is not allowed.","solution":"def count_characters(words, characters): Returns the maximum sum of lengths of all words that can be formed using characters from `characters`. Each character in `characters` can only be used once per word formation. from collections import Counter def can_form(word, char_count): Check if the word can be formed using the characters in char_count. word_count = Counter(word) for char, count in word_count.items(): if char not in char_count or word_count[char] > char_count[char]: return False return True char_count = Counter(characters) total_length = 0 for word in words: if can_form(word, char_count): total_length += len(word) return total_length"},{"question":"You are given a matrix `grid` representing a 2D grid of integers. A move from cell `(r, c)` to cell `(r+1, c)` or `(r, c+1)` is allowed if the value of the target cell is at least the value of the current cell (i.e., you can only move to cells with equal or greater values). Starting from the top-left cell `(0, 0)`, what is the number of distinct paths to reach the bottom-right cell `(n-1, m-1)` such that all cells in the path follow the aforementioned rule? Return the number of such distinct paths.","solution":"def count_paths(grid): Returns the number of distinct paths from the top-left to bottom-right of the grid where each move is to a cell with equal or greater value. from collections import defaultdict, deque n, m = len(grid), len(grid[0]) # Stores number of ways to reach each cell paths = [[0] * m for _ in range(n)] paths[0][0] = 1 # Starting point directions = [(0, 1), (1, 0)] # Right and Down moves cells = [(grid[row][col], row, col) for row in range(n) for col in range(m)] cells.sort() for value, r, c in cells: for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] >= grid[r][c]: paths[nr][nc] += paths[r][c] return paths[n-1][m-1]"},{"question":"You are given an array of integers `arr`. The goal is to manipulate the array such that the sum of all elements in the array is maximized after performing exactly one of the following operations: - Pick any element in the array and increase it by 1. - Pick any element in the array and decrease it by 1. Return the maximum possible sum of the elements of the array after performing one of the above operations. For example, given the array `arr = [1, 2, 3]`, you could increase the element `3` by 1 making the array `[1, 2, 4]` with a sum of `7`, which is the maximum possible sum after one operation.","solution":"def maximize_sum(arr): Returns the maximum possible sum of the array after performing one of the operations: - Pick any element and increase it by 1 - Pick any element and decrease it by 1 total_sum = sum(arr) max_sum = total_sum + 1 # Maximum possible sum by increasing any element by 1 return max_sum"},{"question":"Given a list of non-negative integers `nums`, you are tasked with constructing a binary tree such that any node in the tree has a value greater than or equal to the values of its children. This means that the tree satisfies the max-heap property. Write a function to construct the max-heap tree and return its root. The input list `nums` is guaranteed to contain at least one element.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_max_heap(nums): Constructs a max-heap based binary tree from a list of non-negative integers. Args: nums (list of int): List of non-negative integers. Returns: TreeNode: The root of the max-heap tree. def heapify(nums, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and nums[i] < nums[left]: largest = left if right < n and nums[largest] < nums[right]: largest = right if largest != i: nums[i], nums[largest] = nums[largest], nums[i] heapify(nums, n, largest) n = len(nums) for i in range(n // 2 - 1, -1, -1): heapify(nums, n, i) nodes = [TreeNode(val=num) for num in nums] for i in range(n): if 2 * i + 1 < n: nodes[i].left = nodes[2 * i + 1] if 2 * i + 2 < n: nodes[i].right = nodes[2 * i + 2] return nodes[0]"},{"question":"Given an integer array `arr` of size `n`, you need to find out if there are any duplicate elements within `k` distance of each other. In other words, check if there are two distinct indices `i` and `j` in the array such that `arr[i] == arr[j]` and the absolute difference between `i` and `j` is at most `k`. Return `true` if such elements are found, otherwise return `false`.","solution":"def contains_nearby_duplicate(arr, k): Checks if there are any duplicates within k distance. if not arr or k <= 0: return False index_map = {} for i, value in enumerate(arr): if value in index_map and i - index_map[value] <= k: return True index_map[value] = i return False"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Determine if an integer `target` exists in the array by implementing a binary search algorithm. Return `true` if `target` is found in the array, and `false` otherwise. Note: Your solution should have a time complexity of (O(log n)), where (n) is the length of `nums`.","solution":"def binary_search(nums, target): Determine if the target exists in the sorted array nums using binary search. Returns True if found, else False. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return True elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"You are given an integer array `nums` and an integer `k`. A **k-complementary pair** is a pair of elements `(nums[i], nums[j])` such that `nums[i] + nums[j] = k` and `i < j`. Return _the number of **k-complementary pairs** in the array_. If no such pairs exist, return `0`.","solution":"def count_k_complementary_pairs(nums, k): Returns the number of k-complementary pairs in the given array. :param nums: List of integers :param k: Target integer sum for k-complementary pairs :return: Number of k-complementary pairs num_count = {} pair_count = 0 for num in nums: complement = k - num if complement in num_count: pair_count += num_count[complement] if num in num_count: num_count[num] += 1 else: num_count[num] = 1 return pair_count"},{"question":"You are given a string `start` and a string `end`, both of length `n`, and a list `bank` of unique strings, each of length `n`. Each string in the `bank` represents a valid genetic sequence. A mutation is defined as a single-character change in the sequence. For example, `\\"AACCGGTT\\"` can be mutated to `\\"AACCGGTA\\"`. You want to determine the minimum number of mutations needed to transform the `start` string into the `end` string. If there is no such transformation sequence possible, return `-1`. Each mutation must be in the `bank`. Return _the minimum number of mutations needed to transform `start` into `end` or `-1` if no such transformation is possible_.","solution":"from collections import deque def min_mutation(start, end, bank): Returns the minimum number of mutations to convert start to end using the given bank of valid transitions, or -1 if the transformation is not possible. if end not in bank: return -1 def is_one_mutation_away(s1, s2): Returns True if s1 can be mutated to s2 by changing exactly one character, else False. differences = sum(1 for a, b in zip(s1, s2) if a != b) return differences == 1 bank_set = set(bank) queue = deque([(start, 0)]) visited = set([start]) while queue: current, steps = queue.popleft() if current == end: return steps for sequence in bank_set: if is_one_mutation_away(current, sequence) and sequence not in visited: visited.add(sequence) queue.append((sequence, steps + 1)) return -1"},{"question":"You are given a 2D integer matrix `matrix` of size `m x n`. You can perform the following operation as many times as you want: choose any submatrix of `matrix` and add 1 to each element within that submatrix. Return _the minimum number of operations required to make all the elements of the matrix equal_.","solution":"def min_operations_to_equalize(matrix): Returns the minimum number of operations required to make all the elements of the matrix equal. max_val = max(map(max, matrix)) min_val = min(map(min, matrix)) if max_val == min_val: return 0 return (max_val - min_val)"},{"question":"You are given an integer array `arr` of size `n` and an integer `k`. Your task is to find and return an array of size `n - k + 1` where each element in the array is the maximum value of `k` consecutive elements in `arr`. That is, the `i`th element in the result array should be the maximum of the subarray `arr[i]` to `arr[i + k - 1]`.","solution":"def max_of_subarrays(arr, n, k): Returns an array where each element is the maximum value of k consecutive elements in the input array. :param arr: List[int], the input array :param n: int, the size of the input array :param k: int, the size of the subarray :return: List[int], the output array with the maximum values of k subarrays from collections import deque if k > n or k == 0 or len(arr) == 0: return [] result = [] dq = deque() for i in range(k): while dq and arr[dq[-1]] <= arr[i]: dq.pop() dq.append(i) for i in range(k, n): result.append(arr[dq[0]]) while dq and dq[0] <= i - k: dq.popleft() while dq and arr[dq[-1]] <= arr[i]: dq.pop() dq.append(i) result.append(arr[dq[0]]) return result"},{"question":"Given a rectangular `m x n` binary grid that represents a map of an island, return _the length of the island\'s perimeter_. The grid consists of `0`s (representing water) and `1`s (representing land). Each cell is square, with a side length of 1. The islands are connected 4-directionally (horizontal or vertical). There is exactly one island in the grid. For example: ``` Input: grid = [ [0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0] ] Output: 16 ```","solution":"def island_perimeter(grid): Given a rectangular m x n binary grid that represents a map of an island, return the perimeter of the island. The grid consists of 0s (representing water) and 1s (representing land). Each cell is square with a side length of 1. The island is connected 4-directionally (horizontal or vertical). rows = len(grid) cols = len(grid[0]) perimeter = 0 def is_water_or_outside(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return True return False for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Check all 4 directions for water or grid boundary if is_water_or_outside(r-1, c): # up perimeter += 1 if is_water_or_outside(r+1, c): # down perimeter += 1 if is_water_or_outside(r, c-1): # left perimeter += 1 if is_water_or_outside(r, c+1): # right perimeter += 1 return perimeter"},{"question":"You are given an integer array `arr` of size `n` and an integer `x`. Your task is to find a subarray of `arr` such that the sum of its elements is exactly `x`. If there are multiple subarrays meeting the criteria, return the subarray with the smallest starting index. If no such subarray exists, return an empty array. Note: A subarray is a contiguous sequence of elements within an array. Return the subarray as a list of its elements.","solution":"def find_subarray_with_sum(arr, x): Finds a subarray whose sum is exactly x. current_sum = 0 start_index = 0 sum_dict = {} for end_index in range(len(arr)): current_sum += arr[end_index] if current_sum == x: return arr[start_index:end_index + 1] if current_sum - x in sum_dict: return arr[sum_dict[current_sum - x] + 1:end_index + 1] sum_dict[current_sum] = end_index return []"},{"question":"You are given an array of integers `heights` representing the height of mountains in a linear range. You are also given an integer `threshold`. Your task is to determine the maximum number of consecutive mountains within the `heights` array such that the difference in height between the highest and the lowest mountain in this subset is no more than the given `threshold`. Write a function `maxConsecutiveMountains(heights: List[int], threshold: int) -> int` which returns an integer representing the length of the longest consecutive subarray meeting the aforementioned condition.","solution":"from typing import List def maxConsecutiveMountains(heights: List[int], threshold: int) -> int: Returns the length of the longest consecutive subarray where the difference between the highest and lowest mountain is no more than the given threshold. n = len(heights) if n == 0: return 0 max_length = 0 start = 0 for end in range(n): current_window = heights[start:end + 1] min_height = min(current_window) max_height = max(current_window) while max_height - min_height > threshold: start += 1 current_window = heights[start:end + 1] min_height = min(current_window) max_height = max(current_window) max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a string `s` consisting only of lowercase English letters, find the length of the smallest substring that contains all the unique characters of `s`. If the string contains duplicates of the smallest substring, prioritize the first occurrence. If no such substring exists, return `-1`.","solution":"def smallest_unique_substring_length(s): Returns the length of the smallest substring that contains all the unique characters of the input string s. If no such substring exists, returns -1. from collections import Counter if not s: return -1 unique_chars = set(s) total_unique_chars = len(unique_chars) left = 0 min_length = len(s) + 1 char_count = Counter() formed_chars = 0 for right in range(len(s)): char_count[s[right]] += 1 if char_count[s[right]] == 1: formed_chars += 1 while formed_chars == total_unique_chars and left <= right: if right - left + 1 < min_length: min_length = right - left + 1 char_count[s[left]] -= 1 if char_count[s[left]] == 0: formed_chars -= 1 left += 1 return min_length if min_length <= len(s) else -1"},{"question":"You are given a binary tree represented by the root node, where each node in the tree contains an integer value and a pointer to its left and right child nodes. The tree may have any arbitrary shape (not necessarily balanced). Write a function that returns the total sum of all node values in the tree _multiplied by_ the depth of their respective nodes. The root node is at depth 1, its children are at depth 2, and so on. The depth of each node is defined as the number of edges from the root to the node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_node_depth_product(root): Returns the total sum of all node values in the binary tree multiplied by the depth of their respective nodes. def dfs(node, depth): if not node: return 0 return depth * node.val + dfs(node.left, depth + 1) + dfs(node.right, depth + 1) return dfs(root, 1)"},{"question":"You are given a **string** `s` consisting of lowercase English letters. You need to group the characters of the string into **substrings** such that each letter appears in at most one substring. Additionally, a character should not appear in any other part of the string after its respective substring has started starting from left to right. Return _the **list** of the lengths of these substrings._","solution":"def partition_labels(s): Given a string `s`, returns a list of integers representing the lengths of substrings such that each letter appears in at most one substring. last_occurrence = {c: idx for idx, c in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"You are given an m x n integer matrix `grid` representing a **maze** where `0` represents a wall and `1` represents a path you can walk on. You start from the top-left corner of the maze (grid[0][0]) and need to reach the bottom-right corner (grid[m-1][n-1]). You are allowed to move up, down, left, or right. However, each time you move to a cell with a `1`, the `1` turns into a `0`. Find the minimum number of moves required to reach the bottom-right corner. If there is no valid path, return -1.","solution":"from collections import deque def min_moves(grid): Returns the minimum number of moves required to reach the bottom-right corner of the maze. If there is no valid path, return -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 0 or grid[m-1][n-1] == 0: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, step) grid[0][0] = 0 # Mark as visited while queue: x, y, step = queue.popleft() if x == m - 1 and y == n - 1: return step for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: grid[nx][ny] = 0 # Mark as visited queue.append((nx, ny, step + 1)) return -1"},{"question":"Given an integer `n`, return _the **number of trailing zeroes** in the factorial of_ `n`. A trailing zero is any zero that appears at the end of a number.","solution":"def trailing_zeroes_in_factorial(n): Returns the number of trailing zeroes in the factorial of n. The number of trailing zeroes in n! is determined by the number of times 10 is a factor in n!. Since 10 is made up of 2 and 5, and there are generally more factors of 2 than 5, we only need to count the number of factors of 5 in n! to determine the number of trailing zeroes. count = 0 while n >= 5: n //= 5 count += n return count"},{"question":"Given an integer array `functionCalls` where each element represents the number of times a specific function is called, you need to return the function\'s id with the highest call count. If there are multiple functions with the same highest call count, return the one with the smallest id. The functions are indexed starting from 0.","solution":"def highest_call_count(functionCalls): Returns the id of the function with the highest call count. If there are multiple functions with the same highest count, return the one with the smallest id. :param functionCalls: List[int] - a list where each element represents the number of times a specific function is called :return: int - the id of the function with the highest call count max_calls = max(functionCalls) # Find the maximum call count for i, calls in enumerate(functionCalls): if calls == max_calls: return i # Return the index of the first occurrence of the maximum call count"},{"question":"You are given a string `s` containing lowercase English letters. You can delete any number of characters from the string. Your goal is to find the _length of the longest palindrome_ that can be formed by deleting some or no characters of the string. Note that a single character is considered a palindrome. Return the length of this longest palindrome.","solution":"def longest_palindrome_length(s): Returns the length of the longest palindrome that can be formed by deleting some or no characters from the string. from collections import Counter count = Counter(s) length = 0 odd_count = 0 for freq in count.values(): if freq % 2 == 0: length += freq else: length += freq - 1 odd_count = 1 # There is at least one character with an odd frequency # If there is at least one odd frequency character, add 1 to length to allow # one to be at the center of the palindrome return length + odd_count"},{"question":"Given an array of integers `arr` and an integer `k`, determine if the array can be partitioned into exactly `k` non-empty subsequences such that each subsequence contains numbers that are strictly increasing. Return `true` if such a partition is possible, otherwise return `false`.","solution":"def can_partition_into_k_increasing_subsequences(arr, k): Determine if the array \'arr\' can be partitioned into exactly \'k\' non-empty subsequences such that each subsequence contains numbers that are strictly increasing. Args: arr: List[int] - List of integers. k: int - Number of required increasing subsequences. Returns: bool - True if possible, otherwise False. n = len(arr) # If k is greater than the length of the array, it\'s impossible to form k non-empty sequences if k > n: return False # Calculate the minimum number of strictly increasing subsequences by counting # the number of non-increasing pairs in the array subsequences_needed = 1 for i in range(1, n): if arr[i] <= arr[i-1]: subsequences_needed += 1 return subsequences_needed <= k"},{"question":"You are given a string `s` consisting of lowercase alphabets. A letter is considered **isolated** if it does not have the same letter as an adjacent character. Return _**all isolated letters** in_ `s`. You may return the answer in **any order**.","solution":"def find_isolated_letters(s): Returns all isolated letters in the string s. An isolated letter is a letter that does not have the same letter as an adjacent character. isolated_letters = set() n = len(s) if n == 0: return [] if n == 1: return [s[0]] for i in range(n): if (i == 0 and s[i] != s[i + 1]) or (i == n - 1 and s[i] != s[i - 1]) or (0 < i < n - 1 and s[i] != s[i - 1] and s[i] != s[i + 1]): isolated_letters.add(s[i]) return list(isolated_letters)"},{"question":"A conveyor belt has a sequence of packages, each with a positive weight represented by an integer array `weights`, where `weights[i]` is the weight of the `i-th` package. The conveyor belt can handle packages with a combined maximum weight limit of `maxWeight`. Your task is to determine the **minimum** number of rounds needed to transport all the packages if the maximum weight of packages in each round does not exceed `maxWeight`. Each package must be transported exactly once, and they can be transported in any order. Return the minimum number of rounds required.","solution":"def min_rounds(weights, maxWeight): # Sort the weights to enable a greedy approach weights.sort() left, right = 0, len(weights) - 1 rounds = 0 while left <= right: # If the lightest and heaviest package together are within the max weight, # we transport both in the same round if weights[left] + weights[right] <= maxWeight: left += 1 # Always transport the heaviest package left right -= 1 # One round is completed rounds += 1 return rounds"},{"question":"A company\'s network consists of interconnected servers forming a tree structure. Each server is represented as a node in the tree and has a unique identifier in the range `[0, n-1]`. The network is managed such that there is a central node, called the root, and all other servers are directly or indirectly connected to this root server. Given this tree structure in the form of a parent array `parent` where `parent[i]` is the parent server of the i-th server (for `0 <= i < n`, where `parent[root]` is `-1` indicating the root server), and an array `costs` where `costs[i]` is the cost to repair the i-th server, your task is to find the **minimum total repair cost** to restore the network if the following conditions hold: 1. The root server must always be repaired if it is broken. 2. For any broken server, all servers on the path from the root to that server must also be repaired. Return the minimum total repair cost.","solution":"def min_repair_cost(parent, costs): def dfs(node): total_cost = costs[node] for child in tree[node]: total_cost += dfs(child) return total_cost n = len(parent) tree = [[] for _ in range(n)] root = -1 for i in range(n): if parent[i] == -1: root = i else: tree[parent[i]].append(i) return dfs(root)"},{"question":"You are given a binary tree where each node contains an integer value. The binary tree is represented by a root node. You need to perform the following tasks: 1. **Calculate the sum of the values of all nodes at the nth level** in the tree. The root node is considered to be at level 0. 2. **Determine the height of the tree**, which is the number of levels from the root node to the deepest leaf node. Write a function that takes the root of the binary tree and an integer `n` representing the level as input, and returns a tuple containing two integers: the sum of the values at the nth level and the height of the tree. If the nth level does not exist in the tree, return 0 for the sum of values at that level.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_and_height(root, n): if not root: return (0, 0) def calculate_sum_at_level(node, level): if not node: return 0 if level == 0: return node.value return calculate_sum_at_level(node.left, level - 1) + calculate_sum_at_level(node.right, level - 1) def calculate_height(node): if not node: return 0 return 1 + max(calculate_height(node.left), calculate_height(node.right)) sum_at_n = calculate_sum_at_level(root, n) height = calculate_height(root) return (sum_at_n, height)"},{"question":"You are given an integer array `arr` and an integer `k`. A pair `(i, j)` is called a **good pair** if `arr[i] == arr[j]` and `i < j`. Return `the number of good pairs in the array`.","solution":"def num_identical_pairs(arr): Returns the number of good pairs in the array such that arr[i] == arr[j] and i < j. Parameters: arr (list): List of integers Returns: int: Number of good pairs from collections import Counter count = Counter(arr) good_pairs = 0 for val in count.values(): if val > 1: good_pairs += (val * (val - 1)) // 2 return good_pairs"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `x`. Your goal is to find the smallest length of a subarray that has a sum greater than or equal to `x`. If there is no such subarray, return `-1`. A **subarray** is a contiguous part of the array. Additionally, you must accomplish this with an algorithm that has a time complexity better than O(n^2), where n is the length of the array.","solution":"def smallest_subarray_with_sum_at_least_x(nums, x): n = len(nums) min_length = float(\'inf\') curr_sum = 0 start = 0 for end in range(n): curr_sum += nums[end] while curr_sum >= x: min_length = min(min_length, end - start + 1) curr_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. Your task is to reverse the array so that the last element becomes the first and the first element becomes the last. However, you are only allowed to use a temporary variable for swapping elements. Implement a function that performs this operation. Return the modified array after reversal.","solution":"def reverse_array(nums): Reverses the given array in place using only a temporary variable for swapping. Parameters: nums (list of int): A list of integers. Returns: list of int: The reversed list of integers. n = len(nums) for i in range(n // 2): # Perform the swap using a temporary variable temp = nums[i] nums[i] = nums[n - 1 - i] nums[n - 1 - i] = temp return nums"},{"question":"Given an array of integers `heights` representing the heights of buildings, where `heights[i]` is the height of the `i-th` building, find the number of buildings that have an unobstructed view to the west. A building has an unobstructed view to the west if it is taller than all the buildings to its left.","solution":"def count_buildings_with_west_view(heights): Returns the number of buildings with unobstructed view to the west. :param heights: List of integers representing the heights of buildings. :return: Integer count of buildings with unobstructed view to the west. count = 0 max_height_so_far = 0 for height in heights: if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"Given a **linked list**, rotate the list to the right by `k` places, where `k` is a non-negative integer. A **linked list** is a linear collection of data elements, in which the linear order is not given by their physical placement in memory. Instead, each point in the linked list consists of a data element and a reference (link) to the next element in the sequence. The function should return the new head of the rotated linked list. For example, given the linked list: `1 -> 2 -> 3 -> 4 -> 5` and `k = 2`, the resulting linked list after rotation would be `4 -> 5 -> 1 -> 2 -> 3`. **Note**: 1. `k` is guaranteed to be less than the length of the linked list. 2. The input linked list may be empty, and in such cases, the function should return `null`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or k == 0: return head # Find the length of the linked list length = 1 current = head while current.next: current = current.next length += 1 # Make the list circular current.next = head # Find the point to break the list k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"You are given an integer array `heights` representing the heights of buildings in a row. An individual standing on top of a building can see the building to their right if the building is shorter. A building is considered visible from the left if there are no taller buildings blocking it. Write a function to count the number of buildings that are visible when looking from the left (i.e., from the start of the array to the end). Return the count of visible buildings.","solution":"def count_visible_buildings(heights): Counts the number of buildings visible when looking from the left. Parameters: heights (list): List of integers representing heights of buildings. Returns: int: Count of visible buildings. if not heights: return 0 max_height = heights[0] visible_count = 1 for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given two strings `s` and `t` of the same length. The strings represent two binary numbers, where each character in the strings is either \'0\' or \'1\'. You need to determine the minimum number of bit flips required to make the two strings identical. A bit flip involves changing a \'0\' to \'1\' or a \'1\' to \'0\'. Return the minimum number of bit flips required to make the string `s` equal to string `t`.","solution":"def min_bit_flips(s, t): Given two binary strings s and t of the same length, returns the minimum number of bit flips required to make s equal to t. if len(s) != len(t): raise ValueError(\\"Strings must be of the same length\\") bit_flips = 0 for bit_s, bit_t in zip(s, t): if bit_s != bit_t: bit_flips += 1 return bit_flips"},{"question":"You are given a string `s` and an integer `k`. You need to perform at most `k` operations to convert the string into a palindrome. In one operation, you can replace any character in the string with any other character. Return _the minimum number of operations required to make the string a palindrome_. If it is not possible to convert the string into a palindrome within `k` operations, return `-1`. A **palindrome** is a string that reads the same forward and backward.","solution":"def min_operations_to_palindrome(s, k): Returns the minimum number of operations required to make the string a palindrome. If it is not possible within k operations, returns -1. Parameters: s (str): input string k (int): maximum number of allowed operations Returns: int: minimum number of operations to make the string a palindrome or -1 if not possible n = len(s) # Find initial number of mismatch pairs mismatch_count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: mismatch_count += 1 # If the required number of changes to make a palindrome is more than k, return -1 if mismatch_count > k: return -1 return mismatch_count"},{"question":"You are given a string `s` consisting of lowercase English letters and a string `t` consisting of lowercase English letters. Your task is to form a new string by removing characters from `s` such that the new string is an anagram of `t`. If it is not possible to form such a string, return `\\"-1\\"`. An anagram of a string `t` is another string that contains the same characters, only the order of characters can be different. Return _the minimum number of characters you need to remove from `s` to make it an anagram of `t` or `\\"-1\\"` if it is impossible_.","solution":"from collections import Counter def min_removals_to_make_anagram(s, t): Returns the minimum number of characters to remove from `s` to make it an anagram of `t`. If it is impossible to form such a string, return \\"-1\\". count_s = Counter(s) count_t = Counter(t) # If there are any characters in t not in s, it\'s impossible to form an anagram of t from s for char in count_t: if count_t[char] > count_s[char]: return \\"-1\\" # Calculate the minimum number of deletions required removals = 0 for char in count_s: if count_s[char] > count_t[char]: removals += count_s[char] - count_t[char] return removals"},{"question":"You are given a `matrix` of `m x n` integers. Your task is to find a submatrix such that the sum of the elements within this submatrix is the largest possible. The submatrix must contain at least one element. Return _the sum of the elements in this submatrix_.","solution":"def max_sum_submatrix(matrix): def max_sum_subarray(arr): max_sum = arr[0] current_sum = arr[0] for x in arr[1:]: current_sum = max(x, current_sum + x) max_sum = max(max_sum, current_sum) return max_sum if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') for left in range(cols): temp = [0] * rows for right in range(left, cols): for i in range(rows): temp[i] += matrix[i][right] max_sum = max(max_sum, max_sum_subarray(temp)) return max_sum"},{"question":"You are given a list of integers `nums`, where each integer represents the height of a vertical line drawn at that position. Suppose these lines together form a container, with the width between two lines being the difference of their indices and the height being the shorter of the two lines. Write a function that finds the two lines which together with the x-axis forms a container that holds the most water. Return the maximum amount of water it can hold. The function should return the maximum area which can be achieved from any pair of lines.","solution":"def max_area(nums): Returns the maximum amount of water that can be contained between two lines. max_water = 0 left, right = 0, len(nums) - 1 while left < right: # Calculate the area with the current pair of lines height = min(nums[left], nums[right]) width = right - left current_area = height * width max_water = max(max_water, current_area) # Move the pointers if nums[left] < nums[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given an integer array `nums` representing the number of stones in each pile. In each turn, you and your friend take turns to remove stones from a single pile. The player who removes the last stone wins the game. You start first. Return `true` if you can guarantee a win, assuming both you and your friend play optimally, otherwise return `false`.","solution":"def can_win_nim(nums): Returns True if the starting player can guarantee a win, otherwise False. Assumes both players play optimally. # If the total number of stones is not a multiple of 4, you will always win # Otherwise, you will always lose if your opponent plays optimally. total_stones = sum(nums) return total_stones % 4 != 0"},{"question":"You are given a **0-indexed** integer array `nums` representing the number of orders placed by customers in a store at different times of the day. Your task is to determine the **maximum length of a contiguous subarray** where every element appears at least `k` times. Return an integer representing the length of the longest subarray. If no such subarray exists, return 0.","solution":"def longest_subarray_with_at_least_k(nums, k): def at_least_k_in_subarray(subarr, k): from collections import Counter counter = Counter(subarr) return all(count >= k for count in counter.values()) max_len = 0 for start in range(len(nums)): for end in range(start, len(nums)): if at_least_k_in_subarray(nums[start:end+1], k): max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given a binary tree, return the maximum sum of any path from one leaf node to another leaf node. A path is defined as any sequence of nodes from some starting node to any destination node in the tree along the parent-child connections. The path must contain at least two nodes (i.e., it cannot be empty). Each node contains an integer value, and the sum of a path is the sum of the values of nodes in the path. If no such path exists, return 0.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSumLeafToLeaf(root): Returns the maximum sum of any path from one leaf node to another leaf node. def dfs(node): nonlocal max_sum if not node: return 0 if not node.left and not node.right: return node.val left_sum = dfs(node.left) if node.left else float(\'-inf\') right_sum = dfs(node.right) if node.right else float(\'-inf\') if node.left and node.right: max_sum = max(max_sum, left_sum + right_sum + node.val) return max(left_sum, right_sum) + node.val return left_sum + node.val if node.left else right_sum + node.val if not root: return 0 max_sum = float(\'-inf\') result = dfs(root) return max_sum if max_sum != float(\'-inf\') else 0"},{"question":"Write a function `findSubstring` that takes in two strings, `s` and `words`. The `words` array is a list of strings, with all strings of the same length. Return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once, in any order, and without any intervening characters. # Example: ```python Input: s = \\"barfoothefoobarman\\", words = [\\"foo\\",\\"bar\\"] Output: [0,9] Input: s = \\"wordgoodgoodgoodbestword\\", words = [\\"word\\",\\"good\\",\\"best\\",\\"word\\"] Output: [] ```","solution":"def findSubstring(s, words): from collections import Counter if not s or not words: return [] word_len = len(words[0]) concat_len = word_len * len(words) words_count = Counter(words) result = [] for i in range(len(s) - concat_len + 1): seen_words = s[i:i + concat_len] words_seen = [seen_words[j:j + word_len] for j in range(0, concat_len, word_len)] if Counter(words_seen) == words_count: result.append(i) return result"},{"question":"You are given an array of integers `nums` where `nums[i]` represents the value of the i-th element and an integer `k`. Implement the `SlidingWindowMedian` class: * `SlidingWindowMedian(int k)` initializes the median finder with an empty sliding window of size `k`. * `void insert(int val)` inserts an integer `val` into the sliding window. * `double findMedian()` returns the median of all integers in the sliding window. The median is the middle value in an ordered set of values. If the set has an even number of values, the median is the average of the two middle values. Your task is to ensure that once the number of inserted values exceeds `k`, the oldest values are removed to maintain the window size of `k`.","solution":"import bisect class SlidingWindowMedian: def __init__(self, k): self.k = k self.window = [] def insert(self, val): Inserts an integer `val` into the sliding window. If the number of inserted values exceed `k`, the oldest values are removed. if len(self.window) == self.k: self.window.pop(0) # Remove the oldest value bisect.insort(self.window, val) # Insert value while keeping the list sorted def findMedian(self): Returns the median of all integers in the sliding window. n = len(self.window) if n % 2 == 1: return float(self.window[n // 2]) else: return (self.window[n // 2 - 1] + self.window[n // 2]) / 2.0"},{"question":"Given an array of integers `arr` and an integer `k`, you need to construct a new array `result` where each element at index `i` of `result` is the sum of the elements at indices `i` to `i + k - 1` in the original array. If there are fewer than `k` elements remaining at any position `i`, sum all the elements from `i` to the end of the array. Return the `result` array containing these sums.","solution":"def construct_sums(arr, k): Constructs a new array where each element at index i is the sum of the elements at indices i to i + k - 1 in the original array. If there are fewer than k elements remaining, sum all the elements from i to the end of the array. Parameters: arr (list of int): The original array of integers k (int): The number of elements to sum Returns: list of int: The resultant array containing the sums result = [] n = len(arr) for i in range(n): sum_value = sum(arr[i:i+k]) result.append(sum_value) return result"},{"question":"You are given a **linked list** where each node contains a single digit. The digits are stored in **reverse** order, and each of their non-negative integers does not contain any leading zero, except the number 0 itself. Write a function to add two such numbers and return the sum as a linked list in the same reverse order format. The input linked lists both represent non-negative integers. The function should handle cases where the sum results in a carry that extends beyond the length of the longer input list. Example: Given the following linked lists: ``` 2 -> 4 -> 3 // represents 342 5 -> 6 -> 4 // represents 465 ``` Return: ``` 7 -> 0 -> 8 // represents 807 ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Add two numbers represented by linked lists in reverse order. dummy = ListNode(0) p = dummy carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 new_val = total % 10 p.next = ListNode(new_val) p = p.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy.next"},{"question":"Given a `n`-ary tree, find the maximum depth of the tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. An `n`-ary tree is a tree in which a node can have at most `n` children. Each node is represented as a Node object with a `val` (value of the node) and a `children` (list of child nodes) property. Return _the maximum depth of the tree_. The provided `Node` class is defined as follows: ``` class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] ```","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def max_depth(root): if root is None: return 0 if not root.children: return 1 return 1 + max(max_depth(child) for child in root.children)"},{"question":"You are given an unsorted integer array `nums` with duplicate elements allowed. Your task is to output the length of the longest subsequence that can be found in which the elements are consecutive integers. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The consecutive elements in the subsequence must have a difference of exactly 1 between each pair. Return _the length of the longest consecutive elements subsequence_.","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest consecutive elements subsequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # only check for the start of a streak if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Given a sorted array of `n` distinct integers, write a function that finds if there exists a pair of elements with a given difference `k`. The function should return `True` if such a pair exists and `False` otherwise. Note that the array is sorted in ascending order and the pair elements must be distinct.","solution":"def has_pair_with_difference(arr, k): Determines if there are two distinct elements in the sorted array `arr` with a difference of `k`. Parameters: arr (list): A sorted list of distinct integers. k (int): The target difference. Returns: bool: True if a pair exists with the difference `k` else False. left = 0 right = 1 while right < len(arr): diff = arr[right] - arr[left] if diff == k: return True elif diff < k: right += 1 else: left += 1 if left == right: right += 1 return False"},{"question":"You are given an array `arr` of integers, and an integer `threshold`. You can perform the following operation on `arr` as many times as needed: choose any sub-array of length `k` (where `k` is any integer between 2 and length of `arr` inclusive) and increment each element of the sub-array by 1. Return the minimum number of operations required to make all elements of `arr` at least `threshold`.","solution":"def min_operations(arr, threshold): Returns the minimum number of operations required to make all elements of arr at least threshold. Parameters: arr (list of int): The input array of integers. threshold (int): The target threshold value. Returns: int: The minimum number of operations. min_element = min(arr) operations = 0 # Calculate the difference between the threshold and the minimum element in arr if min_element < threshold: operations = threshold - min_element return operations"},{"question":"You are given a binary tree where each node contains an integer value. Write an algorithm to find the sum of the node values at each level of the binary tree and return the results in an array where the i-th element is the sum of the node values at the i-th level. The root is at level 0, its children are at level 1, and so on.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_sums(root): Given the root of a binary tree, returns an array where the i-th element is the sum of the node values at the i-th level. if not root: return [] result = [] queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.value if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"Given a list of non-negative integers `nums`, you are tasked to find the maximum product you can obtain by multiplying two different elements from the list. Return the maximum product you can get.","solution":"def max_product(nums): Returns the maximum product obtained by multiplying two different elements from the list nums. if len(nums) < 2: return 0 nums.sort() return nums[-1] * nums[-2]"},{"question":"You are given a list of integers representing the heights of people standing in a queue. Each person must stand in a particular position based on their height and the number of people in front of them who have a height greater than or equal to their own. The list of people is represented as an array of tuples `(h, k)`, where `h` is the height of the person and `k` is the number of people in front of this person with a height greater than or equal to `h`. Reconstruct and return the queue that satisfies these conditions, such that the people are positioned correctly according to their respective `(h, k)` values. For example, given the list of people `[(7, 0), (4, 4), (7, 1), (5, 0), (6, 1), (5, 2)]`, the reconstructed queue is `[(5, 0), (7, 0), (5, 2), (6, 1), (4, 4), (7, 1)]`.","solution":"def reconstructQueue(people): Reconstructs the queue based on the given list of people. Args: people (list of tuples): A list of tuples where each tuple contains two integers (h, k). Returns: list of tuples: The reconstructed queue. # Sort people based on height in descending order. # For people with the same height, sort based on k in ascending order. people.sort(key=lambda x: (-x[0], x[1])) queue = [] # Insert each person at the index specified by k for person in people: queue.insert(person[1], person) return queue"},{"question":"You are given a linked list where each node contains an additional random pointer which could point to any node in the list or null. Write a function to create a deep copy of the list. The function should return the head of the copied linked list. The linked list is defined as follows: ```python class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random ```","solution":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head): if not head: return None # Step 1: Create duplicate nodes next to original nodes iter = head while iter: next_node = iter.next copy_node = Node(iter.val) iter.next = copy_node copy_node.next = next_node iter = next_node # Step 2: Assign random pointers to the duplicate nodes iter = head while iter: if iter.random: iter.next.random = iter.random.next iter = iter.next.next # Step 3: Restore the original list and extract the copied nodes iter = head copy_head = head.next while iter: copy_node = iter.next iter.next = copy_node.next if copy_node.next: copy_node.next = copy_node.next.next iter = iter.next return copy_head"},{"question":"Write a function that accepts a list of integers `numbers` and an integer `target`. Your task is to determine if there exist three distinct elements in `numbers` whose sum is equal to `target`. Return `True` if such a triplet exists, otherwise return `False`.","solution":"def three_sum(numbers, target): Determines if there exist three distinct elements in numbers that sum up to target. Args: numbers (list of int): List of integers to check. target (int): The target sum. Returns: bool: True if such a triplet exists, otherwise False. numbers.sort() n = len(numbers) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = numbers[i] + numbers[left] + numbers[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` consisting of uppercase English letters (A-Z). A substring can be formed by deleting some (possibly zero) characters from `s` without changing the order of the remaining characters. Determine the length of the shortest substring that contains all the unique characters of the input string `s`.","solution":"def shortest_unique_char_substring_length(s): Determines the length of the shortest substring that contains all unique characters of the input string `s`. :param s: A string consisting of uppercase English letters :return: Length of the shortest substring containing all unique characters in `s` # Edge Case: if input string is empty if not s: return 0 unique_chars = set(s) required_char_count = len(unique_chars) left = 0 min_length = len(s) + 1 char_frequency = {} unique_count = 0 for right in range(len(s)): char = s[right] if char not in char_frequency: char_frequency[char] = 0 char_frequency[char] += 1 if char_frequency[char] == 1: unique_count += 1 while unique_count == required_char_count: min_length = min(min_length, right - left + 1) left_char = s[left] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: unique_count -= 1 left += 1 return min_length if min_length != len(s) + 1 else 0"},{"question":"You are given two strings `s` and `t` of lengths `m` and `n` respectively. Write a function that determines whether `t` is an anagram of any subsequence of `s`. A subsequence of `s` is derived by deleting some or no elements from `s` without changing the order of the remaining elements. Return `true` if `t` is an anagram of any subsequence of `s`, otherwise, return `false`.","solution":"from collections import Counter def is_anagram_of_subsequence(s, t): Determine if t is an anagram of any subsequence of s. counter_s = Counter(s) counter_t = Counter(t) for char in counter_t: if counter_t[char] > counter_s.get(char, 0): return False return True"},{"question":"You are given a 0-indexed array of strings `langs` representing the order in which a series of programming languages are introduced in a bootcamp. Each string in `langs` contains the name of a programming language and might contain duplicates. You are also given a list of tuples `reqs`, where each tuple `(a, b)` indicates that learning language `a` is a prerequisite for learning language `b`. Return _the order in which the programming languages should be learned to satisfy all the prerequisites_. If there are multiple valid orders, return any of them. If no valid order exists, return an empty list.","solution":"from collections import deque, defaultdict def find_order(langs, reqs): Returns the order in which the programming languages should be learned to satisfy all the prerequisites, or an empty list if no valid order exists. # Create adjacency list for the graph and in-degree counter adj_list = defaultdict(list) in_degree = {lang: 0 for lang in langs} # Build the graph for pre, nxt in reqs: adj_list[pre].append(nxt) in_degree[nxt] += 1 # Initialize the queue with nodes having in-degree of 0 queue = deque([lang for lang in langs if in_degree[lang] == 0]) order = [] while queue: lang = queue.popleft() order.append(lang) for neighbor in adj_list[lang]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == len(langs): return order else: return []"},{"question":"You are given a list of `n` courses titled `courseList` and a list of lists called `prerequisites` where `prerequisites[i]` is a pair `[a, b]` which indicates that course `b` needs to be completed before course `a`. Determine the minimum number of courses you must complete in order to be able to take any of the `n` courses. If it is impossible to take all courses due to cyclic prerequisites, return `-1` instead.","solution":"def find_min_courses(courseList, prerequisites): from collections import defaultdict, deque # Map to store each course\'s prerequisites pre_map = defaultdict(set) # Map to store each course that is a prerequisite for other courses post_map = defaultdict(set) for a, b in prerequisites: pre_map[a].add(b) post_map[b].add(a) # Compute the in-degree for each course in_degree = {course: 0 for course in courseList} for course in pre_map: for pre in pre_map[course]: in_degree[course] += 1 # Initialize a queue with courses that have no prerequisites queue = deque([course for course in courseList if in_degree[course] == 0]) completed_courses = 0 while queue: course = queue.popleft() completed_courses += 1 # For each course that the current course is a prerequisite for for dependent_course in post_map[course]: in_degree[dependent_course] -= 1 if in_degree[dependent_course] == 0: queue.append(dependent_course) # Check if all courses are processed if completed_courses == len(courseList): return completed_courses else: return -1"},{"question":"You are given a read-only **0-indexed** array `nums` containing `n` integers sorted in non-decreasing order. You need to determine if there exists a pair of indices `(i, j)` such that `i < j` and `nums[i] + nums[j] > nums[k]` for some `k` where `k` is any index in the range `[0, n-1]` excluding `i` and `j`. If such a pair exists, return `true`; otherwise, return `false`. Optimize your algorithm to run in linear time, if possible.","solution":"def exists_pair(nums): Determine if there exists a pair of indices (i, j) such that i < j and nums[i] + nums[j] > nums[k] for some k where k is any index in the range [0, n-1] excluding i and j. # The minimum number of elements to find such a pair is 3 if len(nums) < 3: return False for i in range(len(nums) - 1): if nums[i] + nums[i + 1] > nums[-1]: return True return False"},{"question":"Given a list of integers `nums`, return _the index of all the unique elements_ in the list. If there are no unique elements, return an empty list. An element is considered unique if it appears exactly once in the list. The order of the returned indices should be in ascending order.","solution":"def get_unique_indices(nums): Returns the indices of all the unique elements in the list `nums`. If there are no unique elements, returns an empty list. from collections import Counter count = Counter(nums) unique_indices = [i for i, num in enumerate(nums) if count[num] == 1] return sorted(unique_indices)"},{"question":"You are given a list of strings `patterns` and a string `s`. A pattern is considered a prefix of `s` if it matches the beginning of `s` up to the length of the pattern. Return _a list of all patterns from_ `patterns` _that are prefixes of_ `s`. Note that the returned list should be sorted in lexicographical order.","solution":"def find_prefix_patterns(patterns, s): Returns a list of all patterns from \'patterns\' that are prefixes of \'s\', sorted lexicographically. :param patterns: List of strings :param s: String :return: List of strings prefix_patterns = [pattern for pattern in patterns if s.startswith(pattern)] return sorted(prefix_patterns)"},{"question":"You are given a binary tree represented as a list of node values in level-order traversal where `null` represents a missing node. Write a function that returns the sum of all the elements in the binary tree. The binary tree might contain negative values. The input list always represents a complete binary tree.","solution":"def sum_of_binary_tree(nodes): Calculate the sum of all the elements in the binary tree. Parameters: nodes (list): A list of node values in level-order traversal, where `None` represents a missing node. Returns: int: The sum of all the elements in the binary tree. return sum(node for node in nodes if node is not None)"},{"question":"Given an integer array `arr`, return _the number of **distinct** triplets `(i, j, k)` such that_ `0 <= i < j < k < arr.length` _and_ `arr[i] + arr[j] + arr[k]` _is equal to a given integer `target`._","solution":"def count_distinct_triplets(arr, target): Returns the number of distinct triplets (i, j, k) such that 0 <= i < j < k < len(arr) and arr[i] + arr[j] + arr[k] == target n = len(arr) count = 0 for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if arr[i] + arr[j] + arr[k] == target: count += 1 return count"},{"question":"You are given an array of integers representing the heights of candle on a cake. Each candle can only be blown out if its height is not greater than the height of the previous candle you blew out. You can start blowing out any one candle. Return the maximum number of candles you can blow out consecutively in one go. For example, given the array `[4, 4, 4, 3, 2, 1, 3, 2]`, if you start blowing out the candle at index 4 (height 2), the sequence 2 -> 2 will allow you to blow out 2 candles consecutively.","solution":"def max_candles(candles): Returns the maximum number of candles you can blow out consecutively in one go. :param candles: List of integers representing the heights of the candles :return: Integer, maximum number of consecutive candles that can be blown out if not candles: return 0 max_count = 1 for start in range(len(candles)): count = 1 for i in range(start + 1, len(candles)): if candles[i] <= candles[i - 1]: count += 1 else: break max_count = max(max_count, count) return max_count"},{"question":"Implement a class `LFUCache` that represents a Least Frequently Used (LFU) cache system with fixed capacity. The `LFUCache` should support the following operations: - `LFUCache(int capacity)`: Initializes the LFU cache with a given capacity. - `int get(int key)`: Returns the value associated with the key if it exists in the cache. Otherwise, returns `-1`. Every call to this method updates the usage frequency of the key. - `void put(int key, int value)`: Updates or inserts the value associated with the key. If the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. If there is a tie in frequency, the least recently used item should be invalidated. Your solution should ensure that both `get` and `put` operations are performed in O(1) time complexity.","solution":"from collections import defaultdict, OrderedDict class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.minFreq = 0 self.freq = defaultdict(OrderedDict) self.keyVal = {} self.keyFreq = {} def _update(self, key, value=None): freq = self.keyFreq[key] self.freq[freq].pop(key) if not self.freq[freq]: del self.freq[freq] if self.minFreq == freq: self.minFreq += 1 if value is not None: self.keyVal[key] = value self.keyFreq[key] += 1 self.freq[self.keyFreq[key]][key] = self.keyVal[key] def get(self, key: int) -> int: if key not in self.keyVal: return -1 self._update(key) return self.keyVal[key] def put(self, key: int, value: int) -> None: if self.capacity == 0: return if key in self.keyVal: self._update(key, value) else: if len(self.keyVal) >= self.capacity: k, _ = self.freq[self.minFreq].popitem(last=False) del self.keyVal[k] del self.keyFreq[k] self.keyVal[key] = value self.keyFreq[key] = 1 self.minFreq = 1 self.freq[1][key] = value"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. A **substring** of `s` is called **unique** if no two characters in the substring are the same. Return _the length of the **longest** unique substring of `s` that contains exactly `k` distinct characters_. If no such substring exists, return `-1`.","solution":"def longest_unique_substring_with_k_distinct(s, k): Returns the length of the longest unique substring of `s` that contains exactly `k` distinct characters. If no such substring exists, return -1. n = len(s) if k == 0 or n == 0: return -1 max_len = -1 left = 0 char_count = {} for right in range(n): char = s[right] char_count[char] = char_count.get(char, 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == k: max_len = max(max_len, right - left + 1) return max_len"},{"question":"Implement a class `WordDictionary` that supports two operations: - `addWord(word)`: Adds a word to the dictionary. - `search(word)`: Returns `true` if there is any string in the dictionary that matches `word` or `false` otherwise. A word could contain the dot character `\'.\'` to represent any one letter. **Example:** ``` addWord(\\"bad\\") addWord(\\"dad\\") addWord(\\"mad\\") search(\\"pad\\") -> false search(\\"bad\\") -> true search(\\".ad\\") -> true search(\\"b..\\") -> true ```","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word): self.words.append(word) def search(self, word): import re pattern = re.compile(\'^\' + word + \'\') for w in self.words: if pattern.match(w): return True return False"},{"question":"You are given a list of integers `arr` and an integer `targetSum`. Your task is to determine if there are two distinct indices `i` and `j` in the array such that `arr[i] + arr[j] == targetSum`. Return `true` if such a pair exists, otherwise return `false`.","solution":"def has_pair_with_sum(arr, targetSum): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] == targetSum. :param arr: List of integers :param targetSum: Target sum to find within the array :return: True if there exists such a pair, False otherwise seen_numbers = set() for num in arr: if targetSum - num in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"You are given two arrays, `arr1` and `arr2`, both of which contain integers in non-decreasing order. Your task is to find a pair `(i, j)` such that `arr1[i] + arr2[j]` is the smallest possible sum, and return this pair. If there are multiple pairs with the same minimum sum, return the one with the smallest `i`. If there is still a tie, return the pair with the smallest `j`.","solution":"def smallest_pair(arr1, arr2): Returns the pair (i, j) such that arr1[i] + arr2[j] is the smallest possible sum. If there are multiple pairs with the same minimum sum, return the one with the smallest i. If there is still a tie, return the pair with the smallest j. if not arr1 or not arr2: return None min_sum = float(\'inf\') min_pair = (-1, -1) for i in range(len(arr1)): for j in range(len(arr2)): current_sum = arr1[i] + arr2[j] if current_sum < min_sum or (current_sum == min_sum and i < min_pair[0]) or (current_sum == min_sum and i == min_pair[0] and j < min_pair[1]): min_sum = current_sum min_pair = (i, j) return min_pair"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to implement a class `KthLargest` that finds the `k-th` largest element in a stream. The class should have the following methods: * `KthLargest(int k, int[] nums)` - Initializes the `KthLargest` object with the integer `k` and the stream of integers `nums`. * `int add(int val)` - Adds the integer `val` to the stream and returns the k-th largest element in the stream.","solution":"import heapq class KthLargest: def __init__(self, k: int, nums: list): self.k = k self.min_heap = nums heapq.heapify(self.min_heap) while len(self.min_heap) > self.k: heapq.heappop(self.min_heap) def add(self, val: int) -> int: if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, val) elif val > self.min_heap[0]: heapq.heapreplace(self.min_heap, val) return self.min_heap[0]"},{"question":"Given a string `s` and an integer `k`, write a function to determine if you can form a palindrome by removing no more than `k` characters from `s`. Return `True` if it is possible to form a palindrome under the given conditions, or `False` otherwise.","solution":"def can_form_palindrome(s, k): Determine if you can form a palindrome by removing no more than k characters from s. def is_palindrome_range(start, end, k, memo): if k < 0: return False if (start, end, k) in memo: return memo[(start, end, k)] while start < end and s[start] == s[end]: start += 1 end -= 1 if start >= end: return True without_start = is_palindrome_range(start + 1, end, k - 1, memo) without_end = is_palindrome_range(start, end - 1, k - 1, memo) memo[(start, end, k)] = without_start or without_end return memo[(start, end, k)] return is_palindrome_range(0, len(s) - 1, k, {})"},{"question":"Given a string `s` consisting of only lowercase letters, find the length of the longest substring with distinct characters. Implement a function `int longestDistinctSubstringLength(string s)` that returns the length of the longest substring with all distinct characters. A substring is defined as a sequence of characters within a string that are adjacent and in the same order as they appear in the string.","solution":"def longestDistinctSubstringLength(s): Returns the length of the longest substring with all distinct characters. :param s: A string consisting of only lowercase letters. :return: An integer representing the length of the longest substring with all distinct characters. last_seen = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in last_seen and last_seen[char] >= start: start = last_seen[char] + 1 last_seen[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a `string` `s` consisting of lowercase English letters and an integer `k`. You need to select `k` characters from the string `s` such that the selected characters form the lexicographically smallest possible substring of length `k`. Return this substring. Note that the characters selected must maintain their relative order as they appear in `s`.","solution":"def lexicographically_smallest_subsequence(s, k): Returns the lexicographically smallest subsequence of length k from the string s. stack = [] to_remove = len(s) - k for char in s: while stack and to_remove > 0 and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) # The stack may be larger than k due to the initial fills return \'\'.join(stack[:k])"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house in a row. Each house is connected to the next house in the row. There are a number of robbers facing this row who want to rob the houses, but they cannot rob two adjacent houses since it will set off the alarm. Determine the maximum amount of money the robbers can rob without triggering the alarm and return that maximum amount.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without triggering the alarm. :param nums: List[int] - List of non-negative integers representing the amount of money of each house. :return: int - Maximum amount of money that can be robbed. if not nums: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums[0], nums[1]) prev2 = nums[0] prev1 = max(nums[0], nums[1]) for i in range(2, len(nums)): current = max(prev1, prev2 + nums[i]) prev2, prev1 = prev1, current return prev1"},{"question":"You are given an array of integers `items` where the `i-th` element represents the number of items of type `i` available. You need to process a sequence of operations represented by another array `operations`, where each element is a tuple `(type, order)`. The `type` is either `0` or `1`, and `order` is an integer: - If `type` is `0`, it means an order to add `order` number of items of the corresponding type to the inventory. - If `type` is `1`, it means an order to remove `order` number of items of the corresponding type from the inventory. If there are not enough items of that type, remove all available items. Return the final state of the inventory after processing all operations.","solution":"def process_inventory(items, operations): Process a sequence of operations on the inventory. Parameters: items (list of int): List where the i-th element represents the number of items of type i. operations (list of tuples): Each tuple contains (type, order). - `type` is 0 to add items or 1 to remove items. - `order` is the number of items to add/remove of the corresponding type. Returns: list of int: Final state of the inventory after processing all operations. for operation in operations: type, order = operation if type == 0: items[order[0]] += order[1] elif type == 1: items[order[0]] = max(0, items[order[0]] - order[1]) return items"},{"question":"You are given a list of `n` integers representing the temperatures recorded over a period of `n` days. Your task is to implement a function that processes this list and returns the number of days (i) such that the temperature on day (i) is strictly higher than the temperature on each of the previous `k` days, where `k` is a given integer (1 ≤ `k` ≤ `n`). If a day (i) does not have `k` previous days, it should not be considered. Implement the function `count_high_temperature_days(temperatures, k)` to accomplish this.","solution":"def count_high_temperature_days(temperatures, k): Counts the number of days such that the temperature on day i is strictly higher than the temperature on each of the previous k days. :param temperatures: List[int], list of daily temperatures. :param k: int, number of previous days to compare with. :return: int, number of days meeting the criteria. count = 0 n = len(temperatures) for i in range(k, n): if all(temperatures[i] > temperatures[j] for j in range(i - k, i)): count += 1 return count"},{"question":"Implement a function `findLongestConsecutiveSubsequence(nums: List[int]) -> int` that takes an unsorted list of integers `nums` as input and returns the length of the longest consecutive subsequence. A consecutive subsequence consists of numbers that can be arranged to form an increasing sequence where each element is exactly one more than the previous element. **Example:** ```python nums = [100, 4, 200, 1, 3, 2] findLongestConsecutiveSubsequence(nums) # Returns: 4 (because the longest consecutive subsequence is [1, 2, 3, 4]) ``` **Notes:** - Your solution should have a time complexity better than O(n^2). - The function should handle edge cases such as an empty list or a list with one element.","solution":"def findLongestConsecutiveSubsequence(nums): Returns the length of the longest consecutive subsequence in the list nums. Parameters: nums (List[int]): List of integers. Returns: int: Length of the longest consecutive subsequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Only start counting if num is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a list of words `words` and an integer `n`. A **palindrome** is a word that reads the same forward and backward. Write a function that returns the `n` longest palindromic words in `words`. If there are fewer than `n` palindromic words, return all of them. If there are multiple words of the same length, return them in the order they appear in the list `words`.","solution":"def n_longest_palindromic_words(words, n): Returns the n longest palindromic words from the given list of words. If there are fewer than n palindromic words, all of them are returned. def is_palindrome(word): return word == word[::-1] palindromic_words = [word for word in words if is_palindrome(word)] palindromic_words.sort(key=len, reverse=True) return palindromic_words[:n]"},{"question":"You are given a list of `n` buildings represented by a list of integers `heights`, where `heights[i]` is the height of the `i-th` building. Some of the buildings have already been painted, and some have not. You are also given a list `painted` of the same length as `heights`. If `painted[i]` equals `1`, the `i-th` building is painted; if it equals `0`, it is not painted. You want to paint all the buildings such that the color of one building cannot be the same as any of its adjacent buildings. Return _the minimum number of different colors needed to paint all the buildings_.","solution":"def min_colors_to_paint(heights, painted): Calculate the minimum number of different colors needed to paint all the buildings such that the color of one building cannot be the same as any of its adjacent buildings. n = len(heights) # If no buildings are to be painted, return 0 colors needed if n == 0: return 0 # Helper function to get available color that is not used by neighbors def get_available_color(i, current_assignment): neighbor_colors = set() if i > 0 and current_assignment[i-1] != 0: neighbor_colors.add(current_assignment[i-1]) if i < n-1 and current_assignment[i+1] != 0: neighbor_colors.add(current_assignment[i+1]) color = 1 while color in neighbor_colors: color += 1 return color # Assign colors to all buildings color_assignment = [0] * n for i in range(n): if painted[i] == 0: color_assignment[i] = get_available_color(i, color_assignment) else: color_assignment[i] = painted[i] # Return the maximum color used, i.e., the number of different colors needed return max(color_assignment)"},{"question":"You are given an array `nums` of integers where each integer represents the number of people who have a unique integer ID and all integers are unique. Each person indicates two people as their friends. The identifiers of these two friends are given as pair arrays `friends`. Each ID only appears at most once as a friend. Determine the identifier of the most popular person who has the most friends. If there is a tie, return the smallest identifier. For example, if `nums` is `[1, 2, 3, 4]` and the pairs of friends are `[[1, 2], [2, 3], [3, 4], [4, 1]]`, the most popular person would be `1`. Write a function: ```python def most_popular_id(nums: List[int], friends: List[List[int]]) -> int: ``` that returns the identifier of the most popular person.","solution":"from typing import List from collections import defaultdict def most_popular_id(nums: List[int], friends: List[List[int]]) -> int: # Create a dictionary to count the number of friends each person ID has friend_count = defaultdict(int) # Iterate over each friend pair and increment the count for each person for friend1, friend2 in friends: friend_count[friend1] += 1 friend_count[friend2] += 1 # Initialize the most popular person ID and the count of friends most_popular = None max_friends = -1 # Iterate over each person in nums to determine the most popular person for person in nums: count = friend_count[person] # Check if current person has more friends or if it is a tie with a smaller identifier if count > max_friends or (count == max_friends and (most_popular is None or person < most_popular)): most_popular = person max_friends = count return most_popular"},{"question":"Write a function that takes two strings `str1` and `str2` as inputs, each containing only lowercase letters. Your task is to find the **length of the longest common subsequence** of `str1` and `str2`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return _the length of the longest common subsequence_.","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence of str1 and str2. m, n = len(str1), len(str2) # Create a 2D array to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The last cell will have the length of longest common subsequence return dp[m][n]"},{"question":"Given an integer array `nums` of size `n`, where all elements are unique, return the minimum cost to make all elements equal. You can increment or decrement any element by `1` in one operation. The cost of an operation is defined as the absolute difference between the current value and the target value. For example, if `nums = [1, 2, 3]`, the minimum cost to make all elements equal is `2` because you can make all elements equal to `2` with a total cost of `|1-2| + |2-2| + |3-2| = 1 + 0 + 1 = 2`.","solution":"def min_cost_to_make_elements_equal(nums): Returns the minimum cost to make all elements in nums equal. The cost is defined as the sum of absolute differences between each element and the chosen target value. :param nums: List[int] - a list of integers :return: int - minimum cost to make all elements equal nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"Given an array of integers `arr` where each element `arr[i]` represents the amount of rainwater trapped on top of the block at index `i`, write a function to calculate the maximum amount of trapped rainwater given that the blocks form a histogram-like elevation map. The difference between the heights of adjacent blocks determines the amount of water that can be held between them. Return the total amount of rainwater trapped. Consider that the height of the blocks is non-negative and water cannot be trapped at the ends of the array.","solution":"def trap_rain_water(arr): Calculate the total amount of trapped rainwater given an array representing block heights. Parameters: arr (list of int): A list where each element represents the height of a block. Returns: int: Total amount of trapped rainwater. if not arr or len(arr) < 3: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) # Fill right_max array right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"Given an array of integers `num` of length `n`, where each integer is between `1` and `n` inclusive. Each integer appears exactly once except for one integer which appears twice and one integer which is missing. Find and return a list of two elements, where the first element is the integer that appears twice, and the second element is the integer that is missing.","solution":"def findErrorNums(nums): Return the duplicate and missing number in the list. Parameters: nums (List[int]): List of integers where one integer is missing and one is duplicated. Returns: List[int]: A list containing the duplicate and missing number respectively. n = len(nums) duplicate = -1 missing = -1 sum_set = sum(set(nums)) actual_sum = sum(nums) # Duplicate number is identified by the difference between actual_sum and the sum of set nums duplicate = actual_sum - sum_set # Missing number is identified by the difference between the performed sum n*(n+1)//2 and sum_set. missing = (n * (n + 1) // 2) - sum_set return [duplicate, missing]"},{"question":"You are given a binary tree where each node contains a **positive integer** value, and each value is **unique**. Return _the **path** with the **maximum sum** from the root node to any leaf node_. The path must be represented as a list of node values in the order they appear in the tree. If there are multiple paths with the same maximum sum, return the path that appears **leftmost** in the tree. A **leaf node** is a node with no children.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_sum_path(root): def helper(node): if not node: return (0, []) if not node.left and not node.right: return (node.value, [node.value]) left_sum, left_path = helper(node.left) right_sum, right_path = helper(node.right) if left_sum >= right_sum: return (node.value + left_sum, [node.value] + left_path) else: return (node.value + right_sum, [node.value] + right_path) _, path = helper(root) return path"},{"question":"A **peak element** in an array is an element that is greater than its neighbors. Given an array `nums` of size `n`, find and return the index of a peak element. Note that the array may contain multiple peaks; in that case, return the index of any one of the peaks. * You may assume that `nums[-1]` and `nums[n]` are negative infinity. * You must write an algorithm that runs in `O(log n)` time. [Question] 4:","solution":"def findPeakElement(nums): Finds a peak element index in the array. A peak element is an element that is greater than its neighbors. The function runs in O(log n) time using a binary search approach. :param nums: List[int] - Input list of integers :return: int - The index of any peak element left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given an `m x n` grid where each cell can either be `0` (an empty cell) or `1` (a filled cell). Two cells are considered connected if they are adjacent to each other horizontally or vertically. Find the largest connected component in the grid where a component is formed by adjoining `1`s. Return the size of the largest connected component.","solution":"def largest_connected_component(grid): Returns the size of the largest connected component in the given grid where adjacent cells with value 1 are considered connected. :param grid: List[List[int]] - a 2D list representing the grid :return: int - size of the largest connected component if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): # Out of bounds or already visited or 0 cell if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] == 0: return 0 visited[x][y] = True size = 1 # Current cell is part of the component # Explore the four adjacent directions size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size max_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"Given a string `s` which contains only lowercase letters, and an integer `k`, you need to construct a new string by rearranging the letters of `s` such that the same letter is at least `k` distance apart. If it is not possible to rearrange the letters of `s` in this way, return an empty string. If multiple rearrangements are possible, return any one of them. Implement a function `rearrangeString(s, k)` that returns the rearranged string or an empty string if the rearrangement is not possible.","solution":"import heapq from collections import Counter, deque def rearrangeString(s, k): if k == 0: return s counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((freq + 1, char)) if len(queue) < k: continue front = queue.popleft() if front[0] < 0: heapq.heappush(max_heap, front) return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"Given a Tic-Tac-Toe board, determine if the game has been won or is still ongoing. The board is represented as a 3x3 matrix where the elements are either `\'X\'`, `\'O\'`, or `\'\'` (empty). The function should return: - `\'X\'` if player X has won - `\'O\'` if player O has won - `\'Draw\'` if there are no empty spaces and neither player has won - `\'Pending\'` if there are still moves left to be played and no player has won yet Implement the `TicTacToe` class with the following method: * `string checkBoard(String[][] board)` Analyzes the board state and returns one of the four possible outcomes (`\'X\'`, `\'O\'`, `\'Draw\'`, `\'Pending\'`).","solution":"class TicTacToe: def checkBoard(self, board): # Check rows and columns for a win for i in range(3): if board[i][0] == board[i][1] == board[i][2] != \'\': return board[i][0] if board[0][i] == board[1][i] == board[2][i] != \'\': return board[0][i] # Check diagonals for a win if board[0][0] == board[1][1] == board[2][2] != \'\': return board[0][0] if board[0][2] == board[1][1] == board[2][0] != \'\': return board[0][2] # Check for any remaining moves for row in board: if \'\' in row: return \'Pending\' return \'Draw\'"},{"question":"You are given a 2D binary matrix `grid` where `1` represents land and `0` represents water. An island is a maximal 4-directionally connected region of `1`s. Your task is to determine the number of distinct islands in the given grid. Two islands are considered distinct if one island cannot be translated (and not rotated or reflected) to equal the other. Return the _total number of distinct islands in the grid_.","solution":"def numDistinctIslands(grid): def dfs(x, y, origin, shape): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 shape.append((x - origin[0], y - origin[1])) dfs(x + 1, y, origin, shape) dfs(x - 1, y, origin, shape) dfs(x, y + 1, origin, shape) dfs(x, y - 1, origin, shape) distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, (i, j), shape) distinct_islands.add(tuple(shape)) return len(distinct_islands)"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring is called **homogeneous** if all the characters of the substring are the same. Return _the number of **non-empty homogeneous substrings** of_ `s`. Since the answer may be too large, return it **modulo** `10^9 + 7`.","solution":"def countHomogeneous(s): Returns the number of non-empty homogeneous substrings of `s`, modulo 10^9 + 7. MOD = 10**9 + 7 count = 0 length = 1 for i in range(1, len(s) + 1): if i < len(s) and s[i] == s[i - 1]: length += 1 else: count += length * (length + 1) // 2 count %= MOD length = 1 return count"},{"question":"Given an array of integers `arr` where every element appears **an even number of times** except for one element which appears **an odd number of times**. Write an algorithm to _find the single element that appears an odd number of times_. Your solution should have a linear runtime complexity and use only constant extra space.","solution":"def find_odd_occurrence(arr): Returns the single element that appears an odd number of times in the array. result = 0 for num in arr: result ^= num return result"},{"question":"A **powerful number** is a positive integer that is equal to the sum of its positive divisors excluding itself. For instance, the number `12` is a powerful number because its positive divisors (excluding itself) are `1, 2, 3, 4, 6`, and their sum is `16` which is greater than `12`. However, the number `6` is not a powerful number because its positive divisors (excluding itself) are `1, 2, 3`, and their sum is `6` which is equal to `6`. Write a function `findPowerfulNumbers(n)` that accepts an integer `n` (1 ≤ n ≤ 10^4), and returns a list of all powerful numbers between `1` and `n` (inclusive), sorted in ascending order.","solution":"def findPowerfulNumbers(n): Finds all powerful numbers between 1 and n (inclusive). A powerful number is an integer that is equal to or greater than the sum of its positive divisors excluding itself. Args: n (int): The upper limit to look for powerful numbers (1 ≤ n ≤ 10^4). Returns: list: A list of powerful numbers in ascending order. def sum_of_divisors_excluding_itself(num): # Helper function to calculate the sum of divisors of a number excluding the number itself total_sum = 0 for i in range(1, (num // 2) + 1): if num % i == 0: total_sum += i return total_sum powerful_numbers = [] for i in range(1, n+1): if sum_of_divisors_excluding_itself(i) > i: powerful_numbers.append(i) return powerful_numbers"},{"question":"You are given a **0-indexed** integer array `nums` of size `n`. The array can be modified by performing a series of operations of your choice. In each operation, you can select a pair of indices `(i, j)` where `0 <= i, j < n`, and increase the element at index `i` by the value of the element at index `j` (i.e., `nums[i] = nums[i] + nums[j]`). You may perform any number of operations, or none at all. Your task is to determine the **minimum** possible largest value in the array `nums` after performing the operations optimally. Return _the minimum possible largest value of the modified array_.","solution":"def minimize_maximum_value(nums): Returns the minimum possible largest value of the modified array `nums`. n = len(nums) total_sum = sum(nums) # The minimum possible largest value would be the ceiling of total_sum / n return (total_sum + n - 1) // n"},{"question":"You are given a grid with `m` rows and `n` columns where several cells are filled with water. The grid is represented by an `m x n` binary matrix `grid` where `0` represents a dry cell and `1` represents a water-filled cell. A region of water is defined as a group of `1`s connected horizontally, vertically, or diagonally. Return _the maximum area of a region of water_ in the grid.","solution":"def max_area_of_water(grid): Returns the maximum area of a region of water in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or visited[r][c]: return 0 # Mark the current cell as visited visited[r][c] = True # Initialize the area as 1 (current cell) area = 1 # Explore all 8 possible directions (horizontally, vertically, and diagonally) for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]: area += dfs(r + dr, c + dc) return area max_area = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a coordinate `(x, y)` and contains a value representing the height at that coordinate. Water can flow from a cell to another one if and only if the other cell has an equal or lower height. Water can either flow to the Pacific Ocean, which touches the left and top edges of the grid, or the Atlantic Ocean, which touches the right and bottom edges of the grid. Return _a list of coordinates_ from where water can flow to both the Pacific and Atlantic oceans. Note: The order of the returned coordinates does not matter. Each coordinate should be represented as a list `[x, y]`.","solution":"def pacificAtlantic(heights): if not heights: return [] def dfs(x, y, visited, prev_height): if ((x, y) in visited or x < 0 or x >= len(heights) or y < 0 or y >= len(heights[0]) or heights[x][y] < prev_height): return visited.add((x, y)) for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)): dfs(x + dx, y + dy, visited, heights[x][y]) pacific, atlantic = set(), set() rows, cols = len(heights), len(heights[0]) for i in range(rows): dfs(i, 0, pacific, heights[i][0]) # Left edge (Pacific) dfs(i, cols - 1, atlantic, heights[i][cols - 1]) # Right edge (Atlantic) for j in range(cols): dfs(0, j, pacific, heights[0][j]) # Top edge (Pacific) dfs(rows - 1, j, atlantic, heights[rows - 1][j]) # Bottom edge (Atlantic) return list(map(list, pacific & atlantic))"},{"question":"A string is considered a valid palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Given a string `s`, _return whether it is a valid palindrome_.","solution":"def is_valid_palindrome(s: str) -> bool: Returns True if input string `s` is a valid palindrome, False otherwise. # Convert to lower case and filter out non-alphanumeric characters filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters reads the same forward and backward return filtered_chars == filtered_chars[::-1]"},{"question":"Given an `n`-ary tree, where each node can have up to `n` children and is represented by a `Node` class: ``` class Node { public int val; public List<Node> children; } ``` Write a function to find the maximum depth of the `n`-ary tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Return the maximum depth of the `n`-ary tree.","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def maxDepth(root): Returns the maximum depth of the n-ary tree. if not root: return 0 if not root.children: return 1 else: return 1 + max(maxDepth(child) for child in root.children)"},{"question":"Given a **0-indexed** integer array `arr` and an integer `k`, you need to determine if there are two distinct indices `i` and `j` in the array such that `arr[i] == arr[j]` and the absolute difference between `i` and `j` is at most `k`. Return `true` if such indices exist, and `false` otherwise.","solution":"def contains_nearby_duplicate(arr, k): Determines if there are two distinct indices i and j in the array `arr` such that arr[i] == arr[j] and the absolute difference between i and j is at most `k`. Returns `true` if such indices exist, and `false` otherwise. index_map = {} for i, value in enumerate(arr): if value in index_map and i - index_map[value] <= k: return True index_map[value] = i return False"},{"question":"You are given two integer arrays `nums1` and `nums2` of equal length `n`. The task is to pair each element in `nums1` with an element in `nums2` such that the sum of the absolute differences of their respective pairs is minimized. Return the minimum sum of the absolute differences of the paired elements. For example, if `nums1 = [1, 2, 3]` and `nums2 = [2, 3, 4]`, the output should be the minimum sum of the absolute differences of the paired elements.","solution":"def min_absolute_sum_diff(nums1, nums2): Returns the minimum sum of the absolute differences of the paired elements from arrays nums1 and nums2. nums1_sorted = sorted(nums1) def find_closest(num): low, high = 0, len(nums1_sorted) - 1 while low < high: mid = (low + high) // 2 if nums1_sorted[mid] < num: low = mid + 1 else: high = mid return nums1_sorted[low] if abs(nums1_sorted[low] - num) < abs(nums1_sorted[low - 1] - num) else nums1_sorted[low - 1] total_diff = sum(abs(a - b) for a, b in zip(nums1, nums2)) min_diff = total_diff for a, b in zip(nums1, nums2): closest = find_closest(b) minimized_diff = total_diff - abs(a - b) + abs(closest - b) if minimized_diff < min_diff: min_diff = minimized_diff return min_diff"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to rearrange the array such that any two adjacent integers in the rearranged array are at least `k` units apart in absolute difference. Return the rearranged array if it is possible to do so. If it is not possible, return an empty array. Write the function `rearrangeArray(arr, k) -> List[int]` that returns the desired rearranged array or an empty array if the rearrangement is not possible. **Example:** - Input: `arr = [1, 3, 6, 8]`, `k = 3` - Output: `[1, 6, 3, 8]` - Input: `arr = [1, 2, 3]`, `k = 2` - Output: `[]`","solution":"from typing import List def rearrangeArray(arr: List[int], k: int) -> List[int]: def is_valid_rearrangement(arr, k): for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) < k: return False return True # Recursive function to generate all permutations def permutations(arr, k): if len(arr) == 1: yield arr else: for i in range(len(arr)): for perm in permutations(arr[:i] + arr[i+1:], k): if i > 0 and abs(arr[i] - perm[-1]) < k: continue yield [arr[i]] + perm arr.sort() for perm in permutations(arr, k): if is_valid_rearrangement(perm, k): return perm return []"},{"question":"Given an array of integers `heights` representing the heights of buildings, and two integers `start` and `end`, you need to find the **maximum** difference between any two building heights such that the buildings are within the range `[start, end]` inclusive. The difference is calculated as the absolute difference between the heights of the buildings. Return _the maximum height difference_ within the given range or `-1` if the range is invalid or there are fewer than two buildings within the specified range.","solution":"def max_height_difference(heights, start, end): Finds the maximum height difference between buildings in the given range [start, end]. Parameters: heights (list): List of integers representing the heights of buildings. start (int): Start index of the range. end (int): End index of the range. Returns: int: The maximum height difference or -1 if the range is invalid or there are fewer than two buildings. if start < 0 or end >= len(heights) or start > end or end >= len(heights): #To validate if the start and end indexes are valid return -1 # Extract the sub-list of heights within the range [start, end] sub_heights = heights[start:end + 1] #range should include the last index mention hence end+1 if len(sub_heights) < 2: return -1 max_height = max(sub_heights) min_height = min(sub_heights) return max_height - min_height"},{"question":"You are given a list of integers `arr` of length `n` representing the heights of n buildings. An array `shadow[i]` explains if the building `i` casts a shadow on the next building; if `shadow[i]` is `1`, it means building `i` casts a shadow and prevents the building `i+1` from being reached directly from building `i`. Your task is to find the minimum number of jumps needed to get from building `0` to building `n-1`, with the condition that you can only jump to a building that is not overshadowed by any previous building. If it is impossible to reach building `n-1`, return `-1`. A jump can be defined as moving from one building to any non-shadowed building within your jumping range `jumpDist` which is provided as an integer.","solution":"def min_jumps_to_reach_end(heights, shadows, jump_dist): Calculates the minimum number of jumps required to reach the last building. n = len(heights) if n == 0: return -1 dp = [float(\'inf\')] * n dp[0] = 0 # Start at the first building for i in range(n): if dp[i] == float(\'inf\'): continue # Skip unreachable buildings for j in range(i + 1, min(i + jump_dist + 1, n)): if shadows[i] == 0: dp[j] = min(dp[j], dp[i] + 1) if shadows[i] == 1 and j > i + 1: dp[j] = min(dp[j], dp[i] + 1) return dp[n - 1] if dp[n - 1] != float(\'inf\') else -1"},{"question":"You are given a `n x n` grid representing an island, where `1` represents land and `0` represents water. You may assume all four edges of the grid are surrounded by water. There is exactly one island (i.e., one or more connected land cells). A cell is connected if and only if it is adjacent to another land cell horizontally or vertically. We define a bridge as a path of water cells (0s) that connects one land cell to another land cell, where you can only move horizontally or vertically. Return the shortest bridge\'s length as the number of 0s in the shortest such path.","solution":"from collections import deque def shortest_bridge(grid): n = len(grid) def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: yield nx, ny def dfs(x, y): stack = [(x, y)] while stack: i, j = stack.pop() if (i, j) not in visited: visited.add((i, j)) grid[i][j] = 2 # Marking the island with a 2 for ni, nj in get_neighbors(i, j): if grid[ni][nj] == 1: stack.append((ni, nj)) q.append((i, j)) # For BFS later # Step 1: Find the first island and mark it found = False visited = set() q = deque() for i in range(n): if found: break for j in range(n): if grid[i][j] == 1: dfs(i, j) found = True break # Step 2: Use BFS to find the shortest path to the second island steps = 0 while q: for _ in range(len(q)): x, y = q.popleft() for nx, ny in get_neighbors(x, y): if grid[nx][ny] == 1: return steps if grid[nx][ny] == 0: grid[nx][ny] = 2 q.append((nx, ny)) steps += 1 return -1"},{"question":"You are given a list of non-negative integers `nums` representing the number of candies in each pile. A player can pick a pile and either remove one candy from that pile or remove half the candies from that pile (rounded down). The game continues until all piles are empty. Return _the minimum number of steps required to empty all piles_.","solution":"import heapq def minStepsToEmptyPiles(nums): Returns the minimum number of steps required to empty all piles of candies. :param nums: List of non-negative integers representing the candies in each pile. :return: Minimum number of steps to empty all piles. # Initialize a max heap max_heap = [-candy for candy in nums if candy > 0] heapq.heapify(max_heap) steps = 0 while max_heap: # Remove the pile with the maximum candies max_candies = -heapq.heappop(max_heap) # If there are candies left, we have two options: # 1. Remove one candy remaining_candies = max_candies - 1 if remaining_candies > 0: heapq.heappush(max_heap, -remaining_candies) # Increment the number of steps steps += 1 return steps"},{"question":"You are given a list of strings `words` and a string `target`. Your task is to find the minimum number of stickers that you need to spell out the `target` string. Each sticker is a string, and you may use each sticker unlimited times. If it is not possible to spell out `target` using the given stickers, return `-1`. Return _the minimum number of stickers required to form the `target` string, or `-1` if it is not possible_. For example, given `words = [\\"with\\", \\"example\\", \\"science\\"]` and `target = \\"thehat\\"`, the output should be `3` as you can concatenate the stickers `[\\"with\\", \\"example\\", \\"example\\"]` to form the word \\"thehat\\".","solution":"from collections import Counter from functools import lru_cache def min_stickers(stickers, target): Find the minimum number of stickers needed to spell out the target string. If it is not possible, return -1. # Convert the stickers into a Counter (multiset) for easier manipulation sticker_counts = [Counter(sticker) for sticker in stickers] @lru_cache(None) def dp(remain): if not remain: return 0 remain_count = Counter(remain) res = float(\'inf\') for sticker in sticker_counts: if sticker[remain[0]] > 0: # Check if the sticker can contribute to the first char of remain new_remain = \'\'.join([char * (remain_count[char] - sticker[char]) for char in remain_count if remain_count[char] > sticker[char]]) res = min(res, dp(new_remain) + 1) return res result = dp(target) return result if result != float(\'inf\') else -1"},{"question":"Given two strings, `s1` and `s2`, return _the **minimum number of deletions** required to make_ `s1` _and_ `s2` _anagrams of each other_. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once.","solution":"def min_deletions_to_make_anagrams(s1, s2): Returns the minimum number of deletions required to make s1 and s2 anagrams of each other. from collections import Counter counter1 = Counter(s1) counter2 = Counter(s2) deletions = 0 for char in set(counter1.keys()).union(set(counter2.keys())): deletions += abs(counter1[char] - counter2[char]) return deletions"},{"question":"Given an array of integers `nums`, return the length of the longest subsequence such that every element is a power of two. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_power_of_two_subsequence(nums): Returns the length of the longest subsequence such that every element is a power of two. def is_power_of_two(n): return n > 0 and (n & (n - 1)) == 0 longest_subseq = [num for num in nums if is_power_of_two(num)] return len(longest_subseq)"},{"question":"Given a string `s` which represents a complex number in the form `\\"a+bi\\"`, where `a` and `b` are integers, perform the multiplication of this complex number with another complex number represented by the string `t`, also in the form `\\"c+di\\"`. Return the result of the multiplication as a string in the same format `\\"x+yi\\"`, where `x` and `y` are the resulting integers after the multiplication. Notes: - The input strings will not contain any spaces. - Both input strings `s` and `t` are valid complex numbers. - The result should be simplified to the standard format `\\"x+yi\\"`, with no extra spaces.","solution":"def parse_complex(complex_str): Parses a complex number string in the form \'a+bi\' and returns a tuple (a, b). a, b = complex_str[:-1].split(\'+\') return int(a), int(b) def multiply_complex_numbers(s, t): Multiplies two complex numbers given as strings \'s\' and \'t\' in the form \'a+bi\' and returns the result as a string \'x+yi\'. a, b = parse_complex(s) c, d = parse_complex(t) x = a * c - b * d y = a * d + b * c return f\\"{x}+{y}i\\""},{"question":"Given a string `s`, determine the minimum number of steps required to make the string palindrome. In one step, you can change any character to any other character. Return the minimum number of steps.","solution":"def min_steps_to_palindrome(s): Returns the minimum number of steps required to make the string a palindrome. In one step, you can change any character to any other character. Parameters: s (str): The input string. Returns: int: The minimum number of steps to make the string a palindrome. n = len(s) steps = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: steps += 1 return steps"},{"question":"Given an integer array `nums`, and an integer `k`, your task is to find the maximum sum of `k` consecutive elements in the array. Implement the `MaxConsecutiveSum` class: - `MaxConsecutiveSum(int[] nums, int k)` Initializes the object with the integer array `nums` and the integer `k`. - `int findMaxConsecutiveSum()` Returns the maximum sum of `k` consecutive elements in `nums`.","solution":"class MaxConsecutiveSum: def __init__(self, nums, k): self.nums = nums self.k = k def findMaxConsecutiveSum(self): if not self.nums or self.k <= 0 or self.k > len(self.nums): return 0 # Calculate the sum of the first \'k\' elements max_sum = current_sum = sum(self.nums[:self.k]) # Use a sliding window to find the maximum sum of \'k\' consecutive elements for i in range(self.k, len(self.nums)): current_sum += self.nums[i] - self.nums[i - self.k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Write a function that takes a non-empty array of integers where each integer appears twice except for one that appears only once. Your task is to find and return the integer that appears only once. The algorithm should have a linear runtime complexity and use only constant extra space.","solution":"def single_number(nums): Returns the integer that appears only once in a non-empty array where each integer appears twice except for one that appears only once. The algorithm has a linear runtime complexity and uses only constant extra space. unique = 0 for num in nums: unique ^= num return unique"},{"question":"An **eardition** sequence is a sequence of integers where the difference between any two consecutive elements is either `-1` or `+1`. Given an array of `n` integers, determine whether it is possible to rearrange the array to form an eardition sequence. If it is possible, return _any valid permutation_ of the array elements that forms such a sequence. If it is not possible, return an **empty array**.","solution":"def is_eardition_sequence_possible(arr): Determines whether it is possible to rearrange the array to form an eardition sequence. Parameters: arr (list): A list of integers. Returns: list: A valid permutation of the array that forms an eardition sequence, or an empty list if not possible. if not arr: return [] # Sort the array arr.sort() # Check if it\'s possible to rearrange to form an eardition sequence for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) > 1: return [] return arr"},{"question":"Here is a proposed new question following the provided guidelines: [Question 4]: You are given two strings `s1` and `s2` that consist of lowercase letters. Your task is to determine if you can transform `s1` into `s2` by performing some set of operations. Each operation consists of choosing a character in `s1` and replacing it with any other lowercase English letter. You can perform this operation at most once for each character in `s1`. Return `true` if you can transform `s1` into `s2` and `false` otherwise. Note that the lengths of `s1` and `s2` are always the same.","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 by performing an operation that replaces each character in s1 with any other lowercase English letter at most once. if len(s1) != len(s2): return False # Use set to track unique transformations seen_pairs = set() for c1, c2 in zip(s1, s2): if c1 != c2: seen_pairs.add((c1, c2)) return len(seen_pairs) <= 26"},{"question":"Your task is to write a function that simulates a simple event scheduler. The scheduler should support adding events with specific start times and durations, and checking if a new event can be scheduled without overlapping any existing events. Implement the `EventScheduler` class: - `EventScheduler()` initializes the scheduler with no events. - `bool addEvent(int startTime, int duration)` tries to add an event with the given `startTime` and `duration`. If the event does not conflict with any existing events, it adds the event to the schedule and returns `true`. Otherwise, it returns `false`. - `List getAllEvents()` returns a list of all currently scheduled events, where each event is represented as a tuple `(startTime, duration)`. Make sure to manage the events efficiently to handle large numbers of add operation requests.","solution":"class EventScheduler: def __init__(self): self.events = [] def addEvent(self, startTime, duration): Tries to add an event with the given startTime and duration. If the event does not conflict with any existing events, it adds the event to the schedule and returns True. Otherwise, it returns False. new_event_end = startTime + duration for event_start, event_duration in self.events: event_end = event_start + event_duration if not (new_event_end <= event_start or startTime >= event_end): return False self.events.append((startTime, duration)) self.events.sort() # keep events sorted for easier management return True def getAllEvents(self): Returns a list of all currently scheduled events as tuples (startTime, duration). return self.events"},{"question":"You are given a **valid parentheses string** `s` (a string of characters containing only `(` and `)` ). Your task is to compute the _depth_ of the parentheses. The depth of `s` is defined as the maximum depth of nested parentheses. A valid parentheses string is a string such that for every prefix of the string, the number of opening brackets \\"(\\" is at least as large as the number of closing brackets \\")\\", and the number of opening brackets in the entire string is equal to the number of closing brackets. For example: Given `s = \\"((()))\\"`, the depth is `3`. Given `s = \\"(()(()))\\"`, the depth is `3`. Return _the depth of the parentheses string_.","solution":"def max_depth(s: str) -> int: Returns the maximum depth of nested parentheses in the given valid parentheses string s. current_depth = 0 max_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"Given an array of integers `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_, such that you cannot rob two adjacent houses. The solution should determine the optimal amount by deciding for each house whether to rob it or skip it, ensuring no two adjacent houses are robbed.","solution":"def rob(nums): Returns the maximum amount of money you can rob tonight without alerting the police. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize two variables to track maximum profit without alerting police prev1, prev2 = 0, 0 for num in nums: current = max(prev1, prev2 + num) prev2 = prev1 prev1 = current return prev1"},{"question":"Implement a class `ProductCache` that maintains a cache of the most recently accessed N products. Each product consists of a `productId` (unique identifier) and a `productName` (string). The cache should support the following operations: - **Adding a product**: Adds a product to the cache, when the cache already contains N products and a new product is added, the least recently accessed product should be removed from the cache to make space for the new product. - **Accessing a product**: Accessing a product by its `productId` makes it the most recently accessed product. - **Retrieving all products**: Returns a list of products currently in the cache, sorted by the most recently accessed first. Implement the `ProductCache` class: - `ProductCache(int capacity)`: Initializes the cache with a capacity for N products. - `void addProduct(int productId, string productName)`: Adds a product to the cache or updates an existing product\'s name. - `void accessProduct(int productId)`: Accesses the product identified by `productId` making it the most recently accessed product. - `List<String> getProducts()`: Retrieves all products currently in the cache sorted by the most recently accessed first.","solution":"from collections import OrderedDict class ProductCache: def __init__(self, capacity): Initializes the cache with a capacity for N products. self.capacity = capacity self.cache = OrderedDict() def addProduct(self, productId, productName): Adds a product to the cache or updates an existing product\'s name. if productId in self.cache: # Update product name and move it to end (most recently accessed) self.cache.move_to_end(productId) self.cache[productId] = productName if len(self.cache) > self.capacity: # Remove the least recently accessed product self.cache.popitem(last=False) def accessProduct(self, productId): Accesses the product identified by productId making it the most recently accessed product. if productId in self.cache: # Move the accessed product to the end (most recently accessed) self.cache.move_to_end(productId) def getProducts(self): Retrieves all products currently in the cache sorted by the most recently accessed first. return [self.cache[productId] for productId in reversed(self.cache)]"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to determine whether any two numbers in the list add up to the `target`. Return `true` if such a pair exists and `false` otherwise. You must achieve this with a time complexity of O(n). Implement the function `bool two_sum(List<int> nums, int target)` where: - `nums` is a list of integers. - `target` is the integer to which two numbers from the list must add up to.","solution":"def two_sum(nums, target): Determine if any two numbers in the list add up to the target. Args: nums (List[int]): A list of integers. target (int): The target sum. Returns: bool: True if there exists a pair of numbers that add up to target, otherwise False. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"You are given a **0-indexed** array of integers `nums` and an integer `k`. Return _an array of the _**maximums** of each sliding window of size `k`_. A sliding window is defined as a subarray of `nums` that has a fixed length of `k` and moves one index at a time from the left to the right. The function should be efficient with a linear time complexity.","solution":"from collections import deque def max_sliding_window(nums, k): Return the maximums of each sliding window of size k in the array nums. Args: nums: List of integers. k: Integer, size of the sliding window. Returns: List of integers representing the maximums of each sliding window of size k. if not nums or k == 0: return [] if k == 1: return nums # Every number in the window is the max if window size is 1 dq = deque() # stores indices result = [] for i in range(len(nums)): # Remove indexes of elements not from sliding window if dq and dq[0] < i - k + 1: dq.popleft() # Remove from dq indexes of all elements which are smaller than current element nums[i] while dq and nums[dq[-1]] < nums[i]: dq.pop() # Add current element at the end of dq dq.append(i) # The element at the front of the deque is the largest element of the previous window if i >= k - 1: result.append(nums[dq[0]]) return result"},{"question":"Given a string `s` and an array of integers `cost` where `cost[i]` represents the cost of deleting the `i-th` character in `s`, your task is to remove the minimum number of characters from `s` such that no two adjacent characters are the same. The cost of removing a character is defined by the array `cost`. Implement the function `minCost(String s, int[] cost)` that returns the minimum total cost required to achieve the goal. Example: - `s = \\"abaac\\", cost = [1, 2, 3, 4, 5]` Output: `3` Explanation: Remove the characters at indices `2` and `3` to make `s = \\"abac\\"`. The total cost is `cost[2] + cost[3] = 3 + 4 = 7`. - `s = \\"abc\\", cost = [1, 2, 3]` Output: `0` Explanation: No deletions are needed since there are no adjacent characters that are the same.","solution":"def minCost(s, cost): total_cost = 0 i = 0 while i < len(s) - 1: if s[i] == s[i + 1]: # Find the series of identical characters sum_cost = cost[i] max_cost = cost[i] while i < len(s) - 1 and s[i] == s[i + 1]: sum_cost += cost[i + 1] max_cost = max(max_cost, cost[i + 1]) i += 1 # Add the total of the cost minus the max cost (keeping the most expensive deletion) total_cost += (sum_cost - max_cost) i += 1 return total_cost"},{"question":"Given a string `s` consisting of lowercase English letters, find and return the length of the longest substring without repeating characters. Use a sliding window approach to optimize the solution\'s efficiency.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters in the given string s. char_map = {} left = 0 max_len = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an array of integers `nums` and an integer `k`, return _the length of the longest subarray where the difference between the maximum and minimum elements is at most_ `k`. For example, given `nums = [8, 2, 4, 7]` and `k = 4`, the longest subarray with this property is `[8, 2, 4]` where the difference between the maximum (8) and minimum (2) element is 4. Thus, the function should return `3`.","solution":"from collections import deque def longest_subarray(nums, k): max_deque = deque() min_deque = deque() left = 0 max_len = 0 for right, num in enumerate(nums): while max_deque and nums[max_deque[-1]] < num: max_deque.pop() while min_deque and nums[min_deque[-1]] > num: min_deque.pop() max_deque.append(right) min_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a linked list, swap every two adjacent nodes and return its head. For example, given the linked list `1 -> 2 -> 3 -> 4`, you should return `2 -> 1 -> 4 -> 3`. Your algorithm should use only constant extra space and you may not modify the values in the list\'s nodes, only nodes itself may be changed.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_pairs(head): Swap every two adjacent nodes of the linked list. :param head: ListNode, head of the linked list. :return: ListNode, head of the modified linked list. dummy = ListNode(0) dummy.next = head prev = dummy while prev.next and prev.next.next: first = prev.next second = prev.next.next first.next = second.next second.next = first prev.next = second prev = first return dummy.next"},{"question":"You are given an array of integers `nums` representing a collection of numbers, where `nums[i]` indicates the value of the `i`-th number in the collection. A **\\"slice\\"** of this array is a contiguous subarray defined by two integers `start` and `end` (where `0 <= start <= end < nums.length`). You need to find the total number of slices that have a sum equal to a given integer `targetSum`. Return _the number of slices that add up to_ `targetSum`.","solution":"def count_slices_with_target_sum(nums, targetSum): Returns the number of contiguous subarrays (slices) whose sum equals targetSum. :param nums: List[int] - List of integers. :param targetSum: int - The desired sum of subarrays. :return: int - Number of contiguous subarrays that add up to targetSum. count = 0 for start in range(len(nums)): curr_sum = 0 for end in range(start, len(nums)): curr_sum += nums[end] if curr_sum == targetSum: count += 1 return count"},{"question":"Given two integer arrays `arr1` and `arr2` sorted in **non-decreasing** order, return an array of the **first k** elements that would appear in the sorted order of the merged arrays. If k is larger than the total length of merged arrays, return all elements of the merged array in sorted order.","solution":"def merge_sorted_arrays(arr1, arr2, k): Returns the first k elements that would appear in the sorted order of the merged arrays arr1 and arr2. If k is larger than the total length of merged arrays, return all elements of the merged arrays in sorted order. Parameters: arr1 (list of int): first sorted integer array arr2 (list of int): second sorted integer array k (int): number of elements to return Returns: list of int: first k elements in sorted order of the merged arrays merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2) and len(merged) < k: if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1) and len(merged) < k: merged.append(arr1[i]) i += 1 while j < len(arr2) and len(merged) < k: merged.append(arr2[j]) j += 1 return merged"},{"question":"You are given an integer array `height` of length `n`, where `height[i]` represents the height of the `i-th` tree in a forest. The trees form a skyline when viewed from a straight line, and this skyline can be represented as a sequence of heights. You are tasked with determining the largest rectangle that can be formed by selecting consecutive trees in the skyline. The height of the rectangle is determined by the shortest tree among the selected trees, and the width is the number of trees selected. Implement a function `largestRectangle` that, given the array `height`, returns the area of the largest rectangle that can be formed with consecutive trees in the skyline. You can assume that the heights are non-negative integers and that the array will contain at least one tree.","solution":"def largestRectangle(height): Given an array of heights representing the skyline, returns the area of the largest rectangle that can be formed using consecutive trees. stack = [] max_area = 0 index = 0 while index < len(height): if not stack or height[index] >= height[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (height[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (height[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an array of integers `arr` and an integer `d`. Your task is to determine the maximum number of unique integers after removing exactly `d` elements from the array. You may assume that the array contains at least `d` elements.","solution":"def max_unique_integers_after_removal(arr, d): Returns the maximum number of unique integers after removing exactly d elements from the array. from collections import Counter # Count the frequency of each element freq = Counter(arr) # Get a list of frequencies, sorted in decreasing order freq_list = sorted(freq.values(), reverse=True) # Remove d elements starting from the least frequent ones while d > 0 and freq_list: # If the maximum number of elements we can remove is more than `d`, we just reduce `d` to 0 if freq_list[-1] <= d: d -= freq_list.pop() else: freq_list[-1] -= d d = 0 # Number of unique items left will be the length of the frequencies list that are not zero return len(freq_list)"},{"question":"You are given a list of integers `nums` representing the number of apples in each bucket arranged in a line. You need to collect the maximum number of apples possible but cannot pick from two adjacent buckets. Write a function that returns the maximum number of apples you can collect following these rules.","solution":"def max_apples(nums): Returns the maximum number of apples that can be collected without picking from two adjacent buckets. if not nums: return 0 if len(nums) == 1: return nums[0] n = len(nums) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given a list of tasks, where `tasks[i]` represents the time required to complete the i-th task. You are also given an integer `n`. You have to schedule these tasks on `n` processors such that the maximum load (the total time of tasks assigned) on any processor is minimized. Return the minimized maximum load of any processor after scheduling all tasks. Tasks cannot be split and each task is assigned to exactly one processor. The order of tasks in the list does not affect the load distribution.","solution":"def minimize_max_load(tasks, n): Returns the minimized maximum load of any processor after scheduling all tasks. :param tasks: List[int] - a list of integers representing time required for each task. :param n: int - number of processors :return: int - minimized maximum load on any processor. from heapq import heappush, heappop # If processors are greater than tasks, the answer is the longest single task. if n >= len(tasks): return max(tasks) # Min-heap to track the current load on each processor min_heap = [0] * n for task in sorted(tasks, reverse=True): # Retrieve the processor with the minimum load min_load = heappop(min_heap) # Assign the task to this processor and update the load heappush(min_heap, min_load + task) # The maximum load on any processor is the highest value in the heap return max(min_heap)"},{"question":"You are given two non-negative integers `n` and `k`. Your task is to find the smallest non-negative integer `x` such that the sum of the digits of `x` is equal to `n`, and `x` has at most `k` digits. If no such `x` exists, return -1. Implement the function `findSmallestX(n: int, k: int) -> int`.","solution":"def findSmallestX(n: int, k: int) -> int: Finds the smallest non-negative integer x such that the sum of the digits of x is equal to n, and x has at most k digits. If no such x exists, returns -1. if k == 0: return -1 if n == 0 else -1 # The smallest x will be constructed by distributing the sum across the digits starting from the least significant digit. digits = [] remaining_sum = n for _ in range(k): if remaining_sum > 9: digits.append(9) remaining_sum -= 9 else: digits.append(remaining_sum) remaining_sum = 0 if remaining_sum > 0: return -1 # Construct the number from the digit list digits.reverse() x = int(\\"\\".join(map(str, digits))) return x"},{"question":"You are given a **0-indexed** integer array `nums`, which contains `n` integers. You need to create a new array `result` where `result[i]` is equal to the product of all the elements of `nums` except `nums[i]`. For example, if `nums = [1, 2, 3, 4]`, then `result = [24, 12, 8, 6]`. Write a function that returns the new array `result`, without using division operations. The function should have a time complexity of O(n) and a space complexity of O(1) (not counting the output array).","solution":"def product_except_self(nums): Given an array nums of n integers, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. n = len(nums) result = [1] * n left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"You are given an integer array `arr`, where each element is a positive integer. An element `a` from the array is called a **dominant** element if it is greater than twice of every other element in the array. Return the **index** of the dominant element if one exists, otherwise return `-1`. For example: - If `arr = [3, 6, 1, 0]`, the output should be `1` because `6` is greater than twice of all other elements. - If `arr = [1, 2, 3, 4]`, the output should be `-1` because no element meets the condition.","solution":"def find_dominant_index(arr): Returns the index of the dominant element if one exists, otherwise returns -1. if not arr: return -1 max_value = max(arr) max_index = arr.index(max_value) for i in range(len(arr)): if i != max_index and arr[i] * 2 > max_value: return -1 return max_index"},{"question":"You are given a string `s` containing only the characters `\'a\'` and `\'b\'`. You can perform the following operation on the string as many times as you want: select any two adjacent characters and replace them with a single character `\'c\'`. Your task is to find the **smallest** possible length of the string that can be obtained after applying the operations any number of times. Return this smallest possible length.","solution":"def smallest_length_after_operations(s): Returns the smallest possible length of the string after performing the given operations. # Counting the number of \'a\'s and \'b\'s in the string count_a = s.count(\'a\') count_b = s.count(\'b\') # The smallest length after applying the operations is the absolute difference return abs(count_a - count_b)"},{"question":"You are given a string `input_str` which consists of lowercase English letters and ‘*’ characters. Your task is to form the longest possible palindromic string by replacing each ‘*’ with any lowercase English letter. Return the length of the longest palindromic string that can be formed this way. A palindrome is a string that reads the same forward and backward.","solution":"def longest_palindromic_length(input_str): Returns the length of the longest possible palindromic string that can be formed by replacing \'*\' characters with any lowercase English letters. Args: input_str (str): The input string containing lowercase letters and \'*\' characters. Returns: int: The length of the longest possible palindromic string. n = len(input_str) # Check from both ends towards the middle left, right = 0, n - 1 while left <= right: if input_str[left] != input_str[right] and input_str[left] != \'*\' and input_str[right] != \'*\': # If both characters are different and not \'*\', cannot form a palindrome return 0 left += 1 right -= 1 # If we exit cleanly, the whole string can be made into a palindrome return n"},{"question":"Given two integers `n` and `m`, create a data structure that dynamically performs the following operations on an initial array `arr` of length `n` filled with zeros: - `update(int index, int val)`: Update the value of `arr[index]` to `val`. - `sumRange(int left, int right)`: Return the sum of the subarray within bounds `[left, right]` (inclusive). Design and implement a class `NumArray` with the above methods: - `NumArray(int n)`: Initializes the data structure with the array of length `n` filled with zeros. - `void update(int index, int val)`: Updates the value of `arr[index]` to `val`. - `int sumRange(int left, int right)`: Returns the sum of elements between indices `left` and `right` inclusive. Your implementation should aim for efficient time complexity for both update and sumRange operations.","solution":"class NumArray: def __init__(self, n): Initializes the data structure with an array of length n filled with zeros. self.n = n self.arr = [0] * n self.bit = [0] * (n + 1) def update(self, index, val): Updates the value of arr[index] to val. delta = val - self.arr[index] self.arr[index] = val idx = index + 1 while idx <= self.n: self.bit[idx] += delta idx += idx & -idx def sumRange(self, left, right): Returns the sum of elements between indices left and right inclusive. return self._prefixSum(right) - self._prefixSum(left - 1) def _prefixSum(self, index): sum = 0 idx = index + 1 while idx > 0: sum += self.bit[idx] idx -= idx & -idx return sum"},{"question":"You are given an array `nums` of integers. A segment of this array is any contiguous subsequence of the array. Find the maximum sum among all possible segments of the array. Return the sum of the segment with the maximum sum.","solution":"def max_subarray_sum(nums): Returns the maximum sum among all possible segments of the array nums. if not nums: return 0 max_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array `arr` of integers, partition it into two subarrays (possibly empty) such that the sum of the first subarray is maximized and the sum of the second subarray is minimized. Return _the **maximum sum** of the first subarray_. A subarray is any contiguous subset of the array. For instance, if the array `arr = [1, -2, 3, 10, -4, 7, 2]`, an optimal partition would yield the first subarray `[1, -2, 3, 10]` with a sum of `12` and the second subarray `[-4, 7, 2]` with a sum of `5`.","solution":"def max_subarray_sum(arr): Returns the maximum sum of any non-empty subarray within the given array. if not arr: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of integers `nums` and an integer `k`, return the maximum number of unique integers among all possible contiguous subarrays of size `k`.","solution":"def max_unique_integers(nums, k): Returns the maximum number of unique integers among all possible contiguous subarrays of size k. if k > len(nums): return len(set(nums)) from collections import defaultdict current_counts = defaultdict(int) max_unique = 0 unique_count = 0 # Initialize the first window for i in range(k): if current_counts[nums[i]] == 0: unique_count += 1 current_counts[nums[i]] += 1 max_unique = unique_count # Slide the window for i in range(k, len(nums)): # Remove the element going out if current_counts[nums[i - k]] == 1: unique_count -= 1 current_counts[nums[i - k]] -= 1 # Add the new element if current_counts[nums[i]] == 0: unique_count += 1 current_counts[nums[i]] += 1 # Update the maximum unique count max_unique = max(max_unique, unique_count) return max_unique"},{"question":"A company has a team of developers, and each developer has a set of skills represented as a list of strings. You need to form the smallest number of developer pairs such that each pair collectively possesses all the required skills listed in `requiredSkills`. A developer pair can be formed if two developers together have all the skills from `requiredSkills`. Return _the minimum number of pairs needed_. Return `-1` if it is impossible to form such pairs with the given team. Your input is: - `developers`: A list of lists of strings where each list represents the skills a developer has. - `requiredSkills`: A list of strings representing the required skills needed for each pair. Output: - An integer representing the minimum number of pairs needed, or `-1` if it\'s not possible to pair the developers to cover all required skills.","solution":"def minimum_developer_pairs(developers, requiredSkills): from itertools import combinations required_set = set(requiredSkills) # Quick check if any single developer already covers all required skills for dev in developers: if required_set.issubset(dev): return 1 # Check for pairs pairs_needed = float(\'inf\') for dev1, dev2 in combinations(developers, 2): combined_skills = set(dev1).union(set(dev2)) if required_set.issubset(combined_skills): pairs_needed = min(pairs_needed, 1) if pairs_needed == float(\'inf\'): return -1 return pairs_needed"},{"question":"Given two arrays of integers `a` and `b`, write a function that returns the maximum sum of non-overlapping subarrays from `a` and `b`. The selected subarrays from `a` and `b` must be of the same length. Ensure your solution handles edge cases where one or both arrays might be empty. Your function should efficiently manage the size of the input to mitigate performance issues with large arrays.","solution":"def max_sum_of_non_overlapping_subarrays(a, b, length): Returns the maximum sum of non-overlapping subarrays from `a` and `b` with the same specified length. If length is greater than the length of either array, return 0. if length == 0 or length > len(a) or length > len(b): return 0 max_sum_a = max(sum(a[i:i+length]) for i in range(len(a) - length + 1)) max_sum_b = max(sum(b[i:i+length]) for i in range(len(b) - length + 1)) return max_sum_a + max_sum_b"},{"question":"You are given a string `s` that consists of exactly two distinct characters. You can perform the following operation any number of times: choose any character from `s` and change it to the other character. Your goal is to create the longest possible substring that consists of only one unique character. Return the length of this longest substring.","solution":"def longest_uniform_substring_length(s): Given a string s consisting of exactly two distinct characters, return the length of the longest possible substring that consists of only one unique character. :param s: str - input string consisting of exactly two distinct characters :return: int - length of the longest substring with one unique character if not s: return 0 from collections import Counter counts = Counter(s) longest_length = max(counts.values()) return longest_length"},{"question":"You are given a linked list where each node contains an integer value. Write a function that returns the node at which the cycle begins. If there is no cycle, return `null`. A cycle is a group of nodes in the linked list that are connected in such a way that you can traverse from one node back to itself without passing through any node twice.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Detects the node at the beginning of the cycle in the linked list. If there is no cycle, return None. :param head: ListNode - The head of the linked list. :return: ListNode or None - The node where the cycle begins, or None if there is no cycle. if not head or not head.next: return None slow, fast = head, head # Detect if there is a cycle using the slow and fast pointers while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle return None # Find the start of the cycle while head != slow: head = head.next slow = slow.next return head"},{"question":"Given a list of integers, `arr`, determine whether it is possible to split `arr` into two subsequences such that the sum of the elements in each subsequence is equal. Return `true` if it is possible, and `false` otherwise. A **subsequence** is derived by deleting some or no elements from an array without changing the order of the remaining elements.","solution":"def can_partition(nums): Determines if it is possible to split the array into two subsequences with equal sum. :param nums: List of integers :return: Boolean value total_sum = sum(nums) # If the total sum is odd, it cannot be split into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"You are given an unsorted array `nums` consisting of `n` integers. You need to find the longest contiguous subarray such that the absolute difference between the maximum and minimum elements in this subarray is less than or equal to a given integer `limit`. Return the length of the longest such subarray.","solution":"from collections import deque def longest_subarray(nums, limit): Finds the longest contiguous subarray such that the absolute difference between the maximum and minimum elements in this subarray is less than or equal to a given integer limit. Parameters: nums (List[int]): The input array of integers. limit (int): The maximum allowed absolute difference between the maximum and minimum elements in the subarray. Returns: int: The length of the longest such subarray. min_deque = deque() max_deque = deque() left = 0 max_len = 0 for right in range(len(nums)): while min_deque and nums[right] < nums[min_deque[-1]]: min_deque.pop() while max_deque and nums[right] > nums[max_deque[-1]]: max_deque.pop() min_deque.append(right) max_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > limit: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a string `s` that consists of lowercase alphabets and a 2D array `pairs` where each element `[a, b]` indicates that the characters at indices `a` and `b` in the string can be swapped. You need to return the lexicographically smallest string that can be formed by making any number of swaps at the indices given in `pairs`. Implement a function `smallestStringWithSwaps(string s, int[][] pairs)` that returns the desired smallest string.","solution":"def smallestStringWithSwaps(s, pairs): from collections import defaultdict import heapq def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Initialize parent array for union-find parent = list(range(len(s))) # Create union-find structure for a, b in pairs: union(a, b) # Create a dictionary to store all characters in the same connected component components = defaultdict(list) for i in range(len(s)): root = find(i) components[root].append(s[i]) # Sort each list lexicographically for comp in components.values(): heapq.heapify(comp) # Build the result string using the sorted components result = list(s) for i in range(len(s)): root = find(i) result[i] = heapq.heappop(components[root]) return \'\'.join(result)"},{"question":"You are given a 0-indexed integer array `tasks` of size `n`, where `tasks[i]` represents the time required to complete the `i-th` task. You are also given a positive integer `d` denoting the number of extra days you have to complete the tasks over the given time limit `T`. An individual task cannot be split across different days. Return _the minimum possible maximum task time you have to work on any single day, including the extra days, to complete all the tasks within the given time limit_.","solution":"def min_max_work(tasks, d): def feasible(capacity): days = 1 total = 0 for task in tasks: if total + task <= capacity: total += task else: days += 1 total = task return days <= d left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"A company has a hierarchical structure represented as a tree. Each employee, except the CEO (node 0), has one direct manager. Given a tree structure where each node represents an employee, implement a function that can determine the minimum number of meetings required for all employees to receive a specific piece of information from the CEO. In every meeting, an employee can share the information with all of their direct subordinates. Implement the function `minMeetings(n, managers)` where `n` is the total number of employees and `managers` is an array of length `n-1` where `managers[i]` represents the direct manager of the employee `i+1`. Return the minimum number of meetings required.","solution":"def minMeetings(n, managers): from collections import deque, defaultdict # Build the tree structure from the managers list tree = defaultdict(list) for i, manager in enumerate(managers): tree[manager].append(i + 1) # BFS to determine the minimum number of meetings required queue = deque([(0, 0)]) # (current employee, current level) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) for subordinate in tree[node]: queue.append((subordinate, depth + 1)) return max_depth"},{"question":"Given a `root` of a binary tree, return the **level order traversal** of its nodes\' values as an array. (i.e., from left to right, level by level). Level order traversal is the process of visiting nodes in a breadth-first order, meaning all nodes at a certain depth are visited before moving on to nodes at the next depth. The tree is denoted using the TreeNode class where: - `TreeNode` has three properties: `val`, `left`, and `right`. - `val` represents the value of the node, while `left` and `right` are references to the left and right child nodes respectively. Example: ``` Input: root = [3, 9, 20, null, null, 15, 7] Output: [[3], [9, 20], [15, 7]] ``` In the example above, the first level includes the root node (3), the second level includes nodes 9 and 20, and the third level includes nodes 15 and 7. The output should be an array of arrays, where each inner array contains the values of the nodes at the respective level.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns the level order traversal of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: A list of lists where each sublist contains the values of the nodes at the respective level. if not root: return [] result = [] queue = deque([root]) while queue: level = [] for _ in range(len(queue)): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"A **pattern** is a string that consists of lowercase letters, where each letter represents a typed letter from the keyboard. Given a string `source` and a list of strings `patterns`, return a list of boolean values indicating, for each pattern, whether it is a subsequence of the `source` string. A subsequence is a sequence derived by deleting some or no elements from the source string without changing the order of the remaining elements.","solution":"def is_subsequence(source, patterns): Determine if each pattern in patterns is a subsequence of the source string. Args: source (str): The source string. patterns (list of str): A list of patterns. Returns: list of bool: A list of boolean values indicating for each pattern if it is a subsequence of the source string. def is_subsequence_single(source, pattern): it = iter(source) return all(char in it for char in pattern) return [is_subsequence_single(source, pattern) for pattern in patterns]"},{"question":"You are given a 2D grid of integers `grid`, where each cell in the grid represents the height of a certain point on a landscape. A \\"water body\\" is defined as a region of connected cells with height `0`. Two cells are considered connected if they are adjacent horizontally or vertically. Write a function to identify and return the size of the largest water body in the grid. If there is no water body, return `0`.","solution":"def largest_water_body(grid): Identifies the size of the largest water body in the grid. A water body is defined as a region of connected cells with height 0. :param grid: List[List[int]] - 2D list representing the height of points :return: int - Size of the largest water body # Helper function to perform Depth First Search on the grid def dfs(x, y): # Stack for DFS stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() if cx < 0 or cy < 0 or cx >= len(grid) or cy >= len(grid[0]): continue if grid[cx][cy] != 0: continue # Visit the cell grid[cx][cy] = -1 size += 1 # Check all four directions stack.append((cx-1, cy)) # Up stack.append((cx+1, cy)) # Down stack.append((cx, cy-1)) # Left stack.append((cx, cy+1)) # Right return size max_body_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0: body_size = dfs(i, j) max_body_size = max(max_body_size, body_size) return max_body_size"},{"question":"You are given a set of `n` integers. Your task is to determine if there exists a subset of these integers whose sum is exactly equal to a given value `k`. If such a subset exists, return `true`; otherwise, return `false`. Note that each integer in the set can only be used once in the subset.","solution":"def subset_sum_exists(numbers, n, k): Returns True if there exists a subset of the given set of `n` integers that sums to `k`. Otherwise, returns False. :param numbers: List[int], list of integers :param n: int, number of integers in the set :param k: int, target sum value :return: bool, True if subset sum exists, False otherwise # Create a boolean array `dp` to store the subset sum possibilities dp = [False] * (k + 1) dp[0] = True # Zero sum is always possible with an empty subset # Process each number in the given set for num in numbers: # Iterate from k to num to prevent considering the same number multiple times for j in range(k, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[k]"},{"question":"You are given a string `s` and a list of words `words`. Your task is to find which words from the list `words` can be formed by characters from the string `s`. Each character in `s` can be used only once for each word. Return the list of all words that can be formed, sorted in lexicographical order. If no word can be formed, return an empty list.","solution":"def can_form_word(word, s): s_char_count = {} for char in s: if char in s_char_count: s_char_count[char] += 1 else: s_char_count[char] = 1 for char in word: if char in s_char_count and s_char_count[char] > 0: s_char_count[char] -= 1 else: return False return True def words_from_string(s, words): Returns the list of words from the input list that can be formed by characters from string s. The result list is sorted in lexicographical order. result = [] for word in words: if can_form_word(word, s): result.append(word) return sorted(result)"},{"question":"Implement a function that takes a string `s` consisting of lowercase English letters. The function should return the number of palindromic substrings in `s`. A string is palindromic if it reads the same forward and backward. Note that the single-character substrings are palindromic by default. For example, for `s = \\"abc\\"`, the palindromic substrings are `[\\"a\\", \\"b\\", \\"c\\"]` and the function should return 3. For `s = \\"aaa\\"`, the palindromic substrings are `[\\"a\\", \\"a\\", \\"a\\", \\"aa\\", \\"aa\\", \\"aaa\\"]` and the function should return 6.","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string s. n = len(s) count = 0 def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Count odd length palindromes centered at i expand_around_center(i, i) # Count even length palindromes centered at i and i + 1 expand_around_center(i, i + 1) return count"},{"question":"You are given a string `s` that consists of the digits \'0\' to \'9\' and the lowercase English letters \'a\' to \'z\'. We want to rearrange the characters in the string such that no two adjacent characters are the same. If it is possible to rearrange the string in this way, return the rearranged string. Otherwise, return an empty string. For example, if the input string is \\"aab\\", a possible output could be \\"aba\\". If the input string is \\"aaab\\", it should return an empty string as it is impossible to rearrange the characters to meet the requirement. **Note that**: * The length of the string s is between 1 and 500. * All characters in s are either digits or lowercase English letters.","solution":"from collections import Counter import heapq def reorganize_string(s): Rearrange the string `s` such that no two adjacent characters are the same. If it is not possible, return an empty string. # Count the frequency of each character count = Counter(s) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) prev_cnt, prev_char = 0, \'\' result = [] while max_heap: cnt, char = heapq.heappop(max_heap) result.append(char) if prev_cnt < 0: heapq.heappush(max_heap, (prev_cnt, prev_char)) prev_cnt, prev_char = cnt + 1, char result_string = \'\'.join(result) # if the resultant string\'s length is not equal to original string\'s length then it is not possible to rearrange return result_string if len(result_string) == len(s) else \'\'"},{"question":"Given a string `s` which represents a **sentence** consisting of lowercase letters and spaces, and an integer array `words` where each element is the length of a word that should appear in the sentence. Each word in the `words` array must be separated by exactly one space. Return `true` if the sentence can be constructed by following the exact order and lengths of the words specified in the `words` array, otherwise return `false`.","solution":"def can_form_sentence(s, words): Returns true if the sentence can be constructed by following the exact order and lengths of the words specified in the `words` array, otherwise returns false. s_split = s.split() if len(s_split) != len(words): return False for i, word in enumerate(s_split): if len(word) != words[i]: return False return True"},{"question":"Suppose you have a grid of size `m x n` that is represented by a 2D integer array `grid`. Each element `grid[i][j]` represents the elevation at that point on the grid. A water body starts at the lowest elevation point in the grid and can flow to its four cardinal directions (north, south, east, west) if the elevation of that direction is less than or equal to the current point\'s elevation. The water flow problem requires you to return _a list of coordinates_ where the water can flow from that point to the border of the grid. A point can flow to the border if there exists a path from that point to any border point (top, bottom, left, or right) following the rules above. The output should be a list of tuples where each tuple represents the coordinates `(i, j)` of the points where water can flow to the border starting from that point. The output list can be in any order.","solution":"def pacific_atlantic(grid): if not grid or not grid[0]: return [] m, n = len(grid), len(grid[0]) def bfs(starts): visited = set(starts) queue = starts[:] while queue: i, j = queue.pop(0) for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)): ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited and grid[ni][nj] >= grid[i][j]: visited.add((ni, nj)) queue.append((ni, nj)) return visited pacific_starts = [(i, 0) for i in range(m)] + [(0, j) for j in range(1, n)] atlantic_starts = [(i, n - 1) for i in range(m)] + [(m - 1, j) for j in range(n - 1)] pacific_reachable = bfs(pacific_starts) atlantic_reachable = bfs(atlantic_starts) return list(pacific_reachable.intersection(atlantic_reachable))"},{"question":"You are tasked with designing a class that maintains a set of intervals on the number line and supports two main operations: adding intervals and merging overlapping intervals. The class should efficiently support adding new intervals and returning a list of merged intervals. Implement the `IntervalManager` class: * `IntervalManager()` Initializes the object with an empty set of intervals. * `void addInterval(int[] interval)` Adds a new interval `interval = [start, end]` to the set of intervals. * `List<int[]> getMergedIntervals()` Returns a list of merged intervals, where overlapping intervals are merged into one continuous interval. The intervals in the returned list should be sorted in ascending order of their start points. For example, if the intervals added are `[1, 3]`, `[2, 5]`, and `[6, 8]`, the merged intervals would be `[1, 5]` and `[6, 8]`.","solution":"class IntervalManager: def __init__(self): self.intervals = [] def addInterval(self, interval): self.intervals.append(interval) self.intervals.sort() def getMergedIntervals(self): if not self.intervals: return [] merged = [] for interval in self.intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"You are given two strings `s` and `t` which represent two versions of software. The versions are formatted as sequences of numeric segments separated by dots, where each numeric segment starts with a non-negative integer. Write a function to compare the two versions. If version `s` is greater than `t`, return `1`, if `s` is less than `t`, return `-1`, otherwise return `0`. Note that the numeric segments are compared as integers and are of arbitrary length.","solution":"def compare_version(s, t): Compare two version strings, return 1 if s > t, -1 if s < t, and 0 if s == t. Args: s (str): first version string. t (str): second version string. Returns: int: comparison result. s_segments = s.split(\'.\') t_segments = t.split(\'.\') # Pad the shorter list with zeros max_length = max(len(s_segments), len(t_segments)) s_segments += [\'0\'] * (max_length - len(s_segments)) t_segments += [\'0\'] * (max_length - len(t_segments)) for s_seg, t_seg in zip(s_segments, t_segments): s_num, t_num = int(s_seg), int(t_seg) if s_num > t_num: return 1 elif s_num < t_num: return -1 return 0"},{"question":"You are given an unsorted integer array `arr`. Write a function to find the **smallest missing positive integer** from the array. You must solve it in **O(n)** time and use **O(1)** additional space. Return _the smallest missing positive integer.","solution":"def first_missing_positive(arr): Returns the smallest missing positive integer from the unsorted array. This function runs in O(n) time complexity and uses O(1) additional space. n = len(arr) # First, segregate all positive numbers for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # Then find the first instance where the index + 1 does not match the value for i in range(n): if arr[i] != i + 1: return i + 1 # All positions are filled correctly, thus return n + 1 return n + 1"},{"question":"You are given a list of `logs` where each log is a space-separated string containing two identifiers. The first identifier is a user ID and the second identifier is a timestamp. Each user can have multiple logs, but all timestamps within a user\'s logs are unique. Determine the maximum number of logs any user has at a given timestamp by identifying the maximum number of logs corresponding to the same timestamp across the users. Return _the user(s) who have the maximum number of logs at a particular timestamp_. If there are multiple users with the same number of logs at that timestamp, return a list of user IDs sorted lexicographically.","solution":"def max_logs_per_user(logs): Determine the user(s) who have the maximum number of logs at a particular timestamp. If there are multiple users with the same number of logs at that timestamp, return a list of user IDs sorted lexicographically. Parameters: logs (List[str]): A list of log strings where each log is a space-separated user ID and timestamp Returns: List[str]: A list of user IDs sorted lexicographically from collections import defaultdict user_logs = defaultdict(lambda: defaultdict(int)) # Nested dictionary for user -> timestamp -> count for log in logs: user_id, timestamp = log.split() user_logs[user_id][timestamp] += 1 max_count = 0 max_users = [] for user_id, timestamps in user_logs.items(): total_logs = sum(timestamps.values()) if total_logs > max_count: max_count = total_logs max_users = [user_id] elif total_logs == max_count: max_users.append(user_id) return sorted(max_users)"},{"question":"You are given two strings `needle` and `haystack` representing a small string and a bigger string respectively. Your task is to return the starting index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`. You need to implement it with an efficient algorithm to handle large input sizes.","solution":"def strStr(haystack, needle): Returns the starting index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. if not needle: return 0 len_haystack = len(haystack) len_needle = len(needle) # Edge case where the length of needle is greater than len_haystack which means it can\'t be in the haystack if len_needle > len_haystack: return -1 # Sliding window algorithm for i in range(len_haystack - len_needle + 1): if haystack[i:i+len_needle] == needle: return i return -1"},{"question":"Given an integer array `height` representing the heights of walls where the width of each wall is 1, compute how much water it can trap between the walls after raining. Return an integer representing the total amount of water trapped.","solution":"def trap(height): Calculates the total amount of water trapped between walls after raining. :param height: List[int], the elevation map where the width of each bar is 1. :return: int, total water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given a **0-indexed** array `arr` of integers, your task is to find the **minimum** number of operations required to make `arr` non-decreasing. In one operation, you can increment the value of any element in `arr` by `1`. An array is considered non-decreasing if for all `i` such that `0 <= i < arr.length - 1`, `arr[i] <= arr[i+1]`. Return the minimum number of operations needed.","solution":"def min_operations_to_non_decreasing(arr): Returns the minimum number of operations required to make the array non-decreasing. if not arr: return 0 operations = 0 for i in range(1, len(arr)): if arr[i] < arr[i - 1]: operations += arr[i - 1] - arr[i] arr[i] = arr[i - 1] return operations"},{"question":"You are given a **0-indexed** integer array `heights` of length `n` where `heights[i]` represents the height of a person standing in a queue. A queue is said to be sorted if every person can see the person in front of them, i.e., for every `i`, `0 <= i < n-1`, `heights[i] <= heights[i+1]`. You are required to determine the minimum number of people that need to be moved from their current position to sort the queue. Return _the minimum number of moves required to make the queue sorted_.","solution":"def min_moves_to_sort_queue(heights): Returns the minimum number of moves required to make the queue sorted. n = len(heights) sorted_heights = sorted(heights) mismatch_count = 0 for i in range(n): if heights[i] != sorted_heights[i]: mismatch_count += 1 return mismatch_count"},{"question":"You are given a string `s` consisting of lowercase letters and an array of pairs of indices in the string where each pair `(a, b)` indicates that the characters at these indices can be swapped. You are allowed to swap the characters at the given indices any number of times to make the string as lexicographically smallest as possible. Return _the lexicographically smallest string that can be obtained_ by performing the allowed swaps. Example input: ```python s = \\"dcab\\" pairs = [[0, 3], [1, 2]] ``` Example output: ```python \\"bacd\\" ```","solution":"def smallestStringWithSwaps(s, pairs): parent = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for i in range(len(s)): parent[i] = i for x, y in pairs: union(x, y) groups = {} for i in range(len(s)): root = find(i) if root not in groups: groups[root] = [] groups[root].append(i) s = list(s) for group in groups.values(): chars = [s[i] for i in group] chars.sort() for i, char in zip(sorted(group), chars): s[i] = char return \'\'.join(s)"},{"question":"Given an integer array `nums` and an integer `k`, return true if there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and the absolute difference between `i` and `j` is at most `k`. Otherwise, return false. Implement a function: ```python def containsNearbyDuplicate(nums: List[int], k: int) -> bool: ``` # Example ```python containsNearbyDuplicate([1, 2, 3, 1], 3) -> True containsNearbyDuplicate([1, 0, 1, 1], 1) -> True containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2) -> False ``` # Constraints - `1 <= nums.length <= 10^5` - `-10^9 <= nums[i] <= 10^9` - `0 <= k <= 10^5`","solution":"from typing import List def containsNearbyDuplicate(nums: List[int], k: int) -> bool: Determines if there are two distinct indices i and j in the array nums such that nums[i] == nums[j] and the absolute difference between i and j is at most k. num_indices = {} for i, num in enumerate(nums): if num in num_indices and i - num_indices[num] <= k: return True num_indices[num] = i return False"},{"question":"You are given a 2D matrix `matrix` of size `n x m` and an integer `target`. Each row in the matrix is sorted in non-decreasing order. Write a function to find whether the `target` exists in the matrix. Return `true` if the target exists, otherwise return `false`. The function should aim to have a time complexity of O(n + m).","solution":"def search_matrix(matrix, target): Searches for the target in a matrix where each row is sorted in non-decreasing order. Uses a time complexity of O(n + m). Parameters: matrix (list of list of int): The 2D matrix. target (int): The target number to be searched. Returns: bool: True if the target is found, False otherwise. if not matrix or not matrix[0]: return False n = len(matrix) m = len(matrix[0]) # Start from the top right corner row = 0 col = m - 1 while row < n and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given an integer array `heights` representing the heights of buildings along a street, where `heights[i]` is the height of the ith building. You are allowed to increase the height of any building by 1 unit multiple times. However, the total number of increases cannot exceed `k` units. Return _the maximum height that any building can reach after applying the given number of increases_.","solution":"def maxBuildingHeight(heights, k): Returns the maximum height that any building can reach after applying at most k increases. max_current = max(heights) possible_max = max_current + k return possible_max"},{"question":"Suppose you have a list of words `wordsList` and an array of integers `indices` of the same length. For each index `i` in `indices`, remove the `i`-th letter from the word located at `wordsList[i]`. Return the list of modified words. If `i` is out of the range for any word in `wordsList`, leave that word unchanged.","solution":"def remove_ith_letter(wordsList, indices): Removes the ith letter from each word in wordsList based on the corresponding index in indices. If an index is out of bounds for a word, that word is returned unchanged. :param wordsList: List of words. :param indices: List of indices specifying which letter to remove in each word. :return: List of words with the specified letters removed. modified_words = [] for word, index in zip(wordsList, indices): if 0 <= index < len(word): modified_word = word[:index] + word[index+1:] else: modified_word = word modified_words.append(modified_word) return modified_words"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to select `k` distinct characters from the string such that the number of substrings containing at least one of the selected characters is minimized. Return _the minimum number of substrings _ that contain at least one of these `k` characters.","solution":"def min_substrings_with_k_chars(s, k): Returns the minimum number of substrings containing at least one of the k selected characters. from collections import Counter # Count the frequency of each character in the string s freq = Counter(s) # Sort the frequencies in ascending order sorted_freq = sorted(freq.values()) # Sum the lowest k frequencies min_substrings = sum(sorted_freq[:k]) return min_substrings"},{"question":"You are given two strings `s1` and `s2` of equal length, and a list of pairs of indices `pairs` where each pair `[i, j]` indicates that the characters `s1[i]` and `s2[j]` can be swapped with each other. Create a function to determine if `s1` can be converted to `s2` using any number of swaps indicated by the pairs. Return _true_ if it is possible to convert `s1` to `s2`, otherwise return _false_.","solution":"def can_convert(s1, s2, pairs): Determine if s1 can be converted to s2 using the swaps in pairs. if len(s1) != len(s2): return False # Create a graph where each node represents an index and edges represent allowed swaps from collections import defaultdict graph = defaultdict(set) for i, j in pairs: graph[i].add(j) graph[j].add(i) # Helper function to perform DFS and collect all connected indices def dfs(node, visited, indices): visited.add(node) indices.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, indices) visited = set() for i in range(len(s1)): if i not in visited: indices = [] dfs(i, visited, indices) # Collect all characters from s1 and s2 at the connected indices s1_chars = sorted([s1[idx] for idx in indices]) s2_chars = sorted([s2[idx] for idx in indices]) # If the sorted characters do not match, conversion is not possible if s1_chars != s2_chars: return False return True"},{"question":"You are given two positive integers `n` and `m`. Generate a binary matrix of size `n x m` such that: - Each row and each column contain an equal number of 1\'s and 0\'s. - If such a matrix is not possible, return an empty array. A binary matrix has entries only 0 or 1. Return _the binary matrix or an empty array if it is impossible to generate the matrix with the given constraints_.","solution":"def generate_binary_matrix(n, m): Generate a binary matrix of size `n x m` such that each row and each column contain an equal number of 1\'s and 0\'s if possible. Otherwise, return an empty array. # Check if it is possible to create such a matrix if n % 2 != 0 or m % 2 != 0: return [] # Initialize the matrix with 0\'s matrix = [[0] * m for _ in range(n)] for i in range(n): for j in range(i % 2, m, 2): matrix[i][j] = 1 # Return the generated binary matrix return matrix"},{"question":"You are given a string `s` representing a code snippet. A proper nesting of brackets is defined as follows: An empty string has proper nesting. If `A` and `B` have proper nesting, `AB` also has proper nesting. If `A` has proper nesting, `(A)`, `{A}`, and `[A]` also have proper nesting. Given the string `s`, determine whether it has proper nesting. If it does, return `true`. Otherwise, return `false`. Implement the `isNested` function: * `boolean isNested(String s)` Receives a string `s` and returns `true` if it has proper nesting of brackets, otherwise returns `false`.","solution":"def isNested(s): Returns true if the string s has proper nesting of brackets, otherwise returns false. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in \'({[\': stack.append(char) elif char in \')}]\': if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return not stack"},{"question":"Given two arrays `nums1` and `nums2`, both of which represent positive integers in non-increasing order, merge them to form a single array that is sorted in strictly decreasing order. The final merged array should not contain any duplicate elements. Return the merged array as the result.","solution":"def merge_decreasing(nums1, nums2): Merges two arrays, nums1 and nums2, that represent positive integers in non-increasing order into a single array that is sorted in strictly decreasing order and contains no duplicates. # Combine the arrays and convert to a set to remove duplicates merged_set = set(nums1 + nums2) # Convert the set back to a list and sort in decreasing order merged_list = sorted(merged_set, reverse=True) return merged_list"},{"question":"Given a list of integers `nums`, rearrange the elements so that every `nums[i]` is less than or equal to `nums[i + 1]` if `i` is even, and `nums[i]` is greater than or equal to `nums[i + 1]` if `i` is odd. The transformed list should be returned. If there are multiple ways to achieve this, return any valid transformed list. Implement the function: ```python def rearrange_alternating(nums: List[int]) -> List[int]: # your code here ``` # Example: Input: `nums = [3, 5, 2, 1, 6, 4]` Output: `[1, 5, 2, 6, 3, 4]` Explanation: The transformed list achieves the conditions `nums[0] <= nums[1]` (1 <= 5), `nums[2] <= nums[3]` (2 <= 6), and `nums[4] <= nums[5]` (3 <= 4). The odd indexed elements are also correctly arranged such that `nums[1] >= nums[2]` (5 >= 2) and `nums[3] >= nums[4]` (6 >= 3). Multiple valid outputs are possible.","solution":"def rearrange_alternating(nums): Rearranges the elements of nums such that nums[i] <= nums[i + 1] if i is even, and nums[i] >= nums[i + 1] if i is odd. for i in range(len(nums) - 1): if i % 2 == 0: if nums[i] > nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] else: if nums[i] < nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums"},{"question":"You are given an integer array `nums` and an integer `k`. We call an array beautiful if it satisfies the following two conditions: 1. Every index `i` in `nums` has at most `k` positions containing an element equal to `nums[i]` to its left (including `i` itself). 2. Every index `i` in `nums` has at most `k` positions containing an element equal to `nums[i]` to its right (including `i` itself). Return the length of the longest beautiful subarray of `nums`. Note: A subarray is a contiguous part of an array.","solution":"def longest_beautiful_subarray(nums, k): Returns the length of the longest beautiful subarray of nums. n = len(nums) longest = 0 def check_beautiful(subarray): count = {} for num in subarray: if num in count: count[num] += 1 else: count[num] = 1 if count[num] > k: return False return True for start in range(n): for end in range(start, n): subarray = nums[start:end+1] if check_beautiful(subarray): longest = max(longest, end - start + 1) return longest"},{"question":"Given an integer array `arr` consisting of `n` integers and an integer `target`, return _the **minimum number of operations** required to make the array\'s sum equal to the target_. In one operation, you can choose any integer from the array and either increment or decrement it by 1. If it\'s not possible to reach the target sum, return `-1`.","solution":"def min_operations_to_target_sum(arr, target): This function returns the minimum number of operations to make the sum of array equal to the target. In one operation, we can increment or decrement any element by 1. If it\'s not possible to achieve the target sum, the function returns -1. current_sum = sum(arr) difference = abs(target - current_sum) # The number of operations needed is the absolute difference between # the current sum of the array and the target sum. return difference"},{"question":"You are given a string `s` representing a sentence containing words and spaces. Each word in the string is separated by a single space, and there are no leading or trailing spaces. Write a function that returns the string with the words in the reverse order. For example, if `s = \\"hello world\\"`, the function should return `\\"world hello\\"`. Ensure to maintain the exact spacing between words as in the original sentence.","solution":"def reverse_words(s): Reverses the order of words in the given sentence. Parameters: s (str): The input sentence. Returns: str: The sentence with words in reversed order. words = s.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"You are given a string `s` consisting of lowercase English letters and a list of words `wordDict`. Determine if the string `s` can be segmented into a sequence of one or more words found in `wordDict`. The same word in the dictionary may be reused multiple times in the segmentation. Return `true` if `s` can be segmented, otherwise, return `false`. Ensure your solution has a time complexity that is efficient for longer strings and larger dictionaries.","solution":"def wordBreak(s, wordDict): Determine if s can be segmented into a sequence of one or more words found in wordDict. :param s: String to be segmented :param wordDict: List of words that can be used in segmentation :return: True if s can be segmented, otherwise False dp = [False] * (len(s) + 1) dp[0] = True wordSet = set(wordDict) for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in wordSet: dp[i] = True break return dp[-1]"},{"question":"You are given two strings `s1` and `s2` consisting of lowercase English letters. Determine if you can transform `s1` into `s2` using the following operation zero or more times: choose a character from `s1` and insert it into any position within the string. Only insertions are allowed, and you cannot delete or rearrange any other characters. Return `true` if you can transform `s1` into `s2`, otherwise return `false`.","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 by only inserting characters. # If s1 is longer than s2, transformation is impossible if len(s1) > len(s2): return False # Pointers to track positions in s1 and s2 i, j = 0, 0 # Traverse both strings to check if all characters in s1 appear in s2 in the same order while i < len(s1) and j < len(s2): if s1[i] == s2[j]: i += 1 j += 1 # If we have traversed the entire s1, then transformation is possible return i == len(s1)"},{"question":"Given a string `s` of lowercase English letters and an integer `k`, you need to find the length of the longest substring of `s` such that the number of distinct characters in this substring is less than or equal to `k`. Return _this length as an integer_.","solution":"def longest_substring_with_k_distinct_chars(s, k): Returns the length of the longest substring with at most k distinct characters. if k == 0: return 0 n = len(s) left = 0 right = 0 max_length = 0 char_map = {} while right < n: if s[right] not in char_map: char_map[s[right]] = 0 char_map[s[right]] += 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"A valid parentheses string is either empty (\\"\\"), contains only \\"()\\" or catenation of two or more valid parentheses strings. Given a valid parentheses string `s`, find the score of the string based on the following rules: 1. The score of an empty string is 0. 2. The score of \\"()\\" is 1. 3. The score of the concatenation of two valid parentheses strings `A` and `B` is `score(A) + score(B)`. 4. The score of a valid parentheses string `(\\")\\"` is `2 * score(s)` where `s` is a valid parentheses string. Return the score of the given string s.","solution":"def score_of_parentheses(s): Calculate the score of a valid parentheses string. :param s: A valid parentheses string :return: The score as an integer stack = [0] # Initialization with a zero to handle the base score for char in s: if char == \'(\': stack.append(0) else: v = stack.pop() stack[-1] += max(2 * v, 1) return stack[0]"},{"question":"Given a list of `n` integers representing daily stock prices, where `prices[i]` is the price of a given stock on day `i`, return the maximum profit you can achieve by buying and selling the stock with the following constraints: you may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times), but you must sell the stock before you buy it again. You cannot engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Given these constraints, calculate the maximum profit by adding up the differences between consecutive days where you would have sold the stock at a higher price than when you bought it. Return the maximum profit as an integer.","solution":"def max_profit(prices): Calculate the maximum profit with as many transactions as allowed. :param prices: List of integers representing daily stock prices :return: Integer, maximum profit achievable profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: profit += prices[i] - prices[i - 1] return profit"},{"question":"You are given an integer array `nums` where each element represents the number of coins in a pile. Two players, Alice and Bob, take turns starting with Alice, and each turn a player must take all the coins from one pile. The game continues until all the coins are taken. The player with the higher total number of coins at the end wins. If the total number of coins taken by both players is the same, the game results in a draw. Each player plays optimally to maximize their total number of coins. Return the maximum number of coins Alice can have if both players play optimally.","solution":"def maxCoinsAlice(nums): Returns the maximum number of coins Alice can have if both players play optimally. Args: nums (list): List of integers where each element represents the number of coins in a pile. Returns: int: The maximum number of coins Alice can collect. # Sort the coins in descending order, so Alice can pick the largest piles first sorted_piles = sorted(nums, reverse=True) # Alice starts first and takes all coins in every alternate pile alice_total = sum(sorted_piles[i] for i in range(0, len(sorted_piles), 2)) return alice_total"},{"question":"You are given a binary string `s` which consists only of \'0\'s and \'1\'s. A binary string is considered alternating if no two adjacent characters are the same. For example, \\"010101\\" and \\"1010\\" are alternating, while \\"00011\\" and \\"001\\" are not. Your task is to determine the minimum number of flips (\'0\' to \'1\' or \'1\' to \'0\') required to make the given string `s` an alternating binary string. Implement a function `minFlipsToAlternating(s: String) -> int`.","solution":"def minFlipsToAlternating(s): Returns the minimum number of flips required to make the binary string alternating. n = len(s) # Create two possible alternating patterns of the same length as s pattern1 = \'\'.join(\'01\'[(i%2 == 0)] for i in range(n)) pattern2 = \'\'.join(\'10\'[(i%2 == 0)] for i in range(n)) # Count mismatches between string s and both patterns mismatches1 = sum(1 for i in range(n) if s[i] != pattern1[i]) mismatches2 = sum(1 for i in range(n) if s[i] != pattern2[i]) # The minimum number of flips will be the minimum of mismatches1 and mismatches2 return min(mismatches1, mismatches2)"},{"question":"Given a list of non-negative integers representing the amount of money of each house, you are tasked with determining the maximum amount of money you can rob tonight without alerting the police. The constraint is that adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Write a function `rob(int[] nums)` that takes a list of non-negative integers representing the money at each house and returns the maximum amount of money you can rob without robbing two adjacent houses. Example: ``` Input: [2, 7, 9, 3, 1] Output: 12 Explanation: Rob house 1 (money = 2) and then rob house 3 (money = 9) and then rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. ``` Constraints: - `0 <= nums.length <= 100` - `0 <= nums[i] <= 400`","solution":"def rob(nums): if not nums: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"We are given a list of integers `nums` where each integer is either `0` (a space) or a positive number representing a unique ASCII value of a character in the alphabet. Write a function that converts this list back into its original string representation by mapping each number to its corresponding character and concatenating the characters together. Spaces in the string are represented by `0` in the list. Return the final decoded string.","solution":"def decode_string(nums): Decode the list of numbers into its original string representation. Args: nums : list of int List containing 0s (representing space) or positive ASCII values of characters. Returns: str Decoded string. decoded_chars = [chr(num) if num != 0 else \' \' for num in nums] return \'\'.join(decoded_chars)"},{"question":"Given an integer array `heights` where each element represents the height of a person. We need to return a new array `result` where `result[i]` is the count of people standing in front of the `i-th` person who are taller than the `i-th` person. Note that the array `heights` is not sorted, and for each person, we need to consider only the people standing before them in the array.","solution":"def count_taller_people_in_front(heights): Returns a new array where each element at index i contains the count of people standing in front of the i-th person who are taller than the i-th person. Parameters: heights (list): List of integers where each integer represents the height of a person. Returns: list: A list containing counts of taller people standing in front of each person. result = [] for i in range(len(heights)): count = 0 for j in range(i): if heights[j] > heights[i]: count += 1 result.append(count) return result"},{"question":"You are given two strings `start` and `end`, both of which are of the same length and consist of only lowercase alphabetical characters. You can transform `start` into `end` using a series of moves. In each move, you can change one character in `start` to any other lowercase alphabetical character. Your task is to determine the minimum number of moves required to transform `start` into `end`. Return the minimum number of moves needed.","solution":"def min_moves_to_transform(start, end): Returns the minimum number of moves required to transform start into end. if len(start) != len(end): raise ValueError(\\"The lengths of start and end must be the same.\\") moves = 0 for s_char, e_char in zip(start, end): if s_char != e_char: moves += 1 return moves"},{"question":"Given an array of integers `sticks` where `sticks[i]` represents the length of the `i-th` stick, you need to connect all the sticks into one. The cost of connecting two sticks is equal to the sum of their lengths. Return _the minimum cost to connect all the sticks into one stick_. * For example, if `sticks = [2, 4, 3]`, you can connect the sticks as follows: - Connect `[2, 3]` for a cost of `2 + 3 = 5`. - Connect `[5, 4]` for a cost of `5 + 4 = 9`. The total cost is `5 + 9 = 14`.","solution":"import heapq def connect_sticks(sticks): Returns the minimum cost to connect all the sticks into one stick. :param sticks: List[int], a list of integers representing the lengths of the sticks. :return: int, the minimum cost to connect all sticks. if not sticks: return 0 # Create a min heap heapq.heapify(sticks) total_cost = 0 while len(sticks) > 1: # Extract two shortest sticks first = heapq.heappop(sticks) second = heapq.heappop(sticks) # Combine sticks and calculate the cost cost = first + second total_cost += cost # Add the combined stick back to the heap heapq.heappush(sticks, cost) return total_cost"},{"question":"You are given an array of integers `nums`. You want to maximize the sum of any non-empty subarray of `nums` such that exactly one element in the subarray is removed. Define a subarray as a contiguous sequence of elements within the array. Return the maximum possible sum you can obtain by removing exactly one element from any subarray of `nums`.","solution":"def maximum_sum_removing_one_element(nums): Returns the maximum possible sum of any subarray of nums with exactly one element removed. n = len(nums) if n == 1: return 0 left_max = [0] * n right_max = [0] * n max_ending_here = nums[0] left_max[0] = nums[0] for i in range(1, n): max_ending_here = max(max_ending_here + nums[i], nums[i]) left_max[i] = max(left_max[i-1], max_ending_here) max_ending_here = nums[-1] right_max[-1] = nums[-1] for i in range(n-2, -1, -1): max_ending_here = max(max_ending_here + nums[i], nums[i]) right_max[i] = max(right_max[i+1], max_ending_here) max_sum = float(\'-inf\') for i in range(n): if i == 0: max_sum = max(max_sum, right_max[i+1]) elif i == n-1: max_sum = max(max_sum, left_max[i-1]) else: max_sum = max(max_sum, left_max[i-1] + right_max[i+1]) return max_sum"},{"question":"Given a binary tree, imagine yourself standing on the **right** side of it. Return the values of the nodes you can see ordered from **top to bottom**. Construct a function `List<Integer> rightSideView(TreeNode root)` where `TreeNode` is a class that represents a node in the binary tree with attributes `int val`, `TreeNode left`, and `TreeNode right`. The function should yield the list of visible node values from the right side view.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = [root] while queue: level_length = len(queue) for i in range(level_length): node = queue.pop(0) if i == level_length - 1: # If it\'s the rightmost element at the level result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"You are given a directed graph represented by an adjacency list, where each node is a course and the edges represent prerequisites for that course. Each course aims to be finished once all its prerequisites are completed. Determine if it is possible to finish all courses given the prerequisite constraints. Return _true_ if all courses can be completed, otherwise return _false_.","solution":"def can_finish(num_courses, prerequisites): Determines if all courses can be finished given the prerequisite constraints. Parameters: num_courses (int): The total number of courses. prerequisites (List[List[int]]): A list where each element is a pair [a, b] indicating that course a requires course b as prerequisite. Returns: bool: True if all courses can be finished, False otherwise. from collections import defaultdict, deque # Create adjacency list course_dict = defaultdict(list) indegree = [0] * num_courses # Build the graph and calculate in-degrees for prerequisite in prerequisites: next_course, prev_course = prerequisite course_dict[prev_course].append(next_course) indegree[next_course] += 1 # Initialize queue with courses having 0 in-degree zero_indegree_queue = deque([course for course in range(num_courses) if indegree[course] == 0]) # Count of courses that have 0 in-degree count_of_courses = 0 while zero_indegree_queue: course = zero_indegree_queue.popleft() count_of_courses += 1 for next_course in course_dict[course]: indegree[next_course] -= 1 if indegree[next_course] == 0: zero_indegree_queue.append(next_course) # If count_of_courses equals num_courses, all courses can be finished return count_of_courses == num_courses"},{"question":"Given a list of **non-empty** strings `words` where each string is composed of lowercase English letters. Two strings are considered **similar** if they have the same characters with the same frequency of occurrences, but possibly in different orders. For example, `\\"abc\\"` and `\\"bca\\"` are similar, but `\\"abc\\"` and `\\"aabc\\"` are not. Return _the number of **distinct** groups of similar strings that can be formed._ For example, given `words = [\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\", \\"yxz\\", \\"foo\\", \\"ofo\\"]`, the function should return `3` since there are three groups of similar strings: `[\\"abc\\", \\"bca\\", \\"cab\\"], [\\"xyz\\", \\"zyx\\", \\"yxz\\"], and [\\"foo\\", \\"ofo\\"]`.","solution":"def num_similar_groups(words): from collections import Counter def get_signature(word): return tuple(sorted((char, count) for char, count in Counter(word).items())) unique_signatures = set() for word in words: signature = get_signature(word) unique_signatures.add(signature) return len(unique_signatures)"},{"question":"Given an unsorted array of integers, return an array of the same length where each element is replaced with the smallest element from the original array that is larger than the current element. If there is no such element, replace it with `-1`. The replacement should be done in O(n log n) time complexity.","solution":"import bisect def replace_with_next_larger(arr): Replace each element in the array with the smallest element from the original array that is larger than the current element. If there\'s no such element, replace it with -1. sorted_arr = sorted(arr) result = [] for num in arr: pos = bisect.bisect_right(sorted_arr, num) if pos < len(sorted_arr): result.append(sorted_arr[pos]) else: result.append(-1) return result"},{"question":"You are given a string `s` consisting of lowercase English letters, and you need to determine the minimum number of characters that must be added to the string to make it a palindrome. A palindrome is a string that reads the same forward and backward. You may add characters at any position in the string. Write a function `int minInsertionsToPalindrome(String s)` that returns the minimum number of insertions required to make `s` a palindrome.","solution":"def minInsertionsToPalindrome(s): Returns the minimum number of insertions required to make s a palindrome. n = len(s) # Create a dp array to store the minimum insertions needed # to make substring s[i:j] a palindrome dp = [[0] * n for _ in range(n)] # Fill the dp array for length in range(2, n + 1): # length of the substring for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1]"},{"question":"Given an `n x n` 2D matrix `matrix` where each row and each column is sorted in ascending order, return _the k-th smallest element in the matrix_. Note that it is the k-th smallest element in the sorted order, not the k-th distinct element. You must solve the problem in O(k log n) time complexity.","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in the sorted order from an n x n matrix. n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract smallest elements from the heap one by one for _ in range(k): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return element"},{"question":"You are given an integer array `numbers` which contains the first `n` natural numbers (i.e., from 1 to n) in a random order. However, one of the numbers from this sequence is missing. Write a function that finds and returns the missing number. The function should have a time complexity of O(n) and use constant additional space.","solution":"def find_missing_number(numbers): Finds the missing number in the array of first n natural numbers. :param numbers: List[int] - array containing first n natural numbers from 1 to n with one missing :return: int - the missing number n = len(numbers) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(numbers) return total_sum - actual_sum"},{"question":"You are given a rectangular grid consisting of `n` rows and `m` columns represented by a **2D** array `grid` where `grid[i][j]` can either be `0` (empty) or `1` (occupied). Your task is to find the **smallest** rectangular subgrid that contains all the `1`s present in the entire grid. Return _an array_ `[r1, c1, r2, c2]` _where (`r1`, `c1`) are the coordinates of the top-left corner and (`r2`, `c2`) are the coordinates of the bottom-right corner of the smallest subgrid_. If there are no `1`s in the grid, return an empty list.","solution":"def smallest_subgrid(grid): n = len(grid) if n == 0: return [] m = len(grid[0]) if m == 0: return [] min_row, max_row = n, -1 min_col, max_col = m, -1 for i in range(n): for j in range(m): if grid[i][j] == 1: if i < min_row: min_row = i if i > max_row: max_row = i if j < min_col: min_col = j if j > max_col: max_col = j if min_row == n: return [] return [min_row, min_col, max_row, max_col]"},{"question":"You are given a list of non-negative integers `nums` that represents the heights of buildings. You need to reduce the height of each building to zero. In one operation, you can: - Select any segment of consecutive buildings. - Decrease the height of every building in this segment by 1. Return _the minimum number of operations required to make the height of all buildings in_ `nums` _equal to zero_.","solution":"def min_operations(nums): Returns the minimum number of operations needed to make all buildings\' heights zero. Parameters: nums (list): A list of non-negative integers representing the heights of buildings. Returns: int: The minimum number of operations to make all heights zero. if not nums: return 0 operations = 0 current_height = 0 for height in nums: if height > current_height: operations += height - current_height current_height = height return operations"},{"question":"Given an integer array `nums`, return the maximum product of two distinct elements from the array. You must select two different elements such that their product is maximized. For example, if `nums = [1, 5, 4, 8]`, the maximum product of two distinct elements would be `40` (selecting elements `5` and `8`). The array will contain at least **two** elements.","solution":"def max_product(nums): Returns the maximum product of two distinct elements in the array nums. if len(nums) < 2: return 0 # Less than 2 elements, no valid product # Sort the list in descending order so that the first two elements are the largest nums_sorted = sorted(nums, reverse=True) # The maximum product will be the product of the two largest elements return nums_sorted[0] * nums_sorted[1]"},{"question":"You are given a `2-dimensional` grid of integers where each cell represents the elevation at that point. Find the **path** from the **top-left** to the **bottom-right** corner that minimizes the **maximum** elevation you encounter along the path. You can move up, down, left, or right but cannot pass through the same cell more than once. Return the **maximum** elevation you encounter along the optimal path. <pre> For example, given the grid: [ [1, 2, 2], [3, 8, 2], [5, 3, 5] ] The optimal path is [1, 2, 2, 2, 5], and the maximum elevation along this path is 5. Therefore, the return value is 5. </pre>","solution":"import heapq def min_max_elevation_path(grid): Find the path from the top-left to the bottom-right corner that minimizes the maximum elevation encountered along the path. :param grid: List[List[int]]: 2D grid of integers representing elevations :return: int: The maximum elevation encountered along the optimal path rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] pq = [(grid[0][0], 0, 0)] # (elevation, row, col) max_elevation = [[float(\'inf\')]*cols for _ in range(rows)] max_elevation[0][0] = grid[0][0] while pq: elevation, r, c = heapq.heappop(pq) if r == rows - 1 and c == cols - 1: return elevation for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: new_elevation = max(elevation, grid[nr][nc]) if new_elevation < max_elevation[nr][nc]: max_elevation[nr][nc] = new_elevation heapq.heappush(pq, (new_elevation, nr, nc)) return -1 # In case there\'s no valid path"},{"question":"You are given a list of `n` distinct integers `arr` and an integer `k`. Find the number of pairs `(i, j)` such that `0 <= i < j < n` and `(arr[i] + arr[j]) % k == 0`. Return the number of such pairs.","solution":"def count_pairs(arr, k): Returns the number of pairs (i, j) such that 0 <= i < j < n and (arr[i] + arr[j]) % k == 0. :param arr: List of distinct integers :param k: Integer k :return: Number of such pairs n = len(arr) count = 0 for i in range(n): for j in range(i+1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"You are given a list of `n` unique integers and a target sum `S`. Your task is to determine if there exists a subset of the list such that the sum of the subset is equal to `S`. Return `true` if such a subset exists, otherwise return `false`.","solution":"def subset_sum(nums, S): Determines if there exists a subset of `nums` that sums to `S`. :param nums: List of unique integers. :param S: Target sum. :return: True if a subset sums to `S`, False otherwise. n = len(nums) # Initialize a DP table with False values dp = [[False] * (S + 1) for _ in range(n + 1)] # There\'s always a way to make the sum 0 - with the empty subset for i in range(n + 1): dp[i][0] = True # Populate the DP table for i in range(1, n + 1): for j in range(1, S + 1): if nums[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] return dp[n][S]"},{"question":"You are given a binary tree where each node contains an integer value. Return the **level order traversal** of the nodes\' values as an array of arrays. Level order traversal of a tree is breadth-first traversal for the tree, which means visiting all the nodes at depth `0` (root), then all the nodes at depth `1`, and so on. Each sub-array should contain the values of nodes at each level in the order they are visited.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root): Returns the level order traversal of a binary tree. :param root: TreeNode, the root of the binary tree :return: List[List[int]], list of levels with node values if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"A car racing organization wants to calculate the performance of drivers in a race. The race track is a circular loop with `n` checkpoints. Each checkpoint has a specific speed limit. You are given two integer arrays `speed_limits` and `driver_speeds` of length `n` where `speed_limits[i]` and `driver_speeds[i]` correspond to the speed limit and the driver\'s speed at checkpoint `i`, respectively. The driver\'s compliance with the speed limits is important. Calculate the maximum number of checkpoints where the driver was within the speed limit. Return _the maximum number of checkpoints with no speed violations._","solution":"def max_checkpoints_within_limit(speed_limits, driver_speeds): Calculate the maximum number of checkpoints where the driver was within the speed limit. Parameters: speed_limits (list of int): The speed limits at each checkpoints. driver_speeds (list of int): The driver\'s speeds at each checkpoints. Returns: int: Maximum number of checkpoints with no speed violations. max_checkpoints = 0 for limit, speed in zip(speed_limits, driver_speeds): if speed <= limit: max_checkpoints += 1 return max_checkpoints"},{"question":"You are given an array of integers `nums`, where each element represents the number of votes a candidate has received in an election. Among the candidates, find the one with the highest number of votes. If there is a tie, return the candidate who appears first in the array. Return _the index of the winning candidate in the array_.","solution":"def find_winning_candidate(nums): Returns the index of the candidate with the highest number of votes. If there is a tie, the candidate who appears first in the array is returned. Parameters: nums (list of int): A list of integers representing votes for each candidate. Returns: int: The index of the winning candidate. if not nums: return -1 # Return -1 if the list is empty max_votes = nums[0] winning_index = 0 for i in range(1, len(nums)): if nums[i] > max_votes: max_votes = nums[i] winning_index = i return winning_index"},{"question":"You are given an integer array `heights` representing the height of each consecutive segment of a terrain. The difference in height between consecutive segments forms a valley if and only if there exists some segment `i` (1 ≤ i < heights.length - 1) such that: `heights[i-1] > heights[i] < heights[i+1]`. Return the number of such valleys in the given terrain.","solution":"def count_valleys(heights): Returns the count of valleys in the given terrain heights list. A valley is defined as a segment i (1 <= i < len(heights) - 1) such that: heights[i-1] > heights[i] < heights[i+1] :param heights: List[int] :return: int valley_count = 0 for i in range(1, len(heights) - 1): if heights[i-1] > heights[i] < heights[i+1]: valley_count += 1 return valley_count"},{"question":"You are given an array of integers `nums` representing `n` sticks of varying lengths. You want to form a square using all these sticks. You should determine if you can form a square using all the sticks. A square must have all its four sides equal in length. Return `true` if you can form a square with all the sticks, otherwise return `false`.","solution":"def can_form_square(nums): Returns whether all the sticks in the list nums can form a square. if not nums or len(nums) < 4: return False total_length = sum(nums) if total_length % 4 != 0: return False side_length = total_length // 4 nums.sort(reverse=True) sides = [0] * 4 def dfs(index): if index == len(nums): return all(side == side_length for side in sides) for i in range(4): if sides[i] + nums[index] <= side_length: sides[i] += nums[index] if dfs(index + 1): return True sides[i] -= nums[index] return False return dfs(0)"},{"question":"Given a string `s` consisting only of characters \'a\' and \'b\', your task is to transform the string into a string of the same length which contains no two consecutive \'a\'s and no two consecutive \'b\'s by replacing some (possibly zero) characters. Each character can either be replaced with the other character (\'a\' to \'b\' and \'b\' to \'a\') or remain unchanged. Return _the minimum number of replacements required to achieve this transformation_.","solution":"def min_replacements_to_alternate(s): Returns the minimum number of replacements required to transform string s such that there are no two consecutive \'a\'s and no two consecutive \'b\'s. target1 = \'ab\' * ((len(s) // 2) + 1) # \'ababab...\' target2 = \'ba\' * ((len(s) // 2) + 1) # \'bababa...\' count1 = sum(1 for i in range(len(s)) if s[i] != target1[i]) count2 = sum(1 for i in range(len(s)) if s[i] != target2[i]) return min(count1, count2)"},{"question":"Given the `head` of a singly linked list, reverse the nodes of the list `k` at a time, and return the modified list. `k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as they are. You may not alter the values in the list\'s nodes, only nodes themselves may be changed. Design an algorithm that runs in `O(n)` time complexity and uses `O(1)` extra space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): # Helper function to reverse the linked list in groups of k def reverse_linked_list(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head ptr = head count = 0 while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"You are given an array of integers `nums` and an integer `threshold`. You need to find the length of the shortest contiguous subarray such that the sum of its elements is greater than or equal to `threshold`. If there is no such subarray, return `-1`. The subarray must be contiguous and contiguous subarrays must maintain the order of elements in the original array.","solution":"def minSubArrayLen(nums, threshold): Returns the length of the shortest contiguous subarray such that the sum of its elements is greater than or equal to threshold. If no such subarray exists, returns -1. n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= threshold: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given an array of integers `nums` and an integer `k`, find a contiguous subarray whose length is exactly `k` that has the maximum average value. Return the maximum average value as a float. Example: If the input is nums = [1,12,-5,-6,50,3] and k = 4, the subarray [12,-5,-6,50] has the maximum average value of 12.75.","solution":"def find_max_average(nums, k): Given an array of integers nums and an integer k, find a contiguous subarray whose length is exactly k that has the maximum average value. Return the maximum average value as a float. # Initialize the sum of the first subarray of length k current_sum = sum(nums[:k]) max_sum = current_sum # Use a sliding window to find the maximum sum of any subarray of length k for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum # Return the maximum average value return max_sum / k # Example usage # nums = [1,12,-5,-6,50,3] # k = 4 # print(find_max_average(nums, k)) # Output: 12.75"},{"question":"Given a binary string `s`, return the maximum number of r-pairs of substrings `(s1, s2)` that you can get, where both `s1` and `s2` are non-empty substrings of `s` and `s1 + s2` is still a binary string with equal number of `0`s and `1`s. Note that the substrings `s1` and `s2` cannot overlap.","solution":"def max_r_pairs(s): Returns the maximum number of r-pairs of substrings (s1, s2) that can be obtained where both s1 and s2 are non-empty substrings of s and s1 + s2 has an equal number of 0s and 1s. zeros = s.count(\'0\') ones = s.count(\'1\') return min(zeros, ones)"},{"question":"You have been given a list of strings `patterns` and a string `text`. Each string in `patterns` contains only lowercase English letters and has a length between `1` and `50`. The `text` string contains only lowercase English letters and can have a length of up to `10^5`. Write a function to return an array of integers where each integer corresponds to the number of times the respective string in `patterns` appears as a substring in `text`. For example, given `patterns = [\\"a\\", \\"aa\\", \\"aaa\\"]` and `text = \\"aaaaa\\"`, the output should be `[5, 4, 3]` since the string \\"a\\" appears 5 times, \\"aa\\" appears 4 times, and \\"aaa\\" appears 3 times in \\"aaaaa\\".","solution":"def count_substrings(patterns, text): Returns a list of integers where each integer is the count of how many times each pattern appears as a substring in the text. :param patterns: List of strings to search for in the text :param text: The text in which to search for patterns :return: List of counts of each pattern in the text result = [] for pattern in patterns: count = 0 for i in range(len(text) - len(pattern) + 1): if text[i:i+len(pattern)] == pattern: count += 1 result.append(count) return result"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to perform a series of operations on the string such that every character in the string can be replaced by any other character any number of times. The cost of transforming one character `s[i]` to any other character is `1`. Return _the minimum **number** of operations needed to ensure that there are at least `k` **consecutive** identical characters in the string_.","solution":"def min_operations_to_k_consecutive(s, k): Returns the minimum number of operations needed to ensure that there are at least k consecutive identical characters in the string s. from collections import defaultdict max_freq = 0 counter = defaultdict(int) for i in range(len(s)): counter[s[i]] += 1 if i >= k: counter[s[i - k]] -= 1 max_freq = max(max_freq, counter[s[i]]) return k - max_freq"},{"question":"You are given an integer array `numbers` and an integer `k`. You can perform the following operation on the array up to `k` times: * Choose any two adjacent elements in the array and replace one of them with their sum. * You may replace the chosen elements in either order. Your goal is to maximize the sum of the resulting array after performing the operation up to `k` times. Return _the **maximum sum** of the array after at most `k` operations._","solution":"def maximize_array_sum(numbers, k): Maximizes the sum of the array after performing up to k operations. In each operation, we choose two adjacent elements and replace one of them with their sum to maximize the array sum. while k > 0 and len(numbers) > 1: max_sum_index = None max_sum_value = float(\'-inf\') for i in range(len(numbers) - 1): current_sum = numbers[i] + numbers[i + 1] if current_sum > max_sum_value: max_sum_value = current_sum max_sum_index = i numbers[max_sum_index] = max_sum_value del numbers[max_sum_index + 1] k -= 1 return sum(numbers)"},{"question":"You are given a string `s` and an integer `k`. You need to find out whether you can rearrange the characters in the string to form `k` palindrome strings. Return `true` if you can use all characters in the string to create `k` palindromes and `false` otherwise.","solution":"def can_form_k_palindromes(s, k): Determines if the characters in the string \'s\' can be rearranged to form \'k\' palindrome strings. Args: s (str): The input string. k (int): The number of palindrome strings to form. Returns: bool: True if \'k\' palindrome strings can be formed, otherwise False. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count the number of characters that appear an odd number of times odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # Check if the number of odd counts is less than or equal to k if odd_count <= k and len(s) >= k: return True else: return False"},{"question":"You are given a 2D integer array `events` where `events[i] = [starti, endi, valuei]`. Each event encompasses the time interval from `starti` to `endi` (both inclusive) and has a certain positive value `valuei`. You want to determine the maximum sum of values you can obtain from a subset of non-overlapping events. Return the maximum sum of values.","solution":"def maxSum_non_overlapping_events(events): Returns the maximum sum of values from a subset of non-overlapping events. # Sort events based on the end time events.sort(key=lambda x: x[1]) # Initialize dp array dp = [0] * len(events) dp[0] = events[0][2] def binary_search(events, end_time): low, high = 0, len(events) - 1 while low <= high: mid = (low + high) // 2 if events[mid][1] < end_time: if events[mid + 1][1] < end_time: low = mid + 1 else: return mid else: high = mid - 1 return -1 # Populate dp array considering the maximum sum of non-overlapping events for i in range(1, len(events)): current_value = events[i][2] previous_idx = binary_search(events, events[i][0]) if previous_idx != -1: current_value += dp[previous_idx] dp[i] = max(dp[i - 1], current_value) return dp[-1]"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the length of the longest substring in which the characters are arranged in alphabetical order consecutively (i.e., \'a\' followed by \'b\', \'b\' followed by \'c\', ..., up to \'y\' followed by \'z\'). Return _the length of this longest alphabetical substring_.","solution":"def longest_alphabetical_substring_length(s): Returns the length of the longest substring in which the characters are arranged in alphabetical order consecutively. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if ord(s[i]) == ord(s[i - 1]) + 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Given an array of integers `nums`, return the length of the longest contiguous subarray where every element is either strictly increasing or strictly decreasing. A strictly increasing subarray is one where for every `i` such that `0 <= i < len-1`, `nums[i] < nums[i+1]`. A strictly decreasing subarray is one where for every `i` such that `0 <= i < len-1`, `nums[i] > nums[i+1]`. The array must contain at least two elements in the considered subarray.","solution":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray where every element is either strictly increasing or strictly decreasing. if len(nums) < 2: return 0 max_len = 1 current_len = 1 is_increasing = None for i in range(1, len(nums)): if nums[i] > nums[i - 1]: if is_increasing is None or is_increasing: current_len += 1 else: current_len = 2 is_increasing = True elif nums[i] < nums[i - 1]: if is_increasing is None or not is_increasing: current_len += 1 else: current_len = 2 is_increasing = False else: current_len = 1 is_increasing = None max_len = max(max_len, current_len) return max_len"},{"question":"You are given a list of `n` integers. For each integer in the list, find the next smaller number that appears after it in the list. If there is no smaller number that appears after it, return `-1` for that number. Implement the `NextSmallerNumber` class: - `NextSmallerNumber(int[] nums)` Initializes the object with the list of integers `nums`. - `int[] findNextSmaller()` Returns an array of integers where each element is the next smaller number for the corresponding element in `nums` as described above.","solution":"class NextSmallerNumber: def __init__(self, nums): self.nums = nums def findNextSmaller(self): n = len(self.nums) result = [-1] * n stack = [] for i in range(n): while stack and self.nums[stack[-1]] > self.nums[i]: result[stack.pop()] = self.nums[i] stack.append(i) return result"},{"question":"You are given a list of strings `words` and an integer `k`. A word is defined as a contiguous sequence of non-space characters. You need to find out the top `k` frequent words from the list. The result should be the list of `k` most frequent words in descending order of their frequencies. If there are multiple words with the same frequency, they should appear according to their order in the original list. Return the list of `k` most frequent words.","solution":"from collections import Counter def top_k_frequent_words(words, k): Returns the top k frequent words from the list in descending order of frequency. If multiple words have the same frequency, they appear according to their order in the input list. count = Counter(words) # Create a sort key that prioritizes frequency (negated for descending order) and original order sorted_words = sorted(count, key=lambda x: (-count[x], words.index(x))) return sorted_words[:k]"},{"question":"You are given a **0-indexed** integer array `arr`. A 0-indexed integer array `result` of the same length is call a \\"balanced array\\" if for each index `i`, the sum of the elements to the left of `i` (excluding `arr[i]`) is equal to the sum of the elements to the right of `i` (excluding `arr[i]`). Your task is to check if the given array can be rearranged to form a \\"balanced array\\". If it is possible, return true, otherwise return false.","solution":"def can_form_balanced_array(arr): Check if the given array can be rearranged to form a balanced array. Parameters: arr (list of int): The input array. Returns: bool: True if a balanced array can be formed, otherwise False. total_sum = sum(arr) n = len(arr) # total_sum must be divisible by 2 for a balanced array if total_sum % 2 != 0: return False half_sum = total_sum // 2 left_sum = 0 # Find if there exists a subset with sum equal to half_sum seen_sums = set() for num in arr: left_sum += num seen_sums.add(left_sum) if (left_sum - half_sum) in seen_sums or left_sum == half_sum: return True return False"},{"question":"You are given an `n x m` grid `grid` where each cell has an integer value representing the elevation at that point. A **peak** is a cell that is not lower than any of its 4-directionally adjacent cells. A **valley** is a cell that is not higher than any of its 4-directionally adjacent cells. Return _a list with two integers where the first integer is the number of peaks and the second integer is the number of valleys in the grid_.","solution":"def count_peaks_and_valleys(grid): Returns a list with two integers where the first integer is the number of peaks and the second integer is the number of valleys in the grid. n = len(grid) m = len(grid[0]) if n > 0 else 0 def is_peak_or_valley(i, j): current = grid[i][j] adjacent = [] if i > 0: adjacent.append(grid[i-1][j]) if i < n-1: adjacent.append(grid[i+1][j]) if j > 0: adjacent.append(grid[i][j-1]) if j < m-1: adjacent.append(grid[i][j+1]) is_peak = all(current >= adj for adj in adjacent) is_valley = all(current <= adj for adj in adjacent) return is_peak, is_valley peaks = 0 valleys = 0 for i in range(n): for j in range(m): is_peak, is_valley = is_peak_or_valley(i, j) if is_peak: peaks += 1 if is_valley: valleys += 1 return [peaks, valleys]"},{"question":"Given a list of `n` positive integers representing daily stock prices, find the maximum profit you can achieve by making at most two transactions. Note that you cannot engage in multiple transactions simultaneously (you must sell the stock before you buy again). A transaction is defined as buying and then selling one share of the stock.","solution":"def max_profit_with_two_transactions(prices): if not prices: return 0 n = len(prices) left_profits = [0] * n right_profits = [0] * n # Forward phase - maximum profit up to day i min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) left_profits[i] = max(left_profits[i - 1], prices[i] - min_price) # Backward phase - maximum profit from day i onward max_price = prices[-1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) right_profits[i] = max(right_profits[i + 1], max_price - prices[i]) # Combine the two profits max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"A music streaming service wants to display its most played songs in a list of exactly `k` unique song IDs in the order of their popularity. You are given two arrays: `songIDs` and `plays`, where `songIDs[i]` represents the unique identifier of the song and `plays[i]` represents the number of times the song has been played. Write a function that returns a list of `k` song IDs such that the songs are sorted in descending order based on their play count. If two songs have the same number of plays, the song that appears first in the input list should come first in the output list.","solution":"def most_played_songs(songIDs, plays, k): Returns a list of k unique song IDs sorted in descending order based on their play count. from collections import defaultdict # Create a dictionary to count total plays per song play_count = defaultdict(int) # Fill the dictionary with song play counts for song_id, play in zip(songIDs, plays): play_count[song_id] += play # Sort the items based on the play count and then by the order they first appear in songIDs sorted_songs = sorted(play_count.items(), key=lambda x: (-x[1], songIDs.index(x[0]))) # Extract only the song IDs, limited to k elements result = [song_id for song_id, _ in sorted_songs[:k]] return result"},{"question":"```markdown [Question 4]: You are given a string `s` consisting of lowercase English letters. A **substring** is called a **homogeneous substring** if all the characters of the substring are the same. Return the number of **homogeneous substrings** in `s`. **Note**: * A **substring** is a contiguous sequence of characters within a string. * Two substrings are considered different if they start or end at different positions in the string, even if they consist of the same characters. ```","solution":"def count_homogeneous_substrings(s): Returns the number of homogeneous substrings in the given string s. count = 0 length = 1 # length of the current homogeneous substring for i in range(1, len(s)): if s[i] == s[i - 1]: length += 1 else: count += length * (length + 1) // 2 length = 1 # Adding the count for the last homogeneous sequence count += length * (length + 1) // 2 return count"},{"question":"You are given a list of non-negative integers `nums` and a target integer `K`. Your task is to return the length of the shortest subarray whose sum is at least `K`. If no such subarray exists, return `-1`.","solution":"from collections import deque def shortest_subarray(nums, K): Returns the length of the shortest subarray with a sum of at least K. If no such subarray exists, return -1. n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] deque_index = deque() result = float(\'inf\') for i in range(n + 1): while deque_index and prefix_sum[i] - prefix_sum[deque_index[0]] >= K: result = min(result, i - deque_index.popleft()) while deque_index and prefix_sum[i] <= prefix_sum[deque_index[-1]]: deque_index.pop() deque_index.append(i) return result if result != float(\'inf\') else -1"},{"question":"You are given an integer array `nums` and an integer `d`. The array `nums` is **circular**, which means the last element of the array is adjacent to the first element. Find the **maximum sum** of a subarray of length `d` in this circular array. A subarray of length `d` means a contiguous segment of the array of exactly `d` elements. Return the maximum sum encountered.","solution":"def max_sum_subarray_circular(nums, d): n = len(nums) if n == 0 or d <= 0 or d > n: return 0 # Create a new array that considers the circular nature by appending the array to itself nums_extended = nums + nums # Calculate the sum of the first subarray of length d current_sum = sum(nums_extended[:d]) max_sum = current_sum # Use the sliding window approach to find the maximum sum subarray of length d for i in range(1, n): current_sum = current_sum - nums_extended[i - 1] + nums_extended[i + d - 1] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a string `s`, which represents a sequence of operations where each operation can be \'Push\' (push an element onto the stack), \'Pop\' (pop an element from the stack), or \'Top\' (read the top element of the stack), implement a stack and execute the sequence of operations accordingly. You\'ll be provided with a set of initial integers to be pushed onto the stack in sequence during the \'Push\' operations. Return the list of results of the \'Top\' operations. If a \'Pop\' or \'Top\' operation is attempted on an empty stack, ignore that operation.","solution":"class Stack: def __init__(self): self.stack = [] self.index = 0 def push(self, value): self.stack.append(value) def pop(self): if self.stack: self.stack.pop() def top(self): if self.stack: return self.stack[-1] return None def execute_operations(s, initial_values): stack = Stack() results = [] index = 0 for operation in s: if operation == \'Push\': if index < len(initial_values): stack.push(initial_values[index]) index += 1 elif operation == \'Pop\': stack.pop() elif operation == \'Top\': top_value = stack.top() if top_value is not None: results.append(top_value) return results"},{"question":"You are given a grid `grid` of size `m x n` consisting of values \'0\' and \'1\'. A \'1\' represents land and a \'0\' represents water. An **island** is a maximal 4-directionally connected group of \'1\'s. The **perimeter** of an island is the total length of its boundary edges. You need to find the perimeter of the largest island in the given grid. Each side of a cell is considered a boundary if it is touching water (\'0\') or the edge of the grid. Return _the perimeter of the largest island in the grid_.","solution":"def largest_island_perimeter(grid): Returns the perimeter of the largest island in the grid. def dfs(r, c): stack = [(r, c)] visited.add((r, c)) perimeter = 0 island_size = 0 while stack: x, y = stack.pop() island_size += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == \'0\': perimeter += 1 elif grid[nx][ny] == \'1\' and (nx, ny) not in visited: stack.append((nx, ny)) visited.add((nx, ny)) else: perimeter += 1 return perimeter, island_size m, n = len(grid), len(grid[0]) visited = set() max_perimeter = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\' and (i, j) not in visited: perimeter, island_size = dfs(i, j) if island_size > 0: max_perimeter = max(max_perimeter, perimeter) return max_perimeter"},{"question":"Given a binary tree, imagine each node has an additional pointer called `sibling` that points to the next node in the same level. Populate each `sibling` pointer for all nodes. If there is no next node, the `sibling` pointer should be set to `null`. Return the root of the modified binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, sibling=None): self.val = val self.left = left self.right = right self.sibling = sibling def populate_sibling_pointers(root): if not root: return None current = root dummy = TreeNode() while current: level_current = dummy while current: if current.left: level_current.sibling = current.left level_current = level_current.sibling if current.right: level_current.sibling = current.right level_current = level_current.sibling current = current.sibling current = dummy.sibling dummy.sibling = None return root"},{"question":"Given an integer array `A` which consists of only 0s and 1s. You are allowed to flip the value of any bit (from 0 to 1 or from 1 to 0) within a specified range `[L, R]` (inclusive). Your task is to determine the maximum number of contiguous 1s that can be achieved in the array by performing at most one flip operation. If no flip is needed, return the length of the longest contiguous 1s within the array. Note: You only get one flip operation, meaning you can only flip the values in one continuous subarray of `A`.","solution":"def max_contiguous_1s_after_one_flip(A): n = len(A) # Track maximum sequence of 1s we can achieve with one flip max_1s = 0 # Use two pointers to consider every possible range for a flip for L in range(n): original_sequence_length = 0 flip_count = 0 for R in range(L, n): if A[R] == 0: flip_count += 1 original_sequence_length += 1 # Ensure we are only flipping at most one set of 0s if flip_count <= 1: max_1s = max(max_1s, original_sequence_length) else: break return max_1s"},{"question":"Write a function that takes a binary tree and returns its zigzag level order traversal. The zigzag level order traversal of a binary tree is a level order traversal where the nodes at the odd levels (starting from the root at level 0) are traversed from left to right, and the nodes at the even levels are traversed from right to left.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"Given a list of integers `nums`, return the longest consecutive elements sequence\'s length. A consecutive elements sequence is a sequence in which each element is exactly one more than the previous element. For example, given `nums = [100, 4, 200, 1, 3, 2]`, the longest consecutive elements sequence in this case is `[1, 2, 3, 4]`, and its length is `4`. Your function should be able to handle edge cases where the list is empty and should aim for an efficient solution in terms of time complexity.","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the list nums. if not nums: return 0 num_set = set(nums) max_length = 0 for num in nums: if num - 1 not in num_set: # only start counting from the beginning of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"A frog is currently located at the top-left corner of a `n x n` grid. The frog can jump to any of the neighboring cells to the east (right), west (left), north (up), or south (down). The frog may also jump to any cell located directly diagonally. You are given an integer `n` representing the size of the grid and a list of impassable cells `(i, j)`, where `0 <= i, j < n`, meaning that the frog cannot pass through or land on these cells. Given the initial position, determine whether the frog can reach the bottom-right corner of the grid. Return `true` if the frog can reach the bottom-right corner, otherwise return `false`. The frog can only move to valid cells within the grid, and cannot land on or cross through impassable cells.","solution":"def is_reachable(n, impassable): Determines whether the frog can reach the bottom-right corner of the grid. :param n: size of the grid (n x n) :param impassable: list of tuples representing impassable cells :return: True if the frog can reach the bottom-right corner, False otherwise from collections import deque # Directions for moving in 8 possible way (left, right, up, down, and 4 diagonals) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] # Convert impassable list to a set for faster lookups impassable_set = set(impassable) # Initial State start = (0, 0) # Top-left corner goal = (n-1, n-1) # Bottom-right corner if start in impassable_set or goal in impassable_set: return False queue = deque([start]) visited = set([start]) while queue: current = queue.popleft() if current == goal: return True for direction in directions: new_row = current[0] + direction[0] new_col = current[1] + direction[1] new_position = (new_row, new_col) if 0 <= new_row < n and 0 <= new_col < n and new_position not in impassable_set and new_position not in visited: queue.append(new_position) visited.add(new_position) return False"},{"question":"You are given a string `s` containing only lowercase English letters. You have to rearrange the characters of the string such that two consecutive characters are not the same. If it is not possible to rearrange the string in such a way, return an empty string. If there are multiple valid rearrangements, return any one of them. Write a function to achieve this reorganization and ensure that the algorithm is efficient and handles edge cases appropriately.","solution":"from heapq import heappop, heappush from collections import Counter def reorganizeString(s): Rearranges the characters of the string s such that no two consecutive characters are the same. If it is not possible, returns an empty string. # Count frequency of each character freq = Counter(s) # Create a max heap based on frequency (negative for max-heap since Python\'s heapq is min-heap) max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) prev_count, prev_char = 0, \'\' result = [] # Build the result string while max_heap: count, char = heappop(max_heap) result.append(char) # Push the previous character back into the heap if it\'s count is not zero if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char # Decrement the count result_string = \'\'.join(result) # If the length of the result string does not match input string, return empty string if len(result_string) != len(s): return \\"\\" return result_string"},{"question":"You are given an integer array `arr` and an integer `k`. You are allowed to perform exactly `k` operations on the array where, in each operation, you can increment any element of the array by 1. A subarray is defined as a contiguous segment of the array. Return the _length of the longest subarray_ where the difference between the maximum and minimum elements is less than or equal to 1 after performing exactly `k` operations.","solution":"def longest_subarray_with_k_operations(arr, k): Returns the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to 1 after performing exactly k operations. Parameters: - arr: List[int] - the input array - k: int - the number of operations allowed to increment any element of the array by 1 Returns: - int - the length of the longest subarray from collections import defaultdict def can_form_longest_subarray(mid): extra_operations = 0 count_map = defaultdict(int) for i in range(mid): count_map[arr[i]] += 1 min_element = min(count_map) max_element = max(count_map) extra_operations = sum([max_element - key for key in count_map]) if extra_operations <= k: return True for i in range(mid, len(arr)): count_map[arr[i]] += 1 count_map[arr[i - mid]] -= 1 if count_map[arr[i - mid]] == 0: del count_map[arr[i - mid]] min_element = min(count_map) max_element = max(count_map) extra_operations = sum([max_element - key for key in count_map]) if extra_operations <= k: return True return False left, right = 1, len(arr) result = 0 while left <= right: mid = (left + right) // 2 if can_form_longest_subarray(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"You are given a **binary tree** where each node has a value. The value of each node is a binary digit (0 or 1). The **path value** for any path in the tree is defined as the binary number formed by the sequence of node values from the **root to a leaf** node. Return the **sum** of all **unique path values** in the tree. **For example, given the binary tree: ``` 1 / 0 1 / 0 1 1 ``` The unique root-to-leaf paths are `100`, `101`, and `111`, which correspond to the binary numbers 4, 5, and 7 respectively. The sum of all these path values is `16` (4+5+7). Keep in mind, the binary tree\'s nodes can be null. If the root is null, return `0`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_root_to_leaf_numbers(root): Calculates the sum of all unique path values from the root to the leaf nodes. def dfs(node, current_path): if not node: return 0 # Update the current path value current_path = (current_path << 1) | node.value # If it is a leaf node, return the current path value if not node.left and not node.right: return current_path # Otherwise, continue the DFS on the children return dfs(node.left, current_path) + dfs(node.right, current_path) return dfs(root, 0)"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `target`. Your task is to decide if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal to `target`. Return _`True` if such a partition exists, otherwise return `False`_. Note: Each element in the array should be in exactly one subset, and the array must not be rearranged.","solution":"def can_partition(nums, target): Determines if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal to target. Args: nums (list of int): The input array of integers. target (int): The target sum for each subset. Returns: bool: True if such a partition exists, otherwise False. n = len(nums) total = sum(nums) # Early exit if the total sum is not 2 * target if total != 2 * target: return False # Initialize dp array dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"You are given two **0-indexed** integer arrays `arr1` and `arr2` each of length `n`, and an integer `x`. Your task is to determine if there exist two integers `i` and `j` such that `0 <= i, j < n` and `abs(arr1[i] - arr2[j]) == x`. Return _true_ if such values `i` and `j` exist, and _false_ otherwise.","solution":"def exists_pair_with_difference(arr1, arr2, x): Determines if there exist two integers i and j such that 0 <= i, j < n and abs(arr1[i] - arr2[j]) == x. :param arr1: List[int] - First list of integers :param arr2: List[int] - Second list of integers :param x: int - The target difference :return: bool - True if such a pair exists, False otherwise set_arr2 = set(arr2) for a in arr1: if a - x in set_arr2 or a + x in set_arr2: return True return False"},{"question":"You are given a **0-indexed** integer array `arr` consisting of `n` elements, an integer `k`, and an integer `threshold`. Your task is to determine how many subarrays of length `k` have an average greater than or equal to the `threshold`. A subarray is a contiguous sequence of elements within an array. Return _the number of subarrays of length_ `k` _with an average greater than or equal to the_ `threshold`.","solution":"def numOfSubarrays(arr, k, threshold): Returns the number of subarrays of length k with an average greater than or equal to the threshold. count = 0 window_sum = sum(arr[:k]) target_sum = threshold * k if window_sum >= target_sum: count += 1 for i in range(k, len(arr)): window_sum += arr[i] - arr[i - k] if window_sum >= target_sum: count += 1 return count"},{"question":"Given an array of integers `arr`, return the length of the longest contiguous subarray where each element in the subarray differs from the previous element by exactly `1` or `-1`. For example, consider `arr = [1, 2, 3, 2, 3, 4, 5]`, the longest contiguous subarray that satisfies the condition would be `[1, 2, 3, 2, 3, 4, 5]` with a length of 7.","solution":"def longest_contiguous_subarray(arr): if not arr: return 0 longest_length = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) == 1: current_length += 1 else: longest_length = max(longest_length, current_length) current_length = 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"You are given a 0-indexed integer array `nums` containing `n` unique positive integers. Additionally, you are provided with an integer `target`. Your task is to find two distinct indices `i` and `j` in the array such that `nums[i] * nums[j]` equals `target`, or return an empty array if no such pair exists. Write a function that returns the list of indices `[i, j]` where `i < j`. If there are multiple valid pairs, return the pair with the smallest `i` first. If there is still a tie, return the pair with the smallest `j`.","solution":"def find_indices(nums, target): Returns the indices [i, j] such that nums[i] * nums[j] == target and i < j. If no such pair exists, returns an empty array. n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] * nums[j] == target: return [i, j] return []"},{"question":"A **string transformation** can be achieved by performing zero or more operations. Each operation consists of selecting a non-empty substring of some string `s` and either reversing it or replacing every character in it with any character from \'a\' to \'z\'. Given an initial string `s` and a target string `t`, determine if it is possible to convert `s` into `t` using the aforementioned operations. Return `true` if it is possible, otherwise return `false`. For example, given `s = \\"abc\\"` and `t = \\"cba\\"`, you can reverse the substring \\"abc\\" to get \\"cba\\" which matches `t`. But if `s = \\"abc\\"` and `t = \\"aab\\"`, you can replace the substring \\"bc\\" with \\"ba\\" to get \\"aba\\" and then reverse the substring \\"aba\\" to get \\"aab\\", which matches `t`. However, if `s = \\"abc\\"` and `t = \\"def\\"`, it is not possible to achieve the transformation with any combination of the allowed operations.","solution":"def can_transform(s, t): Determines if it is possible to convert string s into string t using the allowed operations. # If s and t are of different lengths, transformation is not possible if len(s) != len(t): return False # Since we can replace any substring\'s characters to any characters \'a\'-\'z\', # the transformation is always possible as long as the lengths match. return True"},{"question":"You are given an array `heights` of integers representing the heights of trees in a forest, and an integer `d` representing the maximum jump distance you can make. You can start from any tree and move to another tree if the difference in height between the starting tree and the target tree is at most `d`. Return _the maximum number of trees you can visit starting from any tree_. Note that you cannot visit a tree more than once in a single path.","solution":"def max_trees(heights, d): n = len(heights) if n == 0: return 0 dp = [1] * n for i in range(n): for j in range(i): if abs(heights[i] - heights[j]) <= d: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given an array of integers `nums` and an integer `k`, your task is to find the `k-th` smallest element in the array. Note that it is the `k-th` smallest element in the sorted order, not the `k-th` distinct element. You are asked to solve it in such a way that the time complexity is better than O(n log n). Return the `k-th` smallest element of the array.","solution":"def quickSelect(nums, low, high, k): if low == high: return nums[low] pivot_index = partition(nums, low, high) if k == pivot_index: return nums[k] elif k < pivot_index: return quickSelect(nums, low, pivot_index - 1, k) else: return quickSelect(nums, pivot_index + 1, high, k) def partition(nums, low, high): pivot = nums[high] i = low for j in range(low, high): if nums[j] <= pivot: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[high] = nums[high], nums[i] return i def findKthSmallest(nums, k): return quickSelect(nums, 0, len(nums) - 1, k - 1)"},{"question":"You are given an array of positive integers representing the heights of walls in a row. Each wall is at a certain position and the width of each wall is 1. Suppose it rains and water is trapped between the walls, calculate how much water is trapped. The width of the array is the same as the width between the walls. Return the total amount of trapped water.","solution":"def trap(height): Calculate the total amount of water trapped between walls. :param height: List[int], a list of positive integers representing the height of walls. :return: int, the total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] right_max[n-1] = height[n-1] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given a binary tree, implement an algorithm to find the maximum width of the tree. The width of a binary tree is the maximum number of nodes in a single level. Your algorithm should traverse through the tree and determine the level with the most nodes, returning that count. For example, given the binary tree: ``` 1 / 2 3 / 4 5 8 9 ``` The maximum width of the binary tree is `3`, which is the width of the 4th level with nodes `4, 5, and 8`.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_width_of_binary_tree(root): if not root: return 0 max_width = 0 queue = deque([root]) while queue: level_length = len(queue) max_width = max(max_width, level_length) for _ in range(level_length): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return max_width"},{"question":"You are given an integer array `nums` where each number is unique and an integer `target`. You have to determine if it is possible to rearrange the elements of `nums` to form a strictly increasing order of elements that sums up to `target`. If possible, return `true`, otherwise return `false`. **Example:** ``` Input: nums = [4, 1, 3, 2], target = 10 Output: true Explanation: The array can be rearranged to [1, 2, 3, 4] which sums up to 10. Input: nums = [5, 6, 7], target = 14 Output: false Explanation: No rearrangement of the array sums up to 14. ```","solution":"def can_rearrange_to_sum(nums, target): Determine if it is possible to rearrange nums to form a strictly increasing order of elements that sums up to target. nums.sort() current_sum = 0 for num in nums: current_sum += num if current_sum == target: return True if current_sum > target: return False return False"},{"question":"Given an `m x n` matrix `grid` of integers (where `m` and `n` represent the number of rows and columns respectively), a __square__ is defined as a contiguous section in the grid bounded by four corners. Return the length of the side of the largest square containing only 1\'s. If there is no such square, return 0. Example: - Input: grid = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] - Output: 2 In this example, the largest square containing only 1\'s has a side length of 2.","solution":"def maximalSquare(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"You are given an undirected weighted graph with `n` nodes labeled from `0` to `n-1` and an edge list where each edge is represented as a triplet `(u, v, w)` indicating there is an edge between nodes `u` and `v` with weight `w`. Your task is to return the length of the shortest path from node `0` to node `n-1`. If there is no such path, return `-1`.","solution":"import heapq from collections import defaultdict def shortest_path(n, edges): Return the length of the shortest path from node 0 to node n-1. If there is no such path, return -1. :param n: Number of nodes. :param edges: List of edges where each edge is represented as a triplet (u, v, w) indicating an edge between nodes u and v with weight w. :return: Length of the shortest path from node 0 to node n-1 or -1 if no such path exists. # Create adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra\'s Algorithm initialization min_heap = [(0, 0)] # (distance, node) distances = {i: float(\'inf\') for i in range(n)} distances[0] = 0 visited = set() while min_heap: current_distance, u = heapq.heappop(min_heap) if u in visited: continue visited.add(u) for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) shortest_distance = distances[n-1] return shortest_distance if shortest_distance != float(\'inf\') else -1"},{"question":"Implement a class `UndergroundSystem` to track the check-in and check-out times and calculate average trip times for a subway system. The system has the following methods: * `checkIn(int id, String stationName, int t)`: A customer with id `id` checks in at station `stationName` at time `t`. * `checkOut(int id, String stationName, int t)`: A customer with id `id` checks out from station `stationName` at time `t`. * `getAverageTime(String startStation, String endStation)`: Returns the average time taken to travel between the start station `startStation` and end station `endStation`. Keep in mind the following: * It is guaranteed that a customer checks in once and only once before checking out. * All stations are represented as strings, and id is an integer. * `checkIn` and `checkOut` have a time complexity of `O(1)`, and `getAverageTime` should have a time complexity of `O(1)` on average.","solution":"class UndergroundSystem: def __init__(self): self.check_ins = {} self.travel_times = {} def checkIn(self, id, stationName, t): self.check_ins[id] = (stationName, t) def checkOut(self, id, stationName, t): start_station, start_time = self.check_ins.pop(id) trip = (start_station, stationName) if trip not in self.travel_times: self.travel_times[trip] = (0, 0) total_time, total_trips = self.travel_times[trip] total_time += t - start_time total_trips += 1 self.travel_times[trip] = (total_time, total_trips) def getAverageTime(self, startStation, endStation): total_time, total_trips = self.travel_times[(startStation, endStation)] return total_time / total_trips"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. An operation involves picking a subarray of length `k` and reversing it. Return the minimum number of such operations required to sort the array in non-decreasing order. If it is not possible to sort the array using the given operation, return `-1`.","solution":"def min_operations_to_sort(arr, k): Returns the minimum number of operations required to sort the array in non-decreasing order by reversing subarrays of length k. If it\'s not possible, return -1. n = len(arr) target = sorted(arr) # Check if array is already sorted if arr == target: return 0 # If k == 1, it\'s impossible to sort array by reversing subarrays because elements can\'t change position if k == 1: return -1 # If k == n, we can reverse the entire array in one operation if k == n: return 1 if arr[::-1] == target else -1 # If k is even, we can always sort the array by reverting k-length segments iteratively if k % 2 == 0: return 1 return 1 if len(arr) % k == 0 else -1"},{"question":"Given an integer array `nums` of length `n`, return the length of the longest **subsequence** such that elements of the subsequence are sorted in a strictly increasing order. A **subsequence** is a sequence derived by deleting some or none of the elements in the array without changing the order of the remaining elements. For example, for the array `[3, 6, 2, 7]`, the subsequence `[3, 6, 7]` is valid but `[6, 3, 7]` is not.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a string `orders` that contains a sequence of orders represented by characters \'P\', \'D\', and \'R\'. \'P\' stands for \\"Place Order\\", \'D\' stands for \\"Deliver Order\\", and \'R\' stands for \\"Return Order\\". You have a warehouse that processes orders in the sequence they appear in the string. Implement a function to simulate the warehouse processing these orders and return the total number of items currently in the warehouse. Each \'P\' adds one item to the warehouse, \'D\' removes one item provided there is at least one item to deliver, and \'R\' does nothing to the count of items. The string is guaranteed to be non-empty and contains only the characters \'P\', \'D\', and \'R\'.","solution":"def process_orders(orders): Processes a sequence of orders and returns the total number of items currently in the warehouse. :param orders: A string containing a sequence of \'P\', \'D\', and \'R\'. :return: An integer representing the total number of items in the warehouse. warehouse_count = 0 for order in orders: if order == \'P\': warehouse_count += 1 elif order == \'D\': if warehouse_count > 0: warehouse_count -= 1 # \'R\' does nothing to the count of items return warehouse_count"},{"question":"You are given a 2D binary grid `grid` of size `m x n`, where each cell is either `0` (representing water) or `1` (representing land). An island is a maximal 4-directionally connected group of `1`s. You can assume all four edges of the grid are surrounded by water. You need to find the largest island formed by flipping exactly one `0` (a water cell) into a `1` (a land cell). If there is no possible way to create a larger island, return the size of the largest island already present. _Return the maximum size of an island you can obtain._","solution":"def find_largest_island(grid): from collections import defaultdict def dfs(x, y, index): stack = [(x, y)] grid[x][y] = index area = 0 while stack: i, j = stack.pop() area += 1 for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1: grid[ni][nj] = index stack.append((ni, nj)) return area m, n = len(grid), len(grid[0]) index = 2 area_map = defaultdict(int) for i in range(m): for j in range(n): if grid[i][j] == 1: area_map[index] = dfs(i, j, index) index += 1 max_area = max(area_map.values(), default=0) for i in range(m): for j in range(n): if grid[i][j] == 0: seen = set() for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > 1: seen.add(grid[ni][nj]) new_area = 1 + sum(area_map[ind] for ind in seen) max_area = max(max_area, new_area) return max_area"},{"question":"Given an array of integers `heights` representing the height of buildings along a street, return the number of buildings that have a clear view to the west. A building has a clear view to the west if there are no taller buildings to its left. The height of the building is determined in comparison to all previous buildings in the array (i.e., buildings with smaller indices). For example, a building at index `i` has a clear view to the west if for all `j < i`, `heights[j] < heights[i]`. Consider the special case when there are no buildings to the left of a particular building (i.e., it is the first building), it always has a clear view to the west. Return the number of buildings with a clear view to the west.","solution":"def count_clear_view_buildings(heights): Returns the number of buildings that have a clear view to the west. Parameters: heights (list of int): List of building heights. Returns: int: Number of buildings with a clear view to the west. if not heights: return 0 count = 1 # The first building always has a clear view max_height = heights[0] for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"You are given a 2D grid `grid` of size `m x n`. Each cell of the grid contains a value representing the height of that cell. You\'re also given an integer `height_threshold`. You can move from a cell to its neighboring cell horizontally or vertically if and only if the height of the neighboring cell does not exceed the height of the current cell by more than 1. Write a function to determine the smallest value in the grid that is greater than or equal to `height_threshold` which, if treated as the starting point, allows you to traverse a path that includes the maximum number of cells. The function should return the height value of this starting cell. If no such path can be created, return `-1`.","solution":"from collections import deque def can_traverse(grid, m, n, sr, sc, threshold): visited = [[False] * n for _ in range(m)] queue = deque([(sr, sc)]) visited[sr][sc] = True count = 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]: if abs(grid[nr][nc] - grid[r][c]) <= 1: visited[nr][nc] = True queue.append((nr, nc)) count += 1 return count def find_best_starting_point(grid, m, n, height_threshold): best_start_value = float(\'inf\') max_reachable_cells = 0 for r in range(m): for c in range(n): if grid[r][c] >= height_threshold: reachable_cells = can_traverse(grid, m, n, r, c, height_threshold) if reachable_cells > max_reachable_cells or (reachable_cells == max_reachable_cells and grid[r][c] < best_start_value): best_start_value = grid[r][c] max_reachable_cells = reachable_cells return -1 if best_start_value == float(\'inf\') else best_start_value"},{"question":"You are given an integer array `nums`. An element in the array is defined as a **dominant element** if it is greater than all elements to its right. Return an array of all the **dominant elements** in the same order as they appear in `nums`. For example, if `nums` is `[16, 17, 4, 3, 5, 2]`, the output should be `[17, 5, 2]`.","solution":"def find_dominant_elements(nums): Returns an array of dominant elements from the given list of integers. An element is dominant if it is greater than all elements to its right. if not nums: return [] dominant_elements = [] max_from_right = float(\'-inf\') for num in reversed(nums): if num > max_from_right: dominant_elements.append(num) max_from_right = num return dominant_elements[::-1]"},{"question":"Given an array of integers `nums`, where each `nums[i]` represents the price of a stock on the `i-th` day, your task is to determine the maximum profit you could achieve if you were allowed to complete **at most one transaction**. A transaction is defined as buying one share of the stock and selling it on a different subsequent day. You cannot buy a stock before the `i-th` day and sell it on or before the same day. Return an integer `maxProfit` representing the maximum profit achievable from this single transaction. If no profit is possible, return `0`.","solution":"def maxProfit(prices): Given a list of prices where each price represents the stock price on the i-th day, this function returns the maximum profit achievable from one transaction. :param prices: List[int] - A list of integers representing stock prices :return: int - The maximum profit from one transaction, or 0 if no profit is possible if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given a list of integers `arr` and an integer `k`. Determine whether it is possible to partition the list `arr` into `k` subsets such that the sum of the elements in each subset is the same. Write a function `canPartitionKSubsets(arr, k)` that returns a boolean value indicating whether such a partitioning is possible. **Example 1:** **Input:** `arr = [4, 3, 2, 3, 5, 2, 1]`, `k = 4` **Output:** `True` **Explanation:** It\'s possible to partition `arr` into 4 subsets: `[5], [1, 4], [2, 3], [2, 3]` which all have equal sums. **Example 2:** **Input:** `arr = [1, 2, 3, 4]`, `k = 3` **Output:** `False` **Explanation:** It\'s not possible to partition `arr` into 3 subsets with equal sums. **Constraints:** - `1 <= k <= arr.length <= 16` - `0 <= arr[i] <= 10^4`","solution":"def canPartitionKSubsets(arr, k): def can_partition(start, k, current_sum, target, visited): if k == 1: return True if current_sum == target: return can_partition(0, k - 1, 0, target, visited) for i in range(start, len(arr)): if not visited[i] and current_sum + arr[i] <= target: visited[i] = True if can_partition(i + 1, k, current_sum + arr[i], target, visited): return True visited[i] = False return False total = sum(arr) if total % k != 0: return False target_sum = total // k visited = [False] * len(arr) arr.sort(reverse=True) return can_partition(0, k, 0, target_sum, visited)"},{"question":"You are given two strings `s` and `p` where `p` is a pattern that includes lowercase letters and may contain the wildcard character `\'.\'` which matches any single character, and the character `\'*\'` which matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Implement a function that checks if `s` matches the pattern `p`. Return `true` if it matches, otherwise, return `false`.","solution":"def is_match(s, p): Returns True if string s matches pattern p, otherwise returns False. Pattern p may include: - \'.\' which matches any single character - \'*\' which matches zero or more of the preceding element m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(2, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if p[j - 2] == s[i - 1] or p[j - 2] == \'.\' else False) else: dp[i][j] = False return dp[m][n]"},{"question":"You are given a string `s` consisting of characters \'L\', \'R\', and \'U\'. A robot initially at position (0, 0) in a 2D grid will execute the commands in `s` step-by-step: * If the command is \'L\', it moves one unit left (decrementing the x-coordinate by 1). * If the command is \'R\', it moves one unit right (incrementing the x-coordinate by 1). * If the command is \'U\', it moves one unit up (incrementing the y-coordinate by 1). Return _the robot\'s final position as a list_ [x, y] _after executing all the commands._","solution":"def final_position(s): Returns the final position of the robot after executing the commands in s. x, y = 0, 0 for command in s: if command == \'L\': x -= 1 elif command == \'R\': x += 1 elif command == \'U\': y += 1 return [x, y]"},{"question":"You are given a string `s` of lowercase alphabetic characters and a 2D array `operations`. Each operation is defined as `[type, left, right, char]` where `type` can be either 1 or 2: 1. For a query of type 1, `operations[i] = [1, left, right, char]`. Replace all occurrences of `char` in the substring `s[left:right+1]` with the character that comes after `char` in the alphabet (a `z` wraps around to `a`). 2. For a query of type 2, `operations[i] = [2, left, right, char]`. Count the number of times `char` appears in the substring `s[left:right+1]` and return this count. Return an array containing the results of all type 2 queries.","solution":"def process_operations(s, operations): Processes the given operations on the string `s`. Args: - s (str): The input string. - operations (list of lists): The list of operations where each operation is represented by a list. Returns: - list: A list of results for all type 2 queries. def replace_next_char(c): return chr(((ord(c) - ord(\'a\') + 1) % 26) + ord(\'a\')) s_list = list(s) results = [] for operation in operations: type_op, left, right, char = operation if type_op == 1: for i in range(left, right + 1): if s_list[i] == char: s_list[i] = replace_next_char(char) elif type_op == 2: count = sum(1 for i in range(left, right + 1) if s_list[i] == char) results.append(count) return results"},{"question":"A company has a hierarchical structure represented as a tree where each node represents an employee. The topmost node is the CEO. Each employee can have multiple direct reports but only one direct manager. You are given a list of `edges` where `edges[i] = [manager, employee]` indicates that the `employee` directly reports to the `manager`. You are also given a dictionary `performance` where `performance[i]` represents the performance score of employee `i`. Implement a function `maxPerformanceInLineOfCommand(CEO, edges, performance)` that returns the maximum total performance score of any direct line of command starting from the CEO down to any of the hierarchy\'s leaf nodes (an employee without any direct reports). A direct line of command is defined as a path in the tree starting from the CEO and ending at any leaf node, moving down through the hierarchical tree structure following the `edges`. **Example:** ``` edges = [[1, 2], [1, 3], [2, 4], [3, 5], [3, 6]] performance = {1: 5, 2: 3, 3: 4, 4: 2, 5: 1, 6: 7} ``` In this example, the function should return `16`, which corresponds to the path from the CEO (1) through 3 to 6 (5 + 4 + 7 = 16). **Note:** - The number of employees does not exceed 1000. - The performance scores of the employees are non-negative integers.","solution":"from collections import defaultdict def maxPerformanceInLineOfCommand(CEO, edges, performance): def dfs(node): if node not in tree: return performance[node] max_perf = float(\'-inf\') for child in tree[node]: max_perf = max(max_perf, dfs(child)) return performance[node] + max_perf # Create the hierarchical tree tree = defaultdict(list) for manager, employee in edges: tree[manager].append(employee) return dfs(CEO)"},{"question":"You are given an integer array `cards` of length `n`, where `cards[i]` represents the value of the `ith` card. Two players, Alice and Bob, are playing a game where they take turns drawing cards from the `cards` array. Alice always goes first, followed by Bob, and they both take one card on each turn, either from the beginning or the end of the array. They continue drawing cards until there are no cards left. The objective for each player is to maximize the sum of the values of the cards they draw. Return the maximum possible score Alice can achieve if both players play optimally.","solution":"def max_score_recursive(cards, start, end, memo): if start > end: return 0 if memo[start][end] != -1: return memo[start][end] pick_start = cards[start] + min(max_score_recursive(cards, start + 2, end, memo), max_score_recursive(cards, start + 1, end - 1, memo)) pick_end = cards[end] + min(max_score_recursive(cards, start + 1, end - 1, memo), max_score_recursive(cards, start, end - 2, memo)) memo[start][end] = max(pick_start, pick_end) return memo[start][end] def max_score(cards): n = len(cards) memo = [[-1] * n for _ in range(n)] return max_score_recursive(cards, 0, n - 1, memo)"},{"question":"You are given an integer array `heights` representing the heights of a series of buildings aligned in a row. A building\'s silhouette is formed by the maximum height at any point across its width. A new building `newHeight` may be added at any location in the row, and it will span a single position, potentially changing the overall silhouette. Write a function that takes in the `heights` array and `newHeight` as inputs and returns the maximum height that the building silhouette can achieve with the addition of the new building. Example: ```python def maxBuildingSilhouette(heights, newHeight): # Your code here # Example usage heights = [3, 1, 4, 1, 5] newHeight = 2 print(maxBuildingSilhouette(heights, newHeight)) # Output should be 5 ``` Explanation: In this example, the silhouette of the skyline is [3, 3, 4, 4, 5]. Adding a new building of height 2 at any position should not change the maximum height of the silhouette, which remains 5. Thus, the output is 5.","solution":"def maxBuildingSilhouette(heights, newHeight): Returns the maximum height that the building silhouette can achieve with the addition of a new building of height `newHeight`. if not heights: # If the list is empty return newHeight return max(max(heights), newHeight)"},{"question":"Given a binary tree, design an algorithm to check whether it is a binary search tree (BST). A binary search tree is a type of binary tree in which each node has at most two children and satisfies the property that every node\'s left child and its descendants have values less than the node, and every node\'s right child and its descendants have values greater than the node. The input is given as the root node of the binary tree. **Node format:** Each node is represented by a binary tree node `class` with the following attributes: - `val` (int): The value of the node. - `left` (TreeNode): The left child of the node or `null` if there is no left child. - `right` (TreeNode): The right child of the node or `null` if there is no right child. Implement the function `isValidBST(root: TreeNode) -> bool` that takes the root of the binary tree and returns `True` if the tree is a BST, otherwise returns `False`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isValidBST(root: TreeNode, low=float(\'-inf\'), high=float(\'inf\')) -> bool: Check if a binary tree is a valid binary search tree (BST). if not root: return True if not (low < root.val < high): return False return isValidBST(root.left, low, root.val) and isValidBST(root.right, root.val, high)"},{"question":"Given a binary tree, implement a function `int deepestLeavesSum(TreeNode root)` that returns the sum of the values of its deepest leaves. A leaf is a node with no children. Note that the binary tree will have at least one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Returns the sum of the values of the deepest leaves. if not root: return 0 from collections import deque queue = deque([(root, 0)]) current_depth = 0 current_sum = 0 while queue: node, depth = queue.popleft() if depth > current_depth: current_depth = depth current_sum = node.val elif depth == current_depth: current_sum += node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return current_sum"},{"question":"You are given a string `s` consisting only of characters \'a\' and \'b\'. A substring is called a \\"balanced substring\\" if it contains an equal number of \'a\'s and \'b\'s. Your task is to find the longest balanced substring in `s`. If there are multiple longest balanced substrings, return the first one. If there is no balanced substring, return an empty string. For example: - Input: `s = \\"aababb\\"` Output: `\\"aababb\\"` - Input: `s = \\"abababc\\"` Output: `\\"ababab\\"` - Input: `s = \\"aaaa\\"` Output: `\\"\\"`","solution":"def find_longest_balanced_substring(s): Returns the longest balanced substring containing equal number of \'a\'s and \'b\'s. If multiple longest balanced substrings exist, returns the first one. If no balanced substring exists, returns an empty string. max_len = 0 max_substr_start = -1 for i in range(len(s)): count_a = 0 count_b = 0 for j in range(i, len(s)): if s[j] == \'a\': count_a += 1 else: count_b += 1 if count_a == count_b: if (j - i + 1) > max_len: max_len = j - i + 1 max_substr_start = i if max_len > 0: return s[max_substr_start:max_substr_start + max_len] return \\"\\""},{"question":"A **reorganizable string** is one where no **two adjacent** characters are the same. Given a string `s`, determine if it is possible to rearrange the characters of `s` such that no two adjacent characters are the same. If it is possible, return _a valid rearrangement_ of the string. If it is not possible, return an empty string.","solution":"import heapq from collections import Counter def reorganizeString(s: str) -> str: Returns a reorganized string where no two adjacent characters are the same. If it is not possible, returns an empty string. # Count the frequency of each character counter = Counter(s) # Create a max heap using negative counts for Python\'s min heap max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) # Variables to keep track of the previous character and its count prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) # Append current character to the result list result.append(char) # If previous character had any remaining count, push it back to the heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update prev_count and prev_char prev_count, prev_char = count + 1, char # Joining the list to form the result string rearranged = \'\'.join(result) # If the length of rearranged string is the same as original string # it means we could successfully rearrange, otherwise not if len(rearranged) == len(s): return rearranged else: return \\"\\""},{"question":"Write a function that takes a string `s` as input and returns the length of the longest substring of `s` that contains only vowels (a, e, i, o, u). The characters in the substring must be contiguous and can appear in any order within the substring. If there are no vowels in the string, return 0.","solution":"def longest_vowel_substring(s): Returns the length of the longest contiguous substring that contains only vowels. Parameters: s (str): The input string Returns: int: The length of the longest contiguous vowel-only substring vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} max_len = 0 current_len = 0 for char in s: if char in vowels: current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len"},{"question":"You are given a 2D list `matrix` representing a binary matrix, where `0` indicates an empty cell and `1` indicates an occupied cell. Each row in the matrix is sorted in non-decreasing order. Return an integer indicating the total number of `0`s in the matrix. To count the number of zeros, you can make use of the following properties: * Each row is sorted in non-decreasing order. * This means that once you hit a `1`, all elements to the right in that row will also be `1`s.","solution":"def count_zeros(matrix): Counts the total number of 0s in a sorted binary matrix. :param matrix: 2D list representing the binary matrix :return: int representing the total number of 0s in matrix total_zeros = 0 for row in matrix: # Find the first occurrence of 1 in the row for elem in row: if elem == 1: break total_zeros += 1 return total_zeros"},{"question":"You are given a **non-empty** array of integers `nums` and a positive integer `k`. The array is circular, meaning the end of the array is connected to the beginning of the array. Find the maximum sum of a subarray with a length of `k`. The subarray must be composed of **consecutive elements**, and it may wrap around the array. Return the maximum sum of any such subarray.","solution":"def max_circular_subarray_sum(nums, k): Finds the maximum sum of a subarray with length k in a circular array. :param nums: List[int] - The input array of integers :param k: int - The length of the subarray :return: int - The maximum sum of the subarray n = len(nums) # Extend the array to handle wrap around extended_nums = nums + nums # Find max sum subarray of length k in the extended nums array max_sum = float(\'-inf\') current_sum = sum(extended_nums[:k]) max_sum = max(max_sum, current_sum) for i in range(1, n): current_sum = current_sum - extended_nums[i - 1] + extended_nums[i + k - 1] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to select any index `i` (0 <= i < s.length) and duplicate the character at that index. The goal is to determine the minimum number of operations required to make the string a palindrome. Return _the minimum number of operations needed_. A **palindrome** is a string that reads the same forward and backward. For example: - For the input `s = \\"ab\\"`, the output should be `1` because duplicating `a` results in \\"aba\\", which is a palindrome. - For the input `s = \\"race\\"`, the output should be `3` because duplicating \'r\', \'c\', and \'r\' results in \\"racecar\\", which is a palindrome.","solution":"def min_operations_to_palindrome(s): Determines the minimum number of operations needed to make the string a palindrome by duplicating characters. # Initialize a counter for counting characters char_count = [0] * 26 # Count the occurrences of each character for char in s: char_count[ord(char) - ord(\'a\')] += 1 # Check the number of characters with odd occurrences odd_count = 0 for count in char_count: if count % 2 != 0: odd_count += 1 # A palindrome can have at most one character with an odd count # The rest need to be paired return max(0, odd_count - 1)"},{"question":"Given a binary tree, implement an iterator class `BinarySearchTreeIterator` that iterates over the nodes in the tree in the **in-order** traversal order. The constructor of the class will be given the root of the tree. The class should support the following functions: - `BinarySearchTreeIterator(TreeNode root)`: Initializes the iterator object with the root of the binary tree. - `int next()`: Returns the next smallest number in the binary tree. - `boolean hasNext()`: Returns `true` if there exists a number in the traversal to be visited, otherwise returns `false`. The binary tree is represented using the TreeNode class, where `TreeNode` is defined as: ``` public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` You need to implement the `BinarySearchTreeIterator` class.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BinarySearchTreeIterator: def __init__(self, root): Initializes the iterator with the root of the binary tree. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to add all the nodes in the leftmost branch of the tree to the stack. while root: self.stack.append(root) root = root.left def next(self): Returns the next smallest number in the binary tree. # The topmost element of the stack is the next smallest element topmost_node = self.stack.pop() # If the node has a right child, we do the inorder traversal for the right child if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self): Returns true if there exists a number within the tree traversal to be visited, otherwise returns false. return len(self.stack) > 0"},{"question":"You are given a string of digits `s` and an integer `k`. Your task is to determine the length of the longest substring of `s` that is both a valid integer and less than or equal to `k`. The integer should not have leading zeros unless it is exactly `0` (i.e., \\"0\\" or \\"00\\" would be valid but \\"01\\" would not). Note that an empty string is not a valid integer. Implement the function `int findLongestSubstring(String s, int k)` that will take the string `s` and integer `k` as input parameters and returns the length of the longest valid substring. Example: - Input: `s = \\"12345678\\"`, `k = 123` - Output: `3` - Explanation: The longest valid substring is \\"123\\" which is less than or equal to 123.","solution":"def findLongestSubstring(s, k): Determines the length of the longest substring of s that is both a valid integer and less than or equal to k without leading zeros, unless it is exactly \'0\'. max_length = 0 n = len(s) for i in range(n): if s[i] == \'0\': # Always consider \'0\' as valid max_length = max(max_length, 1) continue num = 0 for j in range(i, n): num = num * 10 + int(s[j]) if num > k: break if s[i] != \'0\': # check if the substring has valid non-leadning zero integer max_length = max(max_length, j - i + 1) return max_length"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Determine if there exists a pair of distinct elements in the array whose sum equals a given target `k`. Return `true` if such a pair exists, otherwise return `false`.","solution":"def has_pair_with_sum(nums, k): Determine if there exists a pair of distinct elements in the sorted array `nums` whose sum equals the target `k`. Parameters: nums (list of int): A list of integers sorted in non-decreasing order. k (int): The target sum. Returns: bool: True if there exists such a pair, otherwise False. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"You are given an integer `N` representing the number of light bulbs, numbered from `0` to `N-1`. Initially, all the bulbs are turned off. Your task is to turn on all the bulbs following these rules: 1. You have a boolean array, `switches`, of length `N`, where `switches[i]` indicates whether the `i-th` bulb can be toggled (`true` if it can be toggled, `false` otherwise). 2. You can only toggle a bulb if it is currently off. 3. When you toggle a bulb, all bulbs whose indices are factors of the toggled bulb\'s index (excluding the bulb itself) will also be toggled automatically. Return the minimum number of toggles required to turn on all the bulbs, or `-1` if it is impossible to turn on all the bulbs.","solution":"def minimum_toggles(N, switches): Returns the minimum number of toggles required to turn on all the bulbs, or -1 if it is impossible. Parameters: N (int): Number of light bulbs. switches (list of bool): Boolean array representing whether a bulb can be toggled. Returns: int: Minimum number of toggles or -1 if it is impossible. if all(switches) and N > 0: return 1 else: return -1"},{"question":"You are given an integer array `nums` consisting of `n` numbers. You are allowed to perform a specific operation on the array several times: in one operation, you can pick any two adjacent elements and replace them with their sum. After each operation, the length of the array decreases by one. Your task is to maximize the final element remaining in the array after all possible operations have been performed. Given the integer array `nums`, return _the maximum possible value of the final element._","solution":"def maximize_final_element(nums): Returns the maximum possible value of the final element after performing the given operations. In each operation, you can replace any two adjacent elements with their sum. return sum(nums)"},{"question":"You are given two arrays of integers `arr1` and `arr2`, both sorted in non-decreasing order. Your task is to merge these two arrays into a single non-decreasing sorted array and return the resulting array. Be mindful to maintain the overall order and eliminate duplicate elements in the final merged array.","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array without duplicates. Parameters: arr1 (list of int): First sorted array. arr2 (list of int): Second sorted array. Returns: list of int: Merged sorted array without duplicates. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: if not merged_array or merged_array[-1] != arr1[i]: merged_array.append(arr1[i]) i += 1 elif arr1[i] > arr2[j]: if not merged_array or merged_array[-1] != arr2[j]: merged_array.append(arr2[j]) j += 1 else: if not merged_array or merged_array[-1] != arr1[i]: merged_array.append(arr1[i]) i += 1 j += 1 while i < len(arr1): if not merged_array or merged_array[-1] != arr1[i]: merged_array.append(arr1[i]) i += 1 while j < len(arr2): if not merged_array or merged_array[-1] != arr2[j]: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"You are given an `n x n` matrix where each of the rows and columns are sorted in **non-decreasing order**. You need to find the **k-th smallest** element in the matrix. The matrix is guaranteed to be sorted row-wise and column-wise.","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in a n x n matrix that is sorted row-wise and column-wise. n = len(matrix) min_heap = [] # Start with the first element of each row for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k-1 times for _ in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) # The root of the heap is the k-th smallest element return heapq.heappop(min_heap)[0]"},{"question":"Given a string `paragraph`, return the length of the **longest sentence** in the paragraph. A **sentence** is defined as a sequence of words separated by spaces and terminated by a period (`.`), exclamation mark (`!`), or question mark (`?`). Words consist of only alphabetic characters and may be connected by apostrophes (e.g., `it\'s`). Ensure to ignore any trailing punctuations following the sentence terminators. For example, in the paragraph `\\"Hello world! This is an example sentence.\\"`, there are two sentences: `Hello world!` and `This is an example sentence.`. The longest sentence contains 5 words. Return _an integer representing the maximum number of words in a sentence in the given paragraph_.","solution":"def longest_sentence_length(paragraph): Returns the length of the longest sentence in the paragraph. import re # Split the paragraph by sentence terminators sentences = re.split(r\'[.!?]\', paragraph) # Removing leading/trailing spaces and calculate words in each sentence max_length = 0 for sentence in sentences: words = sentence.strip().split() word_count = len(words) if word_count > max_length: max_length = word_count return max_length"},{"question":"You are given an integer array `arr` and an integer `k`. You can perform the following operation exactly `k` times: choose any subarray of `arr` and negate all its elements. Your goal is to maximize the sum of the array after performing exactly `k` operations. Return _the maximum possible sum of the array after_ `k` _operations_.","solution":"def maximize_sum_after_k_negations(arr, k): Returns the maximum possible sum of the array after performing exactly k negations. Parameters: arr (list): List of integers. k (int): Number of negation operations to perform. Returns: int: Maximum possible sum of the array after k negations. # Sort the array arr.sort() # Perform the negations for i in range(len(arr)): if k > 0 and arr[i] < 0: arr[i] = -arr[i] k -= 1 # If we still have an odd number of negations remaining, perform one more negation if k % 2 == 1: # Find the smallest element in the array arr.sort() arr[0] = -arr[0] # Return the sum of the array return sum(arr)"},{"question":"Given an integer array `arr`, your task is to sort the array such that when elements with the same value appear consecutively, they are grouped together in increasing order of their first occurrence in the original array. For example, if an element appears earlier in the array, its consecutive group should appear first in the sorted array. Return the sorted array as the result. Implement your solution without using built-in sort functions.","solution":"def custom_sort(arr): Sort the array such that elements with the same value are grouped together in increasing order of their first occurrence in the original array. seen = {} result = [] for idx, value in enumerate(arr): if value not in seen: seen[value] = idx # Convert our map to a list of tuples and sort it based on our sorting order sorted_items = sorted(seen.items(), key=lambda x: x[1]) for value, _ in sorted_items: count = arr.count(value) result.extend([value] * count) return result"},{"question":"Given a linked list where each node contains a unique integer value, implement a function to find the length of the longest sublist that forms an increasing sequence. The sublist can contain consecutive or non-consecutive nodes but must preserve the original order found in the linked list. Return the length of this longest increasing sublist. **Example**: - Linked list: `1 -> 3 -> 2 -> 5 -> 4 -> 6` - Longest increasing sublist: `1 -> 3 -> 5 -> 6` - Output: `4`","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def longest_increasing_sublist(head): Given the head of a linked list, return the length of the longest increasing sublist that preserves the original order of nodes. if not head: return 0 # Initialize variables max_length = 1 current = head lengths = [1] # lengths[i] stores the length of the longest increasing sublist ending at the i-th node while current.next: current = current.next lengths.append(1) for i in range(len(lengths) - 1): if current.val > nth_value(head, i + 1): lengths[-1] = max(lengths[-1], lengths[i] + 1) max_length = max(max_length, lengths[-1]) return max_length def nth_value(head, n): Helper function to get the value of the nth node in the linked list (1-based index). current = head for _ in range(n - 1): current = current.next return current.val"},{"question":"You are given an integer array `height` representing the heights of a series of buildings. You need to find the maximum area of water that can be contained between two buildings. The water cannot go outside the buildings and should form a container where the length is based on the horizontal distance between the two buildings, and the height is the shorter building\'s height. Return the maximum area of water that can be contained. You must write an algorithm with `O(n)` runtime complexity.","solution":"def max_area(height): Returns the maximum area of water that can be contained between two buildings. :param height: List[int] - List of integers representing building heights :return: int - Maximum area of water that can be contained max_area = 0 left, right = 0, len(height) - 1 while left < right: # Calculate the height and width of the current container current_height = min(height[left], height[right]) current_width = right - left # Calculate the area and update max_area if it\'s larger than the current max_area current_area = current_height * current_width max_area = max(max_area, current_area) # Move the pointers to try and find a larger area if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given a list of `n` integers, `arr`. Your task is to find the length of the longest subsequence that can be derived from the list in which the difference between adjacent elements is exactly `1`. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. Implement the function `int longestSubsequence(int[] arr)` which takes an array of integers as input and returns the length of the longest subsequence with adjacent differences of `1`. For example, if the input array is `[4, 2, 3, 5, 3, 2, 1, 4]`, the function should return `4`, corresponding to the subsequence `[2, 3, 2, 1]`.","solution":"def longestSubsequence(arr): Finds the length of the longest subsequence where the difference between adjacent elements is exactly 1. if not arr: return 0 from collections import defaultdict dp = defaultdict(int) # To store the longest subsequence ending with a particular number max_length = 1 for num in arr: # The longest subsequence ending with `num` is either starting a new sequence or extending the sequence ending with `num-1` or `num+1` dp[num] = max(dp[num], dp[num-1] + 1, dp[num+1] + 1) max_length = max(max_length, dp[num]) return max_length"},{"question":"Given a list of strings `words` and a string `target`, return _the length of the shortest list of words (from the given list) which can be concatenated to form the string_ `target`. If it is not possible to form `target` from the given list, return `-1`.","solution":"from collections import defaultdict, deque def shortest_concat(words, target): Returns the length of the shortest list of words which can be concatenated to form the string target. If it is not possible, returns -1. # Initialize dictionary to track minimum concatenations to reach each substring of target dp = defaultdict(lambda: float(\'inf\')) dp[\'\'] = 0 q = deque([\'\']) while q: current = q.popleft() if current == target: return dp[current] for word in words: if target.startswith(current + word): next_concat = current + word if dp[next_concat] > dp[current] + 1: dp[next_concat] = dp[current] + 1 q.append(next_concat) return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"You are given a list of integers `nums` representing a permutation of the integers from `0` to `n`. You are also given an integer `k` that represents the number of swaps you can make. Your goal is to sort the permutation in ascending order by performing at most `k` adjacent swaps (i.e., each swap can only involve elements at indices `i` and `i+1`). Return the lexicographically smallest permutation that can be obtained after at most `k` swaps.","solution":"def get_lexicographical_smallest_permutation(nums, k): Given a list of integers `nums` and an integer `k` representing the number of swaps, returns the lexicographically smallest permutation that can be obtained after at most `k` swaps. n = len(nums) for i in range(n): # Find the smallest element in nums[i:] that can be moved to nums[i] within k swaps pos = i for j in range(i+1, min(i+k+1, n)): if nums[j] < nums[pos]: pos = j # Calculate the number of swaps needed to bring nums[pos] to index i num_swaps = pos - i # Bring nums[pos] to index i by swapping it with its left neighbors for j in range(pos, i, -1): nums[j], nums[j-1] = nums[j-1], nums[j] # Decrease the count of available swaps k -= num_swaps # If no more swaps are left, break if k <= 0: break return nums"},{"question":"You are given two strings `s` and `t`. You want to transform `s` into `t` using the following operation any number of times: choose an arbitrary non-empty substring of `s` and replace all its characters with the character that appears the most frequently in that substring. If there are multiple characters with the same highest frequency, you may choose any of them. Return _the minimum number of operations required to transform `s` into `t`._ If it\'s impossible to transform `s` into `t`, return `-1`.","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform s into t. If it\'s impossible to transform s into t, return -1. if len(s) != len(t): return -1 # Create a set of unique characters in both strings unique_s = set(s) unique_t = set(t) # Check if for every character in t, there exists a corresponding character in s if not unique_t.issubset(unique_s): return -1 # If s == t, no operation is needed if s == t: return 0 return 1"},{"question":"You are given a list of integers `nums` sorted in non-decreasing order. Your task is to remove the minimum number of elements such that the remaining elements form a strictly increasing subsequence. Return the minimum number of elements to remove to achieve this. Additionally, you are required to provide the length of the longest strictly increasing subsequence that can be achieved from the original list.","solution":"from bisect import bisect_left def min_remove_to_increase(nums): Given a sorted list `nums`, returns a tuple where: - The first element is the minimum number of elements to remove so that the remaining list is strictly increasing. - The second element is the length of the longest strictly increasing subsequence that can be achieved from the original list. if not nums: return (0, 0) # To store the end elements of the increasing subsequences lis = [] for num in nums: pos = bisect_left(lis, num) if pos < len(lis): lis[pos] = num else: lis.append(num) # The length of LIS length_of_lis = len(lis) # The minimum number of elements to remove to form LIS min_remove = len(nums) - length_of_lis return min_remove, length_of_lis"},{"question":"Given a strings array `words`, implement the `AnagramGrouper` class: * `AnagramGrouper(String[] words)` Initializes the object with the array of `words`. * `List<List<String>> group()` Returns a list of lists of strings, where each list contains all the anagrams grouped together from the original array. Each group must contain at least one word, and each word must be included in exactly one group. An anagram of a word is a word that can be formed by rearranging the letters of the original word using each letter exactly once. For example, \\"listen\\" and \\"silent\\" are anagrams.","solution":"from collections import defaultdict class AnagramGrouper: def __init__(self, words): self.words = words def group(self): anagram_map = defaultdict(list) for word in self.words: sorted_word = \'\'.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values())"},{"question":"Given an integer array `height` representing the heights of n buildings in a row, you are tasked with forming the skyline of these buildings with the minimum number of rectangles. Each building\'s width is exactly one unit. Find the minimum number of rectangles required to cover all the buildings in the skyline. A rectangle is defined by its height and the span of contiguous buildings it covers. Return the minimum number of rectangles needed to represent the skyline.","solution":"def min_rectangles_to_form_skyline(height): Calculates the minimum number of rectangles required to form the skyline. Parameters: height (List[int]): A list of integer heights of buildings. Returns: int: The minimum number of rectangles needed to represent the skyline. if not height: return 0 count = 0 n = len(height) # Scan through the buildings and count the number of height changes for i in range(1, n): if height[i] != height[i-1]: count += 1 # Including the initial rectangle return count + 1"},{"question":"Given an array of integers `arr` and an integer `target`, return _the four elements from the array that sum up to a given `target`_. If there are no such element combinations, return an empty list. Note that the elements in each combination must be unique within the combination.","solution":"def four_sum(arr, target): Returns list of four elements from the array that sum up to a given target. If no such elements exist, return an empty list. arr.sort() n = len(arr) result = [] for i in range(n-3): if i > 0 and arr[i] == arr[i-1]: continue for j in range(i+1, n-2): if j > i+1 and arr[j] == arr[j-1]: continue left, right = j+1, n-1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: result = [arr[i], arr[j], arr[left], arr[right]] return result elif total < target: left += 1 else: right -= 1 return result"},{"question":"Given a rectangular `matrix` of dimensions `m x n`, please write an algorithm to find a path from the top-left cell (0, 0) to the bottom-right cell (m-1, n-1) such that the sum of all integers along the path is minimized. You can only move either down or right at any point in time. The function should return the minimum sum possible along with the path taken. The path should be returned as a list of coordinates. If multiple paths yield the same minimum sum, return any one of them.","solution":"def min_path_sum(matrix): Finds the path from top-left to bottom-right in a matrix such that the sum of integers along the path is minimized. Returns the minimum sum and the path taken. Path is returned as a list of coordinates. if not matrix or not matrix[0]: return 0, [] m, n = len(matrix), len(matrix[0]) # Initialize a dp array to store the minimum sum up to each cell dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] # Populate the dp table and path tracking for i in range(m): for j in range(n): if i == 0 and j > 0: dp[i][j] = dp[i][j-1] + matrix[i][j] elif j == 0 and i > 0: dp[i][j] = dp[i-1][j] + matrix[i][j] elif i > 0 and j > 0: dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # Backtrack to find the path path = [] i, j = m - 1, n - 1 path.append((i, j)) while i > 0 or j > 0: if i == 0: j -= 1 elif j == 0: i -= 1 elif dp[i-1][j] < dp[i][j-1]: i -= 1 else: j -= 1 path.append((i, j)) return dp[m-1][n-1], path[::-1]"},{"question":"You are tasked with designing a reservation system for a restaurant with multiple tables. Each table has a specific size, indicating the maximum number of guests it can accommodate. The restaurant takes reservations in the form of a single integer representing the number of guests. Given a 1-indexed integer array `tables` where `tables[i]` is the size of the `i-th` table and a list of reservations in the form of an integer array `reservations`, determine if each reservation can be successfully allocated to a table. A reservation is considered successful if it does not exceed the capacity of any available table and it marks the table as occupied for subsequent reservations. Return an array of the same length as `reservations` where each element is a boolean indicating whether the corresponding reservation can be successfully allocated.","solution":"def allocate_tables(tables, reservations): Determines if each reservation can be allocated to a table. Parameters: tables (List[int]): A 1-indexed list of integers representing the table\'s sizes. reservations (List[int]): A list of integers where each integer represents a reservation size. Returns: List[bool]: A list of booleans indicating if a reservation can be successfully allocated. available_tables = tables[:] # Copy of the table sizes to keep track of available capacities allocation_results = [] for reservation in reservations: # Iterate through available tables to find a suitable one successful_allocation = False for i in range(len(available_tables)): if available_tables[i] >= reservation: # Mark table as occupied by setting its size to 0 available_tables[i] = 0 successful_allocation = True break allocation_results.append(successful_allocation) return allocation_results"},{"question":"You are given two arrays `arr1` and `arr2` each of length `n` representing the values of coins in two separate piles. You can pick exactly one coin from each pile and sum their values. Your task is to find all the unique possible sums, and return them in a sorted order. Write a function to achieve this and provide an array of the unique sums sorted in ascending order.","solution":"def unique_sorted_sums(arr1, arr2): Returns a sorted list of all unique sums of picking one coin from each pile. Parameters: arr1 (list of int): Values in the first pile. arr2 (list of int): Values in the second pile. Returns: list of int: Sorted list of unique sums. unique_sums = set() for val1 in arr1: for val2 in arr2: unique_sums.add(val1 + val2) return sorted(unique_sums)"},{"question":"You are given a **0-indexed** integer array `nums`. An index `i` is called a **peak** if `nums[i]` is greater than both its neighbors (or if it is at the boundary and is greater than its single neighbor). Find the peak element and return its index. If the array contains multiple peaks, return _the index of any one of the peaks_.","solution":"def find_peak_element(nums): Finds any peak element in the array and returns its index. A peak element is an element that is greater than its neighbors. n = len(nums) if n == 1: return 0 if nums[0] > nums[1]: return 0 if nums[n - 1] > nums[n - 2]: return n - 1 for i in range(1, n - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: return i return -1 # This case shouldn\'t normally be hit"},{"question":"Given a string `s` and an integer `k`, reverse the order of the first `k` characters of the string. If `k` is greater than the length of the string, reverse the entire string. For example, if `s = \\"abcdefg\\"` and `k = 3`, reverse the order of the first 3 characters to get \\"cbadefg\\". If `s = \\"abcdefg\\"` and `k = 10`, since `k` is greater than the length of the string, reverse the entire string to get \\"gfedcba\\". Return the resulting string after the reversal.","solution":"def reverse_first_k_chars(s, k): Reverse the order of the first k characters of the string s. If k is greater than the length of string s, reverse the entire string. :param s: str - The input string to be partially reversed :param k: int - The number of characters to reverse from the start :return: str - The resulting string after the reversal if k > len(s): return s[::-1] return s[:k][::-1] + s[k:]"},{"question":"Given a grid `grid` where each entry is either a `\'1\'` (representing land) or a `\'0\'` (representing water), write a function to find the size of the largest island. An island is a group of `\'1\'`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. If there are no islands, return `0`. The function should consider the possibility of converting at most one `\'0\'` (water) to `\'1\'` (land) to potentially maximize the size of the island. Output the size of the largest island that can be achieved under these conditions.","solution":"def largestIsland(grid): Returns the size of the largest island that can be achieved by converting at most one \'0\' to \'1\' in the grid. rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != 1: return 0 grid[r][c] = index area = 1 for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]: area += dfs(r + dr, c + dc, index) return area index = 2 area_map = {0: 0} for r in range(rows): for c in range(cols): if grid[r][c] == 1: area = dfs(r, c, index) area_map[index] = area index += 1 max_area = max(area_map.values(), default=0) for r in range(rows): for c in range(cols): if grid[r][c] == 0: seen = set() for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] > 1: seen.add(grid[nr][nc]) max_area = max(max_area, 1 + sum(area_map[index] for index in seen)) return max_area"},{"question":"Given an array `arr` of integers, return _the length of the longest contiguous subarray with an equal number of 1s and -1s_. If no such subarray exists, return 0. The array will contain only the integers 1, -1, and 0. **Note**: The subarray should not contain the integer `0`.","solution":"def longest_equal_subarray(arr): Returns the length of the longest contiguous subarray with equal number of 1s and -1s. If no such subarray exists, return 0. # Convert 1s to 1 and -1s to -1 and ignore 0s filtered_arr = [x for x in arr if x != 0] # Dictionary to store the first occurrence of count difference count_dict = {0: -1} count = 0 max_length = 0 for i, num in enumerate(filtered_arr): if num == 1: count += 1 elif num == -1: count -= 1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length"},{"question":"You are given an array of integers `arr` where each element may have a different frequency of occurrence. Return an array of integers in descending order of frequency of their occurrence. If two elements have the same frequency, their order in the output array should be in descending numerical order. For example, given an input `arr = [4, 3, 1, 2, 2, 3, 3, 4, 4, 4]`, the corresponding output would be `[4, 3, 2, 1]`.","solution":"from collections import Counter def sort_by_frequency(arr): Sorts the array in descending order of frequency of their occurrence. If two elements have the same frequency, their order in the output array should be in descending numerical order. # Count the frequency of each element frequency_count = Counter(arr) # Sort primarily by frequency (descending) and secondarily by value (descending) sorted_elements = sorted(frequency_count.keys(), key=lambda x: (-frequency_count[x], -x)) return sorted_elements"},{"question":"You are given an array `arr` of integers and an integer `k`. Return the number of unique k-length subarrays in `arr` with an average greater than or equal to a given threshold `t`.","solution":"def count_subarrays_with_avg(arr, k, t): Returns the number of unique k-length subarrays in `arr` with an average greater than or equal to `t`. n = len(arr) count = 0 threshold_sum = k * t for i in range(n - k + 1): subarray_sum = sum(arr[i:i + k]) if subarray_sum >= threshold_sum: count += 1 return count"},{"question":"Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Each node contains a single integer value. Implement a function that takes the root of the binary tree and returns a list of integer values representing the right side view of the binary tree.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: Returns the right side view of the binary tree. res = [] if not root: return res queue = [root] while queue: level_size = len(queue) for i in range(level_size): # For each level node = queue.pop(0) if i == level_size - 1: # Last node in the level res.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return res"},{"question":"Given a binary tree, determine if it is a **mirror** of itself (i.e., symmetric around its center). You should return `true` if the binary tree is symmetric and `false` otherwise. This involves checking whether the left and right subtrees of the root are mirrors of each other recursively. For example, the following tree is symmetric: ``` 1 / 2 2 / / 3 4 4 3 ``` But the following tree is not symmetric: ``` 1 / 2 2 3 3 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Determines if the binary tree is symmetric. if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) return is_mirror(root.left, root.right)"},{"question":"Imagine you are developing a program that manages a **warehouse inventory**. The inventory is represented as a list of tuples where each tuple contains a `sku` (unique identifier for the item), `quantity` (number of items available), and `price` (cost per item). Implement a function to **merge inventories** from two separate warehouses. Each inventory list (from each warehouse) may contain some items with the same `sku`. If an item is present in both inventories, you should merge the quantities and keep the larger of the two prices. The input will be two lists of tuples: `inventory1` and `inventory2`. Return a single merged list of tuples sorted by `sku` in ascending order. Example: - `inventory1 = [(\\"apple\\", 50, 1.2), (\\"banana\\", 70, 0.8), (\\"orange\\", 80, 1.1)]` - `inventory2 = [(\\"apple\\", 30, 1.5), (\\"banana\\", 90, 0.7), (\\"pear\\", 60, 1.3)]` Expected output: - `[(\\"apple\\", 80, 1.5), (\\"banana\\", 160, 0.8), (\\"orange\\", 80, 1.1), (\\"pear\\", 60, 1.3)]`","solution":"def merge_inventories(inventory1, inventory2): Merges inventories from two separate warehouses. :param inventory1: List of tuples (sku, quantity, price) :param inventory2: List of tuples (sku, quantity, price) :return: Merged and sorted list of inventory tuples (sku, quantity, price) from collections import defaultdict merged_inventory = defaultdict(lambda: [0, 0]) for sku, quantity, price in inventory1 + inventory2: merged_inventory[sku][0] += quantity merged_inventory[sku][1] = max(merged_inventory[sku][1], price) merged_inventory_list = [(sku, info[0], info[1]) for sku, info in merged_inventory.items()] merged_inventory_list.sort(key=lambda x: x[0]) return merged_inventory_list"},{"question":"A DNA sequence is composed of a series of nucleotides abbreviated as `\'A\'`, `\'C\'`, `\'G\'`, and `\'T\'`. Given a string `s` representing a DNA sequence, return _all the **10-letter-long** sequences (substrings) that occur more than once in a DNA molecule_. You may return the answer in any order.","solution":"def findRepeatedDnaSequences(s): Returns all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. if len(s) <= 10: return [] seen, repeated = set(), set() for i in range(len(s) - 9): sequence = s[i:i + 10] if sequence in seen: repeated.add(sequence) else: seen.add(sequence) return list(repeated)"},{"question":"You have a list of `n` strings `arr[]` where each string is a lowercase word. You need to find out the **maximum product** of the lengths of two different strings in the list that do not share any common characters. Return the maximum product of the lengths of such two strings. If no such pair of strings exists, return 0.","solution":"def max_product_length(arr): Returns the maximum product of lengths of two different strings in the list that do not share any common characters. n = len(arr) if n < 2: return 0 # Create a bitmask for each word masks = [0] * n lengths = [0] * n for i in range(n): bitmask = 0 for char in arr[i]: bitmask |= 1 << (ord(char) - ord(\'a\')) masks[i] = bitmask lengths[i] = len(arr[i]) max_product = 0 # Compare each pair of words for i in range(n): for j in range(i + 1, n): if masks[i] & masks[j] == 0: # No common characters max_product = max(max_product, lengths[i] * lengths[j]) return max_product"},{"question":"Given an unsorted integer array `nums`, design an algorithm to find the two numbers such that they add up to a specific target number. Return the indices of the two numbers in the form of a tuple `(index1, index2)`. Assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.","solution":"def two_sum(nums, target): Return the indices of the two numbers such that they add up to a specific target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: tuple: A tuple containing the indices of the two numbers. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return (num_map[complement], i) num_map[num] = i # Example usage print(two_sum([2, 7, 11, 15], 9)) # Output should be (0, 1)"},{"question":"You are given an integer array `heights` representing the heights of buildings arranged in a row, from left to right. The rainwater trapped between the buildings can be calculated as follows: * Water trapped over a building is determined by the minimum height of the tallest buildings to its left and right, subtracted by the height of the building itself. Write a function that computes the amount of rainwater trapped in the configuration represented by `heights` and returns the total volume of trapped rainwater. Return _the total volume of trapped rainwater_.","solution":"def trap(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"You are given an integer array `nums` of length `n`, where each element in the array represents the value of a house in a row of houses. You are a burglar planning to rob houses along this row, but you cannot rob two adjacent houses because that would trigger an alarm. Determine the maximum amount of money you can rob tonight without triggering the alarm. Return this maximum amount.","solution":"def rob(nums): Determine the maximum amount of money that can be robbed without triggering the alarm. Args: nums (List[int]): The list of money in the houses. Returns: int: The maximum amount of money that can be robbed. if not nums: return 0 if len(nums) <= 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given a binary tree represented by its root node. Each node contains an integer value, and two children (left and right). Create a function that returns the **sum of all left leaves** in the tree. A leaf is a node with no children, and a left leaf is a leaf that is the left child of its parent. Define the following method in your class: * `int sumOfLeftLeaves(TreeNode root)` where `TreeNode` is the structure for each node in the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): Return the sum of all left leaves in the binary tree rooted at `root`. def is_leaf(node): return node is not None and node.left is None and node.right is None def dfs(node): if node is None: return 0 sum_left_leaves = 0 if node.left and is_leaf(node.left): sum_left_leaves += node.left.val sum_left_leaves += dfs(node.left) sum_left_leaves += dfs(node.right) return sum_left_leaves return dfs(root)"},{"question":"Write a function that takes an array of integers and a target integer. Find the indices of the two numbers in the array that add up to the target integer and return their indices in a tuple `(i, j)`, where `i < j`. You may assume that each input has exactly one solution, and you may not use the same element twice in your calculation. Return `None` if no such indices exist.","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the array that add up to the target integer. Each input has exactly one solution, and you may not use the same element twice. If no such indices exist, return None. :param nums: List of integers :param target: Target integer :return: Tuple of indices (i, j) where i < j or None num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"You are given a `node` class that represents nodes in a binary tree with integer values. The class has attributes `value`, `left`, and `right` which point to the left and right subtrees respectively. Implement a function that takes the `root` of a binary tree and an integer `target`. Your task is to determine if the binary tree has any root-to-leaf path such that adding up all the values along the path equals the given `target`. Return `True` if such a path exists, otherwise return `False`.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def has_path_sum(root, target): Determines if there is a root-to-leaf path in the binary tree such that adding up all the values along the path equals the given target. :param root: The root of the binary tree :param target: The target sum :return: True if such a path exists, otherwise False if not root: return False if not root.left and not root.right: # Check if it is a leaf node return root.value == target target -= root.value return has_path_sum(root.left, target) or has_path_sum(root.right, target)"},{"question":"You are given an array of words `words` and a string `s`. A word is considered a substring of `s` if it appears in a contiguous block within `s`. Return an array indicating for each word in `words` whether it is a substring of `s`. Specifically, if `words[i]` is a substring of `s`, the i-th position in the return array should be `true`; otherwise, it should be `false`.","solution":"def are_substrings(words, s): Returns a list of boolean values indicating whether each word in words is a substring of s. Args: words: list of words to check against the string s. s: the string in which to check for substrings. Returns: list of boolean values corresponding to whether each word is a substring of s. return [word in s for word in words]"},{"question":"You are given an array of integers `nums` representing a series of sequential operations where `nums[i]` indicates the value to be incremented. Assume you initially have a list `operations` where each element is set to 0. For each integer in `nums`, increment the corresponding index of `operations` by 1. Once all operations are performed, return the final `operations` list. Note that the length of `operations` is the maximum value found in `nums` plus one.","solution":"def apply_operations(nums): Given an array of integers \'nums\', this function returns an array \'operations\' where each element at index \'i\' of \'operations\' is incremented based on the elements in \'nums\'. The length of \'operations\' is the maximum value in \'nums\' plus one. if not nums: return [] max_val = max(nums) operations = [0] * (max_val + 1) for num in nums: operations[num] += 1 return operations"},{"question":"You are given a string `s` that consists of only lowercase English letters. You have to perform a series of operations on this string. In each operation, you can remove one occurrence of any character that has appeared at least twice in a row. You must continue this process until there are no more adjacent duplicate characters in the string. Return the final string after all such operations have been performed. For example, if `s = \\"abbacca\\"`, you can remove \\"bb\\" to get \\"aacca\\". Then you can remove \\"cc\\" to get \\"aaa\\". Finally, you can remove \\"aa\\" to get \\"a\\", which is the result of all operations. Return the final string \\"a\\".","solution":"def remove_adjacent_duplicates(s): Removes adjacent duplicates characters in the string s until no such duplicates are left. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given a **0-indexed** matrix `grid` of size `m x n`. Each cell contains a positive integer representing the height of a building at that position. You are also given two points within this grid `(start_row, start_col)` and `(end_row, end_col)`. Your task is to determine the minimum possible difference in height between the highest and lowest building encountered along any path from `(start_row, start_col)` to `(end_row, end_col)`. You can only move up, down, left, or right at each step. Return _the minimum possible difference in height for the described path_.","solution":"import heapq def min_diff_path(grid, start_row, start_col, end_row, end_col): Returns the minimum possible difference in height between the highest and lowest building encountered along any path from (start_row, start_col) to (end_row, end_col). def neighbors(row, col): for drow, dcol in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nrow, ncol = row + drow, col + dcol if 0 <= nrow < len(grid) and 0 <= ncol < len(grid[0]): yield nrow, ncol m, n = len(grid), len(grid[0]) pq = [] heapq.heappush(pq, (0, start_row, start_col, grid[start_row][start_col], grid[start_row][start_col])) visited = set() visited.add((start_row, start_col)) while pq: diff, row, col, min_height, max_height = heapq.heappop(pq) if (row, col) == (end_row, end_col): return diff for nrow, ncol in neighbors(row, col): if (nrow, ncol) not in visited: visited.add((nrow, ncol)) nmin_height = min(min_height, grid[nrow][ncol]) nmax_height = max(max_height, grid[nrow][ncol]) ndiff = nmax_height - nmin_height heapq.heappush(pq, (ndiff, nrow, ncol, nmin_height, nmax_height)) return -1 # if there\'s no possible path, though problem guarantees there is one."},{"question":"Write a function that takes an array of distinct integers and returns all possible permutations (in any order). Each permutation should be represented as an array of integers. The function should handle arrays of different lengths efficiently.","solution":"def permute(nums): Given an array of distinct integers, return all possible permutations. Each permutation is an array of integers. def backtrack(start, end): if start == end: permutations.append(nums[:]) for i in range(start, end): nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1, end) nums[start], nums[i] = nums[i], nums[start] permutations = [] backtrack(0, len(nums)) return permutations"},{"question":"Given a list of integers `nums` and an integer `n`, find the length of the _longest contiguous subarray_ that contains at most `n` distinct integers. If `nums` is empty or `n` is zero, return `0`.","solution":"def longest_subarray_with_n_distinct(nums, n): Finds the length of the longest contiguous subarray that contains at most n distinct integers. :param nums: List of integers :param n: Integer, maximum number of distinct integers allowed in the subarray :return: Length of the longest contiguous subarray with at most n distinct integers if not nums or n == 0: return 0 from collections import defaultdict left = 0 right = 0 max_len = 0 counter = defaultdict(int) while right < len(nums): counter[nums[right]] += 1 while len(counter) > n: counter[nums[left]] -= 1 if counter[nums[left]] == 0: del counter[nums[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"Given a string `s` containing only lowercase letters, you need to find the length of the longest substring where every character appears an even number of times. If no such substring exists, return `0`. Write a function `longestEvenSubstring(s)` that returns this length.","solution":"def longestEvenSubstring(s): Returns the length of the longest substring where every character appears an even number of times. n = len(s) if n == 0: return 0 # dictionary to store the first occurrence of each state first_occurrence = {0: -1} state = 0 max_length = 0 for i in range(n): # Calculate bitmask: toggle bit for current character state ^= (1 << (ord(s[i]) - ord(\'a\'))) if state in first_occurrence: max_length = max(max_length, i - first_occurrence[state]) else: first_occurrence[state] = i return max_length"},{"question":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. Given an integer array `nums` of distinct integers and an integer `k`, return _all the permutations of the array_ `nums` _such that the absolute difference between each adjacent element in the permutation is at least_ `k`.","solution":"import itertools def is_valid_permutation(perm, k): for i in range(1, len(perm)): if abs(perm[i] - perm[i - 1]) < k: return False return True def valid_permutations(nums, k): Returns all permutations of nums where the absolute difference between each adjacent element in the permutation is at least k. all_perms = itertools.permutations(nums) valid_perms = [perm for perm in all_perms if is_valid_permutation(perm, k)] return valid_perms"},{"question":"Given a list of non-negative integers `nums`, you are tasked with creating a new list where each element is the sum of the digits of the corresponding element in `nums`. For example, given `nums = [123, 456, 789]`, the resulting list would be `[6, 15, 24]` because the sum of digits of `123` is `1 + 2 + 3 = 6`, and so on. Return the new list of digit sums.","solution":"def sum_of_digits_list(nums): Given a list of non-negative integers, returns a list where each element is the sum of the digits of the corresponding element in nums. def sum_of_digits(n): return sum(int(digit) for digit in str(n)) return [sum_of_digits(num) for num in nums]"},{"question":"Given a string `s` containing only the characters `\'(\'` and `\')\'`, return the minimum number of parentheses to be added to make the string valid. A string is considered valid if brackets are closed in the correct order, i.e., \\"(()())\\" and \\"()\\" are valid but \\")(\\" and \\"(()\\" are not.","solution":"def minAddToMakeValid(s): Return the minimum number of parentheses to be added to make the string valid. left_count = 0 right_needed = 0 for char in s: if char == \'(\': left_count += 1 elif char == \')\': if left_count > 0: left_count -= 1 else: right_needed += 1 return left_count + right_needed"},{"question":"You are given an array of n integers `heights` representing the heights of students in a line. A student can change their position in the line only if their height is strictly different from both their neighbors (if they have two neighbors). Determine the minimum number of students that need to change positions so that all the students satisfy this condition. Return this minimum number as a result.","solution":"def min_changes_to_satisfy_condition(heights): Returns the minimum number of students that need to change positions so that all students have heights strictly different from both their neighbors. n = len(heights) if n < 3: return 0 # If there are less than 3 students, no changes are needed. changes = 0 for i in range(1, n-1): if heights[i] == heights[i-1] or heights[i] == heights[i+1]: changes += 1 if heights[i-1] != heights[i+1]: heights[i] = heights[i-1] if heights[i] != heights[i-1] else heights[i+1] else: heights[i] = heights[i-1] + 1 # Changing height to ensure it\'s different from both neighbors return changes"},{"question":"Given a directed graph represented as an adjacency list where each node is labeled from `0` to `n-1`, find the length of the shortest path between two given nodes `source` and `destination`. If there is no path between the two nodes, return `-1`. Ensure your implementation efficiently handles graphs with no cycles and graphs with cycles, and accounts for situations where multiple paths of equal length exist.","solution":"from collections import deque def shortest_path(graph, source, destination): Finds the length of the shortest path between source and destination in a directed graph. Parameters: graph (dict): The graph represented as an adjacency list. source (int): The start node. destination (int): The end node. Returns: int: Length of the shortest path, or -1 if no path exists. if source == destination: return 0 visited = set() queue = deque([(source, 0)]) # (current_node, current_distance) while queue: current_node, current_distance = queue.popleft() if current_node == destination: return current_distance visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append((neighbor, current_distance + 1)) return -1"},{"question":"You are given a list of `n` strings called `words` and an integer `k`. Each string in the list represents a unique word. Your task is to find the first `k` words in the list when sorted lexicographically, and then concatenate these `k` words to form a single string. Return _the concatenated string of the first `k` lexicographically sorted words._","solution":"def concatenate_k_lexicographically(words, k): Returns a single string formed by concatenating the first k words in lexicographical order. Parameters: words (list of str): List of unique words. k (int): Number of words to concatenate. Returns: str: Concatenated string of first k lexicographically sorted words. if k > len(words): raise ValueError(\\"k should be less than or equal to the number of words in the list\\") sorted_words = sorted(words) concatenated_string = \'\'.join(sorted_words[:k]) return concatenated_string"},{"question":"You are given a list of integers `arr` representing the value of various stocks on consecutive days. You can complete at most two transactions; where a transaction consists of buying one and selling one share of the stock. Return the maximum profit you can achieve from these transactions. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before buying again).","solution":"def max_profit_with_two_transactions(prices): if not prices: return 0 n = len(prices) # Initialize the dp arrays left_profits = [0] * n right_profits = [0] * n # Fill the left_profits array where left_profits[i] represents # the max profit that can be achieved from day 0 to day i min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) left_profits[i] = max(left_profits[i-1], prices[i] - min_price) # Fill the right_profits array where right_profits[i] represents # the max profit that can be achieved from day i to the last day max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) right_profits[i] = max(right_profits[i+1], max_price - prices[i]) # Calculate the maximum profit by adding left and right profits max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"You are given a 2D grid of size `m x n` consisting of positive integers. A path in the grid is defined as starting from the top-left corner and finishing at the bottom-right corner, where at each step you can only move right or down. Find the maximum sum of values along any path from the top-left to the bottom-right corner of the grid.","solution":"def max_path_sum(grid): Finds the maximum sum of values along any path from the top-left to the bottom-right corner. :param grid: List of lists of integers, the grid data :return: Integer, the maximum sum if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # iterate through grid and update the sum path for i in range(m): for j in range(n): if i == 0 and j == 0: continue # starting point elif i == 0: grid[i][j] += grid[i][j-1] elif j == 0: grid[i][j] += grid[i-1][j] else: grid[i][j] += max(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"Given an array of integers `arr`, find and return all unique triplets `[arr[i], arr[j], arr[k]]` such that `i != j`, `i != k`, and `j != k`, and `arr[i] + arr[j] + arr[k] == 0`. Note that the solution set must not contain duplicate triplets.","solution":"def three_sum(arr): Given an array of integers, find all unique triplets [arr[i], arr[j], arr[k]] such that i != j != k and arr[i] + arr[j] + arr[k] == 0. The solution set must not contain duplicate triplets. arr.sort() unique_triplets = [] for i in range(len(arr) - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, len(arr) - 1 while left < right: sum_three = arr[i] + arr[left] + arr[right] if sum_three == 0: unique_triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif sum_three < 0: left += 1 else: right -= 1 return unique_triplets"},{"question":"Given a list of integers where each element represents the maximum number of steps that can be jumped going forward from that element, determine if you can reach the last index starting from the first index. Each jump requires you to move to an index containing a valid number of steps. Return `True` if you can reach the last index, or `False` otherwise.","solution":"def can_jump(nums): Determines if you can reach the last index from the first index. :param nums: List[int], list of integers representing the maximum number of steps that can be jumped. :return: bool, True if you can reach the last index, False otherwise. max_reachable = 0 n = len(nums) for i, step in enumerate(nums): if i > max_reachable: return False max_reachable = max(max_reachable, i + step) if max_reachable >= n - 1: return True return False"},{"question":"Given an integer `n`, return a list of all unique combinations of factors (excluding 1 and `n` itself) whose product is `n`. You may return the combinations in any order. Each combination should be represented as a list of integers.","solution":"def get_factors(n): def dfs(start, n, path, result): for i in range(start, int(n**0.5)+1): if n % i == 0: result.append(path + [i, n//i]) dfs(i, n//i, path + [i], result) result = [] dfs(2, n, [], result) return result"},{"question":"You are given a **0-indexed** integer array `heights` where `heights[i]` represents the height of the `i-th` building in a line of buildings. A building is defined as \\"good\\" if and only if there can be no shorter building to its right blocking its sunset view. Return _an **integer array** containing the indices of all buildings that are \\"good\\" in ascending order of their indices_.","solution":"def good_buildings(heights): Returns the indices of all buildings that are \\"good\\", in ascending order. A building is considered \\"good\\" if there can be no shorter building to its right blocking its sunset view. n = len(heights) max_height = float(\'-inf\') result = [] for i in range(n): if heights[i] > max_height: result.append(i) max_height = heights[i] return result"},{"question":"Given a binary tree, implement a function that returns the **left view** of the tree. The left view of a binary tree contains the nodes visible when the tree is viewed from the left side. The input to your function will be the root of the binary tree. Return the values of the nodes that are visible from the left view in a list, from top to bottom.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def left_view(root): Returns the left view of the binary tree. :param root: TreeNode :return: List[int] if not root: return [] result = [] max_level = -1 def traverse(node, level, max_level): if not node: return max_level if level > max_level: result.append(node.value) max_level = level max_level = traverse(node.left, level + 1, max_level) max_level = traverse(node.right, level + 1, max_level) return max_level traverse(root, 0, max_level) return result"},{"question":"Implement a system that simulates a parking lot. The parking lot has multiple floors, each with multiple slots. You need to design a data structure that represents the parking lot and supports the following operations: * `ParkingLot(int n, int m)` initializes a parking lot with `n` floors and `m` slots per floor. * `void park(String vehicleId, int floor, int slot)` parks the vehicle with ID `vehicleId` at the specified `floor` and `slot`. If that slot is already taken or the floor/slot does not exist, return an error. * `void leave(String vehicleId)` removes the vehicle with the given ID from the parking lot. If the vehicle is not found, return an error. * `String getSlot(String vehicleId)` returns the location (floor and slot) of the vehicle with the given ID. If the vehicle is not found, return an error. Make sure each operation runs in optimal time complexity.","solution":"class ParkingLot: def __init__(self, n, m): self.floors = n self.slots_per_floor = m self.parking_lot = [[None for _ in range(m)] for _ in range(n)] self.vehicle_map = {} def park(self, vehicleId, floor, slot): if floor >= self.floors or slot >= self.slots_per_floor: return \\"Error: Invalid floor or slot\\" if self.parking_lot[floor][slot] is not None: return \\"Error: Slot already taken\\" self.parking_lot[floor][slot] = vehicleId self.vehicle_map[vehicleId] = (floor, slot) return f\\"Vehicle {vehicleId} parked at floor {floor}, slot {slot}\\" def leave(self, vehicleId): if vehicleId not in self.vehicle_map: return \\"Error: Vehicle not found\\" floor, slot = self.vehicle_map[vehicleId] self.parking_lot[floor][slot] = None del self.vehicle_map[vehicleId] return f\\"Vehicle {vehicleId} left from floor {floor}, slot {slot}\\" def getSlot(self, vehicleId): if vehicleId not in self.vehicle_map: return \\"Error: Vehicle not found\\" floor, slot = self.vehicle_map[vehicleId] return f\\"Vehicle {vehicleId} is at floor {floor}, slot {slot}\\""},{"question":"You are given a positive integer `n`. Your task is to find the smallest integer `x` such that the product of the digits of `x` is equal to `n`. If no such number exists, return -1. Note that `x` must be a single integer without leading zeros. Return the smallest integer `x` if it exists, otherwise return -1.","solution":"def smallest_x_with_product(n): Returns the smallest integer x such that the product of the digits of x equals n. If no such number exists, returns -1. if n == 1: return 1 digits = [] for d in range(9, 1, -1): while n % d == 0: digits.append(d) n //= d if n > 1: return -1 digits.sort() x = int(\'\'.join(map(str, digits))) return x"},{"question":"You are given an integer array `nums` of length `n` and an integer `k`. Implement a function that returns the minimum size of a contiguous subarray of which the sum is greater than or equal to `k`. If there is no such subarray, return `0` instead. The runtime complexity of your solution must be better than O(n^2).","solution":"def min_subarray_length(nums, k): Returns the minimum size of a contiguous subarray of which the sum is greater than or equal to k. If there is no such subarray, returns 0. n = len(nums) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length <= n else 0"},{"question":"You are given a string `s` and an array of pairs of indices `pairs` where each pair `[a, b]` indicates that the characters at indices `a` and `b` can be swapped. You can swap characters at any pair of indices in `pairs` any number of times. Return the lexicographically smallest string that can be obtained by making any number of swaps. Implement the function `smallestStringWithSwaps(s: string, pairs: List[List[int]]) -> string` that returns the lexicographically smallest string possible after performing any number of swaps as described. Example: ``` Input: s = \\"dcab\\", pairs = [[0,3],[1,2]] Output: \\"bacd\\" Explanation: Swap s[0] and s[3], s = \\"bcad\\". Swap s[1] and s[2], s = \\"bacd\\". Input: s = \\"dcab\\", pairs = [[0,3],[1,2],[0,2]] Output: \\"abcd\\" Explanation: Swap s[0] and s[3], s = \\"bcad\\". Swap s[0] and s[2], s = \\"acbd\\". Swap s[1] and s[2], s = \\"abcd\\". ``` Note: * s will only contain lowercase English letters. * The length of s will be between 1 and 100, including 1 and 100. * The length of pairs will be between 0 and 100, including 0 and 100. * The pairs are 0-based indexing.","solution":"from typing import List from collections import defaultdict def smallestStringWithSwaps(s: str, pairs: List[List[int]]) -> str: def dfs(node, visited, component): visited.add(node) component.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, component) # Create adjacency list from the pairs graph = defaultdict(list) for a, b in pairs: graph[a].append(b) graph[b].append(a) visited = set() components = [] # Find all connected components for i in range(len(s)): if i not in visited: component = [] dfs(i, visited, component) components.append(component) # Construct the result string result = list(s) for component in components: indices = sorted(component) letters = sorted(result[i] for i in indices) for i, idx in enumerate(indices): result[idx] = letters[i] return \'\'.join(result)"},{"question":"Given a string `S` representing a sequence of moves for a robot, where each character in `S` is either `\'U\'` (up), `\'D\'` (down), `\'L\'` (left), or `\'R\'` (right), determine if the robot returns to its original starting position after completing all the moves. The robot starts at the origin `(0, 0)` on a 2D plane. Return `true` if the robot returns to the origin after it finishes all the moves, or `false` otherwise.","solution":"def judgeCircle(S): Determines if the robot returns to the original starting position after the sequence of moves. :param S: A string representing a sequence of moves :return: True if the robot returns to the starting position, False otherwise x, y = 0, 0 for move in S: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"You are given a binary tree with `n` nodes where each node has a unique value from `1` to `n`. Each node has either `0, 1, or 2` child nodes. You need to find the length of the longest path in the tree such that each node on the path has an odd value. Note that the path does not need to pass through the root, and it can start and end at any node in the tree. Implement a function `int longestOddNodePath(TreeNode root)` where `TreeNode` is a class that defines a node in the tree. The function returns the length of the longest path with all nodes having odd values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestOddNodePath(root): Returns the length of the longest path with all nodes having odd values. def dfs(node): nonlocal max_path_length if not node: return 0 left_length = dfs(node.left) right_length = dfs(node.right) if node.val % 2 == 1: max_path_length = max(max_path_length, left_length + right_length + 1) return max(left_length, right_length) + 1 else: return 0 if not root: return 0 max_path_length = 0 dfs(root) return max_path_length"},{"question":"A company wants to create a shipping schedule to minimize the total shipping cost. You are given an integer array `weights` where `weights[i]` represents the weight of the `ith` shipment. You are also given an integer `D` which represents the number of days you have to ship all the packages. Every day, you can ship any number of consecutive packages, as long as the total weight of those packages does not exceed a given capacity `C`. Determine the minimum capacity `C` so that all shipments can be scheduled within `D` days.","solution":"def can_ship_in_days(weights, D, capacity): total_days = 1 current_weight = 0 for weight in weights: if current_weight + weight > capacity: total_days += 1 current_weight = 0 current_weight += weight return total_days <= D def find_min_capacity(weights, D): left = max(weights) # Minimum possible capacity right = sum(weights) # Maximum possible capacity while left < right: mid = (left + right) // 2 if can_ship_in_days(weights, D, mid): right = mid else: left = mid + 1 return left"},{"question":"Implement a function that takes as input a string representing a mathematical expression and evaluates it. The expression can contain integers, the \'+\' (addition), \'-\' (subtraction), \'*\' (multiplication), and \'/\' (division) operators, as well as parentheses for grouping. The input string is guaranteed to be a valid expression. The function should return the result of the evaluation as a floating-point number, rounded to two decimal places if necessary.","solution":"def evaluate_expression(expression): Evaluate a mathematical expression given as a string. :param expression: str, mathematical expression to evaluate :return: float, result of the evaluated expression rounded to two decimal places try: result = eval(expression) return round(float(result), 2) except (SyntaxError, ZeroDivisionError, NameError): raise ValueError(\\"Invalid mathematical expression\\")"},{"question":"You are given a string `word`, which consists of lowercase English letters. A **subsequence** of `word` is a string that can be derived from `word` by deleting some or no characters without changing the order of the remaining characters. For example, \\"abc\\", \\"ab\\", and \\"a\\" are all subsequences of \\"abc\\". Return the length of the longest palindromic subsequence in `word`. A **palindrome** is a string that reads the same backward as forward. For instance, \\"racecar\\" and \\"level\\" are palindromes.","solution":"def longest_palindromic_subsequence(word): Returns the length of the longest palindromic subsequence in the given word. n = len(word) dp = [[0] * n for _ in range(n)] for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i + 1, n): if word[i] == word[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"You are given a list of integers `nums` representing the values of stocks on consecutive days. You are also given an integer `k` which represents the maximum number of transactions you can make. A transaction consists of buying one stock and selling it on a later date. Your objective is to maximize your profit by making at most `k` transactions. Implement a function `maxProfit` that returns the maximum profit achievable with the given constraints.","solution":"def maxProfit(k, prices): n = len(prices) if n == 0: return 0 if k >= n // 2: # If we can do transactions as much as we want return sum( max(prices[i + 1] - prices[i], 0) for i in range(n - 1) ) profits = [[0] * n for _ in range(k + 1)] for t in range(1, k + 1): max_diff = -prices[0] for i in range(1, n): profits[t][i] = max(profits[t][i - 1], prices[i] + max_diff) max_diff = max(max_diff, profits[t - 1][i] - prices[i]) return profits[k][n - 1]"},{"question":"You are given a string `s` that consists of only lowercase English letters. A **substring** is a contiguous non-empty sequence of characters within a string. You can replace exactly one character of `s` with any other lowercase English letter. Return _the length of the longest substring containing at most one unique character after performing the replacement_. This means the substring may contain at most two different characters before replacement, but only one after. For example, given the string `s = \\"abbaba\\"`, you may replace one \'a\' with \'b\' to get the substring `bbbb`, which has a length of 4.","solution":"def longest_substring_with_one_replacement(s): Returns the length of the longest substring containing at most one unique character after performing one replacement. if not s: return 0 def max_length_with_replacement(s, target_char): left = 0 max_len = 0 replacement_used = 0 for right in range(len(s)): if s[right] != target_char: replacement_used += 1 while replacement_used > 1: if s[left] != target_char: replacement_used -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len max_len = 0 for char in set(s): max_len = max(max_len, max_length_with_replacement(s, char)) return max_len"},{"question":"Given an integer array `nums`, you are allowed to move each element `nums[i]` to `nums[i] + 1` or `nums[i] - 1` (increment or decrement by 1). Return _the minimum number of moves required to make all elements of the array equal_.","solution":"def min_moves_to_make_equal(nums): Returns the minimum number of moves to make all elements in the array equal. Each element can be incremented or decremented by 1. nums.sort() median = nums[len(nums) // 2] # Median minimizes the absolute deviation sum return sum(abs(num - median) for num in nums)"},{"question":"You are given an integer array `cards` where `cards[i]` represents the value of the `ith` card in a row of cards. You can pick cards from either end of the row. Your goal is to pick exactly `k` cards to maximize the sum of their values. Return the _maximum possible sum_ of the values of the `k` cards you pick.","solution":"def maxScore(cards, k): Returns the maximum possible sum of the values of the k cards you pick. :param cards: List[int], an array of integers representing the card values :param k: int, the number of cards to pick :return: int, the maximum possible sum n = len(cards) total = sum(cards[:k]) max_sum = total for i in range(1, k + 1): total += cards[-i] - cards[k - i] max_sum = max(max_sum, total) return max_sum"},{"question":"You are given an array of unique integers `nums` where each integer `nums[i]` is either `1` or a prime number. Your task is to return **true** if `nums` can be partitioned into two non-empty subsets such that the sum of the elements in both subsets is the same. Otherwise, return **false**. A **subset** of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.","solution":"def can_partition(nums): Returns True if nums can be partitioned into two subsets with equal sum, False otherwise. total_sum = sum(nums) # If the total sum is odd, it\'s not possible to partition it into two equal subsets if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) # Create a DP table, dp[i] means whether sum i can be achieved by any subset of the numbers dp = [False] * (target_sum + 1) dp[0] = True for num in nums: for i in range(target_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target_sum]"},{"question":"You\'re given a list of integers `nums` sorted in non-decreasing order. Your task is to remove the duplicates in-place such that each element appears only once and return the new length of the modified list. Do not allocate extra space for another array; you must do this by modifying the input list in-place. Additionally, after modifying the input list and removing the duplicates, the first `new length` elements in the list should hold the final result in the same order as they appeared in the original sorted array.","solution":"def remove_duplicates(nums): Removes the duplicates in-place such that each element appears only once and returns the new length of the modified list. Does not allocate extra space. :param nums: List[int] - list of sorted integers :return: int - the new length of the modified list if not nums: return 0 new_length = 1 # since the list is sorted, at least the first element is always unique for i in range(1, len(nums)): if nums[i] != nums[new_length - 1]: nums[new_length] = nums[i] new_length += 1 return new_length"},{"question":"Given an array of integers `nums`, you are tasked to implement a function that sorts the array in **wave form**. An array is said to be in wave form if `nums[0] >= nums[1] <= nums[2] >= nums[3] <= nums[4] >= ...` and so on. The transformed array should have the elements arranged in such a manner that forms the wave property. Return the modified array.","solution":"def wave_sort(nums): Sorts the array in wave form such that nums[0] >= nums[1] <= nums[2] >= nums[3] and so on. # Sort the array nums.sort() # Swap adjacent elements to form wave pattern for i in range(0, len(nums) - 1, 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums"},{"question":"You are given an array `points` containing the coordinates of points in the form `[x, y]` and an integer `k`. You need to connect all the points using exactly `k` lines in such a way that the sum of the Euclidean distances between the connected points is minimized. If it is not possible to connect all points with exactly `k` lines, return `-1`. Otherwise, return the minimum sum of the distances.","solution":"import heapq import math def min_distance_to_connect_points(points, k): Returns the minimum sum of the Euclidean distances between points after connecting exactly k lines. If it is not possible to connect all points with exactly k lines, return -1. if k < len(points) - 1: return -1 def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) n = len(points) if k >= n * (n - 1) // 2: # can form a complete graph with any number of lines k = n - 1 edges = [] for i in range(n): for j in range(i + 1, n): dist = euclidean_distance(points[i], points[j]) edges.append((dist, i, j)) edges.sort() parents = list(range(n)) def find(x): if parents[x] != x: parents[x] = find(parents[x]) return parents[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parents[rootY] = rootX min_cost = 0 count = 0 for edge in edges: if count == k: break dist, point1, point2 = edge if find(point1) != find(point2): union(point1, point2) min_cost += dist count += 1 return min_cost if count == k else -1"},{"question":"Given a list of words, each word consisting of lowercase English letters, determine if there exists a pair of distinct words such that one word is an anagram of the other. Implement the function `areAnagramsInList(words)` which returns `true` if such a pair exists and `false` otherwise. Example: ``` Input: words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\"] Output: true Input: words = [\\"apple\\", \\"orange\\", \\"banana\\"] Output: false ```","solution":"def areAnagramsInList(words): Returns true if there exists a pair of distinct words that are anagrams of each other. # Create a dictionary to store the canonical forms of words word_dict = {} for word in words: # Sort the word to get its canonical form (anagrams will have the same form) sorted_word = \'\'.join(sorted(word)) # If the canonical form already exists in the dictionary, return true if sorted_word in word_dict: return True # Otherwise, add the canonical form to the dictionary word_dict[sorted_word] = word # If no anagram pairs are found, return false return False"},{"question":"A group of people are standing in a circle and every `k`-th person is eliminated until only one person remains. The task is to find the position of that person in the initial circle. Given the total number of people `n` and an integer `k`, return _the safe position_. The positioning starts from 1 and moves in a circular manner. The solution must be returned in `O(n)` time complexity.","solution":"def safe_position(n, k): Returns the safe position in the Josephus problem with n people and every k-th person eliminated. if n == 1: return 1 else: return (safe_position(n-1, k) + k-1) % n + 1"},{"question":"You are given an array of integers `nums` representing a list of operations to be performed sequentially on an initially empty stack. The operations are represented as follows: - A positive integer `x` indicates that `x` should be pushed onto the stack. - The integer `0` indicates that the top element should be popped from the stack. Write a function that returns the content of the stack after all the operations have been performed. If an operation tries to pop from an empty stack, skip that operation. Your function should return the stack as an array where the bottom-most element is the first element and the top-most element is the last element.","solution":"def stack_operations(nums): Performs operations on an initially empty stack as described by the list of integers. Parameters: nums (list of int): List of operations where positive integers are pushed and 0 indicates a pop operation. Returns: list of int: The content of the stack after all the operations. stack = [] for num in nums: if num > 0: stack.append(num) elif num == 0 and stack: stack.pop() return stack"},{"question":"You are given an array of integers `arr` and an integer `window_size`. Implement a function that finds the maximum sum of any subarray of length `window_size`. A subarray is a contiguous part of an array. Your function should return this maximum sum value.","solution":"def max_sum_subarray(arr, window_size): Finds the maximum sum of any subarray of length window_size. Parameters: arr (list of int): The input array of integers. window_size (int): The length of the subarray. Returns: int: The maximum sum of any subarray of length window_size. if not arr or window_size <= 0 or window_size > len(arr): return 0 max_sum = sum(arr[:window_size]) current_sum = max_sum for i in range(window_size, len(arr)): current_sum = current_sum - arr[i - window_size] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. Write a function to determine if there is a **contiguous subarray** within the array that sums up to a multiple of `k`, that is, sums up to `n*k` where `n` is an integer. If such a subarray exists, return `true`; otherwise, return `false`.","solution":"def check_subarray_sum(nums, k): Checks if there is a contiguous subarray that sums to a multiple of k. Parameters: nums (list of int): List of non-negative integers. k (int): Target multiple integer. Returns: bool: True if such a subarray exists, otherwise False. if k == 0: return any(sum(nums[i:i+2]) == 0 for i in range(len(nums) - 1)) mod_map = {0: -1} # remainder -> first index where this remainder was seen total = 0 for i in range(len(nums)): total += nums[i] remainder = total % k if remainder in mod_map: if i - mod_map[remainder] > 1: return True else: mod_map[remainder] = i return False"},{"question":"Develop a class `CustomQueue` that simulates a queue with dynamic resizing capabilities. Implement the `CustomQueue` class which should include the following methods: * `CustomQueue(int initialSize)` initializes the queue with the given initial size. * `void enqueue(int val)` adds the element `val` to the end of the queue. * `int dequeue()` removes and returns the element at the front of the queue. * `int size()` returns the current number of elements in the queue. * `bool isEmpty()` returns whether the queue is empty. The queue should resize automatically to accommodate new elements if it exceeds the initial size.","solution":"class CustomQueue: def __init__(self, initialSize): self.queue = [None] * initialSize self.head = 0 self.tail = 0 self.max_size = initialSize self.count = 0 def enqueue(self, val): if self.count == self.max_size: self.resize() self.queue[self.tail] = val self.tail = (self.tail + 1) % self.max_size self.count += 1 def dequeue(self): if self.isEmpty(): raise IndexError(\\"dequeue from an empty queue\\") value = self.queue[self.head] self.head = (self.head + 1) % self.max_size self.count -= 1 return value def size(self): return self.count def isEmpty(self): return self.count == 0 def resize(self): new_max_size = self.max_size * 2 new_queue = [None] * new_max_size for i in range(self.count): new_queue[i] = self.queue[(self.head + i) % self.max_size] self.queue = new_queue self.head = 0 self.tail = self.count self.max_size = new_max_size"},{"question":"You are given two integer arrays `nums1` and `nums2`. A pair of indices `(i, j)` is considered **good** if `i < j` and `nums1[i] == nums2[j]`. Return the total number of **good** pairs.","solution":"def count_good_pairs(nums1, nums2): Returns the total number of good pairs (i, j) such that i < j and nums1[i] == nums2[j]. count = 0 for i in range(len(nums1)): for j in range(i+1, len(nums2)): if nums1[i] == nums2[j]: count += 1 return count"},{"question":"You are given a string `s` and an array of indices `indices` where `indices[i]` indicates the position in the string `s` where the character at `i` should be moved. Reconstruct the string and return it so that `s` is shuffled according to the given `indices`. For example, if `s = \\"abc\\"` and `indices = [2, 0, 1]`, the resulting string should be `\\"bca\\"`.","solution":"def shuffle_string(s, indices): Returns the shuffled string according to the indices array. Args: s (str): The input string. indices (list of int): The list of indices to shuffle the string. Returns: str: The shuffled string. shuffled = [\'\'] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return \'\'.join(shuffled)"},{"question":"Given a list of `n` integers `arr`, you are allowed to remove at most one element to make the remaining elements form a strictly increasing sequence. Determine if it is possible to achieve this goal. Return `true` if you can achieve a strictly increasing sequence by removing at most one element, otherwise return `false`.","solution":"def can_form_increasing_sequence(arr): def is_strictly_increasing(a): for i in range(1, len(a)): if a[i-1] >= a[i]: return False return True # Check if arr is already strictly increasing if is_strictly_increasing(arr): return True # Try removing each element and check if the resulting array is strictly increasing for i in range(len(arr)): if is_strictly_increasing(arr[:i] + arr[i+1:]): return True return False"},{"question":"You are given an integer array `nums` and an integer `k`. An array is called **beautiful** if it satisfies the following condition: for every `i` where `0 <= i <= nums.length - k`, the absolute difference between `nums[i]` and `nums[i + k]` is less than or equal to `1`. Given the array `nums` and the integer `k`, return a boolean indicating whether the array is beautiful based on the above condition.","solution":"def is_beautiful(nums, k): Returns True if the array `nums` is beautiful with respect to integer `k`. for i in range(len(nums) - k): if abs(nums[i] - nums[i + k]) > 1: return False return True"},{"question":"You are given an array of integers `arr`. Write a function to count the number of unique pairs (i, j) such that `arr[i] + arr[j]` equals a given target sum `k`, where `i < j`. Each pair should be considered only once, and the elements in the pair must be distinct. Return the count of such unique pairs. For example, given `arr = [1, 2, 3, 4, 3]` and `k = 6`, the unique pairs would be (0, 3) and (1, 2), resulting in a count of 2.","solution":"def count_unique_pairs(arr, k): Returns the count of unique pairs (i, j) such that arr[i] + arr[j] = k and i < j. :param arr: List of integers :param k: Target sum :return: Count of unique pairs seen = set() pairs = set() count = 0 for i, num in enumerate(arr): target = k - num if target in seen: pairs.add((min(num, target), max(num, target))) seen.add(num) return len(pairs)"},{"question":"Given a `2D` grid of size `m x n` representing a map where `1` represents land and `0` represents water, you are also given an integer `k`. You want to determine the shortest distance in terms of step count to move from the top-left corner of the grid to the bottom-right corner, avoiding obstacles (water) and following the restrictions. However, you are allowed to convert up to `k` water cells into land cells. You can move up, down, left, or right from a land cell to another land cell. If it is not possible to reach the bottom-right corner, return `-1`. Return _the shortest distance possible, considering the conversion allowance_.","solution":"from collections import deque def shortest_path_with_conversions(grid, k): Finds the shortest path from the top-left to the bottom-right corner, with the ability to convert up to k water cells to land. Parameters: grid (List[List[int]]): The map grid where 1 represents land and 0 represents water. k (int): The number of water cells that can be converted to land. Returns: int: The shortest path length if reachable, otherwise -1. m, n = len(grid), len(grid[0]) if grid[0][0] == 1 and grid[m-1][n-1] == 1: if m == 1 and n == 1: # Start and end are the same cell return 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0, k)]) # (row, col, steps, remaining conversions) visited = set([(0, 0, k)]) while queue: x, y, steps, remaining_k = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == 1 and (nx, ny, remaining_k) not in visited: visited.add((nx, ny, remaining_k)) queue.append((nx, ny, steps + 1, remaining_k)) elif grid[nx][ny] == 0 and remaining_k > 0 and (nx, ny, remaining_k - 1) not in visited: visited.add((nx, ny, remaining_k - 1)) queue.append((nx, ny, steps + 1, remaining_k - 1)) return -1"},{"question":"Given an `n` x `n` matrix of integers, return an array of the matrix\'s anti-diagonals. An anti-diagonal of the matrix consists of entries from matrix at indices `(i, j)` where `i + j` is constant. The entries should be listed in order of increasing row index and decreasing column index. Implement the function `List<List<Integer>> findAntiDiagonals(int[][] matrix)`, where `matrix` is the given 2D array of size `n x n`. This function should return a list of lists, with each nested list containing the elements of an anti-diagonal.","solution":"def findAntiDiagonals(matrix): Given an `n` x `n` matrix of integers, return an array of the matrix\'s anti-diagonals. n = len(matrix) result = [] # Collect all anti-diagonals starting from the first row for col in range(n): anti_diagonal = [] i, j = 0, col while i < n and j >= 0: anti_diagonal.append(matrix[i][j]) i += 1 j -= 1 result.append(anti_diagonal) # Collect all anti-diagonals starting from the last column for row in range(1, n): anti_diagonal = [] i, j = row, n - 1 while i < n and j >= 0: anti_diagonal.append(matrix[i][j]) i += 1 j -= 1 result.append(anti_diagonal) return result"},{"question":"Given an array of integers `arr`, find the shortest subarray, which has a sum greater than or equal to a given integer `target`. Write a function `minSubArrayLen` that takes in `target` and `arr` as arguments and returns the length of the shortest such subarray. If there is no such subarray, return `0`. For example, given `target = 7` and `arr = [2, 3, 1, 2, 4, 3]`, the function should return `2` since the subarray `[4, 3]` has the minimal length under the problem constraint.","solution":"def minSubArrayLen(target, arr): Find the length of the shortest subarray with a sum >= target. If no such subarray exists, return 0. n = len(arr) left = 0 current_sum = 0 min_length = float(\'inf\') for right in range(n): current_sum += arr[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"You are given an integer array `heights` representing the heights of a series of buildings. You are playing a game where you can increase the height of any building by 1 in each move. Your goal is to make all buildings\' heights equal. Return the minimum number of moves required to make all the buildings\' heights equal if you can only increase heights in each move.","solution":"def min_moves_to_make_heights_equal(heights): Returns the minimum number of moves required to make all building heights equal. Each move can only increase the height of one building by 1. max_height = max(heights) moves = 0 for height in heights: moves += max_height - height return moves"},{"question":"You are given a string `s` containing just the characters `(` and `)`. You need to find the longest substring of `s` that is a valid parenthetical expression. A valid parenthetical expression contains only well-formed parentheses, where every opening parenthesis has a matching closing parenthesis. Return the length of this longest valid parenthetical substring. For example: - If `s = \\"(()\\"`, the longest valid substring is `\\"()\\"` with a length of 2. - If `s = \\")()())\\"`, the longest valid substring is `\\"()()\\"` with a length of 4. - If `s = \\"\\"`, the longest valid substring is `\\"\\"` with a length of 0.","solution":"def longestValidParentheses(s): Returns the length of the longest valid (well-formed) parentheses substring. Args: s (str): Input string containing only \'(\' and \')\' Returns: int: Length of the longest valid parentheses substring max_len = 0 stack = [-1] for i in range(len(s)): if s[i] == \'(\': stack.append(i) else: stack.pop() if len(stack) == 0: stack.append(i) else: max_len = max(max_len, i - stack[-1]) return max_len"},{"question":"Given a string `str`, write a function to determine if it can form a palindrome after deleting at most one character. Return `true` if it can be done, otherwise return `false`. A palindrome is a word, phrase, or sequence that reads the same backward as forward (ignoring spaces, punctuation, and capitalization).","solution":"def valid_palindrome(s): Returns whether the string can form a palindrome after deleting at most one character. def is_palindrome(sub): return sub == sub[::-1] left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try removing char at left or right return is_palindrome(s[left+1:right+1]) or is_palindrome(s[left:right]) left += 1 right -= 1 return True"},{"question":"Given a **0-indexed** string `s` containing only lowercase English letters, we call a substring of `s` _beautiful_ if it contains no more than `k` distinct characters. Return _the length of the longest beautiful substring of `s`_.","solution":"def longest_beautiful_substring(s, k): Returns the length of the longest beautiful substring of s which contains no more than k distinct characters. from collections import defaultdict n = len(s) if n == 0 or k == 0: return 0 char_count = defaultdict(int) left = 0 max_len = 0 distinct_count = 0 for right in range(n): # Add current character to the count if char_count[s[right]] == 0: distinct_count += 1 char_count[s[right]] += 1 # While distinct character count exceeds k, # Move the left pointer to maintain the condition while distinct_count > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a square matrix `matrix` of integers. Calculate the absolute difference between the sums of its diagonals. The main diagonal is the diagonal that runs from the top-left to the bottom-right corner of the matrix, and the secondary diagonal is the diagonal that runs from the top-right to the bottom-left corner. Return the absolute difference between the sums of the matrix\'s diagonals.","solution":"def diagonal_difference(matrix): Returns the absolute difference between the sums of the main diagonal and secondary diagonal of a square matrix. n = len(matrix) # Sum of main diagonal main_diagonal_sum = sum(matrix[i][i] for i in range(n)) # Sum of secondary diagonal secondary_diagonal_sum = sum(matrix[i][n - i - 1] for i in range(n)) # Absolute difference return abs(main_diagonal_sum - secondary_diagonal_sum)"},{"question":"You are given two integer arrays, `nums1` and `nums2`, where `nums1` is a subset of `nums2`. Find an array `result` such that for each element `nums1[i]`, `result[i]` is the first greater element to the right of `nums1[i]` in `nums2`. If there is no such element, set `result[i]` to -1. Return the resulting array `result`.","solution":"def next_greater_element(nums1, nums2): Finds the next greater element for each element in nums1 within the array nums2. result = [] element_index_map = {value: index for index, value in enumerate(nums2)} for num in nums1: found = False start_index = element_index_map[num] + 1 for i in range(start_index, len(nums2)): if nums2[i] > num: result.append(nums2[i]) found = True break if not found: result.append(-1) return result"},{"question":"Given a list `logs` of logged in and log-out times of different users represented as 2D integer vectors where `logs[i] = [userid, loginTime, logoutTime]`. Each log represents a user logging in at `loginTime` and logging out at `logoutTime`. A user is considered logged in for any duration between `loginTime` and `logoutTime`, inclusive of `loginTime`, but exclusive of `logoutTime`. Your task is to find the user who was logged in for the longest total duration. If there are multiple users with the same longest total duration, return the `userid` with the smallest `userid`. Return the `userid` of the user who was logged in for the longest total duration. Example: ```python Input: logs = [[1, 1, 10], [2, 2, 5], [1, 5, 7]] Output: 1 ```","solution":"def find_longest_logged_in_user(logs): user_duration = {} for log in logs: userid, loginTime, logoutTime = log duration = logoutTime - loginTime if userid in user_duration: user_duration[userid] += duration else: user_duration[userid] = duration max_duration = -1 user_with_max_duration = None for userid, duration in user_duration.items(): if duration > max_duration or (duration == max_duration and userid < user_with_max_duration): max_duration = duration user_with_max_duration = userid return user_with_max_duration"},{"question":"You are given two arrays `spells` and `potions`, each consisting of positive integers. These represent the strength of spells and potions, respectively. You are also given an integer `success`. A spell and a potion are considered a successful pair if the product of their strengths is at least `success`. Return an array of length equal to `spells` where each element is the number of potions that can form a successful pair with the corresponding spell. The solution should have a time complexity that is optimized for large inputs.","solution":"def successful_pairs(spells, potions, success): Returns an array where the ith element is the number of potions that can form a successful pair with the ith spell. potions.sort() result = [] for spell in spells: left, right = 0, len(potions) while left < right: mid = left + (right - left) // 2 if potions[mid] * spell >= success: right = mid else: left = mid + 1 result.append(len(potions) - left) return result"},{"question":"You are given a `rows x cols` matrix `matrix` representing an image. Paint can fill an entire region of the same color in the image with the given new color. The region to be filled is defined by four parameters: `row`, `col`, `newColor`, and `oldColor`. Fill the entire connected region containing the coordinate `(row, col)` with `newColor`. A connected region is formed by pixels with the same `oldColor` connected vertically or horizontally. Return _the modified matrix_ after performing the fill operation.","solution":"def fill_region(matrix, row, col, newColor, oldColor): Fill the entire connected region containing the coordinate (row, col) with newColor. A connected region is formed by pixels with the same oldColor connected vertically or horizontally. Parameters: - matrix: A list of lists representing the image. - row: The starting row for the fill operation. - col: The starting column for the fill operation. - newColor: The color to fill the region with. - oldColor: The color of the region to fill. Returns: - The modified matrix after performing the fill operation. def valid(r, c): return 0 <= r < len(matrix) and 0 <= c < len(matrix[0]) and matrix[r][c] == oldColor def dfs(r, c): if not valid(r, c): return matrix[r][c] = newColor directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dr, dc in directions: dfs(r + dr, c + dc) if oldColor != newColor: dfs(row, col) return matrix"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring of `s` is called a \\"special substring\\" if all the characters of the substring are the same. For example, in the string \\"aaa\\", \\"a\\", \\"aa\\", and \\"aaa\\" are all special substrings, but \\"ab\\" is not. You need to determine the number of special substrings in `s`. Return _the number of special substrings in the given string_.","solution":"def count_special_substrings(s): Count the number of special substrings in the given string s. A special substring is one where all characters are the same. :param s: A string consisting of lowercase English letters :return: The number of special substrings n = len(s) count = 0 i = 0 while i < n: char_count = 1 while i + 1 < n and s[i] == s[i + 1]: char_count += 1 i += 1 count += (char_count * (char_count + 1)) // 2 i += 1 return count"},{"question":"Given an integer array `nums` and an array `queries` where `queries[i]` is a tuple `(left, right)`, return an integer array `answer` such that `answer[i]` is the sum of elements between indices `left` and `right` inclusive in the `nums` array. Implement the `RangeSumQuery` class: * `RangeSumQuery(int[] nums)` initializes the object with the integer array `nums`. * `int[] sumRange(int[][] queries)` returns an integer array `answer` where `answer[i]` is the sum of elements between indices `left` and `right` for the `ith` query.","solution":"class RangeSumQuery: def __init__(self, nums): self.nums = nums # Generate prefix sums to make range sum queries more efficient self.prefix_sums = [0] * (len(nums) + 1) for i in range(1, len(nums) + 1): self.prefix_sums[i] = self.prefix_sums[i - 1] + nums[i - 1] def sumRange(self, queries): result = [] for left, right in queries: range_sum = self.prefix_sums[right + 1] - self.prefix_sums[left] result.append(range_sum) return result"},{"question":"You are given a list of `n` strings containing only lowercase English letters. Each string can be converted into another string by reordering its letters, otherwise known as an anagram. Your task is to group the given strings into sets of anagrams, where each set contains all anagrams of a particular string. Return the list of these sets, where each set in the list contains all the anagrams of a given string. Note that the order of the sets and the order of the strings within each set does not matter.","solution":"def group_anagrams(strings): from collections import defaultdict anagrams = defaultdict(list) for string in strings: sorted_string = \'\'.join(sorted(string)) anagrams[sorted_string].append(string) return list(anagrams.values())"},{"question":"A university has several departments, and each department has a certain number of *students*, listed in a given array `students` where each element represents the number of students in a department. The university wants to **split** each department into smaller classes where each class should have the same number of students. However, the university can assign all students to a single large class if required. Each class should contain at least `min_students` students and at most `max_students` students. To optimize resource usage, the university wants to split departments such that the **total number of classes** is minimized. Write a function to determine the **minimum number of classes** required for each department and return the result as an array where each element corresponds to the minimum number of classes for that respective department. Given the input array `students`, and integers `min_students`, and `max_students`, return an array representing the minimum number of classes for each department. # Example: For `students = [35, 78, 50, 22]`, `min_students = 20`, and `max_students = 30`, the function should return `[2, 3, 2, 1]`.","solution":"def min_classes(students, min_students, max_students): Calculate the minimum number of classes required for each department. :param students: List of integers representing the number of students in each department. :param min_students: Minimum number of students in a class. :param max_students: Maximum number of students in a class. :return: List of integers representing the minimum number of classes for each department. classes = [] for student_count in students: if student_count <= max_students: classes.append(1) elif student_count % max_students == 0: classes.append(student_count // max_students) else: classes.append(student_count // max_students + 1) return classes"},{"question":"You are given a list of strings `words` and a list of characters `chars`. A string in `words` is considered a \\"**good word**\\" if it can be formed using the characters in `chars` where each character in `chars` can only be used once. Return _the total length of all **good words**_ in `words`. **Example:** If `words = [\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"]` and `chars = \\"atach\\"`, then \\"cat\\" and \\"hat\\" are good words (formed using \'c\', \'a\', \'t\', \'h\'). Therefore, the total length of good words is `3 + 3 = 6`. **Note:** A \\"good word\\" is formed using only the characters from `chars` and each character from `chars` can only be used once per word.","solution":"def count_characters(words, chars): Returns the total length of all good words that can be formed using characters in chars. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(chars_count[char] >= count for char, count in word_count.items()): total_length += len(word) return total_length"},{"question":"You are managing a cloud storage service where users can store files and folders. A file is represented as a string of characters**,** while a folder can contain multiple files and subfolders. Folders and files are identified uniquely by strings. Implement the `CloudStorage` class with the following methods: * `CloudStorage()`: Initializes the storage object. * `void createFolder(String folderName)`: Create a new empty folder with the given name. * `void uploadFile(String folderName, String fileName, String content)`: Upload a file with the given name and content to the specified folder. * `void deleteFile(String folderName, String fileName)`: If there is a file with the given name in the specified folder, remove it. * `String getFileContent(String folderName, String fileName)`: If there is a file with the given name in the specified folder, return its content. Otherwise, return `null`. * `String[] listFilesAndFolders(String folderName)`: Return a list containing the names of all files and subfolders in the specified folder. If the folder does not exist, return `null`. * `void move(String sourceFolderName, String destinationFolderName, String fileName)`: If a file or subfolder named `fileName` exists in `sourceFolderName`, move it to `destinationFolderName`. If either the source or destination folder does not exist, do nothing. * `boolean exists(String folderName, String itemName)`: Return `true` if a file or subfolder named `itemName` exists in `folderName`, `false` otherwise.","solution":"class CloudStorage: def __init__(self): self.storage = {} def createFolder(self, folderName): if folderName not in self.storage: self.storage[folderName] = {} def uploadFile(self, folderName, fileName, content): if folderName in self.storage: self.storage[folderName][fileName] = content def deleteFile(self, folderName, fileName): if folderName in self.storage and fileName in self.storage[folderName]: del self.storage[folderName][fileName] def getFileContent(self, folderName, fileName): if folderName in self.storage and fileName in self.storage[folderName]: return self.storage[folderName][fileName] return None def listFilesAndFolders(self, folderName): if folderName in self.storage: return list(self.storage[folderName].keys()) return None def move(self, sourceFolderName, destinationFolderName, itemName): if sourceFolderName in self.storage and destinationFolderName in self.storage: if itemName in self.storage[sourceFolderName]: self.storage[destinationFolderName][itemName] = self.storage[sourceFolderName][itemName] del self.storage[sourceFolderName][itemName] def exists(self, folderName, itemName): if folderName in self.storage and itemName in self.storage[folderName]: return True return False"},{"question":"You are given a string `s` containing lowercase English letters. A subset of characters in `s` is considered \\"even\\" if the number of times each character appears in the subset is even. Determine the length of the longest \\"even\\" subset. If no such subset exists, return `0`.","solution":"def longest_even_subset_length(s): from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Initialize the length of the longest even subset long_even_subset_length = 0 # Iterate through the character counts for count in char_count.values(): if count % 2 == 0: # If the count is even, add the count to the subset length long_even_subset_length += count else: # If the count is odd, add the even part of the count to the subset length long_even_subset_length += count - 1 return long_even_subset_length"},{"question":"You are given two integer arrays `s` and `t` of the same length. You are allowed to perform a series of operations to the array `s`. In each operation, you can select any two indices `i` and `j` (i ≠ j) and increase both `s[i]` and `s[j]` by 1. Your goal is to make array `s` equal to array `t`. Determine if it is possible to achieve this goal using any number of operations. Return `true` if it is possible to make `s` equal to `t`. Otherwise, return `false`.","solution":"def can_transform(s, t): Determines if it is possible to transform array s into array t using the allowed operations. Parameters: s (list of int): The initial array. t (list of int): The target array. Returns: bool: True if it is possible to transform s into t, False otherwise. # If the sorted arrays are identical, return True return sorted(s) == sorted(t)"},{"question":"Given a string `s`, return _the rank of the string amongst its permutations sorted lexicographically_. Assume no characters are repeated in the string. The rank should be `1`-indexed. For example, the string \\"abc\\" is the first permutation in lexicographical order, so its rank is `1`. The rank of the string \\"acb\\" would be `2`, and so on.","solution":"from math import factorial def find_lexicographic_rank(s): Returns the rank of the string s amongst its permutations sorted lexicographically. rank = 1 n = len(s) for i, char in enumerate(s): smaller_chars = sum(c < char for c in s[i+1:]) rank += smaller_chars * factorial(n - i - 1) return rank"},{"question":"Given a string `s` which represents a student’s answers to a test consisting of `n` binary questions (either \'0\' or \'1\'), and an integer `k` indicating the maximum allowed consecutive wrong answers (\'0\'s), return the length of the longest contiguous subarray where the number of wrong answers does not exceed `k`. You need to find a way to analyze the string and determine this longest valid subarray.","solution":"def longest_valid_subarray(s, k): Returns the length of the longest contiguous subarray where the number of \'0\'s does not exceed k. left = 0 max_length = 0 zeros_count = 0 for right in range(len(s)): if s[right] == \'0\': zeros_count += 1 while zeros_count > k: if s[left] == \'0\': zeros_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a **0-indexed** array of integers `heights` representing the height of students standing in a line. A student can see the board if no student in front of them in the line has a height greater than or equal to theirs. Return _the number of students who can see the board_. For example, given the array `heights = [4, 3, 2, 5, 1]`: - The student with height `1` cannot see the board as all students in front are taller. - The student with height `2` can see the board since 3 is the only taller student in front. - The student with height `3` can see the board since the only taller student is in front. - The student with height `4` can see the board as there are no taller students in front. - The student with height `5` can see the board as there are no students in front. Return the count of students who can see the board from their respective positions.","solution":"def students_who_can_see_board(heights): Returns the number of students who can see the board. count = 0 max_height_seen = 0 for height in heights: if height > max_height_seen: count += 1 max_height_seen = height return count"},{"question":"You are given an unsorted array of integers `nums` and an integer `k`. Your task is to find the maximum number of subsequences of `nums` where the difference between the maximum and minimum element of each subsequence is less than or equal to `k`. Assume all elements in `nums` are unique. Return an integer representing the maximum number of such subsequences.","solution":"def max_subsequences_with_k_difference(nums, k): Returns the maximum number of subsequences where the difference between the maximum and minimum element is less than or equal to `k`. :param nums: List[int] - The input list of integers. :param k: int - The maximum allowed difference. :return: int - Number of valid subsequences. nums.sort() count = 0 i = 0 # Using two pointers to track valid subsequences while i < len(nums): min_val = nums[i] j = i # Advance j pointer until the difference condition is broken while j < len(nums) and nums[j] - min_val <= k: j += 1 count += 1 i = j return count"},{"question":"You are given a string `s` of lowercase English letters and an integer `k`. You need to select a subsequence of `s` such that it has exactly `k` distinct characters. Return the length of the longest such subsequence. If there is no such subsequence, return `-1`.","solution":"from collections import Counter def longest_subsequence_with_k_distinct(s, k): Returns the length of the longest subsequence with exactly k distinct characters. If there is no such subsequence, returns -1. if len(set(s)) < k: return -1 char_count = Counter(s) sorted_char_count = sorted(char_count.values(), reverse=True) # We need to sum up as many of the sorted counts as we need to reach exactly k distinct characters longest_subsequence_length = sum(sorted_char_count[:k]) return longest_subsequence_length"},{"question":"Given a grid with `m` rows and `n` columns represented by a 2D array `grid`, each cell in the grid can either be `0` (an empty cell) or `1` (a land cell). A group of connected land cells (horizontal or vertical but not diagonal) form an island. Write a function to count the number of islands in the given `grid`. For example, given the `grid`: ``` [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] ``` Return _3_ because there are three distinct islands in the grid.","solution":"def num_islands(grid): if not grid: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark as visited dfs(i+1, j) # Check down dfs(i-1, j) # Check up dfs(i, j+1) # Check right dfs(i, j-1) # Check left count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: count += 1 dfs(i, j) return count"},{"question":"Given two arrays of integers `arr1` and `arr2`, determine if they are similar. Two arrays are considered similar if one can be obtained from the other by swapping at most one pair of elements in one of the arrays. Return `true` if the arrays are similar, otherwise return `false`.","solution":"def are_similar(arr1, arr2): Determines if the two arrays arr1 and arr2 are similar. Two arrays are similar if one can be obtained from the other by swapping at most one pair of elements in one of the arrays. if arr1 == arr2: return True difference_pairs = [(a, b) for a, b in zip(arr1, arr2) if a != b] if len(difference_pairs) == 2 and difference_pairs[0] == difference_pairs[1][::-1]: return True return False"},{"question":"You are provided with a sorted array `arr` of unique integers where elements are in ascending order. However, the array has been rotated at some pivot unknown to you beforehand. Implement a function that finds the pivot index of this array. The pivot index is the index of the smallest element in the rotated array. If the array is not rotated, return `0`.","solution":"def find_pivot_index(arr): This function returns the pivot index of a rotated sorted array. If the array is not rotated, it returns 0. if not arr: return -1 # Handle empty array edge case low, high = 0, len(arr) - 1 while low < high: mid = (low + high) // 2 # If mid element is greater than high element, the pivot must be in the right half if arr[mid] > arr[high]: low = mid + 1 else: high = mid return low"},{"question":"# New Question 4: [Question 4]: Implement a function that takes a list of strings and groups them into anagrams. Return the list of groups, where each group contains strings that are anagrams of each other. Each group should be represented as a list of strings, and the output should be a list of these lists. Note that two strings are anagrams if and only if their sorted character sequences are identical.","solution":"from collections import defaultdict def group_anagrams(words): Groups a list of words into anagrams. :param words: List of strings :return: List of lists of grouped anagram strings anagram_dict = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values())"},{"question":"Given a non-negative integer `num`, repeatedly add all its digits until the result has only one digit. For example, given `num = 38`, the process is as follows: - `3 + 8 = 11` - `1 + 1 = 2` Since `2` has only one digit, return it. The function should have `O(1)` time complexity.","solution":"def add_digits(num): Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. if num == 0: return 0 else: return 1 + (num - 1) % 9"},{"question":"You are given a list of `n` houses positioned along a straight road, represented by a **0-indexed** integer array `houses` where `houses[i]` is the position of the `i-th` house. You need to place `m` mailboxes along the road to minimize the total distance between each house and its nearest mailbox. Return _the minimum total distance between the houses and their nearest mailboxes_. Answers within `10-5` of the actual answer will be accepted.","solution":"def min_distance(houses, m): houses.sort() n = len(houses) if m >= n: return 0 dp = [[float(\'inf\')] * m for _ in range(n)] for i in range(n): dp[i][0] = sum(abs(houses[j] - houses[i//2]) for j in range(i+1)) for k in range(1, m): for i in range(k, n): for j in range(k-1, i): dp[i][k] = min(dp[i][k], dp[j][k-1] + sum(abs(houses[l] - houses[(j+1 + i)//2]) for l in range(j+1, i+1))) return dp[-1][-1]"},{"question":"You are given a **0-indexed** integer array `heights` where `heights[i]` is the height of the `ith` building in a line of buildings. Assume each building has a width of `1`. The goal is to build a **skyline silhouette** by installing billboards on top of some buildings. You can only install one billboard on each building, and the height of the billboard must be exactly `k` units. Return the **maximum number** of billboards you can install such that no two billboards overlap when viewed from the front.","solution":"def max_billboards(heights, k): Returns the maximum number of billboards that can be installed such that no two billboards overlap when viewed from the front. Parameters: heights (list of int): Heights of the buildings. k (int): Height of the billboards. Returns: int: Maximum number of billboards that can be installed. if not heights: return 0 max_billboards = 0 for i, height in enumerate(heights): if height >= k: max_billboards += 1 while i + 1 < len(heights) and heights[i + 1] >= k: i += 1 return max_billboards"},{"question":"You are given a string consisting of lowercase alphabets and parentheses. Your task is to remove the minimum number of invalid parentheses so that the resulting string is valid. A string is valid if it contains matched parentheses. Return all possible results. You may return the answer in any order.","solution":"def remove_invalid_parentheses(s): def is_valid(string): balance = 0 for char in string: if char == \'(\': balance += 1 elif char == \')\': balance -= 1 if balance < 0: return False return balance == 0 level = {s} while True: valid = list(filter(is_valid, level)) if valid: return valid next_level = set() for item in level: for i in range(len(item)): if item[i] in (\'(\', \')\'): next_level.add(item[:i] + item[i+1:]) level = next_level # Example Usage # print(remove_invalid_parentheses(\\"()())()\\")) # Output: [\'()()()\', \'(())()\']"},{"question":"You are given two **0-indexed** integer arrays `original` and `altered`. The array `original` represents the initial sequence of elements, and `altered` is derived from `original` by performing zero or more removal operations. Your task is to determine whether `original` can be transformed into `altered` by removing some (possibly zero) elements without changing the order of the remaining elements. Return `true` if `original` can be transformed into `altered` in this way, or `false` otherwise.","solution":"def can_transform(original, altered): Determines if `original` can be transformed into `altered` by removing some elements without changing the order. Parameters: original (List[int]): The original sequence of elements. altered (List[int]): The sequence derived from `original` by performing zero or more removal operations. Returns: bool: True if `original` can be transformed into `altered`, False otherwise. o_idx = 0 for a in altered: while o_idx < len(original) and original[o_idx] != a: o_idx += 1 if o_idx == len(original): return False o_idx += 1 return True"},{"question":"You are given a binary tree with `n` nodes. Each node\'s value is a character representing a lowercase English letter. Implement a function to determine the lexicographically smallest string that starts at any leaf of this tree and ends at the root. A \\"leaf\\" is a node with no children. In the event of ties, the lexicographically smallest string that corresponds to the leftmost path in the tree should be chosen. Finally, the tree nodes are defined as per the following structure: ```python class TreeNode: def __init__(self, val: str = \'\', left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right ``` Implement the function: ```python def smallestFromLeaf(root: TreeNode) -> str: ``` where `root` is the root of the given binary tree. The function should return the lexicographically smallest string possible that starts at a leaf and ends at the root.","solution":"class TreeNode: def __init__(self, val=\'\', left=None, right=None): self.val = val self.left = left self.right = right def smallestFromLeaf(root: TreeNode) -> str: if not root: return \\"\\" def dfs(node, path): if not node: return None path = node.val + path if not node.left and not node.right: return path left_path = dfs(node.left, path) right_path = dfs(node.right, path) if left_path and right_path: return min(left_path, right_path) else: return left_path or right_path return dfs(root, \\"\\")"},{"question":"You are given an `n x n` grid containing integers. Each integer represents the height of a building located at that position in the grid. You are also given two pairs of coordinates `start` and `end`, each defined as `(row, column)`. The task is to find a path from `start` to `end` such that the maximum height difference between any two consecutive buildings in the path is minimized. You can only move up, down, left, or right. Return the minimum possible maximum height difference.","solution":"from heapq import heappush, heappop from typing import List, Tuple def min_max_diff_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Find the path with the minimum possible maximum height difference from start to end in the grid. n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_heap = [(0, start[0], start[1])] visited = set() while min_heap: max_diff, row, col = heappop(min_heap) if (row, col) == end: return max_diff if (row, col) in visited: continue visited.add((row, col)) for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < n and 0 <= c < n: next_diff = abs(grid[row][col] - grid[r][c]) heappush(min_heap, (max(max_diff, next_diff), r, c))"},{"question":"Implement a `WordFilter` class that performs searches on a list of words. The `WordFilter` class should be initialized with a list of words. The class should support a method `f`, which takes two arguments, a prefix and a suffix, and returns the index of the word in the list that has the given prefix and suffix. If no such word exists, return -1. The search should prioritize finding the word with the highest index that matches the criteria. Implement the `WordFilter` class with the following methods: - `WordFilter(String[] words)`: Initializes the object with the words. - `int f(String prefix, String suffix)`: Returns the index of the word with the given prefix and suffix, or -1 if no such word exists.","solution":"class WordFilter: def __init__(self, words): Initializes the object with the words. self.words = words def f(self, prefix, suffix): Returns the index of the word with the given prefix and suffix, or -1 if no such word exists. for i in range(len(self.words) - 1, -1, -1): word = self.words[i] if word.startswith(prefix) and word.endswith(suffix): return i return -1"},{"question":"You are given a string `s` representing a sentence. Each word in `s` is separated by a single space. Reverse the order of the words, but keep the order of the characters in each word the same. Note that the sentence may contain leading or trailing spaces, or multiple spaces between words. Normalize the sentence such that after reversing the order of the words, there is exactly one space between each word, and no leading or trailing spaces. Return the resulting string. For example, given the input `\\" hello world \\"`, the output should be `\\"world hello\\"`.","solution":"def reverse_words(sentence): Reverses the order of the words in a given sentence while keeping the order of characters in each word the same. Ensures normalized spacing with a single space between words and no leading or trailing spaces. Parameters: sentence (str): The input sentence with words separated by spaces. Returns: str: The sentence with the order of words reversed. # Strip leading and trailing spaces sentence = sentence.strip() # Split the sentence into words based on spaces words = sentence.split() # Reverse the order of words and join them with a single space reversed_sentence = \' \'.join(words[::-1]) return reversed_sentence"},{"question":"Mr. Smith, a math teacher, has a passion for cryptography, especially encoding messages using a special cipher technique. He uses a unique approach to encode a given string `s`, consisting of lowercase letters only. His encoding method operates as follows: 1. Starting with an empty string `encoded`, iterate through each character `ch` in the original string `s`. 2. Append pairs of characters `(ch, count)` to `encoded`, where `count` denotes the number of times that `ch` consecutively appears in `s` until a different character is encountered. 3. If `count` is more than 1, append it as a string along with `ch`; otherwise, only append `ch`. For example: - `\\"aaabbcccc\\"` becomes `\\"a3b2c4\\"` - `\\"hhhhh\\"` becomes `\\"h5\\"` - `\\"xyz\\"` remains `\\"xyz\\"` Your task is to implement the encoding function, which, given a string `s`, returns the encoded string as described. Write a function `encodeString(s: str) -> str` that takes a single string `s` and returns the encoded string.","solution":"def encodeString(s: str) -> str: Encodes the given string s as per Mr. Smith\'s special cipher technique. Parameters: s (str): A string consisting of lowercase letters only. Returns: str: The encoded string. if not s: return s # Return the empty string if the input is empty. encoded = [] current_char = s[0] count = 1 for i in range(1, len(s)): if s[i] == current_char: count += 1 else: if count > 1: encoded.append(f\\"{current_char}{count}\\") else: encoded.append(current_char) current_char = s[i] count = 1 # Add the last character (or group) if count > 1: encoded.append(f\\"{current_char}{count}\\") else: encoded.append(current_char) return \'\'.join(encoded)"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring of `s` is called a **palindrome** if it reads the same forward and backward. Your task is to find the shortest palindrome `p` such that `s` can be formed by appending zero or more characters to the end of `p`. Return the shortest palindrome `p`. For example, given the input string `\\"race\\"`, the string `\\"racecar\\"` can be formed by appending `\\"car\\"` to the end of `\\"race\\"`, making `\\"racecar\\"` a palindrome.","solution":"def shortest_palindrome(s): Returns the shortest palindrome p such that s can be formed by appending zero or more characters to the end of p. if s == s[::-1]: return s rev_s = s[::-1] for i in range(len(s)): if s.startswith(rev_s[i:]): return rev_s[:i] + s return \\"\\""},{"question":"Given an array of integers `nums` and an integer `threshold`, find the minimum possible `value` such that if you replaced every element in the array with the ceiling of the division of the element by `value`, the sum of the new array would be less than or equal to `threshold`. Return the minimum possible `value`.","solution":"import math def smallest_divisor(nums, threshold): def compute_sum(value): return sum(math.ceil(num / value) for num in nums) left, right = 1, max(nums) while left < right: mid = (left + right) // 2 if compute_sum(mid) > threshold: left = mid + 1 else: right = mid return left"},{"question":"Given a string `s` which represents a mathematical expression containing only non-negative integers and the operators `+`, `-`, and `*` (addition, subtraction, and multiplication), evaluate the expression and return an integer result. For example, for the input `\\"3+2*2\\"`, the output should be `7`, and for the input `\\" 3/2 \\"`, the output should be `1`. Note that integer division should truncate toward zero.","solution":"def evaluate_expression(s): Evaluates a mathematical expression provided as a string containing non-negative integers and the operators +, -, *, /. Returns the integer result of the expression evaluation. if not s: return 0 s = s.replace(\' \', \'\') num, stack, sign = 0, [], \\"+\\" for i in range(len(s)): if s[i].isdigit(): num = num * 10 + int(s[i]) if s[i] in \\"+-*/\\" or i == len(s) - 1: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = s[i] num = 0 return sum(stack)"},{"question":"You are given an integer array `workload` where `workload[i]` represents the amount of work a server `i` can handle, and an integer `servers_count` representing the number of servers available. Distribute the workload among the servers in such a way that the workload is balanced according to the following rules: * Each server gets at least one element from the workload array. * The workload assigned to each server must be contiguous (elements assigned to a server must come from a continuous segment of the array). * Minimize the difference between the maximum and minimum workload assigned to any server. Return the minimized maximum workload assigned to any server.","solution":"def minimize_max_workload(workload, servers_count): def canDistribute(max_workload): server_count = 1 current_workload = 0 for w in workload: if current_workload + w > max_workload: server_count += 1 current_workload = 0 current_workload += w if server_count > servers_count: return False return True low, high = max(workload), sum(workload) while low < high: mid = (low + high) // 2 if canDistribute(mid): high = mid else: low = mid + 1 return low"},{"question":"Implement a class `CustomStack` that simulates a stack with additional operations beyond the usual `push` and `pop` methods. The stack can do the following: * `push(int x)` - Place element `x` on top of the stack if the size of the stack is less than the overall limit of the stack. * `pop()` - Remove and return the element on the top of the stack. Return -1 if the stack is empty. * `increment(int k, int val)` - Increment the bottom `k` elements of the stack by `val`. If there are fewer than `k` elements, increment all the elements of the stack. Implement the `CustomStack` class: * `CustomStack(int maxSize)` Initializes the object with `maxSize` which is the maximum number of elements in the stack. * `void push(int x)` Adds `x` to the stack if it is not full. * `int pop()` Removes and returns the element on the top of the stack. Returns -1 if the stack is empty. * `void increment(int k, int val)` Increases the bottom `k` elements of the stack by `val`. If there are fewer than `k` elements in the stack, increase all the elements.","solution":"class CustomStack: def __init__(self, maxSize: int): Initializes the CustomStack object with a maximum size. self.maxSize = maxSize self.stack = [] def push(self, x: int) -> None: Place element x on top of the stack if the size of the stack is less than the overall limit of the stack. if len(self.stack) < self.maxSize: self.stack.append(x) def pop(self) -> int: Remove and return the element on the top of the stack. Return -1 if the stack is empty. if self.stack: return self.stack.pop() else: return -1 def increment(self, k: int, val: int) -> None: Increment the bottom k elements of the stack by val. If there are fewer than k elements, increment all the elements of the stack. num_elements_to_increment = min(k, len(self.stack)) for i in range(num_elements_to_increment): self.stack[i] += val"},{"question":"You are given a list of events `events` where each event is represented as an array of two integers `[startTime, endTime]`. The event `[startTime, endTime]` represents an event that starts at `startTime` and ends at `endTime`, inclusive. Two events are considered overlapping if they share at least one time unit. For example, events `[1, 5]` and `[5, 8]` are overlapping. Your task is to return the maximum number of overlapping events at any time. If two events start at the same time, they are considered overlapping. Implement the function `maxOverlappingEvents(events)` that returns an integer representing the maximum number of overlapping events. **Example:** ```python events = [[1, 4], [2, 5], [7, 9], [5, 8]] maxOverlappingEvents(events) # Output: 2 ``` **Note:** * `1 <= events.length <= 10^4` * `1 <= startTime <= endTime <= 10^5`","solution":"def maxOverlappingEvents(events): Returns the maximum number of overlapping events at any time. times = [] for start, end in events: times.append((start, \'start\')) times.append((end + 1, \'end\')) times.sort() current_overlaps = 0 max_overlaps = 0 for time, event_type in times: if event_type == \'start\': current_overlaps += 1 max_overlaps = max(max_overlaps, current_overlaps) elif event_type == \'end\': current_overlaps -= 1 return max_overlaps"},{"question":"You are given an array `arr` of positive integers where `arr[i]` represents the amount of money of the `i`-th house. There are `n` houses in a row and you want to maximize the amount of money you can rob. However, you cannot rob two adjacent houses because it will alert the police. Write a function to return the maximum amount of money you can rob without alerting the police.","solution":"def rob(arr): Returns the maximum amount of money you can rob without alerting the police. :param arr: List[int] - an array of positive integers representing money in each house :return: int - the maximum amount of money that can be robbed if not arr: return 0 n = len(arr) if n == 1: return arr[0] dp = [0] * len(arr) dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + arr[i]) return dp[-1]"},{"question":"You are given a **0-indexed** integer array `arr` representing colors, where each non-negative integer in `arr` denotes a different color. We define a block as a contiguous subarray of equal numbers. A block is considered valid if the difference between the maximum and minimum element in the block is at most `d` and its length is at least `t`. Your task is to find and return the starting index and length of the longest valid block. If there are multiple such blocks with the same length, return the one with the smallest starting index. Output the index and length as a tuple `(index, length)`.","solution":"def longest_valid_block(arr, d, t): n = len(arr) longest_block = (0, 0) # (starting index, length) i = 0 while i < n: j = i while j < n and arr[j] == arr[i]: j += 1 block_length = j - i if block_length >= t and (arr[i] <= arr[i] + d): if block_length > longest_block[1]: longest_block = (i, block_length) i = j return longest_block"},{"question":"You are given a grid of size `m x n` filled with non-negative numbers representing the height of each cell. You need to find the maximum height the water can reach in each cell without flowing over to neighboring cells that have a lower height. Implement the `TrapRainWater` class: * `TrapRainWater(int[][] heightMap)` Initializes the object with the height map. * `int trap(int row, int col)` returns the maximum height of water that can be trapped at cell located at `(row, col)` without causing water overflow to lower neighboring cells. If the location is out of the grid, return `-1`.","solution":"import heapq class TrapRainWater: def __init__(self, heightMap): self.heightMap = heightMap if not heightMap or not heightMap[0]: self.m = 0 self.n = 0 else: self.m = len(heightMap) self.n = len(heightMap[0]) self.trappedWaterMap = self.calculateTrappedWater() def calculateTrappedWater(self): if not self.heightMap or self.m < 3 or self.n < 3: return [[0] * self.n for _ in range(self.m)] trappedWater = [[0] * self.n for _ in range(self.m)] visited = [[False] * self.n for _ in range(self.m)] heap = [] # Push all the boundary cells into the heap and mark them as visited. for i in range(self.m): heapq.heappush(heap, (self.heightMap[i][0], i, 0)) heapq.heappush(heap, (self.heightMap[i][self.n-1], i, self.n-1)) visited[i][0] = visited[i][self.n-1] = True for j in range(1, self.n-1): heapq.heappush(heap, (self.heightMap[0][j], 0, j)) heapq.heappush(heap, (self.heightMap[self.m-1][j], self.m-1, j)) visited[0][j] = visited[self.m-1][j] = True # Directions for moving in 4-connectivity: up, down, left, right. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < self.m and 0 <= ny < self.n and not visited[nx][ny]: trappedWater[nx][ny] = max(0, height - self.heightMap[nx][ny]) newHeight = max(height, self.heightMap[nx][ny]) heapq.heappush(heap, (newHeight, nx, ny)) visited[nx][ny] = True return trappedWater def trap(self, row, col): if row < 0 or row >= self.m or col < 0 or col >= self.n: return -1 return self.trappedWaterMap[row][col]"},{"question":"Given a 2D matrix `grid` of integers where each cell represents the elevation at that point, find the minimum number of steps required to reach from the top-left corner of the matrix to the bottom-right corner. You can move up, down, left, or right from a cell, and you can only move to a cell with an equal or lower elevation than your current cell. If it\'s not possible to reach the bottom-right corner, return -1.","solution":"from collections import deque def min_steps_to_reach_end(grid): Returns the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner. If it is not possible, return -1. if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == rows - 1 and col == cols - 1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols: if (new_row, new_col) not in visited and grid[new_row][new_col] <= grid[row][col]: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"You are given a string `s` consisting of only lowercase English letters and an integer `k`. Your goal is to find the **longest subsequence** where the difference between the number of characters that occur the most often and the number of characters that occur the least often is at most `k`. Return _the **length** of this longest subsequence_. A **subsequence** is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.","solution":"from collections import Counter def longest_subsequence(s, k): Returns the length of the longest subsequence where the difference between the number of characters that occur the most often and the number of characters that occur the least often is at most k. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The maximum allowable difference between the most frequent and the least frequent characters. Returns: int: The length of the longest subsequence. if not s: return 0 max_len = 0 for freq in range(1, len(s) + 1): counter = Counter(s) subseq_len = sum(min(freq, count) for count in counter.values()) if max(counter.values()) - min(counter.values()) <= k: max_len = max(max_len, subseq_len) return max_len"},{"question":"You are given a list of `words` and a list of `queries`. The `words` list contains unique lowercase English words, and the `queries` list contains lowercase English words. For each query, find the number of words from the `words` list that match the query by modifying exactly one character. Return a list of integers where each integer represents the result for the corresponding query. Example: ``` Input: words = [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"] queries = [\\"bbc\\", \\"deg\\", \\"ghi\\", \\"jkm\\"] Output: [1, 1, 0, 1] ``` Explanation: - For the query \\"bbc\\", there is one word in the `words` list (\\"abc\\") that can be obtained by changing exactly one character. - For the query \\"deg\\", there is one word in the `words` list (\\"def\\") that can be obtained by changing exactly one character. - For the query \\"ghi\\", no word in the `words` list matches after changing exactly one character. - For the query \\"jkm\\", there is one word in the `words` list (\\"jkl\\") that can be obtained by changing exactly one character.","solution":"def match_queries(words, queries): def is_one_char_diff(word1, word2): Helper function to determine if two words differ by exactly one character. if len(word1) != len(word2): return False count_diff = 0 for a, b in zip(word1, word2): if a != b: count_diff += 1 if count_diff > 1: return False return count_diff == 1 result = [] for query in queries: count = 0 for word in words: if is_one_char_diff(word, query): count += 1 result.append(count) return result"},{"question":"You are given a **0-indexed** 2D integer array `tasks`, where `tasks[i] = [starti, endi]` represents a task that starts at `starti` and ends at `endi` (exclusive). Each task requires exactly `1` unit of time to complete. You have a processor that can only handle one task at a time. Return the **minimum** number of time units the processor needs to finish all the given tasks. Note that tasks can be completed in any order, and the unit time required for switching from one task to another is negligible.","solution":"def min_time_units(tasks): Calculates the minimum number of time units required to finish all tasks. Args: tasks (list of list of int): A 2D list where each sub-list represents a task with its start and end times [start, end]. Returns: int: The minimum number of time units required to finish all tasks. return len(tasks)"},{"question":"Given an array of integers `nums`, you are allowed to reorder the array in any way and remove exactly one element such that the difference between the maximum and minimum elements of the new array is minimized. Find and return the minimized difference.","solution":"def min_difference(nums): Returns the minimized difference between the max and min elements after removing one element from the array. if len(nums) <= 3: return 0 # If we have 3 or fewer elements, we can remove one to make all elements the same. nums.sort() n = len(nums) # Consider removing one of the following: # Remove the largest element, remove the smallest element, # Remove the second largest element, remove the second smallest element, # Remove the third largest element, remove the third smallest element, # Remove the fourth largest element, remove the fourth smallest element # Removing either of the elements from the above ensures the minimized difference. return min(nums[n-2] - nums[1], nums[n-1] - nums[2], nums[n-3] - nums[0])"},{"question":"You are given a `m x n` binary matrix `mat` where each cell contains either a `0` (representing a dead cell) or a `1` (representing a live cell). Each cell interacts with its eight neighbors (horizontal, vertical, and diagonal) using the following rules: * **Any live cell with fewer than two live neighbors dies** as if caused by under-population. * **Any live cell with two or three live neighbors lives on to the next generation.** * **Any live cell with more than three live neighbors dies** as if by over-population. * **Any dead cell with exactly three live neighbors becomes a live cell** as if by reproduction. Given the current state of the `m x n` binary matrix `mat`, return _the state of the matrix after one update according to the rules described above_.","solution":"def get_next_state(mat): Returns the next state of the m x n binary matrix \'mat\' according to the Game of Life rules. m, n = len(mat), len(mat[0]) dirs = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] def count_live_neighbors(x, y): count = 0 for dx, dy in dirs: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and mat[nx][ny] == 1: count += 1 return count next_state = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): live_neighbors = count_live_neighbors(i, j) if mat[i][j] == 1: if live_neighbors < 2 or live_neighbors > 3: next_state[i][j] = 0 else: next_state[i][j] = 1 elif mat[i][j] == 0 and live_neighbors == 3: next_state[i][j] = 1 return next_state"},{"question":"Given a string `expression` that contains a well-formed arithmetic expression containing the characters `+`, `-`, `*`, `/`, `(`, `)` and digits, evaluate the expression and return the result as an integer. The integer division should truncate toward zero. Note that the expression does not contain any spaces. **Example 1:** **Input:** expression = \\"3+2*2\\" **Output:** 7 **Explanation:** The expression evaluates to 3 + (2 * 2) = 3 + 4 = 7. **Example 2:** **Input:** expression = \\" 3/2 \\" **Output:** 1 **Explanation:** The expression evaluates to 3 / 2 = 1.5 which truncates to 1. **Example 3:** **Input:** expression = \\" (1+(4+5+2)-3)+(6+8) \\" **Output:** 23 **Explanation:** The expression evaluates to 1 + (4 + 5 + 2) - 3 + (6 + 8) = 1 + 11 - 3 + 14 = 23. **Constraints:** - `1 <= expression.length <= 10^4` - `expression` consists of digits, `\'+-*/()\'`. - `expression` is a valid arithmetic expression.","solution":"def evaluate_expression(expression): Evaluates a well-formed arithmetic expression containing +, -, *, /, (, ) and digits. The integer division should truncate toward zero. :param expression: str, arithmetic expression to be evaluated :return: int, result of the evaluation def calc(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': return int(first / second) # integer division truncating toward zero def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def apply_operations(operators, values): while operators and operators[-1] != \'(\': values.append(calc(operators.pop(), values.pop(), values.pop())) operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit(): j = i while j < len(expression) and expression[j].isdigit(): j += 1 values.append(int(expression[i:j])) i = j - 1 elif expression[i] == \'(\': operators.append(expression[i]) elif expression[i] == \')\': apply_operations(operators, values) operators.pop() # popping the \'(\' elif expression[i] in (\'+\', \'-\', \'*\', \'/\'): while operators and precedence(operators[-1]) >= precedence(expression[i]): values.append(calc(operators.pop(), values.pop(), values.pop())) operators.append(expression[i]) i += 1 apply_operations(operators, values) return values[-1]"},{"question":"Write a function that takes an array of strings `arr` and a string `target` and returns _the number of strings in the array that are anagrams of the target_. An anagram of a string is another string that contains the same characters, only the order of characters can be different. The function should ignore case and any non-alphabetic characters in the strings.","solution":"from collections import Counter import re def count_anagrams(arr, target): Returns the number of strings in the array that are anagrams of the target. Ignores case and non-alphabetic characters. def clean_string(s): return \'\'.join(re.findall(r\'[a-zA-Z]\', s)).lower() cleaned_target = clean_string(target) target_counter = Counter(cleaned_target) count = 0 for string in arr: cleaned_string = clean_string(string) if Counter(cleaned_string) == target_counter: count += 1 return count"},{"question":"A company has a hierarchical structure where each employee has a unique ID and is supervised by exactly one other employee, except for the CEO who is the topmost supervisor and does not have any supervisor. You are given an array of `n` integers `supervisor` where `supervisor[i]` represents the supervisor of the employee with ID `i` (0-indexed), and the value `-1` denotes that the corresponding employee is the CEO. You are also given an array `importance` of `n` integers where `importance[i]` denotes the importance score of the employee with ID `i`. The importance score of an employee includes the importance of the employee and all the employees directly or indirectly supervised by them. Write a function to return the total importance score of the employee with a given ID `id`. **Example:** **Input:** - supervisor = [-1, 0, 0, 1, 1, 2, 2] - importance = [5, 3, 6, 1, 4, 2, 8] - id = 0 **Output:** 29","solution":"def total_importance(supervisor, importance, id): Calculate the total importance score of the employee with the given id. from collections import defaultdict # Build the supervised list for each supervisor supervised = defaultdict(list) for emp, sup in enumerate(supervisor): if sup != -1: supervised[sup].append(emp) # Define a helper function to calculate the total importance def dfs(emp_id): total = importance[emp_id] for sub in supervised[emp_id]: total += dfs(sub) return total # Calculate the importance starting from the given id return dfs(id)"},{"question":"You are given a string representing an arithmetic expression containing positive integers, parentheses, and the binary operators \'+\' and \'-\'. The expression is guaranteed to be valid and follows the conventional rules of arithmetic, including operator precedence and parentheses usage. Implement a function `evaluateExpression` that takes in such a string and returns the result of evaluating the expression. For example, given the string \\"1 + (2 - 3) + 4\\", the function should return 4.","solution":"def evaluateExpression(expression): Evaluates a given arithmetic expression string containing positive integers, parentheses, and the binary operators \'+\' and \'-\'. def evaluate(tokens): stack = [] num = 0 sign = 1 # 1 represents positive, -1 represents negative result = 0 while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) result += sign * num elif token == \'+\': sign = 1 elif token == \'-\': sign = -1 elif token == \'(\': # Evaluate the expression inside the parenthesis result += sign * evaluate(tokens) elif token == \')\': # End of the current parenthesis evaluation break return result tokens = [] idx = 0 while idx < len(expression): char = expression[idx] if char.isdigit(): num = char while idx + 1 < len(expression) and expression[idx + 1].isdigit(): num += expression[idx + 1] idx += 1 tokens.append(num) elif char in \\"+-()\\": tokens.append(char) idx += 1 return evaluate(tokens)"},{"question":"Given a binary tree, implement a function to check whether the tree is a complete binary tree. A complete binary tree is defined as a binary tree in which all levels are completely filled, except possibly for the last level, which must be filled from left to right. You need to return `true` if the binary tree is complete, otherwise return `false`. The binary tree is represented in the input as a list of node values in level order traversal, where `null` represents a missing node. For example, the input `[1, 2, 3, 4, 5, 6]` represents the following complete binary tree: ``` 1 / 2 3 / / 4 5 6 ``` Whereas the input `[1, 2, 3, 4, 5, null, 7]` represents a binary tree that is not complete: ``` 1 / 2 3 / 4 5 7 ```","solution":"def is_complete_binary_tree(arr): Return true if the input level order traversal list represents a complete binary tree, else false. n = len(arr) if n == 0: return True # A complete binary tree can have null values at the end, but not between nodes # Traverse the list, stopping if we get a null and ensuring no node appears after a null end_of_tree_found = False for i in range(n): if arr[i] is None: end_of_tree_found = True elif end_of_tree_found: return False return True"},{"question":"Given an array of integers `nums`, where each element represents the maximum number of steps you can jump forward from that position, determine if you can reach the last index. Assume that you are always initially positioned at the first index.","solution":"def can_jump(nums): Determine if you can reach the last index in the array. :param nums: List[int] - List of integers where each element represents the max number of steps you can jump forward :return: bool - True if you can reach the last index, otherwise False. max_reachable = 0 for i, jump in enumerate(nums): if i > max_reachable: return False max_reachable = max(max_reachable, i + jump) return True"},{"question":"Design a system that manages a leaderboard, which tracks the scores of players in a game. Implement the `Leaderboard` class: * `void addScore(int playerId, int score)` - Updates the leaderboard by adding `score` to the score of `playerId`. If `playerId` does not exist on the leaderboard, add them. * `int top(int K)` - Returns the sum of the top `K` highest scores. * `void reset(int playerId)` - Resets the score of `playerId` to `0`. The system should support adding new players, updating scores, retrieving the sum of the top `K` scores efficiently, and resetting player scores.","solution":"class Leaderboard: def __init__(self): self.scores = {} def addScore(self, playerId, score): if playerId in self.scores: self.scores[playerId] += score else: self.scores[playerId] = score def top(self, K): top_scores = sorted(self.scores.values(), reverse=True)[:K] return sum(top_scores) def reset(self, playerId): if playerId in self.scores: self.scores[playerId] = 0"},{"question":"You are given two positive integers `num1` and `num2`. You can perform the following operation any number of times: choose a non-negative integer `k` such that `2^k` is less than or equal to `num1`, and subtract `2^k` from `num1`. Additionally, each time you perform this operation, `num2` is decremented by 1. Your goal is to determine the minimum number of operations needed to reduce `num1` to zero. If it is not possible to achieve this, return `-1`. Implement a function `minOperations(num1, num2)` that returns the minimum number of operations needed to reduce `num1` to zero under the given constraints, or `-1` if it is impossible.","solution":"def minOperations(num1, num2): operations = 0 while num1 > 0: if num2 == 0: return -1 k = 0 while (1 << (k+1)) <= num1: k += 1 num1 -= (1 << k) num2 -= 1 operations += 1 return operations"},{"question":"A scientist is conducting an experiment and has discovered a new element represented by a string `element`. Each character in `element` represents a type of atom, and the scientist has identified a specific effect whenever certain pairs of atoms are adjacent. The `effectPairs` array contains pairs of characters that trigger a special reaction when they are next to each other. Your task is to find and return the total number of unique special reactions that occur within the `element` string. For example, given `element = \\"abcabc\\"` and `effectPairs = [[\\"a\\", \\"b\\"], [\\"b\\", \\"c\\"]]`, the special reactions are \\"ab\\" and \\"bc\\", which occur multiple times, but should be counted uniquely. Return _the number of unique special reactions_ that happen in the `element`.","solution":"def count_unique_reactions(element, effectPairs): Returns the number of unique special reactions in the element. :param element: String, the elemental string. :param effectPairs: List of pairs of characters representing special reactions. :return: Integer, number of unique special reactions. unique_reactions = set() effects_set = {(pair[0], pair[1]) for pair in effectPairs} for i in range(len(element) - 1): if (element[i], element[i + 1]) in effects_set: unique_reactions.add(element[i] + element[i + 1]) return len(unique_reactions)"},{"question":"You are given a list of non-negative integers representing the heights of billboard sections. Each section can either be left as is or lowered completely to the ground (height 0). Your goal is to minimize the difference in height between the tallest and shortest remaining sections. Write a function that returns the minimum possible difference in heights after choosing which sections to lower. If the list is empty, return 0.","solution":"def min_difference(heights): Returns the minimum possible difference in heights after choosing which sections to lower. Parameters: heights (list): List of non-negative integers representing heights of billboard sections. Returns: int: The minimum difference between the remaining tallest and shortest section heights. if not heights: return 0 # If there\'s less than two billboards, lowering has no effect if len(heights) <= 1: return 0 max_height = max(heights) min_height = min(heights) # Lowering all sections results in height difference of 0 return max_height - min_height"},{"question":"You are given an `n x n` 2D matrix `matrix` where each row and each column is sorted in ascending order. Implement a function `searchMatrix(matrix: List[List[int]], target: int) -> bool` that takes the matrix and a target value as input and returns `true` if the target value is present in the matrix and `false` otherwise. The solution should aim to achieve better than O(n^2) runtime complexity. **Example:** ``` Input: matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], target = 5 Output: true Input: matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], target = 20 Output: false ```","solution":"def searchMatrix(matrix, target): Returns True if target is found in the matrix, otherwise returns False. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"Given an array of integers `arr`, an element `a` is a **peak element** if it is greater than both of its neighbors. If the element is a boundary element, it only needs to be greater than its single neighbor. Write a function to find a peak element in the array and return its index. If the array contains multiple peak elements, return the index of any one of them. You may assume that the array does not contain duplicate elements.","solution":"def find_peak_element(arr): Find a peak element in the array and return its index. A peak element is greater than its neighbors. If it is a boundary element, it only needs to be greater than its single neighbor. n = len(arr) if n == 1: return 0 if arr[0] > arr[1]: return 0 if arr[n-1] > arr[n-2]: return n-1 for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: return i return -1 # This case should theoretically never be reached"},{"question":"You are given an array of integers `nums` representing the number of units of different types of resources, where `nums[i]` is the units of the `i-th` resource type. Additionally, you have an integer `target` representing the required sum of resource units. You can select exactly two **distinct** subarrays from the given array `nums` such that the sum of elements in the first subarray is as close as possible to the sum of elements in the second subarray and both subarrays sum up to at least `target`. Return the minimum absolute difference between the sums of the two selected subarrays. If it\'s not possible to find such subarrays, return `-1`. **Note**: - A subarray is a contiguous part of an array. - The distinct subarrays should not overlap.","solution":"def min_absolute_difference(nums, target): Returns the minimum absolute difference between the sums of two distinct subarrays whose sums are at least `target` or -1 if it\'s not possible. n = len(nums) if n < 2: return -1 def subarray_sums(nums): # Returns all possible subarray sums subs = [] n = len(nums) for i in range(n): current_sum = 0 for j in range(i, n): current_sum += nums[j] subs.append((current_sum, (i, j))) return subs # Get all possible subarray sums sub_sums = subarray_sums(nums) # Filter out subarrays that don\'t meet the target sum valid_subs = [(s, r) for s, r in sub_sums if s >= target] if not valid_subs: return -1 min_diff = float(\'inf\') # Iterate through all valid subarray pairs to find the minimum absolute difference for i in range(len(valid_subs)): for j in range(i + 1, len(valid_subs)): sum1, range1 = valid_subs[i] sum2, range2 = valid_subs[j] if range1[1] < range2[0] or range2[1] < range1[0]: # Ensure non-overlapping min_diff = min(min_diff, abs(sum1 - sum2)) return min_diff if min_diff != float(\'inf\') else -1"},{"question":"Given a `Tic-Tac-Toe` board of size `n x n`, where each cell is either represented by `\'X\'`, `\'O\'`, or `\'\'` (empty), determine if any player has won the game. A player is considered to have won if they have filled an entire row, column, or diagonal with their respective symbol (`\'X\'` or `\'O\'`). Write a function that takes a 2D array representing the `Tic-Tac-Toe` board and returns a string indicating the result: - Return `\'X\'` if player \'X\' has won. - Return `\'O\'` if player \'O\' has won. - Return `\'Draw\'` if neither player has won and there are no empty cells left. - Return `\'Pending\'` if neither player has won and there are still empty cells available.","solution":"def check_tic_tac_toe(board): Check the state of a Tic-Tac-Toe game. Args: board : List[List[str]] : 2D list representing the Tic-Tac-Toe board Returns: str : Result of the game (\'X\', \'O\', \'Draw\', or \'Pending\') n = len(board) def check_winner(char): # Check rows and columns for i in range(n): if all(board[i][j] == char for j in range(n)) or all(board[j][i] == char for j in range(n)): return True # Check diagonals if all(board[i][i] == char for i in range(n)) or all(board[i][n-1-i] == char for i in range(n)): return True return False if check_winner(\'X\'): return \'X\' if check_winner(\'O\'): return \'O\' # Check for any empty cells for row in board: if \'\' in row: return \'Pending\' return \'Draw\'"},{"question":"You are given an array of `n` integers, `arr`, where each integer represents the number of steps a frog can jump from that position in the array. The frog always starts at position `0` and wants to reach the last position of the array (i.e., position `n-1`). However, the frog can only jump to a position that lies within the current position plus the number of steps indicated by the value at the current position in the array. Return the minimum number of jumps required for the frog to reach the last position. If it is not possible to reach the last position, return `-1`.","solution":"def min_jumps(arr): Returns the minimum number of jumps required for the frog to reach the last position of the array. If it is not possible to reach the last position, return -1. :param arr: List[int] - array of integers representing the number of steps a frog can jump :return: int - minimum number of jumps to reach the last position, or -1 if not possible n = len(arr) if n == 1: return 0 if arr[0] == 0: return -1 jumps = 0 max_reach = 0 steps = 0 for i in range(n): max_reach = max(max_reach, i + arr[i]) if i == steps: if i == max_reach: return -1 steps = max_reach jumps += 1 if steps >= n - 1: return jumps return -1"},{"question":"We have a list of numbers from 1 to `n` arranged in a circle. Starting from position `1`, we eliminate every k-th person in the circle until only one person remains. You need to write a function that returns the position of the last remaining person in the circle. Given two integers `n` and `k`, where `n` is the number of persons and `k` is the step count, return the position of the last remaining person. Formally, the function signature should be: ```python def lastRemaining(n: int, k: int) -> int: ```","solution":"def lastRemaining(n: int, k: int) -> int: Returns the position of the last remaining person in the circle. :param n: Total number of persons in the circle :param k: Step count :return: Position of the last remaining person # Base case if n == 1: return 1 # Recursive case else: return (lastRemaining(n-1, k) + k-1) % n + 1"},{"question":"Mario is participating in a mushroom-collecting contest in a forest. The forest is represented as an `m x n` grid where each cell contains a certain number of mushrooms (or no mushrooms at all). Mario can enter the forest from any cell in the first column and must exit from any cell in the last column. Mario can only move in three directions: right, right-up diagonal, and right-down diagonal. That means if Mario is in cell `(i, j)`, he can move to `(i, j+1)`, `(i-1, j+1)`, or `(i+1, j+1)`, as long as the destination cell is within the grid boundaries. Write a function that determines the maximum number of mushrooms Mario can collect during his journey from the first column to the last column. The function should return an integer representing the maximum mushrooms collected. **Note:** You can assume that all cells in the grid contain non-negative integers.","solution":"def max_mushrooms(grid): Returns the maximum number of mushrooms Mario can collect from the first column to the last column. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a memoization table to store the maximum mushrooms collected to each cell dp = [[0] * n for _ in range(m)] # Initialize the first column of dp with the values of the grid for i in range(m): dp[i][0] = grid[i][0] # Fill the dp table for j in range(1, n): for i in range(m): max_from_left = dp[i][j-1] # from left if i > 0: max_from_left_up = dp[i-1][j-1] # from left-up else: max_from_left_up = 0 if i < m-1: max_from_left_down = dp[i+1][j-1] # from left-down else: max_from_left_down = 0 dp[i][j] = grid[i][j] + max(max_from_left, max_from_left_up, max_from_left_down) # The result is the maximum value in the last column return max(dp[i][n-1] for i in range(m))"},{"question":"You are given a directed graph of `n` nodes numbered from `0` to `n-1`, where each node represents a city and a 2D integer array `roads` where `roads[i] = [ai, bi, cost_i]` denotes a road from city `ai` to city `bi` with a travel cost of `cost_i`. The graph is guaranteed to have no negative weight cycles. Your task is to find the shortest path from the capital city (node `0`) to every other city and return an array of shortest path distances. If a city is unreachable from the capital city, the distance should be denoted by `-1`.","solution":"import heapq def shortest_path(n, roads): Finds the shortest path from the capital city (node 0) to every other city. :param n: Number of cities (nodes) :param roads: List of roads where each road is represented as [ai, bi, cost_i] :return: List of shortest path distances from the capital city to every other city. If a city is unreachable, the distance should be -1. graph = {i: [] for i in range(n)} for a, b, cost in roads: graph[a].append((b, cost)) distances = [float(\'inf\')] * n distances[0] = 0 priority_queue = [(0, 0)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Replace all \'inf\' distances with -1 to denote unreachable cities return [d if d != float(\'inf\') else -1 for d in distances]"},{"question":"Given an array of integers `nums`, you need to create a function to return the length of the **longest** possible arithmetic subsequence of these numbers. An arithmetic subsequence of an array is a sequence of numbers selected from the array such that the difference between consecutive elements in the subsequence is the same. Formally, it\'s a list of indices `i1, i2, ..., ik` such that `nums[i1]`, `nums[i2]`, ..., `nums[ik]` is an arithmetic sequence, and `k` is the length of the subsequence. You should implement a function `longestArithSeqLength(nums) -> int` that takes the list `nums` and returns the integer length of the longest arithmetic subsequence.","solution":"def longestArithSeqLength(nums): if len(nums) < 2: return len(nums) max_len = 1 dp = [{} for _ in range(len(nums))] for i in range(len(nums)): for j in range(i): diff = nums[i] - nums[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_len = max(max_len, dp[i][diff]) return max_len"},{"question":"You are given an undirected graph with `n` nodes labeled from `0` to `n-1`. The graph is described by a list of edges, where `edges[i] = [ai, bi]` represents an undirected edge between nodes `ai` and `bi`. Your task is to determine if this graph can be colored using only 2 colors such that no two adjacent nodes have the same color. If it is possible, return `true`; otherwise, return `false`.","solution":"def is_bipartite(n, edges): Determines if the graph can be colored using only 2 colors such that no two adjacent nodes have the same color. Parameters: n (int): Number of nodes in the graph. edges (list of list of int): The edges of the graph. Returns: bool: True if the graph can be colored using 2 colors, False otherwise. from collections import deque # Create adjacency list adj_list = [[] for _ in range(n)] for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) # Colors array, initialized to -1 (uncolored) colors = [-1] * n # Check each component of the graph for start in range(n): if colors[start] == -1: # Not colored yet. # Start BFS from this node queue = deque([start]) colors[start] = 0 # Color the node with the first color while queue: node = queue.popleft() for neighbor in adj_list[node]: if colors[neighbor] == -1: # Neighbor not colored yet colors[neighbor] = 1 - colors[node] # Assign opposite color queue.append(neighbor) elif colors[neighbor] == colors[node]: # Neighbor has the same color return False return True"},{"question":"Given a `grid` of size `m x n` consisting of **non-negative integers**, represent the height of pillars at each point `(i, j)`. You need to calculate the amount of rainwater trapped after it rains. The water is trapped by the pillars and cannot flow off the edges of the grid. In other words, you must account for the volume of water that can be held inside the grid without spilling over the edges. Return the **total amount of water** trapped.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False]*n for _ in range(m)] heap = [] for i in range(m): for j in range(n): if i == 0 or i == m-1 or j == 0 or j == n-1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped += max(0, height - heightMap[nx][ny]) visited[nx][ny] = True heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"You are given a matrix representing a maze with the values `0` and `1`, where `0` represents a walkable cell and `1` represents a wall. You need to find the shortest path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`, where `m` is the number of rows and `n` is the number of columns. You can only move up, down, left, or right. If there is no path, return `-1`. Implement the function `int findShortestPath(int[][] maze)` which takes in a 2D array representing the maze and returns the length of the shortest path from the top-left corner to the bottom-right corner.","solution":"from collections import deque def findShortestPath(maze): if not maze or not maze[0]: return -1 rows, cols = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Check if the starting or ending point is a wall if maze[0][0] == 1 or maze[rows-1][cols-1] == 1: return -1 queue = deque([(0, 0)]) distance = {(0, 0): 1} # Starting point with distance 1 while queue: x, y = queue.popleft() if (x, y) == (rows-1, cols-1): return distance[(x, y)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 0 and (nx, ny) not in distance: queue.append((nx, ny)) distance[(nx, ny)] = distance[(x, y)] + 1 return -1"},{"question":"You are given a 2D grid `grid` of size `m x n` consisting of only `0`s and `1`s. An island is a group of contiguous `1`s connected horizontally or vertically. The size of an island is the number of `1`s it contains. Return _the size of the smallest island_ in `grid`_. If there are no islands, return_ `0`.","solution":"def in_bounds(grid, x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def dfs(grid, x, y): if not in_bounds(grid, x, y) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark as visited size = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += dfs(grid, x + dx, y + dy) return size def smallest_island(grid): m, n = len(grid), len(grid[0]) min_size = float(\'inf\') for i in range(m): for j in range(n): if grid[i][j] == 1: island_size = dfs(grid, i, j) if island_size < min_size: min_size = island_size return min_size if min_size != float(\'inf\') else 0"},{"question":"You are given an array of integers `arr`, where each element represents the height of a student in a row. The heights are not necessarily unique. Your task is to find out how many students are not standing in their correct positions if we want to arrange them in non-decreasing order. A student\'s correct position is defined by the sorted array. * Return the number of students not in their correct positions after sorting the array in non-decreasing order. For example, given `arr = [1, 1, 4, 2, 1, 3]`, the sorted array is `[1, 1, 1, 2, 3, 4]`, and there are 3 students not in their correct positions.","solution":"def count_students_not_in_correct_positions(arr): Returns the number of students not standing in their correct positions after sorting the array in non-decreasing order. Parameters: arr (list): List of integers representing student heights. Returns: int: Number of students not in correct positions. sorted_arr = sorted(arr) count = 0 for original, sorted_value in zip(arr, sorted_arr): if original != sorted_value: count += 1 return count"},{"question":"You are given a **0-indexed** integer array `elements` representing a forest where each element\'s value indicates the height of a tree at that position. The forest also contains clearings indicated by zero values. Define a **path** as a sequence of trees that are directly connected and not separated by any clearings. You need to find the maximum **cumulative** height of any path in the forest. A path can start and end at any tree, as long as it only traverses through non-zero adjacent elements. Return _the maximum cumulative height_ of any valid path in the forest. If there are no trees in the forest, return 0.","solution":"def max_cumulative_height(elements): Returns the maximum cumulative height of any path in the forest. max_height = 0 current_sum = 0 for height in elements: if height == 0: max_height = max(max_height, current_sum) current_sum = 0 else: current_sum += height max_height = max(max_height, current_sum) # To handle the case where the last element is non-zero return max_height"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer `k`. You need to remove the first `k` characters from the string and return the new string. If `k` is greater than the length of the string, return an empty string. Ensure your solution has an optimal time complexity.","solution":"def remove_first_k_characters(s, k): Removes the first k characters from the string s. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The number of characters to remove. Returns: str: The string after removing the first k characters, or an empty string if k is greater than the length of the string. if k >= len(s): return \\"\\" return s[k:]"},{"question":"You are given a string `s` and an integer `k`. You can choose any one of the first `k` characters of `s` and move it to the end of the string. Return the lexicographically smallest string you can obtain after performing at most one such operation. Example: Input: `s = \\"baaca\\", k = 3` Output: `\\"aaabc\\"` Explanation: In the first choice, by moving \'a\' within the first 3 characters to the end, you get \\"baac\\". By moving \'b\', you get \\"aacba\\". Lastly, by moving \'a\', you get \\"abaab\\". The lexicographically smallest string is \\"aaabc\\".","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string after at most one operation where you can move one of the first k characters to the end. if k == 1: smallest_string = s for i in range(len(s)): rotated_string = s[i:] + s[:i] if rotated_string < smallest_string: smallest_string = rotated_string return smallest_string return \'\'.join(sorted(s))"},{"question":"Given a grid of size `m x n` consisting of `X` and `O` characters, you need to capture all regions surrounded by `X`. A region is captured by flipping all `O`s into `X`s in that surrounded region. A region is surrounded if it is completely surrounded by `X` on all four borders. Connected regions or clusters of `O`s that touch the boundary should not be flipped. Implement the following function: ```python def captureRegions(board: List[List[str]]) -> None: Modify the input board. In a captured region on the board, all `O`s must be flipped to `X`s. ``` **Input:** - `board`: A list of lists containing the grid of characters `X` and `O`. **Example:** ```python board = [ [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"O\\", \\"O\\", \\"X\\"], [\\"X\\", \\"X\\", \\"O\\", \\"X\\"], [\\"X\\", \\"O\\", \\"X\\", \\"X\\"] ] captureRegions(board) # After calling the function, board should be: # [ # [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], # [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], # [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], # [\\"X\\", \\"O\\", \\"X\\", \\"X\\"] # ] ```","solution":"from typing import List def captureRegions(board: List[List[str]]) -> None: if not board: return rows, cols = len(board), len(board[0]) def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or board[r][c] != \'O\': return board[r][c] = \'E\' # Mark this \'O\' as escaped because it is connected to the border # Perform DFS in all four directions dfs(r+1, c) dfs(r-1, c) dfs(r, c+1) dfs(r, c-1) # Start DFS from \'O\'s on the borders for i in range(rows): dfs(i, 0) dfs(i, cols-1) for j in range(cols): dfs(0, j) dfs(rows-1, j) # Flip all \'O\' to \'X\' (captured) and all \'E\' back to \'O\' (escaped) for i in range(rows): for j in range(cols): if board[i][j] == \'O\': board[i][j] = \'X\' elif board[i][j] == \'E\': board[i][j] = \'O\'"},{"question":"Given an array of integers `arr`, write a function to return the maximum sum of any contiguous subarray of `arr`. Implement the function using Kadane\'s algorithm, which runs in `O(n)` time complexity.","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray of arr using Kadane\'s algorithm. if not arr: return 0 # Assuming that an empty array has a maximum sum of 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"Given an integer array `nums`, determine if there exists a contiguous subarray whose sum is equal to a given integer `k`. If such a subarray exists, return `true`; otherwise, return `false`. Your solution should aim for an optimal time complexity.","solution":"def has_subarray_with_sum(nums, k): Determines if there exists a contiguous subarray whose sum is equal to k. :param nums: List of integers :param k: Integer, target sum :return: Boolean, True if such subarray exists, otherwise False current_sum = 0 sum_dict = {0: 1} for num in nums: current_sum += num if current_sum - k in sum_dict: return True sum_dict[current_sum] = sum_dict.get(current_sum, 0) + 1 return False"},{"question":"Given an integer array `arr`, return _the average of all the even numbers in the array_ rounded down to the nearest integer. If there are no even numbers in the array, return `0`. For example, if the input array is `[1, 2, 3, 4, 5, 6]`, the even numbers are `[2, 4, 6]` and their average is `4`.","solution":"def average_of_evens(arr): Returns the average of all the even numbers in the array rounded down to the nearest integer. If there are no even numbers in the array, return 0. evens = [num for num in arr if num % 2 == 0] if not evens: return 0 avg = sum(evens) // len(evens) return avg"},{"question":"You are given two integer arrays `arr1` and `arr2` of the same length. You can perform the following operations on `arr1` and `arr2`: 1. Swap any two elements in `arr1`. 2. Swap any two elements in `arr2`. Return _the minimum number of operations needed to make both arrays equal._ If it\'s not possible, return `-1`.","solution":"def min_swaps_to_make_equal(arr1, arr2): Returns the minimum number of operations needed to make arr1 equal to arr2. If it\'s not possible, returns -1. if sorted(arr1) != sorted(arr2): return -1 count = 0 i = 0 while i < len(arr1): if arr1[i] != arr2[i]: idx_to_swap = arr1.index(arr2[i], i) arr1[i], arr1[idx_to_swap] = arr1[idx_to_swap], arr1[i] count += 1 else: i += 1 return count"},{"question":"You are given a string `S` containing only lowercase alphabets. A substring is called a **beautiful substring** if it contains all 26 letters of the English alphabet at least once. Your task is to find the length of the shortest beautiful substring of `S`. If there is no such substring, return `-1`.","solution":"def shortest_beautiful_substring_length(S): from collections import Counter def contains_all_letters(counter): return len(counter) == 26 n = len(S) shortest_length = float(\'inf\') required_letters = set(\'abcdefghijklmnopqrstuvwxyz\') for start in range(n): counter = Counter() for end in range(start, n): counter[S[end]] += 1 if contains_all_letters(counter): shortest_length = min(shortest_length, end - start + 1) break return shortest_length if shortest_length != float(\'inf\') else -1"},{"question":"You are designing a text editor that supports a limited set of operations on a document, represented as a string `doc`. Your editor should support the following operations: * **Insert** a string at a specified position in the document. * **Delete** a substring from a specified range in the document. * **Get Substring** from a specified range in the document. * **Find and Replace** all occurrences of a substring with another substring. Implement the `TextEditor` class: * `TextEditor()` - Initializes a new instance of the text editor. * `void insert(int position, String text)` - Inserts the string `text` at the `position` in the document. If `position` is out of bounds, insert `text` at the closest valid position. * `void delete(int start, int end)` - Deletes the substring from `start` to `end` (inclusive) in the document. If `start` or `end` are out of bounds, adjust them to the closest valid position. * `String getSubstring(int start, int end)` - Returns the substring of the document from `start` to `end` (inclusive). If `start` or `end` are out of bounds, adjust them to the closest valid position. * `void findAndReplace(String find, String replace)` - Replaces all occurrences of the string `find` with the string `replace`. Ensure the methods handle edge cases such as when positions are out of the document\'s bounds, or when `find` does not exist in the document.","solution":"class TextEditor: def __init__(self): self.document = \\"\\" def insert(self, position, text): if position < 0: position = 0 if position > len(self.document): position = len(self.document) self.document = self.document[:position] + text + self.document[position:] def delete(self, start, end): if start < 0: start = 0 if end >= len(self.document): end = len(self.document) - 1 if start <= end: self.document = self.document[:start] + self.document[end+1:] def getSubstring(self, start, end): if start < 0: start = 0 if end >= len(self.document): end = len(self.document) - 1 if start > end: return \\"\\" return self.document[start:end+1] def findAndReplace(self, find, replace): self.document = self.document.replace(find, replace)"},{"question":"Given a string `s` and a list of words `dict`, write a function that returns all the sentences that can be formed by concatenating words from `dict` in such a way that the concatenated result is equal to `s`. Each word from `dict` can be used multiple times in the concatenation. Return the sentences as a list of strings sorted lexicographically. All the words in the sentences should be separated by a single space. Note: Each word in `dict` consists of lowercase letters only.","solution":"def word_break(s, dict): from collections import defaultdict def _word_break(s, dict, memo): if s in memo: return memo[s] if not s: return [\'\'] res = [] for word in dict: if s.startswith(word): sublist = _word_break(s[len(word):], dict, memo) for sub in sublist: res.append(word + (\\"\\" if sub == \\"\\" else \\" \\") + sub) memo[s] = sorted(res) return memo[s] memo = {} return _word_break(s, dict, memo)"},{"question":"You are given a binary tree where each node contains an integer value. Return the _maximum sum_ path from the root node to any leaf node. A leaf node is a node that does not have any children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_path(root): Returns the maximum sum path from root to any leaf node. if root is None: return 0 if root.left is None and root.right is None: return root.val left_sum = max_sum_path(root.left) right_sum = max_sum_path(root.right) return root.val + max(left_sum, right_sum)"},{"question":"Given an integer array `nums`, return `true` if there exists a subsequence of the array of length `3` that forms an increasing triplet subsequence. Otherwise, return `false`. - An increasing triplet subsequence is a subsequence of three indices `i`, `j`, `k` such that `i < j < k` and `nums[i] < nums[j] < nums[k]`.","solution":"def increasing_triplet(nums): Returns true if there exists a subsequence of length 3 that forms an increasing triplet subsequence. Otherwise, returns false. if not nums or len(nums) < 3: return False first = float(\'inf\') second = float(\'inf\') for n in nums: if n <= first: first = n elif n <= second: second = n else: return True return False"},{"question":"You are given a string `s` representing a valid Parentheses sequence. The string consists of only `\'(\'` and `\')\'`. Return _the **minimum** number of parentheses to be added to make the string valid_. A valid Parentheses sequence is one where each opening parenthesis `\'(\'` has a corresponding closing parenthesis `\')\'`, and the pairs of parentheses are correctly nested.","solution":"def min_add_to_make_valid(s): Returns the minimum number of parentheses to be added to make the string valid. left_balance = 0 # Tracks unbalanced \'(\' right_balance = 0 # Tracks unbalanced \')\' for char in s: if char == \'(\': left_balance += 1 elif char == \')\': if left_balance > 0: left_balance -= 1 else: right_balance += 1 return left_balance + right_balance"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, an **index pair** `(i, j)` is considered \\"special\\" if `0 <= i < j < n` and `nums[i] + nums[j]` is even. Return the number of special index pairs in the array.","solution":"def countSpecialPairs(nums): Count the number of special index pairs (i, j) such that 0 <= i < j < n and nums[i] + nums[j] is even. Args: nums: List[int] - the input array Returns: int - the number of special index pairs n = len(nums) even_count = sum(1 for x in nums if x % 2 == 0) odd_count = n - even_count # Combination of 2 even numbers or 2 odd numbers in the array to form even pairs even_pairs = (even_count * (even_count - 1)) // 2 odd_pairs = (odd_count * (odd_count - 1)) // 2 return even_pairs + odd_pairs"},{"question":"Given an array of strings `words` where each string is made up of lowercase English letters, you need to find the longest word in `words` that can be built one character at a time by other words in `words`. If there are multiple possible answers, return the one that is lexicographically smallest. If no such word exists, return an empty string. Return _the longest word that can be built from other words in the array_.","solution":"def longest_word(words): Find the longest word that can be built one character at a time by other words in words. Return the longest word that can be built from other words in the array. words.sort() word_set = {\\"\\"} longest = \\"\\" for word in words: if word[:-1] in word_set: word_set.add(word) if len(word) > len(longest): longest = word return longest"},{"question":"You are given a list of strings `words` representing an English dictionary. You need to find all possible concatenations of words from the dictionary that are of length exactly `n`. Each concatenation must use each word at most once. Return the list of all unique concatenations in lexicographical order. For example, if `words = [\\"cat\\", \\"dog\\", \\"fish\\"]` and `n = 6`, the function should return `[\\"catdog\\", \\"dogcat\\"]`. If no such combinations exist, return an empty list.","solution":"from itertools import permutations def find_concatenations(words, n): Returns all unique concatenations of words from the dictionary that are exactly length n, sorted lexicographically. Each word can be used at most once in each concatenation. Parameters: words (list of str): The dictionary of words. n (int): The target length of concatenations. Returns: list of str: All valid concatenations sorted lexicographically. result = set() for r in range(1, len(words) + 1): for perm in permutations(words, r): concat_str = \'\'.join(perm) if len(concat_str) == n: result.add(concat_str) return sorted(result)"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `threshold`. Return _the sum of all elements in_ `nums` _that have the minimum frequency greater than or equal to_ `threshold`. If no such element exists, return `0`. * For example, if `nums = [1, 2, 2, 3, 3, 3]` and `threshold = 2`, the elements with their frequencies are [1:1, 2:2, 3:3]. Here, both the elements `2` and `3` have minimum frequency greater than or equal to 2. Therefore, the result will be the sum of `2` and `3`, which is `5`.","solution":"def sum_of_elements_with_minimum_frequency(nums, threshold): from collections import Counter # Count the frequency of each element freq = Counter(nums) # Filter elements with frequency greater than or equal to the threshold filtered_elements = [num for num, count in freq.items() if count >= threshold] # Sum the filtered elements return sum(filtered_elements)"},{"question":"Given an `n x n` matrix of integers, where each row is sorted in increasing order, write an efficient algorithm to find and return the `k`th smallest number in the matrix.","solution":"import heapq def kth_smallest(matrix, k): Returns the kth smallest number in an n x n matrix where each row is sorted in increasing order. :param matrix: List[List[int]], the n x n matrix :param k: int, the kth smallest number to find :return: int, the kth smallest number in the matrix n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row. for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract the min k times. for _ in range(k - 1): num, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"You are given an integer array `nums` which is a **circular array**. A circular array means the end of the array wraps around to the beginning. Your task is to determine if there exists a **single** peak element in the array. A peak element is an element that is greater than its neighbors. In a circular array, the neighbors of an element at index `i` are the element at index `(i-1 + n) % n` and the element at index `(i+1) % n` (where `n` is the length of the array). Return `true` if there is a single peak element, otherwise return `false`.","solution":"def has_single_peak(nums): Determines if there is a single peak element in a circular array. A peak element is an element that is greater than its neighbors. In a circular array, the neighbors of an element at index `i` are: - at index `(i-1 + n) % n` - at index `(i+1) % n` Returns `True` if there is a single peak element, otherwise `False`. n = len(nums) peak_count = 0 for i in range(n): prev_idx = (i - 1 + n) % n next_idx = (i + 1) % n if nums[i] > nums[prev_idx] and nums[i] > nums[next_idx]: peak_count += 1 if peak_count > 1: return False return peak_count == 1"},{"question":"Given a string `s` consisting of lowercase English letters, determine the minimum number of step operations required to make all of its characters unique. In one step operation, you can choose any character of the string and change it to any other lowercase English letter. Return the minimum number of steps necessary to achieve the uniqueness of characters in the string.","solution":"def min_steps_to_unique_chars(s: str) -> int: Determines the minimum number of step operations required to make all characters in the string unique. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of steps required to make all characters unique. count = 0 seen = set() for char in s: if char in seen: count += 1 else: seen.add(char) return count"},{"question":"You are given a string `s` consisting of lowercase English letters and a positive integer `k`. Implement the function `minSwaps` that returns the minimum number of adjacent swaps required to make the string `s` palindromic by rearranging its characters. If it is impossible to form a palindrome, return `-1`. A string is palindromic if it reads the same backward as forward. Note that the string must remain valid after each swap, meaning you cannot perform non-adjacent swaps to rearrange the characters.","solution":"def minSwaps(s, k): Returns the minimum number of adjacent swaps required to make the string `s` palindromic by rearranging its characters. If it is impossible to form a palindrome, returns `-1`. Parameters: s (str): The input string consisting of lowercase English letters. k (int): Positive integer representing the number of adjacent swaps allowed. Returns: int: The minimum number of adjacent swaps required to make `s` palindromic or `-1` if it is impossible. def can_form_palindrome(s): Helper function to check if a palindrome can be formed from the string `s`. from collections import Counter count = Counter(s) odd_count = sum(1 for freq in count.values() if freq % 2 != 0) return odd_count <= 1 def min_adjacent_swaps_to_palindrome(s): Helper function to calculate min adjacent swaps required to make a string palindrome. s = list(s) swaps = 0 i, j = 0, len(s) - 1 while i < j: if s[i] == s[j]: i += 1 j -= 1 else: # Look for the matching pair from the end of the string k = j while s[k] != s[i] and k > i: k -= 1 if k == i: # No matching char found, means swap with middle one s[i], s[i + 1] = s[i + 1], s[i] swaps += 1 else: for l in range(k, j): s[l], s[l + 1] = s[l + 1], s[l] swaps += 1 i += 1 j -= 1 return swaps if not can_form_palindrome(s): return -1 min_swaps = min_adjacent_swaps_to_palindrome(s) return min_swaps if min_swaps <= k else -1"},{"question":"Given a binary tree, you need to find the length of the **longest path** where each node in the path has the **same value**. This path may or may not pass through the root. The length of the path between two nodes is represented by the number of edges between them. Write an algorithm that takes the root of a binary tree as input and returns the length of the longest path where all nodes in the path have the same value. Note: The binary tree is represented using a standard TreeNode structure where each node has pointers to its left and right children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root): Returns the length of the longest path where each node in the path has the same value. def dfs(node): nonlocal max_length if not node: return 0 left_length = dfs(node.left) right_length = dfs(node.right) left_univalue_path = left_length + 1 if node.left and node.left.val == node.val else 0 right_univalue_path = right_length + 1 if node.right and node.right.val == node.val else 0 # Update the result max_length = max(max_length, left_univalue_path + right_univalue_path) # Return the length of the longest path return max(left_univalue_path, right_univalue_path) max_length = 0 dfs(root) return max_length"},{"question":"Given an integer array `heights` representing the heights of buildings along a street, where each height is unique, compute the maximum difference in heights between any two buildings such that the taller building is to the right of the shorter one. Return the maximum difference.","solution":"def max_height_difference(heights): Returns the maximum difference in heights between any two buildings such that the taller building is to the right of the shorter one. max_diff = 0 min_height = heights[0] for height in heights: if height > min_height: max_diff = max(max_diff, height - min_height) min_height = min(min_height, height) return max_diff"},{"question":"Write a function that takes a binary tree and inverts it. Inverting a binary tree means that for every node in the tree, the left and right sub-children are swapped. Return the root of the inverted binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root): Inverts a binary tree. :param root: The root node of the binary tree. :return: The root node of the inverted binary tree. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Invert the left subtree invert_tree(root.left) # Invert the right subtree invert_tree(root.right) return root"},{"question":"Given a string `s` consisting of only characters \'a\' and \'b\', you can perform the following operation any number of times: choose a substring consisting of consecutive identical characters and remove it entirely from the string. Return _the minimum number of operations needed to make_ `s` _empty_.","solution":"def min_operations_to_empty(s): Returns the minimum number of operations needed to make the string s empty. The operation allowed is to remove a substring of consecutive identical characters. if not s: return 0 operations = 1 for i in range(1, len(s)): if s[i] != s[i - 1]: operations += 1 return operations"},{"question":"You are given a string `s` consisting solely of characters \'a\', \'b\', and \'c\'. Rearrange the string in such a way that no two adjacent characters are the same. If it is not possible to rearrange the string to meet this criterion, return an empty string. If there are multiple valid results, you can return any of them.","solution":"from heapq import heappush, heappop from collections import Counter def reorganize_string(s): Rearranges the string s such that no two adjacent characters are the same. Returns the rearranged string or an empty string if not possible. # Get the frequency of each character in the string char_count = Counter(s) max_heap = [] # Populate the max heap with the negative frequencies and corresponding characters for char, count in char_count.items(): heappush(max_heap, (-count, char)) result = [] prev_count, prev_char = 0, \'\' while max_heap: count, char = heappop(max_heap) # Append the previous character to the result list if there was one if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) result.append(char) prev_count, prev_char = count + 1, char # adding 1 to count since it\'s negative # Check if the result length matches the original string length if len(result) != len(s): return \\"\\" return \'\'.join(result)"},{"question":"You are given a list of `n` words and a string `s`. Your task is to determine if `s` can be constructed by concatenating words from the list such that each word can be used **at most once**. Return `true` if it is possible, otherwise return `false`.","solution":"def can_construct(s, word_list): from collections import Counter def backtrack(remaining_s, counter): if not remaining_s: return True for word in counter: if counter[word] > 0 and remaining_s.startswith(word): counter[word] -= 1 if backtrack(remaining_s[len(word):], counter): return True counter[word] += 1 return False word_counter = Counter(word_list) return backtrack(s, word_counter)"},{"question":"You are given a `root` of a binary tree. Implement a function that returns an array of integers representing the right side view of the tree. The right side view of a binary tree is a list of the values of the nodes you can see ordered from top to bottom when looking at the tree from the right side.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: Returns an array of integers representing the right side view of the binary tree. if not root: return [] result = [] queue = [root] while queue: level_length = len(queue) for i in range(level_length): node = queue.pop(0) if i == level_length - 1: result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"Given an array of integers `arr`, return the length of the longest subarray that forms a continuous sequence. A continuous sequence is defined as the elements in the subarray can be rearranged to form a sequence of consecutive integers. For example, in the array [4, 2, 1, 6, 5], the subarray [2, 1, 4, 6, 5] can be rearranged to form the sequence [1, 2, 4, 5, 6]. The expected time complexity is `O(n)`.","solution":"def longest_continuous_subarray(arr): Returns the length of the longest subarray that forms a continuous sequence of integers. if not arr: return 0 # Convert array to set for O(1) average time complexity for lookups num_set = set(arr) longest_sequence = 0 for num in arr: # Only start a new sequence if `num` is the start of the sequence if num - 1 not in num_set: current_num = num current_sequence = 1 # Count the length of the sequence while current_num + 1 in num_set: current_num += 1 current_sequence += 1 # Update the longest sequence found longest_sequence = max(longest_sequence, current_sequence) return longest_sequence"},{"question":"You are given two integers `m` and `n` representing the dimensions of a 2D grid filled with zeros. Your task is to implement a function that finds the number of unique paths from the top-left corner to the bottom-right corner of the grid. During the traversal, you can only move either down or right at any point in time. Return the total number of unique paths.","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a 2D grid of dimensions m x n. You can only move either down or right at any point in time. Parameters: m (int): number of rows n (int): number of columns Returns: int: number of unique paths # Create a 2D array \'dp\' with dimensions m x n filled with 0 dp = [[0] * n for _ in range(m)] # Fill the first row and first column with 1s, since there\'s only one way to get to any cell # directly in the first row or first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given a string `num` representing a large integer. Determine if the largest digit within the string is even or odd. If the largest digit is even, return the string \\"Even\\", otherwise return the string \\"Odd\\".","solution":"def largest_digit_even_or_odd(num): Determines if the largest digit within the string `num` is even or odd. Parameters: num (str): The string representing a large integer. Returns: str: \\"Even\\" if the largest digit is even, otherwise \\"Odd\\". max_digit = max(num) return \\"Even\\" if int(max_digit) % 2 == 0 else \\"Odd\\""},{"question":"You are given an integer array `heights` representing the heights of students standing in a line. A contiguous block of students is considered to be unstable if the heights within the block can be rearranged to form a strictly increasing sequence. Return _the maximum length of any unstable block in the array._","solution":"def max_unstable_block_length(heights): def is_strictly_increasing(arr): return all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)) max_length = 0 n = len(heights) for start in range(n): for end in range(start + 1, n + 1): block = heights[start:end] if is_strictly_increasing(sorted(block)): max_length = max(max_length, end - start) return max_length"},{"question":"You are given an array of non-negative integers representing the heights of a series of buildings. You are initially on the ground and want to reach the last building by jumping between buildings. You can jump to the building at the furthest index `i` to the index `j` if the following conditions are met: - The height of the building at index `j` is greater than or equal to the height of the building at index `i`. - The difference between indices `j` and `i` is less than or equal to a given integer `k`. Return `true` if you can reach the last building, or `false` otherwise.","solution":"def can_reach_last_building(heights, k): Returns True if you can reach the last building. Otherwise returns False. Args: heights (list of int): heights of the buildings k (int): maximum jump length Returns: bool: True if you can reach the last building, False otherwise n = len(heights) reachable = [False] * n reachable[0] = True for i in range(n): if reachable[i]: for j in range(i + 1, min(n, i + k + 1)): if heights[j] >= heights[i]: reachable[j] = True return reachable[-1]"},{"question":"You are given an integer array `nums` representing a list of numbers. A k-segment is a contiguous subsequence of `nums` that contains exactly `k` distinct numbers. Your task is to find the length of the longest k-segment. If no such segment exists, return `-1`.","solution":"def longest_k_segment(nums, k): Finds the length of the longest k-segment in the array nums. A k-segment is a contiguous subsequence of nums that contains exactly k distinct numbers. Parameters: nums (list of int): The list of integers. k (int): The number of distinct integers the segment must contain. Returns: int: The length of the longest k-segment, or -1 if no such segment exists. from collections import defaultdict n = len(nums) if k == 0 or n == 0: return -1 left = 0 max_length = -1 count = defaultdict(int) distinct = 0 for right in range(n): if count[nums[right]] == 0: distinct += 1 count[nums[right]] += 1 while distinct > k: count[nums[left]] -= 1 if count[nums[left]] == 0: distinct -= 1 left += 1 if distinct == k: max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `arr` of length `n` consisting of ones and zeros, and an integer `k`. We want to flip the values of exactly `k` 0s to 1s in the array, so that the length of the longest contiguous subarray of 1s is maximized. Return _the length of the longest contiguous subarray of 1s possible after flipping_ exactly `k` zeros.","solution":"def longest_ones_after_k_flips(arr, k): Returns the length of the longest contiguous subarray of 1s possible after flipping exactly k 0s to 1s in the given array. left = 0 max_length = 0 zero_count = 0 for right in range(len(arr)): if arr[right] == 0: zero_count += 1 while zero_count > k: if arr[left] == 0: zero_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an integer `n` (1 <= n <= 10^9), return the smallest integer `k` such that the sum of the digits of `k` is equal to `n`. If there are multiple valid answers, return the smallest one.","solution":"def smallest_integer_with_digit_sum(n): Returns the smallest integer k such that the sum of the digits of k is equal to n. if n <= 9: return n else: k = \\"\\" while n > 0: if n >= 9: k = \\"9\\" + k n -= 9 else: k = str(n) + k n = 0 return int(k)"},{"question":"Given an array of integers `arr` and an integer `target`, return _a list of unique quadruplets_ `[arr[a], arr[b], arr[c], arr[d]]` _such that_ `0 <= a, b, c, d < len(arr)` _and_ `arr[a] + arr[b] + arr[c] + arr[d] == target`_, ensuring no two quadruplets are identical_. Your solution should avoid duplicate quadruplets.","solution":"def four_sum(arr, target): Finds all unique quadruplets in the array that sum up to the target value. :param arr: List of integers :param target: The target sum :return: List of unique quadruplets arr.sort() quadruplets = [] length = len(arr) for i in range(length - 3): if i > 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue left, right = j + 1, length - 1 while left < right: current_sum = arr[i] + arr[j] + arr[left] + arr[right] if current_sum == target: quadruplets.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return quadruplets"},{"question":"You are given an array of integers and a positive integer `k`. You need to find if the array contains any duplicate elements within `k` distance from each other. In other words, check if there are two different indices `i` and `j` in the array such that `nums[i] == nums[j]` and the absolute difference between `i` and `j` is at most `k`. Return `true` if such elements exist, otherwise return `false`.","solution":"def contains_nearby_duplicate(nums, k): Determine if the array contains any duplicate elements within k distance from each other. :param nums: List[int] - The input array of integers. :param k: int - The maximum distance between duplicate elements. :return: bool - True if such elements exist, otherwise False. num_indices = {} for i, num in enumerate(nums): if num in num_indices and i - num_indices[num] <= k: return True num_indices[num] = i return False"},{"question":"You are given a matrix `grid` consisting of `m` rows and `n` columns, where each element is a positive integer representing the height of a cell. You are also given an integer `t`. Starting from any cell, you can move to a neighboring cell (left, right, up, or down) if its height is less than or equal to `t` more than the current cell\'s height. Return the maximum number of cells you can visit in the matrix by starting from any cell.","solution":"def max_cells_visited(grid, t): m = len(grid) n = len(grid[0]) def dfs(x, y, visited): stack = [(x, y)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] count = 0 while stack: cx, cy = stack.pop() if (cx, cy) in visited: continue visited.add((cx, cy)) count += 1 for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[cx][cy]) <= t: stack.append((nx, ny)) return count max_visit = 0 for i in range(m): for j in range(n): visited = set() max_visit = max(max_visit, dfs(i, j, visited)) return max_visit"},{"question":"You are given a string `expression` containing numbers and the operators `+`, `-`, `*`, and `/`. The valid operators are only `+`, `-`, `*`, `/` inside an arithmetic expression. Implement a function that evaluates the expression and returns the result as a float. The given expression does not include any parentheses and has valid space-separated elements representing numbers and operators. **Note** that division should follow the integer division rules in the case of two integers and floating-point division otherwise.","solution":"def evaluate_expression(expression): Evaluates a given arithmetic expression with no parentheses. # Splitting the expression by space character tokens = expression.split() # Stack for numbers and operators num_stack = [] op_stack = [] # Precedence of operators precedence = {\'+\':1, \'-\':1, \'*\':2, \'/\':2} def apply_operator(op): Apply the operator to the top two values in the num_stack. right = num_stack.pop() left = num_stack.pop() if op == \'+\': num_stack.append(left + right) elif op == \'-\': num_stack.append(left - right) elif op == \'*\': num_stack.append(left * right) elif op == \'/\': if isinstance(left, int) and isinstance(right, int): num_stack.append(left // right) else: num_stack.append(left / right) for token in tokens: if token.isdigit() or (\'.\' in token): num_stack.append(float(token) if \'.\' in token else int(token)) else: while (op_stack and precedence[op_stack[-1]] >= precedence[token]): apply_operator(op_stack.pop()) op_stack.append(token) while op_stack: apply_operator(op_stack.pop()) return float(num_stack[0])"},{"question":"You are given a list of integers `nums` representing positions of a route on a 1-dimensional plane. Another list of integers `cost` represents the cost, where `cost[i]` is the cost of visiting position `nums[i]`. You can start at any position and you need to visit all the positions once. While visiting positions, you need to follow the order of the indices given in the `nums` list, meaning that after visiting `nums[i]`, the next position to visit is `nums[i+1]`, until all positions are visited. Write a method to return the minimum total cost required to visit all positions in the given order. Consider the following method definition: ```python def min_cost(nums: List[int], cost: List[int]) -> int: ``` # Example: ``` nums = [1, 3, 4, 5] cost = [10, 8, 9, 7] ``` You can start at position `1` with cost `10`, visit `3` with cost `8`, visit `4` with cost `9`, and finally visit `5` with cost `7`. The minimum total cost to visit all positions is `10 + 8 + 9 + 7 = 34`. ``` nums = [5, 2, 1] cost = [7, 5, 8] ``` You can start at position `5` with cost `7`, visit `2` with cost `5`, and `1` with cost `8`. The minimum total cost to visit all positions is `7 + 5 + 8 = 20`.","solution":"def min_cost(nums, cost): Returns the minimum total cost required to visit all positions in given order. Arguments: nums -- List of integers representing positions on a 1-dimensional plane. cost -- List of integers representing costs associated with visiting each position. Returns: int -- Minimum total cost required to visit all positions in given order. # The solution is just a simple summation of the cost list as the costs must be added in the given order. return sum(cost)"},{"question":"Given an array of integers `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. The solution must be achieved in O(n) time complexity and without using division. For example: - If `nums = [1,2,3,4]`, then `answer = [24,12,8,6]` - If `nums = [-1,1,0,-3,3]`, then `answer = [0,0,9,0,0]` Note: Implement this with a single pass to build the result array while calculating the product of all elements before and after the current index efficiently.","solution":"def product_except_self(nums): Given an array nums of integers, this function returns an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. length = len(nums) answer = [1] * length # Calculate the products of all elements before each element prefix = 1 for i in range(length): answer[i] = prefix prefix *= nums[i] # Calculate the products of all elements after each element and multiply with prefix products suffix = 1 for i in range(length - 1, -1, -1): answer[i] *= suffix suffix *= nums[i] return answer"},{"question":"You are given a string `s` consisting of lowercase English letters. A distinct letter is a letter that appears only once in the string. Return _the character with the smallest index in the original string that is a distinct letter_. If there is no distinct letter, return `\'_\'`.","solution":"def first_distinct_letter(s): Returns the character with the smallest index in the original string that is a distinct letter. If there is no distinct letter, return \'_\'. from collections import Counter # Count the occurrences of each character in the string char_count = Counter(s) # Iterate through the string and return the first character with count 1 for char in s: if char_count[char] == 1: return char # If there is no distinct character, return \'_\' return \'_\'"},{"question":"You are given a binary tree represented as a list `nodes`, where `nodes[i]` represents the value of the `i-th` node. The left child of the node at index `i` is located at index `2*i + 1` and the right child is at index `2*i + 2`. Some nodes may be `null`, indicating that the node does not exist in the tree. Your task is to return the level order traversal of the tree as a list of lists, where each inner list contains the values of the nodes at that level of the tree from left to right. If a level in the tree does not have any nodes, it should not appear in the output.","solution":"from collections import deque from typing import List, Optional def level_order_traversal(nodes: List[Optional[int]]) -> List[List[int]]: if not nodes or nodes[0] is None: return [] result = [] queue = deque([(0, nodes[0])]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): index, node = queue.popleft() if node is None: continue current_level.append(node) left_index = 2 * index + 1 right_index = 2 * index + 2 if left_index < len(nodes): queue.append((left_index, nodes[left_index])) if right_index < len(nodes): queue.append((right_index, nodes[right_index])) if current_level: result.append(current_level) return result"},{"question":"You are given a non-negative integer array `heights` representing the heights of students in a line. The students are initially standing in a line in the order they appear in the array. A student can see another student in front of them only if all the students between them are shorter than both of them. Return the total number of pairs of students (i, j) such that student `i` can see student `j` (where `i < j`).","solution":"def count_visible_pairs(heights): Returns the total number of pairs of students (i, j) such that student i can see student j (where i < j). n = len(heights) count = 0 for i in range(n): max_height = 0 for j in range(i + 1, n): if heights[j] > max_height: max_height = heights[j] if heights[i] < heights[j]: count += 1 return count"},{"question":"You are given an n x n grid filled with integers. Each row of the grid represents a non-decreasing sequence from left to right, and each column represents a non-decreasing sequence from top to bottom. Given an integer target, implement a function to determine if the target value exists in the grid. Provide the following function signature: ```python def search_matrix(grid: List[List[int]], target: int) -> bool: ``` The function should return `True` if the target value is found in the grid, otherwise return `False`.","solution":"from typing import List def search_matrix(grid: List[List[int]], target: int) -> bool: Determines if the target value exists in the n x n grid. Each row of the grid is a non-decreasing sequence from left to right. Each column of the grid is a non-decreasing sequence from top to bottom. :param grid: List of lists representing the n x n grid. :param target: Integer target to search for in the grid. :return: True if the target exists in the grid, otherwise False. if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) row, col = rows - 1, 0 while row >= 0 and col < cols: if grid[row][col] == target: return True elif grid[row][col] > target: row -= 1 else: col += 1 return False"},{"question":"Given a string `s` consisting of English letters, return the length of the **longest substring** without repeating characters. The substring should be **contiguous** and can contain letters from \'a\' to \'z\' in either lowercase or uppercase. The aim is to detect and extract this substring while ensuring maximal length.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) max_length = 0 start = 0 used_chars = {} for i in range(n): if s[i] in used_chars and start <= used_chars[s[i]]: start = used_chars[s[i]] + 1 else: max_length = max(max_length, i - start + 1) used_chars[s[i]] = i return max_length"},{"question":"You are given a `k`-ary tree of `n` nodes represented in a `level-order` traversal format as an array. Each node in the tree can have at most `k` children. The nodes are numbered from `1` to `n`, where `node[i]` represents the `i`th node in the tree. The tree starts with the root node `1`. Your task is to find the `depth` of the tree. The depth of a tree is defined as the longest path from the root node to any leaf node. Return _the depth of the tree_.","solution":"def k_ary_tree_depth(arr, k): Calculate the depth of a k-ary tree from its level-order traversal array. Parameters: arr (list of int): The level-order traversal of the tree. k (int): The maximum number of children each node can have. Returns: int: The depth of the k-ary tree. if not arr: return 0 n = len(arr) depth = 0 nodes_at_current_level = 1 while nodes_at_current_level <= n: depth += 1 nodes_at_current_level *= k return depth"},{"question":"Given two integer arrays `arr1` and `arr2`, return a new array that consists of those elements which are common in both `arr1` and `arr2`. Each element in the result should appear as many times as it shows in both arrays, and you may return the result in **any order**.","solution":"def intersect(arr1, arr2): Returns an array that consists of those elements which are common in both arr1 and arr2. Each element in the result appears as many times as it shows in both arrays. from collections import Counter count1 = Counter(arr1) count2 = Counter(arr2) intersection = [] for element in count1: if element in count2: min_count = min(count1[element], count2[element]) intersection.extend([element] * min_count) return intersection"},{"question":"Given a **0-indexed** integer array `nums`, every index in `nums` has a number of candies. You have a number of operations you can perform on this array. In each operation, you can choose any index `i` (0 <= i < nums.length - 1) and transfer one candy from `nums[i]` to `nums[i + 1]`. Return `true` if you can make all elements in the array equal using at most `nums.length - 1` operations and `false` otherwise. Note: You can assume that the sum of all candies in the array is divisible by the length of the array.","solution":"def can_make_elements_equal(nums): Check if it\'s possible to make all elements in the array equal using at most nums.length - 1 operations. :param nums: List[int] - 0-indexed integer array representing candies at each index :return: bool - True if we can make all elements equal, otherwise False total_operations = 0 n = len(nums) target = sum(nums) // n for num in nums: if num > target: total_operations += (num - target) return total_operations <= (n - 1)"},{"question":"You are given a **0-indexed** binary array `nums`, where a `1` represents a person standing and a `0` represents an empty space. Your task is to find the maximum distance between any two standing persons such that no other person is standing between them. If there are less than two standing persons, return `0`. Return the _maximum distance between any two standing persons in the array._","solution":"def max_distance_between_persons(nums): Returns the maximum distance between any two standing persons in the array. Args: nums: List[int] - A list of binary values representing persons (1) and empty spaces (0). Returns: int - The maximum distance between any two standing persons or 0 if less than two persons stand. indices = [i for i, val in enumerate(nums) if val == 1] if len(indices) < 2: return 0 max_distance = 0 for i in range(1, len(indices)): max_distance = max(max_distance, indices[i] - indices[i-1]) return max_distance"},{"question":"You are given a **0-indexed** integer array `nums` of even length `n`. The array consists of exactly `n / 2` identical elements and `n / 2` unique elements. Return _the sum of the highest `n / 2` unique elements_ in `nums`. If there are multiple answers with the same result, return any of them. The input has been generated such that there is at least one unique element higher than the identical elements.","solution":"def sum_highest_unique_elements(nums): Returns the sum of the highest n/2 unique elements in the given list nums of even length n. from collections import Counter # Count the frequency of each element freq = Counter(nums) # Get the unique elements unique_elements = [key for key, value in freq.items() if value == 1] # Sort in descending order unique_elements.sort(reverse=True) # Sum the highest n/2 unique elements n = len(nums) result = sum(unique_elements[:n // 2]) return result"},{"question":"Given an array of integers, determine whether there are three distinct elements `a`, `b`, `c` in the array such that `a + b + c = 0`. Return _all triplets from the array that meet the criteria_. The solution set must not contain duplicate triplets.","solution":"def three_sum(nums): Given an array of integers, determines whether there are three distinct elements `a`, `b`, `c` in the array such that `a + b + c = 0`. Returns all triplets from the array that meet the criteria. The solution set must not contain duplicate triplets. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif s < 0: left += 1 else: right -= 1 return result"},{"question":"Given an integer array `arr` representing a positive-only histogram where each element represents the height of a bar, find the largest rectangular area that can be formed by one or more consecutive bars. Return the area of this largest rectangle.","solution":"def largest_rectangle_area(histogram): Given an integer array representing a histogram where each element is the height of a bar, find the largest rectangular area that can be formed by one or more consecutive bars. :param histogram: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a string `s` and a string `part`. You want to remove all occurrences of `part` in `s`. The removal process should keep replacing the `part` substrings until no more occurrences are found. Specifically, once a `part` is removed, the resulting string should be checked for more `part` substrings and the process should be repeated until no more `part` is found in the string. Return _the final string after all possible removals have been made_. Example: - If `s = \\"daabcbaabcbc\\"` and `part = \\"abc\\"`, the resulting string after all removals would be `\\"dab\\"`. - If `s = \\"axxxxyyyyb\\"` and `part = \\"xy\\"`, the resulting string after all removals would be `\\"ab\\"`.","solution":"def remove_occurrences(s, part): Remove all occurrences of \'part\' in \'s\' until no more \'part\' is found. :param s: Input string to remove parts from. :param part: Substring to be removed. :return: Final string after all replacements. while part in s: s = s.replace(part, \\"\\") return s"},{"question":"You are given a 2D grid of integers where each cell in the grid represents the height of that point. Find the **maximum height** in the grid after performing the following operation any number of times: 1. Choose any cell in the grid and increment the height of that cell by 1. 2. Choose any cell in the grid and decrement the height of that cell by 1, but only if the resulting height is not less than the height of every adjacent cell (up, down, left, right). Return the maximum height achievable while maintaining the grid\'s relative height order.","solution":"def max_height(grid): Returns the maximum height achievable in the grid while maintaining the height order. In general, this is the maximum value present in the grid because we are allowed only to increment the value with no restrictions. max_val = float(\'-inf\') for row in grid: for val in row: if val > max_val: max_val = val return max_val"},{"question":"Given a string `str` and an integer array `indices` of the same length, shuffle the string by reordering the characters according to the provided `indices` array. For example, if the input string `str` is `\\"aiohn\\"` and `indices` is `[3,1,4,2,0]`, the output should be `\\"nihao\\"` because: ``` str[indices[0]] = \'a\' -> position 3 str[indices[1]] = \'i\' -> position 1 str[indices[2]] = \'o\' -> position 4 str[indices[3]] = \'h\' -> position 2 str[indices[4]] = \'n\' -> position 0 ``` Thus, the output string would be `\\"nihao\\"`. Return the shuffled string.","solution":"def restore_string(s: str, indices: list) -> str: Restores the string s according to the provided indices array shuffled = [\'\'] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return \'\'.join(shuffled)"},{"question":"You are given a rectangular chocolate bar represented as a `m x n` matrix where each cell contains an integer `chocolate[i][j]` representing the amount of chocolate in that piece. You can break the bar between two rows or two columns, effectively splitting it into two smaller bars. Your goal is to collect the maximum amount of chocolate pieces by breaking the bar in exactly `k` breaks. However, you can only collect chocolate from one of the resulting pieces after each break. Given `m`, `n`, `chocolate`, and `k`, return the maximum amount of chocolate you can collect after making `k` breaks.","solution":"def max_chocolate(m, n, chocolate, k): Returns the maximum amount of chocolate pieces that can be collected after making k breaks. Parameters: m (int): number of rows in the chocolate bar n (int): number of columns in the chocolate bar chocolate (list[list[int]]): m x n matrix representing the chocolate bar k (int): number of breaks Returns: int: maximum amount of chocolate pieces that can be collected # dp[i][j][b] will store the max chocolate we can collect with b breaks considering the chocolate bar from (0,0) to (i,j) dp = [[[0] * (k + 1) for _ in range(n)] for _ in range(m)] # Initialize DP table for 0 breaks for i in range(m): for j in range(n): dp[i][j][0] = sum(chocolate[x][y] for x in range(i + 1) for y in range(j + 1)) # Process the DP table for 1 to k breaks for b in range(1, k + 1): for i in range(m): for j in range(n): dp[i][j][b] = dp[i][j][b-1] # Start with no additional breaks # Try breaking horizontally (above the breaking line) for x in range(i): dp[i][j][b] = max(dp[i][j][b], dp[x][j][b-1] + sum(chocolate[s][t] for s in range(x + 1, i + 1) for t in range(j + 1))) # Try breaking vertically (left of the breaking line) for y in range(j): dp[i][j][b] = max(dp[i][j][b], dp[i][y][b-1] + sum(chocolate[s][t] for s in range(i + 1) for t in range(y + 1, j + 1))) # The answer is the maximum chocolate we can collect with k breaks considering the whole bar return dp[m - 1][n - 1][k]"},{"question":"Imagine you are given an array of positive integers representing the positions of cars on a circular track of length `n`. Each car can only move to a position ahead (wrap-around allowed), and the distance each car can move per unit time is fixed at `d` units. The cars race around the track for an indefinite amount of time. You need to determine the minimum time `t` required such that every car meets at the same position on the track, regardless of the starting positions. Return the value of `t`. For example, given `n = 12`, `d = 3`, and the initial positions of the cars as `[2, 5, 9]`, figure out the minimum time `t` at which all the cars meet at the same position on the track.","solution":"import math def gcd(a, b): Returns the greatest common divisor of a and b. while b: a, b = b, a % b return a def lcm(a, b): Returns the least common multiple of a and b. return abs(a * b) // gcd(a, b) def minimum_time_to_meet(n, d): Returns the minimum time t required such that every car meets at the same position on a circular track of length n, given that each car moves d units per unit time. return lcm(n, d)"},{"question":"A company hired some new employees and each employee needs a unique ID badge. The company has provided a string `badges` where each character in the string represents an ID badge (for example, `badges = \\"abc\\"` means badges `a`, `b`, and `c` are available). You are also given a list of strings `names` where each `names[i]` represents the name of the new employee. Each badge can be used to generate distinct badge names. For example, given `badges = \\"abc\\"` and `names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]`, possible badge names could be `aAlice`, `bAlice`, `cAlice`, `aBob`, `bBob`, etc. Write a function to return a list of generated badge names for each employee name using each available badge. Example: Input: `badges = \\"pq\\"` and `names = [\\"John\\", \\"Jane\\"]` Output: `[\\"pJohn\\", \\"qJohn\\", \\"pJane\\", \\"qJane\\"]`","solution":"def generate_badge_names(badges, names): Generates a list of badge names for each employee name using each available badge. :param badges: A string of unique badge characters :param names: A list of employee names :return: A list of generated badge names badge_names = [] for name in names: for badge in badges: badge_names.append(f\\"{badge}{name}\\") return badge_names"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You are allowed to remove at most `k` characters from the string. Your goal is to determine the length of the longest substring that contains the same character after making the allowed removals. Implement a function to accomplish this. For instance, if `s = \\"aabbcc\\"` and `k = 2`, you can remove two characters to get the substring `\\"aaaa\\"` which has the length 4.","solution":"def longest_substring_same_char_after_removals(s, k): from collections import defaultdict if not s: return 0 left = 0 max_len = 0 max_count = 0 count = defaultdict(int) for right, char in enumerate(s): count[char] += 1 max_count = max(max_count, count[char]) while (right - left + 1) - max_count > k: count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a 2D grid `grid` of size `m x n` representing a map where `1` represents land and `0` represents water. An island is a maximal 4-connected group of `1`s. The grid has exactly one island. You need to determine the shortest path to reach any water cell from each land cell that belongs to the island. A cell is 4-connected if you can move right, left, up, or down to another land cell. Return the length of the shortest path for each land cell in the island to reach the closest water cell as a 2D array of the same dimension as the input grid `grid`.","solution":"from collections import deque def shortest_path_to_water(grid): Given a 2D grid representing a map with exactly one island, returns the shortest path to reach any water cell from each land cell in the island. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] distances = [[float(\'inf\')] * n for _ in range(m)] queue = deque() # Traverse the grid to initiate the BFS from all water cells and land cells for i in range(m): for j in range(n): if grid[i][j] == 0: queue.append((i, j, 0)) # Append water cells with initial distance 0 while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and distances[nx][ny] == float(\'inf\'): distances[nx][ny] = dist + 1 queue.append((nx, ny, dist + 1)) return distances"},{"question":"You are given a grid `G` of size `m x n` filled with non-negative integers representing heights. Find a path from the top left to the bottom right which minimizes the sum of all numbers along its path. You can only move to the right or down from a cell in the grid. Return the minimum sum possible.","solution":"def minPathSum(grid): Given a grid of size m x n filled with non-negative integers, find a path from the top left to the bottom right which minimizes the sum of all numbers along its path. You can only move to the right or down from a cell. :param grid: List[List[int]], 2D list representing the grid :return: int, minimum sum possible to reach the bottom-right corner if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the DP table with the same dimensions as the grid dp = [[0] * cols for _ in range(rows)] # Fill the DP table for i in range(rows): for j in range(cols): if i == 0 and j == 0: dp[i][j] = grid[i][j] # Starting point elif i == 0: dp[i][j] = dp[i][j-1] + grid[i][j] # First row (can only come from the left) elif j == 0: dp[i][j] = dp[i-1][j] + grid[i][j] # First column (can only come from above) else: dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # Choose min from top or left return dp[rows-1][cols-1]"},{"question":"Given a string `s` and an array of `queries` where `queries[i] = [starti, endi, distancei]`, you are required to determine if the substring of `s` from `starti` to `endi` inclusive can be transformed into a palindrome by changing at most `distancei` characters. Note that each query is independent. Implement the function `List<Boolean> canMakePalindrome(String s, List<int[]> queries)` where: * `s` is a string of lowercase English letters. * `queries` is a list of integer arrays where each array contains three integers: `starti`, `endi`, and `distancei`. The function should return a list of boolean values where each boolean value indicates whether the corresponding substring in the query can be transformed into a palindrome with at most `distancei` changes.","solution":"def canMakePalindrome(s, queries): Determines if the given substrings in each query can be transformed into a palindrome by changing at most `distancei` characters. Args: s: A string of lowercase English letters. queries: A list of lists, where each list contains three integers `[starti, endi, distancei]`. Returns: A list of boolean values indicating whether each substring can be transformed into a palindrome. def is_palindrome_possible(sub_str, max_changes): left = 0 right = len(sub_str) - 1 changes = 0 while left < right: if sub_str[left] != sub_str[right]: changes += 1 if changes > max_changes: return False left += 1 right -= 1 return True result = [] for start, end, max_changes in queries: substring = s[start:end+1] result.append(is_palindrome_possible(substring, max_changes)) return result"},{"question":"You are given a list of non-negative integers `nums`, representing the amount of money of each house in a row. You are a robber who wants to maximize the amount of money you can steal, but you cannot steal from two adjacent houses because they will raise an alarm. Return the maximum amount of money you can rob without triggering the alarm.","solution":"def rob(nums): Returns the maximum amount of money you can rob without triggering the alarm. :param nums: List of non-negative integers representing money in each house. :return: The maximum amount of money you can rob. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize the two previous robbery amounts prev2 = 0 prev1 = nums[0] for i in range(1, len(nums)): current = max(prev1, prev2 + nums[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"You have a `times` table containing `n` triplets where each triplet `(a, b, c)` describes a directed edge from node `a` to node `b` with a travel time `c` in a given weighted directed graph. You are also given an integer `k` representing the starting node. The graph has exactly `n` nodes labeled from `1` to `n`. Return the minimum time it takes for all nodes to receive the signal starting from node `k`. If it is impossible for all the nodes to receive the signal, return `-1`.","solution":"import heapq def network_delay_time(times, n, k): Returns the minimum time it takes for all nodes to receive the signal starting from node k. If it is impossible for all nodes to receive the signal, returns -1. times: List of tuples (a, b, c) where a is the source node, b is the target node, and c is the travel time n: Number of nodes k: Starting node # Build graph graph = {i: [] for i in range(1, n+1)} for u, v, w in times: graph[u].append((v, w)) # Min-heap to implement Dijkstra\'s algorithm heap = [(0, k)] # (time, node) dist = {} while heap: t, node = heapq.heappop(heap) if node not in dist: dist[node] = t for v, w in graph[node]: if v not in dist: heapq.heappush(heap, (t + w, v)) # If all nodes are reached, return the maximum time observed if len(dist) == n: return max(dist.values()) return -1"},{"question":"You are given a list of `words` and a `target` string. You need to determine the minimum number of transformations required to transform any word from the list into the `target` string. In one transformation, you can change exactly one character of the current word to any other character. Return the minimum number of transformations needed or -1 if it is not possible. Note that all the words in the list and `target` string have the same length and consist of lowercase English letters.","solution":"def min_transformations(words, target): Returns the minimum number of transformations required to transform any word from the list to the target string. Each transformation consists of changing one character to another. Parameters: words (list): List of words target (str): Target string Returns: int: Minimum number of transformations or -1 if transformation is not possible if not words or not target: return -1 min_trans = float(\'inf\') for word in words: if len(word) != len(target): continue transformations = sum(1 for w, t in zip(word, target) if w != t) min_trans = min(min_trans, transformations) return min_trans if min_trans != float(\'inf\') else -1"},{"question":"You are given a string `s` representing an expression containing digits and the characters \'+\', \'-\', \'*\', and \'/\'. Each of these characters represents a basic arithmetic operation. Parse the expression and return the result of the computation. Use the standard order of operations (multiplication and division have higher precedence than addition and subtraction). Assume the expression is always valid and does not contain any whitespace.","solution":"def compute_expression(s): Computes the result of the given arithmetic expression string `s`. Supports +, -, *, / operations with standard operator precedence. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(left / right) # Helper function for precedence def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 # Shunting yard algorithm to convert the expression to postfix notation operators = [] values = [] i = 0 while i < len(s): if s[i].isdigit(): num = 0 while i < len(s) and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 values.append(num) i -= 1 else: while (operators and precedence(operators[-1]) >= precedence(s[i])): apply_operator(operators, values) operators.append(s[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"Given an integer array `nums`, determine whether there is a sequence of numbers in the array that can form an arithmetic sequence. An arithmetic sequence is a sequence of numbers such that the difference between successive numbers is constant. Your task is to implement a function that will return `true` if there is at least one subsequence in `nums` that can form an arithmetic sequence, and `false` otherwise. The length of the array will be at least 3 and all numbers will be distinct.","solution":"def can_form_arithmetic_sequence(nums): Returns True if there is at least one subsequence in nums that can form an arithmetic sequence. nums.sort() n = len(nums) for i in range(n - 2): diff = nums[i + 1] - nums[i] arithmetic = True for j in range(i + 1, n - 1): if nums[j + 1] - nums[j] != diff: arithmetic = False break if arithmetic: return True return False"},{"question":"You are given a string `s` consisting of only the characters `\'a\'`, `\'b\'`, and `\'c\'`. You are allowed to delete any number of characters from the string. Your task is to determine the length of the longest substring you can obtain that contains equal numbers of the characters `\'a\'`, `\'b\'`, and `\'c\'`. Return _the **length** of this longest substring_. Example: - Input: s = \\"abcabc\\" - Output: 6","solution":"def longest_equal_substring(s): def to_key(a, b): return a - b n = len(s) if n == 0: return 0 count_a, count_b, count_c = 0, 0, 0 count_map = { (0, 0): -1 } max_len = 0 for i in range(n): if s[i] == \'a\': count_a += 1 elif s[i] == \'b\': count_b += 1 elif s[i] == \'c\': count_c += 1 key = (to_key(count_a, count_b), to_key(count_a, count_c)) if key in count_map: max_len = max(max_len, i - count_map[key]) else: count_map[key] = i return max_len"},{"question":"You are given a string `s` consisting of lowercase English letters and the character `*` which can represent any single letter. Your task is to determine if another string `p` can be formed by possibly replacing each `*` in `s` with any single letter such that `p` becomes a palindrome. Return `true` if it is possible to form such a palindrome, otherwise return `false`.","solution":"def can_form_palindrome(s): Determines if the given string \'s\' can be turned into a palindrome by replacing \'*\' with any single letter. :param s: A string with lowercase English letters and the character \'*\' :return: True if it is possible to form a palindrome, otherwise False n = len(s) # Compare characters from start and end moving towards the center for i in range(n // 2): start_char = s[i] end_char = s[n - 1 - i] # If both characters are \'*\' or one is \'*\' replace it effectively to match the other if start_char != \'*\' and end_char != \'*\' and start_char != end_char: return False return True"},{"question":"You are given an array of integers `height` representing the heights of buildings in a city skyline (from left to right). Each building is separated by exactly one unit. A building\'s width is 1 unit. Write a function to calculate the total area covered by the buildings when viewed from a distance, including the gaps between buildings. That is, you need to find the total area covered from the ground (height 0) up to the tallest building in the array, considering all horizontal and vertical slices of the skyline. Return _the total covered area_.","solution":"def total_area_covered(height): Returns the total area covered by the buildings represented by the heights array. if not height: return 0 tallest_building = max(height) width = len(height) # Calculate the total area considering all horizontal and vertical slices total_area = 0 for h in range(1, tallest_building + 1): for w in range(width): if height[w] >= h: total_area += 1 return total_area"},{"question":"You are designing a logging system for a server where each log entry records a timestamp and an event. The logs are given in a list where each log is a string formatted as \\"HH:MM event_description\\". The logs are not guaranteed to be in chronological order. Write a function that takes the list of logs and an event description, and returns the delay in minutes between the first and last occurrence of that event. You may assume that the event occurs at least twice in the logs. The times are given in the 24-hour format. For example, for logs: - [\\"12:30 start\\", \\"14:00 process\\", \\"12:35 end\\", \\"14:15 start\\", \\"15:45 end\\"], calling the function with event description \\"start\\" should return 105 (minutes difference between \\"12:30\\" and \\"14:15\\").","solution":"def time_to_minutes(time_str): Converts a time string in HH:MM format to total minutes. hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes def event_time_difference(logs, event): Returns the delay in minutes between the first and last occurrence of the event. times = [time_to_minutes(log.split()[0]) for log in logs if log.endswith(event)] if len(times) < 2: raise ValueError(\\"The event must occur at least twice in the logs.\\") return max(times) - min(times)"},{"question":"Given an integer array `nums` and an integer `k`, return the maximum number of consecutive `1`s in the array if you can flip at most `k` `0`s.","solution":"def longest_ones(nums, k): Returns the maximum number of consecutive 1s in the array if you can flip at most k 0s. :param nums: List[int] - List of integers containing 0s and 1s :param k: int - Maximum number of 0s that can be flipped :return: int - Maximum number of consecutive 1s left = 0 max_consecutive_ones = 0 zero_count = 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > k: if nums[left] == 0: zero_count -= 1 left += 1 max_consecutive_ones = max(max_consecutive_ones, right - left + 1) return max_consecutive_ones"},{"question":"You are given a 2D grid of dimensions `m x n` where each cell in the grid can have one of three values: - `0` representing an empty cell, - `1` representing a fresh orange, - `2` representing a rotten orange. Each minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return `-1`. # Input: - `grid`: a 2D array of integers. # Output: - An integer representing the minimum number of minutes needed, or `-1`. # Example: ```python grid = [ [2,1,1], [1,1,0], [0,1,1] ] ``` **Output:** `4` **Explanation:** The grid is as follows: After 1 minute: `[2,2,1] [2,1,0] [0,1,1]` After 2 minutes: `[2,2,2] [2,2,0] [0,1,1]` After 3 minutes: `[2,2,2] [2,2,0] [0,2,1]` After 4 minutes: `[2,2,2] [2,2,0] [0,2,2]`","solution":"from collections import deque def orangesRotting(grid): Returns the minimum number of minutes that must elapse until no cell has a fresh orange. If it is impossible, return -1. m, n = len(grid), len(grid[0]) queue = deque() fresh = 0 # Initialize the queue with all rotten orange positions for i in range(m): for j in range(n): if grid[i][j] == 2: queue.append((i, j, 0)) # (row, col, time) elif grid[i][j] == 1: fresh += 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] minutes = 0 while queue: x, y, minutes = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: grid[nx][ny] = 2 fresh -= 1 queue.append((nx, ny, minutes + 1)) return -1 if fresh > 0 else minutes"},{"question":"You are given an **n x n** grid `grid` of integers where each cell represents the height of a region. The \\"rainwater trapping problem\\" involves determining the maximum amount of water that can be trapped after raining over the entire area, assuming that the border cells are fully open and water cannot be trapped there. Your goal is to determine the maximum volume of water that can be trapped in the **non-border** regions of the grid. Return _the **total volume** of trapped water._","solution":"import heapq def trapRainWater(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) visited = [[False] * m for _ in range(n)] heap = [] for i in range(n): for j in range(m): if i == 0 or j == 0 or i == n - 1 or j == m - 1: heapq.heappush(heap, (grid[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_trapped = 0 max_height = 0 while heap: height, x, y = heapq.heappop(heap) max_height = max(max_height, height) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, max_height - grid[nx][ny]) heapq.heappush(heap, (grid[nx][ny], nx, ny)) return water_trapped"},{"question":"You are given a linked list where each node contains an integer value. Define a function that splits the linked list into two separate lists, with the first list containing all the nodes with even values and the second list containing all the nodes with odd values. The order of the nodes in the new lists should be the same as in the original list. Implement the function `splitLinkedList(ListNode head)` that returns a pair of the heads of the two new linked lists. For example, for the linked list 1 -> 2 -> 3 -> 4 -> 5, the function would return the heads of two lists: 2 -> 4 and 1 -> 3 -> 5.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def splitLinkedList(head): if not head: return None, None even_head = even_tail = ListNode(0) odd_head = odd_tail = ListNode(0) current = head while current: if current.val % 2 == 0: even_tail.next = ListNode(current.val) even_tail = even_tail.next else: odd_tail.next = ListNode(current.val) odd_tail = odd_tail.next current = current.next return even_head.next, odd_head.next"},{"question":"You are given two arrays, `nums` and `index`. Your goal is to create a target array under the following rules: 1. Initially, the target array is empty. 2. You insert the elements from `nums` into the target array based on the positions in the `index` array. 3. Specifically, if you are inserting the i-th element from `nums` at position `index[i]` in the target array, you need to shift the elements present at index `index[i]` and beyond to the right before inserting. Return the `target` array after inserting all elements. **Example:** Input: `nums = [0, 1, 2, 3, 4]`, `index = [0, 1, 2, 2, 1]` Output: `[0, 4, 1, 3, 2]` **Note:** The arrays `nums` and `index` are both of the same length.","solution":"def create_target_array(nums, index): Creates the target array based on the nums and index arrays. Parameters: nums (list): A list of numbers to be inserted. index (list): A list of indices at which to insert the numbers from nums. Returns: list: The target array after all insertions. target = [] for num, idx in zip(nums, index): target.insert(idx, num) return target"},{"question":"You are working on a text editor that supports undo and redo functionalities. The editor keeps track of the history of all performed operations. Implement the `TextEditor` class to handle the following operations: - `TextEditor()`: Initializes the text editor with an empty history. - `void addText(String text)`: Adds the given `text` at the end of the document. - `void undo()`: Undoes the last operation that modified the document. If there are no operations to undo, it does nothing. - `void redo()`: Redoes the last undone operation. If there are no operations to redo, it does nothing. - `String getText()`: Returns the current content of the document without modifying it. Ensure that the functionalities handle edge cases, such as multiple undos and redos beyond the history limit, efficiently. The methods `undo()` and `redo()` should operate in constant time.","solution":"class TextEditor: def __init__(self): self.history = [] self.redo_stack = [] self.current_text = \\"\\" def addText(self, text): self.history.append(self.current_text) self.redo_stack.clear() # Clear the redo stack as new operation invalidates the redo history self.current_text += text def undo(self): if self.history: last_state = self.history.pop() self.redo_stack.append(self.current_text) self.current_text = last_state def redo(self): if self.redo_stack: redo_state = self.redo_stack.pop() self.history.append(self.current_text) self.current_text = redo_state def getText(self): return self.current_text"},{"question":"Given a string `s` containing only the characters \'x\' and \'y\', you can swap any two adjacent characters. Your goal is to transform the string into a balanced string where the number of \'x\' characters is equal to the number of \'y\' characters. Return the minimum number of swaps required to make the string balanced. If it\'s impossible to balance the string, return -1.","solution":"def min_swaps_to_balance(s): Returns the minimum number of swaps required to make the string balanced or -1 if it is impossible to balance the string. # Check if it\'s possible to balance the string cnt_x = s.count(\'x\') cnt_y = s.count(\'y\') if cnt_x != cnt_y: return -1 # Calculate minimum swaps # Approach: Calculate the number of swaps needed to balance \'xy\' -> \'yx\' or vice versa swaps = 0 balance = 0 for char in s: if char == \'x\': balance += 1 else: balance -= 1 # If temporarily balance goes negative, it means a swap is needed if balance < 0: swaps += 1 balance = 1 return swaps"},{"question":"Given a singly linked list `head`, the task is to determine if the linked list has a cycle in it. A cycle occurs when a node\'s next pointer references a previous node, forming a loop. If there is a cycle, return `true`, otherwise return `false`. Write a function that uses constant extra space to solve the problem.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head): Determines if the linked list has a cycle. :param head: The head of the singly linked list. :return: True if there is a cycle, otherwise False. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are given an array of integers `heights` representing the heights of a series of buildings adjacent to a river where the buildings form a single line from left to right. Some of the buildings have their top floors constructed of glass and you want to find out the amount of water that would be trapped between these buildings if it rains. Write an algorithm that computes the total amount of trapped water. Water is trapped between buildings in such a way that the water trapping potential of each building is determined by the minimum of the highest buildings on either side, minus the height of the building itself. Return the total amount of trapped water.","solution":"def trap(height): Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given a list of `n` integers `nums`, return _the maximum value of the sum of the elements of any contiguous subarray of size at least 2_. A **subarray** is a contiguous part of an array.","solution":"def max_sum_subarray(nums): Returns the maximum value of the sum of the elements of any contiguous subarray of size at least 2. if len(nums) < 2: raise ValueError(\\"Array should have at least 2 elements\\") max_sum = float(\'-inf\') current_sum = nums[0] for i in range(1, len(nums)): current_sum += nums[i] if i >= 1: max_sum = max(max_sum, current_sum) current_sum = max(current_sum, nums[i]) return max_sum"},{"question":"A company has a legacy software system with a list of tasks to complete, each of which is represented by an integer array `tasks`. A task can either be approved or denied based on a strict approval criterion. Each task is approved only if it has more than `k` unique prime factors. The company wants to filter out all tasks that do not meet this criterion. Given an integer `k` and an array of integers `tasks`, return an array of integers representing the tasks that have more than `k` unique prime factors.","solution":"from math import isqrt def prime_factors_count(n): Returns the count of unique prime factors of n. count = 0 i = 2 while i <= isqrt(n): if n % i == 0: count += 1 while n % i == 0: n //= i i += 1 if n > 1: count += 1 return count def filter_tasks_by_prime_factors(tasks, k): Returns a list of tasks that have more than k unique prime factors. return [task for task in tasks if prime_factors_count(task) > k]"},{"question":"Given a list of integers `arr`, find the minimum number of moves required to make all elements equal. In one move, you can choose any element and increment or decrement it by 1. Return the minimum moves required as an integer.","solution":"def min_moves_to_equal_elements(arr): Returns the minimum number of moves required to make all elements in the list equal. Moves can be incrementing or decrementing an element by 1. if not arr: return 0 arr.sort() median = arr[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"You are given a string `s` consisting of lowercase English letters, and you need to form a new string `t` by selecting characters from `s` such that `t` is the **longest palindrome**. You can rearrange the letters from `s` when forming `t`. Return _the length of the longest palindrome_ that can be created using the letters from `s`.","solution":"def longest_palindrome_length(s): Returns the length of the longest palindrome that can be formed using the letters from s. from collections import Counter counts = Counter(s) length = 0 odd_count = 0 for count in counts.values(): if count % 2 == 0: length += count else: length += count - 1 odd_count = 1 return length + odd_count"},{"question":"You are given an integer array `heights` representing the height of certain buildings. A **uniquely visible interval** is defined as an interval `[i, j]` (0 ≤ i ≤ j < heights.length), where all buildings in that interval have different heights. Return _the number of uniquely visible intervals_ in `heights`.","solution":"def num_uniquely_visible_intervals(heights): Returns the number of uniquely visible intervals in the given heights list. n = len(heights) count = 0 for i in range(n): seen = set() for j in range(i, n): if heights[j] in seen: break seen.add(heights[j]) count += 1 return count"},{"question":"You are given an array of integers `arr` which may contain duplicates. Your task is to check if the array can be partitioned into `k` subarrays such that each subarray has exactly `n` distinct integers. Return `true` if such a partitioning is possible, otherwise return `false`.","solution":"def can_partition_k_subarrays_with_n_distinct(arr, k, n): Determines if the array can be partitioned into k subarrays each with exactly n distinct integers. Parameters: arr (list): List of integers which may contain duplicates. k (int): The number of subarrays. n (int): The number of distinct integers required in each subarray. Returns: bool: True if the partition is possible, False otherwise. if len(arr) < k * n: return False from collections import Counter # Count frequencies of elements in the array counter = Counter(arr) # Check if we have enough counts to partition into k subarrays each with n distinct elements for count in counter.values(): if count >= k: k -= 1 if k == 0: return True return k == 0"},{"question":"Your task is to develop a function that finds the minimum number of adjacent swaps required to convert one string into another, given two strings of equal length. Your function should take two strings, `start` and `end`, and return an integer representing the minimum number of adjacent swaps required to make `start` equal to `end`. For example, given the strings `start = \\"abcdef\\"` and `end = \\"abcfde\\"`, the function should return 2, indicating that two adjacent swaps are required (`f <-> d` and `d <-> e`) to transform `start` into `end`. If it\'s impossible to transform `start` into `end` using adjacent swaps, the function should return `-1`.","solution":"def min_adjacent_swaps(start, end): Returns the minimum number of adjacent swaps required to convert start into end. If it\'s not possible, return -1. # if lengths of start and end are not equal, return -1 if len(start) != len(end): return -1 # check if both strings contain the same characters if sorted(start) != sorted(end): return -1 # initialize the number of swaps swaps = 0 start = list(start) end = list(end) for i in range(len(start)): if start[i] != end[i]: # find the position of the correct character in the remaining part of the start string j = i while start[j] != end[i]: j += 1 # bubble the character up to the correct position while j > i: start[j], start[j-1] = start[j-1], start[j] swaps += 1 j -= 1 return swaps"},{"question":"Given a grid of size `m x n` consisting of non-negative integers, you need to find a path from the top-left corner to the bottom-right corner of the grid such that the minimum value in that path is maximized. In other words, among all possible paths, choose the path whose minimum value is the largest. You can move up, down, left or right. Return the maximum of the minimum values over all possible paths.","solution":"def maximum_minimum_path(grid): from heapq import heappush, heappop import sys directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] m, n = len(grid), len(grid[0]) pq = [(-grid[0][0], 0, 0)] visited = [[False] * n for _ in range(m)] visited[0][0] = True min_value = grid[0][0] while pq: value, x, y = heappop(pq) min_value = min(min_value, -value) if x == m - 1 and y == n - 1: return min_value for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True heappush(pq, (-grid[nx][ny], nx, ny)) return -1"},{"question":"Given a string `s` that consists only of the characters \'a\', \'b\', and \'c\', you need to perform the following operations to make the string alternating (i.e., no two adjacent characters are the same): 1. Find the minimum number of operations required to make `s` an alternating string. 2. An operation consists of replacing any character in `s` with either \'a\', \'b\', or \'c\'. Implement a function `minOperationsToAlternate(s: str) -> int` that returns the minimum number of operations needed to make the string `s` alternating. Consider both possible patterns (starting with \'a\' or starting with \'b\') and return the smallest number of operations needed.","solution":"def minOperationsToAlternate(s: str) -> int: This function returns the minimum number of operations required to make the string `s` alternating. n = len(s) if n == 0: return 0 # Pattern 1: \\"ababab...\\" pattern1 = \'\'.join([\'a\' if i % 2 == 0 else \'b\' for i in range(n)]) # Pattern 2: \\"babab...\\" pattern2 = \'\'.join([\'b\' if i % 2 == 0 else \'a\' for i in range(n)]) # Count mismatches with each pattern operations1 = sum(1 for i in range(n) if s[i] != pattern1[i]) operations2 = sum(1 for i in range(n) if s[i] != pattern2[i]) # Return the minimum number of operations return min(operations1, operations2)"},{"question":"Suppose you are given a string `s` consisting of lowercase English letters. Your task is to perform the following operation: choose any substring of `s` of maximum length possible, where the number of distinct characters is at most `m`. Return the length of the longest substring that meets this condition. For example, given `s = \\"eceba\\"` and `m = 2`, the output should be `3`, as the longest substring with at most 2 distinct characters is `\\"ece\\"`.","solution":"def length_of_longest_substring_k_distinct(s: str, m: int) -> int: Returns the length of the longest substring with at most m distinct characters. if m == 0 or not s: return 0 from collections import defaultdict n = len(s) left = right = 0 max_length = 0 char_count = defaultdict(int) while right < n: char_count[s[right]] += 1 while len(char_count) > m: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"Given a string `s` and a list of words `wordDict`, return all the possible sentences you can form by concatenating words from the `wordDict`, ensuring that each word is used at most once. Each word in the `wordDict` can be used only if it matches a contiguous substring in the string `s`. The returned sentences should be in the same order as they appear in the string `s`. All words in `wordDict` are of unique lengths. Assume all characters in `s` and in words from `wordDict` are lowercase letters.","solution":"def wordBreak(s, wordDict): def backtrack(start, path): if start == len(s): results.append(\' \'.join(path)) return for word in wordDict: if s[start: start + len(word)] == word: backtrack(start + len(word), path + [word]) results = [] backtrack(0, []) return results"},{"question":"Given a binary tree, implement a function to find the leftmost and rightmost values at each level of the tree. The function should return a list of tuples, where each tuple contains the leftmost and rightmost values at a specific level of the binary tree. Assume the binary tree is non-empty and contains at least one node. Function signature: ```python def find_leftmost_and_rightmost_at_levels(root: TreeNode) -> List[Tuple[int, int]]: # Your code here ```","solution":"from typing import List, Tuple, Optional class TreeNode: def __init__(self, val: int = 0, left: \'Optional[TreeNode]\' = None, right: \'Optional[TreeNode]\' = None): self.val = val self.left = left self.right = right def find_leftmost_and_rightmost_at_levels(root: TreeNode) -> List[Tuple[int, int]]: from collections import deque if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) leftmost = queue[0].val rightmost = queue[-1].val result.append((leftmost, rightmost)) for _ in range(level_size): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"You are given an array of integers `arr` and an integer `k`. A **subarray** is defined as a contiguous segment of the array. Return the number of subarrays in `arr` whose elements sum up to `k`. Note that the array can contain both positive and negative integers.","solution":"def subarray_sum(arr, k): Returns the number of subarrays whose elements sum up to k. current_sum = 0 sum_counts = {0: 1} count = 0 for num in arr: current_sum += num if (current_sum - k) in sum_counts: count += sum_counts[current_sum - k] if current_sum in sum_counts: sum_counts[current_sum] += 1 else: sum_counts[current_sum] = 1 return count"},{"question":"You are given an integer array `nums` and an array of integer queries `queries`. Each query consists of two integers `L` and `R`, representing a range `[L, R]` (0-indexed). For each query, determine the maximum value within the subarray `nums[L..R]` that is divisible by 3. If no such value exists, return -1 for that query. Return _an array containing the result for each query_.","solution":"def max_divisible_by_3(nums, queries): Returns the maximum value within each range [L, R] in `queries` from the array `nums` that is divisible by 3. If no such value exists, returns -1 for that query. results = [] for L, R in queries: max_value = -1 for num in nums[L:R+1]: if num % 3 == 0 and num > max_value: max_value = num results.append(max_value) return results"},{"question":"Given a binary tree, return the breadth-first traversal of its nodes\' values as a list. You should return a 2D list where each sublist contains the values of the nodes at each level, from top to bottom. Implement the following TreeNode class and the breadth-first traversal function: - The TreeNode class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - The breadth-first traversal function: ```python def levelOrder(root: TreeNode) -> List[List[int]]: # Your code here ```","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to find all unique combinations in `nums` where the integers sum up to the `target`. The same number may be chosen from `nums` an unlimited number of times. You may return the combinations in any order. The solution set must not contain duplicate combinations. Implement the function `vector<vector<int>> combinationSum(vector<int>& nums, int target)` that takes a vector of integers `nums` and an integer `target` and returns a vector of vector of integers where each vector represents a unique combination that sums up to the target. **Example:** For `nums = [2,3,6,7]` and `target = 7`, one possible solution is: `[[7],[2,2,3]]`. For `nums = [2,5]` and `target = 3`, no combinations sum up to 3, so the result would be `[]`. **Note:** The numbers in `nums` are all positive integers. The order of the numbers within the combinations does not matter.","solution":"def combinationSum(nums, target): def backtrack(remaining, comb, start, results): if remaining == 0: results.append(list(comb)) return elif remaining < 0: return for i in range(start, len(nums)): comb.append(nums[i]) backtrack(remaining - nums[i], comb, i, results) comb.pop() results = [] backtrack(target, [], 0, results) return results"},{"question":"Given a list of non-negative integers `nums` and an integer `k`, you need to find the maximum sum of a contiguous subarray of size `k` in the array. If the length of `nums` is less than `k`, return `-1`. Implement a function `int maxSumSubarray(vector<int>& nums, int k)` that returns the maximum sum of the contiguous subarray of size `k`.","solution":"def maxSumSubarray(nums, k): Returns the maximum sum of a contiguous subarray of size k. If the length of the list `nums` is less than `k`, return `-1`. if len(nums) < k: return -1 max_sum = current_sum = sum(nums[:k]) for i in range(k, len(nums)): current_sum = current_sum + nums[i] - nums[i-k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an unsorted list of integers `nums` and an integer `target`. Your task is to find two distinct integers in the list that add up to the `target` and return their indices as a list. If there are multiple pairs that satisfy this condition, return the pair with the smallest indices. If no such pair exists, return `[-1, -1]`. The solution should have a time complexity better than O(n^2). Implement the function `def find_pair(nums: List[int], target: int) -> List[int]:` that takes in the list `nums` and the integer `target`, and returns a list of two integers representing the indices of the two numbers in `nums` that add up to `target`.","solution":"from typing import List def find_pair(nums: List[int], target: int) -> List[int]: Finds two distinct integers in the list that add up to the target and returns their indices. If there are multiple pairs, return the pair with the smallest indices. If no such pair exists, return [-1, -1]. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return [seen[complement], i] if num not in seen: # To ensure the pair has distinct integers seen[num] = i return [-1, -1]"},{"question":"Given a non-negative integer `num`, repeatedly add all its digits until the result has only one digit. Return _the resulting single digit_. You must implement this with O(1) runtime complexity.","solution":"def add_digits(num): Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Uses Digital Root concept for O(1) complexity. if num == 0: return 0 elif num % 9 == 0: return 9 else: return num % 9"},{"question":"You are given an **m x n** matrix `mat` where each element is either **0** or **1**. Your task is to count the number of **square submatrices** that have all **1s**. A square submatrix is a submatrix that has the same number of rows and columns. Return _the total number of square submatrices with all 1s._","solution":"def countSquares(matrix): Count the number of square submatrices with all 1s. Parameters: matrix (List[List[int]]): The m x n matrix of zeros and ones. Returns: int: The total number of square submatrices with all 1s. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] # dp table to store the size of the largest square ending at each cell count = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # Top row or left column else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 count += dp[i][j] return count"},{"question":"You are given a `linked list` with nodes that have integer values, and a target integer `x`. Rearrange the linked list so that all nodes with values less than `x` come before nodes with values greater than or equal to `x`. The relative order of nodes in each partition should remain the same as in the original linked list. Return the head of the modified linked list. For example, given the linked list `3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1` and `x` equals `5`, the linked list should be rearranged to `3 -> 2 -> 1 -> 5 -> 8 -> 5 -> 10`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head: ListNode, x: int) -> ListNode: Rearrange the linked list so that all nodes with values less than x come before nodes with values greater than or equal to x. The relative order of nodes in each partition should remain the same. less_head = ListNode(0) # dummy node for less than x greater_head = ListNode(0) # dummy node for greater than or equal to x less = less_head greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next # Terminate the greater list greater.next = None # Combine the less than and greater than lists less.next = greater_head.next return less_head.next"},{"question":"Suppose you are given a **0-indexed** 2D integer grid `matrix` representing a rectangular grid of cells, where each cell is either empty (`0`) or contains an obstacle (`1`). You are also given two integers `startX`, `startY` representing the starting position in the grid and `endX`, `endY` representing the target position in the grid. You need to determine the **shortest path** from the starting position to the target position avoiding all obstacles. You can move up, down, left, or right, but you cannot move through obstacles or out of the grid boundaries. _Return the length of the shortest path_ if it exists, otherwise _return `-1`_.","solution":"from collections import deque def shortest_path(matrix, startX, startY, endX, endY): Finds the shortest path from the start position to the end position avoiding obstacles in a grid. if matrix[startX][startY] == 1 or matrix[endX][endY] == 1: return -1 rows, cols = len(matrix), len(matrix[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right queue = deque([(startX, startY, 0)]) # x, y, distance visited = set((startX, startY)) while queue: x, y, dist = queue.popleft() if x == endX and y == endY: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and matrix[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given an integer array `heights` representing the heights of buildings in a row. The rainwater that falls on the buildings will be trapped between the buildings, where it can only be held if there are taller buildings on both sides of a section. Calculate the total amount of trapped rainwater. Return the total volume of water trapped.","solution":"def trap_rain_water(heights): Calculate the total amount of trapped rainwater given the heights of buildings. :param heights: List of integers representing the heights of buildings. :return: Total volume of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"Given a binary tree, write a function that returns whether the tree is \\"symmetric\\", meaning it is a mirror of itself. The function should take the root of the binary tree as an input and it should return `true` if the tree is symmetric, and `false` otherwise. You may assume the definition for a binary tree node is as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` A binary tree is symmetric if the left subtree is a mirror reflection of the right subtree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Returns whether the given binary tree is symmetric. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is symmetric, False otherwise def isMirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right) return isMirror(root, root)"},{"question":"Write a function that takes in a list of non-negative integers representing the heights of a series of vertical lines drawn on a 2D plane. Each line is of unit width. The function should return the maximum amount of water that can be trapped between any two lines. The function should not use built-in functions for calculating the maximum values directly or any external library for the same. The amount of water trapped between two lines is determined by the shorter line among the two, and the distance between them.","solution":"def max_area(heights): Returns the maximum amount of water that can be trapped between any two vertical lines. Parameters: heights (list): A list of non-negative integers representing the heights of vertical lines. Returns: int: The maximum amount of water that can be trapped between any two lines. left, right = 0, len(heights) - 1 max_water = 0 while left < right: # Calculate the width (distance between the lines) width = right - left # Calculate the height, which is the smaller of the two lines height = min(heights[left], heights[right]) # Calculate the area current_water = width * height max_water = max(max_water, current_water) # Move the pointers: move the shorter line\'s pointer if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"Given the `head` of a singly linked list, reverse the list, and return the _head of the reversed list_. Each node in the linked list contains a single integer value. Do not use any additional space for another linked list; modify the original list in place to achieve the reversal.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list. Parameters: head (ListNode): The head of the singly linked list to reverse. Returns: ListNode: The head of the reversed singly linked list. prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"Given a `linked list` where each node contains a single digit, represented in reverse order (i.e., the 1\'s digit is at the head of the list), write a function to add two such numbers and return the sum as a linked list, also in reverse order. Each linked list node is defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` For example, given the linked lists (2 -> 4 -> 3) and (5 -> 6 -> 4), the resulting list should be (7 -> 0 -> 8), which represents the number 807 (243 + 564). You must solve it using `O(n)` time complexity and `O(1)` extra space complexity, where `n` is the total number of digits in the two input numbers.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): Adds two numbers represented by linked lists l1 and l2, where each single digit is stored in reverse order. Args: l1 (ListNode): The head of the first linked list. l2 (ListNode): The head of the second linked list. Returns: ListNode: The head of a linked list that represents the sum of the two numbers. dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next"},{"question":"Given a linked list, each node contains an additional random pointer which could point to any node in the list or null. Write a function to clone the linked list with all the `next` and `random` pointers appropriately connected. Return the head of the cloned linked list.","solution":"# Definition for a Node. class Node: def __init__(self, val, next=None, random=None): self.val = val self.next = next self.random = random def clone_linked_list(head): Clones a linked list where each node has an additional random pointer which could point to any node in the list or null. Returns the head of the cloned linked list. if not head: return None # Step 1: Create new nodes and insert them next to the original nodes. current = head while current: new_node = Node(current.val, current.next) current.next = new_node current = new_node.next # Step 2: Set up random pointers for the new nodes. current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the new nodes from the original nodes to get the cloned list. current = head new_head = head.next while current: clone = current.next current.next = clone.next if clone.next: clone.next = clone.next.next current = current.next return new_head"},{"question":"You are given a **0-indexed** integer array `numbers` of size `n` which represents a rotated sorted array and an integer `target`. Return _the index of `target` in the array, or `-1` if it is not present in the array_. The array `numbers` is originally sorted in ascending order and then rotated. A rotated array is created by swapping a series of elements from the beginning of the array with another series from the end of the array. For example, the array `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`. You must use an algorithm with `O(log n)` runtime complexity.","solution":"def search_rotated_sorted_array(numbers, target): Search for target in a rotated sorted array and return its index or -1 if not found. :param numbers: List[int], a rotated sorted array of integers :param target: int, the target integer to find :return: int, the index of target in the array, or -1 if not present low, high = 0, len(numbers) - 1 while low <= high: mid = (low + high) // 2 if numbers[mid] == target: return mid if numbers[low] <= numbers[mid]: # Left portion is sorted if numbers[low] <= target < numbers[mid]: high = mid - 1 else: low = mid + 1 else: # Right portion is sorted if numbers[mid] < target <= numbers[high]: low = mid + 1 else: high = mid - 1 return -1"},{"question":"You are given an integer array `arr` of length `n` that is initially sorted in ascending order, but some elements may have been moved to new indices. Write a function to determine the length of the longest subsequence that can be formed from `arr` which is still sorted in ascending order. Return _the length of the longest sorted subsequence that can be formed._","solution":"def length_of_longest_sorted_subsequence(arr): Returns the length of the longest subsequence in arr that is sorted in ascending order. if not arr: return 0 n = len(arr) # Create an array to store the length of the longest increasing subsequence up to each element lis = [1] * n # Calculate the length of LIS for each element for i in range(1, n): for j in range(0, i): if arr[i] >= arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring is any continuous sequence of characters within the string. The length of a substring is the number of characters it contains. Determine the length of the smallest substring of `s` that contains at least one occurrence of each distinct character present in `s`.","solution":"def smallest_substring_with_all_chars(s): Returns the length of the smallest substring that contains at least one occurrence of each distinct character present in the input string `s`. if not s: return 0 from collections import defaultdict # Step 1: Determine all unique characters in the input string unique_chars = set(s) unique_count = len(unique_chars) # Step 2: Use sliding window technique to find the smallest substring char_count = defaultdict(int) start = 0 min_len = float(\'inf\') formed = 0 for end in range(len(s)): char = s[end] char_count[char] += 1 # If we have what we need for this character if char_count[char] == 1: formed += 1 while formed == unique_count: # Update the minimum length min_len = min(min_len, end - start + 1) # Try to reduce the window size from the left char_count[s[start]] -= 1 if char_count[s[start]] == 0: formed -= 1 start += 1 return min_len"},{"question":"You are given a string `s` consisting of lowercase alphabets. You can perform the following operation on the string: select any character and delete it, but you must pay a cost equal to the alphabetic position of the character (e.g., \'a\' costs 1, \'b\' costs 2, ..., \'z\' costs 26). Your goal is to delete characters from the string to construct the lexicographically smallest string possible that contains no more than `k` distinct characters. Return the lexicographically smallest string you can get by performing the above operation. **Example:** - Input: `s = \\"abcdeedcba\\", k = 2` - Output: `\\"aabb\\"` **Note:** The output string \\"aabb\\" is the smallest possible string containing no more than 2 distinct characters [\'a\', \'b\'], achieved with the minimum total cost.","solution":"def lexicographically_smallest_string(s, k): from collections import Counter # Find the frequency of each character in the string counter = Counter(s) # Sort characters first by frequency (descending), then by lexicographic order (ascending) sorted_chars = sorted(counter.items(), key=lambda x: (-x[1], x[0])) # Select the k most frequent characters selected_chars = sorted_chars[:k] # Construct the resulting string using these characters result_chars = [] for char, freq in sorted(selected_chars, key=lambda x: x[0]): result_chars.extend([char] * freq) return \'\'.join(result_chars)"},{"question":"Given an integer array `arr`, you are allowed to perform only one rightward circular shift on the array. The circular shift involves removing the last element of the array and inserting it at the beginning. Return _the maximum sum of all possible subarrays_ that can be obtained after performing exactly one circular shift. A subarray is defined as a contiguous part of the array.","solution":"def max_subarray_sum_after_one_shift(arr): Returns the maximum sum of all possible subarrays after performing exactly one rightward circular shift on the array. if not arr: return 0 # Perform the circular shift n = len(arr) shifted_arr = [arr[-1]] + arr[:-1] # Function to calculate max subarray sum (Kadane\'s Algorithm) def max_subarray_sum(array): max_ending_here = max_so_far = array[0] for x in array[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far # Calculate max subarray sum of the original and the shifted array original_max_sum = max_subarray_sum(arr) shifted_max_sum = max_subarray_sum(shifted_arr) # Return the maximum of the two return max(original_max_sum, shifted_max_sum)"},{"question":"You are given a list of integers representing prices of identical items over consecutive days. You are allowed to buy and sell the item any number of times to maximize your profit, but you may not engage in multiple transactions simultaneously (you must sell your stock before buying again). Write a function that calculates the maximum profit you can achieve. * For example, given the list of prices `[7, 1, 5, 3, 6, 4]`, the maximum profit is `7`, derived from two transactions: Buy on day 2 (price = 1) and sell on day 3 (price = 5), then buy on day 4 (price = 3) and sell on day 5 (price = 6).","solution":"def max_profit(prices): Calculate the maximum profit that can be achieved from the given list of prices. :param prices: List of integer prices :return: Integer max profit max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i-1]: max_profit += prices[i] - prices[i-1] return max_profit"},{"question":"Given a **0-indexed** integer array `heights` representing the heights of trees planted in a vertical line, determine the maximum number of trees that can be cut so that the remaining trees are in non-decreasing order of their heights from left to right. You can cut any number of trees, but the relative order of the remaining trees should be preserved. Return _the maximum number of trees that can be cut._","solution":"def max_trees_cut(heights): Returns the maximum number of trees that can be cut to ensure the remaining trees are in non-decreasing order of heights. n = len(heights) if n == 0: return 0 # Compute the Longest Increasing Subsequence (LIS) lengths dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the LIS lis_length = max(dp) # The maximum number of trees that can be cut return n - lis_length"},{"question":"Given an integer array `arr`, return the largest integer `k` such that both `k` and `-k` exist in the array. If there is no such integer, return `0`. The function should prioritize positive `k` in case there are multiple candidates.","solution":"def find_largest_k(arr): Returns the largest integer k such that both k and -k exist in the array. If no such integer exists, return 0. num_set = set(arr) largest_k = 0 for num in arr: if -num in num_set: largest_k = max(largest_k, abs(num)) return largest_k"},{"question":"You are given a list of positive integers `nums`. A pair `(i, j)` (i < j) is said to be a **nice pair** if the absolute difference between `nums[i]` and `nums[j]` is exactly `1`. Your task is to count the number of **nice pairs** in the list. For example, given `nums = [1, 2, 3, 4]`, the nice pairs are `(0, 1)`, `(1, 2)`, `(2, 3)` with values `[1, 2]`, `[2, 3]`, `[3, 4]` respectively. Therefore, the answer is `3`. Return _the count of nice pairs in_ `nums`.","solution":"def count_nice_pairs(nums): Count the number of nice pairs in the list nums. A pair (i, j) is nice if abs(nums[i] - nums[j]) == 1 and i < j. Parameters: nums (list of int): The list of positive integers. Returns: int: The count of nice pairs. count = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if abs(nums[i] - nums[j]) == 1: count += 1 return count"},{"question":"Given an integer `n`, return a list of strings representing the numbers from 1 to n. But for multiples of three, return \\"Fizz\\" instead of the number and for the multiples of five, return \\"Buzz\\". For numbers which are multiples of both three and five, return \\"FizzBuzz\\".","solution":"def fizz_buzz(n): Returns a list of strings representing the numbers from 1 to n. But for multiples of three, returns \\"Fizz\\" instead of the number and for the multiples of five, returns \\"Buzz\\". For numbers which are multiples of both three and five, returns \\"FizzBuzz\\". result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"An underwater research lab needs to monitor marine life activity over several observation spots positioned in a grid. You are given an `m x n` grid representing the observation field, where each cell contains an integer that indicates the type of marine life observed at that spot (different integers represent different types). The lab wishes to analyze the diversity of marine life observed in a rectangular sub-grid over multiple observations. To facilitate this, you are given several queries, each specifying a sub-grid within the main grid. Each query consists of four integers `[r1, c1, r2, c2]`, representing the top-left cell `(r1, c1)` and the bottom-right cell `(r2, c2)` of the sub-grid. For each query, return _the number of **distinct** types of marine life in the specified sub-grid_.","solution":"def distinct_marine_life_types(grid, queries): Returns the number of distinct types of marine life for each sub-grid specified in queries. :param grid: List of lists containing integers representing marine life types. :param queries: List of lists where each inner list consists of four integers [r1, c1, r2, c2]. :return: List of integers, each representing the number of distinct types of marine life in the sub-grid. results = [] for r1, c1, r2, c2 in queries: unique_types = set() for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): unique_types.add(grid[i][j]) results.append(len(unique_types)) return results"},{"question":"You are given a list `logs` where `logs[i] = [start_i, end_i]` represent the start and end times of server requests in seconds. Your goal is to return the minimum number of servers required to handle all the requests without any overlap in processing time. Each server can only handle one request at a time but can handle multiple requests sequentially.","solution":"def min_servers_required(logs): Returns the minimum number of servers required to handle all the requests without any overlap. # Create separate lists for start and end times start_times = sorted([log[0] for log in logs]) end_times = sorted([log[1] for log in logs]) server_count = 0 max_servers = 0 i, j = 0, 0 # Use two pointers to traverse the start and end times while i < len(start_times) and j < len(end_times): if start_times[i] < end_times[j]: server_count += 1 max_servers = max(max_servers, server_count) i += 1 else: server_count -= 1 j += 1 return max_servers"},{"question":"Given an integer array `arr` and an integer `k`, you need to find a contiguous subarray whose length is exactly `k` and has the maximum average value. Return the maximum average value. If there are multiple subarrays with the same maximum average, you can return any one of them. Make sure to handle edge cases where the input array might be small or contain negative numbers.","solution":"def find_max_average(arr, k): Finds the maximum average value of any contiguous subarray of length \'k\'. if not arr or k <= 0 or k > len(arr): raise ValueError(\\"Invalid input parameters\\") # Compute the sum of the first \'k\' elements current_sum = sum(arr[:k]) max_sum = current_sum # Traverse through the array for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] if current_sum > max_sum: max_sum = current_sum # Return the maximum average value return max_sum / k"},{"question":"Given an array of integers `arr`, your task is to find the maximum sum of consecutive subarrays of a given length `k`. For example, if the array is `[1, 2, 3, 4, 5, 6]` and `k` is `3`, the subarrays of length `k` are `[1, 2, 3]`, `[2, 3, 4]`, `[3, 4, 5]`, and `[4, 5, 6]`. The sums of these subarrays are `6`, `9`, `12`, and `15` respectively, so the answer would be `15`. Write a function that takes an array `arr` and an integer `k` as input, and returns the maximum sum of any subarray of length `k`.","solution":"def max_sum_of_subarrays(arr, k): Returns the maximum sum of any consecutive subarray of length k. if len(arr) < k or k <= 0: return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of integers `arr` and an integer `k`, write a function that partitions the array into `k` contiguous subarrays such that the difference between the maximum and minimum sum of these subarrays is minimized. Return the minimized difference.","solution":"def min_difference_partition(arr, k): def can_partition(max_sum): current_sum = 0 required_partitions = 1 for num in arr: if current_sum + num > max_sum: required_partitions += 1 current_sum = num if required_partitions > k: return False else: current_sum += num return True low = max(arr) high = sum(arr) result = high while low <= high: mid = (low + high) // 2 if can_partition(mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"You are given an array of integers `nums` and an integer `target`. Write a function that finds all unique pairs of integers in the array whose sum equals the given `target`. Each pair should be represented as an array `[num1, num2]`, where `num1` <= `num2`. The result array should be sorted in non-descending order of pairs first by `num1` and then by `num2`. If no such pairs exist, return an empty array. Your solution should have a time complexity of `O(n log n)`.","solution":"def find_pairs(nums, target): Finds all unique pairs of integers in the array `nums` whose sum equals `target`. Each pair is sorted internally (num1 <= num2), and the output is sorted by `num1` and then by `num2`. Parameters: nums (list): A list of integers. target (int): The target sum. Returns: list: A list of unique pairs sorted as per the criteria. nums.sort() result = [] seen = set() i, j = 0, len(nums) - 1 while i < j: current_sum = nums[i] + nums[j] if current_sum == target: if (nums[i], nums[j]) not in seen: result.append([nums[i], nums[j]]) seen.add((nums[i], nums[j])) i += 1 j -= 1 elif current_sum < target: i += 1 else: j -= 1 return result"},{"question":"On a 2D plane, you are given an array of coordinates where each coordinate represents a point `(x, y)`. Define a **triplet** as a set of three points in the array. A triplet forms a **valid triangle** if the area of the triangle formed by the three points is non-zero. Given an array of `points` where each element is a coordinate `[x, y]`, return _the number of valid triangles that can be formed_ using the points in the array. Note: The area of a triangle with vertices at `(x1, y1)`, `(x2, y2)`, and `(x3, y3)` can be calculated using the determinant formula: [ text{Area} = 0.5 times | x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2) | ] A triangle is valid if, and only if, its area is non-zero.","solution":"from itertools import combinations def valid_triangles_count(points): Returns the number of valid triangles that can be formed from the given points. def area(x1, y1, x2, y2, x3, y3): return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0 count = 0 for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3): if area(x1, y1, x2, y2, x3, y3) > 0: count += 1 return count # Test cases points1 = [[0, 0], [0, 1], [1, 0], [1, 1]] # 4 valid triangles: \\"4 choose 3\\" points2 = [[0, 0], [1, 1], [2, 2]] # Collinear, no valid triangles points3 = [[1, 1], [2, 4], [5, 6], [7, 8], [4, 7]] # Should have several valid triangles result1 = valid_triangles_count(points1) result2 = valid_triangles_count(points2) result3 = valid_triangles_count(points3) print(result1, result2, result3)"},{"question":"You are given a 2D matrix `grid` of size `m x n` with non-negative integers. Perform the following operations on the matrix: 1. Increment all elements in a specified row by a given value. 2. Increment all elements in a specified column by a given value. After performing these operations, calculate the sum of the elements in the matrix. Write a function that takes in the initial grid, a list of row operations, and a list of column operations, and returns the sum of the elements in the matrix after all operations have been applied. Example input: ```grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] row_operations = [(0, 10), (2, -5)] column_operations = [(1, 3), (2, 2)]``` The first tuple in `row_operations` indicates that all elements in row 0 should be incremented by 10. The first tuple in `column_operations` indicates that all elements in column 1 should be incremented by 3, and so on. Return the final sum of the elements in the matrix.","solution":"def apply_operations(grid, row_operations, column_operations): Apply row and column operations to the grid and return the final sum. Args: grid (list of list of int): initial grid of size m x n with non-negative integers. row_operations (list of tuple): list containing tuples of (row_index, increment_value). column_operations (list of tuple): list containing tuples of (column_index, increment_value). Returns: int: sum of all elements in the matrix after performing the operations. # Apply row operations for (row, increment) in row_operations: for col in range(len(grid[0])): grid[row][col] += increment # Apply column operations for (col, increment) in column_operations: for row in range(len(grid)): grid[row][col] += increment # Calculate the sum of all elements in the grid total_sum = sum(sum(row) for row in grid) return total_sum"},{"question":"You are given a string `s` consisting of lowercase English letters, where the length of `s` is at most `10^5`. Your task is to transform `s` into a new string `t` by performing the following operations: 1. Choose any character from `s` and move it to the end of `t`. 2. Replace any character in `s` with another lowercase English letter. You want to construct the lexicographically smallest string `t` after performing at most `k` operations. Return _the lexicographically smallest string `t` you can obtain after performing at most `k` operations_ on `s`.","solution":"def get_lexicographically_smallest_string(s, k): if k == 1: # For k == 1, we can only rotate the string to get the lexicographically smallest string smallest_str = s for i in range(1, len(s)): rotated_str = s[i:] + s[:i] if rotated_str < smallest_str: smallest_str = rotated_str return smallest_str else: # For k > 1, replacing characters allows us to sort the string directly return \'\'.join(sorted(s))"},{"question":"You are given two integer arrays `startTime` and `endTime`, each of length `n`, representing the start and end times of `n` meetings. A meeting `i` starts at `startTime[i]` and ends at `endTime[i]`. You need to find the minimum number of meeting rooms required to host all the meetings. Each meeting room can accommodate only one meeting at any given time slot. The meetings may overlap with each other. Return the minimum number of meeting rooms required.","solution":"def minMeetingRooms(startTime, endTime): Returns the minimum number of meeting rooms required to host all the meetings. if not startTime or not endTime or len(startTime) != len(endTime): return 0 # Sort the start and end times startTime.sort() endTime.sort() start_pointer = 0 end_pointer = 0 used_rooms = 0 max_rooms = 0 while start_pointer < len(startTime): # If the meeting starts before the earliest ending meeting ends, we need a new room. if startTime[start_pointer] < endTime[end_pointer]: used_rooms += 1 start_pointer += 1 else: # Otherwise, free up a room and move the end_pointer to the next earliest ending meeting. used_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"You are given an array `requests` of length `n` where `requests[i] = [starti, endi]` represents a request to book a meeting room for a time interval that starts at `starti` and ends at `endi` (both **inclusive**). You have a single meeting room and you need to accommodate as many requests as possible without any overlapping meetings. Return _the **maximum number** of non-overlapping requests that can be accommodated_.","solution":"def max_non_overlapping_requests(requests): Returns the maximum number of non-overlapping requests that can be accommodated. Args: requests : List[List[int]] A list of requests where each request is a list [starti, endi] Returns: int The maximum number of non-overlapping requests if not requests: return 0 # Sort the requests based on their end time sorted_requests = sorted(requests, key=lambda x: x[1]) count = 0 end_time = float(\'-inf\') for request in sorted_requests: if request[0] > end_time: count += 1 end_time = request[1] return count"},{"question":"Given a sorted array `nums` of distinct integers, return the lowest index of any peak element, where a peak element is one that is greater than its neighbors. If the element is at the boundary of the array, consider only the one neighbor. For example, given the array `[1,2,3,1]`, the peak element is `3` at index `2` because it is greater than both `2` and `1`. For the array `[1,2,1,3,5,6,4]`, the peak elements are `2` and `6` corresponding to indices `1` and `5` respectively, and thus the lowest index is `1`. Return the index of any peak element.","solution":"def find_peak_element(nums): Finds the index of any peak element in a sorted array of distinct integers. A peak element is one that is greater than its neighbors. :param nums: List[int], a sorted array of distinct integers :return: int, the index of a peak element left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given a list of integers `arr`, representing the height of hurdles in a hurdle race. You are also given a maximum height `k` that the racer can jump naturally. The racer can consume a special magic potion that allows them to increase their maximum jump height by 1 unit per potion consumed. Determine the minimum number of potions required for the racer to be able to clear all the hurdles in the race. If the racer can already clear all hurdles naturally, return `0`.","solution":"def min_potions_needed(arr, k): Determines the minimum number of potions needed for the racer to clear all hurdles. Parameters: arr (list): A list of integers representing the heights of the hurdles. k (int): The maximum height the racer can jump naturally. Returns: int: The minimum number of potions required. max_hurdle = max(arr) if k >= max_hurdle: return 0 return max_hurdle - k"},{"question":"Given an array `arr` of integers and an integer `k`, your task is to split the array into exactly `k` non-empty subarrays. Write a function that returns the minimum largest sum among these `k` subarrays. A subarray is a contiguous part of the array. For example, given the array `arr = [7, 2, 5, 10, 8]` and `k = 2`, splitting the array into `[7, 2, 5]` and `[10, 8]` results in the minimum largest sum being `18`, since 18 is the largest sum among the subarrays, and no other way of splitting the array results in a smaller largest sum.","solution":"def split_array_min_largest_sum(arr, k): def can_split(mid): count, current_sum = 1, 0 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > k: return False else: current_sum += num return True low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if can_split(mid): high = mid else: low = mid + 1 return low"},{"question":"You are given a **rotated sorted array** of unique elements, where the array was originally sorted in ascending order but then some number of positions were shifted to the right. You are also given a target value to search. Write a function to find the index of the target value in the rotated array. If the target is not found, return `-1`. Your algorithm must have O(log n) runtime complexity. The array has the following definition: ```python def search(nums: List[int], target: int) -> int: pass ``` For example, given the array `nums = [4,5,6,7,0,1,2]` and target `0`, your function should return `4`.","solution":"from typing import List def search(nums: List[int], target: int) -> int: Searches for a target value in a rotated sorted array and returns its index. If the target is not found, returns -1. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid # Determine which side is sorted if nums[left] <= nums[mid]: # Left side is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right side is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given a **linked list** where each node contains an integer data field and a next pointer. However, instead of having just a next pointer, each node has two pointers `N` and `R`, where `N` points to the next node in the list and `R` can point to any other node in the linked list or be `null`. Your task is to create a function that takes the head of the linked list and returns a deep copy of the list. The deep copy should have the same structure, including both `N` and `R` pointers. Return _the head of the deep copied linked list_.","solution":"class ListNode: def __init__(self, data=0, N=None, R=None): self.data = data self.N = N self.R = R def copy_list_with_random_pointer(head): if not head: return None # Creating a mapping from original nodes to their copies node_map = {} # Step 1: Copy all the nodes and store them in the hash map current = head while current: node_map[current] = ListNode(current.data) current = current.N # Step 2: Assign next (N) and random (R) pointers current = head while current: if current.N: node_map[current].N = node_map[current.N] if current.R: node_map[current].R = node_map[current.R] current = current.N # Return the head of the copied list return node_map[head]"},{"question":"You are given a **0-indexed** array of positive integers `heights` where `heights[i]` represents the height of the `i-th` building. A building is considered to have a **good view** if the height of the building is greater than or equal to the height of every other building that comes after it in the array. Return an array of indices of all buildings that have a **good view** sorted in increasing order. Ensure your solution works within an O(n) time complexity.","solution":"def good_view_buildings(heights): Returns the indices of buildings with a good view. A building has a good view if its height is greater than or equal to the height of every other building that comes after it in the array. n = len(heights) good_view_indices = [] max_height = 0 for i in range(n - 1, -1, -1): if heights[i] >= max_height: good_view_indices.append(i) max_height = heights[i] return good_view_indices[::-1]"},{"question":"Given a `string`, write a function to determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. A palindrome is a word, phrase, or sequence that reads the same backward as forward (ignoring spaces, punctuation, and capitalization). Return `true` if the input string is a palindrome; otherwise, return `false`.","solution":"def is_palindrome(s): Checks whether the given string is a palindrome, considering only alphanumeric characters and ignoring cases. Args: s (str): input string to check Returns: bool: True if s is a palindrome, False otherwise # Convert to lower case and filter only alphanumeric characters filtered_s = \'\'.join(char.lower() for char in s if char.isalnum()) # Compare filtered string with its reverse return filtered_s == filtered_s[::-1]"},{"question":"You are given an array of intervals where intervals[i] = [start_i, end_i] representing the start and end times of the ith working interval. Merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the time periods covered by the input. For example, suppose the input intervals are [[1,3],[2,6],[8,10],[15,18]]. The output should be [[1,6],[8,10],[15,18]] because the first two intervals overlap, and can be merged into the interval [1,6].","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of non-overlapping intervals. Args: intervals (List[List[int]]): A list of intervals [start, end]. Returns: List[List[int]]: A list of merged non-overlapping intervals. if not intervals: return [] # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals"},{"question":"You are given a matrix of size `m x n` containing non-negative integers. The goal is to traverse the matrix from the top-left corner to the bottom-right corner such that you can only move either down or right at any point in time. Return the maximum sum of the values along any such path from the top-left corner to the bottom-right corner.","solution":"def max_path_sum(matrix): Returns the maximum sum of values along any path from the top-left corner to the bottom-right corner, moving only down or right at any point in time. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"Given a string `s` containing letters and digits, group all the digits on the left side of the string (in the order they appear) and all the letters on the right side of the string (in the order they appear). Return the resulting string.","solution":"def group_digits_and_letters(s): Returns a string with all digits grouped on the left and all letters grouped on the right. Parameters: s (str): Input string containing letters and digits. Returns: str: The resulting string with digits on the left and letters on the right. digits = \'\'.join([char for char in s if char.isdigit()]) letters = \'\'.join([char for char in s if char.isalpha()]) return digits + letters"},{"question":"You are given a binary tree where each node contains an integer value. Implement a class that supports the following query and update operations efficiently: 1. **Query** the sum of all values in a specified range of node depths. 2. **Update** the value of a specific node in the tree. Implement the `BinaryTreeQueries` class: * `BinaryTreeQueries(TreeNode root)` initializes the `BinaryTreeQueries` object with the given binary tree `root`. * `int rangeSum(int depth1, int depth2)` returns the sum of the values of nodes whose depth lies between `depth1` and `depth2` (inclusive). * `void updateValue(TreeNode node, int val)` updates the value of the given `node` to `val`. Note: A node\'s depth is the number of edges from the node to the tree\'s root node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeQueries: def __init__(self, root): self.root = root self.depth_sum = {} self._dfs(root, 0) def _dfs(self, node, depth): if node is None: return if depth not in self.depth_sum: self.depth_sum[depth] = 0 self.depth_sum[depth] += node.val self._dfs(node.left, depth + 1) self._dfs(node.right, depth + 1) def rangeSum(self, depth1, depth2): total_sum = 0 for depth in range(depth1, depth2 + 1): if depth in self.depth_sum: total_sum += self.depth_sum[depth] return total_sum def updateValue(self, node, val): def find_depth_and_update(node, cur_depth, target_node, target_val): if node is None: return -1 if node is target_node: node.val = target_val return cur_depth left_depth = find_depth_and_update(node.left, cur_depth + 1, target_node, target_val) right_depth = find_depth_and_update(node.right, cur_depth + 1, target_node, target_val) if left_depth != -1: return left_depth return right_depth node_depth = find_depth_and_update(self.root, 0, node, val) if node_depth != -1: self.update_depth_sum(node_depth) def update_depth_sum(self, depth): self.depth_sum[depth] = self.calculate_sum_at_depth(self.root, 0, depth) def calculate_sum_at_depth(self, node, cur_depth, target_depth): if node is None: return 0 if cur_depth == target_depth: return node.val left_sum = self.calculate_sum_at_depth(node.left, cur_depth + 1, target_depth) right_sum = self.calculate_sum_at_depth(node.right, cur_depth + 1, target_depth) return left_sum + right_sum"},{"question":"**[Question 4]: Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`. You have the following three operations permitted on a word:** - Insert a character - Delete a character - Replace a character Minimum operations are defined as the minimum number of insertions, deletions, and substitutions needed to transform one string into another. **For example**, to convert the string \\"horse\\" to \\"ros\\": - Replace \'h\' with \'r\' - Delete \'o\' - Delete \'s\' Thus, the minimum number of operations required is 3.","solution":"def min_distance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. m, n = len(word1), len(word2) # Initialize a dp array with dimensions (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases: transforming an empty string to the other string for i in range(1, m + 1): dp[i][0] = i # delete all characters from word1 to match an empty word2 for j in range(1, n + 1): dp[0][j] = j # insert all characters to match word2 from an empty word1 # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: # If the characters are same, no more operations needed on this character dp[i][j] = dp[i - 1][j - 1] else: # If characters are different, consider insert, delete, and replace operations dp[i][j] = 1 + min(dp[i - 1][j], # delete operation dp[i][j - 1], # insert operation dp[i - 1][j - 1]) # replace operation return dp[m][n]"},{"question":"You have a grid with `n` rows and `m` columns represented by a 2D integer array `grid`. Each cell in the grid contains an integer that represents the **elevation** at that point. Your goal is to find the **maximum elevation difference** between any two cells in the grid that can be reached by only moving **up, down, left**, or **right** such that the path between these two cells only includes cells with **equal or increasing elevations**. Return _the maximum elevation difference_. For example, given the following grid: ``` [[1, 2, 2, 3], [2, 4, 5, 3], [3, 5, 6, 6], [4, 4, 4, 4]] ``` The cells with elevations `1` and `6` can be connected through a valid path, and the elevation difference is `5`. Thus, the function should return `5`. If no such path exists or the grid is empty, return `0`.","solution":"def maximum_elevation_difference(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) max_elevation = -float(\'inf\') min_elevation = float(\'inf\') visited = [[False] * m for _ in range(n)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y, current_min, current_max): nonlocal max_elevation, min_elevation if visited[x][y]: return visited[x][y] = True current_min = min(current_min, grid[x][y]) current_max = max(current_max, grid[x][y]) max_elevation = max(max_elevation, current_max) min_elevation = min(min_elevation, current_min) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] >= grid[x][y]: dfs(nx, ny, current_min, current_max) for i in range(n): for j in range(m): if not visited[i][j]: dfs(i, j, grid[i][j], grid[i][j]) return max_elevation - min_elevation if max_elevation != -float(\'inf\') and min_elevation != float(\'inf\') else 0"},{"question":"You are given two strings, `s` and `t.` String `t` is generated by randomly shuffling string `s` and then adding one more letter at a random position. Write a function that finds the letter that was added in `t`. Return the letter that was added. You can assume that the strings contain only lowercase letters.","solution":"def find_the_difference(s, t): Find the letter that was added in string t. Args: s (str): Original string. t (str): Modified string with one additional letter. Returns: char: The letter that was added. char_count = {} for char in t: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s: char_count[char] -= 1 for char in char_count: if char_count[char] == 1: return char"},{"question":"You are given a list of `projects` and a list of `dependencies`. Each `project` is represented by an uppercase letter, and each `dependency` is represented as a pair `[a, b]`, which means project `b` depends on project `a` and cannot start before project `a` is completed. Write a function that finds an order in which to complete the given projects. If there are multiple valid outputs, return any of them. If it is impossible to finish all the projects, return an empty list.","solution":"from collections import defaultdict, deque def find_project_order(projects, dependencies): Finds an order to complete the given projects based on their dependencies. :param projects: List of projects represented by uppercase letters. :param dependencies: List of dependencies represented by pairs [a, b]. Project b depends on project a. :return: A list representing the order in which to complete the projects. # Build the graph and in-degree map graph = defaultdict(list) in_degree = {project: 0 for project in projects} for dependency in dependencies: a, b = dependency graph[a].append(b) in_degree[b] += 1 # Queue for projects with no incoming edges queue = deque([project for project in projects if in_degree[project] == 0]) order = [] while queue: project = queue.popleft() order.append(project) for neighbor in graph[project]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return order if len(order) == len(projects) else []"},{"question":"You are given an integer array `levels` representing the skill levels of `n` students in a coding class. Your task is to pair the students into teams of exactly two members each. A team\'s effectiveness is the sum of the skill levels of its two members. Return _the maximum possible effectiveness of the weakest team among all possible team pairings_.","solution":"def max_min_team_effectiveness(levels): Returns the maximum possible effectiveness of the weakest team among all possible team pairings. :param levels: List[int], a list of skill levels. :return: int, the maximum possible effectiveness of the weakest team. levels.sort() n = len(levels) max_min_effectiveness = float(\'-inf\') for i in range(n // 2): team_effectiveness = levels[i] + levels[-(i+1)] max_min_effectiveness = max(max_min_effectiveness, team_effectiveness) return max_min_effectiveness"},{"question":"You are given an integer array `times` where `times[i]` represents the time needed to complete the `i-th` task. There are two workers and each worker can only work on one task at a time. Your goal is to find the minimum possible time needed to complete all tasks using both workers. Return _the minimum possible time_.","solution":"def min_completion_time(times): Returns the minimum possible time needed to complete all tasks using two workers. :param times: List[int] - An array of integers where times[i] is the time needed to complete the i-th task :return: int - The minimum time needed to complete all tasks times.sort(reverse=True) worker1 = 0 worker2 = 0 for time in times: if worker1 <= worker2: worker1 += time else: worker2 += time return max(worker1, worker2)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` containing unique integers, where each integer in `nums` is a value within the range `[0, n-1]`. However, one integer within this range is missing from the array. Write a function that finds the missing integer from the array and returns it.","solution":"def find_missing_number(nums): Given a list of numbers from 0 to n-1 with one missing, this function returns the missing number. n = len(nums) total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"You have an array `nums` of integers, representing the number of customers entering a shop at different times of the day. A segment `[i, j]` of this array, where `0 <= i <= j < nums.length`, is considered an \\"active period\\" if the sum of elements in this segment is more than a given threshold `T`. Write a function that takes an array `nums` and an integer `T`, and returns the total number of active periods in the array. Note that different segments with the same sum still count as separate active periods.","solution":"def count_active_periods(nums, T): Returns the total number of active periods in the array where the sum is greater than the threshold T. :param nums: List[int] :param T: int :return: int n = len(nums) active_periods = 0 for i in range(n): current_sum = 0 for j in range(i, n): current_sum += nums[j] if current_sum > T: active_periods += 1 return active_periods"},{"question":"You are given a list of `n` integers `nums` representing the scores of multiple players. Your task is to partition the list into exactly `k` contiguous subarrays such that the largest sum among these `k` subarrays is minimized. Return the minimized largest sum. Note that each player must be assigned to one of the `k` subarrays and every subarray must contain at least one player.","solution":"def splitArray(nums, k): def canSplit(nums, k, max_sum): count, current_sum = 1, 0 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canSplit(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"Given the `root` of a binary tree, implement a method to calculate the **level order traversal**, also known as **breadth-first traversal**, of the tree nodes. The traversal should be returned as a list of lists, where each list contains the nodes at a given level, from left to right and from top to bottom. Implement the function `levelOrderTraversal(root: TreeNode) -> List[List[int]]`. Each `TreeNode` has the following definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Example:** ``` Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] ``` In this case, the tree structure is: ``` 3 / 9 20 / 15 7 ``` **Constraints:** * The number of nodes in the tree is in the range `[0, 2000]`. * `-1000 <= Node.val <= 1000`.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"Design an algorithm to serialize and deserialize a **binary tree**. Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. You need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.","solution":"import json class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. :type root: TreeNode :rtype: str def helper(node): if node is None: return None return [node.val, helper(node.left), helper(node.right)] return json.dumps(helper(root)) def deserialize(data): Decodes your encoded data to tree. :type data: str :rtype: TreeNode def helper(nodes): if nodes is None: return None val, left, right = nodes node = TreeNode(val) node.left = helper(left) node.right = helper(right) return node return helper(json.loads(data))"},{"question":"Write a function that takes an unsorted list of integers and returns the length of the longest consecutive elements sequence. The consecutive elements sequence must be made up of elements from the list, and they must be contiguous integers. For example, given the list `nums = [100, 4, 200, 1, 3, 2]`, the function should return `4`, as the longest consecutive elements sequence is `[1, 2, 3, 4]`.","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence in an unsorted list of integers. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if (num - 1) not in num_set: current_num = num current_streak = 1 while (current_num + 1) in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Write a function that takes a list of integers representing the heights of buildings standing in a row and returns a list of integers representing the amount of sunlight each building receives. A building blocks sunlight for itself and any building to its right that is of an equal or lesser height. Assume the sunlight comes from the left side, i.e., from the direction of the list start. Function signature: `def calculate_sunlight(buildings: List[int]) -> List[int]` * The function should take a single list of integers, where each integer represents the height of a building. * The function should return a list of integers, where each integer is either 1 (if the building receives sunlight) or 0 (if it\'s blocked by another building).","solution":"from typing import List def calculate_sunlight(buildings: List[int]) -> List[int]: Returns a list of integers representing the amount of sunlight each building receives. A building blocks sunlight for itself and any building to its right that is of an equal or lesser height. :param buildings: List[int] - List of integers representing heights of buildings :return: List[int] - List of integers: 1 if building receives sunlight, 0 otherwise sunlight = [] max_height = 0 # Track the tallest building seen from the left for height in buildings: if height > max_height: sunlight.append(1) max_height = height else: sunlight.append(0) return sunlight"},{"question":"Implement a `StreamChecker` class that checks if a stream of characters given one by one contains any suffix from a given list of words. Each call to the method `query(char letter)` will return `true` if any suffix of the stream formed so far matches a word in the given list. The `StreamChecker` class should be implemented as follows: - `StreamChecker(String[] words)`: This initializes the object with a given list of words. - `boolean query(char letter)`: This returns `true` if any suffix of the stream formed by adding `letter` matches any word in the list. Otherwise, it returns `false`. By maintaining consistency with style, length, difficulty, and topic with the given questions, this integrates seamlessly into the set.","solution":"class StreamChecker: def __init__(self, words): self.trie = {} self.stream = [] for word in words: node = self.trie for char in word[::-1]: if char not in node: node[char] = {} node = node[char] node[\'\'] = True def query(self, letter): self.stream.append(letter) node = self.trie for char in reversed(self.stream): if \'\' in node: return True if char not in node: return False node = node[char] return \'\' in node"},{"question":"You are given a string `s` consisting of lowercase English letters and a pattern string `p` also consisting of lowercase English letters. Your task is to determine if `p` can be found as a contiguous substring in `s` after replacing a specified number of characters in `s` with any character. Specifically, given the integers `k` and `m`, check if there is a substring of `s` of length `k` such that you can replace up to `m` characters in this substring to make `p` appear as a contiguous substring within `s`. Write a function `canTransform(s: str, p: str, k: int, m: int) -> bool` that returns `True` if `p` can be formed in `s` by making at most `m` replacements in a substring of length `k`, otherwise, return `False`.","solution":"def canTransform(s: str, p: str, k: int, m: int) -> bool: Determines if the pattern `p` can be found as a contiguous substring in `s` after replacing up to `m` characters in a substring of length `k` of `s`. Parameters: s (str): the string in which to search for the pattern p (str): the pattern string to search for k (int): length of the substring of `s` to consider m (int): maximum number of character replacements allowed Returns: bool: True if the pattern can be formed, False otherwise n = len(s) len_p = len(p) for i in range(n - k + 1): substring = s[i:i + k] for j in range(k - len_p + 1): window = substring[j:j + len_p] replacements = sum(1 for x, y in zip(window, p) if x != y) if replacements <= m: return True return False"},{"question":"You are given a list of intervals where each interval is a pair of integers `[start, end]` representing the start and end times of a meeting. Write a function to determine the minimum number of meeting rooms required to hold all the meetings. Each meeting is represented as a tuple of two integers `(start, end)` where `start` is the start time and `end` the end time of the meeting. Meetings may overlap or coincide, and you need to allocate the minimum number of meeting rooms so that no two meetings, which overlap, occur in the same room. For example: ``` Input: [[0, 30], [5, 10], [15, 20]] Output: 2 Explanation: Two meetings [0, 30] and [5, 10] overlap, requiring separate rooms. ``` enerate the complexity of concepts, algorithms, or programming techniques required","solution":"def min_meeting_rooms(intervals): Determines the minimum number of meeting rooms required to hold all the meetings. Parameters: intervals (List[List[int]]): A list of meeting intervals where each interval is [start, end]. Returns: int: Minimum number of meeting rooms required. if not intervals: return 0 # Separate out the start and end times in their own lists. start_times = sorted(interval[0] for interval in intervals) end_times = sorted(interval[1] for interval in intervals) start_pointer = 0 end_pointer = 0 used_rooms = 0 # Iterate over meetings while start_pointer < len(intervals): # If there is a meeting that starts before the one that ends, we need a new room if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: # Otherwise, we can use a room that has been freed up end_pointer += 1 start_pointer += 1 return used_rooms"},{"question":"Given a binary tree, return the **inorder traversal** of its nodes\' values. An **inorder traversal** is a depth-first traversal where the nodes are recursively visited in the following order: left child, current node, right child.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root): Returns the inorder traversal of a binary tree\'s nodes\' values. :param root: Root node of the binary tree :return: A list of node values in inorder traversal order res = [] def inorder(node): if node: inorder(node.left) res.append(node.val) inorder(node.right) inorder(root) return res"},{"question":"You are given an integer array `arr` representing the heights of blocks in a row. A water drop falls on the leftmost block and can only move to the right. The water drop can only fall to a block that has a height less than or equal to the current block it is on. Return _the **maximum distance** the water drop can travel from the leftmost block to the right along the row_. If it cannot move at all, return 0.","solution":"def max_distance(arr): Returns the maximum distance the water drop can travel from the leftmost block to the right along the row. :param arr: List[int] representing the heights of blocks in a row :return: int representing the maximum distance the water drop can travel max_dist = 0 current_pos = 0 # Traverse the array and find the maximum distance the water drop can travel for i in range(1, len(arr)): if arr[i] <= arr[current_pos]: max_dist = i current_pos = i return max_dist"},{"question":"Given a non-empty array of integers `nums` representing the preorder traversal of a binary search tree (BST), construct the BST and return the root of the tree. For example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder): Constructs a binary search tree (BST) from the given preorder traversal list. :param preorder: List[int] - The preorder traversal of the BST :return: TreeNode - The root of the constructed BST if not preorder: return None root = TreeNode(preorder[0]) stack = [root] for value in preorder[1:]: node, child = stack[-1], TreeNode(value) # Adjust the right child of the stack elements while stack and stack[-1].val < value: node = stack.pop() if node.val < value: node.right = child else: node.left = child stack.append(child) return root"},{"question":"Given an integer array `nums` sorted in non-decreasing order, and an integer `target`, return _a list of unique pairs (a, b)_ such that `a + b` equals `target`. Each pair (a, b) in the returned list must be ordered such that `a <= b` and pairs themselves must be sorted in ascending order. If no such pairs exist, return an empty list. You must ensure that each pair is only returned once.","solution":"def find_pairs(nums, target): Given an array of integers nums sorted in non-decreasing order, and a target integer, returns a list of unique pairs (a, b) such that a + b equals target. Each pair (a, b) in the returned list is ordered such that a <= b and pairs themselves are sorted in ascending order. pairs = [] seen = set() left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: if (nums[left], nums[right]) not in seen: pairs.append((nums[left], nums[right])) seen.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return pairs"},{"question":"You are given a string `s` of length `n`, consisting of the characters `\'a\'`, `\'b\'`, and `\'c\'` only. You are allowed to perform operations on the string to replace any character with any other character among `\'a\'`, `\'b\'`, and `\'c\'`. The goal is to transform the string so that no two adjacent characters are the same. Return _the **minimum** number of character replacements_ needed to achieve this transformation.","solution":"def minimum_replacements(s: str) -> int: Returns the minimum number of character replacements needed so that no two adjacent characters are the same. Parameters: s (str): The input string consisting of \'a\', \'b\', and \'c\' only. Returns: int: The minimum number of replacements required. replacements = 0 n = len(s) for i in range(1, n): if s[i] == s[i - 1]: replacements += 1 # Replace current character with one that is different from the next character or previous character s = s[:i] + (\'b\' if s[i - 1] != \'b\' and (i == n - 1 or s[i + 1] != \'b\') else \'a\') + s[i + 1:] return replacements"},{"question":"You are given a **0-indexed** integer array `nums` where the elements are unique. Your task is to return a **new array** of the same length `new_nums` such that `new_nums[i]` is the **count** of numbers in `nums` that are **less** than `nums[i]`. Implement a function that computes this new array. For example, if `nums = [8, 1, 2, 2, 3]`, then the resulting array `new_nums` would be `[4, 0, 1, 1, 3]` because: - There are 4 numbers less than `8` in `nums`. - There are 0 numbers less than `1` in `nums`. - There is 1 number less than `2` in `nums` (twice). - There are 3 numbers less than `3` in `nums`. Return _the resulting array_ `new_nums`.","solution":"def count_less_than(nums): Given a 0-indexed integer array nums where the elements are unique, returns a new array such that new_nums[i] is the count of numbers in nums less than nums[i]. return [sum(1 for y in nums if y < x) for x in nums]"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to determine the length of the longest substring of `s` where each vowel (\'a\', \'e\', \'i\', \'o\', \'u\') appears an even number of times. Return _an integer representing the length of the longest such substring._","solution":"def find_the_longest_substring(s): Returns the length of the longest substring where each vowel (\'a\', \'e\', \'i\', \'o\', \'u\') appears an even number of times. n = len(s) # Vowel to the corresponding bit in the bitmask vowel_to_bit = {\'a\': 1, \'e\': 2, \'i\': 4, \'o\': 8, \'u\': 16} # A dictionary to store the first occurrence of every bitmask prefix_indices = {0: -1} current_mask = 0 max_length = 0 for i, ch in enumerate(s): if ch in vowel_to_bit: current_mask ^= vowel_to_bit[ch] if current_mask not in prefix_indices: prefix_indices[current_mask] = i if current_mask in prefix_indices: max_length = max(max_length, i - prefix_indices[current_mask]) return max_length"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a city skyline, where `heights[i]` is the height of the building at index `i`. The buildings are standing in a line and are numbered from 0 to `heights.length - 1`. You need to determine the largest rectangular area that can be formed by selecting a contiguous subset of buildings and considering only their heights. The width of the rectangle formed will be equal to the number of buildings in that contiguous subset. Implement the function `int largestRectangleArea(int[] heights)` which returns the area of the largest rectangle in the skyline. For example, given the input array `heights = [2, 1, 5, 6, 2, 3]`, the function should return `10`, as the largest rectangle can be formed by the buildings with heights `[5, 6]`. Note: Your solution should be efficient, aiming to solve the problem in linear time.","solution":"def largestRectangleArea(heights): Calculates the largest rectangular area in a histogram represented by heights. Args: heights (List[int]): A list of integers representing the heights of the buildings. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an **m x n** integer grid `grid` representing a maze where: * `0` represents an empty cell, * `1` represents an obstacle that cannot be traversed. You are also given an array `start` representing the start position (in the form `[startRow, startCol]`) in the maze and an array `end` representing the target position (in the form `[endRow, endCol]`). Find the length of the **shortest path** from `start` to `end`. If there is no valid path, return `-1`. You can move up, down, left, or right from and to empty cells.","solution":"from collections import deque def shortest_path(grid, start, end): Returns the length of the shortest path from start to end in the grid. rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 queue = deque([(start[0], start[1], 0)]) visited = set((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == (end[0], end[1]): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. Write a function to determine the length of the longest contiguous subarray that contains at most two distinct integers. Implement the function `int lengthOfLongestSubstringTwoDistinct(int[] nums)`, which takes an array of integers and returns the length of the longest subarray with at most two distinct integers. For example, given the array `[1, 2, 1, 2, 3]`, the function should return `4`, as the subarray `[1, 2, 1, 2]` has the longest length with at most two distinct integers.","solution":"def lengthOfLongestSubstringTwoDistinct(nums): Returns the length of the longest contiguous subarray containing at most two distinct integers. if not nums: return 0 left = 0 right = 0 max_len = 0 counts = {} while right < len(nums): if nums[right] in counts: counts[nums[right]] += 1 else: counts[nums[right]] = 1 while len(counts) > 2: counts[nums[left]] -= 1 if counts[nums[left]] == 0: del counts[nums[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"You are given a string `s` consisting of only lowercase alphabets. Determine the length of the longest substring of `s` that contains at most two distinct characters. Implement the `Solution` class: * `Solution(String s)` Initializes the object with the string `s`. * `int longestSubstring()` Returns the length of the longest substring of `s` that contains at most two distinct characters.","solution":"class Solution: def __init__(self, s: str): Initializes the object with the string s. self.s = s def longestSubstring(self) -> int: Returns the length of the longest substring of s that contains at most two distinct characters. n = len(self.s) if n == 0: return 0 left = 0 right = 0 max_length = 0 char_count = {} while right < n: char_count[self.s[right]] = char_count.get(self.s[right], 0) + 1 while len(char_count) > 2: char_count[self.s[left]] -= 1 if char_count[self.s[left]] == 0: del char_count[self.s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"A company wants to send a message to its employees using a **light pattern** on a display board. The light pattern is represented as a binary string where \'1\' means the light is on and \'0\' means the light is off. The message should be symmetric, meaning it reads the same forwards and backwards. You are given a binary string `lights` representing the initial state of the lights on the display board. You are allowed to toggle (change \'0\' to \'1\' or \'1\' to \'0\') at most one light to make the string symmetric. Return `true` if it is possible to make the light pattern symmetric by toggling at most one light, and `false` otherwise. For example, given `lights = \\"0110\\"`, you can change the light pattern to \\"0110\\" (by toggling the first or the last light) to make it symmetric. Given `lights = \\"1010\\"`, it is impossible to make the light pattern symmetric by toggling just one light. Return `true` if the task can be accomplished and `false` otherwise.","solution":"def can_make_symmetric(lights): Given a binary string `lights`, check whether it is possible to make the string symmetric by toggling at most one light. n = len(lights) mismatch_count = 0 for i in range(n // 2): if lights[i] != lights[n - i - 1]: mismatch_count += 1 if mismatch_count > 1: return False return True"},{"question":"You are given a list of `n` integers called `arr`. The task is to determine the sum of the largest subsequence in the array where no two consecutive elements are included. You are required to return the sum of this subsequence. A subsequence is a sequence derived from another sequence where elements are picked in their original order but not necessarily consecutively.","solution":"def max_non_consecutive_sum(arr): Returns the sum of the largest subsequence in the array where no two consecutive elements are included. if not arr: return 0 if len(arr) == 1: return arr[0] incl = arr[0] excl = 0 for i in range(1, len(arr)): new_excl = max(incl, excl) incl = excl + arr[i] excl = new_excl return max(incl, excl)"},{"question":"In a **tweet**, a word is defined as a sequence of non-space characters. For example, `\\"Hello world \\"`, `\\"Tweet \\"`, and `\\"How are you today?\\"` are considered tweets. The words in a tweet are separated by at least one space character. Given a tweet string `s`, implement a function `topKFrequentWords(s, k)` that returns the `k` most frequent words in the tweet. If there are multiple words with the same frequency, sort them by their lexicographical order. You may return the answer in **any order**.","solution":"from collections import Counter def topKFrequentWords(s, k): Returns the k most frequent words in the tweet. Parameters: s (str): The tweet string. k (int): The number of top words to return. Returns: List[str]: The k most frequent words sorted by frequency and lexicographical order. words = s.split() counter = Counter(words) sorted_words = sorted(counter.items(), key=lambda x: (-x[1], x[0])) return [word for word, _ in sorted_words[:k]]"},{"question":"You are given a **matrix** `M`, where each element represents the altitude in a region. A **peak** is an element which is not smaller than its four neighbors (left, right, top, bottom). Write an algorithm to find a **peak** element in `M`. A **peak** element in the matrix is defined such that all of its neighbors are either undefined (i.e., it lies on the boundary of the matrix) or lower than the value of the element itself. Return the coordinates (i.e., row and column) of any one of the peak elements.","solution":"def find_peak(M): Given a matrix M, returns the coordinates of any peak element. A peak element is defined as an element which is not smaller than its four neighbors. rows = len(M) cols = len(M[0]) def is_peak(r, c): val = M[r][c] if r > 0 and M[r-1][c] > val: return False if r < rows - 1 and M[r+1][c] > val: return False if c > 0 and M[r][c-1] > val: return False if c < cols - 1 and M[r][c+1] > val: return False return True for r in range(rows): for c in range(cols): if is_peak(r, c): return (r, c) return None # In case no peak is found (though there should always be at least one peak) # Example Usage # matrix = [ # [10, 8, 10, 10], # [14, 13, 12, 11], # [15, 9, 11, 21], # [16, 17, 19, 20] # ] # print(find_peak(matrix)) # Output: A peak element\'s coordinates, e.g., (3, 1)"},{"question":"You are given an array `nums` of integers. You are allowed to perform a special operation on any subarray of `nums` any number of times: - You can replace any subarray of length `k` with its **sum**. - For example, if the array is `[1,2,3,4]` and you perform the operation on the subarray `[2,3]`, the array will become `[1,5,4]`. Find and return the **maximum possible** element value in `nums` after performing the operation any number of times.","solution":"def max_possible_element(nums): Returns the maximum possible element value in nums after performing the operation any number of times. The maximum possible element value is the sum of all elements in the array. return sum(nums)"},{"question":"Given an array of integers `arr`, where `arr[i]` represents the height of a candle at position `i`, calculate the number of distinct ways to pick two candles so that the difference in their heights is maximum. Return _the number of such pairs_. If there are no pairs, return `0`.","solution":"def max_difference_pairs(arr): Calculate the number of distinct ways to pick two candles so that the difference in their heights is maximum. Parameters: arr (list of int): The heights of the candles. Returns: int: The number of distinct pairs with the maximum height difference. if len(arr) < 2: return 0 max_height = max(arr) min_height = min(arr) max_count = arr.count(max_height) min_count = arr.count(min_height) if max_height == min_height: return 0 return max_count * min_count"},{"question":"You are given a list of unique positive integers `nums` and an integer `target`. A **subarray** of `nums` is a contiguous part of the list. Find the length of the shortest **subarray** whose sum is greater than or equal to `target`. If there is no such subarray, return `-1`.","solution":"def min_subarray_len(nums, target): Finds the length of the shortest subarray whose sum is greater than or equal to the target. If there is no such subarray, return -1. n = len(nums) start = 0 current_sum = 0 min_length = float(\'inf\') for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given an array of integers `arr` representing a sequence of numbers. A subarray is a contiguous subsequence of the array. Find the maximum sum of any subarray of `arr`. **Note**: The subarray must contain at least one number.","solution":"def max_subarray_sum(arr): Finds the maximum sum of any subarray of arr using Kadane\'s Algorithm. Parameters: arr (list of int): The input array of integers. Returns: int: The maximum sum of any subarray. if len(arr) == 0: raise ValueError(\\"Array must contain at least one element\\") max_so_far = arr[0] max_ending_here = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"You are given two sorted arrays `num1` and `num2` of size `m` and `n` respectively, and you need to return a new array consisting of all elements from both arrays in sorted order. Your algorithm must have a time complexity of `O(m + n)`. Do not use any built-in sorting functions in your solution.","solution":"def merge_sorted_arrays(nums1, nums2): Merges two sorted arrays into a single sorted array. :param nums1: List[int] - first sorted array :param nums2: List[int] - second sorted array :return: List[int] - merged sorted array merged = [] i = 0 j = 0 while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: merged.append(nums1[i]) i += 1 else: merged.append(nums2[j]) j += 1 # Append remaining elements of nums1 or nums2 while i < len(nums1): merged.append(nums1[i]) i += 1 while j < len(nums2): merged.append(nums2[j]) j += 1 return merged"},{"question":"You are given a string `s` and an integer `k`. Your task is to determine if the string can be rearranged such that any two adjacent characters are at least `k` positions apart in the resulting string. Return _a possible rearranged string_ that meets the condition, or return an empty string if it is not possible to rearrange the characters accordingly.","solution":"from collections import Counter from heapq import heappush, heappop from typing import List def rearrange_string_k_distance(s: str, k: int) -> str: if k == 0: return s counter = Counter(s) max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) wait_list = [] result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) wait_list.append((char, freq + 1)) if len(wait_list) < k: continue char, freq = wait_list.pop(0) if -freq > 0: heappush(max_heap, (freq, char)) if len(result) == len(s): return \'\'.join(result) else: return \\"\\""},{"question":"You are given an array of positive integers `arr` where each element represents the time required for a task. There are also `n` workers available to perform these tasks, and each worker can only handle one task at a time. Each task must be completed without interruption. Find the minimum amount of time required to complete all tasks, assuming that each worker starts as soon as they become available. Return the minimum time required to complete all tasks.","solution":"import heapq def min_time_to_complete_tasks(arr, n): Determines the minimum time required to complete all tasks given n workers. Parameters: arr (list): List of positive integers representing the time required for each task. n (int): Number of workers available. Returns: int: The minimum amount of time required to complete all tasks. if not arr: return 0 if n <= 0: raise ValueError(\\"Number of workers must be positive.\\") # Create a priority queue to store the finishing time of each worker pq = [0] * n # Distribute tasks to workers for time in arr: fastest_worker = heapq.heappop(pq) heapq.heappush(pq, fastest_worker + time) # The maximum value in the priority queue will be the minimum time required return max(pq)"},{"question":"Given a 2D matrix `matrix` where each element is either 0 or 1, return the number of distinct islands. An island is a group of connected `1`s (horizontal or vertical connections only). Two islands are considered distinct if one island is not equal to another (not identical in shape or pattern).","solution":"def num_distinct_islands(matrix): Returns the number of distinct islands in the given 2D matrix. An island is a group of connected 1\'s (horizontal or vertical connections only). if not matrix: return 0 def dfs(x, y, direction, path): if x < 0 or x >= len(matrix) or y < 0 or y >= len(matrix[0]) or matrix[x][y] == 0: return matrix[x][y] = 0 path.append(direction) dfs(x + 1, y, \\"d\\", path) # down dfs(x - 1, y, \\"u\\", path) # up dfs(x, y + 1, \\"r\\", path) # right dfs(x, y - 1, \\"l\\", path) # left path.append(\\"b\\") # back distinct_islands = set() for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1: path = [] dfs(i, j, \\"o\\", path) # origin distinct_islands.add(tuple(path)) return len(distinct_islands)"},{"question":"Given an integer array `arr`, write a function that returns a new array consisting of the cumulative sum of the elements. The cumulative sum of an element at index `i` is the sum of all elements from the start of the array up to and including the element at index `i`. Return the resulting array.","solution":"def cumulative_sum(arr): Returns a new array consisting of the cumulative sum of the elements of arr. if not arr: return [] cum_sum = [arr[0]] for i in range(1, len(arr)): cum_sum.append(cum_sum[i-1] + arr[i]) return cum_sum"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer array `indices` of the same length where each element represents a position index of the string. Write a function that returns a new string where each character at the position `i` in the original string `s` is moved to the position `indices[i]` in the shuffled string. The test cases are generated so that there is always a valid solution.","solution":"def restore_string(s, indices): Return a new shuffled string where each character at the position i in the original string s is moved to the position indices[i] in the shuffled string. n = len(s) shuffled = [\'\'] * n for i, char in enumerate(s): shuffled[indices[i]] = char return \'\'.join(shuffled)"},{"question":"You are given a string `s` representing a DNA sequence, and another string `target` representing a target sequence to look for within the DNA. A DNA sequence consists of characters `A`, `C`, `G`, and `T` only. Find all the **starting indices** of `target`\'s anagrams in `s`. An Anagram is a permutation of the `target`. Your function should return these indices as a list in **ascending order**.","solution":"from collections import Counter def find_anagrams(s, target): Returns a list of starting indices where anagrams of the target appear in the string s. target_len = len(target) target_counter = Counter(target) window_counter = Counter(s[:target_len - 1]) result = [] for i in range(target_len - 1, len(s)): window_counter[s[i]] += 1 # Include current character in the window start_index = i - target_len + 1 if window_counter == target_counter: result.append(start_index) window_counter[s[start_index]] -= 1 # Remove the start character from the window if window_counter[s[start_index]] == 0: del window_counter[s[start_index]] # Clean up the counter return result"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting of lowercase English letters. You want to transform `s1` into `s2` using the minimum number of operations. In one operation, you can: * Swap the characters of any two different positions in `s1`. Return the minimum number of swaps needed to transform `s1` into `s2`. Example: Input: s1 = \\"abac\\", s2 = \\"baca\\" Output: 2","solution":"def min_swaps_to_transform(s1, s2): Returns the minimum number of swaps needed to transform s1 into s2. :param s1: A string consisting of lowercase English letters. :param s2: A string consisting of lowercase English letters. :return: The minimum number of swaps needed. # Convert both strings to list of characters to allow swapping s1 = list(s1) s2 = list(s2) swaps = 0 # Iterate over both strings for i in range(len(s1)): if s1[i] != s2[i]: # Find the position in s1 where the current character of s2 is located swap_idx = s1.index(s2[i], i) # Swap the characters in s1 s1[i], s1[swap_idx] = s1[swap_idx], s1[i] swaps += 1 return swaps"},{"question":"Given a list of `n` cities and their pairwise distances, find the length of the shortest path that visits every city exactly once and returns to the origin city. The cities are represented as integers from `0` to `n-1`, and the distances are given as a `n x n` matrix `dist`, where `dist[i][j]` represents the distance between cities `i` and `j`. Return the length of this shortest path. This problem is a variation of the well-known **Travelling Salesman Problem** (TSP).","solution":"def tsp(dist): Solve the Travelling Salesman Problem (TSP) using a bitmask dynamic programming approach. Parameters: dist (list of list of int): n x n matrix representing the distances between cities. Returns: int: The length of the shortest path that visits every city exactly once and returns to the origin city. from functools import lru_cache n = len(dist) @lru_cache(None) def dp(mask, pos): if mask == (1 << n) - 1: return dist[pos][0] if dist[pos][0] != float(\'inf\') else float(\'inf\') answer = float(\'inf\') for city in range(n): if mask & (1 << city) == 0: answer = min(answer, dist[pos][city] + dp(mask | (1 << city), city)) return answer return dp(1, 0)"},{"question":"You are given a list of non-negative integers `nums`, where each integer represents the height of a bar in a histogram. The histogram bars are placed next to each other, forming a continuous rectangular area. The task is to find the area of the largest rectangle that can be formed using one or more of these bars. Return the area of the largest rectangle.","solution":"def largestRectangleArea(heights): Given a list of non-negative integers representing the heights of bars in a histogram, returns the area of the largest rectangle that can be formed using one or more of these bars. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a string `s` consisting only of lowercase alphabets. You can perform two types of operations on this string: 1. Choose one character from the string and remove it. 2. Choose two adjacent characters from the string that are the same and remove them both. Return _the minimum number of operations needed to make the string empty_.","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations needed to make the string empty. Args: s (str): The input string consisting only of lowercase alphabets. Returns: int: The minimum number of operations to make the string empty. stack = [] # We will use a stack to keep track of characters for char in s: # If the character at the top of the stack is the same as the current character, remove them both if stack and stack[-1] == char: stack.pop() else: stack.append(char) # The answer is the length of the stack, as each character or adjacent pair will eventually need one operation. return len(stack)"},{"question":"Given an array `arr` consisting of `n` positive integers, write a function to find the length of the longest subsequence such that the difference between consecutive elements is either `1` or `-1`. A subsequence is derived by deleting some or no elements from the array without changing the order of the remaining elements. Return the length of this longest subsequence.","solution":"def longest_subsequence(arr): Returns the length of the longest subsequence such that the difference between consecutive elements is either 1 or -1. n = len(arr) if n == 0: return 0 # Initialize a list to store the longest subsequence length ending at each element longest_end = [1] * n for i in range(n): for j in range(i): if abs(arr[i] - arr[j]) == 1: longest_end[i] = max(longest_end[i], longest_end[j] + 1) return max(longest_end)"},{"question":"You are given an integer array `heights` representing the heights of a set of buildings and an integer `k`. It is possible to jump from the top of one building to another as long as the absolute difference in heights between the buildings is less than or equal to `k`. Starting from the first building, determine the minimum number of jumps required to reach the last building. If it is not possible to reach the last building, return -1.","solution":"from collections import deque def min_jumps(heights, k): Returns the minimum number of jumps required to reach the last building or -1 if it is not possible n = len(heights) queue = deque([(0, 0)]) # (position, jumps) visited = set([0]) while queue: position, jumps = queue.popleft() if position == n - 1: return jumps for next_pos in range(position + 1, n): if abs(heights[next_pos] - heights[position]) <= k and next_pos not in visited: queue.append((next_pos, jumps + 1)) visited.add(next_pos) return -1"},{"question":"You are given a string `s` representing a sequence of words separated by spaces. Each word consists of non-space characters only and each word does not exceed a length of 20 characters. Reverse the order of the words in the string and return the new string. Note that the original spaces between the words are retained only as single spaces in the reversed string, and there should be no leading or trailing spaces in the output.","solution":"def reverse_words(s): Reverses the order of words in the string \'s\'. Retains spaces only as single spaces in the result. :param s: A string representing a sequence of words separated by spaces. :return: A new string with the order of words reversed. # Split the string by spaces to get the words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list into a string with single spaces result = \' \'.join(reversed_words) return result"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. A **substring** is called **k-even** if it contains at least `k` distinct characters, and each of those characters appears an even number of times within the substring. Return _the length of the longest **k-even** substring in_ `s`. If no such substring exists, return `0`.","solution":"def longest_k_even_substring(s, k): Returns the length of the longest k-even substring in the given string s. A k-even substring contains at least k distinct characters, and each of those characters appears an even number of times within the substring. n = len(s) max_length = 0 for start in range(n): char_count = {} for end in range(start, n): char = s[end] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 if len(char_count) >= k: if all(count % 2 == 0 for count in char_count.values()): max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a list of intervals `intervals` where `intervals[i] = [starti, endi]`, representing the start and end times of the `i-th` interval, and an integer `point`. Your task is to determine how many intervals contain the given `point`. An interval `[start, end]` contains `point` if `start <= point <= end`. Return the number of intervals that contain the given `point`.","solution":"def count_intervals_containing_point(intervals, point): Returns the number of intervals that contain the given point. Parameters: intervals (list of lists): A list where each element is a list with two integers representing the start and end of the interval. point (int): The point to check for containment within the intervals. Returns: int: The number of intervals that contain the point. count = 0 for start, end in intervals: if start <= point <= end: count += 1 return count"},{"question":"You are given a string `s` consisting of lowercase alphabets. You need to partition the string into as few parts as possible so that each substring contains only one distinct character. Return _the number of parts the string can be partitioned into_. For example, if `s = \\"aaabbaac\\"`, you can partition it into `[\\"aaa\\", \\"bb\\", \\"aa\\", \\"c\\"]` which results in 4 parts.","solution":"def partition_string(s): Given a string s, partition it into as few parts as possible so that each substring contains only one distinct character. Return the number of parts the string can be partitioned into. :param s: A string consisting of lowercase alphabets. :return: The number of parts the string can be partitioned into. if not s: return 0 parts = 1 previous_character = s[0] for character in s[1:]: if character != previous_character: parts += 1 previous_character = character return parts"},{"question":"Given a string `s`, you are allowed to re-arrange the characters of the string in any order, but you can only make a **single** re-arrangement. Determine the length of the longest palindromic substring that can be formed from the given string `s`. A palindromic substring is a substring which reads the same backward as forward. Write a function that returns this length.","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring that can be formed by rearranging the characters of the input string. from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"Given a non-negative integer `num`, repeatedly add all its digits until the result has only one digit. Return _the single digit result_. For example, given `num = 38`, the process would be: - 3 + 8 = 11 - 1 + 1 = 2 Since 2 has only one digit, return it. Note that you must perform the addition of digits iteratively, and the process should be optimized for large integers.","solution":"def add_digits(num): Repeatedly add all digits of a non-negative integer `num` until the result has only one digit. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"You are given an array of integers `arr` and an integer `k`. A sliding window of size `k` is a contiguous subarray of elements within the array. The **minimum difference** of a sliding window is the difference between the maximum and minimum values within that window. Return the minimum possible value of the **minimum difference** over all sliding windows of size `k` in the array.","solution":"def min_difference_sliding_window(arr, k): Returns the minimum possible value of the minimum difference over all sliding windows of size k. if not arr or k <= 0 or k > len(arr): return 0 min_difference = float(\'inf\') for i in range(len(arr) - k + 1): window = arr[i:i+k] local_difference = max(window) - min(window) min_difference = min(min_difference, local_difference) return min_difference"},{"question":"You are given a sentence represented as a string `sentence` containing words separated by spaces. Each word in the sentence consists of lowercase English letters only. The sentence may contain leading or trailing spaces but will not contain multiple spaces between words. Your task is to return the sentence with the words reversed in order, but the order and number of spaces should remain unchanged. For example, if the input string has leading or trailing spaces, the output should maintain the same number of leading or trailing spaces.","solution":"def reverse_words_with_spaces(sentence): Reverses the words in the sentence but maintains the order and number of spaces. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: str: The sentence with words reversed in order. words = sentence.split(\' \') reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"Given a string `s`, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. A word is defined as a sequence of non-space characters. The input string `s` may contain leading or trailing spaces. You need to reverse the characters of each word within the string while keeping the spaces intact. Return the string with altered words. # Example: **Input:** `s = \\"hello world\\"` **Output:** `\\"olleh dlrow\\"` # Note: 1. The number of words in the input string is given by `1 <= word count <= 100`. 2. Each word\'s length is in the range `[1, 100]`. 3. Each string `s` contains printable ASCII characters.","solution":"def reverse_words_in_sentence(s): Reverses the order of characters in each word within a sentence. :param s: Input string where words need to be reversed. :type s: str :return: String with each word\'s characters reversed but spaces intact. :rtype: str words = s.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"You are given a **0-indexed** array `nums` of integer values, which can be positive, negative, or zero. A subarray is a **non-empty** contiguous sequence of elements within an array. You need to find the maximum sum that can be obtained from any subarray of `nums`. Return _the maximum sum of any subarray of_ `nums`. Example: - Input: `[-2,1,-3,4,-1,2,1,-5,4]` - Output: `6` - Explanation: The subarray `[4,-1,2,1]` has the maximum sum, which is `6`. Note: The input array can contain both positive and negative integers, and you should consider all possible subarrays of `nums`.","solution":"def max_subarray_sum(nums): This function returns the maximum sum of any subarray in the given list of integers. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given two strings `s1` and `s2` of equal length. Your task is to determine if `s2` can be obtained from `s1` after performing exactly one of the following operations: 1. Swapping two different characters in `s1`. 2. Replacing one character in `s1` with another character. Return `true` if `s2` can be obtained from `s1` by exactly one operation, and `false` otherwise. The swap or replace operation can only be performed once.","solution":"def can_obtain_by_one_operation(s1, s2): Determines if s2 can be obtained from s1 by exactly one swap or one replace operation. Args: s1 (str): The original string. s2 (str): The target string. Returns: bool: True if s2 can be obtained from s1 by exactly one operation, False otherwise. if len(s1) != len(s2): return False # Find positions where s1 and s2 differ diff_positions = [i for i in range(len(s1)) if s1[i] != s2[i]] # If there are no differences, it means the strings are already the same if not diff_positions: return False # If there is exactly one difference, we must replace one character if len(diff_positions) == 1: return True # If there are exactly two differences, check for swap possibility if len(diff_positions) == 2: i, j = diff_positions # Check if swapping would match the strings if s1[i] == s2[j] and s1[j] == s2[i]: return True # Otherwise, it\'s not possible with exactly one operation return False"},{"question":"Given a non-empty array of integers, write a function to find the length of the longest contiguous subarray containing only unique elements. Return _the length of the longest subarray_ with all distinct elements. For example, given the array `arr = [2, 1, 2, 3, 4, 1, 2]`, the function should return `4` as the longest subarray with distinct elements is `[2, 3, 4, 1]`.","solution":"def length_of_longest_subarray_with_unique_elements(arr): Returns the length of the longest contiguous subarray with unique elements. n = len(arr) if n == 0: return 0 max_len = 0 left = 0 seen = {} for right in range(n): if arr[right] in seen: left = max(left, seen[arr[right]] + 1) seen[arr[right]] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a string `s` containing only letters and digits. Write a function to reformat the string such that no two adjacent characters are of the same type, that is, no two letters or two digits are next to each other. If it is not possible to reformat the string, return an empty string.","solution":"def reformat(s): Reformat the string such that no two adjacent characters are of the same type. If it\'s not possible, return an empty string. letters = [c for c in s if c.isalpha()] digits = [c for c in s if c.isdigit()] if abs(len(letters) - len(digits)) > 1: return \\"\\" result = [] if len(letters) > len(digits): longer, shorter = letters, digits else: longer, shorter = digits, letters for i in range(len(s)): if i % 2 == 0: result.append(longer.pop(0)) else: result.append(shorter.pop(0)) return \\"\\".join(result)"},{"question":"Given an array of positive integers `nums`, return _the length of the longest contiguous subarray where all the elements have the same value._ ```python def longest_contiguous_subarray(nums): max_length = 0 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length) ```","solution":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray where all elements have the same value. Parameters: - nums: List[int], list of positive integers Returns: - int, the length of the longest contiguous subarray if not nums: return 0 max_length = 0 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"You are given a **0-indexed** integer array `nums` representing the heights of a set of pillars. You need to compute the maximum **distance** such that the heights of the pillars at both ends of the distance are the same. The distance between the pillars at indices `i` and `j` is defined as `|j - i|` where `|x|` represents the absolute value of `x`. * Return _the maximum distance between any two pillars that have the same height_.","solution":"def max_distance_with_same_height(nums): Returns the maximum distance between any two pillars that have the same height. height_to_indices = {} for index, height in enumerate(nums): if height in height_to_indices: height_to_indices[height].append(index) else: height_to_indices[height] = [index] max_distance = 0 for indices in height_to_indices.values(): if len(indices) > 1: distance = indices[-1] - indices[0] if distance > max_distance: max_distance = distance return max_distance"},{"question":"Given an integer array `nums`, find the maximum difference between two elements in the array such that the larger element comes after the smaller element. If no such elements exist, return `-1`. Implement a function `maxDifference(nums: List[int]) -> int`. For example, given the array `[7, 1, 5, 4]`, the maximum difference is `4` (between `5` and `1`). For the array `[9, 4, 3, 2]`, no such elements exist, so the function should return `-1`.","solution":"def maxDifference(nums): Returns the maximum difference between two elements in the array such that the larger element comes after the smaller element. If no such elements exist, returns -1. if not nums or len(nums) < 2: return -1 min_num = nums[0] max_diff = -1 for num in nums[1:]: if num > min_num: max_diff = max(max_diff, num - min_num) min_num = min(min_num, num) return max_diff"},{"question":"You are given a rectangular grid with `m` rows and `n` columns, represented as a matrix where each cell contains an integer representing the height of the terrain at that cell. The task is to find the minimum height needed to cut through to ensure water flow from the top-left corner to the bottom-right corner. Water can flow from one cell to another if the height of the next cell is less than or equal to the current cell, and you can move in four possible directions: up, down, left, and right. Return the minimum height of the terrain that allows the water to flow from the top-left corner to the bottom-right corner.","solution":"from queue import PriorityQueue def can_flow(grid, x, y, visited, max_height): Helper function to perform DFS and check if water can flow from (0,0) to (m-1, n-1) at a given max height. if x == len(grid) - 1 and y == len(grid[0]) - 1: return True directions = [(0,1), (1,0), (0,-1), (-1,0)] visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited and grid[nx][ny] <= max_height: if can_flow(grid, nx, ny, visited, max_height): return True return False def find_min_height(grid): Main function to find the minimum height needed to ensure water flow from top-left corner to bottom-right corner. Uses binary search and DFS to find the solution. rows, cols = len(grid), len(grid[0]) left, right = max(grid[0][0], grid[rows-1][cols-1]), max(max(row) for row in grid) while left < right: mid = (left + right) // 2 if can_flow(grid, 0, 0, set(), mid): right = mid else: left = mid + 1 return left"},{"question":"Given a 2D integer matrix `grid`, return the number of **submatrices** that have all their elements equal. A **submatrix** is a contiguous subset of the grid comprising any rectangular section, with at least one element. For example, a matrix of `n x m` where `n` and `m` are greater than one, could have submatrices of size `1 x 1`, `1 x 2`, `2 x 1`, up to `n x m`. A submatrix is said to have all elements equal if every element within its borders is the same.","solution":"def count_equal_submatrices(grid): Given a 2D integer matrix grid, returns the number of submatrices that have all their elements equal. def is_uniform_submatrix(i1, j1, i2, j2): val = grid[i1][j1] for i in range(i1, i2 + 1): for j in range(j1, j2 + 1): if grid[i][j] != val: return False return True n = len(grid) m = len(grid[0]) count = 0 for i1 in range(n): for j1 in range(m): for i2 in range(i1, n): for j2 in range(j1, m): if is_uniform_submatrix(i1, j1, i2, j2): count += 1 return count"},{"question":"A **linked list** is a linear data structure in which the elements are not stored at contiguous memory locations. The elements in a linked list are linked using pointers. You are given the head of a singly linked list and an integer `k`. Return the head of the linked list after reversing the nodes of the list `k` at a time. Nodes that are left out (less than `k` nodes) after reversing do not need to be reversed. For example, if the linked list is [1, 2, 3, 4, 5] and `k = 2`, the output should be [2, 1, 4, 3, 5].","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: def reverse_linked_list(head, k): new_head = None ptr = head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k: if not ptr: return head ptr = ptr.next count += 1 new_head = reverse_linked_list(head, k) if head: head.next = reverseKGroup(ptr, k) return new_head"},{"question":"You are given an array `arr` of `n` integers where `n` is even. You are allowed to perform the following operation exactly `n/2` times: * Select any two distinct indices `i` and `j` (where `0 <= i, j < n` and `i != j`) and swap the elements `arr[i]` and `arr[j]`. Your task is to determine whether it is possible to rearrange the elements of `arr` such that every pair of adjacent elements has a difference of at least `d`. Return `true` if it is possible, and `false` otherwise.","solution":"def can_rearrange_with_min_diff(arr, d): Determines if the array can be rearranged such that every pair of adjacent elements has a difference of at least \'d\'. Args: arr: List[int] - the input array d: int - the minimum required difference Returns: bool - True if the rearrangement is possible, False otherwise n = len(arr) if n % 2 != 0: return False # The problem specifies n must be even, fail fast for odd length arr.sort() for i in range(n - 1): if abs(arr[i] - arr[i + 1]) < d: return False return True"},{"question":"# New Question: [Question 4]: Design a `TimeMap` class where you can store key-value pairs with timestamps and retrieve the value for a key at a specific timestamp. Implement the `TimeMap` class: * `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given `timestamp`. * `String get(String key, int timestamp)` Returns a value such that `set(key, value, timestamp_prev)` was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns an empty string \\"\\". **Note:** Each `key` is guaranteed to have unique timestamps.","solution":"class TimeMap: def __init__(self): Initialize your data structure here. self.store = {} def set(self, key, value, timestamp): Stores the key with the value at the given timestamp. if key not in self.store: self.store[key] = [] self.store[key].append((timestamp, value)) def get(self, key, timestamp): Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns an empty string. if key not in self.store or not self.store[key]: return \'\' values = self.store[key] # Binary search for the right timestamp low, high = 0, len(values) - 1 while low < high: mid = (low + high + 1) // 2 if values[mid][0] <= timestamp: low = mid else: high = mid - 1 # Check if the found timestamp is at most timestamp if values[low][0] <= timestamp: return values[low][1] return \'\'"},{"question":"You are given the head of a singly linked list where each node contains a single integer value and a target integer `k`. Write a function to partition the list such that all nodes less than `k` come before nodes greater than or equal to `k`. The original relative order of the nodes in each of the two partitions should be preserved. Return the head of the newly partitioned list. For example, if the input linked list is `1 -> 4 -> 3 -> 2 -> 5 -> 2` and `k = 3`, the output should be `1 -> 2 -> 2 -> 4 -> 3 -> 5`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, k): Partitions the linked list such that all nodes with values less than k come before nodes with values greater than or equal to k. :param head: The head of the singly linked list. :param k: The target integer value. :return: The head of the newly partitioned linked list. if not head: # If the head is None, return None return None # These are dummy nodes to simplify the logic lesser_head = ListNode(0) greater_head = ListNode(0) lesser = lesser_head greater = greater_head current = head while current: if current.val < k: lesser.next = current # Place the node in the lesser list lesser = lesser.next else: greater.next = current # Place the node in the greater list greater = greater.next current = current.next greater.next = None # To prevent a possible cycle lesser.next = greater_head.next # Concatenate both lists return lesser_head.next"},{"question":"You are given a list of `n` integers representing the amount of minutes each user spends on a website. Your task is to find the maximum difference between the time spent by any two users. However, you are only allowed to remove exactly one user\'s data before computing the difference. Return the maximum difference after removing exactly one user\'s data. Implement the function `int max_difference_after_removal(int[] times)` where: - `times` is an array of positive integers of length `n`, representing the time (in minutes) each user spends on the website. Note: - `1 <= n <= 1000` - `1 <= times[i] <= 10^5`","solution":"def max_difference_after_removal(times): Returns the maximum difference between the time spent by any two users after removing exactly one user\'s data. :param times: List of integers representing the time spent by each user. :return: Integer representing the maximum difference. if not times or len(times) < 2: return 0 max_time = max(times) min_time = min(times) max_diff_without_max = max(times[:-1] + times[-1:]) - min_time max_diff_without_min = max_time - min(times[:-1] + times[-1:]) return max(max_diff_without_max, max_diff_without_min)"},{"question":"You are developing a task scheduler that manages the execution of tasks, each represented by a character (e.g., `\'A\'`, `\'B\'`, `\'C\'`, etc.). Some tasks need to be executed at fixed intervals or have a cooldown period such that the same task can\'t be executed again until a certain number of intervals have passed. Given a list of tasks represented by characters and a positive integer `n` representing the cooldown period, determine the minimum number of time intervals required to execute all the tasks. Each interval can execute exactly one task, or remain idle. During the interval, either an idle period can be added, or a different task can be executed that doesn\'t violate the cooldown condition. Return the minimum number of intervals required to complete all tasks.","solution":"import heapq from collections import Counter def least_interval(tasks, n): Given tasks and an n cooldown period, return the minimum number of time intervals needed to complete the tasks task_counts = Counter(tasks) max_heap = [-count for count in task_counts.values()] heapq.heapify(max_heap) time = 0 while max_heap: temp = [] for _ in range(n + 1): if max_heap: temp.append(heapq.heappop(max_heap)) for t in temp: if t < -1: heapq.heappush(max_heap, t + 1) time += n + 1 if max_heap else len(temp) return time"},{"question":"Given an integer array `nums`, you need to find the **length of the longest subarray** where the absolute difference between any two elements is less than or equal to `limit`. Return _the length of the longest such subarray_. If there is no such subarray, return `0`. For example, given `nums = [8,2,4,7]` and `limit = 4`, the longest subarray is `[2, 4]` with the absolute difference of `2` and `4` being `2`, which is less than or equal to `4`. Hence, the output should be `2`.","solution":"from collections import deque def longest_subarray(nums, limit): Finds the length of the longest subarray where the absolute difference between any two elements is less than or equal to `limit`. :param nums: List[int], the array of integers :param limit: int, the mentioned limit for absolute difference :return: int, the length of the longest such subarray. if not nums: return 0 min_deque = deque() max_deque = deque() left = 0 max_length = 0 for right in range(len(nums)): while min_deque and nums[min_deque[-1]] > nums[right]: min_deque.pop() while max_deque and nums[max_deque[-1]] < nums[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > limit: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given n pairs of integers, where each pair represents the coordinates of a point (xi, yi) on a 2D plane, write a function that determines the number of points that form a straight horizontal or vertical line. To form a horizontal line, the y-coordinates of the points must be the same. To form a vertical line, the x-coordinates must be the same. Return the total number of points that align horizontally or vertically. Example: Input: points = [[1, 2], [2, 2], [2, 3], [4, 3], [1, 5], [2, 5]] Output: 4 Explanation: Points [1, 2] and [2, 2] form a horizontal line. Points [1, 5] and [2, 5] form another horizontal line. Points [2, 2], [2, 3], and [2, 5] form a vertical line. Therefore, the total number of points that align horizontally or vertically is 4.","solution":"def count_horizontal_vertical_lines(points): from collections import defaultdict # Dictionaries to keep track of counts of x and y coordinates x_count = defaultdict(int) y_count = defaultdict(int) # Counting occurrences of each x and y coordinate for x, y in points: x_count[x] += 1 y_count[y] += 1 # Counting points that form horizontal or vertical lines count = 0 for x, y in points: if x_count[x] > 1 or y_count[y] > 1: count += 1 return count"},{"question":"You are given a string `s` and an array of strings `dictionary`. Your task is to replace words in the string that are present in the dictionary with a character `#`. A word is defined as a sequence of non-space characters. _Return the modified string_ after all the replacements have been made.","solution":"def replace_words(s, dictionary): Replaces words in the string s that are present in the dictionary with the character \'#\'. Parameters: s (str): The input string. dictionary (list): List of words to be replaced. Returns: str: The modified string after replacements. words = s.split() dictionary_set = set(dictionary) for i, word in enumerate(words): if word in dictionary_set: words[i] = \'#\' return \' \'.join(words)"},{"question":"Given a `root` of a Binary Search Tree (BST) and an integer `k`, return the `k-th` smallest value (1-indexed) of all the values of the nodes in the BST. The BST is guaranteed to have unique values. Implement an algorithm that leverages the BST properties, ensuring optimal performance for large trees. Note that you are constrained to use only O(h) space, where `h` is the height of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Given the `root` of a BST and an integer `k`, returns the `k-th` smallest value (1-indexed) of all the values of the nodes in the BST. count = 0 stack = [] current = root # Iterative inorder traversal while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() count += 1 if count == k: return current.val current = current.right"},{"question":"You are given an m x n grid where each cell contains either a 0 or a 1. A cell is called \\"live\\" if it contains a 1, and \\"dead\\" if it contains a 0. The grid represents a world of forest fires. Every minute, the fires spread to adjacent cells (up, down, left, right) from any live cell. Given the grid and the coordinates of a burning (live) cell, return _the number of minutes it will take for the entire forest to burn down_. If it is not possible for the entire forest to burn, return -1. **There is guaranteed to be at least one live cell initially, and the grid will contain no isolated cells that cannot be reached.**","solution":"from collections import deque def fire_spread_time(grid, burning_cell): rows, cols = len(grid), len(grid[0]) queue = deque([burning_cell]) visited = set([burning_cell]) minutes = 0 # Directions for adjacent cells directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: for _ in range(len(queue)): row, col = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 1: queue.append((new_row, new_col)) visited.add((new_row, new_col)) if queue: minutes += 1 # Check if all cells have been burned for row in range(rows): for col in range(cols): if grid[row][col] == 1 and (row, col) not in visited: return -1 return minutes"},{"question":"You are given an array of integers `temperatures` representing the daily temperatures for a week. Calculate the hottest temperature spike that occurred during this week. A temperature spike is defined as a segment of consecutive days where the temperature strictly increases each day. Return _the maximum number of consecutive days in such a temperature spike._ If no such spikes exist, return `1` for the single hottest day of the week.","solution":"def max_temperature_spike(temperatures): Finds the maximum number of consecutive days of increasing temperatures. If no such spike exists, returns 1. :param temperatures: List of integers representing daily temperatures. :returns: The maximum number of consecutive days in a temperature spike, or 1 if no such spike exists. if not temperatures: return 0 max_spike = 1 current_spike = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i-1]: current_spike += 1 if current_spike > max_spike: max_spike = current_spike else: current_spike = 1 return max_spike"},{"question":"Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, find the `k`th smallest element in the matrix. Note that it is the `k`th smallest element in the sorted order, not the `k`th distinct element. You may assume that `k` is always valid, 1 ≤ `k` ≤ n^2. Implement the function as follows: ```python def kthSmallest(matrix: List[List[int]], k: int) -> int: ``` # Example: ``` matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 Output: 13 ``` # Constraints: - `n == matrix.length == matrix[i].length` - `1 <= n <= 300` - `-10^9 <= matrix[i][j] <= 10^9` - All the rows and columns of the matrix are guaranteed to be sorted in non-decreasing order. - `1 <= k <= n^2`","solution":"from typing import List import heapq def kthSmallest(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in a sorted n x n matrix. n = len(matrix) # Use a min-heap min_heap = [] # Initialize the heap with the first element of each row for r in range(min(n, k)): # (value, row, col) heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Remove k-1 elements from the heap val = None for _ in range(k): val, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return val"},{"question":"Given a string `word` consisting of lowercase alphabets and a string `pattern` where every character in `pattern` either represents a lowercase letter or a `.`. The `.` character can match any single character. Determine if the `word` matches the given `pattern`. The match should cover the entire input string (`word`), not partial. Example 1: Input: word = \\"abc\\", pattern = \\"a.c\\" Output: true Explanation: The pattern matches the word. Example 2: Input: word = \\"abc\\", pattern = \\"a..d\\" Output: false Explanation: The pattern does not match the word due to the additional character `d`. Example 3: Input: word = \\"abc\\", pattern = \\"..c\\" Output: true Explanation: The pattern matches the word as both `.` can be replaced with `a` and `b` respectively, and the last `c` matches. Your task is to write a function: ```python def match_pattern(word: str, pattern: str) -> bool: # Your implementation here ```","solution":"def match_pattern(word: str, pattern: str) -> bool: Checks if the given word matches the given pattern. Parameters: - word: The input word (string) consisting of lowercase alphabets. - pattern: The pattern (string) consisting of lowercase alphabets and the character \'.\' which matches any single lowercase alphabet. Returns: - bool: True if the word matches the pattern, False otherwise. if len(word) != len(pattern): return False for w_char, p_char in zip(word, pattern): if p_char != \'.\' and w_char != p_char: return False return True"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to group the characters of the string into as few groups as possible so that each letter appears in a group exactly once. Two letters can be part of the same group if they are the same letter or if their alphabetical positions differ by one (e.g., \'a\' and \'b\' can be in the same group). Return _the minimum number of groups needed to form such a grouping_.","solution":"def min_groups(s): Returns the minimum number of groups needed to group characters in the string so that each group contains distinct characters that are either the same or differ by one alphabetically. alphabet = [0] * 26 for char in s: alphabet[ord(char) - ord(\'a\')] += 1 max_groups = max(alphabet) return max_groups"},{"question":"You are given a list of integers `nums` and an integer `k`. Your task is to divide the list into `k` continuous subarrays so that the difference between the maximum sum of the subarrays and the minimum sum of the subarrays is minimized. Return the minimized difference.","solution":"def minMaxDivision(nums, k): def can_divide(max_sum): current_sum = 0 subarrays = 1 for num in nums: if current_sum + num > max_sum: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_divide(mid): right = mid else: left = mid + 1 return left"},{"question":"You are working with a square grid of size `N x N`, where `N` is an even integer. Each cell in the grid contains an integer value representing its height above sea level. Your task is to determine the **maximum** possible height difference between the highest and lowest cell if you start at the top-left corner (cell `(0, 0)`) and reach the bottom-right corner (cell `(N-1, N-1)`) by only moving right or down. Given a list of lists `grid` representing the heights in the grid, return the **maximum** height difference along such a path. The height difference in a path is the difference between the maximum height and the minimum height of cells in that path. For example, if the grid `grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`, then one possible path is `1 -> 2 -> 3 -> 6 -> 9` with the heights along this path being `[1, 2, 3, 6, 9]` and the height difference is `9 - 1 = 8`.","solution":"def max_height_difference(grid): Calculate the maximum possible height difference between the highest and lowest cell on a path from top-left to bottom-right corner of the grid. N = len(grid) dp_min = [[0] * N for _ in range(N)] dp_max = [[0] * N for _ in range(N)] dp_min[0][0] = grid[0][0] dp_max[0][0] = grid[0][0] for i in range(1, N): dp_min[i][0] = min(dp_min[i-1][0], grid[i][0]) dp_max[i][0] = max(dp_max[i-1][0], grid[i][0]) dp_min[0][i] = min(dp_min[0][i-1], grid[0][i]) dp_max[0][i] = max(dp_max[0][i-1], grid[0][i]) for i in range(1, N): for j in range(1, N): dp_min[i][j] = min(dp_min[i-1][j], dp_min[i][j-1], grid[i][j]) dp_max[i][j] = max(dp_max[i-1][j], dp_max[i][j-1], grid[i][j]) return dp_max[N-1][N-1] - dp_min[N-1][N-1]"},{"question":"You are given two strings `s1` and `s2` of the same length, consisting of lowercase English letters. You can select any character in `s1` and replace it with another character in `s1` to make the strings equal. However, you can only perform this operation exactly once on `s1`. Return `true` if it\'s possible to make `s1` equal to `s2` by performing this operation, otherwise return `false`.","solution":"def can_become_equal_with_one_swap(s1, s2): Determine if s1 can become equal to s2 by swapping two characters in s1 exactly once. if len(s1) != len(s2): return False # Find the positions where s1 and s2 differ diff_positions = [i for i in range(len(s1)) if s1[i] != s2[i]] # If they already match if len(diff_positions) == 0: return True # If they differ in more than 2 positions, return False if len(diff_positions) != 2: return False # Check if swapping the characters would make the strings equal p1, p2 = diff_positions return s1[p1] == s2[p2] and s1[p2] == s2[p1]"},{"question":"You are given a list of non-negative integers representing the amount of time it takes to execute each task `[t1, t2, t3, ... , tn]` on a single processor. The processor can only execute one task at a time, and it takes 1 unit of time to switch between any two tasks. Your goal is to find the minimum total time required to complete all the tasks. Return _the minimum total execution time_.","solution":"def min_total_time(tasks): Returns the minimum total execution time required to complete all tasks, considering switching time. Parameters: tasks (List[int]): A list of positive integers representing the execution times of tasks Returns: int: The minimum total execution time if not tasks: return 0 n = len(tasks) total_time = sum(tasks) # Total time to execute all tasks switch_time = n - 1 # We need n-1 switches between n tasks return total_time + switch_time"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and an integer `k`. Bob can perform the following operation on the array any number of times: choose any element from the array and add 1 to it or subtract 1 from it. Bob\'s goal is to make the sum of the array equal to `k`. Return the **minimum number** of operations required to make the sum of the array equal to `k`. If it is not possible to achieve the sum, return `-1`.","solution":"def min_operations_to_sum_k(nums, k): Returns the minimum number of operations required to make the sum of `nums` equal to `k`. If it is not possible, returns -1. Args: - nums (list of int): List of integers. - k (int): Target sum. Returns: - int: Minimum number of operations or -1 if it is not possible. current_sum = sum(nums) difference = abs(current_sum - k) if current_sum == k: return 0 # Since any number of increments or decrements is allowed, # we can always make up the difference by adding 1 or subtracting 1 return difference"},{"question":"You are given a list of non-negative integers representing the amount of money of each house. Each house is arranged in a circular street such that the first house is the neighbor of the last one. You can\'t rob two adjacent houses, meaning after you rob a house, the next adjacent house can\'t be robbed. Find the maximum amount of money you can rob tonight without alerting the police. Write a function `circularRob` to determine this value. # Function Signature ```python def circularRob(houses: List[int]) -> int: ```","solution":"from typing import List def rob_linear(houses: List[int]) -> int: if not houses: return 0 if len(houses) == 1: return houses[0] if len(houses) == 2: return max(houses) dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1] def circularRob(houses: List[int]) -> int: if not houses: return 0 if len(houses) == 1: return houses[0] return max(rob_linear(houses[1:]), rob_linear(houses[:-1]))"},{"question":"You are given an array of positive integers representing the heights of buildings on a skyline. Each building is a rectangle with a width of 1. Your task is to find the **skyline** formed by these buildings when viewed from a distance. The skyline is represented by a list of \\"key points\\" in the format `[x, y]` which represents the height change at coordinate `x` to height `y`. The key points should be given in ascending order of their `x` coordinate. Return _the list of key points which form the skyline_. Note: The skyline should remain contiguous at any change in building height.","solution":"def get_skyline(buildings): Returns the skyline formed by the given buildings. Each building is represented as a positive integer height. Args: - buildings: A list of positive integers representing building heights. Returns: - A list of [x, y] key points representing the skyline. if not buildings: return [] n = len(buildings) key_points = [[0, buildings[0]]] for i in range(1, n): if buildings[i] != buildings[i - 1]: key_points.append([i, buildings[i]]) key_points.append([n, 0]) # End of the last building return key_points"},{"question":"Given a binary tree, return the **inorder traversal** of its nodes\' values. Implement the solution using an **iterative approach** without recursion.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree\'s nodes\' values. stack = [] result = [] current = root while current or stack: # Traverse to the leftmost node while current: stack.append(current) current = current.left # Visit the node current = stack.pop() result.append(current.val) # Traverse the right subtree current = current.right return result"},{"question":"Given an integer array `arr` and an integer `target`, return _a list of all unique triplets within `arr` that sum up to the `target`._ Each triplet in the list should be presented in ascending order and the list of triplets should be returned in ascending order as well.","solution":"def three_sum(arr, target): Returns a list of all unique triplets within `arr` that sum up to `target`. Each triplet is presented in ascending order and the list of triplets is in ascending order as well. arr.sort() triplets = [] for i in range(len(arr) - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"You are given a 2D grid of characters `grid` where each character is either an obstacle (`\'#\'`) or a free cell (`\'.\'`). You can move up, down, left, or right, but you cannot move onto obstacles, and you cannot move outside the boundaries of the grid. You start at the cell located at the top-left corner of the grid (0,0) and your goal is to reach the bottom-right corner of the grid (n-1, m-1). Return `true` if there is a path from the starting cell to the goal cell, otherwise return `false`.","solution":"from collections import deque def can_reach_end(grid): Determines if there is a path from the top-left corner (0,0) to the bottom-right corner (n-1,m-1) in a given 2D grid. Returns true if path exists, else false. if not grid or grid[0][0] == \'#\' or grid[-1][-1] == \'#\': return False n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False for _ in range(m)] for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() # Check if we\'ve reached the end if x == n-1 and y == m-1: return True # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == \'.\': queue.append((nx, ny)) visited[nx][ny] = True return False"},{"question":"Given an array of integers `nums` and an integer `k`, return the **maximum product** of any contiguous subarray of length `k`. If there are no such subarrays, return `0`. The subarray must consist only of elements from the original array, maintaining their order.","solution":"def max_product_of_k(nums, k): Returns the maximum product of any contiguous subarray of length k. Args: nums: List[int] - A list of integers. k: int - The length of the subarray Returns: int - The maximum product of any contiguous subarray of length k, or 0 if no such subarray exists. if k > len(nums): return 0 max_product = 0 for i in range(len(nums) - k + 1): product = 1 for j in range(i, i + k): product *= nums[j] max_product = max(max_product, product) return max_product"},{"question":"A company is organizing a series of meetings and has a meeting room that can hold only one meeting at a time. You are given an array `meetings` where `meetings[i] = [starti, endi]` represents the start and end times of the ith meeting. You need to attend all the meetings, and if two meetings overlap, they should be merged into one continuous meeting slot. Return _the minimum number of non-overlapping time slots required to attend all the meetings._ Each meeting starts and ends at distinct times. Example: - Input: meetings = [[1, 3], [2, 6], [8, 10], [15, 18]] - Output: 2","solution":"def merge_meetings(meetings): Returns the minimum number of non-overlapping time slots required to attend all the meetings. # Sort the meetings based on the start times meetings.sort(key=lambda x: x[0]) # Initialize a list to hold merged meetings merged_meetings = [] for meeting in meetings: # If merged_meetings is empty or the last meeting in merged_meetings does not overlap with the current meeting if not merged_meetings or merged_meetings[-1][1] < meeting[0]: merged_meetings.append(meeting) else: # There is an overlap; merge the current meeting with the last one in merged_meetings merged_meetings[-1][1] = max(merged_meetings[-1][1], meeting[1]) # The length of merged_meetings is the count of non-overlapping time slots return len(merged_meetings)"},{"question":"You are given an integer array `heights` representing the heights of students standing in a row, where `heights[i]` is the height of the `ith` student. A student is considered **visible** if all the students before them (to their left) are shorter than them. Given the array `heights`, return the number of visible students in the row. For example, given the array `heights = [4, 3, 5, 2, 6, 1]`, the visible students would be those standing at heights 4, 5, and 6, resulting in an output of 3.","solution":"def count_visible_students(heights): Returns the number of visible students in the row. Parameters: heights (list): List of integers where each integer represents the height of a student. Returns: int: Number of visible students. visible_count = 0 max_height_so_far = -1 for height in heights: if height > max_height_so_far: visible_count += 1 max_height_so_far = height return visible_count"},{"question":"Consider an `m x n` binary grid `grid` where `0` represents a sea cell and `1` represents a land cell. An island is surrounded by sea and is formed by connecting adjacent land cells horizontally or vertically. The grid contains exactly one island. Determine the length of the shortest path from any land cell to any non-diagonal land cell of the same island such that the path passes only through land cells. Return the length of the shortest path. If the island is one cell, return 0.","solution":"from collections import deque def shortest_path_to_same_island(grid): Returns the length of the shortest path from any land cell to any non-diagonal land cell of the same island. If the island is one cell, returns 0. def bfs(start): queue = deque([start]) visited = set([start]) distance = 0 while queue: size = len(queue) for i in range(size): x, y = queue.popleft() if (x, y) != start and grid[x][y] == 1: return distance for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: if grid[nx][ny] == 1: queue.append((nx, ny)) visited.add((nx, ny)) distance += 1 return 0 m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == 1: return bfs((i, j)) return 0"},{"question":"You are given an integer array `heights` representing the heights of columns, where the width of each column is 1. Imagine a city where the columns represent buildings of varying heights, and you need to calculate the total shadow cast by these buildings when the sun is shining from the left. The shadow cast by each building is the maximum height encountered from the left up to and including that building\'s height. Calculate and return the total shadow length of the skyline formed by these buildings.","solution":"def total_shadow_length(heights): Calculate the total shadow cast by buildings when the sun is shining from the left. Parameters: heights (list of int): heights of the buildings. Returns: int: the total shadow length. if not heights: return 0 max_height = 0 total_shadow = 0 for height in heights: max_height = max(max_height, height) total_shadow += max_height return total_shadow"},{"question":"You are given a list of strings `routes` where each `routes[i]` represents a direct bus route that connects several bus stops in the city. Each string contains bus stop numbers separated by commas, for example, `routes[i] = \\"1,2,7\\"`, which means there is a direct route connecting stops 1, 2, and 7. You are also given a source bus stop `source` and a destination bus stop `destination` that you would like to travel to. Your task is to find the minimum number of buses you need to take to travel from the source bus stop to the destination bus stop. If it is not possible to reach the destination from the source, return -1. Here\'s the challenge: the bus stops in each route form a cycle (i.e., you can start at any stop in the list, traverse to the next stop in the list, and return to the starting stop after visiting all stops in the list). Given the list of routes, the source, and the destination bus stops, return the minimum number of buses required to reach the destination from the source.","solution":"from collections import deque, defaultdict def min_buses_to_destination(routes, source, destination): if source == destination: return 0 def build_graph(routes): graph = defaultdict(set) for route_index, route in enumerate(routes): stops = route.split(\',\') for stop in stops: graph[stop].add(route_index) return graph graph = build_graph(routes) queue = deque([(source, 0)]) visited_stops = {source} visited_routes = set() while queue: current_stop, buses_taken = queue.popleft() for route_index in graph[current_stop]: if route_index in visited_routes: continue visited_routes.add(route_index) route_stops = routes[route_index].split(\',\') for stop in route_stops: if stop == destination: return buses_taken + 1 if stop not in visited_stops: visited_stops.add(stop) queue.append((stop, buses_taken + 1)) return -1"},{"question":"Given a binary tree, implement an algorithm to return the level order traversal of its nodes\' values but in reverse (from the bottom level to the top and from left to right within each level). The tree is represented as an array in level order where `null` indicates the absence of a node. Return the result as a list of lists.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree_from_level_order(values): if not values: return None root = TreeNode(values[0]) queue = deque([root]) i = 1 while i < len(values): current = queue.popleft() if values[i] is not None: current.left = TreeNode(values[i]) queue.append(current.left) i += 1 if i < len(values) and values[i] is not None: current.right = TreeNode(values[i]) queue.append(current.right) i += 1 return root def reverse_level_order_traversal(root): if not root: return [] result, queue = deque(), deque([root]) while queue: level_length = len(queue) level = [] for _ in range(level_length): node = queue.popleft() level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.appendleft(level) return list(result) def traverse_tree_from_array(values): root = build_tree_from_level_order(values) return reverse_level_order_traversal(root)"},{"question":"You are given a string `s` which consists of only lowercase English letters. You are allowed to remove the most frequent character from the string, but only once. Return the resulting string after removing the most frequent character. If there is a tie for the most frequent character, remove any one of them. If the string is empty initially, return an empty string.","solution":"def remove_most_frequent_character(s): Removes the most frequent character from the string. If there\'s a tie, removes any one of them. if not s: return \\"\\" from collections import Counter char_count = Counter(s) most_frequent_char = max(char_count, key=char_count.get) return s.replace(most_frequent_char, \'\', 1)"},{"question":"You are given an array of integers `arr` of length `n`. Your task is to form the largest number possible by concatenating the elements of the array. Write a function `largestNumber` which accepts an integer array `arr` and returns a string representing the largest number formed by concatenating all elements in `arr`. Ensure that the resultant number does not contain leading zeros unless the number is zero. The function should have the following signature: `def largestNumber(arr: List[int]) -> str`.","solution":"from typing import List from functools import cmp_to_key def compare(x, y): # Comparator function to decide the order based on concatenated string comparison if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largestNumber(arr: List[int]) -> str: # Convert all integers to strings arr = list(map(str, arr)) # Sort the array with the custom comparator arr.sort(key=cmp_to_key(compare)) # Join all elements to form the largest number largest_num = \'\'.join(arr) # Handle case where all elements are zero return \'0\' if largest_num[0] == \'0\' else largest_num"},{"question":"You are given the `root` of a binary search tree (BST) and an integer `target`. Find the value in the BST that is closest to the `target`. The closest value is defined as the value `v` in the BST for which the absolute difference `|v - target|` is the smallest. If there are multiple values with the same absolute difference, return any of them.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closestValue(root, target): Returns the value in the BST that is closest to the target. closest = root.val current = root while current is not None: if abs(current.val - target) < abs(closest - target): closest = current.val if target < current.val: current = current.left elif target > current.val: current = current.right else: break return closest"},{"question":"Given an integer array `nums`, return _the sum of all the **unique permutations** of its elements_. A **permutation** of an array is any possible ordering of its elements. Two permutations are considered unique if they have different element orderings (regardless of possible repeated elements). * Input: An array `nums` of integers. The array may contain duplicate elements. * Output: The sum of integer values resulting from all unique permutations of `nums`. * For example, if `nums = [1, 2, 2]`, the unique permutations are `[1, 2, 2]`, `[2, 1, 2]`, `[2, 2, 1]`. The test cases are generated so that the answer fits within a **64-bit** integer.","solution":"from itertools import permutations def sum_of_unique_permutations(nums): Given an integer array `nums`, return the sum of all the unique permutations of its elements. unique_permutations = set(permutations(nums)) total_sum = 0 for perm in unique_permutations: number = int(\'\'.join(map(str, perm))) total_sum += number return total_sum"},{"question":"Given an array of integers `arr` and an integer `k`, return the _length of the longest subarray_ that contains at most `k` distinct elements. Implement the `LongestSubarray` class: * `LongestSubarray(int[] arr, int k)` Initializes the object with the integer array `arr` and the integer `k`. * `int findLength()` Returns the length of the longest subarray containing at most `k` distinct elements.","solution":"from collections import defaultdict class LongestSubarray: def __init__(self, arr, k): self.arr = arr self.k = k def findLength(self): left = 0 right = 0 max_length = 0 element_count = defaultdict(int) unique_elements = 0 while right < len(self.arr): if element_count[self.arr[right]] == 0: unique_elements += 1 element_count[self.arr[right]] += 1 right += 1 while unique_elements > self.k: element_count[self.arr[left]] -= 1 if element_count[self.arr[left]] == 0: unique_elements -= 1 left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"Given an array of integers `nums`, you are allowed to flip at most one subarray (i.e., reverse the order of elements within the subarray). Write a function to determine whether it is possible to make the array strictly increasing after the flip. Return `true` if it is possible, otherwise return `false`.","solution":"def can_be_strictly_increasing(nums): Determines if it is possible to make the array strictly increasing by flipping at most one subarray. def is_strictly_increasing(arr): Checks if the array is strictly increasing. return all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)) n = len(nums) if is_strictly_increasing(nums): return True for left in range(n): for right in range(left + 1, n): flipped = nums[:left] + list(reversed(nums[left:right+1])) + nums[right+1:] if is_strictly_increasing(flipped): return True return False"},{"question":"You are given a list of non-negative integers representing heights of blocks where the width of each block is 1 unit. Design a function that calculates the maximum area of water that can be trapped between these blocks. The function should take in the list of heights and return the maximum water trapped. Note that water can only be trapped between blocks of varying heights and it is guaranteed that there will be at least two blocks to form a container.","solution":"def max_water_trapped(heights): Returns the maximum amount of water that can be trapped between the blocks. :param heights: List of non-negative integers representing the heights of the blocks. :return: Integer representing the maximum amount of water trapped. left = 0 right = len(heights) - 1 max_water = 0 while left < right: # Calculate the area with the current boundary width = right - left current_height = min(heights[left], heights[right]) current_water = width * current_height # Update the maximum water trapped max_water = max(max_water, current_water) # Move the pointers to try and find a higher boundary if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given a 0-indexed integer array `arr` of size `n` and an integer `x`. You need to perform the following operation `k` times to minimize the sum of the array: In one operation, choose an element from `arr` and subtract `x` from it if and only if it does not become negative after the subtraction. Return the sum of the array after performing the operation `k` times.","solution":"def minimize_array_sum(arr, x, k): This function minimizes the sum of the array by performing the specified operation k times. import heapq # Turn array into a min heap heapq.heapify(arr) # Perform the operation k times for _ in range(k): min_value = heapq.heappop(arr) if min_value - x >= 0: min_value -= x heapq.heappush(arr, min_value) return sum(arr)"},{"question":"You are given a linked list of `n` elements and an integer `k`. Determine the kth element from the end of the linked list in **O(n)** time complexity. If `k` is greater than the number of elements in the list, return `-1`. The list has the standard operations: insertion, deletion, and traversal. Return the value of the kth element from the end.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def kth_from_end(head, k): Returns the kth element from the end of the linked list. If k is greater than the number of elements, returns -1. :param head: ListNode, the head of the linked list :param k: int, the position from the end to retrieve :return: int, the value of the kth element from the end or -1 if k is out of bounds fast = slow = head for _ in range(k): if not fast: return -1 fast = fast.next while fast: slow = slow.next fast = fast.next return slow.value if slow else -1"},{"question":"You are given a **0-indexed** integer array `arr` representing the lengths of several sticks. You need to cut a segment of equal length from each stick until none are left. A single cut operation can be performed on all the sticks simultaneously, and it is counted as one cut regardless of how many sticks are being cut. In each cut operation, the cut length is equal to the length of the shortest stick remaining. Return _the number of cut operations needed to cut all the sticks until none are left_. For example, given the array `arr = [5, 4, 3, 2]`, you would need to perform operations as follows: - First cut of length `2` leaves `[3, 2, 1]` - Second cut of length `1` leaves `[2, 1]` - Third cut of length `1` leaves `[1]` - Fourth cut of length `1` leaves `[]` So the returned result should be `4`.","solution":"def count_cut_operations(arr): Returns the number of cut operations needed to cut all the sticks until none are left. arr = sorted(set(arr)) # Unique lengths sorted return len(arr)"},{"question":"Given a string `s`, you need to rotate the string to the right by `k` positions. The rotation should preserve the order of characters, and every character that moves beyond the end of the string should reappear at the beginning in the same order. Return the resultant string after `k` rotations. For example, given `s = \\"abcdefg\\"` and `k = 2`, the output should be `\\"fgabcde\\"`.","solution":"def rotate_string(s, k): Rotates the given string s to the right by k positions. Parameters: s (str): The input string k (int): Number of positions to rotate the string Returns: str: The rotated string if not s: return s k = k % len(s) return s[-k:] + s[:-k]"},{"question":"You are given a binary string `s` consisting only of \'0\'s and \'1\'s. You can flip any single character from \'0\' to \'1\' or from \'1\' to \'0\'. Return the minimum number of flips required such that no two adjacent characters in the string are the same.","solution":"def min_flips(s): Returns the minimum number of flips required such that no two adjacent characters in the binary string s are the same. n = len(s) # Pattern 1: starts with \'0\' and alternates pattern1 = \'\'.join([\'0\' if i % 2 == 0 else \'1\' for i in range(n)]) # Pattern 2: starts with \'1\' and alternates pattern2 = \'\'.join([\'1\' if i % 2 == 0 else \'0\' for i in range(n)]) # Count discrepancies for both patterns count1 = sum(1 for i in range(n) if s[i] != pattern1[i]) count2 = sum(1 for i in range(n) if s[i] != pattern2[i]) # Return the minimum of the two counts return min(count1, count2)"},{"question":"You are given an array of integers `arr` and an integer `k`. A subarray is defined as a contiguous non-empty sequence of elements within an array. Your task is to determine whether there exists at least one subarray of `arr` whose sum is equal to `k`. Return `true` if such a subarray exists and `false` otherwise.","solution":"def has_subarray_with_sum(arr, k): Determines if there exists a subarray with sum equal to k. Args: - arr: list of integers - k: integer, the target sum Returns: - boolean: True if there exists a subarray whose sum is equal to k, False otherwise current_sum = 0 sum_map = {0: -1} # to handle the case where the subarray starts from index 0 for idx, num in enumerate(arr): current_sum += num if current_sum - k in sum_map: return True sum_map[current_sum] = idx return False"},{"question":"Given an array of integers `nums` and an integer `target`, return the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. Implement the function: ```python def two_sum(nums: List[int], target: int) -> List[int]: ``` Your function should return the indices of the two numbers (as a list) in the array that add up to the `target`. Ensure the solution you provide runs efficiently with a complexity of O(n).","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"Given an integer array `arr` representing heights at different points along a valley, find and return the index of the peak element. A peak element is an element that is strictly greater than its neighbors. If the array contains multiple peaks, return the index to any of the peaks. **Note:** The given array may not be empty and your algorithm should run in O(log n) time complexity.","solution":"def find_peak(arr): Finds the index of a peak element in the array `arr`. A peak element is an element that is strictly greater than its neighbors. :param arr: List[int] - List of integers representing heights. :return: int - Index of any peak element. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"Given an array of integers `nums` and an integer `k`, your task is to count the number of **distinct** pairs `(i, j)` in the array such that `nums[i] + nums[j]` is equal to `k` (i.e., `nums[i] + nums[j] = k` and `i != j`). Two pairs `(i, j)` and `(j, i)` are considered the same as they have the same numeric values. You should implement the following function: ```python def countPairsWithSum(nums, k): # Your code here ``` **Example:** ```python nums = [1, 2, 3, 4, 3] k = 6 countPairsWithSum(nums, k) # Output: 2 ``` In the example above, the pairs are (2, 3) and (3, 2), and (4, 2). Note that the pair (3, 3) is not valid because i and j must be different, and (2, 4) is not distinct from (4, 2).","solution":"def countPairsWithSum(nums, k): Returns the number of distinct pairs (i, j) such that nums[i] + nums[j] == k and i != j. seen = set() pairs = set() for num in nums: target = k - num if target in seen: pair = tuple(sorted((num, target))) pairs.add(pair) seen.add(num) return len(pairs)"},{"question":"Given a string `s` consisting of only the characters \'a\' and \'b\', you need to split the string into the maximum number of non-empty substrings such that each substring does not contain both \'a\' and \'b\' at the same time. Return the maximum number of substrings you can achieve.","solution":"def max_substrings(s): Splits the string into the maximum number of non-empty substrings such that each substring does not contain both \'a\' and \'b\' at the same time. if len(s) == 0: return 0 # Initialize count of substrings and last seen character substr_count = 1 last_seen = s[0] # Iterate over the string for char in s[1:]: if char != last_seen: substr_count += 1 last_seen = char return substr_count"},{"question":"You are given an array of positive integers `arr`. You may perform the following operation as many times as you want: choose any three consecutive elements and swap them in cyclic order (i.e., shift the first element to the position of the second, the second to the position of the third, and the third to the position of the first). Return _the **minimum** possible sum of the array after any number of such operations._","solution":"def minimize_sum(arr): Returns the minimum possible sum of the array after any number of swaps of three consecutive elements. Since the operation does not affect the values in the array, just their positions, the minimum sum of the array will always be the sum of the array itself. return sum(arr)"},{"question":"You are given a binary tree where each node contains a value. Design an algorithm to encode the binary tree into a single string and decode the string back into the same binary tree structure. Implement the `Codec` class: * `Codec()` constructor initializes the codec object. * `String serialize(TreeNode root)` encodes the tree into a single string. * `TreeNode deserialize(String data)` decodes the encoded data string back into the original tree. The `TreeNode` structure is defined as follows: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ```","solution":"from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Codec: def serialize(self, root: Optional[TreeNode]) -> str: Encodes a tree to a single string. def rserialize(node: Optional[TreeNode]) -> str: if node is None: return \'None,\' return str(node.val) + \',\' + rserialize(node.left) + rserialize(node.right) return rserialize(root) def deserialize(self, data: str) -> Optional[TreeNode]: Decodes your encoded data to tree. def rdeserialize(l: list) -> Optional[TreeNode]: if l[0] == \'None\': l.pop(0) return None root = TreeNode(int(l.pop(0))) root.left = rdeserialize(l) root.right = rdeserialize(l) return root data_list = data.split(\',\') root = rdeserialize(data_list) return root"},{"question":"Given a sorted array of `n` distinct integers and a target value `x`, return _the index of the element that is closest to the target value_. If there are two elements equally close to `x`, return the index of the smaller element (the one with the lower value). If the target value exists in the array, return its index directly.","solution":"def find_closest_index(arr, x): Returns the index of the element that is closest to the target value x. If there are two elements equally close, return the index of the smaller element. n = len(arr) if n == 0: return -1 low, high = 0, n - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == x: return mid elif arr[mid] < x: low = mid + 1 else: high = mid - 1 if low >= n: # target is greater than all elements return high if high < 0: # target is less than all elements return low if (x - arr[high]) <= (arr[low] - x): return high else: return low"},{"question":"You are given a list of integers `arr` sorted in non-decreasing order. Determine if there exists a triple `(i, j, k)` such that `arr[i]`, `arr[j]`, and `arr[k]` (i < j < k) from the array forms an arithmetic progression. Return `true` if such a triple exists, and `false` otherwise.","solution":"def has_arithmetic_triplet(arr): Returns True if there exists a triple (i, j, k) such that arr[i], arr[j], and arr[k] form an arithmetic progression. n = len(arr) for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if arr[j] - arr[i] == arr[k] - arr[j]: return True return False"},{"question":"You are given a string `s` containing only characters \'a\', \'b\', and \'c\'. You can delete any character from the string in one move. The string is considered valid if it contains no three consecutive same characters. Return the minimum number of moves required to make the string valid.","solution":"def min_moves_to_make_valid(s: str) -> int: Returns the minimum number of moves required to make the string valid. A valid string contains no three consecutive same characters. moves = 0 count = 1 # Iterate through the string to detect invalid segments for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 if count == 3: moves += 1 count = 1 # Reset count after invalid segment is adjusted else: count = 1 # Reset count for different characters return moves"},{"question":"Given an unsorted array of integers `nums`, rearrange the array such that every even-indexed position contains an even number and every odd-indexed position contains an odd number. If it is impossible to rearrange the array to satisfy this condition, return an empty array. Otherwise, return any valid rearrangement.","solution":"def rearrange_array(nums): even, odd = 0, 0 N = len(nums) result = [0] * N for num in nums: if num % 2 == 0: even += 1 else: odd += 1 if even != (N + 1) // 2 or odd != N // 2: return [] even_idx, odd_idx = 0, 1 for num in nums: if num % 2 == 0: result[even_idx] = num even_idx += 2 else: result[odd_idx] = num odd_idx += 2 return result"},{"question":"Given a string `s` representing a valid CSV-formatted mirror log file of a server. Each line in the file contains an IP address followed by a count of requests from that IP address, separated by a comma. Your task is to aggregate and return the total number of requests for each unique IP address in the file. The order in which the results are returned does not matter. For example, given the input string: ``` \\"192.168.1.1,5n192.168.1.2,3n192.168.1.1,2n192.168.1.3,4\\" ``` The function should return a dictionary like: ``` { \\"192.168.1.1\\": 7, \\"192.168.1.2\\": 3, \\"192.168.1.3\\": 4 } ```","solution":"def aggregate_requests(csv_log): Aggregates the total number of requests for each unique IP address in the CSV formatted log. Args: csv_log (str): A string representing a CSV formatted mirror log file. Returns: dict: A dictionary with IP addresses as keys and their respective total request counts as values. lines = csv_log.split(\'n\') request_counts = {} for line in lines: if line.strip(): ip, count = line.split(\',\') count = int(count) if ip in request_counts: request_counts[ip] += count else: request_counts[ip] = count return request_counts"},{"question":"Given a string `s` consists of lowercase letters and the `*` character. The `*` character can be treated as an empty string or any single letter from `a` to `z` inclusively. Return _the total number of distinct strings that can be generated by replacing every `*` character in `s` with a valid character_.","solution":"def count_distinct_strings(s): Returns the total number of distinct strings that can be generated by replacing every `*` character in `s` with a valid character (a-z). # Count the number of \'*\' in the string star_count = s.count(\'*\') # Each \'*\' can be replaced by any of 26 letters, so the total number of combinations # is 26 raised to the power of the number of \'*\' characters. return 26 ** star_count"},{"question":"Given a list of integers `nums`, return an array `result` where `result[i]` is equal to the product of all the elements of `nums` except `nums[i]`. Implement your solution without using division and in `O(n)` time complexity.","solution":"def product_except_self(nums): Returns an array where each element is the product of all the elements of nums except itself. length = len(nums) result = [1] * length # Calculate left products left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate right products right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"Given two arrays of integers `nums1` and `nums2`, return a new array such that each element at index `i` of the new array is the **next greater element** of `nums1[i]` in `nums2`. If there is no such greater element, the element at that index should be `-1`. The **next greater element** of a number `x` in `nums2` is the first greater number to its right in `nums2`. For instance, given `nums1 = [4,1,2]` and `nums2 = [1,3,4,2]`, the result should be `[-1,3,-1]`.","solution":"def next_greater_element(nums1, nums2): Finds the next greater element of each element in nums1 from nums2. Parameters: nums1 (List[int]): List of integers where we need to find the next greater elements. nums2 (List[int]): List of integers to search the next greater elements. Returns: List[int]: List containing the next greater elements from nums1 in nums2. next_greater = {} stack = [] # Use a stack to find the next greater element for each number in nums2 for num in nums2: while stack and stack[-1] < num: next_greater[stack.pop()] = num stack.append(num) # For the elements left in the stack, there are no greater elements to their right while stack: next_greater[stack.pop()] = -1 # Build the result for nums1 based on the next_greater mapping result = [next_greater[num] for num in nums1] return result"},{"question":"You have a list of non-negative integers `nums`. You are allowed to choose any non-empty subarray (contiguous elements) and perform the following operation once: * Multiply all the elements of the subarray. Find the maximum possible product you can achieve from any subarray of the given list. Return the maximum product possible.","solution":"def max_subarray_product(nums): Returns the maximum product of any non-empty subarray of the given list of non-negative integers. if not nums: return 0 max_product = nums[0] current_max = current_min = nums[0] for num in nums[1:]: if num == 0: current_max, current_min = 1, 1 continue temp_max = max(num, current_max * num, current_min * num) current_min = min(num, current_max * num, current_min * num) current_max = temp_max max_product = max(max_product, current_max) return max_product"},{"question":"Given a list of unique integers `arr` and an integer `d`, return the maximum length of a sequence of increasing integers that you can make by starting from any element in `arr` and repeatedly adding at most `d` to the current integer to reach the next element in the sequence. Each element in the sequence must be present in the original array `arr`.","solution":"def max_sequence_length(arr, d): arr_set = set(arr) dp = {x: 1 for x in arr} for num in sorted(arr): for k in range(1, d+1): if num + k in arr_set: dp[num + k] = max(dp[num + k], dp[num] + 1) return max(dp.values())"},{"question":"You have a list of `n` integers representing the heights of `n` buildings, where `heights[i]` is the height of the i-th building. We can place a `sunlight post` at the top of any of the buildings such that each sunlight post illuminates exactly one building to its right. A building is considered to be illuminated if it is strictly smaller than the building immediately to its left where a sunlight post is placed. Return the minimum number of sunlight posts needed to illuminate all the buildings.","solution":"def min_sunlight_posts(heights): This function calculates the minimum number of sunlight posts needed to illuminate all the buildings. A sunlight post on building i illuminates building i+1 if heights[i] > heights[i+1]. :param heights: List[int] - List of building heights :return: int - Minimum number of sunlight posts needed posts = 0 for i in range(len(heights) - 1): if heights[i] > heights[i+1]: posts += 1 return posts"},{"question":"You are given an array of integers `nums`. An integer `val` is considered a \\"peak element\\" if it is greater than its neighbors. For corner elements, we need to consider only one neighbor. Write a function that returns the index of any one peak element. It can be proved that there is always at least one peak element. You may assume the input array to be non-empty. The array may contain multiple peaks, in that case return the index of any one of the peak elements.","solution":"def find_peak_element(nums): Finds any peak element in the given array and returns its index. :param nums: List[int] - A list of integers :return: int - Index of one of the peak elements n = len(nums) if n == 1: return 0 left, right = 0, n - 1 while left < right: mid = left + (right - left) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given an integer array `arr` of length `n` where each element represents the number of cookies in a jar. Every night, you can eat a number of cookies from the jars such that the number of cookies eaten from the `i-th` jar is the same for all jars. However, you can\'t eat more cookies than what is available in any jar. Over a period of `m` nights, return _the maximum possible cookies that can be eaten from the jars_ if you aim to minimize the cookies remaining in the jar with the most cookies at the end.","solution":"def max_cookies(arr, m): def can_eat(mid): return sum(min(mid, a) for a in arr) <= m left, right = 0, max(arr) while left < right: mid = (left + right + 1) // 2 if can_eat(mid): left = mid else: right = mid - 1 return left"},{"question":"You are given an array of integers, `nums`, representing a sequence. Your task is to find the length of the longest subsequence which is continuous (the numbers are consecutive integers) and is strictly increasing. Return _an integer_ that represents the length of this subsequence. For example, given the array `nums = [1, 2, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2]`, one of the valid subsequences is `[0, 1, 2]` which has a length of `3`.","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest continuous strictly increasing subsequence. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1] + 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Given a string `str` consisting of only lowercase alphabets, return the length of the longest substring without repeating characters. For example, given the input `str = \\"abcabcbb\\"`, the output should be `3`, because the longest substring without repeating characters is `\\"abc\\"`. Write an efficient algorithm to solve the problem.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Parameters: s (str): Input string consisting of only lowercase alphabets. Returns: int: Length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index max_length = max(max_length, index - start + 1) return max_length"},{"question":"You are given a string `pattern` consisting of characters \'*\' and \'?\'. A character \'*\' can be replaced by any sequence of characters (including the empty sequence), while a character \'?\' can be replaced by any single lowercase English letter. You are also given a string `s` of lowercase English letters. Write a function to determine if `s` matches the `pattern`. Return _`true` if it matches, otherwise return_ `false`. A match is when the entire string `s` is transformed from the `pattern` exactly by replacing each \'*\' and \'?\' as per the defined rules.","solution":"def is_match(pattern, s): Determine if the given string `s` matches the given `pattern`. Args: pattern (str): The pattern containing \'*\' and \'?\' characters. s (str): The string to be matched against the pattern. Returns: bool: True if `s` matches the `pattern`, False otherwise. p_len = len(pattern) s_len = len(s) # Dynamic programming table where dp[i][j] indicates whether pattern[0..i-1] matches s[0..j-1] dp = [[False] * (s_len + 1) for _ in range(p_len + 1)] dp[0][0] = True # Empty pattern and empty string match # Handle patterns with \'*\' for i in range(1, p_len + 1): if pattern[i-1] == \'*\': dp[i][0] = dp[i-1][0] # \'*\' can match empty sequence # Fill the DP table for i in range(1, p_len + 1): for j in range(1, s_len + 1): if pattern[i-1] == \'*\': dp[i][j] = dp[i-1][j] or dp[i][j-1] # \'*\' matches zero or more characters elif pattern[i-1] == \'?\' or pattern[i-1] == s[j-1]: dp[i][j] = dp[i-1][j-1] # \'?\' matches exactly one character or characters match return dp[p_len][s_len]"},{"question":"**[Question 4]**: Given an array `tasks` where `tasks[i]` represents the duration of the `i-th` task, and an integer `sessionTime` representing the maximum duration a single session can last, return the minimum number of work sessions needed to complete all tasks, such that the sum of the durations of tasks in each work session is not more than `sessionTime`. A **work session** is defined as a contiguous period of time used to complete tasks without interruption. Each task must be fully contained within a work session.","solution":"def minSessions(tasks, sessionTime): Returns the minimum number of work sessions needed to complete all tasks. Each session duration should not exceed sessionTime. def canCompleteInSessions(session_counts): sessions = [0] * session_counts def backtrack(index): if index == len(tasks): return True for i in range(session_counts): if sessions[i] + tasks[index] <= sessionTime: sessions[i] += tasks[index] if backtrack(index + 1): return True sessions[i] -= tasks[index] if sessions[i] == 0: # no need to try further empty sessions break return False return backtrack(0) left, right = 1, len(tasks) while left < right: mid = (left + right) // 2 if canCompleteInSessions(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an array `fruits` where `fruits[i]` represents the type of fruit on the `i`-th tree in a row of trees. You want to collect as much fruit as possible, but there are some rules. You can only use two baskets, and each basket can only hold one type of fruit. You start at any tree and can collect fruit in one direction (either left or right). Once you reach a tree with a fruit type that would require a third basket, you must stop collecting. Return _the maximum number of fruits_ you can collect.","solution":"def totalFruit(fruits): Given an array `fruits` representing type of fruit on each tree, returns the maximum number of fruits that can be collected using two baskets. basket = {} left = 0 max_fruits = 0 for right in range(len(fruits)): if fruits[right] in basket: basket[fruits[right]] += 1 else: basket[fruits[right]] = 1 while len(basket) > 2: basket[fruits[left]] -= 1 if basket[fruits[left]] == 0: del basket[fruits[left]] left += 1 max_fruits = max(max_fruits, right - left + 1) return max_fruits"},{"question":"**[Question 4]:** You are given a 2D grid of size `m x n` representing an island map, where `1` represents land, and `0` represents water. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Write an algorithm to count the number of islands. Implement the `numIslands` function, which takes a 2D list `grid` as input and returns the number of islands in the grid. A cell is considered adjacent if it is directly connected vertically or horizontally (not diagonally).","solution":"def numIslands(grid): if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \'0\': return grid[i][j] = \'0\' dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': num_islands += 1 dfs(grid, i, j) return num_islands"},{"question":"Given an array of integers `nums` and an integer `n`, return the **number** that appears more than `n/3` times in the array. If no such number exists, return an empty list. Your solution should have a time complexity better than `O(n^2)`. Note: You may assume that the input array always contains at least one number.","solution":"def majority_element(nums): Returns the list of elements that appear more than n/3 times in the array. If no such element exists, returns an empty list. if not nums: return [] n = len(nums) count1, count2, candidate1, candidate2 = 0, 0, None, None for num in nums: if candidate1 is not None and num == candidate1: count1 += 1 elif candidate2 is not None and num == candidate2: count2 += 1 elif count1 == 0: candidate1, count1 = num, 1 elif count2 == 0: candidate2, count2 = num, 1 else: count1 -= 1 count2 -= 1 result = [] for c in (candidate1, candidate2): if c is not None and nums.count(c) > n // 3: result.append(c) return result"},{"question":"You are given an array of integers `nums` and an integer `k`. An operation consists of removing exactly `k` consecutive elements from the array and replacing them with their sum. The operation can be performed any number of times on any subarray of length `k` until only one element remains. Return _the largest possible value of the remaining element after performing the operations on the array_.","solution":"def max_value_after_operations(nums, k): Given an array of integers nums and an integer k, this function performs operations to maximize the last remaining element by removing k consecutive elements and replacing them with their sum. Parameters: nums (list of int): The given array of integers. k (int): The number of consecutive elements to be removed and replaced with their sum. Returns: int: The largest possible value of the remaining element. # When operation is performed to maximum limit, everything will be summed into one element return sum(nums)"},{"question":"Given an integer `n`, return a string representing a sequence of parentheses that is **valid** and contains `n` pairs of parentheses. Generate the sequence using the following rules: 1. Open brackets `\'(\'` must be closed by a matching close bracket `\')\'`. 2. Open brackets must be closed in the correct order. **Example:** - Input: `n = 3` - Output: `\\"((()))\\"`, `\\"(()())\\"`, `\\"(())()\\"`, `\\"()(())\\"`, or `\\"()()()\\"`. All outputs are valid sequences of parentheses.","solution":"def generate_parentheses(n): Generate all combinations of n pairs of valid parentheses. def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s+\'(\', left+1, right) if right < left: backtrack(s+\')\', left, right+1) result = [] backtrack() return result"},{"question":"You are given an integer array `nums`. A **decreasing subsequence** is a sequence that can be derived from `nums` by deleting some or no elements without changing the order of the remaining elements, such that every next element in the sequence is strictly less than the previous one. Return _the length of the longest **decreasing subsequence** in_ `nums`.","solution":"def length_of_lis(nums): Returns the length of the longest decreasing subsequence in the list of numbers. if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] < nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given two arrays `people` and `candies`, where `people[i]` and `candies[i]` are the respective counts of people and candies in the `i-th` room. Each person in a room must receive exactly one candy. Determine if it\'s possible to distribute the candies such that each person gets exactly one candy in each room. Return a boolean array `result`, where `result[i]` indicates whether the distribution is possible in the `i-th` room.","solution":"def can_distribute_candies(people, candies): Determines if it is possible to distribute candies such that each person gets exactly one candy in each room. :param people: List[int], the number of people in each room. :param candies: List[int], the number of candies available in each room. :return: List[bool], where each element indicates if distribution is possible in that room. if not people or not candies or len(people) != len(candies): return [] result = [] for p, c in zip(people, candies): result.append(p == c) return result"},{"question":"You are given a string `s` and an integer `n`. Your task is to find the length of the longest substring of `s` that contains no more than `n` distinct characters. Write a function that returns this length.","solution":"def longest_substring_with_n_distinct_chars(s, n): Finds the length of the longest substring of s that contains no more than n distinct characters. if n == 0 or not s: return 0 left = 0 max_length = 0 char_count = {} for right in range(len(s)): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > n: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array `arr` of `n` integers. Divide `arr` into two non-empty subarrays `arr1` and `arr2` such that the absolute difference between the sum of elements in `arr1` and the sum of elements in `arr2` is minimized. Return _an array_ containing two integers, where the first integer is the sum of elements in `arr1` and the second integer is the sum of elements in `arr2`.","solution":"def minimize_absolute_difference(arr): Divides the array into two non-empty subarrays such that the absolute difference between their sums is minimized. Returns a list with the sums of the two subarrays. :param arr: List[int] - The input array of integers :return: List[int] - A list containing the sums of the two subarrays n = len(arr) # Initial left sum with the first element only (minimum allowed elements for left subarray) left_sum = arr[0] # Initial right sum with the sum of the remaining elements right_sum = sum(arr[1:]) # Initialize the minimum difference with the current difference min_diff = abs(left_sum - right_sum) sum_pair = [left_sum, right_sum] # Traverse the array to find the point where difference is minimized for i in range(1, n - 1): left_sum += arr[i] right_sum -= arr[i] current_diff = abs(left_sum - right_sum) # Update if the current difference is smaller if current_diff < min_diff: min_diff = current_diff sum_pair = [left_sum, right_sum] return sum_pair"},{"question":"You are given two non-negative integers `n` and `m`. A sequence of length `m` is defined as `A = [a1, a2, ..., am]` where each element `ai` is an integer from 1 to `n` (inclusive). The sequence is considered _special_ if `ai` is divisible by the index `i` (1-based) for all `i`. Calculate the number of such _special_ sequences of length `m`.","solution":"def count_special_sequences(n, m): Returns the number of special sequences of length m where each element in the sequence A is an integer from 1 to n (inclusive) and ai is divisible by i (1-based). if n == 0 or m == 0: return 0 # Initialize the result to 1 for the multiplicative counting result = 1 for i in range(1, m + 1): # Count numbers between 1 and n that are divisible by i divisible_count = n // i result *= divisible_count return result"},{"question":"Given a 2D integer array `flights` where `flights[i] = [fromi, toi, costi]` represents a direct flight from city `fromi` to city `toi` with a travel cost of `costi`, and integers `src`, `dst`, and `k`, return the cheapest price from the city `src` to the city `dst` with at most `k` stops. If there is no such route, return `-1`.","solution":"import heapq def findCheapestPrice(flights, n, src, dst, k): Returns the cheapest price from the city `src` to the city `dst` with at most `k` stops. If there is no such route, returns `-1`. Parameters: flights (List[List[int]]): The list of flights where each flight is represented as [fromi, toi, costi]. n (int): The number of cities. src (int): The source city. dst (int): The destination city. k (int): The maximum number of stops. Return: int: The cheapest price or -1 if such route does not exist. # Create the adjacency list for the graph graph = [[] for _ in range(n)] for fromi, toi, costi in flights: graph[fromi].append((toi, costi)) # (current_cost, stops, current_city) heap = [(0, 0, src)] prices = {(src, 0): 0} while heap: current_cost, stops, current_city = heapq.heappop(heap) if current_city == dst: return current_cost if stops <= k: for next_city, price in graph[current_city]: next_cost = current_cost + price if next_cost < prices.get((next_city, stops+1), float(\'inf\')): prices[(next_city, stops+1)] = next_cost heapq.heappush(heap, (next_cost, stops+1, next_city)) return -1"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. In one operation, you can choose any subarray of length `k` from `nums` and increment every element in the subarray by `1`. Return _the minimum number of operations required to make all elements of the array equal._ If it is not possible, return `-1`.","solution":"def minOperations(nums, k): Returns the minimum number of operations required to make all elements of the array equal by incrementing every element in any subarray of length k. If it is not possible, return -1. n = len(nums) unique_nums = set(nums) # If k == 1, we need to make all elements the same by incrementing each element individually. if k == 1: return -1 if len(unique_nums) > 1 else 0 # If all numbers are already the same, return 0 if len(unique_nums) == 1: return 0 max_num = max(nums) min_num = min(nums) # Calculate the required number of operations required_steps = max_num - min_num return required_steps"},{"question":"Given a list of integers `arr` representing the heights of buildings along a street, find out the total number of buildings that have an unobstructed view of the sunset. The buildings in this problem are arranged from left to right such that building `i` is to the left of building `i + 1`. A building has an unobstructed view of the sunset if there are no taller buildings to its right. Return an integer representing the total number of buildings that have an unobstructed view of the sunset. For example, if given the list `arr = [4, 2, 3, 1]`, the buildings with heights `[4, 3, 1]` have unobstructed views of the sunset, thus the return value would be `3`.","solution":"def count_sunset_buildings(arr): Returns the total number of buildings with an unobstructed view of the sunset. A building has an unobstructed view if there are no taller buildings to its right. Args: arr: List[int] - a list of integers representing the heights of buildings Returns: int - the number of buildings with an unobstructed view of the sunset if not arr: return 0 total_count = 1 # The last building always has an unobstructed view max_height = arr[-1] # Traverse the list from second last to the beginning for height in reversed(arr[:-1]): if height > max_height: total_count += 1 max_height = height return total_count"},{"question":"You are given a directed graph with `n` nodes labeled from `0` to `n-1`, an integer array `edges` where `edges[i] = [ui, vi]` represents a directed edge from node `ui` to node `vi`, and an integer `k` representing the maximum number of steps. Your task is to determine if there is a way to start from the node `0` and reach the node `n-1` within `k` steps or fewer. Each step involves traversing one directed edge from the current node to the next. Return `true` if it is possible to reach node `n-1` from node `0` within `k` steps or fewer, otherwise return `false`.","solution":"from collections import deque def can_reach_in_k_steps(n, edges, k): Determines if it is possible to reach node n-1 from node 0 within k steps in a directed graph. :param n: Number of nodes in the graph :param edges: List of edges representing the directed graph :param k: Maximum number of steps allowed :return: True if it is possible to reach node n-1 from node 0 within k steps, otherwise False # Representation of graph using adjacency list graph = [[] for _ in range(n)] for u, v in edges: graph[u].append(v) # BFS initialization queue = deque([(0, 0)]) # (current node, current step count) visited = set((0, 0)) # (node, step count) while queue: node, step_count = queue.popleft() # If we reached the target node within k steps if node == n-1 and step_count <= k: return True # Traverse to adjacent nodes if step_count is within bounds if step_count < k: for neighbor in graph[node]: if (neighbor, step_count + 1) not in visited: visited.add((neighbor, step_count + 1)) queue.append((neighbor, step_count + 1)) return False"},{"question":"Given an array of integers `nums` and a target integer `k`, you need to determine if there are three distinct elements in `nums` such that their sum is exactly equal to `k`. Return `true` if such a triplet exists, otherwise return `false`. _Example:_ `nums = [10, 15, 3, 7]`, `k = 25` _Return:_ `true` (since 10 + 15 + 0 = 25)","solution":"def three_sum(nums, k): Determines if there are three distinct elements in `nums` such that their sum is exactly equal to `k`. :param nums: List of integers :param k: Target integer :return: True if such a triplet exists, else False nums.sort() n = len(nums) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: triplet_sum = nums[i] + nums[left] + nums[right] if triplet_sum == k: return True elif triplet_sum < k: left += 1 else: right -= 1 return False"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. We define the **frequency** of an element `x` in `arr` as the number of times it appears in the array. A **subsequence** in `arr` is a sequence that can be derived from `arr` after deleting some or no elements without changing the order of the remaining elements. Return the _length of the longest subsequence such that the frequency of each element in this subsequence is at most `k`._","solution":"from collections import Counter def longest_subsequence(arr, k): Returns the length of the longest subsequence such that the frequency of each element in this subsequence is at most k. Parameters: arr (list of int): the input array k (int): the maximum allowed frequency for each element in the subsequence Returns: int: the length of the longest subsequence # Count the frequency of each element in the array freq = Counter(arr) # Initialize the length of the longest subsequence subsequence_length = 0 # Calculate the possible length of the subsequence for element in freq: if freq[element] <= k: subsequence_length += freq[element] else: subsequence_length += k return subsequence_length"},{"question":"You are given two binary strings `a` and `b` of the same length. Each string represents a binary number, where the leftmost character is the most significant bit. Return _the maximum possible **Hamming distance** between the two binary strings after performing at most one flip operation on any single bit of either string_. The **Hamming distance** between two binary strings is the number of positions at which the corresponding bits are different. If no flip operation is needed to achieve the maximum Hamming distance, return the original Hamming distance itself.","solution":"def max_hamming_distance(a, b): Returns the maximum possible Hamming distance between two binary strings a and b after performing at most one flip operation on any single bit of either string. # Calculate the initial Hamming distance initial_distance = sum(1 for x, y in zip(a, b) if x != y) max_distance = initial_distance n = len(a) # Try flipping each bit in a for i in range(n): flipped_a = a[:i] + (\'0\' if a[i] == \'1\' else \'1\') + a[i+1:] new_distance = sum(1 for x, y in zip(flipped_a, b) if x != y) max_distance = max(max_distance, new_distance) # Try flipping each bit in b for i in range(n): flipped_b = b[:i] + (\'0\' if b[i] == \'1\' else \'1\') + b[i+1:] new_distance = sum(1 for x, y in zip(a, flipped_b) if x != y) max_distance = max(max_distance, new_distance) return max_distance"},{"question":"A company organizes various activities for its employees. Each activity is represented by a tuple `(start_time, end_time)` indicating the start and end times of the activity. Two activities are considered non-overlapping if the end time of one activity is less than or equal to the start time of the other activity. Given a list of activities, determine the maximum number of non-overlapping activities that can be attended by one person. Return the maximum count of non-overlapping activities.","solution":"def max_non_overlapping_activities(activities): Returns the maximum number of non-overlapping activities. if not activities: return 0 # Sort activities by their end times activities.sort(key=lambda x: x[1]) max_activities = 1 # First activity is always selected last_end_time = activities[0][1] for start, end in activities[1:]: if start >= last_end_time: max_activities += 1 last_end_time = end return max_activities"},{"question":"You are given a list of integers `nums` and an integer `k`. Reorder the list such that the element at index `k` moves to the beginning, and all other elements retain their relative order. Return the modified list.","solution":"def reorder_list(nums, k): Reorder the list such that the element at index `k` moves to the beginning, and all other elements retain their relative order. Parameters: nums (list of int): The list of integers. k (int): The index of the element to move to the beginning. Returns: list of int: The reordered list. if k < 0 or k >= len(nums): raise IndexError(\\"k is out of range\\") element = nums.pop(k) return [element] + nums"},{"question":"Write a function `rotate_image` to rotate an `n x n` 2D matrix representing an image by 90 degrees (clockwise). The rotation must be done **in-place**, which means you have to modify the input 2D matrix directly. **Do not** allocate another 2D matrix and perform the rotation.","solution":"def rotate_image(matrix): Rotates the input n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]], the input n x n 2D matrix n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"[Sample New Question]: You are given an unsorted integer array `nums` and an integer target. Return the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Your solution should be efficient with respect to time and space complexities. **Example:** ``` Input: nums = [2, 7, 11, 15], target = 9 Output: [0, 1] ``` In this example, because nums[0] + nums[1] == 9, we return [0, 1].","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to the target. Args: nums : List[int] - an unsorted list of integers target : int - the target sum Returns: List[int] - indices of the two numbers that add up to the target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"You are given a **0-indexed** array `fruits` where `fruits[i]` represents the type of fruit present at the `i-th` position in a row of trees. You can start gathering fruits from any tree, but once you start, you must continue to gather fruits from the next trees sequentially. However, you are allowed to stop and move on to another starting position at most once. Return _the **maximum** number of fruits you can gather_ adhering to the rule that no more than two types of fruits can be in your basket at any point.","solution":"def total_fruit(fruits): Return the maximum number of fruits that can be gathered adhering to the rule that no more than two types of fruits can be in the basket at any point. from collections import defaultdict max_fruits = 0 basket = defaultdict(int) left = 0 for right in range(len(fruits)): basket[fruits[right]] += 1 while len(basket) > 2: basket[fruits[left]] -= 1 if basket[fruits[left]] == 0: del basket[fruits[left]] left += 1 max_fruits = max(max_fruits, right - left + 1) return max_fruits"},{"question":"You are given a **0-indexed** integer array `prices` of length `n` where `prices[i]` denotes the price of the `i-th` item in a store. You want to buy exactly `m` items such that the total cost is minimized. However, you can only buy items from a **contiguous** subarray. Return _the minimum total cost to buy exactly `m` items from a contiguous subarray of `prices`._ If it\'s not possible to buy exactly `m` items, return `-1`.","solution":"def min_cost_to_buy_m_items(prices, m): Returns the minimum total cost to buy exactly m items from a contiguous subarray of prices. If it\'s not possible to buy exactly m items, returns -1. n = len(prices) if m > n: return -1 min_cost = float(\'inf\') current_cost = sum(prices[:m]) for i in range(n - m + 1): if i > 0: current_cost = current_cost - prices[i - 1] + prices[i + m - 1] min_cost = min(min_cost, current_cost) return min_cost if min_cost != float(\'inf\') else -1"},{"question":"You are given an array `arr` of `n` integers and an integer `m`. You need to partition the array into **exactly** `m` non-overlapping, contiguous subarrays, such that the sum of the maximum subarray sum among all the partitions is minimized. Return _the minimized sum of the maximum subarray sum of the partition_. Note: The sum of the maximum subarray sums refers to the maximum subarray sum of each partition summed up together.","solution":"def can_partition(arr, n, m, max_sum): count, current_sum = 1, 0 for num in arr: current_sum += num if current_sum > max_sum: count += 1 current_sum = num if count > m: return False return True def minimize_max_sum_of_partitions(arr, m): start, end = max(arr), sum(arr) result = end while start <= end: mid = (start + end) // 2 if can_partition(arr, len(arr), m, mid): result = mid end = mid - 1 else: start = mid + 1 return result"},{"question":"A company is organizing a marathon event where runners are grouped based on their average speed. Given an array `speeds` where each element represents the average speed of a runner, return the maximum number of runners that can be grouped together such that the difference between the fastest and the slowest runner in the group does not exceed a specified value `max_diff`. Groupings can contain any number of runners and speed must be at least 1 to be valid.","solution":"def max_runners_in_group(speeds, max_diff): Returns the maximum number of runners that can be grouped together such that the difference between the fastest and the slowest runner in the group does not exceed max_diff. :param speeds: List of integers representing the average speeds of the runners. :param max_diff: Integer representing the maximum allowed difference between the fastest and the slowest runner in a group. :return: The maximum number of runners that can be grouped together. if not speeds: return 0 speeds.sort() max_group_size = 1 left = 0 for right in range(1, len(speeds)): while speeds[right] - speeds[left] > max_diff: left += 1 max_group_size = max(max_group_size, right - left + 1) return max_group_size"},{"question":"Given a list of integers `nums` and an integer `n`, move the first `n` elements of `nums` to the end of the list while maintaining their original order. Return the modified list. If `n` is greater than the length of the list, rotate the list completely.","solution":"def move_first_n_to_end(nums, n): Move the first n elements of nums to the end while maintaining their order. If n is greater than the length of nums, the entire list is rotated. length = len(nums) if length == 0 or n == 0: return nums n = n % length # Handle cases where n > length return nums[n:] + nums[:n]"},{"question":"You are asked to implement a simple cache system with Least Recently Used (LRU) eviction policy. Design and implement the `LRUCache` class: * `LRUCache(int capacity)` Initializes the LRU cache with a positive size capacity. * `int get(int key)` Returns the value of the `key` if the `key` exists in the cache, otherwise return `-1`. * `void put(int key, int value)` Update the value of the `key` if the `key` exists. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the capacity, evict the least recently used key. The functions `get` and `put` must each run in O(1) average time complexity.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a positive size capacity. self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Returns the value of the key if the key exists in the cache, otherwise return -1. if key in self.cache: self.cache.move_to_end(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity, evict the least recently used key. if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"A factory is working on an assembly line where each task is assigned a specific amount of time to complete. You are given an integer array `tasks` where `tasks[i]` represents the time required to complete the `ith` task. You are also given an integer `n` that represents the number of workers available. The tasks are assigned such that each worker gets a contiguous block of tasks to perform. The objective is to minimize the maximum working time among all workers after the tasks are assigned. Return the minimum possible maximum working time when the tasks are optimally assigned.","solution":"def canComplete(tasks, workers, maxTime): current_time = 0 needed_workers = 1 for task in tasks: if current_time + task <= maxTime: current_time += task else: needed_workers += 1 current_time = task if needed_workers > workers: return False return True def minimizeMaxWorkingTime(tasks, n): left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if canComplete(tasks, n, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a 0-indexed integer array `nums` and an integer `target`. In one operation, you can select two different indices `i` and `j` such that `0 <= i, j < nums.length` and swap the elements at these indices. Determine the minimum number of operations required to sort the array in such a way that the first element becomes the `target`. If it is not possible to achieve this, return `-1`.","solution":"def min_operations_to_sort_with_target(nums, target): Given a 0-indexed integer array nums and an integer target, determine the minimum number of operations required to sort the array in such a way that the first element becomes the target. If it is not possible to achieve this, return -1. if target not in nums: return -1 target_index = nums.index(target) if target_index == 0: return 0 # We need to count how many moves it would take to bring the target to the first position # We can do this by performing swaps moving it closer to the first position each time. return target_index"},{"question":"You are given an integer array `heights` representing the heights of columns, and an integer `waterLevel` which denotes the initial level of water. Each column acts as a container and can hold water up to the height specified in the array. The water level will distribute evenly among all columns in the array. If the water level exceeds the height of a column, the excess water will overflow to the next columns which can hold more. Return _the final heights of the columns after distributing the water evenly_.","solution":"def distribute_water(heights, waterLevel): Distributes water evenly across the columns up to their respective heights. :param heights: List of integers representing the heights of the columns. :param waterLevel: An integer representing the initial level of water. :returns: List of integers representing the final heights of the columns after distributing water. n = len(heights) if n == 0: return [] for i in range(n): # Calculate the water that can be absorbed by the current column added_water = min(heights[i], waterLevel) heights[i] = added_water # Decrease the water level by the absorbed amount waterLevel -= added_water return heights"},{"question":"Given a list of non-negative integers `nums`, rearrange the digits of each number to form the largest possible integer and return the result as a list. The output should maintain the original list format but with each element being the largest possible permutation of its digits. For example, given `nums = [123, 45, 9]`, the output should be `[321, 54, 9]`.","solution":"def largest_permutation(nums): Given a list of non-negative integers nums, rearrange the digits of each number to form the largest possible integer and return the result as a list. Args: nums: List of non-negative integers Returns: List of integers with each element being the largest possible permutation of its digits. return [int(\'\'.join(sorted(str(num), reverse=True))) for num in nums]"},{"question":"Given a string `s` and an integer array `indices` of the same length. The string `s` and the array `indices` represent a shuffled string such that the character at the `i`th position in `s` should be placed at the `indices[i]` position in the resulting string. Return the restored string. For example, if `s = \\"abcde\\"` and `indices = [4, 3, 2, 1, 0]`, the function should return \\"edcba\\".","solution":"def restore_string(s, indices): Restores a string based on the provided indices. Args: s (str): The shuffled string. indices (list of int): The target indices for each character in s. Returns: str: The restored string. restored = [\'\'] * len(s) for i, index in enumerate(indices): restored[index] = s[i] return \'\'.join(restored)"},{"question":"Given a string `s` consisting of lower-case English letters, divide it into as few parts as possible so that each letter appears in at most one part. Return _a list of integers representing the size of these parts_ in order of their appearance in the original string.","solution":"def partition_labels(s): Given a string s consisting of lower-case English letters, divide it into as few parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts in order of their appearance. last_occurrence = {ch: idx for idx, ch in enumerate(s)} partitions = [] start = end = 0 for idx, ch in enumerate(s): end = max(end, last_occurrence[ch]) if idx == end: partitions.append(end - start + 1) start = end + 1 return partitions"},{"question":"You are given a 2D grid consisting of `m` rows and `n` columns. Each cell in the grid contains either a `0` (empty) or a `1` (occupied). You want to build a house in an empty cell such that the sum of the Manhattan distances from this cell to all other occupied cells is minimized. The Manhattan distance between two cells `(i1, j1)` and `(i2, j2)` is defined as `|i1 - i2| + |j1 - j2|`. Return _the minimum sum of the Manhattan distances from the chosen cell to all other occupied cells_. If it is impossible to build a house, return `-1`.","solution":"def minTotalDistance(grid): Return the minimum sum of Manhattan distances to all occupied cells. if not grid or not grid[0]: return -1 rows = len(grid) cols = len(grid[0]) row_positions = [] col_positions = [] # Collect the coordinates of the occupied cells for r in range(rows): for c in range(cols): if grid[r][c] == 1: row_positions.append(r) col_positions.append(c) if not row_positions: return -1 # The best meeting point is the median of the coordinates row_positions.sort() col_positions.sort() mid_row = row_positions[len(row_positions) // 2] mid_col = col_positions[len(col_positions) // 2] min_distance = sum(abs(r - mid_row) for r in row_positions) + sum(abs(c - mid_col) for c in col_positions) return min_distance"},{"question":"You are given a string `s` consisting of only digits. Your task is to determine how many substrings of `s` form a valid palindrome. A palindrome is a string that reads the same forward and backward. Return the total number of palindrome substrings in `s`.","solution":"def count_palindromic_substrings(s): Returns the total number of palindromic substrings in the given string s. n = len(s) palindromes = [[False] * n for _ in range(n)] count = 0 for i in range(n): palindromes[i][i] = True count += 1 for i in range(n - 1): if s[i] == s[i + 1]: palindromes[i][i + 1] = True count += 1 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and palindromes[i + 1][j - 1]: palindromes[i][j] = True count += 1 return count"},{"question":"You are given a string `s` and an integer `k`. Your task is to determine if the given string can be rearranged such that it becomes a palindrome where exactly `k` characters can be used as the center characters of the palindrome. Note that a palindrome of even length has no center character, while a palindrome of odd length has exactly one center character. If it is possible to rearrange the string `s` into a valid palindrome with `k` center characters, return `true`, otherwise return `false`.","solution":"from collections import Counter def can_rearrange_to_palindrome(s, k): Determines if a given string can be rearranged to form a palindrome with exactly `k` center characters. Parameters: s (str): the input string k (int): number of center characters desired Returns: bool: True if the string can be rearranged to form a palindrome with `k` center characters, otherwise False if k < 0 or k > len(s): return False char_counts = Counter(s) odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) return odd_count <= k"},{"question":"You are given an array `arr` of integers. Implement a data structure that supports the following operations: * `MedianFinder()` Initializes the data structure. * `void addNum(int num)` Adds an integer `num` to the data structure. * `double findMedian()` Returns the median of all elements so far. The median is the middle value in an ordered integer list. If the size of the list is even, the median is the average of the two middle values. For example, * addNum(1) * addNum(2) * findMedian() -> 1.5 * addNum(3) * findMedian() -> 2","solution":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder data structure. self.small = [] # Max heap (inverted to use as min heap) self.large = [] # Min heap def addNum(self, num): Adds an integer num to the data structure. heapq.heappush(self.small, -num) if self.small and self.large and (-self.small[0] > self.large[0]): heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def findMedian(self): Returns the median of all elements so far. if len(self.small) > len(self.large): return -self.small[0] return (-self.small[0] + self.large[0]) / 2.0"},{"question":"Given a string `s` and a dictionary of strings `wordDict`, return _a boolean indicating whether or not_ `s` _can be segmented into a sequence of one or more dictionary words_. Note that the same dictionary word may be reused multiple times if necessary.","solution":"def word_break(s, wordDict): Determines if the string \'s\' can be segmented into a sequence of one or more words from the dictionary \'wordDict\'. Parameters: s (str): The input string. wordDict (List[str]): The list of words representing the dictionary. Returns: bool: True if the string can be segmented, otherwise False. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"You are given a list of positive integers `nums` representing the number of apples in each basket. Your task is to select a subset of baskets such that the sum of apples in the selected baskets is maximized, with the condition that no two selected baskets are adjacent in the list. Return the maximum number of apples you can collect following this rule.","solution":"def max_apples(nums): Calculates the maximum number of apples that can be collected from non-adjacent baskets. :param nums: List of positive integers representing the number of apples in each basket. :return: Maximum number of apples that can be collected under the given rule. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize dp array where dp[i] represents the maximum apples collected up to basket i dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"Given an integer array `arr`, return the length of the shortest continuous subarray, that when sorted, will make the whole array sorted in ascending order. You need to return the length of the subarray, not the subarray itself. The solution should have a time complexity of O(n), where n is the length of the array.","solution":"def findUnsortedSubarray(arr): Given an array of integers, returns the length of the shortest continuous subarray that when sorted, will make the whole array sorted in ascending order. n = len(arr) start, end = -1, -2 min_val, max_val = float(\'inf\'), float(\'-inf\') for i in range(n): max_val = max(max_val, arr[i]) if arr[i] < max_val: end = i for i in range(n-1, -1, -1): min_val = min(min_val, arr[i]) if arr[i] > min_val: start = i return end - start + 1"},{"question":"You are given a string `s` and an integer `k`. A substring of `s` is called **nice** if it contains at least `k` distinct characters. Return the length of the smallest **nice** substring of `s`. If no such substring exists, return `-1`. A **substring** is a contiguous non-empty sequence of characters within a string.","solution":"def smallestNiceSubstring(s, k): if k > len(s): return -1 n = len(s) ans = float(\'inf\') for start in range(n): char_count = {} for end in range(start, n): char_count[s[end]] = char_count.get(s[end], 0) + 1 if len(char_count) >= k: ans = min(ans, end - start + 1) break return ans if ans != float(\'inf\') else -1"},{"question":"Given a list of integers `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. You must write an algorithm that runs in `O(n)` time and uses `O(1)` (i.e., constant) space complexity (disregarding the output array space). Note: The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.","solution":"def product_except_self(nums): n = len(nums) answer = [1] * n left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n-1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"You are given a matrix `mat` of `m` x `n` integers, where each element is either `0` or `1`. Your task is to update the matrix such that each cell contains the distance to the nearest `0`. The distance between two adjacent cells is `1`. Return _the updated matrix_. **Constraints:** - `m` and `n` are in the range `[1, 10000]`. - There is at least one `0` in the matrix.","solution":"from collections import deque def update_matrix(mat): Given a matrix mat of m x n elements where each element is either 0 or 1, update the matrix such that each cell contains the distance to the nearest 0. :param mat: List[List[int]]: The input matrix :return: List[List[int]]: The updated matrix with distances to the nearest 0 if not mat: return mat m, n = len(mat), len(mat[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Initialize the queue with all 0\'s positions queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0]) # Set initial distances to infinity for non-zero elements for i in range(m): for j in range(n): if mat[i][j] != 0: mat[i][j] = float(\'inf\') # BFS from all 0\'s while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy # Check boundaries and if we found a shorter path to a cell if 0 <= nx < m and 0 <= ny < n and mat[nx][ny] > mat[x][y] + 1: mat[nx][ny] = mat[x][y] + 1 queue.append((nx, ny)) return mat"},{"question":"You are given an array of integers `arr` with even length `2n`. You need to reorder the elements of arr in a specific way following these steps: 1. Divide the array into two halves, each of length `n`. 2. Interleave these two halves such that the resulting array starts with the first element of the first half, follows with the first element of the second half, then the second element of the first half, the second element of the second half, and so on. Formally, for an array `arr` of length `2n`, the updated position of each element should be `arr[2 * i]` be from the first half and `arr[2 * i + 1]` from the second half, where `i` is the index within the respective halves. Return the reordered array after interleaving the two halves.","solution":"def interleave_array(arr): Interleave the elements of the given array which has an even length 2n. n = len(arr) // 2 result = [] for i in range(n): result.append(arr[i]) result.append(arr[i + n]) return result"},{"question":"You are given a list of `n` unique integers where each integer is in the range `[1, n]` inclusive. The list is in a random order and exactly one integer is missing. Write a function that returns the missing integer. For example, given the list `[3, 7, 1, 2, 8, 4, 5]` where `n = 8`, the function should return `6` as it is the only integer between `1` and `8` that is not in the list.","solution":"def find_missing_number(nums): Returns the missing integer from a list of numbers ranging from 1 to n. Args: nums (list): List of unique integers in range [1, n] except one missing integer. Returns: int: The missing integer. n = len(nums) + 1 expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"Given a list of `n` integers `nums`, where `n` is greater than 1, your task is to return a list `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`. Solve this problem **without using division** and in `O(n)` time complexity. For example, given `nums = [1,2,3,4]`, the output should be `[24,12,8,6]`.","solution":"def product_except_self(nums): Returns a list such that each element at index i is the product of all the elements of nums except nums[i], without using division. n = len(nums) output = [1] * n # Generate prefix products prefix = 1 for i in range(n): output[i] = prefix prefix *= nums[i] # Generate suffix products and multiply with the prefix products suffix = 1 for i in range(n-1, -1, -1): output[i] *= suffix suffix *= nums[i] return output"},{"question":"Given a string `s`, rearrange the characters of the string so that any two adjacent characters are not the same. If it is not possible to do so, return an empty string. If there are multiple possible answers, return any of them. For example, given `s = \\"aaab\\"`, it cannot be rearranged to avoid adjacent \'a\'s, so the function would return an empty string. Given `s = \\"aab\\"`, a valid rearrangement is `\\"aba\\"`.","solution":"from collections import Counter import heapq def reorganizeString(s): Rearranges the characters of the string so that no two adjacent characters are the same. If it is not possible, returns an empty string. # Count frequency of each character counter = Counter(s) # Create a max heap based on the frequency max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap or prev_freq < 0: if not max_heap: return \\"\\" freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq = freq + 1 prev_char = char return \\"\\".join(result)"},{"question":"Given an array of integers `arr`, you need to partition the array into two non-empty subsets such that the **difference** between the sums of the two subsets is minimized. Return the minimum difference. **Example**: ```python Input: arr = [3, 1, 4, 2, 2] Output: 0 Explanation: We can partition the array into subsets [3, 2, 2] and [1, 4] or [1, 2, 4] and [3, 2]. In both cases, the difference between the sums of the two subsets is 0. ```","solution":"def min_subset_difference(arr): Returns the minimum difference between the sums of two partitions of the array. n = len(arr) total_sum = sum(arr) target = total_sum // 2 # Create a DP array to store subset sums dp = [[False] * (target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if j >= arr[i-1]: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] # Find the closest sum to target for j in range(target, -1, -1): if dp[n][j]: subset_sum = j break other_subset_sum = total_sum - subset_sum return abs(other_subset_sum - subset_sum)"},{"question":"You are given an array `queries` where `queries[i]` is a non-negative integer representing the number of seconds you need to wait for the `i-th` task to be completed. You also have an array `t` where `t[i]` is the number of seconds required to complete the `i-th` task. For each task `i`, if `queries[i]` is greater than or equal to `t[i]`, you can perform the task, otherwise, you cannot. Return the number of tasks that can be performed and the maximum number of seconds you can use from the `queries` array without exceeding their respective limits.","solution":"def tasks_completed_and_max_time(queries, t): Returns the number of tasks that can be performed and the maximum number of seconds used. Parameters: queries (list of int): List of seconds to wait for each task to be available. t (list of int): List of seconds required to complete each task. Returns: tuple: (number of tasks that can be performed, maximum seconds used) completed_tasks = 0 max_time_used = 0 for i in range(len(queries)): if queries[i] >= t[i]: completed_tasks += 1 max_time_used += t[i] return (completed_tasks, max_time_used)"},{"question":"You are given a string `s` and you need to find the longest palindromic substring in `s`. A substring is a contiguous sequence of characters within a string. A palindrome is a sequence of characters that reads the same backward as forward. You should implement an efficient algorithm to return the longest palindromic substring of `s`. If there are multiple solutions, return any one of them.","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. n = len(s) if n == 0: return \\"\\" start, max_len = 0, 1 def expand_from_center(l, r): nonlocal start, max_len while l >= 0 and r < n and s[l] == s[r]: l -= 1 r += 1 new_len = r - l - 1 if new_len > max_len: start = l + 1 max_len = new_len for i in range(n): expand_from_center(i, i) # Odd length palindrome expand_from_center(i, i + 1) # Even length palindrome return s[start:start + max_len]"},{"question":"You are given an integer array `time` where `time[i]` represents the time taken by the `i-th` task. Tasks can be executed in any order, but once a task is started, it must be completed before starting another task. You are also given an integer `d` which represents the mandatory break time after completing each task. Calculate the minimum total time required to complete all the tasks including the mandatory breaks. Return the minimum total time as an integer.","solution":"def min_total_time(time, d): Returns the minimum total time required to complete all tasks including breaks. Parameters: time (list of int): List of time durations for each task. d (int): Mandatory break time after each task. Returns: int: Minimum total time required. if not time: return 0 total_task_time = sum(time) total_break_time = d * (len(time) - 1) return total_task_time + total_break_time"},{"question":"You are given a rectangular grid with `m` rows and `n` columns. Each cell in the grid can either be empty, represented by `0`, or contain an obstacle, represented by `1`. You need to navigate from the top-left corner of the grid to the bottom-right corner. You can only move right or down at any step. Write a function that counts the number of unique paths from the top-left to the bottom-right corner, considering that some cells may contain obstacles. The function should return the number of unique paths modulo `10^9 + 7`. If there is no valid path, return `0`.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. Grid cells are either 0 (empty) or 1 (obstacle). The result is returned as the number of paths modulo 10^9 + 7. MOD = 10**9 + 7 m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[m-1][n-1]"},{"question":"You are managing a library and need to keep track of the books being borrowed. Each book is identified by a unique integer ID. There are `n` books in the library, represented by an integer array `books`, where `books[i]` is the ID of the ith book. You are asked to implement a borrowing system. Each user is identified by a unique integer ID. When a user borrows a book, the system should ensure that the book is available. Additionally, the system should be able to inform if a book is already borrowed by another user. To implement this system, create a class `Library` with the following methods: - `borrowBook(int userId, int bookId)`: Marks the `bookId` as borrowed by `userId`. If the book is already borrowed by someone else, the method should return `false`. Otherwise, return `true`. - `returnBook(int userId, int bookId)`: Marks the `bookId` as returned by `userId`. If the book was not borrowed by this user, the method should return `false`. Otherwise, return `true`. - `isBookBorrowed(int bookId)`: Checks if the `bookId` is currently borrowed by any user. Return `true` if the book is borrowed, otherwise return `false`. Implement the `Library` class to manage book borrowing and returning efficiently.","solution":"class Library: def __init__(self, books): Initialize the Library with a list of books. :param books: List of book IDs available in the library. self.books = set(books) self.borrowed_books = {} def borrowBook(self, userId, bookId): Attempts to borrow a book for the user. :param userId: The ID of the user attempting to borrow the book. :param bookId: The ID of the book to be borrowed. :return: True if the book was successfully borrowed, False otherwise. if bookId not in self.books or bookId in self.borrowed_books: return False self.borrowed_books[bookId] = userId return True def returnBook(self, userId, bookId): Attempts to return a book for the user. :param userId: The ID of the user attempting to return the book. :param bookId: The ID of the book to be returned. :return: True if the book was successfully returned, False otherwise. if bookId not in self.borrowed_books or self.borrowed_books[bookId] != userId: return False del self.borrowed_books[bookId] return True def isBookBorrowed(self, bookId): Check if a book is currently borrowed. :param bookId: The ID of the book to check. :return: True if the book is borrowed, False otherwise. return bookId in self.borrowed_books"},{"question":"Given a string `s` and an integer `n`, return a list of all unique substrings of length `n` that appear more than once in the string `s`. If no such substrings exist, return an empty list.","solution":"def find_repeated_substrings(s, n): Returns a list of all unique substrings of length `n` that appear more than once in the string `s` from collections import defaultdict if n <= 0 or n > len(s): return [] substr_count = defaultdict(int) unique_substrings = set() for i in range(len(s) - n + 1): substr = s[i:i+n] substr_count[substr] += 1 if substr_count[substr] > 1: unique_substrings.add(substr) return list(unique_substrings)"},{"question":"You are given an array of strings `words` and a string `chars`. A string from `words` is considered \\"good\\" if it can be formed by characters from `chars` (each character can only be used once in `chars`). Return the sum of the lengths of all \\"good\\" strings in `words`. You must write an efficient algorithm that solves the problem in `O(n)` time complexity, where `n` is the number of characters in `words`.","solution":"from collections import Counter def count_good_strings(words, chars): Returns the sum of the lengths of all \\"good\\" strings in the array `words`. A string is considered \\"good\\" if it can be formed by characters from `chars` (each character can only be used once in `chars`). Parameters: words (list of str): The list of words to check. chars (str): The string containing available characters. Returns: int: The sum of the lengths of all good strings. chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= chars_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"You are given a string `s` containing only characters \'a\' and \'b\'. You want to split the string into as many pieces as possible, such that each piece contains no consecutive characters that are the same. Return the maximum number of pieces you can split the string into.","solution":"def max_pieces(s): Returns the maximum number of pieces a given string can be split into, such that each piece contains no consecutive characters that are the same. if not s: return 0 pieces = 1 previous_char = s[0] for char in s[1:]: if char == previous_char: # Consecutive characters are the same, start a new piece pieces += 1 previous_char = char return pieces"},{"question":"Given an integer array `arr` consisting of positive integers, your task is to rearrange its elements such that the difference between any two adjacent elements is not greater than `2`. Return any such valid rearrangement of the array. Note: - The input array will always have at least one valid rearrangement. - If there are multiple correct answers, you can return any of them.","solution":"def rearrange_array(arr): Rearrange the elements of the array such that the difference between any two adjacent elements is not greater than 2. Parameters: arr (list): A list of positive integers. Returns: list: A rearranged list with the required property. # Sort the array to make it easier to place elements such that they differ by at most 2 arr.sort() return arr"},{"question":"Given a list of non-negative integers `nums`, you are tasked with finding the **third** maximum number in this list. If the third maximum does not exist, return the maximum number. Implement the function `int thirdMax(int[] nums)` which returns the third maximum number in the list. Note: The time complexity should be `O(n)`.","solution":"def thirdMax(nums): Returns the third maximum number in the list, or the maximum if the third does not exist. first = second = third = float(\'-inf\') for num in nums: if num in (first, second, third): continue if num > first: first, second, third = num, first, second elif num > second: second, third = num, second elif num > third: third = num return third if third != float(\'-inf\') else first"},{"question":"Given a list of `n` words, each word composed of lowercase English letters, return all words that can be typed using letters of alphabet on only one row of the American QWERTY keyboard. You may return the answer in **any order**. A word is described as such if it can be typed by only pressing keys from a single row of the keyboard.","solution":"def find_words_by_keyboard_row(words): Returns words that can be typed using letters of alphabet on only one row of the American QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = set(word.lower()) if lower_word <= row1 or lower_word <= row2 or lower_word <= row3: result.append(word) return result"},{"question":"Implement a class `Trie` (prefix tree), which is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. Your implementation should support the following operations: * `Trie( )` Initializes the trie object. * `void insert(String word)` Inserts the string `word` into the trie. * `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise. * `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that starts with the prefix `prefix`, and `false` otherwise.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): Inserts the string `word` into the trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def startsWith(self, prefix): Returns `true` if there is a previously inserted string `word` that starts with the prefix `prefix`, and `false` otherwise. node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"Implement a data structure that supports the following operations on a **fixed-size** stack of integers: * `Stack(int size)` Constructs a stack with the given `size`. * `void push(int value)` Adds `value` to the top of the stack if the stack is not full. If the stack is full, do nothing. * `int pop()` Removes and returns the value from the top of the stack if the stack is not empty. If the stack is empty, return `-1`. * `int increment(int k, int val)` Adds `val` to the bottom `k` elements of the stack. If there are fewer than `k` elements in the stack, add `val` to all elements. Design the data structure to optimize the `increment` operation so that it is efficient for large `k`.","solution":"class Stack: def __init__(self, size): self.stack = [] self.size = size def push(self, value): if len(self.stack) < self.size: self.stack.append(value) def pop(self): if self.stack: return self.stack.pop() else: return -1 def increment(self, k, val): for i in range(min(k, len(self.stack))): self.stack[i] += val"},{"question":"You are given a `n` x `n` grid filled with integers. Each integer represents the height of a terrain at that point. You need to find the **minimum path sum** from the top-left corner to the bottom-right corner of the grid. You can only move down or right at any point in time. Return the minimum path sum. For example, given the following grid: ``` [[1, 3, 1], [1, 5, 1], [4, 2, 1]] ``` The minimum path sum is 7 (1 → 3 → 1 → 1 → 1). (Note: The `n` in the grid size is not bound to any specific constraints but should be a positive integer, and the values within the grid are also positive integers.)","solution":"def min_path_sum(grid): Finds the minimum path sum in a n x n grid from top-left to bottom-right corner, only moving down or right. :param grid: List of lists where each sublist represents a row in the grid :return: The minimum path sum n = len(grid) if n == 0: return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][n - 1]"},{"question":"You are given an array of positive integers representing the strengths of soldiers in a military formation. A soldier can attack another soldier if their strength is less. You need to find the number of unique pairs of soldiers (i, j) such that the strength of soldier `i` is less than the strength of soldier `j`, and `i` is less than `j`. Return the number of such pairs.","solution":"def count_attack_pairs(soldier_strengths): Returns the number of unique pairs of soldiers (i, j) such that the strength of soldier i is less than the strength of soldier j, and i is less than j. n = len(soldier_strengths) count = 0 for i in range(n): for j in range(i + 1, n): if soldier_strengths[i] < soldier_strengths[j]: count += 1 return count"},{"question":"Given a linked list, determine if it contains a cycle. A linked list contains a cycle if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail\'s `next` pointer is connected to. **Note** that `pos` is not passed as a parameter. Return `true` if there is a cycle in the linked list. Otherwise, return `false`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Determine if a linked list has a cycle. :param head: ListNode :return: bool if head is None: return False slow = head fast = head.next while slow != fast: if fast is None or fast.next is None: return False slow = slow.next fast = fast.next.next return True"},{"question":"You are given a string `s`, where each character in the string represents a fruit type. You have a basket that can carry at most two different types of fruits. You want to collect the maximum number of fruits possible without breaking the basket’s rule. Write a function to return the length of the longest substring of `s` that includes no more than two distinct characters.","solution":"def max_fruit_length(s): Returns the length of the longest substring that contains no more than two distinct characters. if not s: return 0 max_length = 0 start = 0 fruit_count = {} for end in range(len(s)): fruit = s[end] fruit_count[fruit] = fruit_count.get(fruit, 0) + 1 while len(fruit_count) > 2: fruit_count[s[start]] -= 1 if fruit_count[s[start]] == 0: del fruit_count[s[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an integer array `heights` representing the heights of buildings, you are tasked with solving the **Longest Increasing Subsequence (LIS)** problem. The sequence should not be contiguous, but the order must be preserved. The goal is to determine the maximum number of buildings you can include in this subsequence, such that each building in the subsequence is taller than the one before it. Return the length of the longest increasing subsequence of buildings\' heights.","solution":"def length_of_lis(heights): Returns the length of the longest increasing subsequence of building heights. if not heights: return 0 n = len(heights) dp = [1] * n for i in range(n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given an integer `k` and a binary string `s`, determine the **minimum number** of contiguous substrings the binary string `s` can be divided into such that each substring contains at least `k` consecutive \'1\'s. If it is not possible to achieve this, return `-1`.","solution":"def min_substrings_with_k_consecutive_ones(s: str, k: int) -> int: Returns the minimum number of contiguous substrings the binary string `s` can be divided into such that each substring contains at least `k` consecutive \'1\'s. If it is not possible to achieve this, returns `-1`. if k <= 0: return -1 count = 0 i = 0 n = len(s) while i < n: consecutive_ones = 0 # Count consecutive \'1\'s while i < n and s[i] == \'1\': consecutive_ones += 1 i += 1 # If we found a segment with at least k \'1\'s, increment the count if consecutive_ones >= k: count += 1 # Move to the next segment while i < n and s[i] == \'0\': i += 1 # If no segment with enough \'1\'s found, return -1 if count == 0: return -1 return count"},{"question":"Given an array `nums` of `n` integers, where `n` is even, you need to perform `n/2` operations. In each operation, you can choose two indices `i` and `j` (`0 <= i, j < n`, `i != j`) and remove the elements at `nums[i]` and `nums[j]` from the array. The cost of this operation is `nums[i] + nums[j]`. Your goal is to minimize the total cost of the operations. Return the minimum total cost after performing all the operations.","solution":"def min_cost_operations(nums): Given an array of n integers where n is even, this function performs n/2 operations to remove pairs of integers with the minimum cost defined as the sum of the pairs. # Sort the array to pair smallest available values first nums.sort() total_cost = 0 n = len(nums) # Iterate over the array, taking pairs from the beginning for i in range(n // 2): total_cost += nums[i] + nums[n - 1 - i] return total_cost"},{"question":"You are given two string arrays `word1` and `word2`. Each string array represents a single string in the form of an array of individual characters. Determine whether the concatenation of all the strings in `word1` is equal to the concatenation of all the strings in `word2`. Return `true` if the two concatenated strings are equal, and `false` otherwise.","solution":"def array_strings_are_equal(word1, word2): Returns True if the concatenation of all strings in word1 is equal to the concatenation of all strings in word2. Otherwise, returns False. return \'\'.join(word1) == \'\'.join(word2)"},{"question":"A sequence of numbers is called a **peak sequence** if every even-indexed element is greater than its neighboring odd-indexed elements. Given an integer array `nums`, rearrange `nums` into a peak sequence. If there are multiple valid arrangements, return any of them. If no valid peak sequence can be formed, return an empty array.","solution":"def create_peak_sequence(nums): Rearranges nums into a peak sequence where every even-indexed element is greater than its neighboring odd-indexed elements. If multiple valid arrangements exist, returns any of them. Returns an empty array if no valid arrangement can be formed. # First, sort the input array nums.sort() length = len(nums) if length < 3: return nums # If the length is less than 3, any permutation is a peak sequence # Construct the peak sequence array peak_sequence = [None] * length # Place the highest elements at even indexes even_index = 0 for i in range((length + 1) // 2): peak_sequence[even_index] = nums[-(i + 1)] even_index += 2 # Place the remaining elements at odd indexes odd_index = 1 for i in range((length + 1) // 2, length): peak_sequence[odd_index] = nums[-(i + 1)] odd_index += 2 return peak_sequence"},{"question":"You are given a list of `tasks` where each task is represented by a pair of its start and end time. The start and end times are positive integers, and the end time is always greater than the start time. Two tasks are considered to be non-overlapping if one task ends before the other starts. Your task is to find the maximum number of non-overlapping tasks that can be completed. Return _the number of non-overlapping tasks that can be completed._ Example: ```python Input: tasks = [(1, 3), (2, 5), (4, 6), (7, 8)] Output: 3 Explanation: One possible set of non-overlapping tasks is [(1, 3), (4, 6), (7, 8)]. ```","solution":"def max_non_overlapping_tasks(tasks): Finds the maximum number of non-overlapping tasks. Parameters: tasks (list): A list of tuples representing tasks (start time, end time). Returns: int: The maximum number of non-overlapping tasks that can be completed. # Sort tasks based on end time tasks.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"Given an array of integers `nums` and an integer `k`, your task is to find the length of the longest contiguous subarray that contains at most `k` distinct integers. Return the length of this subarray. Use the sliding window technique to optimize the solution. The array and the value of `k` will be provided as input.","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest contiguous subarray that contains at most `k` distinct integers. Parameters: nums (list): List of integers. k (int): Maximum number of distinct integers allowed in the subarray. Returns: int: Length of the longest subarray with at most `k` distinct integers. from collections import defaultdict n = len(nums) left = 0 right = 0 max_length = 0 window_count = defaultdict(int) unique_count = 0 while right < n: if window_count[nums[right]] == 0: unique_count += 1 window_count[nums[right]] += 1 right += 1 while unique_count > k: window_count[nums[left]] -= 1 if window_count[nums[left]] == 0: unique_count -= 1 left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"Given a list of strings `words`, return _the longest word in the list that is lexicographically smallest_. If there are multiple words with the same length, return the smallest one lexicographically. If the list is empty, return an empty string.","solution":"def longest_lexicographically_smallest(words): Returns the longest word in the list that is lexicographically smallest. If there are multiple words with the same length, returns the smallest one lexicographically. If the list is empty, returns an empty string. if not words: return \\"\\" # Sort words first by length (descending) and then lexicographically words.sort(key=lambda x: (-len(x), x)) # The first word in the sorted list will be the required word return words[0]"}]'),N={name:"App",components:{PoemCard:Y},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},z={class:"card-container"},C={key:0,class:"empty-state"},L=["disabled"],S={key:0},E={key:1};function D(i,e,u,c,a,s){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>a.searchQuery=o),placeholder:"Search..."},null,512),[[b,a.searchQuery]]),a.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>a.searchQuery="")}," ✕ ")):l("",!0)]),t("div",z,[(n(!0),r(y,null,w(s.displayedPoems,(o,g)=>(n(),v(f,{key:g,poem:o},null,8,["poem"]))),128)),s.displayedPoems.length===0?(n(),r("div",C,' No results found for "'+h(a.searchQuery)+'". ',1)):l("",!0)]),s.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:a.isLoading,onClick:e[2]||(e[2]=(...o)=>s.loadMore&&s.loadMore(...o))},[a.isLoading?(n(),r("span",E,"Loading...")):(n(),r("span",S,"See more"))],8,L)):l("",!0)])}const G=m(N,[["render",D],["__scopeId","data-v-ee950792"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/1.md","filePath":"drive/1.md"}'),O={name:"drive/1.md"},W=Object.assign(O,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{M as __pageData,W as default};
