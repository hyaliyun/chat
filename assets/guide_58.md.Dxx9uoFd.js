import{_,o as s,c as n,a as t,m,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(r,e,u,c,i,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(u.poem.solution),1)])])])}const A=_(q,[["render",R],["__scopeId","data-v-b360f9fb"]]),S=JSON.parse(`[{"question":"def findLongestConcatenatedWord(words): Given an array of words where each word is represented as a string, find the longest concatenated word in the list such that it can be entirely constructed by concatenating the other words from the list. If more than one such longest word exists, return the first one found. If no concatenated word exists, return an empty string. Args: words: List[str] - List of words Returns: str - The longest concatenated word (or first one found if multiple exist), or an empty string Example: >>> findLongestConcatenatedWord([\\"cat\\", \\"cats\\", \\"catsdogcats\\", \\"dog\\", \\"dogcatsdog\\", \\"hippopotamuses\\", \\"rat\\", \\"ratcatdogcat\\"]) 'ratcatdogcat' >>> findLongestConcatenatedWord([\\"cat\\", \\"dog\\", \\"catdog\\"]) 'catdog' pass # Unit Tests def test_example_1(): assert findLongestConcatenatedWord([\\"cat\\", \\"cats\\", \\"catsdogcats\\", \\"dog\\", \\"dogcatsdog\\", \\"hippopotamuses\\", \\"rat\\", \\"ratcatdogcat\\"]) == \\"ratcatdogcat\\" def test_example_2(): assert findLongestConcatenatedWord([\\"cat\\", \\"dog\\", \\"catdog\\"]) == \\"catdog\\" def test_no_concatenated_word(): assert findLongestConcatenatedWord([\\"a\\", \\"b\\", \\"c\\"]) == \\"\\" def test_two_longest_words(): assert findLongestConcatenatedWord([\\"cat\\", \\"dog\\", \\"catdog\\", \\"dogcat\\"]) == \\"catdog\\" def test_single_word(): assert findLongestConcatenatedWord([\\"a\\"]) == \\"\\" def test_words_with_same_length(): assert findLongestConcatenatedWord([\\"abab\\", \\"ab\\", \\"ab\\", \\"cdcd\\", \\"cdcdcdcd\\"]) == \\"cdcdcdcd\\" def test_prefix_cases(): assert findLongestConcatenatedWord([\\"star\\", \\"fish\\", \\"starfish\\", \\"starfishfish\\", \\"starfishfishstar\\"]) == \\"starfishfishstar\\"","solution":"def findLongestConcatenatedWord(words): words_set = set(words) def can_form(word, original_word): if word in words_set and word != original_word: return True for i in range(1, len(word)): prefix, suffix = word[:i], word[i:] if prefix in words_set and suffix != original_word and can_form(suffix, original_word): return True return False words.sort(key=lambda x: len(x), reverse=True) for word in words: if can_form(word, word): return word return \\"\\""},{"question":"def smallest_diff_for_queries(T, test_cases): Takes the number of test cases and the test case data, computes smallest performance difference for specified employee pairs. Args: T (int): Number of test cases. test_cases (list): List of tuples where each tuple contains: - N (int): Number of employees. - M (int): Number of projects. - performance_ratings (list of list of int): The performance ratings for each employee. - Q (int): Number of queries. - queries (list of tuple of int): List of tuples where each tuple contains pair of employee indices. Returns: list: List of smallest performance differences for each query of each test case. pass # Test cases from solution import smallest_diff_for_queries def test_single_test_case(): T = 1 test_cases = [ (3, 4, [ [20, 30, 40, 50], [25, 35, 45, 55], [10, 20, 30, 40] ], 2, [ (1, 2), (1, 3) ]) ] result = smallest_diff_for_queries(T, test_cases) assert result == [5, 10] def test_multiple_test_cases(): T = 2 test_cases = [ (3, 4, [ [20, 30, 40, 50], [25, 35, 45, 55], [10, 20, 30, 40] ], 2, [ (1, 2), (1, 3) ]), (2, 3, [ [50, 60, 70], [55, 65, 75] ], 1, [ (1, 2) ]) ] result = smallest_diff_for_queries(T, test_cases) assert result == [5, 10, 5] def test_no_difference(): T = 1 test_cases = [ (2, 3, [ [20, 20, 20], [20, 20, 20] ], 1, [ (1, 2) ]) ] result = smallest_diff_for_queries(T, test_cases) assert result == [0] def test_large_difference(): T = 1 test_cases = [ (3, 3, [ [0, 100, 50], [100, 0, 50], [50, 50, 50] ], 2, [ (1, 2), (1, 3) ]) ] result = smallest_diff_for_queries(T, test_cases) assert result == [0, 0] def test_single_project(): T = 1 test_cases = [ (3, 1, [ [20], [25], [10] ], 2, [ (1, 2), (1, 3) ]) ] result = smallest_diff_for_queries(T, test_cases) assert result == [5, 10]","solution":"def smallest_diff_for_queries(T, test_cases): Takes the number of test cases and the test case data, computes smallest performance difference for specified employee pairs. results = [] for i in range(T): case = test_cases[i] N, M, performance_ratings, Q, queries = case for u, v in queries: u -= 1 # Convert 1-based index to 0-based v -= 1 # Convert 1-based index to 0-based min_diff = float('inf') for m in range(M): diff = abs(performance_ratings[u][m] - performance_ratings[v][m]) if diff < min_diff: min_diff = diff results.append(min_diff) return results # Example usage T = 1 test_cases = [ (3, 4, [ [20, 30, 40, 50], [25, 35, 45, 55], [10, 20, 30, 40] ], 2, [ (1, 2), (1, 3) ]) ] print(smallest_diff_for_queries(T, test_cases))"},{"question":"def is_rotation(s1: str, s2: str) -> bool: Determines if s1 is a rotation of s2. >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotation(\\"hello\\", \\"ohell\\") True >>> is_rotation(\\"hello\\", \\"world\\") False >>> is_rotation(\\"abc\\", \\"cab\\") True >>> is_rotation(\\"abc\\", \\"bca\\") True","solution":"def is_rotation(s1: str, s2: str) -> bool: Determines if s1 is a rotation of s2. if len(s1) != len(s2): return False concatenated = s1 + s1 return s2 in concatenated"},{"question":"class ScoreManager: A class to manage and query scores of students efficiently. >>> sm = ScoreManager() >>> sm.add(10) >>> sm.add(20) >>> sm.scores [10, 20] >>> sm.remove(10) >>> sm.scores [20] >>> sm.find(20) 1 >>> sm.find(10) 0 >>> sm.min() 20 >>> sm.max() 20 >>> sm.add(30) >>> sm.average() 25 >>> sm.count() 2 >>> sm.remove(20) >>> sm.min() 30 def __init__(self): self.scores = [] def add(self, score): pass def remove(self, score): pass def find(self, score): pass def min(self): pass def max(self): pass def average(self): pass def count(self): pass","solution":"class ScoreManager: def __init__(self): self.scores = [] def add(self, score): self.scores.append(score) def remove(self, score): if score in self.scores: self.scores.remove(score) def find(self, score): return 1 if score in self.scores else 0 def min(self): return min(self.scores) if self.scores else \\"EMPTY\\" def max(self): return max(self.scores) if self.scores else \\"EMPTY\\" def average(self): return sum(self.scores) // len(self.scores) if self.scores else \\"EMPTY\\" def count(self): return len(self.scores)"},{"question":"def can_form_teams(t: int, cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if it's possible to organize the given participants into \`k\` teams where the sum of IDs in every team is the same. Parameters: t (int): Number of test cases. cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases, where each test case contains a tuple of (number of participants, number of teams), and a list of participant IDs. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_form_teams(3, [[(6, 3), [3, 3, 3, 3, 3, 3]], [(6, 2), [1, 2, 3, 4, 5, 6]], [(5, 2), [1, 1, 1, 1, 6]]]) ['YES', 'NO', 'NO']","solution":"def can_form_teams(t, cases): results = [] for i in range(t): n, k = cases[i][0] participants = cases[i][1] total_sum = sum(participants) if total_sum % k != 0: results.append(\\"NO\\") continue target_sum = total_sum // k participants.sort(reverse=True) def backtrack(start, curr_sum, count_used): if count_used == k: return True if curr_sum == target_sum: return backtrack(0, 0, count_used + 1) for i in range(start, n): if not visited[i] and curr_sum + participants[i] <= target_sum: visited[i] = True if backtrack(i + 1, curr_sum + participants[i], count_used): return True visited[i] = False return False visited = [False] * n can_be_divided = backtrack(0, 0, 0) results.append(\\"YES\\" if can_be_divided else \\"NO\\") return results"},{"question":"def is_mirror_array(n: int, array: List[int]) -> str: Determines if the given array is a mirror-array. Args: n (int): The length of the array. array (list of int): The array of integers. Returns: str: \\"YES\\" if the array is a mirror-array, otherwise \\"NO\\". >>> is_mirror_array(5, [1, 2, 3, 2, 1]) 'YES' >>> is_mirror_array(4, [1, 2, 2, 3]) 'NO' >>> is_mirror_array(1, [7]) 'YES'","solution":"def is_mirror_array(n, array): Determines if the given array is a mirror-array. Args: n (int): The length of the array. array (list of int): The array of integers. Returns: str: \\"YES\\" if the array is a mirror-array, otherwise \\"NO\\". for i in range(n // 2): if array[i] != array[n - 1 - i]: return \\"NO\\" return \\"YES\\" # Example Usage n = 5 array = [1, 2, 3, 2, 1] print(is_mirror_array(n, array)) # Output: YES"},{"question":"def min_operations_to_equalize_array(n, arr): Determines the minimum number of operations needed to make all elements in arr equal via the specified operation, and returns that number. If it's impossible, returns -1. Args: n : int : number of elements in the array arr : list of int : the elements of the array Returns: int : the minimum number of operations required, or -1 if impossible >>> min_operations_to_equalize_array(5, [1, 2, 3, 4, 5]) 4 >>> min_operations_to_equalize_array(4, [2, 2, 2, 2]) 0 >>> min_operations_to_equalize_array(3, [1, 1, 2]) 1 def minimum_operations(t, test_cases): Processes multiple test cases to determine the minimum number of operations needed for each array in \`test_cases\`. Args: t : int : number of test cases test_cases : list of tuples : list containing t tuples, each of which contains n and the array Returns: list of int : the minimum number of operations for each test case >>> minimum_operations(3, [(5, [1, 2, 3, 4, 5]), (4, [2, 2, 2, 2]), (3, [1, 1, 2])]) [4, 0, 1] >>> minimum_operations(1, [(3, [7, 7, 7])]) [0]","solution":"def min_operations_to_equalize_array(n, arr): Determines the minimum number of operations needed to make all elements in arr equal via the specified operation, and returns that number. If it's impossible, returns -1. Args: n : int : number of elements in the array arr : list of int : the elements of the array Returns: int : the minimum number of operations required, or -1 if impossible # Check if all elements are already the same if len(set(arr)) == 1: return 0 # Otherwise, return the number of distinct elements minus 1. distinct_elements = len(set(arr)) return distinct_elements - 1 def minimum_operations(t, test_cases): Processes multiple test cases to determine the minimum number of operations needed for each array in \`test_cases\`. Args: t : int : number of test cases test_cases : list of tuples : list containing t tuples, each of which contains n and the array Returns: list of int : the minimum number of operations for each test case results = [] for n, arr in test_cases: result = min_operations_to_equalize_array(n, arr) results.append(result) return results"},{"question":"def parse_input_and_solve(input_string): Given the input string containing multiple test cases, determine for each test case if it is possible that the constraints were maintained throughout the production process. >>> parse_input_and_solve(\\"2n1 3n5 3 4n6 2 7n3 1 5n2 1n4 5 6n\\") ['NO', 'YES'] from solution import parse_input_and_solve def test_single_case_all_possible(): input_data = \\"1n1 3n5 3 4n6 2 7n3 1 5n\\" assert parse_input_and_solve(input_data) == [\\"NO\\"] def test_single_case_possible(): input_data = \\"1n2 1n4 5 6n\\" assert parse_input_and_solve(input_data) == [\\"YES\\"] def test_multiple_cases(): input_data = \\"2n1 3n5 3 4n6 2 7n3 1 5n2 1n4 5 6n\\" assert parse_input_and_solve(input_data) == [\\"NO\\", \\"YES\\"] def test_edge_case_minimal(): input_data = \\"1n1 1n1 1 1n\\" assert parse_input_and_solve(input_data) == [\\"YES\\"] def test_edge_case_maximum_violation(): input_data = \\"1n1 1n0 0 1n\\" assert parse_input_and_solve(input_data) == [\\"NO\\"] def test_edge_case_maximal(): input_data = \\"1n1000 1n1000 1000 1000n\\" assert parse_input_and_solve(input_data) == [\\"YES\\"]","solution":"def check_batches(T, cases): results = [] for case in cases: K, N, batches = case possible = True for batch in batches: a, b, c = batch if a + b < c or abs(a - b) > K: possible = False break results.append(\\"YES\\" if possible else \\"NO\\") return results def parse_input_and_solve(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) index = 1 cases = [] for _ in range(T): K, N = map(int, input_lines[index].split()) batches = [tuple(map(int, input_lines[index + i + 1].split())) for i in range(N)] cases.append((K, N, batches)) index += N + 1 return check_batches(T, cases)"},{"question":"def min_changes_to_balance(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of changes required to make a sequence of integers balanced. A sequence is called balanced if the sum of the integers in the first half is equal to the sum of the integers in the second half. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains: - n (int): The length of the sequence (even integer). - arr (List[int]): The sequence of integers. Returns: List[int]: A list where each element is the minimum number of changes required to balance the corresponding sequence. Examples: >>> min_changes_to_balance(3, [(6, [1, 2, 3, 3, 2, 1]), (4, [4, 5, 6, 7]), (2, [5, 10])]) [0, 1, 1] >>> min_changes_to_balance(1, [(4, [10, 20, 30, 40])]) [1]","solution":"def min_changes_to_balance(t, test_cases): results = [] for case in test_cases: n, arr = case left_sum = sum(arr[:n//2]) right_sum = sum(arr[n//2:]) if left_sum == right_sum: results.append(0) continue difference = abs(left_sum - right_sum) # To balance the array, we need at least one number to change results.append(1 if difference != 0 else 0) return results"},{"question":"def is_valid_sequence(s: str) -> str: Determines if the sequence of parentheses, brackets, and braces is valid. Args: s (str): input string containing '(', ')', '{', '}', '[' and ']' Returns: str: \\"YES\\" if the sequence is valid, otherwise \\"NO\\" >>> is_valid_sequence(\\"()[]{}\\") \\"YES\\" >>> is_valid_sequence(\\"([)]\\") \\"NO\\" >>> is_valid_sequence(\\"{\\") \\"NO\\" >>> is_valid_sequence(\\"{[]}\\") \\"YES\\" >>> is_valid_sequence(\\"(]\\") \\"NO\\" >>> is_valid_sequence(\\"([}}])\\") \\"NO\\" >>> is_valid_sequence(\\"\\") \\"YES\\" >>> is_valid_sequence(\\"{{[[((()))]]}}\\") \\"YES\\" >>> is_valid_sequence(\\"{{[[((())]]}}\\") \\"NO\\"","solution":"def is_valid_sequence(s): Determines if the sequence of parentheses, brackets, and braces is valid. Args: s (str): input string containing '(', ')', '{', '}', '[' and ']' Returns: str: \\"YES\\" if the sequence is valid, otherwise \\"NO\\" stack = [] # Define matching pairs matching_pairs = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_pairs.values(): # If the character is one of the opening characters, push it to the stack stack.append(char) elif char in matching_pairs.keys(): # If the character is one of the closing characters, check for a match if not stack or stack[-1] != matching_pairs[char]: return \\"NO\\" stack.pop() else: return \\"NO\\" # In case there is an invalid character return \\"YES\\" if not stack else \\"NO\\""},{"question":"def minimum_swaps_to_sort(arr): Given an almost sorted array, returns the minimum number of swaps needed to sort the array. >>> minimum_swaps_to_sort([1, 3, 5, 4, 6]) 1 >>> minimum_swaps_to_sort([2, 1, 4, 5, 6, 7]) 1 >>> minimum_swaps_to_sort([1, 2, 3, 5, 7, 6, 4]) 2 >>> minimum_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> minimum_swaps_to_sort([1, 3, 2, 4, 5]) 1","solution":"def minimum_swaps_to_sort(arr): Given an almost sorted array, returns the minimum number of swaps needed to sort the array. # Find the positions where the array is out of order. n = len(arr) wrong_positions = [] for i in range(n-1): if arr[i] > arr[i+1]: wrong_positions.append(i) wrong_positions.append(i+1) # If no wrong positions found, array is already sorted. if not wrong_positions: return 0 # Since it is almost sorted, wrong_positions should have at most 4 different indices. wrong_positions = list(set(wrong_positions)) # Remove duplicates # If more than 2 pairs of wrong positions are found, we need to make sure they are consecutive. if len(wrong_positions) == 2: # Only one swap needed return 1 elif len(wrong_positions) == 4: # Check if we can sort by one or two swaps i1, i2 = wrong_positions[0], wrong_positions[1] j1, j2 = wrong_positions[2], wrong_positions[3] if (arr[i1] <= arr[i2 + 1] and arr[j1] <= arr[j2 + 1]): return 1 else: return 2 else: # Default case return 2"},{"question":"def find_longest_word(sentence: str) -> str: Returns the longest word in the given sentence. If there are multiple words with the same maximum length, returns the one that appears first in the sentence. >>> find_longest_word(\\"I love programming in Python\\") 'programming' >>> find_longest_word(\\"I adore Kubernetes Clouds\\") 'Kubernetes' >>> find_longest_word(\\"Hippopotamus\\") 'Hippopotamus' >>> find_longest_word(\\"cat dog\\") 'cat' >>> find_longest_word(\\"\\") '' >>> find_longest_word(\\"cat bat rat sat mat\\") 'cat'","solution":"def find_longest_word(sentence): Returns the longest word in the given sentence. If there are multiple words with the same maximum length, returns the one that appears first in the sentence. words = sentence.split() longest_word = \\"\\" for word in words: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"def determine_winner(n): Determines the winner of the game based on the number of coins. Args: n (int): Number of coins. Returns: str: 'First' if the first player wins, else returns 'Second'. >>> determine_winner(1) 'First' >>> determine_winner(2) 'Second' >>> determine_winner(4) 'Second' pass def solve_game(T, cases): Solves the game for T test cases and returns a list of results. Each result is either 'First' or 'Second'. Args: T (int): Number of test cases. cases (List[int]): List of coins in each test case. Returns: List[str]: List of results for each test case. >>> solve_game(3, [1, 2, 4]) ['First', 'Second', 'Second'] >>> solve_game(1, [7]) ['First'] >>> solve_game(4, [8, 13, 21, 34]) ['Second', 'First', 'First', 'Second'] pass def test_determine_winner(): assert determine_winner(1) == 'First' assert determine_winner(2) == 'Second' assert determine_winner(4) == 'Second' assert determine_winner(5) == 'First' assert determine_winner(1000) == 'Second' assert determine_winner(999) == 'First' def test_solve_game(): assert solve_game(3, [1, 2, 4]) == ['First', 'Second', 'Second'] assert solve_game(1, [7]) == ['First'] assert solve_game(4, [8, 13, 21, 34]) == ['Second', 'First', 'First', 'Second'] import pytest # Add the tests to pytest pytest.main([__file__])","solution":"def determine_winner(n): Determines the winner of the game based on the number of coins. Returns 'First' if the first player wins, else returns 'Second'. if n % 2 == 1: return 'First' else: return 'Second' def solve_game(T, cases): Solves the game for T test cases and returns a list of results. Each result is either 'First' or 'Second'. results = [] for n in cases: results.append(determine_winner(n)) return results"},{"question":"def findMaxLength(arr: List[int]) -> int: Finds the length of the longest subarray with an equal number of 0s and 1s. Args: arr (List[int]): A list of integers containing only 0s and 1s. Returns: int: The length of the longest subarray with an equal number of 0s and 1s. Examples: >>> findMaxLength([0, 1, 0]) 2 >>> findMaxLength([0, 0, 1, 0, 0, 1, 1]) 6","solution":"def findMaxLength(arr): Finds the length of the longest subarray with an equal number of 0s and 1s. # Dictionary to store the first occurrence of each cumulative sum first_occurrence = {} curr_sum = 0 max_len = 0 for i in range(len(arr)): # Replace 0 with -1 to treat the problem similar to finding subarrays with sum 0 if arr[i] == 0: curr_sum += -1 else: curr_sum += 1 if curr_sum == 0: max_len = i + 1 elif curr_sum in first_occurrence: max_len = max(max_len, i - first_occurrence[curr_sum]) else: first_occurrence[curr_sum] = i return max_len"},{"question":"def get_top_scores(input_lines): Determine the top three scores from each round and identify the participants who scored these top three scores. The function should handle multiple rounds of input and continue until an empty line (indicative of no more rounds). Each round of input ends with a blank line. The input ends with a line containing a single \`0\`. Parameters ---------- input_lines : List[str] List of strings representing the input lines. Returns ------- str Formatted string representing the top scores and the participants. Examples -------- >>> input_lines = [ >>> \\"5\\", >>> \\"Alice 95\\", >>> \\"Bob 85\\", >>> \\"Charlie 90\\", >>> \\"David 100\\", >>> \\"Eve 100\\", >>> \\"\\", >>> \\"0\\" >>> ] >>> get_top_scores(input_lines) 'Top scores:n100: David, Even95: Alicen90: Charlie' >>> input_lines = [ >>> \\"3\\", >>> \\"Tom 80\\", >>> \\"Jerry 85\\", >>> \\"Spike 85\\", >>> \\"\\", >>> \\"0\\" >>> ] >>> get_top_scores(input_lines) 'Top scores:n85: Jerry, Spiken80: Tom'","solution":"def get_top_scores(input_lines): i = 0 rounds = [] while i < len(input_lines): line = input_lines[i].strip() if line == \\"0\\": break if line == \\"\\": i += 1 continue n = int(line) participants = [] for j in range(n): i += 1 name, score = input_lines[i].strip().rsplit(\\" \\", 1) score = int(score) participants.append((name, score)) rounds.append(participants) i += 1 result = [] for participants in rounds: scores_with_names = {} for name, score in participants: if score in scores_with_names: scores_with_names[score].append(name) else: scores_with_names[score] = [name] top_scores = sorted(scores_with_names.keys(), reverse=True)[:3] round_result = [] for score in top_scores: round_result.append(f\\"{score}: {', '.join(scores_with_names[score])}\\") result.append(\\"Top scores:n\\" + \\"n\\".join(round_result)) return \\"nn\\".join(result)"},{"question":"def max_recipes(test_cases): Returns the maximum number of recipes Chef can make for each test case. Parameters: test_cases (list of tuples): List of (A, B) tuples where A and B are the number of units of ingredients A and B. Returns: list of int: Maximum number of recipes for each test case. >>> max_recipes([(1, 2)]) == [1] >>> max_recipes([(3, 6)]) == [3] >>> max_recipes([(5, 1)]) == [0] >>> max_recipes([(4, 10)]) == [4] >>> max_recipes([(0, 0)]) == [0] >>> max_recipes([(0, 10)]) == [0] >>> max_recipes([(10, 0)]) == [0] >>> max_recipes([(10, 20)]) == [10] >>> max_recipes([(10, 21)]) == [10] >>> max_recipes([(12, 24)]) == [12] >>> max_recipes([(12, 23)]) == [11] >>> max_recipes([(1000, 2000)]) == [1000] >>> max_recipes([(500, 1000)]) == [500] >>> max_recipes([(1, 2), (3, 6), (5, 1), (4, 10)]) == [1, 3, 0, 4] >>> max_recipes([(0, 0), (0, 10), (10, 0), (10, 20), (12, 24)]) == [0, 0, 0, 10, 12]","solution":"def max_recipes(test_cases): Returns the maximum number of recipes Chef can make for each test case. Parameters: test_cases (list of tuples): List of (A, B) tuples where A and B are the number of units of ingredients A and B. Returns: list of int: Maximum number of recipes for each test case. results = [] for A, B in test_cases: recipes = min(A, B // 2) results.append(recipes) return results"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Returns the length of the longest sequence of consecutive integers in an unsorted list. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([10, 5, 20, 15, 30]) 1 >>> longest_consecutive_sequence([7, 7, 7, 7, 7]) 1 >>> longest_consecutive_sequence([10, 12, 11, 15, 14, 13, 18, 17, 16, 19, 20, 9]) 12 >>> longest_consecutive_sequence([1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([-1, -2, -3, -4, 0, 1, 2, 3]) 8","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest sequence of consecutive integers in an unsorted list. :param nums: List of integers :type nums: List[int] :return: Length of the longest sequence of consecutive integers :rtype: int if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: # Only check for the start of a sequence if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def shortestCommonSupersequence(A: str, B: str) -> int: Given two strings A and B, find the length of the shortest common supersequence of both the strings. A supersequence is a string that contains both input strings as subsequences. >>> shortestCommonSupersequence(\\"AGGTAB\\", \\"GXTXAYB\\") 9 >>> shortestCommonSupersequence(\\"HELLO\\", \\"GEEK\\") 8","solution":"def shortestCommonSupersequence(A, B): Returns the length of the shortest common supersequence of strings A and B. m, n = len(A), len(B) # Create a table to store lengths of longest common subsequence. dp = [[0] * (n+1) for _ in range(m+1)] # Populate the dp array for i in range(m+1): for j in range(n+1): if i == 0 or j == 0: dp[i][j] = 0 elif A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # Length of the shortest common supersequence lcs_length = dp[m][n] scs_length = m + n - lcs_length return scs_length"},{"question":"import re from collections import Counter def count_words(text: str) -> dict: Counts the occurrences of each unique word in the given text, ignoring case and punctuation. Args: text (str): Input text. Returns: dict: A dictionary with words as keys and their counts as values. >>> count_words(\\"Amazing? This is just amazing, truly amazing.\\") {'amazing': 3, 'this': 1, 'is': 1, 'just': 1, 'truly': 1} >>> count_words(\\"Amazing AMAZING amazing\\") {'amazing': 3} >>> count_words(\\"Hello! This, is a test.\\") {'hello': 1, 'this': 1, 'is': 1, 'a': 1, 'test': 1} >>> count_words(\\"\\") {} >>> count_words(\\"word\\") {'word': 1} >>> count_words(\\"Wait... what?! Really...\\") {'wait': 1, 'what': 1, 'really': 1}","solution":"import re from collections import Counter def count_words(text): Counts the occurrences of each unique word in the given text, ignoring case and punctuation. Args: text (str): Input text. Returns: dict: A dictionary with words as keys and their counts as values. text = re.sub(r'[^ws]', '', text) # Remove punctuation words = text.lower().split() # Convert to lowercase and split into words word_count = Counter(words) # Count the occurrences of each word return dict(word_count)"},{"question":"def sum_of_odd_numbers(n: int) -> int: Returns the sum of the first n odd numbers. >>> sum_of_odd_numbers(1) -> 1 >>> sum_of_odd_numbers(3) -> 9 >>> sum_of_odd_numbers(5) -> 25 >>> sum_of_odd_numbers(0) -> 0 # edge case >>> sum_of_odd_numbers(-3) -> 0 # edge case def test_sum_of_odd_numbers(): assert sum_of_odd_numbers(1) == 1 assert sum_of_odd_numbers(2) == 4 assert sum_of_odd_numbers(3) == 9 assert sum_of_odd_numbers(4) == 16 assert sum_of_odd_numbers(5) == 25 assert sum_of_odd_numbers(0) == 0 assert sum_of_odd_numbers(-3) == 0","solution":"def sum_of_odd_numbers(n): Returns the sum of the first n odd numbers. if n <= 0: return 0 return n * n"},{"question":"def is_subsequence(s1: str, s2: str) -> bool: Check whether s1 is a subsequence of s2. >>> is_subsequence('abc', 'ahbgdc') True >>> is_subsequence('axc', 'ahbgdc') False","solution":"def is_subsequence(s1, s2): Returns True if s1 is a subsequence of s2, otherwise returns False. it = iter(s2) return all(char in it for char in s1)"},{"question":"def can_partition_into_palindromes(m, t, k): Function to determine whether it is possible to partition the string \`t\` into exactly \`k\` palindromic substrings. :param m: Integer, the length of string t. :param t: String, consisting of exactly \`m\` lowercase Latin letters. :param k: Integer, the number of palindromic substrings needed. :return: \\"YES\\" if it is possible to partition t into exactly k palindromic substrings, otherwise \\"NO\\". >>> can_partition_into_palindromes(7, \\"levelup\\", 3) 'YES' >>> can_partition_into_palindromes(5, \\"abcdc\\", 2) 'NO' >>> can_partition_into_palindromes(1, \\"a\\", 1) 'YES' >>> can_partition_into_palindromes(6, \\"aaaaaa\\", 3) 'YES' >>> can_partition_into_palindromes(4, \\"abcd\\", 2) 'NO' >>> can_partition_into_palindromes(7, \\"racecar\\", 7) 'YES' >>> can_partition_into_palindromes(6, \\"abccba\\", 2) 'YES' >>> can_partition_into_palindromes(6, \\"abcdef\\", 5) 'NO'","solution":"def can_partition_into_palindromes(m, t, k): Function to determine whether it is possible to partition the string \`t\` into exactly \`k\` palindromic substrings. :param m: Integer, the length of string t. :param t: String, consisting of exactly \`m\` lowercase Latin letters. :param k: Integer, the number of palindromic substrings needed. :return: \\"YES\\" if it is possible to partition t into exactly k palindromic substrings, otherwise \\"NO\\". def is_palindrome(s): return s == s[::-1] # Precompute palindrome substrings palindromes = [[False] * m for _ in range(m)] for i in range(m): palindromes[i][i] = True for length in range(2, m + 1): for i in range(m - length + 1): j = i + length - 1 if length == 2: palindromes[i][j] = (t[i] == t[j]) else: palindromes[i][j] = (t[i] == t[j]) and palindromes[i + 1][j - 1] # Dynamic programming to find the minimum number of palindromic substrings dp = [float('inf')] * (m + 1) dp[0] = 0 for i in range(1, m + 1): for j in range(i): if palindromes[j][i - 1]: dp[i] = min(dp[i], dp[j] + 1) return \\"YES\\" if dp[m] <= k else \\"NO\\""},{"question":"def find_winner(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine the winner of the game for each test case. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples. Each tuple contains an integer N, the number of elements in the array, followed by a list of integers representing the array. Returns: List[str]: A list of strings. Each string is either \\"ALICE\\" or \\"CHARLIE\\" indicating the winner for the corresponding test case. Example: >>> find_winner(2, [(5, [2, 3, 4, 5, 6]), (6, [7, 11, 14, 15, 18, 20])]) ['ALICE', 'CHARLIE'] pass import pytest def test_sample_input(): T = 2 test_cases = [(5, [2, 3, 4, 5, 6]), (6, [7, 11, 14, 15, 18, 20])] expected = [\\"ALICE\\", \\"CHARLIE\\"] assert find_winner(T, test_cases) == expected def test_no_prime_numbers(): T = 1 test_cases = [(5, [4, 6, 8, 9, 10])] expected = [\\"CHARLIE\\"] assert find_winner(T, test_cases) == expected def test_no_composite_numbers(): T = 1 test_cases = [(4, [2, 3, 5, 7])] expected = [\\"ALICE\\"] assert find_winner(T, test_cases) == expected def test_equal_prime_and_composite(): T = 1 test_cases = [(6, [2, 3, 4, 6, 8, 5])] expected = [\\"CHARLIE\\"] assert find_winner(T, test_cases) == expected def test_large_numbers(): T = 1 test_cases = [(4, [999983, 1000033, 1000037, 1000039])] expected = [\\"ALICE\\"] assert find_winner(T, test_cases) == expected def test_large_input_size(): T = 1 test_cases = [(100000, [2]*50000 + [4]*50000)] expected = [\\"CHARLIE\\"] assert find_winner(T, test_cases) == expected # Run the tests pytest.main()","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def determine_winner(arr): Determines the winner of the game given the array. primes = 0 composites = 0 for num in arr: if is_prime(num): primes += 1 elif num > 1: composites += 1 # Alice starts, so if there are moves for her, she wins if primes > composites: return \\"ALICE\\" else: return \\"CHARLIE\\" def find_winner(T, test_cases): results = [] for case in test_cases: N, arr = case results.append(determine_winner(arr)) return results # Example usage: # T = 2 # test_cases = [(5, [2, 3, 4, 5, 6]), (6, [7, 11, 14, 15, 18, 20])] # print(find_winner(T, test_cases))"},{"question":"import re from typing import Optional def is_palindrome(s: Optional[str]) -> Optional[bool]: Determine if the given string is a palindrome, ignoring case, spaces, and punctuation. If the input is None, return None. Examples: >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(None) None","solution":"import re def is_palindrome(s): Determine if the given string is a palindrome, ignoring case, spaces, and punctuation. If the input is None, return None. if s is None: return None # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is the same forwards and backwards return cleaned_s == cleaned_s[::-1]"},{"question":"def is_palindrome(s: str) -> str: Check if the input string is a palindrome. >>> is_palindrome(\\"level\\") == \\"Palindrome\\" >>> is_palindrome(\\"coding\\") == \\"Not Palindrome\\" >>> is_palindrome(\\"radar\\") == \\"Palindrome\\" >>> is_palindrome(\\"a\\") == \\"Palindrome\\" >>> is_palindrome(\\"ab\\") == \\"Not Palindrome\\" >>> is_palindrome(\\"Level\\") == \\"Not Palindrome\\" >>> is_palindrome(\\"\\") == \\"Palindrome\\"","solution":"def is_palindrome(s): Returns \\"Palindrome\\" if the input string s is a palindrome, else returns \\"Not Palindrome\\". if s == s[::-1]: return \\"Palindrome\\" else: return \\"Not Palindrome\\""},{"question":"from abc import ABC, abstractmethod import math class Shape(ABC): Abstract base class for geometric shapes. @abstractmethod def area(self): pass @abstractmethod def perimeter(self): pass class Rectangle(Shape): Class representing a rectangle. def __init__(self, width, height): self.width = width self.height = height def area(self): Calculate the area of the rectangle. pass def perimeter(self): Calculate the perimeter of the rectangle. pass class Circle(Shape): Class representing a circle. def __init__(self, radius): self.radius = radius def area(self): Calculate the area of the circle. pass def perimeter(self): Calculate the perimeter (circumference) of the circle. pass class Triangle(Shape): Class representing a triangle. def __init__(self, a, b, c): self.a = a self.b = b self.c = c def area(self): Calculate the area of the triangle using Heron's formula. pass def perimeter(self): Calculate the perimeter of the triangle. pass def create_shapes(): Create instances of each shape with arbitrary dimensions. rectangle = Rectangle(3, 4) circle = Circle(5) triangle = Triangle(3, 4, 5) return [rectangle, circle, triangle]","solution":"from abc import ABC, abstractmethod import math class Shape(ABC): @abstractmethod def area(self): pass @abstractmethod def perimeter(self): pass class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height def perimeter(self): return 2 * (self.width + self.height) class Circle(Shape): def __init__(self, radius): self.radius = radius def area(self): return 3.14159 * self.radius * self.radius def perimeter(self): return 2 * 3.14159 * self.radius class Triangle(Shape): def __init__(self, a, b, c): self.a = a self.b = b self.c = c def area(self): s = (self.a + self.b + self.c) / 2 return math.sqrt(s * (s - self.a) * (s - self.b) * (s - self.c)) def perimeter(self): return self.a + self.b + self.c def create_shapes(): rectangle = Rectangle(3, 4) circle = Circle(5) triangle = Triangle(3, 4, 5) return [rectangle, circle, triangle]"},{"question":"def generateParenthesis(n: int) -> List[str]: Given an integer n, return a list of all unique combinations of n pairs of balanced parentheses. The combinations should be sorted lexicographically. >>> generateParenthesis(1) [\\"()\\"] >>> generateParenthesis(2) [\\"(())\\", \\"()()\\"] >>> generateParenthesis(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]","solution":"def generateParenthesis(n): Generates all combinations of n pairs of balanced parentheses sorted lexicographically. def backtrack(s, left, right): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) result = [] backtrack(\\"\\", 0, 0) return result"},{"question":"def can_fit_packages(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]], List[Tuple[int, int]]]]) -> List[str]: Determine if all packages can fit into the boxes. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]], List[Tuple[int, int]]]]): Test cases where each test case is a tuple containing: - Number of boxes (N) - Number of packages (M) - List of tuples representing the dimensions of boxes (length, width) - List of tuples representing the dimensions of packages (length, width) Returns: List[str]: For each test case, returns \\"Possible\\" if all packages can fit into the boxes, otherwise \\"Not Possible\\". Example: >>> can_fit_packages(2, [(3, 2, [(4, 6), (5, 5), (8, 3)], [(2, 3), (3, 8)]), (2, 3, [(2, 2), (1, 1)], [(2, 1), (2, 3), (1, 2)])]) ['Possible', 'Not Possible']","solution":"def can_fit_packages(T, test_cases): results = [] for i in range(T): N, M, boxes, packages = test_cases[i] boxes = sorted(boxes, key=lambda x: (max(x), min(x))) possible = True for package in packages: length, width = package fit = False for box in boxes: box_length, box_width = box if (length <= box_length and width <= box_width) or (length <= box_width and width <= box_length): fit = True break if not fit: possible = False break if possible: results.append(\\"Possible\\") else: results.append(\\"Not Possible\\") return results # Example usage: T = 2 test_cases = [ (3, 2, [(4, 6), (5, 5), (8, 3)], [(2, 3), (3, 8)]), (2, 3, [(2, 2), (1, 1)], [(2, 1), (2, 3), (1, 2)]) ] print(can_fit_packages(T, test_cases)) # Output: ['Possible', 'Not Possible']"},{"question":"def findSingleNumber(nums): Find the integer that occurs only once in a list where every other integer occurs exactly twice. :param nums: List[int] - list of integers where every integer occurs exactly twice except one :return: int - the integer that occurs only once >>> findSingleNumber([2, 3, 5, 4, 5, 3, 4]) 2 >>> findSingleNumber([9, 8, 7, 9, 8]) 7 def test_example_1(): assert findSingleNumber([2, 3, 5, 4, 5, 3, 4]) == 2 def test_example_2(): assert findSingleNumber([9, 8, 7, 9, 8]) == 7 def test_single_element(): assert findSingleNumber([1]) == 1 def test_large_numbers(): assert findSingleNumber([1000000000, 999999999, 1000000000]) == 999999999 def test_mixed_numbers(): assert findSingleNumber([1, 2, 3, 2, 1]) == 3 def test_negative_numbers(): assert findSingleNumber([-1, -2, -2, -3, -1]) == -3","solution":"def findSingleNumber(nums): Find the integer that occurs only once in a list where every other integer occurs exactly twice. :param nums: List[int] - list of integers where every integer occurs exactly twice except one :return: int - the integer that occurs only once result = 0 for num in nums: result ^= num return result"},{"question":"def rank_participants(scores): Returns the ranks of participants based on their scores. >>> rank_participants([100, 50, 50, 25, 100]) [1, 3, 3, 5, 1] >>> rank_participants([90, 85, 85, 80]) [1, 2, 2, 4] >>> rank_participants([1000]) [1] >>> rank_participants([70, 70, 70, 70]) [1, 1, 1, 1] >>> rank_participants([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1]","solution":"def rank_participants(scores): Returns the ranks of participants based on their scores. sorted_scores = sorted(((score, index) for index, score in enumerate(scores)), reverse=True, key=lambda x: x[0]) ranks = [0] * len(scores) current_rank = 1 for i, (score, index) in enumerate(sorted_scores): if i > 0 and score != sorted_scores[i - 1][0]: current_rank = i + 1 ranks[index] = current_rank return ranks"},{"question":"from typing import List, Tuple def min_roads_to_travel(n: int, m: int, uniqueness: List[int], roads: List[Tuple[int, int]]) -> int: Calculate the minimum number of roads Fatima needs to travel to visit at least one city of each uniqueness level from 1 to m. >>> min_roads_to_travel(5, 3, [1, 1, 2, 2, 3], [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 5)]) 3 >>> min_roads_to_travel(6, 4, [1, 1, 2, 3, 3, 4], [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (4, 6), (5, 6)]) 3 >>> min_roads_to_travel(5, 3, [1, 1, 2, 2, 3], [(1, 2), (2, 3), (3, 4)]) -1 >>> min_roads_to_travel(4, 3, [1, 1, 2, 3], [(1, 2), (2, 3), (3, 4)]) 2 >>> min_roads_to_travel(3, 3, [1, 2, 3], [(1, 2), (2, 3)]) 2 >>> min_roads_to_travel(6, 4, [1, 1, 2, 2, 3, 4], [(1, 2), (2, 3), (3, 5), (5, 6), (1, 4), (4, 5)]) 3","solution":"from collections import deque, defaultdict def min_roads_to_travel(n, m, uniqueness, roads): # Group cities by their uniqueness level cities_by_uniqueness = defaultdict(list) for city, level in enumerate(uniqueness, 1): cities_by_uniqueness[level].append(city) # Create adjacency list for the graph graph = defaultdict(list) for a, b in roads: graph[a].append(b) graph[b].append(a) # Assume roads are bidirectional def bfs(start_cities, target_uniqueness): visited = set(start_cities) queue = deque([(city, 0) for city in start_cities]) while queue: current_city, dist = queue.popleft() for neighbor in graph[current_city]: if neighbor not in visited: if uniqueness[neighbor - 1] == target_uniqueness: return dist + 1, neighbor queue.append((neighbor, dist + 1)) visited.add(neighbor) return float('inf'), None total_roads = 0 current_level_cities = cities_by_uniqueness[1] for level in range(2, m + 1): distance, next_city = bfs(current_level_cities, level) if distance == float('inf'): return -1 # Path doesn't exist total_roads += distance current_level_cities = [next_city] return total_roads"},{"question":"def can_make_elements_equal(queries): Determine if you can make all elements of the array equal by performing a series of operations. In one operation, you can add 1 to any integer of the array or subtract 1 from any integer of the array. Args: queries (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer \`n\` and a list of \`n\` integers representing an array. Returns: List[str]: A list of strings, each being \\"YES\\" if you can make all elements of the array equal using the given operations, otherwise \\"NO\\". >>> can_make_elements_equal([(2, 3, 3)]) [\\"YES\\"] >>> can_make_elements_equal([(3, 2, 4, 5)]) [\\"NO\\"] >>> can_make_elements_equal([(4, 1, 2, 2, 1)]) [\\"YES\\"]","solution":"def can_make_elements_equal(queries): results = [] for query in queries: n, arr = query[0], query[1:] max_val = max(arr) min_val = min(arr) if max_val - min_val <= 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def get_creature_gem(creature_name: str) -> str: Returns the corresponding gem for the given creature name. >>> get_creature_gem(\\"Drake\\") \\"Drake-Firestone\\" >>> get_creature_gem(\\"Phoenix\\") \\"Phoenix-Sunstone\\" >>> get_creature_gem(\\"Leviathan\\") \\"Leviathan-Seastone\\" >>> get_creature_gem(\\"Griffin\\") \\"Griffin-Skycrystal\\" >>> get_creature_gem(\\"Unicorn\\") \\"Unicorn-Dreamshard\\" >>> get_creature_gem(\\"Yeti\\") \\"Yeti-Icecrystal\\" >>> get_creature_gem(\\"Dragon\\") \\"Unknown creature\\" >>> get_creature_gem(\\"Fairy\\") \\"Unknown creature\\" >>> get_creature_gem(\\"\\") \\"Unknown creature\\" >>> get_creature_gem(\\"Levi\\") \\"Unknown creature\\" >>> get_creature_gem(\\"drake\\") \\"Unknown creature\\" >>> get_creature_gem(\\"PHOENIX\\") \\"Unknown creature\\" >>> get_creature_gem(\\"Leviathan\\") \\"Leviathan-Seastone\\"","solution":"def get_creature_gem(creature_name): Returns the corresponding gem for the given creature name. creature_gem_map = { \\"Drake\\": \\"Drake-Firestone\\", \\"Phoenix\\": \\"Phoenix-Sunstone\\", \\"Leviathan\\": \\"Leviathan-Seastone\\", \\"Griffin\\": \\"Griffin-Skycrystal\\", \\"Unicorn\\": \\"Unicorn-Dreamshard\\", \\"Yeti\\": \\"Yeti-Icecrystal\\" } return creature_gem_map.get(creature_name, \\"Unknown creature\\")"},{"question":"def longest_digit_substring(S: str) -> int: Returns the length of the longest substring that contains only digits. >>> longest_digit_substring(\\"abc123def45\\") 3 >>> longest_digit_substring(\\"abcxyz\\") 0","solution":"def longest_digit_substring(S): Returns the length of the longest substring that contains only digits. Args: S (str): The input string containing lowercase letters and digits. Returns: int: The length of the longest substring that contains only digits. max_length = 0 current_length = 0 for char in S: if char.isdigit(): current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def merge_sort_deduplicate(arr1: List[int], arr2: List[int]) -> List[int]: Given two integer arrays as input, merge them into a single array, sort it in non-decreasing order, and remove any duplicate elements from the resulting array. Args: arr1 (list of int): First input array. arr2 (list of int): Second input array. Returns: list of int: Merged, sorted, and deduplicated array. Examples: >>> merge_sort_deduplicate([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sort_deduplicate([1, 2, 2, 3], [2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sort_deduplicate([-1, 0, 2], [-3, -1, 0, 4]) [-3, -1, 0, 2, 4]","solution":"def merge_sort_deduplicate(arr1, arr2): Merges two arrays, sorts them in non-decreasing order, and removes duplicates. Args: arr1 (list of int): First input array. arr2 (list of int): Second input array. Returns: list of int: Merged, sorted, and deduplicated array. merged_array = list(set(arr1).union(set(arr2))) merged_array.sort() return merged_array"},{"question":"def can_rearrange(s: str, k: int) -> str: Determine if it is possible to rearrange the string S such that there are at most K consecutive identical characters. Args: s (str): The input string consisting of lowercase English letters. k (int): The maximum number of consecutive identical characters allowed. Returns: str: \\"YES\\" if it is possible to rearrange the string, otherwise \\"NO\\". >>> can_rearrange(\\"aabbcc\\", 2) \\"YES\\" >>> can_rearrange(\\"aabbcc\\", 1) \\"NO\\" >>> can_rearrange(\\"aaaabbbbcc\\", 3) \\"YES\\" def solve(tasks: List[Tuple[str, int]]) -> List[str]: Apply the can_rearrange function to each task and collect the results. Args: tasks (List[Tuple[str, int]]): A list of tuples, each containing a string S and an integer K. Returns: List[str]: A list of results for each task, either \\"YES\\" or \\"NO\\". def preprocess_input(input_data: str) -> List[Tuple[str, int]]: Preprocess the input data to extract the tasks. Args: input_data (str): The raw input data as a single string. Returns: List[Tuple[str, int]]: A list of tuples, each containing a string S and an integer K. from solution import solve, preprocess_input def test_sample_input(): input_data = \\"3naabbcc 2naabbcc 1naaaabbbbcc 3\\" tasks = preprocess_input(input_data) assert solve(tasks) == [\\"YES\\", \\"NO\\", \\"YES\\"] def test_identical_characters_k_1(): input_data = \\"1naaaa 1\\" tasks = preprocess_input(input_data) assert solve(tasks) == [\\"NO\\"] def test_single_character(): input_data = \\"1na 1\\" tasks = preprocess_input(input_data) assert solve(tasks) == [\\"YES\\"] def test_all_different(): input_data = \\"1nabcdef 2\\" tasks = preprocess_input(input_data) assert solve(tasks) == [\\"YES\\"] def test_identical_characters_large_k(): input_data = \\"1naaaabbbb 4\\" tasks = preprocess_input(input_data) assert solve(tasks) == [\\"YES\\"]","solution":"def can_rearrange(s, k): from collections import Counter import heapq # Get the frequency of each character counter = Counter(s) # Max-heap of the counts of the characters max_heap = [-cnt for cnt in counter.values()] heapq.heapify(max_heap) # If the maximum frequency of any character is > K, we need to check deeper while max_heap: # Take the most frequent character max_freq = -heapq.heappop(max_heap) if max_freq > (len(s) - max_freq) * (k - 1) + 1: return \\"NO\\" return \\"YES\\" def solve(tasks): results = [] for s, k in tasks: results.append(can_rearrange(s, k)) return results def preprocess_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) tasks = [] for i in range(1, T + 1): s, k = lines[i].split() k = int(k) tasks.append((s, k)) return tasks"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list where the ith element is the product of all the elements in the input list except the one at index i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5]) [1] >>> product_except_self([]) [] >>> product_except_self([1, 2, 3, 0]) [0, 0, 0, 6] >>> product_except_self([0, 2, 0, 4]) [0, 0, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6]","solution":"def product_except_self(nums): Returns a list where the ith element is the product of all the elements in the input list except the one at index i. length = len(nums) # Create an output array initialized to 1 for holding products of elements except self output = [1] * length # Calculate products of elements before the current index left_product = 1 for i in range(length): output[i] = left_product left_product *= nums[i] # Calculate products of elements after the current index and multiply by the product before the index right_product = 1 for i in range(length-1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def arrange_books(n: int, k: int, books: List[int]) -> List[int]: Returns a list of k books with minimum number of pages in sorted order. Args: n (int): The number of books. k (int): The number of books that can be kept on the shelf at a time. books (List[int]): A list of integers representing the number of pages in each book. Returns: List[int]: A sorted list of the k books with the least number of pages. Examples: >>> arrange_books(5, 3, [8, 2, 5, 3, 1]) [1, 2, 3] >>> arrange_books(4, 4, [4, 3, 2, 1]) [1, 2, 3, 4]","solution":"def arrange_books(n, k, books): Returns a list of k books with minimum number of pages in sorted order. Args: n (int): The number of books. k (int): The number of books that can be kept on the shelf at a time. books (list): A list of integers representing the number of pages in each book. Returns: list: A sorted list of the k books with the least number of pages. # Sort the list of books by number of pages sorted_books = sorted(books) # Return the first k books return sorted_books[:k] # Example usage: # n = 5, k = 3, books = [8, 2, 5, 3, 1] # The returned list should be [1, 2, 3]"},{"question":"def update_inventory(m, operations): Update the inventory based on a list of operations. Parameters: - m: int, the number of operations. - operations: list of tuples, where each tuple is an operation in the form (\\"ADD\\" or \\"REMOVE\\", ISBN, count). Returns: - dict, the final inventory with ISBN as keys and counts as values. # Your code here def inventory_to_string(inventory): Format the inventory dictionary into the required output string format. Parameters: - inventory: dict, the inventory with ISBN as keys and counts as values. Returns: - str, the formatted string for the inventory. # Your code here","solution":"def update_inventory(m, operations): Update the inventory based on a list of operations. Parameters: - m: int, the number of operations. - operations: list of tuples, where each tuple is an operation in the form (\\"ADD\\" or \\"REMOVE\\", ISBN, count). Returns: - dict, the final inventory with ISBN as keys and counts as values. inventory = {} for operation in operations: action, isbn, count = operation count = int(count) if action == 'ADD': if isbn in inventory: inventory[isbn] += count else: inventory[isbn] = count elif action == 'REMOVE': if isbn in inventory and inventory[isbn] >= count: inventory[isbn] -= count if inventory[isbn] == 0: del inventory[isbn] # Return the sorted inventory return {isbn: inventory[isbn] for isbn in sorted(inventory)} # Function to format the output as required by the question def inventory_to_string(inventory): return 'n'.join(f\\"{isbn} {count}\\" for isbn, count in sorted(inventory.items()))"},{"question":"def intersect(list1, list2): Returns a list containing the unique intersection of elements from list1 and list2. >>> intersect([1, 2, 2, 3, 4], [2, 2, 3, 5]) [2, 3] >>> intersect([1, 4, 5], [2, 3, 6]) [] >>> intersect([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> intersect([], [1, 2, 3]) [] >>> intersect(list(range(1000)), list(range(500, 1500))) list(range(500, 1000))","solution":"def intersect(list1, list2): Returns a list containing the unique intersection of elements from list1 and list2. # Convert lists to sets to get unique elements and use set intersection set1 = set(list1) set2 = set(list2) intersection = set1.intersection(set2) # Convert the set back to list return list(intersection)"},{"question":"from typing import List def maximum_profit(prices: List[int]) -> int: Function to find the maximum possible profit from a list of integer prices, where you can buy on one day and sell on a future day. >>> maximum_profit([7, 1, 5, 3, 6, 4]) 5 >>> maximum_profit([7, 6, 4, 3, 1]) 0","solution":"from typing import List def maximum_profit(prices: List[int]) -> int: Function to find the maximum possible profit from a list of integer prices, where you can buy on one day and sell on a future day. if len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def can_traverse(paths: List[Tuple[int, int]], start_room: int, end_room: int) -> bool: Determines if there is a path from start_room to end_room. Parameters: paths (list of tuples): A list of tuples where each tuple represents a one-way path from one room to another. start_room: The room identifier to start from. end_room: The room identifier to reach. Returns: bool: True if there is a path from start_room to end_room, False otherwise. >>> can_traverse([(1, 2), (2, 3), (4, 5)], 1, 3) True >>> can_traverse([(1, 2), (2, 3), (4, 5)], 1, 5) False","solution":"def can_traverse(paths, start_room, end_room): Determines if there is a path from start_room to end_room. Parameters: paths (list of tuples): A list of tuples where each tuple represents a one-way path from one room to another. start_room: The room identifier to start from. end_room: The room identifier to reach. Returns: bool: True if there is a path from start_room to end_room, False otherwise. from collections import defaultdict # Create adjacency list adjacency_list = defaultdict(list) for (src, dest) in paths: adjacency_list[src].append(dest) # Depth-First Search (DFS) to check for path def dfs(current, target, visited): if current == target: return True visited.add(current) for neighbor in adjacency_list[current]: if neighbor not in visited: if dfs(neighbor, target, visited): return True return False return dfs(start_room, end_room, set())"},{"question":"MOD = 10**9 + 7 def mth_number(M): Finds the M-th number in a special sequence where each number is formed by concatenating all integers from 1 up to that number. Returns the result modulo 10^9 + 7. >>> mth_number(1) == 1 >>> mth_number(2) == 12 >>> mth_number(3) == 123 >>> mth_number(500000) != 0 def process_test_cases(Q, test_cases): Processes multiple test cases for the mth_number function. >>> process_test_cases(2, [2, 3]) == [12, 123] >>> process_test_cases(3, [1, 2, 3]) == [1, 12, 123]","solution":"MOD = 10**9 + 7 def mth_number(M): Finds the M-th number in a special sequence where each number is formed by concatenating all integers from 1 up to that number. Returns the result modulo 10^9 + 7. result = 0 for i in range(1, M + 1): result = (result * (10 ** len(str(i))) + i) % MOD return result def process_test_cases(Q, test_cases): results = [] for M in test_cases: results.append(mth_number(M)) return results"},{"question":"def count_strings_without_consecutive_ones(n: int) -> int: Returns the number of binary strings of length n which do not contain two consecutive '1's. The result is returned modulo 1000000007. >>> count_strings_without_consecutive_ones(3) 5 >>> count_strings_without_consecutive_ones(1) 2 >>> count_strings_without_consecutive_ones(4) 8 >>> count_strings_without_consecutive_ones(5) 13 from solution import count_strings_without_consecutive_ones def test_count_strings_length_1(): assert count_strings_without_consecutive_ones(1) == 2 def test_count_strings_length_2(): assert count_strings_without_consecutive_ones(2) == 3 def test_count_strings_length_3(): assert count_strings_without_consecutive_ones(3) == 5 def test_count_strings_length_4(): assert count_strings_without_consecutive_ones(4) == 8 def test_count_strings_length_5(): assert count_strings_without_consecutive_ones(5) == 13 def test_count_strings_large(): assert count_strings_without_consecutive_ones(1000) > 0 # Test for large n without exact value def test_count_strings_modulo(): result = count_strings_without_consecutive_ones(1010) assert result < 1000000007 # Ensure result is mod 1000000007","solution":"def count_strings_without_consecutive_ones(n): Returns the number of binary strings of length n which do not contain two consecutive '1's. The result is returned modulo 1000000007. MOD = 1000000007 if n == 1: return 2 # \\"0\\", \\"1\\" # Arrays to store the count of valid strings of length i a = [0] * (n + 1) b = [0] * (n + 1) a[1] = 1 # \\"1\\" b[1] = 1 # \\"0\\" for i in range(2, n + 1): a[i] = b[i - 1] % MOD b[i] = (a[i - 1] + b[i - 1]) % MOD return (a[n] + b[n]) % MOD"},{"question":"def memory_management(commands): Manages memory through a sequence of allocation, storage, and free commands. Commands: - \\"ALLOC A B\\": Allocates space for variable A with size B. - \\"STORE A I V\\": Stores value V at index I in the memory dedicated to variable A. - \\"FREE A\\": Frees the memory allocated to variable A. - \\"DUMP\\": Dumps the current state of the entire memory space as a single list, with unused cells represented by None. Example usage: >>> memory_management([\\"ALLOC var1 2\\", \\"STORE var1 0 10\\", \\"STORE var1 1 20\\", \\"ALLOC var2 3\\", \\"STORE var2 0 30\\", \\"DUMP\\"]) [10, 20, 30, None, None] memory = [] allocations = {} for command in commands: parts = command.split() op = parts[0] if op == \\"ALLOC\\": var, size = parts[1], int(parts[2]) allocations[var] = len(memory) memory.extend([None] * size) elif op == \\"STORE\\": var, idx, val = parts[1], int(parts[2]), int(parts[3]) memory[allocations[var] + idx] = val elif op == \\"FREE\\": var = parts[1] start = allocations.pop(var) size = len(memory[start:]) memory[start:start + size] = [None] * size elif op == \\"DUMP\\": return memory return memory # Test cases def test_memory_management_example(): commands = [ \\"ALLOC var1 2\\", \\"STORE var1 0 10\\", \\"STORE var1 1 20\\", \\"ALLOC var2 3\\", \\"STORE var2 0 30\\", \\"DUMP\\" ] expected_result = [10, 20, 30, None, None] assert memory_management(commands) == expected_result def test_memory_management_store_and_free(): commands = [ \\"ALLOC var1 2\\", \\"STORE var1 0 5\\", \\"STORE var1 1 15\\", \\"FREE var1\\", \\"ALLOC var2 3\\", \\"STORE var2 0 3\\", \\"DUMP\\" ] expected_result = [None, None, 3, None, None] assert memory_management(commands) == expected_result def test_memory_management_multiple_alloc(): commands = [ \\"ALLOC var1 2\\", \\"STORE var1 0 7\\", \\"STORE var1 1 8\\", \\"ALLOC var2 2\\", \\"STORE var2 0 9\\", \\"STORE var2 1 10\\", \\"DUMP\\" ] expected_result = [7, 8, 9, 10] assert memory_management(commands) == expected_result def test_memory_management_overwrite(): commands = [ \\"ALLOC var1 2\\", \\"STORE var1 0 12\\", \\"STORE var1 1 13\\", \\"ALLOC var2 2\\", \\"STORE var2 0 14\\", \\"STORE var2 1 15\\", \\"STORE var1 0 16\\", \\"STORE var2 1 17\\", \\"DUMP\\" ] expected_result = [16, 13, 14, 17] assert memory_management(commands) == expected_result def test_memory_management_empty_commands(): commands = [] expected_result = [] assert memory_management(commands) == expected_result","solution":"def memory_management(commands): memory = [] allocations = {} for command in commands: parts = command.split() op = parts[0] if op == \\"ALLOC\\": var, size = parts[1], int(parts[2]) allocations[var] = len(memory) memory.extend([None] * size) elif op == \\"STORE\\": var, idx, val = parts[1], int(parts[2]), int(parts[3]) memory[allocations[var] + idx] = val elif op == \\"FREE\\": var = parts[1] start = allocations.pop(var) size = len(memory[start:]) memory[start:start + size] = [None] * size elif op == \\"DUMP\\": return memory return memory"},{"question":"def count_dates_between(start_date, end_date): Returns the number of dates between start_date and end_date inclusive. >>> count_dates_between(\\"a\\", \\"z\\") 26 >>> count_dates_between(\\"abc\\", \\"abd\\") 2 >>> count_dates_between(\\"abc\\", \\"abc\\") 1","solution":"def count_dates_between(start_date, end_date): Returns the number of dates between start_date and end_date inclusive. def string_to_number(string): num = 0 for char in string: num = num * 26 + (ord(char) - ord('a')) return num start_num = string_to_number(start_date) end_num = string_to_number(end_date) return (end_num - start_num + 1)"},{"question":"from collections import deque def min_steps_to_reach_bottom_right(n, m, grid): Returns the minimum number of steps required for the truck to reach the bottom-right corner in a grid or -1 if it's not possible. >>> min_steps_to_reach_bottom_right(3, 3, ['RRB', 'RRR', 'BRR']) 4 >>> min_steps_to_reach_bottom_right(3, 3, ['RRB', 'RRB', 'RRB']) -1","solution":"from collections import deque def min_steps_to_reach_bottom_right(n, m, grid): Returns the minimum number of steps required for the truck to reach the bottom-right corner in a grid or -1 if it's not possible. if grid[0][0] == 'B' or grid[n-1][m-1] == 'B': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False]*m for _ in range(n)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 'R': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"def subset_sum(N: int, K: int, arr: List[int]) -> List[int]: Determines if there exists a subset of the list whose sum is equal to K. :param N: int, number of integers in the list :param K: int, target sum we are trying to find :param arr: list of integers :return: list of integers forming the subset that sums to K or an empty list if no such subset exists >>> subset_sum(5, 9, [3, 34, 4, 12, 5]) [4, 5] >>> subset_sum(3, 11, [1, 2, 3]) [] >>> subset_sum(5, 15, [5, 5, 10, 2, 3]) [5, 10]","solution":"def subset_sum(N, K, arr): Determines if there exists a subset of the list whose sum is equal to K. :param N: int, number of integers in the list :param K: int, target sum we are trying to find :param arr: list of integers :return: list of integers forming the subset that sums to K or an empty list if no such subset exists dp = [[False] * (K + 1) for _ in range(N + 1)] for i in range(N + 1): dp[i][0] = True for i in range(1, N + 1): for j in range(1, K + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] if not dp[N][K]: return [] subset = [] i, j = N, K while i > 0 and j > 0: if dp[i][j] and not dp[i-1][j]: subset.append(arr[i-1]) j -= arr[i-1] i -= 1 return subset[::-1]"},{"question":"def robotic_sort(a: List[int], l: int, r: int) -> List[int]: Sort the subarray from index l-1 to r-1 (inclusive) and return the entire array. Parameters: a (list of int): The list of book weights. l (int): The starting index of the range to be sorted (1-based). r (int): The ending index of the range to be sorted (1-based). Returns: list of int: The array after sorting the specified range. >>> robotic_sort([3, 1, 4, 1, 5], 2, 4) [3, 1, 1, 4, 5] >>> robotic_sort([6, 5, 4, 3, 2, 1], 1, 3) [4, 5, 6, 3, 2, 1] import pytest def test_robotic_sort_1(): assert robotic_sort([3, 1, 4, 1, 5], 2, 4) == [3, 1, 1, 4, 5] def test_robotic_sort_2(): assert robotic_sort([6, 5, 4, 3, 2, 1], 1, 3) == [4, 5, 6, 3, 2, 1] def test_robotic_sort_3(): assert robotic_sort([10, 20, 30, 40, 50], 1, 5) == [10, 20, 30, 40, 50] def test_robotic_sort_4(): assert robotic_sort([10, 5, 15, 10, 20], 2, 4) == [10, 5, 10, 15, 20] def test_robotic_sort_5(): assert robotic_sort([1], 1, 1) == [1] def test_robotic_sort_6(): assert robotic_sort([5, 4, 3, 2, 1], 1, 5) == [1, 2, 3, 4, 5] if __name__ == \\"__main__\\": pytest.main()","solution":"def robotic_sort(a, l, r): Sort the subarray from index l-1 to r-1 (inclusive) and return the entire array. Parameters: a (list of int): The list of book weights. l (int): The starting index of the range to be sorted (1-based). r (int): The ending index of the range to be sorted (1-based). Returns: list of int: The array after sorting the specified range. # Convert l and r to 0-based indices l, r = l - 1, r - 1 # Extract the subarray that needs to be sorted subarray = a[l:r + 1] # Sort the subarray sorted_subarray = sorted(subarray) # Replace the original subarray with the sorted one a[l:r + 1] = sorted_subarray return a"},{"question":"def find_tree_clusters_from_input(n: int, m: int, grid_input: List[str]) -> int: Find the number of tree clusters in a grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid_input (List[str]): List of strings representing the grid rows, each containing '1' (tree) or '0' (empty space) separated by spaces. Returns: int: Number of tree clusters in the grid. Examples: >>> find_tree_clusters_from_input(4, 4, [\\"1 1 0 0\\", \\"1 0 0 1\\", \\"0 0 1 0\\", \\"0 1 1 1\\"]) 3 >>> find_tree_clusters_from_input(3, 3, [\\"1 0 0\\", \\"0 1 0\\", \\"0 0 1\\"]) 3","solution":"def find_tree_clusters(grid): Returns the number of tree clusters in the given grid. Parameters: grid (list of list of int): 2D grid representing the forest. Returns: int: Number of tree clusters. def dfs(x, y): # If out of bounds or already visited or empty cell, return if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 0: return # Mark the cell as visited by setting it to 0 grid[x][y] = 0 # Explore all four possible directions directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: dfs(x + dx, y + dy) if not grid: return 0 n = len(grid) m = len(grid[0]) clusters = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: clusters += 1 dfs(i, j) return clusters # Helper function to run when taking the input in the appropriate format def find_tree_clusters_from_input(n, m, grid_input): grid = [list(map(int, row.split())) for row in grid_input] return find_tree_clusters(grid)"},{"question":"def min_total_absolute_difference(n: int, heights: List[int]) -> int: Returns the minimum total absolute difference for paired students' heights. >>> min_total_absolute_difference(4, [10, 7, 5, 20]) 12 >>> min_total_absolute_difference(4, [1, 2, 3, 4]) 2 >>> min_total_absolute_difference(2, [8, 15]) 7 >>> min_total_absolute_difference(6, [3, 10, 2, 8, 5, 7]) 5 >>> min_total_absolute_difference(4, [1, 100, 2, 101]) 2 >>> min_total_absolute_difference(4, [5, 5, 5, 5]) 0 >>> min_total_absolute_difference(4, [10000, 20000, 30000, 40000]) 20000","solution":"def min_total_absolute_difference(n, heights): Returns the minimum total absolute difference for paired students' heights. :param n: integer, number of students :param heights: list of integers, heights of the students :return: integer, total absolute difference for all optimal pairs heights.sort() total_diff = 0 for i in range(1, n, 2): total_diff += abs(heights[i] - heights[i-1]) return total_diff"},{"question":"def count_buildings_with_sunset_view(B: List[int]) -> int: Returns the count of buildings that can see the sunset with the sun setting to the right. Parameters: B (List[int]): List of integers representing the heights of the buildings. Returns: int: Count of buildings that can see the sunset. >>> count_buildings_with_sunset_view([3, 7, 8, 3, 6, 1]) 3 >>> count_buildings_with_sunset_view([5]) 1 >>> count_buildings_with_sunset_view([4, 4, 4, 4]) 1 >>> count_buildings_with_sunset_view([1, 2, 3, 4, 5]) 1 >>> count_buildings_with_sunset_view([5, 4, 3, 2, 1]) 5 >>> count_buildings_with_sunset_view([10, 4, 5, 3, 11, 2]) 2 >>> count_buildings_with_sunset_view([]) 0","solution":"def count_buildings_with_sunset_view(B): Returns the count of buildings that can see the sunset with the sun setting to the right. Parameters: B (List[int]): List of integers representing the heights of the buildings. Returns: int: Count of buildings that can see the sunset. count = 0 max_height = 0 for height in reversed(B): if height > max_height: count += 1 max_height = height return count"},{"question":"def next_greater_elements(nums: List[int]) -> List[int]: Given a list of integers, find the next greater element for each element of the list. The next greater element for an element \`x\` is the first greater number to its right in the list. If no such number exists, output \`-1\` for that position. Parameters: nums (List[int]): A list of integers. Returns: List[int]: A list of integers representing the next greater element for each position in the input list. Example: >>> next_greater_elements([4, 5, 2, 10, 8]) [5, 10, 10, -1, -1] >>> next_greater_elements([3, 7, 1, 7, 8, 4]) [7, 8, 7, 8, -1, -1] from solution import next_greater_elements def test_example_1(): assert next_greater_elements([4, 5, 2, 10, 8]) == [5, 10, 10, -1, -1] def test_example_2(): assert next_greater_elements([3, 7, 1, 7, 8, 4]) == [7, 8, 7, 8, -1, -1] def test_all_same_elements(): assert next_greater_elements([1, 1, 1, 1]) == [-1, -1, -1, -1] def test_decreasing_order(): assert next_greater_elements([5, 4, 3, 2, 1]) == [-1, -1, -1, -1, -1] def test_increasing_order(): assert next_greater_elements([1, 2, 3, 4, 5]) == [2, 3, 4, 5, -1] def test_single_element(): assert next_greater_elements([10]) == [-1] def test_mixed_elements(): assert next_greater_elements([2, 1, 2, 4, 3]) == [4, 2, 4, -1, -1]","solution":"def next_greater_elements(nums): For each element in nums, find the next greater element to its right. If no such element exists, return -1 for that position. Parameters: nums (List[int]): A list of integers. Returns: List[int]: A list of integers representing the next greater element for each position. stack = [] result = [-1] * len(nums) for i in range(len(nums)): # Maintain a stack of indexes of elements for which we are still looking for the next greater element while stack and nums[stack[-1]] < nums[i]: result[stack.pop()] = nums[i] stack.append(i) return result"},{"question":"def room_rates(rates): Finds the most frequent rate and the room numbers associated with that rate. Args: rates (list of tuple): List containing (room_number, rate) Returns: dict: Dictionary with the most frequent rate as the key and a list of room numbers as the value. pass def test_example1(): assert room_rates([(101, 200), (102, 200), (103, 150), (104, 200), (105, 150), (106, 300)]) == {200: [101, 102, 104]} def test_example2(): assert room_rates([(201, 500), (202, 600), (203, 500), (204, 300), (205, 300), (206, 300)]) == {300: [204, 205, 206]} def test_single_entry(): assert room_rates([(101, 200)]) == {200: [101]} def test_no_entries(): assert room_rates([]) == {} def test_all_different_rates(): assert room_rates([(101, 200), (102, 300), (103, 400), (104, 500)]) == {200: [101]} def test_multiple_frequent_rates(): assert room_rates([(101, 200), (102, 300), (103, 200), (104, 300), (105, 400)]) == {200: [101, 103]} def test_same_rate_more_frequent(): assert room_rates([(101, 200), (102, 200), (103, 200), (104, 300), (105, 300)]) == {200: [101, 102, 103]}","solution":"def room_rates(rates): Finds the most frequent rate and the room numbers associated with that rate. Args: rates (list of tuple): List containing (room_number, rate) Returns: dict: Dictionary with the most frequent rate as the key and a list of room numbers as the value. if not rates: return {} from collections import defaultdict, Counter rate_count = Counter(rate for room, rate in rates) max_frequency = max(rate_count.values()) most_frequent_rates = [rate for rate in rate_count if rate_count[rate] == max_frequency] smallest_most_frequent_rate = min(most_frequent_rates) result = defaultdict(list) for room, rate in rates: if rate == smallest_most_frequent_rate: result[rate].append(room) result[smallest_most_frequent_rate].sort() return result"},{"question":"def unique_sequences(n: int) -> int: Returns the number of unique sequences of card draws possible for \`n\` cards modulo 10^9 + 7. >>> unique_sequences(3) 6 >>> unique_sequences(5) 120 >>> unique_sequences(1) 1","solution":"def unique_sequences(n): Returns the number of unique sequences of card draws possible for \`n\` cards modulo 10^9 + 7. MODULO = 10**9 + 7 result = 1 for i in range(1, n + 1): result = (result * i) % MODULO return result"},{"question":"import re def is_anagram(s1: str, s2: str) -> bool: Checks whether two given strings are anagrams of each other, ignoring case, spaces, and punctuation marks. >>> is_anagram(\\"Dormitory\\", \\"Dirty room!!\\") # True >>> is_anagram(\\"Hello, World!\\", \\"world he ol!\\") # False >>> is_anagram(\\"Astronomer\\", \\"Moon starer\\") # True","solution":"import re def is_anagram(s1: str, s2: str) -> bool: Checks whether two given strings are anagrams of each other, ignoring case, spaces, and punctuation marks. # Preprocess the strings by removing non-alphabetic characters and converting to lowercase preprocess = lambda s: ''.join(re.findall(r'[a-z]', s.lower())) s1_processed = preprocess(s1) s2_processed = preprocess(s2) # Check if the sorted versions of the processed strings are equal return sorted(s1_processed) == sorted(s2_processed)"},{"question":"from typing import List, Tuple def is_fully_connected(N: int, M: int, roads: List[Tuple[int, int]]) -> str: Determine if the kingdom is fully connected. >>> is_fully_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> is_fully_connected(4, 2, [(1, 2), (3, 4)]) \\"NO\\" def connectivity_check(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: For each test case, determine if the kingdom is fully connected. >>> connectivity_check(2, [(4, 3, [(1, 2), (2, 3), (3, 4)]), (4, 2, [(1, 2), (3, 4)])]) [\\"YES\\", \\"NO\\"]","solution":"def is_fully_connected(N, M, roads): from collections import defaultdict, deque def bfs(start, graph): visited = set() queue = deque([start]) while queue: town = queue.popleft() if town not in visited: visited.add(town) for neighbour in graph[town]: if neighbour not in visited: queue.append(neighbour) return visited if N == 1: return \\"YES\\" graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited_towns = bfs(1, graph) if len(visited_towns) == N: return \\"YES\\" else: return \\"NO\\" def connectivity_check(T, test_cases): results = [] for N, M, roads in test_cases: results.append(is_fully_connected(N, M, roads)) return results"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def can_transmit_within_time(n: int, T: int, edges: List[Tuple[int, int, int]]) -> str: Determines if it's possible to transmit data packets from the root node to all other nodes within the given timeframe T. :param n: Number of nodes in the tree :param T: Maximum allowable transmission time :param edges: List of edges in the format (u, v, w) where u and v are nodes connected by an edge of cost w :return: \\"YES\\" if it's possible to transmit data packets within the timeframe T, otherwise \\"NO\\" Examples: >>> can_transmit_within_time(5, 10, [(1, 2, 3), (1, 3, 2), (2, 4, 4), (3, 5, 5)]) 'YES' >>> can_transmit_within_time(4, 5, [(1, 2, 6), (1, 3, 2), (3, 4, 3)]) 'NO' pass def main(n: int, T: int, edges: List[Tuple[int, int, int]]) -> str: Main function to determine if it's possible to transmit data packets within the given timeframe T. :param n: Number of nodes in the tree :param T: Maximum allowable transmission time :param edges: List of edges in the format (u, v, w) where u and v are nodes connected by an edge of cost w :return: \\"YES\\" if it's possible to transmit data packets within the timeframe T, otherwise \\"NO\\" Examples: >>> main(5, 10, [(1, 2, 3), (1, 3, 2), (2, 4, 4), (3, 5, 5)]) 'YES' >>> main(4, 5, [(1, 2, 6), (1, 3, 2), (3, 4, 3)]) 'NO' pass","solution":"import sys from collections import defaultdict, deque def can_transmit_within_time(n, T, edges): def bfs(root): dist = [sys.maxsize] * (n + 1) dist[root] = 0 queue = deque([root]) while queue: node = queue.popleft() for neighbor, weight in tree[node]: if dist[node] + weight < dist[neighbor]: dist[neighbor] = dist[node] + weight queue.append(neighbor) return dist tree = defaultdict(list) for u, v, w in edges: tree[u].append((v, w)) tree[v].append((u, w)) dist = bfs(1) for d in dist[1:]: if d > T: return \\"NO\\" return \\"YES\\" def main(n, T, edges): return can_transmit_within_time(n, T, edges)"},{"question":"def min_delivery_time(n, grid): Determine the minimum travel time from the warehouse (1,1) to the destination (n,n). Parameters: n (int): The size of the grid (n x n) grid (List[List[int]]): A 2D list where grid[i][j] represents the travel time from cell (i, j). Returns: int: The minimum travel time required to travel from cell (1, 1) to cell (n, n). Examples: >>> min_delivery_time(3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_delivery_time(2, [[1, 2], [2, 1]]) 4","solution":"import heapq def min_delivery_time(n, grid): Determine the minimum travel time from the warehouse (1,1) to the destination (n,n). directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Down, Right, Up, Left priority_queue = [(grid[0][0], 0, 0)] # (current time, row, col) min_time = [[float('inf')] * n for _ in range(n)] min_time[0][0] = grid[0][0] while priority_queue: curr_time, x, y = heapq.heappop(priority_queue) if x == n-1 and y == n-1: return curr_time for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: new_time = curr_time + grid[nx][ny] if new_time < min_time[nx][ny]: min_time[nx][ny] = new_time heapq.heappush(priority_queue, (new_time, nx, ny)) return min_time[-1][-1] # Example usage: # n = 3 # grid = [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] # print(min_delivery_time(n, grid)) # Output: 7"},{"question":"def isPalindrome(ar): Determines whether the given array is a palindrome. :param ar: List[int] - The array of integers :return: bool - True if the array is a palindrome, False otherwise >>> isPalindrome([1, 2, 3, 2, 1]) True >>> isPalindrome([1, 2, 2, 3]) False >>> isPalindrome([]) True >>> isPalindrome([1]) True","solution":"def isPalindrome(ar): Determines whether the given array is a palindrome. :param ar: List[int] - The array of integers :return: bool - True if the array is a palindrome, False otherwise return ar == ar[::-1]"},{"question":"from typing import List, Tuple def top_k_categories(purchase_logs: List[Tuple[str, str]], k: int) -> List[str]: Analyze customer purchase logs and determine the top k product categories based on the number of purchases. Args: purchase_logs (List[Tuple[str, str]]): A list of tuples, each containing a customer ID and a product category. k (int): The number of top categories to return. Returns: List[str]: A list of the top k product categories based on purchase counts, ordered lexicographically in case of ties. Examples: >>> purchase_logs = [ ... (\\"c1\\", \\"electronics\\"), ... (\\"c2\\", \\"clothing\\"), ... (\\"c1\\", \\"electronics\\"), ... (\\"c3\\", \\"books\\"), ... (\\"c2\\", \\"electronics\\"), ... (\\"c3\\", \\"clothing\\"), ... (\\"c4\\", \\"clothing\\"), ... (\\"c5\\", \\"electronics\\") ... ] >>> k = 2 >>> top_k_categories(purchase_logs, k) [\\"electronics\\", \\"clothing\\"] >>> purchase_logs = [ ... (\\"c1\\", \\"toys\\"), ... (\\"c2\\", \\"toys\\"), ... (\\"c3\\", \\"toys\\"), ... (\\"c4\\", \\"toys\\"), ... (\\"c5\\", \\"toys\\") ... ] >>> k = 1 >>> top_k_categories(purchase_logs, k) [\\"toys\\"] >>> purchase_logs = [ ... (\\"c1\\", \\"outdoors\\"), ... (\\"c2\\", \\"books\\"), ... (\\"c3\\", \\"toys\\"), ... (\\"c4\\", \\"books\\"), ... (\\"c5\\", \\"gardening\\"), ... (\\"c6\\", \\"electronics\\"), ... (\\"c7\\", \\"sports\\"), ... (\\"c8\\", \\"sports\\"), ... (\\"c9\\", \\"gadgets\\") ... ] >>> k = 3 >>> top_k_categories(purchase_logs, k) [\\"books\\", \\"sports\\", \\"electronics\\"]","solution":"from typing import List, Tuple from collections import defaultdict def top_k_categories(purchase_logs: List[Tuple[str, str]], k: int) -> List[str]: category_count = defaultdict(int) # Count the frequency of each category for _, category in purchase_logs: category_count[category] += 1 # Sort categories based on the frequency (Descending) and lexicographically if frequencies are the same sorted_categories = sorted(category_count.keys(), key=lambda x: (-category_count[x], x)) # Return the top k categories return sorted_categories[:k]"},{"question":"def students_needing_improvement(students, threshold): Analyze a list of student grades and identify students who need improvement. Parameters: students (list of dict): List of dictionaries where each dictionary contains a student's name and their grades. threshold (int): The grade threshold below which a student's average grade is considered as needing improvement. Returns: list: List of student names whose average grade is below the threshold. Example: >>> students = [ ... {\\"name\\": \\"John\\", \\"grades\\": [88, 92, 79, 85]}, ... {\\"name\\": \\"Jane\\", \\"grades\\": [70, 65, 80, 75]}, ... {\\"name\\": \\"Emily\\", \\"grades\\": [95, 91, 89, 96]}, ... {\\"name\\": \\"Bob\\", \\"grades\\": [60, 55, 70, 65]}, ... {\\"name\\": \\"Alice\\", \\"grades\\": [85, 88, 84, 82]} ... ] >>> threshold = 80 >>> students_needing_improvement(students, threshold) [\\"Jane\\", \\"Bob\\"]","solution":"def students_needing_improvement(students, threshold): Returns the names of students whose average grade is below the threshold. Parameters: students (list of dict): List of dictionaries where each dictionary contains a student's name and their grades. threshold (int): The grade threshold below which a student's average grade is considered as needing improvement. Returns: list: List of student names whose average grade is below the threshold. students_needing_help = [] for student in students: average_grade = sum(student[\\"grades\\"]) / len(student[\\"grades\\"]) if average_grade < threshold: students_needing_help.append(student[\\"name\\"]) return students_needing_help"},{"question":"def remove_trailing_spaces(text: str) -> str: Removes trailing spaces from each line of the input text. Parameters: text (str): The multi-line string input. Returns: str: The multi-line string with trailing spaces removed from each line. >>> remove_trailing_spaces(\\"Hello, World! nThis is a test. nTrailing spaces should be removed. \\") \\"Hello, World!nThis is a test.nTrailing spaces should be removed.\\" >>> remove_trailing_spaces(\\" n n \\") \\"nn\\"","solution":"def remove_trailing_spaces(text): Removes trailing spaces from each line of the input text. Parameters: text (str): The multi-line string input. Returns: str: The multi-line string with trailing spaces removed from each line. lines = text.split('n') cleaned_lines = [line.rstrip() for line in lines] return 'n'.join(cleaned_lines)"},{"question":"def max_books(p1: int, recommendations1: List[int], p2: int, recommendations2: List[int]) -> int: Determine the maximum number of books according to the rules. >>> max_books(2, [2, 5], 3, [3, 5, 6]) 4 >>> max_books(1, [3], 2, [2, 4]) 3 pass","solution":"def max_books(p1, recommendations1, p2, recommendations2): recommendations1 = set(recommendations1) recommendations2 = set(recommendations2) all_recommendations = sorted(recommendations1.union(recommendations2)) max_books = 0 last_person = None for week in all_recommendations: if week in recommendations1 and week in recommendations2: max_books += 1 last_person = None elif week in recommendations1: if last_person != \\"Mia\\": max_books += 1 last_person = \\"Mia\\" else: last_person = None elif week in recommendations2: if last_person != \\"Noah\\": max_books += 1 last_person = \\"Noah\\" else: last_person = None return max_books"},{"question":"from typing import List def max_consecutive_sum(arr: List[int], k: int) -> int: Calculate the maximum sum of k consecutive elements in the list arr. >>> max_consecutive_sum([1, 3, 4, 2, 6, -1, 2, 3, 0], 3) 12 >>> max_consecutive_sum([2, 1, 5, 1, 3, 2], 2) 6","solution":"from typing import List def max_consecutive_sum(arr: List[int], k: int) -> int: # Initial sum of the first 'k' elements max_sum = sum(arr[:k]) current_sum = max_sum # Iterate over the array starting from k to the end for i in range(k, len(arr)): # Slide the window right by one element current_sum = current_sum - arr[i - k] + arr[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def smallest_special_string(N: int, K: int) -> str: Returns the lexicographically smallest special string of length N using the first K letters of the alphabet. If no such string exists, returns an empty string. >>> smallest_special_string(4, 3) \\"aabb\\" >>> smallest_special_string(5, 2) \\"\\"","solution":"def smallest_special_string(N, K): Returns the lexicographically smallest special string of length N using the first K letters of the alphabet. If no such string exists, returns an empty string. # If N is odd then it's impossible to form pairs of characters if N % 2 != 0: return \\"\\" # There need to be at least 2 distinct characters to form a special string if K < 2: return \\"\\" # Construct the lexicographically smallest special string half_length = N // 2 return \\"a\\" * half_length + \\"b\\" * half_length"},{"question":"def process_queries(N: int, Q: int, array: List[int], queries: List[Tuple[str, str, str]]) -> List[int]: Handle a list of updates and sum queries on an integer array. Args: N : int : Number of elements in the initial array Q : int : Number of queries array : List[int] : The initial list of integers queries : List[Tuple[str, str, str]] : A list of queries to process Returns: List[int] : The results of all sum queries in the order they appear Examples: >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(\\"Sum\\", \\"1\\", \\"3\\"), (\\"Update\\", \\"2\\", \\"10\\"), (\\"Sum\\", \\"1\\", \\"3\\")]) [6, 14] >>> process_queries(4, 4, [5, 7, 9, 11], [(\\"Sum\\", \\"1\\", \\"2\\"), (\\"Update\\", \\"1\\", \\"15\\"), (\\"Sum\\", \\"1\\", \\"2\\"), (\\"Sum\\", \\"3\\", \\"4\\")]) [12, 22, 20]","solution":"def process_queries(N, Q, array, queries): result = [] for query in queries: query_type, *params = query if query_type == \\"Sum\\": l, r = map(int, params) result.append(sum(array[l-1:r])) elif query_type == \\"Update\\": i, v = map(int, params) array[i-1] = v return result"},{"question":"def path_exists(n: int, m: int, grid: List[str]) -> str: Determines if there exists a path from the top-left cell to the bottom-right cell. The player can move right, down, or diagonally to the bottom-right if cells are empty. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. grid (list of str): the grid representation of the game board. Returns: str: \\"YES\\" if a path exists, otherwise \\"NO\\".","solution":"def path_exists(n, m, grid): Determines if there exists a path from the top-left cell to the bottom-right cell. The player can move right, down, or diagonally to the bottom-right if cells are empty. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. grid (list of str): the grid representation of the game board. Returns: str: \\"YES\\" if a path exists, otherwise \\"NO\\". if grid[0][0] == '#' or grid[n - 1][m - 1] == '#': return \\"NO\\" visited = [[False] * m for _ in range(n)] directions = [(1, 0), (0, 1), (1, 1)] # down, right, bottom-right (diagonal) def dfs(x, y): if x == n - 1 and y == m - 1: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': if dfs(nx, ny): return True return False if dfs(0, 0): return \\"YES\\" return \\"NO\\""},{"question":"def sumOfSquares(N: int) -> int: Given an integer N, calculate the sum of the series 1^2 + 2^2 + 3^2 + ... till N-th term. Returns the sum of the squares of the first N natural numbers. >>> sumOfSquares(4) 30 >>> sumOfSquares(6) 91 >>> sumOfSquares(1) 1 >>> sumOfSquares(1000000) 333333833333500000 >>> sumOfSquares(0) 0 >>> sumOfSquares(10) 385 >>> sumOfSquares(15) 1240 >>> sumOfSquares(100) 338350","solution":"def sumOfSquares(N): Returns the sum of the squares of the first N natural numbers. # Using the formula for the sum of squares of the first N natural numbers return (N * (N + 1) * (2 * N + 1)) // 6"},{"question":"class Node: def __init__(self, data): self.data = data self.next = None def reverse(head, k): Reverse a Linked List in groups of given size 'k'. >>> head = list_to_linked_list([1, 2, 2, 4, 5, 6, 7, 8]) >>> k = 4 >>> new_head = reverse(head, k) >>> linked_list_to_list(new_head) [4, 2, 2, 1, 8, 7, 6, 5] >>> head = list_to_linked_list([1, 2, 3, 4, 5]) >>> k = 3 >>> new_head = reverse(head, k) >>> linked_list_to_list(new_head) [3, 2, 1, 5, 4] >>> head = list_to_linked_list([1, 2, 3]) >>> k = 3 >>> new_head = reverse(head, k) >>> linked_list_to_list(new_head) [3, 2, 1] def linked_list_to_list(head): result = [] while head: result.append(head.data) head = head.next return result def list_to_linked_list(elements): if not elements: return None head = Node(elements[0]) current = head for element in elements[1:]: current.next = Node(element) current = current.next return head","solution":"class Node: def __init__(self, data): self.data = data self.next = None def reverse(head, k): if head is None: return None current = head next = None prev = None count = 0 # Reverse first k nodes of the linked list while current is not None and count < k: next = current.next current.next = prev prev = current current = next count += 1 if next is not None: head.next = reverse(next, k) return prev"},{"question":"from typing import List def find_median(sequence: List[int]) -> float: Returns the median of a given sequence of integers. >>> find_median([3, 1, 2]) 2 >>> find_median([10, 20, 30, 40]) 25.0 def process_sequences(input_lines: List[str]) -> List[float]: Processes multiple lines of integer sequences and returns the medians. >>> process_sequences([\\"3 1 2\\", \\"10 20 30 40\\", \\"5 3 8 1\\", \\"0\\"]) [2, 25.0, 4.0] >>> process_sequences([\\"-10 -20 -30\\", \\"1000 -1000 0\\", \\"0\\"]) [-20, 0.0]","solution":"def find_median(sequence): Returns the median of a given sequence of integers. sequence.sort() n = len(sequence) if n % 2 == 1: median = sequence[n // 2] else: median = (sequence[n // 2 - 1] + sequence[n // 2]) / 2 return median def process_sequences(input_lines): Processes multiple lines of integer sequences and returns the medians. medians = [] for line in input_lines: sequence = list(map(int, line.split())) if sequence == [0]: break medians.append(find_median(sequence)) return medians"},{"question":"def can_be_balanced_with_one_swap(n: int, a: List[int]) -> str: Determine if it is possible to make the sequence balanced by performing exactly one swap. >>> can_be_balanced_with_one_swap(4, [1, 3, 2, 2]) \\"YES\\" >>> can_be_balanced_with_one_swap(3, [1, 2, 3]) \\"NO\\" >>> can_be_balanced_with_one_swap(2, [1, 1]) \\"YES\\"","solution":"def can_be_balanced_with_one_swap(n, a): even_sum = sum(a[i] for i in range(0, n, 2)) odd_sum = sum(a[i] for i in range(1, n, 2)) if even_sum == odd_sum: return \\"YES\\" for i in range(n): for j in range(i + 1, n): if (i % 2 == 0 and j % 2 == 1) or (i % 2 == 1 and j % 2 == 0): new_even_sum = even_sum - a[i] + a[j] new_odd_sum = odd_sum - a[j] + a[i] if new_even_sum == new_odd_sum: return \\"YES\\" return \\"NO\\""},{"question":"def find_peak_element(nums): Finds a peak element in the list. A peak element is one that is greater than its neighbors. Uses a binary search algorithm to achieve O(log n) complexity. :param nums: List of integers :return: A peak element from the list >>> find_peak_element([1]) 1 >>> find_peak_element([1, 3, 20, 4, 1, 0]) 20 >>> find_peak_element([10, 20, 30]) 30 >>> find_peak_element([30, 20, 10]) 30 >>> find_peak_element([1, 3, 4, 3, 2, 5, 6, 4]) 4","solution":"def find_peak_element(nums): Finds a peak element in the list. A peak element is one that is greater than its neighbors. Uses a binary search algorithm to achieve O(log n) complexity. :param nums: List of integers :return: A peak element from the list left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return nums[left]"},{"question":"def count_fruit_combinations(n, apples, m, oranges, k): Returns the number of different combinations of apples and oranges that sum exactly to k. Parameters: n (int): number of apple quantities. apples (list of int): quantities of apples. m (int): number of orange quantities. oranges (list of int): quantities of oranges. k (int): exact number of fruits required. Returns: int: number of combinations that sum exactly to k. >>> count_fruit_combinations(3, [1, 2, 3], 3, [4, 5, 6], 7) 3 >>> count_fruit_combinations(2, [3, 6], 2, [2, 4], 8) 1 >>> count_fruit_combinations(3, [1, 2, 3], 3, [4, 5, 6], 10) 0 >>> count_fruit_combinations(4, [1, 2, 3, 4], 4, [3, 4, 5, 6], 7) 4 >>> count_fruit_combinations(5, [2, 3, 7, 11, 13], 4, [1, 4, 5, 6], 14) 1 >>> count_fruit_combinations(5, [1, 2, 3, 4, 5], 0, [], 5) 0 >>> count_fruit_combinations(0, [], 4, [1, 2, 3, 4], 5) 0","solution":"def count_fruit_combinations(n, apples, m, oranges, k): Returns the number of different combinations of apples and oranges that sum exactly to k. apple_set = set(apples) count = 0 for orange in oranges: if k - orange in apple_set: count += 1 return count"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring with all unique characters. Parameters: s (str): The input string. Returns: str: The longest substring with all unique characters. Examples: >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\"","solution":"def longest_unique_substring(s): Returns the longest substring with all unique characters. Parameters: s (str): The input string. Returns: str: The longest substring with all unique characters. char_index_map = {} start = 0 max_len = 0 max_start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end if end - start + 1 > max_len: max_len = end - start + 1 max_start = start return s[max_start:max_start + max_len]"},{"question":"from typing import List, Tuple def arrange_animals(n: int, restrictions: List[Tuple[int, int]]) -> List[int]: Arranges animals in a single-file line such that no two animals with animosities towards each other are placed side by side. :param n: The number of animals :param restrictions: List of restrictions where each pair contains two integers indicating the animals that cannot be next to each other :return: A valid arrangement if possible, otherwise [-1] >>> arrange_animals(4, [(1, 2), (2, 3)]) [1, 3, 2, 4] >>> arrange_animals(3, [(1, 2), (2, 3), (1, 3)]) [-1]","solution":"from typing import List, Tuple from itertools import permutations def arrange_animals(n: int, restrictions: List[Tuple[int, int]]) -> List[int]: Arranges animals in a single-file line such that no two animals with animosities towards each other are placed side by side. :param n: The number of animals :param restrictions: List of restrictions where each pair contains two integers indicating the animals that cannot be next to each other :return: A valid arrangement if possible, otherwise [-1] # Generate all permutations of animals for perm in permutations(range(1, n + 1)): valid = True # Check if current permutation satisfies all restrictions for i in range(n - 1): if (perm[i], perm[i + 1]) in restrictions or (perm[i + 1], perm[i]) in restrictions: valid = False break if valid: return list(perm) return [-1]"},{"question":"def uniquePaths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner in a m x n grid. >>> uniquePaths(3, 2) == 3 >>> uniquePaths(7, 3) == 28 >>> uniquePaths(3, 7) == 28 >>> uniquePaths(3, 3) == 6 >>> uniquePaths(1, 1) == 1","solution":"def uniquePaths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner in a m x n grid. # Create a 2D list initialized with 1s for dynamic programming dp = [[1]*n for _ in range(m)] # Iterate through the grid starting from cell (1, 1) for i in range(1, m): for j in range(1, n): # Number of ways to reach this cell is sum of ways to reach from the left and above cell dp[i][j] = dp[i-1][j] + dp[i][j-1] # Return the value in the bottom-right corner of the grid return dp[m-1][n-1]"},{"question":"def can_collect_mana(grid, N, target): Determines if a path exists from (0, 0) to (N-1, N-1) with the sum exactly equal to target. def dfs(grid, N, target, current_sum, x, y): if x >= N or y >= N: return False current_sum += grid[x][y] if current_sum > target: return False if x == N - 1 and y == N - 1: return current_sum == target return dfs(grid, N, target, current_sum, x + 1, y) or dfs(grid, N, target, current_sum, x, y + 1) def enchanted_forest(test_cases): results = [] for test in test_cases: N, target, grid = test if can_collect_mana(grid, N, target): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: if __name__ == \\"__main__\\": test_cases_input = [ (4, 14, [ [5, 3, 2, 1], [1, 2, 3, 4], [1, 1, 1, 1], [4, 1, 2, 1] ]), (4, 10, [ [5, 3, 2, 1], [1, 2, 3, 4], [1, 1, 1, 1], [4, 1, 2, 1] ]) ] print(enchanted_forest(test_cases_input)) def test_enchanted_forest(): test_cases = [ (4, 14, [ [5, 3, 2, 1], [1, 2, 3, 4], [1, 1, 1, 1], [4, 1, 2, 1] ]), (4, 10, [ [5, 3, 2, 1], [1, 2, 3, 4], [1, 1, 1, 1], [4, 1, 2, 1] ]) ] expected_results = [\\"YES\\", \\"NO\\"] results = enchanted_forest(test_cases) for result, expected in zip(results, expected_results): assert result == expected def test_small_grid(): test_cases = [ (2, 5, [ [1, 2], [2, 2] ]), (2, 7, [ [1, 2], [2, 2] ]) ] expected_results = [\\"YES\\", \\"NO\\"] results = enchanted_forest(test_cases) for result, expected in zip(results, expected_results): assert result == expected def test_single_element_grid(): test_cases = [ (1, 5, [ [5] ]), (1, 2, [ [1] ]) ] expected_results = [\\"YES\\", \\"NO\\"] results = enchanted_forest(test_cases) for result, expected in zip(results, expected_results): assert result == expected","solution":"def can_collect_mana(grid, N, target): Determines if a path exists from (0, 0) to (N-1, N-1) with the sum exactly equal to target. return dfs(grid, N, target, 0, 0, 0) def dfs(grid, N, target, current_sum, x, y): if x >= N or y >= N: return False current_sum += grid[x][y] if current_sum > target: return False if x == N - 1 and y == N - 1: return current_sum == target return dfs(grid, N, target, current_sum, x + 1, y) or dfs(grid, N, target, current_sum, x, y + 1) def enchanted_forest(test_cases): results = [] for test in test_cases: N, target, grid = test if can_collect_mana(grid, N, target): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: if __name__ == \\"__main__\\": test_cases_input = [ (4, 14, [ [5, 3, 2, 1], [1, 2, 3, 4], [1, 1, 1, 1], [4, 1, 2, 1] ]), (4, 10, [ [5, 3, 2, 1], [1, 2, 3, 4], [1, 1, 1, 1], [4, 1, 2, 1] ]) ] print(enchanted_forest(test_cases_input))"},{"question":"def longest_common_prefix(words: List[str]) -> str: Returns the longest common prefix among all given words. :param words: List of words :type words: List[str] :return: The longest common prefix :rtype: str >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\", \\"flock\\", \\"floral\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"apple\\"]) 'apple' >>> longest_common_prefix([]) '' >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) 'test' >>> longest_common_prefix([\\"a\\", \\"ab\\", \\"ac\\"]) 'a' >>> longest_common_prefix([\\"\\", \\"\\", \\"\\"]) ''","solution":"def longest_common_prefix(words): Returns the longest common prefix among all given words. :param words: List of words :type words: List[str] :return: The longest common prefix :rtype: str if not words: return \\"\\" # Find the shortest word in the list shortest_word = min(words, key=len) # Compare all words with the shortest word for i in range(len(shortest_word)): for word in words: if word[i] != shortest_word[i]: return shortest_word[:i] return shortest_word"},{"question":"def highest_available_ticket(pricelist): Returns the highest available ticket price which is still available or \\"NO TICKETS\\" >>> highest_available_ticket([1, 0, 1, 0, 1]) 4 >>> highest_available_ticket([1, 1, 1, 1]) \\"NO TICKETS\\" >>> highest_available_ticket([0, 0, 0, 0]) 4 >>> highest_available_ticket([1, 1, 0, 1]) 3 >>> highest_available_ticket([0, 1, 1, 1]) 1 >>> highest_available_ticket([0]) 1 >>> highest_available_ticket([1]) \\"NO TICKETS\\" pass def main(input_data): Parses the input data, runs the solution for each test case, and returns the results. >>> main(\\"2n5n1 0 1 0 1n4n1 1 1 1n\\") [4, \\"NO TICKETS\\"] >>> main(\\"1n6n0 0 0 0 0 1n\\") [5] >>> main(\\"1n3n1 1 1n\\") [\\"NO TICKETS\\"] >>> main(\\"3n2n1 0n3n0 1 0n4n0 0 0 0n\\") [2, 3, 4] pass","solution":"def highest_available_ticket(pricelist): Returns the highest available ticket price which is still available or \\"NO TICKETS\\" n = len(pricelist) for i in range(n-1, -1, -1): if pricelist[i] == 0: return i + 1 return \\"NO TICKETS\\" def main(input_data): Parses the input data, runs the solution for each test case, and returns the results. result = [] input_lines = input_data.split('n') T = int(input_lines[0]) index = 1 for _ in range(T): N = int(input_lines[index]) pricelist = list(map(int, input_lines[index+1].split())) result.append(highest_available_ticket(pricelist)) index += 2 return result"},{"question":"def count_squares(n: int, m: int) -> int: Returns the number of unique squares that can be formed within a rectangle of dimensions n x m. >>> count_squares(2, 3) 8 >>> count_squares(4, 4) 30","solution":"def count_squares(n, m): Returns the number of unique squares that can be formed within a rectangle of dimensions n x m. count = 0 # Iterate over possible square sizes for size in range(1, min(n, m) + 1): count += (n - size + 1) * (m - size + 1) return count"},{"question":"def uniqueCharacters(s): Returns True if the string s contains all unique characters, False otherwise. >>> uniqueCharacters('world') True >>> uniqueCharacters('hello') False >>> uniqueCharacters('') True >>> uniqueCharacters('a') True >>> uniqueCharacters('abcdefghijklmnopqrstuvwxyz') True >>> uniqueCharacters('abcdeffghijklmnopqrstuvwxyz') False","solution":"def uniqueCharacters(s): Returns True if the string s contains all unique characters, False otherwise. return len(set(s)) == len(s)"},{"question":"def make_elements_zero(t: int, cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[int]]]: Given multiple test cases, for each test case, determine a series of operations to make n-1 elements of the array equal to zero within at most n + 5 steps. Args: t (int): Number of test cases. cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer n and a list of n integers representing the array. Returns: List[Tuple[int, List[int]]]: A list of tuples where each tuple contains an integer representing the number of operations and a list of integers representing the indices of the corresponding operations. Example: >>> make_elements_zero(2, [(3, [5, 7, 9]), (4, [1, 1, 1, 1])]) [(4, [1, 1, 1, 1]), (5, [1, 1, 1, 1, 1])] >>> make_elements_zero(1, [(2, [1, 2])]) [(3, [1, 1, 1])]","solution":"def make_elements_zero(t, cases): results = [] for case in cases: n, arr = case total_sum = sum(arr) # If there is any element which is not zero we can use any index # any n-n, n-1 positions will always be set to zero operations = [1] * (n + 1) results.append((n + 1, operations)) return results"},{"question":"def word_occurrences(text_lines): For each input line, counts the occurrences of each word and prints the words along with their counts in alphabetical order. Args: text_lines: List of strings, where each string is a line of words. Returns: A list of strings, where each string is in the format \\"word: count\\". >>> word_occurrences([\\"the quick brown fox\\", \\"STOP\\"]) [\\"brown: 1\\", \\"fox: 1\\", \\"quick: 1\\", \\"the: 1\\"] >>> word_occurrences([\\"the quick brown fox\\", \\"jumps over the lazy dog\\", \\"the quick brown dog\\", \\"STOP\\"]) [\\"brown: 1\\", \\"fox: 1\\", \\"quick: 1\\", \\"the: 1\\", \\"dog: 1\\", \\"jumps: 1\\", \\"lazy: 1\\", \\"over: 1\\", \\"the: 1\\", \\"brown: 1\\", \\"dog: 1\\", \\"quick: 1\\", \\"the: 1\\"] >>> word_occurrences([\\"STOP\\"]) [] >>> word_occurrences([\\"word word word word\\", \\"STOP\\"]) [\\"word: 4\\"] >>> word_occurrences([\\"a1 b2 c3\\", \\"b2 b2 a1\\", \\"STOP\\"]) [\\"a1: 1\\", \\"b2: 1\\", \\"c3: 1\\", \\"a1: 1\\", \\"b2: 2\\"]","solution":"def word_occurrences(text_lines): For each input line, counts the occurrences of each word and prints the words along with their counts in alphabetical order. results = [] for line in text_lines: if line == \\"STOP\\": break word_count = {} words = line.split() for word in words: word_count[word] = word_count.get(word, 0) + 1 sorted_words = sorted(word_count.items()) for word, count in sorted_words: results.append(f\\"{word}: {count}\\") return results # Example usage: # text_lines = [ # \\"the quick brown fox\\", # \\"jumps over the lazy dog\\", # \\"the quick brown dog\\", # \\"STOP\\" # ] # print(\\"n\\".join(word_occurrences(text_lines)))"},{"question":"def closest_pair_to_target(lst: List[int], target: int) -> Tuple[int, int]: Find two elements in the list whose sum is closest to the target. >>> closest_pair_to_target([-1, 2, 1, -4, 5], 1) in [(-1, 2), (-4, 5)] True >>> closest_pair_to_target([1, 3, 4, 2, 5], 6) in [(1, 5), (4, 2)] True >>> closest_pair_to_target([-10, -3, 5, 8, 3, -1, 7], 0) in [(-10, 10), (-3, 3)] True >>> closest_pair_to_target([1, -3, 3, 2, -2], -1) in [(1, -2), (3, -3)] True >>> closest_pair_to_target([0, 0, 0, 0], 0) == (0, 0) True","solution":"def closest_pair_to_target(lst, target): Find two elements in the list whose sum is closest to the target. N = len(lst) closest_sum = float('inf') result_pair = (None, None) for i in range(N): for j in range(i + 1, N): current_sum = lst[i] + lst[j] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum result_pair = (lst[i], lst[j]) return result_pair"},{"question":"def can_reorganize_fruits(T: int, test_cases: List[str]) -> List[str]: Determine whether it is possible to rearrange the basket of fruits such that each type of fruit appears the same number of times. >>> can_reorganize_fruits(3, [\\"aabbcc\\", \\"aabbc\\", \\"abcabcabc\\"]) ['YES', 'NO', 'YES'] >>> can_reorganize_fruits(1, [\\"aaaaa\\"]) ['YES'] from collections import Counter def test_all_same_fruit_count(): assert can_reorganize_fruits(1, [\\"aabbcc\\"]) == [\\"YES\\"] def test_not_possible_to_reorganize(): assert can_reorganize_fruits(1, [\\"aabbc\\"]) == [\\"NO\\"] def test_all_fruits_have_same_frequency(): assert can_reorganize_fruits(1, [\\"abcabcabc\\"]) == [\\"YES\\"] def test_single_fruit_type(): assert can_reorganize_fruits(1, [\\"aaaaaa\\"]) == [\\"YES\\"] def test_two_fruit_types_with_same_count(): assert can_reorganize_fruits(1, [\\"aabb\\"]) == [\\"YES\\"] def test_two_fruit_types_with_different_count(): assert can_reorganize_fruits(1, [\\"aabbc\\"]) == [\\"NO\\"] def test_large_input(): long_input = \\"a\\" * 50000 + \\"b\\" * 50000 assert can_reorganize_fruits(1, [long_input]) == [\\"YES\\"]","solution":"def can_reorganize_fruits(T, test_cases): results = [] for S in test_cases: from collections import Counter fruit_count = Counter(S) frequencies = list(fruit_count.values()) common_freq = frequencies[0] if all(freq == common_freq for freq in frequencies): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def next_greater_elements(arr): Given an input array of integers, return an array where each element is replaced by the next greater element to its right. If no greater element exists to the right for a specific position, -1 is placed. Args: arr (List[int]): The input array of non-negative integers. Returns: List[int]: A new array where each position holds the next greater element of the corresponding element in the input array. Examples: >>> next_greater_elements([4, 5, 2, 10]) [5, 10, 10, -1] >>> next_greater_elements([3, 7, 1, 7, 8, 4]) [7, 8, 7, 8, -1, -1]","solution":"def next_greater_elements(arr): Given an input array of integers, return an array where each element is replaced by the next greater element to its right. If no greater element exists to the right for a specific position, -1 is placed. n = len(arr) result = [-1] * n stack = [] # Traverse the list in reverse order for i in range(n - 1, -1, -1): while stack and stack[-1] <= arr[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(arr[i]) return result"},{"question":"def is_compatible(existing_version: str, new_version: str) -> str: Check if new version is compatible with existing version based on the given rules. >>> is_compatible(\\"1.2.3\\", \\"2.0.0\\") \\"Yes\\" >>> is_compatible(\\"3.5.6\\", \\"3.5.8\\") \\"Yes\\" >>> is_compatible(\\"10.9.7\\", \\"10.9.6\\") \\"No\\" pass def check_compatibility(test_cases: List[str]) -> List[str]: Determine the compatibility for a list of versions. >>> check_compatibility([\\"1.2.3\\", \\"2.0.0\\", \\"3.5.6\\", \\"3.5.8\\", \\"10.9.7\\", \\"10.9.6\\"]) [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> check_compatibility([\\"1.2.3\\", \\"1.3.0\\", \\"1.2.3\\", \\"1.2.2\\"]) [\\"Yes\\", \\"No\\"] pass","solution":"def is_compatible(existing_version, new_version): Check if new version is compatible with existing version based on the given rules. existing = list(map(int, existing_version.split('.'))) new = list(map(int, new_version.split('.'))) if new[0] > existing[0]: return \\"Yes\\" elif new[0] == existing[0]: if new[1] > existing[1]: return \\"Yes\\" elif new[1] == existing[1]: if new[2] > existing[2]: return \\"Yes\\" return \\"No\\" def check_compatibility(test_cases): results = [] for i in range(0, len(test_cases), 2): existing_version = test_cases[i] new_version = test_cases[i+1] results.append(is_compatible(existing_version, new_version)) return results"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges all overlapping intervals and returns a list of merged intervals in sorted order. Parameters: intervals (List[List[int]]): List of intervals where each interval is represented as a list [start, end]. Returns: List[List[int]]: A list of merged intervals. Examples: >>> merge_intervals([[1,3],[2,6],[8,10],[15,18]]) [[1,6],[8,10],[15,18]] >>> merge_intervals([[1,4],[4,5]]) [[1,5]] >>> merge_intervals([]) [] >>> merge_intervals([[1,5], [5,10], [10,15], [20,25]]) [[1,15], [20,25]] >>> merge_intervals([[2,3], [4,5], [6,7], [1,10]]) [[1,10]]","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns a list of merged intervals in sorted order. :param intervals: List of intervals where each interval is represented as a list [start, end]. :type intervals: List of List of int :return: A list of merged intervals. :rtype: List of List of int if not intervals: return [] # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # if the list of merged intervals is empty or if the current interval # does not overlap with the previous interval, add it to the list if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # there is overlap, so we merge the current and previous intervals merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"from typing import List def triangle_type(side1: int, side2: int, side3: int) -> str: Determines the type of a triangle given its three sides. Parameters: side1 (int): The length of the first side. side2 (int): The length of the second side. side3 (int): The length of the third side. Returns: str: \\"Equilateral\\" if the triangle is equilateral, \\"Isosceles\\" if the triangle is isosceles, \\"Scalene\\" if the triangle is scalene. >>> triangle_type(5, 5, 5) 'Equilateral' >>> triangle_type(6, 5, 5) 'Isosceles' >>> triangle_type(3, 4, 5) 'Scalene'","solution":"def triangle_type(side1, side2, side3): Determines the type of a triangle given its three sides. Parameters: side1 (int): The length of the first side. side2 (int): The length of the second side. side3 (int): The length of the third side. Returns: str: \\"Equilateral\\" if the triangle is equilateral, \\"Isosceles\\" if the triangle is isosceles, \\"Scalene\\" if the triangle is scalene. if side1 == side2 == side3: return \\"Equilateral\\" elif side1 == side2 or side2 == side3 or side1 == side3: return \\"Isosceles\\" else: return \\"Scalene\\""},{"question":"def trap(height: List[int]) -> int: Given a list of non-negative integers representing the heights of buildings in a row, calculate the amount of water that could be trapped after a downpour. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"def trap(height): Calculates the amount of water that could be trapped after a downpour. n = len(height) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water = 0 for i in range(n): water += min(left_max[i], right_max[i]) - height[i] return water"},{"question":"from typing import List def flatten_and_sort(array: List[List[float]]) -> List[float]: Create a function that takes a two-dimensional array (a list of lists) and returns a flattened, sorted one-dimensional array. Example: >>> flatten_and_sort([[3, 2, 1], [4, 6, 5], [], [9, 7], [8]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_and_sort([[1.2, 3.5, 2.1], [4.6, 5.3], [9.4], [8.8, 7.7]]) [1.2, 2.1, 3.5, 4.6, 5.3, 7.7, 8.8, 9.4] >>> flatten_and_sort([[], [], []]) [] >>> flatten_and_sort([]) [] >>> flatten_and_sort([[1], [2], [3], [4], [5]]) [1, 2, 3, 4, 5] >>> flatten_and_sort([[3, -2, 1], [-4, 6, 5], [], [-9, 7], [8]]) [-9, -4, -2, 1, 3, 5, 6, 7, 8]","solution":"def flatten_and_sort(array): Flattens a two-dimensional list and returns a sorted one-dimensional list. flattened_list = [item for sublist in array for item in sublist] return sorted(flattened_list)"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained by replacing any substring \\"ab\\" with \\"ba\\" any number of times. >>> lexicographically_smallest_string(\\"abab\\") == \\"aabb\\" >>> lexicographically_smallest_string(\\"baa\\") == \\"aab\\" >>> lexicographically_smallest_string(\\"aaaa\\") == \\"aaaa\\" >>> lexicographically_smallest_string(\\"bbbb\\") == \\"bbbb\\" >>> lexicographically_smallest_string(\\"a\\") == \\"a\\" >>> lexicographically_smallest_string(\\"b\\") == \\"b\\" >>> lexicographically_smallest_string(\\"baba\\") == \\"aabb\\" >>> lexicographically_smallest_string(\\"ab\\") == \\"ab\\" >>> lexicographically_smallest_string(\\"ba\\") == \\"ab\\" >>> lexicographically_smallest_string(\\"baab\\") == \\"aabb\\" >>> lexicographically_smallest_string(\\"abbb\\") == \\"abbb\\" >>> lexicographically_smallest_string(\\"aaaabb\\") == \\"aaaabb\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by replacing any substring \\"ab\\" with \\"ba\\" any number of times. # Count the number of 'a's and 'b's in the input string count_a = s.count('a') count_b = len(s) - count_a # Construct the smallest string by placing all 'a's before all 'b's return 'a' * count_a + 'b' * count_b"},{"question":"def most_frequent_letter(s: str) -> str: Finds the most frequent letter in the string s. If there is a tie, the alphabetically first letter is returned. >>> most_frequent_letter(\\"test\\") 't' >>> most_frequent_letter(\\"google\\") 'g' >>> most_frequent_letter(\\"interview\\") 'e' pass def process_input(T: int, strings: List[str]) -> List[str]: Processes multiple test cases and returns a list of the most frequent letter for each string. >>> process_input(3, [\\"test\\", \\"google\\", \\"interview\\"]) ['t', 'g', 'e'] >>> process_input(2, [\\"aabbcc\\", \\"bbccaa\\"]) ['a', 'a'] pass","solution":"def most_frequent_letter(s): Finds the most frequent letter in the string s. In case of a tie, the alphabetically first letter is returned. from collections import Counter # Count the frequency of each letter frequency = Counter(s) # Find the maximum frequency max_frequency = max(frequency.values()) # Get the letters with the maximum frequency most_frequent_letters = [letter for letter, count in frequency.items() if count == max_frequency] # Return the alphabetically first letter among the most frequent ones return min(most_frequent_letters) def process_input(T, strings): results = [] for s in strings: results.append(most_frequent_letter(s)) return results"},{"question":"def process_commands(commands): Process a sequence of commands to simulate a banking transaction system. >>> commands = [ ... \\"DEPOSIT 123 100.00\\", ... \\"DEPOSIT 456 50.00\\", ... \\"WITHDRAW 123 25.00\\", ... \\"BALANCE 123\\", ... \\"WITHDRAW 123 1000.00\\", ... \\"BALANCE 123\\", ... \\"BALANCE 789\\" ... ] >>> process_commands(commands) [\\"75.00\\", \\"75.00\\", \\"ERROR\\"] >>> commands = [ ... \\"DEPOSIT 111 200.00\\", ... \\"WITHDRAW 111 150.00\\", ... \\"BALANCE 111\\" ... ] >>> process_commands(commands) [\\"50.00\\"] >>> commands = [ ... \\"DEPOSIT 222 100.00\\", ... \\"WITHDRAW 222 150.00\\", ... \\"BALANCE 222\\" ... ] >>> process_commands(commands) [\\"100.00\\"] >>> commands = [ ... \\"DEPOSIT 123 100.00\\", ... \\"DEPOSIT 234 50.00\\", ... \\"WITHDRAW 123 60.00\\", ... \\"BALANCE 123\\", ... \\"BALANCE 234\\" ... ] >>> process_commands(commands) [\\"40.00\\", \\"50.00\\"] >>> commands = [ ... \\"BALANCE 999\\" ... ] >>> process_commands(commands) [\\"ERROR\\"]","solution":"def process_commands(commands): accounts = {} results = [] for command in commands: parts = command.split() action = parts[0] account_number = int(parts[1]) if action == \\"DEPOSIT\\": amount = float(parts[2]) if account_number not in accounts: accounts[account_number] = 0.0 accounts[account_number] += amount elif action == \\"WITHDRAW\\": amount = float(parts[2]) if account_number in accounts and accounts[account_number] >= amount: accounts[account_number] -= amount elif action == \\"BALANCE\\": if account_number in accounts: results.append(f\\"{accounts[account_number]:.2f}\\") else: results.append(\\"ERROR\\") return results"},{"question":"def find_combinations(n: int, T: int): Given a positive integer \`n\`, find all unique combinations of \`n\` that add up to a positive integer \`T\`, where \`T\` is less than or equal to 100 and \`1 ≤ n ≤ 30\`. Each number in the combination must be greater than or equal to 1. >>> find_combinations(3, 7) [[1, 1, 5], [1, 2, 4], [1, 3, 3], [2, 2, 3]] >>> find_combinations(2, 5) [[1, 4], [2, 3]]","solution":"def find_combinations(n, target): def backtrack(remain, combo, start): if remain == 0 and len(combo) == n: result.append(list(combo)) return elif remain < 0 or len(combo) == n: return for i in range(start, target + 1): combo.append(i) backtrack(remain - i, combo, i) combo.pop() result = [] backtrack(target, [], 1) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): Converts a list of node values into a binary tree. if not nodes: return None mid = len(nodes) // 2 root = TreeNode(nodes[mid]) root.left = build_tree(nodes[:mid]) root.right = build_tree(nodes[mid+1:]) return root def inorderTraversal(root): Returns the in-order traversal of a binary tree. >>> tree = TreeNode(2) >>> tree.left = TreeNode(1) >>> tree.right = TreeNode(4) >>> tree.right.left = TreeNode(3) >>> tree.right.right = TreeNode(5) >>> inorderTraversal(tree) [1, 2, 3, 4, 5] >>> tree = TreeNode(1) >>> inorderTraversal(tree) [1] >>> tree = TreeNode(3) >>> tree.left = TreeNode(2) >>> tree.left.left = TreeNode(1) >>> inorderTraversal(tree) [1, 2, 3] >>> tree = TreeNode(1) >>> tree.right = TreeNode(2) >>> tree.right.right = TreeNode(3) >>> inorderTraversal(tree) [1, 2, 3] >>> nodes = [1, 2, 3, 4, 5] >>> tree = build_tree(nodes) >>> inorderTraversal(tree) [1, 2, 3, 4, 5]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): if not nodes: return None mid = len(nodes) // 2 root = TreeNode(nodes[mid]) root.left = build_tree(nodes[:mid]) root.right = build_tree(nodes[mid+1:]) return root def inorderTraversal(root): Returns the in-order traversal of a binary tree. result = [] def inorder(node): if not node: return inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result"},{"question":"from typing import List, Tuple, Dict def max_successful_purchases(T: int, test_cases: List[Dict]) -> List[int]: Given the number of test cases and associated data, return the maximum number of successful purchases. Args: T: int - The number of test cases. test_cases: List[Dict] - A list of dictionaries where each dictionary represents one test case and contains the following keys: 'N' (int): The number of products. 'U' (int): The number of user attempts. 'products' (List[Tuple[int, int]]): A list of tuples where each tuple represents a product with (discount, availability). 'user_attempts' (List[Tuple[int, int]]): A list of tuples where each tuple represents a user attempt with (product ID, timestamp). Returns: List[int] - A list where each element corresponds to the maximum number of successful purchases for each test case. Example: >>> max_successful_purchases(1, [{'N': 3, 'U': 5, 'products': [(10, 2), (15, 1), (20, 3)], 'user_attempts': [(1, 5), (2, 10), (1, 5), (3, 15), (2, 10)}]) [3] pass # Implementation goes here from itertools import groupby def test_sample_input(): test_cases = [ { 'N': 3, 'U': 5, 'products': [(10, 2), (15, 1), (20, 3)], 'user_attempts': [(1, 5), (2, 10), (1, 5), (3, 15), (2, 10)] } ] assert max_successful_purchases(1, test_cases) == [3] def test_all_different_timestamps(): test_cases = [ { 'N': 3, 'U': 6, 'products': [(10, 2), (15, 1), (20, 3)], 'user_attempts': [(1, 1), (1, 2), (2, 3), (3, 4), (3, 5), (3, 6)] } ] assert max_successful_purchases(1, test_cases) == [6] def test_limited_availability(): test_cases = [ { 'N': 3, 'U': 5, 'products': [(10, 1), (15, 2), (20, 1)], 'user_attempts': [(1, 2), (1, 2), (2, 3), (2, 3), (3, 4)] } ] assert max_successful_purchases(1, test_cases) == [3] def test_max_purchase_attempts(): test_cases = [ { 'N': 2, 'U': 6, 'products': [(5, 2), (10, 2)], 'user_attempts': [(1, 1), (1, 1), (2, 2), (2, 2), (2, 2), (1, 3)] } ] assert max_successful_purchases(1, test_cases) == [3] def test_no_user_attempts(): test_cases = [ { 'N': 3, 'U': 0, 'products': [(10, 2), (15, 1), (20, 3)], 'user_attempts': [] } ] assert max_successful_purchases(1, test_cases) == [0] def test_exact_availability(): test_cases = [ { 'N': 2, 'U': 4, 'products': [(10, 2), (5, 2)], 'user_attempts': [(1, 2), (1, 2), (2, 3), (2, 3)] } ] assert max_successful_purchases(1, test_cases) == [2]","solution":"from collections import defaultdict, Counter def max_successful_purchases(T, test_cases): results = [] for i in range(T): N, U = test_cases[i]['N'], test_cases[i]['U'] products = test_cases[i]['products'] user_attempts = test_cases[i]['user_attempts'] product_availability = {idx + 1: products[idx][1] for idx in range(N)} attempt_dict = defaultdict(list) for user in user_attempts: P_i, T_i = user attempt_dict[(P_i, T_i)].append(user) successful_purchases = 0 for key, attempts in attempt_dict.items(): P_i = key[0] if product_availability[P_i] > 0: successful_purchases += 1 product_availability[P_i] -= 1 results.append(successful_purchases) return results"},{"question":"def count_elements_with_larger(arr): Returns the number of distinct elements in the array that have at least one other element in the array which is larger than itself. >>> count_elements_with_larger([1, 2, 3, 4]) == 3 >>> count_elements_with_larger([4, 4, 4, 4]) == 0","solution":"def count_elements_with_larger(arr): Returns the number of distinct elements in the array that have at least one other element in the array which is larger than itself. if not arr: return 0 # Find the maximum element in the array max_element = max(arr) # Use a set to store distinct elements distinct_elements = set(arr) # Remove the maximum element from the set if max_element in distinct_elements: distinct_elements.remove(max_element) # Return the count of remaining elements return len(distinct_elements)"},{"question":"def min_in_subarray(arr, queries): Returns the minimum value in the subarray for each query. Parameters: arr (list): List of integers. queries (list): List of tuples, each containing (L, R) indexes. Returns: list: List of minimum values for each query. # Test cases to validate the solution def test_min_in_subarray(): assert min_in_subarray([1, 3, 2, 7, 9], [(1, 3), (2, 4), (1, 5)]) == [1, 2, 1] assert min_in_subarray([4, 8, 6, 3, 5], [(1, 5), (2, 3), (3, 3)]) == [3, 6, 6] assert min_in_subarray([2, 2, 2, 2, 2], [(1, 1), (1, 5), (2, 4)]) == [2, 2, 2] assert min_in_subarray([5, 1, 7, 3], [(1, 2), (3, 4), (1, 4)]) == [1, 3, 1]","solution":"def min_in_subarray(arr, queries): Returns the minimum value in the subarray for each query. Parameters: arr (list): List of integers. queries (list): List of tuples, each containing (L, R) indexes. Returns: list: List of minimum values for each query. results = [] for L, R in queries: results.append(min(arr[L-1:R])) return results # Input Reading and Parsing def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) Q = int(data[1]) A = list(map(int, data[2:N+2])) queries = [(int(data[i]), int(data[i+1])) for i in range(N+2, len(data), 2)] results = min_in_subarray(A, queries) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def can_rearrange_odd_even(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if the given array can be rearranged so that all odd-indexed elements are odd and all even-indexed elements are even (1-based indexing). >>> can_rearrange_odd_even(2, [(4, [1, 2, 3, 4]), (3, [1, 3, 5])]) [\\"YES\\", \\"NO\\"] >>> can_rearrange_odd_even(1, [(6, [1, 3, 5, 2, 4, 6])]) [\\"YES\\"] import pytest def test_case_1(): T = 2 test_cases = [ (4, [1, 2, 3, 4]), (3, [1, 3, 5]) ] expected = [\\"YES\\", \\"NO\\"] assert can_rearrange_odd_even(T, test_cases) == expected def test_case_2(): T = 1 test_cases = [ (5, [2, 4, 1, 3, 5]) ] expected = [\\"YES\\"] assert can_rearrange_odd_even(T, test_cases) == expected def test_case_with_all_evens(): T = 1 test_cases = [ (3, [2, 4, 6]) ] expected = [\\"NO\\"] assert can_rearrange_odd_even(T, test_cases) == expected def test_case_with_all_odds(): T = 1 test_cases = [ (3, [1, 3, 5]) ] expected = [\\"NO\\"] assert can_rearrange_odd_even(T, test_cases) == expected def test_case_large_even_and_odd_counts(): T = 1 test_cases = [ (6, [1, 3, 5, 2, 4, 6]) ] expected = [\\"YES\\"] assert can_rearrange_odd_even(T, test_cases) == expected","solution":"def can_rearrange_odd_even(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] even_count = sum(1 for x in arr if x % 2 == 0) odd_count = N - even_count if even_count >= N // 2 and odd_count >= (N + 1) // 2: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_prime(n: int) -> bool: Check if a number n is prime. A number is prime if it is greater than 1 and is only divisible by 1 and itself. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(29) True >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-5) False pass def is_palindrome(n: int) -> bool: Check if a number n is a palindrome. A number is a palindrome if it reads the same forwards and backwards. >>> is_palindrome(121) True >>> is_palindrome(12321) True >>> is_palindrome(123) False >>> is_palindrome(1) True >>> is_palindrome(22) True pass def smallest_prime_palindrome(m: int) -> int: Find the smallest prime palindrome greater than or equal to m. >>> smallest_prime_palindrome(31) 101 >>> smallest_prime_palindrome(100) 101 >>> smallest_prime_palindrome(313) 313 >>> smallest_prime_palindrome(1) 2 >>> smallest_prime_palindrome(200) 313 pass","solution":"def is_prime(n): Check if a number n is prime. A number is prime if it is greater than 1 and is only divisible by 1 and itself. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindrome(n): Check if a number n is a palindrome. A number is a palindrome if it reads the same forwards and backwards. return str(n) == str(n)[::-1] def smallest_prime_palindrome(m): Find the smallest prime palindrome greater than or equal to m. while True: if is_prime(m) and is_palindrome(m): return m m += 1"},{"question":"class FileSystem: def __init__(self): pass def add_file(self, parent_id, file_id, size): Adds a file with given file_id and size to the directory with parent_id. pass def add_dir(self, parent_id, dir_id): Adds a new directory with dir_id under the directory with parent_id. pass def delete_item(self, item_id): Deletes the file or directory with item_id and all its contents if it is a directory. pass def get_size(self, item_id): Returns the total size of the file or directory with item_id. pass def organize_file_system(operations): Processes the operations on the file system. >>> organize_file_system([ ... \\"ADD_DIR root dir1\\", ... \\"ADD_FILE dir1 file1 100\\", ... \\"ADD_FILE dir1 file2 200\\", ... \\"ADD_DIR dir1 dir2\\", ... \\"ADD_FILE dir2 file3 300\\", ... \\"GET_SIZE dir1\\", ... \\"DELETE_ITEM dir2\\", ... \\"GET_SIZE dir1\\", ... \\"END\\" ... ]) == [\\"600\\", \\"300\\"] >>> organize_file_system([ ... \\"ADD_DIR root dir1\\", ... \\"ADD_FILE dir1 file1 150\\", ... \\"GET_SIZE dir1\\", ... \\"DELETE_ITEM file1\\", ... \\"GET_SIZE dir1\\", ... \\"END\\" ... ]) == [\\"150\\", \\"0\\"] >>> organize_file_system([ ... \\"ADD_DIR root dir1\\", ... \\"ADD_DIR root dir2\\", ... \\"ADD_FILE dir1 file1 100\\", ... \\"ADD_FILE dir2 file2 200\\", ... \\"GET_SIZE dir1\\", ... \\"GET_SIZE dir2\\", ... \\"DELETE_ITEM dir1\\", ... \\"GET_SIZE dir1\\", ... \\"GET_SIZE dir2\\", ... \\"END\\" ... ]) == [\\"100\\", \\"200\\", \\"0\\", \\"200\\"] >>> organize_file_system([ ... \\"ADD_DIR root dir1\\", ... \\"ADD_FILE dir1 file1 100\\", ... \\"ADD_FILE dir1 file2 300\\", ... \\"ADD_DIR dir1 dir2\\", ... \\"ADD_FILE dir2 file3 400\\", ... \\"ADD_DIR dir2 dir3\\", ... \\"ADD_FILE dir3 file4 500\\", ... \\"GET_SIZE dir1\\", ... \\"DELETE_ITEM dir2\\", ... \\"GET_SIZE dir1\\", ... \\"END\\" ... ]) == [\\"1300\\", \\"400\\"] pass","solution":"class FileSystem: def __init__(self): self.dirs = {'root': {}} self.files = {} self.sizes = {} def add_file(self, parent_id, file_id, size): if parent_id in self.dirs: self.dirs[parent_id][file_id] = size self.files[file_id] = (parent_id, size) self.update_size(parent_id, size) def add_dir(self, parent_id, dir_id): if parent_id in self.dirs: self.dirs[parent_id][dir_id] = {} self.dirs[dir_id] = {} def delete_item(self, item_id): if item_id in self.files: parent_id, size = self.files[item_id] del self.files[item_id] self.update_size(parent_id, -size) del self.dirs[parent_id][item_id] else: size = self.calculate_size(item_id) parent_id = self.find_parent(item_id) if parent_id: self.update_size(parent_id, -size) del self.dirs[parent_id][item_id] del self.dirs[item_id] def get_size(self, item_id): return self.calculate_size(item_id) def update_size(self, parent_id, size_change): while parent_id: self.sizes[parent_id] = self.sizes.get(parent_id, 0) + size_change parent_id = self.find_parent(parent_id) def calculate_size(self, item_id): if item_id in self.files: return self.files[item_id][1] total_size = 0 if item_id in self.dirs: for k, v in self.dirs[item_id].items(): if isinstance(v, int): total_size += v else: total_size += self.calculate_size(k) return total_size def find_parent(self, item_id): for parent_id, contents in self.dirs.items(): if item_id in contents: return parent_id return None def organize_file_system(operations): fs = FileSystem() results = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"ADD_FILE\\": _, parent_id, file_id, size = parts fs.add_file(parent_id, file_id, int(size)) elif cmd == \\"ADD_DIR\\": _, parent_id, dir_id = parts fs.add_dir(parent_id, dir_id) elif cmd == \\"DELETE_ITEM\\": _, item_id = parts fs.delete_item(item_id) elif cmd == \\"GET_SIZE\\": _, item_id = parts results.append(str(fs.get_size(item_id))) return results"},{"question":"def findCombinations(nums: List[int], target: int) -> List[List[int]]: Given an integer array nums and an integer target, find all unique combinations in nums where the numbers sum to target. Each number in nums may only be used once in the combination. Args: nums (List[int]): A sorted list of integers. target (int): The target sum for combinations. Returns: List[List[int]]: A list of lists, where each list is a unique combination of integers that sum to target. Examples: >>> findCombinations([2, 3, 6, 7], 7) [[7]] >>> findCombinations([2, 3, 5], 8) [[3, 5]] pass def test_findCombinations_case1(): nums = [2, 3, 6, 7] target = 7 assert findCombinations(nums, target) == [[7]] def test_findCombinations_case2(): nums = [2, 3, 5] target = 8 assert findCombinations(nums, target) == [[3, 5]] def test_findCombinations_case3(): nums = [2, 3, 5, 6, 8] target = 8 assert findCombinations(nums, target) == [[2, 6], [3, 5], [8]] def test_findCombinations_case4(): nums = [2, 5, 2, 1, 2] target = 5 assert findCombinations(nums, target) == [[1, 2, 2], [5]] def test_findCombinations_no_combination(): nums = [1, 2, 3, 4, 5] target = 50 assert findCombinations(nums, target) == [] def test_findCombinations_duplicate_elements(): nums = [2, 2, 4, 6, 8] target = 4 assert findCombinations(nums, target) == [[2, 2], [4]]","solution":"def findCombinations(nums, target): def backtrack(start, path, target): if target == 0: result.append(list(path)) return if target < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: # Skip duplicates continue path.append(nums[i]) backtrack(i + 1, path, target - nums[i]) path.pop() result = [] nums.sort() backtrack(0, [], target) return result"},{"question":"def longest_substring_with_two_distinct(s: str) -> int: Returns the length of the longest substring that contains no more than two distinct characters. >>> longest_substring_with_two_distinct(\\"eceba\\") 3 >>> longest_substring_with_two_distinct(\\"ccaabbb\\") 5 >>> longest_substring_with_two_distinct(\\"a\\") 1 >>> longest_substring_with_two_distinct(\\"ab\\") 2 >>> longest_substring_with_two_distinct(\\"abababab\\") 8 >>> longest_substring_with_two_distinct(\\"abaccc\\") 4 >>> longest_substring_with_two_distinct(\\"aaaaaa\\") 6 >>> longest_substring_with_two_distinct(\\"abcabcabc\\") 2","solution":"def longest_substring_with_two_distinct(s): Returns the length of the longest substring that contains no more than two distinct characters. if len(s) < 3: return len(s) # Dictionary to store the count of each character in the current window char_count = {} left = 0 # Left bound of the window max_len = 2 for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 # Shrink the window from the left until there are no more than two distinct characters while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def count_trees_needing_water(n, trees): Given the number of trees and their respective current water levels and maximum water capacities, determines the number of trees that need additional water. Parameters: n (int): The number of trees. trees (list of tuples): List of tuples where each tuple contains two integers - current water level and maximum water capacity. Returns: int: The number of trees that need additional water. pass def test_no_trees_need_water(): assert count_trees_needing_water(3, [(4, 4), (5, 5), (3, 3)]) == 0 def test_all_trees_need_water(): assert count_trees_needing_water(4, [(2, 5), (1, 3), (0, 2), (3, 4)]) == 4 def test_some_trees_need_water(): assert count_trees_needing_water(5, [(2, 5), (4, 4), (1, 3), (3, 3), (0, 5)]) == 3 def test_single_tree_needs_water(): assert count_trees_needing_water(1, [(2, 5)]) == 1 def test_single_tree_does_not_need_water(): assert count_trees_needing_water(1, [(5, 5)]) == 0 def test_trees_with_varied_water_levels(): assert count_trees_needing_water(6, [(5, 10), (0, 8), (8, 8), (2, 2), (9, 10), (3, 4)]) == 4","solution":"def count_trees_needing_water(n, trees): Given the number of trees and their respective current water levels and maximum water capacities, determines the number of trees that need additional water. Parameters: n (int): The number of trees. trees (list of tuples): List of tuples where each tuple contains two integers - current water level and maximum water capacity. Returns: int: The number of trees that need additional water. count = 0 for current, max_capacity in trees: if current < max_capacity: count += 1 return count"},{"question":"from typing import List def min_drone_distance(N: int, K: int, grid: List[List[int]]) -> int: Calculate the minimum number of moves needed for a drone to travel from the top-left corner to the bottom-right corner of the grid. If it is not possible to reach the destination, return -1. Args: N (int): The size of the grid. K (int): The maximum allowable height difference. grid (List[List[int]]): An NxN matrix representing the building heights. Returns: int: The minimum distance (in terms of number of moves) that a drone needs to travel from (0, 0) to (N-1, N-1). If it is impossible to reach the destination, return -1. Example: >>> min_drone_distance(3, 2, [[10, 8, 10], [12, 9, 8], [10, 11, 10]]) 4 >>> min_drone_distance(2, 0, [[3, 4], [2, 6]]) -1 pass def test_min_drone_distance_sample1(): grid = [ [10, 8, 10], [12, 9, 8], [10, 11, 10] ] assert min_drone_distance(3, 2, grid) == 4 def test_min_drone_distance_sample2(): grid = [ [3, 4], [2, 6] ] assert min_drone_distance(2, 0, grid) == -1 def test_min_drone_distance_large_difference_allowed(): grid = [ [1, 2, 1], [2, 3, 2], [1, 2, 1] ] assert min_drone_distance(3, 10, grid) == 4 def test_min_drone_distance_obstacle(): grid = [ [1, 100], [100, 1] ] assert min_drone_distance(2, 50, grid) == -1 def test_min_drone_distance_large_grid(): N = 100 grid = [[1]*N for _ in range(N)] assert min_drone_distance(N, 0, grid) == 198","solution":"from collections import deque def min_drone_distance(N, K, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * N for _ in range(N)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == N-1 and y == N-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]: if abs(grid[x][y] - grid[nx][ny]) <= K: visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"def countInversions(n: int, arr: List[int]) -> int: Count the number of inversions in the array. >>> countInversions(5, [2, 3, 8, 6, 1]) 5 >>> countInversions(3, [1, 2, 3]) 0 pass","solution":"def countInversions(n, arr): Function to count the number of inversions in the array. Args: n : int : number of elements in the array arr : list of int : the elements of the array Returns: int : the number of inversions in the array def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1)"},{"question":"def longest_substring_with_two_distinct(s: str) -> int: Given a string of lowercase English letters, determine the length of the longest substring that contains at most two distinct characters. :param s: A string of lowercase English letters :return: The length of the longest substring with at most two distinct characters Examples: >>> longest_substring_with_two_distinct('eceba') 3 >>> longest_substring_with_two_distinct('ccaabbb') 5 >>> longest_substring_with_two_distinct('abcabcabc') 2 import pytest from solution import longest_substring_with_two_distinct def test_longest_substring_with_two_distinct_example1(): assert longest_substring_with_two_distinct('eceba') == 3 # \\"ece\\" def test_longest_substring_with_two_distinct_example2(): assert longest_substring_with_two_distinct('ccaabbb') == 5 # \\"aabbb\\" def test_longest_substring_with_two_distinct_example3(): assert longest_substring_with_two_distinct('abcabcabc') == 2 # \\"ab\\", \\"bc\\", or \\"ca\\" def test_edge_cases(): assert longest_substring_with_two_distinct('a') == 1 # single character assert longest_substring_with_two_distinct('aa') == 2 # two same characters assert longest_substring_with_two_distinct('aba') == 3 # already within two distinct def test_varied_inputs(): assert longest_substring_with_two_distinct('abaccc') == 4 # \\"accc\\" assert longest_substring_with_two_distinct('aabbcc') == 4 # \\"aabb\\", \\"bbcc\\" assert longest_substring_with_two_distinct('abcbbcaa') == 5 # \\"bbcaa\\"","solution":"def longest_substring_with_two_distinct(s): Returns the length of the longest substring containing at most two distinct characters. if len(s) < 3: return len(s) left, right = 0, 0 max_length = 2 hashmap = {} while right < len(s): if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_length = max(max_length, right - left) return max_length"},{"question":"def sequence_element(n: int) -> int: Returns the n-th element of the sequence defined by the sum of the squares of the first n natural numbers. >>> sequence_element(1) 1 >>> sequence_element(3) 14 >>> sequence_element(5) 55","solution":"def sequence_element(n): Returns the n-th element of the sequence defined by the sum of the squares of the first n natural numbers. return (n * (n + 1) * (2 * n + 1)) // 6"},{"question":"def minimal_synchronizations(N: int, initial_versions: List[int], M: int, connections: List[Tuple[int, int]]) -> int: Determine the minimal number of synchronizations required such that all servers in the system eventually end up with the same file version. Args: N (int): The number of servers. initial_versions (List[int]): The initial file version on each server. M (int): The number of connections. connections (List[Tuple[int, int]]): The pairs indicating which server can send its file version to another server. Returns: int: The minimal number of synchronizations required, or -1 if it's not possible. Example: >>> minimal_synchronizations(4, [1, 2, 3, 4], 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 3 >>> minimal_synchronizations(3, [5, 5, 5], 2, [(1, 2), (2, 3)]) 0 >>> minimal_synchronizations(4, [1, 4, 3, 4], 2, [(1, 2), (3, 4)]) -1 >>> minimal_synchronizations(1, [3], 0, []) 0 >>> minimal_synchronizations(2, [1, 3], 1, [(2, 1)]) 1","solution":"from collections import deque def minimal_synchronizations(N, initial_versions, M, connections): max_version = max(initial_versions) graph = [[] for _ in range(N)] for a, b in connections: graph[a-1].append(b-1) queue = deque([(i, 0) for i in range(N) if initial_versions[i] == max_version]) visited = [False] * N for i in range(N): if initial_versions[i] == max_version: visited[i] = True counter = 0 while queue: node, step = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: initial_versions[neighbor] = max_version visited[neighbor] = True queue.append((neighbor, step + 1)) counter = step + 1 if all(version == max_version for version in initial_versions): return counter else: return -1"},{"question":"def can_find_subsequence(S: str, A: int, B: int) -> str: Determines if binary representations of A and B can be found as a subsequence in S. :param S: A binary string consisting of '0' and '1' :param A: An integer :param B: An integer :return: \\"YES\\" if the subsequence exists, otherwise \\"NO\\" >>> can_find_subsequence(\\"101011010111\\", 5, 3) \\"YES\\" >>> can_find_subsequence(\\"101011100111\\", 8, 6) \\"NO\\" >>> can_find_subsequence(\\"000000\\", 0, 0) \\"YES\\" >>> can_find_subsequence(\\"110010101111000101010111\\", 1023, 511) \\"NO\\" >>> can_find_subsequence(\\"1101010101\\", 6, 5) \\"YES\\" >>> can_find_subsequence(\\"00000011110101\\", 2, 5) \\"YES\\" >>> can_find_subsequence(\\"1111111111\\", 4, 4) \\"NO\\"","solution":"def can_find_subsequence(S, A, B): Determines if binary representations of A and B can be found as a subsequence in S. :param S: A binary string consisting of '0' and '1' :param A: An integer :param B: An integer :return: \\"YES\\" if the subsequence exists, otherwise \\"NO\\" bin_A = bin(A)[2:] bin_B = bin(B)[2:] combined = bin_A + bin_B it = iter(S) return \\"YES\\" if all(char in it for char in combined) else \\"NO\\""},{"question":"def process_array(t: int, B: List[int]) -> Union[str, int, List[int]]: Manipulate a series of actions based on the value of an operation code. Parameters: t (int): Operation code ranging from 1 to 6. B (List[int]): An array of M integers which can contain both positive and negative integers. Returns: Union[str, int, List[int]]: Result based on the operation code \`t\`. - For \`t = 1\`: Return \\"Even\\" if all elements in \`B\` are even, otherwise return \\"Odd\\". - For \`t = 2\`: Return the maximum element in \`B\`. - For \`t = 3\`: Return the minimum element in \`B\`. - For \`t = 4\`: Return \\"Increasing\\" if the elements in \`B\` are in strictly increasing order, otherwise return \\"Not Increasing\\". - For \`t = 5\`: Return \\"Palindrome\\" if the array \`B\` reads the same forwards and backwards, otherwise return \\"Not Palindrome\\". - For \`t = 6\`: Calculate the cumulative sum of the array and return the resulting sum array. Examples: >>> process_array(1, [2, 4, 6, 8, 10]) \\"Even\\" >>> process_array(2, [-1, 4, 34, 10]) 34 >>> process_array(4, [1, 3, 5, 7, 9, 11]) \\"Increasing\\" >>> process_array(5, [1, 2, 3, 2, 1]) \\"Palindrome\\" >>> process_array(6, [1, -2, 3, 4]) [1, -1, 2, 6] pass","solution":"def process_array(t, B): if t == 1: if all(b % 2 == 0 for b in B): return \\"Even\\" else: return \\"Odd\\" elif t == 2: return max(B) elif t == 3: return min(B) elif t == 4: if all(B[i] < B[i+1] for i in range(len(B)-1)): return \\"Increasing\\" else: return \\"Not Increasing\\" elif t == 5: if B == B[::-1]: return \\"Palindrome\\" else: return \\"Not Palindrome\\" elif t == 6: cumulative_sum = [] current_sum = 0 for b in B: current_sum += b cumulative_sum.append(current_sum) return cumulative_sum"},{"question":"def distinct_paths(n, m, grid): Returns the number of distinct paths in an n x m grid from the top-left to the bottom-right, avoiding obstacles. Parameters ---------- n : int The number of rows in the grid. m : int The number of columns in the grid. grid : List[str] The grid represented as a list of strings, where '.' denotes a free cell, and '#' denotes an obstacle. Returns ------- int The number of distinct paths from the top-left to the bottom-right corner of the grid. Examples -------- >>> distinct_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> distinct_paths(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) 0 >>> distinct_paths(1, 1, [\\".\\"]) 1 >>> distinct_paths(1, 1, [\\"#\\"]) 0","solution":"def distinct_paths(n, m, grid): Returns the number of distinct paths in an n x m grid from the top-left to the bottom-right, avoiding obstacles. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def pairsWithSum(arr, target): Returns a list of unique pairs from the input array that add up to the target sum. Each pair is sorted in ascending order, and the resulting list of pairs is sorted based on the first number of each pair. :param arr: List of positive integers :param target: The target sum :return: List of pairs that add up to the target sum >>> pairsWithSum([2, 4, 3, 5, 7, 8, 9], 7) [[2, 5], [3, 4]] >>> pairsWithSum([2, 4, 3, 5, 3, 7, 8, 9, 2], 7) [[2, 5], [3, 4]] >>> pairsWithSum([1, 2, 3, 4, 5], 10) [] >>> pairsWithSum([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) [[1, 9], [2, 8], [3, 7], [4, 6]] >>> pairsWithSum([5, 5, 5, 5], 10) [[5, 5]] >>> pairsWithSum([5], 10) [] >>> pairsWithSum([], 7) []","solution":"def pairsWithSum(arr, target): Returns a list of unique pairs from the input array that add up to the target sum. Each pair is sorted in ascending order, and the resulting list of pairs is sorted based on the first number of each pair. :param arr: List of positive integers :param target: The target sum :return: List of pairs that add up to the target sum seen = set() output_pairs = set() for num in arr: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) output_pairs.add(pair) seen.add(num) result = [list(pair) for pair in sorted(output_pairs)] return result"},{"question":"from typing import List def trap(height: List[int]) -> int: Calculate the amount of water that can be trapped after raining based on the given building heights. Parameters: height (List[int]): A list of positive integers representing the heights of buildings. Returns: int: The total amount of trapped water. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([4, 2, 0, 3, 2, 5]) == 9 pass","solution":"from typing import List def trap(height: List[int]) -> int: Calculate the amount of water that can be trapped after raining based on the given building heights. Parameters: height (List[int]): A list of positive integers representing the heights of buildings. Returns: int: The total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"def maxLength(N: int) -> int: Return the maximum length L of the contiguous subarray from the array [1, 2, ... N], such that the sum of the elements in this subarray is even. >>> maxLength(5) 4 >>> maxLength(7) 6 >>> maxLength(1) 0 >>> maxLength(2) 2 >>> maxLength(4) 4 >>> maxLength(10) 10 >>> maxLength(100000) 100000 >>> maxLength(99999) 99998","solution":"def maxLength(N): Return the maximum length of the contiguous subarray from 1 to N, such that the sum of the elements in this subarray is even. if N % 2 == 0: return N else: return N - 1"},{"question":"from typing import List, Tuple def largest_even_diff_subset(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the size of the largest subset Chef can select from the given array where the difference between any two consecutive elements in the subset is even. >>> largest_even_diff_subset(3, [ ... (5, [2, 4, 6, 8, 10]), ... (6, [1, 3, 5, 7, 9, 11]), ... (4, [1, 2, 3, 4]) ... ]) == [5, 6, 2] >>> largest_even_diff_subset(2, [ ... (1, [42]), ... (5, [1, 10, 3, 7, 2]) ... ]) == [1, 3] >>> largest_even_diff_subset(1, [ ... (5, [1, 2, 2, 2, 2]) ... ]) == [4]","solution":"def largest_even_diff_subset(T, test_cases): results = [] for t in range(T): N, A = test_cases[t] evens = sum(1 for x in A if x % 2 == 0) odds = N - evens results.append(max(evens, odds)) return results"},{"question":"def max_non_adjacent_sum(nums): Returns the maximum sum of a subsequence such that no two elements are adjacent. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([-1, -2, -3, -4]) 0 >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) 8 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([-5]) 0 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([100, 200, 300, 400, 500]) 900 >>> max_non_adjacent_sum([1000, 2000, 3000, 4000, 5000]) 9000 >>> max_non_adjacent_sum([2, 1, 4, 5, 1]) 7 >>> max_non_adjacent_sum([1, 0, 3, 9, 2]) 10","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of a subsequence such that no two elements are adjacent. if not nums: return 0 n = len(nums) if n == 1: return max(0, nums[0]) prev2 = 0 prev1 = max(0, nums[0]) for i in range(1, n): current = max(prev1, prev2 + nums[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"def min_movement_cost(M, N, requests): Calculate the minimum total movement cost for all robotic arms to complete the given requests. :param M: int, number of rows in the warehouse :param N: int, number of columns in the warehouse :param requests: list of tuples, each tuple contains (sr, sc, dr, dc, items) representing a request with start row, start column, destination row, destination column, and number of items to move. :return: int, minimum total movement cost >>> min_movement_cost(5, 5, [(0, 0, 1, 1, 10), (1, 1, 2, 2, 20), (2, 2, 3, 3, 30)]) 6 >>> min_movement_cost(4, 4, [(0, 0, 3, 3, 5), (3, 3, 0, 0, 5)]) 12","solution":"def min_movement_cost(M, N, requests): Calculate the minimum total movement cost for all robotic arms to complete the given requests. :param M: int, number of rows in the warehouse :param N: int, number of columns in the warehouse :param requests: list of tuples, each tuple contains (sr, sc, dr, dc, items) representing a request with start row, start column, destination row, destination column, and number of items to move. :return: int, minimum total movement cost # Initialize total cost total_cost = 0 for sr, sc, dr, dc, items in requests: # Calculate horizontal and vertical distances horizontal_distance = abs(sc - dc) vertical_distance = abs(sr - dr) # Add the movement cost for this request to the total cost total_cost += (horizontal_distance + vertical_distance) return total_cost"},{"question":"def censorMessage(message: str, forbidden_words: List[str]) -> str: Replaces forbidden words in the message with asterisks. Args: message (str): The original message. forbidden_words (list of str): List of forbidden words to be censored. Returns: str: The censored message. >>> censorMessage(\\"The quick brown fox\\", [\\"quick\\", \\"brown\\"]) \\"The ***** ***** fox\\" >>> censorMessage(\\"Hello World!\\", [\\"World\\"]) \\"Hello *****!\\"","solution":"def censorMessage(message, forbidden_words): Replaces forbidden words in the message with asterisks. Args: message (str): The original message. forbidden_words (list of str): List of forbidden words to be censored. Returns: str: The censored message. for word in forbidden_words: replacement = '*' * len(word) message = message.replace(word, replacement) return message"},{"question":"from typing import List def sum_of_nodes_at_depth(tree: List[int], queries: List[int]) -> List[int]: Returns the sum of nodes at given depths for a given binary tree. :param tree: List[int], the binary tree in level order traversal. :param queries: List[int], depths at which we need to find the sum of nodes. :return: List[int], sums of nodes at given depths. >>> sum_of_nodes_at_depth([1, 2, 3, 4, 5, 6, 7], [1, 2, 3]) [5, 22, 0] >>> sum_of_nodes_at_depth([1, 2, None, 4], [0, 1]) [1, 2]","solution":"def sum_of_nodes_at_depth(tree, queries): Returns the sum of nodes at given depths for a given binary tree. :param tree: List[int], the binary tree in level order traversal. :param queries: List[int], depths at which we need to find the sum of nodes. :return: List[int], sums of nodes at given depths. if not tree: return [0] * len(queries) from collections import deque depth_sums = {} queue = deque([(tree[0], 0)]) # each element is a tuple (node_value, depth) i = 1 while queue: node_val, depth = queue.popleft() if node_val is not None: if depth not in depth_sums: depth_sums[depth] = 0 depth_sums[depth] += node_val # Add left child if i < len(tree): queue.append((tree[i], depth + 1)) i += 1 # Add right child if i < len(tree): queue.append((tree[i], depth + 1)) i += 1 results = [] for query in queries: results.append(depth_sums.get(query, 0)) return results"},{"question":"def longest_substring_without_repeating_characters(s: str) -> int: Finds the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_characters(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") 3 >>> longest_substring_without_repeating_characters(\\" \\") 1 >>> longest_substring_without_repeating_characters(\\"au\\") 2 >>> longest_substring_without_repeating_characters(\\"dvdfz\\") 4","solution":"def longest_substring_without_repeating_characters(s): Finds the length of the longest substring without repeating characters. char_index_map = {} longest_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest_length = max(longest_length, i - start + 1) return longest_length"},{"question":"def secondLargest(arr, N): Returns the second largest element in the array arr of size N. If such an element does not exist, returns None. pass # Test cases def test_normal_case(): arr = [12, 35, 1, 10, 34, 1] N = 6 assert secondLargest(arr, N) == 34 def test_with_duplicates(): arr = [10, 10, 9, 8, 8, 7] N = 6 assert secondLargest(arr, N) == 9 def test_all_elements_same(): arr = [5, 5, 5, 5] N = 4 assert secondLargest(arr, N) == None def test_two_elements(): arr = [1, 2] N = 2 assert secondLargest(arr, N) == 1 def test_single_element(): arr = [1] N = 1 assert secondLargest(arr, N) == None def test_large_numbers(): arr = [10**9, 10**8, 10**7, 10**6] N = 4 assert secondLargest(arr, N) == 10**8 def test_negative_numbers(): arr = [-1, -2, -3, -4] N = 4 assert secondLargest(arr, N) == -2","solution":"def secondLargest(arr, N): Returns the second largest element in the array arr of size N. If such an element does not exist, returns None. if N < 2: return None first, second = float('-inf'), float('-inf') for num in arr: if num > first: first, second = num, first elif first > num > second: second = num return second if second != float('-inf') else None"},{"question":"def findPairWithDifference(arr: List[int], K: int) -> bool: Given an array of integers and a target integer 'K', find whether there are two distinct indices i and j in the array such that the absolute difference between the elements at those indices is exactly K. >>> findPairWithDifference([1, 5, 3, 4, 2], 2) True >>> findPairWithDifference([8, 12, 16, 4, 0, 20], 4) True >>> findPairWithDifference([1, 2, 3, 4, 5], 10) False from typing import List def test_example1(): arr = [1, 5, 3, 4, 2] K = 2 assert findPairWithDifference(arr, K) == True def test_example2(): arr = [8, 12, 16, 4, 0, 20] K = 4 assert findPairWithDifference(arr, K) == True def test_example3(): arr = [1, 2, 3, 4, 5] K = 10 assert findPairWithDifference(arr, K) == False def test_no_difference(): arr = [1, 2, 3, 4, 5] K = 0 assert findPairWithDifference(arr, K) == False def test_large_difference(): arr = [100000, -100000] K = 200000 assert findPairWithDifference(arr, K) == True def test_no_elements(): arr = [] K = 5 assert findPairWithDifference(arr, K) == False def test_single_element(): arr = [1] K = 1 assert findPairWithDifference(arr, K) == False def test_duplicate_elements(): arr = [1, 2, 2, 3, 4] K = 0 assert findPairWithDifference(arr, K) == True def test_negative_K(): arr = [1, 5, 3, 4, 2] K = -2 assert findPairWithDifference(arr, K) == True","solution":"def findPairWithDifference(arr, K): This function returns True if there are two distinct indices i and j in the array such that the absolute difference between arr[i] and arr[j] is exactly K, otherwise returns False. seen = set() for num in arr: if (num + K) in seen or (num - K) in seen: return True seen.add(num) return False"},{"question":"def has_alternating_bits(N: int) -> str: Determines if the binary representation of N has alternating 0s and 1s starting with a 1. :param N: Integer :return: \\"Yes\\" if the binary representation has alternating bits, \\"No\\" otherwise >>> has_alternating_bits(5) \\"Yes\\" >>> has_alternating_bits(7) \\"No\\" >>> has_alternating_bits(1) \\"Yes\\" >>> has_alternating_bits(10) \\"Yes\\" >>> has_alternating_bits(11) \\"No\\" >>> has_alternating_bits(42) \\"Yes\\"","solution":"def has_alternating_bits(N): Determines if the binary representation of N has alternating 0s and 1s starting with a 1. :param N: Integer :return: \\"Yes\\" if the binary representation has alternating bits, \\"No\\" otherwise # Get the binary representation of N without the '0b' prefix binary_str = bin(N)[2:] # Check for alternating bits for i in range(len(binary_str) - 1): if binary_str[i] == binary_str[i + 1]: return \\"No\\" return \\"Yes\\""},{"question":"def sumOfDistinctElements(N: int, M: int, matrix: List[List[int]]) -> int: Returns the sum of all distinct elements present in the matrix. >>> sumOfDistinctElements(3, 3, [ [1, 2, 3], [4, 1, 5], [6, 7, 3]]) 28 >>> sumOfDistinctElements(2, 2, [ [1, 2], [2, 1]]) 3","solution":"def sumOfDistinctElements(N, M, matrix): Returns the sum of all distinct elements present in the matrix. distinct_elements = set() for row in matrix: for element in row: distinct_elements.add(element) return sum(distinct_elements)"},{"question":"import math from typing import Tuple def is_right_triangle(p1: Tuple[int, int], p2: Tuple[int, int], p3: Tuple[int, int]) -> bool: Determine whether three points form a right triangle. >>> is_right_triangle((0, 0), (3, 4), (3, 0)) True >>> is_right_triangle((1, 2), (3, 8), (5, 2)) False >>> is_right_triangle((1, 1), (1, 4), (5, 1)) True >>> is_right_triangle((0, 0), (1, 1), (2, 1)) False >>> is_right_triangle((0, 0), (-3, -4), (-3, 0)) True # Define test cases to check the function def test_right_triangle(): assert is_right_triangle((0, 0), (3, 4), (3, 0)) == True def test_not_right_triangle(): assert is_right_triangle((1, 2), (3, 8), (5, 2)) == False def test_another_right_triangle(): assert is_right_triangle((1, 1), (1, 4), (5, 1)) == True def test_another_not_right_triangle(): assert is_right_triangle((0, 0), (1, 1), (2, 1)) == False def test_right_triangle_with_negative_coordinates(): assert is_right_triangle((0, 0), (-3, -4), (-3, 0)) == True","solution":"import math def is_right_triangle(p1, p2, p3): def dist_squared(a, b): return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 sides = [ dist_squared(p1, p2), dist_squared(p2, p3), dist_squared(p1, p3) ] sides.sort() return sides[0] + sides[1] == sides[2]"},{"question":"from typing import List def find_min_cost(n: int, costs: List[List[int]], route: List[int]) -> int: Write a function called \`find_min_cost\` that takes three parameters: an integer \`n\` representing the number of cities, a 2D list \`costs\` where \`costs[i][j]\` is the cost of flying from city \`i\` to city \`j\`, and a list of integers \`route\` which is a sequence of cities to visit in order. The function should return the minimum total cost to travel according to the provided route. If it's not possible to travel directly between two consecutive cities in the route, return -1. >>> find_min_cost(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]], [0, 1, 3, 2]) 65 >>> find_min_cost(3, [[0, 10, -1], [10, 0, 5], [-1, 5, 0]], [0, 2]) -1 >>> find_min_cost(5, [[0, 12, 8, -1, 15], [12, 0, -1, 14, 7], [8, -1, 0, 10, 20], [-1, 14, 10, 0, 18], [15, 7, 20, 18, 0]], [2, 4, 1]) 27","solution":"def find_min_cost(n, costs, route): total_cost = 0 for i in range(len(route) - 1): from_city = route[i] to_city = route[i+1] cost = costs[from_city][to_city] if cost == -1: return -1 total_cost += cost return total_cost"},{"question":"def count_passing_students(test_cases): Count the number of students passing each homework assignment based on the provided threshold. :param test_cases: List of test case data, each is a tuple where the first item is the number of homeworks, followed by a list of tuples. Each tuple consists of number of students, threshold, and a list of student scores. :return: List of lists containing the number of students passing each homework assignment. Example: >>> count_passing_students([(2, [(3, 50, [40, 55, 60]), (4, 75, [80, 70, 90, 85])])]) [[2, 3]] >>> count_passing_students([(3, [(5, 60, [45, 60, 70, 55, 65]), (2, 55, [50, 60]), (3, 40, [35, 45, 25])])]) [[3, 1, 1]] import unittest class TestCountPassingStudents(unittest.TestCase): def test_count_passing_students(self): test_cases = [ (2, [ (3, 50, [40, 55, 60]), (4, 75, [80, 70, 90, 85]) ]), (3, [ (5, 60, [45, 60, 70, 55, 65]), (2, 55, [50, 60]), (3, 40, [35, 45, 25]) ]) ] expected_output = [ [2, 3], [3, 1, 1] ] self.assertEqual(count_passing_students(test_cases), expected_output) def test_count_passing_students_edge_cases(self): test_cases = [ (1, [(1, 100, [100])]), (1, [(1, 0, [0])]), (1, [(5, 50, [50, 40, 55, 45, 60])]) ] expected_output = [ [1], [1], [3] ] self.assertEqual(count_passing_students(test_cases), expected_output) def test_count_passing_students_no_one_pass(self): test_cases = [(1, [(4, 60, [40, 50, 30, 59])])] expected_output = [[0]] self.assertEqual(count_passing_students(test_cases), expected_output) def test_count_passing_students_all_pass(self): test_cases = [(1, [(4, 30, [40, 50, 45, 60])])] expected_output = [[4]] self.assertEqual(count_passing_students(test_cases), expected_output) if __name__ == \\"__main__\\": unittest.main()","solution":"def count_passing_students(test_cases): Count the number of students passing each homework assignment based on the provided threshold. :param test_cases: List of test case data, each is a tuple where the first item is the number of homeworks, followed by a list of tuples. Each tuple consists of number of students, threshold, and a list of student scores. :return: List of lists containing the number of students passing each homework assignment. result = [] for n, assignments in test_cases: case_result = [] for k, t, scores in assignments: count_pass = sum(1 for score in scores if score >= t) case_result.append(count_pass) result.append(case_result) return result"},{"question":"from typing import List, Tuple def can_create_schedule(n: int, m: int, water_requirements: List[int], conflicts: List[Tuple[int, int]]) -> str: Determine if it's possible to create an optimized watering schedule for the given plants that minimizes total water usage while fulfilling each plant's water requirements and ensuring conflicting plants are not watered on the same day. Parameters: n (int): Number of plants m (int): Number of conflicting pairs water_requirements (List[int]): List of water requirements for each plant conflicts (List[Tuple[int, int]]): List of conflicting pairs of plants Returns: str: \\"YES {minimum_water_usage}\\" if an optimized schedule is possible, otherwise \\"NO\\". >>> can_create_schedule(5, 4, [3, 5, 4, 7, 2], [(1, 2), (2, 3), (4, 5), (3, 4)]) 'YES 21' >>> can_create_schedule(3, 3, [6, 3, 4], [(1, 2), (2, 3), (1, 3)]) 'NO'","solution":"def can_create_schedule(n, m, water_requirements, conflicts): from collections import defaultdict, deque # Create the adjacency list for the conflict graph adjacency_list = defaultdict(list) for i, j in conflicts: adjacency_list[i].append(j) adjacency_list[j].append(i) # To store color of each vertex colors = [-1] * (n + 1) # Function to check if the graph is bipartite def bfs_check_bipartite(start): queue = deque([start]) colors[start] = 0 while queue: u = queue.popleft() for v in adjacency_list[u]: if colors[v] == -1: colors[v] = 1 - colors[u] queue.append(v) elif colors[v] == colors[u]: return False return True for plant in range(1, n + 1): if colors[plant] == -1: if not bfs_check_bipartite(plant): return \\"NO\\" total_water_usage = 0 for color_set in [0, 1]: total_water_usage += sum(water_requirements[i - 1] for i in range(1, n + 1) if colors[i] == color_set) return f\\"YES {total_water_usage}\\""},{"question":"def validate_plant_entries(entries: List[str]) -> List[str]: Validate the plant entries to ensure they meet Zara's criteria. >>> validate_plant_entries([\\"rose: red beautiful fragrant thorny perennial\\", \\"cactus: green thorny vibrant tough resilient\\"]) [\\"valid\\", \\"valid\\"] >>> validate_plant_entries([\\"lily: white elegant fragrant white seasonal\\"]) [\\"invalid\\"]","solution":"def validate_plant_entries(entries): results = [] for entry in entries: name, characteristics_str = entry.split(\\": \\") characteristics = characteristics_str.split() # Check if there are exactly 5 unique characteristics and all characteristics are within allowable length if len(characteristics) == 5 and len(set(characteristics)) == 5 and all(len(c) <= 10 for c in characteristics): results.append(\\"valid\\") else: results.append(\\"invalid\\") return results"},{"question":"def twoSum(nums: List[int], target: int) -> List[int]: Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to the target value. >>> twoSum([2, 7, 11, 15], 9) [0, 1] >>> twoSum([3, 2, 4], 6) [1, 2] >>> twoSum([1, 2, 3, 4, 5], 8) [2, 4] >>> twoSum([1, 2, 3], 7) [] >>> twoSum([1, 3, 3, 4], 6) [1, 2]","solution":"def twoSum(nums, target): Returns the indices of the two numbers in nums such that they add up to target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def findDuplicate(arr): Given an array of N integers, where each integer is in the range [1, N], all elements appear once except one which appears twice. Find the element that appears twice without using extra space. >>> findDuplicate([4, 3, 6, 5, 2, 4, 1]) 4 >>> findDuplicate([1, 3, 2, 3]) 3 from solution import findDuplicate def test_example_1(): assert findDuplicate([4, 3, 6, 5, 2, 4, 1]) == 4 def test_example_2(): assert findDuplicate([1, 3, 2, 3]) == 3 def test_single_duplicate_at_end(): assert findDuplicate([1, 2, 3, 4, 5, 5]) == 5 def test_single_duplicate_at_start(): assert findDuplicate([2, 2, 3, 4, 5, 6]) == 2 def test_all_elements_are_same_except_one(): assert findDuplicate([1, 1, 1, 1, 1, 2]) == 1 def test_large_array(): assert findDuplicate(list(range(1, 100001)) + [50000]) == 50000 def test_no_duplicate_in_invalid_input(): # This technically breaks the function contract since there's no duplicate # But let's see if function can handle it gracefully assert findDuplicate([1, 2, 3, 4, 5, 6]) == -1","solution":"def findDuplicate(arr): Given an array of N integers where each integer is in the range [1, N], all elements appear once except one which appears twice. This function finds the element that appears twice without using extra space. for i in range(len(arr)): index = abs(arr[i]) - 1 if arr[index] < 0: return abs(arr[i]) arr[index] = -arr[index] return -1 # This should never be reached if the input guarantees a duplicate"},{"question":"def max_pair_sum(lst) -> int: Returns the sum of the two largest numbers in the list. Parameters: lst (list): A list of integers. Returns: int: The sum of the two largest numbers in the list. Examples: >>> max_pair_sum([10, 14, 2, 23, 19]) 42 >>> max_pair_sum([99, 2, 2, 23, 19]) 122 >>> max_pair_sum([1, 2, 3]) 5","solution":"def max_pair_sum(lst): Returns the sum of the two largest numbers in the list. Parameters: lst (list): A list of integers. Returns: int: The sum of the two largest numbers in the list. if len(lst) < 2: raise ValueError(\\"The list must contain at least two elements.\\") first_max = max(lst) lst.remove(first_max) second_max = max(lst) return first_max + second_max"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. If there are multiple substrings, return the first one found. >>> longest_palindromic_substring(\\"babad\\") 'bab' or 'aba' >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"racecar\\") 'racecar' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"ac\\") 'a' or 'c' >>> longest_palindromic_substring(\\"abba\\") 'abba' >>> longest_palindromic_substring(\\"\\") '' def process_cases(input_cases: List[str]) -> List[str]: Processes multiple test cases to find the longest palindromic substring for each input string. Stops processing when encountering the string \\"END\\". Returns a list of results. >>> input_cases = [\\"babad\\", \\"cbbd\\", \\"racecar\\", \\"END\\"] >>> process_cases(input_cases) ['bab', 'bb', 'racecar'] >>> input_cases = [\\"a\\", \\"ac\\", \\"abbcccbbb\\", \\"END\\"] >>> process_cases(input_cases) ['a', 'a', 'bbcccbb']","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. If there are multiple substrings, return the first one found. def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not s: return \\"\\" longest = \\"\\" for i in range(len(s)): # Odd length palindromes temp = expand_around_center(s, i, i) if len(temp) > len(longest): longest = temp # Even length palindromes temp = expand_around_center(s, i, i + 1) if len(temp) > len(longest): longest = temp return longest def process_cases(input_cases): results = [] for s in input_cases: if s == \\"END\\": break results.append(longest_palindromic_substring(s)) return results"},{"question":"def max_unique_denominations(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Calculate the maximum number of unique denominations that Johnny can pick given the constraints. >>> max_unique_denominations(2, [((7, 3), [5, 3, 8, 3, 3, 7, 8]), ((5, 2), [1, 2, 2, 5, 5])]) [3, 2] >>> max_unique_denominations(1, [((4, 3), [1, 1, 1, 1])]) [1]","solution":"def max_unique_denominations(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] denominations = test_cases[i][1] # Find the unique denominations unique_denominations = len(set(denominations)) # The maximum unique denominations he can get is the minimum # of the unique denominations available and K (maximum coins he can pick) results.append(min(unique_denominations, K)) return results"},{"question":"def max_magic_level(n: int, magic_levels: List[int]) -> int: Given the number of trees and their magic levels, calculate the maximum possible magic level among the newly added trees. >>> max_magic_level(5, [2, 3, 9, 4, 8]) == 6 >>> max_magic_level(4, [5, 5, 5, 5]) == 5 >>> max_magic_level(3, [1, 2, 3]) == 2 >>> max_magic_level(3, [3, 2, 1]) == 2 >>> max_magic_level(2, [1000000000, 1000000000]) == 1000000000 >>> max_magic_level(2, [1, 1]) == 1 >>> max_magic_level(4, [1, 1000000000, 1, 1000000000]) == 500000000","solution":"def max_magic_level(n, magic_levels): Given the number of trees and their magic levels, calculate the maximum possible magic level among the newly added trees. max_level = 0 # Initialize the maximum magic level for i in range(n - 1): current_mean = (magic_levels[i] + magic_levels[i + 1]) // 2 if current_mean > max_level: max_level = current_mean return max_level"},{"question":"def num_paths(N, M, grid): Calculate the number of distinct paths from the top-left corner to the bottom-right corner of the given grid. >>> num_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_paths(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) 0","solution":"def num_paths(N, M, grid): MOD = 1000000007 if grid[0][0] == '#' or grid[N-1][M-1] == '#': return 0 dp = [[0 for _ in range(M)] for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[N-1][M-1]"},{"question":"def filter_comments(comments, negative_words): Filters out comments that contain any negative words. Parameters: comments (list): A list of comments (strings). negative_words (list): A list of negative words (strings). Returns: list: A list of comments without any negative words. >>> comments = [\\"I hate this product, it's terrible\\", \\"This is the best service ever\\", \\"Worst experience I've had\\", \\"I love how friendly the staff is\\", \\"This place is not good\\"] >>> negative_words = [\\"hate\\", \\"terrible\\", \\"worst\\", \\"not good\\"] >>> filter_comments(comments, negative_words) [\\"This is the best service ever\\", \\"I love how friendly the staff is\\"] >>> comments = [\\"The food is amazing\\", \\"I dislike the ambiance\\", \\"Service was excellent\\"] >>> negative_words = [\\"dislike\\", \\"poor\\", \\"bad\\"] >>> filter_comments(comments, negative_words) [\\"The food is amazing\\", \\"Service was excellent\\"]","solution":"def filter_comments(comments, negative_words): Filters out comments that contain any negative words. Parameters: comments (list): A list of comments (strings). negative_words (list): A list of negative words (strings). Returns: list: A list of comments without any negative words. filtered_comments = [] for comment in comments: # Convert comment to lowercase for case insensitive matching comment_lower = comment.lower() # Check if any negative word is a substring in the comment if not any(negative_word in comment_lower for negative_word in negative_words): filtered_comments.append(comment) return filtered_comments"},{"question":"def count_distinct_pairs(n: int, arr: List[int]) -> int: Returns the count of distinct pairs (i, j) where i < j and the product of the array elements at these positions is even. >>> count_distinct_pairs(5, [1, 2, 3, 4, 5]) 7 >>> count_distinct_pairs(4, [2, 4, 6, 8]) 6 >>> count_distinct_pairs(3, [1, 3, 5]) 0","solution":"def count_distinct_pairs(n, arr): Returns the count of distinct pairs (i, j) such that i < j and the product of arr[i] and arr[j] is even. even_count = sum(1 for x in arr if x % 2 == 0) odd_count = n - even_count # Total pairs formed from n elements is nC2 = n*(n-1)/2 total_pairs = n * (n - 1) // 2 # Pairs where both elements are odd odd_pairs = odd_count * (odd_count - 1) // 2 # Valid pairs are total pairs minus pairs where both elements are odd valid_pairs = total_pairs - odd_pairs return valid_pairs"},{"question":"def min_spells_to_type_one(n, stones): Determine the minimum number of spells required to turn all stones into stones of type 1. If it's not possible, return -1. >>> min_spells_to_type_one(2, [1, 1]) == 0 >>> min_spells_to_type_one(3, [2, 4, 8]) == -1 >>> min_spells_to_type_one(4, [3, 6, 9, 12]) == -1 >>> min_spells_to_type_one(5, [2, 3, 6, 9, 12]) == 5 >>> min_spells_to_type_one(4, [2, 2, 1, 1]) == 2","solution":"def min_spells_to_type_one(n, stones): Determine the minimum number of spells required to turn all stones into stones of type 1. If it's not possible, return -1. from math import gcd from functools import reduce # Function to compute gcd of an array def array_gcd(arr): return reduce(gcd, arr) # Compute gcd of all stone types current_gcd = array_gcd(stones) # If the gcd of all stone types is 1, it's possible # Otherwise, it's not possible if current_gcd != 1: return -1 # Count the number of stones already type 1 count_type_one = stones.count(1) # If there are type 1 stones, we don't need additional spells for them # Otherwise, each stone needs at least one spell to become type 1 if count_type_one > 0: return n - count_type_one else: return n"},{"question":"def min_land_cells(m, n, k): Determine the minimum number of land cells ('1') needed to create at least k distinct islands. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. k (int): Number of islands to create. Returns: int: Minimum number of land cells needed, or -1 if it's impossible. Example: >>> min_land_cells(3, 3, 2) 2 >>> min_land_cells(1, 5, 3) 3 >>> min_land_cells(2, 2, 5) -1","solution":"def min_land_cells(m, n, k): Determine the minimum number of land cells ('1') needed to create at least k distinct islands. # If the total cells in the grid is less than k, return -1 (impossible case) if k > m * n: return -1 # Place each island in a separate cell, ensuring that the islands are not adjacent. # To achieve this, we need at least k cells to be converted to land. # Thus, the minimum land cells needed to create k islands is exactly k. return k"},{"question":"from datetime import datetime from typing import List, Tuple def parse_time(time_str: str) -> datetime: Convert a time string in 'hh:mm' format to a datetime object. Args: time_str (str): Time string in 'hh:mm' format. Returns: datetime: Corresponding datetime object. return datetime.strptime(time_str, '%H:%M') def max_non_overlapping_tasks(tasks: List[Tuple[datetime, datetime]]) -> int: Determines the maximum number of non-overlapping tasks that can be scheduled. Args: tasks (List[Tuple[datetime, datetime]]): List of tuples where each tuple consists of start and end time of a task. Returns: int: Maximum number of non-overlapping tasks. Example: >>> tasks = [(parse_time('09:00'), parse_time('11:00')), (parse_time('13:00'), parse_time('14:00')), (parse_time('10:00'), parse_time('12:00'))] >>> max_non_overlapping_tasks(tasks) 2 >>> tasks = [(parse_time('08:00'), parse_time('09:00')), (parse_time('10:30'), parse_time('11:30')), (parse_time('11:00'), parse_time('12:00')), (parse_time('12:30'), parse_time('14:00')), (parse_time('14:00'), parse_time('15:30'))] >>> max_non_overlapping_tasks(tasks) 4 tasks.sort(key=lambda x: x[1]) # Sort by end time count = 0 last_end_time = datetime.min for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count def process_input(input_data: str) -> List[int]: Process input data and computes the maximum number of non-overlapping tasks for each dataset. Args: input_data (str): Input string representing multiple datasets. Returns: List[int]: List of results for each dataset. Example: >>> input_data = \\"3n09:00 11:00n13:00 14:00n10:00 12:00n5n08:00 09:00n10:30 11:30n11:00 12:00n12:30 14:00n14:00 15:30n0\\" >>> process_input(input_data) [2, 4] lines = input_data.strip().split('n') index = 0 results = [] while index < len(lines): n = int(lines[index]) if n == 0: break index += 1 tasks = [] for i in range(n): start_str, end_str = lines[index + i].split() start = parse_time(start_str) end = parse_time(end_str) tasks.append((start, end)) results.append(max_non_overlapping_tasks(tasks)) index += n return results def main(input_data: str): Main function to process the input data and print the results. Args: input_data (str): Input string representing multiple datasets. Example: >>> input_data = \\"3n09:00 11:00n13:00 14:00n10:00 12:00n5n08:00 09:00n10:30 11:30n11:00 12:00n12:30 14:00n14:00 15:30n0\\" >>> main(input_data) 2 4 results = process_input(input_data) for result in results: print(result)","solution":"from datetime import datetime def parse_time(time_str): return datetime.strptime(time_str, '%H:%M') def max_non_overlapping_tasks(tasks): tasks.sort(key=lambda x: x[1]) # Sort by end time count = 0 last_end_time = datetime.min for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count def process_input(input_data): lines = input_data.strip().split('n') index = 0 results = [] while index < len(lines): n = int(lines[index]) if n == 0: break index += 1 tasks = [] for i in range(n): start_str, end_str = lines[index + i].split() start = parse_time(start_str) end = parse_time(end_str) tasks.append((start, end)) results.append(max_non_overlapping_tasks(tasks)) index += n return results def main(input_data): results = process_input(input_data) for result in results: print(result)"},{"question":"def longest_alphabetical_sequence(s: str) -> str: Identify the longest sequence of consecutive alphabetical characters in a given string. In case of multiple sequences of the same length, return the one which appears first in the string. >>> longest_alphabetical_sequence(\\"a2b3c2abc567defg!\\") == \\"defg\\" >>> longest_alphabetical_sequence(\\"abc12xy34z\\") == \\"abc\\" pass # Example usage print(longest_alphabetical_sequence(\\"a2b3c2abc567defg!\\")) # should return \\"defg\\" print(longest_alphabetical_sequence(\\"abc12xy34z\\")) # should return \\"abc\\" # Unit tests def test_longest_alphabetical_sequence_basic_cases(): assert longest_alphabetical_sequence(\\"a2b3c2abc567defg!\\") == \\"defg\\" assert longest_alphabetical_sequence(\\"abc12xy34z\\") == \\"abc\\" def test_longest_alphabetical_sequence_single_alpha(): assert longest_alphabetical_sequence(\\"1a2b3!\\") == \\"a\\" assert longest_alphabetical_sequence(\\"1!2\\") == \\"\\" def test_longest_alphabetical_sequence_all_alphas(): assert longest_alphabetical_sequence(\\"abcdef\\") == \\"abcdef\\" assert longest_alphabetical_sequence(\\"xyz\\") == \\"xyz\\" def test_longest_alphabetical_sequence_multiple_longest(): assert longest_alphabetical_sequence(\\"ab123cd456ef\\") == \\"ab\\" assert longest_alphabetical_sequence(\\"x12y34z\\") == \\"x\\" def test_longest_alphabetical_sequence_empty_string(): assert longest_alphabetical_sequence(\\"\\") == \\"\\"","solution":"def longest_alphabetical_sequence(s: str) -> str: Returns the longest sequence of consecutive alphabetical characters from the input string. max_seq = \\"\\" current_seq = \\"\\" for char in s: if char.isalpha(): current_seq += char if len(current_seq) > len(max_seq): max_seq = current_seq else: current_seq = \\"\\" return max_seq # Example usage print(longest_alphabetical_sequence(\\"a2b3c2abc567defg!\\")) # should return \\"defg\\" print(longest_alphabetical_sequence(\\"abc12xy34z\\")) # should return \\"abc\\""},{"question":"def diagonal_sum(n: int, grid: List[List[int]]) -> int: Calculate the sum of elements in the primary and secondary diagonals of an n x n grid. If an element belongs to both diagonals, it should only be included once in the sum. Args: n (int): The size of the grid. grid (List[List[int]]): The n x n grid of integers. Returns: int: The sum of the elements in both diagonals of the grid. Examples: >>> diagonal_sum(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 25 >>> diagonal_sum(2, [ ... [1, 2], ... [3, 4] ... ]) 10","solution":"def diagonal_sum(n, grid): primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += grid[i][i] secondary_diagonal_sum += grid[i][n-1-i] # If the grid size is odd, subtract the middle element once because it is counted twice if n % 2 == 1: middle_element = grid[n//2][n//2] return primary_diagonal_sum + secondary_diagonal_sum - middle_element else: return primary_diagonal_sum + secondary_diagonal_sum"},{"question":"def count_subarrays_with_odd(T: int, tests: List[Tuple[int, List[int]]]) -> List[int]: Count the number of subarrays that contain at least one odd number for each test case. Parameters: - T (int): the number of test cases - tests (List[Tuple[int, List[int]]]): a list of tuples, where each tuple contains the length of the array (N) and the array (A) itself. Returns: - List[int]: a list of integers where each integer represents the number of subarrays with at least one odd number for the corresponding test case. Example: >>> count_subarrays_with_odd(2, [(4, [1, 2, 3, 4]), (3, [2, 4, 6])]) [10, 0] >>> count_subarrays_with_odd(1, [(3, [1, 3, 5])]) [6]","solution":"def count_subarrays_with_odd(T, tests): Returns a list of counts of subarrays with at least one odd integer for each test case. results = [] for i in range(T): N = tests[i][0] A = tests[i][1] total_subarrays = N * (N + 1) // 2 even_count = 0 prev_count = 0 subarrays_without_odd = 0 for j in range(N): if A[j] % 2 == 0: even_count += prev_count + 1 prev_count += 1 else: prev_count = 0 subarrays_without_odd = even_count subarrays_with_odd = total_subarrays - subarrays_without_odd results.append(subarrays_with_odd) return results"},{"question":"def findLastStanding(N: int, K: int) -> int: Returns the position (1-indexed) of the last person standing in the elimination game. Parameters: N (int): Total number of people in the circle (1 <= N <= 1000). K (int): The elimination count (1 <= K <= 1000). Returns: int: Position of the last person standing. Examples: >>> findLastStanding(7, 3) 4 >>> findLastStanding(10, 2) 5","solution":"def findLastStanding(N, K): Returns the position (1-indexed) of the last person standing in the elimination game. Parameters: N (int): Total number of people in the circle. K (int): The elimination count. Returns: int: Position of the last person standing. people = list(range(1, N+1)) index = 0 while len(people) > 1: index = (index + K - 1) % len(people) people.pop(index) return people[0]"},{"question":"def unique_student_id(B: int, P: int) -> int: Returns the unique student ID generated from base ID B and position P using XOR operation. >>> unique_student_id(57, 23) 46 >>> unique_student_id(57, 57) 0 >>> unique_student_id(100, 0) 100 >>> unique_student_id(10**9, 10**9) 0 >>> unique_student_id(987654321, 123456789) 987654321 ^ 123456789","solution":"def unique_student_id(B, P): Returns the unique student ID generated from base ID B and position P using XOR operation. return B ^ P"},{"question":"def min_operations_to_make_same(n, arr): Determines the minimum number of operations needed to make all elements the same using the described flip operation on subarrays of consecutive elements. Parameters: n (int): Number of elements in the array. arr (list of int): The array of 0s and 1s. Returns: int: The minimum number of operations. Examples: >>> min_operations_to_make_same(5, [0, 1, 0, 1, 0]) 2 >>> min_operations_to_make_same(6, [1, 1, 0, 0, 1, 1]) 1","solution":"def min_operations_to_make_same(n, arr): Determines the minimum number of operations needed to make all elements the same using the described flip operation on subarrays of consecutive elements. Parameters: n (int): Number of elements in the array. arr (list of int): The array of 0s and 1s. Returns: int: The minimum number of operations. if n == 0: return 0 # Count transitions between 0 and 1 count_transitions = 0 for i in range(1, n): if arr[i] != arr[i - 1]: count_transitions += 1 # The minimum operations needed is half the number of transitions (rounded up) return (count_transitions + 1) // 2"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"billion\\") False","solution":"def are_anagrams(s1, s2): Determine if two strings are anagrams of each other. Parameters: s1 (str): First input string. s2 (str): Second input string. Returns: bool: True if the strings are anagrams, False otherwise. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"def max_sum_subgrid(grid: List[List[int]]) -> int: Given a grid of positive integers, return the largest sum of any subgrid. >>> max_sum_subgrid([[1, 2, 3], [4, 5, 6]]) 21 >>> max_sum_subgrid([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 9 >>> max_sum_subgrid([[1, 2], [3, 4]]) 10 >>> max_sum_subgrid([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) 18 >>> max_sum_subgrid([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45","solution":"def max_sum_subgrid(grid): Given a grid of positive integers, return the largest sum of any subgrid. m = len(grid) n = len(grid[0]) max_sum = -float('inf') for top_row in range(m): row_sum = [0] * n for bottom_row in range(top_row, m): for col in range(n): row_sum[col] += grid[bottom_row][col] max_sum = max(max_sum, kadane(row_sum)) return max_sum def kadane(arr): Helper function to find the maximum sum subarray using Kadane's algorithm. max_current = max_global = arr[0] for x in arr[1:]: max_current = max(x, max_current + x) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def count_ways(n: int) -> int: Returns the number of distinct ways to reach the top of a ladder with n steps, given you can take either 1 step or 2 steps at a time. >>> count_ways(2) # 2 ways: (1+1), (2) 2 >>> count_ways(3) # 3 ways: (1+1+1), (1+2), (2+1) 3 >>> count_ways(5) # 8 ways: (1+1+1+1+1), (1+1+1+2), (1+1+2+1), (1+2+1+1), (2+1+1+1), (2+2+1), (2+1+2), (1+2+2) 8 pass def process_test_cases(t: int, cases: List[int]) -> List[int]: Processes a list of test cases and returns the results for each case. >>> process_test_cases(3, [2, 3, 5]) [2, 3, 8] >>> process_test_cases(4, [0, 1, 4, 6]) [1, 1, 5, 13] pass","solution":"def count_ways(n): Returns the number of distinct ways to reach the top of a ladder with n steps, given you can take either 1 step or 2 steps at a time. if n == 0: return 1 if n == 1: return 1 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] def process_test_cases(t, cases): results = [] for n in cases: results.append(count_ways(n)) return results"},{"question":"def min_latency_connections(T: int, routers: List[int]) -> List[int]: Determines the minimum number of latency connections required for a balanced network of routers. Parameters: T (int): Number of test cases. routers (list of int): List containing the number of routers for each test case. Returns: list of int: List containing the minimum number of latency connections for each test case. >>> min_latency_connections(3, [2, 4, 6]) [1, 3, 5] >>> min_latency_connections(1, [10]) [9]","solution":"def min_latency_connections(T, routers): Determines the minimum number of latency connections required for a balanced network of routers. Parameters: T (int): Number of test cases. routers (list of int): List containing the number of routers for each test case. Returns: list of int: List containing the minimum number of latency connections for each test case. result = [] for N in routers: # For N routers, to form a connected structure with the optimal latency, # we need N-1 connections. result.append(N - 1) return result"},{"question":"def max_score(arr: List[int]) -> int: Returns the maximum possible score for the given array by optimally partitioning the array into subarrays according to the rules described above. >>> max_score([1, 2, 3, 4]) 10 >>> max_score([5, 6, 1]) 12 >>> max_score([0, 0, 0, 0]) 0 >>> max_score([10, 20, 30]) 60 >>> max_score([1000] * 100) 100000","solution":"def max_score(arr): Returns the maximum possible score for the given array by optimally partitioning the array into subarrays according to the rules described above. # The optimal strategy is to keep the largest possible subarrays, # because the product of larger numbers is greater than the product of smaller numbers. n = len(arr) total_sum = sum(arr) # The sum of the entire array return total_sum"},{"question":"def find_pair_with_sum(n: int, lst: List[int], target: int) -> bool: Returns True if there are two distinct numbers in the list that add up to the target sum. Args: n (int): the number of elements in the list. lst (List[int]): a list of integers. target (int): the target sum. Returns: bool: True if such a pair exists, False otherwise. Examples: >>> find_pair_with_sum(5, [1, 2, 3, 4, 5], 9) True >>> find_pair_with_sum(4, [1, 2, 3, 8], 7) False","solution":"def find_pair_with_sum(n, lst, target): Returns True if there are two distinct numbers in the list that add up to the target sum. seen_numbers = set() for number in lst: complement = target - number if complement in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"from typing import List, Tuple def is_valid_subsequence_possible(n: int, a: List[int]) -> str: Determine if there exists a subsequence of \`a\` such that the sum of its elements is even and the product of its elements is odd. >>> is_valid_subsequence_possible(3, [1, 3, 5]) \\"YES\\" >>> is_valid_subsequence_possible(5, [2, 4, 6, 8, 10]) \\"NO\\" >>> is_valid_subsequence_possible(4, [1, 2, 3, 4]) \\"YES\\" >>> is_valid_subsequence_possible(6, [7, 11, 13, 17, 19, 23]) \\"YES\\" pass def solve(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases to check the feasibility of the subsequence with even sum and odd product for each test case. >>> solve([(3, [1, 3, 5]), (5, [2, 4, 6, 8, 10]), (4, [1, 2, 3, 4]), (6, [7, 11, 13, 17, 19, 23])]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] pass","solution":"def is_valid_subsequence_possible(n, a): # Separate the array into odd and even numbers odd_numbers = [x for x in a if x % 2 != 0] even_numbers = [x for x in a if x % 2 == 0] # Check if there's at least one odd number and one even number in the array if odd_numbers and even_numbers: return \\"YES\\" # Alternatively, check if there are at least two odd numbers elif len(odd_numbers) >= 2: return \\"YES\\" else: return \\"NO\\" def solve(test_cases): results = [] for case in test_cases: n, a = case result = is_valid_subsequence_possible(n, a) results.append(result) return results"},{"question":"def notebooks_distribution(N: int, scores: List[int]) -> List[int]: Calculate the number of notebooks each student will receive based on the distribution rules. Args: N (int): The number of students. scores (List[int]): List of scores for each student. Returns: List[int]: List of notebooks distributed to each student based on their score. >>> notebooks_distribution(4, [35, 50, 70, 85]) [2, 5, 7, 10] >>> notebooks_distribution(3, [39, 40, 80]) [2, 5, 10] >>> notebooks_distribution(5, [10, 45, 65, 75, 100]) [2, 5, 7, 7, 10] >>> notebooks_distribution(4, [0, 59, 60, 79]) [2, 5, 7, 7] >>> notebooks_distribution(1, [100]) [10]","solution":"def notebooks_distribution(N, scores): Returns a list of the number of notebooks each student will receive based on their scores. Args: N (int): The number of students. scores (list of int): List of scores for each student. Returns: list of int: List of notebooks distributed to each student based on their score. notebooks = [] for score in scores: if score < 40: notebooks.append(2) elif 40 <= score <= 59: notebooks.append(5) elif 60 <= score <= 79: notebooks.append(7) elif score >= 80: notebooks.append(10) return notebooks"},{"question":"def number_of_unique_paths(n: int, m: int, grid: List[str]) -> int: Determine the number of unique paths Mallik can take to reach his destination, taking into account the obstacles. The function should return the number of unique paths modulo 10^9 + 7. >>> number_of_unique_paths(3, 3, ['...', '.#.', '...']) == 2 >>> number_of_unique_paths(3, 3, ['..#', '.#.', '...']) == 1 >>> number_of_unique_paths(1, 1, ['.']) == 1","solution":"MOD = 10**9 + 7 def number_of_unique_paths(n, m, grid): # Handle edge case for starting point if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 # Fill the dp table for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"def is_prime(num): Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(11) True >>> is_prime(15) False pass def next_prime(n): Returns the smallest prime number greater than n. >>> next_prime(10) 11 >>> next_prime(11) 13 >>> next_prime(20) 23 >>> next_prime(0) 2 >>> next_prime(1) 2 >>> next_prime(2) 3 >>> next_prime(24) 29 pass","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(n): Returns the smallest prime number greater than n. num = n + 1 while not is_prime(num): num += 1 return num"},{"question":"def smallest_missing_positive_integer(arr): This function returns the smallest positive integer that does not occur in the given array. >>> smallest_missing_positive_integer([1, 2, 0]) 3 >>> smallest_missing_positive_integer([-1, 2, 3, 4, 5]) 1 def process_test_cases(test_cases): This function processes multiple test cases to find the smallest positive integer missing in each. >>> process_test_cases([(3, [1, 2, 0]), (5, [-1, 2, 3, 4, 5]), (5, [1, 1, 0, -1, -2])]) [3, 1, 2] def parse_input(input_lines): Parses the input lines into structured test cases. >>> parse_input([\\"3\\", \\"3\\", \\"1 2 0\\", \\"5\\", \\"-1 2 3 4 5\\", \\"5\\", \\"1 1 0 -1 -2\\"]) [(3, [1, 2, 0]), (5, [-1, 2, 3, 4, 5]), (5, [1, 1, 0, -1, -2])]","solution":"def smallest_missing_positive_integer(arr): This function returns the smallest positive integer that does not occur in the given array. s = set(arr) i = 1 while i in s: i += 1 return i def process_test_cases(test_cases): This function processes multiple test cases to find the smallest positive integer missing in each. results = [] for case in test_cases: n, arr = case result = smallest_missing_positive_integer(arr) results.append(result) return results def parse_input(input_lines): Parses the input lines into structured test cases. T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) arr = list(map(int, input_lines[index + 1].split())) test_cases.append((N, arr)) index += 2 return test_cases"},{"question":"def removeDuplicates(arr: list[int]) -> list[int]: Removes duplicate values from the input array while preserving the order of their first appearances. >>> removeDuplicates([]) [] >>> removeDuplicates([1, 2, 3, 4]) [1, 2, 3, 4] >>> removeDuplicates([1, 3, 3, 1, 5, 5, 4, 7, 3, 2, 4]) [1, 3, 5, 4, 7, 2] >>> removeDuplicates([1]) [1] >>> removeDuplicates([2, 2, 2, 2]) [2] >>> removeDuplicates([10, 20, 10, 30, 10, 40, 20, 50]) [10, 20, 30, 40, 50]","solution":"def removeDuplicates(arr: list[int]) -> list[int]: Removes duplicate values from the input array while preserving the order of their first appearances. :param arr: List of integers that may contain duplicates. :return: List of integers without duplicates. seen = set() result = [] for num in arr: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def can_tile_grid(n: int) -> str: Given an odd integer n, determine if it's possible to tile an n x n grid using L-shaped trominoes. Parameters: n (int): The size of the grid (1 ≤ n ≤ 999). Returns: str: \\"NO\\" if the grid cannot be tiled, \\"YES\\" and the grid otherwise. Example: >>> can_tile_grid(3) \\"NO\\" >>> can_tile_grid(5) \\"NO\\"","solution":"def can_tile_grid(n): Given an odd integer n, determine if it's possible to tile an n x n grid using L-shaped trominoes. Parameters: n (int): The size of the grid (1 ≤ n ≤ 999). Returns: str: \\"NO\\" if the grid cannot be tiled, \\"YES\\" and the grid otherwise. # Since n is odd, we cannot tile the grid. return \\"NO\\""},{"question":"def sum_of_even_numbers(N: int) -> int: Compute the sum of all even numbers from 1 to N (inclusive). >>> sum_of_even_numbers(10) 30 >>> sum_of_even_numbers(1) 0 >>> sum_of_even_numbers(6) 12 >>> sum_of_even_numbers(7) 12 >>> sum_of_even_numbers(1000) 250500","solution":"def sum_of_even_numbers(N): Compute the sum of all even numbers from 1 to N (inclusive). return sum(i for i in range(2, N+1, 2))"},{"question":"from typing import List def count_characters(words: List[str], chars: str) -> int: Returns the sum of the lengths of all the words that can be formed by using the characters from chars only once per character. >>> count_characters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> count_characters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"welldonehoneyr\\") 10","solution":"from collections import Counter def count_characters(words, chars): Returns the sum of the lengths of all the words that can be formed by using the characters from chars only once per character. char_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= char_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"def rank_students(student_scores): Ranks students based on their scores in descending order. If two students have the same score, rank them alphabetically by their names. :param student_scores: A list of tuples where each tuple contains a student's name and their score. :return: A list of strings in the format \\"<rank>. <name>\\" # Your code here # Helper function to parse the input (useful for testing) def parse_input(input_str): lines = input_str.strip().split(\\"n\\") n = int(lines[0].strip()) student_scores = [] for i in range(1, n + 1): name, score = lines[i].rsplit(\\" \\", 1) student_scores.append((name, int(score))) return student_scores # Example usage: input_str = \\"4nAlice 85nBob 92nCharlie 75nDavid 85\\" student_scores = parse_input(input_str) ranks = rank_students(student_scores) for rank in ranks: print(rank)","solution":"def rank_students(student_scores): Ranks students based on their scores in descending order. If two students have the same score, rank them alphabetically by their names. :param student_scores: A list of tuples where each tuple contains a student's name and their score. :return: A list of strings in the format \\"<rank>. <name>\\" sorted_students = sorted(student_scores, key=lambda x: (-x[1], x[0])) result = [] current_rank = 1 for i, (name, score) in enumerate(sorted_students): if i > 0 and score == sorted_students[i-1][1]: result.append(f\\"{current_rank}. {name}\\") else: current_rank = i + 1 result.append(f\\"{current_rank}. {name}\\") return result # Helper function to parse the input (useful for testing) def parse_input(input_str): lines = input_str.strip().split(\\"n\\") n = int(lines[0].strip()) student_scores = [] for i in range(1, n+1): name, score = lines[i].rsplit(\\" \\", 1) student_scores.append((name, int(score))) return student_scores"},{"question":"def max_temp_differences(data): Calculate the maximum temperature difference for each day's temperature readings. Given the input data as a list of strings where each string represents temperature readings for a day, this function returns a list of integers representing the maximum temperature difference for each day. Each line of the dataset contains space-separated integers representing the temperature readings for a day. The input ends with a single line containing \\"0\\". Example: >>> max_temp_differences([\\"1 5 10 -5 15\\", \\"-10 0 -20 10\\", \\"20 30 25 15 10 5\\", \\"0\\"]) [20, 30, 25] Test Cases: >>> max_temp_differences([\\"1 5 10 -5 15\\", \\"0\\"]) [20] >>> max_temp_differences([\\"5 10 15\\", \\"2 7 11\\", \\"9 9 9\\", \\"0\\"]) [10, 9, 0]","solution":"def max_temp_differences(data): Calculate the maximum temperature difference for each day's temperature readings. results = [] for line in data: if line == \\"0\\": break temperatures = list(map(int, line.split())) max_diff = max(temperatures) - min(temperatures) results.append(max_diff) return results"},{"question":"import math from typing import List, Tuple def minimum_vehicles_required(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of vehicles required for transportation given the number of employees and the vehicle capacity. >>> minimum_vehicles_required(3, [(15, 4), (7, 5), (20, 10)]) [4, 2, 2] >>> minimum_vehicles_required(1, [(10000, 1000)]) [10] >>> minimum_vehicles_required(3, [(1, 1), (0, 1), (10000, 1)]) [1, 0, 10000] >>> minimum_vehicles_required(1, [(10000, 1)]) [10000] >>> minimum_vehicles_required(1, [(1, 10000)]) [1] >>> minimum_vehicles_required(1, [(1000, 1000)]) [1] >>> minimum_vehicles_required(1, [(0, 5)]) [0]","solution":"import math def minimum_vehicles_required(T, test_cases): results = [] for i in range(T): N, V = test_cases[i] required_vehicles = math.ceil(N / V) results.append(required_vehicles) return results"},{"question":"class MatrixOperations: def __init__(self, N, matrix): self.N = N self.matrix = matrix def add_value(self, x, y, v): self.matrix[x-1][y-1] += v def subtract_value(self, x, y, v): self.matrix[x-1][y-1] -= v def set_value(self, x, y, v): self.matrix[x-1][y-1] = v def sum_submatrix(self, x1, y1, x2, y2): result = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): result += self.matrix[i][j] return result def sum_squares_submatrix(self, x1, y1, x2, y2): result = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): result += self.matrix[i][j] ** 2 return result def process_matrix_operations(N, Q, matrix, queries): Given an N x N matrix, perform Q queries on this matrix. There can be following types of queries: 1. Add value v to the matrix element at position (x, y). 2. Subtract value v from the matrix element at position (x, y). 3. Set the matrix element at position (x, y) to value v. 4. Print the sum of all matrix elements from position (x1, y1) to (x2, y2) inclusive. 5. Print the sum of squares of all matrix elements from position (x1, y1) to (x2, y2) inclusive. N: an integer, the size of the matrix Q: an integer, the number of queries matrix: a list of lists of integers, representing the initial matrix elements queries: a list of strings, each representing a query Returns a list of integers, the results of type 4 and 5 queries. >>> process_matrix_operations(3, 5, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [\\"1 1 1 2\\", \\"2 2 2 1\\", \\"3 3 3 10\\", \\"4 1 1 2 2\\", \\"5 1 1 3 3\\"]) [13, 303] >>> process_matrix_operations(2, 1, [[1, 2], [3, 4]], [\\"1 1 1 3\\"]) []","solution":"class MatrixOperations: def __init__(self, N, matrix): self.N = N self.matrix = matrix def add_value(self, x, y, v): self.matrix[x-1][y-1] += v def subtract_value(self, x, y, v): self.matrix[x-1][y-1] -= v def set_value(self, x, y, v): self.matrix[x-1][y-1] = v def sum_submatrix(self, x1, y1, x2, y2): result = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): result += self.matrix[i][j] return result def sum_squares_submatrix(self, x1, y1, x2, y2): result = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): result += self.matrix[i][j] ** 2 return result def process_matrix_operations(N, Q, matrix, queries): matrix_ops = MatrixOperations(N, matrix) results = [] for query in queries: parts = list(map(int, query.split())) if parts[0] == 1: matrix_ops.add_value(parts[1], parts[2], parts[3]) elif parts[0] == 2: matrix_ops.subtract_value(parts[1], parts[2], parts[3]) elif parts[0] == 3: matrix_ops.set_value(parts[1], parts[2], parts[3]) elif parts[0] == 4: result = matrix_ops.sum_submatrix(parts[1], parts[2], parts[3], parts[4]) results.append(result) elif parts[0] == 5: result = matrix_ops.sum_squares_submatrix(parts[1], parts[2], parts[3], parts[4]) results.append(result) return results"},{"question":"def minimal_adjustments(n: int, digits: str) -> int: Returns the minimum number of adjustments required to convert the sequence of digits into a valid time in the format HH:MM. >>> minimal_adjustments(4, '1234') 0 >>> minimal_adjustments(3, '940') 1 >>> minimal_adjustments(2, '56') 3 >>> minimal_adjustments(1, '1') 3","solution":"def minimal_adjustments(n, digits): Returns the minimum number of adjustments required to convert the sequence of digits into a valid time in the format HH:MM. if n == 4: return 0 # Already in the correct format elif n == 3: best_guess = \\"0\\" + digits[:1] + \\":\\" + digits[1:] return 1 elif n == 2: # Insert a colon and add zero padding return 2 + (0 if int(digits[:1]) <= 2 else 1) elif n == 1: # Needs the most work: zero padding on both hour and the full minutes return 3 return -1 # fallback for unexpected n"},{"question":"def smallest_diff_subarray(numbers, queries): Returns the smallest possible difference between the largest and smallest integer in the chosen subarray for each query. :param numbers: List of integers :param queries: List of tuples (L, R) representing subarray range :return: List of integers representing smallest differences for each query >>> smallest_diff_subarray([1, 3, 4, 5, 2, 6], [(1, 3), (2, 5), (1, 6)]) [3, 3, 5] results = [] # Your code here return results","solution":"def smallest_diff_subarray(numbers, queries): Returns the smallest possible difference between the largest and smallest integer in the chosen subarray for each query. :param numbers: List of integers :param queries: List of tuples (L, R) representing subarray range :return: List of integers representing smallest differences for each query results = [] for L, R in queries: subarray = numbers[L-1:R] smallest_diff = max(subarray) - min(subarray) results.append(smallest_diff) return results"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced substring in the given string of brackets. >>> longest_balanced_substring(\\"(()()\\") 4 >>> longest_balanced_substring(\\")((()))(\\") 6","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring in the given string of brackets. max_len = 0 stack = [-1] for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: stack.append(i) return max_len"},{"question":"from typing import List, Tuple def find_max_donations_team(n: int, donations: List[Tuple[str, int]]) -> str: Process the donations from multiple days and determine the team with the maximum total donation. Args: n (int): the number of days. donations (List[Tuple[str, int]]): list of tuples, each containing a team name and the amount of donation for that day. Returns: str: the name of the team with the maximum total donations. If there are multiple teams with the same maximum total donation, returns the lexicographically smallest name among them. >>> find_max_donations_team(6, [(\\"TeamA\\", 100), (\\"TeamB\\", 200), (\\"TeamA\\", 150), (\\"TeamC\\", 50), (\\"TeamB\\", 300), (\\"TeamC\\", 10)]) \\"TeamB\\" >>> find_max_donations_team(4, [(\\"Alpha\\", 300), (\\"Bravo\\", 300), (\\"Charlie\\", 150), (\\"Bravo\\", 300)]) \\"Bravo\\"","solution":"def find_max_donations_team(n, donations): from collections import defaultdict team_donations = defaultdict(int) for name, donation in donations: team_donations[name] += donation max_donation = max(team_donations.values()) max_teams = [team for team, amount in team_donations.items() if amount == max_donation] return min(max_teams)"},{"question":"def zigzag_sequence(n: int) -> List[int]: Generates the first n terms of the zigzag sequence starting with 1 and 2. If the sequence terminates (reaches 1) before reaching n elements, it stops early. >>> zigzag_sequence(1) [1] >>> zigzag_sequence(3) [1, 2, 1] >>> zigzag_sequence(0) [] >>> zigzag_sequence(-5) [] >>> len(zigzag_sequence(1000)) <= 1000 True","solution":"def zigzag_sequence(n): Generates the first n terms of the zigzag sequence starting with 1 and 2. if n <= 0: return [] if n == 1: return [1] sequence = [1, 2] while len(sequence) < n: last_value = sequence[-1] if last_value == 1: break elif last_value % 2 == 0: next_value = last_value // 2 else: next_value = 3 * last_value + 1 sequence.append(next_value) return sequence[:n]"},{"question":"def can_split_into_k_equal_sums(n, k, arr): Determines if it's possible to split the array into k non-empty continuous subarrays with equal sum. :param n: int - number of elements in the array :param k: int - number of subarrays to split into :param arr: list - list of integers representing the array :return: str - \\"YES\\" if possible, \\"NO\\" otherwise def process_test_cases(t, test_cases): Processes multiple test cases to determine if each can be split into k non-empty continuous subarrays with equal sum. :param t: int - number of test cases :param test_cases: list of tuples - each tuple contains (n, k, arr) representing a test case :return: list of str - each element is \\"YES\\" or \\"NO\\" corresponding to the result of each test case from solution import can_split_into_k_equal_sums, process_test_cases def test_single_case_possible(): assert can_split_into_k_equal_sums(6, 3, [1, 2, 1, 2, 1, 2]) == \\"YES\\" def test_single_case_impossible(): assert can_split_into_k_equal_sums(5, 2, [1, 3, 3, 2, 2]) == \\"NO\\" def test_single_case_possible_another(): assert can_split_into_k_equal_sums(4, 2, [1, 2, 2, 1]) == \\"YES\\" def test_sum_not_divisible(): assert can_split_into_k_equal_sums(4, 3, [1, 2, 2, 1]) == \\"NO\\" def test_exact_split(): assert can_split_into_k_equal_sums(3, 3, [2, 2, 2]) == \\"YES\\" def test_large_input(): assert can_split_into_k_equal_sums(100, 10, [1]*100) == \\"YES\\" def test_process_test_cases(): test_cases = [ (6, 3, [1, 2, 1, 2, 1, 2]), (5, 2, [1, 3, 3, 2, 2]), (4, 2, [1, 2, 2, 1]) ] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases(3, test_cases) == expected","solution":"def can_split_into_k_equal_sums(n, k, arr): Determines if it's possible to split the array into k non-empty continuous subarrays with equal sum. :param n: int - number of elements in the array :param k: int - number of subarrays to split into :param arr: list - list of integers representing the array :return: str - \\"YES\\" if possible, \\"NO\\" otherwise total_sum = sum(arr) if total_sum % k != 0: return \\"NO\\" target_sum = total_sum // k current_sum, count = 0, 0 for num in arr: current_sum += num if current_sum == target_sum: count += 1 current_sum = 0 return \\"YES\\" if count == k else \\"NO\\" def process_test_cases(t, test_cases): results = [] for i in range(t): n, k, arr = test_cases[i] result = can_split_into_k_equal_sums(n, k, arr) results.append(result) return results"},{"question":"def compute_flower_sums(matrix, queries): Compute the total number of flowers in different subregions of the grid. Args: matrix (List[List[int]]): 2D grid representing the field of flowers. queries (List[Tuple[int, int, int, int]]): List of queries specifying the coordinates of the top-left and bottom-right corners of subregions. Returns: List[int]: List of sums of flowers within each subregion specified by the queries. Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [(1, 1, 2, 2), (0, 0, 1, 1)] >>> compute_flower_sums(matrix, queries) [28, 12] >>> matrix = [ ... [10, 20], ... [30, 40] ... ] >>> queries = [(0, 0, 0, 0), (1, 1, 1, 1), (0, 0, 1, 1)] >>> compute_flower_sums(matrix, queries) [10, 40, 100] pass import pytest def test_given_example(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 2, 2), (0, 0, 1, 1)] expected = [28, 12] assert compute_flower_sums(matrix, queries) == expected def test_single_cell_query(): matrix = [ [10, 20], [30, 40] ] queries = [(0, 0, 0, 0), (1, 1, 1, 1), (0, 0, 1, 1)] expected = [10, 40, 100] assert compute_flower_sums(matrix, queries) == expected def test_full_grid_query(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] queries = [(0, 0, 2, 2)] expected = [9] assert compute_flower_sums(matrix, queries) == expected def test_large_values(): matrix = [ [1000, 1000], [1000, 1000] ] queries = [(0, 0, 1, 1)] expected = [4000] assert compute_flower_sums(matrix, queries) == expected def test_non_overlapping_partial_grids(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] queries = [(0, 0, 1, 1), (2, 2, 3, 3)] expected = [14, 54] assert compute_flower_sums(matrix, queries) == expected","solution":"def compute_flower_sums(matrix, queries): n = len(matrix) m = len(matrix[0]) # Compute the prefix sum matrix prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n+1): for j in range(1, m+1): prefix_sum[i][j] = (matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) results = [] for (x1, y1, x2, y2) in queries: total = (prefix_sum[x2 + 1][y2 + 1] - prefix_sum[x1][y2 + 1] - prefix_sum[x2 + 1][y1] + prefix_sum[x1][y1]) results.append(total) return results"},{"question":"def find_pair_with_sum(n: int, arr: List[int], k: int) -> Union[Tuple[int, int], int]: You are given an array of n integers and a target integer k. Your task is to determine if there exists a pair of distinct indices (i, j) such that the elements at those indices add up to k. If such a pair exists, return the indices i and j (0-based indexing). If there are multiple valid pairs, return any one of them. If no such pair exists, return -1. >>> find_pair_with_sum(5, [1, 2, 3, 4, 5], 7) in [(1, 4), (2, 3), (3, 2), (4, 1)] True >>> find_pair_with_sum(4, [5, 1, 3, 6], 10) -1","solution":"def find_pair_with_sum(n, arr, k): seen = {} for i in range(n): complement = k - arr[i] if complement in seen: return seen[complement], i seen[arr[i]] = i return -1"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.data = data self.tree_sum = [0] * (4 * self.n) self.tree_max = [0] * (4 * self.n) self._build(0, 0, self.n - 1) def _build(self, node, start, end): pass def update(self, idx, value): pass def range_sum(self, l, r): pass def range_max(self, l, r): pass def process_queries(n, initial_values, queries): Process a series of queries on a list of integers. Each query can be one of the following: 1. Update the value at a specified index. 2. Find the sum of elements between two specified indices. 3. Find the maximum value between two specified indices. Parameters: n (int): Number of elements in the list. initial_values (List[int]): Initial values of the list. queries (List[Tuple[int]]): List of queries to process. Returns: List[int]: Results of the sum and max queries. Example: >>> process_queries(5, [1, 2, 3, 4, 5], [(2, 1, 3), (3, 2, 5), (1, 3, 10), (2, 1, 5)]) [6, 5, 22] segment_tree = SegmentTree(initial_values) result = [] for query in queries: if query[0] == 1: _, x, y = query segment_tree.update(x - 1, y) elif query[0] == 2: _, l, r = query result.append(segment_tree.range_sum(l - 1, r - 1)) elif query[0] == 3: _, l, r = query result.append(segment_tree.range_max(l - 1, r - 1)) return result","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.data = data self.tree_sum = [0] * (4 * self.n) self.tree_max = [0] * (4 * self.n) self._build(0, 0, self.n - 1) def _build(self, node, start, end): if start == end: self.tree_sum[node] = self.data[start] self.tree_max[node] = self.data[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._build(left_child, start, mid) self._build(right_child, mid + 1, end) self.tree_sum[node] = self.tree_sum[left_child] + self.tree_sum[right_child] self.tree_max[node] = max(self.tree_max[left_child], self.tree_max[right_child]) def update(self, idx, value): def _update(node, start, end): if start == end: self.data[idx] = value self.tree_sum[node] = value self.tree_max[node] = value else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= idx <= mid: _update(left_child, start, mid) else: _update(right_child, mid + 1, end) self.tree_sum[node] = self.tree_sum[left_child] + self.tree_sum[right_child] self.tree_max[node] = max(self.tree_max[left_child], self.tree_max[right_child]) return _update(0, 0, self.n - 1) def range_sum(self, l, r): def _sum(node, start, end): if l > end or r < start: return 0 if l <= start and end <= r: return self.tree_sum[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 return _sum(left_child, start, mid) + _sum(right_child, mid + 1, end) return _sum(0, 0, self.n - 1) def range_max(self, l, r): def _max(node, start, end): if l > end or r < start: return float('-inf') if l <= start and end <= r: return self.tree_max[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 return max(_max(left_child, start, mid), _max(right_child, mid + 1, end)) return _max(0, 0, self.n - 1) def process_queries(n, initial_values, queries): segment_tree = SegmentTree(initial_values) result = [] for query in queries: if query[0] == 1: _, x, y = query segment_tree.update(x - 1, y) elif query[0] == 2: _, l, r = query result.append(segment_tree.range_sum(l - 1, r - 1)) elif query[0] == 3: _, l, r = query result.append(segment_tree.range_max(l - 1, r - 1)) return result"},{"question":"def shortest_length(s: str) -> int: Compute the length of the shortest possible string after repeatedly removing substrings \\"ab\\" or \\"ba\\". >>> shortest_length(\\"abac\\") == 2 >>> shortest_length(\\"aabb\\") == 0 >>> shortest_length(\\"abcba\\") == 1","solution":"def shortest_length(s): Compute the length of the shortest possible string after repeatedly removing substrings \\"ab\\" or \\"ba\\". Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Length of the shortest possible string. stack = [] for char in s: if stack and ((stack[-1] == 'a' and char == 'b') or (stack[-1] == 'b' and char == 'a')): stack.pop() else: stack.append(char) return len(stack)"},{"question":"from typing import List, Tuple def can_distribute_bonuses(N: int, M: int, matchups: List[Tuple[int, int]]) -> str: Determine if it is possible to select bonus-receivers such that no employee receives more than one bonus. Args: N (int): Number of employees. M (int): Number of matchups. matchups (List[Tuple[int, int]]): List of pairwise matchups. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". >>> can_distribute_bonuses(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"YES\\" >>> can_distribute_bonuses(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\" def test_case1(): N, M = 5, 4 matchups = [(1, 2), (2, 3), (3, 4), (4, 5)] assert can_distribute_bonuses(N, M, matchups) == \\"YES\\" def test_case2(): N, M = 3, 3 matchups = [(1, 2), (2, 3), (3, 1)] assert can_distribute_bonuses(N, M, matchups) == \\"NO\\" def test_case3(): N, M = 4, 2 matchups = [(1, 2), (3, 4)] assert can_distribute_bonuses(N, M, matchups) == \\"YES\\" def test_case4(): N, M = 6, 3 matchups = [(1, 2), (3, 4), (5, 6)] assert can_distribute_bonuses(N, M, matchups) == \\"YES\\" def test_case5(): N, M = 3, 2 matchups = [(1, 2), (1, 3)] assert can_distribute_bonuses(N, M, matchups) == \\"YES\\" def test_case6(): N, M = 1, 0 matchups = [] assert can_distribute_bonuses(N, M, matchups) == \\"YES\\"","solution":"def can_distribute_bonuses(N, M, matchups): from collections import defaultdict, deque graph = defaultdict(list) for u, v in matchups: graph[u].append(v) graph[v].append(u) color = {} def bfs(node): queue = deque([node]) color[node] = 0 while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor in color: if color[neighbor] == color[current]: return False else: color[neighbor] = 1 - color[current] queue.append(neighbor) return True for node in range(1, N + 1): if node not in color: if not bfs(node): return \\"NO\\" return \\"YES\\""},{"question":"def is_complete_string(s: str) -> bool: Determines if a given string is complete, meaning every letter in the English alphabet (case insensitive) appears at least once in the string. >>> is_complete_string(\\"The quick brown fox jumps over the lazy dog\\") True >>> is_complete_string(\\"Hello, World!\\") False >>> is_complete_string(\\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_complete_string(\\"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\\") True >>> is_complete_string(\\"Python 3.9 is great!\\") False","solution":"def is_complete_string(s: str) -> bool: Returns True if the input string 's' is a complete string, i.e., it contains every letter from 'a' to 'z' at least once, otherwise returns False. The check is case insensitive. import string alphabet_set = set(string.ascii_lowercase) input_set = set(s.lower()) return alphabet_set.issubset(input_set)"},{"question":"def min_sheets_required(H: int, W: int, parts: List[Tuple[int, int, int]]) -> int: Calculate the minimum number of large sheets required to cut out all the parts. Args: H (int): Height of the large sheet. W (int): Width of the large sheet. parts (List[Tuple[int, int, int]]): A list of tuples where each tuple represents the height, width, and quantity of a part. Returns: int: The minimum number of large sheets required to fulfill the order. >>> min_sheets_required(20, 15, [(5, 5, 10), (10, 5, 2), (2, 3, 4)]) 2 >>> min_sheets_required(10, 10, [(5, 5, 4), (3, 3, 1)]) 2 >>> min_sheets_required(30, 30, [(10, 10, 3), (5, 5, 10)]) 1 >>> min_sheets_required(50, 40, [(25, 20, 6), (15, 15, 8)]) 3 >>> min_sheets_required(25, 30, [(10, 15, 5), (5, 5, 20)]) 2","solution":"def min_sheets_required(H, W, parts): Calculate the minimum number of large sheets required to cut out all the parts. from itertools import product # Initialize the part count array remaining_parts = [] for h, w, q in parts: remaining_parts.append((h, w, q)) sheet_count = 0 while remaining_parts: remaining_area = H * W used_area = [[False] * W for _ in range(H)] # Try to place parts in the current sheet index = 0 while index < len(remaining_parts): h, w, q = remaining_parts[index] placed_count = 0 for x, y in product(range(H - h + 1), range(W - w + 1)): if not any(used_area[i][j] for i in range(x, x + h) for j in range(y, y + w)): for i in range(x, x + h): for j in range(y, y + w): used_area[i][j] = True remaining_area -= h * w placed_count += 1 if placed_count == q: break q -= placed_count if q == 0: remaining_parts.pop(index) else: remaining_parts[index] = (h, w, q) index += 1 if remaining_area <= 0: break # Add a new sheet if there are remaining parts to place sheet_count += 1 return sheet_count"},{"question":"def closest_three_sum(n: int, target: int, arr: List[int]) -> Tuple[int, int, int]: Returns a tuple of three integers from the list such that the sum is closest to the given target. >>> closest_three_sum(6, 10, [-1, 2, 1, -4, 3, 5]) (2, 3, 5) >>> closest_three_sum(6, 13, [-1, 2, 1, -4, 3, 5]) (1, 5, 3) >>> closest_three_sum(6, -2, [-1, 2, 1, -4, 3, 5]) (-1, -4, 3) >>> closest_three_sum(7, 0, [-3, -2, -1, 0, 1, 2, 3]) (-3, 1, 2) >>> closest_three_sum(5, 1, [10**9, -10**9, 2*10**9, -2*10**9, 3*10**9]) (-10**9, 2*10**9, 10**9) pass","solution":"def closest_three_sum(n, target, arr): Returns a tuple of three integers from the list such that the sum is closest to the given target. arr.sort() closest_sum = float('inf') closest_tuple = () for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum closest_tuple = (arr[i], arr[left], arr[right]) if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return (arr[i], arr[left], arr[right]) return closest_tuple"},{"question":"def card_game(n: int, q: int, cards: List[int], operations: List[str]) -> List[int]: Process a series of operations on a deck of cards and provide results for the queries. >>> card_game(5, 7, [1, 2, 3, 4, 5], [\\"Q 3\\", \\"R 2\\", \\"Q 3\\", \\"U 3 10\\", \\"Q 3\\", \\"R 3\\", \\"Q 3\\"]) [3, 5, 15, 3] >>> card_game(4, 2, [10, 20, 30, 40], [\\"Q 1\\", \\"Q 4\\"]) [10, 40] from typing import List def test_example_case(): n = 5 q = 7 cards = [1, 2, 3, 4, 5] operations = [\\"Q 3\\", \\"R 2\\", \\"Q 3\\", \\"U 3 10\\", \\"Q 3\\", \\"R 3\\", \\"Q 3\\"] expected_output = [3, 5, 15, 3] assert card_game(n, q, cards, operations) == expected_output def test_initial_query(): n = 4 q = 2 cards = [10, 20, 30, 40] operations = [\\"Q 1\\", \\"Q 4\\"] expected_output = [10, 40] assert card_game(n, q, cards, operations) == expected_output def test_single_rotation(): n = 3 q = 2 cards = [7, 8, 9] operations = [\\"R 1\\", \\"Q 1\\"] expected_output = [8] assert card_game(n, q, cards, operations) == expected_output def test_multiple_updates(): n = 6 q = 4 cards = [5, 10, 15, 20, 25, 30] operations = [\\"U 2 5\\", \\"U 4 10\\", \\"Q 3\\", \\"Q 4\\"] expected_output = [15, 30] assert card_game(n, q, cards, operations) == expected_output def test_large_rotation(): n = 3 q = 3 cards = [1, 2, 3] operations = [\\"R 3\\", \\"Q 1\\", \\"Q 2\\"] expected_output = [1, 2] assert card_game(n, q, cards, operations) == expected_output def test_rotation_and_update(): n = 4 q = 5 cards = [11, 12, 13, 14] operations = [\\"R 2\\", \\"Q 1\\", \\"U 1 1\\", \\"Q 1\\", \\"Q 3\\"] expected_output = [13, 14, 11] assert card_game(n, q, cards, operations) == expected_output","solution":"def card_game(n, q, cards, operations): current_cards = cards[:] offset = 0 results = [] for operation in operations: op = operation.split() if op[0] == 'Q': i = int(op[1]) - 1 results.append(current_cards[(i + offset) % n]) elif op[0] == 'U': i = int(op[1]) - 1 v = int(op[2]) current_cards[(i + offset) % n] += v elif op[0] == 'R': k = int(op[1]) offset = (offset + k) % n return results"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 >>> longest_palindromic_subsequence(\\"abcdef\\") 1","solution":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string. n = len(s) dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def distance_from_capital(num_cases: int, cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[List[int]]: The kingdom of ByteLand has n towns connected by n-1 bidirectional roads forming a tree structure. Every town has a unique ID from 0 to n-1. A special node, called the capital, is identified by its ID 0. All other towns are directly or indirectly connected to the capital. The citizens of ByteLand want to know the distance of all towns from the capital. The distance between two towns is defined as the number of roads in the shortest path connecting the two towns. You are required to write a program that reads the connections of the roads and outputs the list of distances of each town from the capital town. ------Input------ - The first line contains a single integer T (1 ≤ T ≤ 10) representing the number of test cases. - For each test case, the first line contains a single integer n (2 ≤ n ≤ 10^5), the number of towns. - Each of the next n-1 lines contains two integers u and v (0 ≤ u, v < n) representing a road directly connecting town u and town v. ------Output------ - For each test case, output a single line containing n space-separated integers where the ith integer represents the distance of town i from the capital (town with ID 0). >>> distance_from_capital(2, [(4, [(0, 1), (0, 2), (1, 3)]), (3, [(0, 1), (1, 2)])]) [[0, 1, 1, 2], [0, 1, 2]]","solution":"from collections import deque, defaultdict def distance_from_capital(num_cases, cases): results = [] for n, roads in cases: # Initialize the graph graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # We use BFS to find the shortest path distances from the capital (node 0) distances = [-1] * n queue = deque([0]) distances[0] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if distances[neighbor] == -1: distances[neighbor] = distances[node] + 1 queue.append(neighbor) results.append(distances) return results # Example usage: num_cases = 2 cases = [ (4, [(0, 1), (0, 2), (1, 3)]), (3, [(0, 1), (1, 2)]) ] print(distance_from_capital(num_cases, cases)) # Expected output: [[0, 1, 1, 2], [0, 1, 2]]"},{"question":"from typing import List def min_additional_distance(dist: List[int], target: int) -> int: Determines the minimum number of additional kilometers Marcus must travel on a single day to meet or exceed his weekly target distance. >>> min_additional_distance([0, 5, 7, 10, 6, 4, 2], 40) 0 >>> min_additional_distance([0, 0, 0, 0, 0, 0, 0], 50) -1 >>> min_additional_distance([5, 10, 15, 5, 5, 5, 5], 60) 15","solution":"from typing import List def min_additional_distance(dist: List[int], target: int) -> int: Determines the minimum number of additional kilometers Marcus must travel on a single day to meet or exceed his weekly target distance. total_distance = sum(dist) # If Marcus has already met or exceeded his target distance if total_distance >= target: return 0 # Calculate the required distance Marcus needs to travel to meet the target required_additional_distance = target - total_distance # Determine the maximum additional distance he could travel in one of the remaining days max_possible_distance_per_day = 10000 # Since he can travel up to 10000 km in a single day, # Check if required additional distance is less than or equal to maximum possible in one day if required_additional_distance <= max_possible_distance_per_day: return required_additional_distance # If it's not possible to cover the required additional distance in one of the remaining days return -1"},{"question":"def find_shortest_paths(datasets): Find the shortest paths in multiple datasets using Dijkstra's algorithm. Args: datasets (List[Tuple[int, int, List[Tuple[int, int, int]], int, int]]): A list of datasets, where each dataset consists of: - N (int): the number of delivery points (nodes) - M (int): the number of roads (edges) - edges (List[Tuple[int, int, int]]): a list of tuples representing roads with (u, v, w), where u and v are delivery points and w is the distance - S (int): the starting delivery point - T (int): the target delivery point Returns: List[int]: A list of minimum distances from the starting point to the target point for each dataset. If no path exists, output -1. Example: >>> datasets = [ >>> (4, 4, [(1, 2, 5), (2, 3, 10), (1, 3, 15), (2, 4, 20)], 1, 3), >>> (3, 2, [(1, 2, 3), (2, 3, 5)], 1, 3) >>> ] >>> find_shortest_paths(datasets) [15, 8]","solution":"import heapq def dijkstra(N, graph, start, end): # Initialize distances to infinity and the priority queue distances = {node: float('infinity') for node in range(1, N + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we reach the end node, we can return the distance if current_node == end: return current_distance # If a shorter path has already been found, skip processing if current_distance > distances[current_node]: continue # Explore neighboring nodes for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 if distances[end] == float('infinity') else distances[end] def find_shortest_paths(datasets): results = [] for dataset in datasets: N, M, edges, start, end = dataset graph = {i: [] for i in range(1, N + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) result = dijkstra(N, graph, start, end) results.append(result) return results"},{"question":"from typing import List, Tuple def degrees_of_separation(n: int, m: int, friendships: List[Tuple[int, int]], q: int, queries: List[Tuple[int, int]]) -> List[int]: Write a program to simulate a simple social network by reading a list of friendships and then processing queries to determine the degrees of separation between users. The function takes the number of users \`n\`, the number of friendships \`m\`, a list of friendships, the number of queries \`q\`, and a list of queries. It returns a list of degrees of separation for each query. >>> degrees_of_separation(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 3, [(1, 5), (1, 3), (2, 5)]) [4, 2, 3] >>> degrees_of_separation(5, 2, [(1, 2), (3, 4)], 2, [(1, 3), (2, 4)]) [-1, -1]","solution":"from collections import deque, defaultdict def build_graph(friendships, n): graph = defaultdict(list) for u, v in friendships: graph[u].append(v) graph[v].append(u) return graph def bfs_shortest_path(graph, start, goal): if start == goal: return 0 visited = set() queue = deque([(start, 0)]) while queue: node, depth = queue.popleft() if node == goal: return depth if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append((neighbor, depth + 1)) return -1 def degrees_of_separation(n, m, friendships, q, queries): graph = build_graph(friendships, n) results = [] for a, b in queries: results.append(bfs_shortest_path(graph, a, b)) return results"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved from buying and selling once. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5, 5, 5, 5, 5]) 0 >>> max_profit([5]) 0 >>> max_profit([1, 5]) 4 >>> max_profit([5, 1]) 0 >>> max_profit(list(range(100000, 0, -1))) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from buying and selling once. If no profit is possible, returns 0. if not prices: return 0 # Initialize the necessary variables min_price = float('inf') max_profit = 0 # Iterate through the prices for price in prices: # If we find a new minimum price, we update min_price if price < min_price: min_price = price # Calculate potential profit if current price is sold at potential_profit = price - min_price # Update max_profit if the potential profit is greater if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def longest_path_dag(N: int, M: int, edges: List[Tuple[int, int, int]]) -> int: Compute the length of the longest path in a directed graph that does not revisit any node. Args: N : int : number of nodes in the graph M : int : number of edges in the graph edges : List[Tuple[int, int, int]] : list of edges where each edge is represented as a tuple (u, v, w) Returns: int : length of the longest path that doesn't revisit any node or 0 if no such path exists Examples: >>> longest_path_dag(4, 4, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 2)]) 12 >>> longest_path_dag(3, 2, [(1, 2, 5), (2, 3, 7)]) 12 >>> longest_path_dag(3, 1, [(1, 2, 1)]) 1 >>> longest_path_dag(3, 1, [(1, 2, 1)]) 1 >>> longest_path_dag(4, 0, []) 0","solution":"from collections import defaultdict, deque def longest_path_dag(N, M, edges): # Construct the adjacency list graph = defaultdict(list) indegree = [0] * (N + 1) for u, v, w in edges: graph[u].append((v, w)) indegree[v] += 1 # Topological Sort using Kahn's Algorithm topo_sort = [] zero_indegree = deque([i for i in range(1, N + 1) if indegree[i] == 0]) while zero_indegree: node = zero_indegree.popleft() topo_sort.append(node) for neighbor, weight in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree.append(neighbor) # If topological sort doesn't include all nodes, the graph contains a cycle if len(topo_sort) != N: return 0 # Find the longest path in the acyclic graph distance = [0] * (N + 1) for node in topo_sort: for neighbor, weight in graph[node]: if distance[neighbor] < distance[node] + weight: distance[neighbor] = distance[node] + weight return max(distance) def solve(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) edges = [] index = 2 for _ in range(M): u = int(data[index]) v = int(data[index+1]) w = int(data[index+2]) edges.append((u, v, w)) index += 3 result = longest_path_dag(N, M, edges) print(result)"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained by performing zero or more operations where each consists of removing one character from the string. >>> lexicographically_smallest_string(\\"bac\\") \\"ac\\" >>> lexicographically_smallest_string(\\"abc\\") \\"abc\\" >>> lexicographically_smallest_string(\\"cab\\") \\"ab\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by performing zero or more operations where each consists of removing one character from the string. if not s: return s min_char_index = 0 for i in range(1, len(s)): if s[i] < s[min_char_index]: min_char_index = i # Return the string with the smallest character at the starting point return s[min_char_index:]"},{"question":"def process_input(input_data: str) -> List[int]: Given the input data with the number of test cases and the garden configurations, return a list of integers representing the maximum number of flowers the King can see walking along any single row or any single column for each test case. Args: input_data (str): The input data as a single string. Returns: List[int]: List of maximum flowers seen for each test case. Example: >>> process_input(\\"2n3 4n2 3 1 4n0 6 3 1n5 1 2 7n2 2n10 20n30 40n\\") [15, 70] >>> process_input(\\"1n1 1n5n\\") [5] pass import pytest def test_example_cases(): input_data = \\"2n3 4n2 3 1 4n0 6 3 1n5 1 2 7n2 2n10 20n30 40n\\" expected_output = [15, 70] assert process_input(input_data) == expected_output def test_single_plot(): input_data = \\"1n1 1n5n\\" expected_output = [5] assert process_input(input_data) == expected_output def test_row_dominant(): input_data = \\"1n2 3n4 5 6n1 1 1n\\" expected_output = [15] assert process_input(input_data) == expected_output def test_column_dominant(): input_data = \\"1n2 2n1 4n2 5n\\" expected_output = [9] assert process_input(input_data) == expected_output def test_mixed_flower_counts(): input_data = \\"1n3 3n0 0 0n2 1 3n1 1 1n\\" expected_output = [6] assert process_input(input_data) == expected_output def test_large_values(): input_data = \\"1n3 3n1000 1000 1000n1000 1000 1000n1000 1000 1000n\\" expected_output = [3000] assert process_input(input_data) == expected_output","solution":"def find_max_flowers(test_cases): results = [] for case in test_cases: R, C, garden = case['R'], case['C'], case['garden'] max_flowers = 0 # Check all rows for row in garden: max_flowers = max(max_flowers, sum(row)) # Check all columns for col in range(C): column_sum = sum(garden[row][col] for row in range(R)) max_flowers = max(max_flowers, column_sum) results.append(max_flowers) return results # Function to process input def process_input(input_data): lines = input_data.strip().split(\\"n\\") index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): R, C = map(int, lines[index].split()) index += 1 garden = [] for _ in range(R): garden.append(list(map(int, lines[index].split()))) index += 1 test_cases.append({'R': R, 'C': C, 'garden': garden}) return find_max_flowers(test_cases)"},{"question":"def process_operations(operations): Takes in a list of operations and processes them accordingly. Supports \\"ADD x\\" to add a document with priority x, and \\"QUERY x\\" to print the count of documents with priority x. The function returns a list of results for each \\"QUERY\\" operation. Example: >>> process_operations([\\"ADD 3\\", \\"ADD 5\\", \\"ADD 3\\", \\"QUERY 3\\", \\"ADD 6\\", \\"QUERY 5\\", \\"ADD 3\\", \\"QUERY 3\\"]) [2, 1, 3]","solution":"def process_operations(operations): Takes in a list of operations and processes them accordingly. Supports \\"ADD x\\" to add a document with priority x, and \\"QUERY x\\" to print the count of documents with priority x. from collections import defaultdict document_count = defaultdict(int) # Dictionary to store the count of each priority result = [] for operation in operations: op, val = operation.split() val = int(val) if op == \\"ADD\\": document_count[val] += 1 elif op == \\"QUERY\\": result.append(document_count[val]) return result"},{"question":"def findUnsortedSubarray(nums: List[int]) -> int: Returns the length of the shortest subarray that, if sorted, would result in the entire array being sorted in non-decreasing order. Example 1: >>> findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) 5 Example 2: >>> findUnsortedSubarray([1, 2, 3, 4]) 0 Example 3: >>> findUnsortedSubarray([1, 3, 2, 2, 2]) 4","solution":"def findUnsortedSubarray(nums): Returns the length of the shortest subarray that, if sorted, would result in the entire array being sorted in non-decreasing order. n = len(nums) start, end = 0, -1 max_seen, min_seen = float('-inf'), float('inf') for i in range(n): max_seen = max(max_seen, nums[i]) if nums[i] < max_seen: end = i for i in range(n-1, -1, -1): min_seen = min(min_seen, nums[i]) if nums[i] > min_seen: start = i return end - start + 1"},{"question":"def smallest_lexicographical_substring(n: int, s: str, k: int) -> str: Determine the smallest lexicographical substring of length k from the string s. Parameters: n (int): The length of the string. s (str): The string consisting of lowercase Latin letters. k (int): The length of the required substring. Returns: str: The smallest lexicographical substring of length k. >>> smallest_lexicographical_substring(9, \\"algorithm\\", 3) 'alg' >>> smallest_lexicographical_substring(8, \\"education\\", 5) 'catio' >>> smallest_lexicographical_substring(6, \\"banana\\", 2) 'an'","solution":"def smallest_lexicographical_substring(n, s, k): Returns the smallest lexicographical substring of length k from the string s. min_sub = s[:k] # Start by assuming the first k characters form the smallest substring for i in range(1, n - k + 1): current_sub = s[i:i + k] if current_sub < min_sub: min_sub = current_sub return min_sub"},{"question":"def min_subset_difference(n: int, sizes: List[int]) -> int: Calculate the minimal absolute difference of the total size between the two subsets. >>> min_subset_difference(4, [3, 1, 4, 2]) 0 >>> min_subset_difference(3, [1, 2, 3]) 0 >>> min_subset_difference(5, [1, 2, 3, 4, 5]) 1 >>> min_subset_difference(5, [10, 20, 30, 40, 50]) 10 >>> min_subset_difference(1, [100]) 100 >>> min_subset_difference(2, [1, 100]) 99","solution":"def min_subset_difference(n, sizes): total_sum = sum(sizes) half_sum = total_sum // 2 dp = [0] * (half_sum + 1) for size in sizes: for j in range(half_sum, size - 1, -1): dp[j] = max(dp[j], dp[j - size] + size) largest_sum_partition1 = dp[half_sum] largest_sum_partition2 = total_sum - largest_sum_partition1 return abs(largest_sum_partition1 - largest_sum_partition2)"},{"question":"def count_distinct_primes(n: int, arr: List[int]) -> int: Determine the number of distinct prime numbers present in the array. >>> count_distinct_primes(6, [2, 3, 4, 5, 3, 7]) 4 >>> count_distinct_primes(3, [4, 6, 8]) 0 >>> count_distinct_primes(3, [2, 3, 5]) 3 >>> count_distinct_primes(5, [6, 6, 6, 6, 7]) 1","solution":"def count_distinct_primes(n, arr): def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True prime_set = set() for num in arr: if is_prime(num): prime_set.add(num) return len(prime_set)"},{"question":"def max_common_subarray_sum(arr1, arr2): Finds the maximum sum of any subarray that appears in both arrays. Args: arr1: List[int] - First list of integers. arr2: List[int] - Second list of integers. Returns: int - The maximum sum of any subarray that appears in both arrays. Example: >>> max_common_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4], [3, 4, -1, 2, 1]) 9 >>> max_common_subarray_sum([1, 2, 3], [4, 5, 6]) 0","solution":"def max_common_subarray_sum(arr1, arr2): Finds the maximum sum of any subarray that appears in both arrays. n = len(arr1) m = len(arr2) # DP approach - We will use a hashmap for dynamic programming dp = [[0] * (m + 1) for _ in range(n + 1)] max_sum = 0 # Fill DP table for i in range(1, n + 1): for j in range(1, m + 1): if arr1[i-1] == arr2[j-1]: dp[i][j] = dp[i-1][j-1] + arr1[i-1] max_sum = max(max_sum, dp[i][j]) else: dp[i][j] = 0 return max_sum"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string, return the length of the longest substring without repeating characters. If the input string is empty or null, return \`0\`. >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(None) 0 >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcdefgh\\") 8 >>> length_of_longest_substring(\\"abba\\") 2 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"aabacb\\") 3 >>> length_of_longest_substring(\\"!@#^!@#^\\") 4","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. if s is None or len(s) == 0: return 0 char_index_map = {} max_len = 0 start = 0 for idx, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = idx max_len = max(max_len, idx - start + 1) return max_len"},{"question":"def max_binary_gap(N: int) -> int: Returns the length of the longest sequence of consecutive zeros that is surrounded by ones in the binary representation of a positive integer N. >>> max_binary_gap(9) 2 >>> max_binary_gap(529) 4 >>> max_binary_gap(20) 1 >>> max_binary_gap(15) 0 >>> max_binary_gap(1) 0 >>> max_binary_gap(1041) 5 >>> max_binary_gap(328) 2 pass","solution":"def max_binary_gap(N): Returns the length of the longest sequence of consecutive zeros that is surrounded by ones in the binary representation of a positive integer N. binary_representation = bin(N)[2:] # Get binary representation of N without the '0b' prefix. max_gap = 0 current_gap = 0 in_gap = False for bit in binary_representation: if bit == '1': if in_gap: max_gap = max(max_gap, current_gap) current_gap = 0 in_gap = True elif in_gap: current_gap += 1 return max_gap"},{"question":"def find_significant_character(n: int, s: str) -> str: Determine if there exists any significant character in the given string. A significant character appears strictly more than half the total characters in the string. >>> find_significant_character(4, 'aabb') 'No significant character' >>> find_significant_character(5, 'aaaab') 'a' >>> find_significant_character(1, 'a') 'a' >>> find_significant_character(6, 'aaabbb') 'No significant character' >>> find_significant_character(7, 'aaaabbb') 'a' >>> find_significant_character(3, 'abc') 'No significant character' >>> find_significant_character(10, 'bbbbbabbbb') 'b' >>> find_significant_character(5, 'aaaaa') 'a'","solution":"def find_significant_character(n, s): Determine if there exists any significant character in the given string. A significant character appears strictly more than half the total characters in the string. Parameters: n (int): Length of the string s. s (str): The input string. Returns: str: The significant character or \\"No significant character\\" if no such character exists. from collections import Counter count = Counter(s) for char, freq in count.items(): if freq > n // 2: return char return \\"No significant character\\" # Example usage: # n, s = 5, 'aaaab' # print(find_significant_character(n, s)) # Output: a"},{"question":"def shift_sentence(sentence: str) -> str: Shifts the words in the sentence one place to the right, moving the last word to the first position. >>> shift_sentence(\\"Coding Assessments are fun to create\\") == \\"create Coding Assessments are fun to\\" >>> shift_sentence(\\"hello world\\") == \\"world hello\\" >>> shift_sentence(\\"one two three\\") == \\"three one two\\" >>> shift_sentence(\\"Python Programming Language\\") == \\"Language Python Programming\\" >>> shift_sentence(\\"shift shift shift\\") == \\"shift shift shift\\"","solution":"def shift_sentence(sentence: str) -> str: Shifts the words in the sentence one place to the right, with the last word moved to the first position. words = sentence.split() if len(words) <= 1: return sentence shifted_sentence = [words[-1]] + words[:-1] return ' '.join(shifted_sentence)"},{"question":"def sort_scrolls_with_positions(N, scroll_codes): Sort the scrolls based on their codes and maintain a record of original positions. Args: N : int : The number of scrolls. scroll_codes : List[int] : The codes of the scrolls in the order they are initially stored. Returns: List[int] : The list of original positions in the sorted order of scrolls. >>> sort_scrolls_with_positions(5, [42, 16, 23, 4, 8]) [4, 5, 2, 3, 1] >>> sort_scrolls_with_positions(1, [1]) [1]","solution":"def sort_scrolls_with_positions(N, scroll_codes): # Pair the scroll codes with their original positions indexed_scrolls = [(scroll_codes[i], i+1) for i in range(N)] # Sort the scrolls based on their codes indexed_scrolls.sort() # Extract the original positions in the new sorted order sorted_positions = [pos for code, pos in indexed_scrolls] return sorted_positions # Function to handle the input and output format def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) scroll_codes = [int(data[i+1]) for i in range(N)] sorted_positions = sort_scrolls_with_positions(N, scroll_codes) for pos in sorted_positions: print(pos)"},{"question":"def find_longest_zero_sum_subarray(n: int, array: List[int]) -> str: Find the longest contiguous subarray such that the sum of elements in the subarray is equal to zero. If no such subarray exists, return \\"NA\\". Parameters: n (int): Number of elements in the array. array (List[int]): The integers in the array. Returns: str: The longest contiguous subarray with zero sum or \\"NA\\". pass def process_input(input_text: str) -> str: Process multiple datasets of arrays and returns the longest contiguous subarray with zero sum for each dataset. Insert one blank line between the results of each dataset. Parameters: input_text (str): The input text containing multiple datasets. Returns: str: The results for each dataset separated by blank lines. pass import pytest def test_example_1(): input_text = \\"5n1 2 -2 4 -4n\\" expected_output = \\"2 -2 4 -4\\" assert process_input(input_text) == expected_output def test_example_2(): input_text = \\"6n3 1 -1 -3 2 4n\\" expected_output = \\"3 1 -1 -3\\" assert process_input(input_text) == expected_output def test_example_3(): input_text = \\"4n1 2 3 4n\\" expected_output = \\"NA\\" assert process_input(input_text) == expected_output def test_multiple_datasets(): input_text = \\"5n1 2 -2 4 -4n6n3 1 -1 -3 2 4n4n1 2 3 4n0n\\" expected_output = \\"2 -2 4 -4nn3 1 -1 -3nnNA\\" assert process_input(input_text) == expected_output def test_no_dataset(): input_text = \\"0n\\" expected_output = \\"\\" assert process_input(input_text) == expected_output def test_single_element_zero(): input_text = \\"1n0n\\" expected_output = \\"0\\" assert process_input(input_text) == expected_output def test_single_dataset_with_no_zero_sum_subarray(): input_text = \\"3n1 2 3n\\" expected_output = \\"NA\\" assert process_input(input_text) == expected_output","solution":"def find_longest_zero_sum_subarray(n, array): sum_indices = {} max_len = 0 max_subarray = None current_sum = 0 for i in range(n): current_sum += array[i] if current_sum == 0: max_len = i + 1 max_subarray = array[:i+1] if current_sum in sum_indices: subarray_len = i - sum_indices[current_sum] if subarray_len > max_len: max_len = subarray_len max_subarray = array[sum_indices[current_sum] + 1:i + 1] else: sum_indices[current_sum] = i if max_subarray is None: return \\"NA\\" else: return ' '.join(map(str, max_subarray)) def process_input(input_text): lines = input_text.strip().split('n') index = 0 results = [] while index < len(lines): n = int(lines[index].strip()) if n == 0: break index += 1 array = list(map(int, lines[index].strip().split())) result = find_longest_zero_sum_subarray(n, array) results.append(result) index += 1 return 'nn'.join(results)"},{"question":"def smallest_changes_to_mode(test_cases): Given a sequence of integers for multiple test cases, determine the smallest number of changes required to make all elements of the sequence equal to its mode. The mode of a sequence is the value that appears most frequently. If there are multiple values that appear with the same highest frequency, pick the smallest value among them. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing an integer n and a list of n integers. Returns: List[int]: A list of integers representing the smallest number of changes required for each test case. Examples: >>> smallest_changes_to_mode([(6, [1, 1, 2, 2, 2, 3]), (5, [4, 4, 4, 4, 4]), (4, [1, 2, 3, 4])]) [3, 0, 3] >>> smallest_changes_to_mode([(1, [1])]) [0] >>> smallest_changes_to_mode([(5, [1, 2, 3, 4, 5])]) [4] >>> smallest_changes_to_mode([(5, [2, 2, 2, 2, 2])]) [0] >>> smallest_changes_to_mode([(6, [1, 1, 2, 2, 3, 3]), (7, [1, 1, 1, 2, 2, 2, 3])]) [4, 4]","solution":"from collections import Counter def smallest_changes_to_mode(test_cases): results = [] for n, sequence in test_cases: counter = Counter(sequence) mode_count = max(counter.values()) changes_required = n - mode_count results.append(changes_required) return results"},{"question":"def min_operations_to_sort_array(n: int, arr: List[int]) -> int: Determine the minimum number of operations required to make the array non-decreasing, or state if it's impossible. Parameters: n (int): The number of elements in the array. arr (list of int): A list of integers representing the array. Returns: int: The minimum number of operations required or -1 if it's impossible. Examples: >>> min_operations_to_sort_array(4, [4, 3, 2, 1]) 3 >>> min_operations_to_sort_array(3, [1, 0, -1]) -1","solution":"def min_operations_to_sort_array(n, arr): Determines the minimum number of operations required to make the array non-decreasing. Parameters: n (int): The number of elements in the array. arr (list): A list of integers representing the array. Returns: int: Minimum number of operations or -1 if it's impossible. sorted_arr = sorted(arr) # Check if it's possible to sort arr into non-decreasing order if sorted_arr == arr: return 0 # If there are any negative values in arr, it's impossible if any(x < 0 for x in arr): return -1 # To calculate the number of operations: count = 0 for i in range(n - 1): if arr[i] > arr[i + 1]: count += 1 return count"},{"question":"def maxNonOverlappingReservations(reservations): Determine the maximum number of non-overlapping reservations that can be accommodated in the booking system. >>> maxNonOverlappingReservations([(1, 3, \\"A\\"), (2, 4, \\"A\\"), (3, 5, \\"A\\"), (1, 2, \\"B\\"), (3, 4, \\"B\\")]) 4 >>> maxNonOverlappingReservations([(1, 2, \\"A\\"), (2, 3, \\"A\\"), (3, 4, \\"A\\"), (4, 5, \\"A\\")]) 4","solution":"def maxNonOverlappingReservations(reservations): from collections import defaultdict rooms = defaultdict(list) # Group reservations by room for start, end, room in reservations: rooms[room].append((start, end)) def count_non_overlapping(bookings): # Sort by end time bookings.sort(key=lambda x: x[1]) count = 0 last_end = float('-inf') for start, end in bookings: if start >= last_end: count += 1 last_end = end return count total_non_overlapping = 0 # Calculate non-overlapping reservations for each room for room, bookings in rooms.items(): total_non_overlapping += count_non_overlapping(bookings) return total_non_overlapping"},{"question":"def highest_triplet_sum(nums): Returns the sum of the three highest numbers in the list. If the list has fewer than three integers, return the sum of all the integers in the list. >>> highest_triplet_sum([3, 5, 1, 9]) -> 17 >>> highest_triplet_sum([10, 2, 3]) -> 15 >>> highest_triplet_sum([7]) -> 7 >>> highest_triplet_sum([6, 8]) -> 14","solution":"def highest_triplet_sum(nums): Returns the sum of the three highest numbers in the list. If the list has fewer than three integers, return the sum of all the integers in the list. if len(nums) < 3: return sum(nums) else: nums.sort(reverse=True) return sum(nums[:3])"},{"question":"def max_area_of_island(grid): Returns the maximum area of any island in the grid. >>> max_area_of_island([ ['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','0','1','1'], ['0','0','0','1','1'] ]) 4 >>> max_area_of_island([ ['1','1','1'], ['0','1','0'], ['1','1','1'] ]) 7","solution":"def max_area_of_island(grid): Returns the maximum area of any island in the grid. if not grid: return 0 def dfs(grid, row, col): if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == '0': return 0 grid[row][col] = '0' # Mark as visited area = 1 # Count the current cell # Move in all four directions area += dfs(grid, row + 1, col) area += dfs(grid, row - 1, col) area += dfs(grid, row, col + 1) area += dfs(grid, row, col - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': max_area = max(max_area, dfs(grid, i, j)) return max_area"},{"question":"def find_nth_term(N: int) -> int: Returns the N-th term of the sequence defined by: T(i) = T(i-1) + T(i-2) + T(i-3) for i > 2, with initial terms T(0) = 1, T(1) = 1, and T(2) = 2. >>> find_nth_term(4) 7 >>> find_nth_term(7) 44 >>> find_nth_term(0) 1 >>> find_nth_term(1) 1 >>> find_nth_term(2) 2","solution":"def find_nth_term(N): Returns the N-th term of the sequence defined by: T(i) = T(i-1) + T(i-2) + T(i-3) for i > 2, with initial terms T(0) = 1, T(1) = 1, and T(2) = 2. if N == 0: return 1 elif N == 1: return 1 elif N == 2: return 2 T = [1, 1, 2] for i in range(3, N + 1): T.append(T[i-1] + T[i-2] + T[i-3]) return T[N]"},{"question":"def maxSubArraySum(nums): Returns the largest sum of the contiguous subarray. Uses Kadane's Algorithm to find the maximum sum subarray efficiently. >>> maxSubArraySum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> maxSubArraySum([1]) 1 >>> maxSubArraySum([5,4,-1,7,8]) 23 >>> maxSubArraySum([-1,-2,-3,-4]) -1","solution":"def maxSubArraySum(nums): Returns the largest sum of the contiguous subarray. Uses Kadane's Algorithm to find the maximum sum subarray efficiently. if not nums: return 0 # if the array is empty max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def find_winners(N: int, T: int, rates: List[int], times: List[int]) -> List[int]: Determine the winners for each round of the competition. Args: N (int): The number of students. T (int): The number of rounds. rates (List[int]): A list of integers where the i-th integer indicates the problem-solving rate of the i-th student. times (List[int]): A list of integers where the j-th integer indicates the time allocated for the j-th round. Returns: List[int]: A list of integers where the i-th integer is the 1-based index of the student who wins the i-th round. >>> find_winners(4, 3, [5, 3, 7, 2], [10, 5, 7]) [3, 3, 3] >>> find_winners(3, 2, [4, 5, 6], [10, 20]) [3, 3] >>> find_winners(1, 3, [8], [3, 6, 9]) [1, 1, 1] >>> find_winners(4, 1, [5, 5, 5, 5], [5]) [1] >>> find_winners(2, 1, [1, 2], [1000]) [2]","solution":"def find_winners(N, T, rates, times): winners = [] for time in times: max_problems = -1 winner_index = -1 for i in range(N): problems_solved = rates[i] * time if problems_solved > max_problems: max_problems = problems_solved winner_index = i + 1 # 1-based index winners.append(winner_index) return winners"},{"question":"from typing import List def groupAnagrams(strs: List[str]) -> List[List[str]]: Given an array of strings, group the anagrams together. >>> groupAnagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> groupAnagrams([\\"hello\\"]) [['hello']] >>> groupAnagrams([\\"apple\\", \\"banana\\", \\"carrot\\"]) [['apple'], ['banana'], ['carrot']] >>> groupAnagrams([\\"abc\\", \\"bca\\", \\"cab\\"]) [['abc', 'bca', 'cab']] >>> groupAnagrams([]) []","solution":"from collections import defaultdict def groupAnagrams(strs): Groups anagrams together from the input list of strings. Args: strs (list of str): List of strings which needs to be grouped into anagrams. Returns: List of lists: A list where each sublist contains anagrams grouped together. # Dictionary to map sorted character tuple to list of anagrams anagram_map = defaultdict(list) for string in strs: # Sort the string and use it as a key sorted_str = tuple(sorted(string)) anagram_map[sorted_str].append(string) # Return the grouped anagrams as a list of lists return list(anagram_map.values())"},{"question":"from typing import List def process_enrollments(input_data: str) -> str: Processes a list of student enrollments and queries, and outputs the result of each query. The input_data string contains multiple lines where the first line is the number of enrollments, followed by enrollments in the format 'student_id course_code semester'. After that, the number of queries is specified, followed by the queries. :param input_data: A multi-line string representing enrollments and queries. :return: A string with the results of the queries, each result on a new line. Example: >>> input_data = '''5 ... 101 CS101 Fall2022 ... 102 CS102 Fall2022 ... 101 MA101 Fall2022 ... 103 CS101 Fall2022 ... 101 PH101 Spring2023 ... 3 ... 1 101 ... 2 CS101 Fall2022 ... 2 MA101 Spring2023''' >>> print(process_enrollments(input_data)) CS101 MA101 PH101 101 103 None >>> input_data = '''3 ... 101 CS101 Fall2022 ... 102 CS102 Fall2022 ... 101 MA101 Fall2022 ... 2 ... 2 CS103 Fall2022 ... 2 MA101 Spring2023''' >>> print(process_enrollments(input_data)) None None","solution":"def process_enrollments(input_data): lines = input_data.strip().split('n') n = int(lines[0]) enrollments = [] for i in range(1, n + 1): enrollments.append(lines[i].split()) q_index = n + 1 q = int(lines[q_index]) queries = [] for i in range(q_index + 1, q_index + 1 + q): queries.append(lines[i].split()) student_courses = {} course_students = {} for student_id, course_code, semester in enrollments: if student_id not in student_courses: student_courses[student_id] = [] student_courses[student_id].append(course_code) key = (course_code, semester) if key not in course_students: course_students[key] = [] course_students[key].append(student_id) results = [] for query in queries: if query[0] == '1': student_id = query[1] result = ' '.join(student_courses.get(student_id, [])) results.append(result if result else 'None') elif query[0] == '2': course_code, semester = query[1], query[2] result = ' '.join(course_students.get((course_code, semester), [])) results.append(result if result else 'None') return 'n'.join(results)"},{"question":"def process_events(events, queries): Processes a sequence of event strings and handles filter and sort queries. The function supports the following operations: - filter(item): returns all events that contain the given item. - sort(): returns all events, sorted alphabetically by the first item in each event. Args: events (List[str]): A list of event strings, each containing a comma-separated list of items. queries (List[str]): A list of queries in the form of \\"filter(item)\\" or \\"sort()\\". Returns: List[str]: A list of resulting events for each query, including separation between different query results. Example: >>> events = [\\"apple,banana,carrot\\", \\"banana,apple\\", \\"carrot,mango,apple\\", \\"banana,carrot\\"] >>> queries = [\\"filter(apple)\\", \\"sort()\\"] >>> process_events(events, queries) [\\"apple,banana,carrot\\", \\"banana,apple\\", \\"carrot,mango,apple\\", \\"\\", \\"apple,banana,carrot\\", \\"banana,apple\\", \\"banana,carrot\\", \\"carrot,mango,apple\\", \\"\\"] pass from solution import process_events def test_filter_single_item(): events = [\\"apple,banana,carrot\\", \\"banana,apple\\", \\"carrot,mango,apple\\", \\"banana,carrot\\"] queries = [\\"filter(apple)\\"] expected_output = [\\"apple,banana,carrot\\", \\"banana,apple\\", \\"carrot,mango,apple\\", \\"\\"] assert process_events(events, queries) == expected_output def test_sort_events(): events = [\\"apple,banana,carrot\\", \\"banana,apple\\", \\"carrot,mango,apple\\", \\"banana,carrot\\"] queries = [\\"sort()\\"] expected_output = [\\"apple,banana,carrot\\", \\"banana,apple\\", \\"banana,carrot\\", \\"carrot,mango,apple\\", \\"\\"] assert process_events(events, queries) == expected_output def test_filter_and_sort(): events = [\\"apple,banana,carrot\\", \\"banana,apple\\", \\"carrot,mango,apple\\", \\"banana,carrot\\"] queries = [\\"filter(apple)\\", \\"sort()\\"] expected_output = [\\"apple,banana,carrot\\", \\"banana,apple\\", \\"carrot,mango,apple\\", \\"\\", \\"apple,banana,carrot\\", \\"banana,apple\\", \\"banana,carrot\\", \\"carrot,mango,apple\\", \\"\\"] assert process_events(events, queries) == expected_output","solution":"def process_events(events, queries): def filter_events(item, events): return [event for event in events if item in event.split(',')] def sort_events(events): return sorted(events, key=lambda e: e.split(',')[0]) results = [] for query in queries: if query.startswith(\\"filter(\\"): item = query[len(\\"filter(\\"):-1] result = filter_events(item, events) elif query == \\"sort()\\": result = sort_events(events) results.extend(result) results.append(\\"\\") # To separate result sets return results def main(input_lines): m = int(input_lines[0]) events = input_lines[1:m+1] q = int(input_lines[m+1]) queries = input_lines[m+2:m+2+q] results = process_events(events, queries) for result in results: if result: print(result)"},{"question":"import hashlib from typing import List def generate_unique_codes(n: int, keyword: str, k: int) -> List[str]: Generate unique alphanumeric codes for students given their count, a keyword, and desired code length. :param n: Total number of students. :param keyword: Secret keyword to be concatenated with student ID before hashing. :param k: Length of the required alphanumeric code. :return: A list of unique alphanumeric codes. >>> generate_unique_codes(3, \\"secretcode\\", 8) ['e74c037c', '5b06882b', 'b1b2a2ba']","solution":"import hashlib def generate_unique_codes(n, keyword, k): Generate unique alphanumeric codes for students given a keyword and desired code length. :param n: Total number of students. :param keyword: Secret keyword to be concatenated with student ID before hashing. :param k: Length of the required alphanumeric code. :return: A list of unique alphanumeric codes. codes = [] for i in range(1, n + 1): # Concatenate keyword with student's identifier concatenated_str = f\\"{keyword}{i}\\" # Calculate the SHA-256 hash of the concatenated string hash_digest = hashlib.sha256(concatenated_str.encode()).hexdigest() # Take the first k characters of the hash digest as the unique code unique_code = hash_digest[:k] codes.append(unique_code) return codes"},{"question":"def robotPosition(commands: str) -> tuple[int, int]: Given a string representing the sequence of commands, returns the final position of the robot as a tuple (x, y), where x and y are the coordinates. >>> robotPosition(\\"UUR\\") == (1, 2) >>> robotPosition(\\"LDRU\\") == (0, 0) >>> robotPosition(\\"RRDD\\") == (2, -2) >>> robotPosition(\\"UUU\\") == (0, 3) >>> robotPosition(\\"\\") == (0, 0) # Initialize starting position x, y = 0, 0 # Process each command in the string for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 # Return the final position return x, y def test_robotPosition_no_moves(): assert robotPosition(\\"\\") == (0, 0) def test_robotPosition_up_moves(): assert robotPosition(\\"UUU\\") == (0, 3) assert robotPosition(\\"UUUU\\") == (0, 4) def test_robotPosition_down_moves(): assert robotPosition(\\"DDD\\") == (0, -3) assert robotPosition(\\"DDDD\\") == (0, -4) def test_robotPosition_left_moves(): assert robotPosition(\\"LLL\\") == (-3, 0) assert robotPosition(\\"LLLL\\") == (-4, 0) def test_robotPosition_right_moves(): assert robotPosition(\\"RRR\\") == (3, 0) assert robotPosition(\\"RRRR\\") == (4, 0) def test_robotPosition_mixed_moves(): assert robotPosition(\\"UUR\\") == (1, 2) assert robotPosition(\\"LDRU\\") == (0, 0) assert robotPosition(\\"RRDD\\") == (2, -2) assert robotPosition(\\"UUDDLLRR\\") == (0, 0)","solution":"def robotPosition(commands): Returns the final position of the robot (x, y) after executing the given commands. # Initialize starting position x, y = 0, 0 # Process each command in the string for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 # Return the final position return x, y"},{"question":"def calculate_total_cost(items, shopping_list) -> float: Calculates the total cost of the shopping list applying discounts from the items list. Parameters: - items (list of tuples): (item_id, price, discount_type, discount_param) - shopping_list (list of tuples): (item_id, quantity) Returns: - float: total cost after applying discounts Example: >>> items = [ ... ('apple', 1.0, 'NONE', 0.0), ... ('banana', 2.0, 'BOGO', 0.0), ... ('orange', 1.5, 'BTGO', 0.0), ... ('grape', 3.0, 'PERCENT', 20.0) ... ] >>> shopping_list = [ ... ('apple', 3), ... ('banana', 4), ... ('orange', 5), ... ('grape', 6) ... ] >>> calculate_total_cost(items, shopping_list) 27.4 pass # Unit Test: def test_calculate_total_cost_no_discounts(): items = [ ('apple', 1.0, 'NONE', 0.0), ] shopping_list = [ ('apple', 3), ] assert calculate_total_cost(items, shopping_list) == 3.0 def test_calculate_total_cost_bogo_discount(): items = [ ('banana', 2.0, 'BOGO', 0.0), ] shopping_list = [ ('banana', 4), ] assert calculate_total_cost(items, shopping_list) == 4.0 def test_calculate_total_cost_btgo_discount(): items = [ ('orange', 1.5, 'BTGO', 0.0), ] shopping_list = [ ('orange', 5), ] assert calculate_total_cost(items, shopping_list) == 6.0 def test_calculate_total_cost_percent_discount(): items = [ ('grape', 3.0, 'PERCENT', 20.0), ] shopping_list = [ ('grape', 6), ] assert calculate_total_cost(items, shopping_list) == 14.4 def test_calculate_total_cost_mixed_discounts(): items = [ ('apple', 1.0, 'NONE', 0.0), ('banana', 2.0, 'BOGO', 0.0), ('orange', 1.5, 'BTGO', 0.0), ('grape', 3.0, 'PERCENT', 20.0) ] shopping_list = [ ('apple', 3), ('banana', 4), ('orange', 5), ('grape', 6) ] assert calculate_total_cost(items, shopping_list) == 27.4","solution":"def calculate_total_cost(items, shopping_list) -> float: Calculates the total cost of the shopping list applying discounts from the items list. Parameters: - items (list of tuples): (item_id, price, discount_type, discount_param) - shopping_list (list of tuples): (item_id, quantity) Returns: - float: total cost after applying discounts # Creating a dictionary for easy lookup of item details item_info = {item_id: (price, discount_type, discount_param) for item_id, price, discount_type, discount_param in items} total_cost = 0.0 for item_id, quantity in shopping_list: if item_id in item_info: price, discount_type, discount_param = item_info[item_id] if discount_type == 'NONE': total_cost += price * quantity elif discount_type == 'BOGO': # Buy One Get One Free total_cost += price * (quantity // 2 + quantity % 2) elif discount_type == 'BTGO': # Buy Two Get One Free total_cost += price * (2 * (quantity // 3) + (quantity % 3)) elif discount_type == 'PERCENT': # Bulk percentage discount percentage_discount = discount_param / 100.0 total_cost += price * quantity * (1 - percentage_discount) return round(total_cost, 2)"},{"question":"def count_divisibles(T: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: For each test case, calculate the count of numbers in the range [a, b] which are divisible by N. :param T: Number of test cases :param test_cases: List of tuples where each tuple contains (N, a, b) :return: List of integers, where each integer is the count of numbers divisible by N in range [a, b] >>> count_divisibles(2, [(3, 1, 10), (5, 5, 30)]) [3, 6] >>> count_divisibles(1, [(7, 8, 14)]) [1] >>> count_divisibles(1, [(2, 2, 10)]) [5] >>> count_divisibles(1, [(1, 1, 100)]) [100] >>> count_divisibles(1, [(100, 1, 1000000000)]) [10000000]","solution":"def count_divisibles(T, test_cases): For each test case, calculates the count of numbers in the range [a, b] which are divisible by N. :param T: Number of test cases :param test_cases: List of tuples where each tuple contains (N, a, b) :return: List of integers, where each integer is the count of numbers divisible by N in range [a, b] results = [] for N, a, b in test_cases: # Number of divisible elements from 1 to b count_b = b // N # Number of divisible elements from 1 to a-1 count_a_minus_1 = (a-1) // N # The number of elements that are divisible by N in range [a, b] count = count_b - count_a_minus_1 results.append(count) return results"},{"question":"def edit_distance(s1: str, s2: str) -> int: Compute the minimum number of operations required to transform s1 into s2. The allowed operations are insert a character, delete a character, or replace a character. >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"flaw\\", \\"lawn\\") 2","solution":"def edit_distance(s1, s2): Compute the minimum number of operations required to transform s1 into s2. The allowed operations are insert a character, delete a character, or replace a character. Parameters: s1 (str): The source string. s2 (str): The target string. Returns: int: The minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) # Create a (m+1) x (n+1) matrix to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize base cases for i in range(m + 1): dp[i][0] = i # minimum operations to convert s1[0:i] to empty string is i (all deletions) for j in range(n + 1): dp[0][j] = j # minimum operations to convert empty string to s2[0:j] is j (all insertions) # Fill the dp matrix for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # deletion dp[i][j - 1], # insertion dp[i - 1][j - 1] # replacement ) return dp[m][n] # Example usage print(edit_distance(\\"kitten\\", \\"sitting\\")) # Output: 3 print(edit_distance(\\"flaw\\", \\"lawn\\")) # Output: 2"},{"question":"def can_schedule_deliveries(r, p, time_windows, capacities): Determines if it is possible to schedule all deliveries such that no restaurant gets fish outside its preferred time window and no port exceeds its delivery capacity at any time. :param r: Number of restaurants :param p: Number of ports :param time_windows: List of tuple (start, end) representing preferred time windows for each restaurant :param capacities: List of integers representing capacity of each port :return: \\"Yes\\" if possible to schedule, otherwise \\"No\\" pass import pytest def test_case_1(): r = 3 p = 2 time_windows = [(300, 600), (700, 1000), (1200, 1300)] capacities = [2, 1] assert can_schedule_deliveries(r, p, time_windows, capacities) == \\"Yes\\" def test_case_2(): r = 4 p = 1 time_windows = [(0, 240), (500, 750), (900, 1100), (1300, 1400)] capacities = [1] assert can_schedule_deliveries(r, p, time_windows, capacities) == \\"No\\" def test_case_3(): r = 1 p = 1 time_windows = [(0, 1440)] capacities = [1] assert can_schedule_deliveries(r, p, time_windows, capacities) == \\"Yes\\" def test_case_4(): r = 5 p = 2 time_windows = [(0, 200), (250, 500), (600, 700), (800, 1000), (1100, 1200)] capacities = [3, 2] assert can_schedule_deliveries(r, p, time_windows, capacities) == \\"Yes\\" def test_case_5(): r = 3 p = 3 time_windows = [(300, 600), (600, 800), (800, 1000)] capacities = [1, 1, 1] assert can_schedule_deliveries(r, p, time_windows, capacities) == \\"Yes\\" pytest.main()","solution":"def can_schedule_deliveries(r, p, time_windows, capacities): Determines if it is possible to schedule all deliveries such that no restaurant gets fish outside its preferred time window and no port exceeds its delivery capacity at any time. :param r: Number of restaurants :param p: Number of ports :param time_windows: List of tuple (start, end) representing preferred time windows for each restaurant :param capacities: List of integers representing capacity of each port :return: \\"Yes\\" if possible to schedule, otherwise \\"No\\" # Sort time windows based on the end time time_windows.sort(key=lambda x: x[1]) # Sort capacities in decreasing order capacities.sort(reverse=True) for start, end in time_windows: delivery_done = False for idx in range(len(capacities)): if capacities[idx] > 0: delivery_done = True capacities[idx] -= 1 break if not delivery_done: return \\"No\\" return \\"Yes\\""},{"question":"def minimum_unallocated_passengers(n: int, capacities: List[int], demands: List[int]) -> int: Calculate the minimum unallocated passengers given the capacities and demands. :param n: int: Number of bus lines :param capacities: List[int]: List of integers representing the maximum capacities of the bus lines :param demands: List[int]: List of integers representing the daily passenger demands for each bus line :return: int: The minimum number of unallocated passengers >>> minimum_unallocated_passengers(3, [50, 60, 70], [80, 30, 40]) 30 >>> minimum_unallocated_passengers(5, [100, 80, 120, 60, 90], [60, 80, 150, 50, 110]) 50 >>> minimum_unallocated_passengers(4, [30, 20, 40, 10], [25, 35, 15, 5]) 15 >>> minimum_unallocated_passengers(3, [50, 60, 70], [40, 50, 60]) 0 >>> minimum_unallocated_passengers(2, [10, 20], [30, 40]) 40 >>> minimum_unallocated_passengers(2, [1000000000, 1000000000], [999999999, 2000000000]) 1000000000","solution":"def minimum_unallocated_passengers(n, capacities, demands): Calculate the minimum unallocated passengers given the capacities and demands. :param n: int: Number of bus lines :param capacities: List[int]: List of integers representing the maximum capacities of the bus lines :param demands: List[int]: List of integers representing the daily passenger demands for each bus line :return: int: The minimum number of unallocated passengers unallocated_passengers = 0 for i in range(n): if demands[i] > capacities[i]: unallocated_passengers += demands[i] - capacities[i] return unallocated_passengers"},{"question":"def shortest_subarray_length(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Find the length of the shortest continuous subarray such that the sum of the elements of this subarray is at least k. If no such subarray exists, return -1. :param t: Number of test cases :param test_cases: List of tuples, each containing: - an integer n (the length of the array), - an integer k (the required sum), - a list of integers (the elements of the array) :return: A list of integers representing the length of the shortest continuous subarray with sum at least k for each test case. >>> shortest_subarray_length(2, [(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), (5, 100, [1, 2, 3, 4, 5])]) [2, -1]","solution":"def shortest_subarray_length(t, test_cases): results = [] for test_case in test_cases: n, k, array = test_case start = 0 current_sum = 0 min_length = float('inf') for end in range(n): current_sum += array[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= array[start] start += 1 if min_length == float('inf'): results.append(-1) else: results.append(min_length) return results"},{"question":"def sequence_length(steps): Calculate the length of the sequence after each step. Steps: - (1, x, f): Add number x to the sequence f times. - (2, p, q): Repeat the first p elements q times and add to the sequence. Args: steps (List[Tuple[int, int, int]]): A list of tuples representing the steps. Returns: List[int]: A list of integers representing the sequence length after each step. >>> sequence_length([(1, 2, 3), (1, 3, 2), (2, 5, 1), (1, 1, 4), (2, 10, 4)]) [3, 5, 10, 14, 54] >>> sequence_length([(1, 5, 2)]) [2] >>> sequence_length([(1, 4, 1), (2, 1, 3)]) [1, 4] >>> sequence_length([(1, 1, 1), (1, 2, 1), (1, 3, 1), (2, 3, 2)]) [1, 2, 3, 9] >>> sequence_length([(1, 1, 100000), (2, 100000, 2)]) [100000, 300000] >>> sequence_length([]) []","solution":"def sequence_length(steps): sequence = [] lengths = [] for step in steps: if step[0] == 1: x, f = step[1], step[2] sequence.extend([x] * f) elif step[0] == 2: p, q = step[1], step[2] segment = sequence[:p] sequence.extend(segment * q) lengths.append(len(sequence)) return lengths # Example usage steps = [ (1, 2, 3), (1, 3, 2), (2, 5, 1), (1, 1, 4), (2, 10, 4) ] print(sequence_length(steps)) # Output should be [3, 5, 10, 14, 54]"},{"question":"def isAnagramSubstring(s1: str, s2: str) -> bool: Determines if an anagram of s2 exists as a substring in s1. :param s1: The main string :param s2: The string for which we have to check if an anagram exists as a substring in s1 :return: True if there is an anagram of s2 in s1, otherwise False >>> isAnagramSubstring(\\"abcthesisawesome\\", \\"cba\\") True >>> isAnagramSubstring(\\"hello\\", \\"world\\") False","solution":"from collections import Counter def isAnagramSubstring(s1, s2): Determines if an anagram of s2 exists as a substring in s1. :param s1: The main string :param s2: The string for which we have to check if an anagram exists as a substring in s1 :return: True if there is an anagram of s2 in s1, otherwise False len_s1, len_s2 = len(s1), len(s2) # If s2 is longer than s1, it's not possible for s1 to contain an anagram of s2 if len_s2 > len_s1: return False # Count characters in s2 s2_count = Counter(s2) # Initial window in s1 of size len_s2 window_count = Counter(s1[:len_s2]) # Check the initial window if window_count == s2_count: return True # Slide window across s1 for i in range(1, len_s1 - len_s2 + 1): # Remove the character that goes out of the window from the count window_count[s1[i - 1]] -= 1 if window_count[s1[i - 1]] == 0: del window_count[s1[i - 1]] # Add the new character that enters the window to the count window_count[s1[i + len_s2 - 1]] += 1 # Compare window with s2 count if window_count == s2_count: return True # If no anagram found in the entire string return False"},{"question":"def rotateMatrix(matrix): Rotates the input matrix in place by 90 degrees clockwise. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotateMatrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotateMatrix(matrix) >>> matrix [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]","solution":"def rotateMatrix(matrix): Rotates the input matrix in place by 90 degrees clockwise. if not matrix: return m, n = len(matrix), len(matrix[0]) # Transpose the matrix (rows become columns) for i in range(m): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(m): matrix[i].reverse()"},{"question":"def min_water_sources(r: int, c: int, k: int, altitudes: List[List[int]]) -> int: Determine the minimum number of water sources needed to ensure every cell in the grid can either directly receive water or receive it from an adjoining cell where the altitude difference is <= k. Args: r (int): Number of rows in the grid. c (int): Number of columns in the grid. k (int): The altitude threshold. altitudes (List[List[int]]): The altitude values for each cell in the grid. Returns: int: Minimum number of water sources needed. Examples: >>> min_water_sources(3, 4, 2, [[1, 3, 2, 4], [6, 5, 2, 3], [9, 1, 2, 5]]) 2 >>> min_water_sources(1, 1, 0, [[0]]) 1 >>> min_water_sources(2, 2, 0, [[1, 1], [1, 1]]) 1 >>> min_water_sources(2, 2, 1, [[1, 1000], [1000, 1]]) 4 >>> min_water_sources(2, 2, 10, [[1, 11], [11, 1]]) 1 pass # Unit Test cases def test_example_case(): r = 3 c = 4 k = 2 altitudes = [ [1, 3, 2, 4], [6, 5, 2, 3], [9, 1, 2, 5] ] assert min_water_sources(r, c, k, altitudes) == 2 def test_single_cell(): r = 1 c = 1 k = 0 altitudes = [ [0] ] assert min_water_sources(r, c, k, altitudes) == 1 def test_all_equal_altitudes(): r = 2 c = 2 k = 0 altitudes = [ [1, 1], [1, 1] ] assert min_water_sources(r, c, k, altitudes) == 1 def test_large_altitude_difference(): r = 2 c = 2 k = 1 altitudes = [ [1, 1000], [1000, 1] ] assert min_water_sources(r, c, k, altitudes) == 4 def test_diagonal_reach(): r = 2 c = 2 k = 10 altitudes = [ [1, 11], [11, 1] ] assert min_water_sources(r, c, k, altitudes) == 1","solution":"def min_water_sources(r, c, k, altitudes): from collections import deque def bfs(start_x, start_y, visited): queue = deque() queue.append((start_x, start_y)) visited[start_x][start_y] = True directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < r and 0 <= ny < c and not visited[nx][ny]: if abs(altitudes[nx][ny] - altitudes[x][y]) <= k: visited[nx][ny] = True queue.append((nx, ny)) visited = [[False] * c for _ in range(r)] source_count = 0 for i in range(r): for j in range(c): if not visited[i][j]: bfs(i, j, visited) source_count += 1 return source_count # Example input r = 3 c = 4 k = 2 altitudes = [ [1, 3, 2, 4], [6, 5, 2, 3], [9, 1, 2, 5] ] print(min_water_sources(r, c, k, altitudes)) # Output: 2"},{"question":"def longest_increasing_subsequence(heights): Returns the length of the longest strictly increasing subsequence of heights. >>> longest_increasing_subsequence([5, 1, 6, 2, 3, 7]) == 4 >>> longest_increasing_subsequence([10, 9, 2, 5]) == 2 >>> longest_increasing_subsequence([4]) == 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence([3, 4, 2, 8, 10, 5, 1]) == 4 >>> longest_increasing_subsequence([1, 3, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence([]) == 0 pass","solution":"def longest_increasing_subsequence(heights): Returns the length of the longest strictly increasing subsequence of heights. if not heights: return 0 # Initialize dp array where dp[i] will be the length of LIS ending at position i dp = [1] * len(heights) # Compute LIS for each element for i in range(1, len(heights)): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List, Tuple def min_rounds_to_equal_strings(a: str, b: str) -> int: Returns the minimum number of rounds required to make strings \`a\` and \`b\` identical. Parameters: a (str): The first string. b (str): The second string. Returns: int: The number of changes needed. >>> min_rounds_to_equal_strings(\\"abc\\", \\"abd\\") 1 >>> min_rounds_to_equal_strings(\\"xyz\\", \\"xya\\") 1 >>> min_rounds_to_equal_strings(\\"apple\\", \\"apric\\") 3 pass def process_multiple_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Processes multiple test cases to determine the number of rounds needed for each. Parameters: test_cases (list of tuple): List containing test case string pairs. Returns: list: List of integers representing the number of changes for each test case. >>> process_multiple_cases([(\\"abc\\", \\"abd\\"), (\\"xyz\\", \\"xya\\"), (\\"apple\\", \\"apric\\")]) [1, 1, 3] pass def test_min_rounds_to_equal_strings(): assert min_rounds_to_equal_strings(\\"abc\\", \\"abd\\") == 1 assert min_rounds_to_equal_strings(\\"xyz\\", \\"xya\\") == 1 assert min_rounds_to_equal_strings(\\"apple\\", \\"apric\\") == 3 assert min_rounds_to_equal_strings(\\"same\\", \\"same\\") == 0 assert min_rounds_to_equal_strings(\\"a\\", \\"b\\") == 1 def test_process_multiple_cases(): test_cases = [ (\\"abc\\", \\"abd\\"), (\\"xyz\\", \\"xya\\"), (\\"apple\\", \\"apric\\"), (\\"foo\\", \\"bar\\"), (\\"ping\\", \\"pong\\") ] expected_results = [1, 1, 3, 3, 1] assert process_multiple_cases(test_cases) == expected_results def test_edge_cases(): assert min_rounds_to_equal_strings(\\"a\\" * 1000, \\"b\\" * 1000) == 1000 assert min_rounds_to_equal_strings(\\"a\\" * 1000, \\"a\\" * 1000) == 0 assert min_rounds_to_equal_strings(\\"abcd\\", \\"abcf\\") == 1 assert min_rounds_to_equal_strings(\\"a\\"*999+\\"b\\", \\"a\\"*999+\\"c\\") == 1","solution":"def min_rounds_to_equal_strings(a, b): Returns the minimum number of rounds required to make strings \`a\` and \`b\` identical. Parameters: a (str): The first string. b (str): The second string. Returns: int: The number of changes needed. return sum(char_a != char_b for char_a, char_b in zip(a, b)) def process_multiple_cases(test_cases): Processes multiple test cases to determine the number of rounds needed for each. Parameters: test_cases (list of tuple): List containing test case string pairs. Returns: list: List of integers representing the number of changes for each test case. results = [] for a, b in test_cases: results.append(min_rounds_to_equal_strings(a, b)) return results"},{"question":"def max_consecutive_sum(lst: List[int], k: int) -> int: Write a function that takes a list of integers and an integer \`k\` and returns the maximum sum of \`k\` consecutive elements in the list. If there are fewer than \`k\` elements in the list, the function should return 0. >>> max_consecutive_sum([1, 2, 3, 4, 5], 2) 9 >>> max_consecutive_sum([5, -1, 9, 3, 7], 3) 19 >>> max_consecutive_sum([1, 2], 3) 0","solution":"def max_consecutive_sum(lst, k): if len(lst) < k: return 0 max_sum = current_sum = sum(lst[:k]) for i in range(k, len(lst)): current_sum += lst[i] - lst[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def number_of_repairs_needed(n, m, edges): Determine the minimum number of operations needed to connect all cities. :param n: Number of cities :param m: Number of roads :param edges: List of tuples representing the roads between cities :return: Minimum number of roads needed to connect all cities >>> number_of_repairs_needed(5, 3, [(1, 2), (2, 3), (4, 5)]) 1 >>> number_of_repairs_needed(4, 2, [(1, 2), (3, 4)]) 1 >>> number_of_repairs_needed(3, 0, []) 2 >>> number_of_repairs_needed(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> number_of_repairs_needed(3, 0, []) 2 >>> number_of_repairs_needed(6, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> number_of_repairs_needed(100, 99, [(i, i+1) for i in range(1, 100)]) 0","solution":"def number_of_repairs_needed(n, m, edges): Determine the minimum number of operations needed to connect all cities. :param n: Number of cities :param m: Number of roads :param edges: List of tuples representing the roads between cities :return: Minimum number of roads needed to connect all cities from collections import defaultdict def dfs(node, visited, adj_list): visited[node] = True for neighbor in adj_list[node]: if not visited[neighbor]: dfs(neighbor, visited, adj_list) # Initialize adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Find the number of connected components visited = [False] * (n + 1) connected_components = 0 for i in range(1, n + 1): if not visited[i]: dfs(i, visited, adj_list) connected_components += 1 # Minimum number of operations needed to connect the entire graph return connected_components - 1"},{"question":"def parse_input(M: int, areas_info: List[str], V: int, volunteer_info: List[str]) -> Tuple[Dict[str, Set[int]], Dict[str, List[str]]]: Parse the input information to get areas and volunteers data >>> parse_input(2, [\\"Area1 1 2 3\\", \\"Area2 2 4\\"], 1, [\\"Vol1 Area1 Area2\\"]) ({\\"Area1\\": {1, 2, 3}, \\"Area2\\": {2, 4}}, {\\"Vol1\\": [\\"Area1\\", \\"Area2\\"]}) pass def max_unique_households(M: int, areas_info: List[str], V: int, volunteer_info: List[str]) -> int: Determine the maximum number of unique households served by optimally assigning volunteers to areas. >>> max_unique_households(3, [\\"Area1 1 2 3\\", \\"Area2 2 4\\", \\"Area3 5 6\\"], 2, [\\"Vol1 Area1 Area2\\", \\"Vol2 Area2 Area3\\"]) 6 >>> max_unique_households(2, [\\"North 1 2\\", \\"South 3 4 5\\"], 1, [\\"Helper1 North South\\"]) 5 pass","solution":"from itertools import combinations def parse_input(M, areas_info, V, volunteer_info): areas = {} # Dictionary to store areas and their households volunteers = {} # Dictionary to store volunteers and their coverage for area_info in areas_info: parts = area_info.split() area_name = parts[0] households = set(map(int, parts[1:])) areas[area_name] = households for vol_info in volunteer_info: parts = vol_info.split() vol_name = parts[0] coverage = parts[1:] volunteers[vol_name] = coverage return areas, volunteers def max_unique_households(M, areas_info, V, volunteer_info): areas, volunteers = parse_input(M, areas_info, V, volunteer_info) all_volunteers = list(volunteers.keys()) max_households_covered = 0 for r in range(1, len(all_volunteers) + 1): for vol_combo in combinations(all_volunteers, r): covered_households = set() for vol in vol_combo: for area in volunteers[vol]: if area in areas: covered_households.update(areas[area]) max_households_covered = max(max_households_covered, len(covered_households)) return max_households_covered # Example usage M = 3 areas_info = [ \\"Area1 1 2 3\\", \\"Area2 2 4\\", \\"Area3 5 6\\" ] V = 2 volunteer_info = [ \\"Vol1 Area1 Area2\\", \\"Vol2 Area2 Area3\\" ] print(max_unique_households(M, areas_info, V, volunteer_info)) # Output: 6"},{"question":"def process_queries(n: int, m: int, q: int, grid: List[List[int]], queries: List[List[int]]) -> List[Union[int, str]]: Handle operations and queries on a grid. Args: n: Number of rows in the grid. m: Number of columns in the grid. q: Number of queries. grid: 2D list representing the grid. queries: List of queries to be processed. Returns: A list of results from the queries of type 2 and type 3. Queries can be of three types: - [1 X Y V] Set the value of the cell at (X, Y) to V. - [2 X1 Y1 X2 Y2] Find the maximum value in the sub-grid defined by (X1, Y1) and (X2, Y2). - [3 X] Check if all values in the X-th row are even, returns \\"Yes\\" or \\"No\\". # Unit Tests def test_process_queries(): n = 4 m = 4 q = 5 grid = [ [10, 20, 30, 40], [15, 25, 35, 45], [50, 60, 70, 80], [12, 22, 32, 42] ] queries = [ [2, 1, 1, 3, 3], [1, 2, 2, 99], [2, 1, 1, 3, 3], [3, 4], [3, 2] ] result = process_queries(n, m, q, grid, queries) assert result == [70, 99, \\"Yes\\", \\"No\\"] def test_modify_and_max_subgrid(): n = 2 m = 2 q = 3 grid = [ [5, 6], [7, 8] ] queries = [ [2, 1, 1, 2, 2], [1, 1, 1, 10], [2, 1, 1, 2, 2] ] result = process_queries(n, m, q, grid, queries) assert result == [8, 10] def test_all_even_rows(): n = 3 m = 3 q = 2 grid = [ [2, 4, 6], [1, 3, 5], [8, 10, 12] ] queries = [ [3, 1], [3, 2] ] result = process_queries(n, m, q, grid, queries) assert result == [\\"Yes\\", \\"No\\"]","solution":"def process_queries(n, m, q, grid, queries): results = [] for query in queries: if query[0] == 1: _, x, y, v = query grid[x-1][y-1] = v elif query[0] == 2: _, x1, y1, x2, y2 = query max_val = -1 for i in range(x1-1, x2): for j in range(y1-1, y2): if grid[i][j] > max_val: max_val = grid[i][j] results.append(max_val) elif query[0] == 3: _, x = query all_even = all(value % 2 == 0 for value in grid[x-1]) if all_even: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"import heapq def dijkstra(n, graph, start): Implements Dijkstra's algorithm to find the shortest paths from the start node to all other nodes. Args: n -- number of cities graph -- dictionary containing adjacency list of the graph start -- starting node Returns: A list where the value at index i represents the shortest distance from the start node to node i. distances = [float('inf')] * (n + 1) distances[start] = 0 priority_queue = [(0, start)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def solve(t, test_cases): Solve the shortest travel time problem for multiple test cases. Args: t - number of test cases test_cases - list of tuples, each containing: n - number of cities m - number of roads roads - list of tuples (u, v, w) representing roads between cities u and v with travel time w q - number of queries queries - list of tuples (x, y) representing queries asking for shortest travel time between cities x and y Returns: A list containing the shortest travel times for each query in all test cases. results = [] for case in test_cases: n, m, roads, q, queries = case graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Assuming undirected graph for x, y in queries: distances = dijkstra(n, graph, x) shortest_path = distances[y] if shortest_path == float('inf'): results.append(-1) else: results.append(shortest_path) return results # Unit tests def test_shortest_paths(): t = 1 test_cases = [ (4, 4, [(1, 2, 1), (2, 3, 1), (1, 3, 4), (3, 4, 1)], 2, [(1, 4), (2, 4)]) ] assert solve(t, test_cases) == [3, 2] def test_no_path(): t = 1 test_cases = [ (4, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 1)], 1, [(1, 4)]) ] assert solve(t, test_cases) == [3] def test_direct_path(): t = 1 test_cases = [ (3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 5)], 1, [(1, 3)]) ] assert solve(t, test_cases) == [2] def test_large_graph(): t = 1 n = 1000 m = 1000 roads = [(i, i+1, 1) for i in range(1, 1000)] test_cases = [ (n, m, roads, 1, [(1, 1000)]) ] assert solve(t, test_cases) == [999] def test_disconnected_graph(): t = 1 test_cases = [ (5, 2, [(1, 2, 1), (4, 5, 1)], 2, [(1, 5), (2, 4)]) ] assert solve(t, test_cases) == [-1, -1]","solution":"import heapq def dijkstra(n, graph, start): Implements Dijkstra's algorithm to find the shortest paths from the start node to all other nodes. Args: n -- number of cities graph -- dictionary containing adjacency list of the graph start -- starting node Returns: A list where the value at index i represents the shortest distance from the start node to node i. distances = [float('inf')] * (n + 1) distances[start] = 0 priority_queue = [(0, start)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def solve(t, test_cases): results = [] for case in test_cases: n, m, roads, q, queries = case graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Assuming undirected graph for x, y in queries: distances = dijkstra(n, graph, x) shortest_path = distances[y] if shortest_path == float('inf'): results.append(-1) else: results.append(shortest_path) return results"},{"question":"def max_sum_of_k_consecutive_elements(n, k, arr): Returns the maximum possible sum of k consecutive elements in the array. Parameters: - n: int, length of the array - k: int, number of consecutive elements to sum - arr: list of int, the array of integers Returns: - int, the maximum sum of k consecutive elements >>> max_sum_of_k_consecutive_elements(7, 3, [1, 2, 3, 4, 5, 6, 7]) 18 >>> max_sum_of_k_consecutive_elements(1, 1, [5]) 5 >>> max_sum_of_k_consecutive_elements(5, 2, [3, 3, 3, 3, 3]) 6 >>> max_sum_of_k_consecutive_elements(5, 2, [0, 0, 0, 0, 0]) 0 >>> max_sum_of_k_consecutive_elements(5, 3, [-1, -2, -3, -4, -5]) -6 >>> max_sum_of_k_consecutive_elements(6, 2, [1, -2, 3, -4, 5, 6]) 11 >>> max_sum_of_k_consecutive_elements(5, 5, [1, 2, 3, 4, 5]) 15 >>> max_sum_of_k_consecutive_elements(4, 4, [1, 2, 3, 4]) 10 >>> max_sum_of_k_consecutive_elements(5, 1, [1, 2, 3, 4, 5]) 5","solution":"def max_sum_of_k_consecutive_elements(n, k, arr): Returns the maximum possible sum of k consecutive elements in the array. Parameters: - n: int, length of the array - k: int, number of consecutive elements to sum - arr: list of int, the array of integers Returns: - int, the maximum sum of k consecutive elements if n < k or k <= 0 or n <= 0: return 0 # Initial sum of the first k elements max_sum = sum(arr[:k]) current_sum = max_sum # Use sliding window to find maximum sum of k consecutive elements for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def removeDuplicates(lst): Removes duplicate elements from a list while retaining the original order of the first occurrences of the elements. Parameters: lst (list): A list of integers Returns: list: A new list with duplicates removed >>> removeDuplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> removeDuplicates([1, 1, 1, 1, 1]) [1] >>> removeDuplicates([5, 5, 4, 3, 3, 2]) [5, 4, 3, 2] from solution import removeDuplicates def test_removeDuplicates_no_duplicates(): assert removeDuplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_removeDuplicates_with_duplicates(): assert removeDuplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] assert removeDuplicates([1, 1, 1, 1, 1]) == [1] assert removeDuplicates([5, 5, 4, 3, 3, 2]) == [5, 4, 3, 2] def test_removeDuplicates_empty_list(): assert removeDuplicates([]) == [] def test_removeDuplicates_all_same_elements(): assert removeDuplicates([7, 7, 7, 7]) == [7] def test_removeDuplicates_mixed_list(): assert removeDuplicates([1, 2, 3, 2, 1, 4, 5, 4, 6]) == [1, 2, 3, 4, 5, 6]","solution":"def removeDuplicates(lst): Removes duplicate elements from a list while retaining the original order of the first occurrences of the elements. Parameters: lst (list): A list of integers Returns: list: A new list with duplicates removed seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"from typing import List def find_best_group(N: int, T: int, skill_levels: List[int]) -> List[int]: Find the group of students whose average skill level is closest to the target skill level T. The function returns the skill levels of the students in the optimal group, in non-decreasing order. If there are multiple such groups, the one with the smallest size is chosen. If there is still a tie, the group with the lowest skill level sum is returned. Parameters: N (int): The number of students. T (int): The target skill level. skill_levels (List[int]): A list of integers representing the skill levels of the students. Returns: List[int]: The skill levels of the students in the optimal group, in non-decreasing order. >>> find_best_group(5, 500, [400, 300, 500, 700, 600]) [500] >>> find_best_group(3, 200, [100, 150, 250]) [150, 250] >>> find_best_group(4, 300, [100, 100, 200, 400]) [200, 400] >>> find_best_group(1, 500, [600]) [600] >>> find_best_group(4, 100, [100, 100, 100, 100]) [100] >>> find_best_group(3, 150, [100, 200, 275]) [100, 200]","solution":"from itertools import combinations def find_best_group(N, T, skill_levels): skill_levels.sort() best_group = None min_diff = float('inf') min_size = float('inf') min_skill_sum = float('inf') for r in range(1, N+1): for combo in combinations(skill_levels, r): avg_skill = sum(combo) / r diff = abs(avg_skill - T) skill_sum = sum(combo) if (diff < min_diff or (diff == min_diff and r < min_size) or (diff == min_diff and r == min_size and skill_sum < min_skill_sum)): min_diff = diff min_size = r min_skill_sum = skill_sum best_group = combo return list(best_group)"},{"question":"def distinct_garden_arrangements(N): Returns the number of distinct arrangements of flowers (F) and shrubs (S) of length N. Each arrangement is a sequence of 'F' and 'S'. pass def process_input(T, lengths): Processes multiple test cases and returns the results. pass # Example test cases def test_distinct_garden_arrangements(): assert distinct_garden_arrangements(1) == 2 assert distinct_garden_arrangements(2) == 3 assert distinct_garden_arrangements(3) == 5 assert distinct_garden_arrangements(4) == 9 def test_process_input(): assert process_input(2, [2, 3]) == [3, 5] assert process_input(3, [1, 2, 4]) == [2, 3, 9] assert process_input(1, [4]) == [9] assert process_input(1, [5]) == [17]","solution":"def distinct_garden_arrangements(N): Returns the number of distinct arrangements of flowers (F) and shrubs (S) of length N. Each arrangement is a sequence of 'F' and 'S'. return 2 ** (N - 1) + 1 def process_input(T, lengths): Processes multiple test cases and returns the results. results = [] for length in lengths: results.append(distinct_garden_arrangements(length)) return results"},{"question":"def is_beautiful_sequence(n: int, k: int, a: List[int]) -> str: Determine if a sequence can be divided into strictly increasing contiguous subsequences with a maximum length of k. Parameters: n (int): Length of the sequence k (int): Maximum length of the subsequences a (list): List of integers representing the sequence Returns: str: \\"Yes\\" if it is possible, otherwise \\"No\\" >>> is_beautiful_sequence(10, 3, [1, 2, 3, 4, 5, 2, 3, 4, 1, 2]) \\"Yes\\" >>> is_beautiful_sequence(5, 2, [5, 4, 3, 2, 1]) \\"No\\" from typing import List def test_example_1(): assert is_beautiful_sequence(10, 3, [1, 2, 3, 4, 5, 2, 3, 4, 1, 2]) == \\"Yes\\" def test_example_2(): assert is_beautiful_sequence(5, 2, [5, 4, 3, 2, 1]) == \\"No\\" def test_single_element(): assert is_beautiful_sequence(1, 1, [1]) == \\"Yes\\" def test_all_increasing(): assert is_beautiful_sequence(6, 3, [1, 2, 3, 4, 5, 6]) == \\"Yes\\" def test_all_decreasing(): assert is_beautiful_sequence(6, 3, [6, 5, 4, 3, 2, 1]) == \\"No\\" def test_mixed_sequence_short(): assert is_beautiful_sequence(5, 2, [3, 4, 1, 2, 3]) == \\"Yes\\" def test_mixed_sequence_long(): assert is_beautiful_sequence(10, 3, [1, 3, 5, 3, 4, 2, 3, 1, 2, 4]) == \\"No\\" def test_all_identical_numbers(): assert is_beautiful_sequence(5, 2, [2, 2, 2, 2, 2]) == \\"No\\"","solution":"def is_beautiful_sequence(n, k, a): Given a sequence a of length n, determine if it is possible to divide it into strictly increasing contiguous subsequences such that each subsequence has at most k numbers. Parameters: n (int): Length of the sequence k (int): Maximum length of the subsequences a (list): List of integers representing the sequence Returns: str: \\"Yes\\" if it is possible, otherwise \\"No\\" count = 1 for i in range(1, n): if a[i] <= a[i-1]: count += 1 if count > k: return \\"No\\" return \\"Yes\\""},{"question":"from typing import List def count_misspelled(reference_dict: List[str], words: List[str]) -> int: Returns the number of words in the words list that are not found in the reference dictionary. :param reference_dict: List of correctly spelled words. :param words: List of words to check. :return: Number of misspelled words. >>> count_misspelled([\\"apple\\", \\"banana\\", \\"orange\\"], [\\"apple\\", \\"bananna\\", \\"kiwi\\"]) 2 >>> count_misspelled([\\"tree\\", \\"house\\", \\"car\\"], [\\"tree\\", \\"house\\", \\"car\\"]) 0 >>> count_misspelled([\\"cat\\", \\"dog\\", \\"fish\\"], [\\"rat\\", \\"bat\\", \\"cat\\"]) 2","solution":"def count_misspelled(reference_dict, words): Returns the number of words in the words list that are not found in the reference dictionary. :param reference_dict: List of correctly spelled words. :param words: List of words to check. :return: Number of misspelled words. reference_set = set(reference_dict) misspelled_count = 0 for word in words: if word not in reference_set: misspelled_count += 1 return misspelled_count"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Checks if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filterPrimes(numbers: List[int]) -> List[int]: Filters a list of integers to return only the prime numbers. >>> filterPrimes([10, 17, 18, 19, 20]) [17, 19] >>> filterPrimes([2, 3, 4, 5, 6, 7]) [2, 3, 5, 7] >>> filterPrimes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filterPrimes([1, 4, 6, 8, 9, 10]) [] >>> filterPrimes([104729, 1299709]) [104729, 1299709] >>> filterPrimes([104728, 104729, 1299709, 1299710]) [104729, 1299709]","solution":"import math def is_prime(n): Checks if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filterPrimes(numbers): Filters a list of integers to return only the prime numbers. :param numbers: List of integers :return: List of prime integers return [num for num in numbers if is_prime(num)]"},{"question":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def prefix_sum(self, index): result = 0 while index > 0: result += self.tree[index] index -= index & -index return result def range_sum(self, left, right): return self.prefix_sum(right) - self.prefix_sum(left - 1) def process_queries(n, q, array, queries): Given an integer array A of size n, perform q queries on it. Each query is one of the following types: 1. k x — Replace the k-th element of the array with x. 2. l r — Calculate the sum of the elements in the subarray from index l to r, inclusive. Utilizes a Fenwick Tree to efficiently support both types of queries. Parameters: n : int : size of the array q : int : number of queries array : List[int] : initial array queries : List[List[int]] : list of queries Returns: List[int] : results of the sum queries Example usage: >>> process_queries(5, 5, [1, 2, 3, 4, 5], [[2, 1, 3], [1, 3, 10], [2, 1, 3], [1, 5, 6], [2, 4, 5]]) [6, 13, 10] pass","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def prefix_sum(self, index): result = 0 while index > 0: result += self.tree[index] index -= index & -index return result def range_sum(self, left, right): return self.prefix_sum(right) - self.prefix_sum(left - 1) def process_queries(n, q, array, queries): fenwick_tree = FenwickTree(n) for i in range(n): fenwick_tree.update(i + 1, array[i]) results = [] for query in queries: if query[0] == 1: k, x = query[1], query[2] current_value = fenwick_tree.range_sum(k, k) fenwick_tree.update(k, x - current_value) elif query[0] == 2: l, r = query[1], query[2] results.append(fenwick_tree.range_sum(l, r)) return results"},{"question":"def total_minimum_cable_length(n: int, positions: List[int]) -> int: Given the positions of the houses, returns the total minimum length of cables required to connect all houses to the electric outlet at position 0. >>> total_minimum_cable_length(4, [-5, 3, -2, 7]) 17 >>> total_minimum_cable_length(3, [1, -1, 2]) 4 >>> total_minimum_cable_length(5, [0, 0, 0, 0, 0]) 0 >>> total_minimum_cable_length(1, [-1000000000]) 1000000000 >>> total_minimum_cable_length(2, [500000000, -500000000]) 1000000000 >>> total_minimum_cable_length(6, [1, -1, 2, -2, 3, -3]) 12 >>> total_minimum_cable_length(4, [-5, 8, 3, -7]) 23","solution":"def total_minimum_cable_length(n, positions): Given the positions of the houses, returns the total minimum length of cables required to connect all houses to the electric outlet at position 0. return sum(abs(position) for position in positions)"},{"question":"def findPairWithSum(n, arr, k): Returns true if there is a pair of distinct elements in arr that add up to k. Otherwise, returns false. >>> findPairWithSum(5, [10, 15, 3, 7, 8], 17) True >>> findPairWithSum(5, [1, 2, 3, 4, 5], 10) False","solution":"def findPairWithSum(n, arr, k): Returns true if there is a pair of distinct elements in arr that add up to k. Otherwise, returns false. seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"def rearrange_odd_even(numbers): Rearranges the list so that all odd numbers appear first, followed by all even numbers. Preserves the relative order of odd and even numbers. :param numbers: List of integers :return: Rearranged list of integers >>> rearrange_odd_even([4, 3, 2, 7, 8]) [3, 7, 4, 2, 8] >>> rearrange_odd_even([12, 17, 19, 23, 26, 8]) [17, 19, 23, 12, 26, 8] pass # Complete the function def process_test_cases(test_cases): Process multiple test cases for rearranging odd and even numbers. :param test_cases: List of lists where each inner list contains integers :return: List of lists with rearranged numbers for each test case >>> process_test_cases([[4, 3, 2, 7, 8], [12, 17, 19, 23, 26, 8]]) [[3, 7, 4, 2, 8], [17, 19, 23, 12, 26, 8]] pass # Complete the function def test_rearrange_odd_even(): # Test single cases provided in example # Case 1 input_case_1 = [4, 3, 2, 7, 8] expected_output_case_1 = [3, 7, 4, 2, 8] assert rearrange_odd_even(input_case_1) == expected_output_case_1 # Case 2 input_case_2 = [12, 17, 19, 23, 26, 8] expected_output_case_2 = [17, 19, 23, 12, 26, 8] assert rearrange_odd_even(input_case_2) == expected_output_case_2 def test_process_test_cases(): # Test processing multiple test cases test_cases = [ [4, 3, 2, 7, 8], [12, 17, 19, 23, 26, 8] ] expected_results = [ [3, 7, 4, 2, 8], [17, 19, 23, 12, 26, 8] ] assert process_test_cases(test_cases) == expected_results # Additional edge cases test_cases = [ [1, 2, 3, 4, 5, 6, 7, 8, 9], [2, 4, 6, 8, 10], [1, 3, 5, 7, 9] ] expected_results = [ [1, 3, 5, 7, 9, 2, 4, 6, 8], [2, 4, 6, 8, 10], [1, 3, 5, 7, 9] ] assert process_test_cases(test_cases) == expected_results def run_all_tests(): test_rearrange_odd_even() test_process_test_cases() run_all_tests()","solution":"def rearrange_odd_even(numbers): Rearranges the list so that all odd numbers appear first, followed by all even numbers. Preserves the relative order of odd and even numbers. :param numbers: List of integers :return: Rearranged list of integers odds = [num for num in numbers if num % 2 != 0] evens = [num for num in numbers if num % 2 == 0] return odds + evens def process_test_cases(test_cases): Process multiple test cases for rearranging odd and even numbers. :param test_cases: List of tuples where each tuple contains a list of integers :return: List of lists with rearranged numbers for each test case results = [] for numbers in test_cases: results.append(rearrange_odd_even(numbers)) return results"},{"question":"def min_cost_path(grid: List[List[int]]) -> int: Calculate the minimum cost to travel from the top-left cell (1,1) to the bottom-right cell (N,M) in a grid where each cell contains a cost value. Args: grid (List[List[int]]): A 2D list containing the cost of each cell. Returns: int: The minimum cost to travel from the top-left to the bottom-right cell. Examples: >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2], [1, 1]]) 3","solution":"def min_cost_path(grid): N = len(grid) M = len(grid[0]) # Initialize cost matrix cost = [[0 for _ in range(M)] for _ in range(N)] cost[0][0] = grid[0][0] # Initialize first column of total cost matrix for i in range(1, N): cost[i][0] = cost[i - 1][0] + grid[i][0] # Initialize first row of total cost matrix for j in range(1, M): cost[0][j] = cost[0][j - 1] + grid[0][j] # Fill the rest of the cost matrix for i in range(1, N): for j in range(1, M): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[N-1][M-1]"},{"question":"def longest_path(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the longest path in a connected undirected graph. Arguments: n -- the number of vertices m -- the number of edges edges -- a list of edges represented as tuples (u, v) Returns: The length (in terms of number of edges) of the longest path in the graph. >>> longest_path(5, 5, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)]) 4 >>> longest_path(2, 1, [(1, 2)]) 1","solution":"def longest_path(n, m, edges): from collections import defaultdict # Create an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def dfs(node, visited): max_length = 0 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True path_length = 1 + dfs(neighbor, visited) max_length = max(max_length, path_length) visited[neighbor] = False return max_length longest = 0 for i in range(1, n + 1): visited = [False] * (n + 1) visited[i] = True longest = max(longest, dfs(i, visited)) return longest"},{"question":"def palindrome_game(T: int, test_cases: List[Tuple[int, str, int, List[Tuple[int, int, int]]]]) -> List[str]: Determine if the resulting string after performing a series of rotations is a palindrome for each test case. >>> palindrome_game(2, [(5, \\"abcde\\", 2, [(1, 3, 1), (2, 5, 2)]), (3, \\"aab\\", 1, [(1, 3, 2)])]) [\\"NO\\", \\"YES\\"] >>> palindrome_game(1, [(4, \\"abba\\", 1, [(1, 4, 2)])]) [\\"YES\\"]","solution":"def rotate_substring(s, L, R, K): Rotates the substring s[L:R+1] to the right by K positions L -= 1 R -= 1 K %= (R - L + 1) # Adjust K to make sure it is within the length of the substring rotated_part = s[L:R+1][-K:] + s[L:R+1][:-K] return s[:L] + rotated_part + s[R+1:] def is_palindrome(s): Checks if the given string s is a palindrome return s == s[::-1] def palindrome_game(T, test_cases): results = [] for test_case in test_cases: N, S, Q, queries = test_case for L, R, K in queries: S = rotate_substring(S, L, R, K) if is_palindrome(S): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def deploy(soldiers_strength, k): Deploy soldiers into k units such that no unit exceeds 100% strength. If it's not possible to form k units that satisfy the condition, return an empty list. :param soldiers_strength: List of integers representing the strength of each soldier. :param k: Number of units to form. :return: List of k units, where each unit is a list of soldier strengths. >>> deploy([30, 20, 50, 40, 10], 3) [[50], [40, 10], [30, 20]] >>> deploy([60, 50], 1) [] >>> deploy([10, 20, 30, 40], 1) [[10, 20, 30, 40]] >>> deploy([10, 20, 30, 40], 4) [[10], [20], [30], [40]] >>> deploy([25, 25, 25, 25], 2) [[25, 25], [25, 25]]","solution":"def deploy(soldiers_strength, k): Deploy soldiers into k units such that no unit exceeds 100% strength. If it's not possible to form k units that satisfy the condition, return an empty list. :param soldiers_strength: List of integers representing the strength of each soldier. :param k: Number of units to form. :return: List of k units, where each unit is a list of soldier strengths. soldiers_strength.sort(reverse=True) units = [[] for _ in range(k)] unit_strength = [0] * k for strength in soldiers_strength: # Find the unit with the minimum total strength that can accommodate the current soldier min_unit_index = -1 min_unit_strength = float('inf') for i in range(k): if unit_strength[i] + strength <= 100 and unit_strength[i] < min_unit_strength: min_unit_index = i min_unit_strength = unit_strength[i] if min_unit_index == -1: # Cannot place this soldier in any unit without exceeding the maximum strength return [] units[min_unit_index].append(strength) unit_strength[min_unit_index] += strength return units"},{"question":"import heapq from typing import List, Tuple def shortest_path(N: int, M: int, S: int, routes: List[Tuple[int, int, int]]) -> List[int]: Determine the shortest travel times from the starting planet S to each of the other planets. Args: N (int): number of planets M (int): number of hyperspace routes S (int): starting planet routes (List[Tuple[int, int, int]]): each tuple (U, V, T) signifies a route from planet U to planet V with travel time T Returns: List[int]: Shortest travel times to each planet from S, with -1 for unreachable planets MOD = 10**9 + 7 graph = [[] for _ in range(N)] for U, V, T in routes: graph[U-1].append((V-1, T)) dist = [float('inf')] * N dist[S-1] = 0 priority_queue = [(0, S-1)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) result = [(distance % MOD if distance != float('inf') else -1) for distance in dist] return result def test_basic_case(): N = 4 M = 4 S = 1 routes = [(1, 2, 2), (1, 3, 5), (2, 3, 1), (3, 4, 2)] assert shortest_path(N, M, S, routes) == [0, 2, 3, 5] def test_unreachable_planet(): N = 5 M = 4 S = 1 routes = [(1, 2, 2), (1, 3, 5), (2, 3, 1), (3, 4, 2)] assert shortest_path(N, M, S, routes) == [0, 2, 3, 5, -1] def test_all_planets_reachable(): N = 3 M = 3 S = 2 routes = [(2, 1, 4), (2, 3, 6), (1, 3, 2)] assert shortest_path(N, M, S, routes) == [4, 0, 6] def test_large_weights(): N = 3 M = 2 S = 1 routes = [(1, 2, int(1e9+5)), (2, 3, int(1e9+5))] assert shortest_path(N, M, S, routes) == [0, 1000000005, 1000000003] def test_only_one_edge(): N = 2 M = 1 S = 1 routes = [(1, 2, 1)] assert shortest_path(N, M, S, routes) == [0, 1] def test_same_node_edges(): N = 3 M = 3 S = 1 routes = [(1, 2, 2), (1, 1, 1), (2, 3, 3)] assert shortest_path(N, M, S, routes) == [0, 2, 5]","solution":"import heapq def shortest_path(N, M, S, routes): MOD = 10**9 + 7 graph = [[] for _ in range(N)] for U, V, T in routes: graph[U-1].append((V-1, T)) dist = [float('inf')] * N dist[S-1] = 0 priority_queue = [(0, S-1)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) result = [(distance % MOD if distance != float('inf') else -1) for distance in dist] return result"},{"question":"def generate_spiral_matrix(n): Generates an n x n 2D matrix filled with integers from 1 to n^2 in a spiral order. >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"def generate_spiral_matrix(n): Generates an n x n spiral matrix containing numbers from 1 to n^2. matrix = [[0] * n for _ in range(n)] num = 1 left, right = 0, n - 1 top, bottom = 0, n - 1 while left <= right and top <= bottom: # Traverse from left to right along the top row for col in range(left, right + 1): matrix[top][col] = num num += 1 top += 1 # Traverse from top to bottom along the right column for row in range(top, bottom + 1): matrix[row][right] = num num += 1 right -= 1 # Traverse from right to left along the bottom row for col in range(right, left - 1, -1): matrix[bottom][col] = num num += 1 bottom -= 1 # Traverse from bottom to top along the left column for row in range(bottom, top - 1, -1): matrix[row][left] = num num += 1 left += 1 return matrix"},{"question":"def team_collaboration(queries): Process a series of queries for task management and return the results for QUERY operations. Args: queries (List[str]): List of queries to be performed on the project. Returns: List[int]: Results for each QUERY operation. pass import pytest def test_example_case(): queries = [ 'ADD 1 50', 'ADD 2 60', 'QUERY 55', 'REMOVE 1', 'QUERY 50', 'ADD 3 85', 'QUERY 80', 'REMOVE 3' ] expected_output = [1, 1, 1] assert team_collaboration(queries) == expected_output def test_no_tasks(): queries = ['QUERY 50', 'QUERY 100'] expected_output = [0, 0] assert team_collaboration(queries) == expected_output def test_all_remove(): queries = [ 'ADD 1 20', 'ADD 2 40', 'REMOVE 1', 'REMOVE 2', 'QUERY 10' ] expected_output = [0] assert team_collaboration(queries) == expected_output def test_only_add_queries(): queries = [ 'ADD 1 30', 'ADD 2 40', 'ADD 3 50' ] expected_output = [] assert team_collaboration(queries) == expected_output def test_same_priorities(): queries = [ 'ADD 1 50', 'ADD 2 50', 'QUERY 50' ] expected_output = [2] assert team_collaboration(queries) == expected_output def test_different_priorities(): queries = [ 'ADD 1 50', 'ADD 2 60', 'ADD 3 70', 'QUERY 65', 'QUERY 60' ] expected_output = [1, 2] assert team_collaboration(queries) == expected_output","solution":"def team_collaboration(queries): Process a series of queries for task management and return the results for QUERY operations. Args: queries (List[str]): List of queries to be performed on the project. Returns: List[int]: Results for each QUERY operation. tasks = {} results = [] for query in queries: parts = query.split() if parts[0] == 'ADD': task_id = int(parts[1]) priority = int(parts[2]) tasks[task_id] = priority elif parts[0] == 'REMOVE': task_id = int(parts[1]) if task_id in tasks: del tasks[task_id] elif parts[0] == 'QUERY': priority = int(parts[1]) count = sum(1 for p in tasks.values() if p >= priority) results.append(count) return results"},{"question":"class WeightedDictionary: A Weighted Dictionary where each key-value pair has an associated weight. Methods: - add(key: str, value: int, weight: int) -> None: Adds or updates a key-value pair. - get(key: str) -> Union[int, str]: Retrieves the value associated with the key, or \\"Key not found\\". - get_weighted_average(keys: List[str]) -> Union[float, str]: Returns the weighted average of the given keys, or \\"No valid keys\\" if none of the keys exist. Example: >>> wd = WeightedDictionary() >>> wd.add(\\"apple\\", 10, 2) >>> wd.get(\\"apple\\") 10 >>> wd.get(\\"banana\\") 'Key not found' >>> wd.get_weighted_average([\\"apple\\", \\"banana\\"]) 10.0 def __init__(self): self.data = {} def add(self, key: str, value: int, weight: int) -> None: pass def get(self, key: str) -> Union[int, str]: pass def get_weighted_average(self, keys: List[str]) -> Union[float, str]: pass","solution":"class WeightedDictionary: def __init__(self): self.data = {} def add(self, key, value, weight): self.data[key] = (value, weight) def get(self, key): if key in self.data: return self.data[key][0] return \\"Key not found\\" def get_weighted_average(self, keys): total_weight = 0 weighted_sum = 0 for key in keys: if key in self.data: value, weight = self.data[key] weighted_sum += value * weight total_weight += weight if total_weight == 0: return \\"No valid keys\\" return weighted_sum / total_weight"},{"question":"from typing import List class Node: def __init__(self, age): self.age = age self.left = None self.right = None def insert_node(root, age): if root is None: return Node(age) else: if age < root.age: root.left = insert_node(root.left, age) elif age > root.age: root.right = insert_node(root.right, age) return root def pre_order_traversal(root, result): if root: print(\\"code here\\") def build_and_traverse_bst(species_ages): pass def manage_zoo(n: int, animal_data: List[str]) -> List[str]: Given a number of animals and their species along with their ages, construct a BST for each species and return the pre-order traversal of each BST. >>> manage_zoo(6, [\\"lion 5\\", \\"tiger 3\\", \\"lion 3\\", \\"elephant 7\\", \\"tiger 2\\", \\"lion 9\\"]) [\\"lion\\", \\"5 3 9\\", \\"tiger\\", \\"3 2\\", \\"elephant\\", \\"7\\"] >>> manage_zoo(3, [\\"cat 1\\", \\"cat 3\\", \\"cat 2\\"]) [\\"cat\\", \\"1 3 2\\"]","solution":"from collections import defaultdict class Node: def __init__(self, age): self.age = age self.left = None self.right = None def insert_node(root, age): if root is None: return Node(age) else: if age < root.age: root.left = insert_node(root.left, age) elif age > root.age: root.right = insert_node(root.right, age) return root def pre_order_traversal(root, result): if root: result.append(root.age) pre_order_traversal(root.left, result) pre_order_traversal(root.right, result) def build_and_traverse_bst(species_ages): species_bst = defaultdict(list) trees = {} for species, age in species_ages: if species not in trees: trees[species] = None trees[species] = insert_node(trees[species], age) result = [] for species in trees: result.append(species) nodes = [] pre_order_traversal(trees[species], nodes) result.append(\\" \\".join(map(str, nodes))) return result def manage_zoo(n, animal_data): species_ages = [(animal.split()[0], int(animal.split()[1])) for animal in animal_data] return build_and_traverse_bst(species_ages)"},{"question":"def can_form_ap(sequence): Determines if a given sequence can be rearranged into an arithmetic progression. :param sequence: List of integers representing the sequence. :return: \\"YES\\" if the sequence can be rearranged into an arithmetic progression, otherwise \\"NO\\". pass def process_test_cases(test_cases): Processes multiple test cases to check if each sequence can form an arithmetic progression. :param test_cases: List of tuples where each tuple contains an integer (number of elements) and a list of integers (the sequence). :return: List of strings, \\"YES\\" or \\"NO\\" for each test case. pass def parse_input(input_string): Parses the input string into a list of test cases. :param input_string: Multiline string where the first line is the number of test cases and subsequent lines contain the number of elements and the sequence elements. :return: List of tuples (N, sequence), where N is the number of elements and sequence is the list of integers. pass def main(input_string): Main function to process input and generate output. :param input_string: Multiline string input containing multiple test cases. :return: Multiline string output of \\"YES\\" or \\"NO\\" for each test case. pass","solution":"def can_form_ap(sequence): Determines if a given sequence can be rearranged into an arithmetic progression. :param sequence: List of integers representing the sequence. :return: \\"YES\\" if the sequence can be rearranged into an arithmetic progression, otherwise \\"NO\\". if len(sequence) <= 2: return \\"YES\\" sequence.sort() common_difference = sequence[1] - sequence[0] for i in range(2, len(sequence)): if sequence[i] - sequence[i-1] != common_difference: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for case in test_cases: N, sequence = case results.append(can_form_ap(sequence)) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) sequence = list(map(int, lines[index+1].split())) test_cases.append((N, sequence)) index += 2 return test_cases def main(input_string): test_cases = parse_input(input_string) results = process_test_cases(test_cases) return \\"n\\".join(results)"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome, False otherwise. Ignores punctuation, case, and spacing. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_palindrome(\\"Hello, world!\\") False >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Z\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"nurses run\\") True >>> is_palindrome(\\"nurse run\\") False","solution":"def is_palindrome(s): Returns True if the input string s is a palindrome, False otherwise. Ignores punctuation, case, and spacing. import re # Remove all non-alphanumeric characters and convert to lowercase cleaned_str = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_str == cleaned_str[::-1]"},{"question":"class SegmentTree: def __init__(self, data): Initialize the segment tree with the given data. self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): Build the segment tree from the initial array. for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): Update the value at the given index in the segment tree. pos = index - 1 + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1] def range_sum(self, left, right): Get the sum of the range from 'left' to 'right' in the array. left += self.n - 1 right += self.n sum_ = 0 while left < right: if left % 2 == 1: sum_ += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_ def process_operations(n, arr, operations): Process the list of operations on the given array. Args: n (int): The length of the array. arr (List[int]): The initial values of the array. operations (List[Tuple[int, int, int]]): A list of operations to perform on the array. Returns: List[int]: A list of results for the query operations. >>> process_operations(5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 10), (2, 1, 3), (2, 3, 5)]) [6, 14, 12] >>> process_operations(1, [100], [(2, 1, 1), (1, 1, 200)]) [100] segment_tree = SegmentTree(arr) result = [] for operation in operations: if operation[0] == 1: x, y = operation[1], operation[2] segment_tree.update(x, y) elif operation[0] == 2: x, y = operation[1], operation[2] result.append(segment_tree.range_sum(x, y)) return result","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): pos = index - 1 + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1] def range_sum(self, left, right): left += self.n - 1 right += self.n sum_ = 0 while left < right: if left % 2 == 1: sum_ += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_ def process_operations(n, arr, operations): segment_tree = SegmentTree(arr) result = [] for operation in operations: if operation[0] == 1: x, y = operation[1], operation[2] segment_tree.update(x, y) elif operation[0] == 2: x, y = operation[1], operation[2] result.append(segment_tree.range_sum(x, y)) return result"},{"question":"def validate_log(n: int, tasks: List[str]) -> Tuple[str, Union[List[int], None]]: Validate the log of baking and packaging tasks according to given rules. Arguments: n -- int, number of cakes tasks -- list of strings, list of operations (BAKE and PACKAGE x) Returns: tuple -- ('VALID', [baked_order]) if tasks are valid and consistent ('INVALID', None) otherwise >>> validate_log(4, [\\"BAKE\\", \\"BAKE\\", \\"PACKAGE 1\\", \\"BAKE\\", \\"PACKAGE 2\\", \\"BAKE\\", \\"PACKAGE 3\\", \\"PACKAGE 4\\"]) ('VALID', [1, 2, 3, 4]) >>> validate_log(2, [\\"PACKAGE 1\\", \\"BAKE\\", \\"BAKE\\", \\"PACKAGE 2\\"]) ('INVALID', None) >>> validate_log(3, [\\"BAKE\\", \\"BAKE\\", \\"BAKE\\", \\"PACKAGE 3\\", \\"PACKAGE 1\\", \\"PACKAGE 2\\"]) ('VALID', [3, 1, 2]) >>> validate_log(1, [\\"BAKE\\", \\"PACKAGE 1\\"]) ('VALID', [1]) >>> validate_log(1, [\\"PACKAGE 1\\", \\"BAKE\\"]) ('INVALID', None) >>> validate_log(2, [\\"BAKE\\", \\"PACKAGE 2\\", \\"BAKE\\", \\"PACKAGE 1\\"]) ('VALID', [2, 1])","solution":"def validate_log(n, tasks): Validate the log of baking and packaging tasks according to given rules. Arguments: n -- int, number of cakes tasks -- list of strings, list of operations (BAKE and PACKAGE x) Returns: tuple -- ('VALID', [baked_order]) if tasks are valid and consistent ('INVALID', None) otherwise bake_order = [] # This will hold the order in which cakes were baked package_stack = [] # This stack will help us keep track of available cakes for packaging for task in tasks: if task == \\"BAKE\\": # Initially add the cake with a default priority of -1 (will be replaced soon) package_stack.append(-1) elif task.startswith(\\"PACKAGE\\"): _, priority = task.split() priority = int(priority) if not package_stack or package_stack[-1] != -1: # If there is no cake available to package, return INVALID return \\"INVALID\\", None # Replace the last baked cake with the actual priority before packaging package_stack[-1] = priority # Remove the cake from our stack of cakes waiting for packaging bake_order.append(priority) # Store the priority with which it was baked package_stack.pop() else: return \\"INVALID\\", None # Invalid command return \\"VALID\\", bake_order"},{"question":"def smallest_good_subarray_length(n: int, k: int, A: List[int]) -> int: Find the length of the smallest 'good' subarray. A contiguous subarray is called \\"good\\" if the sum of the subarray is greater than or equal to \`k\`. Args: n (int): Number of elements in the array. k (int): The required sum. A (List[int]): List containing the elements of the array. Returns: int: The length of the smallest \\"good\\" subarray. If no such subarray exists, return -1. >>> smallest_good_subarray_length(5, 11, [1, 2, 3, 4, 5]) 3 >>> smallest_good_subarray_length(3, 8, [1, 4, 5]) 2 >>> smallest_good_subarray_length(4, 15, [1, 2, 3, 4]) -1 from typing import List def test_example_1(): assert smallest_good_subarray_length(5, 11, [1, 2, 3, 4, 5]) == 3 def test_example_2(): assert smallest_good_subarray_length(3, 8, [1, 4, 5]) == 2 def test_example_3(): assert smallest_good_subarray_length(4, 15, [1, 2, 3, 4]) == -1 def test_single_element_equals_k(): assert smallest_good_subarray_length(1, 5, [5]) == 1 def test_single_element_less_than_k(): assert smallest_good_subarray_length(1, 5, [4]) == -1 def test_example_larger_array(): assert smallest_good_subarray_length(7, 10, [1, 2, 3, 4, 5, 6, 7]) == 2 def test_multiple_candidates_for_smallest(): assert smallest_good_subarray_length(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2 def test_entire_array_needed(): assert smallest_good_subarray_length(5, 15, [1, 1, 1, 1, 11]) == 5 def test_no_contiguous_subarray_equals_k(): assert smallest_good_subarray_length(3, 10, [1, 2, 3]) == -1","solution":"def smallest_good_subarray_length(n, k, A): Returns the length of the smallest 'good' subarray in A with sum greater than or equal to k. If no such subarray exists, returns -1. min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += A[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= A[start] start += 1 if min_length == float('inf'): return -1 return min_length # Example usage: # n = 5 # k = 11 # A = [1, 2, 3, 4, 5] # print(smallest_good_subarray_length(n, k, A)) # Output: 3"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_pairs(head): Swaps every two adjacent nodes in the linked list. You may not modify the values in the list's nodes, only nodes itself may be changed. Args: head (ListNode): the head of the linked list Returns: ListNode: the head of the modified linked list Example: >>> list_to_linked = lambda lst: ListNode(lst[0]) if lst else None >>> linked_to_list = lambda head: [] if not head else [head.val] + linked_to_list(head.next) >>> head = list_to_linked([1,2,3,4]) >>> swapped = swap_pairs(head) >>> linked_to_list(swapped) [2, 1, 4, 3] >>> head = list_to_linked([1,2,3,4,5]) >>> swapped = swap_pairs(head) >>> linked_to_list(swapped) [2, 1, 4, 3, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_pairs(head): if not head or not head.next: return head dummy = ListNode() dummy.next = head prev = dummy current = head while current and current.next: first = current second = current.next # Swapping the nodes prev.next = second first.next = second.next second.next = first # Move the pointers forward prev = first current = first.next return dummy.next"},{"question":"def subarrays_with_k_distinct(N, K, colors): Find the number of distinct subarrays with exactly K different colors. >>> subarrays_with_k_distinct(5, 2, [1, 2, 1, 2, 3]) 7 >>> subarrays_with_k_distinct(1, 1, [1]) 1 >>> subarrays_with_k_distinct(5, 3, [1, 1, 1, 1, 1]) 0 >>> subarrays_with_k_distinct(5, 2, [1, 2, 3, 4, 5]) 4 >>> colors = [i % 10 + 1 for i in range(100000)] >>> subarrays_with_k_distinct(100000, 3, colors) > 0 True","solution":"def subarrays_with_k_distinct(N, K, colors): from collections import defaultdict def at_most_k_distinct(k): count = defaultdict(int) left = 0 ans = 0 for right in range(N): if count[colors[right]] == 0: k -= 1 count[colors[right]] += 1 while k < 0: count[colors[left]] -= 1 if count[colors[left]] == 0: k += 1 left += 1 ans += right - left + 1 return ans return at_most_k_distinct(K) - at_most_k_distinct(K - 1)"},{"question":"from typing import List, Tuple def find_first_missing_serial_number(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Identify the first missing serial number in the sequence starting from 1 for each test case. Parameters: T (int): the number of test cases. test_cases (List[Tuple[int, List[int]]]): a list of tuples containing the number of serial numbers and the list of serial numbers. Returns: List[int]: a list of the first missing serial numbers for each test case. Examples: >>> find_first_missing_serial_number(2, [(5, [2, 3, 7, 6, 8]), (3, [1, 2, 3])]) [1, 4] >>> find_first_missing_serial_number(1, [(6, [1, 2, 3, 4, 5, 6])]) [7]","solution":"def find_first_missing_serial_number(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] serial_numbers = test_cases[i][1] serial_set = set(serial_numbers) missing_number = 1 while missing_number in serial_set: missing_number += 1 results.append(missing_number) return results"},{"question":"def simulate_forest(n: int, m: int, k: int, p: float, grid: List[str]) -> List[str]: Simulate the growth of a forest represented as a grid of cells. Each cell can either be empty ('.'), contain a tree ('T'), or be a burning tree ('F'). The forest grid updates based on the following rules: 1. A burning tree ('F') becomes an empty cell ('.') in the next step. 2. A tree ('T') will catch fire if at least one of its neighboring cells is burning ('F'). 3. An empty cell ('.') can become a tree with probability p in each step. 4. A tree remains a tree if none of its neighbors are burning. Args: n (int): the number of rows in the grid. m (int): the number of columns in the grid. k (int): the number of simulation steps. p (float): the probability that an empty cell becomes a tree in each step. grid (List[str]): the initial state of the forest grid. Returns: List[str]: the state of the forest grid after k steps. >>> simulate_forest(4, 4, 3, 0.1, [\\"....\\", \\".T.T\\", \\".TF.\\", \\"F.TT\\"]) [\\"....\\", \\".....\\", \\"....\\", \\"TT..\\"] def parse_input(input_string: str) -> Tuple[int, int, int, float, List[str]]: Helper function to parse the input string. >>> parse_input(\\"4 4 3n0.1n....n.T.Tn.TF.nF.TT\\") (4, 4, 3, 0.1, ['....', '.T.T', '.TF.', 'F.TT']) def format_output(result: List[str]) -> str: Helper function to format the output list of strings. >>> format_output([\\"....\\", \\".....\\", \\"....\\", \\"TT..\\"]) \\"....n.....n....nTT..\\"","solution":"import random def simulate_forest(n, m, k, p, grid): def is_burning(i, j): return grid[i][j] == 'F' def step_forest(grid): new_grid = [['' for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): if grid[i][j] == 'F': new_grid[i][j] = '.' elif grid[i][j] == 'T': if ( (i > 0 and is_burning(i-1, j)) or (i < n-1 and is_burning(i+1, j)) or (j > 0 and is_burning(i, j-1)) or (j < m-1 and is_burning(i, j+1)) ): new_grid[i][j] = 'F' else: new_grid[i][j] = 'T' elif grid[i][j] == '.': if random.random() <= p: new_grid[i][j] = 'T' else: new_grid[i][j] = '.' return new_grid for _ in range(k): grid = step_forest(grid) return [\\"\\".join(row) for row in grid] # Helper function to parse the input def parse_input(input_string): lines = input_string.strip().split(\\"n\\") n, m, k = map(int, lines[0].split()) p = float(lines[1]) grid = [list(line) for line in lines[2:2+n]] return n, m, k, p, grid # Helper function to format the output def format_output(result): return \\"n\\".join(result) # Example usage: input_string = 4 4 3 0.1 .... .T.T .TF. F.TT n, m, k, p, grid = parse_input(input_string) output = simulate_forest(n, m, k, p, grid) print(format_output(output))"},{"question":"def findSmallestAvailableID(problemIDs, unavailableIDs): Finds the smallest available problem ID that is not in the unavailable list. Parameters: problemIDs (list of int): List of available problem IDs. unavailableIDs (list of int): List of unavailable problem IDs. Returns: int: The smallest available problem ID not in the unavailable list. Example: >>> findSmallestAvailableID([1, 2, 3, 4, 5], [1, 2, 3]) 4 >>> findSmallestAvailableID([10, 20, 30, 40, 50], [20, 30, 50]) 10","solution":"def findSmallestAvailableID(problemIDs, unavailableIDs): Finds the smallest available problem ID that is not in the unavailable list. Parameters: problemIDs (list of int): List of available problem IDs. unavailableIDs (list of int): List of unavailable problem IDs. Returns: int: The smallest available problem ID not in the unavailable list. # Convert the unavailable IDs to a set for O(1) look-up time unavailable_set = set(unavailableIDs) # Initialize the smallest ID as None initially smallest_id = None # Iterate over each ID in the problem IDs list for id in problemIDs: # Check if the ID is not in the unavailable set and if it's the smallest found so far if id not in unavailable_set: if smallest_id is None or id < smallest_id: smallest_id = id return smallest_id"},{"question":"from typing import List def subsetsWithDup(nums: List[int]) -> List[List[int]]: Given an integer array nums that may contain duplicates, return all possible subsets (the power set) such that no subset is duplicated. >>> subsetsWithDup([1, 2, 2]) == [ [], [1], [1, 2], [1, 2, 2], [2], [2, 2] ] >>> subsetsWithDup([]) == [[]] >>> subsetsWithDup([1, 2, 3]) == [ [], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3] ] >>> subsetsWithDup([3, 3, 3]) == [ [], [3], [3, 3], [3, 3, 3] ] >>> subsetsWithDup([1, 2, 2, 3]) == [ [], [1], [1, 2], [1, 2, 2], [1, 2, 2, 3], [1, 2, 3], [1, 3], [2], [2, 2], [2, 2, 3], [2, 3], [3] ]","solution":"def subsetsWithDup(nums): Returns all possible subsets of a list of integers containing duplicates. nums.sort() res = [] subset = [] def dfs(index): res.append(subset[:]) for i in range(index, len(nums)): if i > index and nums[i] == nums[i - 1]: continue subset.append(nums[i]) dfs(i + 1) subset.pop() dfs(0) return res"},{"question":"def calculate_difference(T: int, test_cases: list) -> list: Calculate the difference between the sum of elements at even positions and the sum of elements at odd positions for each test case. Args: T (int): Number of test cases. test_cases (list): A list of tuples where each tuple contains N (number of elements) and a list of N integers. Returns: list: A list of integers representing the difference between the sum of elements at even positions and the sum of elements at odd positions for each test case. Sample Usage: >>> calculate_difference(2, [(5, [1, 3, 5, 7, 9]), (4, [2, 4, 6, 8])]) [-5, 4]","solution":"def calculate_difference(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] array = test_cases[i][1] sum_even_pos = sum(array[j] for j in range(1, N, 2)) sum_odd_pos = sum(array[j] for j in range(0, N, 2)) results.append(sum_even_pos - sum_odd_pos) return results # Example usage: # T = 2 # test_cases = [(5, [1, 3, 5, 7, 9]), (4, [2, 4, 6, 8])] # print(calculate_difference(T, test_cases)) # Output: [-5, 4]"},{"question":"from typing import List, Tuple def max_scenic_value(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the maximum total scenic value Emma can achieve by visiting up to \`k\` cities. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List of test cases, where each test case consists of: - n (int): The number of cities. - k (int): The maximum number of cities she can visit. - values (List[int]): The scenic value of each city. Returns: List[int]: A list of the maximum total scenic value possible for each test case. Examples: >>> max_scenic_value(1, [(5, 3, [4, 5, 1, 3, 2])]) [12] >>> max_scenic_value(1, [(4, 2, [2, 2, 2, 2])]) [4] >>> max_scenic_value(1, [(6, 4, [10, 1, 3, 5, 7, 2])]) [25] pass","solution":"def max_scenic_value(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][:2] values = test_cases[i][2] # Take the first k most valuable cities sorted_values = sorted(values, reverse=True) max_value = sum(sorted_values[:k]) results.append(max_value) return results # Example Usage t = 3 test_cases = [ (5, 3, [4, 5, 1, 3, 2]), (4, 2, [2, 2, 2, 2]), (6, 4, [10, 1, 3, 5, 7, 2]) ] print(max_scenic_value(t, test_cases)) # Expected Output: [12, 4, 25]"},{"question":"def largest_possible_even_number(n: int, s: str) -> str: Rearrange the digits of the given string to form the largest possible even number. If no such number can be formed, return -1. >>> largest_possible_even_number(4, \\"1234\\") \\"4312\\" >>> largest_possible_even_number(3, \\"135\\") -1 >>> largest_possible_even_number(5, \\"54321\\") \\"54312\\"","solution":"def largest_possible_even_number(n, s): Returns the largest possible even number by rearranging the digits of the string. If no such even number can be created, returns -1. digits = list(s) even_digits = sorted([d for d in digits if int(d) % 2 == 0]) if not even_digits: return -1 digits.sort(reverse=True) for i in range(len(digits)-1, -1, -1): if int(digits[i]) % 2 == 0: largest_even = digits.pop(i) break largest_number = ''.join(digits) + largest_even return largest_number"},{"question":"def check_bonus_eligibility(data: List[str]) -> List[str]: Determine if an employee is eligible for a bonus based on their historical productivity data. Args: data (list): List of strings representing the input data. Returns: list: List of strings, each being \\"YES\\" or \\"NO\\" for each employee's eligibility. Example: >>> check_bonus_eligibility([ ... \\"3\\", \\"5 10\\", \\"3 15\\", \\"4 12\\", \\"2\\", ... \\"5\\", \\"8 16\\", \\"7 14\\", \\"6 12\\", \\"5 20\\", \\"4 8\\", \\"4\\", ... \\"END\\" ... ]) [\\"YES\\", \\"NO\\"]","solution":"def check_bonus_eligibility(data): Determine if an employee is eligible for a bonus based on their historical productivity data. Args: data (list): List of strings representing the input data. Returns: list: List of strings, each being \\"YES\\" or \\"NO\\" for each employee's eligibility. result = [] i = 0 while i < len(data): if data[i] == \\"END\\": break n = int(data[i]) i += 1 productivity_scores = [] for _ in range(n): Ti, Si = map(int, data[i].split()) productivity_scores.append(Si / Ti) i += 1 threshold = int(data[i]) i += 1 average_productivity = sum(productivity_scores) / n if average_productivity > threshold: result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained by sorting the characters of the input string. :param s: Input string containing only lowercase letters. :return: Lexicographically smallest string. >>> lexicographically_smallest_string('bcad') 'abcd' >>> lexicographically_smallest_string('edcba') 'abcde' >>> lexicographically_smallest_string('aabbcc') 'aabbcc'","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by sorting the characters of the input string. :param s: Input string containing only lowercase letters. :return: Lexicographically smallest string. return ''.join(sorted(s))"},{"question":"def memorial_binary_string(t: int, test_cases: List[Tuple[int, str, str]]) -> List[str]: Determine the memorial binary string for each test case. >>> memorial_binary_string(1, [(5, \\"11001\\", \\"10110\\")]) [\\"01111\\"] >>> memorial_binary_string(3, [(5, \\"11001\\", \\"10110\\"), (6, \\"111000\\", \\"000111\\"), (4, \\"1001\\", \\"1010\\")]) [\\"01111\\", \\"111111\\", \\"0011\\"]","solution":"def memorial_binary_string(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] tim = test_cases[i][1] tom = test_cases[i][2] memorial_string = [] for j in range(n): if tim[j] == tom[j]: memorial_string.append('0') else: memorial_string.append('1') results.append(''.join(memorial_string)) return results"},{"question":"def matrix_sum_diff(matrix): This function takes a square matrix and returns the absolute difference between the sums of its two diagonals. pass # Example Usage: # matrix_sum_diff([ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ]) should return 0 # matrix_sum_diff([ # [11, 2, 4], # [ 4, 5, 6], # [10, 8, -12] # ]) should return 15","solution":"def matrix_sum_diff(matrix): This function takes a square matrix and returns the absolute difference between the sums of its two diagonals. n = len(matrix) primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"def solve_collinearity_problems(test_cases): Determine if all cities visited in each test case are collinear. Each test case contains an integer N, the number of visited cities, followed by N pairs of integers, where each pair represents the coordinates (x, y) of a city. Args: test_cases (list): List of tuples, where each tuple contains an integer N and a list of coordinate pairs. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each test case. >>> solve_collinearity_problems([(3, [(1, 2), (2, 3), (3, 4)])]) [\\"YES\\"] >>> solve_collinearity_problems([(3, [(1, 2), (2, 3), (3, 5)])]) [\\"NO\\"]","solution":"def are_cities_collinear(coordinates): Returns whether all given coordinates lie on a straight line. if len(coordinates) <= 2: return True x0, y0 = coordinates[0] x1, y1 = coordinates[1] for i in range(2, len(coordinates)): x, y = coordinates[i] if (y - y0) * (x1 - x0) != (y1 - y0) * (x - x0): return False return True def solve_collinearity_problems(test_cases): results = [] for test_case in test_cases: N, coordinates = test_case if are_cities_collinear(coordinates): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_sunrise_views(N, B): Count the number of buildings that have a sunrise view. Parameters: N (int): the number of buildings. B (list): the list of building heights. Returns: int: the number of buildings with a sunrise view. pass def process_test_cases(test_cases): Process multiple test cases. Parameters: test_cases (list of tuples): list where each element is a tuple containing the number of buildings (N) and the list of building heights (B). Returns: list: the result of each test case. pass # Unit tests def test_count_sunrise_views(): assert count_sunrise_views(5, [3, 4, 2, 7, 6]) == 3 assert count_sunrise_views(4, [1, 2, 3, 4]) == 4 assert count_sunrise_views(6, [10, 12, 8, 10, 15, 9]) == 3 assert count_sunrise_views(3, [5, 6, 6]) == 2 assert count_sunrise_views(1, [1]) == 1 assert count_sunrise_views(2, [2, 1]) == 1 def test_process_test_cases(): test_cases = [ (5, [3, 4, 2, 7, 6]), (4, [1, 2, 3, 4]), (6, [10, 12, 8, 10, 15, 9]) ] expected_results = [3, 4, 3] assert process_test_cases(test_cases) == expected_results test_cases = [ (3, [5, 6, 6]), (1, [1]), (2, [2, 1]) ] expected_results = [2, 1, 1] assert process_test_cases(test_cases) == expected_results","solution":"def count_sunrise_views(N, B): Count the number of buildings that have a sunrise view. Parameters: N (int): the number of buildings. B (list): the list of building heights. Returns: int: the number of buildings with a sunrise view. # The first building always has a sunrise view count = 1 max_height = B[0] for i in range(1, N): if B[i] > max_height: count += 1 max_height = B[i] return count def process_test_cases(test_cases): Process multiple test cases. Parameters: test_cases (list of tuples): list where each element is a tuple containing the number of buildings (N) and the list of building heights (B). Returns: list: the result of each test case. results = [] for N, B in test_cases: results.append(count_sunrise_views(N, B)) return results"},{"question":"def maximize_projects(test_cases): Assign projects to engineers to maximize the number of projects completed before deadlines. Args: test_cases (list): A list of tuples where each tuple contains: - E (int): Number of engineers - P (int): Number of projects - projects (list of tuples): Each tuple contains (H_i (int), D_i (int)) representing hours required and deadline Returns: list: A list of integers representing the maximum number of projects completed before deadlines for each test case. >>> test_cases = [(3, 3, [(4, 10), (3, 5), (2, 7)]), (4, 3, [(2, 9), (1, 8), (3, 5)])] >>> maximize_projects(test_cases) [3, 3] # Your code here def parse_input(input_str): Parse the input string and invoke maximize_projects function. Args: input_str (str): Input data as string Returns: list: A list of integers representing the maximum number of projects completed before deadlines for each test case. >>> input_str = \\"2n3 3n4 10n3 5n2 7n4 3n2 9n1 8n3 5\\" >>> parse_input(input_str) [3, 3] # Your code here import pytest def test_maximize_projects_example(): input_str = \\"2n3 3n4 10n3 5n2 7n4 3n2 9n1 8n3 5\\" expected_output = [3, 3] assert parse_input(input_str) == expected_output def test_maximize_projects_edge_case_1(): input_str = \\"1n1 1n1 1\\" expected_output = [1] assert parse_input(input_str) == expected_output def test_maximize_projects_edge_case_2(): input_str = \\"1n2 2n2 3n3 2\\" expected_output = [1] assert parse_input(input_str) == expected_output def test_maximize_projects_multiple_cases(): input_str = \\"3n2 2n2 9n1 8n3 3n4 10n3 5n2 7n1 1n1 1\\" expected_output = [2, 3, 1] assert parse_input(input_str) == expected_output def test_maximize_projects_unable_to_meet_deadline(): input_str = \\"1n2 3n5 3n6 4n7 5\\" expected_output = [0] assert parse_input(input_str) == expected_output def test_maximize_projects_some_meet_deadline(): input_str = \\"1n3 4n5 4n4 7n1 2n10 10\\" expected_output = [3] assert parse_input(input_str) == expected_output","solution":"def maximize_projects(test_cases): results = [] for E, P, projects in test_cases: projects.sort(key=lambda x: (x[1], x[0])) # Sort by deadline, then by hours required project_count = 0 available_engineers = E for hours, deadline in projects: if available_engineers > 0 and hours <= deadline: available_engineers -= 1 project_count += 1 results.append(project_count) return results # Function to parse input and invoke the solution def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): E, P = map(int, lines[idx].split()) projects = [] idx += 1 for _ in range(P): H, D = map(int, lines[idx].split()) projects.append((H, D)) idx += 1 test_cases.append((E, P, projects)) return maximize_projects(test_cases)"},{"question":"def is_path_available(n: int, m: int, grid: List[str], r1: int, c1: int, r2: int, c2: int) -> str: Determines if a path exists from (r1, c1) to (r2, c2) in the given grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): The city grid. r1 (int): Starting row index. c1 (int): Starting column index. r2 (int): Ending row index. c2 (int): Ending column index. Returns: str: \\"YES\\" if there is a path from (r1, c1) to (r2, c2), otherwise \\"NO\\". >>> is_path_available(5, 5, [ ... \\".....\\", ... \\"..#..\\", ... \\".\\", ... \\".....\\", ... \\".....\\" ... ], 1, 1, 5, 5) \\"YES\\" >>> is_path_available(5, 5, [ ... \\".....\\", ... \\"#\\", ... \\".....\\", ... \\"#\\", ... \\".....\\" ... ], 1, 1, 5, 5) \\"NO\\" pass","solution":"def is_path_available(n, m, grid, r1, c1, r2, c2): Determines if a path exists from (r1, c1) to (r2, c2) in the given grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): The city grid. r1 (int): Starting row index. c1 (int): Starting column index. r2 (int): Ending row index. c2 (int): Ending column index. Returns: str: \\"YES\\" if there is a path from (r1, c1) to (r2, c2), otherwise \\"NO\\". from collections import deque def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = (r1 - 1, c1 - 1) end = (r2 - 1, c2 - 1) queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == end: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def max_average_concentration(D: int, K: int, concentrations: List[int]) -> float: Find the maximum average concentration over any consecutive K days in the recorded data. >>> max_average_concentration(5, 2, [1, 12, -5, -6, 50]) 22.0 >>> max_average_concentration(7, 3, [5, 5, 5, 5, 5, 5, 5]) 5.0 >>> max_average_concentration(1, 1, [100]) 100.0 >>> max_average_concentration(6, 3, [-5, -6, -7, -8, -9, -10]) -6.0 >>> max_average_concentration(4, 1, [3, -3, 2, -2]) 3.0","solution":"def max_average_concentration(D, K, concentrations): current_sum = sum(concentrations[:K]) max_sum = current_sum for i in range(K, D): current_sum += concentrations[i] - concentrations[i - K] if current_sum > max_sum: max_sum = current_sum return round(max_sum / K, 1) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() D = int(data[0]) K = int(data[1]) concentrations = list(map(int, data[2:D+2])) print(max_average_concentration(D, K, concentrations))"},{"question":"from typing import List, Tuple def plant_scheme(n: int, m: int) -> List[str]: Returns a planting scheme for Farmer Joe's fields. Each cell is either 'W' (wheat) or 'B' (barley) such that: 1. Each cell that contains barley ('B') is not adjacent (horizontally or vertically) to another cell containing barley. 2. There is at least one 'W' cell adjacent to every 'B' cell, but no 'W' cell should be adjacent to more than one 'B' cell. pass def multiple_plant_schemes(test_cases: List[Tuple[int, int]]) -> List[List[str]]: results = [] for n, m in test_cases: results.append(plant_scheme(n, m)) return results # Unit tests def test_plant_scheme_3x3(): result = plant_scheme(3, 3) expected = [ 'WBW', 'BWB', 'WBW' ] assert result == expected def test_plant_scheme_4x5(): result = plant_scheme(4, 5) expected = [ 'WBWBW', 'BWBWB', 'WBWBW', 'BWBWB' ] assert result == expected def test_multiple_plant_schemes(): test_cases = [(3, 3), (4, 5)] result = multiple_plant_schemes(test_cases) expected = [ [ 'WBW', 'BWB', 'WBW' ], [ 'WBWBW', 'BWBWB', 'WBWBW', 'BWBWB' ] ] assert result == expected","solution":"def plant_scheme(n, m): Returns a planting scheme for Farmer Joe's fields. Each cell is either 'W' (wheat) or 'B' (barley) such that: 1. Each cell that contains barley ('B') is not adjacent (horizontally or vertically) to another cell containing barley. 2. There is at least one 'W' cell adjacent to every 'B' cell, but no 'W' cell should be adjacent to more than one 'B' cell. grid = [] for i in range(n): row = [] for j in range(m): if (i + j) % 2 == 0: row.append('W') else: row.append('B') grid.append(\\"\\".join(row)) return grid def multiple_plant_schemes(test_cases): results = [] for n, m in test_cases: results.append(plant_scheme(n, m)) return results"},{"question":"def isBalanced(s: str) -> int: Determine if the string of curly braces is balanced. >>> isBalanced(\\"{}{}\\") 1 >>> isBalanced(\\"{{}}\\") 1 >>> isBalanced(\\"{{}\\") 0","solution":"def isBalanced(s): Returns 1 if the string s containing only curly braces is balanced, otherwise 0. balance = 0 for char in s: if char == '{': balance += 1 elif char == '}': balance -= 1 if balance < 0: return 0 return 1 if balance == 0 else 0"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the string s is a palindrome, False otherwise. Ignores spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"Hello, World!\\") False","solution":"import re def is_palindrome(s): Returns True if the string s is a palindrome, False otherwise. Ignores spaces, punctuation, and capitalization. s = re.sub(r'[^A-Za-z0-9]', '', s).lower() return s == s[::-1]"},{"question":"def min_moves_to_target(n, m, k, obstacles, start, target): Determine the minimum number of moves required for the robot to reach the target position from the start position. If it is not possible for the robot to reach the target, return -1. >>> min_moves_to_target(5, 5, 3, [(2, 2), (3, 3), (4, 4)], (1, 1), (5, 5)) 8 >>> min_moves_to_target(5, 5, 10, [(2, 2), (2, 3), (3, 2), (3, 4), (4, 2), (4, 5), (5, 1), (5, 2), (5, 3), (5, 4)], (1, 1), (5, 5)) -1 >>> min_moves_to_target(3, 3, 0, [], (1, 1), (3, 3)) 4 >>> min_moves_to_target(3, 3, 1, [(2, 2)], (1, 1), (3, 3)) 4 >>> min_moves_to_target(5, 5, 3, [(2, 2), (3, 3), (4, 4)], (1, 1), (1, 1)) 0","solution":"from collections import deque def min_moves_to_target(n, m, k, obstacles, start, target): # Create the warehouse grid and mark obstacles grid = [[0] * m for _ in range(n)] for ox, oy in obstacles: grid[ox - 1][oy - 1] = 1 # Marking obstacle cells as 1 # Starting and target positions sx, sy = start tx, ty = target # Directions for moving in the grid directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right # BFS queue initialized with starting position queue = deque([(sx - 1, sy - 1, 0)]) # (x, y, steps) visited = set() visited.add((sx - 1, sy - 1)) while queue: x, y, steps = queue.popleft() # Check if target is reached if (x, y) == (tx - 1, ty - 1): return steps # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If target is not reachable, return -1 return -1"},{"question":"def max_subarray_sum(n: int, distances: List[int]) -> int: Given \`n\` days and an array of distances, computes the maximum sum of distances traveled over any contiguous subarray of days. >>> max_subarray_sum(5, [3, 1, 2, 7, 4]) 17 >>> max_subarray_sum(7, [2, 3, 4, 1, 6, 8, 5]) 29 >>> max_subarray_sum(4, [1, 3, 5, 7]) 16 >>> max_subarray_sum(3, [5, 0, 6]) 11 >>> max_subarray_sum(1, [100000]) 100000 >>> max_subarray_sum(5, [0, 0, 0, 0, 0]) 0 >>> max_subarray_sum(6, [1, 2, 3, 4, 5, 6]) 21","solution":"def max_subarray_sum(n, distances): Given \`n\` days and an array of distances, computes the maximum sum of distances traveled over any contiguous subarray of days. if n == 0: return 0 max_sum = current_sum = distances[0] for i in range(1, n): current_sum = max(distances[i], current_sum + distances[i]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def maxProductSubarray(arr: List[int]) -> int: Implement a function that takes in an array of integers and returns the maximum product of a contiguous subarray. >>> maxProductSubarray([2, 3, -2, 4, -1]) 48 >>> maxProductSubarray([-2, 0, -1]) 0","solution":"def maxProductSubarray(arr): if not arr: return 0 max_product = min_product = result = arr[0] for num in arr[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result # Example usage: # n = 5 # arr = [2, 3, -2, 4, -1] # print(maxProductSubarray(arr)) # Output: 48 # n = 3 # arr = [-2, 0, -1] # print(maxProductSubarray(arr)) # Output: 0"},{"question":"def day_of_week(N: int) -> str: Returns the day of the week for the N-th day of the year. Parameters: N (int): The N-th day of the year (1 <= N <= 365) Returns: str: The day of the week. pass # Test Cases def test_monday(): assert day_of_week(1) == \\"Monday\\" def test_tuesday(): assert day_of_week(2) == \\"Tuesday\\" def test_wednesday(): assert day_of_week(3) == \\"Wednesday\\" def test_thursday(): assert day_of_week(4) == \\"Thursday\\" def test_friday(): assert day_of_week(5) == \\"Friday\\" def test_saturday(): assert day_of_week(6) == \\"Saturday\\" def test_sunday(): assert day_of_week(7) == \\"Sunday\\" def test_another_monday(): assert day_of_week(8) == \\"Monday\\" def test_end_of_year(): assert day_of_week(365) == \\"Monday\\"","solution":"def day_of_week(N): Returns the day of the week for the N-th day of the year. Parameters: N (int): The N-th day of the year (1 <= N <= 365) Returns: str: The day of the week. days = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] return days[(N - 1) % 7]"},{"question":"def is_odd_product_pair_exists(arr): Returns \\"Yes\\" if there exists a pair of integers in the array whose product is odd, otherwise returns \\"No\\". >>> is_odd_product_pair_exists([1, 2, 3, 4]) \\"Yes\\" >>> is_odd_product_pair_exists([2, 4, 6]) \\"No\\" pass def process_test_cases(T, test_cases): Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases(2, [[4, [1, 2, 3, 4]], [3, [2, 4, 6]]]) [\\"Yes\\", \\"No\\"] >>> process_test_cases(1, [[3, [1, 1, 1]]]) [\\"Yes\\"] pass","solution":"def is_odd_product_pair_exists(arr): Returns \\"Yes\\" if there exists a pair of integers in the array whose product is odd, otherwise returns \\"No\\". odd_count = 0 for num in arr: if num % 2 != 0: odd_count += 1 if odd_count >= 2: return \\"Yes\\" return \\"No\\" def process_test_cases(T, test_cases): Processes multiple test cases and returns a list of results for each test case. results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] results.append(is_odd_product_pair_exists(arr)) return results"},{"question":"from typing import List, Tuple def max_subarray_sum_in_range(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of integers and a series of query ranges, find the maximum sum of any non-empty subarray within each of the specified ranges. >>> arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] >>> queries = [(0, 4), (1, 7), (0, 8)] >>> max_subarray_sum_in_range(arr, queries) [4, 6, 6] >>> arr = [5] >>> queries = [(0, 0)] >>> max_subarray_sum_in_range(arr, queries) [5] >>> arr = [-1, -2, -3, -4] >>> queries = [(0, 3), (1, 2)] >>> max_subarray_sum_in_range(arr, queries) [-1, -2] >>> arr = [3, -1, -1, 3] >>> queries = [(0, 3), (1, 2)] >>> max_subarray_sum_in_range(arr, queries) [4, -1] >>> arr = [i for i in range(1, 101)] >>> queries = [(0, 99)] >>> max_subarray_sum_in_range(arr, queries) [5050]","solution":"from typing import List, Tuple def max_subarray_sum_in_range(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: def kadane_algorithm(subarray: List[int]) -> int: max_ending_here = subarray[0] max_so_far = subarray[0] for num in subarray[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far results = [] for l, r in queries: subarray = arr[l:r+1] max_sum = kadane_algorithm(subarray) results.append(max_sum) return results"},{"question":"def count_intervals_containing_point(intervals, queries): For each query point, count how many intervals contain that point. :param intervals: List of tuples [(L, R), (L, R), ...] where each tuple represents an interval. :param queries: List of integers representing the query points. :return: List of integers where each integer is the count of intervals containing the corresponding query point. >>> count_intervals_containing_point([(1, 5), (10, 15), (20, 25)], [2, 12, 22, 30, 5]) [1, 1, 1, 0, 1] >>> count_intervals_containing_point([(1, 10), (5, 15), (10, 20)], [10]) [3] >>> count_intervals_containing_point([], [5, 10, 15]) [0, 0, 0] >>> count_intervals_containing_point([(1, 2), (3, 4), (5, 6)], []) [] >>> count_intervals_containing_point([(1, 1), (1, 1), (1, 1)], [1]) [3] >>> count_intervals_containing_point([(1000000, 2000000), (500000, 1500000), (0, 1000000000)], [1000000, 3000000, 0, 500000]) [3, 1, 1, 2]","solution":"def count_intervals_containing_point(intervals, queries): For each query point, count how many intervals contain that point. :param intervals: List of tuples [(L, R), (L, R), ...] where each tuple represents an interval. :param queries: List of integers representing the query points. :return: List of integers where each integer is the count of intervals containing the corresponding query point. result = [] for x in queries: count = 0 for L, R in intervals: if L <= x <= R: count += 1 result.append(count) return result"},{"question":"def max_spent_over_k_days(n: int, k: int, expenses: List[int]) -> int: Returns the maximum amount spent over any consecutive period of exactly k days. >>> max_spent_over_k_days(7, 3, [1, 2, 3, 4, 5, 6, 7]) 18 >>> max_spent_over_k_days(5, 2, [4, 2, 3, 5, 1]) 8 >>> max_spent_over_k_days(6, 4, [1, 1, 1, 1, 1, 7]) 10","solution":"def max_spent_over_k_days(n, k, expenses): Returns the maximum amount spent over any consecutive period of exactly k days. current_sum = sum(expenses[:k]) max_sum = current_sum for i in range(k, n): current_sum += expenses[i] - expenses[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_triplet_sum(T: int, events: List[Tuple[int, List[int]]]) -> List[int]: Given the number of events and a list of donations for each event, calculates the maximum of the triplet sums for each event. If there are fewer than 3 donations for an event, the maximum single donation is returned. >>> max_triplet_sum(2, [(5, [10, -2, 8, 3, -1]), (3, [2, 1, 2])]) [16, 5]","solution":"def max_triplet_sum(T, events): result = [] for event in events: N, donations = event if N < 3: result.append(max(donations)) else: max_sum = float('-inf') for i in range(N - 2): current_sum = donations[i] + donations[i+1] + donations[i+2] max_sum = max(max_sum, current_sum) result.append(max_sum) return result"},{"question":"import math from typing import List def findSquareSums(n: int) -> List[int]: Returns an array of two positive integers [a, b] such that a^2 + b^2 = n, or an empty array if such a pair does not exist. >>> findSquareSums(5) [1, 2] >>> findSquareSums(4) [0, 2] >>> findSquareSums(3) []","solution":"import math def findSquareSums(n): Returns an array of two positive integers [a, b] such that a^2 + b^2 = n, or an empty array if such a pair does not exist. for a in range(0, int(math.isqrt(n)) + 1): b_square = n - a * a b = int(math.isqrt(b_square)) if b * b == b_square: return [a, b] return []"},{"question":"from datetime import datetime from typing import List, Tuple def compute_longest_period(T: int, records: List[Tuple[int, str, str]]) -> int: Compute the longest period (in minutes) during which the package remained at a single location without moving to another location. Args: T: int - The number of locations the package visited. records: List[Tuple[int, str, str]] - List of tuples containing location identifier, event type ('R' for received, 'D' for dispatched), and a timestamp in the format 'HH:MM'. Returns: int - The longest period (in minutes) the package spent at any single location. >>> compute_longest_period(3, [(1, \\"R\\", \\"08:00\\"), (1, \\"D\\", \\"10:00\\"), (2, \\"R\\", \\"12:00\\")]) 120 >>> compute_longest_period(3, [(1, \\"R\\", \\"09:00\\"), (2, \\"R\\", \\"10:00\\"), (2, \\"D\\", \\"13:00\\")]) 180","solution":"from datetime import datetime def compute_longest_period(T, records): def diff_in_minutes(start, end): FMT = '%H:%M' tdelta = datetime.strptime(end, FMT) - datetime.strptime(start, FMT) return int(tdelta.total_seconds() // 60) longest_period = 0 current_location = None current_start_time = None locations = {} for record in records: L, event, timestamp = record if event == 'R': current_location = L current_start_time = timestamp if event == 'D': if L == current_location: period = diff_in_minutes(current_start_time, timestamp) if L in locations: locations[L] = max(locations[L], period) else: locations[L] = period current_location = None current_start_time = None for loc in locations: longest_period = max(longest_period, locations[loc]) return longest_period T1 = 3 records1 = [(1, \\"R\\", \\"08:00\\"), (1, \\"D\\", \\"10:00\\"), (2, \\"R\\", \\"12:00\\")] T2 = 3 records2 = [(1, \\"R\\", \\"09:00\\"), (2, \\"R\\", \\"10:00\\"), (2, \\"D\\", \\"13:00\\")] print(compute_longest_period(T1, records1)) # Output should be 120 print(compute_longest_period(T2, records2)) # Output should be 180"},{"question":"def find_seat(seating_str): Given a binary string seating_str where '1' indicates an occupied seat and '0' indicates an unoccupied seat, find the seat index where a new member should be seated to maximize the distance from the nearest occupied seat. Return the seat index (1-based). >>> find_seat(\\"10001\\") 3 >>> find_seat(\\"0010\\") 1 pass def automated_seating(arrangements): Given a list of binary strings representing multiple test cases, where each string represents a row of seats, return the seat index for each test case in the format \\"Case #x: y\\", where x is the test case number and y is the seat index. >>> automated_seating([\\"10001\\", \\"0010\\"]) ['Case #1: 3', 'Case #2: 1'] pass","solution":"def find_seat(seating_str): max_dist = -1 best_seat = -1 occupied_indices = [i for i, seat in enumerate(seating_str) if seat == '1'] for i, seat in enumerate(seating_str): if seat == '0': if not occupied_indices: return i + 1 # if no seats are occupied, take the first available closest_distance = min([abs(i - occupied) for occupied in occupied_indices]) if closest_distance > max_dist: max_dist = closest_distance best_seat = i return best_seat + 1 def automated_seating(arrangements): results = [] for index, seating_str in enumerate(arrangements): seat_index = find_seat(seating_str) results.append(f\\"Case #{index + 1}: {seat_index}\\") return results"},{"question":"def maxAfterDeletion(N: int) -> int: Given an integer N, compute the maximum possible value obtained by deleting exactly one digit of the given number. >>> maxAfterDeletion(2319) 319 >>> maxAfterDeletion(104) 14","solution":"def maxAfterDeletion(N): Returns the maximum possible value obtained by deleting exactly one digit from the given number N. str_N = str(N) max_value = 0 for i in range(len(str_N)): new_value = int(str_N[:i] + str_N[i+1:]) max_value = max(max_value, new_value) return max_value"},{"question":"def process_queries(n: int, q: int, arr: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process queries over an array of integers. Args: n (int): Number of elements in the array. q (int): Number of queries. arr (List[int]): Initial elements of the array. queries (List[Tuple[int, int, int]]): List of queries where each query is a tuple. The first element of the tuple represents the query type: 1. Update the element at the given index to a new value. 2. Compute the sum of elements in a subarray defined by a given range [L, R] (inclusive). 3. Find the maximum value in a subarray defined by a given range [L, R] (inclusive). Returns: List[int]: Results of the sum and maximum queries. Example: >>> process_queries(5, 5, [1, 2, 3, 4, 5], [(2, 1, 3), (3, 2, 5), (1, 3, 10), (2, 1, 3), (3, 2, 5)]) [6, 5, 13, 10] >>> process_queries(3, 4, [5, 8, 6], [(2, 1, 2), (3, 1, 3), (1, 1, 7), (3, 1, 3)]) [13, 8, 8]","solution":"class SegmentTree: def __init__(self, data, default, func): self.n = len(data) self.default = default self.func = func self.tree = [default] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): pos = self.n + index self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.func(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, l, r): res = self.default l += self.n r += self.n + 1 while l < r: if l % 2 == 1: res = self.func(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = self.func(res, self.tree[r]) l //= 2 r //= 2 return res def process_queries(n, q, arr, queries): sum_seg_tree = SegmentTree(arr, 0, lambda x, y: x + y) max_seg_tree = SegmentTree(arr, float('-inf'), max) results = [] for query in queries: if query[0] == 1: index, value = query[1] - 1, query[2] sum_seg_tree.update(index, value) max_seg_tree.update(index, value) elif query[0] == 2: L, R = query[1] - 1, query[2] - 1 results.append(sum_seg_tree.query(L, R)) elif query[0] == 3: L, R = query[1] - 1, query[2] - 1 results.append(max_seg_tree.query(L, R)) return results"},{"question":"def max_skill_level(N: int, K: int, S: List[int]) -> int: Returns the maximum possible total skill level for a team of size K such that no two students in the team have adjacent skill levels in the initial list. >>> max_skill_level(6, 3, [1, 3, 2, 5, 4, 9]) 17 >>> max_skill_level(5, 2, [8, 1, 5, 4, 7]) 15","solution":"def max_skill_level(N, K, S): Returns the maximum possible total skill level for a team of size K such that no two students in the team have adjacent skill levels in the initial list. # Edge case if K == 0: return 0 # Dynamic programming table to store maximum skill values dp = [[0] * (K + 1) for _ in range(N)] # Initialize first column, which represents selecting 0 students for i in range(N): dp[i][0] = 0 # Initialize the first skill dp[0][1] = S[0] # Fill the DP table for i in range(1, N): for k in range(1, K + 1): # Option 1: Do not include the current student dp[i][k] = dp[i-1][k] # Option 2: Include the current student, if possible if k > 0: dp[i][k] = max(dp[i][k], S[i] + (dp[i-2][k-1] if i >= 2 else 0)) # Find the maximum skill level that can be achieved with any K rows max_skill = 0 for i in range(N): max_skill = max(max_skill, dp[i][K]) return max_skill"},{"question":"from typing import List, Tuple def rearrange_no_adjacent(t: int, cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Given an array of integers, rearrange the array such that no two adjacent elements have the same value. If such an arrangement is not possible, return an empty array. Args: t : int : Number of test cases cases : List[Tuple[int, List[int]]] : List containing tuples, each consisting of the number of elements and the array for each test case. Returns: List[List[int]] : List of rearranged arrays for each test case or an empty array if rearrangement is not possible. >>> rearrange_no_adjacent(2, [(5, [1, 1, 1, 2, 2]), (4, [4, 4, 4, 4])]) [[1, 2, 1, 2, 1], []] >>> rearrange_no_adjacent(1, [(1, [1])]) [[1]] pass def test_possible_rearrangement(): t = 2 cases = [(5, [1, 1, 1, 2, 2]), (4, [4, 4, 4, 4])] expected = [[1, 2, 1, 2, 1], []] assert rearrange_no_adjacent(t, cases) == expected def test_all_different_elements(): t = 1 cases = [(5, [1, 2, 3, 4, 5])] expected = [[1, 2, 3, 4, 5]] assert rearrange_no_adjacent(t, cases) == expected def test_single_element(): t = 1 cases = [(1, [1])] expected = [[1]] assert rearrange_no_adjacent(t, cases) == expected def test_identical_elements(): t = 1 cases = [(3, [2, 2, 2])] expected = [[]] assert rearrange_no_adjacent(t, cases) == expected def test_larger_input(): t = 1 cases = [(6, [1, 1, 2, 2, 3, 3])] expected = [[1, 2, 1, 3, 2, 3]] result = rearrange_no_adjacent(t, cases) assertion = sorted(result[0]) == sorted(expected[0]) assert assertion","solution":"from collections import Counter import heapq def rearrange_no_adjacent(t, cases): def rearrange(arr): freq = Counter(arr) max_heap = [(-count, num) for num, count in freq.items()] heapq.heapify(max_heap) prev_count, prev_num = 0, None result = [] while max_heap: count, num = heapq.heappop(max_heap) result.append(num) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_num)) prev_count, prev_num = count + 1, num if len(result) != len(arr): return [] return result results = [] for i in range(t): n, arr = cases[i] result = rearrange(arr) results.append(result) return results"},{"question":"def count_unique_pairs(n: int, target: int, array: List[int]) -> int: Returns the number of unique pairs (a, b) such that a + b == target and a < b. >>> count_unique_pairs(6, 8, [1, 2, 3, 4, 5, 7]) 2 >>> count_unique_pairs(4, 10, [1, 2, 3, 4]) 0 >>> count_unique_pairs(5, 6, [3, 3, 3, 3, 3]) 0 >>> count_unique_pairs(5, 0, [-1, -2, 2, 1, 3]) 2 >>> count_unique_pairs(10, 10, [2, 3, 5, 7, 8, 2, 7, 5, 3, 2]) 2 >>> count_unique_pairs(2, 5, [2, 3]) 1","solution":"def count_unique_pairs(n, target, array): Returns the number of unique pairs (a, b) such that a + b == target and a < b. count = 0 seen = set() for i in range(n): for j in range(i + 1, n): if array[i] < array[j] and array[i] + array[j] == target: pair = (array[i], array[j]) if pair not in seen: count += 1 seen.add(pair) return count # Example usage # n = 6 # target = 8 # array = [1, 2, 3, 4, 5, 7] # print(count_unique_pairs(n, target, array)) # Output: 2"},{"question":"def longest_streak_of_days(days: int, threshold: int, distances: List[int]) -> int: Function to find the longest streak of consecutive days where distance ran is greater or equal to the threshold. Parameters: - days: The number of days (int) - threshold: Minimum threshold distance (int) - distances: List of distances ran each day (list of int) Returns: - Longest streak of consecutive days (int) >>> longest_streak_of_days(30, 5, [2, 5, 6, 5, 5, 6, 7, 4, 5, 6, 7, 8, 5, 6, 3, 4, 6, 7, 7, 8, 9, 4, 5, 6, 7, 8, 6, 5, 4, 3]) 6 >>> longest_streak_of_days(30, 5, [1, 2, 1, 4, 2, 1, 0, 3, 2, 1, 0, 4, 2, 1, 3, 0, 2, 1, 1, 2, 3, 1, 0, 1, 3, 2, 1, 0, 1, 2]) 0 >>> longest_streak_of_days(30, 10, [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]) 30","solution":"def longest_streak_of_days(days, threshold, distances): Function to find the longest streak of consecutive days where distance ran is greater or equal to the threshold. Parameters: - days: The number of days (int) - threshold: Minimum threshold distance (int) - distances: List of distances ran each day (list of int) Returns: - Longest streak of consecutive days (int) max_streak = 0 current_streak = 0 for distance in distances: if distance >= threshold: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 return max_streak def process_input(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 results = [] for _ in range(T): D = int(data[index]) index += 1 N = int(data[index]) index += 1 distances = list(map(int, data[index:index+D])) index += D results.append(longest_streak_of_days(D, N, distances)) for result in results: print(result)"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. pass def level_checker(levels: Dict[str, int]) -> int: Returns the average level (rounded to the nearest integer) of names whose levels are prime numbers. If there are no prime levels, returns 0. Examples: >>> level_checker({\\"Alice\\": 2, \\"Bob\\": 4, \\"Charlie\\": 5, \\"David\\": 9, \\"Eve\\": 11}) == 6 >>> level_checker({\\"Anna\\": 8, \\"Ben\\": 10, \\"Cara\\": 15, \\"Dani\\": 20}) == 0 >>> level_checker({\\"Sam\\": 7, \\"Tom\\": 3, \\"Jill\\": 2, \\"Henry\\": 6}) == 4 >>> level_checker({\\"Alice\\": 7}) == 7 >>> level_checker({\\"Bob\\": 8}) == 0 >>> level_checker({\\"John\\": 7, \\"Doe\\": 9, \\"Jane\\": 11, \\"Smith\\": 4}) == 9 pass","solution":"def is_prime(n): Returns True if n is a prime number, else False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def level_checker(levels): Returns the average level (rounded to the nearest integer) of names whose levels are prime numbers. If there are no prime levels, returns 0. prime_levels = [level for level in levels.values() if is_prime(level)] if not prime_levels: return 0 return round(sum(prime_levels) / len(prime_levels))"},{"question":"def hilltops_surveillance(n, m, edges, k, r): Determine the optimal placement of the watchtowers to maximize the total number of hilltops that can be monitored directly or indirectly. Args: n (int): number of hilltops m (int): number of paths between hilltops edges (List[Tuple[int, int]]): list of bidirectional paths between hilltops k (int): number of watchtowers to be placed r (int): range limit of each watchtower Returns: int: maximum number of hilltops that can be monitored Examples: >>> hilltops_surveillance(6, 7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (4, 5), (5, 6)], 3, 1) 6 >>> hilltops_surveillance(1, 0, [], 1, 1) 1 >>> hilltops_surveillance(5, 0, [], 2, 1) 2 >>> hilltops_surveillance(4, 3, [(1, 2), (1, 3), (1, 4)], 2, 1) 4 >>> hilltops_surveillance(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 1, 2) 5 >>> hilltops_surveillance(100, 99, [(i, i + 1) for i in range(1, 100)], 2, 10) >= 20","solution":"from collections import deque def bfs(graph, start, r): Perform BFS and return nodes covered within range limit \`r\` starting from \`start\` node. visited = set() queue = deque([(start, 0)]) visited.add(start) while queue: current, dist = queue.popleft() if dist < r: for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) return visited def hilltops_surveillance(n, m, edges, k, r): Returns the maximum number of hilltops that can be monitored using k watchtowers. graph = {i: [] for i in range(1, n + 1)} for edge in edges: a, b = edge graph[a].append(b) graph[b].append(a) max_coverage = 0 all_nodes = set(range(1, n + 1)) def place_watchtowers(nodes_remaining, remaining_watchtowers, covered): nonlocal max_coverage if remaining_watchtowers == 0 or not nodes_remaining: max_coverage = max(max_coverage, len(covered)) return for node in nodes_remaining: new_covered = bfs(graph, node, r) new_nodes_remaining = nodes_remaining - new_covered place_watchtowers(new_nodes_remaining, remaining_watchtowers - 1, covered | new_covered) place_watchtowers(all_nodes, k, set()) return max_coverage"},{"question":"def minimize_height_differences(N, heights): Determine the minimum possible sum of the differences in heights between the paired students. >>> minimize_height_differences(6, [10, 20, 30, 40, 50, 60]) 30 >>> minimize_height_differences(5, [10, 20, 30, 40, 50]) 20 >>> minimize_height_differences(1, [10]) 0 >>> minimize_height_differences(2, [1, 10]) 9 >>> minimize_height_differences(4, [1, 1000000000, 2, 999999999]) 2 >>> minimize_height_differences(6, [50, 10, 20, 60, 30, 40]) 30 >>> minimize_height_differences(5, [100, 100, 100, 100, 100]) 0 >>> minimize_height_differences(3, [1000000000, 999999999, 999999998]) 1","solution":"def minimize_height_differences(N, heights): This function returns the minimum possible sum of differences in heights between paired students, given a list of heights. if N <= 1: return 0 heights.sort() min_diff_sum = 0 for i in range(1, N, 2): min_diff_sum += heights[i] - heights[i - 1] return min_diff_sum"},{"question":"from typing import List def split_string(input_string: str, delimiter: str) -> List[str]: Splits the input_string into an array of substrings based on the given delimiter. Parameters: input_string (str): The string to be split. delimiter (str): The delimiter character used to split the string. Returns: list: A list of substrings. Examples: >>> split_string(\\"apple,banana,cherry\\", ',') == [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> split_string(\\"a;b;c;d\\", ';') == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] >>> split_string(\\"one&two&three\\", '&') == [\\"one\\", \\"two\\", \\"three\\"] >>> split_string(\\"apple\\", ',') == [\\"apple\\"] >>> split_string(\\"banana\\", ';') == [\\"banana\\"] >>> split_string(\\"apple\\", '') == [\\"apple\\"] >>> split_string(\\"\\", '') == [\\"\\"] >>> split_string(\\"\\", ',') == [\\"\\"] >>> split_string(\\"apple,\\", ',') == [\\"apple\\", \\"\\"] >>> split_string(\\",apple\\", ',') == [\\"\\", \\"apple\\"] >>> split_string(\\",\\", ',') == [\\"\\", \\"\\"] >>> split_string(\\";;\\", ';') == [\\"\\", \\"\\", \\"\\"] >>> split_string(\\";a;b;c;\\", ';') == [\\"\\", \\"a\\", \\"b\\", \\"c\\", \\"\\"]","solution":"def split_string(input_string, delimiter): Splits the input_string into an array of substrings based on the given delimiter. Parameters: input_string (str): The string to be split. delimiter (str): The delimiter character used to split the string. Returns: list: A list of substrings. if delimiter == \\"\\": return [input_string] return input_string.split(delimiter)"},{"question":"class Library: def __init__(self): self.books = set() self.borrowed_books = {} # Dictionary mapping userId to a set of bookIds def addBook(self, bookId): Adds a new book to the library. def borrowBook(self, userId, bookId): A user borrows a book if it is available. def returnBook(self, userId, bookId): A user returns a book. def getBorrowedBooks(self, userId): Retrieves a list of book ids that the user has currently borrowed. # Unit tests def test_library_operations(): library = Library() # Add books to the library (id = 1, 2). library.addBook(1) library.addBook(2) assert 1 in library.books assert 2 in library.books # User 1 borrows book 1. library.borrowBook(1, 1) assert 1 not in library.books # Book 1 should no longer be available assert library.getBorrowedBooks(1) == [1] # User 1 borrows book 2. library.borrowBook(1, 2) assert 2 not in library.books # Book 2 should no longer be available assert library.getBorrowedBooks(1) == [1, 2] # User 1 returns book 1. library.returnBook(1, 1) assert 1 in library.books # Book 1 should be available again assert library.getBorrowedBooks(1) == [2] # User 2 borrows book 1. library.borrowBook(2, 1) assert 1 not in library.books # Book 1 should no longer be available assert library.getBorrowedBooks(2) == [1] # Ensure User 1's borrowed list is unaffected assert library.getBorrowedBooks(1) == [2] def test_returning_non_borrowed_book(): library = Library() library.addBook(3) # User 2 attempts to return book 3 without borrowing it. library.returnBook(2, 3) assert 3 in library.books # Book 3 should still be in the library because it wasn't borrowed # User 1 borrows book 3, then User 2 attempts to return it. library.borrowBook(1, 3) library.returnBook(2, 3) # User 2 didn't borrow it, should have no effect assert 3 not in library.books # Book 3 should not be in library assert library.getBorrowedBooks(1) == [3] def test_borrowing_nonexistent_book(): library = Library() library.borrowBook(1, 999) # Attempting to borrow a book that doesn't exist assert library.getBorrowedBooks(1) == [] def test_duplicate_addition_of_book(): library = Library() library.addBook(4) library.addBook(4) # Adding the same book twice assert list(library.books).count(4) == 1 # There should be only one instance of book 4","solution":"class Library: def __init__(self): self.books = set() self.borrowed_books = {} # Dictionary mapping userId to a set of bookIds def addBook(self, bookId): Adds a new book to the library. self.books.add(bookId) def borrowBook(self, userId, bookId): A user borrows a book if it is available. if bookId in self.books: if userId not in self.borrowed_books: self.borrowed_books[userId] = set() self.borrowed_books[userId].add(bookId) self.books.remove(bookId) def returnBook(self, userId, bookId): A user returns a book. if userId in self.borrowed_books and bookId in self.borrowed_books[userId]: self.borrowed_books[userId].remove(bookId) self.books.add(bookId) def getBorrowedBooks(self, userId): Retrieves a list of book ids that the user has currently borrowed. if userId in self.borrowed_books: return list(self.borrowed_books[userId]) return []"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained by removing exactly K characters from the input string S. Args: s (str): The input string consisting of lowercase English letters. k (int): The number of characters to remove. Returns: str: The lexicographically smallest string after removing exactly K characters. Examples: >>> lexicographically_smallest_string(\\"cabaab\\", 2) 'aaab' >>> lexicographically_smallest_string(\\"zwacacd\\", 3) 'aacd'","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string that can be obtained by removing exactly K characters from the input string S. stack = [] n = len(s) for i in range(n): while k > 0 and stack and stack[-1] > s[i]: stack.pop() k -= 1 stack.append(s[i]) # If k > 0, remove remaining characters from the end while k > 0: stack.pop() k -= 1 return ''.join(stack)"},{"question":"def can_be_strictly_increasing(n: int, sequence: List[int]) -> str: Determines if the sequence can be made strictly increasing by at most one swap. Parameters: n (int): The length of the sequence. sequence (List[int]): A list of integers representing the sequence. Returns: str: \\"YES\\" if the sequence can be made strictly increasing by one swap, \\"NO\\" otherwise. Examples: >>> can_be_strictly_increasing(5, [1, 5, 3, 4, 2]) \\"YES\\" >>> can_be_strictly_increasing(4, [4, 3, 2, 1]) \\"NO\\" pass # Unit Tests def test_case_1(): assert can_be_strictly_increasing(5, [1, 5, 3, 4, 2]) == \\"YES\\" def test_case_2(): assert can_be_strictly_increasing(4, [4, 3, 2, 1]) == \\"NO\\" def test_case_3(): assert can_be_strictly_increasing(3, [1, 3, 2]) == \\"YES\\" def test_case_4(): assert can_be_strictly_increasing(6, [1, 2, 3, 4, 5, 6]) == \\"YES\\" def test_case_5(): assert can_be_strictly_increasing(4, [1, 3, 2, 4]) == \\"YES\\" def test_case_6(): assert can_be_strictly_increasing(3, [3, 1, 2]) == \\"NO\\" def test_case_7(): assert can_be_strictly_increasing(5, [5, 6, 4, 3, 2]) == \\"NO\\" def test_case_8(): assert can_be_strictly_increasing(7, [1, 2, 3, 5, 4, 6, 7]) == \\"YES\\"","solution":"def can_be_strictly_increasing(n, sequence): Determines if the sequence can be made strictly increasing by at most one swap. def is_increasing(seq): return all(seq[i] < seq[i+1] for i in range(len(seq) - 1)) if is_increasing(sequence): return \\"YES\\" # Check for candidates to swap for i in range(n): for j in range(i + 1, n): # Swap elements at indices i and j sequence[i], sequence[j] = sequence[j], sequence[i] if is_increasing(sequence): return \\"YES\\" # Swap them back sequence[i], sequence[j] = sequence[j], sequence[i] return \\"NO\\""},{"question":"def min_jumps(nums: list[int]) -> int: Returns the minimum number of jumps required to reach the end of the list. If it is not possible to reach the end, returns -1. >>> min_jumps([2, 3, 1, 1, 4]) == 2 >>> min_jumps([3, 2, 1, 0, 4]) == -1 >>> min_jumps([6, 2, 4, 0, 5, 1, 1, 4, 2, 9]) == 2 >>> min_jumps([1, 1, 1, 1]) == 3 >>> min_jumps([0]) == 0 pass","solution":"def min_jumps(nums: list[int]) -> int: Returns the minimum number of jumps required to reach the end of the list. If it is not possible to reach the end, returns -1. n = len(nums) if n == 1: return 0 max_reach = nums[0] steps = nums[0] jumps = 1 for i in range(1, n): if i == n - 1: return jumps max_reach = max(max_reach, i + nums[i]) steps -= 1 if steps == 0: jumps += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"from collections import deque from typing import List, Tuple def bfs_knight_min_moves(sx: int, sy: int, tx: int, ty: int) -> int: Calculates the minimum number of moves for a knight to reach the target position on an infinite chessboard. >>> bfs_knight_min_moves(0, 0, 1, 2) 1 >>> bfs_knight_min_moves(0, 0, 3, 3) 2 pass # Your implementation goes here def minimum_knight_moves(test_cases: List[Tuple[int, int, int, int]]) -> List[int]: For each test case, calculates the minimum number of moves for a knight to reach the target position. >>> test_cases = [(0, 0, 1, 2), (0, 0, 3, 3)] >>> minimum_knight_moves(test_cases) [1, 2] pass # Your implementation goes here","solution":"from collections import deque # Possible moves for the knight moves = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)] def bfs_knight_min_moves(sx, sy, tx, ty): if sx == tx and sy == ty: return 0 # Use a queue to perform BFS queue = deque([(sx, sy, 0)]) # stores (current x, current y, current distance) visited = set((sx, sy)) # set to keep track of visited positions while queue: x, y, dist = queue.popleft() for dx, dy in moves: nx, ny = x + dx, y + dy if (nx, ny) == (tx, ty): return dist + 1 if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # should never reach here for an infinite chessboard def minimum_knight_moves(test_cases): results = [] for sx, sy, tx, ty in test_cases: results.append(bfs_knight_min_moves(sx, sy, tx, ty)) return results"},{"question":"class PrimeSieve: Finds all primes up to a given number n using the Sieve of Eratosthenes. >>> sieve = PrimeSieve(10) >>> sieve.find_primes() [2, 3, 5, 7] >>> sieve = PrimeSieve(30) >>> sieve.find_primes() [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve = PrimeSieve(1) >>> sieve.find_primes() [] >>> sieve = PrimeSieve(2) >>> sieve.find_primes() [2] >>> sieve = PrimeSieve(50) >>> sieve.find_primes() [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> sieve = PrimeSieve(100) >>> sieve.find_primes() [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] def __init__(self, n): self.n = n def find_primes(self): pass","solution":"class PrimeSieve: def __init__(self, n): self.n = n def find_primes(self): if self.n < 2: return [] is_prime = [True] * (self.n + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(self.n**0.5) + 1): if is_prime[i]: for j in range(i * i, self.n + 1, i): is_prime[j] = False return [i for i in range(2, self.n + 1) if is_prime[i]]"},{"question":"def can_arrange_cards(n: int, cards: List[int], k: int) -> Union[str, Tuple[str, List[int]]]: This function determines if the cards can be arranged such that the absolute difference between the numbers on any two adjacent cards is >= k. :param n: Integer representing the number of cards :param cards: List of integers representing the numbers on the cards :param k: Integer representing the minimum required absolute difference :return: \\"NO\\" if arrangement is not possible, otherwise \\"YES\\" and the list of arranged cards >>> can_arrange_cards(5, [1, 3, 5, 7, 9], 2) ('YES', [1, 3, 5, 7, 9]) >>> can_arrange_cards(4, [1, 2, 3, 4], 3) 'NO' from typing import List, Union, Tuple # Test Cases def test_possible_arrangement(): assert can_arrange_cards(5, [1, 3, 5, 7, 9], 2) == (\\"YES\\", [1, 3, 5, 7, 9]) assert can_arrange_cards(6, [10, 20, 30, 40, 50, 60], 10) == (\\"YES\\", [10, 20, 30, 40, 50, 60]) def test_not_possible_arrangement(): assert can_arrange_cards(4, [1, 2, 3, 4], 3) == \\"NO\\" assert can_arrange_cards(3, [1, 2, 4], 3) == \\"NO\\" def test_single_card(): assert can_arrange_cards(1, [5], 1) == (\\"YES\\", [5]) def test_already_satisfies(): assert can_arrange_cards(5, [1, 4, 7, 10, 13], 3) == (\\"YES\\", [1, 4, 7, 10, 13]) def test_unsorted_input(): assert can_arrange_cards(3, [10, 5, 1], 4) == (\\"YES\\", [1, 5, 10])","solution":"def can_arrange_cards(n, cards, k): This function determines if the cards can be arranged such that the absolute difference between the numbers on any two adjacent cards is >= k. cards.sort() for i in range(1, n): if abs(cards[i] - cards[i-1]) < k: return \\"NO\\" return \\"YES\\", cards # Example usage: n = 5 cards = [1, 3, 5, 7, 9] k = 2 result = can_arrange_cards(n, cards, k) print(result)"},{"question":"def min_download_days(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Given the number of test cases and the details for each test case, determine the minimum number of days required to download all the books for each test case. Args: t : int Number of test cases. test_cases : list of tuples Each tuple contains: - n (int): Number of books to download. - max_downloads (int): Maximum downloads allowed per day. - book_ids (list of int): List of book IDs the user wants to download. Returns: list of int : A list containing the minimum number of days required for each test case. Examples: >>> min_download_days(3, [(4, 2, [1, 2, 3, 4]), (5, 3, [5, 6, 7, 8, 9]), (7, 1, [10, 11, 12, 13, 14, 15, 16])]) [2, 2, 7] def test_min_download_days(): input_data = \\"3n4n2n1 2 3 4n5n3n5 6 7 8 9n7n1n10 11 12 13 14 15 16n\\" t, test_cases = parse_input(input_data) assert min_download_days(t, test_cases) == [2, 2, 7] def test_min_download_days_single_case(): input_data = \\"1n5n1n1 2 3 4 5n\\" t, test_cases = parse_input(input_data) assert min_download_days(t, test_cases) == [5] def test_min_download_days_max_downloads_equals_books(): input_data = \\"1n5n5n1 2 3 4 5n\\" t, test_cases = parse_input(input_data) assert min_download_days(t, test_cases) == [1] def test_min_download_days_zero_max_downloads(): input_data = \\"1n5n0n1 2 3 4 5n\\" t, test_cases = parse_input(input_data) assert min_download_days(t, test_cases) == [0] def test_min_download_days_large_numbers(): input_data = \\"1n100000n1000n\\" + \\" \\".join(map(str, range(1, 100001))) + \\"n\\" t, test_cases = parse_input(input_data) assert min_download_days(t, test_cases) == [100] def parse_input(input_string): lines = input_string.split(\\"n\\") t = int(lines[0].strip()) test_cases = [] line_index = 1 for _ in range(t): n = int(lines[line_index].strip()) max_downloads = int(lines[line_index + 1].strip()) book_ids = list(map(int, lines[line_index + 2].strip().split())) test_cases.append((n, max_downloads, book_ids)) line_index += 3 return t, test_cases","solution":"def min_download_days(t, test_cases): Given the number of test cases and the details for each test case, determine the minimum number of days required to download all the books for each test case. Args: t : int Number of test cases. test_cases : list of tuples Each tuple contains: - n (int): Number of books to download. - max_downloads (int): Maximum downloads allowed per day. - book_ids (list of int): List of book IDs the user wants to download. Returns: list of int : A list containing the minimum number of days required for each test case. result = [] for case in test_cases: n, max_downloads, book_ids = case if max_downloads == 0: result.append(0) else: days = (n + max_downloads - 1) // max_downloads result.append(days) return result # Use the parse_input function to parse the input format conveniently def parse_input(input_string): lines = input_string.split(\\"n\\") t = int(lines[0].strip()) test_cases = [] line_index = 1 for _ in range(t): n = int(lines[line_index].strip()) max_downloads = int(lines[line_index + 1].strip()) book_ids = list(map(int, lines[line_index + 2].strip().split())) test_cases.append((n, max_downloads, book_ids)) line_index += 3 return t, test_cases"},{"question":"def reverse_sentence(sentence: str) -> str: Reverses the words in a sentence while maintaining the original punctuation and capitalization. >>> reverse_sentence(\\"Hello, world!\\") --> \\"world! Hello,\\" >>> reverse_sentence(\\"The quick brown fox.\\") --> \\"fox. brown quick The\\" >>> reverse_sentence(\\"A man, a plan, a canal: Panama.\\") --> \\"Panama. canal: a plan, a man, A\\" >>> reverse_sentence(\\"Python is cool.\\") --> \\"cool. is Python\\"","solution":"def reverse_sentence(sentence): Reverses the words in a sentence while maintaining the original punctuation and capitalization. Params: sentence (str): The sentence to reverse Returns: str: The sentence with words in reverse order. # Split the sentence into words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join them back into a string reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def min_deletions_to_make_unique(s: str) -> int: Returns the minimum number of deletions required to make all characters in the string \`s\` unique. >>> min_deletions_to_make_unique(\\"abacabad\\") == 4 >>> min_deletions_to_make_unique(\\"bbbbbb\\") == 5 pass def process_input(T: int, cases: List[str]) -> List[int]: Processes multiple test cases and returns the results as a list of integers. >>> process_input(2, [\\"abacabad\\", \\"bbbbbb\\"]) == [4, 5] >>> process_input(1, [\\"abcdef\\"]) == [0] pass","solution":"def min_deletions_to_make_unique(s): Returns the minimum number of deletions required to make all characters in the string \`s\` unique. frequency = {} for char in s: frequency[char] = frequency.get(char, 0) + 1 deletions = 0 for count in frequency.values(): if count > 1: deletions += count - 1 return deletions def process_input(T, cases): Processes multiple test cases and returns the results as a list of integers. results = [] for case in cases: result = min_deletions_to_make_unique(case) results.append(result) return results"},{"question":"def longest_good_subarray(nums: List[int]) -> int: Returns the length of the longest subarray with an even sum. A subarray is \\"good\\" if its sum is even. >>> longest_good_subarray([1, 2, 3, 4, 5]) 4 >>> longest_good_subarray([2, 4, 6, 8, 10]) 5 >>> longest_good_subarray([1, 1, 1, 1, 1]) 4 >>> longest_good_subarray([-1, -2, -3, -4, -5]) 4","solution":"def longest_good_subarray(nums): Returns the length of the longest subarray with an even sum. A subarray is \\"good\\" if its sum is even. # Initialize the maximum length of good subarray max_len = 0 current_sum = 0 # Dictionary to store the first occurrence of a specific sum sum_index = {0: -1} for i, num in enumerate(nums): current_sum += num # If current_sum is even, update max_len if current_sum % 2 == 0: max_len = max(max_len, i - sum_index.get(current_sum % 2, i)) # Store the first occurrence of the remainder of current_sum divided by 2 if current_sum % 2 not in sum_index: sum_index[current_sum % 2] = i return max_len"},{"question":"def count_distinct_palindromic_numbers(n: int, numbers: List[int]) -> int: Count the number of distinct palindromic numbers in the list. >>> count_distinct_palindromic_numbers(5, [121, 123, 121, 1331, 10]) 2 >>> count_distinct_palindromic_numbers(4, [7, 2233, 3443, 7]) 2","solution":"def count_distinct_palindromic_numbers(n, numbers): def is_palindromic(num): str_num = str(num) return str_num == str_num[::-1] palindromic_set = set() for number in numbers: if is_palindromic(number): palindromic_set.add(number) return len(palindromic_set)"},{"question":"def generate_pascals_triangle(n: int) -> List[List[int]]: Generates the first N rows of Pascal's Triangle. >>> generate_pascals_triangle(1) [[1]] >>> generate_pascals_triangle(2) [[1], [1, 1]] >>> generate_pascals_triangle(3) [[1], [1, 1], [1, 2, 1]] >>> generate_pascals_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] pass def print_pascals_triangle(triangle: List[List[int]]) -> None: Prints Pascal's Triangle row by row. >>> print_pascals_triangle([[1]]) 1 >>> print_pascals_triangle([[1], [1, 1]]) 1n1 1 >>> print_pascals_triangle([[1], [1, 1], [1, 2, 1]]) 1n1 1n1 2 1 >>> print_pascals_triangle([[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]) 1n1 1n1 2 1n1 3 3 1n1 4 6 4 1 pass","solution":"def generate_pascals_triangle(n): Generates the first N rows of Pascal's Triangle. if n <= 0: return [] triangle = [[1]] for i in range(1, n): row = [1] for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) triangle.append(row) return triangle def print_pascals_triangle(triangle): Prints Pascal's Triangle row by row. for row in triangle: print(\\" \\".join(map(str, row)))"},{"question":"def max_sum_sorted_seq(K: int, D: int, B: List[int]) -> int: Given a sequence of positive integers B of length K and a positive integer D, determine the maximum possible sum of the resulting sequence when sorted in non-decreasing order, using the given swap condition. :param K: Length of the sequence :param D: Maximum allowed absolute difference for swaps :param B: List of integers representing the sequence :return: Integer representing the maximum sum of the resulting sorted sequence >>> max_sum_sorted_seq(4, 3, [1, 5, 2, 4]) 12 >>> max_sum_sorted_seq(1, 10, [10]) 10 >>> max_sum_sorted_seq(2, 1, [4, 2]) 6 >>> max_sum_sorted_seq(4, 3, [1, 2, 3, 4]) 10 >>> max_sum_sorted_seq(4, 3, [4, 3, 2, 1]) 10 >>> max_sum_sorted_seq(3, 10, [7, 1, 3]) 11 >>> max_sum_sorted_seq(5, 1, [100, 200, 300, 400, 500]) 1500 >>> max_sum_sorted_seq(4, 2, [3, 3, 3, 3]) 12","solution":"def max_sum_sorted_seq(K, D, B): Given a sequence of positive integers B of length K and a positive integer D, sorts the sequence minimizing the condition on D and returns the sum of the resulting sequence. :param K: Length of the sequence :param D: Maximum allowed absolute difference for swaps :param B: List of integers representing the sequence :return: Integer representing the maximum sum of the resulting sorted sequence # Sort the sequence to comply with the non-decreasing order requirement B_sorted = sorted(B) # Calculate the sum of the sorted sequence max_sum = sum(B_sorted) return max_sum"},{"question":"def contains_magic_square(grid): Returns \\"YES\\" if the grid contains any magic square of size 3x3, otherwise \\"NO\\". >>> contains_magic_square([[4, 9, 2, 3], [3, 5, 7, 8], [8, 1, 6, 3], [2, 7, 6, 9]]) 'YES' >>> contains_magic_square([[4, 8, 2, 4, 9], [3, 5, 7, 23, 5], [8, 1, 6, 4, 1], [1, 9, 8, 2, 7], [2, 7, 6, 9, 3]]) 'NO'","solution":"def is_magic_square(matrix, row, col): Helper function to check if a 3x3 grid with top-left corner at (row, col) is a magic square. s = set() # Sum of the first row magic_sum = sum(matrix[row][col:col+3]) for i in range(3): if sum(matrix[row+i][col:col+3]) != magic_sum: return False s.update(matrix[row+i][col:col+3]) for j in range(3): col_sum = sum(matrix[row+i][col+j] for i in range(3)) if col_sum != magic_sum: return False # Sum of diagonals if sum(matrix[row+i][col+i] for i in range(3)) != magic_sum: return False if sum(matrix[row+i][col+2-i] for i in range(3)) != magic_sum: return False return len(s) == 9 # There should be exactly 9 distinct values def contains_magic_square(grid): Returns \\"YES\\" if the grid contains any magic square of size 3x3, otherwise \\"NO\\". n = len(grid) for i in range(n - 2): for j in range(n - 2): if is_magic_square(grid, i, j): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def has_pair_with_sum(numbers: List[int], target: int) -> bool: Determines if there are two distinct integers in the list that sum up to the target value. Parameters: numbers (List[int]): List of integers. target (int): The target sum value. Returns: bool: True if there are two distinct numbers in the list that sum up to the target, otherwise False. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([-2, 1, 2, 4, 7], 5) True >>> has_pair_with_sum([1, 3, 5, 7, 9], 10) True >>> has_pair_with_sum([2, 4, 6, 8], 3) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 10) False >>> has_pair_with_sum([5], 5) False >>> has_pair_with_sum([3, 3, 3, 3], 6) True >>> has_pair_with_sum([1, 3, 3, 7], 6) True >>> has_pair_with_sum([1, 3, 3, 7], 5) False","solution":"from typing import List def has_pair_with_sum(numbers: List[int], target: int) -> bool: Determines if there are two distinct integers in the list that sum up to the target value. Parameters: numbers (List[int]): List of integers. target (int): The target sum value. Returns: bool: True if there are two distinct numbers in the list that sum up to the target, otherwise False. seen = set() for num in numbers: if target - num in seen: return True seen.add(num) return False"},{"question":"def rotateArray(arr, k): Rotate the array to the right by k steps. >>> rotateArray([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotateArray([1, 2, 3, 4, 5], 3) [3, 4, 5, 1, 2] >>> rotateArray([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotateArray([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotateArray([], 3) [] >>> rotateArray([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotateArray([1, 2, 3, 4, 5], -3) [1, 2, 3, 4, 5]","solution":"def rotateArray(arr, k): Rotates the array to the right by k steps. if not arr or k <= 0: return arr n = len(arr) k = k % n return arr[-k:] + arr[:-k]"},{"question":"def evaluate_expression(input_str: str): Evaluates a simple mathematical expression given as a string. >>> evaluate_expression(\\"3+5\\") 8 >>> evaluate_expression(\\"10-2*5\\") 0 >>> evaluate_expression(\\"(8+2)/2\\") 5.0 >>> evaluate_expression(\\"7+3*2/(1+1)\\") 10 Args: input_str (str): The mathematical expression to evaluate. Returns: float or int: The result of the evaluated expression, or None if division by zero occurs.","solution":"def evaluate_expression(input_str): Evaluates a simple mathematical expression given as a string. try: # Evaluate expression and return result result = eval(input_str, {\\"__builtins__\\": None}, {}) return result except ZeroDivisionError: return None except Exception as e: raise ValueError(\\"Invalid input expression\\") # Examples # print(evaluate_expression(\\"3+5\\")) # 8 # print(evaluate_expression(\\"10-2*5\\")) # 0 # print(evaluate_expression(\\"(8+2)/2\\")) # 5.0 # print(evaluate_expression(\\"7+3*2/(1+1)\\")) # 10"},{"question":"def min_moves_to_sort(arr): Returns the minimum number of adjacent swaps to sort the array in non-decreasing order. >>> min_moves_to_sort([3, 2, 1]) 3 >>> min_moves_to_sort([4, 3, 2, 1]) 6 >>> min_moves_to_sort([1, 2, 3]) 0 >>> min_moves_to_sort([2, 1, 3]) 1 >>> min_moves_to_sort([5, 4, 3, 2, 1]) 10 pass def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list. >>> process_test_cases([(3, [3, 2, 1]), (4, [4, 3, 2, 1])]) [3, 6] >>> process_test_cases([(5, [5, 4, 3, 2, 1]), (3, [1, 3, 2])]) [10, 1] pass","solution":"def min_moves_to_sort(arr): Returns the minimum number of adjacent swaps to sort the array in non-decreasing order. n = len(arr) moves = 0 # Bubble Sort to count the moves for i in range(n-1): for j in range(n-1-i): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] moves += 1 return moves def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list. results = [] for case in test_cases: n, arr = case result = min_moves_to_sort(arr) results.append(result) return results"},{"question":"def analyze_sales(P, D, sales): Analyze the sales data of a bakery and determine the total units sold for each type of pastry and the index of the pastry type with the highest average sales per day. Args: P (int): The number of pastry types. D (int): The number of days the sales were tracked. sales (List[List[int]]): A list of lists, where each inner list contains P integers representing the number of units sold for each pastry type on a given day. Returns: Tuple[List[int], int]: A tuple containing a list of total units sold for each pastry type and the index (1-based) of the pastry type with the highest average sales per day. >>> analyze_sales(3, 4, [[10, 20, 30], [15, 25, 10], [20, 10, 25], [5, 30, 15]]) ([50, 85, 80], 2) >>> analyze_sales(1, 1, [[10]]) ([10], 1) # Implement the function body here def format_output(total_sales_per_pastry, max_average_index): Format the output for total sales per pastry and the index of the pastry type with the highest average sales. Args: total_sales_per_pastry (List[int]): A list of total units sold for each pastry type. max_average_index (int): The index (1-based) of the pastry type with the highest average sales per day. Returns: Tuple[str, str]: A tuple containing two strings: one representing the total sales per pastry and the other representing the index of the highest average sales pastry type. >>> format_output([50, 85, 80], 2) (\\"50 85 80\\", \\"2\\") >>> format_output([10], 1) (\\"10\\", \\"1\\") # Implement the function body here","solution":"def analyze_sales(P, D, sales): total_sales_per_pastry = [0] * P for day_sales in sales: for i in range(P): total_sales_per_pastry[i] += day_sales[i] average_sales_per_pastry = [total_sales_per_pastry[i] / D for i in range(P)] max_average_index = average_sales_per_pastry.index(max(average_sales_per_pastry)) + 1 return total_sales_per_pastry, max_average_index def format_output(total_sales_per_pastry, max_average_index): return ( ' '.join(map(str, total_sales_per_pastry)), str(max_average_index) )"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" True >>> longest_palindromic_substring(\\"aacabdkacaa\\") == \\"aca\\" True >>> longest_palindromic_substring(\\"a\\") == \\"a\\" True >>> longest_palindromic_substring(\\"ab\\") in [\\"a\\", \\"b\\"] True >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" True >>> longest_palindromic_substring(\\"abcba\\") == \\"abcba\\" True >>> longest_palindromic_substring(\\"abcde\\") in [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] True >>> longest_palindromic_substring(\\"a\\" * 1000) == \\"a\\" * 1000 True","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in s. def expand_around_center(s, left, right): Expand around the center to find the longest palindromic substring. while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Check for odd-length palindromes odd_palindrome = expand_around_center(s, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Check for even-length palindromes even_palindrome = expand_around_center(s, i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"def arrange_boxes(n: int, weights: List[int]) -> str: Arrange the boxes in an alternating weight pattern. Args: n : int : number of boxes weights : list of int : list of weights of the boxes Returns: str : the sequence of weights in the required order or \\"Not Possible\\" if arrangement is not possible. >>> arrange_boxes(5, [5, 3, 9, 1, 7]) \\"9 1 7 3 5\\" >>> arrange_boxes(4, [2, 2, 2, 2]) \\"Not Possible\\" from solution import arrange_boxes def test_example_1(): assert arrange_boxes(5, [5, 3, 9, 1, 7]) == \\"9 1 7 3 5\\" def test_example_2(): assert arrange_boxes(4, [2, 2, 2, 2]) == \\"Not Possible\\" def test_unique_weights(): assert arrange_boxes(3, [3, 1, 2]) == \\"3 1 2\\" def test_single_box(): assert arrange_boxes(1, [5]) == \\"5\\" def test_two_boxes(): assert arrange_boxes(2, [5, 2]) == \\"5 2\\" def test_even_number_of_boxes(): assert arrange_boxes(4, [8, 6, 7, 5]) == \\"8 5 7 6\\" def test_large_input(): large_list = list(range(1, 101)) result = arrange_boxes(100, large_list) expected_list = [str(i) for sublist in zip(large_list[::-1][:50], large_list[:50]) for i in sublist] assert result == \\" \\".join(expected_list)","solution":"def arrange_boxes(n, weights): Arrange the boxes in an alternating weight pattern. Args: n : int : number of boxes weights : list of int : list of weights of the boxes Returns: str : the sequence of weights in the required order or \\"Not Possible\\" if arrangement is not possible. if len(set(weights)) != len(weights): return \\"Not Possible\\" weights.sort() result = [] for i in range(n//2): result.append(weights[-(i + 1)]) result.append(weights[i]) if n % 2 == 1: result.append(weights[n // 2]) return \\" \\".join(map(str, result))"},{"question":"from typing import List def reorganize_string(s: str) -> str: Reorder a string such that no two adjacent characters are the same. Args: s (str): A string consisting of lowercase letters. Returns: str: The rearranged string or an empty string if it's not possible to rearrange. Examples: >>> reorganize_string(\\"aab\\") 'aba' >>> reorganize_string(\\"aaab\\") ''","solution":"from collections import Counter import heapq def reorganize_string(s): count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char return ''.join(result) if len(result) == len(s) else ''"},{"question":"def first_missing_positive(nums): Returns the smallest positive integer missing from the array nums. Parameters: nums (list): A list of integers. Returns: int: The smallest positive integer missing from the array nums. Examples: >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 from solution import first_missing_positive def test_case_1(): assert first_missing_positive([3, 4, -1, 1]) == 2 def test_case_2(): assert first_missing_positive([1, 2, 0]) == 3 def test_case_3(): assert first_missing_positive([7, 8, 9, 11, 12]) == 1 def test_case_all_negatives(): assert first_missing_positive([-1, -2, -3, -4]) == 1 def test_case_with_duplicates(): assert first_missing_positive([1, 1, 2, 2]) == 3 def test_case_single_element(): assert first_missing_positive([1]) == 2 assert first_missing_positive([2]) == 1 assert first_missing_positive([-1]) == 1 def test_case_mixed_signs(): assert first_missing_positive([0, 1, 2, 3, -4]) == 4 def test_large_array(): assert first_missing_positive(list(range(1, 1001))) == 1001","solution":"def first_missing_positive(nums): Returns the smallest positive integer missing from the array nums. length = len(nums) # First we need to ensure the numbers that are out of the desired range are # replaced with a placeholder (length + 1) which is out of range for i in range(length): if nums[i] <= 0 or nums[i] > length: nums[i] = length + 1 # Use the index as a hash key to record the presence of integers for i in range(length): num = abs(nums[i]) if num <= length: nums[num - 1] = -abs(nums[num - 1]) # Find the first index which is positive, which indicates the missing number for i in range(length): if nums[i] > 0: return i + 1 return length + 1"},{"question":"def check_suffixes(s: str, suffixes: List[str]) -> List[bool]: Determines which suffixes in the list are genuine suffixes of the given string s. Args: s: The original string from which we want to determine suffixes. suffixes: A list of strings representing the suffixes to check. Returns: A list of booleans indicating if each suffix in the list is a true suffix of s. >>> check_suffixes(\\"example\\", [\\"ple\\", \\"ample\\", \\"exam\\"]) [True, True, False] >>> check_suffixes(\\"123456789\\", [\\"6789\\", \\"56789\\", \\"456789\\", \\"56788\\"]) [True, True, True, False] >>> check_suffixes(\\"abcdef\\", [\\"a\\", \\"ab\\", \\"abc\\"]) [False, False, False] >>> check_suffixes(\\"suffix\\", [\\"x\\", \\"fix\\", \\"uffix\\", \\"suffix\\"]) [True, True, True, True] >>> check_suffixes(\\"\\", [\\"\\", \\"a\\", \\" \\"]) [True, False, False]","solution":"def check_suffixes(s, suffixes): Determines which suffixes in the list are genuine suffixes of the given string s. Args: s: The original string from which we want to determine suffixes. suffixes: A list of strings representing the suffixes to check. Returns: A list of booleans indicating if each suffix in the list is a true suffix of s. return [s.endswith(suffix) for suffix in suffixes]"},{"question":"def collect_packages(n: int, m: int, warehouse_grid: List[str], initial_positions: List[Tuple[int, int]], commands: str) -> int: Simulate robot movement in a warehouse grid and count the number of packages collected. Args: n: Number of rows in the warehouse grid. m: Number of columns in the warehouse grid. warehouse_grid: List of strings representing the warehouse grid. initial_positions: List of tuples representing the initial positions of the robots. commands: String containing the movement commands for the robots. Returns: The number of packages collected by the robots. >>> collect_packages(5, 5, [\\"..P..\\", \\".\\", \\"P...P\\", \\".#.\\", \\"..P#.\\"], [(2, 2), (4, 1)], \\"RDDLLU\\") 1 >>> collect_packages(3, 3, [\\"...\\", \\"...\\", \\"...\\"], [(1, 1), (2, 2)], \\"UU\\") 0","solution":"def collect_packages(n, m, warehouse_grid, initial_positions, commands): collected_packages = set() directions = { 'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1) } for x, y in initial_positions: x -= 1 y -= 1 for command in commands: new_x = x + directions[command][0] new_y = y + directions[command][1] if 0 <= new_x < n and 0 <= new_y < m and warehouse_grid[new_x][new_y] != '#': x, y = new_x, new_y if warehouse_grid[x][y] == 'P': collected_packages.add((x, y)) return len(collected_packages)"},{"question":"def find_top_runners(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[List[int]]: Identify the top k runners based on their finishing order. >>> find_top_runners(2, [[(5, 3), [10, 20, 15, 12, 11]], [(4, 2), [18, 16, 20, 17]]]) [[1, 5, 4], [2, 4]] >>> find_top_runners(1, [[(1, 1), [5]]]) [[1]] >>> find_top_runners(1, [[(3, 2), [5, 5, 5]]]) [[1, 2]] >>> find_top_runners(1, [[(5, 3), [5, 7, 5, 8, 5]]]) [[1, 3, 5]] >>> find_top_runners(1, [[(6, 4), [9, 7, 8, 7, 10, 6]]]) [[6, 2, 4, 3]]","solution":"def find_top_runners(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] times = test_cases[i][1] bib_times = list(enumerate(times, start=1)) bib_times.sort(key=lambda x: (x[1], x[0])) top_runners = [bib_times[j][0] for j in range(k)] results.append(top_runners) return results"},{"question":"from typing import List, Tuple def analyze_user_actions(log_entries: List[Tuple[str, int]], a: int, b: int) -> Tuple[int, str, str]: Counts the users who have performed at least one action within the given time frame and identifies the users with the most and least actions during that period. Arguments: log_entries -- list of tuples (username, timestamp) a -- start of the time interval b -- end of the time interval Returns: tuple containing: - number of unique users who have performed at least one action within the given time frame - username of the user with the most actions within the period - username of the user with the least actions within the period >>> analyze_user_actions([(\\"alice\\", 100), (\\"bob\\", 200), (\\"alice\\", 300), (\\"charlie\\", 400), (\\"bob\\", 500)], 100, 400) (3, 'alice', 'bob') >>> analyze_user_actions([(\\"alice\\", 10), (\\"bob\\", 20), (\\"charlie\\", 30)], 100, 400) (0, 'NONE', 'NONE') >>> analyze_user_actions([(\\"alice\\", 150), (\\"bob\\", 250), (\\"charlie\\", 350)], 100, 400) (3, 'alice', 'alice')","solution":"from collections import defaultdict def analyze_user_actions(log_entries, a, b): Counts the users who have performed at least one action within the given time frame and identifies the users with the most and least actions during that period. Arguments: log_entries -- list of tuples (username, timestamp) a -- start of the time interval b -- end of the time interval Returns: tuple containing: - number of unique users who have performed at least one action within the given time frame - username of the user with the most actions within the period - username of the user with the least actions within the period actions_within_timeframe = defaultdict(int) for username, timestamp in log_entries: if a <= timestamp <= b: actions_within_timeframe[username] += 1 if not actions_within_timeframe: return 0, \\"NONE\\", \\"NONE\\" max_actions_user = max(actions_within_timeframe, key=actions_within_timeframe.get) min_actions_user = min(actions_within_timeframe, key=actions_within_timeframe.get) return len(actions_within_timeframe), max_actions_user, min_actions_user"},{"question":"def max_distinct_substrings(s: str) -> int: Write a function to determine the maximum number of distinct substrings that can be formed from a given string of lowercase letters. A substring is defined as a contiguous sequence of characters within a string. Duplicate substrings should be counted as one. >>> max_distinct_substrings(\\"abc\\") 6 >>> max_distinct_substrings(\\"aaa\\") 3 >>> max_distinct_substrings(\\"ababa\\") 9","solution":"def max_distinct_substrings(s: str) -> int: Returns the maximum number of distinct substrings that can be formed from the given string. substrings = set() n = len(s) for i in range(n): for j in range(i, n): substrings.add(s[i:j+1]) return len(substrings)"},{"question":"def tsp(n, roads): Alex is planning a road trip and wants to visit several cities. Each city is connected by one or more roads, with each road having a specific length. Alex wants to find out the minimum distance he needs to travel to visit all the cities starting from his home city. Given a list of roads connecting the cities and their lengths, determine the minimum total distance required for Alex to visit all the cities starting from city 1 (Alex's home city) and returning to it. Parameters: n (int): the number of cities roads (List[Tuple[int, int, int]]): a list of tuples, where each tuple contains three integers u, v, and w representing a road between cities u and v with length w Returns: int: the minimum distance needed to visit all cities starting and ending at city 1. If it is not possible to visit all cities, return -1. >>> tsp(4, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (3, 4, 25), (2, 4, 30)]) 80 >>> tsp(3, [(1, 2, 10)]) -1 >>> tsp(4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10)]) 40 >>> tsp(4, [(1, 2, 100), (1, 3, 100), (1, 4, 100), (2, 3, 100), (3, 4, 100), (2, 4, 100)]) 400 >>> tsp(2, [(1, 2, 1)]) 2 pass import pytest def test_example_case(): assert tsp(4, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (3, 4, 25), (2, 4, 30)]) == 80 def test_disconnected_graph(): assert tsp(3, [(1, 2, 10)]) == -1 def test_simple_connected_graph(): assert tsp(4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10)]) == 40 def test_large_distance(): assert tsp(4, [(1, 2, 100), (1, 3, 100), (1, 4, 100), (2, 3, 100), (3, 4, 100), (2, 4, 100)]) == 400 def test_single_road(): assert tsp(2, [(1, 2, 1)]) == 2 pytest.main()","solution":"def tsp(n, roads): from itertools import permutations import sys INF = sys.maxsize # Create adjacency matrix dist = [[INF] * n for _ in range(n)] for u, v, w in roads: dist[u-1][v-1] = w dist[v-1][u-1] = w # Check for disconnected graph def is_connected_graph(): visited = [False] * n def dfs(node): visited[node] = True for neighbor in range(n): if dist[node][neighbor] != INF and not visited[neighbor]: dfs(neighbor) dfs(0) return all(visited) if not is_connected_graph(): return -1 # dynamic programming approach for TSP dp = [[INF] * n for _ in range(1 << n)] dp[1][0] = 0 for mask in range(1 << n): for i in range(n): if mask & (1 << i): for j in range(n): if not (mask & (1 << j)) and dist[i][j] != INF: dp[mask | (1 << j)][j] = min(dp[mask | (1 << j)][j], dp[mask][i] + dist[i][j]) answer = min(dp[(1 << n) - 1][i] + dist[i][0] for i in range(n) if dist[i][0] != INF) return answer if answer != INF else -1 # Example usage assert tsp(4, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (3, 4, 25), (2, 4, 30)]) == 80"},{"question":"from typing import List def obfuscate_string(s: str) -> str: Obfuscate the input string \`s\` by replacing each letter with the next letter in the alphabet and each digit with the next sequential digit. Non-alphanumeric characters remain unchanged. >>> obfuscate_string(\\"hello-world123!\\") == \\"ifmmp-xpsme234!\\" >>> obfuscate_string(\\"zZ9\\") == \\"aA0\\" >>> obfuscate_string(\\"abcxyz\\") == \\"bcdyza\\" >>> obfuscate_string(\\"ABCXYZ\\") == \\"BCDYZA\\" >>> obfuscate_string(\\"1234567890\\") == \\"2345678901\\" >>> obfuscate_string(\\"No change! 2021\\") == \\"Op dibohf! 3132\\" pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Given T test cases, apply the obfuscation function on each and return the results. >>> process_test_cases(2, [\\"hello-world123!\\", \\"zZ9\\"]) == [\\"ifmmp-xpsme234!\\", \\"aA0\\"] >>> process_test_cases(1, [\\"hello\\"]) == [\\"ifmmp\\"] >>> process_test_cases(3, [\\"xyz\\", \\"789\\", \\"!@#\\"]) == [\\"yza\\", \\"890\\", \\"!@#\\"] pass","solution":"def obfuscate_string(s): Obfuscate the input string \`s\` by replacing each letter with the next letter in the alphabet and each digit with the next sequential digit. Non-alphanumeric characters remain unchanged. result = [] for char in s: if 'a' <= char <= 'z': new_char = chr((ord(char) - ord('a') + 1) % 26 + ord('a')) elif 'A' <= char <= 'Z': new_char = chr((ord(char) - ord('A') + 1) % 26 + ord('A')) elif '0' <= char <= '9': new_char = chr((ord(char) - ord('0') + 1) % 10 + ord('0')) else: new_char = char result.append(new_char) return ''.join(result) def process_test_cases(T, test_cases): Given T test cases, apply the obfuscation function on each and return the results. results = [] for i in range(T): results.append(obfuscate_string(test_cases[i])) return results"},{"question":"def longestTwoDistinctCharsSubstring(S: str) -> int: Given a string S, find the length of the longest substring that contains exactly two distinct characters. >>> longestTwoDistinctCharsSubstring(\\"eceba\\") 3 >>> longestTwoDistinctCharsSubstring(\\"ccaabbb\\") 5 >>> longestTwoDistinctCharsSubstring(\\"a\\") 1 >>> longestTwoDistinctCharsSubstring(\\"abc\\") 2 >>> longestTwoDistinctCharsSubstring(\\"aaaa\\") 4 >>> longestTwoDistinctCharsSubstring(\\"\\") 0 >>> longestTwoDistinctCharsSubstring(\\"abcdef\\") 2 >>> longestTwoDistinctCharsSubstring(\\"ab\\") 2 >>> longestTwoDistinctCharsSubstring(\\"a\\" * 100000) 100000 >>> longestTwoDistinctCharsSubstring(\\"ab\\" * 50000) 100000 >>> longestTwoDistinctCharsSubstring(\\"abaccc\\") 4","solution":"def longestTwoDistinctCharsSubstring(S: str) -> int: Returns the length of the longest substring that contains exactly two distinct characters. if len(S) < 2: return len(S) left = 0 right = 0 char_map = {} max_length = 0 while right < len(S): char_map[S[right]] = char_map.get(S[right], 0) + 1 right += 1 while len(char_map) > 2: char_map[S[left]] -= 1 if char_map[S[left]] == 0: del char_map[S[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"def min_groups_required(n, toys): Determines the minimum number of groups such that each student in a group has the same number of toys. Args: n: Integer, the number of students. toys: List of integers, number of toys each student has. Returns: Integer, the minimum number of groups required. pass def test_min_groups_required(): # Sample test case assert min_groups_required(5, [1, 2, 2, 3, 3]) == 3 # Custom test cases assert min_groups_required(4, [1, 1, 1, 1]) == 1 assert min_groups_required(3, [1, 2, 3]) == 3 assert min_groups_required(5, [3, 3, 3, 3, 3]) == 1 assert min_groups_required(6, [1, 2, 3, 1, 2, 3]) == 3 assert min_groups_required(0, []) == 0 assert min_groups_required(5, [5, 5, 5, 0, 0]) == 2 assert min_groups_required(7, [1, 2, 1, 2, 1, 2, 1]) == 2 assert min_groups_required(2, [0, 999999]) == 2 assert min_groups_required(3, [1000000, 1000000, 1000000]) == 1 # Running the tests test_min_groups_required()","solution":"def min_groups_required(n, toys): Determines the minimum number of groups such that each student in a group has the same number of toys. Args: n: Integer, the number of students. toys: List of integers, number of toys each student has. Returns: Integer, the minimum number of groups required. toy_count = {} # Count the frequency of each toys number for toy in toys: if toy in toy_count: toy_count[toy] += 1 else: toy_count[toy] = 1 # The number of unique keys in toy_count represents the number of groups required return len(toy_count)"},{"question":"def max_area(height: List[int]) -> int: Returns the maximum area of water a container can store given the heights of the bars. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([0, 0, 0, 0]) 0 >>> max_area([4, 4, 4, 4, 4]) 16 >>> max_area([1, 2, 3, 4, 5]) 6 >>> max_area([5, 4, 3, 2, 1]) 6 >>> max_area([1, 3, 2, 5, 25, 24, 5]) 24 >>> max_area([5]) 0 >>> max_area([1, 1]) 1 >>> max_area([5, 5]) 5","solution":"def max_area(height): Returns the maximum area of water a container can store given the heights of the bars. left, right = 0, len(height) - 1 max_area = 0 while left < right: # Calculate the width and the current area formed. width = right - left current_area = min(height[left], height[right]) * width # Update max_area if current_area is larger. max_area = max(max_area, current_area) # Move the pointers to try to find a larger area. if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"def smallest_lexicographical_string(n: int, s: str) -> str: Returns the lexicographically smallest string t that can be obtained by moving a prefix of s to the end. :param n: length of the string s :param s: string consisting only of lowercase English letters :return: lexicographically smallest string t >>> smallest_lexicographical_string(4, \\"bcda\\") \\"abcd\\" >>> smallest_lexicographical_string(5, \\"aebdc\\") \\"aebdc\\" >>> smallest_lexicographical_string(6, \\"dcbabc\\") \\"abcdcb\\"","solution":"def smallest_lexicographical_string(n, s): Returns the lexicographically smallest string t that can be obtained by moving a prefix of s to the end. smallest_string = s for i in range(1, n): new_string = s[i:] + s[:i] if new_string < smallest_string: smallest_string = new_string return smallest_string"},{"question":"def maxAreaOfIsland(grid: List[List[str]]) -> int: Returns the area of the largest piece of connected land. Example 1: >>> grid = [ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ] >>> maxAreaOfIsland(grid) 4 Example 2: >>> grid = [ ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ... ] >>> maxAreaOfIsland(grid) 0 Note: - The input grid will have dimensions \`n x m\`, where 1 <= n, m <= 100. - Each cell in the input grid is either '1' (land) or '0' (water). pass def test_maxAreaOfIsland_example1(): grid = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] assert maxAreaOfIsland(grid) == 4 def test_maxAreaOfIsland_example2(): grid = [ [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ] assert maxAreaOfIsland(grid) == 0 def test_maxAreaOfIsland_single_land_cell(): grid = [ [\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"1\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\"] ] assert maxAreaOfIsland(grid) == 1 def test_maxAreaOfIsland_multiple_disconnected_lands(): grid = [ [\\"1\\",\\"0\\",\\"0\\",\\"1\\"], [\\"0\\",\\"1\\",\\"1\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\"], [\\"1\\",\\"1\\",\\"0\\",\\"1\\"] ] assert maxAreaOfIsland(grid) == 2 def test_maxAreaOfIsland_all_land(): grid = [ [\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\"] ] assert maxAreaOfIsland(grid) == 9","solution":"def maxAreaOfIsland(grid): def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == '0': return 0 grid[x][y] = '0' area = 1 area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"def longest_distinct_subsequence_length(bead_string: str) -> int: Returns the length of the longest subsequence of distinct beads. Parameters: bead_string (str): A string representing the beads on the rope. Returns: int: The length of the longest subsequence of distinct beads. >>> longest_distinct_subsequence_length(\\"abcdef\\") == 6 >>> longest_distinct_subsequence_length(\\"aaaaa\\") == 1 >>> longest_distinct_subsequence_length(\\"abacc\\") == 3 >>> longest_distinct_subsequence_length(\\"abcabcabc\\") == 3 >>> longest_distinct_subsequence_length(\\"a\\") == 1 >>> longest_distinct_subsequence_length(\\"\\") == 0","solution":"def longest_distinct_subsequence_length(bead_string): Returns the length of the longest subsequence of distinct beads. Parameters: bead_string (str): A string representing the beads on the rope. Returns: int: The length of the longest subsequence of distinct beads. # Set to store unique characters char_set = set() for char in bead_string: char_set.add(char) return len(char_set)"},{"question":"def minimum_swaps(n, arr): Returns the minimum number of swaps required to sort the array in ascending order. :param n: int, number of employees (length of the array) :param arr: list of int, employee IDs :return: int, minimum number of swaps","solution":"def minimum_swaps(n, arr): Returns the minimum number of swaps required to sort the array in ascending order. :param n: int, number of employees (length of the array) :param arr: list of int, employee IDs :return: int, minimum number of swaps arr = list(arr) # Make a copy of the array count = 0 index_dict = {value: index for index, value in enumerate(arr)} for i in range(n): while arr[i] != i + 1: correct_index = index_dict[i + 1] index_dict[arr[i]] = correct_index arr[i], arr[correct_index] = arr[correct_index], arr[i] count += 1 return count"},{"question":"def warehouse_inventory(n: int, m: int, initial_stock: List[int], queries: List[str]) -> List[int]: Manage a warehouse inventory system that tracks multiple product types. Parameters: n (int): Number of different product types. m (int): Number of queries. initial_stock (List[int]): Initial stock of each product type. queries (List[str]): List of queries to perform (add, remove, check stock level). >>> warehouse_inventory(3, 5, [10, 5, 20], [\\"+ 1 5\\", \\"- 2 3\\", \\"? 1\\", \\"? 2\\", \\"+ 3 10\\"]) [15, 2] >>> warehouse_inventory(1, 2, [100], [\\"? 1\\", \\"? 1\\"]) [100, 100] >>> warehouse_inventory(2, 3, [50, 75], [\\"+ 2 25\\", \\"- 2 50\\", \\"? 2\\"]) [50] >>> warehouse_inventory(1, 3, [1000000000], [\\"+ 1 1000000000\\", \\"- 1 500000000\\", \\"? 1\\"]) [1500000000] >>> warehouse_inventory(4, 4, [10, 20, 30, 40], [\\"+ 3 10\\", \\"- 4 5\\", \\"? 3\\", \\"? 4\\"]) [40, 35]","solution":"def warehouse_inventory(n, m, initial_stock, queries): stock = initial_stock[:] results = [] for query in queries: split_query = query.split() if split_query[0] == \\"+\\": x = int(split_query[1]) - 1 k = int(split_query[2]) stock[x] += k elif split_query[0] == \\"-\\": x = int(split_query[1]) - 1 k = int(split_query[2]) stock[x] -= k elif split_query[0] == \\"?\\": x = int(split_query[1]) - 1 results.append(stock[x]) return results"},{"question":"def largest_even_odd_subgrid(n: int, m: int, grid: List[List[int]]) -> int: Determine the size of the largest rectangular subgrid whose elements are either all odd or all even. >>> largest_even_odd_subgrid(3, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == 3 >>> largest_even_odd_subgrid(4, 5, [[1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4]]) == 5 >>> largest_even_odd_subgrid(1, 1, [[3]]) == 1 >>> largest_even_odd_subgrid(2, 3, [[1, 2, 1], [2, 4, 2]]) == 3 >>> largest_even_odd_subgrid(3, 3, [[2, 2, 2], [2, 2, 2], [2, 2, 2]]) == 9 pass # implement the function here def test_largest_even_odd_subgrid_case_1(): n = 3 m = 4 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] assert largest_even_odd_subgrid(n, m, grid) == 3 def test_largest_even_odd_subgrid_case_2(): n = 4 m = 5 grid = [ [1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4] ] assert largest_even_odd_subgrid(n, m, grid) == 5 def test_largest_even_odd_subgrid_single_element(): n = 1 m = 1 grid = [ [3] ] assert largest_even_odd_subgrid(n, m, grid) == 1 def test_largest_even_odd_subgrid_mixed(): n = 2 m = 3 grid = [ [1, 2, 1], [2, 4, 2] ] assert largest_even_odd_subgrid(n, m, grid) == 3 def test_largest_even_odd_subgrid_large_all_same_parity(): n = 3 m = 3 grid = [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ] assert largest_even_odd_subgrid(n, m, grid) == 9","solution":"def largest_even_odd_subgrid(n, m, grid): # Identify the parity of each element is_even = [[(grid[i][j] % 2 == 0) for j in range(m)] for i in range(n)] # Maximum rectangle size max_size = 0 # Helper function to calculate the largest rectangle area in a histogram def largest_rectangle_area(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area # Dynamic Programming for each row dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if is_even[i][j]: if i == 0: dp[i][j] = 1 else: dp[i][j] = dp[i-1][j] + 1 else: dp[i][j] = 0 # For each row compute the maximum rectangle area for row in dp: max_size = max(max_size, largest_rectangle_area(row)) # Repeat the process for odd parity (is_even=False) dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if not is_even[i][j]: if i == 0: dp[i][j] = 1 else: dp[i][j] = dp[i-1][j] + 1 else: dp[i][j] = 0 for row in dp: max_size = max(max_size, largest_rectangle_area(row)) return max_size"},{"question":"def calculate_expenditure_and_most_expensive_item(data): This function calculates total expenditure and identifies the most expensive item from the purchase data. Parameters: data (list of str): List of strings where the first element is the number of items, followed by item names and costs. Returns: tuple: total expenditure as float and the name of the most expensive item as a string. >>> calculate_expenditure_and_most_expensive_item([\\"3\\", \\"apple 1.20\\", \\"banana 2.50\\", \\"orange 1.50\\"]) (5.20, \\"banana\\") >>> calculate_expenditure_and_most_expensive_item([\\"1\\", \\"apple 1.20\\"]) (1.20, \\"apple\\") from solution import calculate_expenditure_and_most_expensive_item def test_single_item(): assert calculate_expenditure_and_most_expensive_item([\\"1\\", \\"apple 1.20\\"]) == (1.20, \\"apple\\") def test_multiple_items(): assert calculate_expenditure_and_most_expensive_item([\\"3\\", \\"apple 1.20\\", \\"banana 2.50\\", \\"orange 1.50\\"]) == (5.20, \\"banana\\") assert calculate_expenditure_and_most_expensive_item([\\"4\\", \\"mango 3.00\\", \\"grape 2.50\\", \\"banana 3.00\\", \\"apple 2.50\\"]) == (11.00, \\"mango\\") def test_items_with_same_cost(): assert calculate_expenditure_and_most_expensive_item([\\"2\\", \\"apple 3.00\\", \\"banana 3.00\\"]) == (6.00, \\"apple\\") def test_zero_cost_items(): assert calculate_expenditure_and_most_expensive_item([\\"3\\", \\"apple 0.00\\", \\"banana 0.00\\", \\"orange 0.00\\"]) == (0.00, \\"apple\\") def test_large_number_of_items(): N = 100 items = [f\\"item{i} {i*0.1:.2f}\\" for i in range(1, N+1)] data = [str(N)] + items total_cost = sum(i*0.1 for i in range(1, N+1)) assert calculate_expenditure_and_most_expensive_item(data) == (round(total_cost, 2), \\"item100\\")","solution":"def calculate_expenditure_and_most_expensive_item(data): This function calculates total expenditure and identifies the most expensive item from the purchase data. Parameters: data (list of str): List of strings where the first element is the number of items, followed by item names and costs. Returns: tuple: total expenditure as float and the name of the most expensive item as a string. n = int(data[0]) total_expenditure = 0.0 most_expensive_item = \\"\\" highest_cost = -1.0 for i in range(1, n + 1): item_info = data[i].split() item_name = item_info[0] item_cost = float(item_info[1]) total_expenditure += item_cost if item_cost > highest_cost: highest_cost = item_cost most_expensive_item = item_name return round(total_expenditure, 2), most_expensive_item"},{"question":"def is_perfect(n: int) -> bool: Determine if a positive integer n is a perfect number. Return True if n is a perfect number, otherwise return False. >>> is_perfect(6) == True >>> is_perfect(28) == True >>> is_perfect(12) == False >>> is_perfect(496) == True >>> is_perfect(8128) == True","solution":"def is_perfect(n): Determines if a given positive integer n is a perfect number. if n <= 1: return False divisors_sum = 1 for i in range(2, int(n**0.5) + 1): if n % i == 0: divisors_sum += i if i != n // i: divisors_sum += n // i return divisors_sum == n"},{"question":"def largest_prime_factors(numbers_list: List[int]) -> List[Tuple[int, int]]: Write a function that takes a list of integers and returns a list of tuples, where each tuple contains two elements: the integer and its largest prime factor. If the number is prime, the second element should be the number itself. >>> largest_prime_factors([10, 15, 21, 7, 13]) [(10, 5), (15, 5), (21, 7), (7, 7), (13, 13)] >>> largest_prime_factors([2, 3, 5, 7, 11]) [(2, 2), (3, 3), (5, 5), (7, 7), (11, 11)]","solution":"def largest_prime_factors(numbers_list): def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def get_largest_prime_factor(n): if is_prime(n): return n largest_factor = 1 while n % 2 == 0: largest_factor = 2 n //= 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: largest_factor = i n //= i if n > 2: largest_factor = n return largest_factor return [(num, get_largest_prime_factor(num)) for num in numbers_list]"},{"question":"def min_toggles_to_turn_on_all_bulbs(n: int, s: str) -> int: Determine the minimum number of toggles needed to turn on all the light bulbs. >>> min_toggles_to_turn_on_all_bulbs(5, \\"01011\\") 2 >>> min_toggles_to_turn_on_all_bulbs(3, \\"000\\") 3 >>> min_toggles_to_turn_on_all_bulbs(4, \\"1111\\") 0 >>> min_toggles_to_turn_on_all_bulbs(1, \\"1\\") 0 >>> min_toggles_to_turn_on_all_bulbs(1, \\"0\\") 1 >>> min_toggles_to_turn_on_all_bulbs(6, \\"101010\\") 3","solution":"def min_toggles_to_turn_on_all_bulbs(n, s): Returns the minimum number of toggles needed to turn on all the light bulbs. # Initialize the toggle count toggles = 0 # Iterate through the binary string for i in range(n): # If the current bulb is '0', we need to toggle it to '1' if s[i] == '0': toggles += 1 return toggles"},{"question":"def is_unique(s: str) -> bool: Write a function that determines whether all characters in a given string are unique. The function should return \`true\` if all characters are unique, \`false\` otherwise. The check should be case-sensitive, meaning 'a' and 'A' are considered different characters. For example: >>> is_unique('abcdef') --> True >>> is_unique('aA') --> True >>> is_unique('hello') --> False","solution":"def is_unique(s): Returns True if all characters in the string are unique, False otherwise. The check is case-sensitive. :param s: Input string :type s: str :return: Boolean indicating whether all characters in the string are unique :rtype: bool return len(s) == len(set(s))"},{"question":"def min_moves_to_all_lights(m, n): Returns the minimum number of moves required to turn on all lights in an m x n grid. >>> min_moves_to_all_lights(2, 2) 4 >>> min_moves_to_all_lights(3, 3) 9 >>> min_moves_to_all_lights(1, 1) 1 >>> min_moves_to_all_lights(10, 10) 100 >>> min_moves_to_all_lights(4, 3) 12 >>> min_moves_to_all_lights(1, 5) 5 >>> min_moves_to_all_lights(6, 1) 6 ... def process_input(inputs): Processes the given input for multiple test cases and returns the results. test_cases = int(inputs[0]) results = [] index = 1 for _ in range(test_cases): m, n = map(int, inputs[index].split()) result = min_moves_to_all_lights(m, n) results.append(result) index += 1 return results","solution":"def min_moves_to_all_lights(m, n): Returns the minimum number of moves required to turn on all lights in an m x n grid. # Since toggling one cell affects its neighbors, we can consider the minimum moves # as the coverage needed to turn on all lights. Essentially, to be comprehensive in # cases where grid sizes are small (1 up to 10 in this problem's constraints), every # single cell needs to be toggled independently at least once. # The minimum number of moves required is equal to m * n as each move toggles 1 cell # and its adjacent cells. return m * n def process_input(inputs): Processes the given input for multiple test cases and returns the results. test_cases = int(inputs[0]) results = [] index = 1 for _ in range(test_cases): m, n = map(int, inputs[index].split()) result = min_moves_to_all_lights(m, n) results.append(result) index += 1 return results"},{"question":"def findMedian(matrix): Returns the median of a matrix where each row is sorted in ascending order. >>> findMedian([[1, 3, 5], [2, 6, 9], [3, 6, 9]]) 5 >>> findMedian([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 5 >>> findMedian([[10]]) 10 >>> findMedian([[1, 3], [2, 4]]) 2 >>> findMedian([[1000000000 for _ in range(3)] for _ in range(3)]) 1000000000","solution":"def findMedian(matrix): Returns the median of a matrix where each row is sorted in ascending order. r = len(matrix) # number of rows c = len(matrix[0]) # number of columns def countLessthanEqual(matrix, mid): count = 0 for i in range(r): l, h = 0, c-1 while l <= h: md = (l + h) // 2 if matrix[i][md] <= mid: l = md + 1 else: h = md - 1 count += l return count low, high = matrix[0][0], matrix[0][0] for i in range(r): low = min(low, matrix[i][0]) high = max(high, matrix[i][c-1]) while low < high: mid = (low + high) // 2 count = countLessthanEqual(matrix, mid) if count < (r * c + 1) // 2: low = mid + 1 else: high = mid return low"},{"question":"def adjusted_average_score(n, student_scores): Computes the adjusted average score for each student after dropping their lowest score. Args: n: int - Number of students student_scores: list of tuples - Each tuple contains the number of exams and the list of exam scores Returns: list of floats - List of adjusted average scores for each student, rounded to 2 decimal places Examples: >>> n, student_scores = process_input([\\"3\\", \\"4\\", \\"75 80 90 100\\", \\"3\\", \\"60 70 80\\", \\"2\\", \\"88 92\\"]) >>> adjusted_average_score(n, student_scores) [90.00, 75.00, 92.00] pass def process_input(data): Processes the input data and returns the number of students and their scores in the required format. Args: data: list of strings - Input data as described in the problem statement Returns: tuple: (number of students, list of tuples with exam count and scores) Examples: >>> process_input([\\"3\\", \\"4\\", \\"75 80 90 100\\", \\"3\\", \\"60 70 80\\", \\"2\\", \\"88 92\\"]) (3, [(4, [75, 80, 90, 100]), (3, [60, 70, 80]), (2, [88, 92])]) pass # Unit Test def test_adjusted_average_score(): data = [ \\"3\\", \\"4\\", \\"75 80 90 100\\", \\"3\\", \\"60 70 80\\", \\"2\\", \\"88 92\\" ] n, student_scores = process_input(data) result = adjusted_average_score(n, student_scores) assert result == [90.00, 75.00, 92.00] def test_process_input(): data = [ \\"3\\", \\"4\\", \\"75 80 90 100\\", \\"3\\", \\"60 70 80\\", \\"2\\", \\"88 92\\" ] n, student_scores = process_input(data) assert n == 3 assert student_scores == [ (4, [75, 80, 90, 100]), (3, [60, 70, 80]), (2, [88, 92]) ] def test_adjusted_average_score_edge_case(): data = [ \\"1\\", \\"2\\", \\"90 10\\" ] n, student_scores = process_input(data) result = adjusted_average_score(n, student_scores) assert result == [90.00] def test_adjusted_average_score_multiple_kinds(): data = [ \\"1\\", \\"5\\", \\"55 65 75 85 95\\" ] n, student_scores = process_input(data) result = adjusted_average_score(n, student_scores) assert result == [80.00]","solution":"def adjusted_average_score(n, student_scores): Computes the adjusted average score for each student after dropping their lowest score. Args: n: int - Number of students student_scores: list of tuples - Each tuple contains the number of exams and the list of exam scores Returns: list of floats - List of adjusted average scores for each student, rounded to 2 decimal places results = [] for exams, scores in student_scores: scores.sort() adjusted_scores = scores[1:] # Drop the lowest score average_score = sum(adjusted_scores) / len(adjusted_scores) results.append(round(average_score, 2)) return results def process_input(data): Processes the input data and returns the number of students and their scores in the required format. Args: data: list of strings - Input data as described in the problem statement Returns: tuple: (number of students, list of tuples with exam count and scores) n = int(data[0]) student_scores = [] index = 1 for _ in range(n): m = int(data[index]) scores = list(map(int, data[index + 1].split())) student_scores.append((m, scores)) index += 2 return n, student_scores"},{"question":"def find_healthy_ingredients(available_ingredients, healthy_ingredients): Filters the available ingredients and returns only those that are considered healthy by Chef. Args: available_ingredients (list of str): List of ingredients available in the market. healthy_ingredients (list of str): List of ingredients considered healthy by Chef. Returns: list of str: List of healthy ingredients available in the market, in the same order as provided in healthy_ingredients. >>> find_healthy_ingredients( ... [\\"tomato\\", \\"cucumber\\", \\"lettuce\\", \\"onion\\", \\"carrot\\"], ... [\\"lettuce\\", \\"carrot\\", \\"celery\\"] ... ) [\\"lettuce\\", \\"carrot\\"] >>> find_healthy_ingredients( ... [\\"tomato\\", \\"cucumber\\", \\"lettuce\\", \\"onion\\", \\"carrot\\"], ... [\\"spinach\\", \\"rocket\\", \\"celery\\"] ... ) [] >>> find_healthy_ingredients( ... [\\"tomato\\", \\"cucumber\\", \\"lettuce\\", \\"onion\\", \\"carrot\\", \\"celery\\"], ... [\\"lettuce\\", \\"carrot\\", \\"celery\\"] ... ) [\\"lettuce\\", \\"carrot\\", \\"celery\\"] >>> find_healthy_ingredients([], [\\"lettuce\\", \\"carrot\\", \\"celery\\"]) [] >>> find_healthy_ingredients( ... [\\"tomato\\", \\"cucumber\\", \\"lettuce\\", \\"onion\\", \\"carrot\\"], []) [] >>> find_healthy_ingredients([], []) [] # Your code here","solution":"def find_healthy_ingredients(available_ingredients, healthy_ingredients): Filters the available ingredients and returns only those that are considered healthy by Chef. Args: available_ingredients (list of str): List of ingredients available in the market. healthy_ingredients (list of str): List of ingredients considered healthy by Chef. Returns: list of str: List of healthy ingredients available in the market, in the same order as provided in healthy_ingredients. available_set = set(available_ingredients) return [ingredient for ingredient in healthy_ingredients if ingredient in available_set]"},{"question":"def merge_intervals(intervals): Merges and returns the list of overlapping intervals. Args: intervals (list): List of intervals [start, end]. Returns: list: List of merged intervals. Example: >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18], [16, 17], [17, 20]]) [[1, 6], [8, 10], [15, 20]] >>> merge_intervals([[5, 10], [1, 4], [6, 8], [2, 3]]) [[1, 4], [5, 10]] >>> merge_intervals([[0, 1], [1, 2]]) [[0, 2]] def format_intervals(intervals): Formats intervals for output. Args: intervals (list): List of intervals [start, end]. Returns: str: Formatted string of intervals, each in a new line. Example: >>> format_intervals([[1, 6], [8, 10], [15, 20]]) '1 6n8 10n15 20'","solution":"def merge_intervals(intervals): Merges and returns the list of overlapping intervals. Args: intervals (list): List of intervals [start, end]. Returns: list: List of merged intervals. if not intervals: return [] # Sort the intervals based on the starting times intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If merged list is empty or no overlap, append the interval to merged if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # If there is overlap, merge the intervals merged[-1][1] = max(merged[-1][1], interval[1]) return merged # Helper function to format the output def format_intervals(intervals): Formats intervals for output. Args: intervals (list): List of intervals [start, end]. Returns: str: Formatted string of intervals, each in a new line. return 'n'.join(f\\"{start} {end}\\" for start, end in intervals)"},{"question":"class DHCPServer: A simple DHCP server simulator to allocate, release, and renew IP addresses for devices. Attributes: - ip_pool: List of IP addresses available for allocation. - allocated_ips: Dictionary mapping device IDs to allocated IP addresses. Methods: - request_ip(device_id: str) -> str: Allocates an IP address to the device. - release_ip(device_id: str) -> bool: Releases the IP address from the device. - renew_ip(device_id: str) -> bool: Renews the IP address lease for the device. Example Usage: >>> dhcp = DHCPServer(ip_pool=['192.168.1.1', '192.168.1.2', '192.168.1.3']) >>> dhcp.request_ip('device1') '192.168.1.1' >>> dhcp.request_ip('device2') '192.168.1.2' >>> dhcp.release_ip('device1') True >>> dhcp.renew_ip('device2') True >>> dhcp.request_ip('device3') '192.168.1.3' >>> dhcp.request_ip('device1') '192.168.1.1' >>> dhcp.release_ip('device4') False >>> dhcp.request_ip('device4') None def __init__(self, ip_pool): pass # Implementation will initialize the IP pool and the allocated IPs dictionary def request_ip(self, device_id): pass # Implementation will allocate an IP address to the device if available def release_ip(self, device_id): pass # Implementation will release the allocated IP address from the device def renew_ip(self, device_id): pass # Implementation will renew the IP address lease for the device import pytest def test_request_ip(): dhcp = DHCPServer(ip_pool=['192.168.1.1', '192.168.1.2', '192.168.1.3']) assert dhcp.request_ip('device1') == '192.168.1.1' assert dhcp.request_ip('device2') == '192.168.1.2' assert dhcp.request_ip('device1') == '192.168.1.1' def test_release_ip(): dhcp = DHCPServer(ip_pool=['192.168.1.1', '192.168.1.2', '192.168.1.3']) dhcp.request_ip('device1') assert dhcp.release_ip('device1') == True assert dhcp.release_ip('device1') == False assert dhcp.release_ip('device_not_allocated') == False def test_renew_ip(): dhcp = DHCPServer(ip_pool=['192.168.1.1', '192.168.1.2', '192.168.1.3']) dhcp.request_ip('device1') assert dhcp.renew_ip('device1') == True assert dhcp.renew_ip('device_not_allocated') == False def test_request_ip_after_release(): dhcp = DHCPServer(ip_pool=['192.168.1.1', '192.168.1.2', '192.168.1.3']) dhcp.request_ip('device1') dhcp.release_ip('device1') assert dhcp.request_ip('device1') == '192.168.1.1' def test_request_ip_no_available_ips(): dhcp = DHCPServer(ip_pool=['192.168.1.1']) dhcp.request_ip('device1') assert dhcp.request_ip('device2') == None","solution":"class DHCPServer: def __init__(self, ip_pool): self.ip_pool = ip_pool # Initial pool of IP addresses self.allocated_ips = {} # Dictionary to keep track of device-IP allocation def request_ip(self, device_id): # If device already has an allocated IP, return it if device_id in self.allocated_ips: return self.allocated_ips[device_id] # If there is an available IP address in pool, allocate it to device for ip in self.ip_pool: if ip not in self.allocated_ips.values(): self.allocated_ips[device_id] = ip return ip # No available IP addresses return None def release_ip(self, device_id): if device_id in self.allocated_ips: del self.allocated_ips[device_id] return True return False def renew_ip(self, device_id): return device_id in self.allocated_ips"},{"question":"def max_non_overlapping_activities(n: int, activities: List[Tuple[int, int]]) -> int: This function receives the number of activities and a list of activities (each activity is a list of two integers [start, end]) and returns the maximum number of non-overlapping activities. Args: n: An integer representing the number of activities. activities: A list of tuples, where each tuple contains two integers representing the start and end times of an activity. Returns: An integer representing the maximum number of non-overlapping activities. Example: >>> max_non_overlapping_activities(4, [(1000, 1030), (1100, 1200), (1230, 1300), (1200, 1230)]) 4 >>> max_non_overlapping_activities(3, [(1900, 2000), (1800, 1900), (1700, 1800)]) 3 >>> max_non_overlapping_activities(5, [(900, 1030), (1000, 1100), (1030, 1200), (1330, 1430), (900, 900)]) 4 pass from typing import List, Tuple def test_max_non_overlapping_activities_case1(): activities = [ [1000, 1030], [1100, 1200], [1230, 1300], [1200, 1230] ] assert max_non_overlapping_activities(4, activities) == 4 def test_max_non_overlapping_activities_case2(): activities = [ [1900, 2000], [1800, 1900], [1700, 1800] ] assert max_non_overlapping_activities(3, activities) == 3 def test_max_non_overlapping_activities_case3(): activities = [ [900, 1030], [1000, 1100], [1030, 1200], [1330, 1430], [900, 900] ] assert max_non_overlapping_activities(5, activities) == 4 def test_max_non_overlapping_activities_case4(): activities = [ [0, 1000], [200, 300], [400, 500] ] assert max_non_overlapping_activities(3, activities) == 2 def test_max_non_overlapping_activities_case5(): activities = [ [900, 930], [940, 1000], [1005, 1100], [1120, 1200] ] assert max_non_overlapping_activities(4, activities) == 4","solution":"def max_non_overlapping_activities(n, activities): This function receives the number of activities and a list of activities (each activity is a list of two integers [start, end]) and returns the maximum number of non-overlapping activities. # Sort activities based on their end times. activities.sort(key=lambda x: x[1]) max_activities = 0 last_end_time = -1 for start, end in activities: # If the current activity starts after the last selected activity ends if start >= last_end_time: max_activities += 1 last_end_time = end return max_activities"},{"question":"def longest_consecutive_sequence(arr: List[int]) -> int: Given an unsorted array of integers, find the length of the longest consecutive sequence of numbers in the array. Args: arr: List of integers Returns: Length of the longest consecutive sequence >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2, 101, 102, 103, 104]) 5 >>> longest_consecutive_sequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_sequence([10, 1, 3, 5, 2, 4]) 5 >>> longest_consecutive_sequence([5, 7, 9, 11, 13]) 1 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) 4 >>> longest_consecutive_sequence([1]) 1 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([10**9 - 1, 10**9 - 2, 10**9 - 3, 10**9 - 5, 10**9 - 4]) 5 >>> longest_consecutive_sequence([-1, -2, -3, -4, -5, 0, 1]) 7 >>> longest_consecutive_sequence([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]) 11","solution":"def longest_consecutive_sequence(arr): Finds the longest consecutive sequence in an array. Args: arr: List of integers Returns: Length of the longest consecutive sequence if not arr: return 0 # Convert to set, as lookups in sets are O(1) num_set = set(arr) max_length = 0 for num in num_set: # Check if num is the start of a sequence if num - 1 not in num_set: current_num = num current_length = 1 # Check length of the current sequence while current_num + 1 in num_set: current_num += 1 current_length += 1 # Update max_length max_length = max(max_length, current_length) return max_length"},{"question":"def max_binary_ones_and_count(sequence): This function returns the maximum value of the sum of binary digits of elements in the sequence and the number of times this maximum value occurs in the sequence. :param sequence: List of non-negative integers :return: A tuple (max_g, count_max_g) >>> max_binary_ones_and_count([3, 7, 8, 15, 6]) (4, 1) >>> max_binary_ones_and_count([0, 0, 0, 0]) (0, 4)","solution":"def max_binary_ones_and_count(sequence): This function returns the maximum value of the sum of binary digits of elements in the sequence and the number of times this maximum value occurs in the sequence. :param sequence: List of non-negative integers :return: A tuple (max_g, count_max_g) max_g = -1 count_max_g = 0 for number in sequence: g = bin(number).count('1') if g > max_g: max_g = g count_max_g = 1 elif g == max_g: count_max_g += 1 return max_g, count_max_g"},{"question":"def department_productivity(N, departments): Calculate the overall productivity score for each department and list department productivity in decreasing order. Args: N (int): Number of departments. departments (List[List[int]]): Each sublist contains an integer D followed by D employee scores. Returns: List[int]: List of department indices sorted by productivity scores in decreasing order. Example: >>> department_productivity(3, [ ... [5, 99, 85, 91, 93, 88], ... [3, 78, 82, 81], ... [4, 97, 83, 79, 85] ... ]) [1, 3, 2]","solution":"def department_productivity(N, departments): department_scores = [] for idx, dept in enumerate(departments, 1): D = dept[0] scores = dept[1:] average_score = sum(scores) / D department_scores.append((idx, average_score)) department_scores.sort(key=lambda x: (-x[1], x[0])) return [dept[0] for dept in department_scores] # Example usage N = 3 departments = [ [5, 99, 85, 91, 93, 88], [3, 78, 82, 81], [4, 97, 83, 79, 85] ] print(department_productivity(N, departments)) # Output: [1, 3, 2]"},{"question":"def can_reach_each_delivery_point(N, grid, delivery_points): Determines whether the delivery robot can reach each delivery point in a grid city. The city is represented as a grid of size N x N, where each cell in the grid can either be an empty cell that the robot can traverse ('0') or an obstacle cell that the robot cannot traverse ('X'). The robot starts at the top-left corner of the grid (0, 0) and another integer K indicates the number of delivery points. Each delivery point is specified by its row and column index (1-based indexing). Args: N (int): the size of the grid (N x N) grid (List[List[str]]): the grid representation, where '0' is an empty cell and 'X' is an obstacle delivery_points (List[Tuple[int, int]]): the list of delivery point coordinates (1-based indexing) Returns: List[str]: A list of \\"YES\\" or \\"NO\\" indicating whether the robot can reach each delivery point Example: >>> N = 5 >>> grid = [['0', '0', 'X', '0', '0'], ['0', 'X', '0', 'X', '0'], ['0', 'X', '0', 'X', '0'], ['0', '0', '0', '0', '0'], ['X', 'X', 'X', 'X', '0']] >>> delivery_points = [(5, 5), (3, 2), (1, 3)] >>> can_reach_each_delivery_point(N, grid, delivery_points) ['YES', 'NO', 'NO']","solution":"def can_reach_each_delivery_point(N, grid, delivery_points): from collections import deque def is_valid_move(x, y, visited): return 0 <= x < N and 0 <= y < N and grid[x][y] == '0' and (x, y) not in visited def bfs(start, target): queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == target: return \\"YES\\" for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid_move(nx, ny, visited): queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\" results = [] start = (0, 0) for xi, yi in delivery_points: target = (xi - 1, yi - 1) results.append(bfs(start, target)) return results"},{"question":"def sort_students_with_heels(heights, heels): Returns the sorted heights of students after accounting for the added height from heels. >>> sort_students_with_heels([150, 160, 155], [0, 0, 0]) [150, 155, 160] >>> sort_students_with_heels([150, 160, 155], [5, 0, 10]) [155, 160, 165] >>> sort_students_with_heels([150, 160, 155], [10, 5, 20]) [160, 165, 175] >>> sort_students_with_heels([170], [10]) [180] >>> sort_students_with_heels([150, 160, 170], [10, 10, 10]) [160, 170, 180]","solution":"def sort_students_with_heels(heights, heels): Returns the sorted heights of students after accounting for the added height from heels. # Calculate the actual heights by adding heels actual_heights = [height + heel for height, heel in zip(heights, heels)] # Sort the actual heights sorted_heights = sorted(actual_heights) return sorted_heights"},{"question":"def length_of_longest_special_substring(s: str) -> int: Returns the length of the longest substring where every character appears only once. >>> length_of_longest_special_substring(\\"abcabcbb\\") 3 >>> length_of_longest_special_substring(\\"bbbbb\\") 1 >>> length_of_longest_special_substring(\\"pwwkew\\") 3 >>> length_of_longest_special_substring(\\"aab\\") 2","solution":"def length_of_longest_special_substring(s: str) -> int: Returns the length of the longest substring where every character appears only once. # Set to store unique characters in the current window char_set = set() l = 0 longest_length = 0 for r in range(len(s)): # If character s[r] is already in the set, # move the left pointer to the right until s[r] is not in the set while s[r] in char_set: char_set.remove(s[l]) l += 1 # Add the current character to the set and update the result if needed char_set.add(s[r]) longest_length = max(longest_length, r - l + 1) return longest_length"},{"question":"def find_unique_element(n: int, elements: List[int]) -> int: Find the integer that appears only once in a sequence where every other integer appears exactly twice. >>> find_unique_element(5, [1, 2, 3, 2, 1]) == 3 >>> find_unique_element(7, [4, 5, 6, 7, 6, 5, 4]) == 7 >>> find_unique_element(1, [10]) == 10 >>> find_unique_element(9, [8, 12, 8, 3, 12, 7, 3, 4, 7]) == 4 >>> find_unique_element(3, [1, 3, 1]) == 3","solution":"def find_unique_element(n, elements): This function finds the element that appears only once in the given list where every other element appears twice. :param n: int - total number of elements in the list :param elements: list of int - the sequence of elements :return: int - the element that appears only once unique_element = 0 for element in elements: unique_element ^= element return unique_element"},{"question":"from typing import List def find_shortest_word_length(s: str) -> int: Write a function that takes a string of space-separated words and returns the length of the shortest word. Args: s (str): a string of space-separated words. Returns: int: the length of the shortest word. Examples: >>> find_shortest_word_length(\\"The quick brown fox jumps over the lazy dog\\") 3 >>> find_shortest_word_length(\\"Elephant\\") 8 >>> find_shortest_word_length(\\"this is a test case\\") 1 >>> find_shortest_word_length(\\"word ward lord card\\") 4 >>> find_shortest_word_length(\\"Biggest Among All\\") 3 >>> find_shortest_word_length(\\" word test here \\") 4","solution":"def find_shortest_word_length(s): This function takes a string of space-separated words and returns the length of the shortest word. words = s.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"def longestPalindrome(s: str) -> int: Determine the length of the longest palindrome that can be built with the letters in the string s. >>> longestPalindrome(\\"abccccdd\\") 7 >>> longestPalindrome(\\"a\\") 1 >>> longestPalindrome(\\"abc\\") 1 >>> longestPalindrome(\\"aaaa\\") 4 >>> longestPalindrome(\\"aaabbb\\") 5 >>> longestPalindrome(\\"abccccddeeffgghhiijj\\") 19 >>> longestPalindrome(\\"\\") 0 >>> longestPalindrome(\\"abcba\\") 5","solution":"def longestPalindrome(s): Determine the length of the longest palindrome that can be built with the letters in the string s. from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def longest_ap_subsequence_length(array): Determines the length of the longest contiguous subsequence that forms an arithmetic progression (AP) in the given array of integers. :param array: A list of integers. :return: An integer representing the length of the longest contiguous subsequence that forms an AP. >>> longest_ap_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_ap_subsequence_length([9, 7, 5, 3, 2, 1]) 4 >>> longest_ap_subsequence_length([10]) 1 >>> longest_ap_subsequence_length([1, 3, 5, 7]) 4 >>> longest_ap_subsequence_length([1, 4, 7, 2, 5, 8]) 3 >>> longest_ap_subsequence_length([5, 5, 5, 5, 5]) 5 >>> longest_ap_subsequence_length([-1, -2, -3, -4]) 4 >>> longest_ap_subsequence_length([1, 2, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]) 6 def solve(test_cases): Processes multiple test cases to determine the length of the longest contiguous subsequence that forms an arithmetic progression (AP) for each array of integers provided. :param test_cases: A list of tuples, where each tuple contains an integer N (number of elements in the array) and a list of N integers. :return: A list of integers, each representing the length of the longest AP subsequence for the corresponding test case. >>> solve([(5, [1, 2, 3, 4, 5]), (6, [9, 7, 5, 3, 2, 1])]) [5, 4] >>> solve([(1, [10]), (4, [1, 3, 5, 7]), (6, [1, 4, 7, 2, 5, 8]), (5, [5, 5, 5, 5, 5]), (4, [-1, -2, -3, -4]), (13, [1, 2, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1])]) [1, 4, 3, 5, 4, 6]","solution":"def longest_ap_subsequence_length(array): Determines the length of the longest contiguous subsequence that forms an arithmetic progression (AP) in the given array of integers. :param array: A list of integers. :return: An integer representing the length of the longest contiguous subsequence that forms an AP. if len(array) <= 1: return len(array) longest_length = 1 current_length = 1 common_diff = array[1] - array[0] for i in range(1, len(array)): if array[i] - array[i-1] == common_diff: current_length += 1 else: common_diff = array[i] - array[i-1] current_length = 2 longest_length = max(longest_length, current_length) return longest_length def solve(test_cases): results = [] for case in test_cases: n, arr = case results.append(longest_ap_subsequence_length(arr)) return results"},{"question":"import math from typing import List, Tuple def lcm(n: int, m: int) -> int: Returns the Least Common Multiple (LCM) of n and m. >>> lcm(4, 6) 12 >>> lcm(15, 20) 60 >>> lcm(7, 13) 91 pass def find_lcms(test_cases: List[Tuple[int, int]]) -> List[int]: Given a list of test cases where each test case is a tuple (n, m), return a list of the LCM results for each test case. >>> find_lcms([(4, 6), (15, 20), (7, 13)]) [12, 60, 91] >>> find_lcms([(1, 1)]) [1] pass","solution":"import math def lcm(n, m): Returns the Least Common Multiple (LCM) of n and m. return abs(n * m) // math.gcd(n, m) def find_lcms(test_cases): Given a list of test cases where each test case is a tuple (n, m), return a list of the LCM results for each test case. return [lcm(n, m) for n, m in test_cases]"},{"question":"def min_docks_required(n: int, schedule: List[Tuple[int, int]]) -> int: Calculate the minimum number of docks required so that no two ships are using the same dock simultaneously. >>> min_docks_required(4, [(1, 4), (2, 3), (3, 7), (5, 8)]) 2 >>> min_docks_required(3, [(0, 10), (10, 20), (20, 30)]) 1","solution":"def min_docks_required(n, schedule): events = [] for arrive, dock in schedule: events.append((arrive, 1)) events.append((dock, -1)) events.sort() current_docks = 0 max_docks = 0 for event in events: current_docks += event[1] if current_docks > max_docks: max_docks = current_docks return max_docks"},{"question":"def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in a given string. Parameters: s (str): The input string. Returns: str: The longest palindromic substring. >>> longest_palindromic_substring(\\"abacdfgdcaba\\") \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"aaaa\\") \\"aaaa\\" >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" >>> longest_palindromic_substring(\\"abcdef\\") \\"a\\" >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") \\"geeksskeeg\\" pass # Implement the function here","solution":"def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in a given string. Parameters: s (str): The input string. Returns: str: The longest palindromic substring. n = len(s) if n == 0: return \\"\\" # Initialize a table to store information about palindromes table = [[False for x in range(n)] for y in range(n)] max_length = 1 start = 0 # All substrings of length 1 are palindromes for i in range(n): table[i][i] = True # Check for substrings of length 2 for i in range(n-1): if s[i] == s[i+1]: table[i][i+1] = True start = i max_length = 2 # Check for substrings of length greater than 2 for k in range(3, n+1): for i in range(n - k + 1): j = i + k - 1 # Ending index of the current substring # Check if the current substring is palindrome if s[i] == s[j] and table[i+1][j-1]: table[i][j] = True if k > max_length: start = i max_length = k return s[start:start + max_length]"},{"question":"def multiply(a, b): Calculate the product of two integers a and b without using the multiplication (*) operator, loops, or recursion. >>> multiply(4, 3) 12 >>> multiply(0, 5) 0 >>> multiply(-4, -3) 12 >>> multiply(-4, 3) -12 >>> multiply(4, -3) -12","solution":"def multiply(a, b): Returns the product of a and b without using * operator, loops, or recursion. product = 0 for _ in range(abs(b)): product += a if b < 0: product = -product return product"},{"question":"from typing import List, Tuple def min_operations_to_ascending_run(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum number of operations required to convert each array in test_cases into an ascending run array. >>> min_operations_to_ascending_run(3, [(4, [1, 3, 2, 4]), (5, [1, 2, 3, 5, 4]), (3, [2, 2, 2])]) [1, 1, 0] >>> min_operations_to_ascending_run(1, [(5, [1, 2, 3, 4, 5])]) [0] def parse_input(input_data: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Parse the input data into the required format. >>> parse_input(\\"3n4n1 3 2 4n5n1 2 3 5 4n3n2 2 2n\\") (3, [(4, [1, 3, 2, 4]), (5, [1, 2, 3, 5, 4]), (3, [2, 2, 2])])","solution":"def min_operations_to_ascending_run(t, test_cases): results = [] for case in test_cases: n, A = case operations = 0 for i in range(1, n): if A[i] < A[i - 1]: operations += (A[i - 1] - A[i]) A[i] = A[i - 1] results.append(operations) return results def parse_input(input_data): lines = input_data.split('n') t = int(lines[0].strip()) test_cases = [] index = 1 for _ in range(t): n = int(lines[index].strip()) A = list(map(int, lines[index + 1].strip().split())) test_cases.append((n, A)) index += 2 return t, test_cases"},{"question":"from typing import List, Dict, Tuple, Union def car_sales_summary(sales: List[Dict[str, Union[int, str]]]) -> Dict[Tuple[str, int], float]: Create a summary of total sales by make and year. >>> car_sales_summary([ ... {\\"id\\": 1, \\"make\\": \\"Toyota\\", \\"model\\": \\"Camry\\", \\"year\\": 2018, \\"sale_date\\": \\"2021-05-21\\", \\"price\\": 15000}, ... {\\"id\\": 2, \\"make\\": \\"Honda\\", \\"model\\": \\"Civic\\", \\"year\\": 2020, \\"sale_date\\": \\"2021-03-15\\", \\"price\\": 20000}, ... {\\"id\\": 3, \\"make\\": \\"Toyota\\", \\"model\\": \\"Corolla\\", \\"year\\": 2018, \\"sale_date\\": \\"2021-06-01\\", \\"price\\": 13000}, ... {\\"id\\": 4, \\"make\\": \\"Honda\\", \\"model\\": \\"Accord\\", \\"year\\": 2020, \\"sale_date\\": \\"2021-07-17\\", \\"price\\": 18000}, ... ]) {(\\"Toyota\\", 2018): 28000, (\\"Honda\\", 2020): 38000}","solution":"from typing import List, Dict, Tuple, Union def car_sales_summary(sales: List[Dict[str, Union[int, str]]]) -> Dict[Tuple[str, int], float]: summary = {} for sale in sales: key = (sale['make'], sale['year']) if key in summary: summary[key] += sale['price'] else: summary[key] = sale['price'] return summary"},{"question":"def count_peaks(arr: List[int]) -> int: Identify the number of peaks in the list. A \\"peak\\" is an element which is strictly greater than its neighbors. For corner elements, we only consider the one neighbor. >>> count_peaks([1, 3, 2, 4, 1, 5, 3]) 3 >>> count_peaks([1, 1, 1, 1]) 0 >>> count_peaks([3, 1, 1, 1]) 1 >>> count_peaks([1, 1, 1, 3]) 1 # Example Unit Tests def test_peaks_in_middle(): assert count_peaks([1, 3, 2, 4, 1, 5, 3]) == 3 def test_no_peaks(): assert count_peaks([1, 1, 1, 1]) == 0 def test_one_peak_at_start(): assert count_peaks([3, 1, 1, 1]) == 1 def test_one_peak_at_end(): assert count_peaks([1, 1, 1, 3]) == 1 def test_all_elements_same(): assert count_peaks([5, 5, 5, 5, 5]) == 0 def test_single_element(): assert count_peaks([9]) == 0 def test_two_elements(): assert count_peaks([2, 1]) == 1 assert count_peaks([1, 2]) == 1 def test_large_numbers(): assert count_peaks([10**9, -10**9, 10**9, -10**9, 10**9]) == 3","solution":"def count_peaks(arr): peaks_count = 0 n = len(arr) if n == 0: return peaks_count for i in range(n): if i == 0 and n > 1 and arr[i] > arr[i+1]: peaks_count += 1 elif i == n - 1 and n > 1 and arr[i] > arr[i - 1]: peaks_count += 1 elif 0 < i < n - 1 and arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peaks_count += 1 return peaks_count # Test Case # 7 # 1 3 2 4 1 5 3 # Output should be 3 print(count_peaks([1, 3, 2, 4, 1, 5, 3])) # Output: 3"},{"question":"def primeOnesCount(N: int) -> int: Given a positive integer N, determine whether the number of 1's in its binary representation is a prime number or not. >>> primeOnesCount(5) 1 >>> primeOnesCount(10) 1 >>> primeOnesCount(15) 0","solution":"def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primeOnesCount(N): Returns 1 if the number of 1's in the binary representation of N is a prime number, else returns 0. # Calculate the number of 1's in the binary representation of N count_ones = bin(N).count('1') # Check if the count is a prime number if is_prime(count_ones): return 1 else: return 0"},{"question":"def sum_of_digits(numbers: List[str]) -> List[int]: Given a list of large natural numbers as strings, returns the sum of the digits for each number. >>> sum_of_digits([\\"12345\\"]) [15] >>> sum_of_digits([\\"999999999\\"]) [81] >>> sum_of_digits([\\"100000000000\\"]) [1] >>> sum_of_digits([\\"12345\\", \\"999999999\\", \\"100000000000\\"]) [15, 81, 1] >>> sum_of_digits([\\"\\"]) [0] >>> sum_of_digits([\\"1000000000000000000000000000001\\"]) [2]","solution":"def sum_of_digits(numbers): Given a list of large natural numbers as strings, returns the sum of the digits for each number. results = [] for number in numbers: digit_sum = sum(int(digit) for digit in number) results.append(digit_sum) return results"},{"question":"def matrix_mult(A, B): Multiplies two matrices A and B. pass def matrix_pow(matrix, n): Raises the matrix to the power of n using exponentiation by squaring. pass def fib(n): Returns the nth Fibonacci number using matrix exponentiation. pass def sum_fib_upto_n(n): Returns the sum of all Fibonacci numbers from F(0) to F(n). >>> sum_fib_upto_n(0) 0 >>> sum_fib_upto_n(1) 1 >>> sum_fib_upto_n(3) 4 >>> sum_fib_upto_n(5) 12 >>> sum_fib_upto_n(10) 143 pass def process_fibonacci_sums(T, cases): Processes multiple test cases and returns the sums of Fibonacci numbers. >>> process_fibonacci_sums(3, [3, 5, 10]) [4, 12, 143] pass","solution":"def matrix_mult(A, B): Multiplies two matrices A and B. return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_pow(matrix, n): Raises the matrix to the power of n using exponentiation by squaring. result = [[1, 0], [0, 1]] base = matrix while n > 0: if n % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) n //= 2 return result def fib(n): Returns the nth Fibonacci number using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] F_n = matrix_pow(F, n-1) return F_n[0][0] def sum_fib_upto_n(n): Returns the sum of all Fibonacci numbers from F(0) to F(n). return fib(n + 2) - 1 def process_fibonacci_sums(T, cases): Processes multiple test cases and returns the sums of Fibonacci numbers. result = [] for n in cases: result.append(sum_fib_upto_n(n)) return result"},{"question":"def findPythagoreanTriplet(arr): Determines if there are three distinct elements a, b, and c in the array such that a^2 + b^2 = c^2. Args: arr (List[int]): The input array of positive integers. Returns: int: 1 if such elements exist, 0 otherwise. Example: >>> findPythagoreanTriplet([3, 1, 4, 6, 5]) 1 >>> findPythagoreanTriplet([1, 2, 3, 4]) 0","solution":"def findPythagoreanTriplet(arr): Determines if there are three distinct elements a, b, and c in the array such that a^2 + b^2 = c^2. Args: arr (List[int]): The input array of positive integers. Returns: int: 1 if such elements exist, 0 otherwise. n = len(arr) # Square all elements squared = [x * x for x in arr] squared_set = set(squared) # Check every pair to see if the sum of their squares is also in the squared list for i in range(n): for j in range(i + 1, n): if squared[i] + squared[j] in squared_set: return 1 return 0"},{"question":"def min_operations_to_empty_string(S: str) -> int: Determine the minimum number of operations required to make the string empty. The operation is to choose a substring that consists of the same character repeated one or more times, and remove this substring from S. Args: S (str): The input string S consisting of lowercase English letters. Returns: int: The minimum number of operations required to make the string empty. Example: >>> min_operations_to_empty_string(\\"aaabbbcc\\") 3 from solution import min_operations_to_empty_string def test_min_operations_example(): assert min_operations_to_empty_string(\\"aaabbbcc\\") == 3 def test_min_operations_single_char(): assert min_operations_to_empty_string(\\"aaaa\\") == 1 def test_min_operations_alternating_chars(): assert min_operations_to_empty_string(\\"ababab\\") == 6 def test_min_operations_mixed_groups(): assert min_operations_to_empty_string(\\"abcdabcd\\") == 8 def test_min_operations_single_char_repeated(): assert min_operations_to_empty_string(\\"a\\") == 1 def test_min_operations_empty_string(): assert min_operations_to_empty_string(\\"\\") == 0 def test_min_operations_all_different_chars(): assert min_operations_to_empty_string(\\"abcdefg\\") == 7 def test_min_operations_large_input(): assert min_operations_to_empty_string(\\"a\\"*50000 + \\"b\\"*50000) == 2","solution":"def min_operations_to_empty_string(S): Returns the minimum number of operations required to make the string empty by removing contiguous substrings consisting of the same character. n = len(S) if n == 0: return 0 operations = 1 for i in range(1, n): if S[i] != S[i - 1]: operations += 1 return operations"},{"question":"from typing import List, Tuple def find_minimum_spanning_tree(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Returns the minimum possible total length of roads that connects all cities, or -1 if not possible to connect all cities. >>> find_minimum_spanning_tree(4, 5, [(1, 2, 1), (1, 3, 2), (3, 4, 4), (1, 4, 3), (2, 3, 2)]) 6 >>> find_minimum_spanning_tree(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 >>> find_minimum_spanning_tree(1, 0, []) 0 >>> find_minimum_spanning_tree(2, 1, [(1, 2, 1)]) 1 def test_minimum_spanning_tree_basic_case(): N, M = 4, 5 roads = [ (1, 2, 1), (1, 3, 2), (3, 4, 4), (1, 4, 3), (2, 3, 2) ] assert find_minimum_spanning_tree(N, M, roads) == 6 def test_minimum_spanning_tree_disconnected(): N, M = 4, 2 roads = [ (1, 2, 1), (3, 4, 2) ] assert find_minimum_spanning_tree(N, M, roads) == -1 def test_minimum_spanning_tree_single_city(): N, M = 1, 0 roads = [] assert find_minimum_spanning_tree(N, M, roads) == 0 def test_minimum_spanning_tree_two_cities_one_road(): N, M = 2, 1 roads = [ (1, 2, 1) ] assert find_minimum_spanning_tree(N, M, roads) == 1 def test_minimum_spanning_tree_large_graph(): N, M = 6, 9 roads = [ (1, 2, 4), (1, 3, 3), (2, 3, 2), (2, 4, 2), (3, 4, 3), (3, 5, 2), (4, 5, 3), (4, 6, 3), (5, 6, 1) ] assert find_minimum_spanning_tree(N, M, roads) == 10","solution":"def find_minimum_spanning_tree(N, M, roads): Returns the minimum possible total length of roads that connects all cities, or -1 if not possible to connect all cities. if M == 0: return -1 if N > 1 else 0 # No roads and more than one city means we can't connect all cities. from heapq import heappop, heappush # Start with a graph represented as adjacency list graph = {i: [] for i in range(1, N+1)} for u, v, w in roads: graph[u].append((w, v)) graph[v].append((w, u)) # Prim's Algorithm to find MST min_heap = [(0, 1)] # (cost, start_node) visited = set() total_cost = 0 while min_heap and len(visited) < N: cost, u = heappop(min_heap) if u not in visited: total_cost += cost visited.add(u) for next_cost, v in graph[u]: if v not in visited: heappush(min_heap, (next_cost, v)) return total_cost if len(visited) == N else -1"},{"question":"def is_valid_palindrome(s: str) -> str: Returns \\"YES\\" if the input string s is a valid palindrome, ignoring non-alphanumeric characters and case. Otherwise returns \\"NO\\". >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") \\"YES\\" >>> is_valid_palindrome(\\"race a car\\") \\"NO\\" >>> is_valid_palindrome(\\"12321\\") \\"YES\\" pass def process_test_cases(T: int, cases: List[str]) -> List[str]: Processes T test cases and returns a list of results. T: number of test cases cases: list of test case strings >>> process_test_cases(3, [\\"A man, a plan, a canal: Panama\\", \\"race a car\\", \\"12321\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [\\"madam\\", \\"step on no pets\\"]) [\\"YES\\", \\"YES\\"] pass","solution":"def is_valid_palindrome(s): Returns \\"YES\\" if the input string s is a valid palindrome, ignoring non-alphanumeric characters and case. Otherwise returns \\"NO\\". # Filter only alphanumeric characters and convert to lower case filtered_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is the same read forwards and backwards if filtered_s == filtered_s[::-1]: return \\"YES\\" else: return \\"NO\\" def process_test_cases(T, cases): Processes T test cases and returns a list of results. T: number of test cases cases: list of test case strings results = [] for case in cases: result = is_valid_palindrome(case) results.append(result) return results"},{"question":"def longest_substring_with_two_distinct_characters(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> longest_substring_with_two_distinct_characters(\\"eceba\\") 3 >>> longest_substring_with_two_distinct_characters(\\"ccaabbb\\") 5","solution":"def longest_substring_with_two_distinct_characters(s): Returns the length of the longest substring that contains at most two distinct characters. :type s: str :rtype: int start = 0 max_length = 0 char_map = {} for end in range(len(s)): char_map[s[end]] = char_map.get(s[end], 0) + 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generates an NxN matrix filled with positive integers in spiral order. The matrix should start with the number 1 in the top left corner and spiral down and inward in a clockwise direction. >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] from typing import List def test_generate_spiral_matrix_1x1(): assert generate_spiral_matrix(1) == [[1]] def test_generate_spiral_matrix_2x2(): assert generate_spiral_matrix(2) == [[1, 2], [4, 3]] def test_generate_spiral_matrix_3x3(): assert generate_spiral_matrix(3) == [[1, 2, 3], [8, 9, 4], [7, 6, 5]] def test_generate_spiral_matrix_4x4(): assert generate_spiral_matrix(4) == [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] def test_generate_spiral_matrix_5x5(): assert generate_spiral_matrix(5) == [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"def generate_spiral_matrix(n): Generates an NxN matrix filled with integers in spiral order. matrix = [[0] * n for _ in range(n)] value = 1 top, bottom, left, right = 0, n-1, 0, n-1 while top <= bottom and left <= right: for i in range(left, right + 1): matrix[top][i] = value value += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = value value += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = value value += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = value value += 1 left += 1 return matrix"},{"question":"def is_possible_to_transform(start: str, target: str, dictionary: List[str]) -> str: Determines if it is possible to transform the starting word into the target word by changing exactly one character at a time such that each intermediate form is a valid word found in the given dictionary. >>> is_possible_to_transform(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) \\"possible\\" >>> is_possible_to_transform(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"lot\\"]) \\"impossible\\"","solution":"from collections import deque def is_possible_to_transform(start, target, dictionary): Determines if it is possible to transform the starting word into the target word by changing exactly one character at a time such that each intermediate form is a valid word found in the given dictionary. if start == target: return \\"possible\\" dictionary = set(dictionary) queue = deque([(start, 0)]) while queue: current_word, steps = queue.popleft() for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word == target: return \\"possible\\" if next_word in dictionary: dictionary.remove(next_word) queue.append((next_word, steps + 1)) return \\"impossible\\""},{"question":"def sumOfUnique(arr): Write a function that takes a list of integers and returns the sum of all unique elements in the list. Elements are considered unique if they appear exactly once in the list. For example, for a given list arr: [4, 5, 7, 5, 4, 8] The unique elements are 7 and 8. So, the function should return: sumOfUnique([4, 5, 7, 5, 4, 8]) => 15 If there are no unique elements, the function should return 0. For example, for the list: [1, 1, 2, 2, 3, 3] All elements are repeated, hence the function should return 0. You can assume that the list will only contain integers. >>> sumOfUnique([4, 5, 7, 5, 4, 8]) 15 >>> sumOfUnique([1, 1, 2, 2, 3, 3]) 0 >>> sumOfUnique([1, 2, 3, 4, 5]) 15 >>> sumOfUnique([]) 0 >>> sumOfUnique([4, -5, 7, -5, 4, 8]) 15 >>> sumOfUnique([4, 5, 7, -9, -9, 5, 4, 2]) 9 >>> sumOfUnique([42]) 42","solution":"def sumOfUnique(arr): Returns the sum of all unique elements in the list. Parameters: arr (list): A list of integers Returns: int: Sum of unique elements in the list from collections import Counter element_count = Counter(arr) unique_elements = [k for k, v in element_count.items() if v == 1] return sum(unique_elements)"},{"question":"def anagram_groups(words: List[str]) -> List[str]: Given a list of words, return all words in canonical form grouped by their original anagram groups in lexicographically ascending order. Args: words: List[str] - List of words consisting of lowercase English letters. Returns: List[str] - List of groups of anagrams in canonical form. Examples: >>> anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"example\\", \\"lead\\", \\"deal\\"]) [\\"deal lead\\", \\"enlist listen silent\\", \\"example\\"] >>> anagram_groups([\\"apple\\"]) [\\"apple\\"] >>> anagram_groups([\\"cat\\", \\"dog\\", \\"bird\\"]) [\\"bird\\", \\"cat\\", \\"dog\\"] >>> anagram_groups([\\"bob\\", \\"obb\\", \\"cat\\", \\"tac\\", \\"act\\", \\"bat\\", \\"tab\\"]) [\\"act cat tac\\", \\"bat tab\\", \\"bob obb\\"] >>> anagram_groups([\\"bat\\", \\"tab\\", \\"bat\\"]) [\\"bat bat tab\\"]","solution":"def anagram_groups(words): from collections import defaultdict # Group words by the sorted tuple of their characters anagram_dict = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) # Sort each group and the list of groups lexicographically result = [] for group in anagram_dict.values(): result.append(' '.join(sorted(group))) return sorted(result)"},{"question":"def preprocess_prefix_sums(arr): This function preprocesses the given array into a prefix sum array for efficient range sum queries. Params: arr (List[int]): The original array of integers. Returns: List[int]: The prefix sum array. pass def range_sum_queries(arr, queries): This function uses the prefix sums to answer each range sum query in constant time. Params: arr (List[int]): The original array of integers. queries (List[Tuple[int, int]]): List of tuples where each tuple contains two integers representing the start and end indices for the range sum query. Returns: List[int]: A list of integers where each integer is the result of a range sum query. pass # Unit Tests def test_example(): arr = [3, 1, 4, 1, 5] queries = [(0, 2), (1, 3), (0, 4)] assert range_sum_queries(arr, queries) == [8, 6, 14] def test_single_element_array(): arr = [5] queries = [(0, 0)] assert range_sum_queries(arr, queries) == [5] def test_identical_values(): arr = [2, 2, 2, 2, 2] queries = [(0, 4), (1, 3), (0, 2)] assert range_sum_queries(arr, queries) == [10, 6, 6] def test_different_lengths(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] queries = [(0, 9), (3, 6), (4, 4)] assert range_sum_queries(arr, queries) == [55, 22, 5] def test_large_values(): arr = [1000000, 1000000, 1000000, 1000000] queries = [(0, 3), (1, 2), (0, 0), (3, 3)] assert range_sum_queries(arr, queries) == [4000000, 2000000, 1000000, 1000000] def test_negative_values(): arr = [-1, -2, -3, -4, -5] queries = [(0, 4), (1, 3), (2, 2)] assert range_sum_queries(arr, queries) == [-15, -9, -3] def test_mixed_values(): arr = [1, -1, 2, -2, 3, -3, 4, -4] queries = [(0, 7), (0, 1), (2, 5), (3, 4)] assert range_sum_queries(arr, queries) == [0, 0, 0, 1]","solution":"def preprocess_prefix_sums(arr): This function preprocesses the given array into a prefix sum array for efficient range sum queries. n = len(arr) prefix_sums = [0] * n prefix_sums[0] = arr[0] for i in range(1, n): prefix_sums[i] = prefix_sums[i - 1] + arr[i] return prefix_sums def range_sum_queries(arr, queries): This function uses the prefix sums to answer each range sum query in constant time. prefix_sums = preprocess_prefix_sums(arr) results = [] for l, r in queries: if l == 0: results.append(prefix_sums[r]) else: results.append(prefix_sums[r] - prefix_sums[l - 1]) return results"},{"question":"from typing import List, Tuple def split_array(arr: List[int]) -> Tuple[List[int], List[int]]: Splits an array into two parts such that: 1. Both parts are non-empty. 2. The median of the first part is less than or equal to the median of the second part. >>> split_array([3, 1, 2]) ([1], [2, 3]) >>> split_array([7, 3, 5, 1, 2, 6, 4]) ([1, 2, 3], [4, 5, 6, 7])","solution":"def split_array(arr): Splits an array into two parts such that: 1. Both parts are non-empty. 2. The median of the first part is less than or equal to the median of the second part. # Sort the array arr.sort() # Calculate the split index n = len(arr) split_index = n // 2 # Split the array into two parts first_part = arr[:split_index] second_part = arr[split_index:] return first_part, second_part"},{"question":"def is_palindrome(s: str) -> str: Returns \\"PALINDROME\\" if the string s is a palindrome, otherwise returns \\"NOT A PALINDROME\\". >>> is_palindrome(\\"racecar\\") \\"PALINDROME\\" >>> is_palindrome(\\"hello\\") \\"NOT A PALINDROME\\" >>> is_palindrome(\\"madam\\") \\"PALINDROME\\" >>> is_palindrome(\\"sample\\") \\"NOT A PALINDROME\\" >>> is_palindrome(\\"rotator\\") \\"PALINDROME\\" >>> is_palindrome(\\"python\\") \\"NOT A PALINDROME\\" >>> is_palindrome(\\"civic\\") \\"PALINDROME\\"","solution":"def is_palindrome(s): Returns \\"PALINDROME\\" if the string s is a palindrome, otherwise returns \\"NOT A PALINDROME\\". return \\"PALINDROME\\" if s == s[::-1] else \\"NOT A PALINDROME\\""},{"question":"def levenshtein_distance(s1: str, s2: str) -> int: Calculates the Levenshtein distance between two strings. >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> levenshtein_distance(\\"intention\\", \\"execution\\") 5 pass # Unit Tests def test_levenshtein_distance_example1(): assert levenshtein_distance(\\"kitten\\", \\"sitting\\") == 3 def test_levenshtein_distance_example2(): assert levenshtein_distance(\\"flaw\\", \\"lawn\\") == 2 def test_levenshtein_distance_example3(): assert levenshtein_distance(\\"intention\\", \\"execution\\") == 5 def test_levenshtein_distance_identical(): assert levenshtein_distance(\\"apple\\", \\"apple\\") == 0 def test_levenshtein_distance_single_deletion(): assert levenshtein_distance(\\"apple\\", \\"apples\\") == 1 def test_levenshtein_distance_single_insertion(): assert levenshtein_distance(\\"apple\\", \\"appl\\") == 1 def test_levenshtein_distance_single_substitution(): assert levenshtein_distance(\\"apple\\", \\"apble\\") == 1 def test_levenshtein_distance_completely_different_strings(): assert levenshtein_distance(\\"abc\\", \\"xyz\\") == 3 def test_levenshtein_distance_empty_to_regular(): assert levenshtein_distance(\\"\\", \\"hello\\") == 5 assert levenshtein_distance(\\"world\\", \\"\\") == 5 def test_levenshtein_distance_long_strings(): s1 = \\"a\\" * 1000 s2 = \\"b\\" * 1000 assert levenshtein_distance(s1, s2) == 1000 s3 = \\"a\\" * 1000 s4 = \\"a\\" * 999 + \\"b\\" assert levenshtein_distance(s3, s4) == 1","solution":"def levenshtein_distance(s1: str, s2: str) -> int: Calculates the Levenshtein distance between two strings s1 and s2. n, m = len(s1), len(s2) # Initialize matrix to (n+1) x (m+1) dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the first row and the first column for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Compute the minimum edit distance for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Substitution ) return dp[n][m]"},{"question":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def max_spanning_tree(n, edges): Find the weight of the maximum spanning tree of the graph. >>> max_spanning_tree(4, [(1, 2, 3), (1, 3, 2), (2, 3, 4), (2, 4, 1), (3, 4, 5)]) 12 >>> max_spanning_tree(1, []) 0 >>> max_spanning_tree(2, [(1, 2, 10)]) 10 def read_input_and_calculate_mst(input_lines): Parse the input and calculate the maximum spanning tree weight. >>> input_lines = \\"4 5n1 2 3n1 3 2n2 3 4n2 4 1n3 4 5\\" >>> read_input_and_calculate_mst(input_lines) 12 >>> input_lines = \\"1 0\\" >>> read_input_and_calculate_mst(input_lines) 0","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def max_spanning_tree(n, edges): edges = sorted(edges, key=lambda item: item[2], reverse=True) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = [] e = 0 i = 0 while e < n - 1 and i < len(edges): u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append((u, v, w)) union(parent, rank, x, y) total_weight = sum([w for u, v, w in result]) return total_weight def read_input_and_calculate_mst(input_lines): input_data = input_lines.strip().split('n') n, m = map(int, input_data[0].split()) edges = [] for i in range(1, m + 1): u, v, w = map(int, input_data[i].split()) edges.append((u, v, w)) return max_spanning_tree(n, edges)"},{"question":"def find_minimum_difference(sequence): This function takes a sequence of integers and returns the minimum possible absolute difference between the sums of two non-empty subsequences obtained by partitioning the sequence. >>> find_minimum_difference([3, 1, 4, 2, 2]) 0 >>> find_minimum_difference([1, 2, 3, 4, 5]) 1 >>> find_minimum_difference([1, 1]) 0 >>> find_minimum_difference([1, 2]) 1 >>> find_minimum_difference([5, 5, 5, 5]) 0 >>> find_minimum_difference([1, 1000]) 999","solution":"def find_minimum_difference(sequence): This function takes a sequence of integers and returns the minimum possible absolute difference between the sums of two non-empty subsequences obtained by partitioning the sequence. total_sum = sum(sequence) n = len(sequence) dp = [False] * (total_sum + 1) dp[0] = True for num in sequence: for i in range(total_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] min_diff = float('inf') for s in range(total_sum // 2 + 1): if dp[s]: min_diff = min(min_diff, abs(total_sum - 2 * s)) return min_diff # Example usage: # sequence = list(map(int, input().strip().split())) # print(find_minimum_difference(sequence))"},{"question":"from typing import List def rank_cars(speeds: List[int]) -> List[int]: Assign ranks based on the given speeds. Parameters: speeds (list): A list of integers representing car speeds. Returns: list: A list of integers representing the ranks of the speeds. >>> rank_cars([1, 2, 3, 3, 4]) [1, 2, 3, 3, 5] >>> rank_cars([10, 20, 20, 10]) [1, 2, 2, 1] pass def process_input(input_data: str) -> List[List[int]]: Process the input data to compute ranks for multiple test cases. Parameters: input_data (str): Multiline string of input data for the problem. Returns: list: A list of lists, each sublist containing the ranks for a specific test case. >>> process_input(\\"2n5 1 2 3 3 4n4 10 20 20 10\\") [[1, 2, 3, 3, 5], [1, 2, 2, 1]] pass","solution":"def rank_cars(speeds): Assign ranks based on the given speeds. Parameters: speeds (list): A list of integers representing car speeds. Returns: list: A list of integers representing the ranks of the speeds. sorted_speeds = sorted(set(speeds)) rank_dict = {speed: rank for rank, speed in enumerate(sorted_speeds, start=1)} return [rank_dict[speed] for speed in speeds] def process_input(input_data): Process the input data to compute ranks for multiple test cases. Parameters: input_data (str): Multiline string of input data for the problem. Returns: list: A list of lists, each sublist containing the ranks for a specific test case. lines = input_data.strip().split('n') T = int(lines[0].strip()) results = [] for i in range(1, T+1): parts = lines[i].strip().split() N = int(parts[0]) speeds = list(map(int, parts[1:])) results.append(rank_cars(speeds)) return results"},{"question":"def min_partition_difference(skill_levels): Function to find the minimum difference between two partitions of skill_levels. Args: skill_levels (list of int): List of skill levels of participants. Returns: int: Minimum possible difference in the sum of skill levels between two groups. pass def minimal_diff_of_partitions(input_str): Function to parse input, calculate and return the minimum possible difference in the sum of skill levels between two groups. Args: input_str (str): Input string containing the number of participants and their skill levels. Returns: int: Minimum possible difference in the sum of skill levels between two groups. pass def test_min_partition_difference_example(): assert min_partition_difference([3, 1, 4, 2]) == 0 def test_min_partition_difference_small_diff(): assert min_partition_difference([10, 11, 23, 20]) == 2 def test_min_partition_difference_large_skills(): assert min_partition_difference([1000, 1000, 1000, 1000]) == 0 def test_min_partition_difference_single_element(): assert min_partition_difference([5]) == 5 def test_minimal_diff_of_partitions_example(): input_str = \\"4n3 1 4 2\\" assert minimal_diff_of_partitions(input_str) == 0 def test_minimal_diff_of_partitions_single_element(): input_str = \\"1n5\\" assert minimal_diff_of_partitions(input_str) == 5 def test_minimal_diff_of_partitions_large_skills(): input_str = \\"4n1000 1000 1000 1000\\" assert minimal_diff_of_partitions(input_str) == 0 def test_minimal_diff_of_partitions_varied_skills(): input_str = \\"5n10 11 23 20 15\\" assert minimal_diff_of_partitions(input_str) == 3","solution":"def min_partition_difference(skill_levels): Function to find the minimum difference between two partitions of skill_levels. Args: skill_levels (list of int): List of skill levels of participants. Returns: int: Minimum possible difference in the sum of skill levels between two groups. N = len(skill_levels) total_sum = sum(skill_levels) half_sum = total_sum // 2 # Initialize a 2D DP array to store boolean values for possible sums dp = [[False] * (half_sum + 1) for _ in range(N + 1)] for i in range(N + 1): dp[i][0] = True for i in range(1, N + 1): for j in range(1, half_sum + 1): dp[i][j] = dp[i-1][j] if j >= skill_levels[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-skill_levels[i-1]] for j in range(half_sum, -1, -1): if dp[N][j]: return total_sum - 2 * j # Function to parse input and return result def minimal_diff_of_partitions(input_str): input_lines = input_str.strip().split('n') N = int(input_lines[0]) skill_levels = list(map(int, input_lines[1].split())) return min_partition_difference(skill_levels)"},{"question":"import math from typing import List def find_primes(n: int) -> List[int]: Returns a list of all prime numbers less than n using an efficient algorithm. >>> find_primes(10) [2, 3, 5, 7] >>> find_primes(2) [] >>> find_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> find_primes(3) [2] >>> find_primes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> find_primes(1) []","solution":"import math def find_primes(n): Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. if n <= 2: return [] sieve = [True] * n sieve[0], sieve[1] = False, False # 0 and 1 are not primes for start in range(2, int(math.sqrt(n)) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False primes = [num for num in range(n) if sieve[num]] return primes"},{"question":"def first_missing_positive_integer(lst): This function takes a list of unique integers and returns the smallest positive integer that is not present in the list. >>> first_missing_positive_integer([1, 2, 0]) 3 >>> first_missing_positive_integer([3, 4, -1, 1]) 2 >>> first_missing_positive_integer([7, 8, 9, 11, 12]) 1 from solution import first_missing_positive_integer def test_example1(): assert first_missing_positive_integer([1, 2, 0]) == 3 def test_example2(): assert first_missing_positive_integer([3, 4, -1, 1]) == 2 def test_example3(): assert first_missing_positive_integer([7, 8, 9, 11, 12]) == 1 def test_contains_negative_and_zeros(): assert first_missing_positive_integer([-5, -1, 0, 1, 2, 3, 5, 6]) == 4 def test_contains_big_numbers(): assert first_missing_positive_integer([100, 101, 102, 104, 105]) == 1 def test_empty_list(): assert first_missing_positive_integer([]) == 1 def test_all_negatives(): assert first_missing_positive_integer([-1, -2, -3, -4]) == 1 def test_out_of_order(): assert first_missing_positive_integer([5, 3, 1, 2]) == 4","solution":"def first_missing_positive_integer(lst): This function takes a list of unique integers and returns the smallest positive integer that is not present in the list. s = set(lst) i = 1 while i in s: i += 1 return i"},{"question":"def min_peaks_and_valleys(n: int, arr: List[int]) -> int: Determine the minimum number of peaks and valleys in the sequence after at most one modification. Parameters: n (int): the number of integers in the sequence. arr (List[int]): the elements of the sequence. Returns: int: the minimum number of peaks and valleys after at most one modification. Examples: >>> min_peaks_and_valleys(5, [1, 3, 2, 4, 5]) 0 >>> min_peaks_and_valleys(7, [10, 5, 3, 7, 2, 9, 8]) 1 >>> min_peaks_and_valleys(4, [5, 4, 2, 3]) 0 import pytest def test_min_peaks_and_valleys_example_1(): assert min_peaks_and_valleys(5, [1, 3, 2, 4, 5]) == 0 def test_min_peaks_and_valleys_example_2(): assert min_peaks_and_valleys(7, [10, 5, 3, 7, 2, 9, 8]) == 1 def test_min_peaks_and_valleys_example_3(): assert min_peaks_and_valleys(4, [5, 4, 2, 3]) == 0 def test_min_peaks_and_valleys_no_peaks_valleys(): assert min_peaks_and_valleys(4, [1, 2, 3, 4]) == 0 def test_min_peaks_and_valleys_single_peak(): assert min_peaks_and_valleys(5, [1, 3, 2, 2, 2]) == 0 def test_min_peaks_and_valleys_multiple_peaks_valleys(): assert min_peaks_and_valleys(6, [6, 5, 6, 5, 6, 5]) == 1","solution":"def find_peaks_and_valleys(arr): peaks_valleys = [] for i in range(1, len(arr) - 1): if (arr[i] > arr[i - 1] and arr[i] > arr[i + 1]) or (arr[i] < arr[i - 1] and arr[i] < arr[i + 1]): peaks_valleys.append(i) return peaks_valleys def count_peaks_and_valleys(arr): count = 0 for i in range(1, len(arr) - 1): if (arr[i] > arr[i - 1] and arr[i] > arr[i + 1]) or (arr[i] < arr[i - 1] and arr[i] < arr[i + 1]): count += 1 return count def min_peaks_and_valleys(n, arr): initial_count = count_peaks_and_valleys(arr) peaks_valleys = find_peaks_and_valleys(arr) if not peaks_valleys: return 0 min_count = initial_count for pv in peaks_valleys: original = arr[pv] # Try changing arr[pv] to the value of its left neighbor arr[pv] = arr[pv - 1] temp_count = count_peaks_and_valleys(arr) min_count = min(min_count, temp_count) # Restore the original value arr[pv] = original # Try changing arr[pv] to the value of its right neighbor arr[pv] = arr[pv + 1] temp_count = count_peaks_and_valleys(arr) min_count = min(min_count, temp_count) # Restore the original value arr[pv] = original return min_count"},{"question":"from typing import List, Tuple def find_min_cost_to_connect_regions(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Returns the minimum cost required to ensure all regions remain connected, or -1 if it is impossible to connect all regions. >>> find_min_cost_to_connect_regions(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 5)]) 6 >>> find_min_cost_to_connect_regions(5, 3, [(1, 2, 1), (3, 4, 2), (4, 5, 3)]) -1 >>> find_min_cost_to_connect_regions(3, 0, []) -1 >>> find_min_cost_to_connect_regions(1, 0, []) 0 >>> find_min_cost_to_connect_regions(2, 1, [(1, 2, 100)]) 100 pass","solution":"def find_min_cost_to_connect_regions(n, m, edges): Returns the minimum cost required to ensure all regions remain connected, or -1 if it is impossible to connect all regions. if n == 1: return 0 from heapq import heappop, heappush parent = list(range(n+1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return True return False # Min-heap to get the edge with the smallest weight first pq = [] for u, v, c in edges: heappush(pq, (c, u, v)) total_cost = 0 edges_used = 0 while pq and edges_used < n-1: cost, u, v = heappop(pq) if union(u, v): total_cost += cost edges_used += 1 # If we used exactly n-1 edges, all nodes are connected return total_cost if edges_used == n-1 else -1"},{"question":"def sum_of_evens(n): Returns the summation of all even integers from 1 to n. >>> sum_of_evens(6) 12 >>> sum_of_evens(1) 0 >>> sum_of_evens(2) 2 >>> sum_of_evens(5) 6 >>> sum_of_evens(9) 20 >>> sum_of_evens(10) 30 >>> sum_of_evens(100) 2550","solution":"def sum_of_evens(n): Returns the summation of all even integers from 1 to n. return sum(i for i in range(2, n+1, 2))"},{"question":"from collections import Counter def is_almost_balanced(S: str) -> str: Checks if the string S is almost balanced. A string S is considered almost balanced if the count of any character in S appears at most one time more than the count of any other character in S. Args: S (str): The input string consisting of only lowercase English letters. Returns: str: \\"YES\\" if the string is almost balanced, otherwise \\"NO\\". >>> is_almost_balanced(\\"abac\\") \\"YES\\" >>> is_almost_balanced(\\"aaab\\") \\"NO\\"","solution":"from collections import Counter def is_almost_balanced(S): Checks if the string S is almost balanced. A string S is considered almost balanced if the count of any character in S appears at most one time more than the count of any other character in S. Args: S (str): The input string consisting of only lowercase English letters. Returns: str: \\"YES\\" if the string is almost balanced, otherwise \\"NO\\". if not S or len(S) == 1: return \\"YES\\" # Count frequencies of each character freq = Counter(S) # Get all frequency values freq_values = list(freq.values()) max_freq = max(freq_values) min_freq = min(freq_values) # Check if the difference between max and min frequency is at most 1 if max_freq - min_freq <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def count_successful_borrows(M, B, books, members): Determine how many members can successfully borrow books based on their borrowing and renewal preferences. M: int - total number of members attempting to borrow books B: int - total number of books available books: List[int] - The maximum number of days each book can be borrowed members: List[Tuple[int, int, int]] - Each member's initial borrow days, renew times, and book number Returns the number of members who can successfully borrow their requested books. >>> count_successful_borrows(3, 3, [15, 20, 10], [(10, 1, 1), (5, 3, 2), (6, 0, 3)]) 2 >>> count_successful_borrows(3, 3, [30, 30, 30], [(10, 1, 1), (10, 1, 2), (10, 0, 3)]) 3 >>> count_successful_borrows(3, 3, [10, 10, 10], [(10, 1, 1), (10, 2, 2), (20, 0, 3)]) 0 >>> count_successful_borrows(4, 2, [15, 20], [(10, 1, 1), (6, 1, 1), (5, 3, 2), (10, 0, 2)]) 2 >>> count_successful_borrows(100000, 100000, [1000000000] * 100000, [(1, 0, i+1) for i in range(100000)]) 100000 >>> count_successful_borrows(2, 1, [1000000000], [(500000000, 0, 1), (1, 999999999, 1)]) 1","solution":"def count_successful_borrows(M, B, books, members): successful_members = 0 book_status = [False] * B # Keeps track if a book is already borrowed for T, R, K in members: K -= 1 # Convert 1-indexed book number to 0-indexed total_days_requested = T + T * R if not book_status[K] and total_days_requested <= books[K]: successful_members += 1 book_status[K] = True # Mark the book as borrowed return successful_members # Example usage: M = 3 B = 3 books = [15, 20, 10] members = [ (10, 1, 1), (5, 3, 2), (6, 0, 3) ] print(count_successful_borrows(M, B, books, members)) # Output: 2"},{"question":"def generate_diagonals(N: int) -> tuple: Generates a 2D array of size N x N and extracts the primary and secondary diagonals. Parameters: N (int): Size of the 2D array. Returns: tuple: A tuple containing two lists, the primary and secondary diagonals. >>> generate_diagonals(3) ([1, 5, 9], [3, 5, 7]) >>> generate_diagonals(1) ([1], [1]) >>> generate_diagonals(2) ([1, 4], [2, 3]) >>> generate_diagonals(4) ([1, 6, 11, 16], [4, 7, 10, 13])","solution":"def generate_diagonals(N): Generates a 2D array of size N x N and extracts the primary and secondary diagonals. Parameters: N (int): Size of the 2D array. Returns: tuple: A tuple containing two lists, the primary and secondary diagonals. # Generate the 2D array array = [[(i * N + j + 1) for j in range(N)] for i in range(N)] # Extract the primary diagonal primary_diagonal = [array[i][i] for i in range(N)] # Extract the secondary diagonal secondary_diagonal = [array[i][N - 1 - i] for i in range(N)] return primary_diagonal, secondary_diagonal"},{"question":"MOD = 1000000007 def fibonacci(n): Calculate the N-th Fibonacci number modulo 1000000007. Parameters: n (int): The position in the Fibonacci sequence. Returns: int: The N-th Fibonacci number modulo 1000000007. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(5) 5 >>> fibonacci(10) 55 pass def process_input(test_cases): Process a list of test cases to compute the N-th Fibonacci number for each case. Parameters: test_cases (list of int): List of numbers representing the positions in the Fibonacci sequence. Returns: list of int: List of Fibonacci numbers corresponding to each position, modulo 1000000007. >>> process_input([2, 5, 10]) [1, 5, 55] pass","solution":"MOD = 1000000007 def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, (a + b) % MOD return b def process_input(test_cases): results = [] for n in test_cases: results.append(fibonacci(n)) return results"},{"question":"def sum_time_durations(durations): Sums up a list of time durations given in the format \\"HH:MM\\". Stops summing when \\"00:00\\" is encountered. Returns the total duration in the format \\"HH:MM\\". >>> sum_time_durations([\\"01:30\\", \\"02:45\\", \\"03:15\\", \\"00:00\\"]) == \\"07:30\\" >>> sum_time_durations([\\"00:00\\"]) == \\"00:00\\" >>> sum_time_durations([\\"02:15\\", \\"00:00\\"]) == \\"02:15\\" >>> sum_time_durations([\\"01:10\\", \\"02:20\\", \\"01:30\\", \\"00:00\\"]) == \\"05:00\\" >>> sum_time_durations([\\"01:10\\", \\"02:20\\", \\"01:30\\"]) == \\"05:00\\"","solution":"def sum_time_durations(durations): Sums up a list of time durations given in the format \\"HH:MM\\". Stops summing when \\"00:00\\" is encountered. Returns the total duration in the format \\"HH:MM\\". total_minutes = 0 for duration in durations: if duration == \\"00:00\\": break hours, minutes = map(int, duration.split(':')) total_minutes += hours * 60 + minutes total_hours = total_minutes // 60 total_minutes = total_minutes % 60 return f\\"{total_hours:02}:{total_minutes:02}\\" # Example usage # durations = [\\"01:30\\", \\"02:45\\", \\"03:15\\", \\"00:00\\"] # print(sum_time_durations(durations)) # Output: \\"07:30\\""},{"question":"import math from typing import List, Tuple def estimate_delivery_time(test_cases: List[Tuple[int, str]]) -> List[int]: Calculate the estimated delivery time for book orders based on the number of books and the delivery type. The delivery time for orders is as follows: - For standard delivery ('S'), it takes one day to prepare the order plus one additional day for every 2 books (rounded up). - For express delivery ('E'), every order takes a fixed time of 1 day regardless of the number of books. Args: test_cases (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer representing the number of books in the order and a character representing the type of delivery ('S' for standard delivery or 'E' for express delivery). Returns: List[int]: A list of integers representing the estimated delivery time for each order in days. Examples: >>> estimate_delivery_time([(10, 'S')]) [6] >>> estimate_delivery_time([(3, 'E')]) [1] >>> estimate_delivery_time([(5, 'S')]) [4] >>> estimate_delivery_time([(10, 'S'), (3, 'E'), (5, 'S')]) [6, 1, 4] >>> estimate_delivery_time([(100, 'S')]) [51] >>> estimate_delivery_time([(100, 'E')]) [1] >>> estimate_delivery_time([(1, 'S')]) [2] >>> estimate_delivery_time([(1, 'E')]) [1]","solution":"import math def estimate_delivery_time(test_cases): results = [] for books, delivery_type in test_cases: if delivery_type == 'S': preparation_time = 1 additional_time = math.ceil(books / 2) total_time = preparation_time + additional_time else: # delivery_type == 'E' total_time = 1 results.append(total_time) return results"},{"question":"def min_days_to_cover_garden(M: int, N: int) -> int: Returns the minimum number of days required to cover an M x N garden with grass. >>> min_days_to_cover_garden(3, 3) 1 >>> min_days_to_cover_garden(5, 5) 2 >>> min_days_to_cover_garden(1000, 1000) 499 >>> min_days_to_cover_garden(3, 1) 1 >>> min_days_to_cover_garden(5, 4) 2 >>> min_days_to_cover_garden(1000, 1) 499 >>> min_days_to_cover_garden(1, 1) 0 >>> min_days_to_cover_garden(1, 5) 2 >>> min_days_to_cover_garden(5, 1) 2","solution":"def min_days_to_cover_garden(M, N): Returns the minimum number of days required to cover an M x N garden with grass. return (max(M, N) - 1) // 2"},{"question":"import math def numSquares(N: int) -> int: Returns the smallest number of integers required such that their squares sum up to N. >>> numSquares(12) 3 >>> numSquares(13) 2","solution":"import math def numSquares(N): Returns the smallest number of integers required such that their squares sum up to N. # Initialize the dp array where dp[i] means the least number of perfect square numbers which sum to i dp = [float('inf')] * (N + 1) # Since 0 is the sum of 0 numbers' squares dp[0] = 0 # Loop through each number from 1 to N and calculate minimum squares for i in range(1, N + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - (j * j)] + 1) j += 1 return dp[N]"},{"question":"def rearrange_array(arr): Rearrange elements of \`arr\` such that it follows the specified pattern: 1. The first element is the smallest. 2. The second element is the largest. 3. The third element is the second smallest. 4. The fourth element is the second largest. And so on. >>> rearrange_array([5, 1, 3, 9, 7]) == [1, 9, 3, 7, 5] >>> rearrange_array([4, 2, 1, 3]) == [1, 4, 2, 3] >>> rearrange_array([10, 20, 30, 40, 50]) == [10, 50, 20, 40, 30] >>> rearrange_array([7, 3]) == [3, 7] >>> rearrange_array([5, 8, 2, 14, 7, 1, 12]) == [1, 14, 2, 12, 5, 8, 7]","solution":"def rearrange_array(arr): Rearrange elements of \`arr\` such that it follows the specified pattern: 1. The first element is the smallest. 2. The second element is the largest. 3. The third element is the second smallest. 4. The fourth element is the second largest. And so on. arr_sorted = sorted(arr) result = [] i, j = 0, len(arr) - 1 while i <= j: if i == j: result.append(arr_sorted[i]) else: result.append(arr_sorted[i]) result.append(arr_sorted[j]) i += 1 j -= 1 return result"},{"question":"from typing import List, Tuple, Dict def analyze_list(arr: List[int]) -> Tuple[List[int], List[int], Dict[int, int]]: Analyze a list of integers to find unique elements, sort the list, and count occurrences. Parameters: arr (list): The input list of integers. Returns: tuple: A tuple containing the list of unique elements, the sorted list, and a dictionary with element counts. Example: >>> analyze_list([4, 5, 6, 5, 4, 3, 2, 1, 3, 2]) ([4, 5, 6, 3, 2, 1], [1, 2, 2, 3, 3, 4, 4, 5, 5, 6], {4: 2, 5: 2, 6: 1, 3: 2, 2: 2, 1: 1}) >>> analyze_list([1, 2, 3, 4, 5, 6]) ([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})","solution":"def analyze_list(arr): Analyze a list of integers to find unique elements, sort the list, and count occurrences. Parameters: arr (list): The input list of integers. Returns: tuple: A tuple containing the list of unique elements, the sorted list, and a dictionary with element counts. # Step 1: Identify and print the unique elements in the order they appeared. unique_elements = [] seen = set() for num in arr: if num not in seen: unique_elements.append(num) seen.add(num) # Step 2: Sort the list in ascending order. sorted_list = sorted(arr) # Step 3: Count the occurrences of each element in the original list. element_frequency = {} for num in arr: if num in element_frequency: element_frequency[num] += 1 else: element_frequency[num] = 1 return unique_elements, sorted_list, element_frequency"},{"question":"def minSegments(n: int, s: str) -> int: Returns the minimum number of segments such that each segment contains only one distinct character. >>> minSegments(8, \\"00110011\\") 4 >>> minSegments(5, \\"11111\\") 1 >>> minSegments(1, \\"0\\") 1 >>> minSegments(2, \\"01\\") 2 >>> minSegments(6, \\"001111\\") 2 # code here def test_minSegments(): assert minSegments(8, \\"00110011\\") == 4 assert minSegments(5, \\"11111\\") == 1 assert minSegments(1, \\"0\\") == 1 assert minSegments(2, \\"01\\") == 2 assert minSegments(6, \\"001111\\") == 2 assert minSegments(0, \\"\\") == 0 def test_minSegments_edge_cases(): assert minSegments(10, \\"0000000000\\") == 1 assert minSegments(10, \\"0000000001\\") == 2 assert minSegments(10, \\"1010101010\\") == 10 assert minSegments(2, \\"10\\") == 2 assert minSegments(2, \\"11\\") == 1","solution":"def minSegments(n, s): Returns the minimum number of segments such that each segment contains only one distinct character. if n == 0: return 0 segment_count = 1 for i in range(1, n): if s[i] != s[i - 1]: segment_count += 1 return segment_count"},{"question":"from typing import List def ladderLength(beginWord: str, endWord: str, wordList: List[str]) -> int: Given two words, beginWord and endWord, and a dictionary's word list, determine the length of the shortest transformation sequence from beginWord to endWord, such that: 1. Only one letter can be changed at a time. 2. Each transformed word must exist in the word list. Note: - Return 0 if there is no such transformation sequence. - All words have the same length. - All words contain only lowercase alphabetic characters. - Assume no duplicates in the word list. - Assume beginWord and endWord are non-empty and are not the same. :param beginWord: A string representing the initial word :param endWord: A string representing the target word :param wordList: A list of strings representing the allowed transformations :return: An integer representing the length of the shortest transformation sequence Example: >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0","solution":"from collections import deque def ladderLength(beginWord, endWord, wordList): Returns the length of the shortest transformation sequence from beginWord to endWord, such that only one letter is changed at a time and each transformed word must exist in wordList. if endWord not in wordList: return 0 wordList = set(wordList) # Convert to a set for faster lookups queue = deque([(beginWord, 1)]) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordList: queue.append((next_word, steps + 1)) wordList.remove(next_word) # Remove the word to prevent re-visiting return 0"},{"question":"from typing import List, Tuple def find_minimum_soldiers(n: int, soldiers: List[int], roads: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the minimum number of soldiers that can be obtained by traveling from city u to city v along the path that connects them. Args: n : int : Number of cities soldiers : List[int] : List of soldiers in each city roads : List[Tuple[int, int]] : List of roads connecting the cities queries : List[Tuple[int, int]] : List of queries to find minimum soldiers along the path between cities Returns: List[int] : List of results for each query Examples: >>> find_minimum_soldiers(5, [10, 20, 30, 40, 50], [(1, 2), (1, 3), (3, 4), (3, 5)], [(1, 5), (2, 4), (4, 5)]) [10, 10, 30] >>> find_minimum_soldiers(3, [5, 2, 8], [(1, 2), (1, 3)], [(2, 3)]) [2] pass def test_find_minimum_soldiers(): # Example 1 n = 5 soldiers = [10, 20, 30, 40, 50] roads = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [(1, 5), (2, 4), (4, 5)] expected = [10, 10, 30] result = find_minimum_soldiers(n, soldiers, roads, queries) assert result == expected, f\\"expected {expected}, got {result}\\" # Example 2 n = 3 soldiers = [5, 2, 8] roads = [(1, 2), (1, 3)] queries = [(2, 3)] expected = [2] result = find_minimum_soldiers(n, soldiers, roads, queries) assert result == expected, f\\"expected {expected}, got {result}\\" # Example 3 n = 4 soldiers = [100, 200, 50, 60] roads = [(1, 2), (2, 3), (3, 4)] queries = [(1, 3), (2, 4)] expected = [50, 50] result = find_minimum_soldiers(n, soldiers, roads, queries) assert result == expected, f\\"expected {expected}, got {result}\\" # Example 4 n = 2 soldiers = [10, 20] roads = [(1, 2)] queries = [(1, 2)] expected = [10] result = find_minimum_soldiers(n, soldiers, roads, queries) assert result == expected, f\\"expected {expected}, got {result}\\"","solution":"from collections import defaultdict, deque def bfs(graph, start, soldiers): queue = deque([start]) visited = {start} dist = {start: soldiers[start - 1]} parent = {start: None} while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) parent[neighbor] = node dist[neighbor] = min(dist[node], soldiers[neighbor - 1]) queue.append(neighbor) return dist, parent def find_minimum_soldiers(n, soldiers, roads, queries): # Building the graph graph = defaultdict(list) for a, b in roads: graph[a].append(b) graph[b].append(a) # Preprocess all shortest paths with BFS from each node min_soldiers = {} parents = {} for node in range(1, n + 1): min_soldiers[node], parents[node] = bfs(graph, node, soldiers) results = [] # Store results for all queries for u, v in queries: min_soldier = float('inf') # Traverse from u to v using the pre-calculated paths # Simplified method leveraging pre-cached paths if min_soldiers[u][v]: min_soldier = min_soldiers[u][v] results.append(min_soldier) return results"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def handle_input_to_tree(N, values, edges): if N == 0: return None nodes = {i + 1: TreeNode(val) for i, val in enumerate(values)} for u, v in edges: if not nodes[u].left: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] return nodes[1] def get_all_paths_sums(root): if not root: return set() def dfs(node, current_sum, sums): if not node.left and not node.right: sums.add(current_sum + node.value) return if node.left: dfs(node.left, current_sum + node.value, sums) if node.right: dfs(node.right, current_sum + node.value, sums) sums = set() dfs(root, 0, sums) return sums def count_distinct_path_sums(T, test_cases): Count the number of distinct sums among all paths from root to leaf nodes in a binary tree for multiple test cases. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int], List[int]]]): List of tuples representing test cases. Each tuple contains the number of nodes, values of the nodes, and edges in the tree. Returns: List[int]: A list containing the number of distinct sums for each test case. Example: >>> T = 2 >>> test_cases = [ ... (3, [5, 3, 7], [1, 2, 1, 3]), ... (5, [1, 2, 3, 4, 5], [1, 2, 1, 3, 2, 4, 2, 5]), ... ] >>> count_distinct_path_sums(T, test_cases) [2, 3] results = [] for i in range(T): N, values, edge_list = test_cases[i] edges = [(edge_list[j], edge_list[j+1]) for j in range(0, len(edge_list), 2)] root = handle_input_to_tree(N, values, edges) distinct_sums = get_all_paths_sums(root) results.append(len(distinct_sums)) return results","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def handle_input_to_tree(N, values, edges): if N == 0: return None nodes = {i + 1: TreeNode(val) for i, val in enumerate(values)} for u, v in edges: if not nodes[u].left: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] return nodes[1] def get_all_paths_sums(root): if not root: return set() def dfs(node, current_sum, sums): if not node.left and not node.right: sums.add(current_sum + node.value) return if node.left: dfs(node.left, current_sum + node.value, sums) if node.right: dfs(node.right, current_sum + node.value, sums) sums = set() dfs(root, 0, sums) return sums def count_distinct_path_sums(T, test_cases): results = [] for i in range(T): N, values, edge_list = test_cases[i] edges = [(edge_list[j], edge_list[j+1]) for j in range(0, len(edge_list), 2)] root = handle_input_to_tree(N, values, edges) distinct_sums = get_all_paths_sums(root) results.append(len(distinct_sums)) return results"},{"question":"def find_min_depth(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the minimum depth of the organizational hierarchy for each test case. >>> find_min_depth(2, [(5, [(1, 0), (2, 1), (3, 2), (4, 2), (5, 1)]), (4, [(1, 0), (2, 1), (3, 1), (4, 1)])]) [3, 2] >>> find_min_depth(1, [(3, [(1, 0), (2, 1), (3, 1)])]) [2] def test_find_min_depth(): # test case 1 t1 = 2 test_cases_1 = [ (5, [(1, 0), (2, 1), (3, 2), (4, 2), (5, 1)]), (4, [(1, 0), (2, 1), (3, 1), (4, 1)]) ] assert find_min_depth(t1, test_cases_1) == [3, 2] # test case 2 t2 = 1 test_cases_2 = [ (3, [(1, 0), (2, 1), (3, 1)]) ] assert find_min_depth(t2, test_cases_2) == [2] # test case 3 t3 = 1 test_cases_3 = [ (6, [(1, 0), (2, 1), (3, 1), (4, 2), (5, 4), (6, 5)]) ] assert find_min_depth(t3, test_cases_3) == [5] # test case 4 t4 = 2 test_cases_4 = [ (3, [(1, 0), (2, 1), (3, 2)]), (4, [(1, 0), (2, 1), (3, 2), (4, 3)]) ] assert find_min_depth(t4, test_cases_4) == [3, 4] # test case 5 t5 = 1 test_cases_5 = [ (5, [(1, 0), (2, 1), (3, 2), (4, 1), (5, 2)]) ] assert find_min_depth(t5, test_cases_5) == [3] # Running the tests test_find_min_depth()","solution":"def find_min_depth(t, test_cases): def get_depth(eid, supervisor_map): if eid not in memo: if supervisor_map[eid] == 0: memo[eid] = 1 else: memo[eid] = 1 + get_depth(supervisor_map[eid], supervisor_map) return memo[eid] results = [] for i in range(t): n, employees = test_cases[i] supervisor_map = {} for eid, sid in employees: supervisor_map[eid] = sid max_depth = 0 memo = {} for eid in supervisor_map: max_depth = max(max_depth, get_depth(eid, supervisor_map)) results.append(max_depth) return results"},{"question":"def longestConsecutive(arr: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers. >>> longestConsecutive([100, 4, 200, 1, 3, 2]) == 4 >>> longestConsecutive([0, -1, -2, 2, 1, 3, 5]) == 6 >>> longestConsecutive([10, 5, 12, 3, 55, 11, 4]) == 3 >>> longestConsecutive([1, 2, 0, 1]) == 3 pass","solution":"def longestConsecutive(arr): Returns the length of the longest subsequence of consecutive integers. if not arr: return 0 num_set = set(arr) # Convert list to set for O(1) lookups max_length = 0 for num in num_set: # Check if it is a starting point of a sequence if num - 1 not in num_set: current_num = num current_length = 1 # Increment the sequence while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def max_magical_pairs(n: int, x: int, gemstones: List[int]) -> int: Calculate the maximum number of magical pairs of gemstones such that the sum of their values is divisible by x. Args: n: The number of gemstones. x: The divisor. gemstones: A list of integers representing the magical values of the gemstones. Returns: An integer representing the maximum number of magical pairs. Examples: >>> max_magical_pairs(5, 3, [1, 2, 3, 4, 6]) 2 >>> max_magical_pairs(7, 5, [2, 5, 7, 10, 3, 8, 4]) 3 >>> max_magical_pairs(4, 3, [1, 1, 1, 1]) 0 >>> max_magical_pairs(4, 1, [1, 2, 3, 4]) 2 >>> max_magical_pairs(6, 10, [10, 20, 30, 40, 50, 60]) 3 >>> max_magical_pairs(1, 2, [1]) 0 pass","solution":"def max_magical_pairs(n, x, gemstones): from collections import defaultdict count_remainders = defaultdict(int) for value in gemstones: remainder = value % x count_remainders[remainder] += 1 pairs = 0 for remainder in range((x // 2) + 1): if remainder == 0 or 2 * remainder == x: pairs += count_remainders[remainder] // 2 else: opposite_remainder = x - remainder possible_pairs = min(count_remainders[remainder], count_remainders[opposite_remainder]) pairs += possible_pairs count_remainders[remainder] -= possible_pairs count_remainders[opposite_remainder] -= possible_pairs return pairs"},{"question":"def activate_element(B, i): Activate the element at index i in the array B. def deactivate_element(B, i): Deactivate the element at index i in the array B. def range_sum(A, B, l, r): Compute the sum of all active elements in the range [l, r]. def process_queries(N, A, B, Q, queries): Process the queries including activating/deactivating elements and computing range sum. Parameters: N : int : Size of arrays A and B A : List[int] : Array of distinct integers B : List[int] : Array representing state (active/inactive) of elements in A Q : int : Number of queries queries : List[List[int]] : List of queries Returns: List[int] : Results of the range sum queries def test_activate_element(): B = [0, 0, 0] activate_element(B, 1) assert B == [1, 0, 0] activate_element(B, 3) assert B == [1, 0, 1] def test_deactivate_element(): B = [1, 1, 1] deactivate_element(B, 2) assert B == [1, 0, 1] deactivate_element(B, 3) assert B == [1, 0, 0] def test_range_sum(): A = [3, 1, 4, 1, 5] B = [1, 0, 1, 0, 1] assert range_sum(A, B, 1, 3) == 7 assert range_sum(A, B, 2, 5) == 9 def test_process_queries(): N = 10 A = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3] B = [1, 0, 1, 0, 1, 0, 1, 0, 1, 0] Q = 5 queries = [ [3, 1, 5], [2, 3], [3, 1, 5], [1, 2], [3, 1, 5] ] assert process_queries(N, A, B, Q, queries) == [12, 8, 9]","solution":"def activate_element(B, i): Activate the element at index i in the array B. B[i-1] = 1 def deactivate_element(B, i): Deactivate the element at index i in the array B. B[i-1] = 0 def range_sum(A, B, l, r): Compute the sum of all active elements in the range [l, r]. total_sum = 0 for i in range(l-1, r): if B[i] == 1: total_sum += A[i] return total_sum def process_queries(N, A, B, Q, queries): results = [] for query in queries: if query[0] == 1: activate_element(B, query[1]) elif query[0] == 2: deactivate_element(B, query[1]) elif query[0] == 3: results.append(range_sum(A, B, query[1], query[2])) return results"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an n x n matrix 90 degrees clockwise. >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[10, 20], [30, 40]]) [[30, 10], [40, 20]] >>> rotate_matrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_matrix([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) [[21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5]]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an n x n matrix 90 degrees clockwise. n = len(matrix) # Create a new n x n matrix rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n-1-i] = matrix[i][j] return rotated"},{"question":"def find_three_elements_with_sum(N: int, arr: List[int], S: int) -> str: Determines if there are three distinct elements in the array that add up to the given target sum S. >>> find_three_elements_with_sum(6, [1, 4, 45, 6, 10, 8], 22) 'YES' >>> find_three_elements_with_sum(5, [12, 3, 4, 1, 6], 24) 'NO'","solution":"def find_three_elements_with_sum(N, arr, S): Determines if there are three distinct elements in the array that add up to the given target sum S. Args: N: int - number of elements in the array arr: list - list of integers representing the array elements S: int - target sum Returns: str: \\"YES\\" if there are three distinct elements which sum to S, otherwise \\"NO\\" arr.sort() for i in range(N-2): l, r = i + 1, N - 1 while l < r: current_sum = arr[i] + arr[l] + arr[r] if current_sum == S: return \\"YES\\" elif current_sum < S: l += 1 else: r -= 1 return \\"NO\\" # Reading inputs and determining output if __name__ == \\"__main__\\": N = int(input().strip()) arr = list(map(int, input().strip().split())) S = int(input().strip()) print(find_three_elements_with_sum(N, arr, S))"},{"question":"from typing import List, Tuple def can_reach_all_neighborhoods(N: int, M: int, routes: List[Tuple[int, int, int]]) -> str: Determines if every neighborhood can be reached from every other neighborhood in Edenville. >>> can_reach_all_neighborhoods(4, 5, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10), (2, 4, 5)]) \\"YES\\" >>> can_reach_all_neighborhoods(4, 3, [(1, 2, 10), (3, 4, 10), (4, 3, 10)]) \\"NO\\" >>> can_reach_all_neighborhoods(1, 0, []) \\"YES\\" >>> can_reach_all_neighborhoods(5, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10)]) \\"NO\\" >>> can_reach_all_neighborhoods(3, 6, [(1, 2, 5), (2, 1, 5), (1, 3, 10), (3, 1, 10), (2, 3, 7), (3, 2, 7)]) \\"YES\\" >>> can_reach_all_neighborhoods(3, 0, []) \\"NO\\"","solution":"from collections import defaultdict, deque def can_reach_all_neighborhoods(N, M, routes): def bfs(start, graph): visited = [False] * (N+1) queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return visited if N == 1: return \\"YES\\" graph = defaultdict(list) reversed_graph = defaultdict(list) for u, v, t in routes: graph[u].append(v) reversed_graph[v].append(u) visited_from_start = bfs(1, graph) if not all(visited_from_start[1:]): return \\"NO\\" visited_from_start_rev = bfs(1, reversed_graph) if not all(visited_from_start_rev[1:]): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def calculate_parking_fee(entry_time: str, exit_time: str) -> int: Calculate the total parking fee for a vehicle based on its entry and exit time. The parking lot fee is calculated using the following rules: 1. The first hour is free. 2. For every subsequent hour or part thereof: 5 per hour. Parameters: entry_time (str): The entry time in HH:mm format. exit_time (str): The exit time in HH:mm format. Returns: int: The total parking fee. Examples: >>> calculate_parking_fee('10:00', '13:30') 10 >>> calculate_parking_fee('09:45', '12:01') 10 >>> calculate_parking_fee('07:00', '08:00') 0","solution":"from datetime import datetime def calculate_parking_fee(entry_time: str, exit_time: str) -> int: Calculate the parking fee based on entry and exit times. Parameters: entry_time (str): Entry time in HH:mm format. exit_time (str): Exit time in HH:mm format. Returns: int: Total parking fee. # Convert entry and exit times to datetime objects entry_dt = datetime.strptime(entry_time, \\"%H:%M\\") exit_dt = datetime.strptime(exit_time, \\"%H:%M\\") # Calculate the total parking duration in minutes duration_minutes = int((exit_dt - entry_dt).total_seconds() / 60) # Calculate the total parking duration in hours duration_hours = duration_minutes // 60 remaining_minutes = duration_minutes % 60 # Calculate the total fee if duration_hours == 0: return 0 else: # First hour is free, so we reduce the duration by 1 duration_hours -= 1 # Any remaining minutes count as an additional hour if remaining_minutes > 0: duration_hours += 1 # Fee is 5 per hour after the first hour return 5 * duration_hours"},{"question":"def organize_books(n: int, books: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Organize books by genre first and then by height within each genre in ascending order. Parameters: n (int): Number of books. books (List[Tuple[str, int]]): List of tuples where each tuple contains a genre and height of a book. Returns: List[Tuple[str, int]]: Sorted list of books by genre and height. Examples: >>> organize_books(6, [(\\"fiction\\", 10), (\\"nonfiction\\", 8), (\\"fiction\\", 20), (\\"mystery\\", 15), (\\"nonfiction\\", 5), (\\"mystery\\", 10)]) [('fiction', 10), ('fiction', 20), ('mystery', 10), ('mystery', 15), ('nonfiction', 5), ('nonfiction', 8)] >>> organize_books(4, [(\\"fantasy\\", 21), (\\"fantasy\\", 19), (\\"romance\\", 12), (\\"romance\\", 18)]) [('fantasy', 19), ('fantasy', 21), ('romance', 12), ('romance', 18)]","solution":"def organize_books(n, books): Organize books by genre first and then by height within each genre in ascending order. Parameters: n (int): Number of books. books (List[Tuple[str, int]]): List of tuples where each tuple contains a genre and height of a book. Returns: List[Tuple[str, int]]: Sorted list of books by genre and height. # Sorting the books first by genre, then by height within each genre sorted_books = sorted(books, key=lambda x: (x[0], x[1])) return sorted_books"},{"question":"def max_photos(n: int, C: int, battery_powers: List[int], recharge_points: List[int]) -> int: Determine the maximum number of scenic spots that can be photographed with the given battery power and recharge points. >>> max_photos(6, 5, [1, 2, 3, 2, 4, 1], [2, 5]) 4 >>> max_photos(4, 5, [1, 1, 1, 1], []) 4 >>> max_photos(4, 2, [1, 2, 1, 1], []) 1 >>> max_photos(4, 3, [1, 2, 1, 3], [1, 2, 3]) 4 >>> max_photos(10, 10, [1, 1, 4, 2, 6, 3, 7, 8, 9, 10], [3, 5, 7, 9]) 8 >>> max_photos(5, 5, [2, 2, 2, 2, 2], [1, 2, 3, 4]) 5 >>> max_photos(6, 5, [1, 2, 5, 2, 4, 1], [2, 4]) 3 >>> max_photos(4, 3, [2, 3, 1, 1], [3]) 1","solution":"def max_photos(n, C, battery_powers, recharge_points): recharge_set = set(recharge_points) battery = C count = 0 for i, power in enumerate(battery_powers): if battery >= power: battery -= power count += 1 else: break if (i + 1) in recharge_set: battery = C # Recharge to full battery return count"},{"question":"def min_diff_between_trees_heights(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum possible difference between the heights of the remaining trees after removing some of them. Args: t (int): Number of test cases. test_cases (list): A list where each element is a tuple (N, heights) where N is the number of trees and heights is a list of tree heights. Returns: list: A list containing the minimum possible difference for each test case. ------ Sample Input 1 ----- 2 4 2 6 4 8 3 1 3 5 ------ Sample Output 1 ----- 2 2","solution":"def min_diff_between_trees_heights(t, test_cases): Find the minimum possible difference between the heights of the remaining trees. Args: t (int): Number of test cases. test_cases (list): A list where each element is a tuple (N, heights) where N is the number of trees and heights is a list of tree heights. Returns: list: A list containing the minimum possible difference for each test case. result = [] for N, heights in test_cases: heights.sort() min_diff = float('inf') for i in range(1, N): min_diff = min(min_diff, heights[i] - heights[i - 1]) result.append(min_diff) return result"},{"question":"def minimal_bridges(n, edges): Returns the minimal total length of the bridges required to connect all the treehouses. >>> minimal_bridges(4, [(1, 2, 1), (2, 3, 4), (1, 3, 2), (3, 4, 3)]) 6 >>> minimal_bridges(4, [(1, 2, 1), (1, 3, 3), (4, 2, 2), (4, 3, 4), (1, 4, 5)]) 6 >>> minimal_bridges(5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4)]) 10 >>> minimal_bridges(5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 3, 2), (2, 4, 2), (3, 5, 2)]) 4 # Your code here","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimal_total_length(n, edges): Returns the minimum total length of bridges required to connect all treehouses. result = [] # This will store the resulting MST i = 0 # An index variable, used for sorted edges e = 0 # An index variable, used for result[] # Step 1: Sort all the edges in non-decreasing order of their weight. edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(n+1): parent.append(node) rank.append(0) # Number of edges to be taken is equal to V-1 while e < n - 1: # Step 2: Pick the smallest edge. Check if it forms a cycle with the spanning-tree # formed so far. If cycle is not formed, include this edge. Otherwise, discard it. u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) # If including this edge does not cause a cycle, # include it in result and increment the index of result for the next edge if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) # Else discard the edge # Calculate the total weight of the MST minimum_cost = 0 for u, v, weight in result: minimum_cost += weight return minimum_cost def minimal_bridges(n, edges): return minimal_total_length(n, edges)"},{"question":"def merge_sales(list1, list2): This function takes two lists of transactions and returns a list of tuples containing product ID and the total quantity sold for products that appear in both lists. Each input list contains tuples (product ID, quantity sold). >>> merge_sales([(101, 10), (202, 15), (303, 5)], [(101, 5), (303, 10), (404, 2)]) [(101, 15), (303, 15)] >>> merge_sales([(101, 10), (202, 15)], [(303, 5), (404, 2)]) [] >>> merge_sales([(101, 10), (202, 20)], [(101, 5), (202, 10)]) [(101, 15), (202, 30)] >>> merge_sales([(101, 10), (202, 15), (305, 7)], [(101, 5), (202, 10), (308, 4)]) [(101, 15), (202, 25)] >>> merge_sales([(101, 0), (202, 0)], [(101, 0), (202, 0)]) [(101, 0), (202, 0)]","solution":"def merge_sales(list1, list2): This function takes two lists of transactions and returns a list of tuples containing product ID and the total quantity sold for products that appear in both lists. Each input list contains tuples (product ID, quantity sold). from collections import defaultdict sales_map = defaultdict(int) for prod_id, qty in list1: sales_map[prod_id] += qty common_sales = [] for prod_id, qty in list2: if prod_id in sales_map: common_sales.append((prod_id, sales_map[prod_id] + qty)) return sorted(common_sales) # Example input list1 = [(101, 10), (202, 15), (303, 5)] list2 = [(101, 5), (303, 10), (404, 2)] print(merge_sales(list1, list2))"},{"question":"def minimize_wand_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Distribute the wands into two groups to minimize the absolute difference of their sums. Args: T : int The number of test cases. test_cases : List[Tuple[int, List[int]]] Each test case contains an integer N representing the number of magic wands and a list of integers indicating the numbers etched on the wands. Returns: List[int] A list of integers where each integer represents the minimal absolute difference achievable between the sums of the two groups for each test case. >>> minimize_wand_difference(2, [(4, [1, 6, 11, 5]), (3, [3, 1, 4])]) [1, 0]","solution":"def minimize_wand_difference(T, test_cases): results = [] for case in test_cases: N, wands = case total_sum = sum(wands) dp = [0] * (total_sum // 2 + 1) for wand in wands: for j in range(total_sum // 2, wand - 1, -1): dp[j] = max(dp[j], dp[j - wand] + wand) min_diff = total_sum - 2 * dp[total_sum // 2] results.append(min_diff) return results"},{"question":"def reorder_list(n: int, arr: List[int]) -> List[int]: Reorders a list such that all positive integers appear before all negative integers, and within the same group (positive or negative), the integers are sorted in descending order. :param n: The number of integers in the list :param arr: The list of integers :return: A reordered list # Implement this function # Test cases def test_reorder_list_example1(): result = reorder_list(10, [3, -5, 12, -1, 0, -6, 2, 4, -2, 7]) assert result == [12, 7, 4, 3, 2, 0, -1, -2, -5, -6] def test_reorder_list_example2(): result = reorder_list(8, [-4, -9, -2, -3, 1, 0, 5, 6]) assert result == [6, 5, 1, 0, -2, -3, -4, -9] def test_reorder_list_all_positive(): result = reorder_list(5, [10, 8, 6, 4, 2]) assert result == [10, 8, 6, 4, 2] def test_reorder_list_all_negative(): result = reorder_list(5, [-1, -2, -3, -4, -5]) assert result == [-1, -2, -3, -4, -5] def test_reorder_list_mixed_zeros(): result = reorder_list(5, [0, -1, 0, 1, -2]) assert result == [1, 0, 0, -1, -2]","solution":"def reorder_list(n, arr): Reorders a list such that all positive integers appear before all negative integers, and within the same group (positive or negative), the integers are sorted in descending order. :param n: The number of integers in the list :param arr: The list of integers :return: A reordered list positives = sorted([x for x in arr if x >= 0], reverse=True) negatives = sorted([x for x in arr if x < 0], reverse=True) return positives + negatives"},{"question":"def max_distance_arms(n: int, lengths: List[int]) -> float: Given the number of robotic arms and their lengths, return the maximum possible distance between two points starting from the same initial point using two arms. The answer should be rounded to one decimal place. >>> max_distance_arms(4, [5, 10, 3, 8]) 18.0 >>> max_distance_arms(3, [7, 2, 5]) 12.0","solution":"def max_distance_arms(n, lengths): Given the number of robotic arms and their lengths, return the maximum possible distance between two points starting from the same initial point using two arms. # Sort the lengths list in descending order to get the two longest arms lengths.sort(reverse=True) # The maximum distance will be the sum of the two longest lengths return round(float(lengths[0] + lengths[1]), 1) # Example usage of the function n = 4 lengths = [5, 10, 3, 8] print(max_distance_arms(n, lengths)) # Output: 18.0"},{"question":"def sum_non_border_elements(matrix: List[List[int]]) -> int: Returns the sum of non-border elements of a rectangular matrix. :param matrix: List of List of integers representing the matrix :return: Integer sum of non-border elements >>> sum_non_border_elements([ ... [1, 1, 1, 1], ... [1, 2, 2, 1], ... [1, 2, 2, 1], ... [1, 1, 1, 1] ... ]) 8 >>> sum_non_border_elements([ ... [1, 1, 1], ... [1, 2, 1], ... [1, 1, 1] ... ]) 2 >>> sum_non_border_elements([ ... [1, 1], ... [1, 1] ... ]) 0 def process_input(T: int, cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Processes the input cases. :param T: Integer number of test cases :param cases: List of Tuples containing the dimensions of the matrix and the matrix itself :return: List of integers with the sum of non-border elements for each case >>> process_input(2, [(4, 4, [ ... [1, 1, 1, 1], ... [1, 2, 2, 1], ... [1, 2, 2, 1], ... [1, 1, 1, 1] ... ]), (3, 3, [ ... [1, 1, 1], ... [1, 2, 1], ... [1, 1, 1] ... ])]) [8, 2] def main(T: int, cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Main function to handle input and output for the problem. :param T: Integer number of test cases :param cases: List of Tuples containing the dimensions of the matrix and the matrix itself :return: List of integers with the sum of non-border elements for each case >>> main(2, [(4, 4, [ ... [1, 1, 1, 1], ... [1, 2, 2, 1], ... [1, 2, 2, 1], ... [1, 1, 1, 1] ... ]), (3, 3, [ ... [1, 1, 1], ... [1, 2, 1], ... [1, 1, 1] ... ])]) [8, 2]","solution":"def sum_non_border_elements(matrix): Returns the sum of non-border elements of a rectangular matrix. M = len(matrix) N = len(matrix[0]) # If the matrix is smaller than 3x3, there are no non-border elements if M < 3 or N < 3: return 0 sum_non_border = 0 for i in range(1, M-1): for j in range(1, N-1): sum_non_border += matrix[i][j] return sum_non_border def process_input(T, cases): results = [] for case in cases: M, N, matrix = case result = sum_non_border_elements(matrix) results.append(result) return results def main(T, cases): results = process_input(T, cases) return results"},{"question":"def is_rearrangement_palindrome(s: str) -> bool: Determines if any permutation of the input string can form a palindrome. >>> is_rearrangement_palindrome(\\"civic\\") True >>> is_rearrangement_palindrome(\\"ivicc\\") True >>> is_rearrangement_palindrome(\\"hello\\") False >>> is_rearrangement_palindrome(\\"aabb\\") True >>> is_rearrangement_palindrome(\\"abcd\\") False","solution":"def is_rearrangement_palindrome(s): Determines if any permutation of the input string can form a palindrome. Args: s (str): The input string. Returns: bool: True if any permutation of the string can form a palindrome, False otherwise. from collections import Counter # Count the occurrence of each character char_count = Counter(s) # Check the number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def determine_winner(participants): Determines the winner from a list of participants based on the criteria. Args: participants: List of tuples where each tuple contains (id, score, submissions) Returns: The ID of the winning participant. Examples: >>> determine_winner([(101, 500, 3), (102, 500, 2), (103, 600, 5), (104, 600, 6), (105, 600, 5)]) 103 >>> determine_winner([(101, 500, 3)]) 101 >>> determine_winner([(101, 500, 3), (102, 500, 3)]) 101 >>> determine_winner([(101, 500, 3), (102, 600, 4)]) 102 >>> determine_winner([(101, 500, 3), (102, 500, 2)]) 102 >>> determine_winner([(101, 500, 3), (102, 700, 2), (103, 700, 3), (104, 700, 2)]) 102","solution":"def determine_winner(participants): Determines the winner from a list of participants based on the criteria. Args: participants: List of tuples where each tuple contains (id, score, submissions) Returns: The ID of the winning participant. # Sort participants by score (descending), submissions (ascending), ID (ascending) participants.sort(key=lambda x: (-x[1], x[2], x[0])) return participants[0][0] # Example Usage # participants = [ # (101, 500, 3), # (102, 500, 2), # (103, 600, 5), # (104, 600, 6), # (105, 600, 5) # ] # print(determine_winner(participants)) # Output: 103"},{"question":"def find_closest_sum_pair(nums: List[int], target: int) -> Tuple[int, int]: Finds two integers in the list whose sum is closest to the given target number. Args: nums: List of integers. target: Target number. Returns: A tuple of two integers whose sum is closest to the target. Constraints: * 2 ≤ length of the list ≤ 1000 * -10000 ≤ elements of the list ≤ 10000 * -20000 ≤ target number ≤ 20000 >>> find_closest_sum_pair([-1, 2, 1, -4, 3], 1) (-1, 2) >>> find_closest_sum_pair([1, 3, 5, -1, -5, 4], 0) (-1, 1) from typing import List, Tuple","solution":"def find_closest_sum_pair(nums, target): Finds two integers in nums whose sum is closest to the target. nums.sort() closest_sum = float('inf') closest_pair = (0, 0) left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum closest_pair = (nums[left], nums[right]) if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: break return closest_pair"},{"question":"def canBeIncreasing(arr): Determines if it's possible to remove at most one element from the array to make it strictly increasing. :param arr: List[int] - List of integers. :return: str - \\"YES\\" or \\"NO\\". Examples: >>> canBeIncreasing([1, 2, 10, 5, 7]) \\"YES\\" >>> canBeIncreasing([2, 3, 1, 2]) \\"NO\\" >>> canBeIncreasing([1, 2, 3, 4]) \\"YES\\"","solution":"def canBeIncreasing(arr): Determines if it's possible to remove at most one element from the array to make it strictly increasing. def is_strictly_increasing(a): return all(a[i] < a[i+1] for i in range(len(a) - 1)) for i in range(len(arr)): if is_strictly_increasing(arr[:i] + arr[i+1:]): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def maximizeHappiness(Happiness: List[int], Sweetness: List[int]) -> int: Optimize the way to serve candies to children in an event to maximize the total minimum happiness each child gets. Each child will receive exactly one candy. The child's happiness is determined by the minimum of the child's happiness level and the sweetness level of the candy given to them. Parameters: Happiness (List[int]): List of happiness levels of the children. Sweetness (List[int]): List of sweetness levels of the candies. Returns: int: Maximum possible sum of minimum happiness each child will get. Example: >>> maximizeHappiness([3, 4, 5], [2, 3, 4]) 9 >>> maximizeHappiness([1, 2, 3], [10, 11, 12]) 6","solution":"from typing import List def maximizeHappiness(Happiness: List[int], Sweetness: List[int]) -> int: # Sort the happiness and sweetness arrays Happiness.sort() Sweetness.sort() total_min_happiness = 0 # Iterate through the sorted lists and match the candies to the children for h, s in zip(Happiness, Sweetness): total_min_happiness += min(h, s) return total_min_happiness"},{"question":"def count_matching_substrings(s: str, p: str) -> int: Count the number of distinct substrings in the string \`s\` that match the pattern \`p\`. The pattern \`p\` may contain wildcard characters, where \`?\` matches exactly one arbitrary character. >>> count_matching_substrings(\\"abacabad\\", \\"a?a\\") 2 >>> count_matching_substrings(\\"aaaa\\", \\"aa\\") 1 >>> count_matching_substrings(\\"mississippi\\", \\"iss?ss?pp\\") 1 from solution import count_matching_substrings def test_example1(): assert count_matching_substrings(\\"abacabad\\", \\"a?a\\") == 2 def test_example2(): assert count_matching_substrings(\\"aaaa\\", \\"aa\\") == 1 def test_example3(): assert count_matching_substrings(\\"mississippi\\", \\"iss?ss?pp\\") == 1 def test_no_match(): assert count_matching_substrings(\\"abcdefg\\", \\"h?i\\") == 0 def test_edge_case_single_char(): assert count_matching_substrings(\\"a\\", \\"a\\") == 1 assert count_matching_substrings(\\"a\\", \\"?\\") == 1 assert count_matching_substrings(\\"a\\", \\"b\\") == 0 def test_edge_case_exact_match(): assert count_matching_substrings(\\"abc\\", \\"abc\\") == 1 assert count_matching_substrings(\\"abcabc\\", \\"abc\\") == 1 def test_multiple_wildcards(): assert count_matching_substrings(\\"abcde\\", \\"a?c?e\\") == 1 assert count_matching_substrings(\\"axcye\\", \\"a?c?e\\") == 1 def test_identical_partial_substrings(): assert count_matching_substrings(\\"aaaaaa\\", \\"?a\\") == 1 def test_all_wildcards(): assert count_matching_substrings(\\"abcde\\", \\"?????\\") == 1 assert count_matching_substrings(\\"abcde\\", \\"???\\") == 3","solution":"def count_matching_substrings(s, p): def is_match(sub, pat): for cs, cp in zip(sub, pat): if cp != '?' and cs != cp: return False return True m, n = len(s), len(p) matched_substrings = set() for i in range(m - n + 1): substring = s[i:i+n] if is_match(substring, p): matched_substrings.add(substring) return len(matched_substrings)"},{"question":"def rotate_array(nums, k): Rotates an array to the right by k steps. :param nums: List[int] - The list of integers to rotate :param k: int - The number of steps to rotate the array :return: List[int] - The rotated array >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([], 1) [] pass # to be implemented # Test cases print(rotate_array([1, 2, 3, 4, 5, 6, 7], 3)) # Output: [5, 6, 7, 1, 2, 3, 4] print(rotate_array([1, 2, 3, 4, 5, 6, 7], 10)) # Output: [5, 6, 7, 1, 2, 3, 4] print(rotate_array([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] print(rotate_array([], 1)) # Output: []","solution":"def rotate_array(nums, k): Rotates an array to the right by k steps. :param nums: List[int] - The list of integers to rotate :param k: int - The number of steps to rotate the array :return: List[int] - The rotated array n = len(nums) if n == 0: return [] k = k % n # Handle cases where k > n return nums[-k:] + nums[:-k]"},{"question":"def nth_prime(N: int) -> int: Find the Nth prime number. Parameters: N (int): The position of the prime number to find. Returns: int: The Nth prime number. Examples: >>> nth_prime(1) 2 >>> nth_prime(5) 11 def test_nth_prime_1(): assert nth_prime(1) == 2 def test_nth_prime_2(): assert nth_prime(2) == 3 def test_nth_prime_3(): assert nth_prime(3) == 5 def test_nth_prime_5(): assert nth_prime(5) == 11 def test_nth_prime_10(): assert nth_prime(10) == 29 def test_nth_prime_100(): assert nth_prime(100) == 541 def test_nth_prime_1000(): assert nth_prime(1000) == 7919 def test_nth_prime_10000(): assert nth_prime(10000) == 104729","solution":"def nth_prime(N): Find the Nth prime number. Parameters: N (int): The position of the prime number to find. Returns: int: The Nth prime number. def is_prime(num): if num < 2: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True prime_count = 0 num = 1 while prime_count < N: num += 1 if is_prime(num): prime_count += 1 return num"},{"question":"def calculate_revenues(n, products): Calculate the revenue for each product and the overall total revenue. Parameters: n (int): The number of different products. products (list of tuples): Each tuple contains (name, price, quantity) Returns: dict: A dictionary where keys are product names and values are their revenues. float: The overall total revenue. >>> products = [ ... (\\"ProductA\\", 10.00, 5), ... (\\"ProductB\\", 15.50, 3), ... (\\"ProductC\\", 7.25, 8) ... ] >>> calculate_revenues(3, products) ({\\"ProductA\\": 50.00, \\"ProductB\\": 46.50, \\"ProductC\\": 58.00}, 154.50)","solution":"def calculate_revenues(n, products): Calculate the revenue for each product and the overall total revenue. Parameters: n (int): The number of different products. products (list of tuples): Each tuple contains (name, price, quantity) Returns: dict: A dictionary where keys are product names and values are their revenues. float: The overall total revenue. revenues = {} total_revenue = 0.0 for product in products: name, price, quantity = product revenue = price * quantity revenues[name] = revenue total_revenue += revenue return revenues, total_revenue"},{"question":"from typing import List def findUnion(arr1: List[int], arr2: List[int], N: int, M: int) -> List[int]: Find the union of two sorted arrays arr1 and arr2. Parameters: arr1 (List[int]): Sorted array of size N arr2 (List[int]): Sorted array of size M N (int): Size of arr1 M (int): Size of arr2 Returns: List[int]: Sorted list containing the union of arr1 and arr2 Examples: >>> findUnion([1, 2, 4, 5, 6], [3, 5, 7], 5, 3) [1, 2, 3, 4, 5, 6, 7] >>> findUnion([2, 2, 3, 4], [4, 4, 5, 6], 4, 4) [2, 3, 4, 5, 6] def test_example_1(): arr1 = [1, 2, 4, 5, 6] arr2 = [3, 5, 7] N = 5 M = 3 assert findUnion(arr1, arr2, N, M) == [1, 2, 3, 4, 5, 6, 7] def test_example_2(): arr1 = [2, 2, 3, 4] arr2 = [4, 4, 5, 6] N = 4 M = 4 assert findUnion(arr1, arr2, N, M) == [2, 3, 4, 5, 6] def test_no_overlap(): arr1 = [1, 3, 5, 7] arr2 = [2, 4, 6, 8] N = 4 M = 4 assert findUnion(arr1, arr2, N, M) == [1, 2, 3, 4, 5, 6, 7, 8] def test_identical_arrays(): arr1 = [1, 2, 3] arr2 = [1, 2, 3] N = 3 M = 3 assert findUnion(arr1, arr2, N, M) == [1, 2, 3] def test_empty_arrays(): arr1 = [] arr2 = [] N = 0 M = 0 assert findUnion(arr1, arr2, N, M) == [] def test_one_empty_array(): arr1 = [1, 2, 3] arr2 = [] N = 3 M = 0 assert findUnion(arr1, arr2, N, M) == [1, 2, 3] arr1 = [] arr2 = [1, 2, 3] N = 0 M = 3 assert findUnion(arr1, arr2, N, M) == [1, 2, 3]","solution":"def findUnion(arr1, arr2, N, M): Finds the union of two sorted arrays arr1 and arr2. Parameters: arr1 (List[int]): Sorted array of size N arr2 (List[int]): Sorted array of size M N (int): Size of arr1 M (int): Size of arr2 Returns: List[int]: Sorted list containing the union of arr1 and arr2 union_result = set(arr1).union(set(arr2)) return sorted(union_result)"},{"question":"def generate_beautiful_picture(n: int) -> (int, List[Tuple[int, int]]): Generate coordinates of green cells in a beautiful picture with n specified cells and even numbered neighbors. :param n: The number of core green cells. :return: (k, coordinates) tuple where k is the total number of green cells and coordinates is list of tuples (x, y). >>> k, coords = generate_beautiful_picture(3) >>> k 9 >>> coords [(0, 0), (1, -1), (1, 0), (1, 1), (2, -1), (2, 0), (2, 1), (3, 0), (4, 0)]","solution":"def generate_beautiful_picture(n): Returns the coordinates of green cells in a beautiful picture with n specified cells and even numbered neighbours. :param n: The number of core green cells. :return: (k, coordinates) tuple where k is the total number of green cells and coordinates is list of tuples (x, y). # Start with the first required n green cells in a line or zig-zag form coords = [(i, 0) for i in range(n)] # Structure surrounding required n cells to ensure even number of green neighbours border = set() for x, y in coords: for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (1, -1), (-1, 1)]: border.add((x + dx, y + dy)) # Ensure we don't double add the coords in the border all_coords = set(coords + list(border)) all_coords = sorted(list(all_coords)) return len(all_coords), all_coords # Example run for input n = 3 k, coordinates = generate_beautiful_picture(3) print(k) for x, y in coordinates: print(x, y)"},{"question":"def gcd(a: int, b: int) -> int: Find the greatest common divisor of two numbers. >>> gcd(6, 9) 3 >>> gcd(12, 15) 3 >>> gcd(24, 36) 12 >>> gcd(7, 3) 1 >>> gcd(100, 1000) 100 def max_plot_area(m: int, n: int) -> int: Find the maximum possible area of each of the smaller plots. >>> max_plot_area(6, 9) 9 >>> max_plot_area(12, 15) 9 >>> max_plot_area(24, 36) 144 >>> max_plot_area(7, 3) 1 >>> max_plot_area(100, 1000) 10000 def solve_garden_division(test_cases: List[Tuple[int, int]]) -> List[int]: Given the dimensions of the garden, determine the maximum possible area of each of the smaller plots for each test case. >>> solve_garden_division([(6, 9), (12, 15), (24, 36), (7, 3), (100, 1000)]) [9, 9, 144, 1, 10000]","solution":"def gcd(a, b): while b: a, b = b, a % b return a def max_plot_area(m, n): greatest_common_divisor = gcd(m, n) return greatest_common_divisor ** 2 def solve_garden_division(test_cases): results = [] for m, n in test_cases: results.append(max_plot_area(m, n)) return results"},{"question":"def can_be_sorted_with_one_operation(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine whether the array can be sorted in non-decreasing order by performing at most one operation. In a single operation, you can increase or decrease any element of the array by 1. Parameters: T (int): The number of test cases test_cases (List[Tuple[int, List[int]]]): A list containing T tuples, each tuple contains N (the size of array) and the list of integers representing the array. Returns: List[str]: A list containing results for each test case (\\"YES\\" or \\"NO\\"). >>> can_be_sorted_with_one_operation(3, [(4, [1, 5, 3, 4]), (3, [2, 1, 2]), (5, [4, 2, 3, 1, 5])]) ['YES', 'YES', 'NO'] >>> can_be_sorted_with_one_operation(1, [(2, [-1, -1])]) ['YES']","solution":"def can_be_sorted_with_one_operation(T, test_cases): results = [] for t in range(T): N, A = test_cases[t] count = 0 for i in range(N - 1): if A[i] > A[i + 1]: count += 1 if count > 1: results.append(\\"NO\\") break if i > 0 and A[i-1] > A[i+1] and i + 2 < N and A[i] > A[i+2]: results.append(\\"NO\\") break else: results.append(\\"YES\\") return results"},{"question":"def isConsecutiveSequence(lst: List[int]) -> bool: Given a list of positive integers, determine if the list forms a consecutive sequence. A consecutive sequence is a sequence in which every adjacent element differs by exactly 1. >>> isConsecutiveSequence([5, 6, 7, 8, 9]) True >>> isConsecutiveSequence([1, 2, 4, 5, 6]) False >>> isConsecutiveSequence([10, 9, 8, 7, 6]) True >>> isConsecutiveSequence([1]) True >>> isConsecutiveSequence([2, 3]) True >>> isConsecutiveSequence([2, 4]) False >>> isConsecutiveSequence(list(range(1, 100001))) True >>> isConsecutiveSequence(list(range(1, 100001)) + [100003]) False >>> isConsecutiveSequence([3, 2, 1, 5, 4]) True","solution":"def isConsecutiveSequence(lst): if len(lst) <= 1: return True lst_sorted = sorted(lst) for i in range(1, len(lst_sorted)): if lst_sorted[i] - lst_sorted[i - 1] != 1: return False return True"},{"question":"def reverse_array_in_place(a): Given an array of integers, reverse the array in place without using any additional array or collection. You are only allowed to use extra space for variables. :param a: List of integers to be reversed :return: The list itself after reversing the elements >>> reverse_array_in_place([1, 2, 3, 4]) [4, 3, 2, 1] >>> reverse_array_in_place([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> reverse_array_in_place([1]) [1] >>> reverse_array_in_place([]) [] >>> reverse_array_in_place([-1, -2, -3, -4, -5]) [-5, -4, -3, -2, -1] >>> reverse_array_in_place([-1, 2, -3, 4, -5]) [-5, 4, -3, 2, -1] >>> reverse_array_in_place(list(range(1, 100001))) list(range(100000, 0, -1))","solution":"def reverse_array_in_place(a): Reverses the given array in place. :param a: List of integers to be reversed :return: The list itself after reversing the elements left = 0 right = len(a) - 1 while left < right: # Swap the elements a[left], a[right] = a[right], a[left] # Move towards the center of the array left += 1 right -= 1 return a"},{"question":"def min_cost(grid): Returns the minimum cost to reach from top-left corner to bottom-right corner of the grid. >>> min_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost([[1, 2], [1, 1]]) 3 >>> min_cost([[1, 2, 3, 4]]) 10 >>> min_cost([[1], [2], [3], [4]]) 10 >>> min_cost([[1, 3, 2, 1], [4, 6, 2, 2], [1, 2, 1, 5], [3, 2, 1, 1]]) 11 >>> min_cost([[1000, 2000], [3000, 4000]]) 7000 >>> min_cost([[1]]) 1","solution":"def min_cost(grid): Returns the minimum cost to reach from top-left corner to bottom-right corner of the grid. N = len(grid) M = len(grid[0]) # DP array to store the minimum cost to reach each cell (i, j) dp = [[0] * M for _ in range(N)] # Initialize the cost to reach the first cell dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp array for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][M-1]"},{"question":"def process_operations(n: int, q: int, array: List[int], operations: List[List[int]]) -> List[int]: Processes a list of operations on an array of integers. Each operation can either update the value at a given index or query the sum of a subarray. >>> n = 5 >>> q = 5 >>> array = [1, 2, 3, 4, 5] >>> operations = [ ... [2, 1, 3], ... [1, 2, 10], ... [2, 1, 3], ... [1, 5, 20], ... [2, 4, 5] ... ] >>> process_operations(n, q, array, operations) [6, 14, 24] >>> n = 3 >>> q = 3 >>> array = [5, 1, 7] >>> operations = [ ... [2, 1, 2], ... [1, 1, 10], ... [2, 1, 3] ... ] >>> process_operations(n, q, array, operations) [6, 18]","solution":"def process_operations(n, q, array, operations): result = [] for operation in operations: if operation[0] == 1: _, i, x = operation array[i-1] = x elif operation[0] == 2: _, l, r = operation result.append(sum(array[l-1:r])) return result"},{"question":"def aesthetically_pleasing_triplets(N: int) -> int: Returns the number of aesthetically pleasing triplets for a given N. A triplet (i, j, k) is considered aesthetically pleasing if tree 'i' is planted at the i-th position, tree 'j' is planted at the j-th position, and there's at least one flower planted between tree 'i' and tree 'j', and tree 'j' and tree 'k'. >>> aesthetically_pleasing_triplets(3) 1 >>> aesthetically_pleasing_triplets(4) 4 >>> aesthetically_pleasing_triplets(5) 10 pass def solve(test_cases: List[int]) -> List[int]: Solves multiple test cases and returns their results in a list. >>> solve([3, 4]) [1, 4] >>> solve([3, 4, 5]) [1, 4, 10] pass","solution":"def aesthetically_pleasing_triplets(N): Returns the number of aesthetically pleasing triplets for a given N. We can plant exactly N trees in a single line, where each tree is separated from the others by exactly 1 meter. if N < 3: return 0 # The number of aesthetically pleasing triplets is the combination of selecting 3 trees out of N return (N - 2) * (N - 1) * N // 6 def solve(test_cases): results = [] for N in test_cases: results.append(aesthetically_pleasing_triplets(N)) return results"},{"question":"def largest_contiguous_residential_block(grid: List[List[str]]) -> int: Finds the largest contiguous block of residential land ('R') in the grid. Examples: >>> largest_contiguous_residential_block([ ... ['R', 'W', 'R', 'R'], ... ['R', 'R', 'W', 'R'], ... ['W', 'R', 'R', 'W'], ... ['R', 'W', 'W', 'R'] ... ]) 5 >>> largest_contiguous_residential_block([ ... ['W', 'W', 'I', 'W'], ... ['W', 'I', 'W', 'W'], ... ['W', 'W', 'W', 'I'], ... ['I', 'W', 'W', 'I'] ... ]) 0 >>> largest_contiguous_residential_block([ ... ['R', 'W', 'R', 'W'], ... ['W', 'R', 'W', 'R'], ... ['R', 'W', 'R', 'W'], ... ['W', 'R', 'W', 'R'] ... ]) 1 >>> largest_contiguous_residential_block([ ... ['R', 'R', 'R'], ... ['R', 'R', 'R'], ... ['R', 'R', 'R'] ... ]) 9 >>> largest_contiguous_residential_block([ ... ['R'] ... ]) 1 pass","solution":"def largest_contiguous_residential_block(grid): Finds the largest contiguous block of residential land ('R') in the grid. :param grid: A 2D list representing the city map. :return: Size of the largest contiguous residential block. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or visited[r][c] or grid[r][c] != 'R': return 0 visited[r][c] = True size = 1 size += dfs(r + 1, c) size += dfs(r - 1, c) size += dfs(r, c + 1) size += dfs(r, c - 1) return size max_block_size = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 'R' and not visited[r][c]: max_block_size = max(max_block_size, dfs(r, c)) return max_block_size"},{"question":"def can_assign_jobs(T, test_cases): Determine if each delivery job can be assigned to a driver without exceeding the weight limits. Args: T: int - Number of test cases test_cases: list of dicts - Each test case is a dictionary with keys: D: int - Number of drivers J: int - Number of jobs drivers: list of int - Weight limits of drivers jobs: list of int - Weights of jobs Returns: list of str - A list containing \\"YES\\" or \\"NO\\" for each test case >>> can_assign_jobs(2, [{'D': 3, 'J': 3, 'drivers': [10, 20, 30], 'jobs': [30, 20, 10]}, {'D': 2, 'J': 4, 'drivers': [20, 15], 'jobs': [5, 10, 15, 5]}]) [\\"YES\\", \\"NO\\"] def test_can_assign_jobs(): test_cases = [ { 'D': 3, 'J': 3, 'drivers': [10, 20, 30], 'jobs': [30, 20, 10], 'expected': \\"YES\\" }, { 'D': 2, 'J': 4, 'drivers': [20, 15], 'jobs': [5, 10, 15, 5], 'expected': \\"NO\\" }, { 'D': 3, 'J': 2, 'drivers': [5, 5, 5], 'jobs': [5, 5], 'expected': \\"YES\\" }, { 'D': 3, 'J': 4, 'drivers': [1, 2, 3], 'jobs': [1, 2, 3, 4], 'expected': \\"NO\\" }, ] for case in test_cases: result = can_assign_jobs(1, [case]) assert result == [case['expected']], f\\"Failed for test case: {case}\\"","solution":"def can_assign_jobs(T, test_cases): results = [] for i in range(T): D, J = test_cases[i]['D'], test_cases[i]['J'] drivers = sorted(test_cases[i]['drivers'], reverse=True) jobs = sorted(test_cases[i]['jobs'], reverse=True) if D < J: results.append(\\"NO\\") continue possible = True job_index = 0 for driver in drivers: if job_index < J and driver >= jobs[job_index]: job_index += 1 if job_index == J: break if job_index == J: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def longestEvenSubarray(B): Given an array B[] of integers, return the start and end indices of the longest contiguous subarray that contains only even numbers. If there are multiple subarrays with the same length, return the indices of the first one. >>> longestEvenSubarray([1, 2, 4, 6, 1, 2, 2, 4]) == (1, 3) >>> longestEvenSubarray([1, 3, 5, 7, 2, 4, 6, 8, 10, 11]) == (4, 8)","solution":"def longestEvenSubarray(B): max_length = 0 max_start = max_end = -1 current_start = -1 current_length = 0 for i in range(len(B)): if B[i] % 2 == 0: if current_start == -1: current_start = i current_length += 1 else: if current_length > max_length: max_length = current_length max_start = current_start max_end = i - 1 current_start = -1 current_length = 0 if current_length > max_length: max_length = current_length max_start = current_start max_end = len(B) - 1 return max_start, max_end"},{"question":"def find_smallest_missing_positive(nums: List[int]) -> int: Given an array of integers, nums, that contains n elements, find the smallest positive integer that is missing from the array. The array can have both positive and negative numbers, and may contain duplicates. Args: nums: List of integers containing n elements. Returns: The smallest positive integer missing from the array. Examples: >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0, -1, -2, -3, 5]) 3 >>> find_smallest_missing_positive([1, 1, 3]) 2 from solution import find_smallest_missing_positive def test_example1(): assert find_smallest_missing_positive([3, 4, -1, 1]) == 2 def test_example2(): assert find_smallest_missing_positive([1, 2, 0, -1, -2, -3, 5]) == 3 def test_example3(): assert find_smallest_missing_positive([1, 1, 3]) == 2 def test_smallest_missing_positive(): assert find_smallest_missing_positive([1, 2, 3, 4]) == 5 assert find_smallest_missing_positive([2, 3, 7, 6, 8, -1, -10, 15]) == 1 assert find_smallest_missing_positive([7, 8, 9, 11, 12]) == 1 def test_only_one_element(): assert find_smallest_missing_positive([1]) == 2 assert find_smallest_missing_positive([-1]) == 1 def test_all_negative(): assert find_smallest_missing_positive([-2, -3, -7, -1]) == 1 def test_all_positive(): assert find_smallest_missing_positive([2, 3, 4, 5]) == 1 def test_large_array(): assert find_smallest_missing_positive(list(range(1, 100001))) == 100001 nums = list(range(2, 100002)) nums[-1] = 1 assert find_smallest_missing_positive(nums) == 100001","solution":"def find_smallest_missing_positive(nums): Given a list of integers, return the smallest positive integer that is missing from the list. Using the concept of swapping elements to their correct positions. Time complexity: O(n) Space complexity: O(1) n = len(nums) for i in range(n): # Place nums[i] to the correct position if nums[i] is in the range [1, n] while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: correct_index = nums[i] - 1 nums[i], nums[correct_index] = nums[correct_index], nums[i] # Find the first position where the number is not correct for i in range(n): if nums[i] != i + 1: return i + 1 # If all positions are correct, the missing number is n + 1 return n + 1"},{"question":"def max_non_overlapping_projects(n: int, projects: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping projects. :param n: The number of projects. :param projects: List of projects where each project is a tuple (s, e) with s as start day and e as end day. :return: The maximum number of non-overlapping projects that can be completed. pass from typing import List, Tuple def test_example_case1(): projects = [(1, 2), (2, 4), (3, 5)] assert max_non_overlapping_projects(3, projects) == 2 def test_example_case2(): projects = [(1, 3), (2, 5), (7, 9), (6, 8)] assert max_non_overlapping_projects(4, projects) == 2 def test_example_case3(): projects = [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)] assert max_non_overlapping_projects(5, projects) == 3 def test_edge_case_one_project(): projects = [(1, 2)] assert max_non_overlapping_projects(1, projects) == 1 def test_case_with_full_overlap(): projects = [(1, 4), (2, 5), (3, 6)] assert max_non_overlapping_projects(3, projects) == 1 def test_case_with_no_overlap(): projects = [(1, 2), (3, 4), (5, 6)] assert max_non_overlapping_projects(3, projects) == 3","solution":"def max_non_overlapping_projects(n, projects): Determines the maximum number of non-overlapping projects. Parameters: n (int): The number of projects. projects (list of tuples): List of projects where each project is a tuple (s, e) with s as start day and e as end day. Returns: int: The maximum number of non-overlapping projects that can be completed. # Sort the projects based on their end time projects.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for s, e in projects: if s >= last_end_time: count += 1 last_end_time = e return count"},{"question":"def max_submatrix_sum(matrix, n, m, X): Consider a matrix of size n x m containing only integers. We need to find the largest rectangular sub-matrix whose sum of elements is closest to a given integer X without exceeding it. Your function should return the sum of the largest rectangular sub-matrix that meets the criteria. Args: matrix (list of list of int): The n x m matrix. n (int): The number of rows in the matrix. m (int): The number of columns in the matrix. X (int): The target sum. Returns: int: The sum of the largest rectangular sub-matrix closest to X without exceeding it. Examples: >>> matrix = [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ] >>> max_submatrix_sum(matrix, 4, 5, 5) 5 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... ] >>> max_submatrix_sum(matrix, 3, 3, 15) 15 >>> matrix = [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9], ... ] >>> max_submatrix_sum(matrix, 3, 3, -1) -1 >>> matrix = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0], ... ] >>> max_submatrix_sum(matrix, 3, 3, 0) 0 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... ] >>> max_submatrix_sum(matrix, 3, 3, 50) 45","solution":"def max_submatrix_sum(matrix, n, m, X): def kadane(arr, max_sum): curr_sum = 0 max_kadane_sum = float('-inf') for val in arr: curr_sum += val if curr_sum > max_sum: curr_sum = val if curr_sum == max_sum: return max_sum max_kadane_sum = max(max_kadane_sum, curr_sum) if curr_sum < 0: curr_sum = 0 return max_kadane_sum max_subsum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += matrix[i][right] max_sum = kadane(temp, X) if max_sum <= X: max_subsum = max(max_subsum, max_sum) if max_subsum == X: return max_subsum return max_subsum"},{"question":"def group_files(file_names): Group file names that share the same set of letters, regardless of their order. Args: file_names (List[str]): List of file names in lowercase. Returns: List[str]: List of groups of file names, each group in alphabetical order, and the groups sorted based on the first file in each group. >>> group_files([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"yxz\\", \\"foo\\"]) [\\"abc bca cab\\", \\"foo\\", \\"xyz yxz\\"] >>> group_files([\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"] >>> group_files([\\"abc\\", \\"cba\\", \\"bac\\", \\"def\\", \\"fed\\", \\"ghi\\"]) [\\"abc bac cba\\", \\"def fed\\", \\"ghi\\"] >>> group_files([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"]) [\\"enlist inlets listen silent\\"] pass","solution":"def group_files(file_names): from collections import defaultdict groups = defaultdict(list) # Grouping files with the same set of characters for file in file_names: sorted_chars = ''.join(sorted(file)) groups[sorted_chars].append(file) # Sorting each group lexicographically for key in groups: groups[key].sort() # Sorting all groups based on the first file name in each group sorted_groups = sorted(groups.values(), key=lambda x: x[0]) # Preparing the result as required format result = [' '.join(group) for group in sorted_groups] return result if __name__ == \\"__main__\\": n = int(input().strip()) file_names = [input().strip() for _ in range(n)] grouped_files = group_files(file_names) for group in grouped_files: print(group)"},{"question":"def reverse_strings(strings): Given a list of strings, return a new list with each string reversed. >>> reverse_strings([\\"hello\\", \\"world\\", \\"programming\\"]) ['olleh', 'dlrow', 'gnimmargorp'] >>> reverse_strings([\\"abc\\", \\"def\\", \\"ghi\\"]) ['cba', 'fed', 'ihg'] >>> reverse_strings([\\"a\\", \\"b\\", \\"c\\"]) ['a', 'b', 'c'] >>> reverse_strings([\\"level\\", \\"radar\\", \\"deified\\"]) ['level', 'radar', 'deified'] >>> reverse_strings([\\"12345\\", \\"67890\\", \\"\\"]) ['54321', '09876', '']","solution":"def reverse_strings(strings): Given a list of strings, return a new list with each string reversed. return [s[::-1] for s in strings]"},{"question":"from typing import List def submatrix_sum(mat: List[List[int]], queries: List[List[int]]) -> List[int]: Returns the sum of all elements in the submatrix defined by its top-left corner at (x1, y1) and bottom-right corner at (x2, y2) for each query in queries. :param mat: 2D matrix of integers :param queries: List of queries where each query is a list of four integers [x1, y1, x2, y2] :return: List of integers representing the sum for each query Example: >>> mat = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [[0,0,1,1], [1,1,2,2], [0,0,2,2]] >>> submatrix_sum(mat, queries) [12, 28, 45] >>> mat = [ ... [1, 2], ... [3, 4] ... ] >>> queries = [[0,0,0,0], [1,1,1,1], [0,1,0,1]] >>> submatrix_sum(mat, queries) [1, 4, 2] >>> mat = [ ... [1, 2], ... [3, 4] ... ] >>> queries = [[0,0,1,1]] >>> submatrix_sum(mat, queries) [10] pass","solution":"def submatrix_sum(mat, queries): Returns the sum of all elements in the submatrix defined by its top-left corner at (x1, y1) and bottom-right corner at (x2, y2) for each query in queries. n = len(mat) m = len(mat[0]) # Precompute the prefix sum matrix prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n): for j in range(m): prefix_sum[i + 1][j + 1] = mat[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] def query_sum(x1, y1, x2, y2): return (prefix_sum[x2 + 1][y2 + 1] - prefix_sum[x1][y2 + 1] - prefix_sum[x2 + 1][y1] + prefix_sum[x1][y1]) # Process each query result = [] for query in queries: x1, y1, x2, y2 = query result.append(query_sum(x1, y1, x2, y2)) return result"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Given a list of integers, return a list of elements that appear more than once. The result is sorted in ascending order. >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([10, 10, 10]) [10]","solution":"def find_duplicates(nums): Given a list of integers, return a list of elements that appear more than once. The result is sorted in ascending order. :param nums: List[int] - List of integers. :return: List[int] - List of integers appearing more than once, sorted in ascending order. from collections import Counter # Count occurrences of elements counts = Counter(nums) # Filter elements that appear more than once and sort the result result = sorted([num for num, count in counts.items() if count > 1]) return result"},{"question":"def decode_message(n: int, message: str) -> str: Decodes a message by shifting each character exactly n positions ahead in the alphabet, wrapping around from 'z' to 'a'. Parameters: n (int): The number of positions to shift each character (1 <= n <= 25). message (str): The encoded message containing only lowercase letters. Returns: str: The decoded message. Examples: >>> decode_message(3, 'abcxyz') == 'defabc' >>> decode_message(5, 'hello') == 'mjqqt' >>> decode_message(1, 'zebra') == 'afcsb' # Your code here","solution":"def decode_message(n, message): Decodes a message by shifting each character exactly n positions ahead in the alphabet, wrapping around from 'z' to 'a'. Parameters: n (int): The number of positions to shift each character (1 <= n <= 25). message (str): The encoded message containing only lowercase letters. Returns: str: The decoded message. decoded_message = '' for char in message: decoded_char = chr((ord(char) - ord('a') + n) % 26 + ord('a')) decoded_message += decoded_char return decoded_message"},{"question":"def min_blocks_to_monotonic(heights): Determine the minimum number of blocks required to make the heights of buildings in a non-decreasing order. Args: heights (list of int): List of integers representing heights of the buildings. Returns: int: Minimum number of blocks needed. Examples: >>> min_blocks_to_monotonic([1, 2, 3, 2, 1]) 3 >>> min_blocks_to_monotonic([4, 1, 3, 2]) 6","solution":"def min_blocks_to_monotonic(heights): Determine the minimum number of blocks required to make the heights of buildings in a non-decreasing order. Args: heights (list of int): List of integers representing heights of the buildings. Returns: int: Minimum number of blocks needed. n = len(heights) blocks_needed = 0 for i in range(1, n): if heights[i] < heights[i - 1]: blocks_needed += heights[i - 1] - heights[i] heights[i] = heights[i - 1] return blocks_needed"},{"question":"def can_complete_course(N: int, K: int, heights: List[int]) -> str: Determines if Tom can complete the course without struggling. Parameters: N (int): Number of obstacles K (int): Tom's jumping capacity heights (list of int): Heights of the obstacles Returns: str: 'Success' if Tom can complete the course, otherwise 'Struggle' >>> can_complete_course(5, 3, [4, 2, 5, 8, 11]) 'Success' >>> can_complete_course(5, 1, [4, 2, 5, 8, 11]) 'Struggle' for i in range(1, N): if abs(heights[i] - heights[i - 1]) > K: return \\"Struggle\\" return \\"Success\\"","solution":"def can_complete_course(N, K, heights): Determines if Tom can complete the course without struggling. Parameters: N (int): Number of obstacles K (int): Tom's jumping capacity heights (list of int): Heights of the obstacles Returns: str: 'Success' if Tom can complete the course, otherwise 'Struggle' for i in range(1, N): if abs(heights[i] - heights[i - 1]) > K: return \\"Struggle\\" return \\"Success\\""},{"question":"def find_path(R: int, C: int, lines: List[str]) -> str: Determines if there is a path from 'S' to 'E' in the given grid. Parameters: R (int): Number of rows. C (int): Number of columns. lines (list of str): The grid represented as a list of strings. Returns: str: \\"YES\\" if a path exists, otherwise \\"NO\\". pass def test_find_path_case_1(): R = 4 C = 4 lines = [ \\"S..#\\", \\".#.#\\", \\".#.E\\", \\"\\" ] assert find_path(R, C, lines) == \\"YES\\" def test_find_path_case_2(): R = 3 C = 3 lines = [ \\"S#.\\", \\"#\\", \\".#E\\" ] assert find_path(R, C, lines) == \\"NO\\" def test_find_path_small_grid_yes(): R = 2 C = 2 lines = [ \\"S.\\", \\".E\\" ] assert find_path(R, C, lines) == \\"YES\\" def test_find_path_small_grid_no(): R = 2 C = 2 lines = [ \\"S#\\", \\"#E\\" ] assert find_path(R, C, lines) == \\"NO\\" def test_find_path_complex_grid_yes(): R = 5 C = 5 lines = [ \\"S....\\", \\".#.\\", \\".#.#.\\", \\".#..E\\", \\"#\\" ] assert find_path(R, C, lines) == \\"YES\\" def test_find_path_complex_grid_no(): R = 5 C = 5 lines = [ \\"S.#.#\\", \\".#.\\", \\".#.#.\\", \\".#.E.\\", \\"#\\" ] assert find_path(R, C, lines) == \\"NO\\"","solution":"from collections import deque def path_exists(grid, R, C): Determines if there is a path from 'S' to 'E' in the given grid. Parameters: grid (list of list of str): The grid representing the map. R (int): Number of rows in the grid. C (int): Number of columns in the grid. Returns: str: \\"YES\\" if a path exists, otherwise \\"NO\\". # Directions for movements: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Find starting point 'S' and ending point 'E' start = end = None for i in range(R): for j in range(C): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'E': end = (i, j) # Initialize a queue for BFS queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() # If we reach the end point, return \\"YES\\" if (x, y) == end: return \\"YES\\" # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny)) # If no path found, return \\"NO\\" return \\"NO\\" def find_path(R, C, lines): Wrapper function to process the lines and call the path_exists. Parameters: R (int): Number of rows. C (int): Number of columns. lines (list of str): The grid represented as a list of strings. Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. grid = [list(line) for line in lines] return path_exists(grid, R, C)"},{"question":"def swap_rooms(n, room_arrangement, guest_a, guest_b): Swaps the rooms of two guests based on their IDs. Args: n : int Number of rooms in the hotel. room_arrangement : list of int List of guest IDs or -1 for each room in the hotel. guest_a : int Guest ID of the first guest. guest_b : int Guest ID of the second guest. Returns: list of int The new arrangement of guests in the rooms after the swap. Examples: >>> swap_rooms(6, [3, -1, 2, 6, 5, 1], 2, 6) [3, -1, 6, 2, 5, 1] >>> swap_rooms(5, [1, 2, 3, 4, 5], 1, 5) [5, 2, 3, 4, 1]","solution":"def swap_rooms(n, room_arrangement, guest_a, guest_b): Swaps the rooms of two guests based on their IDs. Args: n : int Number of rooms in the hotel. room_arrangement : list of int List of guest IDs or -1 for each room in the hotel. guest_a : int Guest ID of the first guest. guest_b : int Guest ID of the second guest. Returns: list of int The new arrangement of guests in the rooms after the swap. # Find the indices of the two guests index_a = room_arrangement.index(guest_a) index_b = room_arrangement.index(guest_b) # Swap the guests in the room arrangement room_arrangement[index_a], room_arrangement[index_b] = room_arrangement[index_b], room_arrangement[index_a] return room_arrangement"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Generates a list of the first n numbers in the Fibonacci sequence. >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_sequence(30) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229]","solution":"def fibonacci_sequence(n): Generates a list of the first n numbers in the Fibonacci sequence. if n == 1: return [0] sequence = [0, 1] for i in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"def valid_subsequence(s1: str, s2: str) -> bool: Write a function valid_subsequence(s1, s2) that takes in two strings s1 and s2, and returns True if s2 is a subsequence of s1, and False otherwise. >>> valid_subsequence(\\"abcdef\\", \\"ace\\") True >>> valid_subsequence(\\"abcdef\\", \\"acf\\") True >>> valid_subsequence(\\"abcdef\\", \\"ef\\") True >>> valid_subsequence(\\"abcdef\\", \\"\\") True >>> valid_subsequence(\\"\\", \\"a\\") False","solution":"def valid_subsequence(s1, s2) -> bool: Returns True if s2 is a subsequence of s1, otherwise False. s2_index = 0 s2_length = len(s2) for char in s1: if s2_index == s2_length: break if char == s2[s2_index]: s2_index += 1 return s2_index == s2_length"},{"question":"def calculate_total(n: int, m: int, k: int, list_a: List[int], list_b: List[int]) -> int: Calculate the total sum of product pairs within a specified index range. >>> calculate_total(4, 4, 3, [2, 4, 6, 8], [1, 3, 5, 7]) 44 >>> calculate_total(2, 2, 5, [1, 2], [3, 4]) 11 >>> calculate_total(5, 5, 2, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 13 >>> calculate_total(4, 4, 0, [1, 2, 3, 4], [5, 6, 7, 8]) 0 >>> calculate_total(1, 1, 1, [5], [5]) 25 >>> calculate_total(3, 3, 2, [-1, 2, -3], [4, -5, 6]) -14 pass","solution":"def calculate_total(n, m, k, list_a, list_b): total = 0 for i in range(min(k, n, m)): total += list_a[i] * list_b[i] return total"},{"question":"def remaining_heights(n: int, heights: List[int], m: int, indices_to_remove: List[int]) -> List[int]: Given the number of plants n, and their respective heights in a list, and the number of plants to be removed m, along with their indices, return the heights of the remaining plants in non-decreasing order. Parameters: n (int): Number of plants initially. heights (list of int): List of initial heights of the plants. m (int): Number of plants to be removed. indices_to_remove (list of int): List of 1-based indices of the plants to be removed. Returns: list of int: Heights of the remaining plants in non-decreasing order. >>> remaining_heights(5, [3, 7, 2, 9, 4], 2, [2, 4]) [2, 3, 4] >>> remaining_heights(3, [10, 5, 8], 1, [1]) [5, 8] >>> remaining_heights(4, [4, 2, 7, 1], 0, []) [1, 2, 4, 7] >>> remaining_heights(3, [5, 10, 3], 3, [1, 2, 3]) [] >>> remaining_heights(6, [1, 6, 3, 9, 2, 5], 3, [1, 4, 6]) [2, 3, 6] >>> remaining_heights(1, [5], 0, []) [5] >>> remaining_heights(1, [5], 1, [1]) []","solution":"def remaining_heights(n, heights, m, indices_to_remove): Given the number of plants n, and their respective heights in a list, and the number of plants to be removed m, along with their indices, return the heights of the remaining plants in non-decreasing order. Parameters: n (int): Number of plants initially. heights (list of int): List of initial heights of the plants. m (int): Number of plants to be removed. indices_to_remove (list of int): List of 1-based indices of the plants to be removed. Returns: list of int: Heights of the remaining plants in non-decreasing order. indices_to_remove_set = set(indices_to_remove) remaining_plants = [heights[i] for i in range(n) if (i + 1) not in indices_to_remove_set] remaining_plants.sort() return remaining_plants"},{"question":"from typing import List def largest_empty_rectangle(N: int, M: int, grid: List[str]) -> int: Find the largest rectangle of empty cells ('.') in a grid of size NxM. >>> largest_empty_rectangle(5, 6, [\\"......\\", \\"....\\", \\".#....\\", \\"....#.\\", \\"....\\"]) 9 >>> largest_empty_rectangle(4, 4, [\\"\\", \\"\\", \\"\\", \\"\\"]) 0 >>> largest_empty_rectangle(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 9 >>> largest_empty_rectangle(3, 4, [\\"..\\", \\"#.#.\\", \\"..\\"]) 2 >>> largest_empty_rectangle(1, 1, [\\".\\"]) 1 >>> largest_empty_rectangle(2, 2, [\\".#\\", \\"#.\\"]) 1","solution":"def max_histogram_area(histogram): Finds the largest rectangular area possible in a given histogram where the width of each bar is 1. stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def largest_rectangle_area(grid, N, M): Returns the area of the largest rectangle of empty cells ('.') in the grid. height = [0] * M max_area = 0 for i in range(N): for j in range(M): if grid[i][j] == '.': height[j] += 1 else: height[j] = 0 max_area = max(max_area, max_histogram_area(height)) return max_area def largest_empty_rectangle(N, M, grid): return largest_rectangle_area(grid, N, M) # Example usage N = 5 M = 6 grid = [ \\"......\\", \\"....\\", \\".#....\\", \\"....#.\\", \\"....\\" ] print(largest_empty_rectangle(N, M, grid)) # Output: 9"},{"question":"def eval_rpn(expression: str) -> int: Evaluates a mathematical expression in Reverse Polish Notation (RPN). :param expression: A string representing a RPN expression :return: The evaluated result as an integer >>> eval_rpn(\\"2 1 + 3 *\\") 9 >>> eval_rpn(\\"4 13 5 / +\\") 6 >>> eval_rpn(\\"10 6 9 3 + -11 * / * 17 + 5 +\\") 22 >>> eval_rpn(\\"42\\") 42 >>> eval_rpn(\\"3 4 +\\") 7 >>> eval_rpn(\\"10 4 -\\") 6 >>> eval_rpn(\\"7 5 *\\") 35 >>> eval_rpn(\\"12 4 /\\") 3 >>> eval_rpn(\\"13 5 /\\") 2 >>> eval_rpn(\\"5 1 2 + 4 * + 3 -\\") 14 >>> eval_rpn(\\"-3 -2 *\\") 6","solution":"def eval_rpn(expression): Evaluates a mathematical expression in Reverse Polish Notation (RPN). :param expression: A string representing a RPN expression :return: The evaluated result as an integer stack = [] tokens = expression.split() for token in tokens: if token in '+-*/': b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': # Use int(a / b) for truncating towards zero stack.append(int(a / b)) else: stack.append(int(token)) return stack[0]"},{"question":"from typing import List, Tuple from collections import Counter import re def word_frequencies(paragraphs: List[str]) -> List[List[Tuple[str, int]]]: Determine the frequency of each distinct word in the string and then sort the words based on their frequencies in descending order. In case of words having the same frequency, sort them lexicographically. A word is defined as a string of alphabetic characters (both uppercase and lowercase) and is case-insensitive. The words should be compared in a case-insensitive manner for the purpose of frequency calculation and ordering. >>> word_frequencies([\\"Hello world! Hello.\\"]) [[('hello', 2), ('world', 1)]] >>> word_frequencies([\\"This is a test. This test is only a test.\\"]) [[('test', 3), ('a', 2), ('is', 2), ('this', 2), ('only', 1)]]","solution":"from collections import Counter import re def word_frequencies(paragraphs): results = [] for paragraph in paragraphs: # Normalize the paragraph to lowercase and extract words words = re.findall(r'b[a-zA-Z]+b', paragraph.lower()) # Count the frequencies of each word word_count = Counter(words) # Sort the words by frequency (descending) and then lexicographically sorted_words = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) results.append(sorted_words) return results"},{"question":"def allUniqueNames(names): Determines if all names in the list are unique. Args: names (list of str): List of names. Returns: bool: True if all names are unique, False otherwise. >>> allUniqueNames([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"]) True >>> allUniqueNames([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Alice\\"]) False >>> allUniqueNames([]) True >>> allUniqueNames([\\"Alice\\"]) True >>> allUniqueNames([str(i) for i in range(10000)]) True >>> allUniqueNames([str(i) for i in range(5000)] + [str(i) for i in range(5000)]) False >>> allUniqueNames([\\"Alice\\", \\"alice\\"]) True >>> allUniqueNames([\\"@lice\\", \\"#Bob!\\", \\"Charlie\\", \\"&David\\"]) True","solution":"def allUniqueNames(names): Determines if all names in the list are unique. Args: names (list of str): List of names. Returns: bool: True if all names are unique, False otherwise. return len(names) == len(set(names))"},{"question":"def is_suitable_problem(problem: str) -> bool: Determines if a given problem string is suitable for practice. A problem string is suitable if characters are unique and in strictly increasing order. >>> is_suitable_problem(\\"abc\\") == True >>> is_suitable_problem(\\"acb\\") == False >>> is_suitable_problem(\\"aaa\\") == False >>> is_suitable_problem(\\"def\\") == True pass def check_problems(t: int, problems: List[str]) -> List[str]: For a given number of test cases and list of problem strings, checks each problem string and returns a list of results. >>> check_problems(4, [\\"abc\\", \\"acb\\", \\"aaa\\", \\"def\\"]) == [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"] >>> check_problems(3, [\\"abcd\\", \\"abca\\", \\"aabb\\"]) == [\\"YES\\", \\"NO\\", \\"NO\\"] >>> check_problems(2, [\\"xy\\", \\"yx\\"]) == [\\"YES\\", \\"NO\\"] >>> check_problems(1, [\\"a\\"]) == [\\"YES\\"] >>> check_problems(2, [\\"abcdefghijkl\\", \\"abcdeff\\"]) == [\\"YES\\", \\"NO\\"] pass","solution":"def is_suitable_problem(problem): Determines if a given problem string is suitable for practice. A problem string is suitable if characters are unique and in strictly increasing order. return list(problem) == sorted(problem) and len(set(problem)) == len(problem) def check_problems(t, problems): For a given number of test cases and list of problem strings, checks each problem string and returns a list of results. result = [] for problem in problems: if is_suitable_problem(problem): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def max_path_sum(grid): Given a grid with R rows and C columns, where each cell contains a non-negative integer, find the maximum sum of the values in the cells along any path from the top-left corner to the bottom-right corner. From each cell, you can only move either to the right or down. Args: grid (list of list of int): The grid consisting of integers. Returns: int: The maximum sum of the values along any valid path. >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 >>> max_path_sum([[5]]) == 5 >>> max_path_sum([[1, 2, 3, 4]]) == 10 >>> max_path_sum([ ... [1], ... [2], ... [3], ... [4] ... ]) == 10 >>> max_path_sum([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> max_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 >>> max_path_sum([]) == 0 >>> max_path_sum([[]]) == 0","solution":"def max_path_sum(grid): Given a grid with R rows and C columns, where each cell contains a non-negative integer, find the maximum sum of the values in the cells along any path from the top-left corner to the bottom-right corner. From each cell, you can only move either to the right or down. Args: grid (list of list of int): The grid consisting of integers. Returns: int: The maximum sum of the values along any valid path. if not grid or not grid[0]: return 0 R = len(grid) C = len(grid[0]) # Create a dp array to store the maximum sum up to each cell dp = [[0] * C for _ in range(R)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, R): for j in range(1, C): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[R-1][C-1] # Example Input R = 3 C = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(max_path_sum(grid)) # Should output 29"},{"question":"def max_subarray_sum_within_range(A, queries): For each query, find the maximum value of s(i,j) such that the range [i,j] satisfies the condition that every element within the range is between l and r inclusive. Args: A: List[int] - The integer array. queries: List[Tuple[int, int, int]] - Each tuple contains (l, r, d). Returns: List[int] - Results for each query. >>> max_subarray_sum_within_range([1, 3, 2, 4, 5], [(2, 4, 3), (1, 5, 2)]) [9, 15] >>> max_subarray_sum_within_range([1, 1, 1, 1, 1], [(1, 1, 2)]) [5] pass","solution":"def max_subarray_sum_within_range(A, queries): results = [] for l, r, d in queries: max_sum = 0 current_sum = 0 for num in A: if l <= num <= r: current_sum += num else: current_sum = 0 max_sum = max(max_sum, current_sum) results.append(max_sum) return results # Reading input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) q = int(data[1]) A = list(map(int, data[2:n+2])) queries = [] for i in range(q): l, r, d = map(int, data[n+2 + 3*i:n+5 + 3*i]) queries.append((l, r, d)) results = max_subarray_sum_within_range(A, queries) for result in results: print(result)"},{"question":"def largest_component_size(N, grid): Given an NxN grid of pixels with color values, find the size of the largest component in the image. A component consists of connected pixels with the same color, connected either vertically or horizontally. :param N: Size of the grid, an integer (2 <= N <= 100) :param grid: NxN list of integers, representing the color values of the pixels (0 <= pixel value <= 255) :return: Size of the largest component in the image, an integer >>> largest_component_size(4, [ ... [1, 2, 3, 4], ... [2, 2, 3, 4], ... [1, 1, 3, 4], ... [1, 1, 0, 0] ...]) 4 >>> largest_component_size(3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ...]) 9 pass from solution import largest_component_size def test_example_case(): grid = [ [1, 2, 3, 4], [2, 2, 3, 4], [1, 1, 3, 4], [1, 1, 0, 0] ] assert largest_component_size(4, grid) == 4 def test_single_color(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert largest_component_size(3, grid) == 9 def test_diagonal_connections(): grid = [ [1, 2, 1], [2, 1, 2], [1, 2, 1] ] assert largest_component_size(3, grid) == 1 def test_individual_colors(): grid = [ [1, 2], [3, 4] ] assert largest_component_size(2, grid) == 1 def test_larger_components(): grid = [ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2] ] assert largest_component_size(4, grid) == 4","solution":"def largest_component_size(N, grid): Returns the size of the largest component in the grid. def bfs(r, c, color): queue = [(r, c)] size = 0 while queue: cr, cc = queue.pop(0) if (cr, cc) not in visited: visited.add((cr, cc)) size += 1 for nr, nc in [(cr-1, cc), (cr+1, cc), (cr, cc-1), (cr, cc+1)]: if 0 <= nr < N and 0 <= nc < N and grid[nr][nc] == color and (nr, nc) not in visited: queue.append((nr, nc)) return size visited = set() max_size = 0 for r in range(N): for c in range(N): if (r, c) not in visited: component_size = bfs(r, c, grid[r][c]) max_size = max(max_size, component_size) return max_size"},{"question":"def missing_number(arr): Returns the smallest positive integer that is missing from the array. >>> missing_number([3, 4, -1, 1]) 2 >>> missing_number([1, 2, 0]) 3 >>> missing_number([-2, -1, -3]) 1 >>> missing_number([7, 8, 9, 11, 12]) 1 >>> missing_number([1, 1, 0, -1, -2]) 2 >>> missing_number([2, 3, 7, 6, 8, -1, -10, 15]) 1 >>> missing_number([1, 2, 3, 4, 5]) 6 >>> missing_number([1, 3, 6, 4, 1, 2]) 5","solution":"def missing_number(arr): Returns the smallest positive integer that is missing from the array. n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"def count_valleys(n: int, heights: List[int]) -> int: Given the number of points and their respective elevations, return the number of valleys encountered during the hike. Parameters: n (int): number of points recorded by the GPS heights (list of int): elevations at each point Returns: int: number of valleys from typing import List def test_single_valley(): assert count_valleys(6, [100, 150, 80, 120, 100, 90]) == 1 def test_multiple_valleys(): assert count_valleys(8, [150, 130, 170, 140, 180, 160, 175, 155]) == 2 def test_no_valleys(): assert count_valleys(5, [100, 200, 300, 400, 500]) == 0 assert count_valleys(3, [100, 80, 100]) == 0 def test_edge_cases(): assert count_valleys(2, [100, 200]) == 0 assert count_valleys(3, [200, 100, 200]) == 0 def test_valleys_with_plateau(): assert count_valleys(6, [100, 150, 80, 80, 120, 90]) == 1 assert count_valleys(9, [150, 130, 170, 140, 170, 160, 175, 150, 155]) == 2","solution":"def count_valleys(n, heights): Given the number of points and their respective elevations, return the number of valleys encountered during the hike. Parameters: n (int): number of points recorded by the GPS heights (list of int): elevations at each point Returns: int: number of valleys if n < 2: return 0 peaks = [] for i in range(1, n - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peaks.append(i) if len(peaks) < 2: return 0 valleys = 0 for i in range(1, len(peaks)): peak1 = peaks[i-1] peak2 = peaks[i] if all(heights[peak1] > heights[k] < heights[peak2] for k in range(peak1 + 1, peak2)): valleys += 1 return valleys"},{"question":"from typing import List def min_moves_to_target(R: int, C: int, grid: List[str], target_x: int, target_y: int) -> int: Determine the minimum number of moves required to reach the target position from the starting position, moving only to adjacent cells (up, down, left, or right) and without moving through obstacles. If it is not possible to reach the target position, return -1. >>> min_moves_to_target(4, 4, [ ... \\"....\\", ... \\".#..\\", ... \\"..#.\\", ... \\"....\\" ... ], 3, 3) 6 >>> min_moves_to_target(4, 4, [ ... \\"....\\", ... \\"\\", ... \\"....\\", ... \\"....\\" ... ], 2, 2) -1 # Unit Test cases def test_min_moves_to_target(): input_1 = (4, 4, [ \\"....\\", \\".#..\\", \\"..#.\\", \\"....\\" ], 3, 3) assert min_moves_to_target(*input_1) == 6 input_2 = (4, 4, [ \\"....\\", \\"\\", \\"....\\", \\"....\\" ], 2, 2) assert min_moves_to_target(*input_2) == -1 input_3 = (3, 3, [ \\".#.\\", \\"...\\", \\".#.\\" ], 2, 2) assert min_moves_to_target(*input_3) == 4 input_4 = (5, 5, [ \\".....\\", \\".#.\\", \\".#.#.\\", \\".#.\\", \\".....\\" ], 4, 4) assert min_moves_to_target(*input_4) == 8 input_5 = (3, 3, [ \\"...\\", \\"...\\", \\"...\\" ], 2, 2) assert min_moves_to_target(*input_5) == 4 def test_min_moves_to_target_unreachable(): input_6 = (3, 3, [ \\"#\\", \\"#.#\\", \\"#\\" ], 1, 1) assert min_moves_to_target(*input_6) == -1 def test_min_moves_to_target_start_is_obstacle(): input_7 = (3, 3, [ \\"#..\\", \\"...\\", \\"...\\" ], 2, 2) assert min_moves_to_target(*input_7) == -1 def test_min_moves_to_target_target_is_obstacle(): input_8 = (3, 3, [ \\"...\\", \\"...\\", \\"..#\\" ], 2, 2) assert min_moves_to_target(*input_8) == -1","solution":"from collections import deque def min_moves_to_target(R, C, grid, target_x, target_y): # Initialize direction vectors for moving up, down, left and right. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Start from the top-left corner. start = (0, 0) # If starting point or target is an obstacle, return -1 immediately. if grid[0][0] == '#' or grid[target_x][target_y] == '#': return -1 # Initialize a queue for BFS and add the starting position with a move count of 0. queue = deque([(start[0], start[1], 0)]) # A set to keep track of visited cells to avoid processing them again. visited = set() visited.add(start) while queue: x, y, moves = queue.popleft() # Check if current cell is the target. if (x, y) == (target_x, target_y): return moves # Explore all possible moves. for dx, dy in directions: nx, ny = x + dx, y + dy # Check if the new position is within grid bounds and not an obstacle. if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) # Return -1 if target cannot be reached. return -1"},{"question":"def can_visit_all_cities(n: int, k: int, portals: List[Tuple[int, int]]) -> str: Determine if it is possible for the subjects to visit all cities starting from city 0 using the portals provided. >>> can_visit_all_cities(4, 1, [(2, 1)]) \\"No\\" >>> can_visit_all_cities(3, 2, [(1, 1), (2, 2)]) \\"Yes\\" >>> can_visit_all_cities(2, 1, [(1, 1)]) \\"Yes\\" >>> can_visit_all_cities(5, 3, [(1, 1), (2, 2), (3, 3)]) \\"Yes\\" >>> can_visit_all_cities(6, 2, [(1, 2), (2, 1)]) \\"Yes\\" >>> can_visit_all_cities(5, 1, [(4, 1)]) \\"No\\"","solution":"def can_visit_all_cities(n, k, portals): def bfs(start, n, portals): visited = [False] * n queue = [start] visited[start] = True while queue: city = queue.pop(0) for a, b in portals: next_city = (city * a + b) % n if not visited[next_city]: visited[next_city] = True queue.append(next_city) return all(visited) return \\"Yes\\" if bfs(0, n, portals) else \\"No\\""},{"question":"def organize_books(books): Sorts the books first by type in alphabetical order ('Novel' before 'Reference'), and then by the number of pages in ascending order. Args: books (list of tuples): A list where each tuple contains (title, type, pages). Returns: list: A sorted list of tuples representing the books. # Example usage: # books = [(\\"Mathematics\\", \\"Reference\\", 500), # (\\"Harry Potter\\", \\"Novel\\", 300), # (\\"Physics\\", \\"Reference\\", 200), # (\\"The Great Gatsby\\", \\"Novel\\", 180)] # # Result: # [('The Great Gatsby', 'Novel', 180), # ('Harry Potter', 'Novel', 300), # ('Physics', 'Reference', 200), # ('Mathematics', 'Reference', 500)]","solution":"def organize_books(books): Sorts the books first by type in alphabetical order ('Novel' before 'Reference'), and then by the number of pages in ascending order. Args: books (list of tuples): A list where each tuple contains (title, type, pages). Returns: list: A sorted list of tuples representing the books. return sorted(books, key=lambda x: (x[1], x[2]))"},{"question":"def can_select_strictly_increasing_bars(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if it is possible to select exactly three bars with strictly increasing heights. Args: t: The number of test cases. test_cases: A list of tuples, where each tuple contains: - The number of bars - A list of integers representing the heights of the bars Returns: A list of strings (\\"YES\\" or \\"NO\\") for each test case. >>> can_select_strictly_increasing_bars(3, [(5, [1, 2, 3, 4, 5]), (4, [5, 4, 3, 2]), (6, [1, 3, 2, 4, 5, 0])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_select_strictly_increasing_bars(2, [(3, [1, 2, 3]), (3, [3, 2, 1])]) [\\"YES\\", \\"NO\\"]","solution":"def can_select_strictly_increasing_bars(t, test_cases): Determines if it is possible to select exactly three bars with strictly increasing heights. Args: t: The number of test cases. test_cases: A list of tuples, where each tuple contains: - The number of bars - A list of integers representing the heights of the bars Returns: A list of strings (\\"YES\\" or \\"NO\\") for each test case. results = [] for n, bars in test_cases: found = False for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if bars[i] < bars[j] < bars[k]: found = True break if found: break if found: break results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def largest_connected_group(m: int, n: int, forest: List[List[int]]) -> int: Given a grid of size m x n representing a forest, find the size of the largest connected group of plants. Args: m: int : number of rows n: int : number of columns forest: List[List[int]] : representation of the forest grid Returns: int : size of the largest connected group of plants Examples: >>> largest_connected_group(3, 4, [ >>> [0, 1, 0, 0], >>> [1, 1, 0, 1], >>> [0, 0, 1, 1] >>> ]) 3 >>> largest_connected_group(4, 5, [ >>> [0, 0, 1, 0, 0], >>> [1, 1, 1, 0, 1], >>> [0, 1, 0, 0, 1], >>> [1, 0, 0, 1, 1] >>> ]) 5","solution":"def largest_connected_group(m, n, forest): Given a grid of size m x n representing a forest, find the size of the largest connected group of plants. Args: m: int : number of rows n: int : number of columns forest: List[List[int]] : representation of the forest grid Returns: int : size of the largest connected group of plants visited = [[False for _ in range(n)] for _ in range(m)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n def dfs(x, y): if not is_valid(x, y) or visited[x][y] or forest[x][y] == 0: return 0 visited[x][y] = True size = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Up, Down, Left, Right size += dfs(x + dx, y + dy) return size largest_group_size = 0 for i in range(m): for j in range(n): if forest[i][j] == 1 and not visited[i][j]: largest_group_size = max(largest_group_size, dfs(i, j)) return largest_group_size"},{"question":"def consolidate_borrowing_log(n: int, entries: List[str]) -> List[str]: Consolidates the borrowing log to list unique activity dates in ascending order for each book. >>> consolidate_borrowing_log(5, [\\"book1 2021-03-15\\", \\"book2 2021-03-15\\", \\"book1 2021-03-16\\", \\"book1 2021-03-15\\", \\"book2 2021-03-14\\"]) [\\"book1 2021-03-15 2021-03-16\\", \\"book2 2021-03-14 2021-03-15\\"] >>> consolidate_borrowing_log(1, [\\"book1 2021-03-15\\"]) [\\"book1 2021-03-15\\"] >>> consolidate_borrowing_log(3, [\\"book1 2021-03-15\\", \\"book1 2021-03-15\\", \\"book1 2021-03-15\\"]) [\\"book1 2021-03-15\\"] >>> consolidate_borrowing_log(6, [\\"book1 2021-03-15\\", \\"book2 2021-03-15\\", \\"book1 2021-03-16\\", \\"book3 2021-03-17\\", \\"book2 2021-03-14\\", \\"book1 2021-03-18\\"]) [\\"book1 2021-03-15 2021-03-16 2021-03-18\\", \\"book2 2021-03-14 2021-03-15\\", \\"book3 2021-03-17\\"] >>> consolidate_borrowing_log(3, [\\"book1 2021-03-15\\", \\"book2 2021-03-15\\", \\"book3 2021-03-15\\"]) [\\"book1 2021-03-15\\", \\"book2 2021-03-15\\", \\"book3 2021-03-15\\"]","solution":"def consolidate_borrowing_log(n, entries): from collections import defaultdict # Dictionary to store the dates for each book_id log = defaultdict(set) for entry in entries: book_id, date = entry.split() log[book_id].add(date) # Prepare the final output in the required format result = [] for book_id in sorted(log.keys()): dates = sorted(log[book_id]) result.append(f\\"{book_id} \\" + \\" \\".join(dates)) return result"},{"question":"def num_of_unique_paths(grid_size: Tuple[int, int], obstacles: List[Tuple[int, int]]) -> int: Given the dimensions of the battlefield and the positions of obstacles, determine the total number of unique paths from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). >>> num_of_unique_paths((3, 3), [(1, 1)]) 2 >>> num_of_unique_paths((3, 3), [(1, 1), (1, 2)]) 1 >>> num_of_unique_paths((3, 3), []) 6 pass","solution":"def num_of_unique_paths(grid_size, obstacles): m, n = grid_size grid = [[0] * n for _ in range(m)] for r, c in obstacles: grid[r][c] = -1 if grid[0][0] == -1 or grid[m-1][n-1] == -1: return 0 grid[0][0] = 1 for r in range(m): for c in range(n): if grid[r][c] == -1: continue if r > 0 and grid[r-1][c] != -1: grid[r][c] += grid[r-1][c] if c > 0 and grid[r][c-1] != -1: grid[r][c] += grid[r][c-1] return grid[m-1][n-1] # Example usage print(num_of_unique_paths((3, 3), [(1, 1)])) # Output: 2 print(num_of_unique_paths((3, 3), [(1, 1), (1, 2)])) # Output: 1 print(num_of_unique_paths((3, 3), [])) # Output: 6"},{"question":"def find_pair_with_sum(arr, k): Determine if there exist two indices i and j such that arr[i] + arr[j] = k and i != j. Parameters: arr (List[int]): the array of integers. k (int): the target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> find_pair_with_sum([4, 3, 5, 7], 8) 'YES' >>> find_pair_with_sum([1, 2, 3, 4], 4) 'YES' >>> find_pair_with_sum([1, 2, 3], 6) 'NO' >>> find_pair_with_sum([1, 4, 3, 2, 5], 10) 'NO' def process_test_cases(test_cases): Process test cases and returns the results for each one. Parameters: test_cases (List[Tuple[int, int, List[int]]]): the list of test cases, each test case includes n (int), k (int), arr (List[int]). Returns: List[str]: the list of results for each test case. >>> process_test_cases([(4, 8, [4, 3, 5, 7]), (4, 4, [1, 2, 3, 4]), (5, 9, [5, 7, 1, 2, 8])]) ['YES', 'YES', 'YES'] >>> process_test_cases([(3, 6, [1, 2, 3]), (5, 10, [1, 4, 3, 5, 2])]) ['NO', 'NO']","solution":"def find_pair_with_sum(arr, k): Determine if there exist two indices i and j such that arr[i] + arr[j] = k and i != j. seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" def process_test_cases(test_cases): Process test cases and returns the results for each one. results = [] for n, k, arr in test_cases: result = find_pair_with_sum(arr, k) results.append(result) return results"},{"question":"def min_subarray_len(n: int, T: int, sequence: List[int]) -> int: Returns the length of the shortest contiguous subarray whose sum is at least T. If no such subarray exists, return -1. >>> min_subarray_len(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2 >>> min_subarray_len(5, 11, [1, 2, 3, 4, 5]) == 3 >>> min_subarray_len(5, 15, [1, 2, 3, 4, 5]) == 5 >>> min_subarray_len(5, 100, [1, 2, 3, 4, 5]) == -1 >>> min_subarray_len(8, 8, [1, 4, 4, 2, 3, 1, 1, 2]) == 2 >>> min_subarray_len(1, 1, [2]) == 1 >>> min_subarray_len(3, 11, [1, 2, 3]) == -1 >>> min_subarray_len(3, 5, [2, 3, 1]) == 2","solution":"def min_subarray_len(n, T, sequence): Returns the length of the shortest contiguous subarray whose sum is at least T. If no such subarray exists, return -1. import sys min_len = sys.maxsize left = 0 current_sum = 0 for right in range(n): current_sum += sequence[right] while current_sum >= T: min_len = min(min_len, right - left + 1) current_sum -= sequence[left] left += 1 return min_len if min_len != sys.maxsize else -1"},{"question":"def calculate_minimum_total_distance(n, m, stores_coordinates, queries): Calculate the minimum total Manhattan distance from the distribution center to all of your stores. Parameters: - n: int, number of stores - m: int, number of queries - stores_coordinates: List of tuples, where each tuple contains two integers representing the coordinates of a store - queries: List of tuples, where each tuple contains two integers representing the coordinates of the distribution center for a query Returns: - List of integers, where each integer is the minimum total Manhattan distance for the corresponding query Example: >>> n = 3 >>> m = 2 >>> stores_coordinates = [(1, 0), (0, 1), (-1, -1)] >>> queries = [(0, 0), (1, 1)] >>> calculate_minimum_total_distance(n, m, stores_coordinates, queries) [4, 6] distances = [] for x, y in queries: total_distance = 0 for si, sj in stores_coordinates: total_distance += abs(si - x) + abs(sj - y) distances.append(total_distance) return distances","solution":"def calculate_minimum_total_distance(n, m, stores_coordinates, queries): distances = [] for x, y in queries: total_distance = 0 for si, sj in stores_coordinates: total_distance += abs(si - x) + abs(sj - y) distances.append(total_distance) return distances"},{"question":"def analyze_tournament(matches): Analyzes the results of a rock-paper-scissors tournament. Args: matches (list): A list of strings representing the match results in the format \\"A:B\\" where A and B can be 'R', 'P', or 'S'. Returns: dict: A dictionary summarizing the number of wins, losses, and draws for the first player, with keys 'wins', 'losses', and 'draws'. Examples: >>> analyze_tournament([\\"R:P\\", \\"S:S\\", \\"P:R\\"]) {'wins': 1, 'losses': 1, 'draws': 1} >>> analyze_tournament([\\"R:S\\", \\"S:P\\", \\"P:R\\"]) {'wins': 3, 'losses': 0, 'draws': 0}","solution":"def analyze_tournament(matches): Analyzes the results of a rock-paper-scissors tournament. Args: matches (list): A list of strings representing the match results in the format \\"A:B\\" where A and B can be 'R', 'P', or 'S'. Returns: dict: A dictionary summarizing the number of wins, losses, and draws for the first player. # Initialize the result dictionary result = {'wins': 0, 'losses': 0, 'draws': 0} # Define the win conditions win_conditions = {'R': 'S', 'S': 'P', 'P': 'R'} # Iterate over each match result for match in matches: player1, player2 = match.split(':') # Determine the result for player1 if player1 == player2: result['draws'] += 1 elif win_conditions[player1] == player2: result['wins'] += 1 else: result['losses'] += 1 return result"},{"question":"from typing import List, Tuple def min_moves_to_repaint(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of moves required to repaint the canvases in a desirable manner where no two adjacent canvases have the same color. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): Each element is a tuple containing: - N (int): Number of canvases. - canvases (List[int]): Colors of the canvases. Returns: List[int]: List containing the minimum number of moves for each test case. pass def process_input_output(input_data: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Process the input data string and returns the number of test cases and the test cases. Args: input_data (str): Input data in string format. Returns: Tuple[int, List[Tuple[int, List[int]]]]: A tuple consisting of - T (int): Number of test cases. - test_cases (List[Tuple[int, List[int]]]): Each element is a tuple containing: - N (int): Number of canvases. - canvases (List[int]): Colors of the canvases. pass def format_output(results: List[int]) -> str: Format the output list into a string. Args: results (List[int]): List of minimum moves for each test case. Returns: str: Formatted string output. pass import pytest def test_case_1(): input_data = \\"2n4n1 1 3 3n5n1 2 2 3 3\\" T, test_cases = process_input_output(input_data) results = min_moves_to_repaint(T, test_cases) assert format_output(results) == \\"2n2\\" def test_input_processing(): input_data = \\"1n4n1 1 3 3\\" T, test_cases = process_input_output(input_data) assert T == 1 assert test_cases == [(4, [1, 1, 3, 3])] def test_format_output(): results = [2, 2] assert format_output(results) == \\"2n2\\" def test_case_custom(): input_data = \\"1n6n1 2 2 3 3 3\\" T, test_cases = process_input_output(input_data) results = min_moves_to_repaint(T, test_cases) assert format_output(results) == \\"2\\" def test_case_all_same(): input_data = \\"1n5n1 1 1 1 1\\" T, test_cases = process_input_output(input_data) results = min_moves_to_repaint(T, test_cases) assert format_output(results) == \\"2\\" def test_case_no_change_needed(): input_data = \\"1n5n1 2 3 4 5\\" T, test_cases = process_input_output(input_data) results = min_moves_to_repaint(T, test_cases) assert format_output(results) == \\"0\\"","solution":"def min_moves_to_repaint(T, test_cases): results = [] for i in range(T): N, canvases = test_cases[i] moves = 0 for j in range(1, N): if canvases[j] == canvases[j - 1]: # choose a new color different from the current and previous one (this can be done arbitrarily) canvases[j] = (canvases[j] % 1000) + 1 if j+1 < N and canvases[j] == canvases[j+1]: canvases[j] = (canvases[j] + 1) % 1000 + 1 moves += 1 results.append(moves) return results def process_input_output(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) canvases = list(map(int, lines[index + 1].split())) test_cases.append((N, canvases)) index += 2 return T, test_cases def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def find_minimum_difference(N, heights): Given a list of N integers representing the heights of towers, find the minimum difference between the heights of any two towers. :param N: Number of towers :param heights: List of tower heights :return: Minimum difference between the heights of any two towers >>> find_minimum_difference(4, [5, 10, 3, 8]) == 2 >>> find_minimum_difference(5, [1, 5, 9, 13, 17]) == 4 >>> find_minimum_difference(6, [6, 10, 3, 1, 8, 5]) == 1 >>> find_minimum_difference(2, [1000000000, 0]) == 1000000000 >>> find_minimum_difference(3, [1, 2, 3]) == 1 >>> find_minimum_difference(4, [5, 5, 5, 5]) == 0","solution":"def find_minimum_difference(N, heights): Given a list of N integers representing the heights of towers, find the minimum difference between the heights of any two towers. :param N: Number of towers :param heights: List of tower heights :return: Minimum difference between the heights of any two towers heights.sort() # Sorts the list of heights in non-decreasing order min_diff = float('inf') # Initialize with a large number for i in range(N - 1): diff = abs(heights[i] - heights[i + 1]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def findDuplicates(arr): Given an array of integers where some elements appear twice and others appear once, find all the elements that appear twice. You must solve the problem in linear time O(N) and use constant space O(1) excluding the space for the input and output arrays. >>> findDuplicates([4,3,2,7,8,2,3,1]) [2,3] >>> findDuplicates([1,1,2]) [1] >>> findDuplicates([1]) []","solution":"def findDuplicates(arr): Returns the elements that appear twice in the array. duplicates = [] for i in range(len(arr)): index = abs(arr[i]) - 1 if arr[index] < 0: duplicates.append(index + 1) else: arr[index] = -arr[index] return duplicates"},{"question":"def longest_symmetrical_subarray(N: int, H: List[int]) -> int: Determine the length of the longest contiguous subarray of book heights that is symmetrical. Args: N : int : The number of books on the shelf. H : List[int] : The heights of the books. Returns: int : The length of the longest symmetrical subarray of book heights. >>> longest_symmetrical_subarray(7, [2, 3, 7, 7, 3, 2, 1]) 6 >>> longest_symmetrical_subarray(5, [1, 2, 3, 4, 5]) 1 def test_longest_symmetrical_subarray_example_1(): assert longest_symmetrical_subarray(7, [2, 3, 7, 7, 3, 2, 1]) == 6 def test_longest_symmetrical_subarray_example_2(): assert longest_symmetrical_subarray(5, [1, 2, 3, 4, 5]) == 1 def test_longest_symmetrical_subarray_all_equal(): assert longest_symmetrical_subarray(5, [1, 1, 1, 1, 1]) == 5 def test_longest_symmetrical_subarray_no_repeats(): assert longest_symmetrical_subarray(3, [1, 2, 3]) == 1 def test_longest_symmetrical_subarray_single_book(): assert longest_symmetrical_subarray(1, [42]) == 1 def test_longest_symmetrical_subarray_two_books_same_height(): assert longest_symmetrical_subarray(2, [4, 4]) == 2 def test_longest_symmetrical_subarray_two_books_different_height(): assert longest_symmetrical_subarray(2, [4, 5]) == 1","solution":"def longest_symmetrical_subarray(N, H): def is_symmetric(subarray): return subarray == subarray[::-1] max_len = 1 # At least each individual book is a symmetrical subarray of length 1 for start in range(N): for end in range(start + 1, N + 1): if is_symmetric(H[start:end]): max_len = max(max_len, end - start) return max_len # Helper function to convert input, this won't be part of the actual solution def main(input_str): input_lines = input_str.strip().split(\\"n\\") N = int(input_lines[0]) H = list(map(int, input_lines[1].split())) return longest_symmetrical_subarray(N, H)"},{"question":"def medians(arr, k): Implement a function that takes a list of integers and returns a new list containing the median of every contiguous subarray of length \`k\`. A median is the middle number in a sorted, odd-length list, or the average of the two middle numbers in an even-length list. >>> medians([1, 3, 4, 2, 5], k=3) [3, 3, 4] >>> medians([7, 2, 1, 6, 5], k=2) [4.5, 1.5, 3.5, 5.5]","solution":"def find_median(arr): n = len(arr) arr.sort() if n % 2 == 0: return (arr[n//2 - 1] + arr[n//2]) / 2 else: return arr[n//2] def medians(arr, k): Returns a list of medians for every contiguous subarray of length \`k\`. if k == 1: return arr # each element is a median of its subarray of length 1 result = [] for i in range(len(arr) - k + 1): subarray = arr[i:i + k] median = find_median(subarray) result.append(median) return result"},{"question":"def minimized_sum(N: int, M: int, array: List[int]) -> int: Minimize the sum of the remaining N-M elements of the array after removing M elements. Parameters: N (int): Number of elements in the array M (int): Number of elements to remove array (list of int): List of positive integers Returns: int: Minimized sum of the remaining elements >>> minimized_sum(5, 2, [3, 7, 2, 5, 8]) 10 >>> minimized_sum(6, 3, [10, 5, 7, 3, 9, 6]) 14 >>> minimized_sum(1, 1, [10]) 0 >>> minimized_sum(4, 2, [5, 5, 5, 5]) 10 >>> minimized_sum(3, 0, [4, 5, 6]) 15 >>> minimized_sum(5, 4, [1, 2, 3, 4, 5]) 1","solution":"def minimized_sum(N, M, array): Minimize the sum of the remaining N-M elements of the array after removing M elements. Parameters: N (int): Number of elements in the array M (int): Number of elements to remove array (list of int): List of positive integers Returns: int: Minimized sum of the remaining elements # Sort the array array.sort() # Sum the first N-M elements minimized_sum = sum(array[:N-M]) return minimized_sum # Example Usage: # minimized_sum(5, 2, [3, 7, 2, 5, 8]) # Output: 10"},{"question":"def fix_consecutive_spaces(s: str) -> str: Restores the original sentence by inserting exactly one space between every pair of consecutive words, reducing multiple spaces between words, and removing any leading or trailing spaces. Parameters: s (str): The input string containing words separated by spaces and possibly multiple consecutive spaces. Returns: str: A string with exactly one space between every pair of consecutive words, and no leading or trailing spaces. >>> fix_consecutive_spaces(\\"hello world\\") \\"hello world\\" >>> fix_consecutive_spaces(\\" this is a test \\") \\"this is a test\\" >>> fix_consecutive_spaces(\\"singleword\\") \\"singleword\\" from solution import fix_consecutive_spaces def test_single_spaces_between_words(): assert fix_consecutive_spaces(\\"hello world\\") == \\"hello world\\" def test_multiple_spaces_between_words(): assert fix_consecutive_spaces(\\"hello world\\") == \\"hello world\\" def test_leading_and_trailing_spaces(): assert fix_consecutive_spaces(\\" hello world \\") == \\"hello world\\" def test_single_word(): assert fix_consecutive_spaces(\\"singleword\\") == \\"singleword\\" def test_multiple_spaces_everywhere(): assert fix_consecutive_spaces(\\" this is a test \\") == \\"this is a test\\" def test_all_multiple_spaces(): assert fix_consecutive_spaces(\\" \\") == \\"\\"","solution":"def fix_consecutive_spaces(s: str) -> str: Restores the original sentence by inserting exactly one space between every pair of consecutive words, reducing multiple spaces between words, and removing any leading or trailing spaces. Parameters: s (str): The input string containing words separated by spaces and possibly multiple consecutive spaces. Returns: str: A string with exactly one space between every pair of consecutive words, and no leading or trailing spaces. # Strip leading and trailing spaces and split the string into words based on spaces words = s.strip().split() # Join the words with a single space and return the result return ' '.join(words)"},{"question":"def find_words_with_prefix(words, prefix): Returns all words from the list \`words\` that start with the given \`prefix\`. >>> find_words_with_prefix([\\"apple\\", \\"apricot\\", \\"banana\\", \\"apartment\\"], \\"ap\\") [\\"apple\\", \\"apricot\\", \\"apartment\\"] >>> find_words_with_prefix([\\"car\\", \\"carbon\\", \\"cat\\", \\"dog\\"], \\"ca\\") [\\"car\\", \\"carbon\\", \\"cat\\"]","solution":"def find_words_with_prefix(words, prefix): Returns all words from the list \`words\` that start with the given \`prefix\`. return [word for word in words if word.startswith(prefix)]"},{"question":"def longest_subsequence(n: int, card_sequence: str) -> int: Determine the length of the longest subsequence of cards Jean can create such that each card appears at least once in every pattern occurrence within the original sequence. >>> longest_subsequence(8, \\"ABACABDA\\") 4 >>> longest_subsequence(10, \\"AAABBBCCDD\\") 4 from collections import Counter def test_example_1(): assert longest_subsequence(8, \\"ABACABDA\\") == 4 def test_example_2(): assert longest_subsequence(10, \\"AAABBBCCDD\\") == 4 def test_single_character(): assert longest_subsequence(1, \\"A\\") == 1 def test_all_unique_characters(): assert longest_subsequence(5, \\"ABCDE\\") == 5 def test_repeated_characters(): assert longest_subsequence(5, \\"AAAAA\\") == 1 def test_mixed_characters(): assert longest_subsequence(7, \\"AABACDA\\") == 4","solution":"def longest_subsequence(n, card_sequence): from collections import Counter # Find the frequency of each card in the sequence card_count = Counter(card_sequence) # The longest subsequence containing unique characters will be limited by # the minimum frequency among the characters in the sequence return len(card_count)"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if the list can be partitioned into two subsets with equal sum. :param nums: List[int], list of integers :return: bool, True if partition is possible, False otherwise >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determine if the list can be partitioned into two subsets with equal sum. :param nums: List[int], list of integers :return: bool, True if partition is possible, False otherwise total_sum = sum(nums) # If total_sum is odd, it's not possible to partition if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a dp array where dp[j] means whether a subset sum j can be formed dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def max_sum_of_k_consecutive_elements(arr, k): Returns the maximum sum of k consecutive elements in the array. If there are less than k elements in the array, return 0. >>> max_sum_of_k_consecutive_elements([1, 2, 3, 4, 5], 2) 9 >>> max_sum_of_k_consecutive_elements([1, 2, 3], 4) 0 >>> max_sum_of_k_consecutive_elements([4], 1) 4 >>> max_sum_of_k_consecutive_elements([1, 2, 3, 4], 4) 10 >>> max_sum_of_k_consecutive_elements([1, -2, 3, -4, 5, -6], 2) 1 >>> max_sum_of_k_consecutive_elements([1, -2, 3, -4, 5, -6], 3) 4 >>> max_sum_of_k_consecutive_elements([], 2) 0 >>> max_sum_of_k_consecutive_elements([1, 2, 3, 4], 5) 0","solution":"def max_sum_of_k_consecutive_elements(arr, k): Returns the maximum sum of k consecutive elements in the array. If there are less than k elements in the array, return 0. if len(arr) < k: return 0 max_sum = sum(arr[:k]) current_sum = max_sum for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def process_actions(initial_books: List[str], actions: List[Tuple[str, str]]) -> Dict[str, List[str]]: Process a series of book borrowing and returning actions. Args: initial_books (List[str]): List of initial available books in the library. actions (List[Tuple[str, str]]): List of tuples where each tuple contains an action (\\"borrow\\" or \\"return\\") and an ISBN number (str). Returns: Dict[str, List[str]]: Dictionary showing the current state of the library's inventory with keys \\"on_loan\\" and \\"available\\". Example: >>> initial_books = [\\"1234567890\\", \\"0987654321\\", \\"1122334455\\"] >>> actions = [ ... (\\"borrow\\", \\"1234567890\\"), ... (\\"borrow\\", \\"0987654321\\"), ... (\\"return\\", \\"1234567890\\"), ... (\\"borrow\\", \\"1122334455\\"), ... (\\"return\\", \\"0987654321\\"), ... (\\"borrow\\", \\"1234567890\\"), ... (\\"return\\", \\"0000000000\\") ... ] >>> process_actions(initial_books, actions) {\\"on_loan\\": [\\"1122334455\\", \\"1234567890\\"], \\"available\\": [\\"0987654321\\"]}","solution":"def process_actions(initial_books, actions): library = { \\"on_loan\\": [], \\"available\\": initial_books.copy() } for action, isbn in actions: if action == \\"borrow\\": if isbn in library[\\"available\\"]: library[\\"available\\"].remove(isbn) library[\\"on_loan\\"].append(isbn) elif action == \\"return\\": if isbn in library[\\"on_loan\\"]: library[\\"on_loan\\"].remove(isbn) library[\\"available\\"].append(isbn) return library"},{"question":"def minimum_emergency_doors(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determines the minimum number of emergency doors required given the number of rooms and corridors connecting them. Parameters: n (int): The number of rooms. m (int): The number of corridors. connections (list of tuples): The corridors connecting the rooms. Returns: int: The minimum number of emergency doors required. >>> minimum_emergency_doors(6, 5, [(1, 2), (2, 3), (3, 4), (5, 6), (1, 6)]) 1 >>> minimum_emergency_doors(5, 0, []) 5 >>> minimum_emergency_doors(3, 2, [(1, 2), (2, 3)]) 1","solution":"def minimum_emergency_doors(n, m, connections): Determines the minimum number of emergency doors required given the number of rooms and corridors connecting them. Parameters: n (int): The number of rooms. m (int): The number of corridors. connections (list of tuples): The corridors connecting the rooms. Returns: int: The minimum number of emergency doors required. def dfs(room, visited, graph): stack = [room] while stack: node = stack.pop() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) # Create the graph graph = [[] for _ in range(n + 1)] for u, v in connections: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) count = 0 # Find connected components using DFS for i in range(1, n + 1): if not visited[i]: dfs(i, visited, graph) count += 1 return count"},{"question":"from typing import List def min_initial_energy(grid: List[List[int]], n: int, m: int) -> int: Determine the minimum amount of initial energy E so that you can reach the bottom-right corner of the grid without your energy dropping below zero at any point of your journey. >>> min_initial_energy([ ... [0, 0, 0], ... [-1, 1, -1], ... [0, 0, 0] ... ], 3, 3) == 1 True >>> min_initial_energy([ ... [0, -1, 0, 1], ... [0, 0, -1, 0], ... [1, 0, -1, 0] ... ], 3, 4) == 1 True >>> min_initial_energy([ ... [-1, 0, 0], ... [0, -1, 1], ... [0, 1, -1] ... ], 3, 3) == 2 True >>> min_initial_energy([ ... [0, -1, -1], ... [1, 0, 0], ... [1, -1, 0] ... ], 3, 3) == 1 True >>> min_initial_energy([ ... [1, 1], ... [1, 1] ... ], 2, 2) == 1 True pass","solution":"def min_initial_energy(grid, n, m): E = float('inf') dp = [[float('inf')] * m for _ in range(n)] dp[0][0] = max(1, 1 - grid[0][0]) for i in range(n): for j in range(m): if i > 0: dp[i][j] = min(dp[i][j], max(dp[i-1][j] - grid[i][j], 1)) if j > 0: dp[i][j] = min(dp[i][j], max(dp[i][j-1] - grid[i][j], 1)) return dp[-1][-1] # Parse input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [] index = 3 for i in range(n): row = list(map(int, data[index:index + m])) grid.append(row) index += m print(min_initial_energy(grid, n, m))"},{"question":"def sort_array_segments(n, m, array, segments): Sorts specified segments of the array in ascending order. Parameters: n (int): Size of the array. m (int): Number of segments to be sorted. array (list of int): The input array. segments (list of tuple): List of segments represented as (l, r) pairs. Returns: list of int: The array after sorting the specified segments. pass def process_datasets(datasets): Processes multiple datasets for sorting array segments. Parameters: datasets (list): A list of datasets, where each dataset is represented as a tuple containing the size of the array \`n\`, the number of segments \`m\`, the array, and the list of segments. Returns: list: A list of resulting arrays after sorting the specified segments. pass import pytest def test_sort_array_segments(): assert sort_array_segments(5, 2, [10, 9, 8, 7, 6], [(0, 1), (3, 4)]) == [9, 10, 8, 6, 7] assert sort_array_segments(2, 1, [100, 120], [(0, 1)]) == [100, 120] assert sort_array_segments(5, 1, [9, 1, 8, 3, 7], [(1, 3)]) == [9, 1, 3, 8, 7] assert sort_array_segments(4, 1, [4, 3, 2, 1], [(0, 3)]) == [1, 2, 3, 4] def test_process_datasets(): datasets = [ (5, 2, [10, 9, 8, 7, 6], [(0, 1), (3, 4)]), (2, 1, [100, 120], [(0, 1)]), (3, 1, [3, 2, 1], [(0, 2)]), ] expected_output = [ [9, 10, 8, 6, 7], [100, 120], [1, 2, 3], ] assert process_datasets(datasets) == expected_output","solution":"def sort_array_segments(n, m, array, segments): Sorts specified segments of the array in ascending order. Parameters: n (int): Size of the array. m (int): Number of segments to be sorted. array (list of int): The input array. segments (list of tuple): List of segments represented as (l, r) pairs. Returns: list of int: The array after sorting the specified segments. for l, r in segments: array[l:r+1] = sorted(array[l:r+1]) return array def process_datasets(datasets): Processes multiple datasets for sorting array segments. Parameters: datasets (list): A list of datasets, where each dataset is represented as a tuple containing the size of the array \`n\`, the number of segments \`m\`, the array, and the list of segments. Returns: list: A list of resulting arrays after sorting the specified segments. results = [] for n, m, array, segments in datasets: res = sort_array_segments(n, m, array, segments) results.append(res) return results"},{"question":"def minimum_moves(T, test_cases): Calculate the minimum number of moves required for the robot to reach the last lane. Args: T (int): The number of test cases. test_cases (List): A list where each pair of elements represents the number of lanes and a list of obstacles in each lane respectively. Returns: List: A list of integers representing the minimum number of moves required for each test case. If it's not possible to reach the last lane, -1 is returned for that test case. >>> minimum_moves(3, [5, [2, 2, 1, 1, 0], 3, [1, 2, 3], 4, [5, 4, 3, 2]]) [4, -1, 3] >>> minimum_moves(1, [4, [1, 0, 0, 0]]) [3]","solution":"def minimum_moves(T, test_cases): results = [] for i in range(T): N = test_cases[i*2] obstacles = test_cases[i*2 + 1] moves = 0 current_obstacles = obstacles[0] for j in range(1, N): if obstacles[j] > current_obstacles: results.append(-1) break else: moves += 1 current_obstacles = obstacles[j] else: results.append(moves) return results"},{"question":"def are_anagrams(s1, s2): Returns 'YES' if s1 and s2 are anagrams of each other, otherwise 'NO'. >>> are_anagrams('listen', 'silent') 'YES' >>> are_anagrams('apple', 'papel') 'YES' >>> are_anagrams('car', 'rat') 'NO' def check_anagrams(test_cases): Returns a list of results for each pair of strings in test_cases indicating if they are anagrams. >>> check_anagrams([('listen', 'silent'), ('apple', 'papel')]) ['YES', 'YES'] >>> check_anagrams([('abc', 'def'), ('hello', 'bello')]) ['NO', 'NO'] >>> check_anagrams([('cinema', 'iceman'), ('dusty', 'study')]) ['YES', 'YES'] >>> check_anagrams([('night', 'thing'), ('a', 'a'), ('abcd', 'dcba')]) ['YES', 'YES', 'YES'] >>> check_anagrams([('rat', 'car')]) ['NO']","solution":"def are_anagrams(s1, s2): Returns 'YES' if s1 and s2 are anagrams of each other, otherwise 'NO'. if sorted(s1) == sorted(s2): return \\"YES\\" else: return \\"NO\\" def check_anagrams(test_cases): Returns a list of results for each pair of strings in test_cases indicating if they are anagrams. results = [] for s1, s2 in test_cases: results.append(are_anagrams(s1, s2)) return results"},{"question":"from typing import List, Tuple, Union def generate_fibonacci(n: int) -> List[int]: Generate the first N Fibonacci numbers. >>> generate_fibonacci(1) [0] >>> generate_fibonacci(5) [0, 1, 1, 2, 3] def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False def fibonacci_primes(n: int) -> Tuple[List[int], Union[List[int], str]]: Generate the first N Fibonacci numbers and find which of them are prime. >>> fibonacci_primes(5) ([0, 1, 1, 2, 3], [2, 3]) >>> fibonacci_primes(1) ([0], \\"No prime numbers\\") def format_output(n: int) -> Tuple[List[int], Union[List[int], str]]: Format the output for the first N Fibonacci numbers and their prime numbers. >>> format_output(5) ([0, 1, 1, 2, 3], [2, 3]) >>> format_output(2) ([0, 1], \\"No prime numbers\\")","solution":"def generate_fibonacci(n): Generate the first N Fibonacci numbers. if n == 1: return [0] fib_nums = [0, 1] while len(fib_nums) < n: fib_nums.append(fib_nums[-1] + fib_nums[-2]) return fib_nums def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def fibonacci_primes(n): Generate the first N Fibonacci numbers and find which of them are prime. fib_nums = generate_fibonacci(n) prime_fib_nums = [num for num in fib_nums if is_prime(num)] return fib_nums, prime_fib_nums if prime_fib_nums else \\"No prime numbers\\" def format_output(n): fib_nums, prime_fib_nums = fibonacci_primes(n) return fib_nums, prime_fib_nums"},{"question":"def is_valid_triangle(a, b, c): Determines if the sides a, b, and c can form a valid non-degenerate triangle. Args: a (int): length of the first side b (int): length of the second side c (int): length of the third side Returns: str: \\"YES\\" if it forms a valid non-degenerate triangle, otherwise \\"NO\\" from solution import is_valid_triangle def test_valid_triangle(): assert is_valid_triangle(3, 4, 5) == \\"YES\\" assert is_valid_triangle(7, 10, 5) == \\"YES\\" assert is_valid_triangle(5, 5, 5) == \\"YES\\" def test_invalid_triangle(): assert is_valid_triangle(1, 1, 2) == \\"NO\\" assert is_valid_triangle(1, 2, 3) == \\"NO\\" assert is_valid_triangle(0, 1, 1) == \\"NO\\" def test_large_numbers(): assert is_valid_triangle(1000000000, 1000000000, 1000000000) == \\"YES\\" assert is_valid_triangle(1000000000, 1000000000, 2000000001) == \\"NO\\"","solution":"def is_valid_triangle(a, b, c): Determines if the sides a, b, and c can form a valid non-degenerate triangle. Args: a (int): length of the first side b (int): length of the second side c (int): length of the third side Returns: str: \\"YES\\" if it forms a valid non-degenerate triangle, otherwise \\"NO\\" if a + b > c and a + c > b and b + c > a: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def process_queries(n: int, t_max: int, queries: List[Tuple[int, ...]]) -> List[int]: Processes a list of queries for an event monitoring system, supporting adding events and querying the event count within a specified time range for user sessions. Parameters: n (int): Number of queries. t_max (int): Maximum possible timestamp. queries (List[Tuple[int, ...]]): List of queries. Each query is represented as a tuple: - (1, u, t): Add a new event for user session \`u\` at timestamp \`t\`. - (2, u, t1, t2): Return the number of events for user session \`u\` that occurred between timestamps \`t1\` and \`t2\`, inclusive. Returns: List[int]: The results of the queries of the second type. Examples: >>> process_queries(10, 100, [(1, 1, 10), (1, 1, 20), (1, 2, 15), (2, 1, 5, 25), (1, 1, 30), (2, 1, 10, 30), (2, 2, 10, 20), (1, 2, 25), (2, 2, 10, 30), (2, 1, 5, 35)]) [2, 2, 1, 2, 3] pass import pytest def test_single_user_single_event(): queries = [ (1, 1, 5), (2, 1, 0, 10) ] assert process_queries(2, 10, queries) == [1] def test_single_user_multiple_events(): queries = [ (1, 1, 5), (1, 1, 15), (2, 1, 0, 10), (2, 1, 0, 20) ] assert process_queries(4, 20, queries) == [1, 2] def test_multiple_users(): queries = [ (1, 1, 5), (1, 2, 10), (1, 1, 15), (2, 2, 5, 15), (2, 1, 0, 20) ] assert process_queries(5, 20, queries) == [1, 2] def test_no_events_in_time_range(): queries = [ (1, 1, 5), (1, 1, 15), (2, 1, 10, 10) ] assert process_queries(3, 20, queries) == [0] def test_event_on_time_boundary(): queries = [ (1, 1, 5), (1, 1, 10), (1, 1, 15), (2, 1, 10, 15) ] assert process_queries(4, 20, queries) == [2] if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import defaultdict import bisect class EventMonitoringSystem: def __init__(self): self.events = defaultdict(list) def add_event(self, user, timestamp): # Add the event timestamp to the user's event list, maintaining sorted order bisect.insort(self.events[user], timestamp) def query_event_count(self, user, start_time, end_time): # Retrieve the list of events for the user timestamps = self.events[user] # Find the insertion points for start_time and end_time left = bisect.bisect_left(timestamps, start_time) right = bisect.bisect_right(timestamps, end_time) # The count of events between the two indices is the result return right - left def process_queries(n, t_max, queries): system = EventMonitoringSystem() results = [] for query in queries: if query[0] == 1: _, u, t = query system.add_event(u, t) elif query[0] == 2: _, u, t1, t2 = query results.append(system.query_event_count(u, t1, t2)) return results # Example usage: # queries = [ # (1, 1, 10), # (1, 1, 20), # (1, 2, 15), # (2, 1, 5, 25), # (1, 1, 30), # (2, 1, 10, 30), # (2, 2, 10, 20), # (1, 2, 25), # (2, 2, 10, 30), # (2, 1, 5, 35) # ] # print(process_queries(10, 100, queries)) # [2, 2, 1, 2, 3]"},{"question":"def index_of_largest_element(nums): Returns the index of the largest element in the list. If there are multiple elements with the same value, returns the one with the smallest index. >>> index_of_largest_element([1]) == 0 >>> index_of_largest_element([1, 3, 7, 7, 5]) == 2 >>> index_of_largest_element([4, 4, 4, 4]) == 0 >>> index_of_largest_element([9, 3, 7, 6, 9]) == 0 >>> index_of_largest_element([1, 2, 3, 4, 5]) == 4 >>> index_of_largest_element([9, 2, 3, 4, 1]) == 0 >>> index_of_largest_element([-1, -2, -3, -4]) == 0 >>> index_of_largest_element([-1, 3, -5, 7, 3]) == 3 >>> index_of_largest_element([1, 2, 3, 3, 3]) == 2 pass","solution":"def index_of_largest_element(nums): Returns the index of the largest element in the list. If there are multiple elements with the same value, returns the one with the smallest index. if not nums: raise ValueError(\\"The list must contain at least one element\\") max_value = nums[0] max_index = 0 for i in range(1, len(nums)): if nums[i] > max_value: max_value = nums[i] max_index = i return max_index"},{"question":"def max_trees(n, m, k): Calculate the maximum number of trees that can be planted in the garden. Parameters: n (int): The length of the garden. m (int): The width of the garden. k (int): The minimum required spacing between trees and from trees to the garden boundary. Returns: int: The maximum number of trees that can be planted. Examples: >>> max_trees(10, 10, 2) 25 >>> max_trees(15, 10, 3) 15","solution":"def max_trees(n, m, k): Calculate the maximum number of trees that can be planted in the garden. Parameters: n (int): The length of the garden. m (int): The width of the garden. k (int): The minimum required spacing between trees and from trees to the garden boundary. Returns: int: The maximum number of trees that can be planted. trees_in_row = n // k trees_in_column = m // k return trees_in_row * trees_in_column"},{"question":"def maximize_sum_sort(arr: List[int], K: int) -> List[int]: Sort the array in such a way that the sum of the first K elements is maximized. If multiple arrays produce the same sum for the first K elements, select the lexicographically smallest array among them. >>> maximize_sum_sort([5, 3, 9, 1, 7], 3) [9, 7, 5, 1, 3] >>> maximize_sum_sort([2, 2, 2, 2], 2) [2, 2, 2, 2] >>> maximize_sum_sort([1, 100, 1000, 10, 10000, 100000], 5) [100000, 10000, 1000, 100, 10, 1] >>> maximize_sum_sort([5, 3, 2, 8, 6], 2) [8, 6, 2, 3, 5] >>> maximize_sum_sort([9, 8, 7, 6, 5], 5) [9, 8, 7, 6, 5]","solution":"def maximize_sum_sort(arr, K): Sort the array in such a way that the sum of the first K elements is maximized. If multiple arrays produce the same sum for the first K elements, select the lexicographically smallest array among them. Parameters: arr (List[int]): The array of integers. K (int): The number of elements to maximize the sum. Returns: List[int]: The sorted array. # Sort the array based on values, but for same values, consider their index to decide the order lexicographically sorted_arr = sorted(arr, key=lambda x: (-x, arr.index(x))) return sorted_arr[:K] + sorted(sorted_arr[K:])"},{"question":"def find_overlapping_tasks(n: int, tasks: List[Tuple[int, int]]) -> Union[str, List[Tuple[int, int]]]: Given a list of tasks with start and end times, find all pairs of overlapping tasks. :param n: Number of tasks (int) :param tasks: List of tuples where each tuple contains start and end times of a task (list of tuples) :return: List of tuples where each tuple contains a pair of indices representing overlapping tasks >>> find_overlapping_tasks(5, [(1, 4), (2, 5), (6, 8), (7, 9), (10, 12)]) [(1, 2), (3, 4)] >>> find_overlapping_tasks(3, [(1, 2), (3, 4), (5, 6)]) \\"No Overlapping Tasks\\"","solution":"def find_overlapping_tasks(n, tasks): Given a list of tasks with start and end times, find all pairs of overlapping tasks. :param n: Number of tasks (int) :param tasks: List of tuples where each tuple contains start and end times of a task (list of tuples) :return: List of tuples where each tuple contains a pair of indices representing overlapping tasks overlapping_pairs = [] for i in range(n): for j in range(i + 1, n): start_i, end_i = tasks[i] start_j, end_j = tasks[j] # Check for overlap if start_i < end_j and start_j < end_i: overlapping_pairs.append((i + 1, j + 1)) # Adding 1 to make it 1-based indices if not overlapping_pairs: return \\"No Overlapping Tasks\\" return overlapping_pairs"},{"question":"def look_and_say(n: int) -> str: Given an integer n, generate the n-th term of the look-and-say sequence. The sequence is defined as follows: 1. The first term is \\"1\\". 2. To generate subsequent terms, read the previous term and count the frequency of each digit in it, then state that frequency digit by digit. Example: >>> look_and_say(1) '1' >>> look_and_say(5) '111221' >>> look_and_say(7) '13112221'","solution":"def look_and_say(n): Returns the n-th term of the look-and-say sequence. if n == 1: return \\"1\\" current_term = \\"1\\" for _ in range(1, n): next_term = \\"\\" i = 0 while i < len(current_term): count = 1 while i + 1 < len(current_term) and current_term[i] == current_term[i + 1]: count += 1 i += 1 next_term += str(count) + current_term[i] i += 1 current_term = next_term return current_term"},{"question":"def min_changes_to_palindrome(s): Returns the minimum number of characters that need to be changed to make the string a palindrome. >>> min_changes_to_palindrome(\\"ab\\") == 1 >>> min_changes_to_palindrome(\\"abb\\") == 1 >>> min_changes_to_palindrome(\\"abba\\") == 0 >>> min_changes_to_palindrome(\\"abc\\") == 1 >>> min_changes_to_palindrome(\\"abcd\\") == 2 def process_test_cases(t, test_cases): Given the number of test cases and a list of strings, returns a list with the minimum number of changes needed to make each string a palindrome. >>> process_test_cases(3, [\\"ab\\", \\"abb\\", \\"abba\\"]) == [1, 1, 0] >>> process_test_cases(2, [\\"abc\\", \\"abcd\\"]) == [1, 2] >>> process_test_cases(1, [\\"a\\"]) == [0] >>> process_test_cases(1, [\\"abcca\\"]) == [1] >>> process_test_cases(0, []) == []","solution":"def min_changes_to_palindrome(s): Returns the minimum number of characters that need to be changed to make the string a palindrome. count = 0 n = len(s) for i in range(n // 2): if s[i] != s[n - i - 1]: count += 1 return count def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_changes_to_palindrome(s)) return results"},{"question":"def compress_string(s: str) -> str: Perform basic string compression using the counts of repeated characters. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcd\\") \\"abcd\\" >>> compress_string(\\"aaAAaa\\") \\"aaAAaa\\" >>> compress_string(\\"aabbcc\\") \\"aabbcc\\" >>> compress_string(\\"\\") \\"\\" >>> compress_string(\\"a\\") \\"a\\" >>> compress_string(\\"aab\\") \\"aab\\" >>> compress_string(\\"aabbbcccccd\\") \\"a2b3c5d1\\"","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def find_subarray_sum(arr, k): This function finds the total number of continuous subarrays whose sum equals to k. >>> find_subarray_sum([1, 1, 1], 2) 2 >>> find_subarray_sum([1, -1, 0, 1], 0) 4 pass def process_test_cases(test_cases): This function processes test cases for the 'find_subarray_sum' function. >>> process_test_cases([(3, 2, [1, 1, 1]), (4, 0, [1, -1, 0, 1])]) [2, 4] pass if __name__ == \\"__main__\\": test_cases = [ (3, 2, [1, 1, 1]), (4, 0, [1, -1, 0, 1]) ] print(process_test_cases(test_cases))","solution":"def find_subarray_sum(arr, k): This function finds the total number of continuous subarrays whose sum equals to k. count = 0 current_sum = 0 sum_map = {0: 1} # To handle the case when subarray starts from index 0 for num in arr: current_sum += num if (current_sum - k) in sum_map: count += sum_map[current_sum - k] if current_sum in sum_map: sum_map[current_sum] += 1 else: sum_map[current_sum] = 1 return count def process_test_cases(test_cases): results = [] for n, k, arr in test_cases: results.append(find_subarray_sum(arr, k)) return results"},{"question":"def min_operations_to_reduce_to_one(n: int) -> int: Returns the minimum number of operations needed to reduce a number n to 1. Allowed operations: 1. Subtract 1 from n 2. If n is divisible by 2, divide n by 2 3. If n is divisible by 3, divide n by 3 Examples: >>> min_operations_to_reduce_to_one(10) 3 >>> min_operations_to_reduce_to_one(6) 2 >>> min_operations_to_reduce_to_one(1) 0 >>> min_operations_to_reduce_to_one(2) 1 >>> min_operations_to_reduce_to_one(18) 3","solution":"def min_operations_to_reduce_to_one(n): Returns the minimum number of operations needed to reduce a number n to 1. Allowed operations: 1. Subtract 1 from n 2. If n is divisible by 2, divide n by 2 3. If n is divisible by 3, divide n by 3 dp = [0] * (n + 1) for i in range(2, n + 1): dp[i] = dp[i - 1] + 1 # operation: subtract 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) # operation: divide by 2 if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) # operation: divide by 3 return dp[n]"},{"question":"def min_jumps_to_reach_last_stone(test_cases): Determine the minimum number of jumps required to reach the last stone from any starting stone. >>> min_jumps_to_reach_last_stone([[6, 2, 4, 0, 3]]) [1] >>> min_jumps_to_reach_last_stone([[6, 2, 4, 0, 3], [1, 0, 1]]) [1, -1] >>> min_jumps_to_reach_last_stone([[0]]) [0] >>> min_jumps_to_reach_last_stone([[0, 1, 2]]) [-1] >>> min_jumps_to_reach_last_stone([[9, 2, 3, 1]]) [1] >>> min_jumps_to_reach_last_stone([[0, 2, 3, 1]]) [-1]","solution":"def min_jumps_to_reach_last_stone(test_cases): def min_jumps(stones): n = len(stones) if n == 1: return 0 if stones[0] == 0: return -1 max_reach = stones[0] step = stones[0] jump = 1 for i in range(1, n): if i == n - 1: return jump max_reach = max(max_reach, i + stones[i]) step -= 1 if step == 0: jump += 1 if i >= max_reach: return -1 step = max_reach - i return -1 results = [] for t in test_cases: results.append(min_jumps(t)) return results"},{"question":"def trap_rain_water(heights: List[int]) -> int: Calculate the total amount of water trapped after raining. :param heights: List[int] - List of positive integers representing heights of the buildings. :return: int - Total water units trapped. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([3, 3, 3, 3]) == 0 >>> trap_rain_water([0, 0, 0, 0]) == 0 >>> trap_rain_water([1, 2, 3, 4]) == 0 >>> trap_rain_water([4, 3, 2, 1]) == 0 >>> trap_rain_water([4, 1, 3]) == 2 >>> trap_rain_water([3, 0, 2, 0, 4]) == 7 >>> trap_rain_water([0, 1]) == 0 >>> trap_rain_water([1, 0]) == 0 >>> assert trap_rain_water([i % 10 for i in range(100000)]) >= 0","solution":"def trap_rain_water(heights): Calculate the total amount of water trapped after raining. :param heights: List[int] - List of positive integers representing heights of the buildings. :return: int - Total water units trapped. if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"def modulo_sum(n, k, arr): Compute the modulo sum of an integer array. Parameters: n (int): number of elements in the array k (int): the modulo integer arr (list of int): the list of integers Returns: int: the result of the modulo sum operation pass def test_example_1(): assert modulo_sum(3, 5, [5, -2, 3]) == 1 def test_example_2(): assert modulo_sum(4, 7, [-1, -1, -1, -1]) == 3 def test_all_positive_numbers(): assert modulo_sum(5, 10, [1, 2, 3, 4, 5]) == 5 def test_all_negative_numbers(): assert modulo_sum(4, 6, [-1, -2, -3, -4]) == 2 def test_mixed_numbers(): assert modulo_sum(3, 9, [-5, 10, 4]) == 9 % 9 def test_zero_in_array(): assert modulo_sum(4, 3, [0, 0, 0, 0]) == 0 def test_array_with_large_elements(): assert modulo_sum(5, 100, [1000, -2000, 3000, -4000, 5000]) == 8000 % 100 def test_large_k(): assert modulo_sum(2, 1000, [1000, 2000]) == 3000 % 1000 def test_large_element_and_small_array(): assert modulo_sum(1, 2, [1001]) == 1001 % 2","solution":"def modulo_sum(n, k, arr): Compute the modulo sum of an integer array. Parameters: n (int): number of elements in the array k (int): the modulo integer arr (list of int): the list of integers Returns: int: the result of the modulo sum operation total_sum = sum(arr) result = total_sum % k return result"},{"question":"import math from typing import List, Tuple def count_flower_arrangements(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Calculate the number of ways to arrange n unique types of flowers in a grid of m rows and k columns such that each row and each column contains exactly one type of flower. Args: t (int): Number of test cases. test_cases (List[Tuple[int, int, int]]): Each test case contains three integers n, m, and k. Returns: List[int]: The number of ways to arrange flowers in each test case, modulo 10^9 + 7. >>> count_flower_arrangements(2, [(3, 3, 3), (4, 4, 4)]) [6, 24] >>> count_flower_arrangements(1, [(1, 1, 1)]) [1]","solution":"import math def count_flower_arrangements(t, test_cases): MOD = 10**9 + 7 results = [] for case in test_cases: n, m, k = case if n != m or m != k: results.append(0) else: results.append(math.factorial(n) % MOD) return results # Example Use t = 2 test_cases = [(3, 3, 3), (4, 4, 4)] print(count_flower_arrangements(t, test_cases))"},{"question":"from typing import List def exist(matrix: List[List[str]], word: str) -> bool: Given a matrix of characters of size N x M and a target word, check if the target word exists in the matrix. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Args: matrix: List of list of characters. word: Target word as a string. Returns: True if the word exists in the matrix, False otherwise. Example usage: >>> matrix = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> exist(matrix, \\"ABCCED\\") True >>> exist(matrix, \\"SEE\\") True >>> exist(matrix, \\"ABCB\\") False pass def test_exist_word_found(): matrix = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] assert exist(matrix, \\"ABCCED\\") == True def test_exist_word_found_another(): matrix = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] assert exist(matrix, \\"SEE\\") == True def test_exist_word_not_found(): matrix = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] assert exist(matrix, \\"ABCB\\") == False def test_exist_empty_matrix(): assert exist([], \\"ABCB\\") == False def test_exist_empty_word(): matrix = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] assert exist(matrix, \\"\\") == False def test_exist_single_letter_word_found(): matrix = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] assert exist(matrix, \\"F\\") == True def test_exist_single_letter_word_not_found(): matrix = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] assert exist(matrix, \\"X\\") == False","solution":"def exist(matrix, word): if not matrix or not word: return False n, m = len(matrix), len(matrix[0]) def backtrack(x, y, suffix): if len(suffix) == 0: return True if x < 0 or x >= n or y < 0 or y >= m or matrix[x][y] != suffix[0]: return False ret = False temp, matrix[x][y] = matrix[x][y], '#' for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: ret = backtrack(x + dx, y + dy, suffix[1:]) if ret: break matrix[x][y] = temp return ret for i in range(n): for j in range(m): if backtrack(i, j, word): return True return False"},{"question":"def convert_score_to_label(score: int) -> str: Convert the given score into a label based on the specified ranges. Args: score (int): The score of a participant (0 ≤ score ≤ 100). Returns: str: The label corresponding to the score. >>> convert_score_to_label(98) 'excellent' >>> convert_score_to_label(76) 'good' >>> convert_score_to_label(45) 'unsatisfactory' >>> convert_score_to_label(73) 'satisfactory' from typing import * def test_convert_score_to_label_excellent(): assert convert_score_to_label(98) == \\"excellent\\" assert convert_score_to_label(90) == \\"excellent\\" def test_convert_score_to_label_good(): assert convert_score_to_label(76) == \\"good\\" assert convert_score_to_label(89) == \\"good\\" def test_convert_score_to_label_satisfactory(): assert convert_score_to_label(50) == \\"satisfactory\\" assert convert_score_to_label(74) == \\"satisfactory\\" def test_convert_score_to_label_unsatisfactory(): assert convert_score_to_label(45) == \\"unsatisfactory\\" assert convert_score_to_label(0) == \\"unsatisfactory\\" assert convert_score_to_label(49) == \\"unsatisfactory\\" def test_convert_score_to_label_boundary(): assert convert_score_to_label(100) == \\"excellent\\" assert convert_score_to_label(75) == \\"good\\" def test_convert_score_to_label_out_of_bounds(): try: convert_score_to_label(-1) except ValueError as ve: assert str(ve) == \\"Score must be between 0 and 100 inclusive.\\" try: convert_score_to_label(101) except ValueError as ve: assert str(ve) == \\"Score must be between 0 and 100 inclusive.\\"","solution":"def convert_score_to_label(score): Convert the given score into a label based on the specified ranges. Args: score (int): The score of a participant (0 ≤ score ≤ 100). Returns: str: The label corresponding to the score. if 90 <= score <= 100: return \\"excellent\\" elif 75 <= score < 90: return \\"good\\" elif 50 <= score < 75: return \\"satisfactory\\" elif 0 <= score < 50: return \\"unsatisfactory\\" else: raise ValueError(\\"Score must be between 0 and 100 inclusive.\\")"},{"question":"def min_energy_path(grid): Given an N x M grid representing energy requirements for each cell, calculates the minimum energy required to travel from the top-left (0, 0) to the bottom-right corner (N-1, M-1). Can only move right or down. Parameters: grid (list of list of int): 2D list representing the grid Returns: int: Minimum energy required # To be implemented # Unit tests def test_min_energy_path_3x3(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_energy_path(grid) == 7 def test_min_energy_path_2x2(): grid = [ [1, 2], [1, 1] ] assert min_energy_path(grid) == 3 def test_min_energy_path_1x1(): grid = [ [5] ] assert min_energy_path(grid) == 5 def test_min_energy_path_2x3(): grid = [ [1, 2, 3], [4, 5, 6] ] assert min_energy_path(grid) == 12 def test_min_energy_path_all_ones(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert min_energy_path(grid) == 5","solution":"def min_energy_path(grid): Given an N x M grid representing energy requirements for each cell, calculates the minimum energy required to travel from the top-left (0, 0) to the bottom-right corner (N-1, M-1). Can only move right or down. Parameters: grid (list of list of int): 2D list representing the grid Returns: int: Minimum energy required N = len(grid) M = len(grid[0]) # Create a 2D dp array with the same dimensions as the grid dp = [[0] * M for _ in range(N)] # Initialize the value for the starting cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer is the value at the bottom-right corner of the dp array return dp[N-1][M-1]"},{"question":"from collections import deque def min_distance_in_maze(grid): Returns the minimum distance required to reach the bottom-right corner of the grid starting from the top-left corner. If it is not possible to reach the bottom-right corner, returns -1. >>> min_distance_in_maze([[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0]]) 9 >>> min_distance_in_maze([[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) -1 >>> min_distance_in_maze([[0]]) 1 >>> min_distance_in_maze([[1]]) -1","solution":"from collections import deque def min_distance_in_maze(grid): Returns the minimum distance required to reach the bottom-right corner of the grid starting from the top-left corner. If it is not possible to reach the bottom-right corner, returns -1. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_adjacent_boxes(heights): Calculate maximum number of adjacent boxes that will be aligned vertically after applying the wind once in either direction. :param heights: List of positive integers representing the heights of boxes. :return: Integer, maximum number of adjacent boxes aligned vertically. >>> max_adjacent_boxes([4, 3, 2, 6, 1, 3]) == 0 >>> max_adjacent_boxes([4, 4, 4, 4]) == 1 >>> max_adjacent_boxes([1, 2, 3, 4, 5]) == 0 >>> max_adjacent_boxes([5, 4, 3, 2, 1]) == 0 >>> max_adjacent_boxes([5]) == 0 >>> max_adjacent_boxes([9, 10]) == 0","solution":"def max_adjacent_boxes(heights): Calculate maximum number of adjacent boxes that will be aligned vertically after applying the wind once in either direction. :param heights: List of positive integers representing the heights of boxes. :return: Integer, maximum number of adjacent boxes aligned vertically. if not heights or len(heights) < 2: return 0 n = len(heights) # Create two lists to store the resulting heights after applying wind in both directions left_heights = [0] * n right_heights = [0] * n # Apply wind to the right for i in range(1, n): right_heights[i - 1] = heights[i - 1] + heights[i] # Apply wind to the left for i in range(n - 1): left_heights[i + 1] = heights[i] + heights[i + 1] # Calculate the maximum number of adjacent boxes with same height max_adjacent = 0 # Check for right wind for i in range(n - 1): if right_heights[i] == right_heights[i + 1]: max_adjacent = max(max_adjacent, 1) # Check for left wind for i in range(1, n - 1): if left_heights[i] == left_heights[i + 1]: max_adjacent = max(max_adjacent, 1) return max_adjacent"},{"question":"def expected_colonies(x, y, n): Calculates the expected number of remaining colonies after n intervals. Parameters: x (int): Initial number of colonies y (int): Multiplication factor n (int): Number of time intervals Returns: float: Expected number of remaining colonies Examples: >>> expected_colonies(10, 2, 0) 10.0 >>> expected_colonies(10, 2, 1) 10.0 >>> expected_colonies(5, 2, 2) 5.0","solution":"def expected_colonies(x, y, n): Calculates the expected number of remaining colonies after n intervals. if n == 0: return float(x) # Probability of each colony multiplying or dying off is 0.5 each # For every time interval, the expected number of colonies remains the same # as (0.5 * y * x) + (0.5 * 0) = 0.5 * y * x expected = x # Initial colonies for _ in range(n): expected = (expected * y * 0.5) # Expected value remain same in each interval return expected"},{"question":"def count_words(sentence: str) -> int: Returns the number of words in the given sentence. A word is defined as a sequence of characters separated by spaces. >>> count_words(\\"Hello, world! Welcome to coding.\\") 5 >>> count_words(\\"Hello, world!\\") 2 >>> count_words(\\"\\") 0 >>> count_words(\\" \\") 0 >>> count_words(\\" Hello world \\") 2 >>> count_words(\\"Hello\\") 1 >>> count_words(\\"Well-done!\\") 1","solution":"def count_words(sentence): Returns the number of words in the given sentence. A word is defined as a sequence of characters separated by spaces. # Split the sentence by spaces words = sentence.split() # Return the length of the list of words return len(words)"},{"question":"def lexicographically_smallest_substring(s: str, k: int) -> str: Returns the lexicographically smallest substring of length k that can be formed by deleting characters from the string s but without reordering the remaining characters. :param s: input string consisting of lowercase English letters :param k: length of the desired substring :return: lexicographically smallest substring of length k >>> lexicographically_smallest_substring(\\"abcde\\", 3) 'abc' >>> lexicographically_smallest_substring(\\"bacabc\\", 3) 'aab' >>> lexicographically_smallest_substring(\\"efghijklmnopqrstuvwxyz\\", 4) 'efgh'","solution":"def lexicographically_smallest_substring(s, k): Returns the lexicographically smallest substring of length k that can be formed by deleting characters from the string s but without reordering the remaining characters. :param s: input string consisting of lowercase English letters :param k: length of the desired substring :return: lexicographically smallest substring of length k n = len(s) result = [] to_remove = n - k for i, char in enumerate(s): while to_remove > 0 and result and result[-1] > char: result.pop() to_remove -= 1 result.append(char) return ''.join(result[:k])"},{"question":"def total_shuttles_required(shuttle_capacities, passenger_groups): Calculate the total number of shuttles required to accommodate all passenger groups. Input: - shuttle_capacities: a list of integers where each integer represents the capacity of a shuttle. - passenger_groups: a list of integers where each integer represents the size of a passenger group. Output: - an integer representing the total number of shuttles required to accommodate all passenger groups. Example: >>> total_shuttles_required([10, 15, 20], [6, 8, 12, 15]) 3 >>> total_shuttles_required([5, 10], [1, 2, 3, 4, 5, 10]) 2","solution":"def total_shuttles_required(shuttle_capacities, passenger_groups): shuttle_index = 0 total_shuttles = 0 for group_size in passenger_groups: while shuttle_index < len(shuttle_capacities) and shuttle_capacities[shuttle_index] < group_size: shuttle_index += 1 if shuttle_index == len(shuttle_capacities): break total_shuttles += 1 shuttle_index += 1 return total_shuttles"},{"question":"import calendar def generate_calendar(month: int, year: int) -> str: Generates a calendar for a specified month and year. Parameters: - month (int): The month for which the calendar is to be generated (1 = January, ..., 12 = December). - year (int): The year for which the calendar is to be generated. Returns: - str: A string representing the calendar for the specified month and year. >>> print(generate_calendar(9, 2023)) September 2023 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 >>> print(generate_calendar(2, 2020)) February 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 >>> print(generate_calendar(4, 2021)) April 2021 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30","solution":"import calendar def generate_calendar(month, year): Generates a calendar for a specified month and year. Parameters: - month (int): The month for which the calendar is to be generated (1 = January, ..., 12 = December). - year (int): The year for which the calendar is to be generated. Returns: - str: A string representing the calendar for the specified month and year. # Create a TextCalendar instance with Sunday as the first day of the week cal = calendar.TextCalendar(calendar.SUNDAY) # Generate the month calendar as a string calendar_str = cal.formatmonth(year, month) return calendar_str"},{"question":"import math from typing import List, Tuple def max_distance(points: List[Tuple[int, int]]) -> float: Function to calculate the maximum distance between any two points in a list. >>> max_distance([(0, 0), (0, 3), (4, 0), (3, 4)]) 5.000000 >>> max_distance([(0, 0)]) 0.000000 >>> max_distance([(0, 0), (3, 4)]) 5.000000 >>> max_distance([(-1000, -1000), (1000, 1000)]) 2828.427125 >>> max_distance([(0, 0), (-3, -4)]) 5.000000","solution":"import math def max_distance(points): Function to calculate the maximum distance between any two points in a list. max_dist = 0 n = len(points) for i in range(n): for j in range(i + 1, n): dist = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) max_dist = max(max_dist, dist) return max_dist"},{"question":"from typing import List def find_shortest_path(n: int, m: int, grid: List[List[int]], x1: int, y1: int, x2: int, y2: int) -> int: Determine the minimum number of steps required to reach from the starting point (x1, y1) to the destination (x2, y2) in a grid. Returns the number of steps if a path exists, otherwise returns -1. >>> find_shortest_path(3, 3, [[0, 0, 0], [1, 1, 0], [0, 0, 0]], 0, 0, 2, 2) 4 >>> find_shortest_path(3, 3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]], 0, 0, 2, 2) -1","solution":"from collections import deque def find_shortest_path(n, m, grid, x1, y1, x2, y2): Returns the minimum number of steps required to reach from (x1, y1) to (x2, y2) in a given grid, or -1 if there is no valid path. if grid[x1][y1] == 1 or grid[x2][y2] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(x1, y1, 0)]) visited = set((x1, y1)) while queue: x, y, steps = queue.popleft() if x == x2 and y == y2: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a number n is a prime number. Args: n (int): The number to check. Returns: bool: True if the number is prime, False otherwise. Examples: >>> is_prime(2) True >>> is_prime(4) False pass def special_primes(N: int) -> List[int]: Finds all special primes up to and including N. A special prime is a prime number whose reverse is also a prime number. Args: N (int): The upper limit up to which to find special primes. Returns: List[int]: A list of special prime numbers up to N. Examples: >>> special_primes(10) [2, 3, 5, 7] >>> special_primes(100) [2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, 97] pass","solution":"def is_prime(n): Checks if a number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def special_primes(N): Finds all special primes up to and including N. A special prime is a prime number whose reverse is also a prime number. result = [] for num in range(2, N+1): if is_prime(num): reversed_num = int(str(num)[::-1]) if is_prime(reversed_num): result.append(num) return result def main(N): special_prime_numbers = special_primes(N) for prime in special_prime_numbers: print(prime)"},{"question":"def count_subarrays_with_target_sum(n: int, target: int, sequence: List[int]) -> int: Find the number of contiguous subarrays whose sum is equal to the target. Args: n (int): the number of elements in the sequence target (int): the target sum sequence (List[int]): the list of integers Returns: int: the number of contiguous subarrays with sum equal to the target Examples: >>> count_subarrays_with_target_sum(5, 5, [1, 2, 3, 4, 5]) 2 >>> count_subarrays_with_target_sum(6, 0, [1, -1, 1, -1, 1, -1]) 9","solution":"def count_subarrays_with_target_sum(n, target, sequence): count = 0 current_sum = 0 sum_dict = {0: 1} for num in sequence: current_sum += num if (current_sum - target) in sum_dict: count += sum_dict[current_sum - target] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"def count_products_meeting_target(n: int, products: list, target: int) -> int: Calculate the number of products with average quarterly sales >= target. Args: n : int : number of products. products: list of str : list containing product identifiers and their quarterly sales. target : int : target average quarterly sales. Returns: int : number of products meeting or exceeding the target average quarterly sales. Examples: >>> n = 3 >>> products = [\\"product1 100 200 300 400\\", \\"product2 500 600 700 800\\", \\"product3 150 250 350 450\\"] >>> target = 300 >>> count_products_meeting_target(n, products, target) 2 >>> n = 2 >>> products = [\\"prodA 200 300 400 500\\", \\"prodB 100 150 200 250\\"] >>> target = 275 >>> count_products_meeting_target(n, products, target) 1 from solution import count_products_meeting_target def test_example_1(): n = 3 products = [ \\"product1 100 200 300 400\\", \\"product2 500 600 700 800\\", \\"product3 150 250 350 450\\" ] target = 300 assert count_products_meeting_target(n, products, target) == 2 def test_example_2(): n = 2 products = [ \\"prodA 200 300 400 500\\", \\"prodB 100 150 200 250\\" ] target = 275 assert count_products_meeting_target(n, products, target) == 1 def test_all_below_target(): n = 2 products = [ \\"prodA 100 150 200 250\\", \\"prodB 50 100 150 200\\" ] target = 300 assert count_products_meeting_target(n, products, target) == 0 def test_all_above_target(): n = 3 products = [ \\"product1 400 400 400 400\\", \\"product2 500 500 500 500\\", \\"product3 600 600 600 600\\" ] target = 300 assert count_products_meeting_target(n, products, target) == 3 def test_edge_case_one_product(): n = 1 products = [ \\"product1 0 0 0 0\\" ] target = 0 assert count_products_meeting_target(n, products, target) == 1 def test_edge_case_largest_inputs(): n = 1000 products = [ f\\"product{i} 1000000 1000000 1000000 1000000\\" for i in range(n) ] target = 1000000 assert count_products_meeting_target(n, products, target) == 1000","solution":"def count_products_meeting_target(n, products, target): Function to count the number of products with average quarterly sales >= target. Args: n : int : number of products. products : list of str : list containing product identifiers and their quarterly sales. target : int : target average quarterly sales. Returns: int : number of products meeting or exceeding the target average quarterly sales. count = 0 for product in products: data = product.split() identifier = data[0] sales = list(map(int, data[1:])) average_sales = sum(sales) / 4 if average_sales >= target: count += 1 return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: Given a singly linked list of size N, reverse the nodes of the list k at a time and return the modified list. The values in the nodes will be represented as ints. You may not alter the values in the nodes, only the nodes themselves may be changed. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. import pytest def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result def test_reverseKGroup(): head = create_linked_list([1, 2, 3, 4, 5, 6, 7, 8]) k = 3 new_head = reverseKGroup(head, k) assert linked_list_to_list(new_head) == [3, 2, 1, 6, 5, 4, 7, 8] head = create_linked_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) k = 2 new_head = reverseKGroup(head, k) assert linked_list_to_list(new_head) == [2, 1, 4, 3, 6, 5, 8, 7, 10, 9] def test_reverseKGroup_single_element(): head = create_linked_list([1]) k = 1 new_head = reverseKGroup(head, k) assert linked_list_to_list(new_head) == [1] def test_reverseKGroup_k_greater_than_length(): head = create_linked_list([1, 2]) k = 3 new_head = reverseKGroup(head, k) assert linked_list_to_list(new_head) == [1, 2] def test_reverseKGroup_empty_list(): head = create_linked_list([]) k = 2 new_head = reverseKGroup(head, k) assert linked_list_to_list(new_head) == [] if __name__ == \\"__main__\\": pytest.main()","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): if head is None or k == 1: return head dummy = ListNode(0) dummy.next = head current, prev, nxt = head, dummy, None # Count the length of the linked list length = 0 while current: length += 1 current = current.next while length >= k: current = prev.next nxt = current.next for _ in range(1, k): current.next = nxt.next nxt.next = prev.next prev.next = nxt nxt = current.next prev = current length -= k return dummy.next"},{"question":"def count_connected_components(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the number of connected components in an undirected, unweighted graph for each test case. Args: T: An integer representing the number of test cases. test_cases: A list of tuples, where each tuple contains: - An integer N representing the number of nodes. - An integer M representing the number of edges. - A list of M tuples, where each tuple contains two integers u and v denoting an edge between node u and node v. Returns: A list of integers where each integer represents the number of connected components for the corresponding test case. Examples: >>> count_connected_components(2, [(5, 2, [(1, 2), (3, 4)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)])]) [3, 1] >>> count_connected_components(1, [(6, 3, [(1, 2), (3, 4), (5, 6)])]) [3]","solution":"def count_connected_components(T, test_cases): def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() visited.add(current) for neighbor in adj_list[current]: if neighbor not in visited: stack.append(neighbor) results = [] for N, M, edges in test_cases: adj_list = {i: [] for i in range(1, N + 1)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = set() connected_components = 0 for node in range(1, N + 1): if node not in visited: dfs(node, visited, adj_list) connected_components += 1 results.append(connected_components) return results"},{"question":"def triangle_type(a: int, b: int, c: int) -> str: Write a function that takes three integers representing the lengths of the sides of a triangle and returns a string describing the type of triangle. The function should return: - \\"Equilateral\\" if all three sides are equal - \\"Isosceles\\" if exactly two sides are equal - \\"Scalene\\" if all three sides are different - \\"Not a triangle\\" if the given sides do not form a valid triangle Note: - A triangle is valid if the sum of any two sides is greater than the third side. >>> triangle_type(1, 1, 2) 'Not a triangle' >>> triangle_type(3, 3, 3) 'Equilateral' >>> triangle_type(3, 3, 2) 'Isosceles' >>> triangle_type(3, 4, 5) 'Scalene'","solution":"def triangle_type(a, b, c): # Check if the given sides form a valid triangle if a + b <= c or a + c <= b or b + c <= a: return \\"Not a triangle\\" # All sides are equal if a == b == c: return \\"Equilateral\\" # Two sides are equal elif a == b or b == c or a == c: return \\"Isosceles\\" # All sides are different else: return \\"Scalene\\""},{"question":"def count_occurrences(N, Q, elements, queries): Returns the count of occurrences of X in the specified subarray for each query. If the subarray is invalid, returns \\"Invalid Query\\". :param N: int, number of elements in the list :param Q: int, number of queries :param elements: list of int, the list of N integers :param queries: list of tuples, each containing three integers (L, R, X) :return: list of results for each query from solution import count_occurrences def test_basic_queries(): N, Q = 10, 3 elements = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] queries = [(1, 5, 3), (2, 7, 6), (10, 10, 10)] assert count_occurrences(N, Q, elements, queries) == [1, 1, 1] def test_invalid_queries(): N, Q = 10, 2 elements = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] queries = [(5, 3, 7), (11, 12, 2)] assert count_occurrences(N, Q, elements, queries) == [\\"Invalid Query\\", \\"Invalid Query\\"] def test_mixed_numbers(): N, Q = 10, 3 elements = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10] queries = [(1, 5, -3), (2, 7, -6), (10, 10, -10)] assert count_occurrences(N, Q, elements, queries) == [1, 1, 1] def test_full_range_query(): N, Q = 10, 1 elements = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] queries = [(1, 10, 1)] assert count_occurrences(N, Q, elements, queries) == [10] def test_nonexistent_element(): N, Q = 10, 1 elements = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] queries = [(1, 10, -1)] assert count_occurrences(N, Q, elements, queries) == [0]","solution":"def count_occurrences(N, Q, elements, queries): Returns the count of occurrences of X in the specified subarray for each query. If the subarray is invalid, returns \\"Invalid Query\\". :param N: int, number of elements in the list :param Q: int, number of queries :param elements: list of int, the list of N integers :param queries: list of tuples, each containing three integers (L, R, X) :return: list of results for each query results = [] for (L, R, X) in queries: if L > R or L < 1 or R > N: # Check if the query is valid results.append(\\"Invalid Query\\") else: subarray = elements[L-1:R] # Get the subarray using 1-based indices count = subarray.count(X) # Count the occurrences of X in subarray results.append(count) return results"},{"question":"def find_pairs(nums, t): Finds all unique pairs in the array that sum up to the target t. Parameters: nums (List[int]): List of integers. t (int): Target sum for pairs. Returns: List[List[int]]: List of unique pairs that sum to the target. Examples: >>> find_pairs([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> find_pairs([3, 1, 4, 1, 5], 6) [[1, 5]] >>> find_pairs([1, 1, 1, 1, 1], 2) [[1, 1]]","solution":"def find_pairs(nums, t): Finds all unique pairs in the array that sum up to the target t. seen = set() pairs = set() for num in nums: complement = t - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return [list(pair) for pair in pairs]"},{"question":"def total_voucher_value(n: int, transactions: List[Tuple[str, int]]) -> int: Determine the total value of the vouchers distributed after processing a series of transactions. Args: n (int): The number of transactions. transactions (List[Tuple[str, int]]): List of tuples containing customer's name and transaction amount. Returns: int: The total value of the vouchers distributed. >>> total_voucher_value(5, [(\\"Alice\\", 100), (\\"Bob\\", 50), (\\"Alice\\", 150), (\\"Alice\\", 70), (\\"Bob\\", 120)]) 40 >>> total_voucher_value(3, [(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Alice\\", 30)]) 0 >>> total_voucher_value(1, [(\\"Alice\\", 1000)]) 100 >>> total_voucher_value(3, [(\\"Alice\\", 100), (\\"Bob\\", 200), (\\"Charlie\\", 300)]) 60 >>> total_voucher_value(2, [(\\"Alice\\", 200), (\\"Bob\\", 100)]) 30","solution":"def total_voucher_value(n, transactions): customers = {} for customer, amount in transactions: if customer not in customers: customers[customer] = 0 customers[customer] += amount total_vouchers = 0 for points in customers.values(): total_vouchers += (points // 100) * 10 return total_vouchers"},{"question":"def max_in_subarray(array, queries): For each query, return the maximum value in the subarray from index L to R. Args: - array (List[int]): A list of non-negative integers. - queries (List[Tuple[int, int]]): A list of queries, each query is a tuple (L, R). Returns: - List[int]: List of maximum values for each query. >>> max_in_subarray([1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [3, 4, 5] >>> max_in_subarray([10], [(1, 1)]) [10] >>> max_in_subarray([5, 3, 8, 6, 7], [(1, 5)]) [8] >>> max_in_subarray([1, 2, 2, 3, 3], [(1, 3), (2, 5)]) [2, 3] >>> max_in_subarray([1, 1000000000, 300000000, 700000000, 900000000], [(1, 5), (2, 4)]) [1000000000, 1000000000] >>> max_in_subarray([10, 20, 11, 9, 2, 8], [(1, 2), (4, 6), (3, 5)]) [20, 9, 11] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def max_in_subarray(array, queries): For each query, return the maximum value in the subarray from index L to R. Args: - array (List[int]): A list of non-negative integers. - queries (List[Tuple[int, int]]): A list of queries, each query is a tuple (L, R). Returns: - List[int]: List of maximum values for each query. results = [] for L, R in queries: results.append(max(array[L-1:R])) return results"},{"question":"from typing import List def wallsAndGates(grid: List[List[int]]) -> None: Modify the grid in-place filling each empty room with the distance to its nearest gate. If it is impossible to reach a gate, the room remains filled with INF. Walls (represented by -1) and gates (represented by 0) remain unchanged. >>> INF = 2**31 - 1 >>> grid = [ ... [INF, -1, 0, INF], ... [INF, INF, INF, -1], ... [INF, -1, INF, -1], ... [ 0, -1, INF, INF] ... ] >>> wallsAndGates(grid) >>> expected = [ ... [ 3, -1, 0, 1], ... [ 2, 2, 1, -1], ... [ 1, -1, 2, -1], ... [ 0, -1, 3, 4] ... ] >>> assert grid == expected >>> grid = [ ... [-1, -1, -1], ... [-1, -1, -1], ... [-1, -1, -1] ... ] >>> wallsAndGates(grid) >>> expected = [ ... [-1, -1, -1], ... [-1, -1, -1], ... [-1, -1, -1] ... ] >>> assert grid == expected >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> wallsAndGates(grid) >>> expected = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> assert grid == expected >>> INF = 2**31 - 1 >>> grid = [ ... [INF, INF, 0], ... [INF, -1, INF], ... [0, INF, INF] ... ] >>> wallsAndGates(grid) >>> expected = [ ... [ 2, 1, 0], ... [ 1, -1, 1], ... [ 0, 1, 2] ... ] >>> assert grid == expected >>> grid = [[0]] >>> wallsAndGates(grid) >>> expected = [[0]] >>> assert grid == expected >>> INF = 2**31 - 1 >>> grid = [[INF]] >>> wallsAndGates(grid) >>> expected = [[INF]] >>> assert grid == expected","solution":"from typing import List from collections import deque def wallsAndGates(grid: List[List[int]]) -> None: INF = 2**31 - 1 rows, cols = len(grid), len(grid[0]) queue = deque() # Enqueue all gates (0s) for r in range(rows): for c in range(cols): if grid[r][c] == 0: queue.append((r, c)) # BFS from the gates directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: r, c = queue.popleft() for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and grid[rr][cc] == INF: grid[rr][cc] = grid[r][c] + 1 queue.append((rr, cc))"},{"question":"def longest_increasing_banner(n: int, lengths: List[int]) -> Tuple[int, List[int]]: Returns the maximum possible length of the banner and the sequence of paper pieces' indices. Parameters: n (int): The number of paper pieces. lengths (list of int): The lengths of the paper pieces. Returns: (int, list of int): The maximum length and the sequence of indices. >>> longest_increasing_banner(5, [4, 3, 2, 6, 8]) (3, [2, 3, 4]) # or (3, [1, 4, 5]) >>> longest_increasing_banner(4, [1, 2, 1, 3]) (3, [1, 2, 4])","solution":"def longest_increasing_banner(n, lengths): Returns the maximum possible length of the banner and the sequence of paper pieces' indices. Parameters: n (int): The number of paper pieces. lengths (list of int): The lengths of the paper pieces. Returns: (int, list of int): The maximum length and the sequence of indices. # Initialize DP arrays dp = [1] * n prev = [-1] * n # Fill the DP arrays for i in range(n): for j in range(i): if lengths[i] > lengths[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev[i] = j # Find the maximum length and its ending index max_len = max(dp) idx = dp.index(max_len) # Reconstruct the sequence sequence = [] while idx != -1: sequence.append(idx + 1) # Convert to 1-based index idx = prev[idx] sequence.reverse() return max_len, sequence"},{"question":"def longest_mountain(arr): Find the length of the longest mountain subarray in the input array. A mountain subarray is defined as an array that has: - At least 3 elements - There exists an index i (0 < i < k - 1) such that: - arr[0] < arr[1] < ... < arr[i] - arr[i] > arr[i + 1] > ... > arr[k-1] :param arr: List of integers :return: Length of the longest mountain subarray >>> longest_mountain([2, 1, 4, 7, 3, 2, 5, 6, 4]) 5 >>> longest_mountain([2, 2, 2, 2, 2]) 0 >>> longest_mountain([2, 3, 3, 4, 4, 2]) 0 >>> longest_mountain([0]) 0 >>> longest_mountain([1, 2, 3, 4, 5]) 0 >>> longest_mountain([5, 4, 3, 2, 1]) 0 >>> longest_mountain([1, 2, 1]) 3 >>> longest_mountain([2, 1, 4, 7, 3, 2, 5, 1, 6, 7, 3, 2]) 5 >>> longest_mountain([2, 1, 2, 3, 4, 4, 4, 3, 2, 1]) 0","solution":"def longest_mountain(arr): Find the length of the longest mountain subarray in the input array. A mountain subarray is defined as an array that has: - At least 3 elements - There exists an index i (0 < i < k - 1) such that: - arr[0] < arr[1] < ... < arr[i] - arr[i] > arr[i + 1] > ... > arr[k-1] :param arr: List of integers :return: Length of the longest mountain subarray n = len(arr) if n < 3: return 0 max_length = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 while left > 0 and arr[left - 1] < arr[left]: left -= 1 right = i + 1 while right < n - 1 and arr[right + 1] < arr[right]: right += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def minTrafficFlow(traffic_data): Returns the minimum traffic flow recorded in any 1-hour period throughout the day. Parameters: traffic_data (list of int): A list of 24 integers representing the traffic flow in each hour of the day. Returns: int: The minimum traffic flow. >>> minTrafficFlow([120, 150, 100, 80, 60, 90, 110, 140, 130, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30]) 30 >>> minTrafficFlow([50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60]) 50 >>> minTrafficFlow([100] * 24) 100 >>> minTrafficFlow([1000, 2000, 1500, 800, 6000, 500, 4000, 3000, 700, 2700, 1600, 3500, 2500, 1800, 2100, 2200, 2300, 2400, 1900, 2000, 1700, 2600, 2800, 2900]) 500 >>> minTrafficFlow([9000, 9500, 9900, 8700, 8800, 8400, 9100, 7200, 8100, 6800, 9600, 6300, 5400, 4500, 9600, 6700, 6900, 7300, 8800, 9900, 9500, 1000, 5600, 300]) 300","solution":"def minTrafficFlow(traffic_data): Returns the minimum traffic flow recorded in any 1-hour period throughout the day. Parameters: traffic_data (list of int): A list of 24 integers representing the traffic flow in each hour of the day. Returns: int: The minimum traffic flow. return min(traffic_data)"},{"question":"def count_illuminated_buildings(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine how many buildings will be illuminated by the streetlight for each test case. The streetlight is positioned at the beginning of the row (before the first building) and emits light that can only shine to the right. The streetlight illuminates a building if there are no taller or equally tall buildings before it in the array that block the light. Args: T: An integer denoting the number of test cases. test_cases: A list of tuples, where each tuple contains: - An integer N, the number of buildings. - A list of N integers representing the heights of the buildings. Returns: A list of integers where each integer represents the number of buildings illuminated in the corresponding test case. Example: >>> count_illuminated_buildings(3, [(5, [3, 1, 4, 2, 5]), (4, [4, 3, 2, 1]), (6, [1, 3, 2, 4, 3, 6])]) [3, 1, 4] >>> count_illuminated_buildings(1, [(5, [2, 2, 2, 2, 2])]) [1] from typing import List, Tuple","solution":"def count_illuminated_buildings(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] heights = test_cases[i][1] illuminated_count = 0 tallest_so_far = 0 for height in heights: if height > tallest_so_far: illuminated_count += 1 tallest_so_far = height results.append(illuminated_count) return results"},{"question":"from collections import Counter from typing import List, Tuple def can_form_k_rectangles(n: int, k: int, sticks: List[int]) -> Tuple[str, List[int]]: Determines if k rectangles can be formed with the given sticks. Args: n: int - The number of sticks. k: int - The number of rectangles to form. sticks: List[int] - List of stick lengths. Returns: Tuple[str, List[int]] - \\"YES\\" or \\"NO\\" indicating whether it's possible to form k rectangles, and a list of the lengths of the sticks that form these rectangles if possible. >>> can_form_k_rectangles(8, 2, [4, 4, 4, 4, 6, 6, 6, 6]) (\\"YES\\", [4, 4, 6, 6]) >>> can_form_k_rectangles(6, 2, [4, 4, 4, 4, 6, 6]) (\\"NO\\", []) >>> can_form_k_rectangles(12, 3, [8, 8, 8, 8, 10, 10, 10, 10, 12, 12, 12, 12]) (\\"YES\\", [8, 8, 10, 10, 12, 12]) def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) sticks = list(map(int, data[2:2+n])) result, pairs = can_form_k_rectangles(n, k, sticks) if result == \\"YES\\": print(result) print(\\" \\".join(map(str, pairs))) else: print(result)","solution":"from collections import Counter def can_form_k_rectangles(n, k, sticks): Determines if k rectangles can be formed with the given sticks. if n < 4 * k: return \\"NO\\", [] stick_count = Counter(sticks) pairs = [] for stick in sorted(stick_count.keys(), reverse=True): while stick_count[stick] >= 2: stick_count[stick] -= 2 pairs.append(stick) if len(pairs) >= 2 * k: break if len(pairs) >= 2 * k: break if len(pairs) >= 2 * k: return \\"YES\\", pairs[:2 * k] else: return \\"NO\\", [] def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) sticks = list(map(int, data[2:2+n])) result, pairs = can_form_k_rectangles(n, k, sticks) if result == \\"YES\\": print(result) print(\\" \\".join(map(str, pairs))) else: print(result)"},{"question":"def min_cost_to_connect_islands(N, M, bridges): Determines the minimum cost to connect all islands in the archipelago. Parameters: N (int): Number of islands. M (int): Number of bridges. bridges (list of tuples): Each tuple contains three integers U, V, L representing a bridge between islands U and V with length L. Returns: int: Minimum cost to make all islands reachable from each other. Returns -1 if impossible. >>> min_cost_to_connect_islands(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (2, 4, 5)]) 6 >>> min_cost_to_connect_islands(4, 2, [(1, 2, 10), (3, 4, 15)]) -1 >>> min_cost_to_connect_islands(2, 1, [(1, 2, 7)]) 7 >>> min_cost_to_connect_islands(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3 >>> min_cost_to_connect_islands(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 10)]) 2 >>> min_cost_to_connect_islands(5, 2, [(1, 2, 8), (4, 5, 12)]) -1 >>> min_cost_to_connect_islands(3, 4, [(1, 2, 1), (1, 2, 2), (2, 3, 2), (1, 3, 2)]) 3","solution":"def min_cost_to_connect_islands(N, M, bridges): Determines the minimum cost to connect all islands in the archipelago. Parameters: N (int): Number of islands. M (int): Number of bridges. bridges (list of tuples): Each tuple contains three integers U, V, L representing a bridge between islands U and V with length L. Returns: int: Minimum cost to make all islands reachable from each other. Returns -1 if impossible. from heapq import heappop, heappush parent = list(range(N + 1)) rank = [0] * (N + 1) def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 edges = [] for u, v, l in bridges: heappush(edges, (l, u, v)) total_cost = 0 edges_used = 0 while edges and edges_used < N - 1: l, u, v = heappop(edges) if find(u) != find(v): union(u, v) total_cost += l edges_used += 1 # Check if we have used exactly N-1 edges if edges_used == N - 1: return total_cost else: return -1"},{"question":"def max_customers(counters: List[int], minutes: int) -> int: Determine the maximum number of customers that can be served within the given amount of time. :param counters: List[int] - Each integer represents a food counter and its value is the number of customers that counter can serve per minute. :param minutes: int - The total time available in minutes. :return: int - The maximum number of customers that can be served within the given time. Examples: >>> max_customers([5, 3, 4], 5) 60 >>> max_customers([10, 2, 8, 6], 3) 78 >>> max_customers([1, 1, 1], 10) 30 >>> max_customers([2, 2, 2, 2], 7) 56 >>> max_customers([7], 4) 28 >>> max_customers([], 5) 0 >>> max_customers([5, 5, 5], 0) 0","solution":"def max_customers(counters, minutes): Returns the maximum number of customers that can be served within the given time. :param counters: List[int] - Each integer represents a food counter and its value is the number of customers that counter can serve per minute. :param minutes: int - The total time available in minutes. :return: int - The maximum number of customers that can be served. return sum(counters) * minutes"},{"question":"def adjust_brightness(n, m, matrix): Adjusts the brightness levels of pixels in the image matrix. Parameters: n (int): number of rows in the matrix m (int): number of columns in the matrix matrix (list of list of int): the pixel brightness levels Returns: list of list of int: the adjusted brightness levels >>> adjust_brightness(3, 3, [ [12, 11, 50], [255, 100, 75], [0, 45, 210] ]) [ [24, 10, 100], [254, 200, 74], [0, 44, 420] ] >>> adjust_brightness(2, 2, [ [1, 2], [3, 4] ]) [ [0, 4], [2, 8] ] pass # Example test cases def test_sample_1(): n, m = 3, 3 matrix = [ [12, 11, 50], [255, 100, 75], [0, 45, 210] ] expected = [ [24, 10, 100], [254, 200, 74], [0, 44, 420] ] assert adjust_brightness(n, m, matrix) == expected def test_sample_2(): n, m = 2, 2 matrix = [ [1, 2], [3, 4] ] expected = [ [0, 4], [2, 8] ] assert adjust_brightness(n, m, matrix) == expected def test_sample_3(): n, m = 1, 5 matrix = [ [10, 21, 30, 41, 50] ] expected = [ [20, 20, 60, 40, 100] ] assert adjust_brightness(n, m, matrix) == expected def test_single_element_even(): n, m = 1, 1 matrix = [ [4] ] expected = [ [8] ] assert adjust_brightness(n, m, matrix) == expected def test_single_element_odd(): n, m = 1, 1 matrix = [ [3] ] expected = [ [2] ] assert adjust_brightness(n, m, matrix) == expected def test_all_zeros(): n, m = 2, 2 matrix = [ [0, 0], [0, 0] ] expected = [ [0, 0], [0, 0] ] assert adjust_brightness(n, m, matrix) == expected def test_all_max_value(): n, m = 2, 2 matrix = [ [255, 255], [255, 255] ] expected = [ [254, 254], [254, 254] ] assert adjust_brightness(n, m, matrix) == expected","solution":"def adjust_brightness(n, m, matrix): Adjusts the brightness levels of pixels in the image matrix. Parameters: n (int): number of rows in the matrix m (int): number of columns in the matrix matrix (list of list of int): the pixel brightness levels Returns: list of list of int: the adjusted brightness levels adjusted_matrix = [] for i in range(n): adjusted_row = [] for j in range(m): pixel = matrix[i][j] if pixel % 2 == 0: adjusted_pixel = pixel * 2 else: adjusted_pixel = pixel - 1 adjusted_row.append(adjusted_pixel) adjusted_matrix.append(adjusted_row) return adjusted_matrix"},{"question":"def find_lexicographically_smallest_string(S: str) -> str: Given a string S, find the lexicographically smallest string possible after performing the allowed operations zero or more times. >>> find_lexicographically_smallest_string(\\"bcab\\") \\"a\\" >>> find_lexicographically_smallest_string(\\"abcdef\\") \\"a\\" >>> find_lexicographically_smallest_string(\\"zzzab\\") \\"a\\" >>> find_lexicographically_smallest_string(\\"bbba\\") \\"a\\" >>> find_lexicographically_smallest_string(\\"zyxwvutsrqponmlkjihgfedcba\\") \\"a\\" >>> find_lexicographically_smallest_string(\\"a\\") \\"a\\" >>> find_lexicographically_smallest_string(\\"bbbbbbbbbbb\\") \\"b\\" >>> find_lexicographically_smallest_string(\\"qwerasdf\\") \\"a\\" >>> find_lexicographically_smallest_string(\\"mniop\\") \\"i\\" >>> find_lexicographically_smallest_string(\\"lkjhgfdsa\\") \\"a\\"","solution":"def find_lexicographically_smallest_string(S): Given a string S, find the lexicographically smallest string possible after performing the allowed operations zero or more times. # The result after operations will just be the smallest character in S. return min(S)"},{"question":"from collections import deque from typing import List def shoe_order_system(operations: List[str]) -> List[int]: Shoemaker's order tracking system. This function processes a list of operations to manage a shoemaker's order queue. Supported operations: - 'place_order x': Add order x to the order queue. - 'process_order': Process the order at the front of the queue. - 'peek_order': Show the order at the front without removing it. - 'count_orders': Print the number of orders in the queue. Args: operations (List[str]): List of operations to be processed Returns: List[int]: List of results for 'peek_order' and 'count_orders' operations Examples: >>> shoe_order_system([\\"place_order 5\\", \\"place_order 10\\", \\"peek_order\\", \\"process_order\\", \\"peek_order\\", \\"count_orders\\", \\"process_order\\"]) [5, 10, 1] >>> shoe_order_system([\\"place_order 1\\", \\"process_order\\", \\"peek_order\\"]) [] >>> shoe_order_system([\\"place_order 1\\", \\"place_order 2\\", \\"process_order\\", \\"count_orders\\"]) [1] >>> shoe_order_system([\\"place_order 1\\", \\"process_order\\", \\"process_order\\", \\"count_orders\\"]) [0] queue = deque() results = [] for operation in operations: if operation.startswith(\\"place_order\\"): _, x = operation.split() queue.append(int(x)) elif operation == \\"process_order\\": if queue: queue.popleft() elif operation == \\"peek_order\\": if queue: results.append(queue[0]) elif operation == \\"count_orders\\": results.append(len(queue)) return results def process_input(input_lines: List[str]) -> List[int]: Process input lines for the shoe order system. Args: input_lines (List[str]): List of input lines containing the number of operations and the operations themselves Returns: List[int]: List of results for 'peek_order' and 'count_orders' operations Examples: >>> process_input([\\"7\\", \\"place_order 5\\", \\"place_order 10\\", \\"peek_order\\", \\"process_order\\", \\"peek_order\\", \\"count_orders\\", \\"process_order\\"]) [5, 10, 1] n = int(input_lines[0]) operations = input_lines[1: n + 1] return shoe_order_system(operations)","solution":"from collections import deque def shoe_order_system(operations): queue = deque() results = [] for operation in operations: if operation.startswith(\\"place_order\\"): _, x = operation.split() queue.append(int(x)) elif operation == \\"process_order\\": if queue: queue.popleft() elif operation == \\"peek_order\\": if queue: results.append(queue[0]) elif operation == \\"count_orders\\": results.append(len(queue)) return results # Read input operations def process_input(input_lines): n = int(input_lines[0]) operations = input_lines[1: n + 1] return shoe_order_system(operations)"},{"question":"def is_prime(num): Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False ... def sieve_of_eratosthenes(n): Generate a list of prime numbers up to n (inclusive if n is prime). >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ... def sum_of_digits(num): Calculate the sum of the digits of a number. >>> sum_of_digits(123) 6 >>> sum_of_digits(49) 13 ... def generate_prime_lists_and_check(N): Generate two lists: prime numbers up to N and sum of their digits, and check if any number from the second list is also a prime number. >>> generate_prime_lists_and_check(10) \\"YES\\" >>> generate_prime_lists_and_check(30) \\"YES\\" ... def process_test_cases(test_cases): Process multiple test cases and return results for each. >>> process_test_cases([10, 30]) [\\"YES\\", \\"YES\\"] >>> process_test_cases([1, 2]) [\\"NO\\", \\"YES\\"] ...","solution":"from math import isqrt def is_prime(num): if num < 2: return False if num in (2, 3): return True if num % 2 == 0 or num % 3 == 0: return False for i in range(5, isqrt(num) + 1, 6): if num % i == 0 or num % (i + 2) == 0: return False return True def sieve_of_eratosthenes(n): is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]] def sum_of_digits(num): return sum(map(int, str(num))) def generate_prime_lists_and_check(N): primes = sieve_of_eratosthenes(N) sum_of_digit_primes = [sum_of_digits(p) for p in primes] for num in sum_of_digit_primes: if is_prime(num): return \\"YES\\" return \\"NO\\" def process_test_cases(test_cases): results = [] for N in test_cases: results.append(generate_prime_lists_and_check(N)) return results"},{"question":"import re def validate_serial_numbers(n: int, serial_numbers: List[str]) -> List[str]: Validates the serial numbers based on the given pattern. Parameters: - n: integer, number of serial numbers - serial_numbers: list of strings, serial numbers to validate Returns: - list of strings: \\"VALID\\" or \\"INVALID\\" for each serial number pattern = re.compile(r'^QAd{4}[XYZ]') result = [] for serial in serial_numbers: if pattern.match(serial): result.append(\\"VALID\\") else: result.append(\\"INVALID\\") return result # Example test cases def test_validate_serial_numbers_all_valid(): assert validate_serial_numbers(3, [\\"QA1234X\\", \\"QA5678Y\\", \\"QA9876Z\\"]) == [\\"VALID\\", \\"VALID\\", \\"VALID\\"] def test_validate_serial_numbers_all_invalid(): assert validate_serial_numbers(3, [\\"QA123Y\\", \\"ABCDEFG\\", \\"QA12345X\\"]) == [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] def test_validate_serial_numbers_mixed(): assert validate_serial_numbers(4, [\\"QA1234X\\", \\"QA12Y\\", \\"QA12345Z\\", \\"QA0000Y\\"]) == [\\"VALID\\", \\"INVALID\\", \\"INVALID\\", \\"VALID\\"] def test_validate_serial_numbers_edge_cases(): assert validate_serial_numbers(2, [\\"QA0000Z\\", \\"QA9999X\\"]) == [\\"VALID\\", \\"VALID\\"] assert validate_serial_numbers(2, [\\"QA0001A\\", \\"QA0001B\\"]) == [\\"INVALID\\", \\"INVALID\\"] def test_validate_serial_numbers_minimal(): assert validate_serial_numbers(1, [\\"QA1234Z\\"]) == [\\"VALID\\"] assert validate_serial_numbers(1, [\\"QA123Z\\"]) == [\\"INVALID\\"]","solution":"import re def validate_serial_numbers(n, serial_numbers): Validates the serial numbers based on the given pattern. Parameters: - n: integer, number of serial numbers - serial_numbers: list of strings, serial numbers to validate Returns: - list of strings: \\"VALID\\" or \\"INVALID\\" for each serial number pattern = re.compile(r'^QAd{4}[XYZ]') result = [] for serial in serial_numbers: if pattern.match(serial): result.append(\\"VALID\\") else: result.append(\\"INVALID\\") return result # Example usage (not part of the required solution): # n = 4 # serial_numbers = [\\"QA1234X\\", \\"QA12Y\\", \\"QA12345Z\\", \\"QA0000Y\\"] # print(validate_serial_numbers(n, serial_numbers)) # Output should be: ['VALID', 'INVALID', 'INVALID', 'VALID']"},{"question":"from collections import deque from typing import List, Tuple def min_steps(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: Calculate the minimum number of steps from start to destination in a grid. :param grid: List of lists representing the grid, where 0 represents an open cell and 1 represents a blocked cell. :param start: Tuple of two integers representing the starting cell coordinates (row, col), where 0 <= row < len(grid) and 0 <= col < len(grid[0]). :param destination: Tuple of two integers representing the destination cell coordinates (row, col), where 0 <= row < len(grid) and 0 <= col < len(grid[0]). :return: The minimum number of steps required to move from the start cell to the destination cell. If there is no valid path, return -1. >>> grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> min_steps(grid, (0, 0), (2, 2)) 4 >>> grid = [[0, 1, 0], [0, 0, 1], [1, 0, 0]] >>> min_steps(grid, (0, 0), (2, 2)) 4 >>> grid = [[1, 0, 0], [0, 0, 0], [0, 0, 0]] >>> min_steps(grid, (0, 0), (2, 2)) -1 >>> grid = [[0, 0, 0], [0, 0, 0], [0, 0, 1]] >>> min_steps(grid, (0, 0), (2, 2)) -1 >>> grid = [[0, 1, 0], [1, 1, 0], [0, 0, 0]] >>> min_steps(grid, (0, 0), (2, 2)) -1","solution":"from collections import deque def min_steps(grid, start, destination): Calculate the minimum number of steps from start to destination in a grid. :param grid: List[List[int]], the grid representation (0 for open cell, 1 for blocked cell). :param start: Tuple[int, int], the start coordinates (row, col). :param destination: Tuple[int, int], the destination coordinates (row, col). :return: int, the minimum number of steps required to reach destination from start, or -1 if no valid path. if grid[start[0]][start[1]] == 1 or grid[destination[0]][destination[1]] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add((start[0], start[1])) while queue: r, c, steps = queue.popleft() if (r, c) == destination: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, steps + 1)) visited.add((nr, nc)) return -1"},{"question":"def max_profit(prices: List[int]) -> int: Computes the maximum profit from a single buy-sell transaction. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def form_groups(K: int, M: int, N: int) -> Tuple[int, List[int]]: Determine the number of groups and the size of each group formed from K customers, given the minimum group size M and the maximum group size N. >>> form_groups(15, 3, 5) (4, [5, 5, 5, 3]) >>> form_groups(10, 2, 4) (3, [4, 4, 2]) >>> form_groups(16, 3, 5) (4, [5, 5, 5, 1]) >>> form_groups(5, 2, 2) (3, [2, 2, 1]) >>> form_groups(1, 1, 1) (1, [1]) >>> form_groups(20, 5, 5) (4, [5, 5, 5, 5]) >>> form_groups(10, 4, 5) (2, [5, 5])","solution":"def form_groups(K, M, N): groups = [] customers_remaining = K while customers_remaining >= M: if customers_remaining >= N: groups.append(N) customers_remaining -= N elif customers_remaining >= M: groups.append(customers_remaining) customers_remaining -= customers_remaining else: break if customers_remaining > 0: groups.append(customers_remaining) return len(groups), groups"},{"question":"from typing import List, Tuple def total_population(N: int, M: int, populations: List[int], bridges: List[Tuple[int, int]]) -> List[int]: Calculate the total population accessible from each island, including itself and all directly connected islands. Args: N (int): Number of islands M (int): Number of bridges populations (List[int]): List of populations of each island bridges (List[Tuple[int, int]]): List of bridges where each bridge connects two islands Returns: List[int]: Total population accessible from each island >>> total_population(4, 3, [10, 20, 30, 40], [(1, 2), (2, 3), (1, 4)]) [70, 60, 50, 50] >>> total_population(3, 0, [10, 20, 30], []) [10, 20, 30] >>> total_population(2, 1, [10, 20], [(1, 2)]) [30, 30] >>> total_population(3, 3, [5, 5, 5], [(1, 2), (1, 3), (2, 3)]) [15, 15, 15] >>> total_population(5, 2, [1, 2, 3, 4, 5], [(1, 2), (4, 5)]) [3, 3, 3, 9, 9] pass","solution":"def total_population(N, M, populations, bridges): from collections import defaultdict # Create graph representation of the islands and bridges graph = defaultdict(list) for a, b in bridges: graph[a - 1].append(b - 1) graph[b - 1].append(a - 1) # Calculate the total accessible population for each island results = [] for i in range(N): total_population = populations[i] for neighbor in graph[i]: total_population += populations[neighbor] results.append(total_population) return results"},{"question":"def can_complete_circular_route(n: int, fuel: List[int]) -> str: Determine whether it is possible to start at exactly one checkpoint with a full tank of fuel and successfully complete the entire circular route without running out of fuel. Parameters: n (int): The number of checkpoints. fuel (List[int]): A list of integers where each integer denotes the amount of fuel at the corresponding checkpoint. Returns: str: \\"YES\\" if there exists a starting checkpoint from which you can complete the entire circular route, otherwise \\"NO\\". Examples: >>> can_complete_circular_route(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_complete_circular_route(3, [1, 0, 4]) \\"NO\\"","solution":"def can_complete_circular_route(n, fuel): total_fuel = 0 total_cost = 0 current_fuel = 0 start_index = 0 for i in range(n): total_fuel += fuel[i] total_cost += (i + 1) current_fuel += fuel[i] - (i + 1) if current_fuel < 0: start_index = i + 1 current_fuel = 0 if total_fuel >= total_cost: return \\"YES\\" else: return \\"NO\\""},{"question":"def findMaxAverage(nums: List[int], n: int, k: int) -> float: Given an array of integers nums[] of size N, find the maximum average of any contiguous subarray of length k. The result should be calculated to 2 decimal places. >>> findMaxAverage([1, 12, 5, 3, 8, 7], 6, 3) 6.67 >>> findMaxAverage([20, 1, 15, 30], 4, 2) 22.50 def test_example1(): nums = [1, 12, 5, 3, 8, 7] n = 6 k = 3 assert findMaxAverage(nums, n, k) == 6.67 def test_example2(): nums = [20, 1, 15, 30] n = 4 k = 2 assert findMaxAverage(nums, n, k) == 22.50 def test_single_element_array(): nums = [99] n = 1 k = 1 assert findMaxAverage(nums, n, k) == 99.00 def test_two_elements(): nums = [1, 99] n = 2 k = 1 assert findMaxAverage(nums, n, k) == 99.00 def test_all_same_elements(): nums = [5, 5, 5, 5, 5] n = 5 k = 3 assert findMaxAverage(nums, n, k) == 5.00 def test_large_k_value(): nums = [1, 12, 5, 3, 8, 7] n = 6 k = 6 assert findMaxAverage(nums, n, k) == 6.00 # Entire array","solution":"def findMaxAverage(nums, n, k): Returns the maximum average of any contiguous subarray of length k. # Initial sum of the first 'k' elements current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, n): current_sum = current_sum - nums[i - k] + nums[i] if current_sum > max_sum: max_sum = current_sum return round(max_sum / k, 2)"},{"question":"def process_script(script_lines): Processes a script in a specific language and produces appropriate outputs. :param script_lines: List of strings representing the lines in the script. :return: List of results for each valid command. Commands: - PRINT: Followed by a string of characters to be printed. - ADD: Followed by two integers separated by a space, sums the integers. - MULT: Followed by two integers separated by a space, multiplies the integers. Comments start with a \\"#\\" and should be ignored. The script ends with the line \\"END\\". >>> process_script([ ... \\"# This is a comment\\", ... \\"PRINT:Hello, World!\\", ... \\"ADD:4 5\\", ... \\"# This line should be ignored\\", ... \\"MULT:3 4\\", ... \\"END\\" ... ]) [\\"Hello, World!\\", \\"9\\", \\"12\\"] >>> process_script([ ... \\"INVALID:This should be ignored\\", ... \\"PRINT:Valid command\\", ... \\"ADD:10 20\\", ... \\"ADD:Invalid 20\\", ... \\"MULT:5 two\\", ... \\"END\\" ... ]) [\\"Valid command\\", \\"30\\"] >>> process_script([ ... \\"# Just a comment\\", ... \\"# Another comment\\", ... \\"# Yet another comment\\", ... \\"END\\" ... ]) [] >>> process_script([ ... \\" \\", ... \\"PRINT:Hello\\", ... \\"ADD:4 3 \\", ... \\" \\", ... \\"END\\" ... ]) [\\"Hello\\", \\"7\\"] >>> process_script([ ... \\"PRINT:Edge case test\\", ... \\"ADD:0 0\\", ... \\"MULT:-1 -1\\", ... \\"ADD:1000000 1000000\\", ... \\"END\\" ... ]) [\\"Edge case test\\", \\"0\\", \\"1\\", \\"2000000\\"]","solution":"def process_script(script_lines): Processes a script in a specific language and produces appropriate outputs. :param script_lines: List of strings representing the lines in the script. :return: List of results for each valid command. results = [] for line in script_lines: if line.startswith(\\"#\\") or line == \\"END\\": continue command_parts = line.split(\\":\\", 1) if len(command_parts) != 2: continue command, detail = command_parts[0], command_parts[1] if command == \\"PRINT\\": results.append(detail) elif command == \\"ADD\\": try: a, b = map(int, detail.split()) results.append(str(a + b)) except ValueError: continue elif command == \\"MULT\\": try: a, b = map(int, detail.split()) results.append(str(a * b)) except ValueError: continue return results"},{"question":"from typing import List, Tuple def can_robot_reach(N: int, M: int, E: int) -> Tuple[str, int]: Determines if the robot can reach the bottom-right corner (N-1, M-1) of the grid and calculates the minimum energy required. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. E (int): Available energy. Returns: tuple: (a string \\"YES\\" or \\"NO\\", the minimum energy required) >>> can_robot_reach(3, 3, 4) (\\"YES\\", 4) >>> can_robot_reach(2, 2, 2) (\\"YES\\", 2) >>> can_robot_reach(5, 5, 8) (\\"YES\\", 8) >>> can_robot_reach(5, 5, 7) (\\"NO\\", 8) pass def multiple_test_cases(test_cases: List[Tuple[int, int, int]]) -> List[Tuple[str, int]]: Processes multiple test cases to determine if the robot can reach the bottom-right corner and the minimum energy required. Parameters: test_cases (list): A list of tuples where each tuple contains three integers - N, M, E. Returns: list: A list of tuples, each containing the result for a test case. >>> multiple_test_cases([(3, 3, 4), (2, 2, 2), (5, 5, 8), (5, 5, 7), (1, 1, 0), (1, 1000, 999), (1000, 1, 999)]) [(\\"YES\\", 4), (\\"YES\\", 2), (\\"YES\\", 8), (\\"NO\\", 8), (\\"YES\\", 0), (\\"YES\\", 999), (\\"YES\\", 999)] pass","solution":"def can_robot_reach(N, M, E): Determines if the robot can reach the bottom-right corner (N-1, M-1) of the grid and calculates the minimum energy required. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. E (int): Available energy. Returns: tuple: (a string \\"YES\\" or \\"NO\\", the minimum energy required) min_energy_required = (N - 1) + (M - 1) if E >= min_energy_required: return \\"YES\\", min_energy_required else: return \\"NO\\", min_energy_required def multiple_test_cases(test_cases): results = [] for N, M, E in test_cases: result = can_robot_reach(N, M, E) results.append(result) return results"},{"question":"def has_even_sum_pair(A, L, R): Determines if there exists a pair in the subarray A[L:R] whose sum is even. Args: A (list): The array of integers. L (int): The starting index of the subarray. R (int): The ending index of the subarray. Returns: bool: True if there exists a pair whose sum is even, False otherwise. def process_queries(T, test_cases): Processes the input test cases and queries, and determines if there exists a pair in the subarray A[L:R] whose sum is even for each query. Args: T (int): The number of test cases. test_cases (list): A list of tuples, each containing: - An integer N (size of the array A) - A list A of N integers - An integer Q (number of queries) - A list of Q tuples, each containing two integers L and R Returns: list: A list of results for each test case, where each result is a list of strings \\"YES\\" or \\"NO\\" for each query. # Test cases to validate the solution from solution import process_queries, has_even_sum_pair import pytest def test_has_even_sum_pair(): A = [2, 3, 4, 5, 6] assert has_even_sum_pair(A, 1, 3) == True # Subarray [2, 3, 4] -> (2, 4) assert has_even_sum_pair(A, 2, 5) == True # Subarray [3, 4, 5, 6] -> (4, 6) assert has_even_sum_pair(A, 3, 4) == False # Subarray [4, 5] assert has_even_sum_pair(A, 1, 1) == False # Subarray [2] def test_process_queries(): T = 1 test_cases = [ ( 5, [2, 3, 4, 5, 6], 2, [ (1, 3), (2, 5), ] ) ] expected_output = [[\\"YES\\", \\"YES\\"]] assert process_queries(T, test_cases) == expected_output pytest.main()","solution":"def has_even_sum_pair(A, L, R): Determines if there exists a pair in the subarray A[L:R] whose sum is even. Args: A (list): The array of integers. L (int): The starting index of the subarray. R (int): The ending index of the subarray. Returns: bool: True if there exists a pair whose sum is even, False otherwise. subarray = A[L-1:R] even_count = odd_count = 0 for number in subarray: if number % 2 == 0: even_count += 1 else: odd_count += 1 # If the subarray has at least two evens or two odds, then there is an even sum pair return even_count >= 2 or odd_count >= 2 def process_queries(T, test_cases): results = [] for case in test_cases: N, A, Q, queries = case case_results = [] for L, R in queries: if has_even_sum_pair(A, L, R): case_results.append(\\"YES\\") else: case_results.append(\\"NO\\") results.append(case_results) return results"},{"question":"def max_in_range(arr, queries): Returns the maximum integer in the specified range for each query. Args: arr: List of integers. queries: List of tuples, where each tuple contains two integers representing the range (inclusive). Returns: List of maximum integers for each query.","solution":"def max_in_range(arr, queries): Returns the maximum integer in the specified range for each query. Args: arr: List of integers. queries: List of tuples, where each tuple contains two integers representing the range (inclusive). Returns: List of maximum integers for each query. results = [] for (a, b) in queries: max_value = max(arr[a:b+1]) results.append(max_value) return results"},{"question":"from typing import List def max_magical_power(N: int, K: int, J: List[int]) -> int: Returns the maximum magical power by choosing exactly K different jewel types from the list J of jewel counts. >>> max_magical_power(5, 3, [3, 1, 4, 1, 5]) 60 >>> max_magical_power(6, 2, [7, 8, 2, 5, 3, 1]) 56","solution":"from functools import reduce import operator def max_magical_power(N, K, J): Returns the maximum magical power by choosing exactly K different jewel types from the list J of jewel counts. J.sort(reverse=True) chosen_jewels = J[:K] magical_power = reduce(operator.mul, chosen_jewels, 1) return magical_power"},{"question":"def reverse_words(s: str) -> str: Returns a new string with the words in reverse order. Words in the input string are separated by single spaces. The function takes care of leading, trailing, and multiple spaces. # your code here # Unit tests def test_reverse_single_word(): assert reverse_words(\\"word\\") == \\"word\\" def test_reverse_two_words(): assert reverse_words(\\"hello world\\") == \\"world hello\\" def test_reverse_multiple_words(): assert reverse_words(\\"this is a test\\") == \\"test a is this\\" def test_reverse_with_leading_space(): assert reverse_words(\\" hello world\\") == \\"world hello\\" def test_reverse_with_trailing_space(): assert reverse_words(\\"hello world \\") == \\"world hello\\" def test_reverse_with_multiple_spaces(): assert reverse_words(\\" hello world this is a test \\") == \\"test a is this world hello\\" def test_reverse_empty_string(): assert reverse_words(\\"\\") == \\"\\" def test_reverse_only_spaces(): assert reverse_words(\\" \\") == \\"\\"","solution":"def reverse_words(s: str) -> str: Returns a new string with the words in reverse order. Words in the input string are separated by single spaces. The function takes care of leading, trailing, and multiple spaces. if not s: return \\"\\" words = [] start = 0 length = len(s) while start < length: while start < length and s[start] == ' ': start += 1 if start >= length: break end = start + 1 while end < length and s[end] != ' ': end += 1 words.append(s[start:end]) start = end + 1 return ' '.join(words[::-1])"},{"question":"def minChangesToStrictlyIncreasing(N: int, Arr: List[int]) -> int: Given an array of integers, determine the smallest number of changes needed to make the array a strictly increasing sequence. A change can be either incrementing or decrementing an element by 1. >>> minChangesToStrictlyIncreasing(5, [1, 5, 3, 6, 7]) 1 >>> minChangesToStrictlyIncreasing(4, [9, 7, 5, 10]) 2","solution":"def minChangesToStrictlyIncreasing(N, Arr): def lis(arr): from bisect import bisect_left dp = [] for num in arr: pos = bisect_left(dp, num) if pos == len(dp): dp.append(num) else: dp[pos] = num return len(dp) lis_length = lis(Arr) return N - lis_length"},{"question":"def find_median(n: int, items: List[int]) -> int: Returns the median number of items among the different types in the store. >>> find_median(5, [10, 3, 4, 7, 6]) == 6 >>> find_median(4, [20, 15, 7, 12]) == 12 >>> find_median(1, [5]) == 5 >>> find_median(3, [2, 2, 2]) == 2 >>> find_median(5, [1, 2, 3, 4, 5]) == 3 >>> find_median(4, [10, 8, 6, 4]) == 6","solution":"def find_median(n, items): Returns the median number of items among the different types in the store. # Sort the items first items.sort() mid_index = n // 2 # If n is odd, return the middle element if n % 2 == 1: return items[mid_index] else: return items[mid_index - 1]"},{"question":"from typing import List, Tuple def sort_items(items: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sort a list of items by their quantity in descending order. If two items have the same quantity, sort them by their name in ascending alphabetical order. Args: items (List[Tuple[str, int]]): List of tuples where each tuple contains an item's name (string) and its quantity (integer) Returns: List[Tuple[str, int]]: Sorted list of items pass # Unit tests def test_single_item(): items = [(\\"apple\\", 5)] expected = [(\\"apple\\", 5)] assert sort_items(items) == expected def test_descending_order(): items = [(\\"banana\\", 2), (\\"apple\\", 5), (\\"orange\\", 5), (\\"grape\\", 3)] expected = [(\\"orange\\", 5), (\\"apple\\", 5), (\\"grape\\", 3), (\\"banana\\", 2)] assert sort_items(items) == expected def test_same_quantity_different_names(): items = [(\\"melon\\", 3), (\\"apple\\", 3), (\\"banana\\", 3)] expected = [(\\"apple\\", 3), (\\"banana\\", 3), (\\"melon\\", 3)] assert sort_items(items) == expected def test_empty_list(): items = [] expected = [] assert sort_items(items) == expected def test_names_with_same_initial(): items = [(\\"apple\\", 3), (\\"apricot\\", 3)] expected = [(\\"apple\\", 3), (\\"apricot\\", 3)] assert sort_items(items) == expected def test_numerous_mixed_items(): items = [(\\"apple\\", 1), (\\"banana\\", 4), (\\"orange\\", 2), (\\"grape\\", 5), (\\"cherry\\", 3)] expected = [(\\"grape\\", 5), (\\"banana\\", 4), (\\"cherry\\", 3), (\\"orange\\", 2), (\\"apple\\", 1)] assert sort_items(items) == expected","solution":"from typing import List, Tuple def sort_items(items: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sort a list of items by their quantity in descending order. If two items have the same quantity, sort them by their name in ascending alphabetical order. Args: items (List[Tuple[str, int]]): List of tuples where each tuple contains an item's name (string) and its quantity (integer) Returns: List[Tuple[str, int]]: Sorted list of items # Sort the list using sorted() with a custom key return sorted(items, key=lambda item: (-item[1], item[0]))"},{"question":"from collections import defaultdict def manage_figurines(n: int, q: int, figurines: List[Tuple[int, int]], requests: List[Union[Tuple[int, int, int], Tuple[int, int, int, int]]]) -> List[int]: Manages Alice's figurine collection by processing various requests to add, remove, or count figurines. Args: n: Initial number of figurines. q: Number of requests. figurines: List of tuples, where each tuple represents a figurine with its size and color. requests: List of requests. Each request can be of type 1 (add figurines), type 2 (remove figurines), or type 3 (count figurines). Returns: A list of integers representing the results of type 3 requests. Example: >>> manage_figurines(5, 5, [(1, 2), (2, 3), (3, 2), (4, 3), (5, 2)], [(3, 2, 3), (1, 2, 6, 2), (3, 6, 2), (2, 1, 2, 3), (3, 2, 3)]) [1, 2, 0] import pytest def test_case1(): n = 5 q = 5 figurines = [(1, 2), (2, 3), (3, 2), (4, 3), (5, 2)] requests = [ (3, 2, 3), (1, 2, 6, 2), (3, 6, 2), (2, 1, 2, 3), (3, 2, 3) ] assert manage_figurines(n, q, figurines, requests) == [1, 2, 0] def test_case2(): n = 3 q = 4 figurines = [(1, 1), (2, 2), (3, 3)] requests = [ (3, 3, 3), (1, 2, 3, 3), (3, 3, 3), (2, 1, 3, 3) ] assert manage_figurines(n, q, figurines, requests) == [1, 3] def test_case3(): n = 6 q = 3 figurines = [(1, 1), (1, 1), (2, 2), (2, 2), (2, 2), (3, 3)] requests = [ (3, 1, 1), (3, 2, 2), (3, 3, 3), ] assert manage_figurines(n, q, figurines, requests) == [2, 3, 1] def test_case4(): n = 2 q = 2 figurines = [(4, 4), (5, 5)] requests = [ (1, 3, 4, 4), (3, 4, 4) ] assert manage_figurines(n, q, figurines, requests) == [4] def test_case5(): n = 3 q = 2 figurines = [(6, 7), (7, 8), (8, 9)] requests = [ (2, 1, 6, 7), (3, 6, 7) ] assert manage_figurines(n, q, figurines, requests) == [0] @pytest.mark.parametrize(\\"n, q, figurines, requests, expected\\", [ (5, 5, [(1, 2), (2, 3), (3, 2), (4, 3), (5, 2)], [(3, 2, 3), (1, 2, 6, 2), (3, 6, 2), (2, 1, 2, 3), (3, 2, 3)], [1, 2, 0]), (3, 4, [(1, 1), (2, 2), (3, 3)], [(3, 3, 3), (1, 2, 3, 3), (3, 3, 3), (2, 1, 3, 3)], [1, 3]), (6, 3, [(1, 1), (1, 1), (2, 2), (2, 2), (2, 2), (3, 3)], [(3, 1, 1), (3, 2, 2), (3, 3, 3)], [2, 3, 1]) ]) def test_parametrized(n, q, figurines, requests, expected): assert manage_figurines(n, q, figurines, requests) == expected","solution":"from collections import defaultdict def manage_figurines(n, q, figurines, requests): # a dictionary that counts the figurines collection = defaultdict(int) # populate the initial collection for s, c in figurines: collection[(s, c)] += 1 result = [] # process the requests for request in requests: if request[0] == 1: # add k figurines of size s and color c _, k, s, c = request collection[(s, c)] += k elif request[0] == 2: # remove k figurines of size s and color c _, k, s, c = request collection[(s, c)] -= k elif request[0] == 3: # count figurines of size s and color c _, s, c = request result.append(collection[(s, c)]) return result"},{"question":"def merge_sort(arr): Function to implement merge sort algorithm on an array. def sort_array(n, array): Given an array of n integers, sort the elements in non-decreasing order using the merge sort algorithm. >>> sort_array(8, [38, 27, 43, 3, 9, 82, 10, -5]) \\"-5 3 9 10 27 38 43 82\\" >>> sort_array(5, [5, 2, 9, 1, 5, 6]) \\"1 2 5 5 6 9\\" >>> sort_array(3, [3, -1, -2]) \\"-2 -1 3\\" >>> sort_array(1, [1]) \\"1\\" >>> sort_array(10, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) \\"1 2 3 4 5 6 7 8 9 10\\" >>> sort_array(6, [4, 2, 8, -3, 7, 0]) \\"-3 0 2 4 7 8\\" >>> sort_array(0, []) \\"\\"","solution":"def merge_sort(arr): Function to implement merge sort algorithm on an array. if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 def sort_array(n, array): Function to handle input and output for the merge sort problem. merge_sort(array) return \\" \\".join(map(str, array))"},{"question":"def magical_trees_sum(N, Q, values, queries): Calculate the sum of the magical values of trees in given ranges. Args: N (int): The number of Magical Trees. Q (int): The number of queries. values (List[int]): A list of integers representing the initial magical values of the trees. queries (List[Tuple[int, int]]): A list of tuples, each containing two integers L and R, representing the range [L, R] for each query. Returns: List[int]: A list of integers, each representing the sum of the values of the trees in the given range for each query. >>> magical_trees_sum(5, 3, [4, 2, 7, 3, 1], [(1, 3), (2, 4), (1, 5)]) [13, 12, 17] >>> magical_trees_sum(5, 1, [4, 2, 7, 3, 1], [(1, 5)]) [17] >>> magical_trees_sum(1, 1, [0], [(1, 1)]) [0] >>> magical_trees_sum(100000, 1, [10000] * 100000, [(1, 100000)]) [1000000000] >>> magical_trees_sum(5, 2, [1, 2, 3, 4, 5], [(1, 2), (4, 5)]) [3, 9]","solution":"def magical_trees_sum(N, Q, values, queries): # Create a prefix sum array prefix_sum = [0] * (N + 1) for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + values[i - 1] # Processing each query and returning results results = [] for L, R in queries: sum_query = prefix_sum[R] - prefix_sum[L - 1] results.append(sum_query) return results"},{"question":"def can_plant_flowers(grid) -> str: The Wizard Academy has a magical garden that is divided into an N x N grid. Each cell in the grid can either contain a plant ('P'), a rock ('R'), or can be empty ('.'). The Academy wants to plant flowers in all empty cells while ensuring that every plant ('P') has at least one adjacent flower and every rock ('R') has no adjacent flowers. Flowers can only be placed in empty cells ('.'). For example: >>> can_plant_flowers([ ... list('P.R'), ... list('.R.'), ... list('...') ... ]) 'YESnPFRnFRFnFFF' >>> can_plant_flowers([ ... list('PP'), ... list('PP') ... ]) 'NO' pass from solution import can_plant_flowers def test_case_1(): grid = [ list(\\"P.R\\"), list(\\".R.\\"), list(\\"...\\") ] result = can_plant_flowers(grid) expected = \\"YESnPFRnFRFnFFF\\" assert result == expected def test_case_2(): grid = [ list(\\"PP\\"), list(\\"PP\\") ] result = can_plant_flowers(grid) expected = \\"NO\\" assert result == expected def test_case_3(): grid = [ list(\\"P..P\\"), list(\\"....\\"), list(\\"....\\"), list(\\"P..P\\") ] result = can_plant_flowers(grid) expected = \\"YESnPFFPnFFFFnFFFFnPFFP\\" assert result == expected def test_case_4(): grid = [ list(\\"R.\\"), list(\\".R\\") ] result = can_plant_flowers(grid) expected = \\"YESnRFnFR\\" assert result == expected def test_case_5(): grid = [ list(\\"P.P\\"), list(\\"R.R\\"), list(\\"P.P\\") ] result = can_plant_flowers(grid) expected = \\"YESnPFPnRFRnPFP\\" assert result == expected","solution":"def can_plant_flowers(grid): N = len(grid) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < N and 0 <= y < N def ensure_flower_around_plant(x, y): for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and grid[nx][ny] == '.': return True return False def place_flower(x, y): for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and grid[nx][ny] == '.': grid[nx][ny] = 'F' for i in range(N): for j in range(N): if grid[i][j] == 'P' and not ensure_flower_around_plant(i, j): return \\"NO\\" for i in range(N): for j in range(N): if grid[i][j] == 'P': place_flower(i, j) for i in range(N): for j in range(N): if grid[i][j] == '.': grid[i][j] = 'F' return \\"YESn\\" + \\"n\\".join(\\"\\".join(row) for row in grid) # Example usage (without input reading): # grid = [ # list(\\"P.R\\"), # list(\\".R.\\"), # list(\\"...\\") # ] # print(can_plant_flowers(grid))"},{"question":"from typing import List def longest_distinct_subarray_length(sessions: List[List[int]]) -> List[int]: Given a list of user sessions, determines the length of the longest sequence of distinct songs for each session. Args: sessions (List[List[int]]): A list of user sessions, each represented by a list of song IDs. Returns: List[int]: A list of integers representing the length of the longest contiguous subarray of distinct song IDs for each session. Example: >>> longest_distinct_subarray_length([[1, 2, 1, 3, 4, 2, 3]]) [4] >>> longest_distinct_subarray_length([[5, 5, 5, 5]]) [1] >>> longest_distinct_subarray_length([[1, 2, 3, 4, 5]]) [5] # Unit tests def test_single_session(): assert longest_distinct_subarray_length([[1, 2, 1, 3, 4, 2, 3]]) == [4] def test_multiple_sessions(): sessions = [ [1, 2, 1, 3, 4, 2, 3], [5, 5, 5, 5] ] assert longest_distinct_subarray_length(sessions) == [4, 1] def test_all_distinct_songs(): assert longest_distinct_subarray_length([[1, 2, 3, 4, 5]]) == [5] def test_all_same_songs(): assert longest_distinct_subarray_length([[7, 7, 7, 7]]) == [1] def test_empty_session(): assert longest_distinct_subarray_length([[]]) == [0] def test_mixed_sessions(): sessions = [ [2, 3, 5, 2, 4, 3, 5, 6], [8, 8, 9, 9, 9, 8], [], [6, 7, 8, 6] ] assert longest_distinct_subarray_length(sessions) == [5, 2, 0, 3]","solution":"def longest_distinct_subarray_length(sessions): Given a list of user sessions, determines the length of the longest sequence of distinct songs for each session. def longest_distinct_subarray(session): song_set = set() left = 0 max_length = 0 for right in range(len(session)): while session[right] in song_set: song_set.remove(session[left]) left += 1 song_set.add(session[right]) max_length = max(max_length, right - left + 1) return max_length return [longest_distinct_subarray(session) for session in sessions] # Example usage sessions = [ [1, 2, 1, 3, 4, 2, 3], [5, 5, 5, 5] ] print(longest_distinct_subarray_length(sessions))"},{"question":"def isValidSudoku(board) -> bool: Checks if a given 2D array is a valid Sudoku board. >>> isValidSudoku([ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ]) == True >>> isValidSudoku([ [\\"8\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ]) == False","solution":"def isValidSudoku(board): Checks if a given 2D array is a valid Sudoku board. def is_valid_unit(unit): unit = [x for x in unit if x != '.'] return len(unit) == len(set(unit)) def is_valid_line(board): for line in board: if not is_valid_unit(line): return False return True def is_valid_col(board): for col in zip(*board): if not is_valid_unit(col): return False return True def is_valid_square(board): for i in (0, 3, 6): for j in (0, 3, 6): square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)] if not is_valid_unit(square): return False return True return is_valid_line(board) and is_valid_col(board) and is_valid_square(board)"},{"question":"def is_k_palindrome(s: str, k: int) -> bool: Given a string s and an integer k, find out if the string can be made into a k-palindrome. A k-palindrome is a string that becomes a palindrome if at most k characters are removed from it. Examples: >>> is_k_palindrome(\\"abcdecba\\", 1) True >>> is_k_palindrome(\\"abcdba\\", 2) True >>> is_k_palindrome(\\"abcdef\\", 2) False from typing import List def test_is_k_palindrome_true_1(): assert is_k_palindrome(\\"abcdecba\\", 1) == True def test_is_k_palindrome_true_2(): assert is_k_palindrome(\\"abcdba\\", 2) == True def test_is_k_palindrome_false(): assert is_k_palindrome(\\"abcdef\\", 2) == False def test_is_k_palindrome_empty_string(): assert is_k_palindrome(\\"\\", 0) == True def test_is_k_palindrome_all_same_characters(): assert is_k_palindrome(\\"aaaaa\\", 0) == True def test_is_k_palindrome_palindrome_string(): assert is_k_palindrome(\\"racecar\\", 0) == True def test_is_k_palindrome_no_removal_needed(): assert is_k_palindrome(\\"abcba\\", 0) == True def test_is_k_palindrome_one_char_removal(): assert is_k_palindrome(\\"abca\\", 1) == True","solution":"def is_k_palindrome(s, k): Returns True if the string s can be made into a k-palindrome, otherwise False. def longest_common_subsequence(s1, s2): m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] n = len(s) reverse_s = s[::-1] lcs_length = longest_common_subsequence(s, reverse_s) return (n - lcs_length) <= k"},{"question":"def can_segment_string(S: str, L: List[str]) -> str: Determine if the string S can be segmented into a space-separated sequence of one or more dictionary words from L. >>> can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == \\"YES\\" >>> can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == \\"YES\\" >>> can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == \\"NO\\"","solution":"def can_segment_string(S, L): Determine if the string S can be segmented into a space-separated sequence of one or more dictionary words from L. word_set = set(L) dp = [False] * (len(S) + 1) dp[0] = True for i in range(1, len(S) + 1): for j in range(i): if dp[j] and S[j:i] in word_set: dp[i] = True break return \\"YES\\" if dp[len(S)] else \\"NO\\""},{"question":"def max_scare_factor(n: int, scare_factors: List[int]) -> int: This function returns the maximum possible sum of scare factors for any valid contiguous subset of haunted houses. :param n: The number of haunted houses :param scare_factors: A list of integers representing the scare factors of the haunted houses :return: The maximum possible sum of scare factors for any valid contiguous subset pass # Unit tests def test_single_house(): assert max_scare_factor(1, [5]) == 5 assert max_scare_factor(1, [-5]) == -5 def test_all_positive(): assert max_scare_factor(5, [1, 2, 3, 4, 5]) == 15 def test_all_negative(): assert max_scare_factor(4, [-1, -2, -3, -4]) == -1 def test_containing_zero(): assert max_scare_factor(5, [1, -2, 3, 0, 2]) == 5 def test_complex_case(): assert max_scare_factor(5, [2, -1, 3, 7, -5]) == 11 assert max_scare_factor(4, [-3, -2, -1, 4]) == 4 def test_large_positive_and_negative(): assert max_scare_factor(6, [10000, -10000, 10000, -10000, 10000, -10000]) == 10000 assert max_scare_factor(6, [-10000, 10000, -10000, 10000, -10000, 10000]) == 10000 def test_mixed_sign_elements(): assert max_scare_factor(7, [-2, -3, 4, -1, 2, 1, -5]) == 6","solution":"def max_scare_factor(n, scare_factors): This function returns the maximum possible sum of scare factors for any valid contiguous subset of haunted houses. if n == 0: return 0 max_sum = float('-inf') current_sum = 0 last_valid_sum = float('-inf') for i in range(n): if i == 0 or scare_factors[i-1] + scare_factors[i] > 0: current_sum = max(current_sum + scare_factors[i], scare_factors[i]) else: current_sum = scare_factors[i] max_sum = max(max_sum, current_sum) last_valid_sum = current_sum if scare_factors[i] > 0 else float('-inf') return max_sum"},{"question":"def max_population(n: int, h: int, growth_rates: List[int]) -> int: Calculate the maximum possible population of the bacteria after h hours given the initial population and a list of percentage growth rates. Args: n (int): Initial population of the bacteria. h (int): Number of hours. growth_rates (list of int): List of percentage growth rates for each hour. Returns: int: Maximum possible population of the bacteria after h hours. # Test Cases from solution import max_population def test_max_population_example(): assert max_population(5, 3, [120, 80, 150]) == 7 def test_max_population_constant_growth(): assert max_population(5, 3, [100, 100, 100]) == 5 def test_max_population_increased_growth(): assert max_population(5, 3, [150, 150, 150]) == 16 def test_max_population_decreased_growth(): assert max_population(5, 3, [80, 80, 80]) == 2 def test_max_population_mixed_growth(): assert max_population(10, 4, [110, 90, 120, 100]) == 11 def test_max_population_single_hour(): assert max_population(100, 1, [150]) == 150 def test_max_population_min_values(): assert max_population(1, 1, [50]) == 0 def test_max_population_max_values(): assert max_population(100, 100, [100] * 100) == 100","solution":"def max_population(n, h, growth_rates): Calculate the maximum possible population of the bacteria after h hours given the initial population and a list of percentage growth rates. Args: n (int): Initial population of the bacteria. h (int): Number of hours. growth_rates (list of int): List of percentage growth rates for each hour. Returns: int: Maximum possible population of the bacteria after h hours. population = n for rate in growth_rates: population *= rate / 100.0 return int(population)"},{"question":"def minimal_total_distance(test_cases): Given multiple test cases, returns a list of minimal total distances the delivery truck needs to travel to complete its delivery route for each test case. :param test_cases: List of tuples, each containing: - N (number of houses) - positions (list of positions of houses in non-decreasing order) - packages (list of number of packages needed by each house) :return: List of integers representing the minimal distances for each test case pass from solution import minimal_total_distance def test_minimal_total_distance(): test_cases = [ (3, [1, 3, 6], [4, 2, 1]), (4, [2, 7, 9, 15], [3, 5, 2, 1]), (2, [1, 5], [10, 20]), (5, [1, 2, 3, 4, 10], [5, 1, 2, 1, 3]), (4, [2, 4, 6, 8], [1, 1, 1, 1]) ] expected_results = [ 5, # 1 -> 3 -> 6 13, # 2 -> 7 -> 9 -> 15 4, # 1 -> 5 9, # 1 -> 2 -> 3 -> 4 -> 10 6 # 2 -> 4 -> 6 -> 8 ] results = minimal_total_distance(test_cases) assert results == expected_results, f\\"Expected {expected_results} but got {results}\\"","solution":"def minimal_total_distance(test_cases): Given multiple test cases, returns a list of minimal total distances the delivery truck needs to travel to complete its delivery route for each test case. :param test_cases: List of tuples, each containing: - N (number of houses) - positions (list of positions of houses in non-decreasing order) - packages (list of number of packages needed by each house) :return: List of integers representing the minimal distances for each test case results = [] for case in test_cases: N, positions, packages = case # Calculate the travel distance total_distance = 0 for i in range(1, N): total_distance += abs(positions[i] - positions[i-1]) results.append(total_distance) return results"},{"question":"def smallest_x_to_make_sum_even(arr): Given an array of integers, find the smallest integer x such that the sum of the array becomes even after adding x. Parameters: arr (List[int]): An array of integers Returns: int: The smallest integer x such that the sum of the array becomes even Examples: >>> smallest_x_to_make_sum_even([1, 3, 5]) 1 >>> smallest_x_to_make_sum_even([2, 4, 6, 8]) 0 >>> smallest_x_to_make_sum_even([7, 8]) 1 from solution import smallest_x_to_make_sum_even def test_sum_even(): arr = [2, 4, 6, 8] assert smallest_x_to_make_sum_even(arr) == 0 def test_sum_odd(): arr = [1, 3, 5] assert smallest_x_to_make_sum_even(arr) == 1 def test_mixed_numbers(): arr = [7, 8] assert smallest_x_to_make_sum_even(arr) == 1 def test_single_element_even(): arr = [10] assert smallest_x_to_make_sum_even(arr) == 0 def test_single_element_odd(): arr = [3] assert smallest_x_to_make_sum_even(arr) == 1 def test_large_numbers(): arr = [10000, -10001] assert smallest_x_to_make_sum_even(arr) == 1 def test_all_negatives_even(): arr = [-2, -4, -6] assert smallest_x_to_make_sum_even(arr) == 0 def test_all_negatives_odd(): arr = [-1, -3, -5] assert smallest_x_to_make_sum_even(arr) == 1","solution":"def smallest_x_to_make_sum_even(arr): Given an array of integers, find the smallest integer x such that the sum of the array becomes even after adding x. sum_of_arr = sum(arr) # If the sum of the array is even, return 0 if sum_of_arr % 2 == 0: return 0 # If the sum of the array is odd, return 1 else: return 1"},{"question":"def maxUniqueSubarray(nums, k): Returns the maximum number of unique integers among all contiguous subarrays of length k. >>> maxUniqueSubarray([1, 2, 1, 2, 3, 4, 5], 3) 3 >>> maxUniqueSubarray([1, 1, 1, 1, 1], 2) 1 >>> maxUniqueSubarray([1, 2, 3, 4, 5, 6], 4) 4 >>> maxUniqueSubarray([5, 5, 5, 5, 5, 6, 6, 7], 2) 2","solution":"def maxUniqueSubarray(nums, k): Returns the maximum number of unique integers among all contiguous subarrays of length k. if not nums or k <= 0 or k > len(nums): return 0 unique_counts = {} max_unique = 0 for i in range(len(nums)): if nums[i] in unique_counts: unique_counts[nums[i]] += 1 else: unique_counts[nums[i]] = 1 # Remove the element that's out of the sliding window if i >= k: if unique_counts[nums[i - k]] == 1: del unique_counts[nums[i - k]] else: unique_counts[nums[i - k]] -= 1 # Update maximum unique count once we have a full window if i >= k - 1: max_unique = max(max_unique, len(unique_counts)) return max_unique"},{"question":"def SingleNumber(A): Returns the single element in the array where every element appears twice except for one. >>> SingleNumber([2, 3, 5, 2, 3]) == 5 >>> SingleNumber([1, 4, 1, 6, 4, 7, 6]) == 7 >>> SingleNumber([6, 1, 2, 6, 2, 3, 1]) == 3 >>> SingleNumber([42]) == 42 >>> SingleNumber([0, 1, 0, 1, 10]) == 10 >>> SingleNumber(list(range(0, 1000000, 2)) * 2 + [999999]) == 999999","solution":"def SingleNumber(A): Returns the single element in the array where every element appears twice except for one. single_element = 0 for num in A: single_element ^= num return single_element"},{"question":"def compute_total_score(points, solved_indices): Returns the total score based on the points for each problem and the indices of solved problems. :param points: List of integers representing points for each problem. :param solved_indices: List of integers representing indices of solved problems. :return: Integer representing total score. pass def test_example_1(): points = [10, 20, 30, 40, 50] solved_indices = [1, 3, 5] assert compute_total_score(points, solved_indices) == 90 def test_example_2(): points = [25, 50, 75, 100] solved_indices = [2, 4] assert compute_total_score(points, solved_indices) == 150 def test_example_3(): points = [15, 25, 40] solved_indices = [] assert compute_total_score(points, solved_indices) == 0 def test_no_problems_solved(): points = [5, 10, 15, 20] solved_indices = [] assert compute_total_score(points, solved_indices) == 0 def test_all_problems_solved(): points = [5, 10, 15] solved_indices = [1, 2, 3] assert compute_total_score(points, solved_indices) == 30 def test_single_problem_solved(): points = [8, 16, 24] solved_indices = [2] assert compute_total_score(points, solved_indices) == 16 def test_last_problem_solved(): points = [7, 14, 21, 28] solved_indices = [4] assert compute_total_score(points, solved_indices) == 28","solution":"def compute_total_score(points, solved_indices): Returns the total score based on the points for each problem and the indices of solved problems. :param points: List of integers representing points for each problem. :param solved_indices: List of integers representing indices of solved problems. :return: Integer representing total score. return sum(points[i - 1] for i in solved_indices)"},{"question":"from typing import List, Tuple def longest_substring_with_k_chars(T: int, cases: List[Tuple[Tuple[int, int], str]]) -> List[int]: Given a string S of length N and a number K, find the length of the longest substring of S that contains at most K different characters. :param T: Number of test cases :param cases: A list of tuples, each containing (N, K) and string S :return: A list of integers representing the length of the longest substring for each test case >>> longest_substring_with_k_chars(2, [[(7, 2), \\"abaaccb\\"], [(5, 1), \\"abcde\\"]]) [4, 1] >>> longest_substring_with_k_chars(1, [[(10, 3), \\"aaabbbcccddd\\"]]) [9]","solution":"def longest_substring_with_k_chars(T, cases): from collections import defaultdict results = [] for i in range(T): N, K = cases[i][0] S = cases[i][1] # Dictionary to keep track of character count in current window char_count = defaultdict(int) max_length = 0 left = 0 # Sliding window technique for right in range(N): char_count[S[right]] += 1 # If more than K distinct characters, shrink the window from the left while len(char_count) > K: char_count[S[left]] -= 1 if char_count[S[left]] == 0: del char_count[S[left]] left += 1 max_length = max(max_length, right - left + 1) results.append(max_length) return results"},{"question":"def min_rectangular_subgrids(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of rectangular subgrids needed so that each subgrid has cells of the same color. Args: n : int - number of rows in the grid. m : int - number of columns in the grid. grid : List[str] - the grid of cells, where each cell is 'B' or 'W'. Returns: int - the minimum number of rectangular subgrids needed. Example: >>> min_rectangular_subgrids(3, 3, [\\"BBB\\", \\"WWW\\", \\"BBB\\"]) 3 >>> min_rectangular_subgrids(4, 4, [\\"BWBW\\", \\"WBWB\\", \\"BWBW\\", \\"WBWB\\"]) 16 >>> min_rectangular_subgrids(2, 2, [\\"BB\\", \\"BB\\"]) 1 pass","solution":"def min_rectangular_subgrids(n, m, grid): Determine the minimum number of rectangular subgrids needed so that each subgrid has cells of the same color. Args: n: int - number of rows in the grid. m: int - number of columns in the grid. grid: list of strings - the grid of cells, where each cell is 'B' or 'W'. Returns: int - the minimum number of rectangular subgrids needed. def dfs(i, j, color): stack = [(i, j)] while stack: x, y = stack.pop() for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == color and not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) visited = [[False]*m for _ in range(n)] subgrids_count = 0 for i in range(n): for j in range(m): if not visited[i][j]: visited[i][j] = True subgrids_count += 1 dfs(i, j, grid[i][j]) return subgrids_count"},{"question":"def product_except_self(nums): Given an array of integers, return a new array where each element at index \`i\` is the product of all the numbers in the original array except the one at \`i\`. Solve this without using division and in O(n) time complexity. Args: nums (List[int]): List of integers. Returns: List[int]: Newly generated array based on the given conditions. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 3]) [6, 3, 2] >>> product_except_self([9, 0]) [0, 9] from solution import product_except_self def test_example1(): assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] def test_example2(): assert product_except_self([1, 2, 3]) == [6, 3, 2] def test_example3(): assert product_except_self([9, 0]) == [0, 9] def test_single_element(): assert product_except_self([5]) == [1] def test_all_zeros(): assert product_except_self([0, 0, 0]) == [0, 0, 0] def test_with_negative_numbers(): assert product_except_self([1, -2, -3, 4]) == [24, -12, -8, 6] def test_mixed_numbers(): assert product_except_self([0, -1, 2, -3]) == [6, 0, 0, 0] def test_large_array(): arr = [i for i in range(1, 1001)] expected = [] product = 1 for i in range(1, 1001): product *= i for i in range(1, 1001): expected.append(product // i) assert product_except_self(arr) == expected","solution":"def product_except_self(nums): n = len(nums) if n == 0: return [] # Initialize the left and right arrays left_products = [1] * n right_products = [1] * n # Compute the left products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Compute the right products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Construct the result array result = [0] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def count_days_meeting_goal(N: int, G: int, steps: List[int]) -> int: Counts how many days Chef met or exceeded his step goal. Parameters: N (int): The number of days Chef recorded his steps. G (int): The daily step goal. steps (list of int): List of steps taken each day. Returns: int: Number of days Chef met or exceeded the step goal. >>> count_days_meeting_goal(5, 10000, [12000, 8000, 15000, 10000, 9000]) 3 >>> count_days_meeting_goal(3, 5000, [3000, 5000, 7000]) 2 >>> count_days_meeting_goal(4, 7000, [7100, 7200, 7000, 8000]) 4 >>> count_days_meeting_goal(4, 7000, [6900, 6800, 6500, 6000]) 0 >>> count_days_meeting_goal(6, 10000, [12000, 15000, 10000, 9999, 0, 10001]) 4","solution":"def count_days_meeting_goal(N, G, steps): Counts how many days Chef met or exceeded his step goal. Parameters: N (int): The number of days Chef recorded his steps. G (int): The daily step goal. steps (list of int): List of steps taken each day. Returns: int: Number of days Chef met or exceeded the step goal. return sum(1 for step in steps if step >= G)"},{"question":"def count_good_subsequences(arr: List[int], d: int) -> int: Counts the number of good subsequences in \`arr\` that have a sum divisible by \`d\`. >>> count_good_subsequences([1, 2, 3, 4, 5], 5) == 8 >>> count_good_subsequences([1, 2, 3], 3) == 4 >>> count_good_subsequences([1, 2], 2) == 2 >>> count_good_subsequences([10], 10) == 2 >>> count_good_subsequences([1, 1, 1], 2) == 4 >>> count_good_subsequences([3, 3, 3], 3) == 8 pass def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Processes multiple test cases and returns the results for each. >>> test_process_test_cases([(5, 5, [1, 2, 3, 4, 5]), (3, 3, [1, 2, 3]), (2, 2, [1, 2]), (1, 10, [10]), (3, 2, [1, 1, 1]), (3, 3, [3, 3, 3])]) [8, 4, 2, 2, 4, 8] pass def main(): Main function to read input and produce output. pass","solution":"def count_good_subsequences(arr, d): Counts the number of good subsequences in \`arr\` that have a sum divisible by \`d\`. n = len(arr) dp = [0] * d dp[0] = 1 # There's one way to have a sum of 0: the empty subsequence for num in arr: new_dp = dp[:] for k in range(d): new_dp[(k + num) % d] += dp[k] dp = new_dp return dp[0] def process_test_cases(test_cases): results = [] for n, d, arr in test_cases: results.append(count_good_subsequences(arr, d)) return results # Function to read input and produce output def main(): t = int(input()) test_cases = [] for _ in range(t): n = int(input()) d = int(input()) arr = list(map(int, input().split())) test_cases.append((n, d, arr)) results = process_test_cases(test_cases) for result in results: print(result) # Uncomment the following line if running locally to read input from the user # main()"},{"question":"def is_die_fair(n: int, rolls: List[int]) -> str: Determines whether a die can be considered fair based on the outcomes of multiple rolls. Each number from 1 to 6 should appear close to 1/6th of the time, with a tolerance of ±0.2 times the ideal count. :param n: Integer representing the number of rolls. :param rolls: List of integers representing the outcomes of each die roll. :return: \\"FAIR\\" if the die is considered fair, \\"UNFAIR\\" otherwise. >>> is_die_fair(6, [1, 2, 3, 4, 5, 6]) \\"FAIR\\" >>> is_die_fair(18, [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]) \\"FAIR\\" >>> is_die_fair(12, [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4]) \\"UNFAIR\\" pass def check_dice_fairness(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Checks the fairness of multiple die based on the given test cases. :param test_cases: List of tuples, where each tuple contains an integer representing the number of rolls and a list of integers representing the outcomes. :return: List of strings, each being \\"FAIR\\" or \\"UNFAIR\\" for the corresponding test case. >>> check_dice_fairness([(6, [1, 2, 3, 4, 5, 6]), (18, [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]), (12, [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4])]) [\\"FAIR\\", \\"FAIR\\", \\"UNFAIR\\"] pass","solution":"def is_die_fair(n, rolls): ideal_count = n / 6 min_count = ideal_count - 0.2 * ideal_count max_count = ideal_count + 0.2 * ideal_count count_dict = {i: 0 for i in range(1, 7)} for roll in rolls: count_dict[roll] += 1 for count in count_dict.values(): if count < min_count or count > max_count: return \\"UNFAIR\\" return \\"FAIR\\" def check_dice_fairness(test_cases): results = [] for case in test_cases: n, rolls = case results.append(is_die_fair(n, rolls)) return results"},{"question":"from typing import List, Tuple def preprocess_array(arr: List[int]) -> List[int]: Preprocess the array to create a prefix sum array. pass def query_sum(prefix_sum: List[int], L: int, R: int) -> int: Returns the sum of the subarray from L to R (inclusive) using the prefix sum array. L and R are 1-based indices. pass def process_queries(N: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process all the queries using preprocessing for efficiency. pass def test_preprocess_array(): assert preprocess_array([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10, 15] def test_query_sum(): prefix_sum = preprocess_array([1, 2, 3, 4, 5]) assert query_sum(prefix_sum, 1, 3) == 6 assert query_sum(prefix_sum, 2, 4) == 9 assert query_sum(prefix_sum, 1, 5) == 15 def test_process_queries(): arr = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] assert process_queries(5, arr, queries) == [6, 9, 15] arr = [3, 1, 4, 1, 5, 9, 2] queries = [(1, 2), (2, 4), (3, 5), (1, 7)] assert process_queries(7, arr, queries) == [4, 6, 10, 25] arr = [10**6] * 5 queries = [(1, 1), (1, 3), (2, 5)] assert process_queries(5, arr, queries) == [10**6, 3*10**6, 4*10**6]","solution":"def preprocess_array(arr): Preprocess the array to create a prefix sum array. N = len(arr) prefix_sum = [0] * (N + 1) for i in range(N): prefix_sum[i + 1] = prefix_sum[i] + arr[i] return prefix_sum def query_sum(prefix_sum, L, R): Returns the sum of the subarray from L to R (inclusive) using the prefix sum array. L and R are 1-based indices. return prefix_sum[R] - prefix_sum[L - 1] def process_queries(N, arr, queries): Process all the queries using preprocessing for efficiency. prefix_sum = preprocess_array(arr) results = [] for L, R in queries: results.append(query_sum(prefix_sum, L, R)) return results"},{"question":"import heapq def shortest_longest_delivery_time(n, m, edges, s): This function finds the shortest possible time for the longest delivery using Dijkstra's algorithm. :param n: Number of intersections :param m: Number of streets :param edges: List of edges where each edge is represented by (u, v, w) :param s: Starting intersection :return: The minimum possible time for the longest delivery or \\"UNREACHABLE\\" if any intersection is not reachable def test_example_1(): n = 4 m = 4 edges = [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 3)] s = 1 assert shortest_longest_delivery_time(n, m, edges, s) == 6 def test_example_2(): n = 4 m = 2 edges = [(1, 2, 3), (1, 3, 5)] s = 4 assert shortest_longest_delivery_time(n, m, edges, s) == \\"UNREACHABLE\\" def test_single_intersection(): n = 1 m = 0 edges = [] s = 1 assert shortest_longest_delivery_time(n, m, edges, s) == 0 def test_unidirectional_edge(): n = 3 m = 3 edges = [(1, 2, 2), (2, 3, 3), (3, 1, 4)] s = 1 assert shortest_longest_delivery_time(n, m, edges, s) == 5 def test_unreachable_nodes(): n = 5 m = 2 edges = [(1, 2, 1), (1, 3, 2)] s = 1 assert shortest_longest_delivery_time(n, m, edges, s) == \\"UNREACHABLE\\"","solution":"import heapq def shortest_longest_delivery_time(n, m, edges, s): This function finds the shortest possible time for the longest delivery using Dijkstra's algorithm. :param n: Number of intersections :param m: Number of streets :param edges: List of edges where each edge is represented by (u, v, w) :param s: Starting intersection :return: The minimum possible time for the longest delivery or \\"UNREACHABLE\\" if any intersection is not reachable # Build graph graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) # Initialize distance array distance = {i: float('inf') for i in range(1, n+1)} distance[s] = 0 # Priority queue for Dijkstra's algorithm pq = [(0, s)] while pq: current_dist, current_node = heapq.heappop(pq) if current_dist > distance[current_node]: continue for neighbor, weight in graph[current_node]: distance_through_current = current_dist + weight if distance_through_current < distance[neighbor]: distance[neighbor] = distance_through_current heapq.heappush(pq, (distance_through_current, neighbor)) # Find the maximum distance in the shortest paths found max_distance = max(distance.values()) # Check if there are unreachable intersections if max_distance == float('inf'): return \\"UNREACHABLE\\" return max_distance"},{"question":"def shortest_subarray_with_sum(arr, x): Returns the length of the shortest subarray with sum greater than or equal to x. If no such subarray exists, return -1. >>> shortest_subarray_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) 2 >>> shortest_subarray_with_sum([1, 2, 3, 4, 5], 100) -1 >>> shortest_subarray_with_sum([100], 99) 1 >>> shortest_subarray_with_sum([1, 2, 3, 4, 5], 6) 2 >>> shortest_subarray_with_sum([1, 1, 1, 1, 1], 10) -1 >>> shortest_subarray_with_sum([1, 2, 3, 4, 5], 15) 5","solution":"def shortest_subarray_with_sum(arr, x): Returns the length of the shortest subarray with sum greater than or equal to x. If no such subarray exists, return -1. n = len(arr) min_length = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum >= x: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def find_winner(participants): Determines the winner based on the scores. Args: - participants (list of tuples): Each tuple contains the participant ID followed by their task scores. Returns: - int: The participant ID with the highest score. >>> find_winner([(1, 10, 20, 30, 40), (2, 40, 10, 20, 30), (3, 20, 30, 40, 10)]) == 1 >>> find_winner([(1, 10, 20, 30, 40), (2, 40, 10, 20, 31), (3, 20, 30, 40, 10)]) == 2 >>> find_winner([(1, 1, 1, 1, 1), (2, 1, 1, 1, 1), (3, 1, 1, 1, 1)]) == 1 >>> find_winner([(1, 100, 0, 0, 0), (2, 50, 50, 0, 0), (3, 0, 0, 50, 50)]) == 1 >>> find_winner([(1, 10, 20, 0), (2, 5, 15, 30), (3, 25, 5, 10)]) == 2","solution":"def find_winner(participants): Determines the winner based on the scores. Args: - participants (list of tuples): Each tuple contains the participant ID followed by their task scores. Returns: - int: The participant ID with the highest score. max_score = -1 winner_id = None for participant in participants: participant_id = participant[0] scores = participant[1:] total_score = sum(scores) if total_score > max_score: max_score = total_score winner_id = participant_id return winner_id"},{"question":"def number_of_ideal_bouquets(m: int, n: int, required: List[int], bouquets: List[List[int]]) -> int: Determine the number of ideal bouquets in the collection. Args: m (int): number of types of flowers. n (int): number of bouquets. required (List[int]): the number of flowers of each type required to be considered \\"ideal\\". bouquets (List[List[int]]): the list of bouquets where each bouquet is represented by a list of the number of flowers of each type. Returns: int: The number of ideal bouquets. >>> number_of_ideal_bouquets(3, 5, [1, 1, 1], [ [1, 0, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [0, 1, 1] ]) 3 >>> number_of_ideal_bouquets(2, 4, [1, 2], [ [2, 3], [1, 1], [2, 2], [0, 2], ]) 2 >>> number_of_ideal_bouquets(3, 0, [1, 1, 1], []) 0 >>> number_of_ideal_bouquets(2, 3, [2, 2], [ [1, 2], [2, 1], [1, 1], ]) 0 >>> number_of_ideal_bouquets(2, 3, [1, 1], [ [1, 1], [2, 2], [3, 3], ]) 3","solution":"def number_of_ideal_bouquets(m, n, required, bouquets): Returns the number of ideal bouquets in the collection. Parameters: m (int): number of types of flowers. n (int): number of bouquets. required (list of int): the number of flowers of each type required to be considered \\"ideal\\". bouquets (list of list of int): the list of bouquets where each bouquet is represented by a list of the number of flowers of each type. Returns: int: The number of ideal bouquets. ideal_count = 0 for bouquet in bouquets: if all(bouquet[i] >= required[i] for i in range(m)): ideal_count += 1 return ideal_count"},{"question":"def can_convert_with_one_swap(s: str, t: str) -> str: Determines if string s can be converted into string t with exactly one swap. Args: s (str): The original string. t (str): The target string. Returns: str: 'YES' if s can be converted to t by one swap, 'NO' otherwise. >>> can_convert_with_one_swap(\\"abc\\", \\"abc\\") 'YES' >>> can_convert_with_one_swap(\\"abcd\\", \\"abdc\\") 'YES' >>> can_convert_with_one_swap(\\"abcd\\", \\"abcf\\") 'NO' >>> can_convert_with_one_swap(\\"abcd\\", \\"dcab\\") 'NO' >>> can_convert_with_one_swap(\\"abcd\\", \\"efgh\\") 'NO' >>> can_convert_with_one_swap(\\"abcd\\", \\"bcda\\") 'NO'","solution":"def can_convert_with_one_swap(s, t): Determines if string s can be converted into string t with exactly one swap. Args: s (str): The original string. t (str): The target string. Returns: str: 'YES' if s can be converted to t by one swap, 'NO' otherwise. if s == t: return \\"YES\\" # Find the positions where s and t differ diff = [] for i in range(len(s)): if s[i] != t[i]: diff.append(i) # If there's exactly two positions where they differ, check if swapping makes them equal if len(diff) == 2: i, j = diff s = list(s) s[i], s[j] = s[j], s[i] if ''.join(s) == t: return \\"YES\\" return \\"NO\\""},{"question":"def longest_correct_order_subarray(n: int, a: List[int]) -> int: Chef Alex wants to know the length of the longest contiguous subarray with ingredients added in non-decreasing order. >>> longest_correct_order_subarray(7, [1, 2, 5, 3, 4, 7, 8]) 4 >>> longest_correct_order_subarray(5, [5, 4, 3, 2, 1]) 1 Unit Test: from solution import longest_correct_order_subarray def test_example_case_1(): assert longest_correct_order_subarray(7, [1, 2, 5, 3, 4, 7, 8]) == 4 def test_example_case_2(): assert longest_correct_order_subarray(5, [5, 4, 3, 2, 1]) == 1 def test_single_element(): assert longest_correct_order_subarray(1, [1]) == 1 def test_all_increasing(): assert longest_correct_order_subarray(5, [1, 2, 3, 4, 5]) == 5 def test_all_same_elements(): assert longest_correct_order_subarray(4, [2, 2, 2, 2]) == 4 def test_random_order(): assert longest_correct_order_subarray(6, [3, 3, 5, 5, 6, 7]) == 6 def test_alternating_increasing_decreasing(): assert longest_correct_order_subarray(10, [1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 2","solution":"def longest_correct_order_subarray(n, a): max_length = 1 current_length = 1 for i in range(1, n): if a[i] >= a[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def min_operations_to_transform(S, T): Transform string S into string T by rearranging subsequences. Return the minimum number of operations required to transform S into T. If transformation is not possible, return -1. >>> min_operations_to_transform(\\"abc\\", \\"bca\\") 1 >>> min_operations_to_transform(\\"aabbcc\\", \\"abccba\\") 2 >>> min_operations_to_transform(\\"abc\\", \\"def\\") -1 >>> min_operations_to_transform(\\"a\\", \\"a\\") 0 >>> min_operations_to_transform(\\"a\\", \\"b\\") -1 def minimum_operations_for_all_cases(test_cases): Compute the minimum number of operations for each test case to transform S into T. Return a list of results for all test cases. >>> minimum_operations_for_all_cases([(\\"abc\\", \\"bca\\"), (\\"aabbcc\\", \\"abccba\\"), (\\"a\\", \\"a\\"), (\\"a\\", \\"b\\"), (\\"abc\\", \\"def\\")]) [1, 2, 0, -1, -1]","solution":"def min_operations_to_transform(S, T): from collections import Counter # If sorted versions of S and T are not the same, transformation is impossible if sorted(S) != sorted(T): return -1 # Detect common lengths from the front in T in reverse within S, this minimizes operations n = len(S) max_match_length = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n): for j in range(n): if S[i] == T[j]: max_match_length[i + 1][j + 1] = max_match_length[i][j] + 1 else: max_match_length[i + 1][j + 1] = max(max_match_length[i + 1][j], max_match_length[i][j + 1]) len_lcs = max_match_length[n][n] return len(S) - len_lcs def minimum_operations_for_all_cases(test_cases): results = [] for S, T in test_cases: results.append(min_operations_to_transform(S, T)) return results"},{"question":"def most_popular_photo(n, photos): Determines the most popular photo based on like and comment counts. Args: n (int): The number of photos. photos (list of tuples): Each tuple contains the number of likes and comments for a photo. Returns: int: The 1-based index of the most popular photo. from solution import most_popular_photo def test_single_photo(): assert most_popular_photo(1, [(10, 5)]) == 1 def test_multiple_photos(): assert most_popular_photo(3, [(10, 5), (8, 7), (10, 5)]) == 1 def test_all_zeros(): assert most_popular_photo(2, [(0, 0), (0, 0)]) == 1 def test_tiebreak_by_index(): assert most_popular_photo(4, [(5, 10), (7, 5), (5, 10), (6, 8)]) == 1 def test_mixed_scores(): assert most_popular_photo(5, [(1, 2), (3, 5), (2, 1), (0, 9), (4, 3)]) == 2 def test_edge_case_high_values(): assert most_popular_photo(3, [(1000, 1000), (999, 1001), (1000, 999)]) == 1","solution":"def most_popular_photo(n, photos): Determines the most popular photo based on like and comment counts. Args: n (int): The number of photos. photos (list of tuples): Each tuple contains the number of likes and comments for a photo. Returns: int: The 1-based index of the most popular photo. max_score = -1 max_index = -1 for i in range(n): l, c = photos[i] score = l * 2 + c if score > max_score or (score == max_score and max_index == -1): max_score = score max_index = i + 1 return max_index"},{"question":"from typing import List, Union def find_median(numbers: List[Union[int, float]]) -> float: Calculate and return the median of a list of numbers. The median is the middle number in a sorted list of numbers. If the list length is even, the median is the average of the two middle numbers. >>> find_median([1, 3, 3, 6, 7, 8, 9]) 6.0 >>> find_median([1, 2, 3, 4, 5, 6, 8, 9]) 4.5 >>> find_median([3.5]) 3.5 >>> find_median([-1, -3, -5, 2, 4, 6, 8]) 2.0 >>> find_median([9.5, 8.5, 7.5, 6.5, 5.5]) 7.5 def test_find_median_odd_length(): assert find_median([1, 3, 3, 6, 7, 8, 9]) == 6.0 def test_find_median_even_length(): assert find_median([1, 2, 3, 4, 5, 6, 8, 9]) == 4.5 def test_find_median_single_element(): assert find_median([3.5]) == 3.5 def test_find_median_negative_and_positive(): assert find_median([-1, -3, -5, 2, 4, 6, 8]) == 2.0 def test_find_median_all_floats(): assert find_median([9.5, 8.5, 7.5, 6.5, 5.5]) == 7.5 def test_find_median_with_zero(): assert find_median([0, 0, 0]) == 0.0 def test_find_median_mixed_numbers(): assert find_median([1.5, 3, 9, 2.8, -4.2, 6.7, 4]) == 3.0 def test_find_median_large_list(): large_list = list(range(1, 1000001)) assert find_median(large_list) == 500000.5","solution":"def find_median(numbers): This function finds the median of a list of numbers. sorted_numbers = sorted(numbers) n = len(sorted_numbers) if n % 2 == 1: return float(sorted_numbers[n // 2]) else: return (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2.0"},{"question":"def are_points_collinear(points): This function checks whether all given points lie on a straight line. :param points: List of tuples representing the coordinates of the points (xi, yi). :return: 'YES' if all points lie on a straight line, otherwise 'NO'. Examples: >>> are_points_collinear([(1, 1), (2, 2), (3, 3), (4, 4)]) 'YES' >>> are_points_collinear([(1, 2), (2, 3), (3, 4), (4, 6)]) 'NO'","solution":"def are_points_collinear(points): This function checks whether all given points lie on a straight line. :param points: List of tuples representing the coordinates of the points (xi, yi). :return: 'YES' if all points lie on a straight line, otherwise 'NO'. if len(points) <= 2: return 'YES' x0, y0 = points[0] x1, y1 = points[1] for i in range(2, len(points)): xi, yi = points[i] if (y1 - y0) * (xi - x0) != (yi - y0) * (x1 - x0): return 'NO' return 'YES'"},{"question":"def max_sublist_sum(N: int, lst: List[int]) -> int: Returns the maximum possible sum of some sublist of the given list. >>> max_sublist_sum(5, [1, 2, -4, 5, 3]) 8 >>> max_sublist_sum(1, [10]) 10 >>> max_sublist_sum(1, [-10]) -10 >>> max_sublist_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_sublist_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_sublist_sum(8, [-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_sublist_sum(5, [0, -3, 2, -2, 1]) 2 >>> max_sublist_sum(5, [10000, -10000, 10000, -10000, 10000]) 10000","solution":"def max_sublist_sum(N, lst): Returns the maximum possible sum of some sublist of the given list. Uses Kadane's Algorithm. max_current = max_global = lst[0] for i in range(1, N): max_current = max(lst[i], max_current + lst[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def pathArea(L: int, W: int, P: int) -> int: Calculate the area of the path around the rectangular field. Parameters: L (int): Length of the field. W (int): Width of the field. P (int): Width of the path. Returns: int: Area of the path in square meters. >>> pathArea(10, 8, 2) 88 >>> pathArea(6, 3, 1) 22","solution":"def pathArea(L, W, P): Calculate the area of the path around the rectangular field. Parameters: L (int): Length of the field. W (int): Width of the field. P (int): Width of the path. Returns: int: Area of the path in square meters. total_area_with_path = (L + 2 * P) * (W + 2 * P) field_area = L * W path_area = total_area_with_path - field_area return path_area"},{"question":"from typing import List, Tuple def max_treasure(n: int, m: int, treasures: List[int], tunnels: List[Tuple[int, int]]) -> int: Alice wants to collect the maximum amount of treasure possible in a network of chambers and tunnels. Args: n: Number of chambers. m: Number of tunnels. treasures: List of integers where the i-th integer represents the amount of treasure in chamber i. tunnels: List of tuples where each tuple contains two integers indicating there is a tunnel between chambers u and v. Returns: The maximum amount of treasure Alice can collect. Examples: >>> max_treasure(3, 2, [7, 2, 3], [(1, 2), (2, 3)]) 10 >>> max_treasure(4, 4, [5, 10, 4, 1], [(1, 2), (2, 3), (3, 4), (4, 1)]) 15 pass # Implement the function here import pytest def test_example1(): assert max_treasure(3, 2, [7, 2, 3], [(1, 2), (2, 3)]) == 12 def test_example2(): assert max_treasure(4, 4, [5, 10, 4, 1], [(1, 2), (2, 3), (3, 4), (4, 1)]) == 20 def test_single_chamber(): assert max_treasure(1, 0, [5], []) == 5 def test_no_tunnels(): assert max_treasure(3, 0, [3, 2, 1], []) == 3 def test_disconnected_components(): assert max_treasure(6, 3, [1, 2, 3, 4, 5, 6], [(1, 2), (3, 4), (5, 6)]) == 11 def test_large_input_small_treasures(): n, m = 5, 4 treasures = [1, 1, 1, 1, 1] tunnels = [(1, 2), (2, 3), (3, 4), (4, 5)] assert max_treasure(n, m, treasures, tunnels) == 5 def test_all_treasures_equal(): n, m = 5, 4 treasures = [10, 10, 10, 10, 10] tunnels = [(1, 2), (2, 3), (3, 4), (4, 5)] assert max_treasure(n, m, treasures, tunnels) == 50","solution":"def max_treasure(n, m, treasures, tunnels): from collections import defaultdict, deque def dfs(node, visited, current_treasure): nonlocal max_treasure visited[node] = True current_treasure += treasures[node] max_treasure = max(max_treasure, current_treasure) for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor, visited, current_treasure) visited[node] = False graph = defaultdict(list) for u, v in tunnels: graph[u-1].append(v-1) graph[v-1].append(u-1) max_treasure = 0 for i in range(n): visited = [False] * n dfs(i, visited, 0) return max_treasure"},{"question":"def remove_vowels(s: str) -> str: Removes all vowels (both lowercase and uppercase) from the string s and returns the resultant string. >>> remove_vowels(\\"Programming\\") 'Prgrmmng' >>> remove_vowels(\\"aeiou\\") '' >>> remove_vowels(\\"AEIOU\\") '' >>> remove_vowels(\\"Hello World!\\") 'Hll Wrld!' >>> remove_vowels(\\"Python Programming\\") 'Pythn Prgrmmng' >>> remove_vowels(\\"Gym\\") 'Gym' >>> remove_vowels(\\"Brr\\") 'Brr' >>> remove_vowels(\\"\\") ''","solution":"def remove_vowels(s): Removes all vowels (both lowercase and uppercase) from the string s and returns the resultant string. vowels = 'aeiouAEIOU' return ''.join(char for char in s if char not in vowels)"},{"question":"def process_numbers(n: int, numbers: List[int]) -> List[str]: Transforms a list of numbers based on the given rules: - Replace numbers divisible by 3 with \\"Fizz\\" - Replace numbers divisible by 5 with \\"Buzz\\" - Replace numbers divisible by 3 and 5 with \\"FizzBuzz\\" - Otherwise, keep the number as it is Args: n (int): The number of integers. numbers (list of int): List of integers. Returns: list: A list of transformed values. Example: >>> process_numbers(5, [3, 5, 15, 4, 7]) ['Fizz', 'Buzz', 'FizzBuzz', '4', '7'] >>> process_numbers(3, [9, 10, 30]) ['Fizz', 'Buzz', 'FizzBuzz'] >>> process_numbers(4, [1, 2, 4, 8]) ['1', '2', '4', '8']","solution":"def process_numbers(n, numbers): Transforms a list of numbers based on the given rules: - Replace numbers divisible by 3 with \\"Fizz\\" - Replace numbers divisible by 5 with \\"Buzz\\" - Replace numbers divisible by 3 and 5 with \\"FizzBuzz\\" - Otherwise, keep the number as it is Args: n (int): The number of integers. numbers (list of int): List of integers. Returns: list: A list of transformed values. result = [] for num in numbers: if num % 3 == 0 and num % 5 == 0: result.append(\\"FizzBuzz\\") elif num % 3 == 0: result.append(\\"Fizz\\") elif num % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(num)) return result"},{"question":"def can_fit_monitors(W: int, H: int, monitors: List[Tuple[int, int]]) -> List[bool]: Determines if each monitor can fit on the table in any orientation. Parameters: W (int): Width of the table. H (int): Height of the table. monitors (list of tuples): List of tuples where each tuple contains the width and height of a monitor. Returns: list of bool: List of booleans indicating for each monitor if it can fit on the table in any orientation. >>> can_fit_monitors(100, 50, [(60, 40), (80, 90), (55, 45)]) [True, False, True] >>> can_fit_monitors(80, 80, [(100, 50), (60, 70)]) [False, True]","solution":"def can_fit_monitors(W, H, monitors): Determines if each monitor can fit on the table in any orientation. Parameters: W (int): Width of the table. H (int): Height of the table. monitors (list of tuples): List of tuples where each tuple contains the width and height of a monitor. Returns: list of bool: List of booleans indicating for each monitor if it can fit on the table in any orientation. result = [] for monitor in monitors: wi, hi = monitor fits = (wi <= W and hi <= H) or (hi <= W and wi <= H) result.append(fits) return result"},{"question":"def min_sprinkler_range(N: int, M: int, garden: List[str]) -> int: Calculate the minimum range required for water sprinklers to cover all plants in the garden. >>> min_sprinkler_range(4, 5, [\\"P....\\", \\".....\\", \\".....\\", \\"....P\\"]) 4 >>> min_sprinkler_range(3, 3, [\\"...\\", \\".P.\\", \\"...\\"]) 0 >>> min_sprinkler_range(3, 3, [\\"PPP\\", \\"...\\", \\"...\\"]) 1","solution":"def min_sprinkler_range(N, M, garden): plants = [(i, j) for i in range(N) for j in range(M) if garden[i][j] == 'P'] def max_manhattan_distance(plants): max_dist = 0 for i in range(len(plants)): for j in range(i+1, len(plants)): max_dist = max(max_dist, abs(plants[i][0] - plants[j][0]) + abs(plants[i][1] - plants[j][1])) return max_dist max_distance = max_manhattan_distance(plants) return (max_distance + 1) // 2 # Example usage: # N = 4 # M = 5 # garden = [ # \\"P....\\", # \\".....\\", # \\".....\\", # \\"....P\\" # ] # print(min_sprinkler_range(N, M, garden)) # Output: 4"},{"question":"def solve(N: int, grid: List[List[int]], Q: int, queries: List[Tuple[int, int, int, int]]) -> List[int]: Solve the problem of finding the sum of building heights in specified rectangular regions. Arguments: N -- the size of the grid (N x N) grid -- a 2D list of integers representing building heights Q -- the number of queries queries -- a list of tuples, each containing four integers (i1, j1, i2, j2) representing the top-left (i1, j1) and bottom-right (i2, j2) corners of the rectangular region Returns: A list of integers, where each integer is the sum of the building heights in the specified region. >>> N = 3 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> Q = 2 >>> queries = [ ... (0, 0, 1, 1), ... (1, 1, 2, 2) ... ] >>> solve(N, grid, Q, queries) [12, 28]","solution":"def compute_prefix_sum(grid, N): prefix_sum = [[0] * (N + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, N + 1): prefix_sum[i][j] = grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] return prefix_sum def query_sum(prefix_sum, i1, j1, i2, j2): return (prefix_sum[i2 + 1][j2 + 1] - prefix_sum[i1][j2 + 1] - prefix_sum[i2 + 1][j1] + prefix_sum[i1][j1]) def solve(N, grid, Q, queries): prefix_sum = compute_prefix_sum(grid, N) results = [] for query in queries: i1, j1, i2, j2 = query results.append(query_sum(prefix_sum, i1, j1, i2, j2)) return results"},{"question":"from typing import List, Tuple def can_schedule_events(test_cases: List[List[Tuple[int, int]]]) -> List[str]: Determine if all events can be scheduled without conflicts. Each test case consists of a list of tuples where each tuple contains the start and end time of an event. The function returns a list of strings where each string indicates if all events in the test case can be scheduled without conflicts (\\"YES\\") or, if not, the maximum number of non-overlapping events that can be scheduled (\\"NO <max_non_overlapping>\\"). Args: test_cases: List of test cases (each containing a list of event time tuples). Returns: List of results for each test case. >>> can_schedule_events([[(1, 3), (4, 6), (7, 9)], [(1, 2), (2, 3), (3, 4)]]) [\\"YES\\", \\"YES\\"] >>> can_schedule_events([[(1, 3), (2, 5), (4, 6)], [(1, 4), (2, 3)]]) [\\"NO 2\\", \\"NO 1\\"] # Placeholder for the solution pass","solution":"from typing import List, Tuple def can_schedule_events(test_cases: List[List[Tuple[int, int]]]) -> List[str]: results = [] for events in test_cases: # Sort events based on the ending times events.sort(key=lambda x: x[1]) max_non_overlapping = 0 end_time = 0 for start, end in events: if start >= end_time: max_non_overlapping += 1 end_time = end # Check if all events are non-overlapping all_non_overlapping = (max_non_overlapping == len(events)) if all_non_overlapping: results.append(\\"YES\\") else: results.append(f\\"NO {max_non_overlapping}\\") return results"},{"question":"def count_colors(colors: List[str]) -> Dict[str, int]: Returns a dictionary containing the count of each unique color in the list. >>> count_colors([\\"red\\", \\"blue\\", \\"red\\", \\"green\\", \\"blue\\", \\"blue\\"]) {'red': 2, 'blue': 3, 'green': 1} >>> count_colors([\\"red\\"]) {'red': 1} >>> count_colors([\\"red\\", \\"blue\\", \\"green\\", \\"yellow\\"]) {'red': 1, 'blue': 1, 'green': 1, 'yellow': 1} >>> count_colors([]) {} >>> count_colors([\\"red\\", \\"red\\", \\"red\\", \\"red\\"]) {'red': 4} >>> count_colors([\\"Red\\", \\"red\\", \\"RED\\", \\"blue\\"]) {'Red': 1, 'red': 1, 'RED': 1, 'blue': 1}","solution":"def count_colors(colors): Returns a dictionary containing the count of each unique color in the list. color_count = {} for color in colors: if color in color_count: color_count[color] += 1 else: color_count[color] = 1 return color_count"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the total number of palindromic substrings in the string s. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abcd\\") 4 >>> count_palindromic_substrings(\\"a\\") 1","solution":"def count_palindromic_substrings(s): Returns the total number of palindromic substrings in the string s. n = len(s) count = 0 dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True count += 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: if length == 2 or dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def solve(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> None: Determine the minimum possible diameter after removing and adding one edge. >>> solve(2, [(5, [(1, 2), (1, 3), (1, 4), (1, 5)]), (4, [(1, 2), (2, 3), (2, 4)])]) 2 2 def bfs_to_get_farthest_node(tree, start): pass def calculate_diameter(tree): pass def find_minimum_diameter(n, edges): pass def process_test_cases(test_cases): pass results = process_test_cases(test_cases) for result in results: print(result) def test_solve(capsys): t = 2 test_cases = [ (5, [(1, 2), (1, 3), (1, 4), (1, 5)]), (4, [(1, 2), (2, 3), (2, 4)]), ] expected_output = \\"2n2n\\" solve(t, test_cases) captured = capsys.readouterr() assert captured.out == expected_output def test_diagram(): t = 1 test_cases = [ (6, [(1, 2), (1, 3), (2, 4), (4, 5), (4, 6)]) ] expected_output = [2] assert process_test_cases(test_cases) == expected_output def test_two_nodes(): t = 1 test_cases = [ (2, [(1, 2)]) ] expected_output = [1] assert process_test_cases(test_cases) == expected_output","solution":"from collections import deque, defaultdict def bfs_to_get_farthest_node(tree, start): Perform BFS to find the farthest node from the start node. Also returns the distances of each node from the start. n = len(tree) distances = [-1] * n queue = deque([start]) distances[start] = 0 farthest_node = start while queue: current = queue.popleft() for neighbor in tree[current]: if distances[neighbor] == -1: distances[neighbor] = distances[current] + 1 queue.append(neighbor) if distances[neighbor] > distances[farthest_node]: farthest_node = neighbor return farthest_node, distances def calculate_diameter(tree): Returns the diameter of the tree. # Find the farthest node from an arbitrary start node (node 0) farthest_node, _ = bfs_to_get_farthest_node(tree, 0) # Find the farthest node from the previously found farthest node opposite_node, distances = bfs_to_get_farthest_node(tree, farthest_node) return distances[opposite_node] def find_minimum_diameter(n, edges): if n == 2: return 1 tree = defaultdict(list) for u, v in edges: tree[u-1].append(v-1) tree[v-1].append(u-1) original_diameter = calculate_diameter(tree) if original_diameter == 2: return 2 return (original_diameter + 1) // 2 def process_test_cases(test_cases): results = [] for case in test_cases: n, edges = case result = find_minimum_diameter(n, edges) results.append(result) return results def solve(t, test_cases): results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_difference(root: TreeNode) -> int: Given a binary tree, find the difference between the sum of the values of nodes at odd levels and the sum of the values of nodes at even levels. The root of the binary tree is at depth 1 (which is odd). Args: root (TreeNode): The root node of the binary tree. Returns: int: The difference between the sum of the values of nodes at odd levels and the sum of the values of nodes at even levels. Examples: >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(8) >>> level_difference(root) 9 >>> root = TreeNode(1) >>> root.left = TreeNode(7) >>> root.right = TreeNode(0) >>> root.left.left = TreeNode(7) >>> root.left.right = TreeNode(-8) >>> level_difference(root) -7 >>> level_difference(None) 0 >>> root = TreeNode(10) >>> level_difference(root) 10","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_difference(root: TreeNode) -> int: if not root: return 0 from collections import deque # Initialize deque with root node and its level (1) queue = deque([(root, 1)]) # Sums for odd and even levels odd_sum = 0 even_sum = 0 while queue: node, level = queue.popleft() # Add to respective sums based on level if level % 2 == 1: odd_sum += node.val else: even_sum += node.val # Add child nodes to the queue with incremented level if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return odd_sum - even_sum"},{"question":"def process_bookings(test_cases): Processes a given list of bookings and cancellations, returning the final list of booked packages for each customer, sorted alphabetically. :param test_cases: A list of test cases where each test case contains a list of actions. :return: A list of strings representing the final booking list for each customer. pass def test_process_bookings(): test_cases = [ [ (\\"john\\", \\"book\\", \\"paris\\"), (\\"john\\", \\"book\\", \\"london\\"), (\\"john\\", \\"cancel\\", \\"paris\\"), (\\"john\\", \\"book\\", \\"berlin\\") ], [ (\\"alice\\", \\"book\\", \\"maldives\\"), (\\"bob\\", \\"book\\", \\"rome\\"), (\\"alice\\", \\"cancel\\", \\"maldives\\") ] ] expected_output = [ \\"john: ['berlin', 'london']\\", \\"alice: []nbob: ['rome']\\" ] assert process_bookings(test_cases) == expected_output def test_process_bookings_multiple_users(): test_cases = [ [ (\\"john\\", \\"book\\", \\"paris\\"), (\\"john\\", \\"book\\", \\"london\\"), (\\"jane\\", \\"book\\", \\"rome\\"), (\\"jane\\", \\"cancel\\", \\"rome\\"), (\\"john\\", \\"book\\", \\"berlin\\"), (\\"jane\\", \\"book\\", \\"venice\\") ] ] expected_output = [ \\"jane: ['venice']njohn: ['berlin', 'london', 'paris']\\" ] assert process_bookings(test_cases) == expected_output def test_process_bookings_no_actions(): test_cases = [ [] ] expected_output = [ \\"\\" ] assert process_bookings(test_cases) == expected_output def test_process_bookings_with_duplicates(): test_cases = [ [ (\\"john\\", \\"book\\", \\"paris\\"), (\\"john\\", \\"book\\", \\"paris\\"), (\\"john\\", \\"cancel\\", \\"paris\\"), (\\"john\\", \\"cancel\\", \\"paris\\"), (\\"john\\", \\"book\\", \\"berlin\\") ] ] expected_output = [ \\"john: ['berlin']\\" ] assert process_bookings(test_cases) == expected_output","solution":"def process_bookings(test_cases): Processes a given list of bookings and cancellations, returning the final list of booked packages for each customer, sorted alphabetically. :param test_cases: A list of test cases where each test case contains a list of actions. :return: A list of strings representing the final booking list for each customer. results = [] for actions in test_cases: booking_dict = {} for action in actions: customer_id, action_type, package = action if customer_id not in booking_dict: booking_dict[customer_id] = set() if action_type == 'book': booking_dict[customer_id].add(package) elif action_type == 'cancel' and package in booking_dict[customer_id]: booking_dict[customer_id].remove(package) result_lines = [] for customer in sorted(booking_dict): packages = sorted(booking_dict[customer]) result_lines.append(f\\"{customer}: {packages}\\") results.append('n'.join(result_lines)) return results"},{"question":"def minimum_subset_difference(n: int, elements: List[int]) -> int: Compute the minimum possible difference between the sums of the elements in two subsets. >>> minimum_subset_difference(4, [1, 6, 11, 5]) 1 >>> minimum_subset_difference(3, [10, 20, 15]) 5 >>> minimum_subset_difference(5, [3, 1, 4, 2, 2]) 0 pass from solution import minimum_subset_difference def test_example_1(): assert minimum_subset_difference(4, [1, 6, 11, 5]) == 1 def test_example_2(): assert minimum_subset_difference(3, [10, 20, 15]) == 5 def test_example_3(): assert minimum_subset_difference(5, [3, 1, 4, 2, 2]) == 0 def test_single_element(): assert minimum_subset_difference(1, [5]) == 5 def test_balanced_partition(): assert minimum_subset_difference(4, [1, 2, 3, 4]) == 0 def test_large_numbers(): assert minimum_subset_difference(3, [1000, 999, 1]) == 0 def test_various_elements(): assert minimum_subset_difference(6, [1, 2, 3, 5, 8, 13]) == 0 def test_double_partition(): assert minimum_subset_difference(6, [3, 1, 4, 2, 2, 1]) == 1","solution":"def minimum_subset_difference(n, elements): Computes the minimum possible difference between the sums of the elements in two subsets. Parameters: n (int): The number of elements in the list. elements (list): A list of n positive integers. Returns: int: The minimum possible difference between the sums of the elements in the two subsets. total_sum = sum(elements) dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in elements: for j in range(total_sum // 2, num - 1, -1): dp[j] = dp[j] or dp[j - num] for j in range(total_sum // 2, -1, -1): if dp[j]: return total_sum - 2 * j return total_sum # This line is theoretically unreachable. def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) elements = list(map(int, data[1:])) print(minimum_subset_difference(n, elements)) if __name__ == \\"__main__\\": main()"},{"question":"def calculate_memory(n: int, sequence: str) -> int: Calculate the minimum amount of memory required to store the given sequence of data blocks using the memory compression technique. Parameters: n (int): the length of the sequence sequence (str): a string of n uppercase alphabet characters representing the data blocks Returns: int: the minimum amount of memory required Examples: >>> calculate_memory(5, \\"ABACA\\") 3 >>> calculate_memory(8, \\"ABCDEFGH\\") 8 >>> calculate_memory(7, \\"AAAAAAA\\") 1","solution":"def calculate_memory(n, sequence): Calculates the minimum amount of memory required to store the given sequence using the given memory compression technique. seen_blocks = set() memory_required = 0 for block in sequence: if block not in seen_blocks: seen_blocks.add(block) memory_required += 1 return memory_required # Example usage: # n, sequence = 5, \\"ABACA\\" # print(calculate_memory(n, sequence)) # Output: 3"},{"question":"def longestSegment(s: str) -> int: Given a binary string s, flip exactly one bit from '0' to '1' and find the length of the longest contiguous segment of '1's. >>> longestSegment(\\"1101110\\") == 6 >>> longestSegment(\\"1001\\") == 2","solution":"def longestSegment(s): Given a binary string s, flip exactly one bit from '0' to '1' and find the length of the longest contiguous segment of '1's. n = len(s) # Count the number of zeros num_zeros = s.count('0') if num_zeros == 0: # If there are no zeros, the whole string is already the longest segment return n elif num_zeros == 1: # If there is only one zero, flipping it will make the whole string 1's return n # Split the string based on '0' and calculate lengths of segments of '1's segments = list(map(len, s.split('0'))) max_length = 0 for i in range(len(segments) - 1): # Calculate the potential segment length by flipping the zero in between two segments of '1's potential_length = segments[i] + segments[i + 1] + 1 max_length = max(max_length, potential_length) # Return the maximum found length return max_length"},{"question":"def can_partition_into_equal_groups(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if it's possible to partition the gems into exactly K groups with equal weight. Parameters: T (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases, where each test case consists of: - A tuple (N, K) where N is the number of gems and K is the number of groups. - A list of integers representing the weights of the gems. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case indicating whether it's possible to partition the gems into K groups with equal weight or not. Example: >>> T = 3 >>> test_cases = [((6, 3), [3, 3, 3, 3, 3, 3]), ((5, 2), [1, 2, 3, 4, 5]), ((4, 2), [2, 1, 4, 1])] >>> can_partition_into_equal_groups(T, test_cases) ['YES', 'NO', 'YES']","solution":"def can_partition_into_equal_groups(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] W = test_cases[i][1] total_weight = sum(W) if total_weight % K != 0: results.append(\\"NO\\") continue target_weight = total_weight // K W.sort(reverse=True) buckets = [0] * K def can_partition(index): if index == N: return all(bucket == target_weight for bucket in buckets) for i in range(K): if buckets[i] + W[index] <= target_weight: buckets[i] += W[index] if can_partition(index + 1): return True buckets[i] -= W[index] if buckets[i] == 0: break return False if can_partition(0): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def findPaths(grid): Returns the number of ways to reach the bottom-right corner of the grid from the top-left corner. Parameters: grid (List[List[int]]): 2D grid where 0 represents an open cell and 1 represents a blocked cell. Returns: int: Number of ways to reach the bottom-right corner. >>> findPaths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> findPaths([ ... [0, 1], ... [0, 0] ... ]) == 1 >>> findPaths([ ... [0, 1], ... [1, 0] ... ]) == 0 >>> findPaths([ ... [0, 0, 0, 0] ... ]) == 1 >>> findPaths([ ... [0], ... [0], ... [0], ... [0] ... ]) == 1 >>> findPaths([[0]*100 for _ in range(100)]) != 0 >>> findPaths([ ... [1, 0], ... [0, 0] ... ]) == 0 >>> findPaths([ ... [0, 0], ... [0, 1] ... ]) == 0","solution":"def findPaths(grid): Returns the number of ways to reach the bottom-right corner of the grid from the top-left corner. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 n = len(grid) m = len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def find_min_difference(t, test_cases): Find the minimum difference between any element from array \`a\` and any element from array \`b\` for each test case. Parameters: t (int): the number of test cases test_cases (list): a list of dictionaries where each dictionary represents a test case with keys as follows: - \\"lengths\\" (tuple): a tuple containing two integers n and m, the lengths of arrays a and b respectively. - \\"array_a\\" (list): list of n integers, elements of array a. - \\"array_b\\" (list): list of m integers, elements of array b. Returns: List[int]: a list of integers where each integer represents the minimum difference for the corresponding test case. >>> t = 3 >>> test_cases = [ ... {\\"lengths\\": (5, 4), \\"array_a\\": [1, 3, 5, 7, 9], \\"array_b\\": [2, 4, 8, 10]}, ... {\\"lengths\\": (1, 1), \\"array_a\\": [-10], \\"array_b\\": [10]}, ... {\\"lengths\\": (3, 3), \\"array_a\\": [-1, -2, -3], \\"array_b\\": [4, 5, 6]} ... ] >>> find_min_difference(t, test_cases) [1, 20, 5]","solution":"def find_min_difference(t, test_cases): results = [] for i in range(t): n, m = test_cases[i][\\"lengths\\"] a = test_cases[i][\\"array_a\\"] b = test_cases[i][\\"array_b\\"] a.sort() b.sort() min_diff = float('inf') i = 0 j = 0 while i < n and j < m: min_diff = min(min_diff, abs(a[i] - b[j])) if a[i] < b[j]: i += 1 else: j += 1 results.append(min_diff) return results"},{"question":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merge two sorted lists into a single sorted list. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([0, 10, 20], [5, 15, 25]) [0, 5, 10, 15, 20, 25] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([-5, 0, 5], [-10, -4, 6]) [-10, -5, -4, 0, 5, 6] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 2, 2, 4], [2, 3, 5]) [1, 2, 2, 2, 3, 4, 5] >>> merge_sorted_lists([-5, -3, -1], [-6, -4, -2]) [-6, -5, -4, -3, -2, -1] >>> merge_sorted_lists([1], [2]) [1, 2] >>> merge_sorted_lists([2], [1]) [1, 2]","solution":"def merge_sorted_lists(list1, list2): Merge two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 # Use two pointers to iterate through both lists while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements (if any) from list1 or list2 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def get_building_heights(heights, queries): For each query, return the maximum height of the buildings that are greater than or equal to the specified height in the query. If there are no such buildings, return -1. Parameters: heights (list[int]): List of building heights. queries (list[int]): List of queries to check against the building heights. Returns: list[int]: List of results for each query. >>> get_building_heights([1, 3, 5, 7, 9, 11], [4, 8, 12]) == [11, 11, -1] >>> get_building_heights([5], [3, 4, 5, 6]) == [5, 5, 5, -1] >>> get_building_heights([5, 5, 5, 5, 5], [4, 5, 6]) == [5, 5, -1] >>> get_building_heights([2, 2, 2, 2], [3, 4, 5]) == [-1, -1, -1] >>> get_building_heights([10, 20, 30, 40, 50], [15, 25, 35, 45, 55]) == [50, 50, 50, 50, -1]","solution":"def get_building_heights(heights, queries): For each query, return the maximum height of the buildings that are greater than or equal to the specified height in the query. If there are no such buildings, return -1. Parameters: heights (list[int]): List of building heights. queries (list[int]): List of queries to check against the building heights. Returns: list[int]: List of results for each query. results = [] sorted_heights = sorted(heights, reverse=True) for x in queries: found = -1 for height in sorted_heights: if height >= x: found = height break results.append(found) return results"},{"question":"def maximize_attendance(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determine the time slot that allows the maximum number of team members to attend for each test case. >>> maximize_attendance(1, [(3, 4, ['1100', '1010', '1001'])]) [3] >>> maximize_attendance(1, [(3, 4, ['0000', '0000', '0000'])]) [0] >>> maximize_attendance(1, [(3, 4, ['1111', '1111', '1111'])]) [3] >>> maximize_attendance(2, [ (3, 4, ['1100', '1010', '1001']), (2, 3, ['010', '110']) ]) [3, 2] >>> maximize_attendance(1, [(1, 5, ['11001'])]) [1]","solution":"def maximize_attendance(T, test_cases): results = [] for t in range(T): M = test_cases[t][0] N = test_cases[t][1] availabilities = test_cases[t][2] max_team_members = 0 for j in range(N): count = sum(int(availabilities[i][j]) for i in range(M)) max_team_members = max(max_team_members, count) results.append(max_team_members) return results # Example usage: # T = 1 # test_cases = [ # (3, 4, ['1100', '1010', '1001']) # ] # print(maximize_attendance(T, test_cases)) # Output: [3]"},{"question":"def evaluate_expression(expression: str) -> str: Evaluates a mathematical expression and returns the result as a float with two decimal places. >>> evaluate_expression(\\"3+5*2\\") \\"13.00\\" >>> evaluate_expression(\\"10/2+1\\") \\"6.00\\" >>> evaluate_expression(\\"7*(2+3)\\") \\"35.00\\" >>> evaluate_expression(\\"8/3*3\\") \\"8.00\\" >>> evaluate_expression(\\"20-4+3*2\\") \\"22.00\\" >>> evaluate_expression(\\"1+1+1\\") \\"3.00\\" def process_expressions(expressions: List[str]) -> None: Processes a list of expressions and prints their evaluated result. The input ends with a line containing a single 0. >>> process_expressions([\\"3+5*2\\", \\"10/2+1\\", \\"7*(2+3)\\", \\"8/3*3\\", \\"20-4+3*2\\", \\"1+1+1\\", \\"0\\"]) 13.00 6.00 35.00 8.00 22.00 3.00","solution":"def evaluate_expression(expression): Evaluates a mathematical expression and returns the result as a float with two decimal places. # Evaluating the expression using eval result = eval(expression) # Formatting the result to two decimal places return format(result, \\".2f\\") def process_expressions(expressions): Processes a list of expressions and prints their evaluated result. The input ends with a line containing a single 0. for expression in expressions: if expression == '0': break print(evaluate_expression(expression))"},{"question":"def fizz_buzz(n): Returns a string following the FizzBuzz pattern for numbers from 1 to n. >>> fizz_buzz(5) '1, 2, Fizz, 4, Buzz' >>> fizz_buzz(10) '1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz'","solution":"def fizz_buzz(n): Returns a string following the FizzBuzz pattern for numbers from 1 to n. result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return \\", \\".join(result)"},{"question":"def form_study_groups(n: int, m: int, friend_pairs: List[Tuple[int, int]]) -> Union[int, List[Tuple[int, int]]]: Determine if it's possible to form groups of students in Aceland. Each student must form a group with exactly one other student, and best-friend pairs should not be in the same group. Args: n (int): The number of students. m (int): The number of best-friend pairs. friend_pairs (List[Tuple[int, int]]): List of best-friend pairs. Returns: Union[int, List[Tuple[int, int]]]: -1 if it's not possible to form valid groups, otherwise a list of tuples indicating the groups. >>> form_study_groups(6, 3, [(1, 2), (2, 3), (4, 5)]) [(1, 3), (2, 4), (5, 6)] >>> form_study_groups(4, 2, [(1, 2), (3, 4)]) [(1, 3), (2, 4)] >>> form_study_groups(4, 1, [(1, 2)]) [(1, 3), (2, 4)] >>> form_study_groups(2, 1, [(1, 2)]) -1 >>> form_study_groups(6, 3, [(1, 2), (3, 4), (5, 6)]) -1 pass if __name__ == \\"__main__\\": test_form_study_groups() print(\\"All tests passed\\")","solution":"def form_study_groups(n, m, friend_pairs): # Create an adjacency list to store friend pairs adjacency_list = {i: set() for i in range(1, n + 1)} for u, v in friend_pairs: adjacency_list[u].add(v) adjacency_list[v].add(u) # Keep track of visited students visited = [False] * (n + 1) groups = [] def dfs(student, current_group): stack = [student] while stack: current = stack.pop() if visited[current]: continue visited[current] = True current_group.append(current) for neighbor in adjacency_list[current]: if not visited[neighbor]: stack.append(neighbor) for student in range(1, n + 1): if not visited[student]: group1 = [] group2 = [] dfs(student, group1) for member in group1: for f in adjacency_list[member]: if f not in group1 and not visited[f]: group2.append(f) visited[f] = True if len(group1) == len(group2): groups.append((group1, group2)) else: return -1 result = [] for group1, group2 in groups: for a, b in zip(group1, group2): result.append((a, b)) return result # Handling input and output def process_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) friend_pairs = [] k = 2 for _ in range(m): ui = int(data[k]) vi = int(data[k + 1]) friend_pairs.append((ui, vi)) k += 2 result = form_study_groups(n, m, friend_pairs) if result == -1: print(-1) else: for pair in result: print(*pair) # For actual use, uncomment this # if __name__ == \\"__main__\\": # process_input()"},{"question":"def process_library_operations(n: int, operations: List[str]) -> List[str]: Simulates a library system for borrowing and returning books. Args: n (int): The number of operations. operations (List[str]): A list of operations in the format 'borrow <user_id>' or 'return <user_id>'. Returns: List[str]: The result of each operation. >>> process_library_operations(5, ['borrow 1', 'borrow 2', 'return 1', 'borrow 1', 'return 2']) [\\"User 1 borrowed a book.\\", \\"User 2 borrowed a book.\\", \\"User 1 returned the book.\\", \\"User 1 borrowed a book.\\", \\"User 2 returned the book.\\"] >>> process_library_operations(4, ['borrow 1', 'borrow 1', 'return 2', 'return 1']) [\\"User 1 borrowed a book.\\", \\"User 1 cannot borrow another book.\\", \\"User 2 cannot return a book they haven't borrowed.\\", \\"User 1 returned the book.\\"]","solution":"def process_library_operations(n, operations): user_books = {} results = [] for operation in operations: action, user_id = operation.split() user_id = int(user_id) if action == 'borrow': if user_id in user_books and user_books[user_id] == 1: results.append(f\\"User {user_id} cannot borrow another book.\\") else: user_books[user_id] = 1 results.append(f\\"User {user_id} borrowed a book.\\") elif action == 'return': if user_id in user_books and user_books[user_id] == 1: user_books[user_id] = 0 results.append(f\\"User {user_id} returned the book.\\") else: results.append(f\\"User {user_id} cannot return a book they haven't borrowed.\\") return results"},{"question":"def smallest_or_negative_one(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Check if the array is non-decreasing. If the array is non-decreasing, return the smallest integer in the array. Otherwise, return -1. >>> smallest_or_negative_one([(5, [1, 2, 3, 4, 5]), (4, [5, 2, 3, 4])]) [1, -1] >>> smallest_or_negative_one([(3, [100, 100, 100]), (2, [1, 2])]) [100, 1] >>> smallest_or_negative_one([(2, [2, 1])]) [-1]","solution":"def smallest_or_negative_one(test_cases): results = [] for case in test_cases: n, array = case is_non_decreasing = all(array[i] <= array[i+1] for i in range(n-1)) if is_non_decreasing: results.append(min(array)) else: results.append(-1) return results"},{"question":"def determine_winner(M: int) -> str: Determines the winner of the card game based on the number of cards. >>> determine_winner(2) == \\"Alan\\" >>> determine_winner(4) == \\"Barbara\\" >>> determine_winner(6) == \\"Alan\\"","solution":"def determine_winner(M): Determines the winner of the card game based on the number of cards. :param M: int - The number of cards in the deck. :return: str - \\"Alan\\" if Alan wins, otherwise \\"Barbara\\". # Alan always starts first and picks optimally # Alan wins if M / 2 is odd, otherwise Barbara wins. if (M // 2) % 2 == 1: return \\"Alan\\" else: return \\"Barbara\\""},{"question":"def reverse_diagonal_pattern(n): Returns a square pattern of n x n size with '*' characters on the reverse diagonal. Parameters: n (int): The size of the square pattern. Returns: List[str]: A list of strings representing the pattern. >>> reverse_diagonal_pattern(1) ['*'] >>> reverse_diagonal_pattern(2) [' *', '* '] >>> reverse_diagonal_pattern(3) [' *', ' * ', '* '] >>> reverse_diagonal_pattern(5) [' *', ' * ', ' * ', ' * ', '* '] >>> reverse_diagonal_pattern(20) == [' ' * (19 - i) + '*' + ' ' * i for i in range(20)] True","solution":"def reverse_diagonal_pattern(n): Returns a square pattern of n x n size with '*' characters on the reverse diagonal. Parameters: n (int): The size of the square pattern. Returns: List[str]: A list of strings representing the pattern. pattern = [] for i in range(n): row = [' '] * n row[n - i - 1] = '*' pattern.append(''.join(row)) return pattern"},{"question":"class Song: def __init__(self, song_id: int, title: str, artist: str, duration: int): self.song_id = song_id self.title = title self.artist = artist self.duration = duration class MediaPlayer: MediaPlayer to handle playing, adding, and removing songs in playlists. # Methods: - create_playlist(playlist_name): Create a new playlist. - add_song_to_playlist(playlist_name, song_id, title, artist, duration): Add a song to a specific playlist. - remove_song_from_playlist(playlist_name, song_id): Remove the song with the specified ID from the playlist. - get_total_duration(playlist_name): Get the total duration of all songs in the playlist. def create_playlist(self, playlist_name: str) -> None: pass def add_song_to_playlist(self, playlist_name: str, song_id: int, title: str, artist: str, duration: int) -> None: pass def remove_song_from_playlist(self, playlist_name: str, song_id: int) -> None: pass def get_total_duration(self, playlist_name: str) -> int: pass # Unit tests def test_create_playlist(): mp = MediaPlayer() mp.create_playlist(\\"Classical\\") assert \\"Classical\\" in mp.playlists def test_add_song_to_playlist(): mp = MediaPlayer() mp.create_playlist(\\"Classical\\") mp.add_song_to_playlist(\\"Classical\\", 1, \\"Canon in D\\", \\"Pachelbel\\", 360) assert len(mp.playlists[\\"Classical\\"]) == 1 song = mp.playlists[\\"Classical\\"][0] assert song.song_id == 1 assert song.title == \\"Canon in D\\" assert song.artist == \\"Pachelbel\\" assert song.duration == 360 def test_get_total_duration(): mp = MediaPlayer() mp.create_playlist(\\"Classical\\") mp.add_song_to_playlist(\\"Classical\\", 1, \\"Canon in D\\", \\"Pachelbel\\", 360) mp.add_song_to_playlist(\\"Classical\\", 2, \\"The Four Seasons\\", \\"Vivaldi\\", 600) total_duration = mp.get_total_duration(\\"Classical\\") assert total_duration == 960 def test_remove_song_from_playlist(): mp = MediaPlayer() mp.create_playlist(\\"Classical\\") mp.add_song_to_playlist(\\"Classical\\", 1, \\"Canon in D\\", \\"Pachelbel\\", 360) mp.add_song_to_playlist(\\"Classical\\", 2, \\"The Four Seasons\\", \\"Vivaldi\\", 600) mp.remove_song_from_playlist(\\"Classical\\", 1) total_duration = mp.get_total_duration(\\"Classical\\") assert total_duration == 600 assert len(mp.playlists[\\"Classical\\"]) == 1 def test_get_total_duration_nonexistent_playlist(): mp = MediaPlayer() assert mp.get_total_duration(\\"Nonexistent\\") == 0 def test_remove_song_from_nonexistent_playlist(): mp = MediaPlayer() mp.remove_song_from_playlist(\\"Nonexistent\\", 1) assert \\"Nonexistent\\" not in mp.playlists def test_add_song_to_nonexistent_playlist(): mp = MediaPlayer() mp.add_song_to_playlist(\\"New Playlist\\", 3, \\"Imagine\\", \\"John Lennon\\", 183) assert \\"New Playlist\\" in mp.playlists assert len(mp.playlists[\\"New Playlist\\"]) == 1 def test_remove_nonexistent_song(): mp = MediaPlayer() mp.add_song_to_playlist(\\"Temporary Playlist\\", 4, \\"Yesterday\\", \\"The Beatles\\", 125) mp.remove_song_from_playlist(\\"Temporary Playlist\\", 999) # non-existent song_id assert len(mp.playlists[\\"Temporary Playlist\\"]) == 1","solution":"class Song: def __init__(self, song_id, title, artist, duration): self.song_id = song_id self.title = title self.artist = artist self.duration = duration class MediaPlayer: def __init__(self): self.playlists = {} def create_playlist(self, playlist_name): if playlist_name not in self.playlists: self.playlists[playlist_name] = [] def add_song_to_playlist(self, playlist_name, song_id, title, artist, duration): if playlist_name not in self.playlists: self.create_playlist(playlist_name) song = Song(song_id, title, artist, duration) self.playlists[playlist_name].append(song) def remove_song_from_playlist(self, playlist_name, song_id): if playlist_name in self.playlists: self.playlists[playlist_name] = [ song for song in self.playlists[playlist_name] if song.song_id != song_id ] def get_total_duration(self, playlist_name): if playlist_name not in self.playlists: return 0 total_duration = sum(song.duration for song in self.playlists[playlist_name]) return total_duration"},{"question":"def can_assign_tasks(T: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[str]: Determine if it's possible to assign all tasks to the employees without exceeding their individual capacities. >>> can_assign_tasks(2, [(3, [10, 15, 20], 5, [5, 5, 10, 10, 5]), (2, [8, 8], 3, [5, 5, 5])]) [\\"yes\\", \\"no\\"] >>> can_assign_tasks(1, [(1, [10], 1, [10])]) [\\"yes\\"] >>> can_assign_tasks(1, [(3, [10, 15, 20], 5, [25, 5, 5, 5, 5])]) [\\"no\\"] >>> can_assign_tasks(1, [(2, [10, 20], 3, [10, 10, 10])]) [\\"yes\\"] >>> can_assign_tasks(1, [(2, [8, 8], 3, [9, 9, 1])]) [\\"no\\"]","solution":"def can_assign_tasks(T, test_cases): results = [] for i in range(T): N, employee_capacities, M, task_workloads = test_cases[i] employee_capacities.sort(reverse=True) task_workloads.sort(reverse=True) for workload in task_workloads: assigned = False for j in range(N): if employee_capacities[j] >= workload: employee_capacities[j] -= workload assigned = True break if not assigned: results.append(\\"no\\") break else: results.append(\\"yes\\") return results # Example usage: # T = 2 # test_cases = [ # (3, [10, 15, 20], 5, [5, 5, 10, 10, 5]), # (2, [8, 8], 3, [5, 5, 5]) # ] # print(can_assign_tasks(T, test_cases))"},{"question":"import sys from typing import List, Tuple def minimum_cost_to_connect_all_stations(n: int, tracks: List[Tuple[int, int, int]]) -> int: Determines the minimum cost to connect all stations such that every station can be reached from any other station. If it's impossible, returns -1. Args: n (int): Number of stations. tracks (List[Tuple[int, int, int]]): List of tuples where each tuple consists of two station indices and the length of the track. Returns: int: Minimum cost to connect all stations, or -1 if it is impossible. Examples: >>> minimum_cost_to_connect_all_stations(6, [(1, 2, 3), (2, 3, 2), (3, 4, 1), (4, 5, 4), (5, 6, 5), (1, 3, 6), (2, 4, 7), (3, 5, 8), (4, 6, 9)]) 15 >>> minimum_cost_to_connect_all_stations(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)]) 6 >>> minimum_cost_to_connect_all_stations(3, [(1, 2, 1), (2, 3, 2)]) 3 >>> minimum_cost_to_connect_all_stations(5, [(1, 2, 10), (1, 3, 6), (2, 4, 5), (3, 4, 15), (4, 5, 8)]) 29 >>> minimum_cost_to_connect_all_stations(3, [(1, 2, 1)]) -1","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): edges.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n mst_cost = 0 num_edges = 0 for u, v, weight in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += weight num_edges += 1 if num_edges == n - 1: break return mst_cost if num_edges == n - 1 else -1 def minimum_cost_to_connect_all_stations(n, tracks): edges = [(x - 1, y - 1, l) for x, y, l in tracks] return kruskal(n, edges)"},{"question":"def min_height_difference(n: int, k: int, heights: List[int]) -> int: Returns the minimum possible difference of heights between the tallest and shortest buildings in the selected group of k buildings. Example: >>> min_height_difference(5, 3, [10, 1, 12, 9, 5]) 3 >>> min_height_difference(4, 2, [3, 3, 3, 3]) 0 >>> min_height_difference(5, 3, [1, 2, 3, 4, 5]) 2 >>> min_height_difference(7, 4, [10, 1, 12, 9, 5, 8, 7]) 3 >>> min_height_difference(1, 1, [5]) 0 >>> min_height_difference(2, 1, [4, 7]) 0 >>> min_height_difference(5, 2, [1000000000, 999999999, 5, 1, 6]) 1","solution":"def min_height_difference(n, k, heights): Returns the minimum difference between the maximum and minimum heights of the selected k buildings. heights.sort() min_diff = float('inf') for i in range(n - k + 1): current_diff = heights[i + k - 1] - heights[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def shortest_path(N: int, M: int, edges: List[List[int]], A: int, B: int) -> int: Find the weight of the shortest path between two given nodes A and B in an undirected graph with N nodes. Parameters: N (int): The number of nodes in the graph. M (int): The number of edges in the graph. edges (List[List[int]]): A list of edges, where each edge is represented as [U, V, W], with U and V as nodes and W as the weight of the edge. A (int): Starting node. B (int): Target node. Returns: int: The weight of the shortest path between nodes A and B. If no such path exists, return -1. >>> parse_input(\\"5 6n1 2 3n1 3 2n2 3 4n2 4 6n3 4 1n4 5 5n1 5\\") (5, 6, [[1, 2, 3], [1, 3, 2], [2, 3, 4], [2, 4, 6], [3, 4, 1], [4, 5, 5]], 1, 5) >>> shortest_path(5, 6, [[1, 2, 3], [1, 3, 2], [2, 3, 4], [2, 4, 6], [3, 4, 1], [4, 5, 5]], 1, 5) 8 >>> parse_input(\\"4 2n1 2 2n3 4 4n1 4\\") (4, 2, [[1, 2, 2], [3, 4, 4]], 1, 4) >>> shortest_path(4, 2, [[1, 2, 2], [3, 4, 4]], 1, 4) -1 def parse_input(input_data: str) -> Tuple[int, int, List[List[int]], int, int]: Parse the input data string into graph parameters. Parameters: input_data (str): The input data string. Returns: tuple: A tuple consisting of N (int), M (int), edges (List[List[int]]), A (int), and B (int). >>> parse_input(\\"5 6n1 2 3n1 3 2n2 3 4n2 4 6n3 4 1n4 5 5n1 5\\") (5, 6, [[1, 2, 3], [1, 3, 2], [2, 3, 4], [2, 4, 6], [3, 4, 1], [4, 5, 5]], 1, 5) >>> parse_input(\\"4 2n1 2 2n3 4 4n1 4\\") (4, 2, [[1, 2, 2], [3, 4, 4]], 1, 4) # Unit Tests def test_shortest_path_basic(): input_data = \\"5 6n1 2 3n1 3 2n2 3 4n2 4 6n3 4 1n4 5 5n1 5\\" N, M, edges, A, B = parse_input(input_data) assert shortest_path(N, M, edges, A, B) == 8 def test_shortest_path_no_path(): input_data = \\"4 2n1 2 2n3 4 4n1 4\\" N, M, edges, A, B = parse_input(input_data) assert shortest_path(N, M, edges, A, B) == -1 def test_shortest_path_single_node(): input_data = \\"1 0n1 1\\" N, M, edges, A, B = parse_input(input_data) assert shortest_path(N, M, edges, A, B) == 0 def test_shortest_path_direct_connection(): input_data = \\"2 1n1 2 1n1 2\\" N, M, edges, A, B = parse_input(input_data) assert shortest_path(N, M, edges, A, B) == 1 def test_shortest_path_multiple_paths(): input_data = \\"3 3n1 2 1n2 3 1n1 3 2n1 3\\" N, M, edges, A, B = parse_input(input_data) assert shortest_path(N, M, edges, A, B) == 2","solution":"import heapq def shortest_path(N, M, edges, A, B): graph = [[] for _ in range(N)] for edge in edges: U, V, W = edge graph[U-1].append((W, V-1)) graph[V-1].append((W, U-1)) pq = [(0, A-1)] dist = [float('inf')] * N dist[A-1] = 0 while pq: current_dist, node = heapq.heappop(pq) if node == B-1: return current_dist for neighbor_weight, neighbor in graph[node]: distance = current_dist + neighbor_weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 # Input Parsing def parse_input(input_data): lines = input_data.strip().split(\\"n\\") N, M = map(int, lines[0].split()) edges = [list(map(int, line.split())) for line in lines[1:M+1]] A, B = map(int, lines[M+1].split()) return N, M, edges, A, B"},{"question":"from typing import List def count_unique_paths(n: int, adj_matrix: List[List[int]], start: int, end: int) -> int: Returns the number of unique paths from start node to end node in a directed graph. def test_count_unique_paths(): # Example test case n = 4 adj_matrix = [[0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 0, 1], [0, 0, 0, 0]] start = 0 end = 3 assert count_unique_paths(n, adj_matrix, start, end) == 2 # Single node case, start is the same as end n = 1 adj_matrix = [[0]] start = 0 end = 0 assert count_unique_paths(n, adj_matrix, start, end) == 1 # Two nodes with no connections n = 2 adj_matrix = [[0, 0], [0, 0]] start = 0 end = 1 assert count_unique_paths(n, adj_matrix, start, end) == 0 # Two nodes with one direct connection n = 2 adj_matrix = [[0, 1], [0, 0]] start = 0 end = 1 assert count_unique_paths(n, adj_matrix, start, end) == 1 # Three nodes forming a cycle n = 3 adj_matrix = [[0, 1, 0], [0, 0, 1], [1, 0, 0]] start = 0 end = 2 assert count_unique_paths(n, adj_matrix, start, end) == 1 # Complex graph with one unique path n = 5 adj_matrix = [[0, 1, 1, 0, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]] start = 0 end = 4 assert count_unique_paths(n, adj_matrix, start, end) == 3","solution":"def count_unique_paths(n, adj_matrix, start, end): Returns the number of unique paths from start node to end node in a directed graph. def dfs(current, end, visited): if current == end: return 1 visited.add(current) path_count = 0 for next_node in range(n): if adj_matrix[current][next_node] == 1: if next_node not in visited: path_count += dfs(next_node, end, visited) visited.remove(current) return path_count visited = set() # a set to keep track of visited nodes to prevent revisiting in the same path return dfs(start, end, visited)"},{"question":"def calculate_bonus(records): Calculate the end-of-year bonus for each employee based on their scores. The performance scores of an employee include scores for productivity (out of 40), teamwork (out of 30), and reliability (out of 30). If an employee does not have a score for a particular category, it is indicated by -1. The end-of-year bonus is awarded based on the following criteria: * If any of the scores is -1, the employee is disqualified and their bonus is zero. * If the total score is greater than or equal to 85, the employee receives a 15% bonus. * If the total score is greater than or equal to 70 and less than 85, the employee receives a 10% bonus. * If the total score is greater than or equal to 50 and less than 70, the employee receives a 5% bonus. * If the total score is less than 50, the employee does not receive any bonus. Input: The input consists of multiple datasets. For each dataset, three integers p, t, and r are given in a line, representing productivity, teamwork, and reliability scores respectively. The input ends with three -1 for p, t, and r respectively. Your program should not process the terminal symbols. The number of datasets (the number of employees) does not exceed 50. Output: For each dataset, print the percentage of the bonus (15%, 10%, 5% or 0%) in a line. >>> calculate_bonus([(35, 25, 20)]) ['10%'] >>> calculate_bonus([(40, 30, 20)]) ['15%'] >>> calculate_bonus([(30, 10, 5)]) ['0%']","solution":"def calculate_bonus(records): Calculate the end-of-year bonus for each employee based on their scores. bonuses = [] for record in records: p, t, r = record if p == -1 or t == -1 or r == -1: bonuses.append(\\"0%\\") continue total_score = p + t + r if total_score >= 85: bonuses.append(\\"15%\\") elif total_score >= 70: bonuses.append(\\"10%\\") elif total_score >= 50: bonuses.append(\\"5%\\") else: bonuses.append(\\"0%\\") return bonuses"},{"question":"from typing import List, Tuple def solve_tree_path_queries(n: int, A: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Return the minimum value in the path from node u to node v for each query. Args: n (int): The number of nodes in the tree. A (List[int]): The values of the nodes. edges (List[Tuple[int, int]]): The edges of the tree. queries (List[Tuple[int, int]]): The queries to answer. Returns: List[int]: The answers to each query. Examples: >>> solve_tree_path_queries(5, [4, 2, 5, 7, 3], [(1, 2), (1, 3), (2, 4), (2, 5)], [(1, 4), (4, 5), (3, 5)]) [2, 2, 2] >>> solve_tree_path_queries(3, [1, 2, 3], [(1, 2), (1, 3)], [(2, 3)]) [1] >>> solve_tree_path_queries(4, [10, 20, 15, 25], [(1, 2), (2, 3), (2, 4)], [(1, 3), (3, 4)]) [10, 15]","solution":"from collections import defaultdict import sys import math sys.setrecursionlimit(200000) def dfs(node, parent, depth, A, adj, P, min_val): P[node][0] = parent min_val[node][0] = A[node] for i in range(1, len(P[node])): if P[node][i-1] != -1: P[node][i] = P[P[node][i-1]][i-1] min_val[node][i] = min(min_val[node][i-1], min_val[P[node][i-1]][i-1]) for neighbor in adj[node]: if neighbor != parent: depth[neighbor] = depth[node] + 1 dfs(neighbor, node, depth, A, adj, P, min_val) def find_lca_and_min(u, v, depth, P, min_val): if depth[u] < depth[v]: u, v = v, u log = len(P[u]) - 1 min_path_value = float('inf') for i in range(log, -1, -1): if depth[u] - (1 << i) >= depth[v]: min_path_value = min(min_path_value, min_val[u][i]) u = P[u][i] if u == v: return min(min_path_value, min_val[u][0]) for i in range(log, -1, -1): if P[u][i] != -1 and P[u][i] != P[v][i]: min_path_value = min(min_path_value, min_val[u][i], min_val[v][i]) u = P[u][i] v = P[v][i] min_path_value = min(min_path_value, min_val[u][0], min_val[v][0]) return min(min_path_value, min_val[P[u][0]][0]) def solve_tree_path_queries(n, A, edges, queries): adj = defaultdict(list) for a, b in edges: adj[a-1].append(b-1) adj[b-1].append(a-1) log = math.ceil(math.log2(n)) P = [[-1] * (log+1) for _ in range(n)] min_val = [[float('inf')] * (log+1) for _ in range(n)] depth = [0] * n dfs(0, -1, depth, A, adj, P, min_val) results = [] for u, v in queries: results.append(find_lca_and_min(u-1, v-1, depth, P, min_val)) return results"},{"question":"def calculate_galactic_credits(S, T): Calculates the number of Galactic Credits (G) based on the number of Star Coins (S) and the time (T) of conversion. Args: S (int): Number of Star Coins. T (int): Time of conversion in hours. Returns: int: Number of Galactic Credits (G). # Code here def process_test_cases(test_cases): Processes multiple test cases to calculate Galactic Credits for each. Args: test_cases (list of tuples): Each tuple contains (S, T) values for a test case. Returns: list of int: Calculated Galactic Credits for each test case. # Code here # Test cases to validate the solution import pytest def test_calculate_galactic_credits_morning(): assert calculate_galactic_credits(10, 5) == 23 assert calculate_galactic_credits(5, 3) == 13 def test_calculate_galactic_credits_afternoon(): assert calculate_galactic_credits(20, 8) == 45 assert calculate_galactic_credits(10, 10) == 25 def test_calculate_galactic_credits_evening(): assert calculate_galactic_credits(15, 15) == 37 assert calculate_galactic_credits(7, 17) == 21 def test_calculate_galactic_credits_night(): assert calculate_galactic_credits(7, 23) == 25 assert calculate_galactic_credits(5, 20) == 21 def test_process_test_cases(): test_cases = [(10, 5), (20, 8), (15, 15), (7, 23)] assert process_test_cases(test_cases) == [23, 45, 37, 25] if __name__ == \\"__main__\\": pytest.main()","solution":"def calculate_galactic_credits(S, T): Calculates the number of Galactic Credits (G) based on the number of Star Coins (S) and the time (T) of conversion. Args: S (int): Number of Star Coins. T (int): Time of conversion in hours. Returns: int: Number of Galactic Credits (G). if 1 <= T <= 6: R = 3 elif 7 <= T <= 12: R = 5 elif 13 <= T <= 18: R = 7 elif 19 <= T <= 24: R = 11 G = (S * 2) + R return G def process_test_cases(test_cases): Processes multiple test cases to calculate Galactic Credits for each. Args: test_cases (list of tuples): Each tuple contains (S, T) values for a test case. Returns: list of int: Calculated Galactic Credits for each test case. results = [] for S, T in test_cases: results.append(calculate_galactic_credits(S, T)) return results"},{"question":"class Point: A class representing a point in 2D space. Attributes: x (float): The x-coordinate of the point. y (float): The y-coordinate of the point. Methods: distance_from_origin() -> float: Calculates the distance from the origin (0, 0). is_within_circle(radius: float) -> bool: Checks if the point is within a circle of given radius centered at origin. move_to(new_x: float, new_y: float): Moves the point to new coordinates. Example usage: >>> p = Point(3, 4) >>> p.distance_from_origin() 5.0 >>> p.is_within_circle(6) True >>> p.move_to(7, 1) >>> p.distance_from_origin() 7.0710678118654755 def __init__(self, x: float, y: float): Args: x (float): The x-coordinate of the point. y (float): The y-coordinate of the point. def distance_from_origin(self) -> float: Calculates the distance from the origin (0, 0). Returns: float: The distance from the origin. def is_within_circle(self, radius: float) -> bool: Checks if the point is within a circle of given radius centered at the origin. Args: radius (float): The radius of the circle. Returns: bool: True if the point is within the circle, False otherwise. def move_to(self, new_x: float, new_y: float): Moves the point to new coordinates. Args: new_x (float): The new x-coordinate of the point. new_y (float): The new y-coordinate of the point.","solution":"import math class Point: def __init__(self, x, y): self.x = x self.y = y def distance_from_origin(self): return math.sqrt(self.x**2 + self.y**2) def is_within_circle(self, radius): return self.distance_from_origin() <= radius def move_to(self, new_x, new_y): self.x = new_x self.y = new_y"},{"question":"def sort_products(products): Sorts a list of products based on the given criteria: 1. Primarily by price in descending order. 2. If two products have the same price, sort them by rating in ascending order. 3. If two products have the same price and rating, sort them by name in lexicographical order. Args: products (list of tuples): List of products where each product is represented by a tuple (name, price, rating) Returns: list of tuples: Sorted list of products based on the specified criteria. Examples: >>> sort_products([(\\"laptop\\", 1000, 4.5), (\\"phone\\", 500, 4.7), (\\"tablet\\", 1000, 4.0), (\\"smartwatch\\", 500, 4.3), (\\"monitor\\", 1500, 4.8)]) [(\\"monitor\\", 1500, 4.8), (\\"tablet\\", 1000, 4.0), (\\"laptop\\", 1000, 4.5), (\\"smartwatch\\", 500, 4.3), (\\"phone\\", 500, 4.7)] >>> sort_products([(\\"laptop\\", 1000, 4.5), (\\"tablet\\", 1000, 4.0), (\\"phone\\", 500, 4.7)]) [(\\"tablet\\", 1000, 4.0), (\\"laptop\\", 1000, 4.5), (\\"phone\\", 500, 4.7)] >>> sort_products([(\\"laptop\\", 1000, 4.5), (\\"tablet\\", 1000, 4.5), (\\"smartwatch\\", 500, 4.7)]) [(\\"laptop\\", 1000, 4.5), (\\"tablet\\", 1000, 4.5), (\\"smartwatch\\", 500, 4.7)] >>> sort_products([(\\"a\\", 500, 4.0), (\\"a\\", 500, 4.0)]) [(\\"a\\", 500, 4.0), (\\"a\\", 500, 4.0)] >>> sort_products([(\\"b\\", 1000, 4.5), (\\"a\\", 1000, 4.5)]) [(\\"a\\", 1000, 4.5), (\\"b\\", 1000, 4.5)]","solution":"def sort_products(products): Sorts a list of products based on the given criteria: 1. Primarily by price in descending order. 2. If two products have the same price, sort them by rating in ascending order. 3. If two products have the same price and rating, sort them by name in lexicographical order. Args: products (list of tuples): List of products where each product is represented by a tuple (name, price, rating) Returns: list of tuples: Sorted list of products based on the specified criteria. products_sorted = sorted(products, key=lambda x: (-x[1], x[2], x[0])) return products_sorted"},{"question":"def longest_common_prefix(strs): Create a function that accepts a list of strings and returns the longest common prefix among all strings. If there is no common prefix, return an empty string. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" >>> longest_common_prefix([]) \\"\\" >>> longest_common_prefix([\\"hello\\"]) \\"hello\\" >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) \\"test\\" >>> longest_common_prefix([\\"interview\\", \\"integral\\", \\"internet\\"]) \\"inte\\" >>> longest_common_prefix([\\"abc\\", \\"abcd\\", \\"abcee\\"]) \\"abc\\"","solution":"def longest_common_prefix(strs): Returns the longest common prefix among all strings in the list. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # The longest common prefix can be at most the length of the shortest string min_length = min(len(s) for s in strs) prefix = \\"\\" for i in range(min_length): # Get the current character from the first string char = strs[0][i] # Check if this character matches in all strings if all(s[i] == char for s in strs): prefix += char else: break return prefix"},{"question":"def alternating_sort(arr): Returns the array sorted in an alternating sequence of the maximum and minimum remaining elements from the unsorted part of the array. >>> alternating_sort([1, 3, 5, 2, 4, 6]) [6, 1, 5, 2, 4, 3] >>> alternating_sort([9, 7, 2, 5, 8]) [9, 2, 8, 5, 7] def process_test_cases(test_cases): Processes multiple test cases and outputs the results of alternating_sort for each test case. >>> input_data = [(6, 1, 3, 5, 2, 4, 6), (5, 9, 7, 2, 5, 8)] >>> process_test_cases(input_data) [[6, 1, 5, 2, 4, 3], [9, 2, 8, 5, 7]]","solution":"def alternating_sort(arr): Returns the array sorted in an alternating sequence of the maximum and minimum remaining elements from the unsorted part of the array. sorted_arr = sorted(arr) result = [] while sorted_arr: if sorted_arr: result.append(sorted_arr.pop()) if sorted_arr: result.append(sorted_arr.pop(0)) return result def process_test_cases(test_cases): results = [] for case in test_cases: N, *arr = case results.append(alternating_sort(arr)) return results"},{"question":"from typing import List, Dict def max_length_subarray(T: int, test_cases: List[Dict[str, any]]) -> List[int]: Returns the maximum length of a contiguous subarray where the sum is at most X for each test case. >>> max_length_subarray(2, [{'N': 5, 'X': 10, 'arr': [1, 2, 3, 4, 5]}, {'N': 3, 'X': 5, 'arr': [3, 1, 2]}]) [4, 2] >>> max_length_subarray(1, [{'N': 4, 'X': 2, 'arr': [3, 4, 5, 6]}]) [0] >>> max_length_subarray(2, [{'N': 1, 'X': 5, 'arr': [5]}, {'N': 1, 'X': 3, 'arr': [6]}]) [1, 0] >>> max_length_subarray(1, [{'N': 4, 'X': 10, 'arr': [1, 2, 3, 4]}]) [4] >>> max_length_subarray(1, [{'N': 5, 'X': 10, 'arr': [2, 2, 2, 2, 2]}]) [5]","solution":"def max_length_subarray(T, test_cases): Returns the maximum length of a contiguous subarray where the sum is at most X for each test case. results = [] for case in test_cases: N, X = case['N'], case['X'] arr = case['arr'] max_len = 0 current_sum = 0 start = 0 for end in range(N): current_sum += arr[end] while current_sum > X: current_sum -= arr[start] start += 1 max_len = max(max_len, end - start + 1) results.append(max_len) return results"},{"question":"def max_consecutive_packages(N: int, W: int, weights: List[int]) -> int: Calculate the maximum number of consecutive packages that can be placed on the conveyor belt without exceeding the weight limit. :param N: int, the number of packages :param W: int, the weight limit of the conveyor belt :param weights: List[int], the weights of the packages :return: int, the maximum number of consecutive packages >>> max_consecutive_packages(6, 50, [10, 20, 30, 10, 10, 10]) == 3 >>> max_consecutive_packages(5, 100, [25, 25, 25, 25, 25]) == 4 >>> max_consecutive_packages(3, 10, [15, 10, 25]) == 1 >>> max_consecutive_packages(4, 50, [10, 10, 10, 10]) == 4 >>> max_consecutive_packages(0, 50, []) == 0 >>> max_consecutive_packages(4, 10, [11, 12, 13, 14]) == 0","solution":"def max_consecutive_packages(N, W, weights): Calculate the maximum number of consecutive packages that can be placed on the conveyor belt without exceeding the weight limit. :param N: int, the number of packages :param W: int, the weight limit of the conveyor belt :param weights: List[int], the weights of the packages :return: int, the maximum number of consecutive packages max_packages = 0 current_weight = 0 start = 0 for end in range(N): current_weight += weights[end] while current_weight > W: current_weight -= weights[start] start += 1 max_packages = max(max_packages, end - start + 1) return max_packages"},{"question":"def min_operations_to_turn_off_all_lamps(n: int, m: int, grid: List[List[int]]) -> int: Returns the minimum number of operations required to turn off all lamps in the grid. :param n: Number of rows. :param m: Number of columns. :param grid: 2D list representing the initial state of the grid. :return: Minimum number of operations required to turn off all lamps. Examples: >>> min_operations_to_turn_off_all_lamps(3, 3, [[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 1 >>> min_operations_to_turn_off_all_lamps(2, 2, [[1, 1], [1, 1]]) 1 >>> min_operations_to_turn_off_all_lamps(4, 4, [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) 0 >>> min_operations_to_turn_off_all_lamps(1, 1, [[1]]) 1 >>> min_operations_to_turn_off_all_lamps(1, 1, [[0]]) 0","solution":"def min_operations_to_turn_off_all_lamps(n, m, grid): Returns the minimum number of operations required to turn off all lamps in the grid. :param n: Number of rows. :param m: Number of columns. :param grid: 2D list representing the initial state of the grid. :return: Minimum number of operations. for row in grid: if all(lamp == 0 for lamp in row): return 0 return 1"},{"question":"def missing_number(nums: List[int]) -> int: Given an integer array nums containing n distinct numbers in the range [0, n], find the one number that is missing from the array. Args: nums (list of int): The input array containing distinct numbers. Returns: int: The missing number. Examples: >>> missing_number([3, 0, 1, 4]) 2 >>> missing_number([0, 1, 3]) 2 >>> missing_number([0, 1, 2, 4, 5]) 3 >>> missing_number([8, 6, 4, 2, 3, 5, 7, 0, 1]) 9 >>> missing_number([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 10 >>> missing_number([1]) 0 >>> missing_number([0]) 1","solution":"def missing_number(nums): Returns the missing number from the array. Args: nums (list of int): The input array containing distinct numbers. Returns: int: The missing number. # Calculate the sum of the first n natural numbers n = len(nums) total_sum = n * (n + 1) / 2 # Calculate the sum of the array elements array_sum = sum(nums) # The missing number is the difference between total_sum and array_sum return int(total_sum - array_sum)"},{"question":"def min_time_to_collect_coins(T: int, cases: List[int]) -> List[int]: Calculates the minimum time required to collect all the coins in each level. Parameters: T (int): The number of test cases. cases (list): A list of integers where each integer represents the number of coins in a level. Returns: list: A list of integers where each integer represents the minimum time to collect all coins for a corresponding level. Examples: >>> min_time_to_collect_coins(3, [1, 2, 5]) [1, 1, 3] >>> min_time_to_collect_coins(2, [4, 7]) [2, 4] pass from typing import List def test_min_time_single_coin(): assert min_time_to_collect_coins(1, [1]) == [1] def test_min_time_consecutive_pairs(): assert min_time_to_collect_coins(2, [1, 2]) == [1, 1] def test_min_time_mixed_cases(): assert min_time_to_collect_coins(3, [1, 2, 5]) == [1, 1, 3] def test_min_time_large_number_of_coins(): assert min_time_to_collect_coins(1, [1000]) == [500] def test_min_time_multiple_cases(): assert min_time_to_collect_coins(4, [3, 4, 7, 10]) == [2, 2, 4, 5] def test_min_time_edge_cases(): assert min_time_to_collect_coins(2, [999, 1000]) == [500, 500]","solution":"def min_time_to_collect_coins(T, cases): Calculates the minimum time required to collect all the coins in each level. Parameters: T (int): The number of test cases. cases (list): A list of integers where each integer represents the number of coins in a level. Returns: list: A list of integers where each integer represents the minimum time to collect all coins for a corresponding level. results = [] for N in cases: # To collect N coins, we can collect in pairs (N//2) times, # and if there's an odd one left, it adds one more unit. min_time = (N // 2) + (N % 2) results.append(min_time) return results"},{"question":"def count_palindromic_substrings(s: str) -> (int, int): Returns the number of palindromic substrings and the length of the longest palindromic substring. >>> count_palindromic_substrings(\\"abc\\") (3, 1) >>> count_palindromic_substrings(\\"aaa\\") (6, 3) >>> count_palindromic_substrings(\\"racecar\\") (10, 7) def solve_palindromic_substrings(T: int, strings: List[str]) -> List[Tuple[int, int]]: Solve multiple test cases of the palindromic substrings problem. >>> solve_palindromic_substrings(3, [\\"abc\\", \\"aaa\\", \\"racecar\\"]) [(3, 1), (6, 3), (10, 7)] >>> solve_palindromic_substrings(2, [\\"a\\", \\"ab\\"]) [(1, 1), (2, 1)] >>> solve_palindromic_substrings(1, [\\"aba\\"]) [(4, 3)]","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings and the length of the longest palindromic substring. n = len(s) count = 0 longest_length = 1 dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True count += 1 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True count += 1 longest_length = 2 for length in range(3, n+1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True count += 1 longest_length = length return count, longest_length def solve_palindromic_substrings(T, strings): results = [] for s in strings: results.append(count_palindromic_substrings(s)) return results"},{"question":"from typing import List def max_product_of_two_numbers(arr: List[int]) -> int: Returns the maximum product of any two distinct numbers in the array. >>> max_product_of_two_numbers([1, 10, 5, 2]) 50 >>> max_product_of_two_numbers([-10, -20, 5, 3]) 200 >>> max_product_of_two_numbers([-1, -2, -3, -4]) 12 >>> max_product_of_two_numbers([0, -1, 2, 3]) 6 >>> max_product_of_two_numbers([2, 3]) 6 >>> max_product_of_two_numbers([10, 2, 3, -5, 12]) 120 >>> max_product_of_two_numbers([-10, 2]) -20","solution":"def max_product_of_two_numbers(arr): Returns the maximum product of any two distinct numbers in the array. if len(arr) < 2: raise ValueError(\\"Array should have at least two elements\\") # Sort the array to find the two largest and two smallest elements easily arr.sort() # The maximum product can be either: # - Product of the two largest elements # - Product of the two smallest elements (if they are both negative) max_product = max(arr[-1] * arr[-2], arr[0] * arr[1]) return max_product"},{"question":"def fizzBuzz(n: int) -> List[str]: Returns a list of strings where each string corresponds to a number from 1 to n, with multiples of three represented as \\"Fizz\\", multiples of five as \\"Buzz\\", and multiples of both three and five as \\"FizzBuzz\\". >>> fizzBuzz(3) [\\"1\\", \\"2\\", \\"Fizz\\"] >>> fizzBuzz(5) [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\"] >>> fizzBuzz(15) [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\"]","solution":"def fizzBuzz(n): Returns a list of strings where each string corresponds to a number from 1 to n, with multiples of three represented as \\"Fizz\\", multiples of five as \\"Buzz\\", and multiples of both three and five as \\"FizzBuzz\\". result = [] for i in range(1, n+1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a new list containing the products of all elements in the original list except the one at each position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 2, 3, 4]) [24, 0, 0, 0] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> product_except_self([5]) [1] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([3, 2, 1]) [2, 3, 6] >>> product_except_self([1, -1, 1, -1]) [1, -1, 1, -1] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([]) [] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1]","solution":"def product_except_self(nums): Given a list of integers, returns a new list containing the products of all elements in the original list except the one at each position. :param nums: List[int] :return: List[int] length = len(nums) if length == 0: return [] # Initialize left and right products array left_products = [1] * length right_products = [1] * length # Fill the left products array for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill the right products array for j in range(length - 2, -1, -1): right_products[j] = right_products[j + 1] * nums[j + 1] # Generate result array by multiplying left and right products result = [1] * length for k in range(length): result[k] = left_products[k] * right_products[k] return result"},{"question":"import math def largest_square_quilt(w: int, h: int) -> int: Returns the side length of the largest square quilt Aunt Caroline can make from the given width and height of the fabric piece. >>> largest_square_quilt(8, 6) 2 >>> largest_square_quilt(5, 9) 1","solution":"import math def largest_square_quilt(w, h): Returns the side length of the largest square quilt Aunt Caroline can make from the given width and height of the fabric piece. return math.gcd(w, h)"},{"question":"def count_clusters(grid, m, n): Counts the number of clusters of 'S' in the grid. >>> grid = [ ... ['S', '.', '.', '.'], ... ['S', 'S', '.', '.'], ... ['.', 'S', '.', '.'], ... ['.', '.', '.', '.'] ... ] >>> count_clusters(grid, 4, 4) 1 >>> grid = [ ... ['S', '.', '.', '.', 'S'], ... ['S', 'S', '.', '.', '.'], ... ['.', 'S', 'S', 'S', '.'], ... ['.', '.', '.', '.', '.'] ... ] >>> count_clusters(grid, 4, 5) 2 >>> grid = [ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ] >>> count_clusters(grid, 3, 3) 0 >>> grid = [ ... ['S', 'S', 'S'], ... ['S', 'S', 'S'], ... ['S', 'S', 'S'] ... ] >>> count_clusters(grid, 3, 3) 1 >>> grid = [ ... ['.', '.', '.'], ... ['.', 'S', '.'], ... ['.', '.', '.'] ... ] >>> count_clusters(grid, 3, 3) 1","solution":"def count_clusters(grid, m, n): Counts the number of clusters of 'S' in the grid. def dfs(x, y): Depth First Search to traverse and mark all connected 'S' cells. # Stack for the DFS stack = [(x, y)] while stack: cx, cy = stack.pop() if 0 <= cx < m and 0 <= cy < n and grid[cx][cy] == 'S': # Mark the cell as visited grid[cx][cy] = '.' # Add all horizontally and vertically connected cells to the stack stack.extend([(cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)]) clusters = 0 for i in range(m): for j in range(n): if grid[i][j] == 'S': # Start a DFS from the cell (i, j) dfs(i, j) clusters += 1 return clusters"},{"question":"def find_unique(nums: list) -> int: Returns the integer that appears only once in the array where every other integer appears twice. >>> find_unique([2, 3, 5, 4, 5, 3, 4]) 2 >>> find_unique([1, 1, 2, 3, 3]) 2","solution":"def find_unique(nums: list) -> int: Returns the integer that appears only once in the array where every other integer appears twice. This is done using bitwise XOR operation which ensures linear runtime and constant space. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations needed to transform the string s into a palindrome. >>> min_operations_to_palindrome('abca') 1 >>> min_operations_to_palindrome('racecar') 0 from solution import min_operations_to_palindrome def test_min_operations_palindrome(): assert min_operations_to_palindrome('abca') == 1 assert min_operations_to_palindrome('racecar') == 0 assert min_operations_to_palindrome('abcd') == 2 assert min_operations_to_palindrome('a') == 0 assert min_operations_to_palindrome('abcba') == 0 assert min_operations_to_palindrome('abccba') == 0 assert min_operations_to_palindrome('aabb') == 2 def test_corner_cases(): assert min_operations_to_palindrome('') == 0 # Empty string assert min_operations_to_palindrome('a' * 2000) == 0 # Already a palindrome with max length assert min_operations_to_palindrome('ab' * 1000) == 1000 # Non-palindrome with max length","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations needed to transform the string s into a palindrome. n = len(s) operations = 0 # Compare characters from both ends to the center for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"class NumMatrix: def __init__(self, n: int, m: int): Initialize the NumMatrix with n rows and m columns filled with zeros. self.n = n self.m = m self.matrix = [[0] * m for _ in range(n)] def update(self, x: int, y: int, val: int): Update the value at position (x, y) to val. self.matrix[x - 1][y - 1] = val def sum_region(self, x1: int, y1: int, x2: int, y2: int) -> int: Calculate the sum of the subrectangle from (x1, y1) to (x2, y2). total_sum = 0 for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): total_sum += self.matrix[i][j] return total_sum def process_operations(n: int, m: int, q: int, operations: List[str]) -> List[int]: Process a list of operations on a NumMatrix and return the results of the sum queries. >>> n, m, q = 3, 3, 5 >>> operations = [\\"UPDATE 1 1 5\\", \\"UPDATE 2 2 3\\", \\"SUM 1 1 2 2\\", \\"UPDATE 3 3 2\\", \\"SUM 1 1 3 3\\"] >>> process_operations(n, m, q, operations) [8, 10] num_matrix = NumMatrix(n, m) results = [] for op in operations: parts = op.split() if parts[0] == \\"UPDATE\\": x, y, val = int(parts[1]), int(parts[2]), int(parts[3]) num_matrix.update(x, y, val) elif parts[0] == \\"SUM\\": x1, y1, x2, y2 = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) result = num_matrix.sum_region(x1, y1, x2, y2) results.append(result) return results","solution":"class NumMatrix: def __init__(self, n, m): self.n = n self.m = m self.matrix = [[0] * m for _ in range(n)] def update(self, x, y, val): self.matrix[x - 1][y - 1] = val def sum_region(self, x1, y1, x2, y2): total_sum = 0 for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): total_sum += self.matrix[i][j] return total_sum def process_operations(n, m, q, operations): num_matrix = NumMatrix(n, m) results = [] for op in operations: parts = op.split() if parts[0] == \\"UPDATE\\": x, y, val = int(parts[1]), int(parts[2]), int(parts[3]) num_matrix.update(x, y, val) elif parts[0] == \\"SUM\\": x1, y1, x2, y2 = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) result = num_matrix.sum_region(x1, y1, x2, y2) results.append(result) return results"},{"question":"def longest_subarray_to_sort(arr): Returns the length of the longest subarray that, when sorted, results in the entire array being sorted. >>> longest_subarray_to_sort([1, 3, 5, 2, 6, 4, 7]) 5 >>> longest_subarray_to_sort([10, 12, 14, 7, 8, 9]) 6 >>> longest_subarray_to_sort([1, 2, 3, 4, 5]) 0 >>>","solution":"def longest_subarray_to_sort(arr): Returns the length of the longest subarray that, when sorted, results in the entire array being sorted. n = len(arr) if n <= 1: return 0 start, end = 0, n - 1 # Find the first element from the left that is out of order while start < n - 1 and arr[start] <= arr[start + 1]: start += 1 if start == n - 1: # The array is already sorted return 0 # Find the last element from the right that is out of order while end > 0 and arr[end] >= arr[end - 1]: end -= 1 subarray_min = min(arr[start:end + 1]) subarray_max = max(arr[start:end + 1]) # Extend the left boundary while start > 0 and arr[start - 1] > subarray_min: start -= 1 # Extend the right boundary while end < n - 1 and arr[end + 1] < subarray_max: end += 1 return end - start + 1"},{"question":"def max_power_diff(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum possible difference in power consumption between the house with the minimum power and the house with the maximum power after any number of valid transfers. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list containing t tuples. Each tuple contains an integer n (the number of houses) and a list of integers p representing the power consumption of each house. Returns: List[int]: A list containing the maximum possible difference in power consumption for each test case. >>> max_power_diff(3, [(4, [1, 3, 2, 4]), (3, [5, 1, 1]), (2, [10, 10])]) [3, 4, 0] >>> max_power_diff(1, [(4, [1, 1, 1, 1])]) [0] >>> max_power_diff(1, [(3, [1000000000, 500000000, 999999999])]) [500000000] >>> max_power_diff(1, [(2, [8, 15])]) [0]","solution":"def max_power_diff(t, test_cases): results = [] for case in test_cases: n, p = case if n == 2: results.append(0) else: min_power = min(p) max_power = max(p) max_diff = max_power - min_power results.append(max_diff) return results"},{"question":"from typing import List, Tuple def find_minimum_travel_cost(n: int, m: int, q: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the minimum travel cost from the starting city to the destination city. Args: n (int): The number of cities. m (int): The number of roads. q (int): The number of queries. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and c representing a road between city u and city v with a travel cost of c. queries (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers s and t representing the starting and destination cities for each query. Returns: List[int]: A list of integers where each integer represents the minimum travel cost for each query. If there is no way to travel, return -1. >>> find_minimum_travel_cost(5, 6, 3, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 3), (2, 5, 10), (4, 5, 1)], [(1, 4), (1, 5), (2, 4)]) [6, 7, 4] >>> find_minimum_travel_cost(4, 2, 1, [(1, 2, 1), (3, 4, 1)], [(1, 3)]) [-1] >>> find_minimum_travel_cost(4, 4, 2, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 3, 5)], [(1, 4), (1, 3)]) [4, 3] >>> find_minimum_travel_cost(1, 0, 1, [], [(1, 1)]) [0]","solution":"import heapq def dijkstra(n, edges, start, target): graph = {i: [] for i in range(1, n+1)} for u, v, c in edges: graph[u].append((v, c)) graph[v].append((u, c)) dist = {i: float('inf') for i in range(1, n+1)} dist[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_node == target: return current_distance if current_distance > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if dist[target] == float('inf') else dist[target] def find_minimum_travel_cost(n, m, q, roads, queries): results = [] for s, t in queries: results.append(dijkstra(n, roads, s, t)) return results"},{"question":"from typing import List, Tuple def maxPoints(points: List[Tuple[int, int]]) -> int: Determine the maximum number of points that lie on the same straight line. Args: points (List[Tuple[int, int]]): An array of tuples representing the coordinates of points on a 2D plane. Returns: int: The maximum number of points that lie on the same straight line. Examples: >>> maxPoints([(1,1), (2,2), (3,3)]) 3 >>> maxPoints([(1,1), (3,2), (5,3), (4,1), (2,3), (1,4)]) 4 from collections import defaultdict from math import gcd def test_maxPoints_simple(): points = [(1,1), (2,2), (3,3)] assert maxPoints(points) == 3 def test_maxPoints_general_case(): points = [(1,1), (3,2), (5,3), (4,1), (2,3), (1,4)] assert maxPoints(points) == 4 def test_maxPoints_one_point(): points = [(1,1)] assert maxPoints(points) == 1 def test_maxPoints_two_points(): points = [(1,1), (2,3)] assert maxPoints(points) == 2 def test_maxPoints_multiple_duplicates(): points = [(1,1), (1,1), (1,1)] assert maxPoints(points) == 3 def test_maxPoints_vertical_line(): points = [(1,1), (1,2), (1,3)] assert maxPoints(points) == 3 def test_maxPoints_horizontal_line(): points = [(1,3), (2,3), (3,3)] assert maxPoints(points) == 3","solution":"from collections import defaultdict from math import gcd from typing import List, Tuple def maxPoints(points: List[Tuple[int, int]]) -> int: def generate_key(dx, dy): if dx == 0: return (0, 1) if dy == 0: return (1, 0) sign = -1 if (dx < 0) ^ (dy < 0) else 1 g = gcd(abs(dx), abs(dy)) return (sign * abs(dx) // g, abs(dy) // g) if not points: return 0 n = len(points) if n <= 2: return n max_points = 0 for i in range(n): lines = defaultdict(int) duplicate = 1 for j in range(i + 1, n): if points[i] == points[j]: duplicate += 1 continue dx = points[j][0] - points[i][0] dy = points[j][1] - points[i][1] key = generate_key(dx, dy) lines[key] += 1 max_points = max(max_points, duplicate + max(lines.values(), default=0)) return max_points"},{"question":"def max_sum_of_squares(m: int, n: int, sequence: List[int]) -> int: Returns the maximum sum of squares of exactly n integers selected from the sequence. :param m: int, length of the sequence :param n: int, number of integers to select :param sequence: list of int, the sequence of integers :return: int, maximum sum of squares of n integers >>> max_sum_of_squares(5, 3, [1, 2, 3, 4, 5]) 50 >>> max_sum_of_squares(5, 3, [-1, -2, -3, -4, -5]) 50 >>> max_sum_of_squares(6, 3, [-1, 2, -3, 4, -5, 6]) 77 >>> max_sum_of_squares(1, 1, [7]) 49 >>> max_sum_of_squares(3, 2, [10000, -10000, 0]) 200000000","solution":"def max_sum_of_squares(m, n, sequence): Returns the maximum sum of squares of exactly n integers selected from the sequence. :param m: int, length of the sequence :param n: int, number of integers to select :param sequence: list of int, the sequence of integers :return: int, maximum sum of squares of n integers # Sort the sequence in descending order based on the absolute values sorted_sequence = sorted(sequence, key=abs, reverse=True) # Select the top n elements top_n_elements = sorted_sequence[:n] # Calculate the sum of squares sum_of_squares = sum(x ** 2 for x in top_n_elements) return sum_of_squares"},{"question":"from datetime import datetime, timedelta from collections import defaultdict class EventManagementSystem: def __init__(self): self.bookings = defaultdict(set) @staticmethod def date_range(start_date, end_date): start = datetime.strptime(start_date, \\"%Y-%m-%d\\") end = datetime.strptime(end_date, \\"%Y-%m-%d\\") delta = timedelta(days=1) while start <= end: yield start.strftime(\\"%Y-%m-%d\\") start += delta def book(self, room, start_date, end_date): Book the specified room for the date range from start_date to end_date inclusive. If the room is already booked for any of those dates, the system should not book the room and should report a conflict. >>> ems = EventManagementSystem() >>> ems.book(1, \\"2023-01-01\\", \\"2023-01-03\\") 'Booked' >>> ems.book(1, \\"2023-01-02\\", \\"2023-01-04\\") 'Conflict' def cancel(self, room, start_date, end_date): Cancel the booking for the specified room within the given date range. >>> ems = EventManagementSystem() >>> ems.book(1, \\"2023-01-01\\", \\"2023-01-03\\") 'Booked' >>> ems.cancel(1, \\"2023-01-02\\", \\"2023-01-02\\") 'Cancelled' >>> ems.check(1, \\"2023-01-02\\") 'no' def check(self, room, date): Check if the specified room is booked on the given date and report the result. >>> ems = EventManagementSystem() >>> ems.book(1, \\"2023-01-01\\", \\"2023-01-03\\") 'Booked' >>> ems.check(1, \\"2023-01-02\\") 'yes' >>> ems.cancel(1, \\"2023-01-02\\", \\"2023-01-02\\") 'Cancelled' >>> ems.check(1, \\"2023-01-02\\") 'no' def list(self, room, start_date, end_date): List all booked dates for the specified room within the provided date range in ascending order. >>> ems = EventManagementSystem() >>> ems.book(1, \\"2023-01-01\\", \\"2023-01-03\\") 'Booked' >>> ems.book(1, \\"2023-01-10\\", \\"2023-01-10\\") 'Booked' >>> ems.list(1, \\"2023-01-01\\", \\"2023-01-03\\") '2023-01-01n2023-01-02n2023-01-03' def main(): import sys input = sys.stdin.read data = input().strip().split('n') q = int(data[0]) ems = EventManagementSystem() for i in range(1, q + 1): query = data[i].split() operation = query[0] room = int(query[1]) if operation == \\"book\\": start_date, end_date = query[2], query[3] result = ems.book(room, start_date, end_date) print(result) elif operation == \\"cancel\\": start_date, end_date = query[2], query[3] result = ems.cancel(room, start_date, end_date) print(result) elif operation == \\"check\\": date = query[2] result = ems.check(room, date) print(result) elif operation == \\"list\\": start_date, end_date = query[2], query[3] result = ems.list(room, start_date, end_date) print(result) if __name__ == \\"__main__\\": main()","solution":"from datetime import datetime, timedelta from collections import defaultdict class EventManagementSystem: def __init__(self): self.bookings = defaultdict(set) @staticmethod def date_range(start_date, end_date): start = datetime.strptime(start_date, \\"%Y-%m-%d\\") end = datetime.strptime(end_date, \\"%Y-%m-%d\\") delta = timedelta(days=1) while start <= end: yield start.strftime(\\"%Y-%m-%d\\") start += delta def book(self, room, start_date, end_date): dates_to_book = set(self.date_range(start_date, end_date)) if any(date in self.bookings[room] for date in dates_to_book): return \\"Conflict\\" self.bookings[room].update(dates_to_book) return \\"Booked\\" def cancel(self, room, start_date, end_date): dates_to_cancel = set(self.date_range(start_date, end_date)) self.bookings[room].difference_update(dates_to_cancel) return \\"Cancelled\\" def check(self, room, date): return \\"yes\\" if date in self.bookings[room] else \\"no\\" def list(self, room, start_date, end_date): dates_in_range = sorted(self.date_range(start_date, end_date)) booked_dates = sorted(date for date in dates_in_range if date in self.bookings[room]) return \\"n\\".join(booked_dates) if booked_dates else \\"\\""},{"question":"def can_form_palindrome(s: str) -> str: Given a string of lowercase alphabets, determine if the string can be rearranged to form a palindrome. If possible, return \\"YES\\", otherwise return \\"NO\\". Examples: >>> can_form_palindrome(\\"racecar\\") \\"YES\\" >>> can_form_palindrome(\\"aabbcc\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\" pass","solution":"def can_form_palindrome(s: str) -> str: Determines if the string can be rearranged to form a palindrome. from collections import Counter # Get the frequency count of each character in the string char_counts = Counter(s) # Count the number of characters with odd occurrences odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def canFormString(s: str, wordsList: List[str]) -> bool: Determines if the string s can be formed by concatenating each word from wordsList exactly once and without any spaces. Args: s (str): The target string. wordsList (list): List of words to form the target string. Returns: bool: True if s can be formed, False otherwise. >>> canFormString(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> canFormString(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> canFormString(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> canFormString(\\"word\\", [\\"word\\"]) True >>> canFormString(\\"word\\", [\\"different\\"]) False","solution":"def canFormString(s, wordsList): Determines if the string s can be formed by concatenating each word from wordsList exactly once and without any spaces. Args: s (str): The target string. wordsList (list): List of words to form the target string. Returns: bool: True if s can be formed, False otherwise. concatenated_string = ''.join(wordsList) return s == concatenated_string"},{"question":"from typing import List def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list of numbers. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> length_of_LIS([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> length_of_LIS([0, 1, 0, 3, 2, 3]) 4 >>> length_of_LIS([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_LIS([10, 5, 8, 3, 9, 4, 12, 11]) 4 >>> length_of_LIS([10]) 1 >>> length_of_LIS([]) 0","solution":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence in the given list of numbers. if not nums: return 0 n = len(nums) dp = [1] * n # dp[i] will store the length of the longest increasing subsequence ending at i for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def count_substrings_start_end_same_char(s: str) -> int: Returns the number of substrings that start and end with the same character. >>> count_substrings_start_end_same_char(\\"abcab\\") 7 >>> count_substrings_start_end_same_char(\\"aaaa\\") 10 >>> count_substrings_start_end_same_char(\\"a\\") 1 >>> count_substrings_start_end_same_char(\\"ab\\") 2 pass def count_substrings_in_test_cases(num_cases: int, test_cases: List[str]) -> List[int]: Given the number of test cases and a list of test case strings, returns a list of integers with the number of substrings that start and end with the same character for each test case. >>> count_substrings_in_test_cases(2, [\\"abcab\\", \\"aaaa\\"]) [7, 10] >>> count_substrings_in_test_cases(3, [\\"abc\\", \\"ab\\", \\"a\\"]) [3, 2, 1] pass","solution":"def count_substrings_start_end_same_char(s): Returns the number of substrings that start and end with the same character. n = len(s) count = 0 # We will use a frequency dictionary to count occurrences of each character freq = {} # For every character in the string for i in range(n): char = s[i] if char in freq: count += freq[char] freq[char] += 1 else: freq[char] = 1 # Every character by itself is a valid substring count += 1 return count def count_substrings_in_test_cases(num_cases, test_cases): results = [] for s in test_cases: results.append(count_substrings_start_end_same_char(s)) return results"},{"question":"def find_closest_pair(A: List[int], B: List[int]) -> Tuple[int, int]: Find the closest pair of elements between two sorted sets A and B. >>> find_closest_pair([1, 3, 15, 20], [8, 10, 12, 16, 17]) (15, 16) >>> find_closest_pair([1, 2, 3], [4, 5, 6]) (3, 4) >>> find_closest_pair([1], [2]) (1, 2) >>> find_closest_pair([1, 4, 7], [2, 5, 8]) (1, 2) >>> find_closest_pair([10, 20, 30], [15, 25]) (10, 15)","solution":"def find_closest_pair(A, B): n = len(A) m = len(B) i = j = 0 min_diff = float('inf') closest_pair = (A[0], B[0]) while i < n and j < m: diff = abs(A[i] - B[j]) if diff < min_diff: min_diff = diff closest_pair = (A[i], B[j]) if A[i] < B[j]: i += 1 else: j += 1 return closest_pair"},{"question":"def count_distinct_substrings(s: str) -> int: Count the number of distinct substrings in a given string s. Args: s (str): Input string. Returns: int: Number of distinct substrings. >>> count_distinct_substrings(\\"banana\\") 15 >>> count_distinct_substrings(\\"a\\") 1 >>> count_distinct_substrings(\\"aa\\") 2 >>> count_distinct_substrings(\\"ab\\") 3 >>> count_distinct_substrings(\\"racecar\\") 25 >>> count_distinct_substrings(\\"abab\\") 7 >>> count_distinct_substrings(\\"abcd\\") 10 pass # Your implementation goes here","solution":"def count_distinct_substrings(s): Count the number of distinct substrings in a given string s. Args: s (str): Input string. Returns: int: Number of distinct substrings. # Using a set to store all unique substrings substrings = set() # Iterate over all possible starting points in the string for i in range(len(s)): # Iterate over all possible ending points from the current starting point for j in range(i + 1, len(s) + 1): # Add the substring from index i to j (exclusive) to the set substrings.add(s[i:j]) # The number of distinct substrings is the size of the set return len(substrings)"},{"question":"def classify_problem(n: int, e: int) -> (str, str): Classify the problem based on problem size n and algorithm efficiency type e. Parameters: n (int): Number of operations in the problem. e (int): Algorithm efficiency type (1, 2, or 3). Returns: str: Problem classification (\\"Easy\\", \\"Medium\\", or \\"Hard\\"). str: Solvability (\\"Solvable\\" or \\"Not Solvable\\"). Examples: >>> classify_problem(500000, 2) == (\\"Easy\\", \\"Solvable\\") >>> classify_problem(6000000, 2) == (\\"Medium\\", \\"Solvable\\") >>> classify_problem(12000000, 3) == (\\"Hard\\", \\"Solvable\\") >>> classify_problem(12000000, 2) == (\\"Hard\\", \\"Not Solvable\\") >>> classify_problem(900000, 1) == (\\"Easy\\", \\"Solvable\\")","solution":"def classify_problem(n, e): Classify the problem based on problem size n and algorithm efficiency type e. Parameters: n (int): Number of operations in the problem. e (int): Algorithm efficiency type (1, 2, or 3). Returns: str: Problem classification (\\"Easy\\", \\"Medium\\", or \\"Hard\\"). str: Solvability (\\"Solvable\\" or \\"Not Solvable\\"). # Classify the problem based on the number of operations if n <= 1_000_000: classification = \\"Easy\\" elif n <= 10_000_000: classification = \\"Medium\\" else: classification = \\"Hard\\" # Determine the solvability based on the efficiency type if e == 1 and n <= 5_000_000: solvability = \\"Solvable\\" elif e == 2 and n <= 10_000_000: solvability = \\"Solvable\\" elif e == 3: solvability = \\"Solvable\\" else: solvability = \\"Not Solvable\\" return classification, solvability"},{"question":"def reduce_boxes(A, B, C, capacity): Determines the fewest number of boxes to remove to match the shipment capacity. Parameters: A (int): Number of boxes of Apples. B (int): Number of boxes of Bananas. C (int): Number of boxes of Cherries. capacity (int): Maximum number of boxes that can be shipped. Returns: int: Fewest number of boxes that need to be removed to meet the shipment capacity. >>> reduce_boxes(10, 15, 20, 40) 5 >>> reduce_boxes(50, 50, 50, 200) 0 >>> reduce_boxes(33, 44, 55, 132) 0 >>> reduce_boxes(20, 30, 40, 80) 10 >>> reduce_boxes(1000, 1000, 1000, 3000) 0 >>> reduce_boxes(1, 1, 1, 1) 2 >>> reduce_boxes(10, 0, 0, 5) 5","solution":"def reduce_boxes(A, B, C, capacity): Determines the fewest number of boxes to remove to match the shipment capacity. Parameters: A (int): Number of boxes of Apples. B (int): Number of boxes of Bananas. C (int): Number of boxes of Cherries. capacity (int): Maximum number of boxes that can be shipped. Returns: int: Fewest number of boxes that need to be removed to meet the shipment capacity. total = A + B + C if total <= capacity: return 0 return total - capacity"},{"question":"def smallest_lexicographic_string(S: str, R: int) -> str: Removes exactly R characters from string S to form the lexicographically smallest possible string. >>> smallest_lexicographic_string('abcde', 2) 'abc' >>> smallest_lexicographic_string('xyzab', 3) 'ab' >>> smallest_lexicographic_string('hello', 1) 'ello' def process_test_cases(T: int, test_cases: List[Tuple[str, int]]) -> List[str]: Processes the test cases and returns the results for each case. >>> process_test_cases(3, [('abcde', 2), ('xyzab', 3), ('hello', 1)]) ['abc', 'ab', 'ello']","solution":"def smallest_lexicographic_string(S, R): Removes exactly R characters from string S to form the lexicographically smallest possible string. n = len(S) stack = [] for i in range(n): while stack and R > 0 and stack[-1] > S[i]: stack.pop() R -= 1 stack.append(S[i]) # If there are any R removals left, remove from the end final_string = ''.join(stack[:len(stack) - R]) return final_string def process_test_cases(T, test_cases): Processes the test cases and prints the results for each case. results = [] for i in range(T): S, R = test_cases[i] R = int(R) result = smallest_lexicographic_string(S, R) results.append(result) return results"},{"question":"def longest_common_subsequence(a: str, b: str) -> int: Calculate the longest common subsequence (LCS) length between two strings. >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"aebdc\\") 3 >>> longest_common_subsequence(\\"abcdef\\", \\"acbcf\\") 4 def find_best_answer(n: int, qa_pairs: List[Tuple[str, str]], user_question: str) -> str: Find the most relevant predefined answer to the user input question based on LCS. >>> qa_pairs = [(\\"How is the weather today?\\", \\"It's sunny.\\"), (\\"What time is it?\\", \\"It is 5 PM.\\"), (\\"Do you like pizza?\\", \\"Yes, I love pizza.\\")] >>> user_question = \\"What time is it now?\\" >>> find_best_answer(3, qa_pairs, user_question) \\"It is 5 PM.\\" >>> qa_pairs = [(\\"How is the weather today?\\", \\"It's sunny.\\"), (\\"Do you like pizza?\\", \\"Yes, I love pizza.\\")] >>> user_question = \\"Do you like pizza?\\" >>> find_best_answer(2, qa_pairs, user_question) \\"Yes, I love pizza.\\" >>> user_question = \\"Is it sunny today?\\" >>> find_best_answer(2, qa_pairs, user_question) \\"It's sunny.\\"","solution":"def longest_common_subsequence(a, b): m, n = len(a), len(b) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def find_best_answer(n, qa_pairs, user_question): best_lcs = -1 best_answer = \\"\\" for i in range(n): predefined_question = qa_pairs[i][0] lcs = longest_common_subsequence(predefined_question, user_question) if lcs > best_lcs: best_lcs = lcs best_answer = qa_pairs[i][1] return best_answer"},{"question":"def rotateArray(arr: List[int], k: int) -> None: Rotates the elements of the array to the right by k positions in-place. Parameters: arr (List[int]): The input array. k (int): The number of positions to rotate. Example: >>> arr = [1, 2, 3, 4, 5] >>> rotateArray(arr, 2) >>> arr [4, 5, 1, 2, 3] >>> arr = [6, 7, 8, 9, 10] >>> rotateArray(arr, 3) >>> arr [8, 9, 10, 6, 7] def test_rotateArray_case1(): arr = [1, 2, 3, 4, 5] rotateArray(arr, 2) assert arr == [4, 5, 1, 2, 3] def test_rotateArray_case2(): arr = [6, 7, 8, 9, 10] rotateArray(arr, 3) assert arr == [8, 9, 10, 6, 7] def test_rotateArray_k_zero(): arr = [1, 2, 3, 4, 5] rotateArray(arr, 0) assert arr == [1, 2, 3, 4, 5] def test_rotateArray_k_equal_to_length(): arr = [1, 2, 3, 4, 5] rotateArray(arr, 5) assert arr == [1, 2, 3, 4, 5] def test_rotateArray_k_greater_than_length(): arr = [1, 2, 3, 4, 5] rotateArray(arr, 7) assert arr == [4, 5, 1, 2, 3] def test_rotateArray_single_element(): arr = [1] rotateArray(arr, 3) assert arr == [1]","solution":"def rotateArray(arr, k): Rotates the elements of the array to the right by k positions in-place. :param arr: List[int], the input array :param k: int, the number of positions to rotate n = len(arr) k %= n # Handle cases where k >= n if k == 0: return # Reverse the entire array arr.reverse() # Reverse the first k elements arr[:k] = reversed(arr[:k]) # Reverse the remaining elements arr[k:] = reversed(arr[k:])"},{"question":"def sum_of_prime_factors(N: int) -> int: Returns the sum of prime factors of N. Each prime factor is counted only once. >>> sum_of_prime_factors(28) 9 >>> sum_of_prime_factors(100) 7 def process_queries(T: int, queries: List[int]) -> List[int]: Processes multiple queries and returns a list of sums of prime factors for each query. >>> process_queries(2, [28, 100]) [9, 7] >>> process_queries(3, [2, 3, 4]) [2, 3, 2] # Unit Test def test_sum_of_prime_factors(): assert sum_of_prime_factors(28) == 9 assert sum_of_prime_factors(100) == 7 assert sum_of_prime_factors(2) == 2 assert sum_of_prime_factors(1) == 0 assert sum_of_prime_factors(3) == 3 assert sum_of_prime_factors(12) == 5 assert sum_of_prime_factors(49) == 7 def test_process_queries(): assert process_queries(2, [28, 100]) == [9, 7] assert process_queries(3, [2, 3, 4]) == [2, 3, 2] assert process_queries(1, [1]) == [0] assert process_queries(2, [12, 49]) == [5, 7]","solution":"def sum_of_prime_factors(N): Returns the sum of prime factors of N. Each prime factor is counted only once. if N < 2: return 0 sum_primes = 0 # Check for number of 2s that divide N if N % 2 == 0: sum_primes += 2 while N % 2 == 0: N = N // 2 # Check for other primes, starting from 3 to sqrt(N) for i in range(3, int(N**0.5) + 1, 2): if N % i == 0: sum_primes += i while N % i == 0: N = N // i # If N is a prime number greater than 2 if N > 2: sum_primes += N return sum_primes def process_queries(T, queries): results = [] for N in queries: results.append(sum_of_prime_factors(N)) return results"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Perform a series of operations on an array and return the results of type 1 queries. Examples: >>> process_queries(5, 5, [1, 2, 2, 3, 4], [(1, 1, 3), (1, 2, 4), (2, 2, 3), (1, 1, 3), (1, 1, 5)]) [2, 2, 3, 4] >>> process_queries(1, 2, [1], [(1, 1, 1), (2, 1, 2)]) [1] >>> process_queries(3, 0, [1, 2, 2], []) [] >>> process_queries(4, 4, [1, 2, 2, 3], [(1, 1, 4), (2, 3, 1), (1, 1, 4), (2, 4, 4)]) [3, 3] >>> process_queries(100000, 1, list(range(1, 100001)), [(1, 1, 100000)]) [100000]","solution":"def process_queries(n, q, array, queries): result = [] for query in queries: if query[0] == 1: l, r = query[1] - 1, query[2] - 1 subarray = array[l:r+1] distinct_elements = len(set(subarray)) result.append(distinct_elements) elif query[0] == 2: idx, val = query[1] - 1, query[2] array[idx] = val return result # Example usage n = 5 q = 5 array = [1, 2, 2, 3, 4] queries = [ (1, 1, 3), (1, 2, 4), (2, 2, 3), (1, 1, 3), (1, 1, 5) ] print(process_queries(n, q, array, queries)) # Expected output: [2, 2, 3, 4]"},{"question":"import re from collections import Counter def can_form_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"A man, a plan, a canal, Panama\\") True","solution":"import re from collections import Counter def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. Args: s (str): Input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Count character frequencies char_counts = Counter(cleaned) # Count how many characters have an odd count odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def balloon_race(n: int, weights: List[int]) -> int: Determines the lowest possible combined weight for the contiguous balloons inflated by the second container. Parameters: n (int): Number of balloons. weights (list of int): List containing weights of the balloons. Returns: int: Lowest possible combined weight for the contiguous balloons. >>> balloon_race(5, [2, 3, 1, 5, 4]) 1 >>> balloon_race(2, [1, 2]) 1 >>> balloon_race(2, [2, 2]) 2 >>> balloon_race(5, [3, 3, 3, 3, 3]) 3 >>> balloon_race(4, [10, 8, 5, 2]) 2 >>> balloon_race(4, [1, 2, 3, 5]) 1 >>> balloon_race(6, [8, 1, 7, 3, 4, 2]) 1","solution":"def balloon_race(n, weights): Determines the lowest possible combined weight for the contiguous balloons inflated by the second container. Parameters: n (int): Number of balloons. weights (list of int): List containing weights of the balloons. Returns: int: Lowest possible combined weight for the contiguous balloons. return min(weights)"},{"question":"def max_gold_steal(G: List[int]) -> int: Returns the maximum amount of gold that can be stolen without stealing from two consecutive houses. >>> max_gold_steal([5]) 5 >>> max_gold_steal([5, 6]) 6 >>> max_gold_steal([5, 6, 10]) 15 >>> max_gold_steal([10, 2, 7]) 17 >>> max_gold_steal([6, 7, 1, 30, 8, 2, 4]) 41 >>> max_gold_steal([1, 2, 3, 4, 5]) 9 >>> max_gold_steal([10, 10, 10, 10, 10]) 30 >>> max_gold_steal([10**9, 10**9, 10**9, 10**9, 10**9]) 3000000000","solution":"def max_gold_steal(G): Returns the maximum amount of gold that can be stolen without stealing from two consecutive houses. if not G: return 0 N = len(G) if N == 1: return G[0] if N == 2: return max(G[0], G[1]) dp = [0] * N dp[0] = G[0] dp[1] = max(G[0], G[1]) for i in range(2, N): dp[i] = max(G[i] + dp[i-2], dp[i-1]) return dp[-1] # Example usage: if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) G = list(map(int, data[1:])) print(max_gold_steal(G))"},{"question":"def tsp(n: int, dist: List[List[int]]) -> int: Given a list of cities and the distances between each pair of cities, find the shortest possible route that visits each city exactly once and returns to the starting city (Traveling Salesperson Problem). >>> tsp(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> tsp(3, [[0, 29, 20], [29, 0, 15], [20, 15, 0]]) 64","solution":"def tsp(n, dist): def tsp_util(cur_city, visited): # If all cities have been visited, return to start if visited == (1 << n) - 1: return dist[cur_city][0] # If result already computed if dp[cur_city][visited] != -1: return dp[cur_city][visited] # Initialize the minimum cost to infinity min_cost = float('inf') # Try to go to an unvisited city for i in range(n): if not visited & (1 << i): new_cost = dist[cur_city][i] + tsp_util(i, visited | (1 << i)) min_cost = min(min_cost, new_cost) # Store and return the result dp[cur_city][visited] = min_cost return dp[cur_city][visited] dp = [[-1] * (1 << n) for _ in range(n)] return tsp_util(0, 1)"},{"question":"def minimum_moves_to_equal_stacks(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum number of moves required to equalize the height of stacks of blocks. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): A list consisting of tuples. Each tuple consists of an integer 'n', the number of stacks followed by a list of integers representing the heights of stacks. Returns: List[int]: A list of integers each representing the minimum number of moves required for each test case. Example: >>> minimum_moves_to_equal_stacks(3, [(3, [1, 2, 3]), (2, [4, 4]), (4, [5, 5, 5, 5])]) [2, 0, 0] >>> minimum_moves_to_equal_stacks(1, [(5, [1, 1, 1, 1, 10000])]) [9999]","solution":"def minimum_moves_to_equal_stacks(t, test_cases): results = [] for i in range(t): n, heights = test_cases[i] median_height = sorted(heights)[n // 2] moves = sum(abs(h - median_height) for h in heights) results.append(moves) return results"},{"question":"def warehouse_operations(n, operations): Function to process warehouse operations and return the results of queries. :param n: Number of operations (int) :param operations: List of strings where each string is an operation of the form \\"add X Y\\" or \\"query X\\" :return: List of integers which are the results of the queries >>> warehouse_operations(6, [\\"add 12345 100\\", \\"add 12345 50\\", \\"query 12345\\", \\"add 67890 200\\", \\"query 67890\\", \\"query 12345\\"]) [150, 200, 150] >>> warehouse_operations(5, [\\"add 111 10\\", \\"add 222 20\\", \\"query 333\\", \\"add 111 5\\", \\"query 111\\"]) [0, 15]","solution":"def warehouse_operations(n, operations): Function to process warehouse operations and return the results of queries. :param n: Number of operations (int) :param operations: List of strings where each string is an operation of the form \\"add X Y\\" or \\"query X\\" :return: List of integers which are the results of the queries stock = {} results = [] for operation in operations: parts = operation.split() if parts[0] == \\"add\\": product_code = int(parts[1]) quantity = int(parts[2]) if product_code in stock: stock[product_code] += quantity else: stock[product_code] = quantity elif parts[0] == \\"query\\": product_code = int(parts[1]) results.append(stock.get(product_code, 0)) return results"},{"question":"def longest_alternating_sequence(N, books): Find the length of the longest sequence of books that alternates between strictly increasing and strictly decreasing in size. Args: N (int): Number of books. books (List[int]): A list of book sizes. Returns: int: The length of the longest alternating sequence. >>> longest_alternating_sequence(5, [1, 3, 2, 4, 5]) == 4 >>> longest_alternating_sequence(4, [10, 5, 10, 5]) == 4 def process_cases(T, cases): Process multiple test cases to find the longest alternating sequence for each. Args: T (int): The number of test cases. cases (List[Tuple[int, List[int]]]): A list of tuples containing the number of books and the list of book sizes for each test case. Returns: List[int]: A list containing the length of the longest alternating sequence for each test case. >>> process_cases(2, [(5, [1, 3, 2, 4, 5]), (4, [10, 5, 10, 5])]) == [4, 4] >>> process_cases(1, [(3, [1, 2, 3])]) == [2] # Unit tests def test_longest_alternating_sequence(): assert longest_alternating_sequence(5, [1, 3, 2, 4, 5]) == 4 assert longest_alternating_sequence(4, [10, 5, 10, 5]) == 4 assert longest_alternating_sequence(3, [1, 2, 3]) == 2 assert longest_alternating_sequence(6, [1, 3, 2, 4, 3, 5]) == 6 assert longest_alternating_sequence(0, []) == 0 assert longest_alternating_sequence(1, [1]) == 1 assert longest_alternating_sequence(2, [5, 5]) == 1 assert longest_alternating_sequence(7, [10, 5, 15, 10, 20, 15, 25]) == 7 def test_process_cases(): assert process_cases(2, [(5, [1, 3, 2, 4, 5]), (4, [10, 5, 10, 5])]) == [4, 4] assert process_cases(1, [(3, [1, 2, 3])]) == [2] # Run the tests test_longest_alternating_sequence() test_process_cases()","solution":"def longest_alternating_sequence(N, books): if N == 0: return 0 inc = 1 dec = 1 for i in range(1, N): if books[i] > books[i - 1]: inc = dec + 1 elif books[i] < books[i - 1]: dec = inc + 1 return max(inc, dec) def process_cases(T, cases): results = [] for i in range(T): N = cases[i][0] books = cases[i][1] results.append(longest_alternating_sequence(N, books)) return results"},{"question":"def top_3_topics(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Identify the top 3 most discussed topics in Tom's chat log for each test case. >>> top_3_topics(2, [(5, [\\"sports\\", \\"weather\\", \\"sports\\", \\"music\\", \\"weather\\"]), (3, [\\"science\\", \\"art\\", \\"science\\"])]) [\\"sports weather music\\", \\"science art\\"] >>> top_3_topics(1, [(7, [\\"travel\\", \\"travel\\", \\"food\\", \\"sports\\", \\"travel\\", \\"sports\\", \\"weather\\"])]) [\\"travel sports food\\"] from solution import top_3_topics # Assuming the solution is in a file named solution.py def test_case_1(): t = 2 test_cases = [ (5, [\\"sports\\", \\"weather\\", \\"sports\\", \\"music\\", \\"weather\\"]), (3, [\\"science\\", \\"art\\", \\"science\\"]) ] expected_output = [\\"sports weather music\\", \\"science art\\"] assert top_3_topics(t, test_cases) == expected_output def test_case_2(): t = 1 test_cases = [ (7, [\\"travel\\", \\"travel\\", \\"food\\", \\"sports\\", \\"travel\\", \\"sports\\", \\"weather\\"]) ] expected_output = [\\"travel sports food\\"] assert top_3_topics(t, test_cases) == expected_output def test_case_3(): t = 1 test_cases = [ (4, [\\"a\\", \\"b\\", \\"c\\", \\"a\\"]) ] expected_output = [\\"a b c\\"] assert top_3_topics(t, test_cases) == expected_output def test_case_4(): t = 1 test_cases = [ (2, [\\"technology\\", \\"science\\"]) ] expected_output = [\\"science technology\\"] assert top_3_topics(t, test_cases) == expected_output def test_case_5(): t = 1 test_cases = [ (10, [\\"x\\", \\"x\\", \\"y\\", \\"y\\", \\"y\\", \\"z\\", \\"z\\", \\"z\\", \\"z\\", \\"x\\"]) ] expected_output = [\\"z x y\\"] assert top_3_topics(t, test_cases) == expected_output def test_case_with_case_sensitivity(): t = 1 test_cases = [ (5, [\\"Topic\\", \\"topic\\", \\"TOPIC\\", \\"Topic\\", \\"TOPIC\\"]) ] expected_output = [\\"TOPIC Topic topic\\"] assert top_3_topics(t, test_cases) == expected_output","solution":"def top_3_topics(t, test_cases): from collections import Counter results = [] for i in range(t): n, topics = test_cases[i] topic_counts = Counter(topics) sorted_topics = sorted(topic_counts.items(), key=lambda x: (-x[1], x[0])) top_3_discussed = [topic for topic, count in sorted_topics[:3]] results.append(\\" \\".join(top_3_discussed)) return results # Example usage if __name__ == \\"__main__\\": t = 2 test_cases = [ (5, [\\"sports\\", \\"weather\\", \\"sports\\", \\"music\\", \\"weather\\"]), (3, [\\"science\\", \\"art\\", \\"science\\"]) ] output = top_3_topics(t, test_cases) for line in output: print(line)"},{"question":"def determine_winner(n: int, sequence: List[int]) -> str: Determines the winner of the game given the sequence length and the sequence. >>> determine_winner(3, [1, 2, 3]) == \\"Alice\\" >>> determine_winner(4, [1, 2, 2, 1]) == \\"Bob\\" >>> determine_winner(1, [5]) == \\"Alice\\" >>> determine_winner(2, [10, 20]) == \\"Bob\\" >>> determine_winner(99999, [1] * 99999) == \\"Alice\\" >>> determine_winner(100000, [1] * 100000) == \\"Bob\\" pass","solution":"def determine_winner(n, sequence): Determines the winner of the game given the sequence length and the sequence. if n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def team_leaders(preference_scores): Given the preference scores of participants, this function returns the highest preference score for each participant. Args: preference_scores (list of int): List of preference scores of participants. Returns: list of int: List containing the highest preference score for each participant. >>> team_leaders([10, 20, 15, 25, 30]) [30, 30, 30, 30, 30] >>> team_leaders([1, 2, 3, 4, 5]) [5, 5, 5, 5, 5] >>> team_leaders([50, 50, 50]) [50, 50, 50]","solution":"def team_leaders(preference_scores): Given the preference scores of participants, this function returns the highest preference score for each participant. Args: preference_scores (list of int): List of preference scores of participants. Returns: list of int: List containing the highest preference score for each participant. max_score = max(preference_scores) return [max_score] * len(preference_scores)"},{"question":"def subsetSum(N: int, X: int, A: List[int]) -> bool: Determine if there exists a subset of array A of size N that sums to X. Uses dynamic programming to solve the subset sum problem. :param N: Integer, size of the array :param X: Integer, the target sum :param A: List of integers, the array elements :return: Boolean, True if there exists a subset with sum equal to X, otherwise False >>> subsetSum(5, 9, [3, 34, 4, 12, 5, 2]) True >>> subsetSum(6, 30, [3, 34, 4, 12, 5, 2]) False >>> subsetSum(3, 0, [1, 2, 3]) True >>> subsetSum(1, 5, [5]) True >>> subsetSum(1, 4, [5]) False >>> subsetSum(5, 15, [3, 4, 5, 2, 1]) True >>> subsetSum(0, 0, []) True >>> subsetSum(0, 1, []) False","solution":"def subsetSum(N, X, A): Determine if there exists a subset of array A of size N that sums to X. Uses dynamic programming to solve the subset sum problem. :param N: Integer, size of the array :param X: Integer, the target sum :param A: List of integers, the array elements :return: Boolean, True if there exists a subset with sum equal to X, otherwise False # Create a DP array to store results of subproblems dp = [False] * (X + 1) dp[0] = True # there is always a subset with sum 0, which is the empty subset for num in A: for j in range(X, num - 1, -1): if dp[j - num]: dp[j] = True return dp[X]"},{"question":"import bisect class OrderedSet: def __init__(self): self.elements = [] def insert(self, x): Insert the integer x into the set. pass def remove(self, x): Remove the integer x from the set if it exists. pass def findRank(self, x): Find the rank of the integer x in the set. >>> os = OrderedSet() >>> os.insert(5) >>> os.insert(10) >>> os.insert(3) >>> os.findRank(5) 2 >>> os.findRank(10) 3 >>> os.findRank(1) -1 pass def findKth(self, k): Find the k-th smallest element in the set. >>> os = OrderedSet() >>> os.insert(5) >>> os.insert(10) >>> os.insert(3) >>> os.findKth(2) 5 >>> os.findKth(1) 3 >>> os.findKth(4) -1 pass def process_queries(queries): Process a list of queries and return the corresponding results for each \`findRank\` and \`findKth\` query. >>> queries = [ ... \\"insert 5\\", ... \\"insert 10\\", ... \\"insert 3\\", ... \\"findRank 5\\", ... \\"findKth 2\\", ... \\"remove 10\\", ... \\"findKth 3\\", ... \\"remove 5\\", ... \\"findRank 3\\", ... \\"findKth 1\\" ... ] >>> process_queries(queries) ['2', '5', '-1', '1', '3'] pass","solution":"import bisect class OrderedSet: def __init__(self): self.elements = [] def insert(self, x): if x not in self.elements: bisect.insort(self.elements, x) def remove(self, x): if x in self.elements: self.elements.remove(x) def findRank(self, x): pos = bisect.bisect_left(self.elements, x) if pos < len(self.elements) and self.elements[pos] == x: return pos + 1 return -1 def findKth(self, k): if 0 < k <= len(self.elements): return self.elements[k - 1] return -1 def process_queries(queries): ordered_set = OrderedSet() result = [] for query in queries: parts = query.split() command = parts[0] value = int(parts[1]) if command == 'insert': ordered_set.insert(value) elif command == 'remove': ordered_set.remove(value) elif command == 'findRank': result.append(str(ordered_set.findRank(value))) elif command == 'findKth': result.append(str(ordered_set.findKth(value))) return result"},{"question":"from collections import defaultdict, Counter from typing import List, Dict, Tuple def most_frequent_category(T: int, cases: List[Tuple[int, List[Tuple[str, str]]]]) -> List[Dict[str, str]]: Determine the most frequently purchased product category for each user. Args: T: The number of test cases. cases: A list of tuples where each tuple consists of an integer N (the number of purchases) and a list of tuples containing user ID and product category. Returns: A list of dictionaries where the keys are the user IDs and the values are the most frequently purchased product category for that user. Test cases: >>> most_frequent_category(2, [(6, [(\\"user1\\", \\"electronics\\"), (\\"user2\\", \\"electronics\\"), (\\"user1\\", \\"books\\"), (\\"user1\\", \\"electronics\\"), (\\"user2\\", \\"books\\"), (\\"user2\\", \\"books\\")]), (4, [(\\"user3\\", \\"groceries\\"), (\\"user3\\", \\"groceries\\"), (\\"user3\\", \\"electronics\\"), (\\"user4\\", \\"books\\")])]) [{'user1': 'electronics', 'user2': 'books'}, {'user3': 'groceries', 'user4': 'books'}] >>> most_frequent_category(1, [(4, [(\\"user1\\", \\"electronics\\"), (\\"user1\\", \\"books\\"), (\\"user1\\", \\"electronics\\"), (\\"user1\\", \\"books\\")])]) [{'user1': 'electronics'}]","solution":"def most_frequent_category(T, cases): from collections import defaultdict, Counter results = [] for i in range(T): N = cases[i][0] purchases = cases[i][1] user_category_counts = defaultdict(Counter) for user, category in purchases: user_category_counts[user][category] += 1 result = {} for user, category_count in user_category_counts.items(): most_common_category = category_count.most_common(1)[0][0] result[user] = most_common_category results.append(result) return results # Helper function to parse input def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 cases = [] for _ in range(T): N = int(input_lines[index]) purchases = [] for j in range(N): user, category = input_lines[index + j + 1].split() purchases.append((user, category)) cases.append((N, purchases)) index += N + 1 return T, cases # Example usage input_str = 2 6 user1 electronics user2 electronics user1 books user1 electronics user2 books user2 books 4 user3 groceries user3 groceries user3 electronics user4 books T, cases = parse_input(input_str) print(most_frequent_category(T, cases))"},{"question":"def max_subsequence_sum(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Zephyr is playing a game with a sequence of integers. The game involves finding a contiguous subsequence such that the sum of the elements in the subsequence is the maximum possible, subject to the constraint that the length of the subsequence must be at least as long as a given value \`k\`. Can you help Zephyr find the maximum sum possible? Args: t (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of test cases, each containing a tuple with two integers \`n\` and \`k\`, and a list of \`n\` integers. Returns: List[int]: A list of integers representing the maximum possible sum of a contiguous subsequence of length at least \`k\`. Examples: >>> max_subsequence_sum(2, [((5, 2), [1, -2, 3, -2, 5]), ((6, 3), [-1, 2, 4, -3, 5, 7])]) [6, 15] >>> max_subsequence_sum(1, [((5, 2), [1, 2, 3, 4, 5])]) [15]","solution":"def max_subsequence_sum(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] sequence = test_cases[i][1] max_sum = float('-inf') for length in range(k, n+1): for start in range(n - length + 1): subsequence_sum = sum(sequence[start:start+length]) max_sum = max(max_sum, subsequence_sum) results.append(max_sum) return results"},{"question":"def will_first_player_win(n: int, initial_string: str, strings: List[str]) -> str: Determine if the first player will win given the constraints of the game. :param n: number of strings in the set. :param initial_string: the initial string. :param strings: list of strings in the set. :return: 'First' if the first player will win, 'Second' otherwise. >>> will_first_player_win(3, \\"abc\\", [\\"def\\", \\"ghi\\", \\"jkl\\"]) 'First' >>> will_first_player_win(2, \\"xyz\\", [\\"abcd\\", \\"efgh\\"]) 'Second' pass # Unit tests def test_first_example(): assert will_first_player_win(3, \\"abc\\", [\\"def\\", \\"ghi\\", \\"jkl\\"]) == \\"First\\" def test_second_example(): assert will_first_player_win(2, \\"xyz\\", [\\"abcd\\", \\"efgh\\"]) == \\"Second\\" def test_no_playable_strings(): assert will_first_player_win(2, \\"zxy\\", [\\"hello\\", \\"world\\"]) == \\"Second\\" def test_all_playable_strings(): assert will_first_player_win(3, \\"aaa\\", [\\"a\\", \\"aa\\", \\"aaaaaaaa\\"]) == \\"Second\\" def test_mixed_playable_and_non_playable(): assert will_first_player_win(4, \\"cat\\", [\\"dog\\", \\"fish\\", \\"tiger\\", \\"bird\\"]) == \\"First\\"","solution":"def will_first_player_win(n, initial_string, strings): Determine if the first player will win given the constraints of the game. :param n: number of strings in the set. :param initial_string: the initial string. :param strings: list of strings in the set. :return: 'First' if the first player will win, 'Second' otherwise. initial_length = len(initial_string) # Determine whether each string can be appended to the initial string to form a valid multiple in length. playable_strings = [s for s in strings if (len(s) + initial_length) % initial_length == 0] # If the number of valid playable strings is odd, the first player will win. return \\"First\\" if len(playable_strings) % 2 != 0 else \\"Second\\""},{"question":"from typing import List, Tuple def count_distinct_permutations(N: int, K: int, array: List[int]) -> int: This function counts the distinct permutations of the given array after performing at most K swaps. >>> count_distinct_permutations(3, 1, [1, 2, 1]) 3 >>> count_distinct_permutations(4, 2, [1, 2, 3, 4]) 24 pass def distinct_permutations(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: For each test case, returns the number of distinct permutations that can be obtained by performing at most K swaps. >>> distinct_permutations(2, [((3, 1), [1, 2, 1]), ((4, 2), [1, 2, 3, 4])]) [3, 24] pass # Sample tests def test_single_swap(): test_cases = [ [(3, 1), [1, 2, 1]], [(4, 2), [1, 2, 3, 4]], ] results = distinct_permutations(2, test_cases) assert results == [3, 24] def test_no_swap_required(): test_cases = [ [(3, 0), [1, 2, 1]], [(2, 0), [1, 1]], ] results = distinct_permutations(2, test_cases) assert results == [1, 1] def test_unreachable_permutation(): test_cases = [ [(3, 1), [1, 1, 1]], ] results = distinct_permutations(1, test_cases) assert results == [1] def test_large_k(): test_cases = [ [(4, 28), [1, 2, 3, 4]], ] results = distinct_permutations(1, test_cases) assert results == [24] def test_small_arrays(): test_cases = [ [(2, 1), [1, 2]], [(1, 1), [1]], ] results = distinct_permutations(2, test_cases) assert results == [2, 1]","solution":"from itertools import permutations def count_distinct_permutations(N, K, array): This function counts the distinct permutations of the given array after performing at most K swaps. all_permutations = set(permutations(array)) distinct_count = 0 def is_reachable(start, end, k): differences = sum(1 for i in range(len(start)) if start[i] != end[i]) return differences <= 2 * k for perm in all_permutations: if is_reachable(array, perm, K): distinct_count += 1 return distinct_count def distinct_permutations(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] array = test_cases[i][1] results.append(count_distinct_permutations(N, K, array)) return results"},{"question":"def is_armstrong_number(n: int) -> str: Checks if a given number is an Armstrong number. Args: n - integer to check Returns: 'YES' if n is an Armstrong number, otherwise 'NO' def check_armstrong_numbers(test_cases: List[int]) -> List[str]: Processes multiple test cases to check if each number is an Armstrong number. Args: test_cases - list of integers to be checked Returns: list of results for each test case, 'YES' or 'NO'","solution":"def is_armstrong_number(n): Checks if a given number is an Armstrong number. Args: n - integer to check Returns: 'YES' if n is an Armstrong number, otherwise 'NO' digits = [int(digit) for digit in str(n)] num_digits = len(digits) armstrong_sum = sum(digit ** num_digits for digit in digits) return \\"YES\\" if armstrong_sum == n else \\"NO\\" def check_armstrong_numbers(test_cases): Processes multiple test cases to check if each number is an Armstrong number. Args: test_cases - list of integers to be checked Returns: list of results for each test case, 'YES' or 'NO' return [is_armstrong_number(n) for n in test_cases]"},{"question":"def min_vertical_distance(n: int, heights: list[int]) -> int: Returns the minimum vertical distance between any two buildings. :param n: int - the number of buildings :param heights: list of int - the heights of the buildings :return: int - the minimum vertical distance >>> min_vertical_distance(5, [10, 15, 12, 18, 13]) 1 >>> min_vertical_distance(3, [1, 100, 101]) 1 >>> min_vertical_distance(4, [9, 8, 3, 7]) 1","solution":"def min_vertical_distance(n, heights): Returns the minimum vertical distance between any two buildings. :param n: int - the number of buildings :param heights: list of int - the heights of the buildings :return: int - the minimum vertical distance heights.sort() min_distance = float('inf') for i in range(1, n): min_distance = min(min_distance, heights[i] - heights[i-1]) return min_distance"},{"question":"class FrequencyTracker: A system to track the frequency of characters in a given string. Methods: add(char): Adds a character to the data structure. remove(char): Removes a character from the data structure if present. getFrequency(char): Returns the frequency of a particular character. Examples: >>> freqTracker = FrequencyTracker() >>> freqTracker.add('a') >>> freqTracker.getFrequency('a') 1 >>> freqTracker.add('a') >>> freqTracker.getFrequency('a') 2 >>> freqTracker.add('b') >>> freqTracker.getFrequency('b') 1 >>> freqTracker.remove('a') >>> freqTracker.getFrequency('a') 1 >>> freqTracker.getFrequency('c') 0 >>> freqTracker.remove('a') >>> freqTracker.getFrequency('a') 0 def __init__(self): pass def add(self, char): pass def remove(self, char): pass def getFrequency(self, char): pass # Unit Tests def test_frequency_tracker_add(): freqTracker = FrequencyTracker() freqTracker.add('a') assert freqTracker.getFrequency('a') == 1 freqTracker.add('a') assert freqTracker.getFrequency('a') == 2 freqTracker.add('b') assert freqTracker.getFrequency('b') == 1 def test_frequency_tracker_remove(): freqTracker = FrequencyTracker() freqTracker.add('a') freqTracker.add('a') freqTracker.remove('a') assert freqTracker.getFrequency('a') == 1 freqTracker.remove('a') assert freqTracker.getFrequency('a') == 0 freqTracker.remove('a') assert freqTracker.getFrequency('a') == 0 # Ensure removal of non-existent character def test_frequency_tracker_getFrequency(): freqTracker = FrequencyTracker() assert freqTracker.getFrequency('a') == 0 freqTracker.add('a') assert freqTracker.getFrequency('a') == 1 freqTracker.add('a') assert freqTracker.getFrequency('a') == 2 freqTracker.remove('a') assert freqTracker.getFrequency('a') == 1 assert freqTracker.getFrequency('b') == 0 # Check frequency of non-added character","solution":"class FrequencyTracker: def __init__(self): self.frequency = {} def add(self, char): if char in self.frequency: self.frequency[char] += 1 else: self.frequency[char] = 1 def remove(self, char): if char in self.frequency: self.frequency[char] -= 1 if self.frequency[char] == 0: del self.frequency[char] def getFrequency(self, char): return self.frequency.get(char, 0)"},{"question":"def max_nuts_collected(grid: List[List[int]]) -> int: Returns the maximum number of nuts collected by the mole navigating from top-left to bottom-right on the grid. >>> max_nuts_collected([ >>> [0, 1, 0], >>> [1, 0, 1], >>> [0, 1, 0] >>> ]) 2 >>> max_nuts_collected([ >>> [1, 0], >>> [0, 1] >>> ]) 2 def solve(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Solves the test cases and returns the results as a list of integers. >>> solve(2, [ >>> (3, 3, [ >>> [0, 1, 0], >>> [1, 0, 1], >>> [0, 1, 0] >>> ]), >>> (2, 2, [ >>> [1, 0], >>> [0, 1] >>> ]) >>> ]) [2, 2]","solution":"def max_nuts_collected(grid): Returns the maximum number of nuts collected by the mole navigating from top-left to bottom-right on the grid. m = len(grid) n = len(grid[0]) # Create a DP table to store the maximum nuts collected up to each cell dp = [[0] * n for _ in range(m)] # Initialize the starting cell dp[0][0] = grid[0][0] # Fill the DP table for i in range(m): for j in range(n): if i == 0 and j > 0: dp[i][j] = dp[i][j - 1] + grid[i][j] # Only can move from the left elif i > 0 and j == 0: dp[i][j] = dp[i - 1][j] + grid[i][j] # Only can move from above elif i > 0 and j > 0: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # Move from left or above return dp[m - 1][n - 1] def solve(T, test_cases): results = [] for case in test_cases: m, n, grid = case result = max_nuts_collected(grid) results.append(result) return results"},{"question":"def can_form_palindrome_by_removing_k_chars(s: str, k: int) -> str: Returns \\"Yes\\" if it's possible to form a palindrome by removing at most k characters from string s, otherwise returns \\"No\\". >>> can_form_palindrome_by_removing_k_chars(\\"abca\\", 1) \\"Yes\\" >>> can_form_palindrome_by_removing_k_chars(\\"abcde\\", 2) \\"No\\" def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Process multiple test cases to determine if each can form a palindrome by removing at most k characters. >>> process_test_cases([(\\"abca\\", 1), (\\"abcde\\", 2)]) [\\"Yes\\", \\"No\\"]","solution":"def can_form_palindrome_by_removing_k_chars(s, k): Returns \\"Yes\\" if it's possible to form a palindrome by removing at most k characters from string s, otherwise returns \\"No\\". def is_palindrome_range(start, end): while start < end: if s[start] != s[end]: return False start += 1 end -= 1 return True def can_form_palindrome(s, start, end, k): while start < end: if s[start] != s[end]: if k == 0: return False # Either skip the start character or the end character return can_form_palindrome(s, start + 1, end, k - 1) or can_form_palindrome(s, start, end - 1, k - 1) start += 1 end -= 1 return True return \\"Yes\\" if can_form_palindrome(s, 0, len(s) - 1, k) else \\"No\\" def process_test_cases(test_cases): results = [] for s, k in test_cases: k = int(k) results.append(can_form_palindrome_by_removing_k_chars(s, k)) return results"},{"question":"from typing import List, Tuple def game_result(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[str]: Determine the result of the game for each test case. Args: T : int : Number of test cases test_cases : List[Tuple[int, int, List[str]]] : List of tuples. Each tuple contains (N, M, grid) where grid is a list of strings. Returns: List[str] : List of strings (\\"Alice\\" or \\"Bob\\") for each test case. Example: >>> game_result(2, [(4, 4, [\\"....\\", \\"..#.\\", \\".#..\\", \\"....\\"]), (3, 3, [\\".\\", \\".#.\\", \\"..#\\"])]) [\\"Alice\\", \\"Bob\\"] >>> game_result(2, [(3, 3, [\\"#\\", \\".#.\\", \\"..#\\"]), (2, 2, [\\"\\", \\"\\"])]) [\\"Bob\\", \\"Bob\\"]","solution":"def is_path_to_bottom_right(grid, N, M): Return True if there is a path from top-left to bottom-right in the grid, otherwise False. from collections import deque if grid[0][0] == '#' or grid[N-1][M-1] == '#': return False queue = deque([(0, 0)]) visited = set((0, 0)) directions = [(1, 0), (0, 1)] # down, right while queue: x, y = queue.popleft() if (x, y) == (N-1, M-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return False def game_result(T, test_cases): Determine the result of the game for each test case. T: Number of test cases test_cases: List of tuples. Each tuple contains (N, M, grid) where grid is a list of strings. Return: List of strings (\\"Alice\\" or \\"Bob\\") for each test case. results = [] for test_case in test_cases: N, M, grid = test_case if is_path_to_bottom_right(grid, N, M): results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results"},{"question":"def shortest_path(grid: List[List[int]]) -> int: Determines the shortest path from the top-left corner to the bottom-right corner of a grid. >>> shortest_path(parse_input(\\"3 4n0 0 0 0n1 1 0 1n0 0 0 0\\")) 5 >>> shortest_path(parse_input(\\"3 3n0 1 0n0 1 0n0 0 0\\")) 4 >>> shortest_path(parse_input(\\"4 4n0 1 1 0n1 1 0 1n1 0 0 1n0 0 1 0\\")) -1 # Your code goes here. def parse_input(input_str: str) -> List[List[int]]: Parses the input string to generate the grid. >>> parse_input(\\"3 4n0 0 0 0n1 1 0 1n0 0 0 0\\") [[0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0]] # Your code goes here. # Unit Tests def test_shortest_path_case_1(): input_str = \\"3 4n0 0 0 0n1 1 0 1n0 0 0 0\\" grid = parse_input(input_str) assert shortest_path(grid) == 5 def test_shortest_path_case_2(): input_str = \\"3 3n0 1 0n0 1 0n0 0 0\\" grid = parse_input(input_str) assert shortest_path(grid) == 4 def test_shortest_path_case_3(): input_str = \\"4 4n0 1 1 0n1 1 0 1n1 0 0 1n0 0 1 0\\" grid = parse_input(input_str) assert shortest_path(grid) == -1 def test_shortest_path_no_obstacles(): input_str = \\"2 2n0 0n0 0\\" grid = parse_input(input_str) assert shortest_path(grid) == 2 def test_shortest_path_start_is_obstacle(): input_str = \\"2 2n1 0n0 0\\" grid = parse_input(input_str) assert shortest_path(grid) == -1 def test_shortest_path_end_is_obstacle(): input_str = \\"2 2n0 0n0 1\\" grid = parse_input(input_str) assert shortest_path(grid) == -1 def test_shortest_path_large_grid(): input_str = \\"3 4n0 0 0 0n0 0 0 0n0 0 0 0\\" grid = parse_input(input_str) assert shortest_path(grid) == 5","solution":"from collections import deque def shortest_path(grid): m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, step = queue.popleft() if x == m - 1 and y == n - 1: return step for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, step + 1)) return -1 def parse_input(input_str): lines = input_str.strip().split(\\"n\\") m, n = map(int, lines[0].split()) grid = [list(map(int, line.split())) for line in lines[1:]] return grid"},{"question":"def find_first_occurrence(arr: List[str], target: str) -> int: Returns the index of the first occurrence of the target string in the array. If the target string is not found, returns -1. >>> find_first_occurrence([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"cherry\\") 2 >>> find_first_occurrence([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"fig\\") -1 >>> find_first_occurrence([\\"car\\", \\"bike\\", \\"boat\\", \\"plane\\"], \\"bike\\") 1 >>> find_first_occurrence([\\"dog\\", \\"cat\\", \\"bird\\", \\"fish\\"], \\"bird\\") 2","solution":"def find_first_occurrence(arr, target): Returns the index of the first occurrence of the target string in the array. If the target string is not found, returns -1. try: return arr.index(target) except ValueError: return -1"},{"question":"import heapq from typing import List, Tuple def can_deliver_all_packages(N: int, M: int, edges: List[Tuple[int, int, int]], B: int, K: int, packages: List[Tuple[int, int, int]]) -> str: Determine if a robot can deliver all its assigned packages within the given deadlines. Args: - N (int): Number of nodes. - M (int): Number of directed edges. - edges (List[Tuple[int, int, int]]): List containing the edges represented by tuples (U, V, W). - B (int): Base node where the robot starts and returns after each delivery. - K (int): Number of packages. - packages (List[Tuple[int, int, int]]): List of packages represented by tuples (S, D, T). Returns: - str: 'YES' if the robot can deliver all packages within their respective deadlines, otherwise 'NO'. >>> can_deliver_all_packages(5, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 1), (4, 5, 3), (5, 1, 4), (1, 3, 5)], 1, 3, [(1, 3, 8), (3, 5, 9), (5, 1, 15)]) 'YES' >>> can_deliver_all_packages(5, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 1), (4, 5, 3), (5, 1, 4), (1, 3, 5)], 1, 3, [(1, 3, 7), (3, 5, 8), (5, 1, 10)]) 'NO' def main(input_text: str) -> str: Parse input and determine if packages can be delivered on time.","solution":"import heapq def can_deliver_all_packages(N, M, edges, B, K, packages): def dijkstra(graph, start): distances = {node: float('infinity') for node in range(1, N+1)} distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances graph = {i: [] for i in range(1, N+1)} for U, V, W in edges: graph[U].append((V, W)) for S, D, T in packages: distances_from_base = dijkstra(graph, B) distances_from_source = dijkstra(graph, S) if distances_from_base[S] + distances_from_source[D] > T: return \\"NO\\" return \\"YES\\" # Input Parsing def parse_input(input_text): lines = input_text.strip().split('n') N, M = map(int, lines[0].split()) edges = [] for i in range(1, M+1): U, V, W = map(int, lines[i].split()) edges.append((U, V, W)) B = int(lines[M+1]) K = int(lines[M+2]) packages = [] for i in range(M+3, M+3+K): S, D, T = map(int, lines[i].split()) packages.append((S, D, T)) return N, M, edges, B, K, packages def main(input_text): N, M, edges, B, K, packages = parse_input(input_text) return can_deliver_all_packages(N, M, edges, B, K, packages)"},{"question":"def countSetBits(n: int) -> int: Given a positive integer \`n\`, count the total number of set bits (1s) in the binary representation of all the numbers from 1 to n. Example 1: >>> countSetBits(3) 4 Explanation: Binary representation of 1 is 1. Binary representation of 2 is 10. Binary representation of 3 is 11. Total number of set bits = 1 + 1 + 2 = 4. Example 2: >>> countSetBits(7) 12 Explanation: Binary representation of numbers from 1 to 7 are: 1 -> 1 2 -> 10 3 -> 11 4 -> 100 5 -> 101 6 -> 110 7 -> 111 Total number of set bits = 1 + 1 + 2 + 1 + 2 + 2 + 3 = 12. pass def test_countSetBits_example1(): assert countSetBits(3) == 4 # 1 + 1 + 2 = 4 def test_countSetBits_example2(): assert countSetBits(7) == 12 # 1 + 1 + 2 + 1 + 2 + 2 + 3 = 12 def test_countSetBits_edge_case(): assert countSetBits(1) == 1 # Binary representation of 1 is 1, so one 1. def test_countSetBits_large_number(): assert countSetBits(1000000) > 0 # General test for large number, function should return a positive integer. def test_countSetBits_zero(): assert countSetBits(0) == 0 # Zero case. def test_countSetBits_power_of_two(): assert countSetBits(8) == 13 # Binary representation numbers are: [1, 10, 11, 100, 101, 110, 111, 1000] def test_countSetBits_large_small_number(): assert countSetBits(15) == 32 # Binary representations: [1, 10, 11, 100, ... 1111] def test_countSetBits_all_ones(): assert countSetBits(31) == 80 # [1, 10, 11, 100, ..., 11111] def test_countSetBits_non_power_of_two(): assert countSetBits(1234) > 0 # Just to test number within extendable bounds. def test_countSetBits_round_test(): assert countSetBits(16) == 33 # Check for completeness for res calculation.","solution":"def countSetBits(n): Returns the total number of set bits (1s) in the binary representation of all the numbers from 1 to n. if n == 0: return 0 # Initialize result result = 0 # i increments in powers of 2, i.e., 1, 2, 4, 8, 16, ... i = 1 while i <= n: # For every bit position \`i\`, calculate total pairs of 0s and 1s # in n+1 numbers. Each pair has exactly one 1 in \`i\`th position. total_pairs = (n + 1) // (i * 2) # Count of 1s will be total pairs of the pairs containing 1 plus the remainder result += total_pairs * i result += max((n + 1) % (i * 2) - i, 0) # Move to the next bit i *= 2 return result"},{"question":"def library_system(M: int, books: List[int], N: int, commands: List[str]) -> List[str]: Manage book rentals and returns in a library system. Start with all books marked as available. Args: - M (int): the number of books in the library. - books (List[int]): unique ISBN numbers of the books. - N (int): the number of commands. - commands (List[str]): list of commands, either \\"Rent ISBN\\" or \\"Return ISBN\\". Returns: - List[str]: the result of each command. >>> library_system(3, [1001, 1002, 1003], 4, [\\"Rent 1001\\", \\"Rent 1001\\", \\"Return 1001\\", \\"Return 1002\\"]) [\\"Book 1001 rented successfully\\", \\"Book 1001 is already rented\\", \\"Book 1001 returned successfully\\", \\"Book 1002 was not rented\\"] >>> library_system(2, [12345, 54321], 6, [\\"Rent 12345\\", \\"Rent 54321\\", \\"Return 12345\\", \\"Rent 12345\\", \\"Return 12345\\", \\"Return 54321\\"]) [\\"Book 12345 rented successfully\\", \\"Book 54321 rented successfully\\", \\"Book 12345 returned successfully\\", \\"Book 12345 rented successfully\\", \\"Book 12345 returned successfully\\", \\"Book 54321 returned successfully\\"]","solution":"def library_system(M, books, N, commands): # Initialize book status dictionary book_status = {isbn: 'available' for isbn in books} output = [] for command in commands: action, isbn = command.split() isbn = int(isbn) if action == 'Rent': if book_status[isbn] == 'available': book_status[isbn] = 'rented' output.append(f\\"Book {isbn} rented successfully\\") else: output.append(f\\"Book {isbn} is already rented\\") elif action == 'Return': if book_status[isbn] == 'rented': book_status[isbn] = 'available' output.append(f\\"Book {isbn} returned successfully\\") else: output.append(f\\"Book {isbn} was not rented\\") return output"},{"question":"from typing import List, Tuple def solve(graph_info: Tuple[int, int], weights: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the maximum weight of a vertex on the shortest path for each query. >>> solve((5, 5), [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], [(1, 3), (2, 5), (1, 4)]) == [3, 5, 4] >>> solve((4, 3), [5, 5, 5, 5], [(1, 2), (2, 3), (3, 4)], [(1, 4), (2, 3), (1, 2)]) == [5, 5, 5] >>> solve((4, 3), [1, 1000000000, 1000000000, 1], [(1, 2), (2, 3), (3, 4)], [(1, 4), (1, 3), (2, 4)]) == [1000000000, 1000000000, 1000000000] >>> solve((3, 2), [10, 20, 30], [(1, 2), (2, 3)], [(1, 3)]) == [30]","solution":"import heapq from collections import defaultdict, deque def dijkstra_max_path(N, graph, weights, start, end): Applies Dijkstra's algorithm to find the maximum weight of a vertex on the shortest path from 'start' to 'end'. max_weights = [0] * (N + 1) max_weights[start] = weights[start - 1] # Adjust index for 1-based to 0-based weights pq = [(weights[start - 1], start)] visited = [False] * (N + 1) while pq: current_weight, node = heapq.heappop(pq) if visited[node]: continue visited[node] = True if node == end: break for neighbor in graph[node]: if not visited[neighbor]: new_weight = max(max_weights[node], weights[neighbor - 1]) if new_weight > max_weights[neighbor]: max_weights[neighbor] = new_weight heapq.heappush(pq, (new_weight, neighbor)) return max_weights[end] def solve(graph_info, weights, edges, queries): N, M = graph_info graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) results = [] for A, B in queries: result = dijkstra_max_path(N, graph, weights, A, B) results.append(result) return results"},{"question":"def shortest_palindrome(s: str) -> str: Returns the shortest palindrome that can be formed by adding characters to the start of the given string. >>> shortest_palindrome(\\"racecar\\") 'racecar' >>> shortest_palindrome(\\"civic\\") 'civic' >>> shortest_palindrome(\\"aacecaaa\\") 'aaacecaaa' >>> shortest_palindrome(\\"abcd\\") 'dcbabcd' >>> shortest_palindrome(\\"a\\") 'a' >>> shortest_palindrome(\\"ab\\") 'bab' >>> shortest_palindrome(\\"aabba\\") 'abbaabba' >>> shortest_palindrome(\\"madamadam\\") 'madamadam'","solution":"def shortest_palindrome(s): Returns the shortest palindrome that can be formed by adding characters to the start of the given string. if s == s[::-1]: return s for i in range(len(s) - 1, -1, -1): if s[:i + 1] == s[:i + 1][::-1]: return s[i + 1:][::-1] + s return s[::-1] + s"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the input string of parentheses is valid. Open brackets '(' must be closed by the corresponding closing brackets ')'. Open brackets '(' must be closed in the correct order. Args: s (str): Input string containing only '(' and ')'. Returns: bool: Returns True if the input string is valid, otherwise False. >>> is_valid_parentheses(\\"()()\\") True >>> is_valid_parentheses(\\"(())\\") True >>> is_valid_parentheses(\\"(()\\") False >>> is_valid_parentheses(\\"())\\") False >>> is_valid_parentheses(\\"()()((()))\\") True >>> is_valid_parentheses(\\"(()))(()\\") False","solution":"def is_valid_parentheses(s: str) -> bool: Determines if the input string of parentheses is valid. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def max_risk_reduction(N, M, risk_factors, risk_reductions): Calculate the maximum possible risk reduction for a given city. Parameters: N (int): Number of days. M (int): Number of projects. risk_factors (list): List of risk factors for past N days. risk_reductions (list): List of risk reductions available from the projects. Returns: int: The maximum risk reduction possible. pass def process_test_cases(T, test_cases): Process multiple test cases to calculate maximum risk reductions. Parameters: T (int): Number of test cases. test_cases (list): List of test case tuples, each containing N, M, risk factors, and risk reductions. Returns: list: List of results with maximum risk reductions for each test case. pass def main(input_data): Main function to process input data and return results. Parameters: input_data (str): Input data as a string. Returns: list: List of results with maximum risk reductions for each test case. pass def test_max_risk_reduction(): assert max_risk_reduction(10, 5, [5, 6, 7, 8, 5, 10, 9, 7, 6, 8], [2, 3, 1, 4, 5]) == 15 assert max_risk_reduction(8, 3, [9, 9, 4, 3, 7, 5, 6, 2], [3, 8, 2]) == 13 assert max_risk_reduction(5, 5, [1, 2, 3, 4, 5], [1, 1, 1, 1, 1]) == 5 assert max_risk_reduction(5, 3, [10, 10, 9, 8, 7], [5, 5, 5]) == 15 assert max_risk_reduction(0, 0, [], []) == 0 input_data = \\"2n10 5n5 6 7 8 5 10 9 7 6 8n2 3 1 4 5n8 3n9 9 4 3 7 5 6 2n3 8 2n\\" expected_output = [15, 13] def test_main(): assert main(input_data) == expected_output","solution":"def max_risk_reduction(N, M, risk_factors, risk_reductions): Calculate the maximum possible risk reduction for a given city. Parameters: N (int): Number of days. M (int): Number of projects. risk_factors (list): List of risk factors for past N days. risk_reductions (list): List of risk reductions available from the projects. Returns: int: The maximum risk reduction possible. risk_factors.sort(reverse=True) risk_reductions.sort(reverse=True) max_reduction = 0 for i in range(min(N, M)): max_reduction += risk_reductions[i] return max_reduction def process_test_cases(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][:2] risk_factors = test_cases[i][2] risk_reductions = test_cases[i][3] result = max_risk_reduction(N, M, risk_factors, risk_reductions) results.append(result) return results def main(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, lines[index].split()) risk_factors = list(map(int, lines[index + 1].split())) risk_reductions = list(map(int, lines[index + 2].split())) test_cases.append((N, M, risk_factors, risk_reductions)) index += 3 results = process_test_cases(T, test_cases) return results"},{"question":"def calculate_damage(base_damage, level): Calculates the actual damage dealt to a monster of a given level using a weapon with a specified base damage. The formula used is: damage = base_damage * (1 + level * 0.05) :param base_damage: int, the inherent damage value of the weapon :param level: int, the level of the monster :return: int, the actual damage pass # Implementation goes here def process_test_cases(test_cases): Processes multiple test cases to calculate the actual damage for each case. :param test_cases: List of tuples, where each tuple contains \`base_damage\` and \`level\` :return: List of int values representing the actual damage for each test case pass # Implementation goes here # Unit Tests import pytest def test_calculate_damage(): assert calculate_damage(100, 5) == 125 # 100 * 1.25 = 125 assert calculate_damage(50, 10) == 75 # 50 * 1.5 = 75 assert calculate_damage(200, 3) == 230 # 200 * 1.15 = 230 assert calculate_damage(0, 5) == 0 # 0 * any level = 0 assert calculate_damage(100, 0) == 100 # 100 * 1 = 100 def test_process_test_cases(): test_cases = [ (100, 5), (50, 10), (200, 3) ] assert process_test_cases(test_cases) == [125, 75, 230] test_cases = [ (0, 5), (100, 0), (150, 5), (1, 100) ] assert process_test_cases(test_cases) == [0, 100, 188, 6] if __name__ == \\"__main__\\": pytest.main()","solution":"def calculate_damage(base_damage, level): Calculates the actual damage dealt to a monster of a given level using a weapon with a specified base damage. The formula used is: damage = base_damage * (1 + level * 0.05) :param base_damage: int, the inherent damage value of the weapon :param level: int, the level of the monster :return: int, the actual damage damage = base_damage * (1 + level * 0.05) return round(damage) def process_test_cases(test_cases): results = [] for base_damage, level in test_cases: results.append(calculate_damage(base_damage, level)) return results"},{"question":"def decrypt_message(num_words, encoded_words, num_entries, dictionary_entries): Decrypts an encoded message based on the provided dictionary of reversed words. Args: num_words (int): Number of words in the encoded message. encoded_words (list of str): List of encoded words. num_entries (int): Number of dictionary entries. dictionary_entries (list of tuples): List of tuples where each tuple contains a reversed word and the corresponding original word. Returns: str: The decrypted message. pass # Example test cases def test_example_1(): num_words = 5 encoded_words = [\\"siht\\", \\"si\\", \\"na\\", \\"elpmas\\", \\"egassem\\"] num_entries = 5 dictionary_entries = [ (\\"siht\\", \\"this\\"), (\\"si\\", \\"is\\"), (\\"na\\", \\"an\\"), (\\"elpmas\\", \\"sample\\"), (\\"egassem\\", \\"message\\") ] expected_output = \\"this is an sample message\\" assert decrypt_message(num_words, encoded_words, num_entries, dictionary_entries) == expected_output def test_example_2(): num_words = 4 encoded_words = [\\"gnitset\\", \\"siht\\", \\"si\\", \\"noitcnuf\\"] num_entries = 4 dictionary_entries = [ (\\"gnitset\\", \\"testing\\"), (\\"siht\\", \\"this\\"), (\\"si\\", \\"is\\"), (\\"noitcnuf\\", \\"function\\") ] expected_output = \\"testing this is function\\" assert decrypt_message(num_words, encoded_words, num_entries, dictionary_entries) == expected_output def test_edge_case(): num_words = 1 encoded_words = [\\"etulosba\\"] num_entries = 1 dictionary_entries = [ (\\"etulosba\\", \\"absolute\\") ] expected_output = \\"absolute\\" assert decrypt_message(num_words, encoded_words, num_entries, dictionary_entries) == expected_output def test_long_word(): num_words = 1 encoded_words = [\\"erehpshpodatuoy\\"] num_entries = 1 dictionary_entries = [ (\\"erehpshpodatuoy\\", \\"yourplaceholder\\") ] expected_output = \\"yourplaceholder\\" assert decrypt_message(num_words, encoded_words, num_entries, dictionary_entries) == expected_output def test_multiple_word_instances(): num_words = 4 encoded_words = [\\"siht\\", \\"si\\", \\"siht\\", \\"si\\"] num_entries = 2 dictionary_entries = [ (\\"siht\\", \\"this\\"), (\\"si\\", \\"is\\"), ] expected_output = \\"this is this is\\" assert decrypt_message(num_words, encoded_words, num_entries, dictionary_entries) == expected_output","solution":"def decrypt_message(num_words, encoded_words, num_entries, dictionary_entries): Decrypts an encoded message based on the provided dictionary of reversed words. Args: num_words (int): Number of words in the encoded message. encoded_words (list of str): List of encoded words. num_entries (int): Number of dictionary entries. dictionary_entries (list of tuples): List of tuples where each tuple contains a reversed word and the corresponding original word. Returns: str: The decrypted message. # Create a dictionary from reversed code to original word decryption_dict = {reverse_code: original_word for reverse_code, original_word in dictionary_entries} # Decrypt each word in encoded message decrypted_words = [decryption_dict[word] for word in encoded_words] # Join decrypted words to form the final message decrypted_message = \\" \\".join(decrypted_words) return decrypted_message # Example to test the function if __name__ == \\"__main__\\": example_num_words = 5 example_encoded_words = [\\"siht\\", \\"si\\", \\"na\\", \\"elpmas\\", \\"egassem\\"] example_num_entries = 5 example_dictionary_entries = [ (\\"siht\\", \\"this\\"), (\\"si\\", \\"is\\"), (\\"na\\", \\"an\\"), (\\"elpmas\\", \\"sample\\"), (\\"egassem\\", \\"message\\") ] print(decrypt_message(example_num_words, example_encoded_words, example_num_entries, example_dictionary_entries)) # Output: \\"this is an sample message\\""},{"question":"def rearrange_negatives(array): Rearranges the given array such that all negative numbers come to the beginning and all positive numbers go to the end, keeping their relative order intact. Parameters: array (list of int): The input integer array. Returns: list of int: The rearranged array. Examples: >>> rearrange_negatives([3, -1, 4, -2, -7, 5, 6]) [-1, -2, -7, 3, 4, 5, 6] >>> rearrange_negatives([-3, -1, -4, -2, -7]) [-3, -1, -4, -2, -7] >>> rearrange_negatives([3, 1, 4, 2, 7]) [3, 1, 4, 2, 7] >>> rearrange_negatives([]) [] >>> rearrange_negatives([-1]) [-1] >>> rearrange_negatives([1]) [1] >>> rearrange_negatives([0, -1, 2]) [-1, 0, 2]","solution":"def rearrange_negatives(array): Rearranges the given array such that all negative numbers come to the beginning and all positive numbers go to the end, keeping their relative order intact. Parameters: array (list of int): The input integer array. Returns: list of int: The rearranged array. negative_numbers = [] positive_numbers = [] for num in array: if num < 0: negative_numbers.append(num) else: positive_numbers.append(num) return negative_numbers + positive_numbers"},{"question":"def is_anagram(s1: str, s2: str) -> str: Determine whether s2 is an anagram of s1. An anagram is a word formed by rearranging the letters of another word, using all original letters exactly once. Args: s1 (str): The first string. s2 (str): The second string. Returns: str: \\"True\\" if s2 is an anagram of s1, otherwise \\"False\\". >>> is_anagram(\\"listen\\", \\"silent\\") 'True' >>> is_anagram(\\"hello\\", \\"olelh\\") 'True' >>> is_anagram(\\"test\\", \\"best\\") 'False' pass def process_input(T: int, test_cases: list) -> list: Process a number of test cases to determine if pairs of strings are anagrams. Args: T (int): The number of test cases. test_cases (list): A list of tuples, each containing two strings. Returns: list: A list of results (\\"True\\" or \\"False\\") for each test case. >>> process_input(3, [(\\"listen\\", \\"silent\\"), (\\"hello\\", \\"olelh\\"), (\\"test\\", \\"best\\")]) ['True', 'True', 'False'] >>> process_input(2, [(\\"anagram\\", \\"nagaram\\"), (\\"rat\\", \\"car\\")]) ['True', 'False'] pass","solution":"def is_anagram(s1, s2): Returns 'True' if s2 is an anagram of s1, otherwise returns 'False'. return sorted(s1) == sorted(s2) def process_input(T, test_cases): results = [] for i in range(T): s1, s2 = test_cases[i] results.append(str(is_anagram(s1, s2))) return results # Example usage: # T = 3 # test_cases = [(\\"listen\\", \\"silent\\"), (\\"hello\\", \\"olelh\\"), (\\"test\\", \\"best\\")] # results = process_input(T, test_cases) # for result in results: # print(result)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_unival_subtree(root): Returns the size of the largest subtree where all nodes have the same value. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(4) >>> root.right.left = TreeNode(2) >>> root.right.right = TreeNode(2) >>> root.right.right.right = TreeNode(2) >>> largest_unival_subtree(root) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_unival_subtree(root): Returns the size of the largest subtree where all nodes have the same value. def helper(node): if not node: return (True, 0, None) # (is_unival, subtree_size, node_value) left_is_unival, left_size, left_value = helper(node.left) right_is_unival, right_size, right_value = helper(node.right) current_is_unival = ( left_is_unival and right_is_unival and (node.left is None or left_value == node.val) and (node.right is None or right_value == node.val) ) if current_is_unival: return (True, left_size + right_size + 1, node.val) else: return (False, max(left_size, right_size), node.val) return helper(root)[1]"},{"question":"def find_highest_scores(student_records): Finds the highest score in each subject and the student ID of the student who achieved it. Args: student_records (list of list): List of records where each record is a list containing student ID followed by grades in 5 subjects. Returns: List of tuples: Each tuple contains the highest score in each subject and the student ID. def process_input_data(data): Processes input data and returns it in the required format. Args: data (str): Input data in string format Returns: tuple: Number of students and list of student records. def main(data): Determines the highest score in each subject and the student ID of the student who achieved it. Args: data (str): Input data in string format Returns: str: Highest score in each subject followed by the student ID who achieved it. N, student_records = process_input_data(data) highest_scores = find_highest_scores(student_records) return 'n'.join(f\\"{score[0]} {score[1]}\\" for score in highest_scores) def test_sample_input(): data = \\"4n1001 88 92 93 85 91n1002 85 90 96 88 90n1003 88 92 93 85 95n1004 85 87 91 90 95\\" expected_output = \\"88 1001n92 1001n96 1002n90 1004n95 1003\\" assert main(data) == expected_output def test_all_same_scores(): data = \\"3n1001 90 90 90 90 90n1002 90 90 90 90 90n1003 90 90 90 90 90\\" expected_output = \\"90 1001n90 1001n90 1001n90 1001n90 1001\\" assert main(data) == expected_output def test_different_high_scores(): data = \\"2n1010 100 50 75 60 95n1020 99 60 80 70 100\\" expected_output = \\"100 1010n60 1020n80 1020n70 1020n100 1020\\" assert main(data) == expected_output def test_single_student(): data = \\"1n1001 85 90 95 80 75\\" expected_output = \\"85 1001n90 1001n95 1001n80 1001n75 1001\\" assert main(data) == expected_output def test_edge_case_smallest_id(): data = \\"2n1000 50 60 70 80 90n1001 50 60 70 80 90\\" expected_output = \\"50 1000n60 1000n70 1000n80 1000n90 1000\\" assert main(data) == expected_output","solution":"def find_highest_scores(student_records): Finds the highest score in each subject and the student ID of the student who achieved it. Args: student_records (list of list): List of records where each record is a list containing student ID followed by grades in 5 subjects. Returns: List of tuples: Each tuple contains the highest score in each subject and the student ID. # Initialize variables to store highest scores and corresponding student IDs highest_scores = [(0, float('inf')) for _ in range(5)] for record in student_records: student_id = record[0] grades = record[1:] for idx in range(len(grades)): if grades[idx] > highest_scores[idx][0] or (grades[idx] == highest_scores[idx][0] and student_id < highest_scores[idx][1]): highest_scores[idx] = (grades[idx], student_id) return highest_scores def process_input_data(data): Processes input data and returns it in the required format. Args: data (str): Input data in string format Returns: tuple: Number of students and list of student records. lines = data.strip().split('n') N = int(lines[0]) student_records = [] for i in range(1, N + 1): student_records.append(list(map(int, lines[i].split()))) return N, student_records def main(data): N, student_records = process_input_data(data) highest_scores = find_highest_scores(student_records) return 'n'.join(f\\"{score[0]} {score[1]}\\" for score in highest_scores)"},{"question":"def can_be_palindrome(s: str) -> str: Determine whether you can make a string a palindrome with at most one deletion. :param s: Input string consisting of lowercase English letters :return: \\"YES\\" if the string can be made a palindrome by removing at most one character, \\"NO\\" otherwise Example: >>> can_be_palindrome(\\"abca\\") \\"YES\\" >>> can_be_palindrome(\\"racecar\\") \\"YES\\" >>> can_be_palindrome(\\"abcdefg\\") \\"NO\\" # Your code here def test_can_be_palindrome(): assert can_be_palindrome(\\"abca\\") == \\"YES\\" assert can_be_palindrome(\\"racecar\\") == \\"YES\\" assert can_be_palindrome(\\"abcdefg\\") == \\"NO\\" assert can_be_palindrome(\\"a\\") == \\"YES\\" # Single character is always a palindrome assert can_be_palindrome(\\"aba\\") == \\"YES\\" # Already a palindrome assert can_be_palindrome(\\"abccbaa\\") == \\"YES\\" # Needs one removal character to be palindrome assert can_be_palindrome(\\"abc\\") == \\"NO\\" # Impossible to form palindrome assert can_be_palindrome(\\"a\\" * 10**5) == \\"YES\\" # Long string, already a palindrome assert can_be_palindrome(\\"a\\" * (10**5 - 1) + \\"b\\") == \\"YES\\" # Long string with one different character","solution":"def can_be_palindrome(s): Checks whether the string can be made a palindrome by removing at most one character. :param s: Input string consisting of lowercase English letters :return: \\"YES\\" if the string can be made a palindrome by removing at most one character, \\"NO\\" otherwise def is_palindrome_range(i, j): Returns True if the substring s[i:j+1] is a palindrome return all(s[k] == s[j - k + i] for k in range(i, (j + i) // 2 + 1)) start, end = 0, len(s) - 1 while start < end: if s[start] != s[end]: return \\"YES\\" if is_palindrome_range(start + 1, end) or is_palindrome_range(start, end - 1) else \\"NO\\" start, end = start + 1, end - 1 return \\"YES\\" # Sample inputs to test the function print(can_be_palindrome(\\"abca\\")) # Expected output: \\"YES\\" print(can_be_palindrome(\\"racecar\\")) # Expected output: \\"YES\\" print(can_be_palindrome(\\"abcdefg\\")) # Expected output: \\"NO\\""},{"question":"from typing import List def is_path_possible(grid: List[List[str]]) -> bool: Determine if there exists a path from the top-left corner of the grid (cell (0, 0)) to the bottom-right corner (cell (N-1, M-1)). The grid contains empty cells (.) and obstacles (#). Movement is allowed left, right, up, or down, but not through obstacles. >>> grid1 = [ ['.', '.', '#'], ['#', '.', '.'], ['.', '#', '.'] ] >>> is_path_possible(grid1) True >>> grid2 = [ ['.', '#', '#'], ['#', '#', '.'], ['.', '#', '.'] ] >>> is_path_possible(grid2) False >>> grid3 = [ ['.', '.'], ['.', '.'] ] >>> is_path_possible(grid3) True >>> grid4 = [ ['.', '#'], ['#', '.'] ] >>> is_path_possible(grid4) False >>> grid5 = [ ['.'] ] >>> is_path_possible(grid5) True >>> grid6 = [ ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '#', '#', '#', '#', '#', '#', '#', '#', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '#', '.'], ['.', '#', '#', '#', '#', '#', '#', '.', '#', '.'], ['.', '.', '.', '.', '.', '.', '#', '.', '#', '.'], ['.', '#', '#', '#', '#', '.', '#', '.', '#', '.'], ['.', '#', '.', '.', '.', '.', '#', '.', '#', '.'], ['.', '#', '#', '#', '#', '#', '#', '.', '#', '.'], ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.'], ['.', '#', '#', '#', '#', '#', '#', '#', '#', '.'] ] >>> is_path_possible(grid6) True pass","solution":"from typing import List def is_path_possible(grid: List[List[str]]) -> bool: if not grid or not grid[0]: return False N = len(grid) M = len(grid[0]) visited = [[False for _ in range(M)] for _ in range(N)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == '.' and not visited[x][y] def dfs(x, y): if x == N - 1 and y == M - 1: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"def is_valid_license_plate(s): Checks if the given string is a valid license plate. The valid formats are two uppercase letters followed by four digits, or four digits followed by two uppercase letters. if len(s) != 6: return \\"Invalid\\" if (s[:2].isupper() and s[2:].isdigit()) or (s[:4].isdigit() and s[4:].isupper()): return \\"Valid\\" return \\"Invalid\\" def check_license_plates(plate_strings): Given a list of strings, determines if each string is a valid license plate. The valid formats are two uppercase letters followed by four digits, or four digits followed by two uppercase letters. The input list is terminated by a string containing only '#'. Returns a list of \\"Valid\\" or \\"Invalid\\" for each input string except '#'. >>> check_license_plates([\\"AB1234\\", \\"1234AB\\", \\"abcd12\\", \\"1A2B3C\\", \\"ABCD12\\", \\"123ABC\\", \\"BA9876\\", \\"#\\"]) ['Valid', 'Valid', 'Invalid', 'Invalid', 'Invalid', 'Invalid', 'Valid'] def test_is_valid_license_plate(): assert is_valid_license_plate(\\"AB1234\\") == \\"Valid\\" assert is_valid_license_plate(\\"1234AB\\") == \\"Valid\\" assert is_valid_license_plate(\\"abcd12\\") == \\"Invalid\\" assert is_valid_license_plate(\\"1A2B3C\\") == \\"Invalid\\" assert is_valid_license_plate(\\"ABCD12\\") == \\"Invalid\\" assert is_valid_license_plate(\\"123ABC\\") == \\"Invalid\\" assert is_valid_license_plate(\\"BA9876\\") == \\"Valid\\" assert is_valid_license_plate(\\"#\\") == \\"Invalid\\" def test_check_license_plates(): input_plates = [ \\"AB1234\\", \\"1234AB\\", \\"abcd12\\", \\"1A2B3C\\", \\"ABCD12\\", \\"123ABC\\", \\"BA9876\\", \\"#\\" ] expected_output = [ \\"Valid\\", \\"Valid\\", \\"Invalid\\", \\"Invalid\\", \\"Invalid\\", \\"Invalid\\", \\"Valid\\" ] assert check_license_plates(input_plates) == expected_output test_is_valid_license_plate() test_check_license_plates()","solution":"def is_valid_license_plate(s): Checks if the given string is a valid license plate. The valid formats are two uppercase letters followed by four digits, or four digits followed by two uppercase letters. if len(s) != 6: return \\"Invalid\\" if (s[:2].isupper() and s[2:].isdigit()) or (s[:4].isdigit() and s[4:].isupper()): return \\"Valid\\" return \\"Invalid\\" def check_license_plates(plate_strings): results = [] for plate in plate_strings: if plate == '#': break results.append(is_valid_license_plate(plate)) return results"},{"question":"def max_excitement(n, w, s): Calculate the maximum excitement level for each starting doorway for the given days. n: int - The number of doorways. w: list - List of weights of toys. s: list - List of starting doorways for each day. Returns: list - List of maximum excitement levels for each starting doorway. Example: >>> max_excitement(5, [1, 3, 5, 7, 9], [1, 3, 5]) [25, 25, 25] >>> max_excitement(4, [10, 20, 30, 40], [2, 4]) [100, 100] pass Unit Test: def test_max_excitement(): assert max_excitement(5, [1, 3, 5, 7, 9], [1, 3, 5]) == [25, 25, 25] assert max_excitement(4, [10, 20, 30, 40], [2, 4]) == [100, 100] assert max_excitement(3, [5, 5, 5], [1, 2, 3]) == [15, 15, 15] assert max_excitement(6, [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]) == [21, 21, 21, 21, 21, 21] assert max_excitement(7, [7, 14, 21, 28, 35, 42, 49], [7, 5, 6, 1]) == [196, 196, 196, 196] assert max_excitement(1, [99], [1]) == [99] test_max_excitement() # This will run the unit tests to verify our solution","solution":"def max_excitement(n, w, s): Calculate the maximum excitement level for each starting doorway for the given days. n: int - The number of doorways. w: list - List of weights of toys. s: list - List of starting doorways for each day. Returns: list - List of maximum excitement levels for each starting doorway. total_excitement = sum(w) return [total_excitement for _ in s]"},{"question":"def min_difference(n: int, values: List[int]) -> int: Returns the minimum possible difference between the total value of the two groups. >>> min_difference(4, [1, 2, 3, 4]) 0 >>> min_difference(3, [8, 3, 5]) 0","solution":"def min_difference(n, values): Returns the minimum possible difference between the total value of the two groups. total_sum = sum(values) dp = [False] * (total_sum // 2 + 1) dp[0] = True for value in values: for j in range(total_sum // 2, value - 1, -1): dp[j] |= dp[j - value] for i in range(total_sum // 2, -1, -1): if dp[i]: return total_sum - 2 * i # Examples in the prompt print(min_difference(4, [1, 2, 3, 4])) # Output: 0 print(min_difference(3, [8, 3, 5])) # Output: 0"},{"question":"def max_bitwise_and(n: int, arr: List[int]) -> int: Finds the maximum bitwise AND value among all possible subarrays of the given array. >>> max_bitwise_and(5, [1, 2, 3, 4, 5]) # 5 >>> max_bitwise_and(4, [12, 15, 7, 9]) # 15 >>> max_bitwise_and(3, [1, 1, 1]) # 1","solution":"def max_bitwise_and(n, arr): Finds the maximum bitwise AND value among all possible subarrays of the given array. max_and = 0 for num in arr: max_and = max(max_and, num) return max_and"},{"question":"from typing import List def rob(nums: List[int]) -> int: Returns the maximum amount of money the robber can rob without robbing two consecutive houses. >>> rob([1,2,3,1]) 4 >>> rob([2,7,9,3,1]) 12","solution":"from typing import List def rob(nums: List[int]) -> int: Returns the maximum amount of money the robber can rob without robbing two consecutive houses. if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def highest_scorers(participants, scores): Returns a list of participant names with the highest score in alphabetical order >>> participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Dan\\", \\"Eve\\"] >>> scores = { ... \\"Alice\\": 95, ... \\"Bob\\": 85, ... \\"Charlie\\": 95, ... \\"Dan\\": 80, ... \\"Eve\\": 95 ... } >>> highest_scorers(participants, scores) ['Alice', 'Charlie', 'Eve']","solution":"def highest_scorers(participants, scores): Returns a list of participant names with the highest score in alphabetical order if not participants or not scores: return [] # Get the highest score highest_score = max(scores.values()) # Find all participants with the highest score highest_scorers = [name for name in participants if scores.get(name, 0) == highest_score] # Sort the result in alphabetical order highest_scorers.sort() return highest_scorers"},{"question":"def max_consecutive_group(individuals: List[str]) -> Tuple[int, int]: Determine the maximum number of consecutive humans and aliens. Arguments: individuals -- list of strings representing humans ('h') and aliens ('a') Returns: A tuple (max_humans, max_aliens) where: - max_humans is the maximum number of consecutive humans - max_aliens is the maximum number of consecutive aliens >>> max_consecutive_group([\\"h\\", \\"a\\", \\"a\\", \\"a\\", \\"h\\", \\"h\\", \\"a\\", \\"h\\", \\"h\\", \\"h\\"]) (3, 3) >>> max_consecutive_group([\\"h\\", \\"a\\", \\"h\\", \\"a\\", \\"h\\", \\"a\\"]) (1, 1) >>> max_consecutive_group([\\"h\\"]) (1, 0) >>> max_consecutive_group([\\"a\\"]) (0, 1) >>> max_consecutive_group([\\"h\\"] * 10) (10, 0) >>> max_consecutive_group([\\"a\\"] * 5) (0, 5)","solution":"def max_consecutive_group(individuals): max_humans = 0 max_aliens = 0 current_humans = 0 current_aliens = 0 for individual in individuals: if individual == \\"h\\": current_humans += 1 current_aliens = 0 elif individual == \\"a\\": current_aliens += 1 current_humans = 0 max_humans = max(max_humans, current_humans) max_aliens = max(max_aliens, current_aliens) return max_humans, max_aliens"},{"question":"# Function Signature from typing import List, Tuple def frequent_combos(order_log: List[Tuple[int, int]], threshold: int) -> List[Tuple[int, int]]: Create a function that takes in an order log and a threshold, and returns a list of product pairs frequently ordered together. >>> frequent_combos([(1, 2), (2, 1), (3, 5), (2, 1), (1, 2), (3, 5)], 2) [(1, 2), (2, 3)] >>> frequent_combos([(1, 1), (2, 1), (3, 1), (4, 1)], 2) [] >>> frequent_combos([(1, 2), (2, 2), (1, 2), (2, 2)], 2) [(1, 2)] >>> frequent_combos([(1, 2), (2, 2), (3, 2), (1, 2), (2, 2), (3, 2)], 2) [(1, 2), (1, 3), (2, 3)] >>> frequent_combos([(1, 3), (2, 2), (1, 3), (2, 2), (1, 3), (2, 2)], 3) [(1, 2)] pass from solution import frequent_combos def test_no_combinations_meet_threshold(): order_log = [(1, 1), (2, 1), (3, 1), (4, 1)] threshold = 2 assert frequent_combos(order_log, threshold) == [] def test_single_combination_exceeds_threshold(): order_log = [(1, 2), (2, 2), (1, 2), (2, 2)] threshold = 2 assert frequent_combos(order_log, threshold) == [(1, 2)] def test_multiple_combinations_meet_threshold(): order_log = [(1, 2), (2, 2), (3, 2), (1, 2), (2, 2), (3, 2)] threshold = 2 assert frequent_combos(order_log, threshold) == [(1, 2), (1, 3), (2, 3)] def test_combinations_with_higher_threshold(): order_log = [(1, 3), (2, 2), (1, 3), (2, 2), (1, 3), (2, 2)] threshold = 3 assert frequent_combos(order_log, threshold) == [(1, 2)] def test_multiple_orders_below_threshold(): order_log = [(1, 2), (2, 1), (3, 1), (1, 1), (2, 1), (3, 1)] threshold = 3 assert frequent_combos(order_log, threshold) == []","solution":"from typing import List, Tuple from collections import defaultdict from itertools import combinations def frequent_combos(order_log: List[Tuple[int, int]], threshold: int) -> List[Tuple[int, int]]: # Dictionary to keep track of combinations count combo_count = defaultdict(int) # Iterate over the order log and calculate combinations for product_id, quantity in order_log: combo_count[product_id] += quantity # List to store the result result = [] # Find all combinations of products and their counts product_ids = list(combo_count.keys()) for combo in combinations(product_ids, 2): combo_key = tuple(sorted(combo)) # Sum up the combination count if combo_count[combo[0]] >= threshold and combo_count[combo[1]] >= threshold: result.append(combo_key) # Sort result based on first product ID, and then by the second product ID result.sort() return result"},{"question":"class TrieNode: def __init__(self): Initialize the Trie node with a dictionary to store children and a flag to denote end of word. class Trie: def __init__(self): Initialize the Trie with a root TrieNode. def insert(self, word): Inserts a word into the trie. def search(self, word): Returns if the word is in the trie. def startsWith(self, prefix): Returns if there is any word in the trie that starts with the given prefix. import pytest def test_trie_operations(): trie = Trie() # Test insert and search operations trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True assert trie.search(\\"app\\") == False # Test startsWith operation assert trie.startsWith(\\"app\\") == True # Test insert and search operations again trie.insert(\\"app\\") assert trie.search(\\"app\\") == True # Test insert and startsWith operations trie.insert(\\"application\\") assert trie.startsWith(\\"appl\\") == True def test_insert_search_startsWith(): trie = Trie() trie.insert(\\"hello\\") trie.insert(\\"world\\") trie.insert(\\"hi\\") trie.insert(\\"her\\") assert trie.search(\\"hello\\") == True assert trie.search(\\"hero\\") == False assert trie.startsWith(\\"wo\\") == True assert trie.startsWith(\\"he\\") == True assert trie.startsWith(\\"h\\") == True assert trie.startsWith(\\"her\\") == True assert trie.startsWith(\\"hera\\") == False if __name__ == \\"__main__\\": pytest.main()","solution":"class TrieNode: def __init__(self): Initialize the Trie node with a dictionary to store children and a flag to denote end of word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the Trie with a root TrieNode. self.root = TrieNode() def insert(self, word): Inserts a word into the trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): Returns if the word is in the trie. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def startsWith(self, prefix): Returns if there is any word in the trie that starts with the given prefix. node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(nodes, n): Constructs a binary tree from a list of nodes. Args: nodes (List[Tuple[int, int, int]]): Each tuple contains a value v and two integers l and r representing the left and right children. n (int): Number of nodes in the tree. Returns: TreeNode: The root of the binary tree. def smallest_from_leaf(root): Finds the lexicographically smallest string from leaf to the root in a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: str: Lexicographically smallest string from leaf to root. >>> smallest_from_leaf(build_tree([(0, 1, 2), (1, 3, 4), (2, 5, 6), (3, -1, -1), (4, -1, -1), (5, -1, -1), (6, -1, -1)], 7)) 'dba' >>> smallest_from_leaf(build_tree([(0, -1, -1)], 1)) 'a' >>> smallest_from_leaf(build_tree([(0, 1, -1), (1, 2, -1), (2, 3, -1), (3, -1, -1)], 4)) 'dcba' >>> smallest_from_leaf(build_tree([(0, -1, 1), (1, -1, 2), (2, -1, 3), (3, -1, -1)], 4)) 'dcba' >>> smallest_from_leaf(build_tree([(0, 1, 2), (1, -1, -1), (2, -1, -1)], 3)) 'ba'","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(nodes, n): tree_nodes = [TreeNode() for _ in range(n)] for i in range(n): v, l, r = nodes[i] tree_nodes[i].value = v if l != -1: tree_nodes[i].left = tree_nodes[l] if r != -1: tree_nodes[i].right = tree_nodes[r] return tree_nodes[0] def smallest_from_leaf(root): def dfs(node, path): if not node: return path.append(chr(node.value + ord('a'))) if not node.left and not node.right: result.append(''.join(reversed(path))) dfs(node.left, path) dfs(node.right, path) path.pop() result = [] dfs(root, []) return min(result) if result else '' # Parsing input and creating the binary tree def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) nodes = [tuple(map(int, data[i*3+1:i*3+4])) for i in range(n)] root = build_tree(nodes, n) print(smallest_from_leaf(root)) # If running this script directly, use the main function to handle input/output if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Dict def count_top_level_domains(domains: List[str]) -> Dict[str, int]: Counts the occurrences of top-level domains (TLDs) in the given list of domain names. Parameters: domains (list of str): A list of domain names. Returns: dict: A dictionary where keys are top-level domains (TLDs) and values are their counts. >>> count_top_level_domains([\\"example.com\\"]) {\\"com\\": 1} >>> count_top_level_domains([\\"example.com\\", \\"test.org\\", \\"site.edu\\", \\"example.edu\\", \\"mywebsite.com\\"]) {\\"com\\": 2, \\"org\\": 1, \\"edu\\": 2} >>> count_top_level_domains([\\"example.com\\", \\"anotherexample.com\\"]) {\\"com\\": 2} >>> count_top_level_domains([\\"example.com\\", \\"example.org\\", \\"example.net\\"]) {\\"com\\": 1, \\"org\\": 1, \\"net\\": 1} >>> count_top_level_domains([\\"example.com\\", \\"example.org\\", \\"example.net\\", \\"example.io\\", \\"example.edu\\"]) {\\"com\\": 1, \\"org\\": 1, \\"net\\": 1, \\"io\\": 1, \\"edu\\": 1} >>> count_top_level_domains([\\"sub.example.com\\", \\"another.sub.example.org\\"]) {\\"com\\": 1, \\"org\\": 1}","solution":"from typing import List, Dict def count_top_level_domains(domains: List[str]) -> Dict[str, int]: Counts the occurrences of top-level domains (TLDs) in the given list of domain names. Parameters: domains (list of str): A list of domain names. Returns: dict: A dictionary where keys are top-level domains (TLDs) and values are their counts. tld_count = {} for domain in domains: tld = domain.split('.')[-1] if tld in tld_count: tld_count[tld] += 1 else: tld_count[tld] = 1 return tld_count"},{"question":"def min_coins(coins, amount): Find the minimum number of coins required to make a given amount. :param coins: List[int] - the coin denominations available :param amount: int - the target amount :return: int - the minimum number of coins required or -1 if not possible pass def process_test_cases(test_cases): Process multiple test cases to find the minimum number of coins needed for each. :param test_cases: List[List[int]] - each test case with number of denominations, coin values and amount :return: List[int] - results for each test case pass def main(input_lines): Main function to read input lines, process them and print the results. :param input_lines: List[str] - lines of input pass # Example unit tests import pytest def test_min_coins_case_1(): coins = [1, 2, 5] amount = 11 assert min_coins(coins, amount) == 3 # 5+5+1 def test_min_coins_case_2(): coins = [2, 5, 10, 20] amount = 15 assert min_coins(coins, amount) == 2 # 10+5 def test_min_coins_case_3(): coins = [1, 3, 4] amount = 6 assert min_coins(coins, amount) == 2 # 3+3 def test_min_coins_case_4(): coins = [2] amount = 3 assert min_coins(coins, amount) == -1 # Not possible def test_min_coins_case_5(): coins = [1] amount = 0 assert min_coins(coins, amount) == 0 # No coins needed def test_process_test_cases(): test_cases = [ [3, 1, 2, 5, 11], [4, 2, 5, 10, 20, 15], [0] ] assert process_test_cases(test_cases) == [3, 2] pytest.main()","solution":"def min_coins(coins, amount): Find the minimum number of coins required to make a given amount. :param coins: List[int] - the coin denominations available :param amount: int - the target amount :return: int - the minimum number of coins required or -1 if not possible if amount == 0: return 0 # Initialize the DP array with a value larger than any possible answer dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1 def process_test_cases(test_cases): results = [] for case in test_cases: n, *data = case if n == 0: break coins = data[:n] amount = data[n] results.append(min_coins(coins, amount)) return results def main(input_lines): test_cases = [] for line in input_lines: parts = list(map(int, line.split())) if parts[0] == 0: break test_cases.append(parts) results = process_test_cases(test_cases) for result in results: print(result) # Example input input_lines = [ \\"3 1 2 5 11\\", \\"4 2 5 10 20 15\\", \\"0\\" ] main(input_lines)"},{"question":"from typing import List def smallest_lexicographical_sequence(n: int, nums: List[int]) -> List[int]: Given a list of integers, arrange the integers into the lexicographically smallest sequence possible using the described process. >>> smallest_lexicographical_sequence(6, [4, 2, 3, 1, 5, 6]) [1, 2, 3, 4, 5, 6] >>> smallest_lexicographical_sequence(5, [5, 3, 4, 2, 1]) [1, 2, 3, 4, 5] >>> smallest_lexicographical_sequence(3, [3, 1, 2]) [1, 2, 3]","solution":"def smallest_lexicographical_sequence(n, nums): nums.sort() return nums"},{"question":"def max_requests(n, q, requests, queries): Returns the maximum number of requests processed during any contiguous subarray of length exactly \`m\`. Args: n : int : number of time units q : int : number of queries requests : list : list of integers representing the number of requests processed at each time unit queries : list : list of integers representing the length of the contiguous subarray for each query Returns: list : list of integers where each element is the maximum number of requests processed during any contiguous subarray of length exactly \`m\` for each \`m\` in queries. pass # Unit Test def test_max_requests_example(): assert max_requests(8, 3, [1, 3, 2, 5, 1, 1, 2, 3], [3, 5, 6]) == [10, 12, 14] def test_max_requests_single_element(): assert max_requests(1, 1, [10], [1]) == [10] def test_max_requests_all_same_requests(): assert max_requests(5, 2, [2, 2, 2, 2, 2], [2, 3]) == [4, 6] def test_max_requests_m_equals_n(): assert max_requests(6, 1, [1, 2, 3, 4, 5, 6], [6]) == [21] def test_max_requests_various_m(): assert max_requests(5, 3, [10, 20, 30, 40, 50], [1, 2, 3]) == [50, 90, 120]","solution":"def max_requests(n, q, requests, queries): Returns the maximum number of requests processed during any contiguous subarray of length exactly \`m\`. Args: n : int : number of time units q : int : number of queries requests : list : list of integers representing the number of requests processed at each time unit queries : list : list of integers representing the length of the contiguous subarray for each query Returns: list : list of integers where each element is the maximum number of requests processed during any contiguous subarray of length exactly \`m\` for each \`m\` in queries. def max_subarray_sum(arr, m): Calculate the maximum sum of any contiguous subarray of length \`m\`. current_sum = sum(arr[:m]) max_sum = current_sum for i in range(m, len(arr)): current_sum += arr[i] - arr[i - m] if current_sum > max_sum: max_sum = current_sum return max_sum results = [] for m in queries: results.append(max_subarray_sum(requests, m)) return results"},{"question":"def isPalindrome(S: str) -> str: Given a string S, check whether the string is a palindrome or not using a recursive approach. >>> isPalindrome(\\"madam\\") \\"Yes\\" >>> isPalindrome(\\"hello\\") \\"No\\"","solution":"def isPalindrome(S): Checks if a given string S is a palindrome using a recursive approach. def check_palindrome(start, end): # Base case: if start >= end, it's a palindrome if start >= end: return True # Recursive case: check if characters at start and end are the same if S[start] != S[end]: return False return check_palindrome(start + 1, end - 1) # Start the recursion from the full length of the string result = check_palindrome(0, len(S) - 1) return \\"Yes\\" if result else \\"No\\""},{"question":"from typing import List, Tuple def performOperations(arr: List[int], operations: List[Tuple[int, int, int]]) -> int: Perform a series of operations on an array and return the maximum value in the array after all operations. Each operation is represented as a tuple (l, r, k) which indicates that you should add the integer value \`k\` to every element in the array \`arr\` from index \`l\` to index \`r\` (inclusive). Args: arr (List[int]): The initial list of integers. operations (List[Tuple[int, int, int]]): The list of operations to perform on the array. Returns: int: The maximum value in the array after performing all operations. Examples: >>> arr = [1, 2, 3, 4, 5] >>> operations = [(1, 3, 2), (0, 2, 1), (2, 4, 3)] >>> performOperations(arr, operations) 9 >>> arr = [0, 0, 0, 0, 0] >>> operations = [(0, 4, 100), (1, 3, -50), (2, 2, 25)] >>> performOperations(arr, operations) 100","solution":"from typing import List, Tuple def performOperations(arr: List[int], operations: List[Tuple[int, int, int]]) -> int: # Use prefix sum array (difference array) method to efficiently apply range updates n = len(arr) diff = [0] * (n + 1) # Apply range updates using the difference array for l, r, k in operations: diff[l] += k if r + 1 <= n - 1: diff[r + 1] -= k # Apply the difference array to the original array current_addition = 0 for i in range(n): current_addition += diff[i] arr[i] += current_addition # Return the maximum value in the resulting array return max(arr)"},{"question":"def reorder_messages(n, messages): Reorders a list of messages based on their timestamps and message_ids. Parameters: - n (int): number of messages. - messages (list of tuples): each tuple contains (timestamp, message_id, content) Returns: - list of tuples: sorted list of messages. >>> reorder_messages(4, [(1609459201, 3, 'Happy New Year!'), (1609459200, 1, 'Hello!'), (1609459200, 2, 'Welcome!'), (1609459202, 4, 'Goodbye!')]) [(1609459200, 1, 'Hello!'), (1609459200, 2, 'Welcome!'), (1609459201, 3, 'Happy New Year!'), (1609459202, 4, 'Goodbye!')] >>> reorder_messages(3, [(1609459203, 2, 'Hi!'), (1609459203, 1, 'Hey!'), (1609459201, 3, 'How are you?')]) [(1609459201, 3, 'How are you?'), (1609459203, 1, 'Hey!'), (1609459203, 2, 'Hi!')]","solution":"def reorder_messages(n, messages): Reorders a list of messages based on their timestamps and message_ids. Parameters: - n (int): number of messages. - messages (list of tuples): each tuple contains (timestamp, message_id, content) Returns: - list of tuples: sorted list of messages. return sorted(messages, key=lambda x: (x[0], x[1])) # Example usage: # messages = [(1609459201, 3, 'Happy New Year!'), (1609459200, 1, 'Hello!'), (1609459200, 2, 'Welcome!'), (1609459202, 4, 'Goodbye!')] # print(reorder_messages(4, messages))"},{"question":"class Employee: A class to represent an employee with an ID, name, hourly wage, and total hours worked. def __init__(self, emp_id: str, name: str, hourly_wage: float): Initializes an Employee object. Parameters: emp_id (str): The ID of the employee. name (str): The name of the employee. hourly_wage (float): The hourly wage of the employee. pass def work_hours(self, hours: float): Adds the given hours to the total hours worked by the employee. Parameters: hours (float): The number of hours worked in a single session. pass def calculate_pay(self) -> float: Calculates the total pay for the employee. Returns: float: The total pay for the employee. pass # Unit tests def test_employee_initialization(): emp = Employee(\\"E001\\", \\"John Doe\\", 15.0) assert emp.emp_id == \\"E001\\" assert emp.name == \\"John Doe\\" assert emp.hourly_wage == 15.0 assert emp.total_hours == 0.0 def test_work_hours(): emp = Employee(\\"E001\\", \\"John Doe\\", 15.0) emp.work_hours(8) assert emp.total_hours == 8.0 emp.work_hours(4.5) assert emp.total_hours == 12.5 def test_calculate_pay(): emp = Employee(\\"E001\\", \\"John Doe\\", 15.0) emp.work_hours(8) emp.work_hours(4.5) assert emp.calculate_pay() == 187.5 def test_calculate_pay_no_hours(): emp = Employee(\\"E001\\", \\"John Doe\\", 15.0) assert emp.calculate_pay() == 0.0 def test_work_hours_and_calculate_pay(): emp = Employee(\\"E002\\", \\"Jane Doe\\", 20.0) emp.work_hours(5) emp.work_hours(3.5) expected_total_hours = 8.5 expected_pay = 170.0 assert emp.total_hours == expected_total_hours assert emp.calculate_pay() == expected_pay","solution":"class Employee: def __init__(self, emp_id: str, name: str, hourly_wage: float): self.emp_id = emp_id self.name = name self.hourly_wage = hourly_wage self.total_hours = 0.0 def work_hours(self, hours: float): self.total_hours += hours def calculate_pay(self) -> float: return self.total_hours * self.hourly_wage"},{"question":"def process_messages(n, initial_status, messages): Processes a sequence of messages and determines the outcome of each 'check' message. Args: n (int): The number of devices. initial_status (List[int]): Initial status values of the devices. messages (List[str]): Sequence of messages describing operations. Returns: List[str]: Results of the 'check' messages. Examples: >>> process_messages(5, [10, 20, 30, 40, 50], [\\"check 3\\", \\"update 3 100\\", \\"status 3\\", \\"check 3\\"]) ['20 30 40', '20 100 40'] >>> process_messages(4, [5, 15, 25, 35], [\\"check 1\\", \\"update 4 45\\", \\"check 4\\"]) ['-1 5 15', '25 45 -1'] def test_process_messages_example1(): n = 5 initial_status = [10, 20, 30, 40, 50] messages = [\\"check 3\\", \\"update 3 100\\", \\"status 3\\", \\"check 3\\"] result = process_messages(n, initial_status, messages) assert result == [\\"20 30 40\\", \\"20 100 40\\"] def test_process_messages_example2(): n = 4 initial_status = [5, 15, 25, 35] messages = [\\"check 1\\", \\"update 4 45\\", \\"check 4\\"] result = process_messages(n, initial_status, messages) assert result == [\\"-1 5 15\\", \\"25 45 -1\\"] def test_process_messages_single_device(): n = 1 initial_status = [42] messages = [\\"check 1\\", \\"update 1 100\\", \\"check 1\\"] result = process_messages(n, initial_status, messages) assert result == [\\"-1 42 -1\\", \\"-1 100 -1\\"] def test_process_messages_small_random(): n = 3 initial_status = [3, 6, 9] messages = [\\"check 2\\", \\"update 3 10\\", \\"check 2\\"] result = process_messages(n, initial_status, messages) assert result == [\\"3 6 9\\", \\"3 6 10\\"] def test_process_messages_all_checks(): n = 5 initial_status = [1, 2, 3, 4, 5] messages = [\\"check 1\\", \\"check 2\\", \\"check 3\\", \\"check 4\\", \\"check 5\\"] result = process_messages(n, initial_status, messages) assert result == [\\"-1 1 2\\", \\"1 2 3\\", \\"2 3 4\\", \\"3 4 5\\", \\"4 5 -1\\"] def test_process_messages_all_updates(): n = 3 initial_status = [10, 20, 30] messages = [\\"update 1 11\\", \\"update 2 22\\", \\"update 3 33\\", \\"check 1\\", \\"check 2\\", \\"check 3\\"] result = process_messages(n, initial_status, messages) assert result == [\\"-1 11 22\\", \\"11 22 33\\", \\"22 33 -1\\"]","solution":"def process_messages(n, initial_status, messages): status = initial_status[:] # Copying the initial statuses results = [] for msg in messages: parts = msg.split() command = parts[0] if command == \\"status\\": continue # status command does not require any action in our solution elif command == \\"update\\": i = int(parts[1]) - 1 x = int(parts[2]) status[i] = x # Update the status of the device elif command == \\"check\\": i = int(parts[1]) - 1 left = status[i - 1] if i - 1 >= 0 else -1 center = status[i] right = status[i + 1] if i + 1 < n else -1 results.append(f\\"{left} {center} {right}\\") return results # Example usage: n = 5 initial_status = [10, 20, 30, 40, 50] messages = [\\"check 3\\", \\"update 3 100\\", \\"status 3\\", \\"check 3\\"] print(process_messages(n, initial_status, messages)) # Expected: ['20 30 40', '20 100 40']"},{"question":"from typing import List, Tuple def find_minimum_cost(N: int, M: int, connections: List[Tuple[int, int, int]]) -> int: Find the minimum cost to connect all the computers in a network. Parameters: N (int): Number of computers M (int): Number of potential connections connections (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, and w representing the two computers connected by the cable and the cost of the cable Returns: int: The minimum total cost to connect all the computers. If it's impossible, return -1. >>> find_minimum_cost(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 5)]) 6 >>> find_minimum_cost(3, 1, [(1, 2, 1)]) -1 import heapq def test_example_1(): N = 4 M = 5 connections = [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 5)] assert find_minimum_cost(N, M, connections) == 6 def test_example_2(): N = 3 M = 1 connections = [(1, 2, 1)] assert find_minimum_cost(N, M, connections) == -1 def test_no_connections(): N = 3 M = 0 connections = [] assert find_minimum_cost(N, M, connections) == -1 def test_already_connected(): N = 3 M = 3 connections = [(1, 2, 1), (1, 3, 1), (2, 3, 1)] assert find_minimum_cost(N, M, connections) == 2 def test_disconnected_graph(): N = 6 M = 4 connections = [(1, 2, 3), (2, 3, 4), (4, 5, 6), (5, 6, 7)] assert find_minimum_cost(N, M, connections) == -1 def test_large_input(): N = 4 M = 6 connections = [(1, 2, 1), (1, 3, 2), (1, 4, 3), (2, 3, 4), (2, 4, 5), (3, 4, 6)] assert find_minimum_cost(N, M, connections) == 6","solution":"import heapq def find_minimum_cost(N, M, connections): parent = list(range(N + 1)) rank = [0] * (N + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False edges = [] for u, v, w in connections: edges.append((w, u, v)) heapq.heapify(edges) mst_cost = 0 edges_used = 0 while edges and edges_used < N - 1: w, u, v = heapq.heappop(edges) if union(u, v): mst_cost += w edges_used += 1 if edges_used == N - 1: return mst_cost else: return -1"},{"question":"def is_path_exists(n: int, m: int, grid: List[List[int]]) -> str: Determine if there's a path from the top-left corner to the bottom-right corner in a city grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D matrix representing the city grid with 0s and 1s. Returns: str: \\"YES\\" if a path exists, otherwise \\"NO\\". >>> n, m = 3, 3 >>> grid = [ ... [0, 0, 1], ... [1, 0, 1], ... [1, 0, 0] ... ] >>> is_path_exists(n, m, grid) \\"YES\\" >>> n, m = 3, 3 >>> grid = [ ... [0, 1, 1], ... [1, 1, 1], ... [1, 0, 0] ... ] >>> is_path_exists(n, m, grid) \\"NO\\"","solution":"def is_path_exists(n, m, grid): from collections import deque # Helper function to check if a cell is valid def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 # Directions: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS starting from the top-left corner queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # Check if we have reached the bottom-right corner if x == n - 1 and y == m - 1: return \\"YES\\" # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\" # Example usage n, m = 3, 3 grid = [ [0, 0, 1], [1, 0, 1], [1, 0, 0] ] print(is_path_exists(n, m, grid)) # Output should be \\"YES\\""},{"question":"def min_water_flow_operations(grid: List[List[int]]) -> int: Given a two-dimensional grid of size n x m, where each cell contains a non-negative integer representing an elevation, determine the minimum number of water flow operations required to completely fill the grid with water, starting from any empty cell. >>> min_water_flow_operations([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 8 >>> min_water_flow_operations([ ... [0, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 8 >>> min_water_flow_operations([ ... [3, 3, 3], ... [3, 3, 3], ... [3, 3, 3] ... ]) == 0 >>> min_water_flow_operations([ ... [1, 0], ... [0, 2] ... ]) == 2 >>> min_water_flow_operations([ ... [9, 6, 3], ... [8, 5, 2], ... [7, 4, 1] ... ]) == 8","solution":"def min_water_flow_operations(grid): n = len(grid) m = len(grid[0]) def get_neighbors(x, y): neighbors = [] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: neighbors.append((nx, ny)) return neighbors def bfs(): from collections import deque queue = deque() visited = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): if grid[i][j] == max_elev: queue.append((i, j, 0)) visited[i][j] = True total_operations = 0 while queue: x, y, ops = queue.popleft() for nx, ny in get_neighbors(x, y): if not visited[nx][ny] and grid[nx][ny] < grid[x][y]: queue.append((nx, ny, ops + 1)) visited[nx][ny] = True total_operations += 1 return total_operations max_elev = max(max(row) for row in grid) return bfs()"},{"question":"def findUniqueElement(arr): This function takes an array of integers and returns the element that appears only once. >>> findUniqueElement([2, 3, 5, 4, 5, 3, 4]) 2 >>> findUniqueElement([7, 7, 8, 8, 9]) 9","solution":"def findUniqueElement(arr): This function takes an array of integers and returns the element that appears only once. unique_element = 0 for num in arr: unique_element ^= num # Using XOR to find the unique element return unique_element"},{"question":"def hexadecimal_multiplication_table(n): Generates an n x n multiplication table with hexadecimal values. :param n: Size of the multiplication table :return: List of lists representing the table with hexadecimal values >>> hexadecimal_multiplication_table(3) [['0x0', '0x0', '0x0'], ['0x0', '0x1', '0x2'], ['0x0', '0x2', '0x4']] >>> hexadecimal_multiplication_table(5) [['0x0', '0x0', '0x0', '0x0', '0x0'], ['0x0', '0x1', '0x2', '0x3', '0x4'], ['0x0', '0x2', '0x4', '0x6', '0x8'], ['0x0', '0x3', '0x6', '0x9', '0xc'], ['0x0', '0x4', '0x8', '0xc', '0x10']]","solution":"def hexadecimal_multiplication_table(n): Generates an n x n multiplication table with hexadecimal values. :param n: Size of the multiplication table :return: List of lists representing the table with hexadecimal values table = [] for i in range(n): row = [] for j in range(n): row.append(hex(i * j)) table.append(row) return table"},{"question":"def find_median_after_swaps(n, k, coins, swaps): Find the median amount of gold coins after performing all swaps. Parameters: n (int): Number of houses k (int): Number of swaps coins (list of int): List of gold coins in each house swaps (list of tuple of int): List of swap operations (each represented as a tuple of two integers) Returns: int: The median amount of gold coins in the houses after all swaps are performed >>> find_median_after_swaps(5, 2, [1, 3, 5, 7, 9], [(2, 5), (1, 3)]) == 5 >>> find_median_after_swaps(4, 1, [2, 8, 1, 4], [(1, 2)]) == 3 >>> find_median_after_swaps(6, 0, [6, 2, 1, 5, 9, 4], []) == 4 >>> find_median_after_swaps(1, 0, [10], []) == 10 >>> find_median_after_swaps(3, 0, [1, 2, 3], []) == 2 >>> find_median_after_swaps(5, 3, [1, 5, 3, 7, 9], [(5, 1), (3, 4), (2, 3)]) == 5 # Perform the swaps for a, b in swaps: coins[a - 1], coins[b - 1] = coins[b - 1], coins[a - 1] # Sort the coins to find the median coins.sort() # Calculate the median if n % 2 == 1: return coins[n // 2] else: return (coins[n // 2 - 1] + coins[n // 2]) // 2","solution":"def find_median_after_swaps(n, k, coins, swaps): Find the median amount of gold coins after performing all swaps. Parameters: n (int): Number of houses k (int): Number of swaps coins (list of int): List of gold coins in each house swaps (list of tuple of int): List of swap operations (each represented as a tuple of two integers) Returns: int: The median amount of gold coins in the houses after all swaps are performed # Perform the swaps for a, b in swaps: coins[a - 1], coins[b - 1] = coins[b - 1], coins[a - 1] # Sort the coins to find the median coins.sort() # Calculate the median if n % 2 == 1: return coins[n // 2] else: return (coins[n // 2 - 1] + coins[n // 2]) // 2 # Example usage: # n, k = 5, 2 # coins = [1, 3, 5, 7, 9] # swaps = [(2, 5), (1, 3)] # print(find_median_after_swaps(n, k, coins, swaps)) # Output: 5"},{"question":"def is_arithmetic_progression(nums): Determines if an array forms an arithmetic progression when sorted. Parameters: nums (List[int]): The array of integers to be checked. Returns: str: \\"Yes\\" if the array forms an arithmetic progression when sorted, otherwise \\"No\\". >>> is_arithmetic_progression([3, 5, 1]) \\"Yes\\" >>> is_arithmetic_progression([1, 2, 4]) \\"No\\"","solution":"def is_arithmetic_progression(nums): Determines if an array forms an arithmetic progression when sorted. Parameters: nums (List[int]): The array of integers to be checked. Returns: str: \\"Yes\\" if the array forms an arithmetic progression when sorted, otherwise \\"No\\". # Sort the array in non-decreasing order nums.sort() # Calculate the common difference from the first two elements diff = nums[1] - nums[0] # Check the difference between each consecutive pair of elements for i in range(2, len(nums)): if nums[i] - nums[i - 1] != diff: return \\"No\\" return \\"Yes\\""},{"question":"def max_total_sweetness(fruits): Determine the maximum total sweetness that can be achieved by repeatedly merging fruits. Args: fruits (List[Tuple[int, int]]): A list of tuples where each tuple contains the weight and sweetness of a fruit. Returns: int: The maximum total sweetness. Example: >>> max_total_sweetness([(1, 3), (2, 1), (4, 2)]) 6 >>> max_total_sweetness([(5, 5), (7, 3), (2, 4), (9, 2)]) 120","solution":"def max_total_sweetness(fruits): from functools import reduce from operator import mul # Extract the sweetness levels from the fruits sweetness_levels = [s for w, s in fruits] # Function to calculate the total sweetness by multiplying all sweets total_sweetness = reduce(mul, sweetness_levels, 1) return total_sweetness # Main function to handle input and output if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) fruits = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n)] result = max_total_sweetness(fruits) print(result)"},{"question":"def min_operations_to_equal_elements(n: int, arr: List[int]) -> int: Compute the minimum number of operations required to make all elements in the array equal. Args: n (int): Number of elements in the array. arr (list of int): The elements of the array. Returns: int: Minimum number of operations required to make all elements equal. >>> min_operations_to_equal_elements(3, [3, 1, 4]) 3 >>> min_operations_to_equal_elements(1, [5]) 0 >>> min_operations_to_equal_elements(5, [2, 4, 7, 3, 3]) 6 >>> min_operations_to_equal_elements(3, [100, 200, 300]) 200 >>> min_operations_to_equal_elements(4, [1, 2, 3, 4]) 4 >>> min_operations_to_equal_elements(3, [10, 20, 30]) 20","solution":"def min_operations_to_equal_elements(n, arr): Function to compute the minimum number of operations required to make all elements of the array equal. Args: n: int : number of elements in the array arr: list of int : the elements of the array Returns: int: minimum number of operations required # Sort the array to find the median arr.sort() # Find the median element median = arr[n // 2] # Compute the total number of operations required to make all elements equal to the median operations = sum(abs(x - median) for x in arr) return operations"},{"question":"from typing import List, Tuple def minimize_overlaps(shows: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Rearrange shows to minimize the total number of overlapping shows. >>> minimize_overlaps([(1, 5), (2, 3), (4, 7), (6, 8)]) [(2, 3), (4, 7), (6, 8)] >>> minimize_overlaps([(1, 3), (4, 6), (7, 9)]) [(1, 3), (4, 6), (7, 9)] >>> minimize_overlaps([(1, 2)]) [(1, 2)]","solution":"from typing import List, Tuple def minimize_overlaps(shows: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Rearrange shows to minimize the total number of overlapping shows. # Sort the shows by their end time; if end time is the same, by start time shows.sort(key=lambda x: (x[1], x[0])) # Initialize the solution list with the first show result = [shows[0]] # Track the end time of the last added show in the result list last_end_time = shows[0][1] # Loop over the sorted shows starting from the second one for i in range(1, len(shows)): # Only add the show if it doesn't overlap with the last added show if shows[i][0] >= last_end_time: result.append(shows[i]) last_end_time = shows[i][1] return result"},{"question":"def k_means_clustering(k, n, documents, embeddings_list): Classify the documents into k clusters using k-means clustering. Parameters: k (int): Number of clusters. n (int): Number of documents. documents (List[str]): List of n documents, each represented as a space-separated list of words. embeddings_list (List[str]): List of word embeddings, each of the form \`word vector\`, where \`vector\` is a space-separated list of floats. Returns: List[int]: List of cluster assignments for each document. Examples: >>> k = 2 >>> n = 3 >>> documents = [ \\"apple banana fruit\\", \\"fruit apple\\", \\"dog cat pet\\" ] >>> embeddings_list = [ \\"apple 0.1 0.2 0.3 ... 0.299\\", \\"banana 0.4 0.5 0.6 ... 0.398\\", \\"fruit 0.7 0.8 0.9 ... 0.697\\", \\"dog 0.2 0.3 0.4 ... 0.299\\", \\"cat 0.5 0.6 0.7 ... 0.498\\", \\"pet 0.8 0.9 1.0 ... 0.899\\", ] >>> k_means_clustering(k, n, documents, embeddings_list) [0, 0, 1] from solution import k_means_clustering def test_k_means_clustering(): k = 2 n = 3 documents = [ \\"apple banana fruit\\", \\"fruit apple\\", \\"dog cat pet\\" ] embeddings_list = [ \\"apple 0.1 0.2 0.3 ...\\" + ' '.join(['0.299'] * 296), \\"banana 0.4 0.5 0.6 ...\\" + ' '.join(['0.398'] * 296), \\"fruit 0.7 0.8 0.9 ...\\" + ' '.join(['0.697'] * 296), \\"dog 0.2 0.3 0.4 ...\\" + ' '.join(['0.299'] * 296), \\"cat 0.5 0.6 0.7 ...\\" + ' '.join(['0.498'] * 296), \\"pet 0.8 0.9 1.0 ...\\" + ' '.join(['0.899'] * 296), ] embeddings_list = [\\" \\".join(embedding.split()[:2] + ['%.3f' % (i+1) for i in range(300)]) for embedding in embeddings_list] labels = k_means_clustering(k, n, documents, embeddings_list) assert labels[0] == labels[1] assert labels[0] != labels[2] def test_single_cluster(): k = 1 n = 2 documents = [ \\"apple fruit\\", \\"banana fruit\\" ] embeddings_list = [ \\"apple 0.1 0.2 0.3 ...\\" + ' '.join(['0.299'] * 296), \\"banana 0.4 0.5 0.6 ...\\" + ' '.join(['0.398'] * 296), \\"fruit 0.7 0.8 0.9 ...\\" + ' '.join(['0.697'] * 296), ] embeddings_list = [\\" \\".join(embedding.split()[:2] + ['%.3f' % (i+1) for i in range(300)]) for embedding in embeddings_list] labels = k_means_clustering(k, n, documents, embeddings_list) assert labels[0] == 0 assert labels[1] == 0 def test_different_clusters(): k = 2 n = 2 documents = [ \\"apple banana\\", \\"dog cat\\" ] embeddings_list = [ \\"apple 0.1 0.2 0.3 ...\\" + ' '.join(['0.299'] * 296), \\"banana 0.4 0.5 0.6 ...\\" + ' '.join(['0.398'] * 296), \\"dog 0.2 0.3 0.4 ...\\" + ' '.join(['0.299'] * 296), \\"cat 0.5 0.6 0.7 ...\\" + ' '.join(['0.498'] * 296), ] embeddings_list = [\\" \\".join(embedding.split()[:2] + ['%.3f' % (i+1) for i in range(300)]) for embedding in embeddings_list] labels = k_means_clustering(k, n, documents, embeddings_list) assert labels[0] != labels[1]","solution":"import numpy as np from sklearn.cluster import KMeans def avg_vector(document, embeddings): vectors = [embeddings[word] for word in document if word in embeddings] return np.mean(vectors, axis=0) if vectors else np.zeros(300) def k_means_clustering(k, n, documents, embeddings_list): embeddings = {emb.split()[0]: np.array(list(map(float, emb.split()[1:]))) for emb in embeddings_list} doc_vectors = [avg_vector(doc.split(), embeddings) for doc in documents] kmeans = KMeans(n_clusters=k, random_state=0).fit(doc_vectors) return kmeans.labels_ # Example usage if __name__ == \\"__main__\\": k = 2 n = 3 documents = [ \\"apple banana fruit\\", \\"fruit apple\\", \\"dog cat pet\\" ] embeddings_list = [ \\"apple 0.1 0.2 0.3 ... 0.299\\".split(), \\"banana 0.4 0.5 0.6 ... 0.398\\".split(), \\"fruit 0.7 0.8 0.9 ... 0.697\\".split(), \\"dog 0.2 0.3 0.4 ... 0.299\\".split(), \\"cat 0.5 0.6 0.7 ... 0.498\\".split(), \\"pet 0.8 0.9 1.0 ... 0.899\\".split() ] embeddings_list = [\\" \\".join(embedding[:2] + ['%.3f' % (i+1) for i in range(300)]) for embedding in embeddings_list] labels = k_means_clustering(k, n, documents, embeddings_list) print(labels)"},{"question":"def min_starships_needed(n: int, m: int, package_weights: List[int], starship_caps: List[int]) -> int: Calculate the minimum number of starships required to carry all packages. If it is impossible to carry all packages with the given starships, return -1. >>> min_starships_needed(5, 3, [5, 10, 3, 7, 8], [15, 10, 20]) 2 >>> min_starships_needed(4, 2, [2, 2, 2, 3], [3, 3]) -1","solution":"def min_starships_needed(n, m, package_weights, starship_caps): package_weights.sort(reverse=True) starship_caps.sort(reverse=True) used_starships = [0] * m for weight in package_weights: for i in range(m): if used_starships[i] + weight <= starship_caps[i]: used_starships[i] += weight break else: return -1 count = 0 for used in used_starships: if used > 0: count += 1 return count"},{"question":"def min_operations_to_palindrome(s: str) -> int: Compute the minimum number of operations required to convert the string s into a palindrome. Args: s (str): The input string consisting of only alphabetical characters. Returns: int: The minimum number of operations needed to convert the string into a palindrome. Examples: >>> min_operations_to_palindrome(\\"abc\\") 2 >>> min_operations_to_palindrome(\\"race\\") 1 # MISSING IMPLEMENTATION def process_input(): import sys input = sys.stdin.read data = input().splitlines() case_number = 1 results = [] for line in data: if line == '*': break operations = min_operations_to_palindrome(line) results.append(f\\"Case {case_number}: {operations}\\") case_number += 1 return results def main(): results = process_input() for result in results: print(result)","solution":"def min_operations_to_palindrome(s): Computes the minimum number of operations required to convert the string \`s\` into a palindrome. n = len(s) ops = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: ops += 1 return ops def process_input(): import sys input = sys.stdin.read data = input().splitlines() case_number = 1 results = [] for line in data: if line == '*': break operations = min_operations_to_palindrome(line) results.append(f\\"Case {case_number}: {operations}\\") case_number += 1 return results def main(): results = process_input() for result in results: print(result)"},{"question":"def toggle_bulbs(M, N, initial_states, operations): Toggles the states of bulbs based on a list of operations. Parameters: M (int): Number of bulbs. N (int): Number of operations. initial_states (list of int): Initial states of the bulbs. operations (list of tuple): Each tuple contains two integers (L, R), indicating the range of bulbs to toggle. Returns: list of int: Final states of the bulbs. pass # Example test cases def test_example_case(): M, N = 5, 3 initial_states = [0, 1, 0, 1, 0] operations = [(1, 3), (2, 4), (3, 5)] assert toggle_bulbs(M, N, initial_states, operations) == [1, 1, 1, 1, 1] def test_all_off(): M, N = 4, 2 initial_states = [0, 0, 0, 0] operations = [(1, 2), (3, 4)] assert toggle_bulbs(M, N, initial_states, operations) == [1, 1, 1, 1] def test_alternate_on_off(): M, N = 5, 1 initial_states = [0, 1, 0, 1, 0] operations = [(1, 5)] assert toggle_bulbs(M, N, initial_states, operations) == [1, 0, 1, 0, 1] def test_no_operations(): M, N = 3, 0 initial_states = [1, 0, 1] operations = [] assert toggle_bulbs(M, N, initial_states, operations) == [1, 0, 1] def test_full_range_toggle(): M, N = 6, 2 initial_states = [0, 1, 1, 0, 0, 1] operations = [(1, 6), (1, 6)] assert toggle_bulbs(M, N, initial_states, operations) == [0, 1, 1, 0, 0, 1]","solution":"def toggle_bulbs(M, N, initial_states, operations): Toggles the states of bulbs based on a list of operations. Parameters: M (int): Number of bulbs. N (int): Number of operations. initial_states (list of int): Initial states of the bulbs. operations (list of tuple): Each tuple contains two integers (L, R), indicating the range of bulbs to toggle. Returns: list of int: Final states of the bulbs. bulbs = initial_states[:] for (L, R) in operations: for i in range(L - 1, R): bulbs[i] = 1 - bulbs[i] return bulbs # Example usage: # M, N = 5, 3 # initial_states = [0, 1, 0, 1, 0] # operations = [(1, 3), (2, 4), (3, 5)] # print(toggle_bulbs(M, N, initial_states, operations)) # Output: [1, 1, 1, 1, 1]"},{"question":"def solve_queries(T: int, test_cases: List[Tuple[int, int, List[int], List[Tuple[int, int]]]]) -> List[int]: For each query, determine the sum of the distinct elements in the subarray from index L to index R (inclusive). Args: T (int): Number of test cases test_cases (List[Tuple[int, int, List[int], List[Tuple[int, int]]]]): List containing tuples where each tuple represents a test case. Each test case tuple contains: - N (int): Number of integers in the sequence - Q (int): Number of queries - List[int]: Sequence of N integers - List[Tuple[int, int]]: Q queries where each query is a tuple of two integers L and R. Returns: List[int]: List of results for each query. Example: >>> T = 1 >>> test_cases = [(5, 3, [1, 2, 3, 2, 1], [(1, 3), (2, 5), (1, 5)])] >>> solve_queries(T, test_cases) [6, 6, 6]","solution":"def solve_queries(T, test_cases): results = [] for i in range(T): N, Q, sequence, queries = test_cases[i] for (L, R) in queries: subarray = sequence[L-1:R] distinct_sum = sum(set(subarray)) results.append(distinct_sum) return results # Example Usage T = 1 test_cases = [ (5, 3, [1, 2, 3, 2, 1], [(1, 3), (2, 5), (1, 5)]) ] print(solve_queries(T, test_cases)) # Output: [6, 6, 6]"},{"question":"def second_smallest(nums: List[int]) -> int: Given a list of integers, find and return the second smallest number in the list. If the list has fewer than two unique elements, return -1. Example 1: >>> second_smallest([3, 1, 4, 1, 5, 9]) 3 Example 2: >>> second_smallest([7, 7, 7]) -1","solution":"def second_smallest(nums): Returns the second smallest number in the list, or -1 if it does not exist. if len(nums) < 2: return -1 first = second = float('inf') for num in nums: if num < first: first, second = num, first elif first < num < second: second = num return second if second != float('inf') else -1"},{"question":"def minCoins(coins, amount): Returns the minimum number of coins required to make up the given amount using any combination of the coins. If it's not possible, returns -1. # Your code here from solution import minCoins def test_minCoins_example1(): assert minCoins([1, 2, 5], 11) == 3 def test_minCoins_example2(): assert minCoins([2], 3) == -1 def test_minCoins_zero_amount(): assert minCoins([1, 2, 5], 0) == 0 def test_minCoins_single_coin(): assert minCoins([1], 7) == 7 def test_minCoins_unsorted_coins(): assert minCoins([2, 5, 1], 11) == 3 def test_minCoins_large_amount(): assert minCoins([1, 2, 5], 100) == 20 def test_minCoins_no_solution_large_amount(): assert minCoins([2], 10001) == -1","solution":"def minCoins(coins, amount): Returns the minimum number of coins required to make up the given amount using any combination of the coins. If it's not possible, returns -1. if amount == 0: return 0 # Initialize the array to store the minimum coins for each amount dp = [float('inf')] * (amount + 1) # Base case: no coins are needed to make 0 amount dp[0] = 0 # Iterate over each coin and update the array for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still infinity, it means it's not possible to form the amount with given coins return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def min_replacements_to_substring(s: str, t: str) -> int: Determine the minimum number of character replacements required in s such that s contains at least one occurrence of t as a substring. >>> min_replacements_to_substring(\\"abcde\\", \\"cda\\") 1 >>> min_replacements_to_substring(\\"abcdxyz\\", \\"wxyz\\") 1 >>> min_replacements_to_substring(\\"abcdef\\", \\"def\\") 0 >>> min_replacements_to_substring(\\"zzzz\\", \\"zz\\") 0 >>> min_replacements_to_substring(\\"balloon\\", \\"apple\\") 4 >>> min_replacements_to_substring(\\"aaaaa\\", \\"bbbbb\\") 5","solution":"def min_replacements_to_substring(s, t): Determine the minimum number of character replacements required in s such that s contains at least one occurrence of t as a substring. min_replacements = float('inf') # Iterate over each possible substring of \`s\` with length equal to \`t\` for i in range(len(s) - len(t) + 1): current_replacements = 0 # Compare the substring of s with t for j in range(len(t)): if s[i + j] != t[j]: current_replacements += 1 # Update the minimum replacements if the current one is lower min_replacements = min(min_replacements, current_replacements) return min_replacements"},{"question":"from typing import List, Tuple def preprocess_prefix_sums(arr: List[int]) -> List[int]: Preprocess the array to get the prefix sums which help in finding the sum of any subarray efficiently. pass def query_sum(prefix_sums: List[int], l: int, r: int) -> int: Returns the sum of the subarray from index l to r, inclusive. l and r are 1-based indices. pass def process_queries(n: int, m: int, arr: List[int], queries: List[Tuple[int, int]]) -> Tuple[List[int], List[int]]: Process the queries to get the sum of the subarray for each query and return them as a list of results. The array gets incremented at the end of processing all queries. pass def test_preprocess_prefix_sums(): arr = [1, 2, 3, 4, 5] assert preprocess_prefix_sums(arr) == [0, 1, 3, 6, 10, 15] def test_query_sum(): prefix_sums = [0, 1, 3, 6, 10, 15] assert query_sum(prefix_sums, 2, 4) == 9 assert query_sum(prefix_sums, 1, 5) == 15 assert query_sum(prefix_sums, 3, 3) == 3 def test_process_queries(): n, m = 5, 3 arr = [1, 2, 3, 4, 5] queries = [(2, 4), (1, 5), (3, 3)] expected_results = [9, 15, 3] results, modified_arr = process_queries(n, m, arr, queries) assert results == expected_results assert modified_arr == [2, 3, 4, 5, 6] def test_multiple_queries(): n, m = 5, 2 arr = [5, 4, 3, 2, 1] queries = [(1, 3), (3, 5)] expected_results = [12, 6] results, modified_arr = process_queries(n, m, arr, queries) assert results == expected_results assert modified_arr == [6, 5, 4, 3, 2] def test_single_element_array(): n, m = 1, 1 arr = [10] query = [(1, 1)] expected_results = [10] results, modified_arr = process_queries(n, m, arr, query) assert results == expected_results assert modified_arr == [11]","solution":"def preprocess_prefix_sums(arr): Preprocess the array to get the prefix sums which help in finding the sum of any subarray efficiently. prefix_sums = [0] * (len(arr) + 1) for i in range(len(arr)): prefix_sums[i + 1] = prefix_sums[i] + arr[i] return prefix_sums def query_sum(prefix_sums, l, r): Returns the sum of the subarray from index l to r, inclusive. l and r are 1-based indices. return prefix_sums[r] - prefix_sums[l - 1] def process_queries(n, m, arr, queries): Process the queries to get the sum of the subarray for each query and return them as a list of results. The array gets incremented at the end of processing all queries. # Preprocess to get prefix sums prefix_sums = preprocess_prefix_sums(arr) results = [] # Process each query for l, r in queries: results.append(query_sum(prefix_sums, l, r)) # Increment each element of the array by 1 arr = [x + 1 for x in arr] return results, arr"},{"question":"def serialize(nested_list: list) -> str: Serializes a nested list into a string format as specified. >>> serialize([1, [2, [3, 4], 5], 6]) '1,[2,[3,4],5],6' >>> serialize([[1, 2], 3, [4, [5, 6]]]) '[1,2],3,[4,[5,6]]' def test_serialize(): assert serialize([1, [2, [3, 4], 5], 6]) == '1,[2,[3,4],5],6' assert serialize([[1, 2], 3, [4, [5, 6]]]) == '[1,2],3,[4,[5,6]]' assert serialize([1, 2, [3, 4, [5]], [6, 7]]) == '1,2,[3,4,[5]],[6,7]' assert serialize([]) == '' assert serialize([10, [-100, 0, 1000], -1]) == '10,[-100,0,1000],-1' assert serialize([[[-1], [-2, [-3]]], 4, [[[5]]]]) == '[[-1],[-2,[-3]]],4,[[[5]]]' assert serialize([[1000], [-999], [0]]) == '[1000],[-999],[0]'","solution":"def serialize(nested_list: list) -> str: Serializes a nested list into a string format as specified. def serialize_helper(lst): serialized_elements = [] for element in lst: if isinstance(element, list): serialized_elements.append(f\\"[{serialize_helper(element)}]\\") else: serialized_elements.append(str(element)) return \\",\\".join(serialized_elements) return serialize_helper(nested_list)"},{"question":"def knapsack(n: int, W: int, stones: List[Tuple[int, int]]) -> int: Determines the maximum value that can be achieved with the given weight limit. Args: n (int): Number of stones. W (int): Maximum weight capacity of the knapsack. stones (List[Tuple[int, int]]): List of tuples where each tuple contains the weight and value of the stone (weight, value). Returns: int: Maximum value that can be achieved within the weight limit. Examples: >>> knapsack(4, 8, [(2, 3), (3, 4), (4, 5), (5, 6)]) 10 >>> knapsack(4, 6, [(1, 1), (2, 2), (3, 3), (8, 10)]) 6 >>> knapsack(4, 5, [(1, 10), (2, 20), (3, 30), (4, 40)]) 50 >>> knapsack(3, 50, [(10, 60), (20, 100), (30, 120)]) 220 >>> knapsack(3, 5, [(5, 50), (6, 60), (7, 70)]) 50","solution":"def knapsack(n, W, stones): Determines the maximum value that can be achieved with the given weight limit. Args: n (int): Number of stones W (int): Maximum weight capacity of the knapsack stones (list of tuples): List of tuples where each tuple contains the weight and value of the stone (weight, value) Returns: int: Maximum value that can be achieved within the weight limit # Initialize the DP table dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] # Build the DP table for i in range(1, n + 1): for w in range(1, W + 1): if stones[i-1][0] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-stones[i-1][0]] + stones[i-1][1]) else: dp[i][w] = dp[i-1][w] return dp[n][W]"},{"question":"def is_semi_prime(X: int) -> str: Determine if an integer X is a semi-prime number. Returns \\"YES\\" if X is a semi-prime number, otherwise \\"NO\\". Args: X (int): The integer to be checked. Returns: str: \\"YES\\" if X is a semi-prime, otherwise \\"NO\\". Examples: >>> is_semi_prime(15) \\"YES\\" >>> is_semi_prime(10) \\"YES\\" >>> is_semi_prime(8) \\"NO\\" >>> is_semi_prime(49) \\"YES\\" # additional We can use the following as unit test cases to validate the solution: assert is_semi_prime(15) == \\"YES\\" assert is_semi_prime(10) == \\"YES\\" assert is_semi_prime(49) == \\"YES\\" assert is_semi_prime(8) == \\"NO\\" assert is_semi_prime(1) == \\"NO\\" assert is_semi_prime(100) == \\"NO\\" assert is_semi_prime(4) == \\"YES\\" assert is_semi_prime(9) == \\"YES\\" assert is_semi_prime(6) == \\"YES\\"","solution":"def is_semi_prime(X): Returns \\"YES\\" if X is a semi-prime number, otherwise returns \\"NO\\". def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True for i in range(2, X): if X % i == 0: if is_prime(i) and is_prime(X // i): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def find_paths(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the number of distinct paths between select pairs of cities in a directed acyclic graph. Args: n: int - number of cities. edges: List[Tuple[int, int]] - list of directed roads (u, v) from city u to city v. queries: List[Tuple[int, int]] - list of queries (a, b) to find number of distinct paths from city a to city b. Returns: List[int] - list of the number of distinct paths for each query. Examples: >>> find_paths(5, [(1, 2), (2, 3), (3, 5), (1, 4), (4, 5)], [(1, 5), (4, 5)]) [2, 1] >>> find_paths(4, [(1, 2), (3, 4)], [(1, 4)]) [0]","solution":"from collections import defaultdict, deque def find_paths(n, edges, queries): # Build adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) memo = {} def count_paths(start, end): if start == end: return 1 if start in memo and end in memo[start]: return memo[start][end] path_count = 0 for neighbor in graph[start]: path_count += count_paths(neighbor, end) if start not in memo: memo[start] = {} memo[start][end] = path_count return path_count results = [] for a, b in queries: results.append(count_paths(a, b)) return results def read_input(): n, m = map(int, input().split()) edges = [tuple(map(int, input().split())) for _ in range(m)] q = int(input()) queries = [tuple(map(int, input().split())) for _ in range(q)] return find_paths(n, edges, queries)"},{"question":"def max_performances(schedule): Given a list of performance timings with start and end times, returns the maximum number of non-overlapping performances that can be attended. :param schedule: a list of tuples, where each tuple contains two integers representing the start and end times of a performance. :return: an integer, the maximum number of performances that can be attended. >>> max_performances([(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)]) 3 >>> max_performances([(1, 2), (2, 3), (3, 4)]) 3 >>> max_performances([(1, 4), (1, 4), (1, 4)]) 1 >>> max_performances([(1, 3), (2, 5), (4, 6)]) 2 >>> max_performances([(0, 1)]) 1 >>> max_performances([(i, i+1) for i in range(1000)]) 1000","solution":"def max_performances(schedule): Given a list of performance timings with start and end times, returns the maximum number of non-overlapping performances that can be attended. :param schedule: a list of tuples, where each tuple contains two integers representing the start and end times of a performance. :return: an integer, the maximum number of performances that can be attended. # Sort the performances based on their end time schedule.sort(key=lambda x: x[1]) # Initialize variables max_perf = 0 last_end_time = -1 # Iterate through the sorted schedule for start, end in schedule: if start >= last_end_time: # If the current performance starts after or when the last one ends max_perf += 1 last_end_time = end return max_perf"},{"question":"def kth_highest_unique_score(scores, k): Returns the k-th highest unique score or 'Not enough unique scores' if there are fewer than k unique scores. >>> kth_highest_unique_score([100, 200, 200, 100, 150, 50, 150, 250], 3) 150 >>> kth_highest_unique_score([10, 20, 20, 30, 30], 6) 'Not enough unique scores' >>> kth_highest_unique_score([100, 100, 200, 200, 300, 300], 2) 200 >>> kth_highest_unique_score([50], 1) 50 >>> kth_highest_unique_score([1, 2, 3, 4, 5], 5) 1 >>> kth_highest_unique_score([1, 2, 3, 4, 5], 6) 'Not enough unique scores' >>> kth_highest_unique_score([5, 3, 5, 2, 8, 2, 10, 8], 3) 5 >>> kth_highest_unique_score([100] * 1000, 1) 100","solution":"def kth_highest_unique_score(scores, k): Returns the k-th highest unique score or 'Not enough unique scores' if there are fewer than k unique scores. unique_scores = list(set(scores)) unique_scores.sort(reverse=True) if len(unique_scores) < k: return \\"Not enough unique scores\\" else: return unique_scores[k - 1] def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) k = int(data[1]) scores = list(map(int, data[2:N+2])) result = kth_highest_unique_score(scores, k) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def dijkstra(graph, n, start): Dijkstra's algorithm for finding the shortest paths from a given start vertex. # Implement the algorithm here pass def floyd_warshall(graph, n): Floyd-Warshall algorithm for finding shortest paths between all pairs of vertices. # Implement the algorithm here pass def shortest_cycle_length(graph, n): Find the length of the shortest cycle in the graph. # Implement the algorithm here pass def reverse_edge(graph, u, v): Reverse the direction of an edge in the graph. # Implement the algorithm here pass def main(): Main function to process input and use the above functions to find the shortest cycle length. # Implement the function here pass if __name__ == \\"__main__\\": main() import sys from io import StringIO def run_test(input_data, expected_output): old_stdin = sys.stdin sys.stdin = StringIO(input_data) try: main() finally: sys.stdin = old_stdin def test_case_1(): input_data = 5 6 1 2 2 3 3 4 4 1 4 5 5 2 3 0 4 1 0 1 2 0 5 2 expected_output = 4 4 4 3 run_test(input_data, expected_output) def test_case_2(): input_data = 3 3 1 2 2 3 3 1 2 0 1 2 0 2 3 expected_output = 3 3 3 run_test(input_data, expected_output) def test_case_3(): input_data = 4 3 1 2 2 3 3 4 1 0 2 3 expected_output = -1 -1 run_test(input_data, expected_output) if __name__ == \\"__main__\\": test_case_1() test_case_2() test_case_3()","solution":"import heapq def dijkstra(graph, n, start): distances = [float('inf')] * n distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_vertex = heapq.heappop(pq) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def floyd_warshall(graph, n): dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 for u in range(n): for v, w in graph[u]: dist[u][v] = min(dist[u][v], w) for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def shortest_cycle_length(graph, n): dist = floyd_warshall(graph, n) shortest_cycle = float('inf') for i in range(n): for j in range(n): if i != j and dist[i][j] < float('inf') and dist[j][i] < float('inf'): shortest_cycle = min(shortest_cycle, dist[i][j] + dist[j][i]) return shortest_cycle if shortest_cycle < float('inf') else -1 def reverse_edge(graph, u, v): graph[u] = [(node, weight) for node, weight in graph[u] if node != v] graph[v].append((u, 1)) def main(): import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) m = int(data[index + 1]) graph = [[] for _ in range(n)] index += 2 for _ in range(m): u = int(data[index]) - 1 v = int(data[index + 1]) - 1 graph[u].append((v, 1)) index += 2 q = int(data[index]) index += 1 operations = [] for _ in range(q): operation = (int(data[index]), int(data[index + 1]) - 1, int(data[index + 2]) - 1) operations.append(operation) index += 3 result = [] result.append(shortest_cycle_length(graph, n)) for operation in operations: _, u, v = operation reverse_edge(graph, u, v) result.append(shortest_cycle_length(graph, n)) print(\\"n\\".join(map(str, result))) if __name__ == \\"__main__\\": main()"},{"question":"def distinct_arrangements(queries: List[int]) -> List[int]: Given a list of integers representing the number of friends for each query, returns the number of distinct circular arrangements modulo 1000000007 for each query. >>> distinct_arrangements([1]) == [1] >>> distinct_arrangements([3]) == [2] >>> distinct_arrangements([4]) == [6] >>> distinct_arrangements([10]) == [362880] >>> distinct_arrangements([1, 3, 4, 6]) == [1, 2, 6, 120]","solution":"def factorial_mod(n, mod=1000000007): Computes the factorial of (n-1) % mod. if n == 1: return 1 result = 1 for i in range(2, n): result = (result * i) % mod return result def distinct_arrangements(queries): Given a list of integers representing the number of friends for each query, returns the number of distinct circular arrangements modulo 1000000007 for each query. results = [] for n in queries: results.append(factorial_mod(n)) return results # Example for running the function: # queries = [1, 3, 4] # print(distinct_arrangements(queries))"},{"question":"def max_possible_sum(N: int, A: List[int]) -> int: Given an array of integers, select exactly one non-empty subarray and perform the following operation any number of times: pick one integer from the subarray and add 1 to it. Determine the maximum possible sum of the elements of the subarray after performing the operation any number of times. >>> max_possible_sum(5, [3, 1, 4, 1, 5]) 30 >>> max_possible_sum(3, [9, 8, 7]) 30 >>> max_possible_sum(4, [1, 2, 3, 4]) 20 >>> max_possible_sum(1, [10]) 11 >>> max_possible_sum(6, [1, 1, 1, 1, 1, 1]) 12 from typing import List","solution":"def max_possible_sum(N, A): Given an array of integers, the objective is to select a non-empty subarray and perform an operation where one integer from the subarray is incremented by 1 any number of times to maximize the sum. The operation can be thought of as incrementing each selected subarray element infinite times. The best approach is to choose the entire array because incrementing any subarray won't provide a better maximum than incrementing the entire array. The maximum possible sum is effectively the sum of all elements if they were all incremented to the maximum element present in the array plus one. Parameters: N (int): The number of elements in the array. A (list of int): The array of integers. Returns: int: The maximum possible sum of the elements of the subarray after performing the operation any number of times. max_element = max(A) # Increment every element in the subarray to max_element+1 return N * (max_element + 1)"},{"question":"def max_water_bottles(n: int, c: int, bottles: List[int]) -> int: Determines the maximum number of water bottles that can be collected given the constraints. Parameters: n (int): The number of checkpoints. c (int): The maximum number of water bottles one can carry at a time. bottles (list of int): The number of water bottles available at each checkpoint. Returns: int: The maximum number of water bottles collected. >>> max_water_bottles(5, 10, [1, 2, 3, 4, 5]) 10 >>> max_water_bottles(5, 5, [6, 7, 8, 9, 10]) 5 >>> max_water_bottles(4, 8, [5, 10, 3, 7]) 8 >>> max_water_bottles(0, 10, []) 0 >>> max_water_bottles(5, 0, [1, 2, 3, 4, 5]) 0 >>> max_water_bottles(3, 1000, [400, 300, 350]) 1000 >>> max_water_bottles(3, 7, [4, 2, 1]) 7 >>> max_water_bottles(100000, 1000, [i for i in range(1, 1001)]) 1000 from typing import List def test_example_1(): assert max_water_bottles(5, 10, [1, 2, 3, 4, 5]) == 10 def test_example_2(): assert max_water_bottles(5, 5, [6, 7, 8, 9, 10]) == 5 def test_example_3(): assert max_water_bottles(4, 8, [5, 10, 3, 7]) == 8 def test_no_checkpoints(): assert max_water_bottles(0, 10, []) == 0 def test_zero_capacity(): assert max_water_bottles(5, 0, [1, 2, 3, 4, 5]) == 0 def test_large_values(): assert max_water_bottles(3, 1000, [400, 300, 350]) == 1000 def test_sum_exact_capacity(): assert max_water_bottles(3, 7, [4, 2, 1]) == 7 def test_large_input(): assert max_water_bottles(100000, 1000, [i for i in range(1, 1001)]) == 1000","solution":"def max_water_bottles(n, c, bottles): Determines the maximum number of water bottles that can be collected given the constraints. Parameters: n (int): The number of checkpoints. c (int): The maximum number of water bottles one can carry at a time. bottles (list of int): The number of water bottles available at each checkpoint. Returns: int: The maximum number of water bottles collected. if n == 0 or c == 0: return 0 bottles.sort() total_bottles = 0 for water in bottles: if total_bottles + water <= c: total_bottles += water else: return c return total_bottles"},{"question":"def max_profit(prices): Given an integer array prices where prices[i] represents the price of a given stock on the i-th day, design an algorithm to find the maximum profit. You may complete as many transactions (i.e., buy one and sell one share of the stock multiple times) as you like with the following restrictions: - You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). - After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day). Return the maximum profit you can achieve. Examples: >>> max_profit([1, 2, 3, 0, 2]) 3 >>> max_profit([1]) 0 from solution import max_profit def test_max_profit_example1(): assert max_profit([1, 2, 3, 0, 2]) == 3 def test_max_profit_example2(): assert max_profit([1]) == 0 def test_max_profit_no_prices(): assert max_profit([]) == 0 def test_max_profit_two_days(): assert max_profit([1, 2]) == 1 def test_max_profit_multiple_same_prices(): assert max_profit([1, 1, 1, 1]) == 0 def test_max_profit_alternating_prices(): assert max_profit([1, 2, 1, 2, 1, 2]) == 2 # Buy-sell every alternative day def test_max_profit_declining_prices(): assert max_profit([5, 4, 3, 2, 1]) == 0 # No profit to be made","solution":"def max_profit(prices): Function to determine the maximum profit from stock prices with cooldown period. if not prices: return 0 n = len(prices) if n < 2: return 0 # dp arrays to store the maximum profit up to day i buy = [0] * n sell = [0] * n cooldown = [0] * n # Initial conditions buy[0] = -prices[0] sell[0] = float('-inf') cooldown[0] = 0 for i in range(1, n): buy[i] = max(buy[i-1], cooldown[i-1] - prices[i]) sell[i] = buy[i-1] + prices[i] cooldown[i] = max(cooldown[i-1], sell[i-1]) return max(sell[n-1], cooldown[n-1])"},{"question":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: Rearrange the elements of the array such that the minimum distance between any two adjacent elements is maximized. >>> rearrange_array([4, 3, 9, 1, -7]) [-7, 4, 1, 9, 3] >>> rearrange_array([1, 3, 5, 7]) [1, 7, 3, 5] pass","solution":"def rearrange_array(arr): arr.sort() n = len(arr) result = [0] * n left, right = 0, n-1 for i in range(n): if i % 2 == 0: result[i] = arr[left] left += 1 else: result[i] = arr[right] right -= 1 return result # Example Usage # n = 5 # arr = [4, 3, 9, 1, -7] # rearranged = rearrange_array(arr) # print(rearranged) # Example output: [-7, 4, 1, 9, 3]"},{"question":"def max_pairs(n: int, k: int, strengths: List[int]) -> int: Returns the maximum number of pairs that can be formed with the given strengths and allowable difference k. >>> max_pairs(5, 3, [1, 5, 3, 3, 2]) 2 >>> max_pairs(4, 1, [1, 2, 4, 5]) 2","solution":"def max_pairs(n, k, strengths): Returns the maximum number of pairs that can be formed with the given strengths and allowable difference k. strengths.sort() i = 0 pairs = 0 while i < n - 1: if strengths[i + 1] - strengths[i] <= k: pairs += 1 i += 2 # Move to the next pair else: i += 1 # Check the next potential pair return pairs"},{"question":"from typing import List def find_odd_occurrence(arr: List[int]) -> int: Returns the integer that occurs an odd number of times in the array. >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3]) == 3 >>> find_odd_occurrence([4, 5, 4, 5, 4]) == 4 >>> find_odd_occurrence([-1, -1, -1]) == -1 >>> find_odd_occurrence([10, 15, 10]) == 15 >>> find_odd_occurrence([7]) == 7 >>> find_odd_occurrence([10**9, 10**9, 10**9 + 1]) == 10**9 + 1 >>> find_odd_occurrence([-5, -5, -3, -3, -3]) == -3 >>> find_odd_occurrence([0, -1, 0, -1, -2]) == -2","solution":"from typing import List def find_odd_occurrence(arr: List[int]) -> int: Returns the integer that occurs an odd number of times in the array. result = 0 for num in arr: result ^= num return result"},{"question":"from typing import List, Tuple class SegmentTree: def __init__(self, arr: List[int]): self.n = len(arr) self.tree = [0] * (self.n * 4) self.lazy = [0] * (self.n * 4) self.lazy_set = [None] * (self.n * 4) self.build(0, 0, self.n - 1, arr) def build(self, node: int, start: int, end: int, arr: List[int]): if start == end: self.tree[node] = arr[start] else: mid = (start + end) // 2 self.build(node * 2 + 1, start, mid, arr) self.build(node * 2 + 2, mid + 1, end, arr) self.tree[node] = max(self.tree[node * 2 + 1], self.tree[node * 2 + 2]) def push(self, node: int, start: int, end: int): if self.lazy_set[node] is not None: self.tree[node] = self.lazy_set[node] if start != end: self.lazy_set[node * 2 + 1] = self.lazy_set[node] self.lazy_set[node * 2 + 2] = self.lazy_set[node] self.lazy[node * 2 + 1] = 0 self.lazy[node * 2 + 2] = 0 self.lazy_set[node] = None if self.lazy[node] != 0: self.tree[node] += self.lazy[node] if start != end: if self.lazy_set[node * 2 + 1] is not None: self.lazy_set[node * 2 + 1] += self.lazy[node] else: self.lazy[node * 2 + 1] += self.lazy[node] if self.lazy_set[node * 2 + 2] is not None: self.lazy_set[node * 2 + 2] += self.lazy[node] else: self.lazy[node * 2 + 2] += self.lazy[node] self.lazy[node] = 0 def update_add(self, l: int, r: int, val: int, node: int = 0, start: int = 0, end: int = None): Add \`val\` to all elements in the subarray arr[l...r]. if end is None: end = self.n - 1 self.push(node, start, end) if start > end or start > r or end < l: return if start >= l and end <= r: self.lazy[node] += val self.push(node, start, end) else: mid = (start + end) // 2 self.update_add(l, r, val, node * 2 + 1, start, mid) self.update_add(l, r, val, node * 2 + 2, mid + 1, end) self.tree[node] = max(self.tree[node * 2 + 1], self.tree[node * 2 + 2]) def update_set(self, l: int, r: int, val: int, node: int = 0, start: int = 0, end: int = None): Set all elements in the subarray arr[l...r] to \`val\`. if end is None: end = self.n - 1 self.push(node, start, end) if start > end or start > r or end < l: return if start >= l and end <= r: self.lazy_set[node] = val self.push(node, start, end) else: mid = (start + end) // 2 self.update_set(l, r, val, node * 2 + 1, start, mid) self.update_set(l, r, val, node * 2 + 2, mid + 1, end) self.tree[node] = max(self.tree[node * 2 + 1], self.tree[node * 2 + 2]) def query_max(self, l: int, r: int, node: int = 0, start: int = 0, end: int = None) -> int: Output the maximum value of the elements in the subarray arr[l...r]. if end is None: end = self.n - 1 self.push(node, start, end) if start > end or start > r or end < l: return -float('inf') if start >= l and end <= r: return self.tree[node] mid = (start + end) // 2 left_query = self.query_max(l, r, node * 2 + 1, start, mid) right_query = self.query_max(l, r, node * 2 + 2, mid + 1, end) return max(left_query, right_query) def process_operations(n: int, arr: List[int], operations: List[Tuple[int, ...]]) -> List[int]: Process a series of operations on the sequence. Args: n: The length of the sequence. arr: The initial values of the sequence. operations: The list of operations to process. Returns: The results of all Max_Query operations. seg_tree = SegmentTree(arr) results = [] for op in operations: if op[0] == 1: _, l, r, v = op seg_tree.update_add(l - 1, r - 1, v) elif op[0] == 2: _, l, r = op results.append(seg_tree.query_max(l - 1, r - 1)) elif op[0] == 3: _, l, r, v = op seg_tree.update_set(l - 1, r - 1, v) return results def test_process_operations(): n = 5 arr = [1, 3, 5, 7, 9] operations = [ (1, 1, 3, 4), # Add 4 to the subarray arr[0:3] -> {5, 7, 9, 7, 9} (2, 1, 5), # Max of the array -> 9 (3, 2, 4, 0), # Set arr[1:4] to 0 -> {5, 0, 0, 0, 9} (2, 1, 5), # Max of the array -> 9 (1, 3, 5, -2), # Subtract 2 to the subarray arr[2:5] -> {5, 0, -2, -2, 7} (2, 1, 5) # Max of the array -> 7 ] expected_results = [9, 9, 7] results = process_operations(n, arr, operations) assert results == expected_results def test_set_query(): n = 4 arr = [2, 4, 6, 8] operations = [ (3, 1, 3, 5), # Set arr[0:3] to 5 -> {5, 5, 5, 8} (2, 1, 4), # Max of the array -> 8 (3, 2, 4, 1), # Set arr[1:4] to 1 -> {5, 1, 1, 1} (2, 1, 4) # Max of the array -> 5 ] expected_results = [8, 5] results = process_operations(n, arr, operations) assert results == expected_results def test_add_query_overlapping(): n = 4 arr = [1, 2, 3, 4] operations = [ (1, 1, 2, 1), # Add 1 to arr[0:2] -> {2, 3, 3, 4} (1, 2, 4, 2), # Add 2 to arr[1:4] -> {2, 5, 5, 6} (2, 1, 4) # Max of the array -> 6 ] expected_results = [6] results = process_operations(n, arr, operations) assert results == expected_results","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (self.n * 4) self.lazy = [0] * (self.n * 4) self.lazy_set = [None] * (self.n * 4) self.build(0, 0, self.n - 1, arr) def build(self, node, start, end, arr): if start == end: self.tree[node] = arr[start] else: mid = (start + end) // 2 self.build(node * 2 + 1, start, mid, arr) self.build(node * 2 + 2, mid + 1, end, arr) self.tree[node] = max(self.tree[node * 2 + 1], self.tree[node * 2 + 2]) def push(self, node, start, end): if self.lazy_set[node] is not None: self.tree[node] = self.lazy_set[node] if start != end: self.lazy_set[node * 2 + 1] = self.lazy_set[node] self.lazy_set[node * 2 + 2] = self.lazy_set[node] self.lazy[node * 2 + 1] = 0 self.lazy[node * 2 + 2] = 0 self.lazy_set[node] = None if self.lazy[node] != 0: self.tree[node] += self.lazy[node] if start != end: if self.lazy_set[node * 2 + 1] is not None: self.lazy_set[node * 2 + 1] += self.lazy[node] else: self.lazy[node * 2 + 1] += self.lazy[node] if self.lazy_set[node * 2 + 2] is not None: self.lazy_set[node * 2 + 2] += self.lazy[node] else: self.lazy[node * 2 + 2] += self.lazy[node] self.lazy[node] = 0 def update_add(self, l, r, val, node=0, start=0, end=None): if end is None: end = self.n - 1 self.push(node, start, end) if start > end or start > r or end < l: return if start >= l and end <= r: self.lazy[node] += val self.push(node, start, end) else: mid = (start + end) // 2 self.update_add(l, r, val, node * 2 + 1, start, mid) self.update_add(l, r, val, node * 2 + 2, mid + 1, end) self.tree[node] = max(self.tree[node * 2 + 1], self.tree[node * 2 + 2]) def update_set(self, l, r, val, node=0, start=0, end=None): if end is None: end = self.n - 1 self.push(node, start, end) if start > end or start > r or end < l: return if start >= l and end <= r: self.lazy_set[node] = val self.push(node, start, end) else: mid = (start + end) // 2 self.update_set(l, r, val, node * 2 + 1, start, mid) self.update_set(l, r, val, node * 2 + 2, mid + 1, end) self.tree[node] = max(self.tree[node * 2 + 1], self.tree[node * 2 + 2]) def query_max(self, l, r, node=0, start=0, end=None): if end is None: end = self.n - 1 self.push(node, start, end) if start > end or start > r or end < l: return -float('inf') if start >= l and end <= r: return self.tree[node] mid = (start + end) // 2 left_query = self.query_max(l, r, node * 2 + 1, start, mid) right_query = self.query_max(l, r, node * 2 + 2, mid + 1, end) return max(left_query, right_query) def process_operations(n, arr, operations): seg_tree = SegmentTree(arr) results = [] for op in operations: if op[0] == 1: _, l, r, v = op seg_tree.update_add(l - 1, r - 1, v) elif op[0] == 2: _, l, r = op results.append(seg_tree.query_max(l - 1, r - 1)) elif op[0] == 3: _, l, r, v = op seg_tree.update_set(l - 1, r - 1, v) return results"},{"question":"def process_commands(commands): This function takes a list of commands and determines if all removal operations are valid based on the presence of the user in the active users' list. Parameters: commands (List[str]): List of commands in the form of \\"ADD user_name\\" or \\"REMOVE user_name\\". Returns: str: \\"VALID\\" if all removal operations are valid, otherwise \\"INVALID\\". pass def test_sample_case(): commands = [ \\"ADD alice\\", \\"ADD bob\\", \\"REMOVE alice\\", \\"REMOVE charlie\\", \\"REMOVE bob\\" ] assert process_commands(commands) == \\"INVALID\\" def test_valid_case(): commands = [ \\"ADD alice\\", \\"ADD bob\\", \\"REMOVE bob\\", \\"REMOVE alice\\", \\"ADD charlie\\", \\"REMOVE charlie\\" ] assert process_commands(commands) == \\"VALID\\" def test_invalid_case_with_empty_list(): commands = [ \\"REMOVE alice\\" ] assert process_commands(commands) == \\"INVALID\\" def test_edge_case_repeated_actions(): commands = [ \\"ADD alice\\", \\"REMOVE alice\\", \\"ADD alice\\", \\"REMOVE alice\\" ] assert process_commands(commands) == \\"VALID\\" def test_case_with_multiple_users(): commands = [ \\"ADD alice\\", \\"ADD bob\\", \\"ADD charlie\\", \\"REMOVE alice\\", \\"REMOVE bob\\", \\"REMOVE charlie\\" ] assert process_commands(commands) == \\"VALID\\" def test_case_with_invalid_remove(): commands = [ \\"ADD alice\\", \\"ADD bob\\", \\"REMOVE bob\\", \\"REMOVE charlie\\", # Invalid removal \\"REMOVE alice\\" ] assert process_commands(commands) == \\"INVALID\\"","solution":"def process_commands(commands): This function takes a list of commands and determines if all removal operations are valid based on the presence of the user in the active users' list. Parameters: commands (List[str]): List of commands in the form of \\"ADD user_name\\" or \\"REMOVE user_name\\". Returns: str: \\"VALID\\" if all removal operations are valid, otherwise \\"INVALID\\". active_users = set() for command in commands: operation, user_name = command.split() if operation == \\"ADD\\": active_users.add(user_name) elif operation == \\"REMOVE\\": if user_name in active_users: active_users.remove(user_name) else: return \\"INVALID\\" return \\"VALID\\""},{"question":"from typing import List, Tuple def can_transfer_power(n: int, m: int, p: int, lines: List[Tuple[int, int, int]], s: int, t: int) -> str: Determine if there is a path from s to t such that all power lines on the path have a capacity of at least p. Args: n (int): the number of junctions m (int): the number of power lines p (int): the minimum required capacity lines (List[Tuple[int, int, int]]): list of triples representing the power lines [(ai, bi, ci)] s (int): the source junction t (int): the target junction Returns: str: \\"YES\\" if there is a path from s to t such that all power lines on the path have a capacity of at least p, otherwise \\"NO\\" >>> can_transfer_power(6, 7, 4, [(1, 2, 5), (2, 3, 4), (3, 4, 8), (4, 5, 6), (5, 6, 3), (1, 3, 10), (3, 6, 2)], 1, 6) \\"NO\\" >>> can_transfer_power(4, 4, 2, [(1, 2, 3), (2, 3, 4), (3, 4, 1), (1, 4, 2)], 1, 4) \\"YES\\"","solution":"from collections import defaultdict, deque def can_transfer_power(n, m, p, lines, s, t): def bfs(source, target): visited = set() queue = deque([source]) while queue: node = queue.popleft() if node == target: return True for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return False adj_list = defaultdict(list) for ai, bi, ci in lines: if ci >= p: adj_list[ai].append(bi) adj_list[bi].append(ai) return \\"YES\\" if bfs(s, t) else \\"NO\\""},{"question":"from typing import List def minimize_total_time(N: int, M: List[List[int]]) -> int: Given an NxN matrix M representing the time each worker i takes to complete task j, return the minimum total time needed to complete all tasks optimally. >>> minimize_total_time(3, [ [2, 3, 4], [3, 2, 4], [5, 6, 1] ]) 5 >>> minimize_total_time(2, [ [4, 2], [3, 5] ]) 5 pass","solution":"from itertools import permutations def minimize_total_time(N, M): Given an NxN matrix M representing the time each worker i takes to complete task j, return the minimum total time needed to complete all tasks optimally. min_time = float('inf') # Generate all possible permutations of task assignments for perm in permutations(range(N)): current_time = sum(M[i][perm[i]] for i in range(N)) if current_time < min_time: min_time = current_time return min_time"},{"question":"def count_unique_substrings(s: str) -> int: Given a string \`s\`, return the number of unique substrings that can be formed from \`s\`. >>> count_unique_substrings(\\"abc\\") 6 >>> count_unique_substrings(\\"aaa\\") 3 # Your code goes here pass # Unit Tests def test_single_character(): assert count_unique_substrings('a') == 1 def test_two_different_characters(): assert count_unique_substrings('ab') == 3 # \\"a\\", \\"b\\", \\"ab\\" def test_two_same_characters(): assert count_unique_substrings('aa') == 2 # \\"a\\", \\"aa\\" def test_example_case1(): assert count_unique_substrings('abc') == 6 # \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\" def test_example_case2(): assert count_unique_substrings('aaa') == 3 # \\"a\\", \\"aa\\", \\"aaa\\" def test_all_unique_chars(): assert count_unique_substrings('abcd') == 10 # all possible substrings \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"ab\\", \\"bc\\", \\"cd\\", \\"abc\\", \\"bcd\\", \\"abcd\\" def test_repeated_pattern(): assert count_unique_substrings('abab') == 7 # \\"a\\", \\"b\\", \\"ab\\", \\"ba\\", \\"aba\\", \\"bab\\", \\"abab\\" def test_empty_string(): assert count_unique_substrings('') == 0 # no substrings","solution":"def count_unique_substrings(s): Return the number of unique substrings that can be formed from the given string \`s\`. if not s: return 0 unique_substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): unique_substrings.add(s[i:j]) return len(unique_substrings)"},{"question":"def find_missing_piece(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Finds the missing piece in each test case. Parameters: T : int : number of test cases test_cases : list of tuples : each tuple contains (N, pieces_list) Returns: list : list of missing pieces for each test case >>> find_missing_piece(3, [(5, [1, 2, 3, 5]), (3, [1, 3]), (4, [1, 2, 3])]) [4, 2, 4] >>> find_missing_piece(1, [(2, [1])]) [2] >>> find_missing_piece(1, [(3, [1, 3])]) [2]","solution":"def find_missing_piece(T, test_cases): Finds the missing piece in each test case. Parameters: T : int : number of test cases test_cases : list of tuples : each tuple contains (N, pieces_list) Returns: list : list of missing pieces for each test case missing_pieces = [] for case in test_cases: N, pieces = case total_sum = sum(range(1, N + 1)) current_sum = sum(pieces) missing_pieces.append(total_sum - current_sum) return missing_pieces"},{"question":"def count_requests_above_threshold(requests, threshold): Returns the number of requests with priority values greater than the given threshold. Args: requests (list of int): The priority values of the customer requests. threshold (int): The priority threshold. Returns: int: The number of requests with priority values greater than the threshold. Examples: >>> count_requests_above_threshold([12, 25, 8, 30, 10], 15) 2 >>> count_requests_above_threshold([50, 60, 70, 80], 65) 2 >>> count_requests_above_threshold([20, 25, 25], 25) 0 >>> count_requests_above_threshold([15, 19, 22, 25, 18, 24], 20) 3","solution":"def count_requests_above_threshold(requests, threshold): Returns the number of requests with priority values greater than the given threshold. Args: requests (list of int): The priority values of the customer requests. threshold (int): The priority threshold. Returns: int: The number of requests with priority values greater than the threshold. count = 0 for priority in requests: if priority > threshold: count += 1 return count"},{"question":"def most_frequent_char(s: str) -> str: Given a string \`s\` of lowercase English letters, find the character that appears the most frequently. If there are multiple characters with the same maximum frequency, return the lexicographically smallest one among them. >>> most_frequent_char(\\"aabbbcc\\") == \\"b\\" >>> most_frequent_char(\\"abcabcabc\\") == \\"a\\" >>> most_frequent_char(\\"zzxyxxy\\") == \\"x\\"","solution":"def most_frequent_char(s: str) -> str: Returns the character that appears most frequently in the string. If there are multiple characters with the same maximum frequency, the lexicographically smallest one is returned. from collections import Counter # Count frequency of each character char_count = Counter(s) # Find maximum frequency max_frequency = max(char_count.values()) # Find all characters with the max frequency and return the lexicographically smallest one max_chars = [char for char, count in char_count.items() if count == max_frequency] return min(max_chars)"},{"question":"def max_employees_with_gifts(e, p, budgets, prices): Returns the maximum number of different employees that can receive gifts such that the price of each gift does not exceed the employee's budget. >>> max_employees_with_gifts(3, 3, [100, 200, 300], [150, 200, 250]) 2 >>> max_employees_with_gifts(4, 3, [100, 200, 300, 400], [350, 100, 200]) 3 >>> max_employees_with_gifts(5, 5, [200, 300, 400, 500, 600], [100, 100, 100, 100, 100]) 5 >>> max_employees_with_gifts(2, 2, [100, 200], [300, 400]) 0 >>> max_employees_with_gifts(4, 4, [200, 300, 400, 500], [100, 200, 300, 400]) 4 >>> max_employees_with_gifts(1, 1, [100], [100]) 1 >>> max_employees_with_gifts(1, 3, [100], [50, 60, 70]) 1 >>> max_employees_with_gifts(3, 1, [300, 200, 100], [50]) 1 >>> max_employees_with_gifts(4, 4, [500, 200, 400, 300], [300, 400, 200, 100]) 4","solution":"def max_employees_with_gifts(e, p, budgets, prices): Returns the maximum number of different employees that can receive gifts such that the price of each gift does not exceed the employee's budget. budgets.sort() prices.sort() # Initialize pointers for both budgets and prices i = j = count = 0 while i < e and j < p: if prices[j] <= budgets[i]: count += 1 j += 1 # Move the budget pointer regardless of match i += 1 return count"},{"question":"def longest_contiguous_optimal_subsequence(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Finds the length of the longest contiguous subsequence of trees with optimal sunlight exposure level (1). Parameters: T (int): Number of test cases. test_cases (list of tuples): List of test cases where each tuple contains (N (int), A (list of int)). Returns: list of int: List containing the length of the longest contiguous subsequence for each test case. >>> longest_contiguous_optimal_subsequence(2, [(5, [0, 1, 1, 0, 1]), (7, [1, 1, 0, 2, 1, 1, 1])]) [2, 3] >>> longest_contiguous_optimal_subsequence(1, [(5, [1, 1, 1, 1, 1])]) [5] >>> longest_contiguous_optimal_subsequence(1, [(5, [0, 0, 0, 0, 0])]) [0] >>> longest_contiguous_optimal_subsequence(1, [(8, [1, 0, 1, 1, 0, 1, 1, 1])]) [3] >>> longest_contiguous_optimal_subsequence(2, [(1, [1]), (1, [0])]) [1, 0]","solution":"def longest_contiguous_optimal_subsequence(T, test_cases): Finds the length of the longest contiguous subsequence of trees with optimal sunlight exposure level (1). Parameters: T (int): Number of test cases. test_cases (list of tuples): List of test cases where each tuple contains (N (int), A (list of int)). Returns: list of int: List containing the length of the longest contiguous subsequence for each test case. results = [] optimal_level = 1 for N, A in test_cases: max_length = 0 current_length = 0 for sunlight in A: if sunlight == optimal_level: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 results.append(max_length) return results"},{"question":"def cumulative_sums(profits): Returns a list of cumulative sums from a list of daily profits. :param profits: List of integers representing daily profits :return: List containing the cumulative sums >>> cumulative_sums([10, 20, 30]) [10, 30, 60] >>> cumulative_sums([-5, 10, -15, 20]) [-5, 5, -10, 10] >>> cumulative_sums([1, 1, 1, 1, 1]) [1, 2, 3, 4, 5] def format_output(cumulative_sums): Formats the output of cumulative sums as space-separated string. :param cumulative_sums: List of cumulative sums :return: A string with space-separated cumulative sums >>> format_output([10, 30, 60]) \\"10 30 60\\" >>> format_output([-5, 5, -10, 10]) \\"-5 5 -10 10\\" >>> format_output([1, 2, 3, 4, 5]) \\"1 2 3 4 5\\"","solution":"def cumulative_sums(profits): Returns a list of cumulative sums from a list of daily profits. :param profits: List of integers representing daily profits :return: List containing the cumulative sums cumulative_sum = [] current_sum = 0 for profit in profits: current_sum += profit cumulative_sum.append(current_sum) return cumulative_sum # Function to format the output space-separated as required def format_output(cumulative_sums): return ' '.join(map(str, cumulative_sums)) # Sample usage input_profits = [10, 20, 30] cumulative_sum_result = cumulative_sums(input_profits) print(format_output(cumulative_sum_result)) # Output: \\"10 30 60\\""},{"question":"def numDistinctPaths(J, K, grid): Determine the number of distinct paths the robot can take from the start to the bottom-right cell. >>> numDistinctPaths(3, 3, [['.', '#', '#'], ['.', '#', '.'], ['.', '.', '.']]) 1 >>> numDistinctPaths(3, 3, [['.', '.', '#'], ['#', '#', '#'], ['.', '#', '.']]) 0 >>> numDistinctPaths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2","solution":"def numDistinctPaths(J, K, grid): Determine the number of distinct paths the robot can take from the start to the bottom-right cell. # Base case check if the start or end is blocked if grid[0][0] == '#' or grid[J-1][K-1] == '#': return 0 # Create a 2D list for storing path counts dp = [[0 for _ in range(K)] for _ in range(J)] # Starting position dp[0][0] = 1 # Fill the dp array for i in range(J): for j in range(K): if grid[i][j] == '.': if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[J-1][K-1]"},{"question":"def max_fish_value(C, M, fish_data): Calculate the maximum value of fish that can be carried within the weight limit C. Parameters: C (int): Maximum weight capacity of the fisherman's basket. M (int): Number of types of fish. fish_data (list of tuples): Each tuple contains (weight, value) for each type of fish. Returns: int: Maximum value of fish that can be carried. >>> max_fish_value(10, 3, [(2, 3), (3, 4), (4, 5)]) == 15 >>> max_fish_value(50, 3, [(10, 10), (20, 20), (30, 30)]) == 50 >>> max_fish_value(10, 1, [(5, 10)]) == 20 >>> max_fish_value(10, 3, [(6, 6), (2, 2), (1, 1)]) == 10 >>> max_fish_value(0, 3, [(2, 3), (3, 4), (4, 5)]) == 0","solution":"def max_fish_value(C, M, fish_data): Returns the maximum value of fish that can be carried within the weight limit C. Parameters: C (int): Maximum weight capacity of the fisherman's basket. M (int): Number of types of fish. fish_data (list of tuples): Each tuple contains (weight, value) for each type of fish. Returns: int: Maximum value of fish that can be carried. # DP array to store the maximum value for each weight up to C dp = [0] * (C + 1) # Iterate over each fish for weight, value in fish_data: for current_weight in range(weight, C + 1): dp[current_weight] = max(dp[current_weight], dp[current_weight - weight] + value) return dp[C]"},{"question":"def can_defeat_dragons(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Determine if it's possible for knights to defeat all dragons. Given the number of test cases, and for each test case, the number of knights and dragons (both are of equal number), their respective strengths and required strengths, determines if it's possible for all dragons to be defeated. Returns 'YES' if all dragons can be defeated, otherwise 'NO'. Args: t: int - the number of test cases. test_cases: List of tuples, where each tuple contains: - an integer n (the number of knights and dragons), - a list of integers representing the strengths of the knights, - a list of integers representing the required strengths of the dragons. Returns: List of strings containing 'YES' or 'NO' for each test case. Example: >>> can_defeat_dragons(2, [(3, [4, 5, 8], [1, 3, 7]), (4, [2, 3, 5, 6], [7, 6, 5, 4])]) ['YES', 'NO'] >>> can_defeat_dragons(1, [(3, [3, 6, 9], [4, 5, 10])]) ['NO'] def process_input(input_str: str) -> Tuple[int, List[Tuple[int, List[int], List[int]]]]: Process the input string to extract the number of test cases and their details. Args: input_str: str - the input string containing number of test cases and details of each test case. Returns: A tuple containing: - an integer t (the number of test cases), - a list of tuples, where each tuple contains: - an integer n (the number of knights and dragons), - a list of integers representing the strengths of the knights, - a list of integers representing the required strengths of the dragons. Example: >>> process_input(\\"2n3n4 5 8n1 3 7n4n2 3 5 6n7 6 5 4n\\") (2, [(3, [4, 5, 8], [1, 3, 7]), (4, [2, 3, 5, 6], [7, 6, 5, 4])]) def main(input_str: str) -> str: Main function to determine if knights can defeat all dragons for given test cases. Args: input_str: str - the input string containing number of test cases and details of each test case. Returns: str - Output string containing 'YES' or 'NO' for each test case, separated by newlines. Example: >>> main(\\"2n3n4 5 8n1 3 7n4n2 3 5 6n7 6 5 4n\\") 'YESnNO'","solution":"def can_defeat_dragons(t, test_cases): results = [] for test_case in test_cases: n, knights_strengths, dragons_strengths = test_case knights_strengths.sort(reverse=True) dragons_strengths.sort(reverse=True) possible = True for k_strength, d_strength in zip(knights_strengths, dragons_strengths): if k_strength < d_strength: possible = False break if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def process_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) knights_strengths = list(map(int, lines[index + 1].split())) dragons_strengths = list(map(int, lines[index + 2].split())) test_cases.append((n, knights_strengths, dragons_strengths)) index += 3 return t, test_cases def main(input_str): t, test_cases = process_input(input_str) results = can_defeat_dragons(t, test_cases) return \\"n\\".join(results)"},{"question":"def unique_paths(grid) -> int: Calculates the number of unique paths from the top-left to the bottom-right corner of a grid, where each cell can be either \`1\` (walkable) or \`0\` (blocked). Args: grid (List[List[int]]): The grid represented as a list of lists of integers. Returns: int: The number of unique paths. Examples: >>> unique_paths([ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]) 2 >>> unique_paths([ ... [1, 1, 1], ... [0, 0, 1], ... [1, 1, 1] ... ]) 1 >>> unique_paths([ ... [1] ... ]) 1 >>> unique_paths([ ... [0, 1], ... [1, 1] ... ]) 0 >>> unique_paths([ ... [1, 1], ... [1, 0] ... ]) 0 >>> unique_paths([ ... [1, 1, 1, 1], ... [1, 0, 1, 1], ... [1, 1, 1, 0], ... [1, 1, 1, 1] ... ]) 4","solution":"def unique_paths(grid): n = len(grid) m = len(grid[0]) # If the starting or ending cell is blocked, return 0 paths if grid[0][0] == 0 or grid[n-1][m-1] == 0: return 0 dp = [[0] * m for _ in range(n)] # Initialize the starting position dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def longest_palindromic_substring_frequency(s: str) -> int: Determine the frequency of the longest palindromic substring in the given string \`s\`. >>> longest_palindromic_substring_frequency(\\"abcbaxyzcbba\\") 3 >>> longest_palindromic_substring_frequency(\\"forgeeksskeegfor\\") 2 >>> longest_palindromic_substring_frequency(\\"a\\") 1 >>> longest_palindromic_substring_frequency(\\"racecar\\") 1 >>> longest_palindromic_substring_frequency(\\"abacdfgdcaba\\") 2 >>> longest_palindromic_substring_frequency(\\"abcde\\") 1 >>> longest_palindromic_substring_frequency(\\"aaabaaa\\") 1","solution":"def longest_palindromic_substring_frequency(s): def longest_palindromic_substring(s): n = len(s) if n == 0: return \\"\\" # Table to store length of all palindromic substrings. dp = [[0] * n for _ in range(n)] start, max_length = 0, 1 # All substrings of length 1 are palindromic for i in range(n): dp[i][i] = True # Check for substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True start = i max_length = length return s[start:start + max_length] # Find the longest palindromic substring longest_palindrome = longest_palindromic_substring(s) # Count the frequency of the longest palindromic substring in the given string return s.count(longest_palindrome)"},{"question":"def is_path_possible(M: List[List[int]], R: int, C: int) -> str: Determines if there exists a path from the top-left to the bottom-right cell of the matrix M following the specified rules. Returns \\"Possible\\" if a path exists, otherwise returns \\"Impossible\\". >>> is_path_possible([[4, 3, 2], [3, 2, 1], [2, 1, 0]], 3, 3) 'Possible' >>> is_path_possible([[1, 2, 3], [2, 3, 4], [3, 4, 5]], 3, 3) 'Impossible' >>> is_path_possible([[0]], 1, 1) 'Possible' >>> is_path_possible([[1, 0], [0, 0]], 2, 2) 'Possible' >>> is_path_possible([[0, 1], [1, 0]], 2, 2) 'Impossible'","solution":"def is_path_possible(M, R, C): Determines if there exists a path from the top-left to the bottom-right cell of the matrix M following the specified rules. Returns \\"Possible\\" if a path exists, otherwise returns \\"Impossible\\". def dfs(x, y): Depth-First Search to traverse the matrix if x == R-1 and y == C-1: return True # Mark the current cell as visited visited[x][y] = True # Try moving right if y + 1 < C and not visited[x][y + 1] and M[x][y + 1] <= M[x][y]: if dfs(x, y + 1): return True # Try moving down if x + 1 < R and not visited[x + 1][y] and M[x + 1][y] <= M[x][y]: if dfs(x + 1, y): return True return False # Initialize visited matrix visited = [[False] * C for _ in range(R)] # Start DFS from the top-left cell if dfs(0, 0): return \\"Possible\\" else: return \\"Impossible\\""},{"question":"def AddPlaylist(name): This function adds a new playlist with the given name to the collection. >>> mc = MusicCollection() >>> mc.AddPlaylist(\\"Chill Vibes\\") >>> mc.GetPlaylist(\\"Chill Vibes\\") [] def AddSong(playlistName, songName): This function adds a new song to the specified playlist. If the playlist does not exist, it creates the playlist first. >>> mc = MusicCollection() >>> mc.AddSong(\\"Rock Classics\\", \\"Bohemian Rhapsody\\") >>> mc.GetPlaylist(\\"Rock Classics\\") [\\"Bohemian Rhapsody\\"] def RemovePlaylist(name): This function removes the playlist with the given name from the collection. If the playlist does not exist, it does nothing. >>> mc = MusicCollection() >>> mc.AddPlaylist(\\"Workout\\") >>> mc.RemovePlaylist(\\"Workout\\") >>> mc.GetPlaylist(\\"Workout\\") [] def RemoveSong(playlistName, songName): This function removes the song from the specified playlist. If the playlist or the song does not exist, it does nothing. >>> mc = MusicCollection() >>> mc.AddSong(\\"Rock Classics\\", \\"Hotel California\\") >>> mc.RemoveSong(\\"Rock Classics\\", \\"Hotel California\\") >>> mc.GetPlaylist(\\"Rock Classics\\") [] def GetPlaylist(playlistName): This function returns a list of all the songs in the specified playlist. If the playlist does not exist, it returns an empty list. >>> mc = MusicCollection() >>> mc.GetPlaylist(\\"Nonexistent Playlist\\") [] class MusicCollection: def __init__(self): Initialize the music collection. def AddPlaylist(self, name): Add a new playlist with the given name to the collection. def AddSong(self, playlistName, songName): Add a new song to the specified playlist. If the playlist does not exist, it creates the playlist first. def RemovePlaylist(self, name): Remove the playlist with the given name from the collection. If the playlist does not exist, it does nothing. def RemoveSong(self, playlistName, songName): Remove the song from the specified playlist. If the playlist or the song does not exist, it does nothing. def GetPlaylist(self, playlistName): Return a list of all the songs in the specified playlist. If the playlist does not exist, it returns an empty list. def test_add_playlist(): mc = MusicCollection() mc.AddPlaylist(\\"Chill Vibes\\") assert mc.GetPlaylist(\\"Chill Vibes\\") == [] def test_add_song(): mc = MusicCollection() mc.AddSong(\\"Rock Classics\\", \\"Bohemian Rhapsody\\") assert mc.GetPlaylist(\\"Rock Classics\\") == [\\"Bohemian Rhapsody\\"] def test_add_song_to_nonexistent_playlist(): mc = MusicCollection() mc.AddSong(\\"Favorites\\", \\"Imagine\\") assert mc.GetPlaylist(\\"Favorites\\") == [\\"Imagine\\"] def test_remove_playlist(): mc = MusicCollection() mc.AddPlaylist(\\"Workout\\") mc.RemovePlaylist(\\"Workout\\") assert mc.GetPlaylist(\\"Workout\\") == [] def test_remove_song(): mc = MusicCollection() mc.AddSong(\\"Rock Classics\\", \\"Hotel California\\") mc.RemoveSong(\\"Rock Classics\\", \\"Hotel California\\") assert mc.GetPlaylist(\\"Rock Classics\\") == [] def test_remove_song_nonexistent(): mc = MusicCollection() mc.RemoveSong(\\"Nonexistent Playlist\\", \\"Nonexistent Song\\") assert mc.GetPlaylist(\\"Nonexistent Playlist\\") == [] def test_get_playlist_nonexistent(): mc = MusicCollection() assert mc.GetPlaylist(\\"Nonexistent Playlist\\") == [] def test_add_multiple_songs(): mc = MusicCollection() mc.AddSong(\\"Hits\\", \\"Song 1\\") mc.AddSong(\\"Hits\\", \\"Song 2\\") mc.AddSong(\\"Hits\\", \\"Song 3\\") assert set(mc.GetPlaylist(\\"Hits\\")) == {\\"Song 1\\", \\"Song 2\\", \\"Song 3\\"}","solution":"class MusicCollection: def __init__(self): self.playlists = {} def AddPlaylist(self, name): if name not in self.playlists: self.playlists[name] = set() def AddSong(self, playlistName, songName): if playlistName not in self.playlists: self.AddPlaylist(playlistName) self.playlists[playlistName].add(songName) def RemovePlaylist(self, name): if name in self.playlists: del self.playlists[name] def RemoveSong(self, playlistName, songName): if playlistName in self.playlists and songName in self.playlists[playlistName]: self.playlists[playlistName].remove(songName) def GetPlaylist(self, playlistName): if playlistName in self.playlists: return list(self.playlists[playlistName]) return []"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False # Implement the function here def sumOfPrimes(numbers: List[int]) -> int: Returns the sum of all prime numbers in the list. >>> sumOfPrimes([2, 3, 4, 5, 10]) 10 >>> sumOfPrimes([10, 15, 20]) 0 >>> sumOfPrimes([]) 0 >>> sumOfPrimes([7]) 7 >>> sumOfPrimes([1000000, 999983, 1000001]) 999983 >>> sumOfPrimes([2, 3, 5, 7, 11]) 28 >>> sumOfPrimes([0, 1, 2, 17, 19, 23, 24, 25, 79]) 140 # Implement the function here","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sumOfPrimes(numbers): Returns the sum of all prime numbers in the list. prime_sum = 0 for number in numbers: if is_prime(number): prime_sum += number return prime_sum"},{"question":"def countBattleships(grid: List[List[str]]) -> int: Count the number of battleships on a given grid. Args: grid (List[List[str]]): A 2D list of strings representing the game board. Returns: int: The number of battleships on the board. Example: >>> grid = [ ... ['.', 'B', 'B', '.'], ... ['.', '.', '.', 'B'], ... ['B', '.', '.', 'B'], ... ['.', '.', '.', '.'] ... ] >>> countBattleships(grid) 3","solution":"def countBattleships(grid): Count the number of battleships on a given grid. Args: grid (List[List[str]]): A 2D list of strings representing the game board. Returns: int: The number of battleships on the board. if not grid: return 0 rows = len(grid) cols = len(grid[0]) count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 'B': if i > 0 and grid[i-1][j] == 'B': continue if j > 0 and grid[i][j-1] == 'B': continue count += 1 return count"},{"question":"def maxArea(height): Calculate the maximum area of water that can be contained using the given heights of columns. >>> maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> maxArea([1, 2, 4, 3]) 4","solution":"def maxArea(height): Calculate the maximum area of water that can be contained using the given heights of columns. :param height: List of integers representing the heights of columns. :return: Maximum area of water that can be contained. left = 0 # Pointer to the leftmost element right = len(height) - 1 # Pointer to the rightmost element max_area = 0 # Variable to store the maximum area while left < right: # Calculate the area with the current pair of columns width = right - left min_height = min(height[left], height[right]) current_area = width * min_height # Update the maximum area if the current area is larger max_area = max(max_area, current_area) # Move the pointer pointing to the shorter column if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"def word_with_most_vowels(sentence: str) -> str: Takes a string sentence and returns the word with the most vowels. In case of a tie, returns the first such word. >>> word_with_most_vowels(\\"Hello\\") == \\"Hello\\" >>> word_with_most_vowels(\\"This is a test sentence\\") == \\"sentence\\" >>> word_with_most_vowels(\\"pear bear care\\") == \\"pear\\" >>> word_with_most_vowels(\\"Education Is Important\\") == \\"Education\\" >>> word_with_most_vowels(\\"AeIoU aeio AEIOU\\") == \\"AeIoU\\" >>> word_with_most_vowels(\\"bit bot bite boat\\") == \\"bite\\"","solution":"def word_with_most_vowels(sentence): Takes a string sentence and returns the word with the most vowels. In case of a tie, returns the first such word. vowels = set('aeiouAEIOU') def count_vowels(word): return sum(1 for char in word if char in vowels) words = sentence.split() max_vowel_word = max(words, key=count_vowels) return max_vowel_word"},{"question":"from typing import List, Tuple def minimal_enclosing_rectangle(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Returns the coordinates of the smallest bounding rectangle that can enclose all given points. Parameters: points (List[Tuple[int, int]]): A list of tuples representing the coordinates of points. Returns: List[Tuple[int, int]]: A list of four tuples representing the four corners of the bounding rectangle. Example: >>> minimal_enclosing_rectangle([(1, 3), (4, 4), (2, 2), (3, 5)]) [(1, 2), (4, 2), (4, 5), (1, 5)] >>> minimal_enclosing_rectangle([(0, 0)]) [(0, 0), (0, 0), (0, 0), (0, 0)]","solution":"from typing import List, Tuple def minimal_enclosing_rectangle(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Returns the coordinates of the smallest bounding rectangle that can enclose all given points. Parameters: points (List[Tuple[int, int]]): A list of tuples representing the coordinates of points. Returns: List[Tuple[int, int]]: A list of four tuples representing the four corners of the bounding rectangle. min_x = min(point[0] for point in points) max_x = max(point[0] for point in points) min_y = min(point[1] for point in points) max_y = max(point[1] for point in points) bottom_left = (min_x, min_y) bottom_right = (max_x, min_y) top_right = (max_x, max_y) top_left = (min_x, max_y) return [bottom_left, bottom_right, top_right, top_left]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_paths_equal_to_k(root: TreeNode, k: int) -> int: You are given a tree consisting of n nodes. Each node has an integer value assigned to it. Implement a function that takes the tree and an integer k as input and returns the number of paths in the tree where the sum of the values of the nodes on the path is equal to k. Args: root (TreeNode): A TreeNode object representing the root of the tree. k (int): An integer representing the target sum. Returns: int: An integer representing the number of paths where the sum of the values is equal to k. Examples: >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(-3) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(2) >>> root.right.right = TreeNode(11) >>> root.left.left.left = TreeNode(3) >>> root.left.left.right = TreeNode(-2) >>> root.left.right.right = TreeNode(1) >>> k = 8 >>> count_paths_equal_to_k(root, k) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(-2) >>> root.right = TreeNode(-3) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> root.left.left.left = TreeNode(-1) >>> root.right.left = TreeNode(-2) >>> k = -1 >>> count_paths_equal_to_k(root, k) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_paths_equal_to_k(root: TreeNode, k: int) -> int: from collections import defaultdict def dfs(node, current_sum): if not node: return 0 current_sum += node.val path_count = prefix_sum[current_sum - k] prefix_sum[current_sum] += 1 path_count += dfs(node.left, current_sum) path_count += dfs(node.right, current_sum) prefix_sum[current_sum] -= 1 return path_count prefix_sum = defaultdict(int) prefix_sum[0] = 1 return dfs(root, 0)"},{"question":"def determine_winner(X, Y): Determines the winner of the game based on coordinates (X, Y). Parameters: X (int): X coordinate Y (int): Y coordinate Returns: str: \\"Alice\\" if Alice wins, otherwise \\"Bob\\" >>> determine_winner(1, 1) 'Bob' >>> determine_winner(2, 3) 'Alice' >>> determine_winner(0, 0) 'Bob' >>> determine_winner(4, 4) 'Bob' >>> determine_winner(7, 6) 'Alice'","solution":"def determine_winner(X, Y): Determines the winner of the game based on coordinates (X, Y). Parameters: X (int): X coordinate Y (int): Y coordinate Returns: str: \\"Alice\\" if Alice wins, otherwise \\"Bob\\" if (X + Y) % 2 == 0: return \\"Bob\\" else: return \\"Alice\\""},{"question":"def kth_least_flavorful_cheese(n: int, q: int, flavor_indices: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Returns a list of results for each query, finding the k-th least flavorful cheese in the given range. >>> n = 7 >>> q = 3 >>> flavor_indices = [8, 4, 7, 2, 5, 9, 3] >>> queries = [(1, 4, 2), (2, 7, 3), (1, 7, 4)] >>> kth_least_flavorful_cheese(n, q, flavor_indices, queries) [4, 4, 5]","solution":"def kth_least_flavorful_cheese(n, q, flavor_indices, queries): Returns a list of results for each query, finding the k-th least flavorful cheese in the given range. results = [] for l, r, k in queries: subrange = flavor_indices[l-1:r] subrange.sort() results.append(subrange[k-1]) return results"},{"question":"from typing import List, Tuple def max_treasure(t: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Determine the maximum amount of treasure the adventurer can collect for each dungeon configuration. Parameters: t (int): The number of test cases test_cases (List[Tuple[int, List[List[int]]]]): A list of tuples where each tuple contains the grid size (N) and the N x N grid of treasure values Returns: List[int]: A list of integers where each integer is the maximum amount of treasure collectible for each test case Example: >>> t = 2 >>> test_cases = [ ... (3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]), ... (2, [[1, 2], [3, 4]]) ... ] >>> max_treasure(t, test_cases) [12, 8]","solution":"def max_treasure(t, test_cases): def max_treasure_single_case(n, grid): dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) return dp[n-1][n-1] results = [] for case in test_cases: n = case[0] grid = case[1:] results.append(max_treasure_single_case(n, grid)) return results # Example usage # t = 2 # test_cases = [ # [3, [1, 3, 1], [1, 5, 1], [4, 2, 1]], # [2, [1, 2], [3, 4]] # ] # print(max_treasure(t, test_cases)) # Output should be: [12, 8]"},{"question":"from typing import List def most_frequent_die_face(n: int, rolls: List[int]) -> int: Returns the die face that appears the most frequently. If there's a tie, returns the smallest one. >>> most_frequent_die_face(8, [1, 3, 4, 3, 5, 6, 6, 3]) 3 >>> most_frequent_die_face(5, [4, 4, 4, 5, 5]) 4 >>> most_frequent_die_face(6, [1, 2, 2, 3, 3, 1]) 1 # Unit tests def test_single_roll(): assert most_frequent_die_face(1, [4]) == 4 def test_all_faces_same_frequency(): assert most_frequent_die_face(6, [1, 2, 3, 4, 5, 6]) == 1 def test_multiple_rolls_with_clear_winner(): assert most_frequent_die_face(8, [1, 3, 4, 3, 5, 6, 6, 3]) == 3 def test_multiple_rolls_with_tie(): assert most_frequent_die_face(5, [4, 4, 4, 5, 5]) == 4 def test_multiple_ties(): assert most_frequent_die_face(6, [1, 2, 2, 3, 3, 1]) == 1 def test_alternating_rolls(): assert most_frequent_die_face(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) == 1 def test_high_number_of_rolls(): rolls = [6] * 50000 + [5] * 50000 assert most_frequent_die_face(100000, rolls) == 5","solution":"def most_frequent_die_face(n, rolls): Returns the die face that appears the most frequently. If there's a tie, returns the smallest one. from collections import Counter # Count the frequency of each die face counter = Counter(rolls) # Find the die face with the maximum frequency # In case of tie, min selects the smallest die face most_frequent = min((face for face in counter), key=lambda face: (-counter[face], face)) return most_frequent"},{"question":"def can_place_pieces(t: int, test_cases: list) -> list: Determine if it is possible to place all a rooks and b knights on the grid without any attacking each other. Args: t (int): The number of test cases. test_cases (list): A list of tuples, each representing a test case with four integers n, m, a, and b. Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_place_pieces(4, [(3, 3, 3, 3), (4, 4, 2, 8), (5, 5, 5, 2), (2, 2, 3, 2)]) ['YES', 'YES', 'YES', 'NO']","solution":"def can_place_pieces(t, test_cases): results = [] for test_case in test_cases: n, m, a, b = test_case if a > n or a > m: results.append(\\"NO\\") elif a + b > n * m: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def reverse_sentence(sentence: str) -> str: Reverses the order of words in a given sentence. Args: sentence (str): A sentence to reverse. Returns: str: The sentence with the order of words reversed. Examples: >>> reverse_sentence(\\"hello world\\") \\"world hello\\" >>> reverse_sentence(\\"Programming is fun\\") \\"fun is Programming\\" >>> reverse_sentence(\\"Goodbye everyone\\") \\"everyone Goodbye\\" >>> reverse_sentence(\\"Hello\\") \\"Hello\\" >>> reverse_sentence(\\"This is a test\\") \\"test a is This\\" >>> reverse_sentence(\\"Hello, world!\\") \\"world! Hello,\\" >>> reverse_sentence(\\"Space between words\\") \\"words between Space\\"","solution":"def reverse_sentence(sentence): Reverses the order of words in a given sentence. Args: sentence (str): A sentence to reverse. Returns: str: The sentence with the order of words reversed. # Split the sentence into words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a single string reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def process_operations(num_participants: int, num_operations: int, operations: List[str]) -> List[int]: Process score updates and reset operations for a coding competition. The scoreboard starts with all scores set to zero. This function processes a number of operations that either update a participant's score or reset it to zero, and returns the final scores for each participant. Args: num_participants (int): The number of participants. num_operations (int): The number of operations to process. operations (List[str]): A list of operations in the format \\"1 X S\\" or \\"2 X\\". Returns: List[int]: A list containing the final scores of each participant. Examples: >>> process_operations(3, 5, [\\"1 1 10\\", \\"1 2 20\\", \\"2 1\\", \\"1 3 30\\", \\"1 1 40\\"]) [40, 20, 30] >>> process_operations(2, 3, [\\"1 1 5\\", \\"1 1 5\\", \\"2 1\\"]) [0, 0] >>> process_operations(4, 4, [\\"1 1 10\\", \\"1 2 20\\", \\"1 3 30\\", \\"1 4 40\\"]) [10, 20, 30, 40]","solution":"def process_operations(num_participants, num_operations, operations): scores = [0] * num_participants for operation in operations: op = operation.split() if op[0] == \\"1\\": participant = int(op[1]) - 1 score_add = int(op[2]) scores[participant] += score_add elif op[0] == \\"2\\": participant = int(op[1]) - 1 scores[participant] = 0 return scores"},{"question":"def sum_of_digits(numbers): Given a list of numbers, returns the sum of the digits of each number. :param numbers: List of integers. :return: Integer representing the sum of digits of all numbers in the list. >>> sum_of_digits([123, 45, 67]) == 28 >>> sum_of_digits([1, 2, 3, 4]) == 10 >>> sum_of_digits([5]) == 5 >>> sum_of_digits([999999, 123456]) == 54 + 21 >>> sum_of_digits([123, 456, 789, 1010]) == 6 + 15 + 24 + 2","solution":"def sum_of_digits(numbers): Given a list of numbers, returns the sum of the digits of each number. :param numbers: List of integers. :return: Integer representing the sum of digits of all numbers in the list. total_sum = 0 for number in numbers: total_sum += sum(int(digit) for digit in str(number)) return total_sum"},{"question":"def count_unique_substrings(k: int, s: str) -> int: Returns the number of unique substrings of length k in the string s. Parameters: k (int): The length of the desired substrings. s (str): The input string. Returns: int: The number of unique substrings of length k. Examples: >>> count_unique_substrings(3, \\"abcabc\\") 3 >>> count_unique_substrings(2, \\"aabaab\\") 3 >>> count_unique_substrings(6, \\"abcdef\\") 1 >>> count_unique_substrings(7, \\"abcdef\\") 0 >>> count_unique_substrings(1, \\"aaaa\\") 1 >>> count_unique_substrings(1, \\"abcd\\") 4 >>> count_unique_substrings(2, \\"abcd\\") 3 >>> count_unique_substrings(3, \\"abcd\\") 2 >>> count_unique_substrings(500, \\"a\\"*1000) 1 >>> count_unique_substrings(6, \\"aabbcc\\") 1","solution":"def count_unique_substrings(k, s): Returns the number of unique substrings of length k in the string s. Parameters: k (int): The length of the desired substrings. s (str): The input string. Returns: int: The number of unique substrings of length k. if k > len(s): return 0 unique_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"def max_unique_elevation_changes(n, heights): Determine the maximum number of unique elevation changes Daniel can experience during his hike. >>> max_unique_elevation_changes(5, [1, 3, 1, 2, 5]) 4 >>> max_unique_elevation_changes(4, [4, 4, 4, 4]) 0 >>> max_unique_elevation_changes(7, [1, 2, 3, 4, 3, 2, 1]) 6","solution":"def max_unique_elevation_changes(n, heights): if n <= 1: return 0 unique_changes = set() for i in range(1, n): if heights[i] != heights[i-1]: change = (heights[i-1], heights[i]) unique_changes.add(change) return len(unique_changes) # Example usages print(max_unique_elevation_changes(5, [1, 3, 1, 2, 5])) # Output: 4 print(max_unique_elevation_changes(4, [4, 4, 4, 4])) # Output: 0 print(max_unique_elevation_changes(7, [1, 2, 3, 4, 3, 2, 1])) # Output: 6"},{"question":"def cumulativeRainfall(rainfall: List[int], queries: List[List[int]]) -> List[int]: Calculate cumulative rainfall for given range of days. :param rainfall: A list of integers representing daily rainfall amounts. :param queries: A list of lists where each sub-list contains two integers representing the start and end day. :return: A list of integers where each element corresponds to the total rainfall for a queried range. >>> cumulativeRainfall([2, 4, 0, 3, 7, 1, 8, 9, 5, 6], [[3, 7], [1, 5], [2, 10]]) [19, 16, 43] >>> cumulativeRainfall([0, 5, 10, 5, 0, 0, 20, 0, 5, 5], [[1, 10], [4, 7], [3, 6]]) [50, 25, 15] >>> cumulativeRainfall([100, 200, 300, 400, 500], [[1, 3], [2, 4], [1, 5]]) [600, 900, 1500] >>> cumulativeRainfall([0, 0, 0, 0, 0], [[1, 5], [2, 4]]) [0, 0] >>> cumulativeRainfall([1, 2, 3, 4, 5], [[1, 1], [1, 3], [2, 2], [3, 5]]) [1, 6, 2, 12]","solution":"def cumulativeRainfall(rainfall, queries): Calculate cumulative rainfall for given range of days. :param rainfall: A list of integers representing daily rainfall amounts. :param queries: A list of lists where each sub-list contains two integers representing the start and end day. :return: A list of integers where each element corresponds to the total rainfall for a queried range. # Compute prefix sums n = len(rainfall) prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + rainfall[i - 1] # Process each query and find cumulative rainfall result = [] for start, end in queries: total_rainfall = prefix_sum[end] - prefix_sum[start - 1] result.append(total_rainfall) return result"},{"question":"def max_depth(tree): Given a binary tree, find the maximum depth of the binary tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. The input tree is represented as a tuple (value, left, right), where value is the node's value, left is the left child, and right is the right child. Examples: >>> max_depth((1, (2, (4, None, None), None), (3, (5, None, None), (6, None, None)))) 3 >>> max_depth((1, None, None)) 1 >>> max_depth((1, (2, (3, (4, None, None), None), None), None)) 4 >>> max_depth((1, (2, None, None), (3, None, None))) 2","solution":"def max_depth(tree): Returns the maximum depth of the binary tree. The input tree is represented as a tuple (value, left, right), where value is the node's value, left is the left child, and right is the right child. # If the tree is None, the depth is 0 if tree is None: return 0 # Extract the left and right subtrees _, left, right = tree # Recursively find the depth of the left and right subtrees left_depth = max_depth(left) right_depth = max_depth(right) # The depth of the tree is the greater of the two subtrees' depths, plus one for the current node return max(left_depth, right_depth) + 1"},{"question":"def is_repeating_sequence(dna_sequence: str) -> str: Determines if the given DNA sequence can be made by repeating a substring. :param dna_sequence: str, DNA sequence consisting only of 'A', 'T', 'C', 'G' :return: str, \\"YES\\" if the sequence can be constructed by repeating a substring, otherwise \\"NO\\" >>> is_repeating_sequence(\\"ATGCATGC\\") \\"YES\\" >>> is_repeating_sequence(\\"ATGCGTAC\\") \\"NO\\"","solution":"def is_repeating_sequence(dna_sequence): Determines if the given DNA sequence can be made by repeating a substring. :param dna_sequence: str, DNA sequence consisting only 'A', 'T', 'C', 'G' :return: str, \\"YES\\" if the sequence can be constructed by repeating a substring, otherwise \\"NO\\" n = len(dna_sequence) for i in range(1, n // 2 + 1): if n % i == 0: if dna_sequence[:i] * (n // i) == dna_sequence: return \\"YES\\" return \\"NO\\""},{"question":"def rearrangeAltPattern(arr, n): Rearranges the array such that every second element is greater than the previous element, and every second element is smaller than the previous element in an alternating fashion. >>> rearrangeAltPattern([3, 5, 2, 1, 6, 4], 6) [3, 5, 1, 6, 2, 4] >>> rearrangeAltPattern([10, 20, 30, 40, 50, 60, 70], 7) [10, 30, 20, 50, 40, 70, 60] pass def test_rearrangeAltPattern_example1(): assert rearrangeAltPattern([3, 5, 2, 1, 6, 4], 6) == [3, 5, 1, 6, 2, 4] def test_rearrangeAltPattern_example2(): assert rearrangeAltPattern([10, 20, 30, 40, 50, 60, 70], 7) == [10, 30, 20, 50, 40, 70, 60] def test_rearrangeAltPattern_small(): assert rearrangeAltPattern([1, 3, 2], 3) == [1, 3, 2] def test_rearrangeAltPattern_all_sorted(): assert rearrangeAltPattern([1, 2, 3, 4, 5, 6], 6) == [1, 3, 2, 5, 4, 6] def test_rearrangeAltPattern_all_equal(): assert rearrangeAltPattern([1, 1, 1, 1, 1, 1], 6) == [1, 1, 1, 1, 1, 1] def test_rearrangeAltPattern_single_element(): assert rearrangeAltPattern([1], 1) == [1] def test_rearrangeAltPattern_two_elements(): assert rearrangeAltPattern([2, 1], 2) == [1, 2] def test_rearrangeAltPattern_descending_order(): assert rearrangeAltPattern([5, 4, 3, 2, 1], 5) == [4, 5, 2, 3, 1]","solution":"def rearrangeAltPattern(arr, n): Rearranges the array such that every second element is greater than the previous element, and every second element is smaller than the previous element in an alternating fashion. for i in range(n - 1): # if index is even, ensure arr[i] < arr[i+1] if (i % 2 == 0 and arr[i] > arr[i+1]) or (i % 2 == 1 and arr[i] < arr[i+1]): arr[i], arr[i+1] = arr[i+1], arr[i] return arr"},{"question":"from typing import List def reorder_even_before_odd(arr: List[int]) -> List[int]: Reorder the list such that all even integers come before all odd integers while maintaining the relative order of even and odd integers as they appeared in the original list. >>> reorder_even_before_odd([1, 3, 2, 4, 7, 6]) [2, 4, 6, 1, 3, 7] >>> reorder_even_before_odd([4, 2, 3, 1]) [4, 2, 3, 1] >>> reorder_even_before_odd([2, 4, 6, 8]) [2, 4, 6, 8] >>> reorder_even_before_odd([1, 3, 5, 7]) [1, 3, 5, 7] >>> reorder_even_before_odd([7, 14, 21, 28, 35]) [14, 28, 7, 21, 35] >>> reorder_even_before_odd([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> reorder_even_before_odd([4]) [4] >>> reorder_even_before_odd([5]) [5] >>> reorder_even_before_odd([]) []","solution":"from typing import List def reorder_even_before_odd(arr: List[int]) -> List[int]: Reorder the list such that all even integers come before all odd integers while maintaining the relative order of even and odd integers as they appeared in the original list. :param arr: A list of non-negative integers :return: A list of integers with all evens before all odds even_numbers = [num for num in arr if num % 2 == 0] odd_numbers = [num for num in arr if num % 2 != 0] return even_numbers + odd_numbers"},{"question":"def min_path_costs(input_text): Determine the minimum cost path in the grid from top-left to bottom-right. >>> input_text = \\"2n3 3n1 3 1n1 5 1n4 2 1n2 2n1 2n1 1\\" >>> min_path_costs(input_text) 7 3","solution":"def min_path_cost(grid): N = len(grid) M = len(grid[0]) # Initialize dp table dp = [[0] * M for _ in range(N)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][M-1] def process_input(input_text): input_lines = input_text.strip().split('n') T = int(input_lines[0]) index = 1 results = [] for _ in range(T): N, M = map(int, input_lines[index].split()) grid = [] for i in range(N): grid.append(list(map(int, input_lines[index + 1 + i].split()))) result = min_path_cost(grid) results.append(result) index += N + 1 return results def min_path_costs(input_text): results = process_input(input_text) for result in results: print(result)"},{"question":"import math from typing import List, Tuple class RangeMinQuery: def __init__(self, array: List[int]): n = len(array) self.n = n self.log = [0] * (n + 1) self.st = [[0] * (math.floor(math.log2(n)) + 1) for _ in range(n)] # Precompute log values for efficiency for i in range(2, n + 1): self.log[i] = self.log[i // 2] + 1 # Initialize Sparse Table for i in range(n): self.st[i][0] = array[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: self.st[i][j] = min(self.st[i][j - 1], self.st[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 def query(self, L: int, R: int) -> int: j = self.log[R - L + 1] return min(self.st[L][j], self.st[R - (1 << j) + 1][j]) def process_queries(n: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a sequence of integers in an array, this function answers multiple range queries efficiently. Each query will ask to find the minimum value in a specified subarray. :param n: Length of the array. :param array: List of integers. :param queries: List of tuples, where each tuple contains two integers representing the start and end indices of the subarray. :return: List of minimum values for each query. Example: >>> process_queries(6, [1, 3, -1, 7, 9, 4], [(1, 3), (2, 5), (4, 6)]) [-1, -1, 4] pass","solution":"import sys import math class RangeMinQuery: def __init__(self, array): n = len(array) self.n = n self.log = [0] * (n + 1) self.st = [[0] * (math.floor(math.log2(n)) + 1) for _ in range(n)] # Precompute log values for efficiency for i in range(2, n + 1): self.log[i] = self.log[i // 2] + 1 # Initialize Sparse Table for i in range(n): self.st[i][0] = array[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: self.st[i][j] = min(self.st[i][j - 1], self.st[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 def query(self, L, R): j = self.log[R - L + 1] return min(self.st[L][j], self.st[R - (1 << j) + 1][j]) def process_queries(n, array, queries): rmq = RangeMinQuery(array) results = [] for l, r in queries: results.append(rmq.query(l - 1, r - 1)) return results"},{"question":"def max_palindromic_subsequence_length(s: str, k: int) -> int: Given a string 's' and a non-negative integer 'k', returns the maximum possible length of a non-empty palindromic subsequence that can be obtained after performing at most 'k' operations. Args: s (str): The input string. k (int): The maximum number of allowed operations. Returns: int: The maximum length of a non-empty palindromic subsequence. Examples: >>> max_palindromic_subsequence_length(\\"abcde\\", 2) 5 >>> max_palindromic_subsequence_length(\\"abacaba\\", 1) 7 >>> max_palindromic_subsequence_length(\\"abc\\", 0) 1 def test_max_palindromic_subsequence_length(): assert max_palindromic_subsequence_length(\\"abcde\\", 2) == 5 assert max_palindromic_subsequence_length(\\"abacaba\\", 1) == 7 assert max_palindromic_subsequence_length(\\"abc\\", 0) == 1 assert max_palindromic_subsequence_length(\\"a\\", 0) == 1 assert max_palindromic_subsequence_length(\\"racecar\\", 1) == 7 assert max_palindromic_subsequence_length(\\"abab\\", 2) == 4 assert max_palindromic_subsequence_length(\\"abcdefg\\", 3) == 7","solution":"def max_palindromic_subsequence_length(s, k): Given a string 's' and a non-negative integer 'k', returns the maximum possible length of a non-empty palindromic subsequence that can be obtained after performing at most 'k' operations. # The idea here is to determine the maximum length of a palindrome we can form with at most 'k' modifications. n = len(s) # If \`k\` is large enough to change more than half the characters, we can just create a palindrome of length \`n\` if k >= n // 2: return n # Initialize a 2D array for dynamic programming dp = [[0] * n for _ in range(n)] # Base case: single character substrings are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Fill DP table for L in range(2, n + 1): # L is the length of the current substring for i in range(n - L + 1): j = i + L - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) # Get the length of the longest palindromic subsequence longest_pal_subseq = dp[0][n - 1] # We can increase it by up to 2*k return min(n, longest_pal_subseq + 2 * k)"},{"question":"def maximum_attendance_probability(test_cases): Given a list of n probabilities and a maximum number of tickets k, determine the maximum probability of attendance for each test case. >>> maximum_attendance_probability([(3, 2, [0.5, 0.8, 0.3]), (4, 3, [0.1, 0.4, 0.7, 0.6])]) [1.3, 1.7] >>> maximum_attendance_probability([(4, 2, [0.2, 0.9, 0.4, 0.5])]) [1.4] >>> maximum_attendance_probability([(5, 0, [0.1, 0.2, 0.3, 0.4, 0.5])]) [0.0] >>> maximum_attendance_probability([(3, 3, [0.1, 0.9, 0.4])]) [1.4] >>> maximum_attendance_probability([(3, 2, [0.0, 0.0, 0.0])]) [0.0] pass def parse_input(input_string): Parse the input string into a list of test cases. Each test case is a tuple containing the number of attendees, the number of tickets, and the list of probabilities. >>> parse_input(\\"2n3 2n0.5 0.8 0.3n4 3n0.1 0.4 0.7 0.6\\") [(3, 2, [0.5, 0.8, 0.3]), (4, 3, [0.1, 0.4, 0.7, 0.6])] pass def format_output(output): Format the output list into a string. Each element of the list should be formatted to one decimal place and joined by a newline. >>> format_output([1.3, 1.7]) '1.3n1.7' pass from solution import maximum_attendance_probability, parse_input, format_output def test_maximum_attendance_example_case(): input_string = \\"2n3 2n0.5 0.8 0.3n4 3n0.1 0.4 0.7 0.6\\" test_cases = parse_input(input_string) results = maximum_attendance_probability(test_cases) assert format_output(results) == \\"1.3n1.7\\" def test_maximum_attendance_single_case(): input_string = \\"1n4 2n0.2 0.9 0.4 0.5\\" test_cases = parse_input(input_string) results = maximum_attendance_probability(test_cases) assert format_output(results) == \\"1.4\\" def test_maximum_attendance_no_tickets(): input_string = \\"1n5 0n0.1 0.2 0.3 0.4 0.5\\" test_cases = parse_input(input_string) results = maximum_attendance_probability(test_cases) assert format_output(results) == \\"0.0\\" def test_maximum_attendance_all_tickets(): input_string = \\"1n3 3n0.1 0.9 0.4\\" test_cases = parse_input(input_string) results = maximum_attendance_probability(test_cases) assert format_output(results) == \\"1.4\\" def test_maximum_attendance_all_zero_probabilities(): input_string = \\"1n3 2n0.0 0.0 0.0\\" test_cases = parse_input(input_string) results = maximum_attendance_probability(test_cases) assert format_output(results) == \\"0.0\\"","solution":"def maximum_attendance_probability(test_cases): results = [] for n, k, probabilities in test_cases: # Sort probabilities in descending order to maximize total probability probabilities.sort(reverse=True) # Sum the top k probabilities max_prob = sum(probabilities[:k]) results.append(max_prob) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n, k = map(int, lines[index].split()) probabilities = list(map(float, lines[index+1].split())) test_cases.append((n, k, probabilities)) index += 2 return test_cases def format_output(output): return \\"n\\".join(f\\"{o:.1f}\\" for o in output) # Example usage: input_string = \\"2n3 2n0.5 0.8 0.3n4 3n0.1 0.4 0.7 0.6\\" test_cases = parse_input(input_string) results = maximum_attendance_probability(test_cases) output = format_output(results) print(output)"},{"question":"from typing import List, Tuple def max_non_overlapping_books(n: int, book_intervals: List[Tuple[int, int, int]]) -> int: Determine the maximum number of books that can be borrowed without overlapping borrowing intervals. >>> max_non_overlapping_books(3, [(101, 1, 10), (102, 5, 15), (103, 20, 30)]) 2 >>> max_non_overlapping_books(2, [(101, 1, 10), (102, 5, 15)]) 1 >>> max_non_overlapping_books(4, [(101, 1, 5), (102, 6, 10), (103, 11, 15), (104, 16, 20)]) 4 >>> max_non_overlapping_books(3, [(101, 1, 10), (102, 11, 20), (103, 21, 30)]) 3 >>> max_non_overlapping_books(3, [(101, 1, 10), (102, 2, 9), (103, 20, 30)]) 2","solution":"def max_non_overlapping_books(n, book_intervals): # Sort book intervals by end time book_intervals.sort(key=lambda x: x[2]) # Initialize counters max_books = 0 last_end_time = 0 for book_id, start, end in book_intervals: if start > last_end_time: # If current book's start time is greater than last chosen end time, select this book max_books += 1 last_end_time = end return max_books # Define function to parse input def parse_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) book_intervals = [] for i in range(n): book_id = int(data[1 + 3 * i]) start = int(data[2 + 3 * i]) end = int(data[3 + 3 * i]) book_intervals.append((book_id, start, end)) return n, book_intervals"},{"question":"def longestAlternatingSubsequence(arr: List[int]) -> int: Find the length of the longest alternating subsequence in a given list of integers. An alternating subsequence is a sequence derived from the original list by deleting some elements (without changing the order of the remaining elements) such that the differences between consecutive elements, when taken in absolute value, strictly alternate. Args: arr (List[int]): The list of integers. Returns: int: The length of the longest alternating subsequence. >>> longestAlternatingSubsequence([1, 7, 4, 9, 2, 5]) 6 >>> longestAlternatingSubsequence([10, 22, 9, 33, 49, 50, 31, 60]) 6 >>> longestAlternatingSubsequence([1, 5, 4]) 3 >>> longestAlternatingSubsequence([1, 2, 3, 4, 5]) 2 >>> longestAlternatingSubsequence([5, 4, 3, 2, 1]) 2 >>> longestAlternatingSubsequence([1]) 1 >>> longestAlternatingSubsequence([3, 1, 5, 7, 2, 8, 3, 4]) 7 >>> longestAlternatingSubsequence([]) 0 >>> longestAlternatingSubsequence([1, 1, 1, 1]) 1","solution":"def longestAlternatingSubsequence(arr): n = len(arr) if n == 0: return 0 up = [1] * n down = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: up[i] = max(up[i], down[j] + 1) elif arr[i] < arr[j]: down[i] = max(down[i], up[j] + 1) return max(max(up), max(down))"},{"question":"def min_roads_to_remove(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Returns the minimum number of roads that need to be removed such that the graph remains connected. >>> min_roads_to_remove(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (3, 5), (5, 6), (2, 6)]) == 2 >>> min_roads_to_remove(4, 5, [(1, 2), (2, 3), (3, 4), (1, 3), (2, 4)]) == 2 >>> min_roads_to_remove(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4), (1, 5)]) == 2 >>> min_roads_to_remove(7, 10, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (1, 7), (2, 6), (1, 3), (4, 6)]) == 4 >>> min_roads_to_remove(3, 3, [(1, 2), (2, 3), (1, 3)]) == 1 >>> min_roads_to_remove(2, 1, [(1, 2)]) == 0 >>> min_roads_to_remove(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == 1","solution":"def min_roads_to_remove(n, m, roads): Returns the minimum number of roads that need to be removed such that the graph remains connected. # The minimum number of roads to be removed while maintaining connectivity return m - (n - 1) # Example usage: # n = 6 # m = 7 # roads = [(1, 2), (2, 3), (3, 4), (4, 5), (3, 5), (5, 6), (2, 6)] # Result should be 2 print(min_roads_to_remove(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (3, 5), (5, 6), (2, 6)])) # Output: 2"},{"question":"def determine_temperature_description(n: int) -> str: Given an integer n that represents temperature in degrees Celsius, determine if it is a freezing, cold, warm, or hot day. A temperature below 0 degrees is considered 'Freezing'. A temperature from 0 to 10 degrees inclusive is considered 'Cold'. A temperature from 11 to 25 degrees inclusive is considered 'Warm'. A temperature above 25 degrees is considered 'Hot'. Args: n (int): Temperature in degrees Celsius. Returns: str: The description of the temperature. Examples: >>> determine_temperature_description(-10) 'Freezing' >>> determine_temperature_description(5) 'Cold' >>> determine_temperature_description(20) 'Warm' >>> determine_temperature_description(30) 'Hot'","solution":"def determine_temperature_description(n): if n < 0: return 'Freezing' elif 0 <= n <= 10: return 'Cold' elif 11 <= n <= 25: return 'Warm' else: return 'Hot'"},{"question":"def min_operations_to_subsequence(s, t): Returns the minimum number of operations required to make string s a subsequence of string t. pass # Replace with implementation def test_min_operations_to_subsequence(): assert min_operations_to_subsequence(\\"abc\\", \\"ahbgdc\\") == 0 assert min_operations_to_subsequence(\\"axc\\", \\"ahbgdc\\") == 2 assert min_operations_to_subsequence(\\"ace\\", \\"abcde\\") == 0 assert min_operations_to_subsequence(\\"xyz\\", \\"abcxyz\\") == 0 assert min_operations_to_subsequence(\\"xyz\\", \\"aaxycxyz\\") == 0 assert min_operations_to_subsequence(\\"abc\\", \\"ab\\") == 1 assert min_operations_to_subsequence(\\"agc\\", \\"abgcabc\\") == 0 assert min_operations_to_subsequence(\\"agc\\", \\"aaxcba\\") == 2 assert min_operations_to_subsequence(\\"apple\\", \\"aapple\\") == 0 assert min_operations_to_subsequence(\\"apple\\", \\"bapple\\") == 0 assert min_operations_to_subsequence(\\"abcd\\", \\"abcdefg\\") == 0 test_min_operations_to_subsequence()","solution":"def min_operations_to_subsequence(s, t): Returns the minimum number of operations required to make string s a subsequence of string t. # Two pointers for both strings s and t i, j = 0, 0 # Traverse both strings while i < len(s) and j < len(t): if s[i] == t[j]: i += 1 j += 1 # If we traversed all characters of s, it's a subsequence of t if i == len(s): return 0 # Count the remaining characters in s and t that needs to be removed remaining_s = len(s) - i remaining_t = len(t) - j # Total operations is sum of remaining characters return remaining_s + remaining_t"},{"question":"def process_commands(n: int, commands: List[str]) -> List[str]: Given a string \`s\`, perform the following operations based on the commands provided: 1. **add_front c**: Add character \`c\` to the front of the string. 2. **add_end c**: Add character \`c\` to the end of the string. 3. **reverse**: Reverse the string. 4. **remove_first c**: Remove the first occurrence of character \`c\` in the string. 5. **remove_last c**: Remove the last occurrence of character \`c\` in the string. 6. **replace a b**: Replace all occurrences of character \`a\` with character \`b\`. 7. **print**: Print the string. Initialize your string \`s\` as an empty string. Args: - n (int): The number of commands. - commands (List[str]): A list of commands to process. Returns: - List[str]: The results of each print command. >>> process_commands(8, [\\"add_end a\\", \\"add_end b\\", \\"add_front c\\", \\"print\\", \\"reverse\\", \\"print\\", \\"replace a d\\", \\"print\\"]) [\\"cab\\", \\"bac\\", \\"bdc\\"] >>> process_commands(9, [\\"add_end a\\", \\"add_end a\\", \\"add_end b\\", \\"add_front c\\", \\"print\\", \\"remove_first a\\", \\"print\\", \\"remove_last a\\", \\"print\\"]) [\\"caab\\", \\"cab\\", \\"cb\\"]","solution":"def process_commands(n, commands): s = \\"\\" def add_front(c): nonlocal s s = c + s def add_end(c): nonlocal s s = s + c def reverse(): nonlocal s s = s[::-1] def remove_first(c): nonlocal s s = s.replace(c, \\"\\", 1) def remove_last(c): nonlocal s reverse() s = s.replace(c, \\"\\", 1) reverse() def replace(a, b): nonlocal s s = s.replace(a, b) result = [] for command in commands: parts = command.split() cmd = parts[0] if cmd == \\"add_front\\": add_front(parts[1]) elif cmd == \\"add_end\\": add_end(parts[1]) elif cmd == \\"reverse\\": reverse() elif cmd == \\"remove_first\\": remove_first(parts[1]) elif cmd == \\"remove_last\\": remove_last(parts[1]) elif cmd == \\"replace\\": replace(parts[1], parts[2]) elif cmd == \\"print\\": result.append(s) return result"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the string can be rearranged to form a palindrome. Returns \\"YES\\" if possible, \\"NO\\" otherwise. >>> can_form_palindrome(\\"carrace\\") 'YES' >>> can_form_palindrome(\\"abc\\") 'NO' >>> can_form_palindrome(\\"\\") 'YES' >>> can_form_palindrome(\\"aabbcc\\") 'YES' >>> can_form_palindrome(\\"aaabbbaaa\\") 'YES' >>> can_form_palindrome(\\"aaabbbaaaa\\") 'NO' >>> can_form_palindrome(\\"a\\") 'YES' >>> can_form_palindrome(\\"aaaa\\") 'YES'","solution":"def can_form_palindrome(s): Determines if the string can be rearranged to form a palindrome. Returns \\"YES\\" if possible, \\"NO\\" otherwise. from collections import Counter freqs = Counter(s) odd_count = sum(1 for count in freqs.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def max_mutation_index(n, k, s): This function calculates the maximum mutation index for any contiguous subsequence of length \`k\` in the given DNA sequence \`s\`. :param n: Integer, length of the DNA sequence. :param k: Integer, length of the contiguous subsequence. :param s: String, the DNA sequence consisting of characters 'A', 'C', 'G', and 'T'. :return: Integer, the maximum mutation index for any contiguous subsequence of length \`k\`. >>> max_mutation_index(10, 4, \\"ACGTACGTAC\\") 4 >>> max_mutation_index(5, 3, \\"AACGT\\") 3","solution":"def max_mutation_index(n, k, s): This function calculates the maximum mutation index for any contiguous subsequence of length \`k\` in the given DNA sequence \`s\`. :param n: Integer, length of the DNA sequence. :param k: Integer, length of the contiguous subsequence. :param s: String, the DNA sequence consisting of characters 'A', 'C', 'G', and 'T'. :return: Integer, the maximum mutation index for any contiguous subsequence of length \`k\`. max_mutation = 0 for i in range(n - k + 1): subsequence = s[i:i + k] mutation_index = k # All characters differ considering full mutation by default max_mutation = max(max_mutation, mutation_index) return max_mutation"},{"question":"def find_first_missing_positive(T: int, test_cases: list) -> list: Finds the first missing positive integer in an unsorted array for multiple test cases. Parameters: T (int): Number of test cases test_cases (list of tuples): A list where each tuple contains the number of elements (n) and the list of elements. Returns: list: A list of the smallest missing positive integers for each test case. >>> find_first_missing_positive(2, [(3, [1, 2, 0]), (4, [3, 4, -1, 1])]) [3, 2] >>> find_first_missing_positive(1, [(4, [1, 2, 3, 4])]) [5] >>> find_first_missing_positive(1, [(5, [2, 3, 4, 5, 6])]) [1] >>> find_first_missing_positive(1, [(5, [0, -10, -3, -1, 7])]) [1] >>> find_first_missing_positive(2, [(6, [1, 1, 0, -1, -2, 1]), (3, [0, 1, 2])]) [2, 3]","solution":"def find_first_missing_positive(T, test_cases): Finds the first missing positive integer in an unsorted array for multiple test cases. Parameters: T (int): Number of test cases test_cases (list of tuples): A list where each tuple contains the number of elements (n) and the list of elements. Returns: list: A list of the smallest missing positive integers for each test case. results = [] for n, array in test_cases: # We only care about positive numbers in the range 1 to n+1 current_set = set(x for x in array if 1 <= x <= n + 1) # Find the smallest missing positive integer missing_number = 1 while missing_number in current_set: missing_number += 1 results.append(missing_number) return results"},{"question":"def generate_binary_strings(n): Generates all binary strings of length n. Parameters: n (int): The length of the binary strings to generate. Returns: List[str]: A list of binary strings of length n. pass # Unit Tests def test_generate_binary_strings_length_1(): assert generate_binary_strings(1) == [\\"0\\", \\"1\\"] def test_generate_binary_strings_length_2(): assert generate_binary_strings(2) == [\\"00\\", \\"01\\", \\"10\\", \\"11\\"] def test_generate_binary_strings_length_3(): assert generate_binary_strings(3) == [\\"000\\", \\"001\\", \\"010\\", \\"011\\", \\"100\\", \\"101\\", \\"110\\", \\"111\\"] def test_generate_binary_strings_length_0(): assert generate_binary_strings(0) == [\\"\\"] def test_generate_binary_strings_length_4(): expected = [\\"0000\\", \\"0001\\", \\"0010\\", \\"0011\\", \\"0100\\", \\"0101\\", \\"0110\\", \\"0111\\", \\"1000\\", \\"1001\\", \\"1010\\", \\"1011\\", \\"1100\\", \\"1101\\", \\"1110\\", \\"1111\\"] assert generate_binary_strings(4) == expected","solution":"def generate_binary_strings(n): Generates all binary strings of length n. Parameters: n (int): The length of the binary strings to generate. Returns: List[str]: A list of binary strings of length n. if n == 0: return [\\"\\"] from itertools import product # Generate all possible combinations of length n using '0' and '1' return [''.join(bits) for bits in product('01', repeat=n)]"},{"question":"from typing import List def number_of_unique_balanced_bsts(a: List[int]) -> int: Determine the number of unique balanced binary search trees (BSTs) that can be formed from a given sorted array of integers. >>> number_of_unique_balanced_bsts([10]) == 1 >>> number_of_unique_balanced_bsts([10, 20]) == 2 >>> number_of_unique_balanced_bsts([10, 20, 30]) == 5 >>> number_of_unique_balanced_bsts([10, 20, 30, 40]) == 14 >>> number_of_unique_balanced_bsts([1, 2, 3, 4, 5]) == 42 >>> number_of_unique_balanced_bsts([]) == 1 >>> number_of_unique_balanced_bsts([42]) == 1","solution":"from functools import lru_cache @lru_cache(None) def count_unique_bsts(n): if n <= 1: return 1 total_trees = 0 for i in range(n): left_trees = count_unique_bsts(i) right_trees = count_unique_bsts(n - 1 - i) total_trees += left_trees * right_trees return total_trees def number_of_unique_balanced_bsts(a): n = len(a) return count_unique_bsts(n) # Example usage: # input_array = [10, 20, 30] # print(number_of_unique_balanced_bsts(input_array)) # Output should be 5"},{"question":"def count_buildings_with_good_view(n: int, heights: List[int]) -> int: Returns the number of buildings that have a good view. A building has a good view if it is not shorter than any of the buildings to its right. Args: n: An integer, the number of buildings. heights: A list of integers, representing heights of the buildings. Returns: An integer representing the count of buildings with a good view. >>> count_buildings_with_good_view(6, [3, 7, 8, 3, 6, 1]) == 3 >>> count_buildings_with_good_view(4, [4, 3, 2, 1]) == 4 >>> count_buildings_with_good_view(1, [5]) == 1 >>> count_buildings_with_good_view(5, [5, 5, 5, 5, 5]) == 5 >>> count_buildings_with_good_view(2, [3, 2]) == 2 >>> count_buildings_with_good_view(2, [2, 3]) == 1 >>> count_buildings_with_good_view(0, []) == 0","solution":"def count_buildings_with_good_view(n, heights): Returns the number of buildings that have a good view. Parameters: n (int): The number of buildings. heights (list): List of heights of the buildings. Returns: int: The count of buildings with a good view. if n == 0: return 0 count = 1 # The last building always has a good view max_height_to_right = heights[-1] # Traverse the list from second last to first for i in range(n-2, -1, -1): if heights[i] >= max_height_to_right: count += 1 max_height_to_right = heights[i] return count"},{"question":"def is_coin_in_collection(N: int, coin_values: List[int], new_coin_value: int) -> str: Returns \\"YES\\" if the new coin value is already in the collection, otherwise \\"NO\\". >>> is_coin_in_collection(5, [1, 2, 3, 4, 5], 3) == \\"YES\\" >>> is_coin_in_collection(5, [1, 2, 3, 4, 5], 6) == \\"NO\\"","solution":"def is_coin_in_collection(N, coin_values, new_coin_value): Returns \\"YES\\" if the new coin value is already in the collection, otherwise \\"NO\\". :param N: int, the size of the collection. :param coin_values: list of int, the values of the coins in the collection. :param new_coin_value: int, the value of the new coin to check. :return: str, \\"YES\\" or \\"NO\\" if new_coin_value in coin_values: return \\"YES\\" else: return \\"NO\\" # Example usage: N = 5 coin_values = [1, 2, 3, 4, 5] new_coin_value = 3 print(is_coin_in_collection(N, coin_values, new_coin_value)) # Output: YES"},{"question":"def can_convert(A, B): Determine if array A can be transformed into array B by reversing any number of subarrays. >>> can_convert([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) True >>> can_convert([1, 3, 2, 4], [1, 2, 3, 4]) True >>> can_convert([1, 2, 3], [1, 2, 2]) False >>> can_convert([1, 2, 3], [3, 2, 1]) True >>> can_convert([2, 1], [1, 2]) True >>> can_convert([1], [1]) True >>> can_convert([1, 1, 2], [2, 1, 1]) True >>> can_convert([1, 1, 2], [1, 1, 1]) False # Implementation def process_test_cases(T, test_cases): Process multiple test cases to determine if each pair of arrays can be transformed. >>> process_test_cases(2, [ (5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]), (4, [1, 3, 2, 4], [1, 2, 3, 4]) ]) [\\"YES\\", \\"YES\\"] >>> process_test_cases(1, [ (3, [1, 2, 3], [1, 2, 2]) ]) [\\"NO\\"] >>> process_test_cases(3, [ (3, [1, 2, 3], [3, 2, 1]), (2, [2, 1], [1, 2]), (1, [1], [1]) ]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases(2, [ (3, [1, 1, 2], [2, 1, 1]), (3, [1, 1, 2], [1, 1, 1]), ]) [\\"YES\\", \\"NO\\"] # Implementation","solution":"def can_convert(A, B): Determine if array A can be transformed into array B by reversing any number of subarrays. return sorted(A) == sorted(B) def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] B = test_cases[i][2] if can_convert(A, B): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def max_participants_per_group(n: int, participants: List[int]) -> int: Naomi wants to divide the participants into groups such that each group has an equal number of participants. Find out the maximum number of participants that can be in each group. :param n: Number of workshops :param participants: List of participants in each workshop :return: Maximum number of participants per group >>> max_participants_per_group(4, [10, 20, 30, 40]) 10 >>> max_participants_per_group(3, [15, 15, 15]) 15 >>> max_participants_per_group(3, [17, 19, 23]) 1 >>> max_participants_per_group(5, [1, 1, 1, 1, 1]) 1 >>> max_participants_per_group(3, [100, 200, 300]) 100 >>> max_participants_per_group(5, [35, 10, 50, 25, 30]) 5 >>> max_participants_per_group(2, [5, 10]) 5 >>> max_participants_per_group(4, [60, 120, 180, 240]) 60","solution":"import math from functools import reduce def max_participants_per_group(n, participants): Returns the maximum number of participants per group. :param n: Number of workshops :param participants: List of participants in each workshop :return: Maximum number of participants per group def gcd(a, b): while b: a, b = b, a % b return a return reduce(gcd, participants)"},{"question":"def largest_team_size(n: int, t: int) -> int: Returns the size of the largest team given n students and t teams. >>> largest_team_size(14, 3) 5 >>> largest_team_size(7, 5) 2","solution":"def largest_team_size(n, t): Returns the size of the largest team given n students and t teams. # Each student must be assigned to exactly one team. # The size of the largest team should be minimized and teams should be as balanced as possible. # Calculate base size of each team base_size = n // t # Calculate the number of teams that will have the base_size + 1 students num_larger_teams = n % t # If there are larger teams, their size will be base_size + 1 if num_larger_teams > 0: return base_size + 1 # If all teams are of the same size else: return base_size"},{"question":"def reverseWords(s: str) -> str: Reverses the order of words in a given string. >>> reverseWords(\\"python coding challenges\\") \\"challenges coding python\\" >>> reverseWords(\\"hello\\") \\"hello\\" >>> reverseWords(\\"hello world\\") \\"world hello\\" >>> reverseWords(\\"\\") \\"\\" >>> reverseWords(\\"a b c\\") \\"c b a\\"","solution":"def reverseWords(s): Reverses the order of words in a given string s. return ' '.join(s.split()[::-1])"},{"question":"def gcd_of_range(m: int, n: int) -> int: Given two integers M and N, find the greatest common divisor (GCD) of all integers between M and N (inclusive). Input Format: The only line of input contains two integers M and N separated by a space. Output Format: Output the GCD of all integers between M and N. Constraints: 1 ≤ M ≤ N ≤ 10^6 >>> gcd_of_range(10, 10) 10 >>> gcd_of_range(1, 1) 1 >>> gcd_of_range(999999, 999999) 999999 >>> gcd_of_range(10, 15) 1 >>> gcd_of_range(1, 10) 1 >>> gcd_of_range(2, 4) 1 >>> gcd_of_range(1, 2) 1 >>> gcd_of_range(2, 3) 1 >>> gcd_of_range(999998, 999999) 1 >>> gcd_of_range(500000, 1000000) 1 # Your code here.","solution":"import math def gcd_of_range(m, n): Returns the GCD of all integers between m and n (inclusive). # GCD of a range where there is more than one distinct number within the range is always 1 start = min(m, n) end = max(m, n) if start == end: return start return 1"},{"question":"def sequence_length(n: int) -> int: Given a positive integer n, returns the length of the sequence until it reaches 1. >>> sequence_length(6) 9 >>> sequence_length(19) 21 def arjuns_sequence(T: int, nums: List[int]) -> List[int]: For T test cases given in nums, returns a list of sequence lengths for each starting integer. >>> arjuns_sequence(2, [6, 19]) [9, 21] >>> arjuns_sequence(1, [1]) [1]","solution":"def sequence_length(n): Given a positive integer n, returns the length of the sequence until it reaches 1. length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length def arjuns_sequence(T, nums): For T test cases given in nums, returns a list of sequence lengths for each starting integer. results = [] for n in nums: results.append(sequence_length(n)) return results"},{"question":"def min_days_to_complete_sessions(n: int, d: int, t: List[int]) -> int: Calculate the minimum number of days required to attend all the sessions. Each session must be attended without any breaks in between days. Parameters: n: the number of sessions d: the number of maximum sessions a day t: the hours required for each session >>> min_days_to_complete_sessions(9, 1, [5, 3, 2, 7, 4, 6, 5, 8, 3]) == 9 >>> min_days_to_complete_sessions(8, 1, [2, 1, 3, 4, 5, 6, 8, 7]) == 8 >>> min_days_to_complete_sessions(6, 2, [4, 2, 3, 1, 6, 5]) == 3 >>> min_days_to_complete_sessions(1, 1, [5]) == 1 >>> min_days_to_complete_sessions(2, 1, [5, 3]) == 2 >>> min_days_to_complete_sessions(2, 2, [5, 3]) == 1 >>> n = 100 >>> d = 1 >>> t = list(range(1, 101)) >>> min_days_to_complete_sessions(n, d, t) == 100","solution":"def min_days_to_complete_sessions(n, d, t): days = 0 curr_sum = 0 for i in range(n): if curr_sum + 1 > d: days += 1 curr_sum = 0 curr_sum += 1 if curr_sum > 0: days += 1 return days"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Determines the minimum number of operations required to transform string s into string t by incrementing characters. If it is impossible to transform s into t, return -1. >>> min_operations_to_transform(\\"abc\\", \\"bcd\\") 3 >>> min_operations_to_transform(\\"abc\\", \\"bac\\") -1 >>> min_operations_to_transform(\\"xyz\\", \\"yzx\\") -1","solution":"def min_operations_to_transform(s: str, t: str) -> int: Determines the minimum number of operations required to transform string s into string t by incrementing characters. if len(s) != len(t): return -1 operations = 0 for i in range(len(s)): if s[i] > t[i]: return -1 operations += ord(t[i]) - ord(s[i]) return operations"},{"question":"from typing import List def total_storage(files: List[int], block_size: int) -> int: Calculate the total storage space occupied by the files considering the block size. >>> total_storage([450, 600, 2000], 512) 3584 >>> total_storage([1024, 2048, 2049], 1024) 6144 >>> total_storage([123, 456, 789], 256) 1792","solution":"from typing import List def total_storage(files: List[int], block_size: int) -> int: Calculate the total storage space occupied by the files considering the block size. total_storage_used = 0 for file_size in files: blocks_needed = (file_size + block_size - 1) // block_size # Ceiling division total_storage_used += blocks_needed * block_size return total_storage_used"},{"question":"def find_pair_with_sum(nums, target): Finds the first pair of integers in the list nums whose sum equals the target. Args: nums (list of int): A list of unique integers. target (int): The target sum. Returns: tuple or None: A tuple containing the first pair of integers whose sum is equal to the target, or None if no such pair exists. Examples: >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None >>> find_pair_with_sum([10, -2, 3, 7, 5], 8) (10, -2)","solution":"def find_pair_with_sum(nums, target): Finds the first pair of integers in the list nums whose sum equals the target. Args: nums (list of int): A list of unique integers. target (int): The target sum. Returns: tuple or None: A tuple containing the first pair of integers whose sum is equal to the target, or None if no such pair exists. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (complement, num) num_to_index[num] = index return None"},{"question":"def compressString(s: str) -> str: Compresses the string based on counts of repeated characters. If the compressed string is not smaller than the original, returns the original string. :param s: Input string :return: Compressed string or original string based on the condition >>> compressString(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compressString(\\"abcdef\\") \\"abcdef\\"","solution":"def compressString(s): Compresses the string based on counts of repeated characters. If the compressed string is not smaller than the original, returns the original string. :param s: Input string :return: Compressed string or original string based on the condition if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 compressed.append(s[-1]) compressed.append(str(count)) compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"def char_count(s: str) -> dict: Write a function that takes a string as input and returns a dictionary with the count of each character in the string. The function should be case-sensitive, meaning 'A' and 'a' should be counted separately. >>> char_count(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> char_count(\\"a!@#a!@#\\") {'a': 2, '!': 2, '@': 2, '#': 2}","solution":"def char_count(s): Returns a dictionary with the count of each character in the string. count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"from typing import Generator, List def most_frequent_integer(data_generator: Generator[List[int], None, None]) -> int: Returns the most frequent integer from a dataset provided in chunks by a generator. If there is a tie, returns any one of the most frequent integers.","solution":"from collections import defaultdict from typing import Generator, List def most_frequent_integer(data_generator: Generator[List[int], None, None]) -> int: Returns the most frequent integer from a dataset provided in chunks by a generator. If there is a tie, returns any one of the most frequent integers. frequency = defaultdict(int) for chunk in data_generator: for num in chunk: frequency[num] += 1 most_frequent = None max_count = 0 for num, count in frequency.items(): if count > max_count: max_count = count most_frequent = num return most_frequent"},{"question":"def longest_contiguous_subsequence(arr: List[int]) -> int: Find the length of the longest contiguous subsequence where the absolute difference between any two consecutive elements is no more than 1. >>> longest_contiguous_subsequence([1, 2, 2, 3, 4, 5]) 6 >>> longest_contiguous_subsequence([10, 9, 8, 8, 7, 7, 6]) 7","solution":"def longest_contiguous_subsequence(arr): if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) <= 1: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"def longest_bitonic_subarray_length(arr): Find the length of the longest bitonic subarray. A bitonic subarray is one which first strictly increases and then strictly decreases. >>> longest_bitonic_subarray_length([1, 2, 3, 4, 5, 3, 2, 1, 0]) 9 >>> longest_bitonic_subarray_length([1, 5, 4, 3, 2, 5, 6]) 5 >>> longest_bitonic_subarray_length([12, 4, 78, 90, 45, 23]) 5","solution":"def longest_bitonic_subarray_length(arr): n = len(arr) if n == 0: return 0 # Initialize increase and decrease arrays inc = [1] * n dec = [1] * n # Construct inc array for i in range(1, n): if arr[i] > arr[i - 1]: inc[i] = inc[i - 1] + 1 # Construct dec array for i in range(n - 2, -1, -1): if arr[i] > arr[i + 1]: dec[i] = dec[i + 1] + 1 # Find the length of the longest bitonic subarray max_len = 1 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Returns the length of the longest subsequence where each element is greater than the previous one by exactly one. >>> longest_consecutive_sequence([1, 2, 3, 5, 6, 3, 4, 5, 6, 7]) 5 >>> longest_consecutive_sequence([10, 20, 30, 40]) 1 >>> longest_consecutive_sequence([5, 6, 3, 1, 2, 3, 7, 8, 9]) 3","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest subsequence where each element is greater than the previous one by exactly one. if not nums: return 0 max_len = 1 current_len = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1] + 1: current_len += 1 else: current_len = 1 if current_len > max_len: max_len = current_len return max_len"},{"question":"def max_continuous_segment_sum(n, magical_values): Determine the maximum sum of a continuous segment of stones. Args: - n (int): the number of stones in the path. - magical_values (list of int): the magical values of the stones. Returns: - int: the maximum sum of a continuous segment of stones. Examples: >>> max_continuous_segment_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_continuous_segment_sum(4, [1, 2, 3, 4]) 10 >>> max_continuous_segment_sum(8, [-1, -1, -1, -1, -1, -1, -1, -1]) -1","solution":"def max_continuous_segment_sum(n, magical_values): Determine the maximum sum of a continuous segment of stones. Args: - n (int): the number of stones in the path. - magical_values (list of int): the magical values of the stones. Returns: - int: the maximum sum of a continuous segment of stones. max_sum = magical_values[0] current_sum = magical_values[0] for i in range(1, n): current_sum = max(magical_values[i], current_sum + magical_values[i]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def nearestSmallerIndices(arr, n): Function to find the index of the nearest smaller element for each element in the array. If there are multiple smaller elements at the same distance, returns the leftmost one. Parameters: arr (list of int): Input array of integers. n (int): Size of the input array. Returns: list of int: Indices of the nearest smaller elements. Examples: >>> nearestSmallerIndices([4, 5, 2, 10, 8, 9, 2], 7) [-1, 0, -1, 2, 2, 4, -1] >>> nearestSmallerIndices([1, 3, 0, 2], 4) [-1, 0, -1, 2] def test_nearest_smaller_indices(): assert nearestSmallerIndices([4, 5, 2, 10, 8, 9, 2], 7) == [-1, 0, -1, 2, 2, 4, -1] assert nearestSmallerIndices([1, 3, 0, 2], 4) == [-1, 0, -1, 2] assert nearestSmallerIndices([3, 2, 1], 3) == [-1, -1, -1] assert nearestSmallerIndices([5, 6, 7, 8, 9], 5) == [-1, 0, 1, 2, 3] assert nearestSmallerIndices([9, 8, 7, 6, 5], 5) == [-1, -1, -1, -1, -1] assert nearestSmallerIndices([2, 1], 2) == [-1, -1] assert nearestSmallerIndices([1], 1) == [-1] def run_tests(): test_nearest_smaller_indices() print(\\"All tests passed.\\") # Run tests run_tests()","solution":"def nearestSmallerIndices(arr, n): Function to find the index of the nearest smaller element for each element in the array. If there are multiple smaller elements at the same distance, returns the leftmost one. Parameters: arr (list of int): Input array of integers. n (int): Size of the input array. Returns: list of int: Indices of the nearest smaller elements. stack = [] result = [-1] * n for i in range(n): while stack and arr[stack[-1]] >= arr[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(i) return result"},{"question":"def flippingMatrix(t: int, cases: List[Tuple[int, List[List[int]]]]) -> List[int]: For each test case, return the maximum sum of the elements in the n x n sub-matrix located in the top-left corner of the 2n x 2n matrix after performing any number of specified operations. Args: t: an integer, the number of test cases cases: a list of tuples where each tuple contains: - an integer n, the size of the sub-matrix and half of the dimension of the 2n x 2n matrix - a 2n x 2n matrix represented as a list of lists of integers Returns: A list of integers where each integer is the maximum sum of the elements in the top-left corner sub-matrix for each test case. >>> flippingMatrix(2, [ (1, [ [1, 2], [3, 4] ]), (2, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) ]) [4, 54] >>> flippingMatrix(1, [ (2, [ [112, 42, 83, 119], [56, 125, 56, 49], [15, 78, 101, 43], [62, 98, 114, 108] ]) ]) [414] >>> flippingMatrix(1, [ (1, [ [1, 10000000], [10000000, 1] ]) ]) [10000000] >>> flippingMatrix(1, [ (3, [ [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1] ]) ]) [9]","solution":"def flippingMatrix(t, cases): results = [] for case in cases: n = case[0] matrix = case[1] total = 0 # Iterate over the top-left n x n sub-matrix elements for i in range(n): for j in range(n): # Find the maximum value of the possible flips total += max( matrix[i][j], # original matrix[2*n - i - 1][j], # flip vertically matrix[i][2*n - j - 1], # flip horizontally matrix[2*n - i - 1][2*n - j - 1] # flip both ) results.append(total) return results"},{"question":"def compress_string(s): Given a string consisting of lowercase and uppercase characters, this function performs run-length encoding and returns the compressed version of the string. Run-length encoding is a simple form of data compression where consecutive occurrences of the same character are replaced with the character followed by the number of repetitions. If the compressed string is not shorter than the original string, return the original string instead. Examples: >>> compress_string(\\"aaabccdddd\\") \\"a3b1c2d4\\" >>> compress_string(\\"wwwwaaadexxxxxx\\") \\"w4a3d1e1x6\\" >>> compress_string(\\"abcd\\") \\"abcd\\" pass","solution":"def compress_string(s): Performs run-length encoding on the input string. If the compressed string is not shorter than the original string, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) result = ''.join(compressed) return result if len(result) < len(s) else s"},{"question":"def make_symmetric(matrix: List[List[int]]) -> List[List[int]]: Jane's professor gave her a matrix and asked her to make the matrix symmetric by setting any non-symmetric elements to -1. Write a function that takes a square matrix as input and outputs its symmetric version according to the professor's rules. Args: matrix (List[List[int]]): A square matrix. Returns: List[List[int]]: The transformed symmetric matrix. >>> make_symmetric([ ... [1, 2, 3], ... [2, 1, 4], ... [3, 5, 1] ... ]) [[1, 2, 3], [2, 1, -1], [3, -1, 1]] >>> make_symmetric([ ... [5, 6], ... [6, 7] ... ]) [[5, 6], [6, 7]]","solution":"def make_symmetric(matrix): n = len(matrix) for i in range(n): for j in range(i+1, n): if matrix[i][j] != matrix[j][i]: matrix[i][j] = -1 matrix[j][i] = -1 return matrix # Example usage: # n = 3 # matrix = [ # [1, 2, 3], # [2, 1, 4], # [3, 5, 1] # ] # print(make_symmetric(matrix))"},{"question":"def manage_reservations(ride_capacities, reservations): Processes reservations for rides and returns the reservation status. :param ride_capacities: List[int] with maximum capacity for each ride :param reservations: List[Tuple[int, int]] where each tuple is (ride_number, tickets_requested) :return: List[str], list of \\"Reservation Accepted\\" or \\"Reservation Rejected\\" >>> manage_reservations([5, 10, 15], [(1, 3), (2, 5), (3, 20), (1, 4), (2, 3)]) ['Reservation Accepted', 'Reservation Accepted', 'Reservation Rejected', 'Reservation Rejected', 'Reservation Accepted'] >>> manage_reservations([7, 4], [(1, 7), (2, 4), (1, 1), (2, 1)]) ['Reservation Accepted', 'Reservation Accepted', 'Reservation Rejected', 'Reservation Rejected']","solution":"def manage_reservations(ride_capacities, reservations): Processes reservations for rides and returns the reservation status. :param ride_capacities: List[int] with maximum capacity for each ride :param reservations: List[Tuple[int, int]] where each tuple is (ride_number, tickets_requested) :return: List[str], list of \\"Reservation Accepted\\" or \\"Reservation Rejected\\" results = [] for ride_number, tickets_requested in reservations: if ride_capacities[ride_number - 1] >= tickets_requested: ride_capacities[ride_number - 1] -= tickets_requested results.append(\\"Reservation Accepted\\") else: results.append(\\"Reservation Rejected\\") return results # Reading inputs for testing if __name__ == \\"__main__\\": r = int(input()) ride_capacities = list(map(int, input().split())) n = int(input()) reservations = [tuple(map(int, input().split())) for _ in range(n)] results = manage_reservations(ride_capacities, reservations) for result in results: print(result)"},{"question":"def can_form_arithmetic_progression(arr: List[int], K: int) -> str: Checks if there exist K distinct elements in arr that form an arithmetic progression. Args: arr (list): List of integers K (int): Number of elements to form the arithmetic progression Returns: str: \\"YES\\" if such K elements exist, otherwise \\"NO\\" >>> can_form_arithmetic_progression([1, 3, 5, 7, 9, 11], 3) == \\"YES\\" >>> can_form_arithmetic_progression([1, 2, 4, 8, 16], 4) == \\"NO\\"","solution":"def can_form_arithmetic_progression(arr, K): Checks if there exist K distinct elements in arr that form an arithmetic progression. Args: arr (list): List of integers K (int): Number of elements to form the arithmetic progression Returns: str: \\"YES\\" if such K elements exist, otherwise \\"NO\\" n = len(arr) if K == 1: return \\"YES\\" arr = sorted(set(arr)) n = len(arr) if n < K: return \\"NO\\" for i in range(n): for j in range(i + 1, n): d = arr[j] - arr[i] count = 2 prev = arr[j] for k in range(j + 1, n): if arr[k] - prev == d: count += 1 prev = arr[k] if count == K: return \\"YES\\" return \\"NO\\""},{"question":"def process_operations(binary_string: str, operations: list) -> list: Process a series of FLIP and COUNT operations on a binary string. Args: binary_string (str): Initial binary string. operations (list): List of operations to perform on the binary string. Returns: list: List of results from COUNT operations. >>> process_operations(\\"11001\\", [\\"FLIP 0\\", \\"COUNT\\", \\"FLIP 2\\", \\"COUNT\\", \\"FLIP 4\\"]) [2, 3] >>> process_operations(\\"00000\\", [\\"COUNT\\", \\"FLIP 1\\", \\"FLIP 3\\", \\"COUNT\\"]) [0, 2] >>> process_operations(\\"11111\\", [\\"COUNT\\", \\"FLIP 1\\", \\"FLIP 3\\", \\"COUNT\\"]) [5, 3] >>> process_operations(\\"0\\", [\\"FLIP 0\\", \\"COUNT\\"]) [1] >>> process_operations(\\"1\\", [\\"COUNT\\"]) [1] >>> process_operations(\\"00000\\", []) [] >>> process_operations(\\"11111\\", [\\"FLIP 0\\", \\"FLIP 1\\", \\"FLIP 2\\", \\"FLIP 3\\", \\"FLIP 4\\", \\"COUNT\\"]) [0] >>> process_operations(\\"10101\\", [\\"FLIP 0\\", \\"FLIP 1\\", \\"FLIP 2\\"]) []","solution":"def process_operations(binary_string, operations): Processes a series of FLIP and COUNT operations on a binary string. Args: binary_string (str): Initial binary string. operations (list): List of operations to perform on the binary string. Returns: list: List of results from COUNT operations. result = [] binary_list = list(binary_string) for operation in operations: if operation.startswith(\\"FLIP\\"): _, x = operation.split() x = int(x) binary_list[x] = '1' if binary_list[x] == '0' else '0' elif operation == \\"COUNT\\": result.append(binary_list.count('1')) return result"},{"question":"import math def uniqueSequences(N: int, K: int) -> int: Returns the count of unique sequences of length K that can be formed from N unique stamps. Parameters: N (int): The total number of stamps. K (int): The length of the sequence. Returns: int: The count of unique sequences. Examples: >>> uniqueSequences(4, 2) 6 >>> uniqueSequences(5, 3) 10","solution":"import math def uniqueSequences(N, K): Returns the count of unique sequences of length K that can be formed from N unique stamps. if K > N: return 0 # The number of unique sequences of length K is given by the binomial coefficient C(N, K) return math.comb(N, K)"},{"question":"def is_orderly_parking(m: int, n: int, grid: List[List[int]]) -> str: Determines if the given parking lot grid is orderly according to the rules. Args: m (int): number of rows in the grid. n (int): number of columns in the grid. grid (list of list of ints): 2D grid representing the parking lot. Returns: str: \\"YES\\" if the parking lot is orderly, else \\"NO\\". pass # Unit Tests def test_orderly_parking_1(): m, n = 2, 3 grid = [ [1, 0, 1], [1, 1, 0] ] assert is_orderly_parking(m, n, grid) == \\"NO\\" def test_orderly_parking_2(): m, n = 2, 4 grid = [ [0, 1, 1, 0], [0, 0, 1, 1] ] assert is_orderly_parking(m, n, grid) == \\"YES\\" def test_orderly_parking_all_empty(): m, n = 3, 3 grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert is_orderly_parking(m, n, grid) == \\"YES\\" def test_orderly_parking_single_row(): m, n = 1, 4 grid = [ [1, 1, 0, 1] ] assert is_orderly_parking(m, n, grid) == \\"NO\\" def test_orderly_parking_single_column(): m, n = 4, 1 grid = [ [1], [0], [1], [1] ] assert is_orderly_parking(m, n, grid) == \\"NO\\" def test_orderly_parking_large_grid(): m, n = 5, 5 grid = [ [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] assert is_orderly_parking(m, n, grid) == \\"NO\\" def test_orderly_parking_single_car(): m, n = 3, 3 grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert is_orderly_parking(m, n, grid) == \\"YES\\"","solution":"def is_orderly_parking(m, n, grid): Determines if the given parking lot grid is orderly according to the rules. Args: m (int): number of rows in the grid. n (int): number of columns in the grid. grid (list of list of ints): 2D grid representing the parking lot. Returns: str: \\"YES\\" if the parking lot is orderly, else \\"NO\\". # Check each row to ensure cars are parked contiguously for row in grid: found_car = False found_emptiness_after_car = False for cell in row: if cell == 1: if found_emptiness_after_car: return \\"NO\\" found_car = True elif cell == 0: if found_car: found_emptiness_after_car = True # Check each column to ensure cars are parked contiguously for col in range(n): found_car = False found_emptiness_after_car = False for row in range(m): if grid[row][col] == 1: if found_emptiness_after_car: return \\"NO\\" found_car = True elif grid[row][col] == 0: if found_car: found_emptiness_after_car = True return \\"YES\\""},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepth(root): Determine the minimum depth of the binary tree, which is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children. >>> minDepth(None) 0 >>> root = TreeNode(1) >>> minDepth(root) 1 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> minDepth(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> minDepth(root) 3 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> minDepth(root) 3 >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> minDepth(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> root.left.left.left = TreeNode(8) >>> minDepth(root) 3","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepth(root): if not root: return 0 queue = deque([(root, 1)]) # Start with the root node at depth 1 while queue: node, depth = queue.popleft() # Check if we have reached a leaf node if not node.left and not node.right: return depth # Add the children to the queue with incremented depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return 0"},{"question":"def max_absolute_difference(arr): Given an array of integers, find the maximum absolute difference between any two elements such that one element is smaller than the other and occurs before the other in the array. >>> max_absolute_difference([1, 2, 3]) == 2 >>> max_absolute_difference([1, -2, 3]) == 5 >>> max_absolute_difference([-1, -2, -3]) == 1 >>> max_absolute_difference([1000000000, -1000000000]) == 2000000000 >>> max_absolute_difference([5]) == 0 >>> max_absolute_difference([]) == 0 >>> max_absolute_difference([7, 1]) == 6 >>> max_absolute_difference([1, 5, 3, 10, 7]) == 9","solution":"def max_absolute_difference(arr): Given an array of integers, find the maximum absolute difference between any two elements such that one element is smaller than the other and occurs before the other in the array. if not arr: return 0 min_element = arr[0] max_diff = 0 for i in range(1, len(arr)): max_diff = max(max_diff, abs(arr[i] - min_element)) min_element = min(min_element, arr[i]) return max_diff"},{"question":"def countEqualSubstrings(s: str) -> int: Returns the number of substrings with equal numbers of 0s and 1s. >>> countEqualSubstrings(\\"00110011\\") 6 >>> countEqualSubstrings(\\"10101\\") 4","solution":"def countEqualSubstrings(s): Returns the number of substrings with equal numbers of 0s and 1s. count = 0 prev_run_length = 0 current_run_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_run_length += 1 else: prev_run_length = current_run_length current_run_length = 1 if prev_run_length >= current_run_length: count += 1 return count"},{"question":"from typing import List, Tuple def are_points_collinear(points: List[Tuple[int, int]]) -> bool: Determines if all given points lie on a straight line. >>> are_points_collinear([(0, 0), (1, 1), (2, 2), (3, 3)]) True >>> are_points_collinear([(0, 1), (2, 2), (3, 3)]) False Args: points (List[Tuple[int, int]]): List of points represented as tuples of two integers (x, y) Returns: bool: True if all points lie on a straight line, False otherwise.","solution":"from typing import List, Tuple def are_points_collinear(points: List[Tuple[int, int]]) -> bool: Determines if all given points lie on a straight line. Args: points (List[Tuple[int, int]]): List of points represented as tuples of two integers (x, y) Returns: bool: True if all points lie on a straight line, False otherwise. if len(points) < 2: return True # Less than 2 points are trivially collinear # Get the first two points to determine the reference slope (x0, y0), (x1, y1) = points[0], points[1] # We will use a cross product approach to avoid dealing with division and floating point errors. def cross_product(x0, y0, x1, y1, x2, y2): return (y1 - y0) * (x2 - x1) - (y2 - y1) * (x1 - x0) for i in range(2, len(points)): (xi, yi) = points[i] if cross_product(x0, y0, x1, y1, xi, yi) != 0: return False return True"},{"question":"def find_highest_frequency_card(n, cards): Returns the card number with the highest frequency. If there is a tie, returns the smallest card number among them. :param n: int, number of cards in the deck :param cards: list of int, card numbers :return: int, the card number with the highest frequency >>> find_highest_frequency_card(1, [7]) 7 >>> find_highest_frequency_card(5, [1, 2, 3, 4, 5]) 1 >>> find_highest_frequency_card(8, [4, 6, 4, 2, 4, 6, 6, 2]) 4 >>> find_highest_frequency_card(6, [1000000, 999999, 1000000, 999999, 1000000, 999999]) 999999 >>> find_highest_frequency_card(10, [5, 5, 1, 2, 2, 3, 6, 7, 7, 7]) 7 >>> find_highest_frequency_card(7, [3, 3, 3, 7, 7, 1, 2]) 3","solution":"def find_highest_frequency_card(n, cards): Returns the card number with the highest frequency. If there is a tie, returns the smallest card number among them. :param n: int, number of cards in the deck :param cards: list of int, card numbers :return: int, the card number with the highest frequency from collections import Counter card_counter = Counter(cards) max_frequency = max(card_counter.values()) # Find all card numbers with the highest frequency candidates = [card for card, freq in card_counter.items() if freq == max_frequency] # Return the smallest card number among them return min(candidates)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Return the sum of the values of the deepest leaves of the binary tree. Example 1: Input: 1 / 2 3 / 4 5 6 / 7 8 Output: 15 Explanation: Leaves 7 and 8 are located deepest, and their sum is 7 + 8 = 15. Example 2: Input: 1 / 2 3 / 4 5 Output: 9 Explanation: Leaves 4 and 5 are located deepest, and their sum is 4 + 5 = 9. from solution import TreeNode, deepestLeavesSum def test_deepest_leaves_sum_example_1(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.left.left.left = TreeNode(7) root.right.right.right = TreeNode(8) assert deepestLeavesSum(root) == 15 def test_deepest_leaves_sum_example_2(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert deepestLeavesSum(root) == 9 def test_deepest_leaves_sum_single_node(): root = TreeNode(1) assert deepestLeavesSum(root) == 1 def test_deepest_leaves_sum_empty_tree(): root = None assert deepestLeavesSum(root) == 0 def test_deepest_leaves_sum_skewed_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert deepestLeavesSum(root) == 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 for i in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"def minimal_cost_to_equalize(N: int, P: List[int], Q: List[int]) -> List[int]: Calculates the minimal cost to equalize the magical power of each plant type to the magical power of plant type 1. :param N: Integer, number of plant types :param P: List of integers, the magical power values of each plant type :param Q: List of integers, the nutrient absorption rates of each plant type :return: List of integers, the minimal cost for each plant type Examples: >>> minimal_cost_to_equalize(3, [10, 20, 30], [2, 3, 1]) [0, 30, 20] >>> minimal_cost_to_equalize(4, [15, 10, 20, 25], [1, 1, 2, 3]) [0, 5, 10, 30] >>> minimal_cost_to_equalize(3, [5, 5, 5], [1, 1, 1]) [0, 0, 0] >>> minimal_cost_to_equalize(2, [1000000000, 999999999], [1000000000, 1]) [0, 1] >>> minimal_cost_to_equalize(2, [1000000000, 0], [1, 1000000000]) [0, 1000000000000000000]","solution":"def minimal_cost_to_equalize(N, P, Q): Calculates the minimal cost to equalize the magical power of each plant type to the magical power of plant type 1. :param N: Integer, number of plant types :param P: List of integers, the magical power values of each plant type :param Q: List of integers, the nutrient absorption rates of each plant type :return: List of integers, the minimal cost for each plant type reference_power = P[0] costs = [] for i in range(N): cost = abs(P[i] - reference_power) * Q[i] costs.append(cost) return costs"},{"question":"def max_books_on_shelf(n: int, books: List[Tuple[int, int]]) -> int: Determine the maximum number of books that can be arranged on the shelf according to the rules. >>> max_books_on_shelf(5, [(3, 2), (1, 2), (2, 3), (4, 6), (5, 4)]) 3 >>> max_books_on_shelf(1, [(1, 2)]) 1 >>> max_books_on_shelf(3, [(3, 4), (2, 5), (1, 6)]) 1 >>> max_books_on_shelf(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_books_on_shelf(6, [(1, 2), (2, 1), (3, 5), (2, 3), (4, 4), (5, 6)]) 4","solution":"def max_books_on_shelf(n, books): # Sorting books by height and then by width books.sort() # Initialize DP array, each book can be a starting point dp = [1] * n # Find the longest increasing subsequence based on height and width for i in range(n): for j in range(i): if books[j][1] < books[i][1]: # width[j] < width[i] dp[i] = max(dp[i], dp[j] + 1) # The maximum value in dp array is the answer return max(dp)"},{"question":"import math def find_gcd_of_range(n: int, m: int) -> int: Returns the GCD of all numbers in the range [n, m], inclusive. >>> find_gcd_of_range(5, 5) 5 >>> find_gcd_of_range(2, 4) 1 >>> find_gcd_of_range(2, 12) 1 >>> find_gcd_of_range(12, 24) 12 >>> find_gcd_of_range(17, 17) 17 >>> find_gcd_of_range(8, 9) 1 >>> find_gcd_of_range(14, 15) 1","solution":"import math def find_gcd_of_range(n, m): Returns the GCD of all numbers in the range [n, m]. if n == m: return n # If the difference between m and n is greater than 1 # there is at least one pair of coprime numbers in the range # Thus, GCD will be 1 if m - n > 1: return 1 return math.gcd(n, m)"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determines if the string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if and only if at most one character has an odd frequency in the string. :param s: A string consisting of lowercase English letters. :return: True if the string is a palindrome permutation, False otherwise. >>> is_palindrome_permutation('civic') == True >>> is_palindrome_permutation('ivicc') == True >>> is_palindrome_permutation('hello') == False from solution import is_palindrome_permutation def test_palindrome_permutation_single_char(): assert is_palindrome_permutation('a') == True def test_palindrome_permutation_all_same_char(): assert is_palindrome_permutation('aaa') == True def test_palindrome_permutation_even_freq_chars(): assert is_palindrome_permutation('aabb') == True def test_palindrome_permutation_odd_freq_one_char(): assert is_palindrome_permutation('aab') == True def test_palindrome_permutation_odd_freq_multiple_chars(): assert is_palindrome_permutation('abc') == False def test_palindrome_permutation_example_1(): assert is_palindrome_permutation('civic') == True def test_palindrome_permutation_example_2(): assert is_palindrome_permutation('ivicc') == True def test_palindrome_permutation_example_3(): assert is_palindrome_permutation('hello') == False def test_palindrome_permutation_mixed_freq_chars(): assert is_palindrome_permutation('aabbccc') == True def test_palindrome_permutation_large_string(): assert is_palindrome_permutation('a' * 500 + 'b' * 499) == True","solution":"def is_palindrome_permutation(s): Determines if the string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if and only if at most one character has an odd frequency in the string. :param s: A string consisting of lowercase English letters. :return: True if the string is a palindrome permutation, False otherwise. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Check the number of characters with odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # At most one character should have an odd frequency for it to be a palindrome permutation return odd_count <= 1"},{"question":"def maxProfit(prices, k): Determine the maximum profit you can achieve from at most k transactions. A single transaction consists of buying on one day and selling on another, and you must buy before you can sell. You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Args: prices (List[int]): A list of integers representing stock prices for consecutive days. k (int): The maximum number of transactions. Returns: int: The maximum profit that can be achieved with at most k transactions. Examples: >>> maxProfit([3, 2, 6, 5, 0, 3], 1) 4 >>> maxProfit([3, 2, 6, 5, 0, 3], 2) 7 >>> maxProfit([1, 2, 4, 2, 5], 3) 6 def main(): import sys input = sys.stdin.read data = input().split() idx = 0 n = int(data[idx]) idx += 1 prices = list(map(int, data[idx:idx + n])) idx += n q = int(data[idx]) idx += 1 queries = [] for _ in range(q): queries.append(int(data[idx])) idx += 1 results = [] for k in queries: results.append(maxProfit(prices, k)) for result in results: print(result)","solution":"def maxProfit(prices, k): n = len(prices) # If no prices or k is zero if n == 0 or k == 0: return 0 # If k >= n/2, then it's the same as no transaction limit (Profit every up) if k >= n // 2: profit = 0 for i in range(1, n): if prices[i] > prices[i - 1]: profit += prices[i] - prices[i - 1] return profit # Initialize dp arrays # dp[i][j] represents the max profit up until prices[j] using at most i transactions. dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[k][n - 1] def main(): import sys input = sys.stdin.read data = input().split() idx = 0 n = int(data[idx]) idx += 1 prices = list(map(int, data[idx:idx + n])) idx += n q = int(data[idx]) idx += 1 queries = [] for _ in range(q): queries.append(int(data[idx])) idx += 1 results = [] for k in queries: results.append(maxProfit(prices, k)) for result in results: print(result)"},{"question":"def split_array(nums: List[int], k: int) -> int: Divide the array into k contiguous subarrays such that the sum of the largest sums of these subarrays is minimized. >>> split_array([10, 20, 30, 40], 2) 60 >>> split_array([10], 1) 10 >>> split_array([10, 10, 10, 10], 2) 20 >>> split_array([7, 2, 5, 10, 8], 5) 10 >>> split_array([0, 0, 0, 0], 2) 0 >>> split_array([1, 2147483647], 2) 2147483647 >>> split_array([1, 2, 3, 4, 5], 2) 9","solution":"def split_array(nums, k): def is_valid(mid): current_sum = 0 required_subarrays = 1 for num in nums: if current_sum + num <= mid: current_sum += num else: required_subarrays += 1 current_sum = num if required_subarrays > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if is_valid(mid): right = mid else: left = mid + 1 return left"},{"question":"def find_pair(arr: List[int], target: int) -> Optional[Tuple[int, int]]: Determines if there are two distinct integers in the array whose difference is equal to the given target. Args: arr: List[int] - An array of integers target: int - An integer target Returns: Optional[Tuple[int, int]] - A tuple of two integers representing the indices of the two distinct integers or None Examples: >>> find_pair([1, 2, 3, 4, 5], 3) (0, 3) >>> find_pair([10, 7, 5, 3, 1], 4) (1, 4) >>> find_pair([1, 5, 9], 10) None","solution":"def find_pair(arr, target): Determines if there are two distinct integers in the array whose difference is equal to the given target. If such a pair exists, return the pair as a tuple of their indices. If there are multiple pairs, return any one of them. If no such pair exists, return None. seen = {} for i, num in enumerate(arr): if (num - target) in seen: return (seen[num - target], i) if (num + target) in seen: return (seen[num + target], i) seen[num] = i return None"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def find_minimum_edges_to_add(N: int, M: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of edges that need to be added to make the graph fully connected. Args: N : int : Number of nodes M : int : Number of edges edges : List[Tuple[int, int]] : List of edges represented as tuples Returns: int : Minimum number of edges to add >>> find_minimum_edges_to_add(6, 3, [(1, 2), (2, 3), (3, 4)]) 2 >>> find_minimum_edges_to_add(1, 0, []) 0 >>> find_minimum_edges_to_add(4, 0, []) 3 >>> find_minimum_edges_to_add(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 0 >>> find_minimum_edges_to_add(5, 2, [(1, 2), (3, 4)]) 2 >>> find_minimum_edges_to_add(6, 4, [(1, 2), (2, 3), (4, 5)]) 2","solution":"def find_minimum_edges_to_add(N, M, edges): from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(node, visited): queue = deque([node]) visited[node] = True while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) visited = [False] * (N + 1) components = 0 for node in range(1, N + 1): if not visited[node]: bfs(node, visited) components += 1 return components - 1 # Example usage # N, M = 6, 3 # edges = [(1, 2), (2, 3), (3, 4)] # print(find_minimum_edges_to_add(N, M, edges)) # Output: 2"},{"question":"def sort_tasks(test_cases): Takes a list of test cases and returns the sorted tasks for each test case. Arguments: test_cases -- list of tuples, each containing the number of tasks and a list of (priority, duration) tuples Returns: List of strings representing the sorted tasks for each test case in the required format. pass def parse_input(input_string): Parses the input string into test cases. Arguments: input_string -- string representing the input in the described format Returns: List of tuples representing the test cases. Each tuple contains the number of tasks and a list of (priority, duration) tuples pass def format_output(results): Formats the sorted tasks into the required output format. Arguments: results -- list of strings representing the sorted tasks for each test case Returns: A formatted string representing the sorted tasks for all test cases, separated by newlines. pass # Unit Tests def test_sort_tasks(): input_str = \\"2n3n3 200n2 400n2 100n2n1 500n1 300n\\" test_cases = parse_input(input_str) result = sort_tasks(test_cases) formatted_result = format_output(result) expected_output = \\"(2, 100); (2, 400); (3, 200)n(1, 300); (1, 500)\\" assert formatted_result == expected_output def test_sort_single_task(): input_str = \\"1n1n5 600n\\" test_cases = parse_input(input_str) result = sort_tasks(test_cases) formatted_result = format_output(result) expected_output = \\"(5, 600)\\" assert formatted_result == expected_output def test_sort_multiple_tasks_same_priority(): input_str = \\"1n3n3 200n3 100n3 400n\\" test_cases = parse_input(input_str) result = sort_tasks(test_cases) formatted_result = format_output(result) expected_output = \\"(3, 100); (3, 200); (3, 400)\\" assert formatted_result == expected_output def test_parse_input(): input_str = \\"2n3n3 200n2 400n2 100n2n1 500n1 300n\\" expected_output = [ (3, [(3, 200), (2, 400), (2, 100)]), (2, [(1, 500), (1, 300)]) ] assert parse_input(input_str) == expected_output def test_format_output(): input_list = [\\"(2, 100); (2, 400); (3, 200)\\", \\"(1, 300); (1, 500)\\"] expected_output = \\"(2, 100); (2, 400); (3, 200)n(1, 300); (1, 500)\\" assert format_output(input_list) == expected_output","solution":"def sort_tasks(test_cases): Takes a list of test cases and returns the sorted tasks for each test case. Arguments: test_cases -- list of tuples, each containing the number of tasks and a list of (priority, duration) tuples Returns: List of strings representing the sorted tasks for each test case in the required format. results = [] for num_tasks, tasks in test_cases: sorted_tasks = sorted(tasks, key=lambda x: (x[0], x[1])) formatted_tasks = \\"; \\".join([f\\"({p}, {d})\\" for p, d in sorted_tasks]) results.append(formatted_tasks) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 tasks = [] for _ in range(N): p, d = map(int, lines[index].split()) index += 1 tasks.append((p, d)) test_cases.append((N, tasks)) return test_cases def format_output(results): return \\"n\\".join(results)"},{"question":"def can_be_sorted_with_one_reverse(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if an array can be sorted with at most one reverse operation. Args: T : int - Number of test cases. test_cases : List[Tuple[int, List[int]]] - A list of test cases, where each test case is a tuple containing: - An integer N, the size of the array. - A list of N integers, the array elements. Returns: List[str] - For each test case, \\"YES\\" if the array can be sorted with at most one reverse operation, otherwise \\"NO\\". >>> can_be_sorted_with_one_reverse(4, [(5, [1, 2, 5, 4, 3]), (4, [4, 3, 2, 1]), (3, [1, 2, 3]), (6, [1, 3, 5, 2, 4, 6])]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> can_be_sorted_with_one_reverse(1, [(1, [10])]) [\\"YES\\"] >>> can_be_sorted_with_one_reverse(1, [(5, [2, 4, 6, 8, 10])]) [\\"YES\\"] >>> can_be_sorted_with_one_reverse(1, [(5, [1, 2, 3, 5, 4])]) [\\"YES\\"] >>> can_be_sorted_with_one_reverse(1, [(5, [10, 1, 20, 2, 30])]) [\\"NO\\"] >>> can_be_sorted_with_one_reverse(2, [(4, [1, 2, 4, 3]), (5, [2, 1, 3, 5, 6])]) [\\"YES\\", \\"YES\\"]","solution":"def can_be_sorted_with_one_reverse(T, test_cases): results = [] for case in test_cases: n, array = case sorted_array = sorted(array) l = 0 while l < n and array[l] == sorted_array[l]: l += 1 r = n - 1 while r >= 0 and array[r] == sorted_array[r]: r -= 1 if l >= r: results.append(\\"YES\\") else: if array[l:r + 1] == sorted_array[l:r + 1][::-1]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def rotate_matrix_90_degrees(matrix): Rotate the given N x N matrix 90 degrees to the right. >>> rotate_matrix_90_degrees([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def rotate_matrix(matrix, k): Rotate the given N x N matrix 90 degrees to the right k times. >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) [[9, 8, 7], [6, 5, 4], [3, 2, 1]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) [[3, 6, 9], [2, 5, 8], [1, 4, 7]] def solve_game_configuration(n, l, initial_matrix, levels): Given the size of the matrix n, the number of levels l, the initial configuration of the matrix, and a list of levels containing the number of 90-degree right rotations per level, return the final configuration of the matrix for each level. >>> solve_game_configuration(3, 2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [2, 3]) [[[9, 8, 7], [6, 5, 4], [3, 2, 1]], [[3, 6, 9], [2, 5, 8], [1, 4, 7]]]","solution":"def rotate_matrix_90_degrees(matrix): n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated def rotate_matrix(matrix, k): rotations = k % 4 # As 4 rotations bring the matrix to the initial state for _ in range(rotations): matrix = rotate_matrix_90_degrees(matrix) return matrix def solve_game_configuration(n, l, initial_matrix, levels): results = [] for k in levels: rotated_matrix = rotate_matrix(initial_matrix, k) results.append(rotated_matrix) return results # Input example processing def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) l = int(data[1]) initial_matrix = [] index = 2 for i in range(n): row = list(map(int, data[index:index + n])) initial_matrix.append(row) index += n levels = [] for i in range(l): levels.append(int(data[index])) index += 1 results = solve_game_configuration(n, l, initial_matrix, levels) for result in results: for row in result: print(' '.join(map(str, row))) print() if __name__ == \\"__main__\\": main()"},{"question":"def final_top_scores(scores, updates): Sarah is organizing a programming contest. She has the results of the contest submitted by participants. The results are provided in an array of integers \`scores\` where each integer represents the score given by a participant. Each participant can provide any integer score (both positive and negative). However, the event rules provide that once the competition is over, all non-positive scores should be removed from the results. Sarah also wants to be able to quickly determine the highest score at any point after removing the non-positive scores. This process needs to be efficient because it might be executed multiple times. Args: scores: List[int] - List of initial scores which might include non-positive values. updates: List[tuple] - List of updates, where each update is a tuple (type, value). Returns: List[int] - List of highest scores after each \\"query\\" type update. Example: >>> final_top_scores([5, -1, 3, 10, -4, 0], [(\\"query\\", 0), (\\"add\\", 7), (\\"query\\", 0), (\\"add\\", -2), (\\"query\\", 0)]) [10, 10, 10] >>> final_top_scores([], [(\\"query\\", 0), (\\"add\\", 5), (\\"query\\", 0), (\\"add\\", 10), (\\"query\\", 0)]) [0, 5, 10] >>> final_top_scores([12, 15, 2], [(\\"query\\", 0), (\\"add\\", -5), (\\"query\\", 0), (\\"add\\", 20), (\\"query\\", 0)]) [15, 15, 20] >>> final_top_scores([1, 2, 3], [(\\"query\\", 0), (\\"query\\", 0), (\\"query\\", 0)]) [3, 3, 3] >>> final_top_scores([-5, -10, -1], [(\\"query\\", 0), (\\"add\\", -45), (\\"query\\", 0), (\\"add\\", 0), (\\"query\\", 0)]) [0, 0, 0]","solution":"def final_top_scores(scores, updates): Returns the highest scores after each query in the updates. scores: List[int] - List of initial scores which might include non-positive values. updates: List[tuple] - List of updates, where each update is a tuple (\\"type\\", value). return: List[int] - List of highest scores after each \\"query\\" type update. # Filter out non-positive scores valid_scores = [score for score in scores if score > 0] valid_scores.sort(reverse=True) # Sort in descending order for easier max query results = [] for update in updates: operation, value = update if operation == \\"add\\": if value > 0: # insert maintaining sorted order index = 0 while index < len(valid_scores) and valid_scores[index] > value: index += 1 valid_scores.insert(index, value) elif operation == \\"query\\": if valid_scores: results.append(valid_scores[0]) else: results.append(0) # if there's no positive score return results"},{"question":"def shift_string(input_str: str, n: int) -> str: Shifts each character in the input_str by n positions in the alphabet. If n is positive, shift to the right, and if n is negative, shift to the left. Non-alphabetic characters remain unchanged. :param input_str: str - The string to be shifted :param n: int - The number of positions to shift :return: str - The encoded string after shifting >>> shift_string('abc', 1) 'bcd' >>> shift_string('xyz', 2) 'zab' >>> shift_string('abc', -1) 'zab' >>> shift_string('xyz', -3) 'uvw'","solution":"def shift_string(input_str, n): Shifts each character in the input_str by n positions in the alphabet. :param input_str: str - The string to be shifted :param n: int - The number of positions to shift :return: str - The encoded string after shifting shifted_str = [] alphabet = 'abcdefghijklmnopqrstuvwxyz' for char in input_str: if char in alphabet: old_index = alphabet.index(char) new_index = (old_index + n) % 26 shifted_str.append(alphabet[new_index]) else: shifted_str.append(char) # non-alphabetic characters are unchanged return ''.join(shifted_str)"},{"question":"def is_prime(num: int) -> bool: Helper function to determine if a number is a prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(10) False >>> is_prime(11) True def sum_of_primes(n: int) -> int: Returns the sum of all prime numbers less than or equal to n. >>> sum_of_primes(2) 2 >>> sum_of_primes(10) 17 >>> sum_of_primes(20) 77 >>> sum_of_primes(1) 0 >>> sum_of_primes(1000) 76127","solution":"def is_prime(num): Helper function to determine if a number is a prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to n. return sum(num for num in range(2, n + 1) if is_prime(num))"},{"question":"def toggle_bulbs(n: int) -> List[int]: Determines which bulbs are on after performing the sequence of operations. :param n: integer, number of bulbs :return: list of integers, 1 if the bulb is on, 0 if it is off >>> toggle_bulbs(3) [1, 0, 0] >>> toggle_bulbs(5) [1, 0, 0, 1, 0] >>> toggle_bulbs(6) [1, 0, 0, 1, 0, 0] pass","solution":"def toggle_bulbs(n): Determines which bulbs are on after performing the sequence of operations. :param n: integer, number of bulbs :return: list of integers, 1 if the bulb is on, 0 if it is off bulbs = [0] * n for k in range(1, n + 1): for i in range(k - 1, n, k): bulbs[i] = 1 - bulbs[i] return bulbs"},{"question":"def max_non_overlapping_lectures(n, lectures): Given n lectures with their start and end times, return the maximum number of non-overlapping lectures that can be attended. :param n: int, the number of lectures :param lectures: List[Tuple[int, int]], a list of tuples where each tuple contains the start and end time of a lecture :return: int, the maximum number of non-overlapping lectures >>> max_non_overlapping_lectures(3, [(1, 2), (2, 3), (3, 4)]) 3 >>> max_non_overlapping_lectures(4, [(1, 3), (2, 4), (3, 5), (4, 6)]) 2","solution":"def max_non_overlapping_lectures(n, lectures): Given n lectures with their start and end times, return the maximum number of non-overlapping lectures that can be attended. :param n: int, the number of lectures :param lectures: List[Tuple[int, int]], a list of tuples where each tuple contains the start and end time of a lecture :return: int, the maximum number of non-overlapping lectures # Sort lectures by end time lectures.sort(key=lambda x: x[1]) count = 0 end_time = 0 for start, end in lectures: if start >= end_time: count += 1 end_time = end return count"},{"question":"def formSmallestNumber(arr, n): Returns the smallest number that can be formed by rearranging the elements of the array. >>> formSmallestNumber([3, 1, 4, 1, 5, 9], 6) == \\"113459\\" >>> formSmallestNumber([0, 0, 1], 3) == \\"001\\"","solution":"def formSmallestNumber(arr, n): Returns the smallest number that can be formed by rearranging the elements of the array. arr.sort() # Sort the array return ''.join(map(str, arr)) # Convert each element to string and join them"},{"question":"def find_smallest_number(n: int) -> int: Finds the smallest positive integer m such that the product of the digits of m is equal to n. If no such number exists, returns -1. >>> find_smallest_number(10) 25 >>> find_smallest_number(22) -1 >>> find_smallest_number(100) 455 >>> find_smallest_number(1) 1","solution":"def find_smallest_number(n): Finds the smallest positive integer m such that the product of the digits of m is equal to n. If no such number exists, returns -1. if n == 1: return 1 # To store the factors of n from 9 to 1 factors = [] # Try to divide n by all integers from 9 to 2 for i in range(9, 1, -1): while n % i == 0: n = n // i factors.append(i) # If n is not 1, then it's not possible to represent n as a product of digits if n != 1: return -1 # Combine the factors to form the smallest number factors.sort() result = int(''.join(map(str, factors))) return result"},{"question":"def find_pythagorean_triplet(k: int) -> tuple: Given a positive integer k, generate the smallest Pythagorean triplet (a, b, c) such that a^2 + b^2 = c^2 and a = k. If no such triplet exists, return (-1, -1, -1). >>> find_pythagorean_triplet(3) (3, 4, 5) >>> find_pythagorean_triplet(2) (-1, -1, -1) >>> find_pythagorean_triplet(5) (5, 12, 13)","solution":"def find_pythagorean_triplet(k): Given a positive integer k, generate the smallest Pythagorean triplet (a, b, c) such that a^2 + b^2 = c^2 and a = k. If no such triplet exists, return (-1, -1, -1). if k <= 0: return (-1, -1, -1) # Pythagorean triplet where k is one of the two smaller legs if k == 1: return (-1, -1, -1) elif k == 2: return (-1, -1, -1) elif k % 2 == 0: m = k // 2 n = 1 a = k b = m**2 - n**2 c = m**2 + n**2 else: m = (k + 1) // 2 n = (k - 1) // 2 a = k b = 2 * m * n c = m**2 + n**2 return (a, b, c)"},{"question":"def count_landmasses(n: int, m: int, grid: List[List[str]]) -> int: Count distinct landmasses in the grid. A \\"landmass\\" is a contiguous group of land cells ('L') that are connected horizontally or vertically. The function returns the number of distinct landmasses. Args: n (int): Number of rows. m (int): Number of columns. grid (List[List[str]]): The grid representing the map where each cell is either 'W' or 'L'. >>> count_landmasses(5, 5, [ ... ['L', 'W', 'W', 'L', 'L'], ... ['L', 'W', 'L', 'W', 'L'], ... ['W', 'W', 'W', 'L', 'L'], ... ['L', 'W', 'L', 'W', 'W'], ... ['L', 'L', 'L', 'L', 'W'] ... ]) 4 >>> count_landmasses(3, 3, [ ... ['W', 'W', 'W'], ... ['W', 'W', 'W'], ... ['W', 'W', 'W'] ... ]) 0 >>> count_landmasses(3, 3, [ ... ['L', 'L', 'L'], ... ['L', 'L', 'L'], ... ['L', 'L', 'L'] ... ]) 1 >>> count_landmasses(3, 3, [ ... ['L', 'W', 'L'], ... ['W', 'L', 'W'], ... ['L', 'W', 'L'] ... ]) 5 >>> count_landmasses(3, 1, [ ... ['W'], ... ['L'], ... ['W'] ... ]) 1 >>> count_landmasses(2, 2, [ ... ['L', 'W'], ... ['W', 'L'] ... ]) 2","solution":"def count_landmasses(n, m, grid): def dfs(x, y): # If out of bounds; or it's water or already visited, return. if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != 'L': return # Mark the cell as visited by changing 'L' to something else, e.g., '#' grid[x][y] = '#' # Move in four possible directions dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) landmasses = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L': # found an unvisited land landmasses += 1 dfs(i, j) return landmasses"},{"question":"def kth_smallest_after_removing_duplicates(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Given an array of integers and a positive integer k, find the k-th smallest integer in the array after removing all duplicate values for each test case. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple contains: - an integer n (number of elements in the array) - an integer k (the position of the smallest integer to find) - a list of n integers Returns: List[int]: A list with the k-th smallest integer for each test case after removing duplicates. If k is larger than the number of unique elements, return -1 for that test case. >>> kth_smallest_after_removing_duplicates(2, [(5, 3, [4, 2, 7, 2, 5]), (6, 2, [1, 1, 2, 2, 3, 3])]) [5, 2] >>> kth_smallest_after_removing_duplicates(1, [(4, 2, [1, 2, 3, 4])]) [2] >>> kth_smallest_after_removing_duplicates(1, [(5, 1, [1, 1, 1, 1, 1])]) [1] >>> kth_smallest_after_removing_duplicates(1, [(5, 6, [1, 2, 3, 4, 5])]) [-1] >>> kth_smallest_after_removing_duplicates(1, [(6, 3, [9, 8, 7, 8, 9, 7])]) [9] >>> kth_smallest_after_removing_duplicates(1, [(1, 1, [10])]) [10]","solution":"def kth_smallest_after_removing_duplicates(t, test_cases): Given an array of integers and a positive integer k, find the k-th smallest integer in the array after removing all duplicate values for each test case. Parameters: t (int): Number of test cases. test_cases (list): A list of tuples where each tuple contains: - an integer n (number of elements in the array) - an integer k (the position of the smallest integer to find) - a list of n integers Returns: list: A list with the k-th smallest integer for each test case after removing duplicates. If k is larger than the number of unique elements, return -1 for that test case. results = [] for n, k, array in test_cases: unique_elements = sorted(set(array)) if k > len(unique_elements): results.append(-1) else: results.append(unique_elements[k-1]) return results"},{"question":"def update_donations(initial_donations, new_donations): Updates the donation record with new donations. Parameters: initial_donations (list of tuples): Each tuple contains a donor name and their initial donation amount. new_donations (list of tuples): Each tuple contains a donor name and their new donation amount. Returns: list of tuples: Updated donation record sorted lexicographically by donor names. >>> update_donations([(\\"Alice\\", 50), (\\"Bob\\", 30), (\\"Charlie\\", 20)], [(\\"Bob\\", 25), (\\"Alice\\", 10)]) [('Alice', 60), ('Bob', 55), ('Charlie', 20)] >>> update_donations([(\\"David\\", 100), (\\"Eva\\", 150)], [(\\"David\\", 50), (\\"Eva\\", 50), (\\"John\\", 200)]) [('David', 150), ('Eva', 200), ('John', 200)]","solution":"def update_donations(initial_donations, new_donations): Updates the donation record with new donations. Parameters: initial_donations (list of tuples): Each tuple contains a donor name and their initial donation amount. new_donations (list of tuples): Each tuple contains a donor name and their new donation amount. Returns: list of tuples: Updated donation record sorted lexicographically by donor names. donation_record = {} # Update donation record with initial donations for name, amount in initial_donations: donation_record[name] = amount # Update donation record with new donations for name, amount in new_donations: if name in donation_record: donation_record[name] += amount else: donation_record[name] = amount # Convert the donation record to a sorted list of tuples sorted_donation_record = sorted(donation_record.items()) return sorted_donation_record"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Determine if two given strings are anagrams of each other. The comparison is case-insensitive and ignores spaces. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"Triangle\\", \\"Integral\\") True >>> is_anagram(\\"apple\\", \\"pale\\") False >>> is_anagram(\\"Dormitory\\", \\"Dirty room\\") True >>> is_anagram(\\"School master\\", \\"The classroom\\") True","solution":"def is_anagram(s1: str, s2: str) -> bool: Determine if two given strings are anagrams of each other. The comparison is case-insensitive and ignores spaces. s1 = ''.join(s1.split()).lower() s2 = ''.join(s2.split()).lower() return sorted(s1) == sorted(s2)"},{"question":"def max_cards(threshold: int) -> int: Determine the maximum number of cards that can be picked consecutively such that their ranks' sum is less than or equal to the given threshold. Args: threshold (int): The sum threshold. Returns: int: The maximum number of cards that can be picked. >>> max_cards(10) 4 >>> max_cards(15) 5 >>> max_cards(5) 2 >>> max_cards(1) 1 >>> max_cards(0) 0 >>> max_cards(36) 8 def process_test_cases(test_cases: List[int]) -> List[int]: Process a list of test cases to find the maximum number of cards for each threshold. Args: test_cases (List[int]): A list of threshold sums. Returns: List[int]: A list of results with the maximum number of cards that can be picked for each threshold. >>> process_test_cases([10, 15, 5]) [4, 5, 2] >>> process_test_cases([7, 1, 21]) [3, 1, 6] >>> process_test_cases([0, 13, 30]) [0, 4, 7]","solution":"def max_cards(threshold): Determine the maximum number of cards that can be picked consecutively such that their ranks' sum is less than or equal to the threshold. total_sum = 0 count = 0 for rank in range(1, 14): if total_sum + rank <= threshold: total_sum += rank count += 1 else: break return count def process_test_cases(test_cases): results = [] for threshold in test_cases: results.append(max_cards(threshold)) return results"},{"question":"def determine_profitable_week(T, sales_data): Determines if each week is profitable based on the sales data. Parameters: T (int): number of test cases. sales_data (list of list of int): list containing sales data for each test case. Returns: list of str: List of \\"YES\\" or \\"NO\\" indicating if the week was profitable. >>> determine_profitable_week(3, [[20, 25, 15, 10, 30, 15, 10], [10, 10, 10, 10, 10, 10, 10], [50, 40, 30, 20, 10, 5, 3]]) ['NO', 'NO', 'YES'] >>> determine_profitable_week(1, [[0, 0, 0, 0, 0, 0, 0]]) ['NO'] >>> determine_profitable_week(1, [[10, 10, 10, 10, 10, 20, 30]]) ['NO'] >>> determine_profitable_week(1, [[25, 25, 25, 25, 10, 5, 5]]) ['YES'] >>> determine_profitable_week(1, [[14, 15, 16, 17, 18, 19, 12]]) ['YES']","solution":"def determine_profitable_week(T, sales_data): Determines if each week is profitable based on the sales data. Parameters: T (int): number of test cases. sales_data (list of list of int): list containing sales data for each test case. Returns: list of str: List of \\"YES\\" or \\"NO\\" indicating if the week was profitable. results = [] for sales in sales_data: if sum(sales) > 100: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple, Union def kingdom_path(n: int, m: int, roads: List[str]) -> Union[int, Tuple[int, List[int]]]: Finds the shortest possible path the king must travel through from Town 1 to Town n, without re-using any road. If there is no possible route, returns -1. Args: n (int): The number of towns. m (int): The number of direct roads. roads (List[str]): The list of roads where each road is represented as a string \\"u v\\" indicating a direct road between town u and town v. Returns: Union[int, Tuple[int, List[int]]]: If there's a path, returns a tuple where the first element is the minimum number of roads the king must travel through and the second element is the list of towns visited in order. If no such route exists, returns -1. >>> kingdom_path(5, 5, [\\"1 2\\", \\"2 3\\", \\"3 4\\", \\"4 5\\", \\"1 5\\"]) (1, [1, 5]) >>> kingdom_path(5, 3, [\\"1 2\\", \\"2 3\\", \\"4 5\\"]) -1","solution":"from collections import deque, defaultdict def shortest_path(n, roads): adj_list = defaultdict(list) for u, v in roads: adj_list[u].append(v) adj_list[v].append(u) dist = [-1] * (n + 1) parent = [-1] * (n + 1) dist[1] = 0 q = deque([1]) while q: u = q.popleft() for v in adj_list[u]: if dist[v] == -1: dist[v] = dist[u] + 1 parent[v] = u q.append(v) if v == n: q = deque() break if dist[n] == -1: return -1, [] path = [] current = n while current != -1: path.append(current) current = parent[current] path.reverse() return dist[n], path def kingdom_path(n, m, roads): if m == 0: return -1 roads_list = [] for road in roads: u, v = map(int, road.split()) roads_list.append((u, v)) dist, path = shortest_path(n, roads_list) if dist == -1: return -1 return dist, path"},{"question":"def countPrimeFactorsInFactorial(N: int) -> int: Given a positive integer N, count how many prime numbers are present in the factorial of N. Return the result modulo 10^9 + 7. >>> countPrimeFactorsInFactorial(5) 3 >>> countPrimeFactorsInFactorial(10) 4 >>> countPrimeFactorsInFactorial(1) 0","solution":"def countPrimeFactorsInFactorial(N): Returns the count of distinct prime numbers in the factorial of N modulo 10^9 + 7. MOD = 10**9 + 7 def sieve(n): is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, n + 1) if is_prime[p]] return prime_numbers primes = sieve(N) return len(primes) % MOD"},{"question":"def generate_frequencies(T: int, test_cases: list) -> list: Generate frequency values for all houses in the sequence, including the Baseline House. Args: T: int - number of test cases. test_cases: list of tuples - each tuple contains three integers: 'n' (number of houses on one side of the Baseline House), 'B' (frequency of the Baseline House), 'd' (common difference of the sequence). Returns: list of lists - each list contains frequency values in the sequence in increasing order. Example: >>> generate_frequencies(3, [(2, 10, 3), (3, 5, 2), (1, 15, 1)]) [[4, 7, 10, 13, 16], [-1, 1, 3, 5, 7, 9, 11], [14, 15, 16]] >>> generate_frequencies(1, [(1, 100, 10)]) [[90, 100, 110]]","solution":"def generate_frequencies(T, test_cases): results = [] for i in range(T): n, B, d = test_cases[i] frequencies = [] for j in range(-n, n + 1): frequencies.append(B + j * d) results.append(sorted(frequencies)) return results"},{"question":"def num_connected_components(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the number of connected components in the galaxy's communication network. >>> num_connected_components(4, 2, [(1, 2), (3, 4)]) 2 >>> num_connected_components(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> num_connected_components(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 1","solution":"def num_connected_components(n, m, edges): from collections import defaultdict # Build adjacency list graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) count = 0 for node in range(1, n + 1): if node not in visited: visited.add(node) dfs(node) count += 1 return count"},{"question":"def minDeletionsToPalindrome(s: str) -> int: Returns the minimum number of deletions needed to make the given string a palindrome. >>> minDeletionsToPalindrome(\\"abccba\\") 0 >>> minDeletionsToPalindrome(\\"abcdba\\") 1 >>> minDeletionsToPalindrome(\\"abcde\\") 4 >>> minDeletionsToPalindrome(\\"aebcbda\\") 2 >>> minDeletionsToPalindrome(\\"racecar\\") 0 pass","solution":"def minDeletionsToPalindrome(s: str) -> int: Returns the minimum number of deletions needed to make the given string a palindrome. # Longest Palindromic Subsequence (LPS) problem n = len(s) dp = [[0] * n for _ in range(n)] # Initialize the dp array for single character palindromes for i in range(n): dp[i][i] = 1 # Fill the dp array for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) # The longest palindromic subsequence length is found in dp[0][n-1] lps_length = dp[0][n-1] # Minimum deletions to make the string a palindrome is # the length of the string minus the length of the longest palindromic subsequence return n - lps_length"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], target: int) -> str: Determines if there are two distinct integers in the array that add up to the target integer. Args: arr (List[int]): The list of integers. target (int): The target integer. Returns: str: \\"YES\\" if there are two distinct integers in the array that add up to the target integer, otherwise \\"NO\\". Examples: >>> has_pair_with_sum([2, 7, 11, 15, 1], 9) 'YES' >>> has_pair_with_sum([3, 6, 4, 8], 10) 'YES' >>> has_pair_with_sum([1, 5, 3, 6], 12) 'NO' pass","solution":"def has_pair_with_sum(arr, target): Determines if there are two distinct integers in the array that add up to the target integer. seen = set() for number in arr: if target - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def check_blacklist(blacklist: List[str], applicants: List[str]) -> List[bool]: Check if any applicant's name exactly matches a name on the blacklist. Parameters: - blacklist (list of str): List of blacklisted names. - applicants (list of str): List of loan applicant names. Returns: - list of bool: List indicating whether each applicant is blacklisted. >>> check_blacklist([\\"John Doe\\", \\"Jane Smith\\", \\"Emily Davis\\"], [\\"Alice Johnson\\", \\"Jane Smith\\", \\"Chris Brown\\", \\"Emily Davis\\", \\"Johnathan Doe\\"]) [False, True, False, True, False] >>> check_blacklist([\\"A B\\", \\"C D\\"], [\\"A B\\", \\"B A\\", \\"C D\\", \\"D C\\"]) [True, False, True, False] # Implement your solution here pass","solution":"def check_blacklist(blacklist, applicants): This function checks if each applicant is on the blacklist. Parameters: - blacklist (list of str): List of blacklisted names. - applicants (list of str): List of applicant names. Returns: - list of bool: List indicating whether each applicant is blacklisted. blacklist_set = set(blacklist) return [applicant in blacklist_set for applicant in applicants]"},{"question":"def min_operations_to_equal_elements(n: int, A: List[int]) -> int: Returns the minimum number of operations to make all elements of the array equal. >>> min_operations_to_equal_elements(4, [1, 1, 2, 2]) 2 >>> min_operations_to_equal_elements(3, [1, 2, 3]) 2 >>> min_operations_to_equal_elements(5, [5, 5, 5, 5, 5]) 0 >>> min_operations_to_equal_elements(2, [1, 10]) 9 >>> min_operations_to_equal_elements(1, [0]) 0 >>> min_operations_to_equal_elements(5, [-1, -1, 0, 1, 1]) 4 >>> min_operations_to_equal_elements(4, [-1000000000, 0, 1000000000, 1000000000]) 3000000000","solution":"def min_operations_to_equal_elements(n, A): Returns the minimum number of operations to make all elements of the array equal. # Sort the array to find the median more directly A.sort() # Choose the median as the target element for minimum operations median = A[n // 2] # Calculate total number of operations operations = sum(abs(x - median) for x in A) return operations"},{"question":"def longest_even_char_substring_length(s: str) -> int: Find the length of the longest substring where each character appears an even number of times. >>> longest_even_char_substring_length(\\"aabbcc\\") == 6 >>> longest_even_char_substring_length(\\"abcdabcd\\") == 8 >>> longest_even_char_substring_length(\\"abc\\") == 0 >>> longest_even_char_substring_length(\\"abbaaccbbaa\\") == 10 >>> longest_even_char_substring_length(\\"\\") == 0 >>> longest_even_char_substring_length(\\"aaaaa\\") == 4 >>> longest_even_char_substring_length(\\"a\\" * 100000) == 100000 pass","solution":"def longest_even_char_substring_length(s): Find the length of the longest substring where each character appears an even number of times. n = len(s) mask = 0 first_occurrence = {mask: -1} max_length = 0 for i in range(n): mask ^= 1 << (ord(s[i]) - ord('a')) if mask in first_occurrence: max_length = max(max_length, i - first_occurrence[mask]) else: first_occurrence[mask] = i return max_length"},{"question":"def diamond_pattern(N: int) -> None: Generates and prints the diamond pattern for a given odd integer N. pass def produce_diamonds(T: int, cases: List[int]) -> None: Produces the diamond patterns for multiple test cases. >>> cases = [5] >>> T = len(cases) >>> produce_diamonds(T, cases) * *** ***** *** * >>> cases = [3, 5] >>> T = len(cases) >>> produce_diamonds(T, cases) * *** * * *** ***** *** * pass","solution":"def diamond_pattern(N): Generates and prints the diamond pattern for a given odd integer N. # Upper half including middle line for i in range(N // 2 + 1): line = ' ' * (N // 2 - i) + '*' * (2 * i + 1) print(line) # Lower half below the middle line for i in range(N // 2 - 1, -1, -1): line = ' ' * (N // 2 - i) + '*' * (2 * i + 1) print(line) def produce_diamonds(T, cases): Produces the diamond patterns for multiple test cases. for i in range(T): diamond_pattern(cases[i]) if i < T - 1: print() # Example of how to run the function for the given input T = 1 cases = [5] produce_diamonds(T, cases)"},{"question":"from typing import List, Tuple def possible_to_assign_colors(n: int, m: int, lights: List[int], restrictions: List[Tuple[int, int]]) -> str: Determine if it's possible to assign colors to all the lights such that no two adjacent lights have the same color. Args: n (int): the number of lights m (int): the number of colors lights (List[int]): positions of the lights restrictions (List[Tuple[int, int]]): pairs of positions that can't have the same color Returns: str: \\"YES\\" if it's possible to assign colors accordingly, \\"NO\\" otherwise Example: >>> possible_to_assign_colors(5, 3, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) \\"NO\\" >>> possible_to_assign_colors(4, 3, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) \\"YES\\" def test_possible_to_assign_colors_case1(): n, m = 5, 3 lights = [1, 2, 3, 4, 5] restrictions = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] assert possible_to_assign_colors(n, m, lights, restrictions) == \\"NO\\" def test_possible_to_assign_colors_case2(): n, m = 4, 3 lights = [1, 2, 3, 4] restrictions = [(1, 2), (2, 3), (3, 4)] assert possible_to_assign_colors(n, m, lights, restrictions) == \\"YES\\" def test_possible_to_assign_colors_case3(): n, m = 6, 2 lights = [1, 2, 3, 4, 5, 6] restrictions = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)] assert possible_to_assign_colors(n, m, lights, restrictions) == \\"NO\\" def test_possible_to_assign_colors_case4(): n, m = 2, 2 lights = [1, 2] restrictions = [(1, 2)] assert possible_to_assign_colors(n, m, lights, restrictions) == \\"YES\\" def test_possible_to_assign_colors_case5(): n, m = 3, 3 lights = [1, 2, 3] restrictions = [(1, 2), (2, 3), (3, 1)] assert possible_to_assign_colors(n, m, lights, restrictions) == \\"NO\\"","solution":"def possible_to_assign_colors(n, m, lights, restrictions): from collections import defaultdict, deque graph = defaultdict(list) for a, b in restrictions: graph[a].append(b) graph[b].append(a) color = [-1] * (n + 1) def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for i in range(1, n + 1): if color[i] == -1: if not bfs(i): return \\"NO\\" return \\"YES\\" # Example usage n, m = 5, 3 lights = [1, 2, 3, 4, 5] restrictions = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] print(possible_to_assign_colors(n, m, lights, restrictions)) # Output: NO n, m = 4, 3 lights = [1, 2, 3, 4] restrictions = [(1, 2), (2, 3), (3, 4)] print(possible_to_assign_colors(n, m, lights, restrictions)) # Output: YES"},{"question":"def find_missing_number(array): Finds the missing number from the array containing n distinct numbers taken from 0 to n. >>> find_missing_number([3, 0, 1]) == 2 >>> find_missing_number([0, 1]) == 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) == 8","solution":"def find_missing_number(array): Finds the missing number from the array containing n distinct numbers taken from 0 to n. n = len(array) total_sum = n * (n + 1) / 2 array_sum = sum(array) return int(total_sum - array_sum)"},{"question":"def find_central_city(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine whether a central city exists. If it exists, output the city number. If it doesn't, output \\"-1\\". >>> find_central_city(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == -1 >>> find_central_city(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) == 1","solution":"def find_central_city(n, m, roads): if m == 0: return -1 if n > 1 else 1 # If no roads, only a single city can be a central city from collections import defaultdict, Counter adj_list = defaultdict(set) degree_count = Counter() # Create adjacency list and count degrees for u, v in roads: adj_list[u].add(v) adj_list[v].add(u) degree_count[u] += 1 degree_count[v] += 1 possible_central_city = [city for city, count in degree_count.items() if count == n - 1] if possible_central_city: return possible_central_city[0] for city in range(1, n + 1): non_neighbors = set(range(1, n + 1)) - adj_list[city] - {city} if all(city in adj_list[non_neighbor] for non_neighbor in non_neighbors): return city return -1"},{"question":"def rotateMatrix(matrix): Rotate the matrix 90 degrees clockwise. Return 'Invalid matrix' if input is not a valid 2D matrix of integers. >>> rotateMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotateMatrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotateMatrix('hello') 'Invalid matrix' >>> rotateMatrix([['string', 1], [2, 3]]) 'Invalid matrix' >>> rotateMatrix([[1, 2, 3], [4, 'a', 6], [7, 8, 9]]) 'Invalid matrix'","solution":"def rotateMatrix(matrix): Rotate the matrix 90 degrees clockwise. Return 'Invalid matrix' if input is not a valid 2D matrix of integers. if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return 'Invalid matrix' if not all(isinstance(elem, int) for row in matrix for elem in row): return 'Invalid matrix' num_rows = len(matrix) if num_rows == 0: return 'Invalid matrix' num_cols = len(matrix[0]) if not all(len(row) == num_cols for row in matrix): return 'Invalid matrix' # Rotate the matrix rotated_matrix = [[matrix[num_rows - 1 - r][c] for r in range(num_rows)] for c in range(num_cols)] return rotated_matrix"},{"question":"def find_max_depth(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Find the maximum depth of the organizational structure for all given test cases. >>> find_max_depth(1, [(6, [(2, 1), (3, 1), (4, 2), (5, 3), (6, 3), (7, 5)])]) [4] >>> find_max_depth(1, [(6, [(2, 1), (3, 2), (4, 3), (5, 4), (6, 5)])]) [6] >>> find_max_depth(1, [(6, [(2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1)])]) [2] >>> find_max_depth(1, [(0, [])]) [1] pass","solution":"def find_max_depth(T, test_cases): depths = [] for case in test_cases: N = case[0] employees = case[1] # Create a dictionary where keys are supervisors and values are their direct reports org_tree = {} for employee in employees: Ei, Si = employee if Si not in org_tree: org_tree[Si] = [] org_tree[Si].append(Ei) # Function to calculate the depth of the organizational tree def calculate_depth(node): if node not in org_tree: return 1 else: return 1 + max(calculate_depth(eid) for eid in org_tree[node]) # CEO's EID is always 1 max_depth = calculate_depth(1) depths.append(max_depth) return depths"},{"question":"def capture_surrounded_regions(matrix): Find all regions surrounded by 'X' in a matrix and replace all 'O's in such regions with 'X'. Args: matrix (List[List[str]]): A matrix of characters containing only 'X' and 'O'. Returns: List[List[str]]: The modified matrix with surrounded regions replaced. Example: >>> capture_surrounded_regions([ ... ['X', 'X', 'X'], ... ['X', 'O', 'X'], ... ['X', 'X', 'X']]) [['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'X', 'X']] >>> capture_surrounded_regions([ ... ['X', 'X', 'X', 'X'], ... ['X', 'O', 'O', 'X'], ... ['X', 'X', 'O', 'X'], ... ['X', 'O', 'X', 'X']]) [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X']]","solution":"def capture_surrounded_regions(matrix): if not matrix or not matrix[0]: return matrix rows, cols = len(matrix), len(matrix[0]) # Helper function to mark safe regions (those connected to boundary) def mark_safe(i, j): if i < 0 or i >= rows or j < 0 or j >= cols or matrix[i][j] != 'O': return matrix[i][j] = 'S' mark_safe(i-1, j) mark_safe(i+1, j) mark_safe(i, j-1) mark_safe(i, j+1) # Step 1: Mark all 'O's connected to boundaries as 'S' for i in range(rows): mark_safe(i, 0) mark_safe(i, cols - 1) for j in range(cols): mark_safe(0, j) mark_safe(rows - 1, j) # Step 2: Replace all 'O's with 'X' and 'S' back to 'O' for i in range(rows): for j in range(cols): if matrix[i][j] == 'O': matrix[i][j] = 'X' elif matrix[i][j] == 'S': matrix[i][j] = 'O' return matrix"},{"question":"def rotate_string(s: str, N: int) -> str: Rotates the characters of the string \`s\` to the right by \`N\` positions. Parameters: s (str): The original string. N (int): Number of positions to rotate. Returns: str: The string after rotation. >>> rotate_string(\\"abcdef\\", 2) 'efabcd' >>> rotate_string(\\"hello\\", 1) 'ohell' >>> rotate_string(\\"abcdef\\", 0) 'abcdef' >>> rotate_string(\\"abcdef\\", -2) 'abcdef' >>> rotate_string(\\"abcdef\\", 8) 'efabcd' >>> rotate_string(\\"hello\\", 11) 'ohell' >>> rotate_string(\\"\\", 5) '' >>> rotate_string(\\"\\", 0) '' >>> rotate_string(\\"a\\", 3) 'a' >>> rotate_string(\\"b\\", 0) 'b' pass","solution":"def rotate_string(s, N): Rotates the characters of the string \`s\` to the right by \`N\` positions. Parameters: s (str): The original string. N (int): Number of positions to rotate. Returns: str: The string after rotation. if N <= 0 or not s: return s N = N % len(s) return s[-N:] + s[:-N]"},{"question":"from collections import Counter def is_interesting_number(s: str) -> str: Given a string \`s\`, determines if its integer representation is an \\"interesting number\\". A number is interesting if it can be reordered to form a palindrome. >>> is_interesting_number(\\"civic\\") \\"YES\\" >>> is_interesting_number(\\"geek\\") \\"NO\\" >>> is_interesting_number(\\"ivicc\\") \\"YES\\" >>> is_interesting_number(\\"geekforgeeks\\") \\"NO\\"","solution":"from collections import Counter def is_interesting_number(s): Given a string \`s\`, determines if its integer representation is an \\"interesting number\\". A number is interesting if it can be reordered to form a palindrome. Args: s (str): Input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the integer representation of the string is interesting, otherwise \\"NO\\". count = Counter(s) odd_count = sum(1 for value in count.values() if value % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def unique_elements(arr): Write a function that takes an array of integers and returns a new array containing only the unique elements from the original array, preserving the order of their first occurrences. The function should have a linear time complexity, and you are not allowed to use any additional data structures like sets or dictionaries. >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, -1, 2, -2, 1, -1]) [1, -1, 2, -2] >>> unique_elements([]) [] >>> unique_elements([5]) [5]","solution":"def unique_elements(arr): Returns a list containing only the unique elements from the original array, preserving the order of their first occurrences. Args: arr (list): A list of integers. Returns: list: A list of unique integers in the order of their first occurrence. unique_list = [] for num in arr: if num not in unique_list: unique_list.append(num) return unique_list"},{"question":"from typing import List, Tuple def find_kth_smallest_palindrome(S: str, K: int) -> str: Find the K-th lexicographically smallest palindrome that can be formed using the characters of the string S. If no such palindrome exists, return \\"NO\\". >>> find_kth_smallest_palindrome(\\"aab\\", 1) \\"aba\\" >>> find_kth_smallest_palindrome(\\"abcd\\", 2) \\"NO\\" pass def solve(test_cases: List[Tuple[str, int]]) -> List[str]: Solve the given test cases to find the K-th lexicographically smallest palindrome. >>> solve([(\\"aab\\", 1), (\\"abcd\\", 2)]) [\\"aba\\", \\"NO\\"] pass","solution":"from itertools import permutations def find_kth_smallest_palindrome(S, K): # Find all unique permutations of the string S perm_set = set(permutations(S)) # Filter out only palindromic permutations palindromes = sorted([''.join(p) for p in perm_set if ''.join(p) == ''.join(p)[::-1]]) # If K is larger than the number of palindromes, return \\"NO\\" if K > len(palindromes): return \\"NO\\" # Return the K-th lexicographically smallest palindrome return palindromes[K-1] def solve(test_cases): results = [] for S, K in test_cases: results.append(find_kth_smallest_palindrome(S, K)) return results"},{"question":"def energy_to_quarks(E: int) -> int: Converts energy units to the equivalent number of quarks. Parameters: E (int): Amount of energy units (0 ≤ E ≤ 1600) Returns: int: The equivalent number of quarks >>> energy_to_quarks(256) 16 >>> energy_to_quarks(48) 3 >>> energy_to_quarks(0) 0 >>> energy_to_quarks(1) 0 >>> energy_to_quarks(1599) 99 >>> energy_to_quarks(1600) 100","solution":"def energy_to_quarks(E): Converts energy units to the equivalent number of quarks. Parameters: E (int): Amount of energy units (0 ≤ E ≤ 1600) Returns: int: The equivalent number of quarks return E // 16"},{"question":"def correct_isbn_order(n: int, isbn_numbers: List[int]) -> List[int]: This function corrects the order of ISBN numbers by swapping back the swapped elements to their correct positions. Parameters: n (int): The number of ISBN numbers. isbn_numbers (list): The list of ISBN numbers. Returns: list: The corrected list of ISBN numbers. >>> correct_isbn_order(5, [1234, 2345, 3456, 4567, 3455]) [1234, 2345, 3455, 4567, 3456] >>> correct_isbn_order(6, [1234, 2346, 2345, 3456, 4567, 5678]) [1234, 2345, 2346, 3456, 4567, 5678] >>> correct_isbn_order(4, [1111, 3333, 2222, 4444]) [1111, 2222, 3333, 4444]","solution":"def correct_isbn_order(n, isbn_numbers): This function corrects the order of ISBN numbers by swapping back the swapped elements to their correct positions. Parameters: n (int): The number of ISBN numbers. isbn_numbers (list): The list of ISBN numbers. Returns: list: The corrected list of ISBN numbers. sorted_numbers = sorted(isbn_numbers) # Find the two positions where the isbn_numbers and sorted_numbers differ swap_a = swap_b = -1 for i in range(n): if isbn_numbers[i] != sorted_numbers[i]: if swap_a == -1: swap_a = i else: swap_b = i # Swap the two different elements isbn_numbers[swap_a], isbn_numbers[swap_b] = isbn_numbers[swap_b], isbn_numbers[swap_a] return isbn_numbers"},{"question":"def sequence_sum(n: int) -> int: Returns the sum of the sequence S(n) where S(n) = sum of factorials up to n. >>> sequence_sum(3) 9 >>> sequence_sum(5) 153","solution":"def sequence_sum(n): Returns the sum of the sequence S(n) where S(n) = sum of factorials up to n. def factorial(k): if k == 0 or k == 1: return 1 else: product = 1 for i in range(2, k + 1): product *= i return product total_sum = 0 for i in range(1, n + 1): total_sum += factorial(i) return total_sum"},{"question":"def int_to_roman(num: int) -> str: Converts an integer to a Roman numeral. Parameters: num (int): The integer to convert. Returns: str: The corresponding Roman numeral. Examples: >>> int_to_roman(1) 'I' >>> int_to_roman(4) 'IV' >>> int_to_roman(9) 'IX' >>> int_to_roman(58) 'LVIII' >>> int_to_roman(3999) 'MMMCMXCIX'","solution":"def int_to_roman(num): Converts an integer to a Roman numeral. Parameters: num (int): The integer to convert. Returns: str: The corresponding Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"def can_form_arithmetic_sequence(N: int, A: List[int], C: List[str]) -> str: Determine if it's possible to select three different cards such that the numbers on the cards can form an arithmetic sequence and all selected cards have the same color. >>> can_form_arithmetic_sequence(5, [1, 3, 5, 6, 9], ['R', 'R', 'R', 'B', 'B']) \\"Yes\\" >>> can_form_arithmetic_sequence(4, [1, 3, 5, 7], ['B', 'B', 'R', 'R']) \\"No\\" def run_tests(test_cases: List[Tuple[int, List[int], List[str]]]) -> List[str]: Run multiple test cases and determine the results for each one.","solution":"def can_form_arithmetic_sequence(N, A, C): color_dict = {'R': [], 'B': []} for i in range(N): color_dict[C[i]].append(A[i]) for color in ['R', 'B']: arr = sorted(color_dict[color]) loc = len(arr) for i in range(loc - 2): for j in range(i + 1, loc - 1): for k in range(j + 1, loc): if arr[i] - arr[j] == arr[j] - arr[k]: return \\"Yes\\" return \\"No\\" def run_tests(test_cases): results = [] for N, A, C in test_cases: results.append(can_form_arithmetic_sequence(N, A, C)) return results"},{"question":"def minSwapsToPalindrome(s: str) -> int: Determine the minimum number of adjacent character swaps required to transform the string into a palindrome. If it is not possible to transform the string into a palindrome, return -1. >>> minSwapsToPalindrome('mamad') == 3 >>> minSwapsToPalindrome('aabb') == 2 >>> minSwapsToPalindrome('nttin') == 1 >>> minSwapsToPalindrome('aaaa') == 0 >>> minSwapsToPalindrome('abcba') == 0 >>> minSwapsToPalindrome('abcd') == -1 >>> minSwapsToPalindrome('abcde') == -1 >>> minSwapsToPalindrome('a') == 0 >>> minSwapsToPalindrome('aa') == 0 >>> minSwapsToPalindrome('ab') == -1 >>> minSwapsToPalindrome('') == 0","solution":"def minSwapsToPalindrome(s): Calculates the minimum number of adjacent swaps to transform the string into a palindrome. If it's not possible, returns -1. def canFormPalindrome(s): count = {} for char in s: count[char] = count.get(char, 0) + 1 odd_count = sum(v % 2 for v in count.values()) return odd_count <= 1 if not canFormPalindrome(s): return -1 chars = list(s) n = len(chars) swaps = 0 for i in range(n // 2): left = i right = n - left - 1 while left < right: if chars[left] == chars[right]: break right -= 1 if left == right: chars[left], chars[left + 1] = chars[left + 1], chars[left] swaps += 1 right = n - left - 1 for j in range(right, n - left - 1): chars[j], chars[j + 1] = chars[j + 1], chars[j] swaps += 1 return swaps"},{"question":"def trap(height): Compute how much water it is able to trap after raining. :param height: List[int] :return: int >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([4,2,0,3,2,5]) == 9","solution":"def trap(height): Compute how much water it is able to trap after raining. :param height: List[int] :return: int if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"def min_insertions_to_balance(s: str) -> int: Determine the minimum number of insertions required to make the string of parentheses balanced. Parameters: s (str): The input string consisting of characters '(' and ')'. Returns: int: The minimum number of insertions needed to make the string balanced. >>> min_insertions_to_balance(\\"()\\") 0 >>> min_insertions_to_balance(\\"(()())\\") 0 >>> min_insertions_to_balance(\\"(())\\") 0 >>> min_insertions_to_balance(\\"(((\\") 3 >>> min_insertions_to_balance(\\"(()\\") 1 >>> min_insertions_to_balance(\\"((())\\") 1 >>> min_insertions_to_balance(\\")))\\") 3 >>> min_insertions_to_balance(\\"())\\") 1 >>> min_insertions_to_balance(\\"())())\\") 2 >>> min_insertions_to_balance(\\"())(\\") 2 >>> min_insertions_to_balance(\\"(()))(\\") 2 >>> min_insertions_to_balance(\\"())(()\\") 2 >>> min_insertions_to_balance(\\"(\\") 1 >>> min_insertions_to_balance(\\")\\") 1","solution":"def min_insertions_to_balance(s): This function calculates the minimum number of insertions needed to make the input string of parentheses balanced. open_count = 0 close_count = 0 for char in s: if char == '(': open_count += 1 else: if open_count > 0: open_count -= 1 else: close_count += 1 return open_count + close_count"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},D={class:"card-container"},P={key:0,class:"empty-state"},I=["disabled"],C={key:0},z={key:1};function F(r,e,u,c,i,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",D,[(s(!0),n(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",P,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),n("span",z,"Loading...")):(s(),n("span",C,"See more"))],8,I)):l("",!0)])}const O=_(E,[["render",F],["__scopeId","data-v-4d516782"]]),Y=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/58.md","filePath":"guide/58.md"}'),M={name:"guide/58.md"},G=Object.assign(M,{setup(r){return(e,u)=>(s(),n("div",null,[w(O)]))}});export{Y as __pageData,G as default};
