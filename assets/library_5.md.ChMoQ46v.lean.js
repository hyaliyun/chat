import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},R={class:"review-title"},j={class:"review-content"};function I(i,e,u,f,s,a){return n(),r("div",q,[t("div",T,[t("div",R,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",j,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const Y=m(k,[["render",I],["__scopeId","data-v-bb36918a"]]),F=JSON.parse('[{"question":"You are given a list of integers `nums` sorted in non-decreasing order and an integer `target`. Your task is to find the starting and ending position of the target value in the array. If the target is not found in the array, return `[-1, -1]`. Implement the function `searchRange(nums, target)` that finds the range in which `target` appears. The function should follow these specifications: * The function should return a list of two integers indicating the start and end positions of the target in the array. * If the target is not present, the function should return `[-1, -1]`. * The function must have a logarithmic time complexity, ensuring efficiency even for large datasets. Example: ```python assert searchRange([5,7,7,8,8,10], 8) == [3,4] assert searchRange([5,7,7,8,8,10], 6) == [-1,-1] assert searchRange([], 0) == [-1,-1] ```","solution":"def searchRange(nums, target): Returns the starting and ending positions of the target in the array. If the target is not found, return [-1, -1]. def find_left_index(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right_index(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_index = find_left_index(nums, target) right_index = find_right_index(nums, target) # Check if target is not inside the array. if left_index <= right_index and left_index < len(nums) and nums[left_index] == target: return [left_index, right_index] else: return [-1, -1]"},{"question":"You are given an integer array `nums` of unique elements. Consider a new array `sorted_nums` which is the result of sorting `nums` in ascending order. Write an algorithm to determine the length of the smallest subsequence in `nums` that can be removed to make the remaining elements in the same order as `sorted_nums`. If no removal is needed, return `0`. Example: ``` Input: nums = [4, 2, 3, 1] Output: 2 Explanation: Removing the subsequence [4, 1] will result in [2, 3] which is sorted in ascending order. ```","solution":"def length_of_smallest_subsequence_to_remove(nums): Returns the length of the smallest subsequence in nums that can be removed to make the remaining elements sorted in ascending order. def find_lis_length(nums): # Helper function to find the length of the Longest Increasing Subsequence (LIS) from bisect import bisect_left lis = [] for num in nums: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) length_of_lis = find_lis_length(nums) return len(nums) - length_of_lis"},{"question":"Given the root of a binary search tree (BST) and a value `val`, insert `val` into the BST such that the properties of the binary search tree are maintained. Return the root of the BST after the insertion. It is guaranteed that there are no duplicate values in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): Inserts a value into the BST and returns the root of the BST. :param root: TreeNode, the root of the BST. :param val: int, the value to be inserted. :return: TreeNode, the root of the BST after insertion. if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root"},{"question":"You have an array of integers `arr` where each element appears exactly twice, except for one element that appears exactly once. Implement a function that takes `arr` as input and returns the element that appears only once. Your solution should have a linear runtime complexity and use only constant extra space. Return the unique element in the array.","solution":"def find_single_element(arr): Returns the element that appears only once in the array where every other element appears twice. Parameters: arr (list of int): The input array of integers. Returns: int: The unique element that appears only once. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"Given an integer `n`, generate an `n x n` matrix filled with elements from `1` to `n^2` in spiral order, and return the resulting matrix. A matrix is filled in spiral order if the elements are arranged in a circular fashion starting from the top-left corner and proceeding in the following order: rightwards across the top row, downwards along the rightmost column, leftwards along the bottom row, and upwards along the leftmost column, repeating this pattern towards the center of the matrix. For example: - For `n = 3`, the generated `3 x 3` matrix would be: ``` [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] ``` - For `n = 4`, the generated `4 x 4` matrix would be: ``` [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] ``` Write a function: ```python def generateMatrix(n: int) -> List[List[int]]: # implementation here ``` that takes an integer `n` and returns an `n x n` matrix filled in spiral order. Here, `List` is assumed to be imported from `typing`.","solution":"from typing import List def generateMatrix(n: int) -> List[List[int]]: matrix = [[0] * n for _ in range(n)] start_row, end_row = 0, n - 1 start_col, end_col = 0, n - 1 num = 1 while start_row <= end_row and start_col <= end_col: for col in range(start_col, end_col + 1): matrix[start_row][col] = num num += 1 start_row += 1 for row in range(start_row, end_row + 1): matrix[row][end_col] = num num += 1 end_col -= 1 if start_row <= end_row: for col in range(end_col, start_col - 1, -1): matrix[end_row][col] = num num += 1 end_row -= 1 if start_col <= end_col: for row in range(end_row, start_row - 1, -1): matrix[row][start_col] = num num += 1 start_col += 1 return matrix"},{"question":"You are given a string `s` consisting of lowercase alphabetical characters. You need to find out the number of distinct subsequences that can be generated from `s`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return _the number of distinct subsequences_. Since the answer can be very large, return it modulo `10^9 + 7`.","solution":"def numDistinctSubsequences(s): MOD = 10**9 + 7 n = len(s) # dp[i] = number of distinct subsequences ending at the i-th character dp = [0] * (n + 1) dp[0] = 1 # An empty string has one subsequence - the empty string itself # last[index] will store the last occurrence index of character `index` (\'a\' -> 0, ..., \'z\' -> 25) last = [-1] * 26 for i in range(1, n + 1): char_index = ord(s[i - 1]) - ord(\'a\') dp[i] = (2 * dp[i - 1]) % MOD if last[char_index] != -1: dp[i] = (dp[i] - dp[last[char_index]]) % MOD last[char_index] = i - 1 # Subtract 1 to exclude the empty subsequence return (dp[n] - 1) % MOD"},{"question":"A bookstore owner keeps track of a list of books and their respective sales. The owner wants to arrange a display that maximizes the number of days the top `K` books are consistent. Implement the `BookstoreDisplay` class: * `BookstoreDisplay(String[] bookTitles)` initializes the book display with a list of book titles. * `void addSales(String bookTitle, int sales)` records the number of sales for the given book. * `List<String> getTopKBooks(int K)` returns a list of the current top `K` books sorted by sales in descending order. In case of a tie (same number of sales), sort the books lexicographically by their titles.","solution":"class BookstoreDisplay: def __init__(self, bookTitles): self.bookTitles = bookTitles self.sales = {title: 0 for title in bookTitles} def addSales(self, bookTitle, sales): if bookTitle in self.sales: self.sales[bookTitle] += sales def getTopKBooks(self, K): sorted_books = sorted(self.sales.items(), key=lambda item: (-item[1], item[0])) return [title for title, _ in sorted_books[:K]]"},{"question":"You are given a string `s` representing a sequence of characters and a non-negative integer `k`. Your task is to return the lexicographically earliest subsequence of `s` of length `k`. A subsequence is obtained from `s` by deleting some (possibly zero) characters without changing the relative order of the remaining characters. For example, given the string `s = \\"abcde\\"` and `k = 3`, the lexicographically earliest subsequence of length `3` is `\\"abc\\"`. If `s = \\"cbade\\"` and `k = 2`, the lexicographically earliest subsequence of length `2` is `\\"ad\\"`. Return the lexicographically earliest subsequence of `s` of length `k`.","solution":"def earliest_subsequence(s, k): Returns the lexicographically earliest subsequence of s of length k. Parameters: s (str): The input string. k (int): The length of the subsequence to be returned. Returns: str: The lexicographically earliest subsequence of length k. stack = [] to_remove = len(s) - k for char in s: while to_remove > 0 and stack and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) return \'\'.join(stack[:k])"},{"question":"You are given a 2D grid representing a map of \'1\'s (land) and \'0\'s (water). An island is a group of adjacent \'1\'s connected vertically or horizontally. The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). There is a bridge connecting this island to other parts of land outside the grid, ensuring it is not a part of the island itself. Write a function that returns the perimeter of the island. The perimeter is the total length of the edges that are directly connected to the water.","solution":"def island_perimeter(grid): Calculate the perimeter of the island. Args: grid (List[List[int]]): A 2D grid representing the map, where 1 represents land and 0 represents water. Returns: int: The perimeter of the island. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) perimeter = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: # Check all four directions if i == 0 or grid[i-1][j] == 0: # Check upward perimeter += 1 if i == rows-1 or grid[i+1][j] == 0: # Check downward perimeter += 1 if j == 0 or grid[i][j-1] == 0: # Check left perimeter += 1 if j == cols-1 or grid[i][j+1] == 0: # Check right perimeter += 1 return perimeter"},{"question":"You are given a **0-indexed** matrix `grid` of integers where each cell represents the elevation at that point. A lake is defined as a contiguous group of cells that are all at the same elevation. The lake is surrounded by cells of higher elevation (or the boundary of the grid). The size of a lake is the number of cells it contains. You want to find the size of the largest lake in the grid. Assume a lake merges diagonally, horizontally, and vertically connected cells of equal elevation. Return the size of the largest lake. # Example: Given the matrix: ``` [ [1, 2, 2, 3], [3, 2, 1, 4], [4, 4, 3, 4] ] ``` The largest lake consists of elevation \'2\' and contains three cells. The function should return `3`.","solution":"def explore_lake(grid, visited, i, j, elevation): Helper function to explore the lake and return its size directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] stack = [(i, j)] lake_size = 0 while stack: x, y = stack.pop() if visited[x][y]: continue visited[x][y] = True lake_size += 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and not visited[nx][ny] and grid[nx][ny] == elevation: stack.append((nx, ny)) return lake_size def largest_lake(grid): Returns the size of the largest lake in the given grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] max_lake_size = 0 for i in range(rows): for j in range(cols): if not visited[i][j]: lake_size = explore_lake(grid, visited, i, j, grid[i][j]) max_lake_size = max(max_lake_size, lake_size) return max_lake_size"},{"question":"Write a function that takes two strings `s` and `t` and returns whether `t` can be formed by reordering the characters in `s` and possibly adding more characters. In other words, check if `t` is a supersequence of `s`. For example, if `s = \\"abc\\"` and `t = \\"aebdc\\"`, the function should return true because `aebdc` can be formed by reordering `abc` and adding the characters `e` and `d`. However, if `s = \\"abc\\"` and `t = \\"abdef\\"`, the function should return false because \\"c\\" from \\"abc\\" is missing in \\"abdef\\". The function should be efficient and handle strings of varying lengths.","solution":"def is_supersequence(s, t): Returns True if `t` can be formed by reordering the characters in `s` and possibly adding more characters. from collections import Counter counter_s = Counter(s) counter_t = Counter(t) for char in counter_s: if counter_s[char] > counter_t[char]: return False return True"},{"question":"You are given a string `s` containing only lowercase alphabets. You can perform a transformation in which you choose any character in the string and change it to any lowercase alphabet. Return the minimum number of such transformations needed to make the string a palindrome. A palindrome is a string that reads the same backward as forward. For example, if `s = \\"abc\\"`, you can make the string a palindrome by changing `\'c\'` to `\'a\'` or `\'b\'` to `\'c\'`, resulting in `\\"aba\\"` or `\\"cbc\\"`, respectively. Note: The length of the string will be at most 10^5.","solution":"def min_transformations_to_palindrome(s): Returns the minimum number of transformations needed to make the string a palindrome. n = len(s) count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: count += 1 return count"},{"question":"You are given an array of integers `nums` representing the pre-order traversal of a binary search tree. Construct the binary search tree from the given pre-order traversal and return its root. A **binary search tree** is a binary tree where each node has at most two children, which are referred to as the **left child** and **right child**. For any node, all values in its left subtree are less than the node\'s value, and all values in its right subtree are greater than the node\'s value.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorder(preorder): if not preorder: return None root = TreeNode(preorder[0]) stack = [root] for value in preorder[1:]: node, child = stack[-1], TreeNode(value) # Adjust the position for the new node in the tree while stack and stack[-1].val < value: node = stack.pop() if node.val < value: node.right = child else: node.left = child stack.append(child) return root def preorderTraversal(root): Helper function to get the preorder traversal of a tree, used for verification in tests. return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right) if root else []"},{"question":"You are given a string `s` representing an expression in a valid mathematical format, containing digits and the operators `+`, `-`, `*`, and `/`. Evaluate this expression and return its result as an integer. The division should truncate toward zero. You may assume that the given string is always valid. You can use the built-in eval function (not efficient) or implement a more optimized solution. * For example, given `s = \\"3 + 2 * 2\\"`, return 7. * If `s = \\" 3/2 \\"`, return 1.","solution":"def evaluate_expression(s): Evaluates a mathematical expression string containing integers and the operators +, -, *, and /. The division operator performs integer division that truncates towards zero. # Remove any spaces from the string s = s.replace(\\" \\", \\"\\") # Check if the string is empty if not s: return 0 # Initialize variables current_number = 0 stack = [] operation = \\"+\\" # Iterate over the characters in the string for i, char in enumerate(s): if char.isdigit(): current_number = current_number * 10 + int(char) # If the char is an operator or the end of the string is reached if char in \\"+-*/\\" or i == len(s) - 1: if operation == \\"+\\": stack.append(current_number) elif operation == \\"-\\": stack.append(-current_number) elif operation == \\"*\\": stack.append(stack.pop() * current_number) elif operation == \\"/\\": # Truncate division towards zero stack.append(int(stack.pop() / current_number)) # Reset current number and update operation current_number = 0 operation = char # Sum up all the values in the stack to get the result return sum(stack)"},{"question":"Given an array of integers `arr` representing the heights of buildings, return _the amount of rainwater that can be trapped_ after raining. Each element in the array represents the height of a building, and the width of each building is 1.","solution":"def trap_rain_water(arr): Calculate the amount of rainwater that can be trapped after raining. :param arr: List[int] - heights of the buildings. :return: int - total amount of trapped rainwater. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"Given a list of `n` integers, `arr`, representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The solution should calculate the total units of water that can be trapped between the bars after it rains.","solution":"def trapRainWater(arr): Calculate the total water that can be trapped between the bars. :param arr: List[int] - list of integers representing the elevation map. :return: int - total units of trapped water. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"You are given a two-dimensional integer array `buildings` where `buildings[i] = [left_i, right_i, height_i]` represents a building with its left and right edge positions and its height. The array `buildings` is unsorted. Your task is to produce the skyline by merging overlapping buildings together and representing the contour of these buildings in the form of key points. A key point is defined as a change in the height from its previous height. Return the resulting skyline as a list of key points `[x, y]` where `x` is the x-coordinate and `y` is the height after the change in height. The final output should be sorted by the x-coordinates and should not have consecutive points with the same x-coordinate and height.","solution":"import heapq def get_skyline(buildings): Returns the skyline as a list of key points. if not buildings: return [] # Create events for all left and right edges events = [] for left, right, height in buildings: events.append((left, -height, right)) # start of the building events.append((right, 0, None)) # end of the building # Sort events: first by x, second by height events.sort() # Priority queue to store living buildings pq = [(0, float(\'inf\'))] # Tuple of negative height and end position skyline = [[0, 0]] for x, negH, right in events: while x >= pq[0][1]: # Remove buildings from the heap that ended before the current x heapq.heappop(pq) if negH != 0: heapq.heappush(pq, (negH, right)) max_height = -pq[0][0] # Current max height if skyline[-1][1] != max_height: skyline.append([x, max_height]) return skyline[1:]"},{"question":"You are given an integer `n`, representing the number of students in a class. Each student has a unique ID from `1` to `n`. You are also given a list of `friendRequests`, where each element `friendRequests[i]` is a pair of integers `[a, b]`, representing a friendship request between students `a` and `b`. Given a list `initiated`, where `initiated[i]` is a boolean value indicating whether the friendship request `friendRequests[i]` was actually initiated or not, return the final friends list for each student. If student `a` and student `b` are friends, they should appear in each other\'s friends list. Formally, implement a function `friendshipStatus(n, friendRequests, initiated)`.","solution":"def friendshipStatus(n, friendRequests, initiated): Returns the final friends list for each student. :param n: Number of students :param friendRequests: List of pairs representing friendship requests :param initiated: List of booleans indicating which requests were initiated :return: List of lists representing each student\'s friends # Initialize list of friends for each student friends = [[] for _ in range(n)] for i, (a, b) in enumerate(friendRequests): if initiated[i]: friends[a - 1].append(b) friends[b - 1].append(a) return friends"},{"question":"You are given an integer array `costs` where `costs[i]` is the cost of the `iᵗʰ` course. You want to maximize the number of courses you can take with a given amount of money `budget`. You must take all the courses you select, and the sum of the costs of the selected courses must be less than or equal to `budget`. Return _the **maximum number** of courses you can take_.","solution":"def max_courses(costs, budget): Returns the maximum number of courses that can be taken without exceeding the given budget. costs.sort() total_cost = 0 course_count = 0 for cost in costs: if total_cost + cost <= budget: total_cost += cost course_count += 1 else: break return course_count"},{"question":"You are given a 2D matrix where each cell contains a non-negative integer representing the cost to enter that cell. You are initially positioned in the top-left cell of the matrix and you need to move to the bottom-right cell. From any cell, you can either move right or down to an adjacent cell. Return the minimum cost path sum to reach the bottom-right cell from the top-left cell. For example, given the following matrix: ``` [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ``` The minimum cost path sum to reach the bottom-right cell is 7, formed by the path 1 → 3 → 1 → 1 → 1.","solution":"def min_path_sum(grid): Returns the minimum cost path sum to reach the bottom-right cell from the top-left cell. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the first row by cumulatively adding the values for col in range(1, cols): grid[0][col] += grid[0][col - 1] # Initialize the first column by cumulatively adding the values for row in range(1, rows): grid[row][0] += grid[row - 1][0] # Update the rest of the grid for row in range(1, rows): for col in range(1, cols): grid[row][col] += min(grid[row - 1][col], grid[row][col - 1]) return grid[rows - 1][cols - 1]"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to choose some characters from the string and rearrange them so that the new string contains exactly `k` distinct characters. Return _the length of the longest possible new string with exactly `k` distinct characters_. If it is not possible to form a string with exactly `k` distinct characters, return `-1`.","solution":"def longest_k_distinct_substring(s, k): Given a string s and an integer k, return the length of the longest possible substring with exactly k distinct characters. If it\'s not possible, return -1. from collections import Counter # Count the frequency of each character in the string. char_count = Counter(s) # If there are fewer distinct characters than k, it\'s impossible. if len(char_count) < k: return -1 # Extract character frequencies and sort them in descending order. frequencies = sorted(char_count.values(), reverse=True) # Sum up the top k frequencies. max_length = sum(frequencies[:k]) return max_length"},{"question":"You are given a **rooted** binary tree with `n` nodes, each having a unique value from `1` to `n`. The tree is represented with the `root` node, where each node contains a value and two children pointers (left and right). Define a **level-order traversal** as a traversal where we visit all nodes at depth `0`, then depth `1`, and so on. You need to modify the tree such that the level-order traversal of modified tree lists the node values in an **increasing order**. Return the modified root node of the tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def increase_level_order(root): if not root: return None # Step 1: Perform level-order traversal queue = deque([root]) node_values = [] while queue: node = queue.popleft() node_values.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) # Step 2: Sort the values in ascending order node_values.sort() # Step 3: Modify tree values in level-order with sorted values queue = deque([root]) i = 0 while queue: node = queue.popleft() node.val = node_values[i] i += 1 if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root"},{"question":"You are given a `nxn` matrix `matrix` filled with integers. Your task is to rotate the matrix 90 degrees clockwise in place. * For example, if the matrix is `[[1,2,3], [4,5,6], [7,8,9]]`, rotating it 90 degrees clockwise will transform it to `[[7,4,1], [8,5,2], [9,6,3]]`. Return _the matrix after rotating it 90 degrees clockwise_.","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given nxn matrix 90 degrees clockwise in place. :param matrix: List[List[int]] : nxn matrix to be rotated :return: matrix after rotating 90 degrees clockwise n = len(matrix) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top return matrix"},{"question":"Given a non-negative integer `n`, generate an array of all `n`-bit gray codes. A gray code sequence for `n` bits is a sequence of `2^n` integers where two successive values differ in exactly one bit. Return the sequence in an array. Note that the first element should be `0`, and the sequence should be in such a way that the last element is also different from the first element by exactly one bit.","solution":"def gray_code(n): Generate the list of n-bit Gray codes. :param n: int, number of bits :return: list of int, representing the n-bit Gray codes. # Base case when n is 0 if n == 0: return [0] # Recursive case: generate (n-1)-bit Gray code prev_gray_code = gray_code(n - 1) result = [] # Add the leading 0-bit to the (n-1)-bit Gray code for code in prev_gray_code: result.append(code) # Add the leading 1-bit to the reversed (n-1)-bit Gray code for code in reversed(prev_gray_code): result.append(code | 1 << (n - 1)) return result"},{"question":"Write a function that takes a string `s` as input and returns a list of strings representing all possible valid IP addresses that can be formed by inserting dots into `s`. An IP address consists of four integers (each between 0 and 255) separated by dots (\'.\'). The string `s` does not contain any dots. If there are multiple possible valid IP addresses, return them in lexicographical order. If no valid IP address can be formed, return an empty list. **Example:** - Input: `s = \\"25525511135\\"` - Output: `[\\"255.255.11.135\\", \\"255.255.111.35\\"]` **Note:** - A valid segment (between the dots) cannot have leading zeros unless it is the number 0 itself. - The length of `s` will be between 4 and 12.","solution":"def restore_ip_addresses(s): Returns all possible valid IP addresses that can be formed by inserting dots into `s`. def is_valid(segment): return len(segment) == 1 or (segment[0] != \'0\' and int(segment) <= 255) def backtrack(start=0, parts=[]): if start == len(s) and len(parts) == 4: addresses.append(\\".\\".join(parts)) elif len(parts) < 4: for end in range(start + 1, min(start + 4, len(s) + 1)): segment = s[start:end] if is_valid(segment): backtrack(end, parts + [segment]) addresses = [] backtrack() return sorted(addresses)"},{"question":"You are given an `m x n` grid containing characters \'X\' and \'O\'. The \'X\' characters represent walls and the \'O\' characters represent open space. You need to find and return the number of distinct regions of \'O\'s in the grid. A region is defined as a contiguous area of \'O\'s connected horizontally or vertically. Two \'O\' characters are in the same region if they are adjacent horizontally or vertically but not diagonally. Write a function that takes a 2D list representing the grid and returns the number of distinct \'O\' regions. # Additional Note: - The grid may contain multiple regions and is not necessarily surrounded by walls. - Think about how to efficiently traverse the grid and mark visited regions without modifying the original grid if possible.","solution":"def num_regions(grid): Returns the number of distinct regions of \'O\'s in the given grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(x, y): stack = [(x, y)] while stack: i, j = stack.pop() if 0 <= i < m and 0 <= j < n and grid[i][j] == \'O\' and not visited[i][j]: visited[i][j] = True stack.append((i+1, j)) stack.append((i-1, j)) stack.append((i, j+1)) stack.append((i, j-1)) regions = 0 for i in range(m): for j in range(n): if grid[i][j] == \'O\' and not visited[i][j]: dfs(i, j) regions += 1 return regions"},{"question":"You are given the heads of two sorted linked lists `list1` and `list2`. Merge the two lists into a single sorted linked list and return the head of the merged list. The merged list should be made by splicing together the nodes of the first two lists in a sorted order. The linked lists are defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(list1, list2): Merges two sorted linked lists into a single sorted linked list and returns the head of the merged list. dummy = ListNode() current = dummy while list1 and list2: if list1.val < list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next if list1: current.next = list1 else: current.next = list2 return dummy.next"},{"question":"You are given a linked list with `n` nodes, where each node has an integer value. You are also given a positive integer `k`. Partition the linked list into `k` consecutive linked list parts of as equal size as possible. The length of each part should be `n // k` or `n // k + 1`, and the parts should be in the same order as in the original list. Return an array of linked lists representing the `k` parts. For example, if the given linked list is `[1, 2, 3, 4, 5]` and `k = 3`, then the list should be partitioned into `k` parts: `[1, 2]`, `[3, 4]`, and `[5]`. *Note:* The linked list nodes should be represented as instances of the `ListNode` class, and each linked list part should be returned as the head of the respective linked list. If the number of nodes is less than `k`, some parts will be `null`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def split_linked_list_to_parts(head, k): # find the length of the linked list n = 0 current = head while current: n += 1 current = current.next # calculate the size for each part part_size = n // k extra_nodes = n % k # Split the list parts = [] current = head for i in range(k): part_head = current for j in range(part_size + (i < extra_nodes) - 1): if current: current = current.next if current: temp = current.next current.next = None current = temp parts.append(part_head) return parts"},{"question":"Given a 2D grid of size `m x n`, where each cell is either a land (`1`) or water (`0`), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Implement a class `IslandCounter` with the following method: * `int numIslands(char[][] grid)` - this method takes a 2D grid as its input and returns the number of islands in the grid. Note: An island is considered one single connected region of `1`s (land), and is formed by adjacent cells which share a border (either horizontally or vertically). You can assume the grid dimensions do not exceed 300x300.","solution":"class IslandCounter: def numIslands(self, grid): if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == \'0\' or visited[i][j]: return visited[i][j] = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) num_islands = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\' and not visited[i][j]: dfs(i, j) num_islands += 1 return num_islands"},{"question":"You are given a list of `n` integers, where each integer represents the number of votes a candidate received in an election. Each candidate has a unique id ranging from `0` to `n-1`. The list of votes is such that the vote count for each candidate increases sequentially, but at some point in the list, the vote counts start decreasing (like a peak point). Your task is to write a function to find the candidate with the highest vote count. You may assume that the vote counts follow a bitonic sequence, which means it first increases and then decreases. Return the id of the candidate with the highest votes.","solution":"def find_highest_vote_candidate(votes): Returns the id of the candidate with the highest vote count. left, right = 0, len(votes) - 1 while left < right: mid = (left + right) // 2 if votes[mid] > votes[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given a **0-indexed** integer array `nums`. Return _the length of the **longest subarray** of `nums` where the absolute difference between any two elements is less than or equal to `1`_. A **subarray** is a contiguous sequence of elements within an array.","solution":"def longest_subarray(nums): Returns the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1. if not nums: return 0 max_length = 0 left, right = 0, 0 while right < len(nums): if abs(nums[right] - nums[left]) <= 1: max_length = max(max_length, right - left + 1) else: left = right right += 1 return max_length"},{"question":"Given an array of integers `nums` constructed by rearranging an integer array, return the number of unique pairs `(i, j)` such that `0 <= i < j < nums.length` and `nums[i] + nums[j]` is divisible by a positive integer `k`. Ensure you optimize your solution for both time and space complexities.","solution":"def count_divisible_pairs(nums, k): Returns the number of unique pairs (i, j) such that 0 <= i < j < len(nums) and nums[i] + nums[j] is divisible by a positive integer k. count = 0 n = len(nums) # Iterate over all pairs (i, j) for i in range(n): for j in range(i + 1, n): if (nums[i] + nums[j]) % k == 0: count += 1 return count"},{"question":"You are given a list of integers `buildings` representing the heights of buildings in a street, from left to right. The task is to determine the total amount of rainwater that can be trapped between the buildings after raining. Each building\'s width is 1 unit. Example: Given `buildings = [3, 0, 2, 0, 4]`, the procedure will calculate that `7` units of rainwater are trapped. Return the total units of rainwater that can be trapped.","solution":"def trap_rainwater(buildings): if not buildings: return 0 n = len(buildings) left_max = [0] * n right_max = [0] * n left_max[0] = buildings[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], buildings[i]) right_max[n - 1] = buildings[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], buildings[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - buildings[i] return water_trapped"},{"question":"You are given two strings `word1` and `word2`. Your task is to merge these strings such that the resulting string is the longest possible sequence of alternating characters from `word1` and `word2`. In case of a tie, the characters from `word1` should precede those from `word2`. Implement a function `mergeAlternately(word1, word2)` that returns the resulting string formed by the above rules.","solution":"def mergeAlternately(word1, word2): Returns a string that is a combination of the longest possible sequence of alternating characters from word1 and word2. In the case of a tie, characters from word1 precede those from word2. result = [] len1, len2 = len(word1), len(word2) for i in range(max(len1, len2)): if i < len1: result.append(word1[i]) if i < len2: result.append(word2[i]) return \'\'.join(result)"},{"question":"Given a `string` s and an array of `substring` queries brk_idx, implement a method that returns the result of breaking `string` s into parts at every index given in brk_idx. For example, given the string `s = \\"abcdefg\\"` and `brk_idx = [2, 4, 5]`, the function should return a list of strings `[\\"ab\\", \\"cd\\", \\"e\\", \\"fg\\"]`. **Definition of the function:** Parameters: - `String s` - `int[] brk_idx` Returns: - `List<String>` **Example:** Input: - s = \\"abcdefg\\" - brk_idx = [2, 4, 5] Output: - [\\"ab\\", \\"cd\\", \\"e\\", \\"fg\\"] **Note:** - If `brk_idx` is empty, the whole string `s` should be returned as a single element list. - The indices in `brk_idx` are guaranteed to be in increasing order. - The function should handle edge cases where `brk_idx` contains indices at the boundaries (0 or length of s). - Each index in `brk_idx` will be within the bounds of the string length.","solution":"def break_string(s, brk_idx): Breaks the string s into parts at every index given in brk_idx. Parameters: - s (str): The input string to be broken into parts. - brk_idx (list of int): The list of indices where the string should be broken. Returns: - list of str: List of substrings after breaking the string. if not brk_idx: return [s] result = [] previous_index = 0 for index in brk_idx: result.append(s[previous_index:index]) previous_index = index result.append(s[previous_index:]) return result"},{"question":"You are given a **0-indexed** array `heights` representing the heights of buildings. The goal is to determine the maximum number of buildings you can see, starting from the first building in the array. A building is visible if all the buildings before it (closer to the start of the array) have a lower height. In other words, a building `heights[j]` is visible from building `heights[i]` if there is no `k` with `i < k < j` such that `heights[k] >= heights[j]`. Return an integer representing the maximum number of buildings that are visible from the first building.","solution":"def max_visible_buildings(heights): Returns the maximum number of buildings visible from the first building in the list. Parameters: heights (list): List of integers representing the heights of the buildings. Returns: int: Maximum number of visible buildings. if not heights: return 0 max_count = 1 # First building is always visible current_height = heights[0] for height in heights[1:]: if height > current_height: max_count += 1 current_height = height return max_count"},{"question":"Given a binary tree, find the maximum width of the tree. The maximum width of a tree is defined as the maximum number of nodes present at any level within the tree. Return the maximum width of the binary tree as an integer. Note that the binary tree can have varying depths and structures.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxWidth(root): if not root: return 0 max_width = 0 queue = deque([(root, 0)]) while queue: level_length = len(queue) _, first_index = queue[0] for i in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) _, last_index = node, index max_width = max(max_width, last_index - first_index + 1) return max_width"},{"question":"Given a matrix of integers `grid` of size m x n and an integer `x`, count the number of squares of size `x` x `x` in the grid whose sums of all elements are greater than a given threshold `threshold`. A square in the grid is defined as a submatrix of size `x` x `x` with its top-left corner at `(i, j)` for `0 <= i <= m-x` and `0 <= j <= n-x`. Return the count of such squares.","solution":"def count_squares_with_sum_greater_than_threshold(grid, x, threshold): Count the number of squares of size x x x in the grid whose sums of all elements are greater than a given threshold. :param grid: List[List[int]] - 2D list of integers representing the grid :param x: int - size of the square submatrix :param threshold: int - threshold value :return: int - count of squares with sum greater than the threshold m = len(grid) n = len(grid[0]) count = 0 for i in range(m - x + 1): for j in range(n - x + 1): total = 0 for di in range(x): for dj in range(x): total += grid[i + di][j + dj] if total > threshold: count += 1 return count"},{"question":"Given an integer array `arr` and an integer `k`, rearrange the elements in `arr` such that any two adjacent elements have an absolute difference of at most `k`. If it\'s not possible to rearrange the array to meet the condition, return an empty array. Otherwise, return any rearrangement of the array that meets the condition. For example: - Input: `arr = [1, 3, 5, 8]`, `k = 3` - Output: `[1, 3, 5, 8]` or any valid rearrangement like `[3, 1, 5, 8]` or `[8, 5, 3, 1]`. This challenge will test your ability to manipulate arrays and ensure certain conditions are met within the rearranged structure.","solution":"def rearrange_array(arr, k): Rearranges the elements in arr such that any two adjacent elements have an absolute difference of at most k. If it\'s not possible, returns an empty array. Parameters: arr (list of int): The input array to be rearranged. k (int): The maximum allowed absolute difference between adjacent elements. Returns: list of int: A rearranged array that meets the condition, or an empty array if not possible. if not arr: return [] # First, we sort the array arr.sort() # Check from sorted array if we can rearange elements for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) > k: return [] return arr"},{"question":"A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). For example, `madam`, `racecar`, and `12321` are all palindromes. Write a function that accepts a string and returns `true` if it is a palindrome and `false` otherwise. Your function should ignore cases and non-alphanumeric characters. You may assume that the input string will not be longer than 100,000 characters.","solution":"import re def is_palindrome(s): Returns True if the given string is a palindrome, False otherwise. This function ignores spaces, punctuation, and capitalization. # Remove all non-alphanumeric characters and convert to lowercase s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Check if the string is equal to its reverse return s == s[::-1]"},{"question":"You are given a list of `available_items` representing the quantities of different items available in a warehouse and a list of `orders` where each order is a tuple `(item_index, quantity)` representing an order for a specific quantity of an item identified by its index in `available_items`. Write a function to process the orders in the given sequence and return a list of booleans representing whether each order can be completely fulfilled (True) or not (False). An order can be fulfilled if the quantity requested does not exceed the current quantity available for that item. After processing an order, the available quantity for that item should be decreased accordingly.","solution":"def process_orders(available_items, orders): Processes a list of orders and returns a list of booleans indicating whether each order can be completely fulfilled. Args: available_items (list of int): The quantities available for each item. orders (list of tuple): Each tuple represents an order in the format (item_index, quantity). Returns: list of bool: A list of booleans where each boolean represents whether the corresponding order can be completely fulfilled. result = [] for item_index, quantity in orders: if 0 <= item_index < len(available_items) and available_items[item_index] >= quantity: result.append(True) available_items[item_index] -= quantity else: result.append(False) return result"},{"question":"You are given a list of strings `words` and a string `targetWord`. Your goal is to find the number of unique words in the list that can be transformed into `targetWord` by rearranging its letters. In other words, count the anagrams of `targetWord` that exist in the `words` list. Return _the number of such anagrams found in `words`._","solution":"def count_anagrams(words, targetWord): Returns the count of unique words in the list that are anagrams of the targetWord. Args: words: List of strings targetWord: A string whose anagrams we are checking in the list Returns: int: Count of unique anagrams of targetWord in the list from collections import Counter target_counter = Counter(targetWord) anagram_set = set() for word in words: if Counter(word) == target_counter: anagram_set.add(word) return len(anagram_set)"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the length of the longest substring that contains at most two distinct characters. If `s` is empty, return `0`.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring containing at most two distinct characters. if not s: return 0 left = 0 max_length = 0 char_count = {} for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given an unsorted array of integers `nums` and an integer `k`. The task is to find the **k-th smallest element** in the array. Note that it is the **k-th smallest element** in the sorted order, not the k-th distinct element. Implement a function `findKthSmallestElement(nums: List[int], k: int) -> int` that returns this element. You must optimize the function to have a time complexity better than O(n log n).","solution":"import heapq from typing import List def findKthSmallestElement(nums: List[int], k: int) -> int: Finds the k-th smallest element in the array. if k < 1 or k > len(nums): raise ValueError(\\"k is out of the valid range\\") # Using a heap to find the k-th smallest element min_heap = nums[:] heapq.heapify(min_heap) # Extract the k-th smallest element for _ in range(k - 1): heapq.heappop(min_heap) return heapq.heappop(min_heap)"},{"question":"Given a circular array of integers `nums` of size `n`, and an integer `k`, rotate the array to the right by `k` steps, where `k` is non-negative. Return the modified array after performing the rotation. A circular array wraps around when the end is reached, so elements shifted off the right end appear at the beginning in the same order.","solution":"def rotate_array(nums, k): Rotates the array to the right by k steps. Parameters: nums (list of int): The input circular array to be rotated. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. n = len(nums) k = k % n # In case k is greater than n return nums[-k:] + nums[:-k] # Rotate the array"},{"question":"Given an array of integers `nums`, return _the total number of pairs_ `(i, j)` _such that_ `nums[i]` _and_ `nums[j]` _(i ≠ j) are both even_. Since the number of pairs may be large, return the result modulo `10^9 + 7`.","solution":"def count_even_pairs(nums): Returns the total number of pairs (i, j) such that nums[i] and nums[j] (i ≠ j) are both even. The result is returned modulo 10^9 + 7. MOD = 10**9 + 7 even_count = sum(1 for num in nums if num % 2 == 0) if even_count < 2: return 0 # Number of ways to pick 2 even numbers from even_count return (even_count * (even_count - 1) // 2) % MOD"},{"question":"You are given a string `s` representing a sequence of parentheses, and an integer `k`. To create a valid parentheses string, you can perform two types of operations: - **Add** a parenthesis (either \'(\' or \')\') at any position in the string. - **Remove** a parenthesis from any position in the string. Return _the minimum number of operations needed to make the parentheses string valid._ A parentheses string is valid if each opening parenthesis \'(\' has a corresponding closing parenthesis \')\', and pairs of parentheses are properly nested.","solution":"def min_operations_to_make_valid(s, k): Returns the minimum number of operations needed to make the parentheses string valid. # Stack to track unmatched opening parentheses stack = [] # Unmatched closing parentheses unbalanced_closing = 0 # Traverse the string to identify unmatched parentheses for char in s: if char == \'(\': stack.append(char) elif char == \')\': if stack: stack.pop() else: unbalanced_closing += 1 # The number of operations needed to balance the unmatched parentheses # will be the sum of the size of the stack (unmatched openings) and # the unbalanced closing parentheses return len(stack) + unbalanced_closing"},{"question":"Given a binary tree, return its zigzag level order traversal. In zigzag level order traversal, the nodes are visited from left to right, then right to left for the next level, and so on, alternately changing the direction. The tree is represented by TreeNode where the TreeNode definition is as follows: ``` class TreeNode { public: int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} } ``` Implement the function `vector<vector<int>> zigzagLevelOrder(TreeNode* root)` that returns a 2D vector where each inner vector represents the nodes at each level of the binary tree, in zigzag order.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. if not root: return [] results = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) results.append(list(level_nodes)) left_to_right = not left_to_right return results"},{"question":"You are given a string `s` consisting of only lowercase English letters and an integer `n`. Return _the length of the longest substring of `s` where the number of distinct characters is exactly `n`_. If no such substring exists, return `-1`.","solution":"def longest_substring_with_n_distinct_chars(s, n): Returns the length of the longest substring of `s` where the number of distinct characters is exactly `n`. If no such substring exists, return `-1`. if n == 0: return -1 if s else 0 max_length = -1 char_count = {} left = 0 for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > n: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == n: max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `arr` and an integer `k`. Your task is to find the minimum number of adjacent swaps required to make the maximum integer in `arr` be at least `k` places from the start of the array. Return the minimal number of swaps needed to achieve this. If it\'s not possible to satisfy the condition, return `-1`.","solution":"def min_adjacent_swaps_to_move_max_at_least_k_places(arr, k): Returns the minimum number of adjacent swaps required to move the maximum integer in arr at least k places from the start of the array. If it\'s not possible, return -1. max_val = max(arr) max_index = arr.index(max_val) if max_index >= k: return 0 if k >= len(arr): return -1 swaps_needed = k - max_index return swaps_needed"},{"question":"Design an algorithm that takes a matrix of integers where each row is sorted in ascending order. Return the **k-th smallest element** in the matrix. Note that it is the k-th smallest element in the sorted order, not the k-th distinct element. For example, consider the following matrix: ``` [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] ``` If `k = 8`, the k-th smallest element in the matrix is `13`. Implement the function: ```python def kthSmallest(matrix: List[List[int]], k: int) -> int ```","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in a sorted matrix. Parameters: matrix (List[List[int]]): 2D list of integers where each row is sorted in ascending order. k (int): The order of the smallest element to find. Returns: int: The k-th smallest element in the matrix. # Min-heap to store the smallest elements from each row min_heap = [] # Add the first element of each row into the min-heap for r in range(min(len(matrix), k)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k times to get the k-th smallest element while k > 0: element, r, c = heapq.heappop(min_heap) # If there\'s a next element in the same row, push it to the heap if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"You are given an `m x n` integer grid `heights` representing the height of each unit cell in a hilly area. An island is defined to be a group of `1`s at four connectivity (i.e., vertical or horizontal) surrounded by `0`s. Two islands are distinct if and only if they are not connected. Return _the number of distinct islands_ in the grid.","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the grid where an island is defined as a group of 1s connected vertically or horizontally and surrounded by 0s. :param grid: List[List[int]], the heights grid :return: int, number of distinct islands rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c, direction): if (r >= 0 and r < rows and c >= 0 and c < cols and grid[r][c] == 1 and (r, c) not in visited): visited.add((r, c)) shape.append(direction) dfs(r+1, c, \\"D\\") dfs(r-1, c, \\"U\\") dfs(r, c+1, \\"R\\") dfs(r, c-1, \\"L\\") shape.append(\\"B\\") # Add a backtrack step to record the shape correctly shapes = set() for r in range(rows): for c in range(cols): if grid[r][c] == 1 and (r, c) not in visited: shape = [] dfs(r, c, \\"S\\") shapes.add(tuple(shape)) return len(shapes)"},{"question":"Given an array of integers `arr`, return `true` if there are three consecutive elements in the array that are strictly increasing, otherwise return `false`.","solution":"def has_three_consecutive_increasing(arr): Returns true if there are three consecutive elements in the array that are strictly increasing, otherwise returns false. for i in range(len(arr) - 2): if arr[i] < arr[i + 1] < arr[i + 2]: return True return False"},{"question":"Implement the `WordDistance` class that stores a list of words and provides a method to find the shortest distance between any two different words in the list. * `WordDistance(List<String> wordsDict)` Initializes the object with the words in the list. * `int shortest(String word1, String word2)` Returns the shortest distance between `word1` and `word2` in the list. The distance between two words is defined as the number of indices between them. It is guaranteed that both words will exist in the list.","solution":"class WordDistance: def __init__(self, wordsDict): Initializes the object with the words in the list. :param wordsDict: List of words. self.word_positions = {} for index, word in enumerate(wordsDict): if word not in self.word_positions: self.word_positions[word] = [] self.word_positions[word].append(index) def shortest(self, word1, word2): Returns the shortest distance between word1 and word2 in the list. :param word1: First word. :param word2: Second word. :return: Shortest distance between word1 and word2. positions1 = self.word_positions[word1] positions2 = self.word_positions[word2] i, j = 0, 0 min_distance = float(\'inf\') while i < len(positions1) and j < len(positions2): min_distance = min(min_distance, abs(positions1[i] - positions2[j])) if positions1[i] < positions2[j]: i += 1 else: j += 1 return min_distance"},{"question":"You are given an integer array `height` of length `n` representing the heights of `n` buildings in a city, where the width of each building is exactly `1` unit. The city planning department wants to install a new advertising banner that will be placed across some of these buildings. However, the banner must be perfectly rectangular and fit within the height of the shortest building it spans. Given the heights of the buildings, determine the maximum area of a rectangle that can be formed by choosing a subset of these buildings the banner will cover. Write a function that computes and returns this maximum area.","solution":"def largestRectangleArea(heights): Computes the maximum area of a rectangle that can be formed by choosing a subset of buildings. :param heights: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"Given an integer array `nums`, find the next permutation of the array. The next permutation is the lexicographically next greater permutation of numbers. If such permutation is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order). The replacement must be in-place and use only constant extra memory. Return the array after rearranging it into the next permutation.","solution":"def next_permutation(nums): Rearrange the array `nums` into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order). The replacement is done in-place with constant extra memory. Parameters: nums (List[int]): The list of integers to rearrange. Returns: List[int]: The rearranged list as the next permutation. # Find the first decrease from the end i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Find the element just larger than the one at i j = len(nums) - 1 while j >= 0 and nums[j] <= nums[i]: j -= 1 # Swap them nums[i], nums[j] = nums[j], nums[i] # Reverse the elements from i+1 to end to get the next smallest lexicographical order nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"You are given a list of `n` intervals, where each interval is represented as a pair of integers `[start, end]` indicating the start and end time of the interval. Write a function that finds the minimum number of meeting rooms required to accommodate all the meetings without conflicts. Each meeting must take place in a separate room if it overlaps with another meeting in time. The function should return an integer representing the minimum number of meeting rooms needed.","solution":"def minMeetingRooms(intervals): Returns the minimum number of meeting rooms required to accommodate all the meetings without conflicts. :param intervals: List of intervals where each interval is a list [start, end]. if not intervals: return 0 # Separate start and end times starts = sorted(interval[0] for interval in intervals) ends = sorted(interval[1] for interval in intervals) start_ptr, end_ptr = 0, 0 used_rooms = 0 max_rooms = 0 while start_ptr < len(intervals): # If the meeting starts before or when another meeting ends if starts[start_ptr] < ends[end_ptr]: used_rooms += 1 start_ptr += 1 else: used_rooms -= 1 end_ptr += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"You are given a list of integers representing the heights of buildings along a street, where the `i-th` integer represents the height of the `i-th` building. A building `i` has an **ocean view** if all the buildings to its right have a smaller height than the building itself. Write a function that returns a list of indices of all buildings that have an **ocean view**, sorted in ascending order.","solution":"def find_buildings_with_ocean_view(heights): Returns a list of indices of all buildings that have an ocean view. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: list: A list of indices with ocean views, sorted in ascending order. n = len(heights) result = [] max_height_so_far = float(\'-inf\') for i in range(n-1, -1, -1): if heights[i] > max_height_so_far: result.append(i) max_height_so_far = heights[i] return result[::-1]"},{"question":"Given an array of integers `nums` and an integer `k`, return _the smallest number of steps to reduce the array until all elements are less than or equal to_ `k`. In one step, you can choose an element and either add or subtract `1` to/from it.","solution":"def min_steps_to_reduce(nums, k): Returns the smallest number of steps to reduce the array so that all elements are less than or equal to k. Parameters: nums (list of int): The array of integers. k (int): The threshold value. Returns: int: The minimum steps needed. steps = 0 for num in nums: if num > k: steps += num - k return steps"},{"question":"Given a **0-indexed** integer array `arr` and an integer `k`, implement a function to find the maximum value of the following expression for different choices of subarrays `(arr[i], arr[j])` such that `i <= j`: [ text{max}(arr[i], arr[j]) + k cdot |i - j| ] The function should return the maximum value of this expression. Use efficient algorithms to optimize the solution within reasonable time complexity for large input sizes.","solution":"def max_expression(arr, k): Finds the maximum value of max(arr[i], arr[j]) + k * |i - j| for different choices of subarrays (arr[i], arr[j]). if not arr: return 0 n = len(arr) max_value = float(\'-inf\') for i in range(n): for j in range(i, n): current_value = max(arr[i], arr[j]) + k * (j - i) max_value = max(max_value, current_value) return max_value"},{"question":"You are given a string `text` consisting of lowercase English letters and an integer `k`. You need to select a maximum of `k` characters from `text` such that each character is unique and their order in the string is preserved. If there are multiple results, return the lexicographically smallest one. Return _the resulting string after selecting up to `k` unique characters preserving their order from the original string_.","solution":"def select_k_unique_chars(text, k): Select a maximum of k characters from text such that each character is unique and their order in the string is preserved. unique_chars = set() result = [] for char in text: if char not in unique_chars: if len(unique_chars) < k: unique_chars.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given a **0-indexed** integer array `weights` representing the weights of `n` items and a positive integer `maxWeight`. You need to determine the maximum number of items that can be selected such that the sum of their weights does not exceed `maxWeight`. Return _the maximum number of items that can be selected_.","solution":"def max_items_that_fit(weights, maxWeight): Determines the maximum number of items that can be selected such that the sum of their weights does not exceed maxWeight. :param weights: List of item weights (non-negative integers). :param maxWeight: The maximum allowable weight sum (positive integer). :return: Maximum number of items that can be selected. weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= maxWeight: total_weight += weight count += 1 else: break return count"},{"question":"Given an array of `words` and an integer `k`, return the `k` most frequent words in the array. The answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Define the `WordsFrequency` class with the following methods: * `WordsFrequency(String[] words)` Initializes the object with the array of words `words`. * `List<String> getTopKFrequent(int k)` Returns the list of `k` most frequent words.","solution":"from typing import List from collections import Counter class WordsFrequency: def __init__(self, words: List[str]): self.words_counter = Counter(words) def getTopKFrequent(self, k: int) -> List[str]: # Sort words by frequency and then alphabetically sorted_words = sorted(self.words_counter.keys(), key=lambda word: (-self.words_counter[word], word)) return sorted_words[:k]"},{"question":"You are given a 2D integer array `matrix` representing a `m x n` grid where `matrix[i][j]` is the number of obstacles in the cell. You need to find a path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` such that the sum of the obstacles encountered along the path is minimized. You can move only right or down from a cell. Return the minimum sum of obstacles to reach the bottom-right corner from the top-left corner.","solution":"def min_path_sum(matrix): Returns the minimum sum of obstacles to reach the bottom-right corner from the top-left corner. You can only move right or down from a cell. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Initialize the first row and first column for i in range(1, m): matrix[i][0] += matrix[i-1][0] for j in range(1, n): matrix[0][j] += matrix[0][j-1] # Fill the rest of the matrix for i in range(1, m): for j in range(1, n): matrix[i][j] += min(matrix[i-1][j], matrix[i][j-1]) return matrix[m-1][n-1]"},{"question":"You are given a **0-indexed** `m x n` binary matrix `grid` representing a field, where `0` represents barren land and `1` represents fertile land. You can perform the following operation on the grid: Choose any (sub)matrix of size `k x k` from `grid` (i.e., a contiguous block of `k` rows and `k` columns) and change all barren cells (`0`) in that submatrix to fertile cells (`1`). The operation can be performed multiple times and on different submatrices. However, the goal is to make all cells in the `grid` fertile cells using the **minimum number** of such operations. Given the dimensions of the grid, `m` and `n`, along with `k`, return _the **minimum number of operations** required to make all cells in the grid `1`_.","solution":"import math def min_operations(m, n, k): Calculate the minimum number of `k x k` matrices required to cover an `m x n` grid. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. k (int): Size of the submatrix. Returns: int: Minimum number of k x k operations required to fully cover the grid. rows_needed = math.ceil(m / k) cols_needed = math.ceil(n / k) return rows_needed * cols_needed"},{"question":"Given an integer array `arr`, write a function to find the maximum sum of any contiguous subarray of `arr` with at least one element. The function should return an object containing the sum, as well as the start and end indices of the subarray. Implement the function `findMaxSubarray` with the following signature: ``` function findMaxSubarray(arr: number[]): { maxSum: number, start: number, end: number } ``` Your function should use a linear-time algorithm to solve the problem. Example: ``` Input: arr = [-2,1,-3,4,-1,2,1,-5,4] Output: { maxSum: 6, start: 3, end: 6 } // Explanation: The subarray [4, -1, 2, 1] has the largest sum 6. ```","solution":"def findMaxSubarray(arr): Find the maximum sum of any contiguous subarray with at least one element. Args: arr (list of int): The input array Returns: dict: A dictionary containing \'maxSum\', \'start\', and \'end\' indices # Initialize variables max_sum = float(\'-inf\') current_sum = 0 start = end = temp_start = 0 for i in range(len(arr)): if current_sum <= 0: temp_start = i current_sum = arr[i] else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return {\'maxSum\': max_sum, \'start\': start, \'end\': end}"},{"question":"You are given a 2D integer matrix `mat` representing a grid of size `m x n`, and an integer `threshold`. The matrix elements are non-negative integers representing heights. Your task is to find the largest side length of a square subgrid, such that the sum of the elements inside the square subgrid is less than or equal to `threshold`. Return the side length of the largest such square subgrid. If no such square subgrid exists, return 0.","solution":"def maxSideLength(mat, threshold): def get_sum(x1, y1, x2, y2, prefix_sum): return prefix_sum[x2 + 1][y2 + 1] - prefix_sum[x1][y2 + 1] - prefix_sum[x2 + 1][y1] + prefix_sum[x1][y1] m, n = len(mat), len(mat[0]) prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): prefix_sum[i + 1][j + 1] = mat[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] max_side = 0 for side_len in range(1, min(m, n) + 1): found = False for i in range(m - side_len + 1): for j in range(n - side_len + 1): if get_sum(i, j, i + side_len - 1, j + side_len - 1, prefix_sum) <= threshold: found = True max_side = side_len if not found: break return max_side"},{"question":"Given a matrix `grid` where each cell contains a positive integer, you are to perform a series of **update** operations and **query** operations. For each `update` operation, you will be given a coordinate `(x, y)` and a new value `val` to update `grid[x][y]` to `val`. For each `query` operation, you will be given the coordinates of a submatrix from `(x1, y1)` to `(x2, y2)`, and you are to return the sum of all values within this submatrix. Implement a data structure that supports efficient execution of a sequence of `update` and `query` operations. Return an array `results` where `results[i]` is the result of the i-th query operation.","solution":"class NumMatrix: def __init__(self, grid): Initialize the object with the integer matrix `grid`. if not grid or not grid[0]: raise ValueError(\\"Grid must be non-empty\\") self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) self.bit = [[0] * (self.cols + 1) for _ in range(self.rows + 1)] self.buildBIT() def buildBIT(self): for i in range(self.rows): for j in range(self.cols): self.updateBIT(i, j, self.grid[i][j]) def updateBIT(self, row, col, val): x = row + 1 while x <= self.rows: y = col + 1 while y <= self.cols: self.bit[x][y] += val y += (y & -y) x += (x & -x) def sumRegionBIT(self, row, col): result = 0 x = row + 1 while x > 0: y = col + 1 while y > 0: result += self.bit[x][y] y -= (y & -y) x -= (x & -x) return result def update(self, x, y, val): Update the value of grid[x][y] to val. diff = val - self.grid[x][y] self.grid[x][y] = val self.updateBIT(x, y, diff) def sumRegion(self, x1, y1, x2, y2): Return the sum of the elements of the submatrix from (x1, y1) to (x2, y2), inclusive. return (self.sumRegionBIT(x2, y2) - self.sumRegionBIT(x1 - 1, y2) - self.sumRegionBIT(x2, y1 - 1) + self.sumRegionBIT(x1 - 1, y1 - 1))"},{"question":"You are provided with a list of `n` integers. Write a function that returns the **maximum** product you can get by multiplying any three distinct integers from the list. Ensure your solution handles both positive and negative integers. If there are fewer than three integers in the list, return `0`.","solution":"def maximum_product_of_three(numbers): Returns the maximum product obtained by multiplying any three distinct integers from the list. If there are fewer than three integers in the list, returns 0. Parameters: numbers (list): A list of integers. Returns: int: The maximum product of three distinct integers from the list. if len(numbers) < 3: return 0 numbers.sort() # Finding the product of three largest numbers max_product1 = numbers[-1] * numbers[-2] * numbers[-3] # Finding the product of two smallest numbers and the largest number max_product2 = numbers[0] * numbers[1] * numbers[-1] return max(max_product1, max_product2)"},{"question":"You are given a string `s` and a list of indices `indices` (0-indexed). The string `s` is initially in its original order, and you need to shuffle the characters according to the given `indices` such that the character at the `i-th` position moves to `indices[i]` in the shuffled string. Return the shuffled string.","solution":"def restore_string(s, indices): Shuffles the characters of \'s\' according to the given \'indices\'. Args: s (str): the original string. indices (List[int]): the list of indices for shuffling. Returns: str: the shuffled string. shuffled = [\'\'] * len(s) # Initialize an empty list to hold shuffled characters for i, index in enumerate(indices): shuffled[index] = s[i] # Place each character at the correct index return \'\'.join(shuffled) # Join the list into a string and return"},{"question":"You are given an array of strings `words` and a string `chars`. A string is considered \\"good\\" if it can be formed using the characters in `chars` without any character repetition (each character in `chars` can only be used once). Return the sum of the lengths of all \\"good\\" strings in `words`. * `words` is an array of strings * `chars` is a string containing the characters available to form \\"good\\" strings **Example:** ```python words = [\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"] chars = \\"atach\\" ``` **Output:** ```python 6 ``` _Explanation:_ \\"cat\\" and \\"hat\\" can be formed using characters from `chars`, and their lengths are 3 and 3, respectively. \\"bt\\" and \\"tree\\" cannot be formed entirely using characters from `chars`. Write a function to solve the problem.","solution":"def count_good_strings(words, chars): Returns the sum of the lengths of all \\"good\\" strings in words. from collections import Counter char_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) can_form = True for char in word_count: if word_count[char] > char_count.get(char, 0): can_form = False break if can_form: total_length += len(word) return total_length"},{"question":"Given a string `s` containing only lowercase English letters, construct the shortest possible palindrome by adding characters to the end of `s`. Return the shortest palindrome you can get by performing this transformation.","solution":"def shortest_palindrome(s): Constructs the shortest possible palindrome by adding characters to the end of the given string. def is_palindrome(x): return x == x[::-1] if is_palindrome(s): return s for i in range(len(s)): if is_palindrome(s[i:]): return s + s[:i][::-1] return s"},{"question":"Given a list of integers `nums` and an integer `k`, partition the list into two subarrays such that the difference in the sum of the elements of the two subarrays is minimized. The difference is defined as the absolute difference between the sums of the two subarrays. Return the minimum possible difference.","solution":"def minDifferencePartition(nums, k): Partition the list nums into two subarrays such that the difference in the sum of the elements of the two subarrays is minimized. k is just an extra parameter which is not used in this function. Args: nums (list): list of integers k (int): a given integer that is unused in the function Returns: int: the minimum possible difference between the sums of the two subarrays total_sum = sum(nums) half_sum = total_sum // 2 n = len(nums) # Initialize the dp array dp = [0] * (half_sum + 1) for num in nums: for j in range(half_sum, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) min_diff = abs(total_sum - 2 * dp[half_sum]) return min_diff"},{"question":"You are given two sorted arrays of integers `arr1` and `arr2`, and an integer `k`. Your task is to merge these two sorted arrays and return the `k`-th smallest element in the merged array. If `k` is larger than the total number of elements in the merged array, return `-1`.","solution":"def kth_smallest_element(arr1, arr2, k): Returns the k-th smallest element in the merged sorted array of arr1 and arr2. If k is larger than the total number of elements in the merged array, return -1. merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 if k > len(merged): return -1 return merged[k-1]"},{"question":"Given an array of integers `nums` where each integer represents a digit from `0` to `9`, and an integer `k`. You are allowed to remove exactly `k` digits from the array to form the smallest possible number. Return _the smallest possible number_ that can be formed as a string of digits after removing exactly `k` digits. **Note**: The resulting number should not contain leading zeroes. If the resulting number is empty, return \\"0\\".","solution":"def removeKdigits(num: str, k: int) -> str: Remove k digits from the `num` to form the smallest possible number. stack = [] for digit in num: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still digits to remove, remove them from the end while k > 0: stack.pop() k -= 1 # Convert list to string and remove leading zeros result = \'\'.join(stack).lstrip(\'0\') return result if result else \\"0\\""},{"question":"Given an array of integers `arr` where the elements can be both positive and negative, return the length of the longest subarray that starts and ends with the same element. If no such subarray exists, return `0`. To clarify, a subarray is a contiguous segment of the array.","solution":"def longest_subarray_with_same_start_end(arr): Given an array of integers, returns the length of the longest subarray that starts and ends with the same element. If no such subarray exists, return 0. max_length = 0 n = len(arr) for i in range(n): for j in range(i, n): if arr[i] == arr[j]: max_length = max(max_length, j - i + 1) return max_length"},{"question":"You are given a string `s` and a list of word lists `wordList`. Each word list contains a list of words that can be substituted for each other. Return _all possible unique sentences that can be formed by replacing words in the string with words from their respective word lists_. Words in the string and the words in the word lists are always separated by single spaces. - Note that each word in the string may only be replaced with words from the corresponding word list (if it exists), and the words should remain in their original order. If a word in the string does not have a corresponding word list, it should remain unchanged in the sentences.","solution":"import itertools def possible_sentences(s, wordList): Generate all possible unique sentences by replacing the words in the string with words from their respective word lists. :param s: Original sentence as a string. :param wordList: List of lists, where each sublist contains words that can be substituted with each other. :return: Set of all possible unique sentences. words = s.split() word_dict = {word: substitutes for word_list in wordList for word in word_list for substitutes in [word_list]} def get_substitutes(word): return word_dict.get(word, [word]) substitute_combinations = [get_substitutes(word) for word in words] all_possible_sentences = [\' \'.join(sentence) for sentence in itertools.product(*substitute_combinations)] return set(all_possible_sentences)"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and two integers `k1` and `k2`. You are tasked with finding the `k1`-th smallest number common to both arrays and the `k2`-th smallest number common to both arrays. If there are fewer than `k1` or `k2` common elements, return `-1` for the respective k-th smallest number. Your function should return a list with two elements, the `k1`-th smallest common number and the `k2`-th smallest common number. If there are fewer than `k1` or `k2` common elements, the corresponding position should have `-1`. The solution should have a time complexity better than `O(n * m)`, where `n` and `m` are the lengths of `nums1` and `nums2` respectively.","solution":"def find_kth_smallest_common(nums1, nums2, k1, k2): Finds the k1-th and k2-th smallest common elements in nums1 and nums2. If fewer than k1 or k2 common elements exist, returns -1 for the respective positions. common_elements = set(nums1).intersection(nums2) common_sorted = sorted(common_elements) result = [] for k in [k1, k2]: if k <= len(common_sorted): result.append(common_sorted[k-1]) else: result.append(-1) return result"},{"question":"Given a binary tree where each node contains an integer value, return the sum of the integers in all the longest paths from the root to a leaf node. If there are multiple longest paths, sum the integers of each of those paths. If the tree is empty, return 0.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_longest_path(root): Returns the sum of the integers in all the longest paths from the root to a leaf node. if not root: return 0 def dfs(node): if not node: return (0, 0) # (sum, length) left_sum, left_len = dfs(node.left) right_sum, right_len = dfs(node.right) if left_len > right_len: return (left_sum + node.val, left_len + 1) elif right_len > left_len: return (right_sum + node.val, right_len + 1) else: return (left_sum + right_sum + node.val, left_len + 1) total_sum, _ = dfs(root) return total_sum"},{"question":"Given an integer array `nums` and an integer `k`, determine if there is a subarray of length `k` that appears more than once in the array. A subarray is a contiguous portion of the array. Return `true` if there is at least one such subarray, and `false` otherwise.","solution":"def has_duplicate_subarray(nums, k): Determines if there is a subarray of length k that appears more than once in the array. :param nums: List of integers. :param k: Length of the subarray. :return: True if there\'s at least one subarray of length k that appears more than once, False otherwise. seen = set() for i in range(len(nums) - k + 1): # Generate the subarray of length k subarray = tuple(nums[i:i + k]) if subarray in seen: return True seen.add(subarray) return False"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to find the number of contiguous subarrays of length `k` that have at least one even number. Return the count of such subarrays. If `k` is greater than the length of `nums`, return `0`.","solution":"def count_subarrays_with_even(nums, k): Returns the number of contiguous subarrays of length `k` that have at least one even number. if k > len(nums): return 0 count = 0 # Iterate over all possible subarrays of length k for i in range(len(nums) - k + 1): subarray = nums[i:i + k] if any(num % 2 == 0 for num in subarray): count += 1 return count"},{"question":"Given an array of integers `arr`, split the array into `n` consecutive subarrays such that the sum of the maximum element of each subarray is minimized. Return _the minimum possible sum of the maximum elements of the subarrays_. Note that each element of the original array must be included in exactly one subarray and splits must occur between elements.","solution":"def can_partition(arr, mid, n): Helper function to determine if the array can be partitioned into n subarrays with maximum subarray sum less than or equal to mid. count, total_sum = 1, 0 for num in arr: if total_sum + num > mid: total_sum = num count += 1 else: total_sum += num if count > n: return False return True def minimize_max_sum_of_subarrays(arr, n): Given an array arr and an integer n, split the array into n consecutive subarrays such that the sum of the maximum element of each subarray is minimized. low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if can_partition(arr, mid, n): high = mid else: low = mid + 1 return low"},{"question":"You are given an array of `n` integers, where each integer represents a position on a number line. Assume that each position `i` in the array has a unique identifier linked to it. Your task is to find and return the identifier of the position that is closest to the median of all positions in the array. If there are two positions equally close to the median, return the identifier of the smaller position. Note that the median of an array is the middle element when the array is sorted, or the average of the two middle elements if the array has an even number of elements. **Custom testing:** * The input will be an array of integers representing positions, and an array of unique integers representing the corresponding identifiers. * The output should be a single integer which is the identifier of the position closest to the median.","solution":"def find_closest_to_median(positions, identifiers): Returns the identifier of the position closest to the median of the positions. Parameters: positions (list of int): An array of integers representing positions on a number line. identifiers (list of int): An array of unique integers representing the corresponding identifiers. Returns: int: The identifier of the position closest to the median. sorted_positions = sorted(zip(positions, identifiers)) n = len(positions) if n % 2 == 1: median_value = sorted_positions[n // 2][0] else: median_value = (sorted_positions[n // 2][0] + sorted_positions[n // 2 - 1][0]) / 2 closest_position = None closest_identifier = None smallest_diff = float(\'inf\') for pos, iden in sorted_positions: diff = abs(pos - median_value) if diff < smallest_diff or (diff == smallest_diff and (closest_position is None or pos < closest_position)): smallest_diff = diff closest_position = pos closest_identifier = iden return closest_identifier"},{"question":"You are given a 2D integer array `matrix` representing an `m x n` grid, where each element in the grid is either `0` or `1`. A path from top-left to bottom-right exists if we can move either right or down at any point in time along cells containing `1` only. Return _the length of the shortest such path if it exists, otherwise return_ `-1`.","solution":"from collections import deque def shortest_path(matrix): Returns the length of the shortest path from top-left to bottom-right in the matrix where a path can only traverse cells with value 1. Moves are restricted to right and down directions. If no such path exists, returns -1. if not matrix or not matrix[0] or matrix[0][0] == 0 or matrix[-1][-1] == 0: return -1 m, n = len(matrix), len(matrix[0]) directions = [(1, 0), (0, 1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == m - 1 and c == n - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and matrix[nr][nc] == 1: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given an array of integers `arr` where each integer appears exactly three times, except for one integer which appears exactly once. Find and return the integer that appears exactly once. Please implement an efficient solution with a linear time complexity.","solution":"def single_number(arr): Returns the integer that appears exactly once in the array. All other integers appear exactly three times. ones, twos = 0, 0 for num in arr: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"You are given a list of intervals `intervals` where each interval is represented as a pair of integers `[start, end]`. The intervals may overlap. You need to find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Return _the number of intervals you need to remove_. **Example:** ```python Input: intervals = [[1,2],[2,3],[3,4],[1,3]] Output: 1 ``` In the example, you can remove the interval `[1,3]` to make the rest of the intervals non-overlapping: `[1,2]`, `[2,3]`, `[3,4]`. Ensure your solution uses efficient techniques to handle larger lists of intervals.","solution":"def eraseOverlapIntervals(intervals): Finds the minimum number of intervals to remove to make the rest of the intervals non-overlapping. Args: intervals (List[List[int]]): List of intervals represented as pairs [start, end]. Returns: int: The minimum number of intervals to remove. if not intervals: return 0 # Sort intervals by their end time intervals.sort(key=lambda x: x[1]) # Initialize variables remove_count = 0 # Number of intervals to remove prev_end = intervals[0][1] # End time of the last interval added to the final set # Loop through the intervals starting from the second one for i in range(1, len(intervals)): if intervals[i][0] < prev_end: # If current interval\'s start is before the end of the previous interval, remove it remove_count += 1 else: # Otherwise, update the end time of the last added interval prev_end = intervals[i][1] return remove_count"},{"question":"You are given a string `s` consisting of only characters \'a\', \'b\', and \'c\'. We call the string **valid** if for every \'a\' there are two additional characters \'b\' and \'c\' in the string, and they are in the order \'a\', \'b\', and \'c\'. Write a function that takes the string `s` and returns _the length of the longest substring of `s` that is valid_. If no such valid substring exists, return 0.","solution":"def longest_valid_substring(s): Returns the length of the longest valid substring (\'a\' followed by \'b\' and \'c\') in the given string s. max_length = 0 current_length = 0 a_count = 0 for char in s: if char == \'a\': a_count += 1 current_length = 1 elif char == \'b\' and a_count > 0: current_length += 1 elif char == \'c\' and a_count > 0 and current_length == 2: current_length += 1 max_length = max(max_length, current_length) a_count -= 1 current_length = 0 # reset for a new potential valid substring else: a_count = 0 current_length = 0 return max_length"},{"question":"You are given an array of integers `front` and `back` where `front[i]` and `back[i]` represent the numbers displayed on the front and back of the `i-th` card respectively. You want to flip some cards so that one or more of them reveal the same number on the front side. You cannot reveal a number that is present on one of the backs of the cards you flipped. Return the smallest number you can reveal on the front of at least one card after flipping any subset of the cards (including not flipping any). If no such number exists, return 0.","solution":"def flipgame(front, back): same_numbers = {x for i, x in enumerate(front) if x == back[i]} res = float(\'inf\') for num in front + back: if num not in same_numbers: res = min(res, num) return res if res != float(\'inf\') else 0"},{"question":"Given a binary tree, implement the `BinaryTree` class that supports two operations: * `BinaryTree(TreeNode root)`: Initializes the object with the root of the binary tree `root`. * `List<Integer> getRightView()`: Returns the list of values visible from the right view of the binary tree. The `TreeNode` class is defined as: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } } ``` For example, given the following binary tree: ``` 1 / 2 3 5 4 ``` The right view would be `[1, 3, 4]`. Return the visible nodes when viewed from the right side of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root: TreeNode): self.root = root def getRightView(self) -> list: Returns the list of values visible from the right view of the binary tree. if not self.root: return [] right_view = [] queue = [(self.root, 0)] while queue: current_level_size = len(queue) for i in range(current_level_size): node, level = queue.pop(0) if i == current_level_size - 1: # Last element of the current level right_view.append(node.val) if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return right_view"},{"question":"You are given a grid of size `m x n` filled with non-negative numbers representing the height of bars in a 2D histogram, where each bar\'s width is `1`. The grid starts at the bottom-left corner and extends to the top-right corner. Your task is to find the largest rectangle containing only 1s and return its area.","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 n = len(matrix[0]) heights = [0] * (n + 1) for row in matrix: for i in range(n): heights[i] = heights[i] + 1 if row[i] == \'1\' else 0 stack = [-1] for j in range(n + 1): while heights[j] < heights[stack[-1]]: h = heights[stack.pop()] w = j - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(j) return max_area"},{"question":"**[Question 4]:** You are given a binary tree where each node contains an integer value. Design an algorithm that serializes the tree to a single string and deserializes that string back to the original tree structure. The serialized string should represent the tree in a way that allows for efficient reconstruction. Implement the `BinaryTreeCodec` class: * `string serialize(TreeNode root)` Encodes a tree to a single string. * `TreeNode deserialize(String data)` Decodes your encoded data to tree. **Example:** ``` Input: 1 / 2 3 / 4 5 BinaryTreeCodec codec = new BinaryTreeCodec(); codec.deserialize(codec.serialize(root)); Output: The constructed binary tree should be identical to the input binary tree. ``` **Note:** - The input tree is guaranteed to have no more than 1000 nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeCodec: def serialize(self, root): Encodes a tree to a single string. def preorder(node): if not node: return [\\"None\\"] return [str(node.val)] + preorder(node.left) + preorder(node.right) return \',\'.join(preorder(root)) def deserialize(self, data): Decodes your encoded data to tree. def build_tree(vals): val = vals.pop(0) if val == \\"None\\": return None node = TreeNode(int(val)) node.left = build_tree(vals) node.right = build_tree(vals) return node vals = data.split(\',\') root = build_tree(vals) return root"},{"question":"Given a list of `n` integers and an integer `target`, find all unique triplets in the list that sum up to the `target`. Each triplet should be represented as a list `[x, y, z]`, where `x <= y <= z`. Note that the order of the triplets in the output does not matter, and the solution set must not contain duplicate triplets. Return _a list of all such triplets_.","solution":"def three_sum(nums, target): Given a list of integers and a target integer, finds all unique triplets in the list that sum up to the target. Each triplet is sorted in a non-decreasing order. nums.sort() result = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue # Skip same results left, right = i + 1, n - 1 while left < right: sum_value = nums[i] + nums[left] + nums[right] if sum_value == target: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_value < target: left += 1 else: right -= 1 return result"},{"question":"You are given a linked list where each node contains an integer value. Your task is to write a function that reverses every k nodes in the linked list. If the number of nodes is not a multiple of k, leave the remaining nodes as they are. For example, if the linked list is `1 -> 2 -> 3 -> 4 -> 5` and k is 2, the linked list should become `2 -> 1 -> 4 -> 3 -> 5`. Return the head of the modified linked list. The function should have a time complexity of O(n), where n is the number of nodes in the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head # Count the number of nodes in the linked list node_count = 0 ptr = head while ptr: node_count += 1 ptr = ptr.next dummy = ListNode(0) dummy.next = head prev = dummy while node_count >= k: # Reverse next k nodes tail = prev.next next_prev = tail for _ in range(k): tail = tail.next new_head = reverseLinkedList(prev.next, k) prev.next = new_head next_prev.next = tail prev = next_prev node_count -= k return dummy.next"},{"question":"Given a string `s` which represents a mathematical expression, implement a basic calculator to evaluate it and return the result as an integer. The expression string may contain open `(` and closing parentheses `)`, the plus `+` or minus `-` sign, non-negative integers, and empty spaces. The integer division should truncate toward zero.","solution":"def calculate(s): Evaluate a basic mathematical expression containing +, -, numbers, and parentheses. The expression is represented as a string. def apply_ops(operators, values): operator = operators.pop() b = values.pop() a = values.pop() if operator == \'+\': values.append(a + b) elif operator == \'-\': values.append(a - b) operators, values = [], [] i, n = 0, len(s) while i < n: if s[i] == \' \': i += 1 elif s[i] == \'(\': operators.append(s[i]) i += 1 elif s[i] == \')\': while operators and operators[-1] != \'(\': apply_ops(operators, values) operators.pop() # pop \'(\' i += 1 elif s[i] in \'+-\': while (operators and operators[-1] in \'+-\'): apply_ops(operators, values) operators.append(s[i]) i += 1 else: # Must be a number j = i while j < n and s[j].isdigit(): j += 1 values.append(int(s[i:j])) i = j while operators: apply_ops(operators, values) return values[0]"},{"question":"You are given an `n x n` binary grid, where each cell contains either a `0` or a `1`. A `0` represents water, and a `1` represents land. An island is a maximal group of `1`s connected horizontally or vertically. The grid has exactly **one** island. Return the **smallest bridge length** needed to connect the given island to itself, which would make it continuous in terms of connectivity. Here\'s a hint: the bridge length is the number of `0`s in the shortest path connecting two separate parts of the island.","solution":"from collections import deque def shortest_bridge(grid): def bfs(queue): visited = set() directions = [(-1,0), (1,0), (0,-1), (0,1)] while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: if grid[nx][ny] == 1: return dist elif grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) def find_island(): for i in range(n): for j in range(n): if grid[i][j] == 1: return i, j def mark_island(x, y, queue): directions = [(-1,0), (1,0), (0,-1), (0,1)] grid[x][y] = -1 queue.append((x, y, 0)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 1: mark_island(nx, ny, queue) n = len(grid) queue = deque() start_x, start_y = find_island() mark_island(start_x, start_y, queue) return bfs(queue)"},{"question":"You are given a 2D grid `grid` of `1`s (land) and `0`s (water). An **island** is a maximal 4-directionally connected group of `1`s. The **perimeter** of an island is the total length of the boundary between island cells and water cells. Return the perimeter of the island in `grid`. The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn\'t have \\"lakes\\" (water inside that isn\'t connected to the water around the island).","solution":"def islandPerimeter(grid): Calculates the perimeter of an island in the given grid. :param grid: List[List[int]] -- 2D list representing the grid with 1\'s as land and 0\'s as water. :return: int -- Perimeter of the island. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 if r > 0 and grid[r-1][c] == 1: # check cell above perimeter -= 2 if c > 0 and grid[r][c-1] == 1: # check cell to the left perimeter -= 2 return perimeter"},{"question":"Develop a system to manage a collection of user posts with voting capabilities. Each post can have upvotes, downvotes, and is categorized by a specific topic. Implement the `PostManager` class: * `PostManager()` Initializes an empty post manager. * `void createPost(String username, String topic, String content)` Creates a new post by a user in a specific topic with the given content. * `void upvotePost(int postId)` Adds an upvote to the post identified by `postId`. * `void downvotePost(int postId)` Adds a downvote to the post identified by `postId`. * `int getScore(int postId)` Returns the score of the post identified by `postId`, which is the difference between the number of upvotes and downvotes. * `List<String> getTopPosts(String topic, int k)` Returns the content of the top `k` posts for a given topic based on their score. If there is a tie in score, return the posts in descending order of their creation time (the latest post should come first). Your implementation should efficiently handle the management of posts, voting, and retrieval of top posts for given topics.","solution":"from collections import defaultdict class PostManager: def __init__(self): self.posts = [] self.topic_posts = defaultdict(list) self.post_votes = defaultdict(lambda: {\'upvotes\': 0, \'downvotes\': 0}) def createPost(self, username, topic, content): post_id = len(self.posts) post_data = {\'id\': post_id, \'username\': username, \'topic\': topic, \'content\': content, \'score\': 0} self.posts.append(post_data) self.topic_posts[topic].append(post_data) return post_id def upvotePost(self, postId): post = self.posts[postId] post_id = post[\'id\'] self.post_votes[post_id][\'upvotes\'] += 1 self._updatePostScore(post_id) def downvotePost(self, postId): post = self.posts[postId] post_id = post[\'id\'] self.post_votes[post_id][\'downvotes\'] += 1 self._updatePostScore(post_id) def getScore(self, postId): return self.posts[postId][\'score\'] def getTopPosts(self, topic, k): posts = self.topic_posts[topic] sorted_posts = sorted(posts, key=lambda p: (p[\'score\'], p[\'id\']), reverse=True) top_posts = [post[\'content\'] for post in sorted_posts[:k]] return top_posts def _updatePostScore(self, post_id): upvotes = self.post_votes[post_id][\'upvotes\'] downvotes = self.post_votes[post_id][\'downvotes\'] self.posts[post_id][\'score\'] = upvotes - downvotes"},{"question":"You are given a **0-indexed** `m x n` matrix `grid` consisting of 1\'s (land) and 0\'s (water). An island is a maximal group of 1\'s connected in the 4-direction (up, down, left, right). A closed island is an island that is completely surrounded by 0\'s. Return _the number of closed islands in the `grid`_.","solution":"def closedIsland(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]): return False if grid[i][j] == 1: return True grid[i][j] = 1 up = dfs(i - 1, j) down = dfs(i + 1, j) left = dfs(i, j - 1) right = dfs(i, j + 1) return up and down and left and right closed_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0: if dfs(i, j): closed_islands += 1 return closed_islands"},{"question":"You are given an integer array `nums` and an integer `k`. You need to determine the **maximum** sum of a non-empty subset of `nums` such that the sum is **divisible** by `k`. If no such subset exists, return `0`. _A subset is a contiguous part of the array or can be obtained by removing some elements from the array while maintaining the order of the remaining elements._ Your task is to implement a function to solve this problem.","solution":"def max_sum_divisible_by_k(nums, k): Returns the maximum sum of a non-empty subset of nums such that the sum is divisible by k. dp = [0] + [-float(\'inf\')] * (k - 1) for num in nums: new_dp = dp[:] for i in range(k): new_dp[(i + num) % k] = max(new_dp[(i + num) % k], dp[i] + num) dp = new_dp return dp[0] if dp[0] != 0 else 0"},{"question":"Implement a function `findShortestPath` to find the shortest path in an unweighted graph represented by an adjacency list from a given source node to a destination node. You need to implement the function `findShortestPath(graph: Dict[int, List[int]], source: int, destination: int) -> List[int]` where: - `graph` is a dictionary representing the adjacency list of the graph. - `source` is an integer representing the starting node. - `destination` is an integer representing the target node. The function should return a list of nodes representing the shortest path from the source to the destination, including both source and destination. If no path exists, return an empty list. You can assume that all nodes and edges in the graph are non-negative integers.","solution":"from collections import deque def findShortestPath(graph, source, destination): Finds the shortest path in an unweighted graph from source to destination. Parameters: graph (Dict[int, List[int]]): The adjacency list of the graph. source (int): The starting node. destination (int): The target node. Returns: List[int]: The list of nodes representing the shortest path from source to destination. If no path exists, returns an empty list. if source == destination: return [source] visited = set() queue = deque([(source, [source])]) while queue: current_node, path = queue.popleft() visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == destination: return path + [neighbor] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) visited.add(neighbor) return []"},{"question":"Given an integer `n`, generate the `n`th **Fibonacci number**, but each time the number exceeds `10^9`, you must take the remainder when divided by `10^9`. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, typically starting with 0 and 1. Return the `n`th **Fibonacci number modulo `10^9`**.","solution":"def fibonacci_mod(n): Returns the n-th Fibonacci number modulo 10^9. if n == 0: return 0 elif n == 1: return 1 MOD = 10**9 a, b = 0, 1 for i in range(2, n + 1): a, b = b, (a + b) % MOD return b"},{"question":"A linked list is given such that each node contains an additional random pointer, which could point to any node in the list or null. The linked list is represented in the input as a list of tuples `nodeList` where each tuple consists of two elements: `(val, random_index)`: - `val`: an integer representing the value of the node. - `random_index`: an integer representing the index of the node in the array that the random pointer is pointing to (or `null` if it is not pointing to any node). Return a deep copy of the linked list. The deep copy should consist of exactly `n` brand new nodes, where each new node has its random pointer set as per the input list. The linked list should be returned as a list of tuples in the same format as the input.","solution":"class ListNode: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def deep_copy_linked_list(nodeList): if not nodeList: return [] nodes = [ListNode(val=node[0]) for node in nodeList] for i, node in enumerate(nodes): if i < len(nodes) - 1: node.next = nodes[i + 1] if nodeList[i][1] is not None: node.random = nodes[nodeList[i][1]] copied_nodes = [(node.val, None if node.random is None else nodes.index(node.random)) for node in nodes] return copied_nodes"},{"question":"Given two strings `s` and `goal`, return `true` if and only if `s` can become `goal` after some number of shifts on `s`. A shift on `s` consists of moving the leftmost character of `s` to the rightmost position. For example, if `s = \\"abcde\\"`, then it will be `\\"bcdea\\"` after one shift. Write a function to determine if one string is a rotation of another string.","solution":"def can_shift_to_goal(s, goal): Determines if string s can be shifted to become the string goal. Args: s (str): The original string. goal (str): The target string. Returns: bool: True if s can be shifted to become goal, False otherwise. if len(s) != len(goal): return False return goal in (s + s)"},{"question":"You are given a list of stock prices where `prices[i]` is the price of a given stock on the `i`th day. You can buy and sell the stock only once. Write a function to determine the maximum profit you can achieve from a single transaction. If you cannot make any profit, return 0. Note that you cannot sell a stock before you buy one.","solution":"def max_profit(prices): if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"Given two integers `x` and `k`, find `k` positive integers that exist in an array `A` such that the bitwise AND of all elements of the array `A` equals `x`. If such an array cannot be found, return an empty array. For example, suppose `x = 12` and `k = 3`. The function should return an array `[12, 4, 12]` because 12 & 4 & 12 = 4 and 12 & 4 = 4, which is equal to `x`. If there are multiple valid arrays, any of them will be accepted.","solution":"def find_k_integers(x, k): Given x and k, return an array of k positive integers such that the bitwise AND of all elements in the array equals x. If no such array exists, return an empty array. if k > 64 or k <= 0 or x <= 0: return [] # We\'ll use the fact that x itself can be k times in the array along with 1\'s # This logic works as x & x & ... & x (k-times) is still x result = [x] * (k - 1) # Adding 1 to the array to keep length k and maintain AND sum as x result.append((1 << 32) - 1) # A very large number as a filler which won\'t change AND result with x. return result"},{"question":"You are given an integer array `arr` of length `n`, which consists of distinct integers from `0` to `n-1` inclusive. A **cycle** in this array is defined as a sequence of indices starting at some index `i` and following the sequence `arr[i]`, `arr[arr[i]]`, `arr[arr[arr[i]]]`, and so on, until you return to index `i` again. The **length** of a cycle is the number of indices visited before returning to the start. Find and return the length of the **longest cycle** that can be formed in the array. If no cycle exists, return `-1`.","solution":"def find_longest_cycle(arr): def find_cycle_length(start, arr, visited): current = start length = 0 while current not in visited: visited.add(current) current = arr[current] length += 1 return length if current == start else 0 max_length = -1 visited = set() for i in range(len(arr)): if i not in visited: cycle_length = find_cycle_length(i, arr, visited) max_length = max(max_length, cycle_length) return max_length if max_length > 1 else -1"},{"question":"You are given two arrays `a` and `b`, each of size `n`, where all elements are distinct positive integers. The task is to form an array `c` using exactly one element from `a` and exactly one element from `b` such that `c[i] = a[j] + b[k]` for some `0 <= j, k < n` and `i` is the index in `c`. Return the maximum possible value of the minimum element in `c` once it is fully formed.","solution":"def max_min_element_in_c(a, b): Returns the maximum possible value of the minimum element in array c formed by summing each element in a with each element in b. n = len(a) # sort both arrays to obtain combinations in an orderly fashion a.sort() b.sort() # the resultant array c will have the minimum element as the sum of the smallest elements from a and b min_element = a[0] + b[0] return min_element"},{"question":"Given a collection of integers that might contain duplicates, `nums`, return all possible unique permutations. You can return the answer in **any order**. # Example: Input: `nums = [1,1,2]` Output: `[[1,1,2],[1,2,1],[2,1,1]]` Input: `nums = [1,2,3]` Output: `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]` Implement a function: ```python def permuteUnique(nums: List[int]) -> List[List[int]]: ```","solution":"from typing import List def permuteUnique(nums: List[int]) -> List[List[int]]: def backtrack(path, used): if len(path) == len(nums): result.append(path[:]) return for i in range(len(nums)): if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]): continue used[i] = True path.append(nums[i]) backtrack(path, used) path.pop() used[i] = False nums.sort() result = [] backtrack([], [False] * len(nums)) return result"},{"question":"You are given a linked list, where each node contains an integer value. The linked list is either empty or consists of nodes labeled from `0` to `n-1`. You need to find the first node in the list where a cycle begins. A cycle exists in a linked list if some node in the list\'s next node points back to a previous node in the list (forming a loop). If there is no cycle, return `null`. You are not allowed to modify the linked list, and you must use `O(1)` (i.e., constant) memory for this purpose.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Returns the node where the cycle begins, or None if there is no cycle. if not head or not head.next: return None slow = head fast = head # First step: Determine whether a cycle is present using Floyd\'s Tortoise and Hare algorithm. while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # If there is no cycle return None # Second step: Find the start node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"A company has a fleet of `m` delivery trucks available for `n` delivery requests. Each delivery request has a start time and an end time, and each truck can handle only one delivery at a time. You are given two integer arrays `startTimes` and `endTimes` where `startTimes[i]` and `endTimes[i]` represent the start and end time of the `i-th` delivery request. All times are represented in the 24-hour format `HHMM` (for example, `0130` for 1:30 AM and `2350` for 11:50 PM). Determine if it is possible to complete all delivery requests with the available trucks. Return `true` if it is possible; otherwise, return `false`.","solution":"def can_complete_deliveries(startTimes, endTimes, m): Determine if all delivery requests can be completed with the available trucks. :param startTimes: List of integers representing start times of delivery requests in HHMM format. :param endTimes: List of integers representing end times of delivery requests in HHMM format. :param m: Integer representing number of available trucks. :return: Boolean value, True if all deliveries can be completed, False otherwise. events = [] for start, end in zip(startTimes, endTimes): events.append((start, \'start\')) events.append((end, \'end\')) # Sort events: by time, then by type (\'end\' before \'start\' if they are the same time) events.sort(key=lambda x: (x[0], x[1] == \'start\')) current_trucks_in_use = 0 for event in events: if event[1] == \'start\': current_trucks_in_use += 1 if current_trucks_in_use > m: return False else: current_trucks_in_use -= 1 return True"},{"question":"You are given an integer array `nums` and an integer `k`. A **subsequence** of `nums` is a sequence that can be derived from `nums` by deleting some or no elements without changing the order of the remaining elements. Find the **longest subsequence** such that every element in the subsequence is divisible by `k`, and return its length.","solution":"def longest_divisible_subsequence(nums, k): Returns the length of the longest subsequence such that every element in the subsequence is divisible by k. Parameters: nums (list[int]): List of integers. k (int): The integer which each element in the subsequence must be divisible by. Returns: int: Length of the longest divisible subsequence. return len([num for num in nums if num % k == 0])"},{"question":"You are given a list of integers `tickets` where `tickets[i]` represents the number of bus tickets a passenger has for a single bus route. Each bus has a maximum capacity of `capacity` passengers. Your task is to determine the minimum number of buses required to transport all passengers. You must fill each bus to its capacity before starting to fill the next one. Implement the following method: * `int minBuses(int[] tickets, int capacity)` - Returns the minimum number of buses needed. For example, given `tickets = [1, 2, 1, 4, 3]` and `capacity = 3`, the result would be `4` buses as follows: * First bus: [1, 2] (capacity filled to 3) * Second bus: [1] (capacity filled to 1) * Third bus: [4] (capacity filled to 4) * Fourth bus: [3] (capacity filled to 3) You may assume all values in `tickets` and `capacity` are positive integers.","solution":"def minBuses(tickets, capacity): Returns the minimum number of buses needed to transport all passengers. Parameters: tickets (list of int): Number of bus tickets each passenger has. capacity (int): Maximum capacity of each bus. Returns: int: Minimum number of buses required. buses = 0 current_capacity = 0 for ticket in tickets: if current_capacity + ticket > capacity: buses += 1 current_capacity = ticket else: current_capacity += ticket if current_capacity > 0: buses += 1 return buses"},{"question":"You are given a list of integers `arr` representing the heights of buildings. The buildings are aligned in a row, and the heights are given from left to right. You are tasked with calculating the \\"view factor\\" of the buildings. The view factor is defined as the total number of buildings that can be seen from the right-hand side. A building is visible if there are no taller buildings blocking the view to the right. Write a function `calculateViewFactor(arr)` that takes `arr` as input and returns the view factor. Your solution should run in linear time.","solution":"def calculateViewFactor(arr): Calculates the view factor of buildings from the right-hand side. Args: arr (list of int): A list of integers representing the heights of buildings. Returns: int: The total number of buildings that can be seen from the right-hand side. if not arr: return 0 view_count = 1 # The rightmost building is always visible max_height = arr[-1] # Traverse the list from the second-last element to the first for height in reversed(arr[:-1]): if height > max_height: view_count += 1 max_height = height return view_count"},{"question":"You are given two integers, `m` and `n`, representing the number of rows and columns of a matrix, respectively. You also have a 2D array called `operations`, where each element is an array of two integers, `[a, b]`. Each operation `[a, b]` increments by 1 every element in the submatrix whose top-left corner is (0, 0) and bottom-right corner is (a-1, b-1). Return the number of elements in the matrix that have the maximum integer value after performing all the given operations on the matrix. For example, if you are given `m = 3`, `n = 3`, and `operations = [[2, 2], [3, 3]]`, the matrix after performing the operations would be: ``` [ [2, 2, 1], [2, 2, 1], [1, 1, 1] ] ``` And the function should return `4`, as there are four elements with the maximum value 2.","solution":"def max_count(m, n, operations): Returns the number of elements in the matrix that have the maximum integer value after performing all the given operations on the matrix. :param m: int: Number of rows in the matrix :param n: int: Number of columns in the matrix :param operations: List[List[int]]: List of operations where each operation is represented by [a, b] :return: int: Number of elements with the maximum value if not operations: return m * n min_row = min(op[0] for op in operations) min_col = min(op[1] for op in operations) return min_row * min_col"},{"question":"Given a linked list, split it into two consecutive linked lists `A` and `B` such that the size of `A` is equal to or one more than the size of `B`. If the original linked list has even length, the two lists should have equal sizes. If the original linked list has odd length, then `A` should have one more node than `B`. Return the heads of the two linked lists `A` and `B` in a list `[headA, headB]`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def split_list_to_two(head): if not head: return [None, None] slow = head fast = head prev = None while fast and fast.next: fast = fast.next.next prev = slow slow = slow.next # If fast is not None, it means the list has an odd length if fast: prev = slow slow = slow.next # Split the list into two if prev: prev.next = None return [head, slow]"},{"question":"You are given a string `s` consisting of lowercase alphabetic characters and an integer `k`. You need to select `k` distinct characters from the string such that the number of substrings containing exactly `k` distinct characters is maximized. Return the maximum number of such substrings. Consider that: - A substring is a contiguous sequence of characters within the string. - The characters in the selected `k` distinct characters must appear in exactly those substrings where their count is `k`. If it is not possible to select `k` distinct characters, return `0`.","solution":"def max_substrings_with_k_distinct_chars(s, k): Finds the maximum number of substrings containing exactly k distinct characters. :param s: a string consisting of lowercase alphabetic characters :param k: an integer representing the number of distinct characters in substrings :return: an integer representing the maximum number of such substrings from collections import defaultdict if k > 26 or k == 0: return 0 n = len(s) max_number_of_substrings = 0 for start in range(n): char_count = defaultdict(int) distinct_count = 0 for end in range(start, n): if char_count[s[end]] == 0: distinct_count += 1 char_count[s[end]] += 1 if distinct_count == k: max_number_of_substrings += 1 elif distinct_count > k: break return max_number_of_substrings"},{"question":"Given two integers `a` and `b`, return _the minimum number of operations required to **convert** `a` into `b`._ You can perform the following operations on `a`: - **Increment**: Increase `a` by 1. - **Decrement**: Decrease `a` by 1. - **Double**: Double the value of `a` (i.e., multiply `a` by 2). Determine the minimum number of these operations needed to make `a` equal to `b`.","solution":"from collections import deque def minimum_operations(a, b): Returns the minimum number of operations required to convert a into b. Operations include increment, decrement, and double. # Early return if a is already equal to b if a == b: return 0 queue = deque([(a, 0)]) visited = set([a]) while queue: curr, steps = queue.popleft() if curr == b: return steps # Operation: Increment if curr + 1 not in visited: queue.append((curr + 1, steps + 1)) visited.add(curr + 1) # Operation: Decrement if curr - 1 not in visited: queue.append((curr - 1, steps + 1)) visited.add(curr - 1) # Operation: Double if curr * 2 not in visited: queue.append((curr * 2, steps + 1)) visited.add(curr * 2) return -1 # This will not be reached"},{"question":"You are given an array of integers `arr` where the `i`-th element represents the color of the `i`-th balloon. Two balloons `arr[i]` and `arr[j]` (where `i != j`) can be exchanged if they are the same color. Design and implement a function to determine the maximum number of pairs of balloons that can be formed where each pair consists of balloons of the same color. A balloon cannot be part of more than one pair. **Return** the maximum number of pairs. **Function Signature**: `def maxPairs(arr: List[int]) -> int:` # Example: ```python arr = [1, 2, 3, 1, 2, 2] print(maxPairs(arr)) # Output: 2 ```","solution":"from typing import List from collections import Counter def maxPairs(arr: List[int]) -> int: Determines the maximum number of pairs of balloons that can be formed where each pair consists of balloons of the same color. Parameters: arr (List[int]): List of integers representing the colors of the balloons. Returns: int: Maximum number of pairs of the same color balloons that can be formed. color_counts = Counter(arr) return sum(count // 2 for count in color_counts.values())"},{"question":"You are given a 2D grid of integers, `grid`, where each cell represents the cost of stepping on that cell. You are initially positioned at the top-left corner of the grid and you want to reach the bottom-right corner. From a cell `(i, j)`, you can either move to the cell `(i+1, j)` or the cell `(i, j+1)`. Return _the minimum cost to reach the bottom-right corner of the grid_.","solution":"def minPathSum(grid): Calculate the minimum path sum from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the first cell with its own cost for r in range(rows): for c in range(cols): if r == 0 and c == 0: continue elif r == 0: # Only one way to reach cells in the first row (from the left) grid[r][c] += grid[r][c - 1] elif c == 0: # Only one way to reach cells in the first column (from above) grid[r][c] += grid[r - 1][c] else: # Choose the minimum cost between coming from the left or from above grid[r][c] += min(grid[r - 1][c], grid[r][c - 1]) # The bottom-right cell contains the minimum path sum return grid[rows - 1][cols - 1]"},{"question":"You are given a collection of strings `words` and two words `word1` and `word2`. Find the minimum distance between these two words in the list. `Distance` is defined as the number of elements between the two words (inclusive) in the list. If the same word appears multiple times, consider the positions that give the smallest distance. Return _the minimum distance between_ `word1` _and_ `word2` _in the list of_ `words`.","solution":"def minimum_distance(words, word1, word2): Returns the minimum distance between word1 and word2 in the list of words. Distance is defined as the number of elements between the two words (inclusive). pos1, pos2 = -1, -1 min_distance = float(\'inf\') for i, word in enumerate(words): if word == word1: pos1 = i if word == word2: pos2 = i if pos1 != -1 and pos2 != -1: min_distance = min(min_distance, abs(pos2 - pos1) + 1) return min_distance"},{"question":"Implement a class `FlightManager` that helps manage flight seat reservations. The class should support the following functionalities: - `FlightManager(int totalSeats)` Initializes the `FlightManager` with the specified number of total seats reserved for the flight. - `boolean reserveSeat(int seatNumber)` Reserves a specific seat given by `seatNumber`. If the seat is already reserved or invalid (e.g., seat number outside the range of total seats), return `false`; otherwise, reserve the seat and return `true`. - `boolean cancelReservation(int seatNumber)` Cancels an existing reservation for the given seat number. If the seat is not currently reserved or invalid, return `false`; otherwise, cancel the reservation and return `true`. - `List<Integer> getAvailableSeats()` Returns a list of all available seat numbers sorted in ascending order.","solution":"class FlightManager: def __init__(self, totalSeats): Initializes the FlightManager with the specified number of total seats. self.totalSeats = totalSeats self.reservedSeats = set() def reserveSeat(self, seatNumber): Reserves a specific seat given by seatNumber. Returns True if the seat is successfully reserved, False otherwise. if 1 <= seatNumber <= self.totalSeats and seatNumber not in self.reservedSeats: self.reservedSeats.add(seatNumber) return True return False def cancelReservation(self, seatNumber): Cancels an existing reservation for the given seat number. Returns True if the reservation is successfully cancelled, False otherwise. if 1 <= seatNumber <= self.totalSeats and seatNumber in self.reservedSeats: self.reservedSeats.remove(seatNumber) return True return False def getAvailableSeats(self): Returns a list of all available seat numbers sorted in ascending order. return sorted(set(range(1, self.totalSeats + 1)) - self.reservedSeats)"},{"question":"Given a 2D grid of size `m x n` consisting of only the characters `\'X\'` and `\'O\'`, an `\'X\'` represents a wall and an `\'O\'` represents an open space. You need to fill all the regions surrounded by walls. A region is defined as all the `\'O\'` characters that are surrounded by `\'X\'` characters in the borders and are not connected to the boundary of the grid. Fill all such regions with `\'X\'`. Return the modified grid.","solution":"def capture_regions(board): Capture all the regions surrounded by \'X\' on a given board. if not board or not board[0]: return board m, n = len(board), len(board[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or board[x][y] != \'O\': return board[x][y] = \'E\' # mark \'E\' to avoid revisiting dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) for i in range(m): if board[i][0] == \'O\': dfs(i, 0) if board[i][n - 1] == \'O\': dfs(i, n - 1) for j in range(n): if board[0][j] == \'O\': dfs(0, j) if board[m - 1][j] == \'O\': dfs(m - 1, j) for i in range(m): for j in range(n): if board[i][j] == \'O\': board[i][j] = \'X\' elif board[i][j] == \'E\': board[i][j] = \'O\' return board"},{"question":"Given a string `s` which represents a binary number, return the number of steps to reduce it to `1` under the following rules: - If the current number is even, divide it by 2. - If the current number is odd, subtract 1 from it. Each step can be considered as either a division by 2 or a subtraction by 1. The function should count the number of these steps until the binary number becomes 1. The given string `s` will always represent a valid binary number starting with \'1\'.","solution":"def num_steps_to_reduce_to_one(s): Returns the number of steps to reduce a binary number represented by string s to 1. steps = 0 num = int(s, 2) # Convert binary number to integer while num > 1: if num % 2 == 0: num //= 2 else: num -= 1 steps += 1 return steps"},{"question":"You are given a 2D grid `grid` of `0`s (land) and `1`s (water). An **island** is a group of `0`s (land) connected **4-directionally (horizontal or vertical)**. You may assume all four edges of the grid are surrounded by water. Count the number of distinct islands on the grid and return _the count of islands found_. Note that the island shapes must be different (considering rotations and reflections as well).","solution":"class IslandCounter: def countDistinctIslands(self, grid): if not grid: return 0 self.rows, self.cols = len(grid), len(grid[0]) visited = set() def dfs(r, c, r0, c0, shape): if 0 <= r < self.rows and 0 <= c < self.cols and (r, c) not in visited and grid[r][c] == 0: visited.add((r, c)) shape.append((r - r0, c - c0)) # normalized shape dfs(r + 1, c, r0, c0, shape) dfs(r - 1, c, r0, c0, shape) dfs(r, c + 1, r0, c0, shape) dfs(r, c - 1, r0, c0, shape) unique_islands = set() for r in range(self.rows): for c in range(self.cols): if grid[r][c] == 0 and (r, c) not in visited: shape = [] dfs(r, c, r, c, shape) unique_islands.add(tuple(shape)) return len(unique_islands)"},{"question":"You are given an unsorted array of integers `arr` and an integer `k`. The task is to find the `k`th smallest element in the array. Write a function that takes the array `arr` and `k` as inputs and returns the `k`th smallest element. If `k` is greater than the length of the array or less than 1, return `-1`. The array may contain duplicate elements. Note: The solution should have an average time complexity better than `O(n log n)` where `n` is the length of the array.","solution":"def kth_smallest(arr, k): Returns the k-th smallest element in an unsorted array. If k is out of the range of 1 to len(arr), returns -1. if k < 1 or k > len(arr): return -1 def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): if left == right: return arr[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1)"},{"question":"You are given an array of integers `nums` and an integer `threshold`. A subarray is defined as a contiguous portion of the array. Implement a function `longestSubarray(nums, threshold)` that returns the length of the longest subarray such that the sum of its elements is less than or equal to `threshold`. If no such subarray exists, return `0`. **Example:** ``` Input: nums = [1, 2, 3, 4, 5], threshold = 8 Output: 3 Explanation: The subarray [1, 2, 3] has a sum of 6, which is less than 8, and it is the longest subarray with sum <= threshold. ``` **Note:** The solution must achieve a time complexity of O(n).","solution":"def longestSubarray(nums, threshold): Returns the length of the longest subarray such that the sum of its elements is less than or equal to the threshold. max_len = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > threshold: current_sum -= nums[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an array of integers `arr` that represents the strengths of `n` warriors. Each warrior `i` will only fight against another warrior `j` if `arr[i]` is greater than `arr[j]` and `i < j`. The winner of each battle will increase their strength by the amount equal to the strength of the defeated warrior. Return an array representing the final strengths of the warriors after all possible battles have occurred.","solution":"def final_strengths(arr): Returns the final strengths of the warriors after all possible battles have occurred. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i] += arr[j] arr[j] = 0 return arr"},{"question":"Implement a data structure `Fancy` that supports the following operations: * `void append(int val)` Adds an integer `val` to the sequence. * `void addAll(int inc)` Increases all elements in the sequence by an integer `inc`. * `void multAll(int m)` Multiplies all elements in the sequence by an integer `m`. * `int getIndex(int idx)` Gets the current value at index `idx` (0-indexed) of the sequence. The sequence starts empty. The result of `getIndex` should be returned **modulo** `10^9 + 7`. If the index `idx` is greater than or equal to the length of the sequence, return `-1`.","solution":"class Fancy: def __init__(self): self.values = [] self.additive = 0 self.multiplicative = 1 self.mod = 10**9 + 7 def append(self, val: int) -> None: val = (val - self.additive) * pow(self.multiplicative, self.mod-2, self.mod) % self.mod self.values.append(val) def addAll(self, inc: int) -> None: self.additive = (self.additive + inc) % self.mod def multAll(self, m: int) -> None: self.additive = (self.additive * m) % self.mod self.multiplicative = (self.multiplicative * m) % self.mod def getIndex(self, idx: int) -> int: if idx >= len(self.values): return -1 return (self.values[idx] * self.multiplicative + self.additive) % self.mod"},{"question":"You are given an array `heights` containing `n` positive integers, where `heights[i]` represents the height of a building located at position `i`. You need to use a water tank situated at position `0` to fill the roofs of the buildings with water. You can only use a ladder to move between buildings, and the ladder can be adjusted to any building height. Starting from position `0`, you can move to position `i` (i > 0) if and only if you have already filled all the buildings at positions `1` to `i-1`. Filling the roof of a building at position `i` with water costs `abs(heights[i] - heights[0])` units of water. Your task is to determine the minimum total units of water required to fill the roofs of all the buildings with water. Return _the minimum total units of water required to fill all the roofs_.","solution":"def min_water_units(heights): Returns the minimum total units of water required to fill all the roofs. Parameters: heights (List[int]): A list of positive integers representing the heights of buildings. Returns: int: The minimum total units of water required to fill all the roofs. n = len(heights) if n == 0: return 0 total_water_units = 0 initial_height = heights[0] for i in range(1, n): total_water_units += abs(heights[i] - initial_height) return total_water_units"},{"question":"You are given a **0-indexed** integer array `height` representing the heights of `n` buildings. Every building has a water container on its roof, and the height of this container equals the height of the building itself. Water from higher containers can overflow to adjacent lower containers if they are lower in height. However, the water can only flow horizontally, not vertically down between buildings. If all containers start full, return _the total volume of water that will be retained atop all the buildings after settling_.","solution":"def trap_water(height): This function calculates the total volume of water retained atop all buildings after settling. :param height: List[int] - a list of integers representing the heights of buildings :return: int - volume of water retained if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given a string `str`, remove all consecutive duplicate characters, leaving only the first occurrence of each character. For example, given the input string `\\"aabccba\\"`, the resulting string should be `\\"abcba\\"`. Write a function that performs this task and returns the resulting string.","solution":"def remove_consecutive_duplicates(s): Returns a string with all consecutive duplicate characters removed, leaving only the first occurrence of each character. if not s: return \'\' result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return \'\'.join(result)"},{"question":"You are given an array of integers `arr` where some of the elements are duplicates. Write a function that returns the first element that appears at least twice in the array. If no such element exists, return `-1`. The algorithm should have O(n) time complexity and use O(1) additional space.","solution":"def first_repeating_element(arr): Returns the first element that appears at least twice in the array. If no such element exists, return -1. seen = set() for num in arr: if num in seen: return num seen.add(num) return -1"},{"question":"You are given a list of integers `arr` of length `n`. Your task is to partition the list into as many non-overlapping subarrays as possible, where each subarray is sorted in **non-decreasing order**. Each element in the array must be part of exactly one subarray. Return _the maximum number of subarrays you can create_.","solution":"def max_partition_subarrays(arr): Returns the maximum number of non-overlapping non-decreasing subarrays. if not arr: return 0 count = 1 max_val = arr[0] for i in range(1, len(arr)): if arr[i] < max_val: count += 1 max_val = arr[i] else: max_val = max(max_val, arr[i]) return count"},{"question":"You are given two strings `s1` and `s2` of equal length consisting of lowercase English letters. You want to change `s1` to `s2` using the following operation any number of times: choose any character in `s1` and change it to any other lowercase English letter. The cost of this operation is the difference in their positions in the alphabet (for example, changing from \'a\' to \'c\' costs 2). Return _the **minimum** cost required to change `s1` to `s2`._","solution":"def minimum_cost_to_change(s1, s2): Calculate the minimum cost required to change string s1 to string s2. Parameters: s1 (str): The original string. s2 (str): The target string. Returns: int: The minimum cost to change s1 to s2. cost = 0 for char_s1, char_s2 in zip(s1, s2): cost += abs(ord(char_s1) - ord(char_s2)) return cost"},{"question":"You are given an integer array `nums` where the `ith` element represents the number of coins you have on the `ith` day. You can decide to sell the coins you have on any number of days, but you must pay a fee for each transaction. You need to maximize your profit. The fee is represented by an integer `fee`. Implement the function `maxProfit(nums, fee)` that returns the maximum profit you can achieve with the given fee. The transaction fee is deducted whenever you sell coins on any day.","solution":"def maxProfit(nums, fee): Returns the maximum profit you can achieve given the coins and transaction fee. n = len(nums) if n < 2: return 0 # Initialize the current cash and stock cash, stock = 0, -nums[0] for i in range(1, n): cash = max(cash, stock + nums[i] - fee) stock = max(stock, cash - nums[i]) return cash"},{"question":"You are given an integer array `arr` and a positive integer `k`. An element is considered a **peak** if it is greater than its immediate left and immediate right neighbors. Return the _**sum** of the values of the **k** largest peaks_ in the array. If there are fewer than `k` peaks, return the sum of all the peak values.","solution":"def k_largest_peaks_sum(arr, k): Returns the sum of the values of the k largest peaks in the array. If there are fewer than k peaks, returns the sum of all the peak values. # Helper to find peaks def find_peaks(arr): peaks = [] for i in range(1, len(arr) - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peaks.append(arr[i]) return peaks peaks = find_peaks(arr) if len(peaks) < k: return sum(peaks) # Sort the peaks in descending order and take the sum of the k largest peaks.sort(reverse=True) return sum(peaks[:k])"},{"question":"You are given an array of integers `arr` and an integer `k`. A \\"good\\" subsequence is defined as a subsequence where the absolute difference between the maximum and minimum integers is less than or equal to `k`. Write a function to find the length of the longest \\"good\\" subsequence in the array. Note that the elements of the subsequence do not need to be contiguous.","solution":"def longest_good_subsequence(arr, k): Finds the length of the longest \\"good\\" subsequence. A \\"good\\" subsequence is defined as a subsequence where the absolute difference between the maximum and minimum integers is less than or equal to `k`. Parameters: - arr: List[int], the array of integers - k: int, the maximum allowed absolute difference between max and min in the subsequence Returns: - int, length of the longest good subsequence if not arr: return 0 arr.sort() max_length = 0 n = len(arr) for i in range(n): j = i while j < n and arr[j] - arr[i] <= k: j += 1 max_length = max(max_length, j - i) return max_length"},{"question":"Given an array of strings `sentences` where each sentence is a single string containing several words, return _the paragraph formed by concatenating all sentences without using any punctuation marks other than spaces. Each word in a sentence should be separated by a single space, and there should be exactly one space separating the last word of one sentence from the first word of the next sentence. Leading and trailing spaces should be removed from the final paragraph._","solution":"def form_paragraph(sentences): Concatenates a list of sentences into a single paragraph, ensuring there are exactly one space between each sentence and no leading or trailing spaces. Parameters: sentences (list): A list of strings, each string is a sentence. Returns: str: The paragraph formed by concatenating all sentences. return \' \'.join(sentence.strip() for sentence in sentences).strip()"},{"question":"You are given an integer array `nums` and an integer `k`. You want to select a contiguous subarray from `nums` of length `k` that has the maximum possible sum. The array `nums` may contain both positive and negative integers. Return _the maximum sum_ of such a subarray.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a contiguous subarray of length k. Parameters: nums (list of int): The input array. k (int): The length of the subarray. Returns: int: The maximum sum of a contiguous subarray of length k. if len(nums) < k: raise ValueError(\\"The length of the subarray k cannot be greater than the length of the input array.\\") max_sum = sum(nums[:k]) current_sum = max_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a **0-indexed** 2D integer array `intervals` where `intervals[i] = [start_i, end_i]` represents an interval starting at `start_i` and ending at `end_i`. You are also given an integer `k`. Return _an array_ `result` _of length_ `k`, _where_ `result[i]` _is the number of intervals that include the number_ `i`. An interval `[start_i, end_i]` includes a number `i` if `start_i <= i <= end_i`.","solution":"def count_intervals(intervals, k): Returns an array of length k where result[i] is the number of intervals that include the number i. result = [0] * k for start, end in intervals: for i in range(max(0, start), min(k, end + 1)): result[i] += 1 return result"},{"question":"You are given a 0-indexed integer array `arr` of length `n`. An array element `arr[i]` is said to be a **peak** if it is not smaller than its neighbors. For array elements at the border, consider only the one neighbor (i.e., `arr[0]` and `arr[n-1]` have only one neighbor each). Write an algorithm to find the index of a peak element. If multiple peak elements exist, return the index of any one of them. The array may contain duplicates. Return _the index of any one peak element_.","solution":"def find_peak_element(arr): This function takes in a list of integers \'arr\' and returns the index of any peak element. A peak element is one that is not smaller than its neighbors. n = len(arr) if n == 1: return 0 low, high = 0, n - 1 while low < high: mid = (low + high) // 2 if arr[mid] < arr[mid + 1]: low = mid + 1 else: high = mid return low"},{"question":"Given a list of integers `arr`, write a function to find the maximum sum of any contiguous subarray of `arr` that does not contain any negative numbers. Return _an integer representing the maximum sum_. If all numbers in `arr` are negative, return `0`.","solution":"def max_sum_non_negative_subarray(arr): Returns the maximum sum of any contiguous subarray of `arr` that does not contain any negative numbers. If all numbers in `arr` are negative, returns 0. max_sum = 0 current_sum = 0 for num in arr: if num >= 0: current_sum += num else: max_sum = max(max_sum, current_sum) current_sum = 0 max_sum = max(max_sum, current_sum) # To catch the last subarray if it has the maximum sum return max_sum"},{"question":"Given a string `s`, you need to find the smallest number of transformations needed to make the string a palindrome. In one transformation, you can change any single character to any other character. Return the minimum number of transformations required.","solution":"def min_transformations_to_palindrome(s): Returns the minimum number of transformations needed to make the string s a palindrome. A transformation means changing one character to another. Arguments: s -- string to be transformed into a palindrome Returns: int -- minimum number of transformations required n = len(s) cnt = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: cnt += 1 return cnt"},{"question":"Given an integer array `arr` and an integer `k`, you need to select a contiguous subarray from `arr` such that the sum of the elements in the subarray is divisible by `k`. Return the **length** of the longest such subarray. If no such subarray exists, return `-1`. For example, given `arr = [4, 5, 7, 9, 12]` and `k = 5`, the longest subarray would be `[5, 7, 9, 12]` with a sum of `33`, which is divisible by `5`, and the length is `4`.","solution":"def longest_subarray_divisible_by_k(arr, k): Returns the length of the longest contiguous subarray whose sum is divisible by k. If no such subarray exists, return -1. # Dictionary to store the first occurrence of a particular remainder remainder_dict = {0: -1} total_sum = 0 max_length = 0 for i, num in enumerate(arr): total_sum += num remainder = total_sum % k # We need to handle negative remainders if remainder < 0: remainder += k if remainder in remainder_dict: subarray_length = i - remainder_dict[remainder] max_length = max(max_length, subarray_length) else: remainder_dict[remainder] = i return max_length if max_length > 0 else -1"},{"question":"You are given an array `heights` representing the vertical heights of buildings along a street. Each building\'s width is considered to be `1` unit. You are to compute the maximum area of a rectangle formed between the buildings, such that the rectangle\'s base lies on the x-axis. Return the maximum rectangular area possible using the heights of the buildings, which can be solved using a stack-based approach.","solution":"def largestRectangleArea(heights): Calculates the largest rectangle area in a histogram. :param heights: List[int] - a list of building heights :return: int - the area of the largest rectangle stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a string `s` that consists of only lowercase English letters, you need to find and return the first non-repeating character in it. If there isn\'t any non-repeating character, return the underscore character (`\'_\'`). You may assume that the input string always has at least one character. Try to accomplish this with a time complexity better than O(n^2).","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there isn\'t any non-repeating character, returns \'_\'. from collections import Counter # Create a counter to count the frequency of each character char_count = Counter(s) # Traverse the string to find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return \'_\'"},{"question":"You are given a string `s` and an integer `m`. You need to determine if you can partition the string into exactly `m` palindromic substrings. A palindromic substring is a sequence of characters that reads the same forward and backward. Return _true_ if it is possible to partition `s` into `m` palindromic substrings, otherwise return _false_.","solution":"def can_partition_into_palindromes(s, m): def is_palindrome(x): return x == x[::-1] def dfs(s, m, start): if m < 0: return False if start == len(s) and m == 0: return True for end in range(start + 1, len(s) + 1): if is_palindrome(s[start:end]) and dfs(s, m - 1, end): return True return False return dfs(s, m, 0)"},{"question":"Given an array of integers `nums` where the values are sorted in ascending order, and an integer `target`, implement a function to search for the `target` in `nums`. If the target is found, return its index. If not, return the index where it would be if it were inserted in order. You must solve the problem using a binary search algorithm.","solution":"def search_insert_position(nums, target): Searches for the target in nums using binary search algorithm. If found, returns the index of target. If not found, returns the index where it would be if inserted in order. :param nums: List[int] - List of sorted integers :param target: int - Target integer to search for :return: int - Index of target if found, or insertion index left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"A scientist is conducting an experiment with bacteria colonies represented as a matrix of integers `grid` where each cell in the matrix holds an integer representing the amount of bacteria in that colony. The scientist observes that bacteria can only spread to adjacent cells (up, down, left, right) if the bacteria count in the source cell is greater than the destination cell. Write a function to determine the longest path starting from any cell in the `grid` where bacteria spread according to the rule provided. The length of a path is defined as the number of cells visited, including the starting cell. Return _the length of the longest path in the `grid` where bacteria spread from one cell to another_.","solution":"def longest_path(grid): Function to find the longest path in the grid where bacteria spread from one cell to another according to the rule where bacteria can only spread to adjacent cells with smaller values. def dfs(x, y, memo): if memo[x][y] != -1: return memo[x][y] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] < grid[x][y]: max_length = max(max_length, 1 + dfs(nx, ny, memo)) memo[x][y] = max_length return max_length if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) memo = [[-1 for _ in range(cols)] for _ in range(rows)] longest = 0 for i in range(rows): for j in range(cols): longest = max(longest, dfs(i, j, memo)) return longest"},{"question":"**[Question 4]:** You are given a 2D grid of size `m x n` representing a map where `0` represents water and `1` represents land. An **island** is a group of `1`s (land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Return the maximum area of an island in the grid. If there is no island, return `0`.","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(r, c): if r < 0 or c < 0 or r >= m or c >= n or grid[r][c] == 0 or visited[r][c]: return 0 visited[r][c] = True return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1) max_area = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"Given an array of integers `arr` of size `n`, rearrange the elements of `arr` such that all even numbers appear before all odd numbers. The relative order of the even and odd numbers should remain the same. Return the modified array. For example, given `arr = [1, 2, 3, 4, 5, 6]`, the output should be `[2, 4, 6, 1, 3, 5]`.","solution":"def rearrange_even_odd(arr): Rearrange the elements of arr such that all even numbers appear before all odd numbers. The relative order of the even and odd numbers should remain the same. Parameters: arr (list): A list of integers. Returns: list: The rearranged list with all even numbers first and odd numbers second. even_numbers = [x for x in arr if x % 2 == 0] odd_numbers = [x for x in arr if x % 2 != 0] return even_numbers + odd_numbers"},{"question":"You are given an integer array `nums` of length `n` where each element represents the number of votes a candidate received. The winner is the candidate who has more than half of the total votes. If such a candidate exists, return their index (0-indexed) in the array. If no such candidate exists, return `-1`. If there are multiple candidates with the exact half of the total votes, return `-1`.","solution":"def find_winner(nums): Finds the index of the candidate who has more than half of the total votes in the array. If no such candidate exists, returns -1. Parameters: nums (list): A list of integers representing the number of votes each candidate received. Returns: int: The index (0-based) of the winning candidate, or -1 if no such candidate exists. total_votes = sum(nums) majority_votes = total_votes / 2 for i, votes in enumerate(nums): if votes > majority_votes: return i return -1"},{"question":"Implement a `DataStream` class that helps in finding and managing the average of the last `k` elements in a stream of integers. The class should support the following two methods: * `void addElement(int value)` Adds a new integer `value` to the data stream. * `double getAverage()` Returns the average of the last `k` elements added to the stream. If fewer than `k` elements are present, return the average of all the elements in the stream. Initialize the DataStream class with an integer `k`.","solution":"class DataStream: def __init__(self, k): Initialize the DataStream with the given window size k. self.k = k self.stream = [] def addElement(self, value): Adds a new integer value to the data stream. self.stream.append(value) def getAverage(self): Returns the average of the last k elements added to the stream. If fewer than k elements are present, return the average of all elements. if len(self.stream) <= self.k: return sum(self.stream) / len(self.stream) else: return sum(self.stream[-self.k:]) / self.k"},{"question":"You are given a 2-dimensional (2D) integer array `matrix` and an integer `target`. Each row in `matrix` is sorted in non-decreasing order and each column is also sorted in non-decreasing order. You need to determine whether the `target` integer exists within the matrix. Return `true` if `target` is found in `matrix` and `false` otherwise.","solution":"def search_matrix(matrix, target): Returns True if target is found in the matrix, else False. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given a list of intervals `intervals` where `intervals[i] = [start_i, end_i]`, and an integer `n`. Each interval `[start_i, end_i]` represents a meeting time for that specific interval from `start_i` to `end_i` (both inclusive). You need to determine if it is possible to attend all meetings given the intervals, without any overlap, within the given `n` hours a day. Note that meetings can be scheduled on different days but each day has a maximum of `n` hours available. Return `true` if it is possible to attend all meetings without any overlap within the given n hours a day, otherwise return `false`.","solution":"def can_attend_all_meetings(intervals, n): Determine if it is possible to attend all meetings without any overlap within the given n hours a day. Parameters: intervals (list of list of int): Intervals representing meeting times. n (int): Maximum hours available in one day. Returns: bool: True if it is possible to attend all meetings without any overlap within the given n hours a day, otherwise false. # Sort intervals by start time intervals.sort(key=lambda x: x[0]) # Check for overlaps for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: # Overlapping condition return False # Check if an interval exceeds the daily limit for start, end in intervals: if end - start + 1 > n: return False return True"},{"question":"Given a 2D matrix `grid` where `grid[i][j]` represents the cost of stepping on the cell `(i, j)`, return the minimum cost to travel from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`. You can only move right or down at any point in time. If there is no path to the bottom-right corner, return `-1`.","solution":"def min_path_sum(grid): Finds the minimum path sum from top-left to bottom-right in a grid. if not grid or not grid[0]: return -1 # No possible path because grid is empty or malformed m, n = len(grid), len(grid[0]) # Initialize the top row for i in range(1, n): grid[0][i] += grid[0][i-1] # Initialize the left column for i in range(1, m): grid[i][0] += grid[i-1][0] # Fill in the rest of the grid for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[-1][-1]"},{"question":"You are given a matrix representing a 2D grid of `m` rows and `n` columns. Each cell in the grid has a non-negative integer value that represents the height of a building at that position. A cell with height `0` represents an empty lot. Two buildings are deemed connected if there exists a direct path consisting of cells either vertically or horizontally adjacent. Determine the number of separate connected buildings in the grid.","solution":"def count_connected_buildings(grid): Returns the number of separate connected buildings in the grid. Parameters: grid (List[List[int]]): A 2D list representing the grid where each element is a non-negative integer. Returns: int: The number of separate connected buildings in the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] > 0: visited[nx][ny] = True stack.append((nx, ny)) count = 0 for i in range(m): for j in range(n): if grid[i][j] > 0 and not visited[i][j]: visited[i][j] = True count += 1 dfs(i, j) return count"},{"question":"You are given two strings, `s1` and `s2`. Both strings only contain lowercase alphabets. Your task is to determine if you can make `s1` an anagram of `s2` by deleting exactly one character from `s1`. Return _`true` if it is possible to make `s1` an anagram of `s2`, otherwise return `false`._","solution":"def can_make_anagram_by_deleting_one_char(s1, s2): Determine if `s1` can be made into an anagram of `s2` by deleting exactly one character. from collections import Counter # Ensure the lengths are appropriate if len(s1) != len(s2) + 1: return False # Count frequency of each character in both strings counter_s1 = Counter(s1) counter_s2 = Counter(s2) # Compare character counts diff_count = 0 for char in counter_s1: if counter_s1[char] > counter_s2.get(char, 0): diff_count += counter_s1[char] - counter_s2.get(char, 0) # There should be exactly one extra character in s1 return diff_count == 1"},{"question":"You are given a list of integers `nums` sorted in **ascending order**, and an integer `target`. You are also given a boolean `findFirst`. The list `nums` may contain duplicates. Implement the function `searchRange(nums, target, findFirst)` that returns a list of indices representing the starting and ending position of the target element in `nums`. If `findFirst` is `True`, the function should return the first occurrence\'s index of the target in `nums`; otherwise, it should return the last occurrence\'s index. If the target is not found, return `[-1, -1]`.","solution":"def searchRange(nums, target, findFirst): Finds the range of indices for the given target in the sorted list nums. def binarySearch(nums, target, findFirst): low, high = 0, len(nums) - 1 result = -1 while low <= high: mid = (low + high) // 2 if nums[mid] == target: result = mid if findFirst: high = mid - 1 else: low = mid + 1 elif nums[mid] < target: low = mid + 1 else: high = mid - 1 return result firstIndex = binarySearch(nums, target, True) lastIndex = binarySearch(nums, target, False) if firstIndex != -1: return [firstIndex, lastIndex] else: return [-1, -1]"},{"question":"You are given an array of integers `heights` representing the heights of buildings, and an integer `k` representing the maximum number of jumps you can make. Each jump allows you to move to the right to any building, provided the building is taller than the current one. Your task is to write a function that returns the maximum number of buildings you can visit starting from the first building and making at most `k` jumps.","solution":"def max_buildings(heights, k): Returns the maximum number of buildings that can be visited starting from the first building and making at most k jumps. n = len(heights) dp = [1] * n for i in range(n): for j in range(i + 1, n): if heights[j] > heights[i]: dp[j] = max(dp[j], dp[i] + 1) if dp[j] > k + 1: # As we start counting from the first building break return min(max(dp), k + 1)"},{"question":"You are given a **directed graph** with `n` nodes labeled from `1` to `n`. Each edge is a tuple `(u, v, w)`, where `u` is the starting node, `v` is the ending node, and `w` is the weight of the edge. Your task is to determine the **shortest distance** from a given start node `s` to a given end node `t`. If there is no path from `s` to `t`, return `-1`. Assume that the graph may contain **cycles** but does not contain negative weight cycles. Return _the shortest distance from_ `s` _to_ `t`.","solution":"import heapq def shortest_distance(n, edges, start, end): Finds the shortest distance from start node to end node in a directed graph. :param n: Number of nodes :param edges: List of tuples (u, v, w) representing directed edges and their weights :param start: Start node :param end: End node :return: Shortest distance from start to end, or -1 if no path exists # Create adjacency list graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) # Use Dijkstra\'s algorithm to find the shortest path heap = [(0, start)] distances = {i: float(\'inf\') for i in range(1, n+1)} distances[start] = 0 while heap: current_distance, current_node = heapq.heappop(heap) if current_node == end: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return -1 if distances[end] == float(\'inf\') else distances[end]"},{"question":"You are given an array of integers `arr` and an integer `m`. Your task is to find the number of **distinct** pairs `(i, j)` such that `0 <= i < j < arr.length` and the **sum** of `arr[i]` and `arr[j]` is divisible by `m`. Return the number of such pairs.","solution":"def count_divisible_pairs(arr, m): Returns the number of distinct pairs (i, j) such that 0 <= i < j < arr.length and the sum of arr[i] and arr[j] is divisible by m. n = len(arr) count = 0 # Iterate over each pair (i, j) and check the sum divisibility for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % m == 0: count += 1 return count"},{"question":"You are given a linked list where each node contains a single integer. Determine if the linked list is a palindrome. A linked list is considered a palindrome if the sequence of values read forward is the same as the sequence of values read backward. Implement a function `bool isPalindrome(ListNode* head)` that returns `true` if the linked list is a palindrome, and `false` otherwise. The linked list node is defined as: ```cpp struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def isPalindrome(head): Returns True if the linked list is a palindrome, False otherwise. :param head: ListNode - the head of the linked list :return: bool - True if the linked list is a palindrome, False otherwise # Fast and slow pointers to reach the middle of the linked list slow, fast = head, head stack = [] # Push half of the linked list onto the stack while fast and fast.next: stack.append(slow.val) slow = slow.next fast = fast.next.next # If the length is odd, skip the middle element if fast: slow = slow.next # Compare the second half of the list with the values in the stack while slow: top = stack.pop() if top != slow.val: return False slow = slow.next return True"},{"question":"Given a string `s` containing only lowercase English letters and a list of queries where each query specifies two indices `start` and `end`, return the count of distinct characters in the substring `s[start:end+1]` for each query. If `end` is out of bounds, consider the substring up to the end of the string. Return a list of results for each query.","solution":"def count_distinct_characters(s, queries): Returns a list of counts of distinct characters in the specified substrings. Args: s: str - Input string containing only lowercase English letters. queries: List[Tuple[int, int]] - List of queries where each query is a tuple (start, end). Returns: List[int] - List of counts of distinct characters for each query. results = [] for start, end in queries: # Adjust end if it is out of bounds if end >= len(s): end = len(s) - 1 substring = s[start:end+1] distinct_count = len(set(substring)) results.append(distinct_count) return results"},{"question":"You are given an integer array `heights` representing the height of buildings in a city. You are looking at the city from the left side, where `heights[i]` is the height of the building at index `i`. A building can block the view of another building if it is taller. Return _the number of buildings visible from the left side_. *Note*: The first building is always visible. A building is visible if all buildings before it are shorter.","solution":"def visible_buildings(heights): Returns the number of buildings visible from the left side. The first building is always visible. A building is visible if all buildings before it are shorter. :param heights: List[int] - list of building heights. :return: int - number of visible buildings from the left side. visible_count = 0 max_height = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given a list of `events` where each event is represented as a tuple `(start, end)`, indicating the start and end times of the event. Your task is to determine if a person can attend all the events without any overlap. Events may share the same start or end time points. Return `True` if it is possible for the person to attend all events and `False` otherwise.","solution":"def can_attend_all_events(events): Determines if a person can attend all events without any overlap. :param events: List of tuples where each tuple contains (start, end) of an event :return: True if it\'s possible to attend all events without any overlap, False otherwise # Sort events based on their start time first, and end time if start times are the same events.sort(key=lambda x: (x[0], x[1])) # Check for any overlapping events for i in range(1, len(events)): if events[i][0] < events[i-1][1]: return False return True"},{"question":"You are given two sorted integer arrays `nums1` and `nums2`, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2`, respectively. Merge `nums1` and `nums2` into a single array sorted in non-decreasing order. **Note**: `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored.","solution":"def merge(nums1, m, nums2, n): Merges two sorted integer arrays nums1 and nums2, where nums1 has a length of m + n. Args: nums1 (List[int]): First sorted array with length m + n. m (int): Number of actual elements in nums1. nums2 (List[int]): Second sorted array with length n. n (int): Number of actual elements in nums2. Returns: None: Modifies nums1 in place. # Last index of nums1\'s merged array last = m + n - 1 # Merge in reverse order while m > 0 and n > 0: if nums1[m-1] > nums2[n-1]: nums1[last] = nums1[m-1] m -= 1 else: nums1[last] = nums2[n-1] n -= 1 last -= 1 # Fill nums1 with remaining elements of nums2 while n > 0: nums1[last] = nums2[n-1] n -= 1 last -= 1"},{"question":"Write a function that takes an integer array `arr` and an integer `k`, and rotates the array to the right by `k` steps. Note that the values in `k` can be negative to indicate rotation to the left. Return the modified array after the rotation. The function should handle large inputs efficiently.","solution":"def rotate_array(arr, k): Rotates the array `arr` to the right by `k` steps. If `k` is negative, rotates to the left by `-k` steps. Args: arr: List[int] - The array to be rotated. k: int - Steps to rotate the array. Returns: List[int] - The rotated array. n = len(arr) if n == 0: return arr k = k % n # Handling cases where k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"The provided questions are a mixture of algorithms involving tree data structures and number puzzles. Here is a new question that fits the style, complexity, and scope: [Question 4]: You are given a linked list where each node contains a single digit. The digits are stored in reverse order, and each of their non-empty linked lists represents a non-negative integer. Add the two numbers and return the sum as a linked list. For example, if the linked lists are (2 -> 4 -> 3) and (5 -> 6 -> 4), they represent the numbers 342 and 465, and their sum is 807, so the linked list should be (7 -> 0 -> 8). Your task is to implement the function that takes two linked lists and returns their sum as a linked list. --- This new question targets linked list manipulation and elementary arithmetic, complementing the existing binary tree and string processing problems while maintaining cognitive and technical consistency.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): Adds two numbers represented by linked lists where each node contains a single digit. The digits are stored in reverse order, and the function returns their sum as a linked list. dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 is not None or l2 is not None: x = l1.val if l1 is not None else 0 y = l2.val if l2 is not None else 0 total = carry + x + y carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next if carry > 0: current.next = ListNode(carry) return dummy_head.next"},{"question":"You are given an integer array `heights` representing the height of a bush at various positions along a line. Your task is to cut the bushes such that every bush has the same height. You can only cut bushes to make them shorter, and you can perform this operation any number of times. Return the minimum total number of units that need to be cut to achieve this. You may assume that the input array is non-empty and contains positive integers only.","solution":"def min_cut_units(heights): Returns the minimum total number of units that need to be cut to make all bushes the same height. :param heights: List[int] - an array of integers representing the height of bushes :return: int - the minimum number of cut units needed min_height = min(heights) total_cuts = sum(height - min_height for height in heights) return total_cuts"},{"question":"Given a collection of `n` stones positioned in a row, each stone has a positive integer weight represented by the array `weights`. You can perform a merge operation where you pick two adjacent stones and replace them with a new stone whose weight is the sum of the two picked stones. This operation reduces the total number of stones by one. Your objective is to merge all the stones into a single stone with minimal total cost, where the cost of each merge operation is equal to the weight of the newly formed stone. Return _the minimal total cost_ required to merge all the stones into one stone.","solution":"def min_merge_cost(weights): Returns the minimal total cost required to merge all stones into one stone. weights: list of int The weights of the stones. return: int The minimal total cost. from heapq import heappop, heappush, heapify heapify(weights) total_cost = 0 while len(weights) > 1: # Pick the two smallest stones first_min = heappop(weights) second_min = heappop(weights) # Merge them new_stone = first_min + second_min total_cost += new_stone # Add the new stone back into the heap heappush(weights, new_stone) return total_cost"},{"question":"Write a function to return the **intersecting node** of two single linked lists. For example, the following two linked lists: A: a1 -> a2 c1 -> c2 -> c3 / B: b1 -> b2 -> b3 Intersect at node c1. The function should take the two head nodes of the linked lists as input and return the reference to the intersecting node. If the two linked lists have no intersection at all, return `null`. Do this in `O(n + m)` time where `n` and `m` are the lengths of the two lists respectively and only use `O(1)` memory.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA, headB): This function returns the node at which two linked lists intersect. If the two linked lists have no intersection, return None. if not headA or not headB: return None pointerA = headA pointerB = headB while pointerA != pointerB: pointerA = headB if pointerA is None else pointerA.next pointerB = headA if pointerB is None else pointerB.next return pointerA"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped between bars of different heights where the width of each bar is 1 unit. Write an efficient algorithm to compute how much water can be trapped after raining. Implement a function `trap` that takes a list of integers `height` and returns an integer representing the total units of water trapped. Example: Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Notice that in this example, 6 units of rainwater are trapped between the bars.","solution":"def trap(height): Compute how much water can be trapped after raining. :param height: List of non-negative integers representing the height of bars. :return: Integer representing the total units of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"A string `sentence` is given which consists of words separated by spaces. Each word is a permutation of a word found in a given list of `valid_words`. Write a function that returns a list of words in `sentence` which are valid permutations found in `valid_words`. Each word in the result list should appear in the same order as they appear in `sentence`.","solution":"def is_permutation(word, valid_word): return sorted(word) == sorted(valid_word) def find_valid_words(sentence, valid_words): Returns a list of words in `sentence` which are valid permutations found in `valid_words`. words = sentence.split() result = [] for word in words: for valid_word in valid_words: if is_permutation(word, valid_word): result.append(word) break return result"},{"question":"You are given an undirected graph represented by an integer `n` (the number of nodes) and a 2D integer array `edges`, where `edges[i] = [u, v]` indicates that there is an edge between `u` and `v`. You need to determine if the graph forms a valid tree. A valid tree must satisfy two conditions: it must be acyclic (no cycles) and fully connected (there is a path between any two nodes). Return _`true` if the graph is a valid tree, otherwise return `false`_.","solution":"def is_valid_tree(n, edges): Determines if the undirected graph with n nodes and edges forms a valid tree. if n == 0: return False # For a graph to be a valid tree, it must have exactly n-1 edges if len(edges) != n - 1: return False # Create an adjacency list from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Perform BFS to check connectivity and acyclity visited = set() stack = [(0, -1)] # (current node, parent node) while stack: node, parent = stack.pop() if node in visited: return False # Cycle detected visited.add(node) for neighbor in graph[node]: if neighbor != parent: stack.append((neighbor, node)) return len(visited) == n # Check if all nodes are visited"},{"question":"You are given a string `s` containing only lowercase letters. You need to partition the string into as few parts as possible such that each substring contains at most one unique character. Each part must form a contiguous block of the original string. Return the length of each part. **Example**: ``` Input: s = \\"aaabbbcccaaa\\" Output: [3, 3, 3, 3] ```","solution":"def partition_string(s): Partitions the given string `s` into as few parts as possible such that each substring contains at most one unique character. Returns a list with the lengths of each part. :param s: str, the input string containing only lowercase letters :return: List[int], lengths of each part in the partition if not s: return [] partitions = [] current_char = s[0] current_length = 1 for char in s[1:]: if char == current_char: current_length += 1 else: partitions.append(current_length) current_char = char current_length = 1 partitions.append(current_length) return partitions"},{"question":"Given a string `s` representing a binary number, return the number of operations required to reduce the number to `0`. In one operation, you can either: 1. If the number is even, divide it by `2`. 2. If the number is odd, subtract `1` from it. The input string `s` contains only `\'0\'` and `\'1\'` characters and has length between `1` and `1000\'`.","solution":"def num_operations_to_zero(s): Given a binary string `s`, this function returns the number of operations required to reduce the corresponding binary number to 0 following these rules: 1. If the number is even, divide it by 2. 2. If the number is odd, subtract 1 from it. num = int(s, 2) steps = 0 while num > 0: if num % 2 == 0: num //= 2 else: num -= 1 steps += 1 return steps"},{"question":"Given an array of integers `nums` where each integer represents the number of candies in a pile. You have to make all the piles equal by performing a sequence of operations. In a single operation, you can choose any pile and remove one candy from it. Determine the minimum number of operations needed to make all piles have the same number of candies. You can assume that it is possible to make all piles equal with the given operations. Return an integer that represents the minimum number of operations required.","solution":"def min_operations_to_equal_piles(nums): Returns the minimum number of operations to make all piles have the same number of candies. min_candies = min(nums) return sum(candy - min_candies for candy in nums)"},{"question":"You are given an integer array `nums` and you need to find a subarray whose sum is the largest among all possible subarrays. Return the sum of this maximum subarray. A subarray is a contiguous part of an array. For example, if the input array is `nums = [-2,1,-3,4,-1,2,1,-5,4]`, the subarray `[4,-1,2,1]` has the largest sum `6`, so the function should return `6`.","solution":"def max_subarray_sum(nums): Returns the sum of the largest subarray. # Initialize with the first element of the array max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given an integer array `heights` where `heights[i]` represents the height of a person. A person `i` can see over person `j` if `heights[i] > heights[j]` and `j` stands directly next to `i` (either on the left or the right). Find and return the number of people in the array that can see over both of their neighbors. If a person has fewer than two neighbors, they cannot see over both neighbors.","solution":"def count_people_who_can_see(heights): count = 0 n = len(heights) for i in range(1, n-1): if heights[i] > heights[i-1] and heights[i] > heights[i+1]: count += 1 return count"},{"question":"You are given an integer array `heights` representing the heights of buildings standing in a line of `n` buildings. Each building\'s width is 1. A building can trap water if there are taller buildings to its left and right. Implement a function to compute the maximum amount of water that can be trapped between buildings after it rains. Water trapped at index `i` is the minimum of the maximum height of buildings to its left and right minus the height at index `i`. Return the maximum amount of water trapped across all buildings. If no water can be trapped, return `0`.","solution":"def trap(heights): Computes the maximum amount of water that can be trapped between buildings after it rains. :param heights: List[int], the heights of buildings. :return: int, the maximum amount of water that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += max(0, min(left_max[i], right_max[i]) - heights[i]) return water_trapped"},{"question":"Given an integer array `arr`, your task is to determine whether the array can be partitioned into two subsets such that the sum of the elements in both subsets is equal. Return _a boolean value `true` if such a partition is possible, and `false` otherwise._ For example, given `arr = [1, 5, 11, 5]`, we can partition it as `[1, 5, 5]` and `[11]`, so the function should return `true`. If given `arr = [1, 2, 3, 5]`, the function should return `false` since no equal sum partition exists.","solution":"def can_partition(arr): Determines whether the array can be partitioned into two subsets with equal sum. total_sum = sum(arr) # If total_sum is odd, it\'s not possible to partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(arr) # dp[i] will be True if a subset with sum i can be achieved with elements from the array dp = [False] * (target + 1) dp[0] = True # A subset with sum 0 is always possible for num in arr: for i in range(target, num - 1, -1): if dp[i - num]: dp[i] = True return dp[target]"},{"question":"You are given a **0-indexed** integer array `nums`. Your goal is to calculate the **product sum** of all non-empty subarrays in the array. The **product sum** of a subarray is defined as the product of all its elements. Return _the sum of the product sums_ for all possible non-empty subarrays of `nums`.","solution":"def subarrayProductSum(nums): Calculate the sum of product sums of all non-empty subarrays of the array nums. n = len(nums) total_sum = 0 for start in range(n): product = 1 for end in range(start, n): product *= nums[end] total_sum += product return total_sum"},{"question":"You are given a matrix `grid` representing a maze where `0` represents an open path and `1` represents a wall. You are also given two arrays `start` and `end`, each containing two integers representing the starting and ending positions in the maze, respectively. The robot can move up, down, left, or right. Determine if there is a path from `start` to `end` in the maze. Return `true` if such a path exists, otherwise, return `false`.","solution":"def is_path_exist(grid, start, end): Determines if there is a path from start to end in the given grid. :param grid: List[List[int]] - the grid representing the maze :param start: List[int] - starting position in the grid `[x, y]` :param end: List[int] - ending position in the grid `[x, y]` :return: bool - True if there is a path, False otherwise rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y, visited): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 and not visited[x][y] def dfs(x, y, visited): if [x, y] == end: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, visited) and dfs(nx, ny, visited): return True return False visited = [[False for _ in range(cols)] for _ in range(rows)] return dfs(start[0], start[1], visited)"},{"question":"You are given a string `s` consisting of lowercase alphabets and a list of words `dict` where each word is shorter than string `s`. Write a function `findAllConcatenations(s, dict)` that returns all starting indices of substring(s) in `s` that is a concatenation of each word in `dict` exactly once and without any intervening characters. The words in `dict` can appear in any order and the concatenation of all words forms a valid contiguous substring in `s`. If no such concatenations exist, return an empty list.","solution":"from collections import defaultdict def findAllConcatenations(s, dict): if not dict or not s: return [] word_len = len(dict[0]) num_words = len(dict) total_len = word_len * num_words word_count = defaultdict(int) for word in dict: word_count[word] += 1 def valid_substring(start): seen_words = defaultdict(int) words_used = 0 for i in range(start, start + total_len, word_len): current_word = s[i:i+word_len] if current_word in word_count: if seen_words[current_word] < word_count[current_word]: seen_words[current_word] += 1 words_used += 1 else: return False else: return False return words_used == num_words result_indices = [] for i in range(len(s) - total_len + 1): if valid_substring(i): result_indices.append(i) return result_indices"},{"question":"Write a function that takes a list of integers `heights` representing the heights of different buildings in a row. The objective is to modify the list such that no two adjacent buildings have the same height. You can increase or decrease the heights of the buildings. For each modification (either increase or decrease), there is a cost of 1 unit. Return the minimum total cost required to achieve the result.","solution":"def min_cost_modify_heights(heights): Modify the list of buildings heights so that no two adjacent buildings have the same height with the minimum cost. The cost for each modification (either increase or decrease) is 1 unit. Return the minimum total cost. if not heights: # if the list is empty, return 0 cost return 0 n = len(heights) if n == 1: # if there is only one building, no modification is needed return 0 # Initialize the cost array costs = [0] * n # The cost to modify the first building is 0, as we start with it for i in range(1, n): costs[i] = costs[i - 1] + (heights[i] == heights[i - 1]) if i > 1 and heights[i] == heights[i - 2]: costs[i] = min(costs[i], costs[i - 2] + 1) # Increasing the cost if necessary return costs[-1]"},{"question":"Given an array of integers `nums` and an integer `threshold`, find the maximum length of a subarray such that the sum of its elements is less than or equal to `threshold`. Return the length of the longest such subarray.","solution":"def max_length_subarray(nums, threshold): Finds the maximum length of a subarray such that the sum of its elements is less than or equal to threshold. Returns the length of the longest such subarray. n = len(nums) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum > threshold: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a **0-indexed** array of integers `coins` that represent the value of coins in a row. A player can pick a few coins from the list, but once a coin is picked, its adjacent coins (both left and right) cannot be picked because they are removed from the row, along with the picked coin. Return _the maximum value of coins the player can pick without breaking the adjacency rule._","solution":"def max_coins(coins): n = len(coins) if n == 0: return 0 if n == 1: return coins[0] if n == 2: return max(coins) # Initialize dp array dp = [0] * n # base cases for dp array dp[0] = coins[0] dp[1] = max(coins[0], coins[1]) for i in range(2, n): dp[i] = max(dp[i - 1], coins[i] + dp[i - 2]) return dp[-1]"},{"question":"Given an array of integers `arr` where `arr[i]` represents the height of the `i-th` building, a list of queries where each query is represented as `[start_index, end_index]`, and another integer `k`, return a list of boolean values where each value indicates whether there exists a path from the building at `start_index` to the building at `end_index` such that the height difference between consecutive buildings on the path is at most `k`. A path from `A` to `B` exists if you can move from building `A` to building `B` by moving only to adjacent buildings (i.e., from building `i` to building `i+1` or from building `i` to building `i-1`).","solution":"def can_traverse(arr, queries, k): Determines if a path exists between buildings in each query such that the difference in heights between adjacent buildings is at most k. Parameters: arr (list of int): Heights of buildings. queries (list of list of int): Each query represented as [start_index, end_index]. k (int): The maximum allowable height difference. Returns: list of bool: A list of boolean values indicating the result for each query. def is_path_possible(start, end): if start == end: return True direction = 1 if end > start else -1 for i in range(start, end, direction): if abs(arr[i] - arr[i + direction]) > k: return False return True results = [is_path_possible(start, end) for start, end in queries] return results"},{"question":"Implement a class `MedianFinder` that continuously calculates the **median** from a stream of numbers. The median is the middle value in an ordered integer list. If the size of the list is even, the median is the average of the two middle numbers. The class should have the following methods: - `MedianFinder()`: Initializes the `MedianFinder` object. - `void addNum(int num)`: Adds the integer `num` to the data stream. - `double findMedian()`: Returns the median of all elements so far. For example: - `addNum(1)` and `addNum(2)` would yield `findMedian()` to return `1.5`. - `addNum(3)` would then yield `findMedian()` to return `2.0`.","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. self.min_heap = [] self.max_heap = [] def addNum(self, num: int) -> None: Adds a number to the data stream. heapq.heappush(self.max_heap, -num) if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self) -> float: Returns the median of all elements. if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"You are given the `head` of a singly linked list. Write an algorithm to reorder the list such that: * The nodes from the front and the end alternate. Specifically, after reordering, the list should be as follows: the first node, the last node, the second node, the second-to-last node, and so on. For example, consider the linked list `1 -> 2 -> 3 -> 4 -> 5`. After reordering, the list should become `1 -> 5 -> 2 -> 4 -> 3`. Modify the list in-place and return nothing.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): Reorder the linked list in the specified pattern. if not head or not head.next: return # Find the middle of the linked list with slow and fast pointers slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Merge two halves first, second = head, prev while second.next: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first = temp1 second = temp2"},{"question":"You are given an array of integers `nums`. In one operation, you can pick an integer `a` from the array and replace it with any integer from `1` to `a-1`, inclusive. Find the **minimum** number of operations required to make all the elements of the array **unique**. If it\'s impossible to make all elements unique, return `-1`.","solution":"def min_operations_to_unique(nums): nums.sort() operations = 0 for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: increment = (nums[i - 1] + 1) - nums[i] operations += increment nums[i] = nums[i - 1] + 1 return operations"},{"question":"You are given an array of integers `arr` representing the heights of people standing in a row, and an integer `x` representing the number of people to be selected. You need to select `x` people such that the difference between the height of the tallest and shortest person among the selected `x` is minimized. Return the minimum possible difference.","solution":"def min_difference(arr, x): Returns the minimum possible difference between the height of the tallest and shortest person among the selected x people. if x == 0 or not arr or len(arr) < x: return 0 arr.sort() # Sort the array to find the minimum difference efficiently min_diff = float(\'inf\') # Initialize minimum difference to infinity # Iterate through array to find the minimum difference between # the highest and lowest in every x-sized subsequence for i in range(len(arr) - x + 1): min_diff = min(min_diff, arr[i + x - 1] - arr[i]) return min_diff"},{"question":"You are given an integer array `arr` of size `n` and a positive integer `k`. You need to find the total number of contiguous subarrays of length `k` that have at least one element that appears more than once within the subarray. Return the total count of such subarrays.","solution":"def count_repeated_subarrays(arr, k): Returns the count of contiguous subarrays of length k that have at least one element that appears more than once. :param arr: List[int] - the input array of integers :param k: int - the length of the contiguous subarrays :return: int - the count of such subarrays from collections import Counter n = len(arr) count = 0 for i in range(n - k + 1): subarray = arr[i:i+k] freq = Counter(subarray) if any(value > 1 for value in freq.values()): count += 1 return count"},{"question":"You are given an array of integers `nums` representing the number of coins present in each pile. You need to divide the coins into two groups with as equal a total value as possible. Write a function `canDivideEqualCoins(nums)` that returns `true` if it\'s possible to divide the coins into two groups with equal sum, and `false` otherwise. Note that each pile must belong to exactly one group.","solution":"def canDivideEqualCoins(nums): Returns True if it\'s possible to divide the coins into two groups with equal sum, otherwise False. total_sum = sum(nums) # If total sum is odd, we can\'t divide it into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) # dp[i] will be True if a subset of nums[0..i-1] has a sum equal to `target_sum` dp = [False] * (target_sum + 1) dp[0] = True for coin in nums: for j in range(target_sum, coin - 1, -1): dp[j] = dp[j] or dp[j - coin] return dp[target_sum]"},{"question":"You are given an array of integers `arr` and an integer `target`. You need to find the length of the smallest contiguous subarray of which the sum is greater than or equal to `target`. If there is no such subarray, return `0` instead. Implement a function `int smallestSubarrayWithSum(int[] arr, int target)` that returns the required length. *Example:* ``` Input: arr = [2,3,1,2,4,3], target = 7 Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. ``` *Example:* ``` Input: arr = [1,4,4], target = 4 Output: 1 Explanation: The subarray [4] has the minimal length under the problem constraint. ``` *Example:* ``` Input: arr = [1,1,1,1,1,1,1,1], target = 11 Output: 0 Explanation: No subarray satisfies the condition. ```","solution":"def smallestSubarrayWithSum(arr, target): n = len(arr) if n == 0: return 0 min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"You are given an integer array `nums` and two integers `x` and `y`. We define a pair of indices `(i, j)` as a special pair if the difference between `nums[i]` and `nums[j]` is at most `x` and the absolute difference between `i` and `j` is at most `y`. Return _(the number of special pairs)_ `(i, j)` _such that_ `0 <= i < j < nums.length`.","solution":"def count_special_pairs(nums, x, y): Count the number of special pairs (i, j) where: - The difference between nums[i] and nums[j] is at most x - The absolute difference between i and j is at most y - 0 <= i < j < len(nums) Args: nums (list): List of integers x (int): The maximum difference allowed between nums[i] and nums[j] y (int): The maximum absolute difference allowed between indices i and j Returns: int: The number of special pairs n = len(nums) count = 0 for i in range(n): for j in range(i + 1, min(i + y + 1, n)): if abs(nums[i] - nums[j]) <= x: count += 1 return count"},{"question":"Write a function `increase_elements_by_k` that modifies an array of integers by increasing each element by a given value `k`. The function should return the modified array. For example, given the array `[1, 2, 3]` and `k = 2`, the function should return `[3, 4, 5]`. Provide a solution that efficiently handles arrays of varying lengths.","solution":"def increase_elements_by_k(arr, k): Returns a new array where each element is increased by k. Parameters: arr (list of int): List of integers to be modified. k (int): Value to increase each element by. Returns: list of int: Modified list with each element increased by k. return [x + k for x in arr]"},{"question":"You are given the head of a singly linked list, where each node contains an integer value. You need to reverse the linked list, but you must do it in groups of `k` nodes. That is, reversals should only occur in blocks of size `k`. If the remaining nodes are fewer than `k`, they should remain in their original order. Write a function that takes the head of the linked list and an integer `k` and returns the head of the modified list after reversing each k-group of nodes. For example, given the linked list `[1 -> 2 -> 3 -> 4 -> 5]` and `k = 3`, your output should be `[3 -> 2 -> 1 -> 4 -> 5]`. For `k = 2`, the output should be `[2 -> 1 -> 4 -> 3 -> 5]`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): new_head = None ptr = head while k > 0: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"You are given an array of non-negative integers representing the height of blocks where the width of each block is 1. Imagine water being poured over the blocks until it settles on top of the blocks or between them. Return _the total amount of water that can be trapped between the blocks after it rains_, assuming the edges of the array extend upwards infinitely. Use an algorithm with a linear runtime complexity.","solution":"def trap(height): Calculates the amount of water that can be trapped after raining. :param height: List[int] representing the height of blocks :return: int, the total amount of trapped water if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given a string `str`, determine if it is possible to make the string a palindrome by removing **at most one** character. Return `true` if it is possible to make the string a palindrome by removing **at most one** character, otherwise return `false`. A palindrome is a word that reads the same backward as forward.","solution":"def valid_palindrome(s): Determine if it is possible to make the string a palindrome by removing at most one character. def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"Given a matrix of `m x n` integers, return the minimum sum path to reach the bottom-right corner of the matrix starting from the top-left corner. You can only move either down or right at any point in time.","solution":"def min_sum_path(matrix): Returns the minimum sum path to reach the bottom-right corner of the matrix starting from the top-left corner. You can only move either down or right at any point in time. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Create a 2D dp array with the same dimensions as the matrix dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"You are given an array `arr` containing `n` distinct integers. A permutation of the array is called a Zigzag permutation if the elements of the permutation alternate between a higher and a lower value. Formally, a permutation `p` is Zigzag if for every odd index `i` (1-based indexing), `p[i-1] < p[i] > p[i+1]`. Determine whether a Zigzag permutation of the array exists. If it exists, return any Zigzag permutation of the array. If it does not exist, return an empty array.","solution":"def zigzag_permutation(arr): Returns a zigzag permutation of the array if it exists, otherwise returns an empty array. if not arr: return [] arr.sort() for i in range(1, len(arr)-1, 2): arr[i], arr[i+1] = arr[i+1], arr[i] return arr if len(arr) < 2 or arr[-2] < arr[-1] else []"},{"question":"Given an integer array `nums` and an integer `target`, determine if you can construct the integer `target` using a subset of the elements in `nums` such that each element can only be used once. Return _true_ if you can construct the `target`, otherwise return _false_.","solution":"def can_construct_target(nums, target): Determines if the target can be constructed using a subset of elements in nums. Args: nums (list): List of integers. target (int): Target integer to construct using a subset of nums. Returns: bool: True if target can be constructed, otherwise false. def can_construct(index, current_sum): if current_sum == target: return True if current_sum > target or index == len(nums): return False # Choose the number at index include_num = can_construct(index + 1, current_sum + nums[index]) # Do not choose the number at index exclude_num = can_construct(index + 1, current_sum) return include_num or exclude_num return can_construct(0, 0)"},{"question":"Given a string `s` representing an encoded message where each letter is represented by a number corresponding to its position in the alphabet (`\'A\' = 1, \'B\' = 2, ..., \'Z\' = 26`), return the total number of ways to decode it. A single digit can be decoded if it is between 1 and 9, and a pair of digits can be decoded if it forms a number between 10 and 26 inclusive. Assume the input string does not contain any leading zeros and is non-empty. For example, given the string `\\"12\\"`, it can be decoded as `\\"AB\\"` (1 2) or `\\"L\\"` (12), which results in 2 ways.","solution":"def num_decodings(s): Return the total number of ways to decode the string s. if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != \'0\': dp[i] += dp[i - 1] if i != 1 and s[i - 2] != \'0\' and 10 <= int(s[i - 2:i]) <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given a square matrix `grid` of size `n x n` consisting of non-negative integers. You initially start at the top-left corner of the matrix (i.e., `grid[0][0]`). Your goal is to move to the bottom-right corner of the matrix (i.e., `grid[n-1][n-1]`). You can only move either right or down at any point in time. You want to make the total sum of the values in the path as small as possible. Return _the **minimum** path sum_ from the top-left corner to the bottom-right corner.","solution":"def min_path_sum(grid): Returns the minimum path sum from the top-left corner to the bottom-right corner of a given n x n grid where you can only move right or down. n = len(grid) # Create a 2D array to store the minimum path sum up to each cell dp = [[0] * n for _ in range(n)] # Set the value for the top-left cell dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the result return dp[n-1][n-1]"},{"question":"You are given a list of strings `words`. Each word is in lowercase and may contain duplicate letters. You need to find out if there is any subset of two words such that their concatenation results in a palindrome. Return true if at least one such subset exists, otherwise return false.","solution":"def is_palindrome(s): Helper function to check if a string is a palindrome. return s == s[::-1] def can_form_palindrome(words): Returns True if any subset of two words can form a palindrome upon concatenation. for i in range(len(words)): for j in range(i + 1, len(words)): if is_palindrome(words[i] + words[j]) or is_palindrome(words[j] + words[i]): return True return False"},{"question":"Given a string `s` consisting of lowercase letters, you are asked to find all possible palindromic substrings in `s`. Return an array `result` where each element is a palindromic substring of `s` in no particular order. The array should not contain duplicate substrings.","solution":"def find_palindromic_substrings(s): Returns all unique palindromic substrings in the given string. :param s: The input string consisting of lowercase letters. :return: A list containing all unique palindromic substrings. def is_palindrome(sub): return sub == sub[::-1] unique_palindromes = set() for i in range(len(s)): for j in range(i+1, len(s)+1): substring = s[i:j] if is_palindrome(substring): unique_palindromes.add(substring) return list(unique_palindromes)"},{"question":"You are given a string representing a sequence of lowercase letters, and you need to determine the length of the **longest substring** that contains at most **two distinct characters**. A substring is a contiguous sequence of characters within the string. For example, given the string `\\"eceba\\"`, the longest substring with at most two distinct characters is `\\"ece\\"` with a length of 3. Write a function that receives a string `s` and returns an integer representing the length of the longest substring with at most two distinct characters. Your algorithm should aim for an optimal solution with a time complexity of `O(n)`.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. :param s: A string consisting of lowercase letters. :return: An integer indicating the length of the longest substring with at most two distinct characters. if len(s) < 3: return len(s) left = 0 max_length = 0 char_map = {} for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array of integers `heights` where `heights[i]` represents the height of a building at index `i`. The buildings form a skyline. You are also given an integer `bricks` and an integer `ladders`. You can either use a brick or a ladder to jump between buildings, but bricks can only be used to climb short heights while ladders can be used to climb any height. Each brick can help you climb a 1-unit height difference between two adjacent buildings. You start at the first building (index 0) and you want to go as far as possible by either using bricks, ladders, or both. Return _the maximum index you can reach starting from the first building using the given number of bricks and ladders_.","solution":"import heapq def furthest_building(heights, bricks, ladders): This function returns the maximum index you can reach starting from the first building using the given number of bricks and ladders. Args: heights: List of integers representing the height of buildings. bricks: Integer representing the number of bricks available. ladders: Integer representing the number of ladders available. Returns: Integer representing the maximum index that can be reached. heap = [] for i in range(len(heights) - 1): diff = heights[i + 1] - heights[i] if diff > 0: heapq.heappush(heap, diff) if len(heap) > ladders: bricks -= heapq.heappop(heap) if bricks < 0: return i return len(heights) - 1"},{"question":"You are given an integer array `arr` of length `n`. You can choose at most one element from `arr` and replace it with any integer you want. Your goal is to make the array strictly increasing with the minimum number of modifications. A strictly increasing array is one in which `arr[i] < arr[i+1]` for all `0 <= i < n - 1`. Return _the minimum number of modifications needed_ to make the array strictly increasing. If it is not possible to create a strictly increasing array with the given constraint, return `-1`.","solution":"def min_modifications_to_strictly_increasing(arr): Returns the minimum number of modifications needed to make the array strictly increasing with at most one modification. If it\'s not possible with one modification, returns -1. n = len(arr) if n <= 1: return 0 decreasing_errors = [] for i in range(n - 1): if arr[i] >= arr[i + 1]: decreasing_errors.append(i + 1) if len(decreasing_errors) == 0: return 0 elif len(decreasing_errors) > 1: return -1 index = decreasing_errors[0] if index == 1 or arr[index] > arr[index - 2]: return 1 if index == n - 1 or arr[index - 1] < arr[index + 1]: return 1 return -1"},{"question":"Given a string `s`, determine the length of the longest substring of `s` that consists of the same character. For example, if the input string is \\"abbcccddddeeeeedcba\\", the output should be 5, since the longest substring with identical characters is \\"eeeee\\" which has length 5.","solution":"def longest_repeating_substring(s): Returns the length of the longest substring of s that consists of the same character. if not s: return 0 max_length = 1 current_length = 1 # Iterate over the string to find the longest substring of the same character for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # Final check at the end of the string max_length = max(max_length, current_length) return max_length"},{"question":"Given two arrays of integers `arr1` and `arr2` of length `n` and `m` respectively, where `arr1` and `arr2` are sorted in non-decreasing order, merge the two arrays into a single sorted array. Return the merged sorted array without using any extra space (i.e., modify the arrays in-place and merge them).","solution":"def merge_arrays(arr1, arr2): Merge two sorted arrays in-place without extra space. Args: arr1 (list): First sorted array of length n arr2 (list): Second sorted array of length m Returns: list: The merged sorted array # Lengths of the arrays n, m = len(arr1), len(arr2) # Pointer to the end of arr1 i = n - 1 # Pointer to the end of arr2 j = m - 1 # Pointer to the end of the merged array which will be of size (n + m) k = n + m - 1 # Extend arr1 to hold all elements arr1.extend([0]*m) # Traverse both arrays from the end while i >= 0 and j >= 0: if arr1[i] > arr2[j]: arr1[k] = arr1[i] i -= 1 else: arr1[k] = arr2[j] j -= 1 k -= 1 # If any remaining elements in arr2, add them while j >= 0: arr1[k] = arr2[j] j -= 1 k -= 1 # No need to add remaining elements from arr1 as they are already in place # Return the final merged array return arr1"},{"question":"Given a list of non-negative integers representing the heights of bars in a histogram, return the area of the largest rectangle that can be formed within the histogram. The width of each bar is `1`. Each bar corresponds to a horizontal stripe, and the height of the bar represents the height of the stripe. Formulate an efficient algorithm to compute the maximum possible rectangular area that can be created using these bars in the histogram. Return _an integer representing the area of the largest rectangle_.","solution":"def largestRectangleArea(heights): Given a list of non-negative integers representing the heights of bars in a histogram, return the area of the largest rectangle that can be formed within the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are tasked with creating a custom playlist for a music streaming service. The playlist should contain songs from different genres, but you must ensure that no two consecutive songs are of the same genre. You are given an array `songs` where each element is a string in the format `\\"title:genre\\"` (e.g., `\\"Bohemian Rhapsody:Rock\\"`, `\\"Imagine:Pop\\"`). Write a function that returns a valid playlist (a reordered list of `songs` where no two consecutive songs are of the same genre), or an empty list if no such arrangement is possible. ```python def create_playlist(songs): # your code here # Example usage: songs = [\\"Bohemian Rhapsody:Rock\\", \\"Imagine:Pop\\", \\"Stairway to Heaven:Rock\\", \\"Billie Jean:Pop\\"] print(create_playlist(songs)) # Output: a list where no two consecutive songs are of the same genre ```","solution":"from collections import Counter, defaultdict def create_playlist(songs): # Split titles and genres, and count genre occurrences song_data = [(song.split(\':\')[0], song.split(\':\')[1]) for song in songs] genre_count = Counter([genre for _, genre in song_data]) # If any genre appears more than (n + 1) // 2 times, no valid arrangement is possible max_allowed = (len(songs) + 1) // 2 if any(count > max_allowed for count in genre_count.values()): return [] # Bucket songs by genre for easy access genre_buckets = defaultdict(list) for title, genre in song_data: genre_buckets[genre].append(title) # Sort genres by their counts in descending order to prioritize placement sorted_genres = sorted(genre_count, key=lambda g: -genre_count[g]) result = [None] * len(songs) index = 0 # Place each genre\'s songs in the result array ensuring no consecutive same genres for genre in sorted_genres: for title in genre_buckets[genre]: result[index] = f\\"{title}:{genre}\\" index += 2 if index >= len(result): index = 1 return result"},{"question":"Given a binary tree, you need to find the **largest subtree sum**. A subtree is defined as any node and all its descendants in the binary tree. The subtree sum is the sum of all the node values in that subtree. Write a function that takes the root of a binary tree as input and returns the largest sum among all subtrees of that tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestSubtreeSum(root): Return the largest subtree sum in the given binary tree. :param root: TreeNode :return: int def dfs(node): if not node: return 0 # Calculate left and right subtree sums recursively left_sum = dfs(node.left) right_sum = dfs(node.right) # Calculate the sum of the current subtree current_subtree_sum = node.val + left_sum + right_sum # Update the largest sum found so far nonlocal largest_sum largest_sum = max(largest_sum, current_subtree_sum) return current_subtree_sum largest_sum = float(\\"-inf\\") dfs(root) return largest_sum"},{"question":"Given a string `s` consisting of lowercase alphabets and a positive integer `k`, return _the lexicographically smallest string that can be obtained by performing the following operation_: 1. Select any character `s[i]` and replace it with any character from `\'a\'` to `\'z\'`. You are allowed to perform this operation at most `k` times.","solution":"def smallest_lexicographical_string(s, k): Returns the lexicographically smallest string that can be obtained by performing the given operation at most k times. s_list = list(s) n = len(s_list) # We will perform up to k replacements for i in range(n): if k <= 0: break # Replace s[i] with \'a\' if it is not already \'a\' if s_list[i] != \'a\': s_list[i] = \'a\' k -= 1 return \'\'.join(s_list)"},{"question":"Implement a Movie Rating System that allows users to rate movies and retrieve average ratings. The `MovieRating` class should have the following methods: * `void addMovie(int movieId)` - Adds a movie with the ID `movieId` to the system. * `void rateMovie(int userId, int movieId, int rating)` - Allows a user with the ID `userId` to rate a movie with the ID `movieId` with a rating value from `1` to `5`. * `double getAverageRating(int movieId)` - Returns the average rating of the movie with the ID `movieId`. If the movie has not been rated yet, return `0.0`. * `int getUserRating(int userId, int movieId)` - Returns the rating given by the user with the ID `userId` for the movie with the ID `movieId`. If the user has not rated the movie yet, return `-1`.","solution":"class MovieRating: def __init__(self): self.movies = {} self.user_ratings = {} def addMovie(self, movieId): if movieId not in self.movies: self.movies[movieId] = [] def rateMovie(self, userId, movieId, rating): if movieId in self.movies and 1 <= rating <= 5: self.movies[movieId].append(rating) if userId not in self.user_ratings: self.user_ratings[userId] = {} self.user_ratings[userId][movieId] = rating def getAverageRating(self, movieId): if movieId in self.movies and self.movies[movieId]: return sum(self.movies[movieId]) / len(self.movies[movieId]) return 0.0 def getUserRating(self, userId, movieId): if userId in self.user_ratings and movieId in self.user_ratings[userId]: return self.user_ratings[userId][movieId] return -1"},{"question":"Given an array of `n` integers where `n > 2`, find a `peak element` in `the array`. An element is a peak if it is greater than its neighbors. For corner elements, we need to consider only one neighbor. Your task is to write a function that returns the index of any one of the peak elements. For example, if the input array is `[1, 3, 20, 4, 1, 0]`, the function can return index `2` (the peak element `20`) or index `1` (the peak element `3`) as both satisfy the peak condition. Return _the index of one of the peak elements_. Note: - The array may contain multiple peaks, in which case return the index to any one of the peaks is fine. - You can assume that `arr[-1] = arr[n] = -∞ (negative infinity)`.","solution":"def find_peak_element(arr): Returns the index of a peak element in the array. n = len(arr) if n == 1: return 0 if arr[0] >= arr[1]: return 0 if arr[n - 1] >= arr[n - 2]: return n - 1 for i in range(1, n - 1): if arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]: return i"},{"question":"You are given an integer array `nums` and an integer `k`. A part of the array is defined as a contiguous sequence of elements. Your task is to find the number of distinct elements in each part of the array that consists of exactly `k` elements. Return an array `result` where `result[i]` is the number of distinct elements in the part of the array `nums` starting from position `i` and ending at position `i + k - 1`. If there are fewer than `k` elements remaining in the array to form a part, do not include any results for those remaining elements.","solution":"def distinct_elements_in_subarrays(nums, k): Returns an array where each element represents the number of distinct elements in each subarray of length k in the input list nums. if k > len(nums): return [] result = [] for i in range(len(nums) - k + 1): distinct_count = len(set(nums[i:i + k])) result.append(distinct_count) return result"},{"question":"You are given a string `sequence` that consists of parentheses `(` and `)`. A string is called **valid** if: - Any left parenthesis `(` has a corresponding right parenthesis `)`. - Any right parenthesis `)` has a corresponding left parenthesis `(`. - Left parentheses should be closed in the correct order, i.e., every opening parenthesis should be matched before its corresponding closing parenthesis. You need to find the length of the longest valid parentheses substring in the given `sequence`. Return _the length of the longest valid parentheses substring_.","solution":"def longest_valid_parentheses(sequence): Returns the length of the longest valid parentheses substring. max_length = 0 stack = [-1] for i, char in enumerate(sequence): if char == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"You are given a list of `n` words. A word `w` is called a \\"reversible word\\" if reversing the order of characters in `w` gives another word which is present in the list. For example, if the list contains the word \\"abc\\" and its reverse \\"cba\\", then \\"abc\\" is a reversible word. Write a function that returns the count of reversible words in the list. Note that each word in the list is to be considered only once, even if its reverse appears multiple times.","solution":"def count_reversible_words(words): Returns the count of reversible words in the list. A word w is called a \\"reversible word\\" if reversing the order of characters in w gives another word which is present in the list. word_set = set(words) reversible_count = 0 seen_words = set() for word in words: if word not in seen_words: # Ensure each word is counted only once reversed_word = word[::-1] if reversed_word in word_set and reversed_word != word: reversible_count += 1 seen_words.add(reversed_word) seen_words.add(word) return reversible_count"},{"question":"You are given a list of `words` where each word is either a positive integer or a non-integer string. Your task is to sort this list based on the following criteria: 1. All integer words should be sorted in ascending order. 2. All non-integer words should be sorted in lexicographically ascending order, ignoring case. 3. All integers should appear before any non-integer words in the sorted list. Write a function `sort_words(words)` that takes a list of words and returns a new list where the words are sorted as described. For example, given the list `[\\"apple\\", \\"Banana\\", \\"30\\", \\"20\\", \\"zebra\\", \\"10\\"]`, the function should return `[\\"10\\", \\"20\\", \\"30\\", \\"apple\\", \\"Banana\\", \\"zebra\\"]`.","solution":"def sort_words(words): Sorts a list of words such that all integers appear before any non-integer words, with integers sorted in ascending order and non-integer words sorted lexicographically (case-insensitive). integer_words = sorted([word for word in words if word.isdigit()], key=int) non_integer_words = sorted([word for word in words if not word.isdigit()], key=lambda x: x.lower()) return integer_words + non_integer_words"},{"question":"Given an unsorted integer array `arr`, find the smallest positive integer that does not appear in `arr`.","solution":"def smallest_missing_positive(arr): Returns the smallest positive integer that does not appear in the array `arr`. nums_set = set(arr) smallest_missing = 1 while smallest_missing in nums_set: smallest_missing += 1 return smallest_missing"},{"question":"Given an integer array `arr`, determine whether there exists a subarray, whose sum of the elements is equal to a prime number. If such a subarray exists, return `true`; otherwise, return `false`. A **subarray** is a contiguous part of an array. # Constraints: - The number of subarrays to be considered is a large enough value. - Use an efficient algorithm to avoid unnecessary computations.","solution":"def is_prime(n): Checks if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def has_prime_sum_subarray(arr): Determines whether there exists a subarray in arr whose sum is prime. n = len(arr) # Generate all subarrays for start in range(n): subarray_sum = 0 for end in range(start, n): subarray_sum += arr[end] if is_prime(subarray_sum): return True return False"},{"question":"Given a **directed acyclic graph (DAG)**, find and return _one of its topological orderings_. The graph is given as an adjacency list where each node is represented by a unique integer.","solution":"def topological_sort(graph): Returns one of the topological orderings of a directed acyclic graph. Parameters: graph (dict): A dictionary where keys are node integers and values are lists of integers representing directed edges. Returns: list: A list of integers representing one of the topological orderings of the graph. def dfs(node): nonlocal graph, visited, stack visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor) stack.append(node) visited = set() stack = [] # Call DFS from all nodes to cover disconnected parts of the graph for node in graph: if node not in visited: dfs(node) return stack[::-1] # return the stack reversed as the topological order"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `n`. Find the length of the shortest substring of `s` that contains at least `n` distinct characters. If no such substring exists, return `-1`.","solution":"def shortest_substring_with_n_distinct_chars(s, n): This function finds the length of the shortest substring of `s` that contains at least `n` distinct characters. If no such substring exists, it returns `-1`. if n > len(set(s)): return -1 start = 0 min_length = float(\'inf\') char_count = {} for end in range(len(s)): if s[end] in char_count: char_count[s[end]] += 1 else: char_count[s[end]] = 1 while len(char_count) >= n: min_length = min(min_length, end - start + 1) char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given two strings `s` and `t` consisting of lowercase English letters. Determine if `t` is an anagram of `s`, meaning that `t` can be formed by rearranging the letters of `s` with each character appearing the same number of times. You should solve this problem in `O(n)` time complexity, where `n` is the length of the strings. Return _true_ if `t` is an anagram of `s`, otherwise return _false_.","solution":"def is_anagram(s, t): Determine if t is an anagram of s. :param s: The original string. :param t: The string to check if it is an anagram of s. :return: True if t is an anagram of s, False otherwise. if len(s) != len(t): return False char_count_s = {} char_count_t = {} for char in s: if char in char_count_s: char_count_s[char] += 1 else: char_count_s[char] = 1 for char in t: if char in char_count_t: char_count_t[char] += 1 else: char_count_t[char] = 1 return char_count_s == char_count_t"},{"question":"Given a string `s` and a list of words `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words from `wordDict`. Note that the same word in the dictionary may be reused multiple times in the segmentation. For example: - Given `s = \\"leetcode\\"`, `wordDict = [\\"leet\\", \\"code\\"]`, it returns `true` as \\"leetcode\\" can be segmented as \\"leet code\\". - Given `s = \\"applepenapple\\"`, `wordDict = [\\"apple\\", \\"pen\\"]`, it returns `true` as \\"applepenapple\\" can be segmented as \\"apple pen apple\\". This problem tests your ability to implement dynamic programming and understand how to efficiently check substring segments against a provided dictionary.","solution":"def word_break(s, wordDict): Returns true if s can be segmented into a space-separated sequence of one or more dictionary words from wordDict. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # Base case: an empty string can be segmented. for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"You are given an integer matrix `matrix` and an integer `target`. The matrix has the following properties: - Each row is sorted in non-decreasing order. - The first integer of each row is greater than the last integer of the previous row. Write an algorithm to find the position of `target` in the matrix. If the target exists, return its position as a list `[row_index, column_index]`. If the target does not exist in the matrix, return `[-1, -1]`. The algorithm should have a logarithmic time complexity.","solution":"def search_matrix(matrix, target): Searches for a target value in a matrix. Returns the position of the target as [row_index, column_index]. If the target does not exist, returns [-1, -1]. :param matrix: List[List[int]] - A list of lists of integers representing the matrix. :param target: int - The target integer to search for in the matrix. :return: List[int] - A list of two integers representing the position of the target. if not matrix or not matrix[0]: return [-1, -1] rows = len(matrix) cols = len(matrix[0]) left, right = 0, (rows * cols) - 1 while left <= right: mid = left + (right - left) // 2 mid_value = matrix[mid // cols][mid % cols] if mid_value == target: return [mid // cols, mid % cols] elif mid_value < target: left = mid + 1 else: right = mid - 1 return [-1, -1]"},{"question":"You are given an array `heights` representing the heights of buildings, where `heights[i]` is the height of the `i-th` building. You need to select and remove some buildings such that the remaining buildings\' heights form a strictly increasing sequence. Return _the maximum number of buildings you can remove to achieve this_.","solution":"def max_buildings_to_remove(heights): Returns the maximum number of buildings that can be removed to form a strictly increasing sequence of remaining buildings\' heights. n = len(heights) if n == 0: return 0 # Calculate the length of the longest increasing subsequence (LIS) lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) # Length of LIS is the number of buildings left to form increasing sequence max_lis = max(lis) return n - max_lis"},{"question":"You are given a string `str` containing only lowercase letters. A string is called **balanced** if every letter appears in it exactly the same number of times. Your task is to determine whether the given string is balanced. Return `true` _if_ `str` _is balanced_. Otherwise, return `false`.","solution":"def is_balanced(s: str) -> bool: Determines if the given string is balanced. A string is balanced if every letter appears in it exactly the same number of times. Args: s (str): Input string containing only lowercase letters Returns: bool: True if the string is balanced, false otherwise from collections import Counter if not s: return True # An empty string is considered balanced counter = Counter(s) frequencies = list(counter.values()) return len(set(frequencies)) == 1"},{"question":"Given a binary tree, return the **sum** of values of all nodes with a value in the range `[low, high]`. The binary tree is represented by its root node, and nodes have integer values. Construct an algorithm to perform this operation efficiently. Each node in the tree has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function with the following signature: ```python def rangeSumBST(root: TreeNode, low: int, high: int) -> int: ``` The function should return an integer representing the sum of all nodes within the specified range.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSumBST(root: TreeNode, low: int, high: int) -> int: Returns the sum of values of all nodes with a value in the range [low, high]. if root is None: return 0 total_sum = 0 if low <= root.val <= high: total_sum += root.val if low < root.val: total_sum += rangeSumBST(root.left, low, high) if root.val < high: total_sum += rangeSumBST(root.right, low, high) return total_sum"},{"question":"You are given two sorted arrays, `arr1` and `arr2`, of size `m` and `n` respectively. Merge these two arrays into a single sorted array without using extra space. Return _the merged and sorted array as the final output_. Note that you are not allowed to use any extra space for another array and you have to modify the arrays `arr1` and `arr2` in place.","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array in place and returns the new combined list. Parameters: arr1 (list of int): First sorted array arr2 (list of int): Second sorted array Returns: list of int: The merged and sorted array m, n = len(arr1), len(arr2) i, j = m - 1, 0 # First loop to adjust elements as per rules to ignore extra space while i >= 0 and j < n: if arr1[i] > arr2[j]: arr1[i], arr2[j] = arr2[j], arr1[i] i -= 1 j += 1 # Sort both arrays again since we may have disrupted order arr1.sort() arr2.sort() # Combine both arrays return arr1 + arr2"},{"question":"You are given an array of integers `nums` which contains `n` numbers. Your task is to rearrange the elements of the array such that all the even-indexed elements are in non-decreasing order and all the odd-indexed elements are in non-increasing order. Return the rearranged array.","solution":"def rearrange_array(nums): Rearranges the elements of the array such that all the even-indexed elements are in non-decreasing order and all the odd-indexed elements are in non-increasing order. Args: nums: List[int] - a list of integers. Returns: List[int] - the rearranged list. even_idx_elements = sorted(nums[::2]) odd_idx_elements = sorted(nums[1::2], reverse=True) result = [] even_idx = 0 odd_idx = 0 for i in range(len(nums)): if i % 2 == 0: result.append(even_idx_elements[even_idx]) even_idx += 1 else: result.append(odd_idx_elements[odd_idx]) odd_idx += 1 return result"},{"question":"You are given a linked list where each node contains an integer value. The linked list can be represented as `L0 -> L1 -> L2 -> ... -> Ln-1 -> Ln`. You are required to **reorder** the list to `L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ...` such that it rearranges the nodes to get this interweaving pattern. You are not allowed to modify the values in the list\'s nodes but must rearrange the nodes themselves. Given the head of the linked list, return the reordered linked list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reorder_list(head): Reorders the linked list in the pattern L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ... :param head: ListNode, the head of the linked list :return: None, the linked list is rearranged in place if not head or not head.next: return head # Step 1: Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list prev, curr = None, slow while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node # Step 3: Merge the two halves first, second = head, prev while second.next: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first, second = temp1, temp2"},{"question":"A **balanced string** is a string that contains an equal number of `\'L\'` and `\'R\'` characters. Given a string `s` consisting of `\'L\'` and `\'R\'`, split the string into the maximum number of balanced substrings and return the number of such substrings. A substring is balanced if there is no non-empty proper prefix of the substring that has more `\'R\'` than `\'L\'` or more `\'L\'` than `\'R\'`.","solution":"def balanced_string_split(s): Returns the maximum number of balanced substrings from the input string s. balance = 0 balanced_count = 0 for char in s: if char == \'L\': balance += 1 else: balance -= 1 if balance == 0: balanced_count += 1 return balanced_count"},{"question":"A string `s` is given which is a sequence of `0`s and `1`s. You can change at most one digit from `0` to `1` or from `1` to `0`. Your task is to determine the length of the longest subsequence of `1`s you can achieve by performing this operation at most once. Subsequence means that the characters in the string must appear in the same order, but they do not have to be contiguous. Return _the maximum length of the subsequence of `1`s after performing the operation at most once_.","solution":"def max_subsequence_ones(s): Returns the length of the longest subsequence of \'1\'s after performing at most one operation on the string. # Count the number of ones in the original string original_ones_count = s.count(\'1\') max_ones = original_ones_count n = len(s) for i in range(n): # Create a temporary string with one character swapped if s[i] == \'0\': temp_ones_count = original_ones_count + 1 else: temp_ones_count = original_ones_count - 1 # Get the immediate preceding and following \'1\'s before the swap left_ones = s[:i].count(\'1\') right_ones = s[i + 1:].count(\'1\') # Calculate the count of \'1\'s in the modified string temp_ones_count = left_ones + right_ones + (1 if s[i] == \'0\' else 0) # Update the max count with the maximum found so far max_ones = max(max_ones, temp_ones_count) return max_ones"},{"question":"Write a function `duplicate_zeros` that takes a list of integers and duplicates each occurrence of zero in the list, shifting the remaining elements to the right. Note that the list\'s length should remain unchanged after the operation, so some elements may be lost at the end. Modify the input list in place and do not return anything.","solution":"def duplicate_zeros(arr): Duplicates each occurrence of zero in the list, shifting the remaining elements to the right. The list length remains unchanged. :param arr: List of integers to modify in place. n = len(arr) i = 0 while i < n: if arr[i] == 0: arr.insert(i + 1, 0) arr.pop() # To maintain the same length i += 1 # skip the next zero i += 1"},{"question":"You are given a list of non-negative integers `nums` and a target non-negative integer `sum`. Your task is to determine if there exists a subset of `nums` that sums up to exactly `sum`. Return `true` if such a subset exists, otherwise return `false`.","solution":"def subset_sum(nums, target): Determine if there exists a subset of nums that sums up to target. n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"You are given a list of `n` tasks, where each task `i` is represented as an interval `[starti, endi]` indicating the start and end times. You need to determine if a single person can complete all `n` tasks without overlapping. Return `true` if it is possible for the person to complete all tasks without any overlap, otherwise return `false`.","solution":"def can_complete_all_tasks(tasks): Returns true if a single person can complete all tasks without overlapping, false otherwise. # First, sort the tasks based on their start times tasks.sort(key=lambda x: x[0]) # Iterate through the sorted tasks to check for any overlap for i in range(1, len(tasks)): # If the current task\'s start time is less than the previous task\'s end time, there is an overlap if tasks[i][0] < tasks[i-1][1]: return False return True"},{"question":"Given an array of integers `arr`, return _the **length of the shortest continuous subarray** such that the sum of its elements is **at least** a given integer_ `k`. If no such subarray exists, return `-1`.","solution":"from collections import deque def shortest_subarray_with_sum_at_least_k(arr, k): n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] result = float(\'inf\') mono_queue = deque() for i in range(n + 1): while mono_queue and prefix_sums[i] - prefix_sums[mono_queue[0]] >= k: result = min(result, i - mono_queue.popleft()) while mono_queue and prefix_sums[i] <= prefix_sums[mono_queue[-1]]: mono_queue.pop() mono_queue.append(i) return result if result != float(\'inf\') else -1"},{"question":"You are given an m x n integer matrix `mat` and an integer k. A row in `mat` is considered special if it contains exactly k distinct numbers. You need to find and return the number of special rows in the matrix `mat`. Consider the example below for clarity: ``` mat = [ [1, 2, 2, 3], [3, 3, 3, 4], [1, 2, 3, 4] ] k = 3 ``` In this case, the matrix has 3 rows, and k is 3. The special rows are those which have exactly 3 distinct numbers. Here, only the first row `[1, 2, 2, 3]` has exactly 3 distinct numbers (1, 2, and 3), so the expected output is 1.","solution":"def count_special_rows(mat, k): Returns the count of special rows in the matrix `mat` that contain exactly `k` distinct numbers. Args: mat: List of List of integers, representing the matrix. k: Integer, the number of distinct numbers that a row must have to be special. Returns: Integer: The number of special rows. count = 0 for row in mat: if len(set(row)) == k: count += 1 return count"},{"question":"Given two strings `s1` and `s2`, return the _minimum number of operations required to convert `s1` into `s2`_. You can perform the following operations on `s1`: - **Insert** a character - **Remove** a character - **Replace** a character Each operation counts as a single step. Example Input: - s1 = \\"horse\\" - s2 = \\"ros\\" Example Output: - 3","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s1 is empty, all characters of s2 need to be inserted elif j == 0: dp[i][j] = i # If s2 is empty, all characters of s1 need to be removed elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # If last characters are the same, ignore and recur for the remaining strings else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of a series of buildings. Two buildings form a viewable pair if the second building is taller than the first and is located to its right. Return the number of viewable pairs in the array. A pair `(i, j)` is considered viewable if `i < j` and `heights[i] < heights[j]`.","solution":"def count_viewable_pairs(heights): Returns the number of viewable pairs in the array such that for a pair (i, j), heights[i] < heights[j] and i < j. :param heights: List[int] - heights of the buildings :return: int - number of viewable pairs n = len(heights) count = 0 for i in range(n): for j in range(i+1, n): if heights[i] < heights[j]: count += 1 return count"},{"question":"Given a matrix `grid` of dimensions `m x n` consisting of integers, find the minimum sum of any path from the top-left cell to the bottom-right cell. You can move either down or right at any point in time. Implement the function `minPathSum(int[][] grid)` that returns the minimum path sum.","solution":"def minPathSum(grid): Finds the minimum sum of any path from the top-left cell to the bottom-right cell in a given m x n matrix grid. :param grid: List[List[int]] - 2D list representing the grid. :return: int - minimum path sum. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first row sums for j in range(1, n): grid[0][j] += grid[0][j - 1] # Initialize the first column sums for i in range(1, m): grid[i][0] += grid[i - 1][0] # Compute the path sums for the remaining cells for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"Given two non-negative integers `num1` and `num2` represented as strings, return the sum of `num1` and `num2` as a string. You must solve the problem by performing the addition directly, without converting the inputs to integers.","solution":"def add_strings(num1, num2): Returns the sum of num1 and num2, which are non-negative integers represented as strings. # Ensure num1 is the longer string, swap if necessary. if len(num1) < len(num2): num1, num2 = num2, num1 # Reverse the strings to facilitate addition from the least significant digit. num1, num2 = num1[::-1], num2[::-1] carry, result = 0, [] # Iterate over digits, adding corresponding ones and the carry. for i in range(len(num1)): digit1 = int(num1[i]) digit2 = int(num2[i]) if i < len(num2) else 0 total = digit1 + digit2 + carry carry = total // 10 result.append(str(total % 10)) # If there\'s a carry left at the end, append it. if carry: result.append(str(carry)) # Reverse the result list to construct the final result string. return \'\'.join(result[::-1])"},{"question":"You are given an array of integers `arr` where every integer appears exactly three times, except for one integer which appears exactly once. Your task is to find the integer that appears only once. Implement a function `findUnique` that accepts an array of integers and returns the integer that appears exactly once. * `int findUnique(int[] arr)` Returns the integer that appears exactly once. Example: * Input: [2, 2, 3, 2] * Output: 3 * Input: [0, 1, 0, 1, 0, 1, 99] * Output: 99","solution":"def findUnique(arr): Returns the integer that appears exactly once in the array where every other integer appears exactly three times. ones, twos = 0, 0 for num in arr: twos |= ones & num ones ^= num common_mask = ~(ones & twos) ones &= common_mask twos &= common_mask return ones"},{"question":"You are given an array `tasks` where `tasks[i] = [start_i, end_i]` represents the starting and ending times of the `i`th task. Each task requires uninterrupted access to a specific resource. For each task, determine the minimum number of resources required to complete all the tasks without any overlap in time for the same resource. Return _the minimum number of resources needed_.","solution":"def min_resources(tasks): events = [] # Add start and end times to events list for start, end in tasks: events.append((start, \'start\')) events.append((end, \'end\')) # Sort the events list first by time, then by type (end before start if times are the same) events.sort(key=lambda x: (x[0], x[1] == \'start\')) max_resources = 0 current_resources = 0 # Traverse the sorted events list to calculate the minimum resources needed for _, event in events: if event == \'start\': current_resources += 1 max_resources = max(max_resources, current_resources) else: current_resources -= 1 return max_resources"},{"question":"You are given a `0-indexed` integer array `nums` containing `n` elements. Every integer in the array has a corresponding frequency that appears exactly once elsewhere in the array. In other words, for every element `x` in `nums`, there is another element `y` such that `nums[f_x] == y` and `nums[f_y] == x`, where `f_x` and `f_y` are their respective frequencies in the array. Your task is to find the unique pair of integers that both appear exactly once in the array. Return _an array containing these two unique integers in ascending order_.","solution":"def find_unique_elements(nums): Find the pair of unique elements that appear exactly once in the array. Params: nums (list): A list of integers where exactly two elements appear once and the remaining elements appear exactly twice. Returns: list: Sorted list with the two unique elements from collections import Counter # Count the frequency of each element in nums count = Counter(nums) # Find the elements that have a frequency of 1 unique_elements = [num for num, freq in count.items() if freq == 1] # Return the elements sorted return sorted(unique_elements)"},{"question":"You are given a binary string `s`, which consists only of \'0\'s and \'1\'s. A powerful operation involves selecting any substring of `s` and flipping all its bits (changing \'0\'s to \'1\'s and \'1\'s to \'0\'s). Your task is to find the minimum number of powerful operations needed to transform the binary string `s` into a string that contains no two consecutive \'1\'s. Return _the minimum number of powerful operations required_.","solution":"def min_operations_to_avoid_consecutive_ones(s): Returns the minimum number of powerful operations needed to transform the binary string s into a string that contains no two consecutive \'1\'s. n = len(s) cnt = 0 i = 0 while i < n: if s[i] == \'1\': j = i while j < n and s[j] == \'1\': j += 1 if j - i > 1: cnt += 1 i = j else: i += 1 return cnt"},{"question":"Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A contiguous subarray is a subarray that appears within the original array with sequences of elements in the same order. You may assume numbers in `nums` can range from negative to positive values. This problem can be solved using a dynamic programming approach, where you track the maximum subarray sum ending at each index and update the global maximum as you iterate through the array. Return the maximum sum of any contiguous subarray in `nums`.","solution":"def max_subarray_sum(nums): Find the contiguous subarray within an array, `nums`, which has the largest sum, and return its sum. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"Given an array of integers `nums` representing a list of numbers, and an integer `target`, return the **number of pairs** `[i, j]` where `i < j` and the `sum` of `nums[i] + nums[j]` is equal to the `target`. Each pair must be unique (use indices as part of uniqueness). For example, in the array `nums = [1, 2, 3, 4, 3]` and `target = 6`, the pairs are `(2, 4)` and `(1, 3)` resulting in an output of `2`.","solution":"def count_pairs_with_sum(nums, target): Returns the number of unique pairs (i, j) where i < j and nums[i] + nums[j] equals the target. count = 0 seen = set() for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target and (i, j) not in seen: count += 1 seen.add((i, j)) return count"},{"question":"Given an array of integers `arr`, find the length of the longest subarray that contains unique elements. Implement the method `int longestUniqueSubarray(int[] arr)` that returns the length of the longest subarray such that all its elements are unique.","solution":"def longestUniqueSubarray(arr): Returns the length of the longest subarray with unique elements. seen = {} left = 0 max_length = 0 for right in range(len(arr)): if arr[right] in seen: left = max(left, seen[arr[right]] + 1) seen[arr[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given two strings `s1` and `s2` of the same length. Your task is to determine if you can transform `s1` into `s2` by swapping any two characters exactly once. Return _True_ if it is possible to transform `s1` into `s2` by swapping any two characters exactly once, otherwise return _False_.","solution":"def can_transform_by_one_swap(s1, s2): Determines if s1 can be transformed into s2 by exactly one swap of any two characters. if len(s1) != len(s2): return False # Find all positions where the characters are different diff = [] for i in range(len(s1)): if s1[i] != s2[i]: diff.append(i) # If there are exactly 2 positions where characters are different, # check if swapping them will make s1 equal to s2. if len(diff) == 2: i, j = diff s1 = list(s1) s1[i], s1[j] = s1[j], s1[i] if s1 == list(s2): return True return False"},{"question":"Given a string `s` consisting of lowercase English letters and a dictionary of strings `wordDict`, return all the possible sentences you can form by concatenating the words from `wordDict` where each word from `wordDict` can be used any number of times and without reordering the characters in `s`. Each word in the dictionary can only be used with its exact form and alignment. --- Note: Ensure that the problem given provides a clear question statement that challenges the candidate to apply knowledge on string manipulation, recursion, dynamic programming, or graph algorithms, similar to the style and complexity observed in the given questions.","solution":"def word_break(s, wordDict): Given a string s and a dictionary of words wordDict, returns a list of all possible sentences that can be formed by concatenating words from the dictionary without reordering the characters in s. :param s: The input string. :param wordDict: The dictionary of words. :return: A list of sentences formed by concatenating words from the dictionary. memo = {} def dfs(s): if s in memo: return memo[s] if not s: return [\\"\\"] sentences = [] for word in wordDict: if s.startswith(word): sub_sentences = dfs(s[len(word):]) for sub_sentence in sub_sentences: if sub_sentence: sentences.append(word + \\" \\" + sub_sentence) else: sentences.append(word) memo[s] = sentences return sentences return dfs(s)"},{"question":"You are given two integer arrays `nums` and `limit`, where each `limit[i]` represents an upper constraint on `nums[i]` amount. Your task is to determine the number of valid subsets such that the sum of elements in each subset does not exceed the corresponding sum of elements in the `limit` array. A subset is valid if for each element `nums[j]` included in the subset, its sum does not surpass `limit[j]`. Return the number of valid subsets. Note: A subset can be empty as well.","solution":"def count_valid_subsets(nums, limit): from itertools import product count = 0 n = len(nums) for bits in product([0, 1], repeat=n): valid = True for i in range(n): if bits[i] == 1 and nums[i] > limit[i]: valid = False break if valid: count += 1 return count"},{"question":"Given an integer array `nums` and an integer `k`, return _the shorted contiguous subarray whose length is greater than or equal to `k` and the sum of the subarray\'s elements is the highest possible value_. If there are multiple results, return any of them. **Note:** * The input array `nums` can contain both positive and negative integers. * `1 <= k <= length of nums`.","solution":"def max_subarray_with_length_k(nums, k): Returns the shortest contiguous subarray with length >= k that has the maximum possible sum. n = len(nums) max_sum = float(\'-inf\') start_index = 0 end_index = k - 1 current_sum = sum(nums[:k]) if current_sum > max_sum: max_sum = current_sum max_start_index = 0 max_end_index = k - 1 for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum max_start_index = i - k + 1 max_end_index = i return nums[max_start_index:max_end_index + 1]"},{"question":"Consider a 2D grid of size `m x n` initialized with the value `0`. You are given several update operations in the form of a 2D array where each operation is represented by `[r, c]`. This indicates that you should increment by `1` the values in all rows and columns of the grid starting from the given row `r` and column `c` to the last row `m-1` and last column `n-1`. Return _the number of cells which have the maximum integer in the grid after performing all the given operations_.","solution":"def max_count(m, n, ops): Returns the number of cells which have the maximum integer in the grid after performing all the given operations. if not ops: return m * n min_row = m min_col = n for r, c in ops: min_row = min(min_row, r) min_col = min(min_col, c) return min_row * min_col"},{"question":"You are given a string `s` and an integer `numRows`. Write a function that arranges the characters of the string in a zigzag pattern across `numRows` and then returns the characters read line by line from top to bottom. For example, the string \\"PAYPALISHIRING\\" arranged in a zigzag pattern with `numRows = 3` would look like this: ``` P A H N A P L S I I G Y I R ``` Your function should return \\"PAHNAPLSIIGYIR\\" as the output in this case. Use the same logic for any string and number of rows.","solution":"def convert_zigzag(s: str, numRows: int) -> str: Converts the given string into a zigzag pattern on the given number of rows. Then reads the pattern row by row to form a new string. if numRows == 1 or numRows >= len(s): return s rows = [\'\'] * min(numRows, len(s)) curRow, goingDown = 0, False for char in s: rows[curRow] += char if curRow == 0 or curRow == numRows - 1: goingDown = not goingDown curRow += 1 if goingDown else -1 return \'\'.join(rows)"},{"question":"You are given a string representing a series of nested mathematical expressions. The expressions include integer additions, subtractions, and parentheses to denote the order of operations. Your task is to evaluate the string and return the final integer result. The string may contain extra spaces, which should be ignored. The syntax for the expressions is as follows: * An expression is either a single integer or a combination of integers and the operators `+` and `-`. * Parentheses `()` may be used to group sub-expressions, and they indicate that the sub-expression inside the parentheses should be evaluated first. For example: * `evaluate(\\"1 + 1\\")` should return `2`. * `evaluate(\\"2 - (1 + 2)\\")` should return `-1`. * `evaluate(\\"(3 + (2 - 1))\\")` should return `4`. Note that the input string will always be a valid expression. Please see the examples for more details on how the expression should be evaluated.","solution":"def evaluate(expression): Evaluates a string expression containing integers, + and - operators, and parentheses to denote order of operations. def helper(expr, start): stack = [] num = 0 sign = 1 i = start while i < len(expr): char = expr[i] if char.isdigit(): num = num * 10 + int(char) elif char in \'+-\': stack.append(sign * num) num = 0 sign = 1 if char == \'+\' else -1 elif char == \'(\': num, next_i = helper(expr, i + 1) i = next_i elif char == \')\': stack.append(sign * num) return sum(stack), i i += 1 stack.append(sign * num) return sum(stack), i expr = expression.replace(\' \', \'\') result, _ = helper(expr, 0) return result"},{"question":"You are given a binary tree in which each node contains an integer value. Write a function to determine whether the binary tree is symmetric. A binary tree is symmetric if a binary tree is a mirror reflection of itself. Note: A binary tree is a tree where each node has at most two children. You are required to implement the function using the following definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Implement the function `def isSymmetric(root: TreeNode) -> bool:` that returns a boolean indicating if the tree is symmetric. Your solution must be efficient and handle large trees. You may also assume that the tree nodes consist of unique values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: def is_mirror(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.right, right.left) and is_mirror(left.left, right.right) if not root: return True return is_mirror(root.left, root.right)"},{"question":"You are given an array of integers `arr` and an integer `k`. An array is called _k-sorted_ if every element is at most `k` positions away from its target position in the sorted array. Return the sorted array using an efficient algorithm.","solution":"import heapq def k_sorted_sort(arr, k): Sorts a k-sorted array. An array is k-sorted if every element is at most k positions away from its target position in the sorted array. :param arr: List of integers to be sorted :param k: Integer, max distance each element is away from its target position :return: Sorted list of integers # Initialize a min heap heap = [] # Build a min heap with the first k+1 elements for i in range(min(k+1, len(arr))): heapq.heappush(heap, arr[i]) result = [] index = 0 # For the rest elements in the array, pop elements from the heap and add new elements to it for i in range(k+1, len(arr)): arr[index] = heapq.heappop(heap) heapq.heappush(heap, arr[i]) index += 1 # Pop the remaining elements from the heap and place them into the array while heap: arr[index] = heapq.heappop(heap) index += 1 return arr"},{"question":"You are given a string `str` and a list of words `words`. Your task is to determine the minimum number of words from the list `words` required to form the string `str` by concatenating the words from `words` in any order. Each word from the list can be used multiple times if necessary. If it\'s not possible to form `str` using the words from `words`, return `-1`.","solution":"def min_words_to_form_string(s, words): Determines the minimum number of words from the list `words` required to form the string `str`. If it\'s not possible to form `str` using the words from `words`, returns `-1`. from functools import lru_cache word_set = set(words) @lru_cache(None) def dfs(remaining): if not remaining: return 0 min_words = float(\'inf\') for word in word_set: if remaining.startswith(word): next_count = dfs(remaining[len(word):]) if next_count != -1: min_words = min(min_words, next_count + 1) return min_words if min_words != float(\'inf\') else -1 return dfs(s)"},{"question":"You are implementing an online music streaming platform. The system keeps track of the number of streams for each song in a **0-indexed** integer array `streams`, where `streams[i]` represents the number of streams for the `i-th` song. You are tasked with designing a feature that provides the top `k` most streamed songs at any point in time. If there are ties in the number of streams, the songs with the smaller indices should be considered higher ranked. Implement the `MusicStreams` class: * `MusicStreams(int[] streams)` Initializes the object with the list of initial streams for each song. * `void addStreams(int songIndex, int numStreams)` Adds `numStreams` to the streams of the song at `songIndex`. * `List<Integer> topKSongs(int k)` Returns a list of the indices of the top `k` most streamed songs.","solution":"from heapq import nlargest class MusicStreams: def __init__(self, streams): Initializes the object with the list of initial streams for each song. :param streams: List[int] self.streams = streams def addStreams(self, songIndex, numStreams): Adds numStreams to the streams of the song at songIndex. :param songIndex: int :param numStreams: int self.streams[songIndex] += numStreams def topKSongs(self, k): Returns a list of the indices of the top k most streamed songs. :param k: int :return: List[int] pairs = [(self.streams[i], i) for i in range(len(self.streams))] top_k_pairs = nlargest(k, pairs, key=lambda x: (x[0], -x[1])) return [index for _, index in top_k_pairs]"},{"question":"Given an integer array `arr`, write a function that finds the maximum sum of any contiguous subarray (a subarray with at least one element). Implement the solution using an efficient algorithm with a time complexity of O(n).","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray within the array `arr`. if not arr: return 0 max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a **0-indexed** array `ratings` of integers, where `ratings[i]` represents the satisfaction rating of the `ith` customer. You are also given an integer `X`. You need to distribute `X` distinct bonuses across the customers such that: * Each customer should receive at most one bonus. * The sum of the ratings of customers who receive the bonuses is maximized. Return _the positions of the customers who receive the bonuses_. If there are multiple solutions that achieve the same maximum sum, return _the list of positions sorted in **increasing** order_.","solution":"def distribute_bonuses(ratings, X): Distribute X distinct bonuses to maximize the sum of ratings of customers who receive the bonuses, ensuring no customer receives more than one bonus. Parameters: ratings (list): A list of ratings of customers X (int): Number of distinct bonuses to distribute Returns: list: Positions of customers who receive the bonuses if X == 0 or not ratings: return [] # Pair each rating with its index indexed_ratings = list(enumerate(ratings)) # Sort based on ratings in descending order indexed_ratings.sort(key=lambda x: x[1], reverse=True) # Get the indices of the top X ratings top_indices = [i for i, _ in indexed_ratings[:X]] # Sort the indices in increasing order before returning return sorted(top_indices)"},{"question":"Write a function that takes as input a list of integers and returns a list of integers such that the value at each index in the output list is equal to the product of all the numbers in the input list except the number at that index. You should solve it without using division and in O(n) time complexity.","solution":"def product_except_self(nums): Returns a list of integers such that the value at each index is equal to the product of all the numbers in the list except the number at that index. length = len(nums) # Initialize two lists to keep track of left and right products left_products = [1] * length right_products = [1] * length output = [1] * length # Fill left_products such that left_products[i] contains the product of all elements to the left of i for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products such that right_products[i] contains the product of all elements to the right of i for i in reversed(range(length - 1)): right_products[i] = right_products[i + 1] * nums[i + 1] # Construct the output such that output[i] is the product of left_products[i] and right_products[i] for i in range(length): output[i] = left_products[i] * right_products[i] return output"},{"question":"Implement a function that receives an integer `n` and returns the number of structurally unique Binary Search Trees (BSTs) that can be built with exactly `n` nodes labeled from 1 to `n`.","solution":"def num_trees(n): Returns the number of structurally unique Binary Search Trees (BSTs) that can be built with exactly n nodes. if n == 0 or n == 1: return 1 # Initialize the table dp with zeros dp = [0] * (n + 1) # Base cases dp[0] = 1 dp[1] = 1 # Fill the table dp using the recurrences for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"Given the `root` of a binary search tree (BST) and a node `p` in it, find the in-order successor of that node in the BST. If the given node has no in-order successor, return `null`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderSuccessor(root, p): Find the in-order successor of node `p` in BST rooted with `root`. successor = None while root: if p.val < root.val: successor = root root = root.left else: root = root.right return successor"},{"question":"**[Question 4]:** You are given a string `s` and an array of pairs representing swaps that can be performed on the characters of the string. The array of pairs is given as `pairs[i] = [a, b]` where `a` and `b` are indices (0-based) of characters in the string `s` that can be swapped. You can perform any number of swaps on the characters in the string `s`. The goal is to return the lexicographically smallest string that can be formed by performing any number of swaps. Implement a function to return the lexicographically smallest string possible after performing the swaps.","solution":"def smallestStringWithSwaps(s, pairs): from collections import defaultdict def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY # Step 1: Initialize union-find structure n = len(s) parent = list(range(n)) # Step 2: Apply union on all pairs for a, b in pairs: union(a, b) # Step 3: Group all connected indices connected_components = defaultdict(list) for i in range(n): root = find(i) connected_components[root].append(i) # Step 4: Sort characters within each connected component result = list(s) for indices in connected_components.values(): sorted_chars = sorted(result[i] for i in indices) for i, char in zip(sorted(indices), sorted_chars): result[i] = char return \'\'.join(result)"},{"question":"A binary string is called **beautiful** if it doesn\'t contain the substring `\\"010\\"`. Given a binary string `s`, find the minimal number of bit changes required to make the string beautiful. Return the required number of bit changes.","solution":"def min_changes_to_beautiful(s): Returns the minimal number of bit changes required to make the binary string s beautiful. count = 0 i = 0 while i < len(s) - 2: if s[i:i+3] == \\"010\\": count += 1 i += 3 # Skip past this \\"010\\" to avoid overlapping changes else: i += 1 return count"},{"question":"You are given a 0-indexed integer array `nums`. The array contains both negative and positive integers. Your task is to find the length of the longest subarray with a sum equal to zero. Return _the length of the longest such subarray_. If there is no such subarray, return `0`.","solution":"def longest_zero_sum_subarray(nums): prefix_sum_to_index = {} prefix_sum = 0 max_length = 0 for index, num in enumerate(nums): prefix_sum += num if prefix_sum == 0: max_length = index + 1 if prefix_sum in prefix_sum_to_index: subarray_length = index - prefix_sum_to_index[prefix_sum] if subarray_length > max_length: max_length = subarray_length else: prefix_sum_to_index[prefix_sum] = index return max_length"},{"question":"You are given a `2D` matrix `matrix` of `n` x `m` integers. Your task is to find out if there exists a path from the top-left corner of the matrix to the bottom-right corner, with the following conditions: 1. You can only move either down or right at any point in time. 2. The path can only pass through cells containing `1`. Return `true` if such a path exists, otherwise return `false`.","solution":"def is_path_exist(matrix): Determines if there exists a path from the top-left corner to the bottom-right corner in a 2D matrix where you can only move down or right and can only pass through cells containing 1. Args: matrix (list of list of int): The 2D matrix containing 1s and 0s. Returns: bool: True if such a path exists, False otherwise. if not matrix or matrix[0][0] != 1 or matrix[-1][-1] != 1: return False n, m = len(matrix), len(matrix[0]) directions = [(1, 0), (0, 1)] def dfs(x, y, visited): if x == n - 1 and y == m - 1: return True if not (0 <= x < n and 0 <= y < m) or (x, y) in visited or matrix[x][y] != 1: return False visited.add((x, y)) for dx, dy in directions: if dfs(x + dx, y + dy, visited): return True return False return dfs(0, 0, set())"},{"question":"You are given a class `DataStream` that manages a stream of integers. The class supports the following operations: - `DataStream(int[] nums)`: Initializes the data stream with an array of integers. - `void add(int num)`: Adds the integer `num` to the end of the stream. - `int getLast(int k)`: Returns the `k-th` last element from the stream. If `k` is greater than the total number of elements in the stream, return `-1`. Implement the `DataStream` class.","solution":"class DataStream: def __init__(self, nums): Initializes the data stream with an array of integers. :param nums: List of initial integers in the data stream. self.stream = nums def add(self, num): Adds the integer `num` to the end of the stream. :param num: Integer to add to the data stream. self.stream.append(num) def getLast(self, k): Returns the k-th last element from the stream. If k is greater than the total number of elements in the stream, return -1. :param k: The position from the end to retrieve the element. :return: The k-th last element or -1 if k is out of bounds. if k > len(self.stream): return -1 return self.stream[-k]"},{"question":"Implement a function that takes an integer array `nums` and an integer `k`, and returns _the `k` most frequent elements_. Your function should return the elements in **any order**.","solution":"from collections import Counter def top_k_frequent(nums, k): Returns the k most frequent elements in nums list. :param nums: List[int] :param k: int :return: List[int] count = Counter(nums) return [item for item, freq in count.most_common(k)]"},{"question":"You are given a binary tree in the form of an integer array `tree`, where each element represents a node\'s value in a level-order traversal format (i.e., the root is at index 0, its children are at index 1 and 2, their children at index 3, 4, 5, 6, and so on). Given an integer `target`, return the path from the root to the node with the value equal to `target`. If the target value is not present in the tree, return an empty list. The path should be represented as a list of node values. Note: In the given binary tree array representation, if a node is absent, its value is `null`.","solution":"def find_path(tree, target): def get_child_index(parent_index, left_child): return 2 * parent_index + (1 if left_child else 2) def dfs(index, path): if index >= len(tree) or tree[index] is None: return False path.append(tree[index]) if tree[index] == target: return True left_child_idx = get_child_index(index, True) right_child_idx = get_child_index(index, False) if dfs(left_child_idx, path) or dfs(right_child_idx, path): return True path.pop() return False if not tree: return [] path = [] dfs(0, path) return path if tree[0] == target or path else []"},{"question":"You are given a 0-indexed integer array `coins` of length `n` where each element represents the number of coins in a specific pile. You are also given an integer `m` representing the **required minimum number of coins** that you need to collect. You can take coins from any pile but must take them consecutively from the start of the array, i.e., you can collect coins from the sequence of piles starting from index `0` up to some index `i` that satisfies the required `m` coins. Return _the **minimum** number of piles required to collect at least `m` coins_. If it is not possible to collect `m` coins, return `-1`.","solution":"def min_piles(coins, m): Returns the minimum number of piles required to collect at least m coins. If it is not possible to collect m coins, returns -1. current_sum = 0 for i, coin in enumerate(coins): current_sum += coin if current_sum >= m: return i + 1 return -1"},{"question":"You are given an integer array `arr` consisting of both positive and negative integers. Your task is to find a contiguous subarray with the largest sum and return that sum. This subarray must contain at least one element. [Question 4]:","solution":"def max_subarray_sum(arr): Returns the sum of the contiguous subarray with the largest sum. Parameters: arr (list of int): The input array containing both positive and negative integers. Returns: int: The sum of the contiguous subarray with the largest sum. if not arr: return 0 # Edge case: If the array is empty, return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array `heights` representing the heights of students standing in a row from left to right, determine the minimum number of students that must move to ensure all students are standing in non-decreasing order of their heights. Return _the minimum number of moves required_. A move involves taking a student from their position and placing them at the end of the array, thereby maintaining the relative order of the remaining students. For example, given `heights = [1,3,2,6,5]`, rearranging the array to `[1,2,3,5,6]` requires two moves.","solution":"def minimum_moves_to_sort(heights): Returns the minimum number of moves needed to make the array non-decreasing. n = len(heights) lis_length = [1] * n # Find the longest increasing subsequence (LIS) for i in range(n): for j in range(i): if heights[i] >= heights[j]: lis_length[i] = max(lis_length[i], lis_length[j] + 1) longest_increasing_subsequence = max(lis_length) moves = n - longest_increasing_subsequence return moves"},{"question":"You are given a matrix `grid` representing a grid of cells where each cell can either contain a wall (\'#\') or be an empty space (\'.\'). A robot can move in four possible directions: left, right, up, and down. However, the robot can only move to a cell that is an empty space (\'.\'). The robot starts at the top-left corner of the grid and aims to reach the bottom-right corner. Determine if it is possible for the robot to reach the bottom-right corner from the top-left corner. If it is possible, return the minimum number of moves required; otherwise, return -1.","solution":"from collections import deque def min_moves_to_reach_end(grid): Determines if it\'s possible to reach the bottom-right corner from the top-left corner and returns the minimum number of moves required. If it\'s not possible, returns -1. if not grid or not grid[0] or grid[0][0] == \'#\' or grid[-1][-1] == \'#\': return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == rows - 1 and col == cols - 1: return dist # explore all possible directions for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == \'.\': queue.append((new_row, new_col, dist + 1)) visited.add((new_row, new_col)) return -1"},{"question":"Given an array of integers `nums` and a positive integer `k`, write a function to calculate the number of contiguous subarrays that sum to `k`. The function should return an integer that represents the count of such subarrays. Ensure that your solution handles both positive and negative integers in `nums`.","solution":"def subarray_sum(nums, k): Returns the number of contiguous subarrays that sum to k. count = 0 current_sum = 0 sum_map = {0: 1} for num in nums: current_sum += num if (current_sum - k) in sum_map: count += sum_map[current_sum - k] if current_sum in sum_map: sum_map[current_sum] += 1 else: sum_map[current_sum] = 1 return count"},{"question":"You are given a list of positive integers `nums` and a target integer `k`. You are allowed to remove exactly one element from the list. Determine if there exists a subarray (contiguous elements) of `nums` such that its sum is exactly `k` after the removal of one element. Return `true` if such a subarray exists, otherwise, return `false`.","solution":"def subarray_sum_with_one_removal(nums, k): Determines if there exists a subarray with sum k after removing exactly one element. n = len(nums) # Helper function to find if there exists a subarray with the exact sum using given array def has_subarray_with_sum(array, target): curr_sum = 0 lookup = set([0]) for num in array: curr_sum += num if (curr_sum - target) in lookup: return True lookup.add(curr_sum) return False for i in range(n): # Remove element at index i modified_nums = nums[:i] + nums[i+1:] if has_subarray_with_sum(modified_nums, k): return True return False"},{"question":"You are given a matrix `grid` with dimensions `m x n` consisting of non-negative integers. A move consists of taking the maximum value in any row or column and reducing all elements in that row or column by 1. Return the minimum number of moves required to make at least one element in the grid equal to 0.","solution":"def min_moves_to_zero(grid): Returns the minimum number of moves required to make at least one element in the grid equal to 0. max_element = max(max(row) for row in grid) return max_element"},{"question":"You are given a string `str` consisting of lowercase alphabets and an integer `k`. You need to perform exactly `k` operations on the string. In one operation, you can move any character of the string to the end of the string. Your task is to determine the lexicographically smallest string that can be obtained by performing exactly `k` operations. Return _the lexicographically smallest string possible after exactly `k` operations_. **Note that:** * The given string `str` may contain duplicate characters. * You must perform exactly `k` operations.","solution":"def smallest_string_after_operations(s, k): Returns the lexicographically smallest string after exactly k operations where in each operation, any character of the string can be moved to the end. if k == 0: return s # If k > 1, we can sort the string to get the smallest possible permutation if k > 1: return \'\'.join(sorted(s)) # If k == 1, we need to consider all rotations of the string smallest = s for i in range(len(s)): rotated = s[i:] + s[:i] if rotated < smallest: smallest = rotated return smallest"},{"question":"You are given two strings `s` and `t` of the same length, consisting of lowercase letters. You can choose any two letters in the string `s` and swap them. Return the minimum number of swaps required such that the string `s` is equal to the string `t`. If it is impossible to make the two strings equal with any number of swaps, return `-1`.","solution":"def min_swaps_to_equal(s, t): Returns the minimum number of swaps required such that the string `s` is equal to the string `t`. If it is impossible, returns -1. if sorted(s) != sorted(t): return -1 swaps = 0 s = list(s) t = list(t) n = len(s) for i in range(n): if s[i] != t[i]: for j in range(i + 1, n): if s[j] == t[i]: s[i], s[j] = s[j], s[i] swaps += 1 break return swaps"},{"question":"Given the `head` of a singly linked list, determine if there exists a cycle in the linked list. A cycle occurs when a node\'s `next` pointer points back to a previous node, forming a loop. Implement the `hasCycle` function that takes the `head` of the linked list as an argument and returns `true` if there is a cycle in the list and `false` otherwise. Use Floyd’s Tortoise and Hare algorithm to detect the cycle in **O(n)** time and **O(1)** space complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Determines if there is a cycle in a linked list using Floyd\'s Tortoise and Hare algorithm. :param head: ListNode, the head of the singly linked list :return: bool, True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"You are given a 0-indexed integer array `nums`. You need to find the **length of the longest contiguous subarray** where all the elements have the **same value**. Return the length of the subarray. For example, given `nums = [1,3,3,3,2,2,4]`, the longest contiguous subarray with the same value is `[3,3,3]` with a length of 3.","solution":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray where all elements have the same value. if not nums: return 0 max_len = 1 current_len = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"Given a non-empty **0-indexed** array of integers `arr`, partition the array into exactly two subarrays such that the sum of the first subarray is **less** than or **equal** to the sum of the second subarray. Return _true if you can achieve this partition and false otherwise_. Both subarrays must be non-empty.","solution":"def can_partition(arr): Function to determine if the array can be partitioned into two non-empty subarrays such that the sum of the first subarray is less than or equal to the sum of the second subarray. total = sum(arr) left_sum = 0 for i in range(len(arr) - 1): left_sum += arr[i] right_sum = total - left_sum if left_sum <= right_sum: return True return False"},{"question":"You are given a list of non-negative integers representing the amounts of money of each house along a street. Rob a maximum amount without robbing two adjacent houses. Write an algorithm to determine the maximum amount of money you can rob tonight without alerting the police.","solution":"def rob(nums): Function to determine the maximum amount of money that can be robbed without robbing two adjacent houses. :param nums: List of non-negative integers representing the amounts of money at each house. :return: Maximum amount of money that can be robbed. if not nums: return 0 if len(nums) <= 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], nums[i] + dp[i-2]) return dp[-1]"},{"question":"Given an integer array `nums` of size `n`, return the **number of pairs `(i, j)`** where `0 <= i < j < n` and `nums[i] == nums[j]`. The pair `(i, j)` should satisfy the condition that the values at indices `i` and `j` are equal.","solution":"def count_equal_pairs(nums): Returns the number of pairs (i, j) where 0 <= i < j < n and nums[i] == nums[j]. Args: nums (List[int]): The input list of integers. Returns: int: The number of equal value pairs. count = 0 num_counts = {} for num in nums: if num in num_counts: count += num_counts[num] num_counts[num] += 1 else: num_counts[num] = 1 return count"},{"question":"You are given a 2D integer array `matrix` representing a grid of `m x n` cells, where each cell has an initial value of 0. You are also given an array `updates`, where each element of `updates` is a tuple `(row1, col1, row2, col2)` representing a submatrix within the grid. For each tuple `(row1, col1, row2, col2)`, increment the value of every cell in the submatrix from `(row1, col1)` to `(row2, col2)` (inclusive). Return the updated grid after applying all updates. For example, if `matrix` is `3 x 3` and `updates` is `[(0, 0, 1, 1), (1, 1, 2, 2)]`, the updated grid should be: ``` [1, 1, 0] [1, 2, 1] [0, 1, 1] ``` Return the final state of the grid after all updates.","solution":"def update_matrix(matrix, updates): Updates the values of a 2D matrix based on the given list of submatrix updates. Parameters: matrix (list of lists of int): The 2D matrix to be updated. updates (list of tuples of int): List of submatrix updates defined by (row1, col1, row2, col2). Returns: list of lists of int: The updated 2D matrix. for update in updates: row1, col1, row2, col2 = update for row in range(row1, row2 + 1): for col in range(col1, col2 + 1): matrix[row][col] += 1 return matrix"},{"question":"Given a sorted array of `n` integers where each integer is unique, you need to find a specific integer `k` such that the number of elements less than `k` is equal to the number of elements greater than `k`. If there are multiple such integers, return the smallest one. If no such integer exists, return -1.","solution":"def find_element_with_equal_sides(arr, n): Given a sorted array of n unique integers, find the integer such that the number of elements less than it is equal to the number of elements greater than it. If multiple such integers exist, return the smallest one. If no such integer exists, return -1. # If the array is empty or has less than 3 elements, return -1 if not arr or n < 3: return -1 # For the element to have equal elements on both sides, it must be at the middle mid = n // 2 # Check if it is perfectly in the middle if (n - mid - 1) == mid: return arr[mid] else: return -1"},{"question":"Given an array of integers `nums` and an integer `k`, modify the array in such a way that each element appears **at most** `k` times while maintaining the first occurrence of each unique element. Return the modified array\'s new length. Implement the `KDistinctElements` class: * `KDistinctElements(int[] nums, int k)` Initializes the object with the integer array `nums` and the integer `k`. * `int[] processArray()` Processes the array according to the given condition, returning the modified array.","solution":"class KDistinctElements: def __init__(self, nums, k): Initializes the object with the integer array nums and the integer k. self.nums = nums self.k = k def processArray(self): Processes the array such that each element appears at most k times. Returns: list: The modified array. if self.k < 1: return [] element_count = {} result = [] for num in self.nums: if num not in element_count: element_count[num] = 0 if element_count[num] < self.k: result.append(num) element_count[num] += 1 return result"},{"question":"You are given an unsorted integer array `nums` where every element appears exactly twice, except for one element which appears exactly once. Write a function that finds and returns the single element that appears only once. Your solution should have a linear runtime complexity and use only constant extra space.","solution":"def single_number(nums): Returns the single element in the array that appears only once. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"You are given an **n-ary tree** represented as a list of `Node` objects, where each `Node` has a unique integer `val` and a list of `children` nodes. An `n-ary tree` is a tree in which each node can have at most `n` children. You need to write a function that returns the level order traversal of its nodes\' values, where each level is represented as a separate list. Level order traversal is a breadth-first search where we visit all the nodes at one level before moving on to the next level. Return _a list of lists of integers representing the node values at each level in the n-ary tree_.","solution":"from collections import deque class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def level_order(root): Returns the level order traversal of an n-ary tree. :param root: Root node of the n-ary tree :return: List of lists of integers representing the node values at each level if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) for child in node.children: queue.append(child) result.append(level_nodes) return result"},{"question":"You are given a list of networks where each network is represented by an integer from `1` to `n`. Each network can communicate with another network through a list of direct connections `connections`, where `connections[i] = [a, b]` indicates that network `a` can directly communicate with network `b` and vice-versa. A network is considered isolated if it cannot communicate with any other network, either directly or indirectly through a chain of direct connections. Determine the number of isolated networks after all connections have been established.","solution":"def find_isolated_networks(n, connections): Determines the number of isolated networks. Parameters: n (int): The number of networks. connections (List[List[int]]): The list of direct connections. Returns: int: The number of isolated networks. def dfs(network, visited, adjacency_list): if visited[network]: return visited[network] = True for neighbor in adjacency_list[network]: dfs(neighbor, visited, adjacency_list) # Initialize adjacency list for each network adjacency_list = [[] for _ in range(n+1)] for a, b in connections: adjacency_list[a].append(b) adjacency_list[b].append(a) visited = [False] * (n+1) isolated_networks = 0 for i in range(1, n+1): if not visited[i] and len(adjacency_list[i]) == 0: isolated_networks += 1 elif not visited[i]: dfs(i, visited, adjacency_list) return isolated_networks"},{"question":"You are given a **0-indexed** integer array `nums` of size `n`. A subarray is called **good** if the sum of the elements in the subarray is equal to a given integer `target`. Return the length of the longest **good** subarray from `nums`. If no such subarray exists, return -1.","solution":"def longest_good_subarray(nums, target): Returns the length of the longest subarray with sum equal to target. If no such subarray exists, return -1. max_length = -1 current_sum = 0 sum_indices = {0: -1} # Dictionary to store the first occurrence of sum for i, num in enumerate(nums): current_sum += num if (current_sum - target) in sum_indices: max_length = max(max_length, i - sum_indices[current_sum - target]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_length"},{"question":"You are given a grid of size `m x n` consisting of non-negative integers representing the height of each unit cell in a 2D elevation map. Suppose rain water is trapped in the grid. Water can only flow from a cell to another cell directly north, south, east, or west if the adjacent cell\'s height is less than or equal to the current cell\'s height. You need to find the total volume of water trapped after raining. Return _the **total volume** of water trapped_ in the grid.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] for i in range(m): heapq.heappush(heap, (heightMap[i][0], i, 0)) visited[i][0] = True heapq.heappush(heap, (heightMap[i][n - 1], i, n - 1)) visited[i][n - 1] = True for j in range(1, n - 1): heapq.heappush(heap, (heightMap[0][j], 0, j)) visited[0][j] = True heapq.heappush(heap, (heightMap[m - 1][j], m - 1, j)) visited[m - 1][j] = True volume = 0 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True volume += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return volume"},{"question":"You are given a list of integers `nums` representing a binary tree in level order traversal. Some nodes are empty (null) and are represented by `-1`. You need to construct the binary tree and then return the level order traversal of the tree but with the levels reflected around the center. For example, if the binary tree level order traversal is given by `nums = [1, 2, 3, -1, 5, -1, -1]`, the constructed binary tree should be: ``` 1 / 2 3 5 ``` The level order traversal would be: ``` [ [1], [3, 2], [5] ] ``` Your task is to write a function that takes `nums` as input and returns the level order traversal of the constructed binary tree after reflecting each level around the center.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(nums): if not nums: return None from collections import deque root = TreeNode(nums[0]) queue = deque([root]) i = 1 while queue and i < len(nums): node = queue.popleft() if nums[i] != -1: node.left = TreeNode(nums[i]) queue.append(node.left) i += 1 if i < len(nums) and nums[i] != -1: node.right = TreeNode(nums[i]) queue.append(node.right) i += 1 return root def reflect_levels(levels): return [level[::-1] for level in levels] def level_order_traversal(root): if not root: return [] from collections import deque result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result def reflected_level_order(nums): root = construct_tree(nums) levels = level_order_traversal(root) return reflect_levels(levels)"},{"question":"Given a binary tree, write a function to find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. A leaf is a node with no children. The binary tree is represented as follows using a list where the elements are filled in level order traversal of the tree (i.e., from left to right at each level). If a node does not have a left or right child, its place in the list is filled with `None`. For example, a binary tree with the following structure: ``` 3 / 9 20 / 15 7 ``` would be represented as: `[3, 9, 20, None, None, 15, 7]`. Write a function that takes this list representation of a binary tree and returns the maximum depth of the tree.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def build_tree_from_list(values: List[Optional[int]]) -> Optional[TreeNode]: if not values: return None nodes = [None if v is None else TreeNode(v) for v in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root def max_depth(root: TreeNode) -> int: if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1 def find_max_depth(tree_list: List[Optional[int]]) -> int: root = build_tree_from_list(tree_list) return max_depth(root)"},{"question":"You are given a list of integers `arr`. Write a function that finds the longest contiguous subarray where the absolute difference between any two elements is less than or equal to a given integer `limit`. Return _the length of the longest such subarray_.","solution":"from collections import deque def longest_subarray(arr, limit): Finds the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to limit. Parameters: - arr: List[int] - limit: int Returns: - int: The length of the longest such subarray. min_deque, max_deque = deque(), deque() left = 0 max_len = 0 for right in range(len(arr)): while min_deque and arr[right] < arr[min_deque[-1]]: min_deque.pop() while max_deque and arr[right] > arr[max_deque[-1]]: max_deque.pop() min_deque.append(right) max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > limit: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given an array of strings `transactions` where each string represents a banking transaction in the format `\\"{sender}:{recipient}:{amount}\\"`. Each transaction is between two unique individuals and involves the transfer of a certain amount of money from the sender to the recipient. Write a function that calculates the final balance for each individual after all the transactions are completed. The balance for each individual should start at 0. If a transaction is made by a sender to a recipient, the sender\'s balance should decrease by the amount of the transaction and the recipient\'s balance should increase by the same amount. Return a dictionary where the keys are the individuals\' names and the values are their final balances. For example, if `transactions = [\\"Alice:Bob:20\\", \\"Bob:Charlie:15\\", \\"Alice:Charlie:5\\"]`, the function should return `{\\"Alice\\": -25, \\"Bob\\": 5, \\"Charlie\\": 20}`.","solution":"def calculate_balances(transactions): Calculate the final balance for each individual after all transactions. Args: transactions (list of str): List of transactions in the format \\"{sender}:{recipient}:{amount}\\". Returns: dict: Dictionary where keys are individuals\' names and values are their final balances. balances = {} for transaction in transactions: sender, recipient, amount_str = transaction.split(\':\') amount = int(amount_str) if sender not in balances: balances[sender] = 0 if recipient not in balances: balances[recipient] = 0 balances[sender] -= amount balances[recipient] += amount return balances"},{"question":"Implement a function that takes in two sorted arrays `nums1` and `nums2` and returns a new array containing the intersection of the two arrays. Each element in the result should appear as many times as it shows in both arrays, and the result can be in any order.","solution":"def intersect(nums1, nums2): Returns the intersection of two sorted arrays nums1 and nums2. Each element in the result appears as many times as it shows in both arrays. from collections import Counter count1 = Counter(nums1) count2 = Counter(nums2) intersection = [] for num in count1: if num in count2: intersection.extend([num] * min(count1[num], count2[num])) return intersection"},{"question":"You are given a string `s` representing an encoded message. To decode the message, you can convert digits to letters based on their positions in the alphabet: `\'1\'` is `\'A\'`, `\'2\'` is `\'B\'`, ..., `\'26\'` is `\'Z\'`. However, due to corruption, some characters in the string have become `\'*\'`, which can represent any digit from `\'1\'` to `\'9\'`. The decoding must take this into account as well. Return the number of ways to decode the message. Since the answer could be very large, return it modulo `10^9 + 7`.","solution":"def numDecodings(s): MOD = 10**9 + 7 n = len(s) if n == 0: return 0 dp = [0] * (n + 1) dp[0] = 1 # Handling the first character if s[0] == \'0\': return 0 elif s[0] == \'*\': dp[1] = 9 else: dp[1] = 1 for i in range(1, n): if s[i] == \'*\': dp[i + 1] = 9 * dp[i] % MOD elif s[i] != \'0\': dp[i + 1] = dp[i] if s[i-1] == \'1\': if s[i] == \'*\': dp[i + 1] = (dp[i + 1] + 9 * dp[i-1]) % MOD else: dp[i + 1] = (dp[i + 1] + dp[i-1]) % MOD elif s[i-1] == \'2\': if s[i] == \'*\': dp[i + 1] = (dp[i + 1] + 6 * dp[i-1]) % MOD elif s[i] <= \'6\': dp[i + 1] = (dp[i + 1] + dp[i-1]) % MOD elif s[i-1] == \'*\': if s[i] == \'*\': dp[i + 1] = (dp[i + 1] + 15 * dp[i-1]) % MOD elif s[i] <= \'6\': dp[i + 1] = (dp[i + 1] + 2 * dp[i-1]) % MOD else: dp[i + 1] = (dp[i + 1] + dp[i-1]) % MOD return dp[n]"},{"question":"Given a binary tree, imagine you are standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom. The binary tree is represented as `TreeNode` objects, and you need to implement a function that receives the root of the binary tree and returns a list of integers representing the right side view of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes you can see from the right side of the binary tree. :param root: TreeNode, the root of the binary tree :return: List[int], values of the nodes as seen from the right side view if not root: return [] from collections import deque queue = deque([root]) right_view = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # If it\'s the last node in the current level, add it to right_view if i == level_length - 1: right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"You are given an integer array `expenses` representing your monthly expenses for a year, where `expenses[i]` is the expense for the `i-th` month. Find the maximum number of consecutive months within one year where the sum of expenses is less than or equal to a given budget `B`. Return this maximum number of consecutive months.","solution":"def max_consecutive_months_within_budget(expenses, B): n = len(expenses) max_months = 0 current_sum = 0 left = 0 for right in range(n): current_sum += expenses[right] while current_sum > B and left <= right: current_sum -= expenses[left] left += 1 max_months = max(max_months, right - left + 1) return max_months"},{"question":"You are given a list of `n` integers, `heights`, where each integer represents the height of a tree. You are also given an integer `cut_height`. You need to cut down all trees that are taller than `cut_height` so that their new height becomes `cut_height`. After performing the operation on all applicable trees, calculate the total amount of wood that has been collected. Return _an integer that represents the total amount of wood collected_.","solution":"def total_wood_collected(heights, cut_height): Returns the total amount of wood collected after cutting down all trees taller than cut_height to the cut_height. Parameters: heights (list of int): List of integers representing the heights of trees. cut_height (int): The height to which trees taller than this should be cut. Returns: int: Total amount of wood collected. total_wood = 0 for height in heights: if height > cut_height: total_wood += height - cut_height return total_wood"},{"question":"Given an n-ary tree, return the preorder traversal of its nodes\' values. An n-ary tree is a tree in which a node can have at most n children. Implement the `preorder` function: * `List<Integer> preorder(Node root)` returns the list of node values in preorder traversal. For example, given an n-ary tree: ``` 1 / | 3 2 4 / 5 6 ``` Return ` [1, 3, 5, 6, 2, 4]`.","solution":"# Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def preorder(root): Given the root of an n-ary tree, return the preorder traversal of its nodes\' values. if not root: return [] result = [] stack = [root] while stack: current = stack.pop() result.append(current.val) stack.extend(reversed(current.children)) return result"},{"question":"You are given a 2D integer matrix `grid` where each cell contains a value representing the height of the terrain at that position. The task is to find a path from the top-left corner (i.e., `grid[0][0]`) to the bottom-right corner (i.e., `grid[m - 1][n - 1]`) such that the difference in height between two consecutive cells along the path is minimized. The robot can only move either down or right at any point in time. Return the minimum possible value of the maximum height difference between two consecutive cells in the path.","solution":"import heapq def minimum_effort_path(grid): Returns the minimum possible value of the maximum height difference between two consecutive cells in the path from top-left to bottom-right. m, n = len(grid), len(grid[0]) # Directions for right and down movements directions = [(0, 1), (1, 0)] # Min Heap to store (effort, x, y) heap = [(0, 0, 0)] # Start at top-left corner with 0 effort efforts = [[float(\'inf\')] * n for _ in range(m)] efforts[0][0] = 0 while heap: current_effort, x, y = heapq.heappop(heap) if x == m - 1 and y == n - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_effort = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heapq.heappush(heap, (new_effort, nx, ny)) return -1"},{"question":"You are given two non-empty binary trees `root1` and `root2`. Write a function to determine if `root2` is a **subtree** of `root1`. A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node\'s descendants. The tree `root1` could be an empty tree, in which case it cannot have any subtrees. Return _True_ if `root2` is a subtree of `root1`, otherwise return _False_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(root1, root2): if not root2: return True if not root1: return False if is_same_tree(root1, root2): return True return is_subtree(root1.left, root2) or is_subtree(root1.right, root2) def is_same_tree(s, t): if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right)"},{"question":"Given a matrix `mat` of integers, where each row is sorted in ascending order and each column is sorted in ascending order, find the k-th smallest element in the matrix. For example, if the matrix is: ``` mat = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] ``` and `k = 8`, the 8th smallest element is 13. Return the k-th smallest element.","solution":"import heapq def kth_smallest_element(matrix, k): Returns the k-th smallest element in a matrix where each row and each column is sorted in ascending order. n = len(matrix) min_heap = [(matrix[0][0], 0, 0)] visited = set((0, 0)) for _ in range(k - 1): val, r, c = heapq.heappop(min_heap) if r + 1 < n and (r + 1, c) not in visited: heapq.heappush(min_heap, (matrix[r + 1][c], r + 1, c)) visited.add((r + 1, c)) if c + 1 < n and (r, c + 1) not in visited: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) visited.add((r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"You are given a list of `projects`, where each project is represented by a tuple `(profit, capital)`. You are also given an integer `initialCapital`, which represents your starting capital, and an integer `numberOfProjects` that represents the maximum number of projects you can undertake. The goal is to maximize your profit by selecting up to `numberOfProjects` projects provided you have the required capital to start them. Return the maximum profit you can achieve after completing the selected projects. Note that you can only start projects that you have enough capital for at the time of selection.","solution":"import heapq def find_maximized_capital(numberOfProjects, initialCapital, projects): Find the maximum capital after completing a certain number of projects. Args: numberOfProjects (int): The maximum number of projects you can undertake initialCapital (int): Initial capital you start with projects (list of tuple): List of projects where each project is represented as (profit, capital) Returns: int: The maximum capital after completing the projects # Sort projects by the capital required to start them in ascending order projects.sort(key=lambda x: x[1]) # To keep the max heap of projects based on profit max_profit_heap = [] current_capital = initialCapital projects_idx = 0 for _ in range(numberOfProjects): # Add all projects that can be started with current_capital to the max heap while projects_idx < len(projects) and projects[projects_idx][1] <= current_capital: heapq.heappush(max_profit_heap, -projects[projects_idx][0]) projects_idx += 1 # If we have any projects in the heap, complete the most profitable one if max_profit_heap: current_capital += -heapq.heappop(max_profit_heap) else: break # No more projects can be done with current capital return current_capital"},{"question":"You are given two integer arrays `arr1` and `arr2` of length `n` and `m` respectively, containing distinct integers. Your task is to find the maximum length of a subarray that appears in both `arr1` and `arr2`. Return the length of this subarray.","solution":"def find_length(arr1, arr2): Returns the maximum length of a subarray that appears in both arr1 and arr2. n, m = len(arr1), len(arr2) dp = [[0] * (m + 1) for _ in range(n + 1)] max_length = 0 for i in range(1, n + 1): for j in range(1, m + 1): if arr1[i-1] == arr2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"You are given a list of non-overlapping intervals represented by a list of lists where each sublist contains two integers representing the start and end of an interval. Write a function that inserts a new interval into the list and merges overlapping intervals if necessary. The input intervals are initially sorted by their start times. For example, given the intervals `[[1, 3], [6, 9]]` and a new interval `[2, 5]`, the function should return `[[1, 5], [6, 9]]`. If given the intervals `[[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]]` and a new interval `[4, 8]`, the function should return `[[1, 2], [3, 10], [12, 16]]`.","solution":"def insert_interval(intervals, new_interval): Inserts a new interval into a list of existing non-overlapping intervals and merges overlapping intervals if necessary. Args: intervals (List[List[int]]): List of non-overlapping intervals sorted by start times. new_interval (List[int]): The new interval to insert. Returns: List[List[int]]: The updated list of non-overlapping intervals after insertion and merging. merged = [] i = 0 n = len(intervals) # Add all intervals ending before new_interval starts. while i < n and intervals[i][1] < new_interval[0]: merged.append(intervals[i]) i += 1 # Merge all overlapping intervals into new_interval. while i < n and intervals[i][0] <= new_interval[1]: new_interval[0] = min(new_interval[0], intervals[i][0]) new_interval[1] = max(new_interval[1], intervals[i][1]) i += 1 merged.append(new_interval) # Add the remaining intervals. while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"You are given an array of integers `nums` and a target integer `target`. Your task is to find all unique quadruples `[nums[a], nums[b], nums[c], nums[d]]` where (a, b, c,) and (d) are distinct indices such that (nums[a] + nums[b] + nums[c] + nums[d] = target). Return all such unique quadruples as a list of lists. The quadruples should be returned in ascending order, where each internal list is sorted in ascending order. Duplicate quadruples should not be included in the final list.","solution":"def four_sum(nums, target): Returns all unique quadruples [nums[a], nums[b], nums[c], nums[d]] such that nums[a] + nums[b] + nums[c] + nums[d] == target. The quadruples should be returned in ascending order. nums.sort() quadruples = set() n = len(nums) for i in range(n): for j in range(i+1, n): left = j + 1 right = n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruples.add((nums[i], nums[j], nums[left], nums[right])) left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return [list(quad) for quad in sorted(quadruples)]"},{"question":"You are given a 2D integer array `calendar` where `calendar[i] = [startDayi, endDayi]` represents an event that starts at `startDayi` and ends at `endDayi` (**inclusive**). Each day on the calendar can have multiple events. A day is considered a **busy day** if it has at least `k` events. Given `calendar` and an integer `k`, return the number of **busy days** in the specified calendar.","solution":"def count_busy_days(calendar, k): Returns the number of busy days in the calendar where each day has at least k events. Parameters: calendar (list of list of int): List of events, each represented by [startDay, endDay]. k (int): Minimum number of events for a day to be considered busy. Returns: int: The number of busy days. from collections import defaultdict # Dictionary to keep count of events per day day_counts = defaultdict(int) # Iterate through each event in the calendar for start, end in calendar: for day in range(start, end + 1): day_counts[day] += 1 # Count how many days have at least k events busy_days = sum(1 for day in day_counts if day_counts[day] >= k) return busy_days"},{"question":"Given a list of `n` integers where each integer represents the number of days you must wait to get a warmer temperature, write a function that takes this list and returns a list where, for each day in the input, you determine how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` in the corresponding position. Note: The length of the list will be at least 1 and does not exceed 10^5. Each temperature is in the range of [30, 100], and the temperatures are given as integers.","solution":"def daily_temperatures(temperatures): Given a list of integers `temperatures` where each integer represents the temperature of the day, return a list where, for each day in the input, you determine how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` in the corresponding position. Args: temperatures (list of int): List of daily temperatures. Returns: list of int: List of days to wait for a warmer temperature. n = len(temperatures) answer = [0] * n stack = [] # this will store indices of temperatures list for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() answer[index] = i - index stack.append(i) return answer"},{"question":"You are given an array `nums` of size `n` containing **positive** integers. You need to find the **maximum** length of a subarray such that the sum of the elements in the subarray is **less than or equal to** a given integer `s`. Return _the length of the longest such subarray_.","solution":"def max_length_subarray(nums, s): Returns the length of the longest subarray where the sum of the subarray is less than or equal to s. n = len(nums) max_len = 0 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum > s: current_sum -= nums[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"Write a function `findPairs` that, given an integer array `nums` and an integer `k`, returns the number of unique k-diff pairs in the array. A **k-diff pair** is an integer pair `(nums[i], nums[j])`, where `nums[i]` and `nums[j]` are both distinct and `|nums[i] - nums[j]| == k`. The function signature is: ```python def findPairs(nums: List[int], k: int) -> int: ``` * **Input**: * `nums`: List of integers. * `k`: An integer representing the difference between pairs. * **Output**: * Return the number of unique k-diff pairs.","solution":"from typing import List def findPairs(nums: List[int], k: int) -> int: if k < 0: return 0 seen = set() pairs = set() for num in nums: if num - k in seen: pairs.add((num - k, num)) if num + k in seen: pairs.add((num, num + k)) seen.add(num) return len(pairs)"},{"question":"You are given an array of positive integers `arr` where each integer represents the height of a cylinder. A **stack** of cylinders is formed by placing cylinders on top of each other. You need to find the **minimum** number of stacks required so that each stack is **non-increasing** in height from bottom to top. Return the minimum number of such stacks that can be formed.","solution":"def min_stacks(arr): stacks = [] for height in arr: placed = False for stack in stacks: if height <= stack[-1]: stack.append(height) placed = True break if not placed: stacks.append([height]) return len(stacks)"},{"question":"Given a list of unique words `words`, return _all the pairs of different indices `(i, j)` such that the concatenation of the two words `words[i] + words[j]` is a palindrome_. A string is a **palindrome** if it reads the same backward as forward. For example, given `words = [\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"]`, the output should be `[[0, 1], [1, 0], [3, 2], [2, 4]]` because: - \\"abcd\\" + \\"dcba\\" = \\"abcddcba\\" (palindrome) - \\"dcba\\" + \\"abcd\\" = \\"dcbaabcd\\" (palindrome) - \\"s\\" + \\"lls\\" = \\"slls\\" (palindrome) - \\"lls\\" + \\"sssll\\" = \\"llssssll\\" (palindrome)","solution":"def is_palindrome(s): Helper function to check if a string is a palindrome. return s == s[::-1] def palindrome_pairs(words): Given a list of unique words, return all pairs of different indices (i, j) such that the concatenation of the two words words[i] + words[j] is a palindrome. :param List[str] words: List of unique words :return List[List[int]]: List of pairs of indices forming palindrome concatenation pairs = [] for i in range(len(words)): for j in range(len(words)): if i != j: if is_palindrome(words[i] + words[j]): pairs.append([i, j]) return pairs"},{"question":"Given a list of integers `arr`, return a list of integers such that each element at index `i` is the **product** of all the numbers in the original array **except** the one at `i`. You must solve the problem without using division, and the algorithm should run in `O(n)` time where `n` is the length of the input list. For example, given the input list `[1, 2, 3, 4]`, return `[24, 12, 8, 6]`.","solution":"def product_except_self(nums): Returns a list of integers such that each element at index i is the product of all the numbers in the original array except the one at i. length = len(nums) result = [1] * length prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] suffix = 1 for i in range(length - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"An integer array `nums` is said to be \\"cyclically sorted\\" if it is possible to cyclically shift (rotate) the array to make it sorted in non-decreasing order. Given an integer array `nums`, determine if it is cyclically sorted. Return `true` if it is cyclically sorted and `false` otherwise. The array: * Cannot contain duplicate elements. * Cannot be empty. For example, for the input `[3, 4, 5, 1, 2]`, it is possible to shift `[3, 4, 5, 1, 2]` to get `[1, 2, 3, 4, 5]`, which is sorted in non-decreasing order. Therefore, the output should be `true`.","solution":"def is_cyclically_sorted(nums): Determines if the given array is cyclically sorted. n = len(nums) count = 0 for i in range(n): if nums[i] > nums[(i + 1) % n]: count += 1 return count <= 1"},{"question":"Given a string `s`, the task is to partition `s` into as few substrings as possible such that each substring is a palindrome. You will then return _the **length of the smallest** substring in any of the optimal palindromic partitionings of `s`_. For example, given the string `\\"aab\\"`, the possible palindromic partitionings are `[\\"a\\", \\"a\\", \\"b\\"]` and `[\\"aa\\", \\"b\\"]`. The optimal partitioning is `[\\"aa\\", \\"b\\"]`, where the smallest substring length is `1` (`\\"b\\"`). Hence, you should return `1`.","solution":"def min_smallest_palindromic_partition_length(s): n = len(s) def is_palindrome(sub): return sub == sub[::-1] # dp[i] will be the minimum number of cuts needed to partition s[:i+1] dp = [float(\'inf\')] * n # palin[i][j] will be True if s[i:j+1] is a palindrome palin = [[False] * n for _ in range(n)] for i in range(n): min_cut = i # Maximum cuts, which is i (all single characters) for j in range(i + 1): if s[j] == s[i] and (i - j < 3 or palin[j + 1][i - 1]): palin[j][i] = True min_cut = 0 if j == 0 else min(min_cut, dp[j - 1] + 1) dp[i] = min_cut smallest_length = n start = 0 while start < n: end = start while end < n and not palin[start][end]: end += 1 smallest_length = min(smallest_length, end - start + 1) start = end + 1 return smallest_length"},{"question":"A warehouse system stores inventory in a category-subcategory hierarchy using a tree structure. You are provided with a `TreeNode` class representing each node in the hierarchy, where each node contains a name and a list of its children nodes. Implement a function `find_max_product_subcategory(root: TreeNode) -> str` that finds the name of the subcategory with the maximum total number of products stored directly under it and under all its subcategories. Your function should return the name of this subcategory. If there are multiple subcategories with the same maximum product count, return the lexicographically smallest name. Each `TreeNode` contains: - `name`: a string representing the name of the category or subcategory. - `products`: an integer representing the number of products stored directly under this node. - `children`: a list of `TreeNode` objects representing the subcategories under this category. Here is the definition of the `TreeNode` class for reference: ```python class TreeNode: def __init__(self, name: str, products: int, children: List[\'TreeNode\'] = None): self.name = name self.products = products self.children = children if children is not None else [] ```","solution":"class TreeNode: def __init__(self, name: str, products: int, children=None): if children is None: children = [] self.name = name self.products = products self.children = children def find_max_product_subcategory(root: TreeNode) -> str: def total_products(node): total = node.products for child in node.children: total += total_products(child) return total max_products = -1 max_subcategory_name = \\"\\" if not root.children: return root.name stack = [(root, child) for child in root.children] while stack: parent, node = stack.pop() prod_count = total_products(node) if (prod_count > max_products or (prod_count == max_products and node.name < max_subcategory_name)): max_products = prod_count max_subcategory_name = node.name for child in node.children: stack.append((node, child)) return max_subcategory_name"},{"question":"You are given a 2D grid of size `m x n` representing a map of land and water, where `1` represents land and `0` represents water. An island is a group of adjacent lands connected horizontally or vertically. You can assume all four edges of the grid are surrounded by water. Explore and return the perimeter of the island. The grid will have exactly one island.","solution":"def island_perimeter(grid): Returns the perimeter of the island in the given grid. Parameters: grid (List[List[int]]): A 2D grid representing the map of land (1) and water (0). Returns: int: The perimeter of the island. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Initial count for the current land. perimeter += 4 # Subtract perimeter count for adjacent lands. if r > 0 and grid[r-1][c] == 1: perimeter -= 2 if c > 0 and grid[r][c-1] == 1: perimeter -= 2 return perimeter"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` distinct integers. Return `true` if there exists an integer in the array such that all elements to the left of it are in strictly increasing order and all elements to the right of it are in strictly decreasing order. Otherwise, return `false`.","solution":"def valid_mountain_array(nums): Returns true if there exists an integer in the array such that all elements to the left of it are in strictly increasing order and all elements to the right of it are in strictly decreasing order. n = len(nums) if n < 3: return False i = 1 # walk up while i < n and nums[i] > nums[i - 1]: i += 1 # peak can\'t be first or last if i == 1 or i == n: return False # walk down while i < n and nums[i] < nums[i - 1]: i += 1 return i == n"},{"question":"You are given an array of integers `arr` and an integer `target`. Your goal is to find two distinct indices `i` and `j` in the array such that `arr[i] + arr[j] == target`. Return an array containing the two indices in any order. If there are multiple valid solutions, return any one of them. You may assume that each input would have exactly one solution. The function should be implemented as: * `int[] findTwoSum(int[] arr, int target)` - where `arr` is the input array and `target` is the target sum. The function returns an array of two integers representing the indices of the elements that add up to `target`.","solution":"def find_two_sum(arr, target): Finds two distinct indices i and j in the array such that arr[i] + arr[j] == target. Parameters: arr (list of int): List of integers. target (int): Target sum. Returns: list of int: A list containing two indices [i, j]. value_to_index = {} for index, value in enumerate(arr): complement = target - value if complement in value_to_index: return [value_to_index[complement], index] value_to_index[value] = index"},{"question":"You are given a **binary tree** where the nodes have integer values, and an integer `target`. Write a function to find **all paths** in the binary tree such that the sum of the node values in each path equals the `target`. Each path should be represented as a list of the node values. Return _a list of lists_ with each sublist representing a valid path from **root to leaf** nodes having the specified sum. If no such path exists, return an empty list.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target): def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target: result.append(list(current_path)) dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"You are given two strings `s` and `t`, both consisting of lowercase letters. You need to transform `s` into `t` using the following operation any number of times: select a prefix of `s` and move it to the end of the string. Return the minimum number of such operations needed to transform `s` into `t`. If it\'s not possible, return `-1`.","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations needed to transform string s into string t using the described prefix move operation. If it\'s not possible, returns -1. if len(s) != len(t): return -1 concatenated = s + s position = concatenated.find(t) if position == -1: return -1 else: return position"},{"question":"You are given a **0-indexed** array of strings `words` where each word consists of lowercase English letters. Write a function that returns the longest **common prefix** among all the words in the array. If there is no common prefix, return an empty string. A **common prefix** among a set of strings is a sequence of characters that appears at the start of all strings in the set.","solution":"def longest_common_prefix(words): Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. if not words: return \\"\\" # Assume the first word is the common prefix entirely prefix = words[0] for word in words[1:]: while not word.startswith(prefix): # Reduce the prefix by one character until it\'s a common prefix prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"# New Question: Given an unsorted array `arr` of integers, where every integer appears twice except for one integer which appears only once, find and return the integer that appears only once. Your solution should have a linear runtime complexity and use only constant extra space.","solution":"def single_number(arr): Given an unsorted array `arr` of integers where every element appears twice except for one element which appears once, find and return that single element. The solution should have linear runtime complexity and only use constant extra space. single = 0 for num in arr: single ^= num return single"},{"question":"You are given two arrays `word1` and `word2` that represent two sequences of characters. Your task is to determine if the sequences in both arrays are equivalent by composing the arrays into single strings. Return _true if the arrays represent the same sequence of characters, and false otherwise_.","solution":"def array_strings_are_equal(word1, word2): Determines if the sequences in both arrays represent the same sequence of characters by composing the arrays into single strings. Args: word1 : List[str] : First list of strings. word2 : List[str] : Second list of strings. Returns: bool : True if the arrays represent the same sequence of characters, False otherwise. return \'\'.join(word1) == \'\'.join(word2)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. The operation is to select any index `i` (0 <= i < n) and set `nums[i]` to `nums[i] & nums[i+1]` (bitwise AND between consecutive elements). This operation can be performed any number of times on any index. Return _an integer_ representing the minimum possible sum of elements in the array `nums` after performing the operation any number of times.","solution":"def min_possible_sum(nums): Returns the minimum possible sum of elements in the array `nums` after performing bitwise AND operations. Args: nums: List[int] : A list of integers. Returns: int : The minimum possible sum of elements in the array. # After applying the operation unlimited times, every element can eventually be reduced to the bitwise AND of all elements. and_result = nums[0] for num in nums[1:]: and_result &= num # The minimal array sum would be n copies of that final value. return and_result * len(nums)"},{"question":"You are given an `m x n` matrix `mat` where each row is sorted in non-decreasing order. Find the smallest common element in all rows. If there is no common element, return `-1`. Return _the smallest common element in all rows of the matrix_.","solution":"def smallestCommonElement(mat): Finds the smallest common element in all rows of the matrix mat. Parameters: mat (list of list of int): Matrix where each row is sorted in non-decreasing order. Returns: int: The smallest common element in all rows. If no common element exists, returns -1. if not mat or not mat[0]: return -1 # Create a dictionary to count the elements count = {} # Count the occurrences of each element in the first row for num in mat[0]: count[num] = 1 # Traverse remaining rows to increment the count of occurrences for row in mat[1:]: new_count = {} for num in row: if num in count and num not in new_count: new_count[num] = count[num] + 1 count = new_count # Check for the smallest common element with occurrences equal to the number of rows num_rows = len(mat) smallest_common_element = float(\'inf\') for num, cnt in count.items(): if cnt == num_rows: smallest_common_element = min(smallest_common_element, num) return smallest_common_element if smallest_common_element != float(\'inf\') else -1"},{"question":"You are given an integer array `nums` and an integer `k`. The array `nums` is initially sorted in ascending order, but has been rotated at an unknown pivot, so that it is now of the form `[a[k], a[k+1], ..., a[n-1], a[0], a[1], ..., a[k-1]]`. You need to find the index of the minimum element in the array. Return the index of the minimum element. You must write an algorithm that runs in `O(log n)` time.","solution":"def find_min_index(nums): Finds the index of the minimum element in a rotated sorted array. Args: nums (List[int]): The rotated sorted array. Returns: int: The index of the minimum element. if not nums: return -1 # Array is empty left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: # The minimum is in the right part left = mid + 1 else: # The minimum is in the left part including mid right = mid return left"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to find the **number of distinct subsequences** of `nums` of length `k` that are **sorted in non-decreasing order**. A subsequence is derived from the array by deleting some or none of the elements without changing the order of the remaining elements. Return _the number of distinct subsequences of length_ `k` _that are sorted in non-decreasing order_.","solution":"def count_sorted_subsequences(nums, k): from itertools import combinations sorted_combinations = set() for combination in combinations(nums, k): if list(combination) == sorted(combination): sorted_combinations.add(combination) return len(sorted_combinations)"},{"question":"Given `n` houses on a straight street numbered `1` through `n`, each house `i` has a certain amount of treasure `t[i]` stored inside it. A thief has planned to steal the maximum possible treasure, but he cannot rob two consecutive houses because the security systems will detect him. Given an integer array `treasure` where `treasure[i]` represents the amount of treasure in the `i-th` house, return _the maximum amount of treasure that can be stolen without triggering the security system_.","solution":"def max_treasure(treasure): Returns the maximum amount of treasure that can be stolen without robbing two consecutive houses. :param treasure: List[int], where treasure[i] represents the treasure in the i-th house. :return: int, the maximum treasure that can be stolen. n = len(treasure) if n == 0: return 0 if n == 1: return treasure[0] # dp array to store the maximum treasure that can be stolen up to the i-th house. dp = [0] * n dp[0] = treasure[0] dp[1] = max(treasure[0], treasure[1]) for i in range(2, n): dp[i] = max(treasure[i] + dp[i - 2], dp[i - 1]) return dp[-1]"},{"question":"Given a binary tree, populate each `next` pointer to point to its next right node. If there is no next right node, the `next` pointer should be set to `NULL`. Initially, all `next` pointers are set to `NULL`. You may only use constant extra space. The given binary tree will have the following structure: ``` struct Node { int val; Node* left; Node* right; Node* next; } ``` The tree is perfect binary tree, meaning all leaves are at the same level and every parent has two children.","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root: Node) -> Node: Connects each node\'s next pointer to its next right node. if not root: return root # Start with the root node leftmost = root while leftmost.left: # Iterate the \\"linked list\\" at the current level using the next pointers head = leftmost while head: # Connection 1 head.left.next = head.right # Connection 2 if head.next: head.right.next = head.next.left # Move to the next node in the current level head = head.next # Move to the leftmost node in the next level leftmost = leftmost.left return root"},{"question":"Given an `m x n` matrix where every row and column is sorted in non-decreasing order, and an integer `target`, write a function to search for the target in the matrix. Return `true` if the target is found, or `false` otherwise.","solution":"def search_matrix(matrix, target): Searches for a target in an m x n matrix where every row and column is sorted in non-decreasing order. Returns True if the target is found, otherwise returns False. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # Start from top-right corner while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"You are given a list of strings `words` and a string `chars`. A string is considered **good** if it can be formed by characters in `chars` (each character can only be used once). Return the length of the total number of characters in all **good** strings in `words`. You may assume the string `chars` contains only lowercase English letters.","solution":"def count_characters(words, chars): from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= chars_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"Given an array of distinct integers, analyze the array to determine if the elements can be rearranged to form a sequence of consecutive integers. Return `true` if they can be rearranged to form such a sequence, and `false` otherwise. Implement the function `bool canFormConsecutiveSequence(vector<int>& nums)`. The function should return a boolean value indicating whether the elements can be rearranged to form a sequence of consecutive integers. The input array `nums` may have at most `10^5` elements.","solution":"def canFormConsecutiveSequence(nums): Determines if the elements of the array can be rearranged to form a sequence of consecutive integers. :param nums: List[int] - List of distinct integers :return: bool - True if they can be rearranged to form a sequence of consecutive integers, False otherwise if not nums: # Handle the empty list case return False min_num = min(nums) max_num = max(nums) # Check if the length of nums matches the range between the minimum and maximum numbers return (max_num - min_num + 1) == len(nums)"},{"question":"Given a string `s` representing a sentence and an integer `k`, return _the longest substring_ of `s` that contains **at most** `k` distinct characters. If there are multiple possible substrings with the same length, return the one that appears first. **Note:** The substring must be contiguous and the characters in the substring are case sensitive.","solution":"def longest_substring_k_distinct(s, k): Returns the longest substring of s that contains at most k distinct characters. If there are multiple possible substrings with the same length, return the one that appears first. if k == 0 or not s: return \\"\\" left = 0 char_map = {} max_len = 0 max_substr = \\"\\" for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del(char_map[s[left]]) left += 1 if right - left + 1 > max_len: max_len = right - left + 1 max_substr = s[left:right + 1] return max_substr"},{"question":"A delivery robot is located at the top-left corner of a `m x n` grid marked by an integer matrix `grid`. The robot moves according to the values in `grid`, where a positive integer `grid[i][j]` represents a possible step in direction right, down, left, or up from the current position `(i, j)`. However, certain cells in the grid, marked with a `-1`, represent obstacles and cannot be crossed. You are tasked to find the shortest path (measured in number of steps) for the robot to reach the bottom-right corner `(m - 1, n - 1)` of the grid, starting from `(0, 0)`. If no such path exists, return `-1`. Return _the minimum number of steps required for the robot to reach the bottom-right corner of the grid_ if it is possible, otherwise return `-1`.","solution":"from collections import deque def shortest_path(grid): m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if grid[0][0] == -1 or grid[m-1][n-1] == -1: return -1 queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if (r, c) == (m-1, n-1): return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] != -1 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"Given a string `s` consisting of lowercase alphabets, determine the length of the longest subsequence that appears in alphabetical order. A subsequence is derived by deleting some or no characters of the string without changing the order of the remaining characters. Return _the length of the longest alphabetical subsequence_ in `s`.","solution":"def longest_alphabetical_subsequence_length(s): Returns the length of the longest subsequence that appears in alphabetical order. if not s: return 0 longest_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] >= s[i-1]: current_length += 1 else: current_length = 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"Given an array of integers `arr` representing a sequence of numbers, you need to determine if it\'s possible to split the array into two non-empty subsequences such that the sum of the elements in both subsequences is the same. Return `true` if such a split is possible, otherwise, return `false`. For example, given the array `[1, 2, 3, 4, 6]`, it\'s possible to split it into `[1, 2, 3, 4]` and `[6]` where both subsequences have a sum of 10. However, for the array `[1, 2, 3, 5]`, there is no way to split it where the sums of the subsequences are equal.","solution":"def can_split_array(arr): Determines if it\'s possible to split the array into two non-empty subsequences such that the sum of the elements in both subsequences is the same. Parameters: arr (list of int): The input array. Returns: bool: True if such a split is possible, False otherwise. total_sum = sum(arr) # If the total sum is odd, we cannot divide it into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(arr) # Initialize a set to store the sums that can be achieved achievable_sums = {0} for num in arr: new_sums = achievable_sums.copy() for s in achievable_sums: new_sum = s + num if new_sum == target_sum: return True new_sums.add(new_sum) achievable_sums = new_sums return False"},{"question":"Design a reservation system for a movie theater that can perform the following operations: - **Reserve** seats for a specific showtime. - **Query** the number of available seats for a specific showtime. - **Cancel** a seat reservation. Implement the `MovieTheater` class: - `MovieTheater(int numShowtimes, int numSeatsPerShowtime)` Initializes the movie theater with `numShowtimes` showtimes, each having `numSeatsPerShowtime` seats available. - `boolean reserveSeats(int showtimeId, int count)` Attempts to reserve `count` seats for the showtime with ID `showtimeId`. Returns `true` if the reservation is successful (all requested seats are available) and `false` otherwise. - `int availableSeats(int showtimeId)` Returns the number of seats currently available for the showtime with ID `showtimeId`. - `void cancelReservation(int showtimeId, int count)` Cancels `count` seats for the showtime with ID `showtimeId`. If the number of seats to cancel exceeds the number of reserved seats, cancel all reserved seats. Each showtime ID is a non-negative integer starting from 0 up to `numShowtimes - 1`. Ensure your implementation maintains efficient and accurate seat tracking for all showtimes.","solution":"class MovieTheater: def __init__(self, numShowtimes, numSeatsPerShowtime): Initializes the movie theater with numShowtimes showtimes, each having numSeatsPerShowtime seats available. self.seats = {showtimeId: numSeatsPerShowtime for showtimeId in range(numShowtimes)} self.numSeatsPerShowtime = numSeatsPerShowtime def reserveSeats(self, showtimeId, count): Attempts to reserve count seats for the showtime with ID showtimeId. Returns True if the reservation is successful (all requested seats are available) and False otherwise. if self.seats[showtimeId] >= count: self.seats[showtimeId] -= count return True return False def availableSeats(self, showtimeId): Returns the number of seats currently available for the showtime with ID showtimeId. return self.seats[showtimeId] def cancelReservation(self, showtimeId, count): Cancels count seats for the showtime with ID showtimeId. If the number of seats to cancel exceeds the number of reserved seats, cancel all reserved seats. self.seats[showtimeId] = min(self.seats[showtimeId] + count, self.numSeatsPerShowtime) # Ensuring that seats do not exceed the total seats available."},{"question":"Given a list of unique strings, words, return _the length of the longest chain of words that can be formed_. A word `w1` can be a predecessor of another word `w2` if and only if `w1` can be formed by removing exactly one character from `w2` and the resulting word is in the original list. Formally, the word chain is a sequence of words `w0, w1, ..., wn-1` with `w0` as the shortest word and `wn-1` as the longest, such that `w0` is a predecessor of `w1`, `w1` is a predecessor of `w2`, and so on. Return the length of the longest possible word chain with these words.","solution":"def longest_str_chain(words): Given a list of unique strings `words`, return the length of the longest chain of words. A word w1 can be a predecessor of another word w2 if and only if w1 can be formed by removing exactly one character from w2 and the resulting word is in the original list. words.sort(key=len) # Sort by length dp = {} max_chain_length = 1 for word in words: dp[word] = 1 # Each word is at least a chain of length 1 for i in range(len(word)): prev = word[:i] + word[i+1:] if prev in dp: dp[word] = max(dp[word], dp[prev] + 1) max_chain_length = max(max_chain_length, dp[word]) return max_chain_length"},{"question":"You are given a string `s` and an array of dictionaries `words`, each representing a word. Your goal is to find the number of words in the `words` array that are subsequences of the string `s`. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. Return _the number of words in the `words` array that are subsequences of the string `s`_.","solution":"from typing import List, Dict def num_matching_subseq(s: str, words: List[Dict]) -> int: def is_subsequence(word, s): it = iter(s) return all(char in it for char in word) count = 0 for word_dict in words: for word in word_dict.values(): if is_subsequence(word, s): count += 1 return count"},{"question":"You are given a 2D grid `grid` of size `n x n` representing the initial state of a square board. Each cell in the grid contains an integer value which can be 0 (empty) or 1 (occupied). You need to determine the largest square (which could be empty or contain only 1s) that can be formed in the grid. Return _the area of the maximum square that can be formed on the board._","solution":"def largest_square_area(grid): if not grid or not grid[0]: return 0 n = len(grid) dp = [[0] * n for _ in range(n)] max_side = 0 for i in range(n): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"Write a function to find the longest path in a matrix where each cell contains an integer. The path must increase at each step. You can move in four directions (up, down, left, right). Return the length of the longest path.","solution":"def longest_increasing_path(matrix): Finds the longest increasing path in a given matrix. Parameters: matrix (List[List[int]]): 2D list of integers representing the matrix. Returns: int: Length of the longest increasing path. if not matrix or not matrix[0]: return 0 def dfs(x, y): if cache[x][y] != -1: return cache[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) cache[x][y] = max_length return max_length rows, cols = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] cache = [[-1]*cols for _ in range(rows)] longest_path_length = 0 for r in range(rows): for c in range(cols): longest_path_length = max(longest_path_length, dfs(r, c)) return longest_path_length"},{"question":"Given a list of strings `words`, where each word consists of lowercase English letters (a-z). A word `a` is an **anagram** of another word `b` if it uses the same characters in the same frequency. For example, \\"listen\\" is an anagram of \\"silent\\". You need to group the words that are anagrams of each other and return a list of the grouped anagrams. Each group should have at least two words. Return the groups in any order.","solution":"from collections import defaultdict def group_anagrams(words): Groups words that are anagrams of each other. Args: words (list of str): List of words consisting of lowercase English letters. Returns: list of list of str: List of groups of anagrams. anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return [group for group in anagrams.values() if len(group) >= 2]"},{"question":"You are given two sorted arrays `arr1` and `arr2` of sizes `m` and `n` respectively, and an integer `k`. Merge these two arrays into a single sorted array and find the `k`-th smallest element in the merged array. The arrays may contain duplicate elements. Return the k-th smallest element of the merged sorted array.","solution":"def kth_smallest_element(arr1, arr2, k): Merges two sorted arrays and returns the k-th smallest element in the merged array. :param arr1: List[int] - First sorted array :param arr2: List[int] - Second sorted array :param k: int - The index (1-based) of the smallest element to find :return: int - The k-th smallest element in the merged array merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array[k - 1]"},{"question":"You are given two strings `start` and `goal`, and a string array `bank` containing distinct strings, each having the same length. A valid genetic mutation entails changing a single letter of a string into a different letter. Given the `start` string, determine the minimum number of mutations required to get to the `goal` string. If it is not possible to mutate the `start` string into the `goal` string using the mutations provided in the `bank`, return -1. Implement the `minMutations` class: * `minMutations(String start, String goal, String[] bank)` Initializes the `minMutations` class with `start`, `goal`, and `bank`. * `int getMinMutations()` Returns the minimum number of mutations required to mutate `start` into `goal`, or -1 if the mutation is not possible.","solution":"from collections import deque class minMutations: def __init__(self, start, goal, bank): self.start = start self.goal = goal self.bank = set(bank) # Using set for O(1) lookups def getMinMutations(self): if self.goal not in self.bank: return -1 def is_valid_mutation(current, next_str): count = 0 for c1, c2 in zip(current, next_str): if c1 != c2: count += 1 if count > 1: return False return count == 1 queue = deque([(self.start, 0)]) visited = set([self.start]) while queue: current, mutations = queue.popleft() if current == self.goal: return mutations for candidate in list(self.bank): if candidate not in visited and is_valid_mutation(current, candidate): visited.add(candidate) queue.append((candidate, mutations + 1)) return -1"},{"question":"Given a list of non-negative integers representing the amount of time in minutes required to complete each task on a server, and an integer `k` representing the limit on the maximum time a task can take, return the minimum number of sessions required to complete all tasks if a session can be of any length but each task must be run consecutively without interruption and cannot run longer than `k` minutes. A session ends when no more tasks are left or when a task exceeds the time limit `k`.","solution":"def min_sessions(tasks, k): Determine the minimum number of sessions required to complete all tasks. Args: tasks (List[int]): List of non-negative integers representing the time required for each task. k (int): Maximum allowed time for a single task. Returns: int: Minimum number of sessions required. if any(task > k for task in tasks): raise ValueError(\\"A task exceeds the maximum allowed time for a session.\\") sessions = 0 tasks.sort(reverse=True) # Sort tasks in descending order to optimize sessions while tasks: remaining_time = k i = 0 while i < len(tasks): if tasks[i] <= remaining_time: remaining_time -= tasks[i] tasks.pop(i) else: i += 1 sessions += 1 return sessions"},{"question":"You are given an array of integers `arr` and a positive integer `x`. Your task is to find the length of the smallest contiguous subarray of which the sum is greater than or equal to `x`. If there isn\'t one, return `0` instead. A **contiguous subarray** is a sequence of elements within the array that are adjacent and maintain their order in the original array. For example, given the array `arr = [2, 3, 1, 2, 4, 3]` and `x = 7`, the smallest subarray with a sum greater than or equal to `7` is `[4, 3]`, so the function returns `2`.","solution":"def smallest_subarray_with_sum(arr, x): Returns the length of the smallest subarray with a sum greater than or equal to x. If no such subarray, returns 0. n = len(arr) min_length = float(\'inf\') start = 0 end = 0 current_sum = 0 while end < n: # Add elements to the current window current_sum += arr[end] # While current window satisfies the condition, try to shrink the window while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 end += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":": Given an array `nums` of integers, return _the **number** of **good pairs**_. A **good pair** is a pair `(i, j)` where `nums[i]` is **equal** to `nums[j]` and `i < j`.","solution":"def num_good_pairs(nums): Returns the number of good pairs in the nums array. A good pair is a pair (i, j) where nums[i] == nums[j] and i < j. count = 0 freq = {} for num in nums: if num in freq: count += freq[num] freq[num] += 1 else: freq[num] = 1 return count"},{"question":"Given an integer array `nums` and an integer `k`, return the maximum number of non-overlapping subarrays that sum up to `k`. A subarray is a contiguous part of the array, and two subarrays are non-overlapping if they do not share any elements. For example, given `nums = [1,1,1,1,1]` and `k = 2`, the function should return 2 because the subarrays `[1,1]` and `[1,1]` each sum up to 2 and are non-overlapping. Another example could be `nums = [-1, 3, 4, -2, -2, 5]` and `k = 5`, returning 2 for subarrays `[4, -2, -2, 5]` and `[5]`.","solution":"def maxNonOverlapping(nums, k): Returns the maximum number of non-overlapping subarrays that sum up to k. prefix_sums = {0} current_sum = 0 count = 0 for num in nums: current_sum += num if current_sum - k in prefix_sums: count += 1 prefix_sums = {0} current_sum = 0 else: prefix_sums.add(current_sum) return count"},{"question":"Given an integer array `arr`, a **subarray** is defined as a contiguous segment of the array. Return the number of subarrays where the **product** of all the elements in the subarray is less than `k`, where `k` is a positive integer. Implement the function `int countSubarraysWithProductLessThanK(int[] arr, int k)` which takes in an array `arr` of integers and an integer `k` and returns the count of such subarrays. Note that the input array can contain up to `10^4` elements and each element can have a value ranging from `1` to `10^4`.","solution":"def countSubarraysWithProductLessThanK(arr, k): if k <= 1: return 0 count = 0 product = 1 start = 0 for end in range(len(arr)): product *= arr[end] while product >= k: product //= arr[start] start += 1 count += end - start + 1 return count"},{"question":"You are given an array of integers `nums` and an integer `target`. Write a function to determine if there are three integers in `nums` whose sum is equal to `target`. Return _a boolean value_ - `true` if such a triplet exists, and `false` otherwise. Note that the integers in the array `nums` can include negative numbers and duplicates. Ensure your algorithm has a time complexity of **O(n^2)** or better.","solution":"def three_sum(nums, target): Determines if there are three integers in nums whose sum equals the target. Args: - nums: List of integers. - target: An integer representing the target sum. Returns: - A boolean, True if there exists three integers that sum up to the target, False otherwise. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: # Skip duplicate elements continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"You are given a 2D matrix `grid` of size `n x n`, where each cell contains an integer. You start at the top-left cell (0, 0) and must traverse to the bottom-right cell (n-1, n-1) following these rules: - You can only move right or down. - You must collect the integers from the cells you visit. Return the maximum sum you can collect by the time you reach the bottom-right cell.","solution":"def max_path_sum(grid): Returns the maximum sum you can collect by traversing from the top-left to the bottom-right of the grid. n = len(grid) # Create a dp matrix to store the max sum at each cell dp = [[0] * n for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp matrix for i in range(1, n): for j in range(1, n): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) # The bottom-right cell contains the maximum sum return dp[n-1][n-1]"},{"question":"You are given a string containing digits and the character \'X\'. The character \'X\' can be replaced by any digit from \'1\' to \'9\'. Determine the number of distinct palindromic permutations that can be formed from the string after replacing all occurrences of \'X\'. Return the result modulo 10^9 + 7. Two permutations are considered distinct even if they consist of the same characters but arranged differently.","solution":"def count_distinct_palindromes(s): MOD = 10**9 + 7 # Function to determine if a string can be rearranged into a palindrome def can_form_palindrome(char_count): odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 from collections import Counter # Replace each \'X\' with \'1\' and create a counter of characters char_count = Counter(s.replace(\'X\', \'1\')) if not can_form_palindrome(char_count): return 0 # Count the number of \'X\' in the string x_count = s.count(\'X\') # Calculate the total distinct palindles modulo 10**9 + 7 # Every \'X\' can be replaced by any of \'1\' to \'9\', thus there are 9^x_count possibilities. result = pow(9, x_count, MOD) return result"},{"question":"You are given a binary tree where each node has an integer value. You need to find the path from the root to a leaf that has the maximum sum of node values. A leaf is a node with no children. Return a list of integers representing the node values in the path with the maximum sum. If there are multiple paths with the same sum, return any one of them.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_sum_path(root): def helper(node): if not node: return (0, []) left_sum, left_path = helper(node.left) right_sum, right_path = helper(node.right) if left_sum > right_sum: return (node.value + left_sum, [node.value] + left_path) else: return (node.value + right_sum, [node.value] + right_path) total_sum, path = helper(root) return path"},{"question":"You are given a list of integers representing servers\' request processing times. Each server can handle one request at a time. You have a load balancer that assigns new incoming requests in round-robin fashion to the servers. Implement the `LoadBalancer` class to track the servers\' load: - `LoadBalancer(int numServers)` initializes the load balancer with `numServers` servers. - `void addRequest(int processTime)` assigns a new request with the given `processTime` to the next server in the round-robin rotation. - `List<Integer> getLoads()` returns a list with the total processing time for each server. Example: ``` LoadBalancer lb = new LoadBalancer(3); lb.addRequest(5); // adds request with processing time 5 to first server lb.addRequest(3); // adds request with processing time 3 to second server lb.addRequest(10); // adds request with processing time 10 to third server lb.addRequest(8); // adds request with processing time 8 to first server again lb.getLoads(); // returns [13, 3, 10] ``` Ensure that your implementation efficiently manages adding requests and retrieving the current load of each server.","solution":"class LoadBalancer: def __init__(self, numServers): self.numServers = numServers self.loads = [0] * numServers self.currentServer = 0 def addRequest(self, processTime): self.loads[self.currentServer] += processTime self.currentServer = (self.currentServer + 1) % self.numServers def getLoads(self): return self.loads"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to divide the array into `k` non-empty subsets such that the sum of elements in each subset is the same. If it is possible, return `true`; otherwise, return `false`. For example, if `arr = [4, 3, 2, 3, 5, 2, 1]` and `k = 4`, then you can divide the array into 4 subsets, each with sums equal to 5: `[4, 1]`, `[3, 2]`, `[3, 2]`, and `[5]`. Therefore, the output should be `true`. If `arr = [1, 2, 3, 4]` and `k = 3`, it is not possible to divide the array into 3 subsets with equal sums, so the output should be `false`.","solution":"def canPartitionKSubsets(arr, k): def canPartition(start, k, current_sum, target_sum, visited): if k == 1: return True # only one subset left, no need to check if current_sum == target_sum: return canPartition(0, k - 1, 0, target_sum, visited) # found one subset, looking for next for i in range(start, len(arr)): if not visited[i] and current_sum + arr[i] <= target_sum: visited[i] = True if canPartition(i + 1, k, current_sum + arr[i], target_sum, visited): return True visited[i] = False return False if k == 0 or k > len(arr): return False total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k visited = [False] * len(arr) arr.sort(reverse=True) # Sort to optimize backtracking return canPartition(0, k, 0, target_sum, visited)"},{"question":"Given a string `s` that represents a mathematical expression with positive integers and the operators `\'+\'` and `\'-\'``, evaluate and return the result of the expression. You may assume the expression is always valid and follows the standard order of operations (i.e., from left to right with no operator precedence).","solution":"def evaluate_expression(s): Evaluate a simple mathematical expression containing + and - operators and return the result. The expression is evaluated from left to right without considering any operator precedence. # Split the string by spaces and compute the result iteratively tokens = s.split() result = int(tokens[0]) i = 1 while i < len(tokens): operator = tokens[i] number = int(tokens[i + 1]) if operator == \'+\': result += number elif operator == \'-\': result -= number i += 2 return result"},{"question":"A **string transformation** is defined as changing a string character by character such that at each step, you can: 1. Replace a character with its subsequent character in the alphabet (e.g., \'a\' becomes \'b\', \'b\' becomes \'c\', ..., \'z\' becomes \'a\'). 2. Replace a character with its preceding character in the alphabet (e.g., \'b\' becomes \'a\', \'c\' becomes \'b\', ..., \'a\' becomes \'z\'). Given a string `start` and a string `end` of the same length, return `true` if you can transform `start` into `end` by performing the above described operation for each character in `start` in a single pass. Otherwise, return `false`. # Example: - Input: `start = \\"abc\\", end = \\"bcd\\"` - Output: `true` - Input: `start = \\"abc\\", end = \\"xyz\\"` - Output: `false`","solution":"def can_transform(start, end): Returns True if the start string can be transformed into the end string character by character. if len(start) != len(end): return False for s, e in zip(start, end): if s == e: continue # Calculate distance in the alphabet (considering circular nature) forward_steps = (ord(e) - ord(s)) % 26 backward_steps = (ord(s) - ord(e)) % 26 if not (forward_steps == 1 or backward_steps == 1): return False return True"},{"question":"You are given an integer array `nums`. A subset of `nums` is considered **good** if the product of its elements is a perfect square. Implement a function to find the size of the largest **good** subset of `nums`. Example: - Input: `nums = [4, 3, 9, 7, 16]` - Output: `3` - Explanation: The subset `[4, 9, 16]` has the product `576` which is a perfect square. Note: - The input array will have at most 20 elements. - Elements in the array are positive integers and do not exceed 100.","solution":"from itertools import combinations import math def largest_good_subset_size(nums): Returns the size of the largest subset of nums where the product of its elements is a perfect square. def is_perfect_square(n): return int(math.isqrt(n)) ** 2 == n n = len(nums) max_size = 0 for r in range(1, n + 1): for subset in combinations(nums, r): product = math.prod(subset) if is_perfect_square(product): max_size = max(max_size, len(subset)) return max_size"},{"question":"You are given a list of integers `nums` representing a histogram, where the width of each bar is `1` and the height of each bar is given by the corresponding integer in the list. Write a function to find the area of the largest rectangle that can be formed within the bounds of the histogram. The rectangle must be aligned with the x and y axes. For example, given the list `nums = [2, 1, 5, 6, 2, 3]`, the function should return `10` as the largest rectangle has an area of `10` (formed by the bars with heights `5` and `6`).","solution":"def largest_rectangle_area(nums): Finds the area of the largest rectangle that can be formed within the bounds of the histogram. :param nums: List of integers representing the heights of histogram bars :return: The maximum area of the rectangle stack = [] max_area = 0 index = 0 while index < len(nums): if not stack or nums[stack[-1]] <= nums[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an integer array `nums` of length `n` and an integer `target`. You need to find a pair of distinct indices `(i, j)` in the array such that their corresponding values add up to `target`. Return the indices of the first such pair you encounter (i.e., in ascending order of the first index). If there is no such pair, return an empty array. For example: ``` Input: nums = [2, 7, 11, 15], target = 9 Output: [0, 1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. ``` To solve the problem: * Traverse the list in a single pass to find the first pair of indices that add up to `target`. * Ensure the solution works with various edge cases, including negative numbers and no valid pairs.","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to target. If no such pair exists, returns an empty array. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"Given a 2D grid of integers, you need to perform certain operations on it. The grid is represented as `grid[r][c]` where `r` is the number of rows and `c` is the number of columns. Each cell in the grid is either `0` (representing water) or `1` (representing land). Your task is to mark all distinct islands in the grid. Two cells are part of the same island if they are both land (`1`) and adjacent to each other horizontally or vertically. Return _an integer_ representing the number of distinct islands. Note that islands are considered distinct if and only if their shapes are different (i.e., one island cannot be exactly transformed into another by rotating or flipping). --- Note: The remaining content should include a function signature and examples with explanations, which are not part of the current task output.","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = set() distinct_islands = set() def dfs(r, c, pos, origin): stack = [(r, c, pos)] shape = [] while stack: curr_r, curr_c, pos = stack.pop() if (curr_r, curr_c) in visited or not (0 <= curr_r < rows and 0 <= curr_c < cols) or grid[curr_r][curr_c] == 0: continue visited.add((curr_r, curr_c)) shape.append((pos[0] - origin[0], pos[1] - origin[1])) for dr, dc, direction in [(1, 0, (1, 0)), (-1, 0, (-1, 0)), (0, 1, (0, 1)), (0, -1, (0, -1))]: stack.append((curr_r + dr, curr_c + dc, (pos[0] + direction[0], pos[1] + direction[1]))) return tuple(shape) for r in range(rows): for c in range(cols): if grid[r][c] == 1 and (r, c) not in visited: island_shape = dfs(r, c, (0, 0), (0, 0)) distinct_islands.add(island_shape) return len(distinct_islands)"},{"question":"You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount cannot be made up by any combination of the coins, return `-1`. You may assume that you have an infinite number of each kind of coin. Implement the function: * `int coinChange(int[] coins, int amount)` which returns the minimum number of coins needed, or `-1` if it is impossible to make the amount with the given coins.","solution":"def coinChange(coins, amount): Finds the minimum number of coins needed to make up the given amount. Returns -1 if the amount cannot be made up by any combination of the coins. # Initialize DP table with a value greater than the highest possible number of coins needed dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make amount 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"You are given a matrix of integers `grid` representing a grid of a dungeon. The knight starts at the top-left corner of the grid and can only move to the right or down. Each cell contains an integer which represents the health points the knight will gain or lose upon entering that cell (negative values mean losing health points). The knight must ensure that his health never drops to zero or below at any point on his journey. Initially, the knight has very low health but the minimum health points upon entering any cell should always remain positive. Return the minimum initial health points the knight needs to start with so that he can reach the bottom-right corner of the grid without his health dropping to zero or below at any point.","solution":"def min_initial_health(grid): Calculate the minimum initial health needed for the knight to traverse the dungeon. The knight can only move right or down and must keep his health above 0 at all times. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Bottom-right cell (target) dp[-1][-1] = max(1, 1 - grid[-1][-1]) # Last row (moving left) for j in range(n - 2, -1, -1): dp[-1][j] = max(1, dp[-1][j + 1] - grid[-1][j]) # Last column (moving up) for i in range(m - 2, -1, -1): dp[i][-1] = max(1, dp[i + 1][-1] - grid[i][-1]) # Fill the rest of the dp table for i in range(m - 2, -1, -1): for j in range(n - 2, -1, -1): min_health_on_exit = min(dp[i + 1][j], dp[i][j + 1]) dp[i][j] = max(1, min_health_on_exit - grid[i][j]) return dp[0][0]"},{"question":"Given a sorted array of integers `arr` and an integer `N`, return a list of the N integers that are closest to a given target number `target`. The result should also be sorted in ascending order. If there is a tie between two numbers, the smaller number should be chosen. For example, if `arr = [1, 2, 3, 4, 5]`, `N = 4`, and `target = 3`, the result should be `[1, 2, 3, 4]`. Another example, if `arr = [1, 2, 3, 4, 5]`, `N = 4`, and `target = -1`, the result should be `[1, 2, 3, 4]`. Return the list of `N` closest integers to `target` in ascending order.","solution":"def find_closest_numbers(arr, N, target): Returns a list of N integers from the sorted array `arr` that are closest to `target`. If there is a tie between two numbers, the smaller number is chosen. arr.sort() closest_numbers = sorted(arr, key=lambda x: (abs(x - target), x))[:N] return sorted(closest_numbers)"},{"question":"[Question]: Given a list of non-negative integers `nums`, rearrange the list such that the concatenation of its numbers forms the largest possible integer. Since the result may be very large, return it as a string rather than an integer. You may assume that every number in `nums` is non-negative.","solution":"from functools import cmp_to_key def largest_number(nums): Given a list of non-negative integers nums, rearrange the list such that the concatenation of its numbers forms the largest possible integer. Returns the result as a string. def compare(x, y): return (1 if x + y < y + x else -1) if x + y != y + x else 0 # Convert integers to strings since we need to concatenate nums_str = list(map(str, nums)) # Sort the array with the custom comparator nums_str.sort(key=cmp_to_key(compare)) # If the highest number is \'0\', return \'0\'; otherwise, join the sorted array if nums_str[0] == \'0\': return \'0\' else: return \'\'.join(nums_str)"},{"question":"Given a list of integers `arr` and an integer `k`, return the maximum average of any contiguous subarray of length `k`. A contiguous subarray of length `k` is a subarray that consists of `k` consecutive elements from `arr`. For example, the contiguous subarrays of length `3` for the array `[1, 12, -5, -6, 50, 3]` are `[1, 12, -5]`, `[12, -5, -6]`, `[-5, -6, 50]`, and `[-6, 50, 3]`. Return a floating point number representing the maximum average.","solution":"def find_max_average(arr, k): Returns the maximum average of any contiguous subarray of length k. Parameters: arr (list of int): The input list of integers. k (int): The length of the subarray. Returns: float: The maximum average of any contiguous subarray of length k. if not arr or k <= 0 or k > len(arr): return 0.0 # Calculate the sum of the first k elements. current_sum = sum(arr[:k]) max_sum = current_sum # Use a sliding window to find the maximum sum of any contiguous subarray of length k. for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) # Return the maximum average return max_sum / k"},{"question":"You are given a string `pattern` and another string `str`. You need to find out if `str` follows the same pattern. Here, following means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `str`. * For example, given `pattern = \\"abba\\"` and `str = \\"dog cat cat dog\\"`, the function should return `true` because each letter in the pattern corresponds to one unique word in the string. Return `true` if `str` follows the `pattern`, otherwise return `false`.","solution":"def word_pattern(pattern, str): Determine if `str` follows the same pattern as `pattern`. Parameters: pattern (str): A pattern containing letters. str (str): A string that contains words separated by spaces. Returns: bool: Returns True if `str` follows the `pattern`, otherwise False. words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for ch, word in zip(pattern, words): if ch in char_to_word: if char_to_word[ch] != word: return False else: char_to_word[ch] = word if word in word_to_char: if word_to_char[word] != ch: return False else: word_to_char[word] = ch return True"},{"question":"You are given an integer matrix `mat` where each cell represents the height of a terrain. The rain water can flow to four possible directions - left, right, up, and down from a cell. The matrix contains mountains (cells with higher values) and valleys (cells with lower values). Cells on the border of the matrix can flow off the matrix. Determine the number of cells from which water can flow to the border of the matrix. Return _the count of such cells_.","solution":"def can_flow_to_border(mat): Determines the number of cells from which water can flow to the border of the matrix. :param mat: List of List of integers where each element represents the height of a cell. :return: Integer count of cells from which water can flow to the border. if not mat or not mat[0]: return 0 rows, cols = len(mat), len(mat[0]) can_flow = set() def dfs(r, c): if (r, c) in can_flow: return can_flow.add((r, c)) for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)): nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and mat[nr][nc] <= mat[r][c]: dfs(nr, nc) # Start DFS from the border cells for r in range(rows): dfs(r, 0) dfs(r, cols - 1) for c in range(cols): dfs(0, c) dfs(rows - 1, c) return len(can_flow)"},{"question":"Given a list of integers called `heights` representing the heights of students standing in a line, where each student can see the student directly in front of them if and only if all the students between them are shorter. Find the number of students who can see the first student in the line. **Constraints**: - Each student is 1-indexed, meaning the first student is at index 1, the second at index 2, and so on. - The list of heights will contain at least one student and at most 1000 students, with each height being a positive integer not greater than 10,000. Return an integer representing the number of students who can see the first student in the line.","solution":"def num_students_can_see_first(heights): Returns the number of students who can see the first student in the line. count = 0 tallest = heights[0] for height in heights: if height <= tallest: count += 1 tallest = max(tallest, height) return count"},{"question":"You are given an array of distinct integers `arr` and an integer `k`. An interval `[i, j]` is defined as _subarray of `arr` starting from index `i` to index `j` (inclusive)_. Find the length of the shortest interval such that the sum of its elements is greater than or equal to `k`. If no such interval exists, return `-1`.","solution":"def shortest_subarray_with_sum_at_least_k(arr, k): Returns the length of the shortest subarray with sum at least k. If no such subarray exists, returns -1. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given an integer array `arr` and an integer `target`. Determine if there are two distinct integers in `arr` that add up to `target`. Return `true` if such a pair exists, otherwise return `false`.","solution":"def has_pair_with_sum(arr, target): Determines if there are two distinct integers in the array that add up to the target. :param arr: List of integers :param target: Integer target sum :return: True if such a pair exists, otherwise False seen_numbers = set() for num in arr: if target - num in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"Given a string `s` consisting of lowercase English letters, recursively remove adjacent duplicate characters in the string. Adjacent duplicates are consecutive characters that are the same. Return the final string after all such duplicate removals have been made. If no adjacent duplicates are present, return the string as is. For example, given the string `s = \\"abbaca\\"`, the output should be `\\"ca\\"` after removing `\\"bb\\"` and the resulting `\\"aa\\"` consecutively.","solution":"def remove_adjacent_duplicates(s): Recursively removes adjacent duplicate characters in the string `s` and returns the final string after all such duplicate removals have been made. :param s: Input string consisting of lowercase English letters :type s: str :return: String after removing all adjacent duplicates :rtype: str # Base case: if the string is empty or has only one character, return it as is if len(s) <= 1: return s # Use a stack to process the string stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the last character if it is the same as the current one else: stack.append(char) # Convert the stack back to a string result = \'\'.join(stack) return result"},{"question":"You are given a list of strings, `words`, where each word consists of lowercase English letters. Find the longest string in the list that can be formed by concatenating other words from the list exactly once each (each word can be used only once). If there is a tie, return the lexicographically smallest string. If no such string exists, return an empty string. For example, given `words = [\\"cat\\", \\"bat\\", \\"rat\\", \\"catbat\\"]`, the output should be `\\"catbat\\"` because it can be formed by concatenating `\\"cat\\"` and `\\"bat\\"`.","solution":"def get_candidates(words): # This helper function generates all possible concatenations of the given words. candidates = set() for i in range(len(words)): for j in range(len(words)): if i != j: candidates.add(words[i] + words[j]) return candidates def longest_concat_word(words): Returns the longest string in the list that can be formed by concatenating other words from the list exactly once. In case of a tie, the lexicographically smallest word is returned. If no such string exists, returns an empty string. candidates = get_candidates(words) valid_words = [word for word in words if word in candidates] if not valid_words: return \\"\\" valid_words.sort(key=lambda x: (-len(x), x)) return valid_words[0]"},{"question":"You are given a list of `tasks` where each task is represented by a unique integer and a list `dependencies` where `dependencies[i] = [a, b]` indicates that task `a` must be completed before task `b`. You need to create a function that returns a possible order of completion for all tasks such that all dependencies are satisfied. If there are multiple correct solutions, return any of them. If it is impossible to complete all tasks due to a circular dependency, return an empty list. **Note**: * Each task can only be completed once. * There are no duplicate dependencies in the list. * The result may be a list of arbitrary order as long as all dependencies are satisfied.","solution":"from collections import defaultdict, deque def find_task_order(tasks, dependencies): Returns a possible order of completion for all tasks such that all dependencies are satisfied. If it is impossible to complete all tasks due to a circular dependency, returns an empty list. :param tasks: List of tasks represented by unique integers :param dependencies: List of dependency pairs [a, b], where a must be completed before b :return: List of tasks in a possible order of completion or an empty list if not possible indegree = {task: 0 for task in tasks} graph = defaultdict(list) for a, b in dependencies: graph[a].append(b) indegree[b] += 1 queue = deque([task for task in tasks if indegree[task] == 0]) order = [] while queue: curr = queue.popleft() order.append(curr) for neighbor in graph[curr]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == len(tasks): return order else: return []"},{"question":"Given a non-empty string `s` consisting of only lowercase English letters and an integer `k`, you need to rearrange the string such that the same characters are at least `k` distance apart from each other. If it is not possible to rearrange the string to satisfy the condition, return an empty string. Otherwise, return any valid rearrangement of the string. For example, if `s = \\"aabbcc\\"` and `k = 3`, one possible rearrangement could be `\\"abcabc\\"`. If `s = \\"aaabc\\"` and `k = 3`, it is not possible to rearrange the string such that the same characters are at least `k` distance apart, so you should return an empty string.","solution":"from heapq import heappush, heappop from collections import Counter, deque def rearrange_string(s, k): if k == 0: return s frequency_map = Counter(s) max_heap = [] for char, freq in frequency_map.items(): heappush(max_heap, (-freq, char)) queue = deque() result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) queue.append((char, freq + 1)) if len(queue) < k: continue char, freq = queue.popleft() if -freq > 0: heappush(max_heap, (freq, char)) if len(result) == len(s): return \'\'.join(result) else: return \\"\\""},{"question":"You are given an array of `n` integers representing the heights of a series of buildings. A building with height `h` casts a shadow that extends exactly `h` units to its right. Determine the total number of distinct buildings that are fully visible from the left side, where a building is considered fully visible if it is not covered by the shadow of any previous building.","solution":"def count_visible_buildings(heights): Given an array of building heights, returns the count of distinct fully visible buildings from the left side. if not heights: return 0 visible_count = 1 max_height = heights[0] for i in range(1, len(heights)): if heights[i] > max_height: visible_count += 1 max_height = heights[i] return visible_count"},{"question":"You are given a **0-indexed** integer array `nums`. Your task is to determine if it is possible to reorder the elements of `nums` such that the sum of every pair of adjacent elements is **odd**. Return `true` if it is possible, otherwise return `false`. Note that you are allowed to rearrange the elements in any order.","solution":"def can_reorder_to_odd_sums(nums): Determines if it is possible to reorder the elements of nums such that the sum of every pair of adjacent elements is odd. Args: nums (list): A list of integers. Returns: bool: True if possible, False otherwise. num_odd = sum(1 for num in nums if num % 2 != 0) num_even = len(nums) - num_odd # A valid reordering is only possible if the number of odd and even elements is equal. return num_odd == num_even"},{"question":"Given a **0-indexed** integer array `arr` and an integer `d`, return the maximum length of a subsequence that can be obtained by adding exactly `d` to one element of the subsequence. A **subsequence** is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. The **length** of a subsequence is the number of elements it contains.","solution":"def max_length_subsequence_with_d(arr, d): Returns the maximum length of a subsequence that can be obtained by adding exactly `d` to one element of the subsequence. n = len(arr) max_len = 0 for i in range(n): current_len = 1 # Starting with the current element current_val = arr[i] + d for j in range(i + 1, n): if arr[j] == current_val: current_len += 1 current_val += d max_len = max(max_len, current_len) return max_len"},{"question":"You are given a binary tree where each node contains an integer value. Write a function to return the sum of the values of all nodes with an even-valued grandparent. A node\'s grandparent is its parent\'s parent, and may not exist. If there are no such nodes with an even-valued grandparent, return 0. A binary tree is defined as follows: ``` struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; ``` Your function signature should be: ```cpp int sumEvenGrandparent(TreeNode* root); ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sumEvenGrandparent(root): def dfs(node, parent, grandparent): if not node: return 0 sum_left = dfs(node.left, node, parent) sum_right = dfs(node.right, node, parent) sum_current = 0 if grandparent and grandparent.val % 2 == 0: sum_current += node.val return sum_current + sum_left + sum_right return dfs(root, None, None)"},{"question":"Given a string `s` consisting of only the characters \'a\', \'b\', and \'c\', you are to perform the following operations to make sure that no three consecutive characters are the same: 1. You can replace any character in the string with any of the characters \'a\', \'b\', or \'c\'. 2. You should minimize the number of replacements required. Return the minimum number of replacements needed to ensure that no three consecutive characters in the string are the same.","solution":"def minimize_replacements(s): Given a string consisting of characters \'a\', \'b\', and \'c\', this function returns the minimum number of replacements needed to ensure that no three consecutive characters are the same. if len(s) < 3: return 0 replacements = 0 s = list(s) for i in range(2, len(s)): if s[i] == s[i-1] == s[i-2]: replacements += 1 # Choose a different character that is not equal to the previous two characters for replacement in \'abc\': if replacement != s[i-1]: s[i] = replacement break return replacements"},{"question":"You are given a string `s` containing only the characters \'a\', \'b\', and \'c\'. You can perform any number of operations on this string. In each operation, you can choose any two consecutive equal characters and remove them, resulting in the concatenation of the remaining parts of the string. Return _the length_ of the _smallest string_ that you can obtain after any number of such operations.","solution":"def smallest_string_length(s): Returns the length of the smallest string that can be obtained by removing consecutive equal characters any number of times. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` positive integers, and an integer `target`. You play a game with the following rules: - You start by selecting an initial number in `nums` and coloring it green. - You can only color a number green if it shares a common divisor greater than 1 with at least one already green-colored number. - You win if you can color at least one number such that the sum of all green-colored numbers equals `target`. Return whether it is possible to win the game.","solution":"from math import gcd def can_win(nums, target): Determines if it is possible to win the game by coloring numbers in nums such that their sum equals target. n = len(nums) dp = [False] * (target + 1) def helper(available_nums, cur_sum): if cur_sum == target: return True if cur_sum > target: return False for i, num in enumerate(available_nums): if cur_sum + num <= target: next_available_nums = [x for j, x in enumerate(available_nums) if j != i and gcd(x, num) > 1] if helper(next_available_nums, cur_sum + num): return True return False for num in nums: if helper([x for x in nums if x != num and gcd(x, num) > 1], num): return True return False"},{"question":"Write a function `diagonalTraverse(matrix)` that takes a 2D array `matrix` and returns all elements of the matrix in a diagonal order. The traversal should start from the top-left element, moving up-right diagonally until it reaches the boundary, after which it switches direction to down-left diagonally, continuing this pattern. If the matrix has `m` rows and `n` columns, your function should return a list of `m * n` integers representing the elements in order of traversal.","solution":"def diagonalTraverse(matrix): Returns all elements of the matrix in diagonal order. :param matrix: List of lists representing the 2D matrix. :return: List of integers representing the elements in diagonal order. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] diag_map = {} # Group elements on the same diagonals together for i in range(m): for j in range(n): if i + j not in diag_map: diag_map[i + j] = [] diag_map[i + j].append(matrix[i][j]) # Collect the diagonals into the result list for k in range(m + n - 1): if k % 2 == 0: # Even numbered diagonals go in reverse order result.extend(diag_map[k][::-1]) else: # Odd numbered diagonals go in regular order result.extend(diag_map[k]) return result"},{"question":"You are given an **m x n** matrix `matrix` consisting of non-negative integers. Your task is to find the number of distinct paths from the top-left corner to the bottom-right corner of the matrix. You can only move either **down** or **right** at any point in time. Additionally, certain cells are **blocked**, and you cannot move through them. A blocked cell is represented by a `-1` in the matrix while all other cells will contain a non-negative integer. Return the number of distinct paths from the top-left to the bottom-right corner of the matrix. If there is no valid path, return `0`.","solution":"def unique_paths_with_obstacles(matrix): m, n = len(matrix), len(matrix[0]) if matrix[0][0] == -1 or matrix[m-1][n-1] == -1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 if matrix[0][0] != -1 else 0 for i in range(m): for j in range(n): if matrix[i][j] == -1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"[Question]: You are given a list of `words` and a string `order` that represents the lexicographical order of an alien language with distinct characters. Determine if the `words` are sorted lexicographically according to the `order`. Implement the `Solution` class: * `Solution(String[] words, String order)` Initializes the object with the list of `words` and the lexicographical `order` of the alien language. * `boolean isAlienSorted()` Returns `true` if the `words` are sorted according to the given `order`, otherwise returns `false`.","solution":"class Solution: def __init__(self, words, order): self.words = words self.order = order self.order_map = {char: index for index, char in enumerate(order)} def isAlienSorted(self): def compare(word1, word2): i = 0 while i < len(word1) and i < len(word2): if word1[i] != word2[i]: return self.order_map[word1[i]] - self.order_map[word2[i]] i += 1 return len(word1) - len(word2) for i in range(len(self.words) - 1): if compare(self.words[i], self.words[i + 1]) > 0: return False return True"},{"question":"You are given an integer array `arr` and an integer `d`. A subsequence is a sequence derived from the array by deleting some or no elements without changing the order of the remaining elements. A subsequence is called **distinctively spaced** if the difference between any two consecutive elements is at least `d`. Return _the length of the longest distinctively spaced subsequence among all possible subsequences of `arr`_.","solution":"def longestDistinctivelySpacedSubsequence(arr, d): n = len(arr) if n == 0: return 0 # dp[i] will store the length of the longest distinctively spaced subsequence ending at index i dp = [1] * n # Iterate through each element to find a valid distinctively spaced subsequence for i in range(n): for j in range(i): if abs(arr[i] - arr[j]) >= d: dp[i] = max(dp[i], dp[j] + 1) # The result is the maximum value in dp array return max(dp)"},{"question":"You are given a list of `n` records titled `records` where each record is represented as a list containing exactly two integers, `[start_i, end_i]`. Each record `[start_i, end_i]` signifies that an event starts at time `start_i` and ends at time `end_i`. Two events are considered to **overlap** if one event starts before or when the other event ends and ends after or when the other event starts. Your task is to return _the maximum number of events that can be attended without any overlap_.","solution":"def max_non_overlapping_events(records): Returns the maximum number of non-overlapping events that can be attended. Each record is represented as a list containing exactly two integers, [start, end]. if not records: return 0 # Sort the events by their end time. records.sort(key=lambda x: x[1]) # Initialize the end time of the last attended event to a very small value. last_end_time = float(\'-inf\') count = 0 for start, end in records: if start >= last_end_time: # If the current event starts after or when the last attended event ends, attend it. last_end_time = end count += 1 return count"},{"question":"You are given a string `s` that consists of only digits. Return the sum of all possible unique substrings of `s` that can be formed. The substrings can be of any length from 1 to the size of the string itself, and the sum should be calculated by treating each substring as an integer.","solution":"def sum_of_unique_substrings(s): Calculate the sum of all possible unique substrings of the given string s. unique_substrs = set() for i in range(len(s)): for j in range(i+1, len(s)+1): unique_substrs.add(s[i:j]) total_sum = sum(int(substr) for substr in unique_substrs) return total_sum"},{"question":"You are given an integer array `balls` of length `n` where `balls[i]` represents the number of balls of the `i-th` type you have. You can perform the following operation as many times as you want: select any two **different** types of balls, and remove one ball of each type. Your goal is to minimize the number of balls remaining after performing the operations. Return _the minimum number of balls remaining_.","solution":"def min_remaining_balls(balls): Given an integer array balls where balls[i] represents the number of balls of the ith type, returns the minimum number of balls remaining after repeatedly performing the operation of removing one ball each from any two different types of balls. :param balls: List[int] - array representing the number of balls of each type :return: int - minimum number of balls remaining total_balls = sum(balls) if total_balls % 2 == 0: return 0 else: return 1"},{"question":"Write a function that takes an integer `n` and returns an integer representing the total number of distinct ways to climb to the top. Each time you can either climb `1` or `2` steps. Note that given `n` will be a positive integer.","solution":"def climb_stairs(n): Returns the number of distinct ways to climb to the top of a staircase with `n` steps, where each time you can either climb 1 or 2 steps. if n <= 2: return n ways = [0] * (n + 1) ways[1] = 1 ways[2] = 2 for i in range(3, n + 1): ways[i] = ways[i - 1] + ways[i - 2] return ways[n]"},{"question":"You are given a square matrix `matrix` of integers where each cell contains an integer representing the cost of stepping on that cell. Starting from the top-left corner of the matrix, your task is to reach the bottom-right corner of the matrix with minimum cost. You can move to adjacent cells either to the right or down. Return the minimum cost to reach the bottom-right corner of the matrix from the top-left corner.","solution":"def min_cost_path(matrix): Find the minimum cost path from top-left to bottom-right in a grid where you can only move right or down. :param matrix: List of Lists of integers representing the cost grid :return: Integer representing the minimum cost to reach the bottom-right corner if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Create a DP table to store the minimum cost path dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[rows-1][cols-1]"},{"question":"You are given a 2D list of integers `grid` representing a map where each positive integer represents land and zeros represent water. A bridge can be constructed to connect any two pieces of land if they are adjacent either horizontally or vertically. Return the number of distinct islands (connected components of land). An island is composed of cells consisting of only land and connected 4-directionally (horizontal or vertical). Two islands are considered distinct if there is a cell in one island that is not in the other. Implement the function `int numDistinctIslands(List<List<int>> grid)` that takes a 2D list `grid` and returns the number of distinct islands.","solution":"def numDistinctIslands(grid): if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c, direction, shape): if (r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or (r, c) in visited): return visited.add((r, c)) shape.append(direction) dfs(r + 1, c, \\"d\\", shape) # down dfs(r - 1, c, \\"u\\", shape) # up dfs(r, c + 1, \\"r\\", shape) # right dfs(r, c - 1, \\"l\\", shape) # left shape.append(\\"b\\") # backtrack distinct_islands = set() for r in range(rows): for c in range(cols): if grid[r][c] == 1 and (r, c) not in visited: shape = [] dfs(r, c, \\"o\\", shape) # origin distinct_islands.add(tuple(shape)) return len(distinct_islands)"},{"question":"You are given a **0-indexed** string `s` consisting of only characters \\"A\\" and \\"B\\". You are allowed to perform multiple operations on the string, where in each operation you can choose a non-empty substring made of the same character and remove it from the string, and then concatenate the remaining parts of the string together. Calculate and return _the minimum number of operations needed to make the string `s` empty_.","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations needed to make the string `s` empty. if not s: # if the string is empty return 0 # Count the number of contiguous blocks of characters count_blocks = 1 for i in range(1, len(s)): if s[i] != s[i - 1]: count_blocks += 1 return count_blocks"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `target`. Determine if there exist three elements in `nums` whose sum is exactly equal to `target`. Return _true if there exist three such elements, otherwise return false_.","solution":"from itertools import combinations def three_sum(nums, target): Determines if there exist three elements in nums whose sum is exactly equal to target. Args: nums (list of int): List of integers. target (int): Target sum. Returns: bool: True if there exist three elements in nums whose sum is exactly equal to target, otherwise False. for comb in combinations(nums, 3): if sum(comb) == target: return True return False"},{"question":"A **0-indexed** string `s` of length `n` is said to be **repeating** if one of its substrings at the start of the string (excluding the empty substring) can be concatenated some number of times to form the entire string. For example, the string `\\"abab\\"` is repeating because the substring `\\"ab\\"` can be concatenated to form `\\"abab\\"`. However, the string `\\"abcd\\"` is not repeating. You are given a **0-indexed** 2D integer array `queries`, where `queries[i] = [start_i, end_i]` contains the indices defining a substring of `s`. Your task is to determine if the substring `s[start_i : end_i + 1]` is **repeating** for each query. Return _a **boolean array** `result`_ where `result.length == queries.length`_ and the _`i-th`_ value of _`result`_ is _`true`_ if the substring for _`queries[i]`_ is **repeating**, and _`false`_ otherwise_.","solution":"def is_repeating(s, queries): Determines if substrings specified by queries in the given string s are repeating. Args: s (str): The input string. queries (list of lists): List of queries with each query containing [start, end]. Returns: list of bool: List of boolean values indicating if the substrings are repeating. def check_repeating(substring): sub_len = len(substring) for i in range(1, sub_len//2 + 1): if sub_len % i == 0: if substring[:i] * (sub_len // i) == substring: return True return False result = [] for query in queries: start, end = query substring = s[start:end + 1] result.append(check_repeating(substring)) return result"},{"question":"Given an array of integers `arr`, create a function that returns an array of length `n` where each element at index `i` is the product of all the numbers in the original array except the one at `i` without using division.","solution":"def product_except_self(arr): Returns an array of length n where each element at index i is the product of all the numbers in the original array except the one at i. n = len(arr) if n == 0: return [] # Create arrays to hold products of all elements to the left and right of each element left_products = [1] * n right_products = [1] * n # Fill the left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Fill the right_products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Calculate the result by multiplying elements of left_products and right_products result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to determine if there exists a subset of `nums` that adds up to `target` under the following constraints: * Each number in `nums` can only be used once. * The subset must contain **at least 2 elements**. Return `True` if such a subset exists, otherwise return `False`.","solution":"from itertools import combinations def subset_sum(nums, target): Determine if there exists a subset of `nums` that adds up to `target` and contains at least 2 elements. if len(nums) < 2: return False # If there are fewer than 2 elements, it\'s impossible # Check all possible subsets of length 2 or more for r in range(2, len(nums) + 1): for subset in combinations(nums, r): if sum(subset) == target: return True return False"},{"question":"You are given a string consisting of lowercase letters and digits. You need to find the length of the longest substring without repeating characters. Your task is to implement a function that returns the length of this longest substring.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_set = set() left = 0 max_len = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a string `text`, return _an integer array of length 26 where each element_ `i` _represents the number of occurrences of the_ `i-th` _letter of the alphabet in_ `text`. _Assume the input string contains only lowercase alphabetical characters._","solution":"def count_letter_occurrences(text): Returns an integer array of length 26 where each element represents the number of occurrences of the i-th letter of the alphabet in `text`. counts = [0] * 26 for char in text: index = ord(char) - ord(\'a\') counts[index] += 1 return counts"},{"question":"A **magic square** is a grid of numbers such that the sum of numbers in each row, column, and both main diagonals are the same. Given an `n x n` matrix `grid`, write a function to determine if the grid forms a magic square. If the grid is a magic square, return the magic constant (the common sum). If it is not a magic square, return `-1`. For example, given the matrix: ``` [ [2, 7, 6], [9, 5, 1], [4, 3, 8] ] ``` The function should return `15`, as the grid is a magic square with a magic constant of `15`.","solution":"def is_magic_square(grid): Determine if the given n x n grid is a magic square. :param grid: List of lists representing the grid :return: The magic constant if the grid is a magic square, else -1 n = len(grid) if any(len(row) != n for row in grid): return -1 # Calculate the magic constant using the sum of the first row magic_constant = sum(grid[0]) # Check all rows for row in grid: if sum(row) != magic_constant: return -1 # Check all columns for col in range(n): if sum(grid[row][col] for row in range(n)) != magic_constant: return -1 # Check the main diagonal if sum(grid[i][i] for i in range(n)) != magic_constant: return -1 # Check the anti-diagonal if sum(grid[i][n - i - 1] for i in range(n)) != magic_constant: return -1 return magic_constant"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `threshold`. A **subarray** of `arr` is called a \\"good subarray\\" if the sum of the elements in the subarray is **greater than or equal to** `threshold`. Return the **minimum length** of a \\"good subarray\\". If no such subarray exists, return `-1`.","solution":"def min_length_good_subarray(arr, threshold): Returns the minimum length of a good subarray where the sum is >= threshold. If no such subarray exists, returns -1. n = len(arr) min_length = float(\'inf\') for start in range(n): current_sum = 0 for end in range(start, n): current_sum += arr[end] if current_sum >= threshold: min_length = min(min_length, end - start + 1) break return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. If you are allowed to pick `k` indices from the list such that the sum of the values at those indices is the maximum possible. You need to determine the maximum sum you can achieve by picking exactly `k` elements from the list. Return _the maximum sum possible by selecting `k` elements from_ `nums`.","solution":"def max_sum_k_elements(nums, k): Returns the maximum sum possible by selecting k elements from nums. If k is greater than the length of nums or nums is empty, return 0. if not nums or k <= 0: return 0 if k >= len(nums): return sum(nums) nums.sort(reverse=True) return sum(nums[:k])"},{"question":"You are given an array of integers `heights` representing the height of buildings along a street from left to right. A building can cast a shadow on the buildings to its right if it is taller than those buildings. Write a function to determine the number of buildings that have their view partially or completely blocked by the shadows of taller buildings to their left. Return the number of such buildings.","solution":"def blocked_views(heights): Determines the number of buildings that have their view partially or completely blocked by the shadows of taller buildings to their left. Parameters: heights (list of int): List of heights of buildings along a street. Returns: int: Number of buildings with blocked views. max_height_so_far = 0 blocked_count = 0 for height in heights: if height <= max_height_so_far: blocked_count += 1 else: max_height_so_far = height return blocked_count"},{"question":"Given a list of `n` integers, return the length of the longest consecutive sequence of numbers. The sequence can be in any order but must consist of consecutive integers. For example, in the list `[100, 4, 200, 1, 3, 2]`, the longest consecutive sequence is `[1, 2, 3, 4]`, so the length is `4`. Write a function with the following signature: ```python def longest_consecutive_sequence(nums: List[int]) -> int: pass ```","solution":"def longest_consecutive_sequence(nums): if not nums: return 0 nums_set = set(nums) max_length = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"Given an integer `n`, find the number of different ways to write `n` as the sum of consecutive positive integers. Two sums are considered different if they contain different numbers of terms. Return _the number of different ways to write `n` as the sum of consecutive positive integers_.","solution":"def count_consecutive_sum_ways(n): Returns the number of different ways to write n as the sum of consecutive positive integers. count = 0 k = 1 while (k * (k + 1)) / 2 <= n: if (n - (k * (k + 1)) // 2) % k == 0: count += 1 k += 1 return count"},{"question":"You are given a 2D grid of characters and a target word. Each cell in the grid contains a single letter. You can move to adjacent cells horizontally or vertically to form the word. You cannot reuse the same cell more than once. Determine if the word exists in the grid. Return _`true` if the word exists and `false` otherwise_.","solution":"def exist(board, word): def dfs(board, word, i, j, k): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False tmp, board[i][j] = board[i][j], \'#\' res = dfs(board, word, i + 1, j, k + 1) or dfs(board, word, i - 1, j, k + 1) or dfs(board, word, i, j + 1, k + 1) or dfs(board, word, i, j - 1, k + 1) board[i][j] = tmp return res for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"You are given an integer array `nums` and an integer `target`. The array `nums` is sorted in non-decreasing order and contains unique elements. Write a function that returns the indices of the two numbers in `nums` such that their sum is equal to `target`. Return the indices as a list of two integers, and the returned list should have the smaller index first and the larger index second. If there are no such indices, return an empty list. Your solution should use an algorithm with a time complexity of O(n).","solution":"def two_sum(nums, target): Returns the indices of the two numbers in \'nums\' such that their sum is equal to \'target\'. Args: nums (List[int]): A list of integers sorted in non-decreasing order. target (int): The target sum for which we need to find indices. Returns: List[int]: A list containing the two indices, or an empty list if no such indices exist. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"You are given an `m x n` 2D grid initialized with these three possible values: - `-1` for a wall or an obstacle, - `0` for an empty room, - `2147483647` (2^31 - 1) for a gate. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave the value as `2147483647` (representing infinity). - For example, given the 2D grid: ``` [[2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647]] ``` Return the modified grid as: ``` [[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]] ```","solution":"from collections import deque def walls_and_gates(rooms): if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) gates = [(i, j) for i in range(m) for j in range(n) if rooms[i][j] == 0] queue = deque(gates) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"You are given an array of integers `heights` representing the heights of buildings along a street, where the width of each building is 1. Each building has a unique height. The goal is to construct a skyline which is the outer contour of the silhouette formed by these buildings when viewed from a distance. The skyline should be represented as a list of key points, where each key point is a pair `(x, y)` denoting the location of a **vertical line** starting from position `x` and ending at height `y`. The key points should be returned in the correct order, forming a series of **left-to-right** horizontal line segments. Return _the list of key points that form the skyline_. Example: Input: heights = [3, 1, 4, 2] Output: [[0, 3], [1, 1], [2, 4], [3, 2]] Explanation: The skyline forms a distinct series of horizontal and vertical lines going through each building height in the correct left-to-right order.","solution":"def get_skyline(heights): Returns the skyline formed by the buildings represented by their heights. n = len(heights) key_points = [] for i in range(n): key_points.append([i, heights[i]]) return key_points"},{"question":"You are given a representative integer `n` indicating the number of nodes and a list of undirected edges `edges`, where each `edges[i] = [ui, vi]` indicates there is an edge between nodes `ui` and `vi`. Return the minimum number of edges you need to remove to make the graph a forest, i.e., a series of trees with no cycles. A tree is a connected graph with no cycles, and a forest is a collection of trees.","solution":"def min_edges_to_remove(n, edges): Given a graph with `n` nodes and `edges`, return the minimum number of edges to remove to make the graph a forest. # A function to find the root of the node def find(x): if parent[x] == x: return x parent[x] = find(parent[x]) return parent[x] # A function to union two subsets def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return True return False parent = list(range(n)) # Starting with none of the nodes connected extra_edges = 0 for u, v in edges: if not union(u, v): extra_edges += 1 return extra_edges"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. An interval from index `i` to index `j` (`i <= j`) is called a **good interval** if the sum of the elements in that interval is divisible by `k`. Return the total number of **good intervals** in the array `nums`.","solution":"def count_good_intervals(nums, k): Returns the total number of good intervals in the array, where a good interval is defined as an interval [i, j] (i <= j) such that the sum of the elements in that interval is divisible by k. good_intervals_count = 0 prefix_sums = {0: 1} current_sum = 0 for num in nums: current_sum += num remainder = current_sum % k if remainder < 0: remainder += k if remainder in prefix_sums: good_intervals_count += prefix_sums[remainder] if remainder in prefix_sums: prefix_sums[remainder] += 1 else: prefix_sums[remainder] = 1 return good_intervals_count"},{"question":"Given an array of integers `arr` and an integer `k`, return the `k-th` smallest element in the array after removing any duplicate values from the array. The array can contain both positive and negative integers. Ensure your solution has a time complexity of `O(n log n)`.","solution":"def kth_smallest_unique_element(arr, k): Returns the k-th smallest element in the array after removing duplicates. unique_elements = list(set(arr)) # Remove duplicates unique_elements.sort() # Sort the unique elements return unique_elements[k-1] # Return the k-th smallest element (1-based index)"},{"question":"You are given the head of a singly linked list. The list can be represented as: `L0 → L1 → … → Ln - 1 → Ln`. Reorder the list to be in the following form: `L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …`. You must do this in-place without altering the nodes\' values, only their pointers. Return the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): Reorder the given linked list in the specific form. Args: head (ListNode): The head of the singly linked list. Returns: None: Do not return anything, modify the list in-place. if not head or not head.next: return # Step 1: Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Step 3: Merge the two halves first, second = head, prev while second.next: first_next, second_next = first.next, second.next first.next = second second.next = first_next first = first_next second = second_next # Helper function to convert list to linked list def array_to_linked_list(array): if not array: return None head = ListNode(array[0]) current = head for value in array[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to list def linked_list_to_array(head): array = [] current = head while current: array.append(current.val) current = current.next return array"},{"question":"Given two arrays of integers `arr1` and `arr2`, return the maximum length of a subarray that appears in both arrays. For example: - Input: `arr1 = [1,2,3,2,1]`, `arr2 = [3,2,1,4,7]` - Output: `3` Explanation: The longest subarray that appears in both arrays is `[3,2,1]` with length `3`.","solution":"def find_length(arr1, arr2): Returns the maximum length of a subarray that appears in both arr1 and arr2. len1, len2 = len(arr1), len(arr2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] max_len = 0 for i in range(1, len1 + 1): for j in range(1, len2 + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_len = max(max_len, dp[i][j]) return max_len"},{"question":"Given an integer array `nums`, you need to find a contiguous subarray within an array (containing at least one number) which has the largest product. Return _the largest product_ of that contiguous subarray.","solution":"def max_product(nums): Returns the largest product of a contiguous subarray within the array nums. if not nums: return 0 # Initialize variables to store the maximum product, the minimum product, and the result max_so_far = nums[0] min_so_far = nums[0] result = nums[0] # Iterate through the array, updating the max and min products for n in nums[1:]: if n < 0: max_so_far, min_so_far = min_so_far, max_so_far max_so_far = max(n, max_so_far * n) min_so_far = min(n, min_so_far * n) # Update the result if the current max product is larger result = max(result, max_so_far) return result"},{"question":"Given an array of integers `arr`, return _an array where each element_ `i` _is replaced by the product of all other elements in_ `arr` _except_ `arr[i]`. You must solve it without using division and in linear time.","solution":"def product_except_self(arr): n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n # Compute left running product for each element for i in range(1, n): left_products[i] = left_products[i-1] * arr[i-1] # Compute right running product for each element for i in range(n-2, -1, -1): right_products[i] = right_products[i+1] * arr[i+1] # Combine them to get the final result for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"You are given an integer array `prices` representing the prices of various items in a store, and an integer `k`. You are also given a 2D array `discounts`, where `discounts[i] = [li, ri, ai, bi]` indicates that from the `li-th` to the `ri-th` item in the store, you can choose items such that every `ai-th` item can be bought at `bi` percent off. The value of `bi` is between `0` and `100` inclusive. Your task is to determine the minimum cost to buy at least `k` items from the store using the discounts available. Return an integer representing the minimum cost to buy `k` items. If it\'s not possible to buy `k` items, return `-1`.","solution":"import heapq def min_cost_to_buy_k_items(prices, k, discounts): discounted_prices = [] # Apply the discounts for li, ri, ai, bi in discounts: for i in range(li, ri + 1): adjusted_price = prices[i] * (1 - bi / 100) discounted_prices.append(adjusted_price) # Add non-discounted prices as well for i in range(len(prices)): if not any(li <= i <= ri for li, ri, ai, bi in discounts): discounted_prices.append(prices[i]) if len(discounted_prices) < k: return -1 # Get the smallest k prices heapq.heapify(discounted_prices) total_cost = 0 for _ in range(k): total_cost += heapq.heappop(discounted_prices) return total_cost"},{"question":"A company stores daily transaction records in the form of a nested dictionary. Each key in the dictionary is a day, and the value is another dictionary containing transaction records for that day. Each transaction record consists of a unique transaction ID as the key and the transaction amount as the value. Implement a function that calculates the total transaction amount for each day and returns a dictionary with the daily totals. For example, given the following transaction records: ```python transactions = { \\"2023-10-01\\": {\\"TX1001\\": 100, \\"TX1002\\": 200, \\"TX1003\\": 50}, \\"2023-10-02\\": {\\"TX1004\\": 300, \\"TX1005\\": 150}, \\"2023-10-03\\": {\\"TX1006\\": 75, \\"TX1007\\": 125, \\"TX1008\\": 175}, } ``` The function should return a dictionary with the daily totals: ```python { \\"2023-10-01\\": 350, \\"2023-10-02\\": 450, \\"2023-10-03\\": 375, } ``` Write the function `calculate_daily_totals(transactions: Dict[str, Dict[str, int]]) -> Dict[str, int]` that solves this problem.","solution":"def calculate_daily_totals(transactions): Calculate the total transaction amount for each day and return a dictionary with the daily totals. :param transactions: A dictionary of daily transaction records. :return: A dictionary with the total transaction amount for each day. daily_totals = {} for day, records in transactions.items(): daily_totals[day] = sum(records.values()) return daily_totals"},{"question":"You are given a list of intervals, `intervals`, where `intervals[i] = [starti, endi]` represents a closed interval `[starti, endi]`. The interval length is defined as `endi - starti`. Merge all overlapping intervals, and return _a list of the merged intervals sorted by the starting points_. Two intervals `[a,b]` and `[c,d]` are considered overlapping if `a <= d` and `c <= b`. The intervals should be compared mainly by their `start` value, and if those are equal, by their `end` value.","solution":"def merge_intervals(intervals): Given a list of intervals, this function merges all overlapping intervals and returns a list of the merged intervals sorted by the starting points. if not intervals: return [] # Sort intervals by start time, and if equal then by end time intervals.sort(key=lambda x: (x[0], x[1])) merged = [intervals[0]] for current in intervals[1:]: previous = merged[-1] if current[0] <= previous[1]: # Overlapping intervals # Merge the intervals merged[-1] = [previous[0], max(previous[1], current[1])] else: merged.append(current) return merged"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting of lowercase English letters. A **morphism** is a one-to-one mapping between the characters of `s1` and `s2` such that each character in `s1` maps to a unique character in `s2`. You need to determine if it is possible to create such a morphism. Return `true` if a valid morphism exists, otherwise return `false`.","solution":"def can_form_morphism(s1, s2): Determines if a one-to-one mapping exists between the characters of s1 and s2. :param s1: First string. :param s2: Second string. :return: Boolean - True if a valid morphism exists, otherwise False. # A one-to-one morphism can exist if both strings have unique characters mapped uniquely if len(s1) != len(s2): return False mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for char1, char2 in zip(s1, s2): if char1 in mapping_s1_to_s2: if mapping_s1_to_s2[char1] != char2: return False else: mapping_s1_to_s2[char1] = char2 if char2 in mapping_s2_to_s1: if mapping_s2_to_s1[char2] != char1: return False else: mapping_s2_to_s1[char2] = char1 return True"},{"question":"Given a list of non-negative integers `nums`, represented as strings, return the smallest number possible when these numbers are concatenated together. If the result starts with zeroes (e.g., \\"00032\\"), the leading zeroes should be removed, and only \\"32\\" should be returned. If the final result is \\"0\\", return \\"0\\".","solution":"from functools import cmp_to_key def compare(x, y): Custom comparator function to order strings based on their concatenated result. If \'xy\' < \'yx\', then \'x\' should come before \'y\', otherwise \'y\' should come before \'x\'. if x + y < y + x: return -1 elif x + y > y + x: return 1 else: return 0 def smallest_number(nums): Returns the smallest number possible from the concatenation of the strings in nums. # Sort `nums` based on the custom comparator nums_sorted = sorted(nums, key=cmp_to_key(compare)) # Concatenate the sorted numbers result = \'\'.join(nums_sorted) # Strip leading zeroes result = result.lstrip(\'0\') # Return \'0\' if the result is empty, otherwise return the result return result if result else \'0\'"},{"question":"You are given a string `s` consisting of only lowercase English letters and an integer `k`. You need to construct a new string by choosing some characters from `s` such that the string formed has exactly `k` **distinct** characters. The relative order of the characters must remain the same as in the original string `s`. Return _the length of the **shortest** such string possible. If it is not possible to form a string with exactly_ `k` _distinct characters, return_ `-1`.","solution":"def shortest_substring_with_k_distinct(s, k): Returns the length of the shortest substring of string s that contains exactly k distinct characters. If it\'s not possible to form such a substring, return -1. if k > len(set(s)) or k <= 0: return -1 n = len(s) left = 0 min_len = float(\'inf\') char_map = {} for right in range(n): if s[right] in char_map: char_map[s[right]] += 1 else: char_map[s[right]] = 1 while len(char_map) == k: min_len = min(min_len, right - left + 1) char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given a string `formula` representing a chemical formula, and you need to return a map (or dictionary) that stores the count of each atom in the formula. The formula will contain element names, which start with uppercase characters and may be followed by lowercase characters, and possibly numeric subscripts indicating the number of atoms. For nested parts of the formula enclosed in parentheses, the entire group can have a subscript following it, which multiplies the count of each atom in the group. For example: - `H2O` would result in `{ \\"H\\": 2, \\"O\\": 1 }` - `Mg(OH)2` would result in `{ \\"Mg\\": 1, \\"O\\": 2, \\"H\\": 2 }` - `K4(ON(SO3)2)2` would result in `{ \\"K\\": 4, \\"O\\": 14, \\"N\\": 2, \\"S\\": 4 }` Write a function `countAtoms(formula)` that computes and returns the map (or dictionary) of element counts in the given `formula`.","solution":"import re from collections import defaultdict def countAtoms(formula): def multiply_counts(multi_dict, multiplier): return {k: v * multiplier for k, v in multi_dict.items()} def merge_counts(main_dict, temp_dict): for key, value in temp_dict.items(): main_dict[key] += value def parse_formula(f): stack = [] current_dict = defaultdict(int) i, n = 0, len(f) while i < n: if f[i] == \'(\': stack.append(current_dict) current_dict = defaultdict(int) i += 1 elif f[i] == \')\': i += 1 i_start = i while i < n and f[i].isdigit(): i += 1 multiplier = int(f[i_start:i] or 1) temp_dict = multiply_counts(current_dict, multiplier) current_dict = stack.pop() merge_counts(current_dict, temp_dict) else: i_start = i i += 1 while i < n and f[i].islower(): i += 1 element = f[i_start:i] i_start = i while i < n and f[i].isdigit(): i += 1 count = int(f[i_start:i] or 1) current_dict[element] += count return current_dict return dict(parse_formula(formula))"},{"question":"Given an array of integers `arr` and an integer `x`, partition the array into two subsets such that the sum of elements in subset one is greater than or equal to `x`, and the number of elements in subset one is minimized. Return the elements of subset one. If there are multiple solutions, return any one of them.","solution":"def partition_subset(arr, x): Partition the array into two subsets such that the sum of elements in subset one is greater than or equal to x, and the number of elements in subset one is minimized. Parameters: arr (list of int): The input array of integers. x (int): The required sum of subset one. Returns: list of int: The elements of subset one that meet the criteria. # Sort the array in descending order to get the largest numbers first arr.sort(reverse=True) subset = [] current_sum = 0 for num in arr: if current_sum >= x: break subset.append(num) current_sum += num return subset"},{"question":"You are given two strings, `s1` and `s2`, and you need to make the two strings equal by performing the minimum number of operations. In each operation, you can remove one character from either string. Return the minimum number of operations required to make `s1` and `s2` equal. For example, given `s1 = \\"sea\\"` and `s2 = \\"eat\\"`, you can make `s1` equal to `s2` in 2 operations by removing \'s\' from `s1` and \'t\' from `s2` (or vice versa). # Constraints: - The length of `s1` and `s2` are both between 1 and 1000. - `s1` and `s2` consist of only lowercase English letters.","solution":"def min_operations_to_make_equal(s1, s2): Returns the minimum number of operations required to make s1 and s2 equal. An operation consists of removing one character from either string. m, n = len(s1), len(s2) # Create a table to store the length of longest common subsequence of substrings # lcs_length[i][j] will be the length of lcs of s1[0..i-1] & s2[0..j-1] lcs_length = [[0] * (n + 1) for _ in range(m + 1)] # Build the lcs_length table from bottom right corner for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: lcs_length[i][j] = lcs_length[i - 1][j - 1] + 1 else: lcs_length[i][j] = max(lcs_length[i - 1][j], lcs_length[i][j - 1]) # The number of operations needed is the sum of deletions needed return (m - lcs_length[m][n]) + (n - lcs_length[m][n])"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the longest substring that appears at least twice. This substring may overlap. Return the longest such substring. If there is a tie in the length, you can return any of the longest substrings. Make sure your solution can handle strings up to a length of 10^5 efficiently.","solution":"def longest_repeating_substring(s): Returns the longest substring that appears at least twice in the given string s. n = len(s) # Helper function to check if a substring of length L appears at least twice def check(L): seen = set() for i in range(n - L + 1): substr = s[i:i + L] if substr in seen: return substr seen.add(substr) return \\"\\" # Binary search for the length of the longest substring. left, right = 1, n result = \\"\\" while left <= right: mid = (left + right) // 2 candidate = check(mid) if candidate: result = candidate left = mid + 1 else: right = mid - 1 return result"},{"question":"Consider an aquarium with `m` fish species, each initially containing a certain number of fish. You want to feed them using `p` different feeding patterns. Each feeding pattern has a different impact on the number of fish for each species. These feeding patterns are represented by a 2D list `patterns`, where each `patterns[i]` is a list of integers indicating the change in the fish count for each species when that pattern is applied. You are provided with the initial number of fish for each species in a list `initial`, and an integer `x` representing the number of times you can apply any feeding pattern from the `patterns` list. Your task is to determine the total number of fish for all species after exactly `x` feeding applications. Given the list `initial`, the 2D list `patterns`, and the integer `x`, return the total number of fish after exactly `x` feeding applications.","solution":"def total_fish_after_feedings(initial, patterns, x): Calculate the total number of fish after x feedings using the given patterns. :param initial: List[int], the initial number of fish for each species. :param patterns: List[List[int]], the feeding patterns. :param x: int, the number of feedings to apply. :return: int, the total number of fish after x feedings. m = len(initial) best_pattern = [0] * m for pattern in patterns: for i in range(m): best_pattern[i] = max(best_pattern[i], pattern[i]) final_counts = [initial[i] + x * best_pattern[i] for i in range(m)] return sum(final_counts)"},{"question":"You are given an array of integers representing the heights of `n` buildings in a row, where the width of each building is `1`. The sun rises from the left, so a building can block the view of another building to its right if it is taller. You need to implement a data structure that supports the following operations efficiently: * `BuildingView(int[] heights)`: Initializes the object with the given array of building heights. * `int countVisible()`: Returns the number of buildings that are visible from the left. * `void update(int index, int newHeight)`: Updates the height of the building at the specified index to `newHeight`. Implement the `BuildingView` class to handle these operations.","solution":"class BuildingView: def __init__(self, heights): self.heights = heights self.max_from_left = self._calculate_max_from_left() def _calculate_max_from_left(self): max_heights = [] current_max = float(\'-inf\') for height in self.heights: if height > current_max: max_heights.append(height) current_max = height return max_heights def countVisible(self): return len(self.max_from_left) def update(self, index, newHeight): self.heights[index] = newHeight self.max_from_left = self._calculate_max_from_left()"},{"question":"Given an array of integers where each element appears twice except for one. Write a function to find that single one. Implement your solution without using extra memory, ensuring it has linear time complexity. Your function should return the single element that does not have a pair.","solution":"def single_number(nums): Returns the single element that does not appear twice in the array. Args: nums: List[int] - A list of integers where every element appears twice except for one. Returns: int - The single element that does not have a pair. result = 0 for num in nums: result ^= num return result"},{"question":"You are given an integer array `nums` where the elements are sorted in ascending order, and an integer `target`. Your task is to find whether the `target` exists in the array or not. The catch is that the array is rotated at some unknown pivot (i.e., elements might be shifted left or right). Write a function that returns `true` if `target` is present in the array and `false` otherwise, meeting the complexity requirement of O(log n).","solution":"def search_in_rotated_array(nums, target): Searches for target in a rotated sorted array. Params: nums: List[int] - a list of integers target: int - integer target to be searched Returns: bool - True if target is found, False otherwise if not nums: return False left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return True # If left part is sorted if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # If right part is sorted else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return False"},{"question":"You are given two strings `s1` and `s2`, consisting of lowercase English letters. Your task is to determine if you can **transform** `s1` into `s2` using the following operation: * Choose any character in `s1` and replace it with any other lowercase English letter. You are allowed to use this operation any number of times, but the total number of transformations should be minimized. Return _the **minimum number** of transformations required to change_ `s1` _into_ `s2`, _or_ `-1` _if it is not possible to transform_ `s1` _into_ `s2`.","solution":"def min_transformations(s1, s2): Returns the minimum number of transformations required to change s1 into s2, or -1 if it is not possible to transform s1 into s2. if len(s1) != len(s2): return -1 transformations = 0 for char_s1, char_s2 in zip(s1, s2): if char_s1 != char_s2: transformations += 1 return transformations"},{"question":"You are given an integer array `transactions` where each element represents a positive deposit or a negative withdrawal in your bank account. Your task is to determine if it is possible to rearrange the transactions such that at no point in time the account balance drops below zero. Return _true_ if such a reordering is possible, otherwise return _false_.","solution":"def can_reorder_transactions(transactions): Determines if the transactions can be reordered so that the balance never drops below zero. Args: transactions (list of int): List of integers representing deposits (positive) and withdrawals (negative). Returns: bool: True if the transactions can be reordered to prevent the balance from dropping below zero, otherwise False. current_balance = 0 transactions.sort(reverse=True) for transaction in transactions: current_balance += transaction if current_balance < 0: return False return True"},{"question":"You are given an array of strings `words`. Each string is a word, and it consists of lowercase English letters. Return the total number of pairs `(i, j)` where `0 <= i < j < words.length`, and the concatenation of `words[i] + words[j]` or `words[j] + words[i]` forms a palindrome. For example, given `words = [\\"bat\\", \\"tab\\", \\"cat\\"]`, the pairs (0, 1) and (1, 0) are valid because \\"battab\\" and \\"tabbat\\" are palindromes, but there are no other pairs that form palindromes from the given words. Write a function `palindromePairs` that accepts the list of words and returns an integer representing the number of valid pairs.","solution":"def is_palindrome(word): Helper function to check if a word is a palindrome. return word == word[::-1] def palindromePairs(words): Returns the total number of pairs (i, j) where 0 <= i < j < words.length, and the concatenation of words[i] + words[j] or words[j] + words[i] forms a palindrome. count = 0 for i in range(len(words)): for j in range(i + 1, len(words)): if is_palindrome(words[i] + words[j]): count += 1 if is_palindrome(words[j] + words[i]): count += 1 return count"},{"question":"Given two integer arrays `arr1` and `arr2` of length `n`, your task is to interleave these arrays to form a new array of length `2n` such that the elements from `arr1` appear at the even indices (0-based) and the elements from `arr2` appear at the odd indices. Return the interleaved array. For example, if `arr1 = [1, 2, 3]` and `arr2 = [4, 5, 6]`, the interleaved array should be `[1, 4, 2, 5, 3, 6]`.","solution":"def interleave_arrays(arr1, arr2): Interleaves two arrays of the same length such that elements from arr1 appear at even indices and elements from arr2 appear at odd indices. if len(arr1) != len(arr2): raise ValueError(\\"Arrays must be of the same length\\") interleaved = [None] * (len(arr1) + len(arr2)) interleaved[::2] = arr1 interleaved[1::2] = arr2 return interleaved"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to determine whether there are two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] == k` and the absolute difference between `i` and `j` is at most `t`. Return `true` if such pairs exist, otherwise return `false`. Note that the indices must be different for the sum to be valid, but the constraint on their absolute difference should be adhered to while checking the conditions.","solution":"def check_sum_within_distance(nums, k, t): Check if there are two indices i and j such that nums[i] + nums[j] == k and the absolute difference between i and j is at most t. Parameters: nums (list of int): The list of integers. k (int): The target sum value. t (int): The maximum allowable distance between indices i and j. Returns: bool: True if such a pair exists, otherwise False. for i in range(len(nums)): for j in range(i + 1, min(i + t + 1, len(nums))): if nums[i] + nums[j] == k: return True return False"},{"question":"You are given two strings `s` and `t` containing only lowercase letters and an integer `k`. You need to determine if it is possible to convert `s` into `t` by performing exactly `k` operations. In one operation, you can choose any character of `s` and change it to any other lowercase English letter. Return `true` if you can transform `s` into `t` in exactly `k` operations, or `false` otherwise.","solution":"def can_convert_string(s, t, k): Returns True if s can be converted to t in exactly k operations, False otherwise. if len(s) != len(t): return False # Count the different characters diff_count = sum(1 for sc, tc in zip(s, t) if sc != tc) # We can convert s to t in exactly k operations if and only if diff_count <= k and # the difference (k - diff_count) is an even number (each change can be undone or # a new change can be made in a pairwise manner). return diff_count <= k and (k - diff_count) % 2 == 0"},{"question":"Given a string `s` of lowercase English letters, we want to form a new string by merging two non-overlapping substrings of `s` and sorting the result in non-decreasing order. Return the lexicographically smallest string that can be obtained by this process.","solution":"def merge_and_sort_substrings(s): Given a string s of lowercase English letters, form a new string by merging two non-overlapping substrings and sorting the result in non-decreasing order. Return the lexicographically smallest string that can be obtained by this process. n = len(s) smallest_string = s # Initialize with the original string for i in range(1, n): left_part = s[:i] right_part = s[i:] merged_string = \'\'.join(sorted(left_part + right_part)) if merged_string < smallest_string: smallest_string = merged_string return smallest_string"},{"question":"You are given a `root` of a binary tree. Each node in the tree contains an integer value. A **good path** is defined as a path from the root to any node where the maximum-value node on that path is unique (i.e., there is no other node in the tree with the same value). Return _the number of unique good paths in the tree._ * For example, given the binary tree: ``` 5 / 4 8 / / 4 7 9 ``` The unique good paths are: `5->4->4`, `5->8->7`, and `5->8->9`. The node with value `5` is not part of any unique good paths because it is not unique (it appears multiple times). Note: The order of the unique good paths does not matter. Each node value is unique for any given tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def unique_good_paths(root): if not root: return 0 # Helper function to collect all values in the tree def collect_values(node): if not node: return [] return [node.val] + collect_values(node.left) + collect_values(node.right) # Helper function to count the number of unique good paths def count_unique_paths(node, max_value, unique_values_counter): if not node: return 0 if unique_values_counter[node.val] == 1 and node.val > max_value: return 1 + count_unique_paths(node.left, node.val, unique_values_counter) + count_unique_paths(node.right, node.val, unique_values_counter) return count_unique_paths(node.left, max_value, unique_values_counter) + count_unique_paths(node.right, max_value, unique_values_counter) all_values = collect_values(root) unique_values_counter = {val: all_values.count(val) for val in set(all_values)} return count_unique_paths(root, float(\'-inf\'), unique_values_counter)"},{"question":"You are given a **0-indexed** array `coins` of length `n`, where `coins[i]` represents the value of the `ith` coin. Initially, you have 0 coins. You can perform two types of operations as many times as needed (even zero times): 1. Pick any coin from the array and add it to your collection. 2. Remove any coin from your collection. Your goal is to make the sum of the value of the coins in your collection equal to `target`. Return the **minimum number** of operations needed to achieve this sum. If it\'s not possible, return `-1`.","solution":"def min_operations(coins, target): n = len(coins) MAX_OPS = float(\'inf\') dp = [[MAX_OPS] * (target + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n + 1): coin = coins[i - 1] for j in range(target + 1): # Not picking the i-th coin dp[i][j] = dp[i - 1][j] # Picking the i-th coin, only if it\'s not larger than the current sum we\'re considering if j >= coin: dp[i][j] = min(dp[i][j], dp[i - 1][j - coin] + 1) return dp[n][target] if dp[n][target] != MAX_OPS else -1"},{"question":"Given a string `s` and an integer `numRows`, return _**the string read off by horizontally zigzagging**_ across the number of rows specified by `numRows`. Here, zigzagging means filling the rows from top to bottom and then diagonally up to the top again, and so on. If `numRows` is 1, return the string unchanged.","solution":"def convert(s, numRows): Convert a string into a zigzag pattern based on the number of rows and return the string read off row-by-row. If numRows is 1, return the string unchanged. if numRows == 1: return s rows = [\'\'] * min(numRows, len(s)) curRow = 0 goingDown = False for c in s: rows[curRow] += c if curRow == 0 or curRow == numRows - 1: goingDown = not goingDown curRow += 1 if goingDown else -1 return \'\'.join(rows)"},{"question":"Given a **0-indexed** integer array `heights` representing the heights of buildings, arranged from left to right, return _an array_ `ans` _of the same length_, where `ans[i]` _is the **number** of buildings to the right of the_ `i-th` _building that have heights **strictly greater** than the height of the_ `i-th` _building_. A building \\"right\\" to the `i-th` building means any building with an index greater than `i`.","solution":"def count_greater_buildings(heights): Returns an array where each element corresponds to the number of buildings to the right that have heights strictly greater than the current building. n = len(heights) ans = [0] * n for i in range(n - 1): count = 0 for j in range(i + 1, n): if heights[j] > heights[i]: count += 1 ans[i] = count return ans"},{"question":"Given a 2D matrix `mat` of `n` rows and `m` columns, return _the elements of the matrix in spiral order starting from the top-left corner_.","solution":"def spiralOrder(mat): Returns the elements of the matrix in spiral order starting from the top-left corner. :param mat: List[List[int]] -> 2D matrix :return: List[int] -> Elements of the matrix in spiral order if not mat or not mat[0]: return [] results = [] top, bottom, left, right = 0, len(mat) - 1, 0, len(mat[0]) - 1 while top <= bottom and left <= right: for i in range(left, right + 1): results.append(mat[top][i]) top += 1 for i in range(top, bottom + 1): results.append(mat[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): results.append(mat[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): results.append(mat[i][left]) left += 1 return results"},{"question":"You are given a list of `n` unique integers, `nums`, and an integer target `k`. Write a function that returns the minimum length of a contiguous subarray whose sum is greater than or equal to `k`. If there is no such subarray, return `0` instead. An optimal solution runs in O(n) time.","solution":"def minSubArrayLen(nums, k): Returns the minimum length of a contiguous subarray whose sum is greater than or equal to k. If there is no such subarray, returns 0. n = len(nums) start = 0 current_sum = 0 min_length = n + 1 for end in range(n): current_sum += nums[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length <= n else 0"},{"question":"You are given a binary tree where each node\'s value is an integer. Implement a function that returns the level order traversal of its nodes\' values as a list of lists. In a level order traversal, we visit every node on a level before going to a lower level. The tree should be traversed from left to right at each level. Complete the function to return the desired output.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root): Returns the level order traversal of a binary tree. :param TreeNode root: The root node of the binary tree. :return: A list of lists, where each inner list contains the values of the nodes at that level. :rtype: List[List[int]] if not root: return [] result = [] queue = deque([root]) while queue: level_nodes = [] for _ in range(len(queue)): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"You are given a 2D grid of size `m x n` representing a maze of cells, where `1` represents a wall and `0` represents an open space you can walk through. You are also given two points: the starting point `(startX, startY)` and the destination point `(destX, destY)`. The goal is to determine if there is a path from the start to the destination that you can follow, only moving up, down, left, or right through open spaces. Return a boolean value indicating if such a path exists. Additionally, if the start and destination points are the same, return `True`.","solution":"def is_path_exist(grid, startX, startY, destX, destY): def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 1: return False if (x, y) == (destX, destY): return True grid[x][y] = 1 return dfs(x+1, y) or dfs(x-1, y) or dfs(x, y+1) or dfs(x, y-1) if (startX, startY) == (destX, destY): return True return dfs(startX, startY)"},{"question":"A company\'s internal case tracking system marks incidents with unique identifiers. Each identifier consists of a combination of lowercase alphabetic characters and digits. The combination always starts with a letter and must be at least 3 characters long. Any incidents that fail to meet these criteria are considered invalid and should be excluded from the results. Given an array of strings `identifiers` where each string represents an incident identifier, return _the number of valid incident identifiers_.","solution":"def is_valid_identifier(identifier): Checks if an incident identifier is valid. A valid identifier: - Starts with a lowercase alphabetic character - Is at least 3 characters long - Consists only of lowercase alphabetic characters and digits Args: identifier (str): The incident identifier to validate. Returns: bool: True if the identifier is valid, False otherwise. if len(identifier) < 3: return False if not identifier[0].islower(): return False if not identifier.isalnum(): return False return True def count_valid_identifiers(identifiers): Counts the number of valid incident identifiers in a list. Args: identifiers (list of str): List of incident identifiers. Returns: int: Number of valid identifiers. return sum(is_valid_identifier(identifier) for identifier in identifiers)"},{"question":"Given an integer array `nums` and an integer `x`, you want to determine the length of the shortest contiguous subarray that has a sum equal to or greater than `x`. Return _the length of the shortest such subarray, or -1 if no such subarray exists_. For example, given the array `[1, 4, 4]` and `x = 8`, the shortest subarray with a sum of at least 8 would be `[4, 4]` with a length of 2.","solution":"def min_subarray_len(nums, x): Returns the length of the shortest contiguous subarray with sum >= x, or -1 if no such subarray exists. n = len(nums) min_len = float(\'inf\') current_sum = start = 0 for end in range(n): current_sum += nums[end] while current_sum >= x: min_len = min(min_len, end - start + 1) current_sum -= nums[start] start += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given a 2D integer matrix `mat` of size `m x n` and an integer threshold. Each element in the matrix represents the height of a particular cell. A cell is considered **reachable** if there is a path from the top-left corner (0, 0) to this cell such that the absolute difference in height between any two adjacent cells in the path is less than or equal to the `threshold`. Two cells are considered adjacent if they share a common edge. Return _the maximum height value in the path from the top-left corner to the bottom-right corner that respects the threshold, or_ `-1` _if there is no such path._","solution":"def maximum_path_height(mat, threshold): Returns the maximum height value in the path from the top-left corner to the bottom-right corner of the matrix that respects the given threshold or -1 if no such path exists. from collections import deque import heapq m, n = len(mat), len(mat[0]) def in_bounds(x, y): return 0 <= x < m and 0 <= y < n directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_height = [[float(\'-inf\')] * n for _ in range(m)] max_height[0][0] = mat[0][0] heap = [(-mat[0][0], 0, 0)] # Use negative values to simulate max-heap while heap: current_negative_height, x, y = heapq.heappop(heap) current_height = -current_negative_height if x == m - 1 and y == n - 1: return current_height for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny): if abs(mat[nx][ny] - mat[x][y]) <= threshold: new_height = mat[nx][ny] if new_height > max_height[nx][ny]: max_height[nx][ny] = new_height heapq.heappush(heap, (-new_height, nx, ny)) return -1"},{"question":"You are given two **0-indexed** integer arrays `nums1` and `nums2`, both of length `n`. A **comparison** for a pair of indices `(i, j)` is defined as follows: `nums1[i] < nums2[j]`. Return _the **maximum number**_ of such comparisons for all valid pairs of indices `(i, j)` (i.e., where `0 <= i, j < n`). Note that each element in `nums1` and `nums2` can only be used in **one comparison**.","solution":"def max_comparisons(nums1, nums2): Returns the maximum number of comparisons (i, j) where nums1[i] < nums2[j]. Each element in nums1 and nums2 can only be used in one comparison. count = 0 nums1_sorted = sorted(nums1) nums2_sorted = sorted(nums2) j = 0 for i in range(len(nums1_sorted)): while j < len(nums2_sorted) and nums1_sorted[i] >= nums2_sorted[j]: j += 1 if j < len(nums2_sorted): count += 1 j += 1 return count"},{"question":"You are given an `m x n` 2D `grid` initialized with the value `0`. We have several `update` operations to perform on this grid. Each operation is represented by a list of three integers `[r, c, x]` which means increasing the value at the cell `(r, c)` by `x`. After performing all the given operations, return _the total count of the maximum integer in the grid_.","solution":"def count_max_in_grid(m, n, operations): Perform the given operations on the grid and return the count of the maximum integer in the grid. Args: - m (int): number of rows in the grid. - n (int): number of columns in the grid. - operations (List[List[int]]): list of operations, each operation is represented by a list of three integers [r, c, x]. Returns: - int: total count of the maximum integer in the grid. # Initialize the grid with zeros grid = [[0] * n for _ in range(m)] # Perform the operations for r, c, x in operations: grid[r][c] += x # Find the maximum value in the grid max_value = max(max(row) for row in grid) # Count the occurrences of the maximum value max_count = sum(row.count(max_value) for row in grid) return max_count"},{"question":"Given an integer `n`, return the number of structurally unique Binary Search Trees (BST) that store values `1` to `n`. Two BSTs are considered structurally unique if they have different shapes or arrangements, even if they hold the same node values. Implement the function `numUniqueBST(int n)` that returns the number of unique BSTs.","solution":"def numUniqueBST(n): Returns the number of structurally unique BSTs that store values 1 to n. if n == 0 or n == 1: return 1 # DP array to store the number of unique BSTs for each number from 0 to n dp = [0] * (n + 1) dp[0] = dp[1] = 1 for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"You are given `n` dominoes represented as pairs of integers. A domino pair `(a, b)` is considered to be equal to another domino pair `(c, d)` if and only if one of the following conditions is true: - `a == c` and `b == d` - `a == d` and `b == c` Write a function that returns the number of pairs `(i, j)` for which `dominoes[i]` is equal to `dominoes[j]` and `i < j`. Here is a function signature to help you: ```python def numEquivDominoPairs(dominoes: List[List[int]]) -> int: # Your code here ```","solution":"from collections import defaultdict from typing import List def numEquivDominoPairs(dominoes: List[List[int]]) -> int: Computes the number of equivalent domino pairs in the list. Args: dominoes (List[List[int]]): List of domino pairs. Returns: int: Number of equivalent domino pairs. count = defaultdict(int) result = 0 for a, b in dominoes: key = tuple(sorted((a, b))) result += count[key] count[key] += 1 return result"},{"question":"A string is called balanced if it can be written as `XYYX` where `X` and `Y` are non-empty substrings, and `X` being the reverse of `Y`. Given a string `s`, check if it can be rearranged to form a balanced string. Return _true_ if such an arrangement is possible, or _false_ otherwise.","solution":"from collections import Counter def can_form_balanced(s): Check if a given string can be rearranged to form a balanced string. A string is called balanced if it can be written as `XYYX` where `X` and `Y` are non-empty substrings, and `X` is the reverse of `Y`. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a balanced string, False otherwise. char_count = Counter(s) odd_counts = 0 for count in char_count.values(): if count % 2 != 0: odd_counts += 1 return odd_counts <= 1"},{"question":"You are given a sorted array of distinct integers. You need to find a pair of elements (a, b) such that the difference between a and b is equal to a given target. Write a function that takes in the array and the target difference and returns the pair if it exists, or an empty list if it doesn\'t. The function should have a time complexity better than O(n^2).","solution":"def find_pair_with_difference(arr, target): Returns a pair (a, b) such that the difference between a and b is equal to the target. If no such pair exists, returns an empty list. left = 0 right = 1 n = len(arr) while left < n and right < n: diff = arr[right] - arr[left] if diff == target and left != right: return [arr[left], arr[right]] elif diff < target: right += 1 else: left += 1 return [] # Example usage: # arr = [1, 2, 3, 5, 7] # target = 2 # The function should return [1, 3] or any other valid pair with a difference of 2."},{"question":"Given an integer array `arr` where each element represents the height of a block, return the maximum number of blocks that can be picked such that the difference in height between any two picked blocks is at most `d`. The blocks picked do not need to be contiguous.","solution":"def maxBlocks(arr, d): Returns the maximum number of blocks that can be picked such that the difference in height between any two picked blocks is at most d. # Sort the array to check consecutive blocks sorted_arr = sorted(arr) count = 1 max_count = 1 for i in range(1, len(sorted_arr)): if sorted_arr[i] - sorted_arr[i-1] <= d: count += 1 else: max_count = max(max_count, count) count = 1 # Final comparison for the last sequence max_count = max(max_count, count) return max_count"},{"question":"Given a `root` of a binary search tree and an integer `k`, return _the kth smallest value (1-indexed) of all the values of the nodes in the tree_. A binary search tree is defined as a binary tree in which each node has at most two children, and for each node, the left subtree contains only values less than or equal to the node\'s value, and the right subtree contains only values greater than the node\'s value. For example, in the BST: ``` 3 / 1 4 2 ``` The `2nd` smallest value is `2`. It is guaranteed that `k` is always valid, i.e., `1 ≤ k ≤ number of nodes in the tree`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest value in the BST. def inorder_traversal(node): if not node: return [] # Traverse left subtree, root, then right subtree return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Get all the values in the BST in sorted order sorted_values = inorder_traversal(root) # Return the kth smallest value (1-indexed -> k-1 for 0-indexed) return sorted_values[k-1]"},{"question":"Given a string `s` and a list of words `words`, return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. The words in `words` are all of the same length. Implement an algorithm that runs in `O(n)` time.","solution":"def find_substring(s, words): Given a string `s` and a list of words `words`, return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. The words in `words` are all of the same length. from collections import defaultdict if not s or not words: return [] word_length = len(words[0]) word_count = len(words) total_length = word_length * word_count word_map = defaultdict(int) for word in words: word_map[word] += 1 def check(start): seen = defaultdict(int) words_used = 0 for i in range(start, start + total_length, word_length): current_word = s[i:i + word_length] if current_word in word_map: seen[current_word] += 1 if seen[current_word] > word_map[current_word]: return False words_used += 1 else: return False return words_used == word_count result = [] for i in range(len(s) - total_length + 1): if check(i): result.append(i) return result"},{"question":"Given an integer `n`, return the number of trailing zeroes in `n!` (n factorial). Note that `n!` means `n × (n - 1) × ... × 2 × 1`. For example, `5! = 120` has one trailing zero. You are required to implement an efficient algorithm to solve this problem.","solution":"def trailing_zeroes(n): Returns the number of trailing zeroes in n! (n factorial). count = 0 while n >= 5: n //= 5 count += n return count"},{"question":"You are given two arrays of integers `nums1` and `nums2`. A pair (u, v) is said to be a \\"fair pair\\" if the absolute difference between `u` from `nums1` and `v` from `nums2` is less than or equal to a given integer `k`. Write a function `countFairPairs(nums1, nums2, k)` that returns the number of fair pairs in the two arrays. The function should handle large inputs efficiently.","solution":"def countFairPairs(nums1, nums2, k): Returns the number of fair pairs (u, v) such that the absolute difference between u and v is less than or equal to k. Parameters: nums1 (list): The first list of integers. nums2 (list): The second list of integers. k (int): The maximum allowed absolute difference. Returns: int: The count of fair pairs. count = 0 for u in nums1: for v in nums2: if abs(u - v) <= k: count += 1 return count"},{"question":"Write a function to perform **in-order traversal** of a binary tree without using recursion. The function should return a list of the tree\'s values in in-order sequence. Define the tree node class as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - The function should take a `TreeNode` representing the root of the binary tree as its input parameter. - Implement the in-order traversal using an iterative approach, leveraging a stack.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def in_order_traversal(root): Perform in-order traversal of a binary tree without recursion. Return a list of the tree\'s values in in-order sequence. result = [] stack = [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"You are given an integer array `nums` where each element represents the number of balloons present in each of the consecutive rooms. You want to burst all the balloons such that each time you burst a balloon in the `i-th` room, you collect `nums[i-1] * nums[i] * nums[i+1]` coins. If `i-1` or `i+1` goes out of bounds of the array, substitute it with `1`. Write a function that calculates the maximum coins you can collect by bursting all balloons in the optimal order. Return the maximum coins you can collect.","solution":"def maxCoins(nums): Returns the maximum coins that can be collected by bursting all balloons in the optimal order. # Add virtual balloons with 1 coin to the beginning and end of the array nums = [1] + nums + [1] n = len(nums) dp = [[0] * n for _ in range(n)] # dp[i][j] will store the maximum coins obtained by bursting balloons between indexes i and j for length in range(2, n): # length is the current window size for left in range(n - length): # left index of window right = left + length # right index of window for i in range(left + 1, right): # k is the last balloon burst in this subarray dp[left][right] = max(dp[left][right], nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]) return dp[0][n - 1]"},{"question":"Given two integer arrays, `nums1` and `nums2`, both of which are sorted in non-decreasing order, merge `nums2` into `nums1` as one sorted array. The final sorted array should not be returned by creating a new array, but instead by modifying `nums1` in place. Assume that `nums1` has a size equal to `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to 0 and should be ignored. `nums2` has exactly `n` elements. Write a function to achieve the merging process.","solution":"def merge(nums1, m, nums2, n): Merges nums2 into nums1 in place. :param nums1: List[int], the first sorted array with length m + n where the last n elements are 0 and should be ignored :param m: int, the number of initialization elements in nums1 :param nums2: List[int], the second sorted array with exactly n elements :param n: int, the number of initialization elements in nums2 # Start from the end of both arrays and merge in reverse order p1, p2, p = m - 1, n - 1, m + n - 1 while p1 >= 0 and p2 >= 0: if nums1[p1] > nums2[p2]: nums1[p] = nums1[p1] p1 -= 1 else: nums1[p] = nums2[p2] p2 -= 1 p -= 1 # If any elements left in nums2, add them to nums1 while p2 >= 0: nums1[p] = nums2[p2] p -= 1 p2 -= 1"},{"question":"You are given an array of positive integers `arr` representing the strength of soldiers. Your task is to form the strongest battalion, which consists of `k` soldiers and the strength of the battalion is defined as the sum of the soldiers\' strength. However, the selection of soldiers follows these rules: - Out of the `k` soldiers, at most `m` of them can be chosen from consecutive positions in the array. Return the maximum possible strength of the battalion that can be formed under these conditions. Example: ``` arr = [1, 3, 2, 1, 4, 1, 5], k = 3, m = 2 Output: 12 Explanation: We can pick soldiers from positions 5 and 6 to get [4, 1, 5]. ```","solution":"def strongest_battalion(arr, k, m): Returns the maximum possible strength of a battalion formed under the given conditions. :param arr: List of positive integers representing the strength of soldiers. :param k: Integer representing number of soldiers in the battalion. :param m: Integer representing the maximum number of consecutive soldiers that can be chosen. :return: Integer representing the maximum possible strength of the battalion. n = len(arr) max_strength = 0 # Go through all possible combinations of picking k soldiers with at most m consecutive ones def dfs(index, selected, current_strength, last_taken): nonlocal max_strength # If we\'ve picked k soldiers, compare and update max_strength if selected == k: max_strength = max(max_strength, current_strength) return for i in range(index, n): # Can only pick current soldier if it\'s not consecutive to the last chosen (if last_taken is not None) if last_taken is None or i - last_taken > m: dfs(i + 1, selected + 1, current_strength + arr[i], i) elif last_taken is not None and (0 < i - last_taken <= m): dfs(i + 1, selected + 1, current_strength + arr[i], i) dfs(0, 0, 0, None) return max_strength"},{"question":"You are given an array `arr` of positive integers and an integer `n`. You must find the **nth** highest element in the array. If `n` is greater than the number of unique elements in `arr`, return `-1`. Note that the elements of the array can be repeated, but each unique value should be considered only once. Implement the function `nthHighestElement(arr, n)` that returns the **nth** highest unique element in the array. For example, given the array `[4, 5, 1, 3, 2, 2, 5, 3]` and `n = 2`, the **2nd** highest unique element is `4`. If `n = 6`, return `-1` as there are less than 6 unique elements in the array.","solution":"def nthHighestElement(arr, n): Returns the nth highest unique element in the array `arr`. If `n` is greater than the number of unique elements, return -1. unique_elements = list(set(arr)) unique_elements.sort(reverse=True) if n > len(unique_elements): return -1 return unique_elements[n-1]"},{"question":"You are given a string `s` that consists of only lowercase English letters and an integer `n`. We define a **beautiful substring** as a substring of `s` that contains exactly `n` distinct letters. Your task is to find the length of the longest beautiful substring. Return the length of that substring, or 0 if no such substring exists. A substring is a contiguous segment of a string.","solution":"def longest_beautiful_substring(s, n): Returns the length of the longest beautiful substring, which contains exactly n distinct letters. from collections import defaultdict max_length = 0 left = 0 frequency = defaultdict(int) for right in range(len(s)): frequency[s[right]] += 1 while len(frequency) > n: frequency[s[left]] -= 1 if frequency[s[left]] == 0: del frequency[s[left]] left += 1 if len(frequency) == n: max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given a `target` string and a list of `wordlist` strings, find the longest common subsequence (LCS) between the `target` string and each string in the `wordlist`. The LCS is the longest sequence that appears in both strings in the same order, but not necessarily consecutively. Return an array `answer` where `answer[i]` is the length of the longest common subsequence between the `target` string and `wordlist[i]`. If there is no common subsequence, the length should be 0. For example: * Example: `target = \\"abcde\\"`, `wordlist = [\\"ace\\", \\"aec\\", \\"bd\\"]` => `answer = [3, 2, 2]` * Example: `target = \\"abcdef\\"`, `wordlist = [\\"abc\\", \\"def\\", \\"xyz\\"]` => `answer = [3, 3, 0]`","solution":"def lcs_length(target, word): Returns the length of the longest common subsequence (LCS) between target and word. m, n = len(target), len(word) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if target[i - 1] == word[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def lcs_lengths(target, wordlist): Returns a list where each element is the length of the LCS between the target string and the corresponding word in wordlist. return [lcs_length(target, word) for word in wordlist]"},{"question":"You are given a list of `logs`, where each element is a string formatted as `\\"ID Process_Start_Time Process_End_Time\\"`. Each `Process_Start_Time` and `Process_End_Time` is in the format `HH:MM`. Calculate the total execution time for all processes combined and return the result in the format `HH:MM`. Note that the times are within the same day, thus no processes span across days. Example: Given the input `logs = [\\"1 09:00 09:40\\", \\"2 10:00 11:10\\", \\"3 18:30 20:00\\"]`, the output should be `\\"03:20\\"`.","solution":"def time_difference(start, end): Calculate the difference between two times given in the format \\"HH:MM\\". Returns the difference in minutes. start_hour, start_minute = map(int, start.split(\\":\\")) end_hour, end_minute = map(int, end.split(\\":\\")) start_total_minutes = start_hour * 60 + start_minute end_total_minutes = end_hour * 60 + end_minute return end_total_minutes - start_total_minutes def convert_minutes_to_HHMM(total_minutes): Convert a total number of minutes to the format \\"HH:MM\\". hours = total_minutes // 60 minutes = total_minutes % 60 return f\\"{hours:02}:{minutes:02}\\" def total_execution_time(logs): Calculate the total execution time for all processes combined from the logs. Returns the total execution time in the format \\"HH:MM\\". total_minutes = 0 for log in logs: _, start_time, end_time = log.split() total_minutes += time_difference(start_time, end_time) return convert_minutes_to_HHMM(total_minutes)"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of pillars in a row. The pillars form a series of walls, and rainwater may collect on top of the pillars and between them. Each unit segment of the top of a pillar can support one unit of water. Calculate the **maximum** amount of water that can be trapped after raining. Return _an integer_ `maxWater` _which is the maximum units of water that can be trapped._","solution":"def trap(heights): Calculate the maximum amount of water that can be trapped. :param heights: List of integers representing the heights of the pillars :return: Integer representing the maximum units of water that can be trapped if not heights: return 0 n = len(heights) max_water = 0 # Create left_max and right_max arrays left_max = [0]*n right_max = [0]*n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water for i in range(n): max_water += min(left_max[i], right_max[i]) - heights[i] return max_water"},{"question":"You are given a string `text` and a string `pattern`. You need to find all start indices of `pattern`\'s anagrams in `text`. The output should be returned in an array in ascending order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Write a function that returns the list of starting indices of the anagram `pattern` in the `text`.","solution":"def find_anagrams(text, pattern): from collections import Counter def is_anagram(counter1, counter2): for k in counter1: if counter1[k] != counter2.get(k, 0): return False return True pattern_length = len(pattern) pattern_counter = Counter(pattern) result = [] for i in range(len(text) - pattern_length + 1): window = text[i:i + pattern_length] if is_anagram(pattern_counter, Counter(window)): result.append(i) return result"},{"question":"You are given a string `text`. Write a function to rearrange the characters in `text` such that any two adjacent characters are not the same. If it is possible to rearrange the characters in this way, return the rearranged string. If it is not possible, return an empty string. Assume that the input string contains only lowercase English letters.","solution":"import heapq from collections import Counter def rearrange_string(text): Rearrange the characters in the text such that any two adjacent characters are not the same. If it is not possible, return an empty string. # Count the frequency of each character char_count = Counter(text) # Create a max-heap based on character count max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] prev_count, prev_char = 0, \'\' while max_heap: count, char = heapq.heappop(max_heap) # Add the previous character back if it exists if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Append current character to the result result.append(char) prev_count, prev_char = count + 1, char # Decrement count rearranged_string = \'\'.join(result) # Check if the rearranged string is of the same length as the input text return rearranged_string if len(rearranged_string) == len(text) else \\"\\""},{"question":"Design a data structure that simulates a collection of stacks which can grow dynamically. Implement the `DinnerPlates` class: * `DinnerPlates(int capacity)` - Initializes the object with the given capacity of stacks. * `void push(int val)` - Adds the `val` to the leftmost stack that is not full. If no stacks are available, creates a new one. * `int pop()` - Removes the top element from the rightmost non-empty stack and returns it. If all stacks are empty, returns `-1`. * `int popAtStack(int index)` - Removes the top element from the stack with the given `index` and returns it. If the stack is empty or does not exist, returns `-1`.","solution":"class DinnerPlates: def __init__(self, capacity: int): self.capacity = capacity self.stacks = [] def push(self, val: int) -> None: for stack in self.stacks: if len(stack) < self.capacity: stack.append(val) return new_stack = [val] self.stacks.append(new_stack) def pop(self) -> int: while self.stacks and not self.stacks[-1]: self.stacks.pop() if not self.stacks: return -1 return self.stacks[-1].pop() def popAtStack(self, index: int) -> int: if index < 0 or index >= len(self.stacks) or not self.stacks[index]: return -1 return self.stacks[index].pop()"},{"question":"Given a string `s` containing only lowercase alphabetical characters and an integer `k`, determine if you can rearrange the characters in `s` to form a palindrome such that no two adjacent characters are the same. Return _True_ if such a rearrangement is possible, otherwise return _False_.","solution":"def can_rearrange_to_palindrome(s, k): from collections import Counter char_count = Counter(s) # In a valid palindrome, at most one character can have an odd count. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If there are more than one character with odd counts, it\'s impossible. if odd_count > 1: return False # Check if the k constraint can be satisfied # Check that with current frequency counts, no two of the same characters can be adjacent half_length = (len(s) // 2) max_allowed_same_char = (len(s) // 2) + (len(s) % 2) max_char_frequency = max(char_count.values()) if max_char_frequency > max_allowed_same_char: return False return True"},{"question":"Given an array of integers `heights` representing the heights of buildings in a row, return an array `answer` such that `answer[i]` contains the total number of buildings before the `i`-th building that are shorter in height than the `i`-th building.","solution":"def count_shorter_buildings(heights): Returns an array such that answer[i] contains the total number of buildings before the i-th building that are shorter in height than the i-th building. n = len(heights) answer = [0] * n for i in range(1, n): count = 0 for j in range(i): if heights[j] < heights[i]: count += 1 answer[i] = count return answer"},{"question":"Given a list of integers `nums` and an integer `k`, return the _least number of unique integers_ after removing exactly `k` elements from `nums`. For example, if `nums = [4,3,1,1,3,3,2]` and `k = 3`, you need to remove three elements such that the count of the unique integers in the remaining list is minimized. Return the minimum number of unique integers after the removal.","solution":"from collections import Counter def find_least_num_of_unique_ints(nums, k): Returns the least number of unique integers after removing exactly k elements from nums. :param nums: List of integers :param k: Integer number of elements to remove :return: Integer least number of unique integers # Count frequency of each integer freq = Counter(nums) # Convert frequency dictionary to a list of (number, count) and sort by count freq_list = sorted(freq.items(), key=lambda item: item[1]) # Remove elements with the smallest occurrences first for number, count in freq_list: if k >= count: k -= count del freq[number] else: break # Return the number of unique keys remaining in the frequency dictionary return len(freq)"},{"question":"Given a **0-indexed** integer array `nums`, determine the number of pairs `(i, j)` where `0 <= i < j < n` and `nums[i] + nums[j]` is even. Return _an integer representing the count of such pairs.","solution":"def count_even_sum_pairs(nums): Returns the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] is even. Parameters: nums (list): a list of integers. Returns: int: count of pairs with an even sum. even_count = 0 odd_count = 0 # Count even and odd numbers in the array for num in nums: if num % 2 == 0: even_count += 1 else: odd_count += 1 # Pairs (i, j) with even sum can be formed by: # - both even numbers # - both odd numbers even_pairs = (even_count * (even_count - 1)) // 2 odd_pairs = (odd_count * (odd_count - 1)) // 2 # Return the sum of even pairs and odd pairs return even_pairs + odd_pairs"},{"question":"Given a list of non-negative integers representing elevation heights of a terrain, calculate the maximum volume of water that can be trapped between the columns after a rain. The width of each column is 1 unit. The height of the stored water at each point is determined by the heights of the tallest elevations to the left and right, minus the height of the terrain at that point. Return the amount of water that can be trapped.","solution":"def trap_rain_water(heights): Calculate the maximum volume of water that can be trapped between the columns after a rain. :param heights: List[int] - a list of non-negative integers representing elevation heights :return: int - total volume of trapped rain water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"You are given a binary tree with `n` nodes where each node has a distinct value from `1` to `n`. Your task is to serialize the tree into a string in such a way that the tree can be uniquely reconstructed from this string. Specifically, return a preorder traversal of the binary tree represented as a string, where the nodes are visited in the order: root, left subtree, right subtree. The values of the nodes should be separated by commas. For example, given the following binary tree: ``` 1 / 2 3 / 4 5 ``` The string representation will be `\\"1,2,4,5,3\\"`. Note that each node value is separated by a comma. Return _the serialized string representation of the tree_.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def serialize_tree(root): def preorder_traversal(node): if not node: return [] result = [str(node.value)] result += preorder_traversal(node.left) result += preorder_traversal(node.right) return result return \',\'.join(preorder_traversal(root))"},{"question":"You are given a list of strings, where each string represents a directory path. Some directory paths contain redundant components such as `\\"./\\"` (current directory) or `\\"/../\\"` (parent directory), which should be properly resolved. Write a function to simplify the given list of directory paths and return the resultant list. The function should remove any redundant components, resulting in the shortest equivalent path for each input directory. The function should follow these simplification rules: 1. Replace multiple consecutive `\\"//\\"` with a single `\\"/\\"`. 2. Simplify `\\"./\\"` to the current directory, i.e., remove it. 3. Simplify `\\"/../\\"` to the parent directory, i.e., remove the parent directory and the `\\"/../\\"` component. 4. If there are several parent directory references (`\\"/../\\"`) at the start of a path with no actual parent directory to return to, consider them as invalid and ignore them. 5. The resultant directory path should always start with a `\\"/\\"`. For example, given the list of directory paths: `[\\"/a//b//c/\\", \\"/a/b/c/./\\", \\"/a/b/../c/\\"]` The function should return: `[\\"/a/b/c\\", \\"/a/b/c\\", \\"/a/c\\"]`","solution":"def simplify_directory_paths(paths): def simplify_path(path): parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() elif not stack: continue else: stack.append(part) return \'/\' + \'/\'.join(stack) return [simplify_path(path) for path in paths]"},{"question":"Given a list of `n` integers, you need to determine if there exists a triplet (a, b, c) in the array such that: * `a` + `b` + `c` = 0 * The indices of the elements are distinct Write a function that returns all unique triplets that sum up to zero. The solution set must not contain duplicate triplets. ```python def find_triplets(nums: List[int]) -> List[List[int]]: # Implementation goes here ``` **Example:** ```python # Input: nums = [-1, 0, 1, 2, -1, -4] # Output: [[-1, -1, 2], [-1, 0, 1]] ```","solution":"from typing import List def find_triplets(nums: List[int]) -> List[List[int]]: Finds all unique triplets in the list which give the sum of zero. nums.sort() triplets = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return triplets"},{"question":"You are given a **binary tree** with `n` nodes labeled from `1` to `n`. Each node has a value assigned to it, which is given in the form of an array `values` where `values[i]` is the value of the node labeled `i+1`. Your task is to find the **maximum sum** of node values in any path from the tree\'s **root** to any of its **leaf** nodes. Return the maximum sum. **Note**: A leaf node is a node with no children.","solution":"class TreeNode: def __init__(self, label, value): self.label = label self.value = value self.left = None self.right = None def max_sum_from_root_to_leaf(root): Returns the maximum sum of values from root to any leaf node. if root is None: return 0 if root.left is None and root.right is None: return root.value left_sum = max_sum_from_root_to_leaf(root.left) right_sum = max_sum_from_root_to_leaf(root.right) return root.value + max(left_sum, right_sum)"},{"question":"Given an array of integers `arr` and an integer `k`, find the total number of continuous subarrays whose sum equals to `k`.","solution":"def subarray_sum_equals_k(arr, k): Returns the total number of continuous subarrays whose sum equals to k. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: int: Total number of continuous subarrays whose sum equals to k. count = 0 current_sum = 0 sum_dict = {0: 1} # Initialize with 0 sum having one count as a base case for num in arr: current_sum += num if (current_sum - k) in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"Given a string `s` consisting of only lowercase alphabetic characters, return the length of the longest substring with all distinct characters. For example, the longest substring with all distinct characters in \\"abcabcbb\\" is \\"abc\\", with a length of 3. Similarly, in \\"bbbbb\\", the longest substring with all distinct characters is \\"b\\", with a length of 1. Write a function: ```python def length_of_longest_substring(s: str) -> int: # Your code here ```","solution":"def length_of_longest_substring(s: str) -> int: char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"You are given a `2D` grid of size `m x n` representing a map as an array of array of integers. The grid contains `0`s representing water and `1`s representing land. An island is a group of `1`s (land) connected orthogonally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. The number of distinct islands will depend on the shape rather than the position and the number of occurrences. Write a function to find the number of distinct-shaped islands. Each distinct island is defined by its shape when seen in the grid. The shape is defined by relative positions of cells in the island and should be considered as identical even if the island is rotated or flipped.","solution":"def find_distinct_islands(grid): def dfs(x, y, direction, island_shape): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != 1: return grid[x][y] = -1 island_shape.append(direction) dfs(x-1, y, \'U\', island_shape) # Up dfs(x+1, y, \'D\', island_shape) # Down dfs(x, y-1, \'L\', island_shape) # Left dfs(x, y+1, \'R\', island_shape) # Right island_shape.append(\'B\') # Back to previous cell unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: island_shape = [] dfs(i, j, \'S\', island_shape) # Start of a shape unique_islands.add(tuple(island_shape)) return len(unique_islands)"},{"question":"You are given an array of strings `strings` representing a list of words and an array of characters `chars` where each character has a certain frequency. Write a function to determine the maximum length of strings that can be formed using the characters in `chars`. Each character in `chars` can only be used once per word but could be reused in forming different words. For example, given `strings = [\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"]` and `chars = \\"atach\\"`, you can form the words \\"cat\\" and \\"hat\\" with the characters from `chars`, yielding a total length of 6. Return the integer _representing the total length of strings that can be formed_.","solution":"from collections import Counter def count_characters(strings, chars): Returns the total length of strings that can be formed using the characters in chars. Each character in chars can only be used once per word. chars_count = Counter(chars) total_length = 0 for word in strings: word_count = Counter(word) can_form = True for char in word_count: if word_count[char] > chars_count.get(char, 0): can_form = False break if can_form: total_length += len(word) return total_length"},{"question":"You are given an integer array `heights` representing the heights of students in a line. The teacher wants to pick one student and move them to any position in the line such that the students remain sorted in non-decreasing order. Return _the **minimum** number of such moves needed_ to achieve the sorted order. Note: The original positions of the students are 1-based, and you can only pick one student to move.","solution":"def min_moves_to_sort_heights(heights): Returns the minimum number of moves needed to sort the heights array by picking one student and moving them to any position. sorted_heights = sorted(heights) differences = sum([1 for i, height in enumerate(heights) if height != sorted_heights[i]]) # If the list is already sorted if differences == 0: return 0 # If only one element is out of place, one move is always sufficient if differences == 2: return 1 # If more than two elements are out of place, more than one move is needed return 2"},{"question":"Given a list of `n` integers and an integer `target`, design an algorithm to determine if there are two distinct numbers in the list that add up to `target`. Return _**true**_ if such a pair exists, otherwise return _**false**_. The algorithm should have a time complexity better than O(n^2).","solution":"def two_sum(nums, target): Determines if there are two distinct numbers in the list that add up to the target. Args: nums: List of integers. target: Integer target sum. Returns: Boolean indicating whether there are two distinct numbers that add up to the target. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"Given an array of integers `nums` and an integer `k`, partition the array into exactly `k` non-empty subsets such that the sum of the largest element in each subset is minimized. Return the minimized sum of the largest elements. If it is not possible to partition the array into `k` subsets, return `-1`. Note that once an integer is used in a subset, it cannot be reused in another subset.","solution":"def partition_minimized_sum_of_largest_elements(nums, k): Partitions the array `nums` into exactly `k` non-empty subsets such that the sum of the largest element in each subset is minimized. Args: nums (list of int): The array of integers to be partitioned. k (int): The number of subsets to partition into. Returns: int: The minimized sum of the largest elements if possible, otherwise -1. if k > len(nums): return -1 nums.sort() # The largest `k` elements are the largest elements in each subset largest_elements = nums[-k:] return sum(largest_elements)"},{"question":"You are given a integer array `weights` of size `n`, and an integer `maxWeight`. The array represents the weights of `n` items, and `maxWeight` represents the maximum weight capacity of both the knapsack and each of the two partitions. Your task is to determine if it\'s possible to partition the `n` items into two groups such that the sum of weights in each group does not exceed `maxWeight`. Each item must go into exactly one of the two groups. Return `true` if it\'s possible to partition the items accordingly, otherwise return `false`.","solution":"def can_partition_to_max_weight(weights, maxWeight): totalWeight = sum(weights) if totalWeight > 2 * maxWeight: return False n = len(weights) target = maxWeight dp = [False] * (target + 1) dp[0] = True for weight in weights: for j in range(target, weight - 1, -1): if dp[j - weight]: dp[j] = True for w in range(target, -1, -1): if dp[w] and totalWeight - w <= maxWeight: return True return False"},{"question":"You are given an integer array `nums`. A subarray is called a **wiggle subarray** if the differences between successive elements strictly alternate between positive and negative. The **length** of a wiggle subarray is the number of elements in that subarray. Return _the **maximum length** of any wiggle subarray_ within `nums`.","solution":"def max_wiggle_length(nums): Returns the maximum length of any wiggle subarray within nums. if not nums: return 0 n = len(nums) if n == 1: return 1 max_length = 1 current_length = 1 last_diff = 0 for i in range(1, n): current_diff = nums[i] - nums[i - 1] if (current_diff > 0 and last_diff <= 0) or (current_diff < 0 and last_diff >= 0): current_length += 1 max_length = max(max_length, current_length) last_diff = current_diff elif current_diff == 0: current_length = 1 last_diff = 0 return max_length"},{"question":"You are given a 2D integer matrix `grid` of size `m x n` representing a field. Each cell contains a positive integer, indicating the height of a pillar at that location. You are allowed to remove any number of pillars to form a rectangular sub-region of the field. The **density** of a rectangular sub-region is defined as the sum of the heights of all the remaining pillars within that region. Return the **maximum density** of any rectangular sub-region within the given field. The rectangular sub-region should contain at least one pillar.","solution":"def maxDensityOfSubRegion(grid): Returns the maximum density of any rectangular sub-region within the given field. if not grid or not grid[0]: return 0 m = len(grid) n = len(grid[0]) max_density = 0 # Compute the prefix sum array prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): prefix_sum[i][j] = (grid[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]) # Find the maximum density sub-region for i1 in range(1, m + 1): for j1 in range(1, n + 1): for i2 in range(i1, m + 1): for j2 in range(j1, n + 1): current_density = (prefix_sum[i2][j2] - prefix_sum[i1 - 1][j2] - prefix_sum[i2][j1 - 1] + prefix_sum[i1 - 1][j1 - 1]) max_density = max(max_density, current_density) return max_density"},{"question":"You are given an integer array `heights` representing the heights of buildings in a row. Return _the maximum area of a rectangle formed by any subset of the buildings_, where the width is determined by selecting buildings between (and including) the leftmost and rightmost selected buildings, and the height is the minimum height among the selected buildings.","solution":"def max_rectangle_area(heights): Returns the maximum rectangle area that can be formed by the given heights of buildings. heights: List[int] - heights of buildings in a row. max_area = 0 stack = [] for i, height in enumerate(heights): start = i while stack and stack[-1][1] > height: index, h = stack.pop() max_area = max(max_area, h * (i - index)) start = index stack.append((start, height)) for i, height in stack: max_area = max(max_area, height * (len(heights) - i)) return max_area"},{"question":"Consider a **linked list** where each node contains an integer value. You are given the **head** of the linked list and an integer **k**. You need to rotate the list to the right by **k** places. Return the head of the rotated linked list. The list should retain its original relative order after each rotation. The rotation is defined as moving the last element of the list to the front.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # First, determine the length of the list old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 # Form a circular list old_tail.next = head # Find the new tail : (length - k % length - 1)th node k = k % length new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next # Find the new head : (length - k % length)th node new_head = new_tail.next # Break the cycle new_tail.next = None return new_head"},{"question":"Given two integers `x` and `y`, return the largest integer `n` such that the sum of the integers from 1 to `n` is less than or equal to `x + y`. Only positive integers are considered valid. Implement the function `int largestIntegerSum(int x, int y)` that returns the largest possible `n`.","solution":"def largestIntegerSum(x, y): Returns the largest integer n such that the sum of the integers from 1 to n is less than or equal to the sum of x and y. Parameters: x (int): First integer y (int): Second integer Returns: int: Largest possible integer n total_sum = x + y n = 1 while n * (n + 1) // 2 <= total_sum: n += 1 return n - 1"},{"question":"Given a `string` `s` and an `integer` `k`, return the smallest lexicographically `substring` of length `k` from `s`. If there is no such substring, return an empty string. A substring is a contiguous sequence of characters within a string. For example, given `s = \\"abcde\\"` and `k = 3`, the answer is `\\"abc\\"`. For `s = \\"dcba\\"` and `k = 2`, the answer is `\\"ba\\"`.","solution":"def smallest_lexicographic_substring(s, k): Returns the smallest lexicographically substring of length k from string s. If there is no such substring, return an empty string. if len(s) < k or k <= 0: return \\"\\" min_substring = s[:k] for i in range(1, len(s) - k + 1): current_substring = s[i:i+k] if current_substring < min_substring: min_substring = current_substring return min_substring"},{"question":"You are given an integer array `arr` of unique elements. A subset of `arr` is an array that can be derived by deleting some or no elements from `arr` without changing the order of the remaining elements. Return _the length of the longest increasing subsequence that can be derived from `arr`_. An increasing subsequence is a subset of `arr` where each subsequent element is larger than the previous one.","solution":"def length_of_lis(arr): Returns the length of the longest increasing subsequence from the given array. Parameters: arr (List[int]): List of unique integers. Returns: int: Length of the longest increasing subsequence. if not arr: return 0 # Initialize DP array with 1s since the shortest increasing subsequence is 1 lis = [1] * len(arr) # Fill `lis` array in a bottom-up DP fashion for i in range(1, len(arr)): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) # Return the maximum value in the `lis` array return max(lis)"},{"question":"Write a function that takes an array of integers `arr` and an integer `threshold`. The function should return the length of the shortest subarray of `arr` whose sum is greater than or equal to `threshold`. If no such subarray exists, return `-1`. Note that a subarray is defined as a contiguous portion of the array.","solution":"def min_subarray_length(arr, threshold): Returns the length of the shortest subarray of `arr` with a sum greater than or equal to `threshold`. If no such subarray exists, returns -1. n = len(arr) min_len = float(\'inf\') # Start with an infinitely large number start = 0 current_sum = 0 for end in range(n): current_sum += arr[end] while current_sum >= threshold: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 # If min_len was never updated, return -1 return min_len if min_len != float(\'inf\') else -1"},{"question":"Given a list of `sentences` where each sentence is a string of words separated by spaces, and a list of `searchWords` which contains individual words, return a count of how many times each search word appears as a **whole word** (case-sensitive) across all sentences. The result should be a dictionary where the keys are the search words and the values are their respective counts.","solution":"def count_search_words(sentences, searchWords): Counts the occurrence of each word in searchWords as a whole word across all sentences. Parameters: sentences (list of str): List of sentences. searchWords (list of str): List of words to search for. Returns: dict: Dictionary with words as keys and their respective counts as values. from collections import Counter # Join all sentences into one long string with all sentences text = \' \'.join(sentences) # Create a list of all words in the text words = text.split() # Create Counter of all words word_count = Counter(words) # Create a result dictionary for the searchWords result = {word: word_count[word] for word in searchWords} return result"},{"question":"You are working with a social networking site that needs to determine the engagement rate on posts within different user-defined intervals. To facilitate this, you need to implement a system that supports the recording of post engagements and then returns the engagement counts for specified intervals. Implement the `PostEngagements` class: - `PostEngagements()` Initializes the `PostEngagements` object. - `void recordEngagement(int postId, int time)` Records an engagement on the `postId` at the given `time` (in seconds). - `List<Integer> getEngagementCounts(int postId, int startTime, int endTime, int interval)` Returns a list of integers where each integer represents the number of engagements in each defined interval (in seconds) within the period `[startTime, endTime]`. The size of each interval is specified by `interval`. For example, if `interval` is `60` (seconds), and `[startTime, endTime]` is `[0, 180]`, you would partition the period into 3 intervals: `[0, 59]`, `[60, 119]`, and `[120, 180]`. Note that the last interval may be shorter and will always end with the `endTime`.","solution":"from collections import defaultdict from bisect import bisect_left, bisect_right class PostEngagements: def __init__(self): Initializes the PostEngagements object. self.engagements = defaultdict(list) def recordEngagement(self, postId, time): Records an engagement on the `postId` at the given `time`. self.engagements[postId].append(time) def getEngagementCounts(self, postId, startTime, endTime, interval): Returns a list of engagement counts for specified intervals within the period `[startTime, endTime]`. if postId not in self.engagements: return [] times = sorted(self.engagements[postId]) counts = [] for t in range(startTime, endTime + 1, interval): start = t end = min(t + interval - 1, endTime) start_idx = bisect_left(times, start) end_idx = bisect_right(times, end) counts.append(end_idx - start_idx) return counts"},{"question":"Given a string `s` consisting of lowercase English letters and a character `ch`, return an array of integers representing the shortest distance from each character in the string to the character `ch`. If the character `ch` does not exist in the string, return an array of the same length as `s` filled with the value `-1`.","solution":"def shortest_to_char(s, ch): Given a string `s` consisting of lowercase English letters and a character `ch`, returns an array of integers representing the shortest distance from each character in the string to the character `ch`. If the character `ch` does not exist in the string, returns an array of the same length as `s` filled with `-1`. if ch not in s: return [-1] * len(s) n = len(s) result = [float(\'inf\')] * n # Forward pass distance = float(\'inf\') for i in range(n): if s[i] == ch: distance = 0 result[i] = distance if distance != float(\'inf\'): distance += 1 # Backward pass distance = float(\'inf\') for i in range(n-1, -1, -1): if s[i] == ch: distance = 0 result[i] = min(result[i], distance) if distance != float(\'inf\'): distance += 1 return result"},{"question":"Given a binary tree, determine if it is a **height-balanced** binary tree. A **height-balanced** binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than one. For this task, you need to implement a function that accepts the `root` of the binary tree and returns `true` if the tree is height-balanced, and `false` otherwise. The `TreeNode` class is provided for you to create the nodes of the tree. You can assume that the binary tree nodes have integer values.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root): Determines if a binary tree is height-balanced. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is height-balanced, False otherwise def check_balanced(node): if not node: return 0, True left_height, left_balanced = check_balanced(node.left) right_height, right_balanced = check_balanced(node.right) current_height = 1 + max(left_height, right_height) is_current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, is_current_balanced return check_balanced(root)[1]"},{"question":"You are given a string `s` of lowercase English letters and an integer `k`. Find the length of the longest substring of `s` that contains at most `k` distinct characters. If there are multiple substrings with the same length, return the one that appears first. Return the length and the substring itself as a tuple.","solution":"def longest_substring_with_k_distinct(s, k): Returns the length and the longest substring with at most k distinct characters. If multiple substrings have the same longest length, the one that appears first is returned. Parameters: s (str): The input string. k (int): The maximum number of distinct characters. Returns: tuple: The length of the substring and the substring itself. if k == 0: return 0, \\"\\" n = len(s) if n == 0: return 0, \\"\\" l, r = 0, 0 max_length = 0 max_substring = \\"\\" char_count = {} while r < n: char_count[s[r]] = char_count.get(s[r], 0) + 1 while len(char_count) > k: char_count[s[l]] -= 1 if char_count[s[l]] == 0: del char_count[s[l]] l += 1 current_length = r - l + 1 if current_length > max_length: max_length = current_length max_substring = s[l:r+1] r += 1 return max_length, max_substring"},{"question":"You are given a 2D grid of size `m x n` representing a map where `1` represents land and `0` represents water. An **island** is a group of `1`s (land) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Return the number of **distinct islands**. Two islands are considered distinct if and only if one island is not equal to another (not counting transformations such as rotations and reflections).__() # Example: **Input**: ```plaintext grid = [ [1, 1, 0, 0, 0], [1, 0, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 0] ] ``` **Output**: ```plaintext 2 ```","solution":"def numDistinctIslands(grid): def dfs(x, y, direction): if (0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1): grid[x][y] = 0 path_signature.append(direction) dfs(x+1, y, \'D\') # go Down dfs(x-1, y, \'U\') # go Up dfs(x, y+1, \'R\') # go Right dfs(x, y-1, \'L\') # go Left path_signature.append(\'B\') # Backtrack distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path_signature = [] dfs(i, j, \'O\') # start of a new island \'O\' for Origin distinct_islands.add(tuple(path_signature)) return len(distinct_islands)"},{"question":"An **image** is represented by a 2D array of integers, where each integer corresponds to a pixel with a certain color value. You are also given an integer called **threshold**. The **image** can be filtered by comparing each pixel with the **threshold** and updating the pixel according to the following rules: - If a pixel value is greater than the threshold, it gets set to `255` (white). - If a pixel value is less than or equal to the threshold, it gets set to `0` (black). Write a function that takes in a 2D array of integers representing the **image** and an integer **threshold**. Return the new 2D array after applying the filter. Ensure that the dimensions and shape of the returned 2D array are the same as the supplied **image**. **Example:** ``` Input: image = [ [34, 200, 123], [56, 78, 190], [33, 240, 88] ] threshold = 100 Output: [ [0, 255, 255], [0, 0, 255], [0, 255, 0] ] ```","solution":"def threshold_filter(image, threshold): Apply a threshold filter to a 2D array representing an image. Parameters: image (list of list of int): 2D array representing the image threshold (int): Integer used as the threshold for filtering Returns: list of list of int: New 2D array after applying the threshold filter filtered_image = [] for row in image: filtered_row = [] for pixel in row: if pixel > threshold: filtered_row.append(255) else: filtered_row.append(0) filtered_image.append(filtered_row) return filtered_image"},{"question":"You are given an array `heights` representing the heights of buildings, where `heights[i]` is the height of the ith building. You are also given several queries where each query contains two integers `start` and `end`. For each query, return the maximum height of the buildings from index `start` to index `end` inclusive. This should be accomplished efficiently to handle multiple queries quickly.","solution":"def max_height_between(heights, queries): Returns a list of maximum heights for each query. Parameters: heights (list[int]): A list of integers representing the heights of buildings. queries (list[tuple[int, int]]): A list of queries where each query is a tuple (start, end). Returns: list[int]: A list of maximum heights for each query. results = [] for start, end in queries: max_height = max(heights[start:end+1]) results.append(max_height) return results # Example usage: # heights = [4, 1, 3, 7, 2, 4, 6] # queries = [(1, 3), (0, 4), (2, 5)] # max_height_between(heights, queries) should return [7, 7, 7]"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped between building heights where the width of each building (bar) is 1. Each integer represents the height of a building (bar). Write a function that calculates the maximum amount of rainwater that can be trapped. For example, given the list `[0,1,0,2,1,0,1,3,2,1,2,1]`, your function should return `6` indicating that 6 units of rainwater can be trapped between the buildings. Implement and return the function that solves this problem.","solution":"def trap(height): Calculate the total amount of rainwater trapped. :param height: List[int] - non-negative integers representing building heights :return: int - total amount of rainwater trapped if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] total_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) total_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) total_water += max(0, right_max - height[right]) return total_water"},{"question":"You are given an integer array `nums` and two integers `m` and `k`. Your task is to determine if you can split the `nums` array into exactly `m` non-empty subarrays such that the sum of the maximum elements of these subarrays is at least `k`. Return `true` if it is possible to achieve this partition, and `false` otherwise.","solution":"def can_split(nums, m, k): Determines if the nums array can be split into exactly m non-empty subarrays such that the sum of the maximum elements of these subarrays is at least k. Args: nums (list of int): List of integers. m (int): Number of subarrays. k (int): Minimum required sum of maximum elements of subarrays. Returns: bool: True if possible to partition as described, otherwise False. if len(nums) < m: return False # Function to determine if a given limit for maximum subarray sum is possible def can_partition_with_max_sum(limit): count = 1 current_sum = 0 for num in nums: if current_sum + num > limit: count += 1 current_sum = num if count > m: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition_with_max_sum(mid): right = mid else: left = mid + 1 max_each_subarray_sum_possible = left if can_partition_with_max_sum(max_each_subarray_sum_possible): return sum([max(nums[i:i + len(nums) // m]) for i in range(0, len(nums), len(nums) // m)]) >= k return False"},{"question":"You are given a **0-indexed** array of integers `arr` and an integer `k`. Create a function that returns the number of **subarrays** with elements that sum up to `k`. A subarray is a contiguous part of an array.","solution":"def subarray_sum(arr, k): Returns the number of subarrays with elements that sum up to k. from collections import defaultdict count = 0 current_sum = 0 sum_dict = defaultdict(int) sum_dict[0] = 1 # there is one way to have a sum of 0 (with an empty subarray) for num in arr: current_sum += num if (current_sum - k) in sum_dict: count += sum_dict[current_sum - k] sum_dict[current_sum] += 1 return count"},{"question":"Given an unsorted array of integers `nums`, find the length of the longest increasing subsequence. An increasing subsequence is a sequence of elements that appear in ascending order, but not necessarily consecutively in the array. Write a function `longestIncreasingSubsequence(nums)` that takes in the array `nums` and returns the length of the longest increasing subsequence. Use dynamic programming to solve this problem efficiently.","solution":"def longestIncreasingSubsequence(nums): Returns the length of the longest increasing subsequence in the unsorted array nums. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given two **0-indexed** integer arrays `nums1` and `nums2` of the same length `n`. Each array represents a list of sequential game scores for two players. Your task is to find and return the length of the **longest common subarray** between `nums1` and `nums2`. A subarray is defined as a contiguous segment of an array. For instance, in the array `[1, 2, 3, 4]`, the subarrays include `[1, 2]`, `[2, 3, 4]`, and `[1, 2, 3]`, among others.","solution":"def longest_common_subarray(nums1, nums2): Returns the length of the longest common subarray between nums1 and nums2. n = len(nums1) m = len(nums2) # Initialize a 2D array to store lengths of longest common subarray segments. dp = [[0]*(m+1) for _ in range(n+1)] max_length = 0 # Fill the dp table. for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) else: dp[i][j] = 0 return max_length"},{"question":"Write a function `findWinners` to determine the winners of a gaming competition. You are given an array of arrays, where each sub-array consists of three elements: [player_id, opponent_id, result]. The `player_id` and `opponent_id` are IDs of the players who competed in a match, and `result` is 1 if `player_id` won and 0 if `opponent_id` won. A player can be considered a \\"winner\\" if they won all their matches. Return an array with the IDs of all the winners in ascending order.","solution":"def findWinners(matches): Determines the winners of a gaming competition. A player is considered a winner if they won all their matches. Parameters: matches (list of list): Each sub-list consists of three elements [player_id, opponent_id, result]. The result is 1 if `player_id` won, and 0 if `opponent_id` won. Returns: list: List of winner player IDs in ascending order. from collections import defaultdict # Win and lose counters for each player wins = defaultdict(int) losses = defaultdict(int) players = set() for match in matches: player_id, opponent_id, result = match players.add(player_id) players.add(opponent_id) if result == 1: wins[player_id] += 1 losses[opponent_id] += 1 else: wins[opponent_id] += 1 losses[player_id] += 1 # A player is a winner if they won all their matches (i.e., they have 0 losses) winners = [player for player in players if losses[player] == 0] return sorted(winners)"},{"question":"You are given an integer `n` and an array `requests` where `requests[i] = [start_i, end_i]` represents a request to add one building in each empty slot from `start_i` to `end_i`. You need to return the maximum number of requests that can be accommodated without overlapping any of the intervals from the requests array. Each building can only be added in a slot that is initially empty, and no two buildings can overlap.","solution":"def max_non_overlapping_requests(n, requests): Returns the maximum number of non-overlapping requests. Parameters: n (int): Number of slots. requests (List[List[int]]): List of [start, end] for each request. Returns: int: Maximum number of requests that can be accommodated without overlap. # Sort requests based on the ending slot requests.sort(key=lambda x: x[1]) count = 0 last_end = -1 for start, end in requests: if start > last_end: count += 1 last_end = end return count"},{"question":"You are given a string `s` and an integer `k`. The string `s` can be divided into contiguous substrings such that each substring contains exactly `k` distinct characters. Return _the **minimum** number of substrings required to achieve this division_. If it\'s not possible to divide the string in such a way, return `-1`.","solution":"def min_substrings_with_k_distinct_chars(s, k): Returns the minimum number of substrings required such that each substring contains exactly k distinct characters. If it\'s not possible, returns -1. if k > len(set(s)): return -1 # More distinct characters required than available in the string start = 0 num_substrings = 0 while start < len(s): char_set = set() substring_valid = False for end in range(start, len(s)): char_set.add(s[end]) if len(char_set) == k: num_substrings += 1 start = end + 1 substring_valid = True break if not substring_valid: return -1 # If a valid substring with k distinct chars was not formed return num_substrings"},{"question":"Given a 2D grid of size `n x m` representing a map where `1` represents land and `0` represents water, an island is a group of `1`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Count the number of distinct islands. An island is considered distinct if and only if it is not a duplicate of any other island. Two islands are considered the same if and only if one island can be translated (not rotated or reflected) to match another. Write a function `numDistinctIslands(grid: List[List[int]]) -> int` that returns the number of distinct islands. **Note:** - The dimensions of the grid `n` and `m` are between `1` and `50`. - Grid elements will be either `0` or `1`.","solution":"from typing import List, Set, Tuple def numDistinctIslands(grid: List[List[int]]) -> int: def dfs(x: int, y: int, pos: Tuple[int, int], island: Set[Tuple[int, int]]): if 0 <= x < n and 0 <= y < m and grid[x][y] == 1: grid[x][y] = 0 island.add(pos) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: dfs(x + dx, y + dy, (pos[0] + dx, pos[1] + dy), island) def normalize(island: Set[Tuple[int, int]]) -> Tuple[Tuple[int, int], ...]: min_x = min(x for x, y in island) min_y = min(y for x, y in island) return tuple(sorted((x - min_x, y - min_y) for x, y in island)) n = len(grid) m = len(grid[0]) unique_islands = set() for i in range(n): for j in range(m): if grid[i][j] == 1: island = set() dfs(i, j, (0, 0), island) normalized_island = normalize(island) unique_islands.add(normalized_island) return len(unique_islands)"},{"question":"You are given a list of `n` integers, where each integer represents a person\'s unique ID number. The list is sorted in non-decreasing order. There are exactly `n+1` integers in the list, and one integer is repeated exactly twice. Find and return the ID number that is repeated. Your solution should have a time complexity of O(log n).","solution":"def find_duplicate_id(ids): Finds and returns the ID number that is repeated exactly twice. The list is sorted in non-decreasing order. Time complexity: O(log n) left, right = 0, len(ids) - 1 while left < right: mid = left + (right - left) // 2 # Check the number of unique numbers on the left part of the array if ids[mid] >= mid + ids[0]: left = mid + 1 else: right = mid return ids[left]"},{"question":"You are given an array `plants` where `plants[i]` represents the amount of water required by the `i-th` plant. You start with an `empty` watering can of capacity `capacity`. You can refill the watering can any number of times at the river, but each refill takes a fixed amount of time `refillTime`. Write a program that determines the minimum time required to water all the plants in the sequence. Note that moving from the river to the plants or between plants takes no additional time. Return the _minimum **time** required to water all the plants in the order given._","solution":"def min_watering_time(plants, capacity, refillTime): Calculate the minimum time required to water all the plants. Parameters: - plants: list of int, each representing the water required by each plant. - capacity: int, capacity of the watering can. - refillTime: int, time taken to refill the watering can. Returns: - int, minimum time required to water all plants. time = 0 current_water = capacity for water_needed in plants: if current_water >= water_needed: current_water -= water_needed else: time += refillTime current_water = capacity - water_needed return time"},{"question":"You are given two strings `s` and `t` consisting of lowercase letters. You need to **transform** `s` into `t` using the following operations any number of times: 1. **Insert** a character at any position in `s`. 2. **Delete** a character from `s`. 3. **Replace** a character in `s` with another character. Write an algorithm to determine the **minimum number of operations** required to transform `s` into `t`.","solution":"def min_distance(s, t): Returns the minimum number of operations required to transform string s into string t. The operations allowed are Insert, Delete, Replace. m, n = len(s), len(t) # Create a DP table to store the number of operations required dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table with the base cases for i in range(m + 1): dp[i][0] = i # Delete all characters from s to make it empty for j in range(n + 1): dp[0][j] = j # Insert all characters of t into s # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j - 1], # Replace dp[i - 1][j], # Delete dp[i][j - 1]) # Insert dp[i][j] += 1 return dp[m][n]"},{"question":"Given an integer `numRows`, generate the first `numRows` of Pascal\'s Triangle. In Pascal\'s Triangle, each number is the sum of the two numbers directly above it. The triangle starts with a single `1` at the top, and each row has one more number than the previous row. For example, if `numRows` is `5`, the result should be: ``` [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] ```","solution":"def generate_pascal_triangle(numRows): Generate the first `numRows` of Pascal\'s Triangle. :param numRows: The number of rows of Pascal\'s Triangle to generate :type numRows: int :return: A list of lists representing the first `numRows` of Pascal\'s Triangle :rtype: list if numRows <= 0: return [] triangle = [[1]] for row_num in range(1, numRows): row = [1] prev_row = triangle[row_num - 1] for i in range(1, row_num): row.append(prev_row[i - 1] + prev_row[i]) row.append(1) triangle.append(row) return triangle"},{"question":"You are given an integer array `arr` of size `n` where `n` is even. Split the array into two subsets equal in size and return the minimum possible absolute difference between the sums of the two subsets. The two subsets must satisfy the condition of being equally sized, meaning each subset should have `n/2` elements. Ensure to explore all possible splits and determine the split giving the minimal sum difference.","solution":"from itertools import combinations def min_subset_sum_diff(arr): Given an even-sized array, splits it into two subsets of equal size and returns the minimum possible absolute difference between the sums of the two subsets. n = len(arr) total_sum = sum(arr) half_n = n // 2 # Generate all combinations of size half_n combinations_list = list(combinations(arr, half_n)) min_diff = float(\'inf\') for combo in combinations_list: subset_sum = sum(combo) complement_sum = total_sum - subset_sum diff = abs(subset_sum - complement_sum) if diff < min_diff: min_diff = diff return min_diff"},{"question":"Given a binary matrix of `0`s and `1`s, where `0` represents an empty cell and `1` represents a blocked cell. Find the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1), moving only through empty cells. You can move up, down, left, or right. Return the length of the shortest path if it exists. If there is no such path, return -1. Implement your solution using a Breadth-First Search (BFS) algorithm.","solution":"from collections import deque def shortest_path_bfs(matrix): Finds the shortest path in a binary matrix from top-left to bottom-right corner using BFS. Args: matrix: List[List[int]] - Binary matrix containing 0s and 1s where 0 represents empty cell and 1 represents blocked cell. Returns: int - Length of the shortest path from top-left to bottom-right corner. If no such path exists, return -1. if not matrix or not matrix[0] or matrix[0][0] == 1 or matrix[-1][-1] == 1: return -1 n, m = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 1)]) # (x, y, distance) matrix[0][0] = 1 # mark as visited while queue: x, y, distance = queue.popleft() if x == n - 1 and y == m - 1: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 0: queue.append((nx, ny, distance + 1)) matrix[nx][ny] = 1 # mark as visited return -1"},{"question":"You are given a string `s` and an integer `k`. You need to perform the following operation exactly `k` times: Select any character from `s` and remove it from the string. Your goal is to minimize the resultant string\'s lexicographical order after performing the `k` operations. Return the resultant string.","solution":"def minimize_string_by_removal(s, k): This function minimizes the lexicographical order of the string `s` by exactly removing `k` characters. Parameters: s (str): The input string k (int): The number of characters to remove Returns: str: The minimized lexicographical order string stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If there are still characters to remove, remove them from the end final_stack = stack[:-k] if k > 0 else stack return \'\'.join(final_stack)"},{"question":"You are given an array of integers `heights` representing the heights of buildings along a street, arranged in left to right order. You are standing at the leftmost building and want to walk to the rightmost building, but you can only move to the next building if it is the same height or taller than the current one. As you walk, you also want to count the number of different buildings you can visit. Return the maximum number of different buildings that you can visit by following these rules.","solution":"def max_buildings(heights): Returns the maximum number of different buildings that can be visited by following the rules. Parameters: heights (list): A list of integer heights of the buildings. Returns: int: The maximum number of buildings that can be visited. if not heights: return 0 count = 1 # at least can visit the first building current_height = heights[0] for height in heights[1:]: if height >= current_height: count += 1 current_height = height return count"},{"question":"You are given a list of integers `prices` where `prices[i]` represents the price of a given stock on the `i`-th day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`. Implement the function: * `int maxProfit(int[] prices)` which takes an integer array `prices` and returns an integer representing the maximum profit.","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved by buying and selling one stock. :param prices: List[int] - List of stock prices where prices[i] is the price on the ith day. :return: int - Maximum profit possible, or 0 if no profit can be made. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Given a nested list of integers where each element is a list of two integers `[start, end]` representing an interval, merge all overlapping intervals and return an array of the merged intervals. The intervals should be returned in ascending order by their starting point. For example, if the input is `[[1, 3], [2, 6], [8, 10], [15, 18]]`, the output should be `[[1, 6], [8, 10], [15, 18]]` since the first two intervals overlap and merge into `[1, 6]`.","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns an array of the merged intervals. Args: intervals (list of lists): A list of [start, end] intervals. Returns: list of lists: A list of the merged intervals in ascending order by their starting point. if not intervals: return [] # Sort the intervals based on the starting points intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If the list of merged intervals is empty or if the current interval does not overlap with the last one, add it. if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # Otherwise, there is overlap, so we merge the current interval with the last one. merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"You are given a **0-indexed** 2D integer array `grid` of size `m x n` representing a grid of land and water. An entry `grid[i][j]` is `0` if it represents water, and `1` if it represents land. A **connected component** in the grid is a set of `1`s (land) connected by `4-directional` (horizontal or vertical) connections. You can only perform `2 types` of operations: **add water (set 1 to 0)** or **add land (set 0 to 1)**. Return _the **minimum** number of operations required to turn the grid into a grid with exactly one connected component of land._ If it is already a single connected component, return _`0`._","solution":"from collections import deque # Define direction vectors for 4-directional movement (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(x, y, grid, visited): m, n = len(grid), len(grid[0]) queue = deque([(x, y)]) visited[x][y] = True while queue: cx, cy = queue.popleft() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 1: visited[nx][ny] = True queue.append((nx, ny)) def count_components(grid): m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: count += 1 bfs(i, j, grid, visited) return count def min_operations_to_one_component(grid): components = count_components(grid) # If already one component, return 0 return max(components - 1, 0)"},{"question":"You are given a list of flight bookings represented by a 2D integer array `bookings` where each `bookings[i] = [firsti, lasti, seatsi]` indicates that there are `seatsi` seats booked on each flight from `firsti` to `lasti` (inclusive). Return an integer array `answer` of length `n`, where `answer[i]` is the total number of seats booked on flight `i + 1` in the overall range. Example: If `bookings = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]` and `n = 5`, the resulting array should be `[10, 55, 45, 25, 25]`.","solution":"def corpFlightBookings(bookings, n): Returns the number of seats booked on each flight. :param bookings: List of bookings where each booking is [first, last, seats] :param n: Total number of flights :return: List representing seats booked on each flight seats = [0] * (n + 1) # Apply the bookings to the seats array using a difference array approach for first, last, seats_count in bookings: seats[first - 1] += seats_count if last < n: seats[last] -= seats_count # Calculate the final number of seats booked per flight for i in range(1, n): seats[i] += seats[i - 1] return seats[:n]"},{"question":"Given an array of integers `_arr_`, reverse the order of elements in each subarray of size `k`. If the number of elements in the last subarray is less than `k`, simply reverse all the remaining elements. The array should be modified in place. Return the modified array. For example, given the array `[1, 2, 3, 4, 5, 6, 7, 8, 9]` and `k = 3`, the output should be `[3, 2, 1, 6, 5, 4, 9, 8, 7]`.","solution":"def reverse_in_groups(arr, k): Reverses the order of elements in each subarray of size `k`. If the number of elements in the last subarray is less than `k`, reverse all the remaining elements. The array is modified in place. :param arr: List[int] - the array of integers to be modified. :param k: int - the size of the subarray to be reversed. :return: List[int] - the modified array with the reversed subarrays. n = len(arr) for start in range(0, n, k): end = min(start + k, n) arr[start:end] = arr[start:end][::-1] return arr"},{"question":"You are given a list of strings `words` and a string `pattern`. You need to find all strings in `words` that match the pattern. A word matches the pattern if there exists some permutation of letters `p` so that after replacing every letter `x` in the pattern with `p(x)`, you get exactly the word. Return a list of the words in `words` that match the pattern. All words and patterns consist only of lowercase English letters. Note that one letter cannot map to multiple letters, but a letter may map to itself.","solution":"def find_and_replace_pattern(words, pattern): def match(word): if len(word) != len(pattern): return False word_to_pattern = {} pattern_to_word = {} for w, p in zip(word, pattern): if w not in word_to_pattern: word_to_pattern[w] = p if p not in pattern_to_word: pattern_to_word[p] = w if word_to_pattern[w] != p or pattern_to_word[p] != w: return False return True return [word for word in words if match(word)]"},{"question":"You are given a matrix `mat` of integers with `m` rows and `n` columns. Implement the `MatrixManipulator` class with the following methods: `MatrixManipulator`: A constructor that takes a 2D integer array `mat` as an argument and initializes the matrix. `transpose()`: Transposes the matrix. Transposing a matrix means converting rows into columns and columns into rows. `rotate(direction)`: Rotates the matrix 90 degrees. The `direction` parameter will be either `\'clockwise\'` or `\'counterclockwise\'` specifying the rotation direction. `sumRegion(row1, col1, row2, col2)`: Returns the sum of elements in the rectangular region defined by the corners `(row1, col1)` and `(row2, col2)` inclusive, where `0 <= row1 <= row2 < m` and `0 <= col1 <= col2 < n`. Implement the `MatrixManipulator` class with the methods described above.","solution":"class MatrixManipulator: def __init__(self, mat): self.mat = mat def transpose(self): self.mat = list(map(list, zip(*self.mat))) def rotate(self, direction): if direction == \'clockwise\': self.transpose() for row in self.mat: row.reverse() elif direction == \'counterclockwise\': self.transpose() self.mat.reverse() def sumRegion(self, row1, col1, row2, col2): return sum( self.mat[i][j] for i in range(row1, row2 + 1) for j in range(col1, col2 + 1) )"},{"question":"You are given a string `s` composed of lowercase alphabets and another string `target`. You need to find the minimum number of operations required to transform `s` into `target`. The only operation allowed is swapping any two adjacent characters in `s`. Return the minimum number of swaps required to transform `s` into `target`, or `-1` if it is impossible to do so.","solution":"def min_swaps_to_transform(s, target): if sorted(s) != sorted(target): return -1 def count_inversions(s_list): inversions = 0 for i in range(len(s_list)): for j in range(i + 1, len(s_list)): if s_list[i] > s_list[j]: inversions += 1 return inversions s_list = list(s) target_list = list(target) inversions_initial = count_inversions(s_list) inversions_target = count_inversions(target_list) return abs(inversions_initial - inversions_target)"},{"question":"Given an m x n integer matrix `grid` where `grid[i][j]` represents the number of apples at cell `(i, j)`. You are initially positioned at the top-left corner of the grid `(0, 0)` and you need to move to the bottom-right corner `(m-1, n-1)`. In one move, you can either move right or move down. You cannot move diagonally. Additionally, there is a condition that you can only collect apples from cells that are visited during the path. Return the maximum number of apples you can collect on the way to the bottom-right corner of the grid.","solution":"def max_apples(grid): Returns the maximum number of apples collected on the way to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize dp table with the same size as grid dp = [[0] * n for _ in range(m)] # Fill the dp table dp[0][0] = grid[0][0] # Starting point # Fill the first row (can only move right) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only move down) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given an array of integers `arr` and an integer `n`. Find the **number of subarrays** (contiguous non-empty sequences of elements) of `arr` whose product of elements is less than `n`. Return _this count_. Note that the product of a subarray containing a single element is the element itself.","solution":"def num_subarrays_with_product_less_than_n(arr, n): Returns the count of subarrays whose product of elements is less than n. if n <= 1: return 0 count = 0 product = 1 start = 0 for end in range(len(arr)): product *= arr[end] while product >= n and start <= end: product //= arr[start] start += 1 count += (end - start + 1) return count"},{"question":"Implement a function to determine if a given string is a permutation of a palindrome. A palindrome is a string that reads the same forward and backward. A permutation is a rearrangement of letters. The function should return `true` if the string is a permutation of a palindrome and `false` otherwise. The input string will contain only lowercase letters and may include spaces. Ignore spaces and consider all letters in lowercase.","solution":"def is_palindrome_permutation(s): Determine if the given string is a permutation of a palindrome. Parameters: s (str): The input string containing only lowercase letters and spaces. Returns: bool: True if the string is a permutation of a palindrome, False otherwise. # Clean the string: remove spaces and convert to lowercase s = s.replace(\\" \\", \\"\\").lower() # Count the frequency of each character char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 # Check the counts of characters odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # For a string to be a permutation of a palindrome: # it can have at most one character with an odd count return odd_count <= 1"},{"question":"Given an array of integers `nums` of length `n`, find the maximum sum you can obtain by forming a contiguous subarray (a subarray of consecutive elements). Your function should return an integer representing this maximum sum. If the input array is empty or the maximum sum is negative, return 0. Note: The contiguous subarray must contain at least one element.","solution":"def max_subarray_sum(nums): Returns the maximum sum of a contiguous subarray. If the input array is empty or the maximum sum is negative, return 0. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max(max_sum, 0)"},{"question":"You are given an undirected graph represented by an integer `n` which denotes the number of nodes (labeled `0` to `n-1`) and an array `edges` of length `m` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi`. Each node has a certain value represented in the array `nodeValue`, where `nodeValue[i]` represents the value of node `i`. Your task is to find the sum of node values for the largest connected component in the graph. A connected component is a subset of nodes in the graph such that there exists a path between any two nodes in this subset, and this subset is connected independently from other nodes. Return the sum of node values for the largest connected component. If there are multiple largest components, return the sum for any one of them.","solution":"def largest_connected_component_sum(n, edges, nodeValue): from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited[node] = True component_sum = 0 while queue: current = queue.popleft() component_sum += nodeValue[current] for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_sum # Create the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * n max_sum = 0 for i in range(n): if not visited[i]: component_sum = bfs(i) max_sum = max(max_sum, component_sum) return max_sum"},{"question":"You are given an integer array `nums` and you are allowed to perform a specific operation any number of times on `nums`. In one operation, you can choose any element of the array and increment it by 1. Return the **minimum number of operations** needed to make all elements of the array pairwise distinct. Example: Input: `nums = [3,2,1,2,1,7]` Output: `6` Explanation: You can perform the following operations: 1. Increment `nums[4]` from 1 to 8. Now `nums` becomes [3,2,1,2,8,7]. 2. Increment `nums[3]` from 2 to 9. Now, `nums` becomes [3,2,1,9,8,7]. 3. Increment `nums[2]` from 1 to 10. Now, `nums` becomes [3,2,10,9,8,7]. A total of 6 operations are needed to make all elements of the array distinct.","solution":"def min_operations(nums): nums.sort() operations = 0 for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: increment = nums[i - 1] - nums[i] + 1 nums[i] += increment operations += increment return operations"},{"question":"Design an algorithm to find the longest common subsequence of two given strings `s1` and `s2`. The longest common subsequence (LCS) is defined as the longest sequence that can be derived from both strings by deleting some characters without reordering the remaining characters. For example, if `s1 = \\"abcde\\"` and `s2 = \\"ace\\"`, the longest common subsequence is `\\"ace\\"`, which has a length of 3. Your algorithm should return the length of the LCS. Be sure to consider all possible ways of forming the subsequence and to use an efficient approach to handle cases where the strings can be of considerable length.","solution":"def longest_common_subsequence(s1, s2): Finds the length of the longest common subsequence between two strings s1 and s2. :param s1: First string :param s2: Second string :return: Length of the longest common subsequence m, n = len(s1), len(s2) # Create a 2D list (m+1) x (n+1) filled with zeros dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array, iterating through each character of both strings for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of the longest common subsequence is at dp[m][n] return dp[m][n]"},{"question":"Given a string `s` and an array `words` of strings, return _the number of times `words[i]` appears as a substring in `s` for all `i`_. *Example:* For `s = \\"abcdef\\"` and `words = [\\"a\\", \\"bc\\", \\"def\\", \\"f\\"]`, the function should return `4` since `\\"a\\"`, `\\"bc\\"`, `\\"def\\"`, and `\\"f\\"` each appear as substrings in `\\"abcdef\\"`.","solution":"def count_substrings(s, words): Returns the number of times each word in words appears as a substring in s. Parameters: s (str): The main string. words (list of str): List of words to check. Returns: int: The number of times words[i] appears as a substring in s. count = 0 for word in words: if word in s: count += 1 return count"},{"question":"Given an integer array `nums` of length `n`, you need to find the maximum sum you can obtain by selecting some non-empty subarray (contiguous elements) of `nums` such that, for each selected subarray, at most one element can be deleted. You may assume that the given array contains at least one positive element. Return the maximum possible sum of the subarray, considering the constraint of deleting at most one element.","solution":"def maximum_sum(nums): Returns the maximum sum of a subarray with at most one element deletion. n = len(nums) if n == 1: return nums[0] max_ending_here = [0] * n max_starting_here = [0] * n # Initialize the first elements max_ending_here[0] = nums[0] for i in range(1, n): max_ending_here[i] = max(nums[i], max_ending_here[i-1] + nums[i]) max_starting_here[n-1] = nums[n-1] for i in range(n-2, -1, -1): max_starting_here[i] = max(nums[i], max_starting_here[i+1] + nums[i]) max_sum = max(max_ending_here) # This is the max sum without deleting any element for i in range(1, n-1): max_sum = max(max_sum, max_ending_here[i-1] + max_starting_here[i+1]) return max_sum"},{"question":"You are given an integer array `height` representing the height of buildings. The width of each building is 1. Two buildings can be viewed as a container, where the height of the container is the minimum height of the two buildings, and the width is the distance between them. Return the maximum amount of water a container can store, which is calculated by the product of width and height. Example: Input: `height = [1,8,6,2,5,4,8,3,7]` Output: `49` Explanation: The container formed by the building at index 1 (height = 8) and the building at index 8 (height = 7) has a width of 8 - 1 = 7 and a height of min(8, 7) = 7. So, the container can store 7 * 7 = 49 units of water.","solution":"def max_area(height): Returns the maximum amount of water a container can store. max_water = 0 left, right = 0, len(height) - 1 while left < right: # Calculating the width and the current water amount width = right - left current_water = min(height[left], height[right]) * width # Updating the maximum water if the current is larger max_water = max(max_water, current_water) # Moving the pointer with the smaller height inward if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given an **m x n** matrix `mat` where each element is either a `0` or a `1`. You know that in each row of the matrix, all `1`\'s appear before all `0`\'s. Find the row with the highest number of 1\'s and return its index. If there are multiple rows with the highest number of 1\'s, return the smallest index among them. If all rows consist only of 0\'s, return `-1`.","solution":"def row_with_max_ones(mat): Returns the index of the row with the highest number of 1\'s in a given matrix where each element is either a 0 or a 1, and 1\'s appear before 0\'s in each row. If there are multiple such rows, return the smallest index among them. If all rows consist only of 0\'s, return -1. :param mat: List[List[int]]; the matrix with 0\'s and 1\'s :return: int; the index of the row with the highest number of 1\'s max_1s_row_index = -1 max_1s_count = 0 for i, row in enumerate(mat): count_1s = row.count(1) if count_1s > max_1s_count: max_1s_count = count_1s max_1s_row_index = i # Since the rows are sorted with 1\'s before 0\'s, if we find a row with all 1\'s # we can break early as it won\'t get any better if max_1s_count == len(row): break return max_1s_count == 0 and -1 or max_1s_row_index"},{"question":"Given a 2D grid of size `m x n` where each cell represents a piece of land marked by `1` or water marked by `0`, you need to find the shortest distance from any water cell to the nearest land cell. The distance between two cells is measured by the number of cells traversed in a 4-directional path (up, down, left, right). Return _the shortest such distance_. If there is no water cell or no land cell in the grid, return `-1`.","solution":"from collections import deque def shortest_distance_to_land(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) distance = [[-1] * n for _ in range(m)] queue = deque() # Initialize the queue with all land cells and distances set to 0 for i in range(m): for j in range(n): if grid[i][j] == 1: queue.append((i, j)) distance[i][j] = 0 if not queue: return -1 # No land cell in the grid if len(queue) == m * n: return -1 # No water cell in the grid directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < m and 0 <= new_y < n and distance[new_x][new_y] == -1: distance[new_x][new_y] = distance[x][y] + 1 queue.append((new_x, new_y)) shortest_distance = float(\'inf\') for i in range(m): for j in range(n): if grid[i][j] == 0 and distance[i][j] != -1: shortest_distance = min(shortest_distance, distance[i][j]) return shortest_distance if shortest_distance != float(\'inf\') else -1"},{"question":"Implement a class `WordDictionary` that supports the following operations: `addWord` and `search`. * `WordDictionary()` Initializes the object. * `void addWord(word)` Adds a word to the data structure. * `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `.` where dots can be matched with any letter. ```python class WordDictionary: def __init__(self): Initialize your data structure here. pass def addWord(self, word: str) -> None: Adds a word into the data structure. pass def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. pass ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def addWord(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"Given an array of integers `arr`, find the maximum length of a contiguous subarray that satisfies the condition that there are more even numbers than odd numbers. If no such subarray exists, return `0`.","solution":"def max_length_more_evens(arr): Returns the maximum length of a contiguous subarray that has more even numbers than odd numbers. If no such subarray exists, returns 0. n = len(arr) even_count = 0 odd_count = 0 max_length = 0 count_diff_map = {0: -1} for i in range(n): if arr[i] % 2 == 0: even_count += 1 else: odd_count += 1 diff = even_count - odd_count if diff > 0: max_length = i + 1 elif diff in count_diff_map: max_length = max(max_length, i - count_diff_map[diff]) else: count_diff_map[diff] = i return max_length"},{"question":"You are given a string `s` consisting of parentheses (`\'(\'` and `\')\'`) and asterisks (`\'*\'`). The asterisks can represent either an empty string, a single `\'(\'`, or a single `\')\'`. Write a function to determine if the string can be made valid by replacing the asterisks. A string is considered valid if there are no unmatched parentheses and the order of the parentheses is correct. Return _`true` if the string can be made valid, and_ `false` _otherwise._","solution":"def checkValidString(s): Determine if the string can be made valid by replacing the asterisks. Uses a greedy approach by tracking the possible minimum and maximum number of open parentheses at any given point in the string scan. :param s: str, input string containing \'(\', \')\' and \'*\' :return: bool, True if the string can be made valid, else False min_open = 0 # minimum number of open parentheses max_open = 0 # maximum number of open parentheses for char in s: if char == \'(\': min_open += 1 max_open += 1 elif char == \')\': min_open = max(min_open - 1, 0) max_open -= 1 elif char == \'*\': min_open = max(min_open - 1, 0) max_open += 1 if max_open < 0: return False return min_open == 0"},{"question":"You are given a **0-indexed** 2D integer array `intervals` where each `intervals[i] = [start_i, end_i]` represents the start and end of the `i-th` interval. Your task is to find and return _all intervals that are not **covered** by another interval in the array_. An interval `[a, b]` is **covered** by an interval `[c, d]` if and only if `c <= a` and `b <= d`. Return _the remaining intervals after removing all that are covered by another interval in the array_ in any order.","solution":"def remove_covered_intervals(intervals): Removes intervals covered by another interval from the list of intervals. Args: intervals (List[List[int]]): A list of intervals where each interval is represented as [start, end]. Returns: List[List[int]]: The list of intervals after removing the covered ones. # Sort intervals by starting point; if two intervals have the same start, sort by end in descending order. intervals.sort(key=lambda x: (x[0], -x[1])) remaining_intervals = [] prev_end = 0 for start, end in intervals: # An interval is not covered if its end point is greater than the previously recorded end point. if end > prev_end: remaining_intervals.append([start, end]) prev_end = end return remaining_intervals"},{"question":"You are given a list of words and a pattern. Return a list of words that match the given pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing each letter x in the pattern with p(x), we get the desired word. The pattern and the words in the given list contain only lowercase letters.","solution":"def find_and_replace_pattern(words, pattern): def match(word, pattern): if len(word) != len(pattern): return False char_map = {} used_chars = set() for w, p in zip(word, pattern): if p not in char_map: if w in used_chars: return False char_map[p] = w used_chars.add(w) elif char_map[p] != w: return False return True return [word for word in words if match(word, pattern)]"},{"question":"You are given a binary search tree (BST) with non-negative values and a target value `k`. Write a function to return whether there exist two different nodes in the BST such that their values sum up to `k`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_target(root, k): Returns whether there exist two different nodes in the BST such that their values sum up to k. if not root: return False def inorder_traversal(node): # Conduct an in-order traversal to get a sorted list of values if not node: return [] left_values = inorder_traversal(node.left) right_values = inorder_traversal(node.right) return left_values + [node.val] + right_values values = inorder_traversal(root) left, right = 0, len(values) - 1 while left < right: current_sum = values[left] + values[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"You are given an integer array `arr` of size `n` and an integer `maxK`. Your task is to find pairs of indices `(i, j)` such that `i < j` and the sum of `arr[i] + arr[j]` is less than or equal to `maxK`. Return the total number of such pairs. For example, given `arr = [1, 2, 3, 4]` and `maxK = 5`, the pairs that satisfy the condition are `(0, 1)`, `(0, 2)`, `(1, 2)`, and `(0, 3)`. Thus, the function should return 4.","solution":"def count_pairs(arr, maxK): Given an integer array `arr` and an integer `maxK`, return the number of pairs of indices (i, j) such that i < j and arr[i] + arr[j] <= maxK. :param arr: List[int] - The input array :param maxK: int - The maximum sum constraint :return: int - Number of pairs satisfying the condition n = len(arr) count = 0 for i in range(n): for j in range(i + 1, n): if arr[i] + arr[j] <= maxK: count += 1 return count"},{"question":"You are given two integer arrays `nums1` and `nums2` of length `n` each, which represent two sequences of numbers. A subsequence of `nums1` is a sequence that can be derived by deleting zero or more elements from `nums1`, and similarly, a subsequence of `nums2` can be derived from deleting zero or more elements from `nums2`. Your task is to find the length of the longest common subsequence (LCS) of the two sequences `nums1` and `nums2`. The longest common subsequence is the longest sequence that can be derived from both `nums1` and `nums2` by deleting elements without changing the order of the remaining elements. Given the integer arrays `nums1` and `nums2`, return _the length of the longest common subsequence_ of `nums1` and `nums2`.","solution":"def longest_common_subsequence(nums1, nums2): Returns the length of the longest common subsequence between nums1 and nums2. n, m = len(nums1), len(nums2) # Create a 2D DP array dp = [[0] * (m + 1) for _ in range(n + 1)] # Iterate over each element in nums1 and nums2 for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] == nums2[j - 1]: # If elements are the same, take diagonal value and add 1 dp[i][j] = dp[i - 1][j - 1] + 1 else: # If elements are different, take the maximum of the top or left value dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"You are given a maze represented by a 2D grid of characters, where each cell is a wall \'X\' or an open space \'.\'. Your goal is to find the shortest path from a starting cell to a destination cell. The path can only pass through open spaces and cannot pass through walls. You can move up, down, left, or right. Implement a function that takes the grid and the coordinates of the starting cell and destination cell, then returns the length of the shortest path between them. If there is no valid path, return -1. **Note**: - The length of the path is the number of cells traversed from the start to the destination, including the starting and destination cells. - The grid is guaranteed to have at least a 1x1 dimension with a valid open space for the starting and destination cells.","solution":"from collections import deque def shortest_path(maze, start, end): if not maze or not maze[0]: return -1 rows, cols = len(maze), len(maze[0]) queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == \'.\' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Given an integer array `arr`, a **subarray** is a contiguous part of an array. A **subarray sum** is the sum of all elements in that subarray. Return the number of subarrays that have an even sum. Since the number can be large, return the result **modulo** `10^9 + 7`.","solution":"def count_even_sum_subarrays(arr): Returns the number of subarrays that have an even sum. The result is returned modulo 10^9 + 7. MOD = 10**9 + 7 count_even, count_odd = 1, 0 # Initial count for an empty subarray with sum 0 (even) current_sum = 0 result = 0 for num in arr: current_sum += num if current_sum % 2 == 0: result = (result + count_even) % MOD count_even += 1 else: result = (result + count_odd) % MOD count_odd += 1 return result"},{"question":"Given a directed acyclic graph (DAG) represented by an integer array graph, where `graph[i]` is a list of all the nodes `j` for which there is a directed edge from node `i` to node `j`. Implement a function to determine if all paths starting from node `0` lead to terminal nodes. A terminal node is a node with no outgoing edges. Return _true_ if all paths from node `0` lead to terminal nodes, and _false_ otherwise.","solution":"def leadsToTerminal(graph): Determines if all paths starting from node 0 lead to terminal nodes. Parameters: graph (List[List[int]]): The DAG represented by an adjacency list. Returns: bool: True if all paths from node 0 lead to terminal nodes, False otherwise. def dfs(node, visited): if visited[node] != 0: return visited[node] == 1 if not graph[node]: visited[node] = 1 return True visited[node] = -1 for neighbor in graph[node]: if not dfs(neighbor, visited): return False visited[node] = 1 return True visited = [0] * len(graph) return dfs(0, visited)"},{"question":"Given a matrix of `m x n` elements (m rows, n columns), return all elements of the matrix in spiral order, starting from the top-left corner and moving initially to the right. The elements of the matrix will be all of integers. Your algorithm should traverse the matrix as follows: move right until you hit the boundary or a previously visited cell, then move down, then left, then up, and continue this spiraling order until all elements have been visited.","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. if not matrix: return [] result = [] top, bottom = 0, len(matrix) left, right = 0, len(matrix[0]) while top < bottom and left < right: for i in range(left, right): result.append(matrix[top][i]) top += 1 for i in range(top, bottom): result.append(matrix[i][right - 1]) right -= 1 if not (top < bottom and left < right): break for i in range(right - 1, left - 1, -1): result.append(matrix[bottom - 1][i]) bottom -= 1 for i in range(bottom - 1, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"You are given a circular array `nums` of length `n` where each element `nums[i]` represents the amount of gas at position `i`. You also have an array `cost` of length `n` where `cost[i]` is the cost of gas needed to travel from position `i` to position `(i+1) % n`. You start with an empty tank at any position, and you want to complete a full circle around the circular array once. Return the starting position `i` such that you can complete the journey, otherwise return -1 if it is not possible to make the trip. If there are multiple solutions, return the smallest index.","solution":"def can_complete_circuit(nums, cost): Determines the starting position from which a full circle around the circular array can be completed. If not possible, returns -1. total_tank, current_tank = 0, 0 start_pos = 0 for i in range(len(nums)): total_tank += nums[i] - cost[i] current_tank += nums[i] - cost[i] # If at any point current tank goes negative, reset the start position # and current tank if current_tank < 0: start_pos = i + 1 current_tank = 0 # If total amount of gas is less than total cost, journey can\'t be completed if total_tank < 0: return -1 else: return start_pos"},{"question":"Given an array `positions` of size `n`, where `positions[i]` is the position of the `i-th` ball on a number line, create a function that places `m` balls into different positions from the array such that the minimum distance between any two of the balls is maximized. Return the maximum possible minimum distance between the placed balls. Example: ``` positions = [1, 2, 8, 4, 9] m = 3 ``` Output: ``` 3 ```","solution":"def canPlaceBalls(positions, m, minDist): Helper function to check if we can place `m` balls with at least `minDist` apart. count = 1 # place the first ball at the first position last_position = positions[0] for i in range(1, len(positions)): if positions[i] - last_position >= minDist: count += 1 last_position = positions[i] if count >= m: return True return False def maxDistance(positions, m): Returns the maximum possible minimum distance between the placed balls. positions.sort() low, high = 1, positions[-1] - positions[0] best = 0 while low <= high: mid = (low + high) // 2 if canPlaceBalls(positions, m, mid): best = mid low = mid + 1 else: high = mid - 1 return best"},{"question":"You are given an integer `s` and an array `arr` of integers. You need to find the maximum number of non-overlapping subarrays such that the sum of the elements in each subarray is equal to `s`. Return _the maximum number of such non-overlapping subarrays_.","solution":"def max_non_overlapping_subarrays(s, arr): Finds the maximum number of non-overlapping subarrays such that the sum of the elements in each subarray is equal to `s`. Args: s (int): the target sum for each subarray. arr (list of int): the list of integers. Returns: int: the maximum number of non-overlapping subarrays with sum equal to `s`. count = 0 current_sum = 0 sum_indices = {0: -1} for idx, num in enumerate(arr): current_sum += num if current_sum - s in sum_indices: count += 1 sum_indices = {0: idx} current_sum = 0 else: sum_indices[current_sum] = idx return count"},{"question":"You are given a `0-indexed` integer array `nums` of even length `n`. Split this array into two equal parts: a left part and a right part. The left part is the first `n/2` elements of the array, and the right part is the last `n/2` elements. A function `calculate(part)` is defined to calculate the product of non-zero elements in the `part`. If the `part` has no non-zero elements, its product is considered to be `1`. Return `true` if the product of non-zero elements in the left part is greater than the product of non-zero elements in the right part. Otherwise, return `false`. For example: - ```nums = [1, 2, 0, 3, 4, 0] ``` returns `true` since the product of non-zero elements in the left part `[1, 2]` is `2`, and the product of non-zero elements in the right part `[3, 4]` is `12`. - ```nums = [1, 0, 2, 0, 3, 4]``` returns `false` since the product of non-zero elements in the left part `[1, 0, 2]` is `2`, and the product of non-zero elements in the right part `[0, 3, 4]` is `12`.","solution":"def calculate(part): Calculate the product of non-zero elements in the part. If the part has no non-zero elements, its product is considered to be 1. product = 1 has_non_zero = False for num in part: if num != 0: product *= num has_non_zero = True return product if has_non_zero else 1 def compare_products(nums): Returns true if the product of non-zero elements in the left part is greater than the product of non-zero elements in the right part. Otherwise, returns false. n = len(nums) left_part = nums[:n//2] right_part = nums[n//2:] left_product = calculate(left_part) right_product = calculate(right_part) return left_product > right_product"},{"question":"You are given a string `s` consisting of lowercase alphabets, a single integer `k`, and an unusual constraint: any two consecutive characters in the string must have an alphabetical difference of at most `k`. Implement a function that verifies if the given string satisfies this constraint. If it does, return `true`; otherwise, return `false`. The alphabetical difference between two characters `a` and `b` is defined as `abs(ord(a) - ord(b))`.","solution":"def satisfies_constraint(s, k): Checks if any two consecutive characters in the string `s` have an alphabetical difference of at most `k`. Parameters: s (str): The input string consisting of lowercase alphabets. k (int): The maximum allowed alphabetical difference between any two consecutive characters. Returns: bool: True if the string satisfies the condition, False otherwise. for i in range(1, len(s)): if abs(ord(s[i]) - ord(s[i-1])) > k: return False return True"},{"question":"Given an `m x n` grid `grid` consisting of non-negative integers representing the height of each cell, find a water collection spot such that if a raindrop falls, it can travel to the lowest neighboring cell, continuing this process until it cannot flow to a lower height. Return the minimum height of the final cell where the water can collect. The flow is possible only four directions: up, down, left, and right. If water can collect in multiple spots with the same height, return that height.","solution":"def find_water_collection_grid(grid): Find the minimum height of the final cell where the water can collect in the grid. def dfs(x, y): if (x, y) in memo: return memo[(x, y)] min_height = grid[x][y] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] < grid[x][y]: min_height = min(min_height, dfs(nx, ny)) memo[(x, y)] = min_height return min_height if not grid or not grid[0]: return -1 memo = {} result = float(\'inf\') for i in range(len(grid)): for j in range(len(grid[0])): result = min(result, dfs(i, j)) return result"},{"question":"You are given a list of strings `strs` containing multiple duplicate strings, and an integer `k`. Your task is to return the `k` most frequent strings from the list sorted by their frequency. If multiple strings have the same frequency, they should be sorted lexicographically. If the `k` most frequent strings have unique frequencies, simply return them in the order of their frequencies. The function should return the result as a list of strings.","solution":"from collections import defaultdict, Counter def k_most_frequent_strings(strs, k): Returns the k most frequent strings from the list \'strs\' sorted by their frequency. If multiple strings have the same frequency, they are sorted lexicographically. :param strs: List of strings. :param k: Number of top most frequent strings to return. :return: List of k most frequent strings. frequency = Counter(strs) sorted_items = sorted(frequency.items(), key=lambda item: (-item[1], item[0])) return [item[0] for item in sorted_items[:k]]"},{"question":"You are given a list of **integer intervals**, where each interval is represented as a pair of integers `[start, end]` indicating the interval is inclusive of `start` and `end`. Implement an algorithm that: * **Adds** an interval to the list of intervals, merging if necessary to ensure that overlapping or adjacent intervals are combined into a single interval. * **Removes** an interval from the list, again updating the list to ensure that merging of overlapping intervals occurs correctly. Implement the `IntervalManager` class: * `IntervalManager()` Initializes the object with no intervals. * `void addInterval(int start, int end)` Adds the interval `[start, end]` to the list, merging overlapping or adjacent intervals. * `void removeInterval(int start, int end)` Removes the interval `[start, end]` from the list, ensuring that the intervals are updated correctly. * `List<List<Integer>> getIntervals()` Returns the current list of intervals, sorted by the starting interval in ascending order. **Example:** ``` IntervalManager im = new IntervalManager(); im.addInterval(1, 3); im.addInterval(6, 9); im.addInterval(2, 5); // The intervals now become [[1, 5], [6, 9]] im.removeInterval(4, 7); // The intervals now become [[1, 3], [7, 9]] im.getIntervals(); // Returns [[1, 3], [7, 9]] ```","solution":"class IntervalManager: def __init__(self): self.intervals = [] def addInterval(self, start, end): new_intervals = [] i, n = 0, len(self.intervals) while i < n and self.intervals[i][1] < start: new_intervals.append(self.intervals[i]) i += 1 while i < n and self.intervals[i][0] <= end: start = min(start, self.intervals[i][0]) end = max(end, self.intervals[i][1]) i += 1 new_intervals.append([start, end]) while i < n: new_intervals.append(self.intervals[i]) i += 1 self.intervals = new_intervals def removeInterval(self, start, end): new_intervals = [] for interval in self.intervals: if interval[1] < start or interval[0] > end: new_intervals.append(interval) else: if interval[0] < start: new_intervals.append([interval[0], start - 1]) if interval[1] > end: new_intervals.append([end + 1, interval[1]]) self.intervals = new_intervals def getIntervals(self): return self.intervals"},{"question":"You are given two integers `m` and `n`, representing the dimensions of a 2D grid, and a list of bomb positions as an integer array `bombs` where each element `bombs[i]` is an array of two integers representing the row and column of a bomb on the grid. Each bomb explodes and marks all the cells in its row and column as affected. Return a 2D array `grid` of size `m x n` where `grid[i][j]` is 1 if the cell is affected by a bomb\'s explosion, and 0 otherwise.","solution":"def mark_affected_cells(m, n, bombs): Returns a 2D grid of size m x n where cells affected by bombs are marked with 1, otherwise 0. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. bombs (list of list of int): Positions of bombs on the grid. Returns: list of list of int: Resultant grid with affected cells marked as 1. grid = [[0 for _ in range(n)] for _ in range(m)] rows_affected = set() cols_affected = set() for bomb in bombs: row, col = bomb rows_affected.add(row) cols_affected.add(col) for row in rows_affected: for col in range(n): grid[row][col] = 1 for col in cols_affected: for row in range(m): grid[row][col] = 1 return grid"},{"question":"You are given a binary tree where each node contains an integer value. Design an algorithm to find the largest value in each row of the tree. The tree structure is defined by the `TreeNode` class as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = None self.right = None ``` Write a function `largestValues` that takes the root of the binary tree and returns a list of integers representing the largest value in each row of the tree (from top to bottom). If the tree is empty, return an empty list. ```python def largestValues(root: TreeNode) -> List[int]: # Your code goes here ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestValues(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = [(root, 0)] while queue: node, level = queue.pop(0) if level == len(result): result.append(node.val) else: result[level] = max(result[level], node.val) if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return result"},{"question":"You are given an array `events` where `events[i] = [startDayi, endDayi, valuei]` represents an event that starts at `startDayi` and ends at `endDayi` (inclusive) with a value of `valuei`. You can attend at most two non-overlapping events simultaneously. Return _the maximum value_ you can achieve by attending at most two non-overlapping events. Two events are said to overlap if their periods overlap, i.e., one event starts before or on the same day another event ends and ends after or on the same day the other event starts.","solution":"def maxTwoEvents(events): This function calculates the maximum sum of values by attending at most two non-overlapping events. # Sort the events by their start times events.sort(key=lambda x: x[0]) n = len(events) max_val = 0 endval = [0] * n # Array to store max value of one event till ith event # Fill the endval array for i in range(n-1, -1, -1): if i == n-1: endval[i] = events[i][2] else: endval[i] = max(endval[i+1], events[i][2]) i = 0 for j in range(n): # Find an event end time that does not overlap with the current start time while i < n and events[i][0] <= events[j][1]: i += 1 if i < n: max_val = max(max_val, events[j][2] + endval[i]) else: max_val = max(max_val, events[j][2]) return max_val"},{"question":"You are given a list of `n` meetings where `meetings[i] = [start_i, end_i]` indicates the start and end times of the `i-th` meeting. Two meetings intersect if their meeting times overlap in any way (i.e., one of the start or end times is within the duration of the other meeting). Your task is to determine the maximum number of meetings that can be attended by one person. Note that a person can only attend one meeting at a time. Return _the maximum number of meetings_ a person can attend.","solution":"def max_meetings(meetings): Returns the maximum number of meetings a person can attend. Arguments: meetings -- list of meetings [start_i, end_i] Returns: max number of meetings # Sort meetings by their end times to maximize the number of non-overlapping meetings sorted_meetings = sorted(meetings, key=lambda x: x[1]) last_end_time = 0 count = 0 for meeting in sorted_meetings: if meeting[0] >= last_end_time: # If the meeting starts after the last meeting ends count += 1 last_end_time = meeting[1] return count"},{"question":"You are tasked with implementing a song playlist manager. Each song is represented by a unique identifier `songId`, which is a positive integer. Implement the `PlaylistManager` class: * `addSong(int songId)` Adds a song with the given `songId` to the playlist. If the song already exists, return `false`; otherwise, return `true`. * `removeSong(int songId)` Removes a song with the given `songId` from the playlist. If the song does not exist, return `false`; otherwise, return `true`. * `getNextSong()` Returns the `songId` of the next song in the playlist. Songs should be played in the order they were added. If the playlist is empty, return `-1`. * `getPlaylistSize()` Returns the number of songs currently in the playlist. Your implementation should efficiently support the operations described.","solution":"from collections import deque class PlaylistManager: def __init__(self): self.playlist = deque() self.song_set = set() def addSong(self, songId): if songId in self.song_set: return False self.playlist.append(songId) self.song_set.add(songId) return True def removeSong(self, songId): if songId not in self.song_set: return False self.playlist.remove(songId) self.song_set.remove(songId) return True def getNextSong(self): if not self.playlist: return -1 return self.playlist[0] def getPlaylistSize(self): return len(self.playlist)"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting of lowercase alphabets. Your task is to determine if the characters of `s1` can be rearranged to match `s2` by performing at most one swap between any two characters in `s1`. If it is possible, return `true`; otherwise, return `false`. Implement the `canRearrangeByOneSwap` function that returns a boolean indicating whether `s1` can be rearranged to match `s2` with at most one swap. ```python def canRearrangeByOneSwap(s1: str, s2: str) -> bool: # Your implementation here ```","solution":"def canRearrangeByOneSwap(s1: str, s2: str) -> bool: Determine if the characters of `s1` can be rearranged to match `s2` by performing at most one swap between any two characters in `s1`. if s1 == s2: return True diffs = [] for i in range(len(s1)): if s1[i] != s2[i]: diffs.append(i) if len(diffs) == 2: i, j = diffs s1 = list(s1) s1[i], s1[j] = s1[j], s1[i] return \'\'.join(s1) == s2 else: return False"},{"question":"Given a grid of size `n x m`, each cell can either be empty (represented by `0`), contain a wall (represented by `1`), contain a start point (represented by `S`), or contain a goal point (represented by `G`). You need to find the **shortest path** from the start point to the goal point, considering the following rules: - You can move up, down, left, or right. - You cannot pass through walls. - If there is no path from `S` to `G`, return `-1`. Implement a function: ```python def shortest_path(grid: List[List[str]]) -> int: # your code here ``` * `grid` is a list of list of strings representing the n x m grid. The function should return the length of the shortest path from the start point (`S`) to the goal point (`G`), or `-1` if no such path exists. **Example:** ``` Input: [[\'S\', \'0\', \'1\'], [\'0\', \'0\', \'G\'], [\'1\', \'0\', \'1\']] Output: 3 ```","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[str]]) -> int: def bfs(start: Tuple[int, int]) -> int: # Initialize queue for BFS and visited set queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() # Check if we\'ve reached the goal if grid[x][y] == \'G\': return dist # Explore the 4 possible directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy # Check boundaries and whether the cell is visitable if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != \'1\' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If goal is not reached return -1 start = (-1, -1) for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'S\': start = (i, j) break if start != (-1, -1): break if start == (-1, -1): return -1 # No start point found return bfs(start)"},{"question":"Given a **0-indexed** integer array `nums`, determine the rightmost index where a target integer `target` can be inserted in order to maintain the sorted order of the array. You must complete this in `O(log n)` time complexity. If the target is already present in the array, the new target should be inserted to the right of the existing targets. Return the index where the target integer should be inserted.","solution":"def rightmost_insert_index(nums, target): Determines the rightmost index where target can be inserted in order to maintain the sorted order of the array in O(log n) time complexity. Args: nums (list of int): A sorted list of integers. target (int): The target value to insert. Returns: int: The rightmost insertion index for the target value. left, right = 0, len(nums) while left < right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid return left"},{"question":"Given a binary tree, implement a function `TreeNode* invertTree(TreeNode* root)` that inverts the tree and returns the root of the inverted tree. Inverting a binary tree means that the left and right children of all nodes are swapped. The TreeNode structure is defined as follows: ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; ``` Example: Input: ``` 4 / 2 7 / / 1 3 6 9 ``` Output: ``` 4 / 7 2 / / 9 6 3 1 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root): Inverts a binary tree by swapping the left and right children of all nodes. Args: root (TreeNode): Root of the binary tree. Returns: TreeNode: Root of the inverted binary tree. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invertTree(root.left) invertTree(root.right) return root"},{"question":"You are given a string `s` and an array of string pairs `pairs` where each `pairs[i] = [a, b]` indicates that the strings `a` and `b` are similar. A string `t` is similar to `s` if it can be obtained by swapping any two similar characters in `s` any number of times. Return `true` if string `s` is similar to string `t`, and `false` otherwise. Note that the similarity relation is transitive. In other words, if `a` is similar to `b` and `b` is similar to `c`, then `a` is similar to `c`.","solution":"def are_similar(s, t, pairs): if len(s) != len(t): return False from collections import defaultdict parent = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for a, b in pairs: if a not in parent: parent[a] = a if b not in parent: parent[b] = b union(a, b) for char in set(s + t): if char not in parent: parent[char] = char for i in range(len(s)): if find(s[i]) != find(t[i]): return False return True"},{"question":"You are given a rectangular 2D grid of characters `grid` of size `m x n`. Each cell in the grid contains either the character `\'L\'` for land or `\'W\'` for water. You may assume that all four edges of the grid are completely surrounded by water. You need to find the perimeter of the island. The island is formed by combining all the adjacent lands `\'L\'` (connected horizontally or vertically). You may assume that there is exactly one island in the grid. Return _the perimeter_ of the island.","solution":"def island_perimeter(grid): Calculates the perimeter of the island in the given grid. :param grid: List[List[str]], 2D list representing the grid with \'L\' for land and \'W\' for water :return: int, the perimeter of the island def is_land(i, j): return 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \'L\' perimeter = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'L\': count_borders = 4 # Start with assuming the cell is surrounded by water on all four sides if is_land(i - 1, j): # Top cell count_borders -= 1 if is_land(i + 1, j): # Bottom cell count_borders -= 1 if is_land(i, j - 1): # Left cell count_borders -= 1 if is_land(i, j + 1): # Right cell count_borders -= 1 perimeter += count_borders return perimeter"},{"question":"You are given an array of integers `nums` where `n` file sizes are represented. You have a disk with a capacity of `D` bytes. Your task is to maximize the number of files that can be placed on the disk without exceeding the disk\'s capacity `D`. Note that each file in `nums` must be used exactly once, and the order of the files cannot be rearranged. You must return the maximum number of files that can be successfully stored on the disk.","solution":"def max_files_on_disk(nums, D): This function returns the maximum number of files that can be placed on the disk without exceeding the capacity D. The files must be used exactly once, and the order cannot be rearranged. Parameters: nums (list): List of file sizes. D (int): Disk capacity in bytes. Returns: int: Maximum number of files that can be placed on the disk. total_size = 0 count = 0 for file_size in nums: if total_size + file_size > D: break total_size += file_size count += 1 return count"},{"question":"Given a string `s` and an array of strings `words`, determine if `s` is a concatenation of each string in `words` exactly once and without any intervening characters. All input strings are lowercase English letters. Return `true` if `s` is a concatenation of each string in `words` exactly once, otherwise return `false`.","solution":"def is_concatenation(s, words): Determines if s is a concatenation of each string in words exactly once and without any intervening characters. Parameters: s (str): The main string. words (List[str]): An array of strings. Returns: bool: True if `s` is a concatenation of each string in `words` exactly once, otherwise False. concatenated = \'\'.join(words) return s == concatenated"},{"question":"Given an array of integers `arr` representing heights of trees in a forest, you need to cut some trees such that the remaining trees form a strictly increasing sequence in terms of their heights. Once cut, the remaining trees cannot be rearranged. Determine the minimum number of trees that need to be cut to achieve this. Return the minimum number of cuts required.","solution":"def min_cuts_to_increasing_sequence(arr): Returns the minimum number of cuts required to form a strictly increasing sequence of trees\' heights. :param arr: List[int] - an array representing heights of trees in a forest :return: int - minimum number of cuts required if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) lis_length = max(dp) return n - lis_length"},{"question":"You are given two strings `s` and `p`, where `p` is a shorter string. Write a function to determine if a permutation of `p` is a substring of `s`. In other words, check if there exists a substring in `s` that is an anagram of `p`. Return `true` if such a substring exists, and `false` otherwise.","solution":"def is_permutation_substring(s, p): Determines if a permutation of the string p is a substring of s. Returns True if such a substring exists, False otherwise. from collections import Counter len_s, len_p = len(s), len(p) if len_p > len_s: return False p_counter = Counter(p) window_counter = Counter(s[:len_p]) for i in range(len_p, len_s): if window_counter == p_counter: return True window_counter[s[i]] += 1 window_counter[s[i - len_p]] -= 1 if window_counter[s[i - len_p]] == 0: del window_counter[s[i - len_p]] return window_counter == p_counter"},{"question":"You are given a string `s` and an integer `k`. The string `s` can be modified by removing some of its characters to create a new string. Your task is to determine the minimum possible length of the new string such that there are no more than `k` distinct characters in the new string. You do not need to maintain the order of characters in the string. Return _the minimum possible length_ of the new string.","solution":"from collections import Counter def min_length_with_k_distinct(s, k): Returns the minimum possible length of a new string such that there are no more than k distinct characters in the new string. if k == 0: return 0 char_count = Counter(s) distinct_count = len(char_count) if distinct_count <= k: return len(s) sorted_counts = sorted(char_count.values(), reverse=True) min_length = sum(sorted_counts[:k]) return min_length"},{"question":"Given an array of integers `arr` and an integer `x`, determine _the number of pairs_ `(i, j)` _such that_ `0 <= i < j < arr.length` _and_ `arr[i] + arr[j] == x`.","solution":"def count_pairs_with_sum(arr, x): Returns the number of pairs (i, j) such that 0 <= i < j < len(arr) and arr[i] + arr[j] == x. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] + arr[j] == x: count += 1 return count"},{"question":"A company has `n` employees, organized in a hierarchy, where each employee has a unique ID and a supervisor. The company intends to hold an all-hands meeting and needs to determine the communication path from the CEO to a specific employee. The CEO is represented by an employee with no supervisor (i.e., the root of the hierarchy). The hierarchy is given as a list of pairs `[[employee1, supervisor1], [employee2, supervisor2], ...]`, where the first element in each pair represents an employee, and the second element represents that employee\'s direct supervisor. Given the hierarchy and the ID of the target employee, return the sequence of IDs representing the communication path from the CEO to that employee. If there is no valid path to the target employee, return an empty list. **Note**: The input guarantees that there is only one CEO and a unique path exists for each employee under the CEO.","solution":"def find_communication_path(hierarchy, target): Returns the sequence of employee IDs representing the communication path from the CEO to the target employee. :param hierarchy: List[List[int]] - a list of pairs [employee, supervisor] :param target: int - the ID of the target employee :return: List[int] - the sequence of IDs from the CEO to the target employee supervisor_map = {employee: supervisor for employee, supervisor in hierarchy} # Find the CEO (root node), who doesn\'t appear as an employee all_employees = set(supervisor_map.keys()) all_supervisors = set(supervisor_map.values()) ceo = (all_supervisors - all_employees).pop() # Create the path from the target to the CEO path = [] current = target while current != ceo: path.append(current) if current not in supervisor_map: return [] # In case there is no valid path current = supervisor_map[current] path.append(ceo) return path[::-1]"},{"question":"You are given an integer array `arr` and an integer `k`. You need to distribute all elements of `arr` into exactly `k` non-empty subsets such that the maximum sum of the subsets is minimized. Return _the minimized maximum sum_ considering all possible distributions of the array into `k` subsets.","solution":"def minimize_max_sum(arr, k): def can_partition(max_sum): partitions, current_sum = 1, 0 for num in arr: if current_sum + num > max_sum: partitions += 1 current_sum = 0 current_sum += num return partitions <= k arr.sort(reverse=True) low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if can_partition(mid): high = mid else: low = mid + 1 return low"},{"question":"Given a list of `n` integers, where each integer `nums[i]` represents the number of units of water that can be held by the bucket at the `i-th` position. Your task is to adjust the height of the buckets such that the total amount of water they hold is maximized without any two adjacent buckets overflowing. A bucket overflows if the amount of water it holds is greater than both its height and the height of the bucket next to it. Return the maximum amount of water that can be held by the buckets after adjustment.","solution":"def max_water(nums): Returns the maximum amount of water that can be held by the buckets after adjustment. n = len(nums) if n == 0: return 0 if n == 1: return nums[0] # dp[i] will store the maximum amount of water up to the i-th bucket that can be held dp = [0] * n # Initialize the first two buckets dp[0] = nums[0] if n > 1: dp[1] = max(nums[0], nums[1]) # Fill the dp array using dynamic programming approach for i in range(2, n): dp[i] = max(dp[i-1], nums[i] + dp[i-2]) return dp[n-1]"},{"question":"Given a string `s` representing a sequence of parentheses, implement a function to determine if the parentheses are balanced. The input string `s` may contain any combination of the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. Return `true` if `s` is balanced, and `false` otherwise. A string is considered balanced if each opening bracket has a corresponding closing bracket, and the pairs of parentheses are properly nested.","solution":"def is_balanced(s): Returns True if the string s has balanced parentheses, brackets, and braces, otherwise False. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in \'({[\': stack.append(char) elif char in \')}]\': if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return not stack"},{"question":"You are given a list of `n` integers representing the `heights` of a set of buildings arranged in a line. The goal is to find the maximum area of a rectangular block of contiguous buildings, considering that the width of each building is 1. The area of the rectangular block is calculated as the product of the height of the shortest building in the block and the number of buildings in the block. Write a function that takes the list of building heights and returns the maximum rectangular area that can be formed.","solution":"def max_rect_area(heights): Returns the maximum rectangular area formed by a list of building heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an integer array `nums` containing non-negative integers. Write a function that returns the length of the longest contiguous subarray within `nums` where the difference between the maximum and minimum values is at most `1`. Your solution should be efficient with a time complexity not exceeding `O(n)`.","solution":"def longest_subarray(nums): Returns the length of the longest contiguous subarray where the difference between the maximum and minimum values is at most 1. if not nums: return 0 left = 0 max_len = 0 current_max = current_min = nums[0] for right in range(len(nums)): current_max = max(current_max, nums[right]) current_min = min(current_min, nums[right]) while current_max - current_min > 1: left += 1 current_max = max(nums[left:right+1]) current_min = min(nums[left:right+1]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an `n x n` matrix where each of the rows and columns are sorted in ascending order, write a function `searchMatrix(matrix: List[List[int]], target: int) -> bool` that returns `true` if the target number is found in the matrix, and `false` otherwise.","solution":"from typing import List def searchMatrix(matrix: List[List[int]], target: int) -> bool: Searches for a target number in a sorted n x n matrix. Args: matrix (List[List[int]]): 2D list where each row and column are sorted in ascending order. target (int): The number to search for. Returns: bool: True if the target number is found, False otherwise. if not matrix or not matrix[0]: return False # Start from the top-right corner of the matrix row, col = 0, len(matrix[0]) - 1 while row < len(matrix) and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given a 2D grid of size `m x n` where every cell is either empty (`0`) or blocked (`1`). You want to find the shortest path from the top-left corner to the bottom-right corner, navigating through only empty cells. You may move up, down, left, or right but you cannot move diagonally. Return the length of the shortest path, or `-1` if no such path exists.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner of the grid, navigating through empty cells (\'0\'). If no such path exists, returns -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"Given an array of integers where each element appears twice except for one element which appears exactly once, find and return the element that appears only once. You must implement a solution with linear runtime complexity and use only constant extra space. Write a function `int findUniqueElement(int[] nums)` that takes in the array `nums` as its parameter and returns the single occurring element.","solution":"def findUniqueElement(nums): Returns the element that appears only once in the list nums where each element appears twice except for one element. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to arrange the characters in the string in such a way that each character appears at least `k` distance away from its previous occurrence. Return a possible arrangement of the string or an empty string if it is not possible to arrange the string with the given conditions.","solution":"from collections import Counter, deque import heapq def rearrange_string(s, k): if k == 0: return s counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) result = [] queue = deque() while max_heap: val, char = heapq.heappop(max_heap) result.append(char) queue.append((char, val+1)) if len(queue) >= k: front_char, front_val = queue.popleft() if front_val < 0: heapq.heappush(max_heap, (front_val, front_char)) return \'\'.join(result) if len(result) == len(s) else \'\'"},{"question":"You are given a `0-indexed` array of integers `nums` and an integer `k`. Return the **maximum sum** of a subarray of length `k`. A subarray is a contiguous non-empty sequence of elements within an array. # Example 1: **Input:** nums = [1, 4, 2, 10, 23, 3, 1, 0, 20], k = 4 **Output:** 39 **Explanation:** The subarray [4, 2, 10, 23] has the maximum sum of 39. # Example 2: **Input:** nums = [2, 3], k = 3 **Output:** null **Explanation:** Since the length of subarray `k` is greater than the array length, return null. # Constraints: * `1 <= len(nums) <= 10^5` * `-10^4 <= nums[i] <= 10^4` * `1 <= k <= len(nums)`","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of a subarray of length k. Args: nums: List[int] - A list of integers. k: int - The length of the subarray. Returns: int or None - The maximum sum of a subarray of length k, or None if k is larger than the array\'s length. n = len(nums) # If k is greater than the length of the nums array, return None. if k > n: return None # Initialize the maximum sum as the sum of the first subarray of length k max_sum = current_sum = sum(nums[:k]) # Slide the window over the array to find the maximum sum subarray of length k for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an m x n matrix `grid` where each cell contains a non-negative integer. Define the **sum of any submatrix** as the sum of all the elements within that submatrix. Given an integer `k`, return _the maximum sum of any submatrix within_ `grid` _such that the sum is no larger than_ `k`.","solution":"import bisect def max_sum_submatrix(matrix, k): Given an m x n matrix matrix and an integer k, return the maximum sum of any rectangle submatrix such that the sum is no larger than k. if not matrix or not matrix[0]: return 0 def max_sum_no_larger_than_k(nums, k): max_sum = float(\'-inf\') curr_sum = 0 prefix_sums = [0] for num in nums: curr_sum += num index = bisect.bisect_left(prefix_sums, curr_sum - k) if index < len(prefix_sums): max_sum = max(max_sum, curr_sum - prefix_sums[index]) bisect.insort(prefix_sums, curr_sum) return max_sum rows, cols = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') for left in range(cols): row_sums = [0] * rows for right in range(left, cols): for r in range(rows): row_sums[r] += matrix[r][right] max_sum = max(max_sum, max_sum_no_larger_than_k(row_sums, k)) return max_sum"},{"question":"Given an integer array `nums`, return an integer array `answer` such that each element in `answer` represents the count of numbers smaller than the number at that position in the original array `nums`. You must write an algorithm that runs in `O(n log n)` time.","solution":"def smaller_numbers_than_current(nums): Given an array of integers nums, returns an array of integers where each element i represents the count of numbers smaller than nums[i]. Parameters: nums (list of int): List of integers Returns: list of int: List of integers where each integer represents the count of numbers smaller than nums[i] # Create a sorted copy of the array sorted_nums = sorted(nums) # Dictionary to store the count of numbers smaller than the current number smaller_count = {} # Iterate over the sorted array and store the count of numbers smaller than each number for i, num in enumerate(sorted_nums): if num not in smaller_count: smaller_count[num] = i # Generate the output array answer = [smaller_count[num] for num in nums] return answer"},{"question":"Given a binary tree, return the _inorder traversal_ of its nodes\' values. Write a function that takes the `TreeNode` root of a binary tree and returns a list of integers representing the inorder traversal.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Perform an inorder traversal of a binary tree. :param root: TreeNode, the root of the binary tree :return: List[int], the inorder traversal of the tree\'s nodes\' values def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) result = [] traverse(root) return result"},{"question":": Given an integer array `arr` of positive integers where `arr[i]` represents the number of candies the `i-th` child has. You are allowed to perform the following operation any number of times: - Choose any two adjacent children and give one candy from one child to the other. Return _the minimum number of operations required to achieve the goal where every child has the same number of candies._ If it is impossible to make every child have the same number of candies, return `-1`.","solution":"def min_operations_to_equal_candies(arr): total_candies = sum(arr) n = len(arr) # Check if it is possible to distribute candies equally if total_candies % n != 0: return -1 target = total_candies // n operations = 0 excess = 0 for candies in arr: excess += candies - target operations += abs(excess) return operations"},{"question":"You are given two arrays of integers `A` and `B`, each of length `n`. A pair `(i, j)` is considered a *good pair* if the sum of `A[i]` and `B[j]` is equal to a given integer `k`. Write a function that returns the number of *good pairs* `(i, j)` such that `0 <= i, j < n`. If no such pair exists, return 0.","solution":"def count_good_pairs(A, B, k): Returns the number of good pairs `(i, j)` such that `A[i] + B[j] == k`. Parameters: A (list of int): Array of integers. B (list of int): Array of integers. k (int): Target sum. Returns: int: The number of good pairs. good_pair_count = 0 n = len(A) for i in range(n): for j in range(n): if A[i] + B[j] == k: good_pair_count += 1 return good_pair_count"},{"question":"Given a string `s` containing only the characters `\'a\'` and `\'b\'`, return _the minimum number of deletions required to make the string a palindrome_.","solution":"def min_deletions_to_make_palindrome(s): Returns the minimum number of deletions required to make the string a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0 for x in range(n)] for y in range(n)] # Strings of length 1 are already palindromes for i in range(n): dp[i][i] = 0 # Fill the table for length in range(2, n+1): for i in range(n-length+1): j = i+length-1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1 # The result is the minimum number of deletions for s[0...n-1] return dp[0][n-1]"},{"question":"You are given an integer array `nums` and an integer `k`. A contiguous subarray is called a **subsequence subarray** if the frequency of each element in this subarray does not exceed `k`. Return _the **length of the longest** subsequence subarray_.","solution":"def longest_subsequence_subarray(nums, k): Returns the length of the longest subsequence subarray where the frequency of each element does not exceed k. Args: nums : List[int] - List of integers. k : int - Maximum allowed frequency for an element in a subarray. Returns: int - Length of the longest subsequence subarray. from collections import defaultdict freq = defaultdict(int) left = 0 max_len = 0 for right in range(len(nums)): freq[nums[right]] += 1 while max(freq.values(), default=0) > k: freq[nums[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a list of `n` integers representing the daily temperatures in a city, write a function to determine, for each day, how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, return `0` for that day. The return value should be an array of length `n` where the `ith` element is the number of days you have to wait after the `ith` day to get a warmer temperature.","solution":"def daily_temperatures(temperatures): Determine, for each day, how many days you would have to wait until a warmer temperature. :param temperatures: List of integers representing daily temperatures. :return: List of integers representing the count of days until a warmer temperature. n = len(temperatures) result = [0] * n stack = [] # Iterate through the list of temperatures for i in range(n): # While stack is not empty and the current temperature is greater than temperature at index stored in stack while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"You are given an integer array `nums` where each element represents the position of a student in a line. A student is considered correctly positioned if each student at an even index is shorter than the student at the previous odd index. Your task is to find the number of students who are correctly positioned. Return the number of students who are correctly positioned in the array. Note: Assume the array has at least one element.","solution":"def correctly_positioned_students(nums): Given an integer array `nums` where each element represents the position of a student in a line, returns the number of students who are correctly positioned according to the rule: each student at an even index is shorter than the student at the previous odd index. if len(nums) < 2: return 0 count = 0 for i in range(1, len(nums), 2): if nums[i-1] > nums[i]: count += 1 return count"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. Determine _the _**number** of unique substrings_ of length `k` in `s`. Return _an integer representing the count of unique substrings of length `k`_. Note that _two substrings are considered different if they start and end at different positions in_ `s`, _even if they consist of the same characters._","solution":"def count_unique_substrings(s, k): Returns the count of unique substrings of length `k` in string `s`. if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substr = s[i:i+k] substrings.add(substr) return len(substrings)"},{"question":"Given a string `s`, you need to find the length of the longest contiguous substring that contains at most two distinct characters. A contiguous substring is defined as a sequence of characters within `s` that occur in a continuous block without any gaps. Return _the length of the longest substring that meets the criteria_.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest contiguous substring that contains at most two distinct characters. n = len(s) if n < 3: return n # Sliding window [left, right] left, right = 0, 0 # HashMap to store the rightmost position of each character in the current window hash_map = {} max_len = 2 while right < n: # Add the character at the right pointer to the hashmap and update the right pointer hash_map[s[right]] = right right += 1 # If the window contains 3 characters, we need to remove the leftmost character if len(hash_map) == 3: # Find the leftmost character in the current window del_idx = min(hash_map.values()) # Remove it from the hashmap del hash_map[s[del_idx]] # Move the left pointer of the sliding window left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given a list of `n` integers, `arr`, and an integer `target`. Your task is to determine if there are three distinct elements in the list that sum up to the `target`. Return `true` if such a combination exists, and `false` otherwise. For example, given the list `[1, 2, 3, 4, 5]` and `target` = `9`, the elements `[2, 3, 4]` sum up to `9`, so the function should return `true`. If the `target` is `20`, there is no such combination, so the function should return `false`.","solution":"def three_sum_exists(arr, target): Determines if there are three distinct elements in the list that sum up to the target. :param arr: List of integers :param target: Integer target sum :return: Boolean, True if such a combination exists, False otherwise. n = len(arr) arr.sort() for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a list of integers `arr` and an integer `target`. Return _the number of pairs of elements in_ `arr` _that sum up to_ `target`.","solution":"def count_pairs_with_sum(arr, target): Returns the number of pairs of elements in arr that sum up to target. count = 0 seen = {} for number in arr: complement = target - number if complement in seen: count += seen[complement] if number in seen: seen[number] += 1 else: seen[number] = 1 return count"},{"question":"You are given an unsorted integer array `arr` and an integer `k`. You need to rearrange the elements of the array such that the element at position `k` is the same as it would be if the array was sorted, while ensuring that the order of elements before and after position `k` may not necessarily match their order in the sorted array. Return _the resultant_ `arr` _after the rearrangement_.","solution":"def rearrange_array(arr, k): Rearranges the elements of the array such that the element at position `k` is the same as it would be if the array was sorted. The order of other elements is not important. :param arr: List[int] - The unsorted array of integers :param k: int - The position to ensure has the correct element :return: List[int] - The rearranged array if not (0 <= k < len(arr)): raise IndexError(\\"k is out of the bounds of the array length.\\") # Perform nth element (quickselect algorithm) def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quickselect(left, right, k): if left == right: return arr[left] pivot_index = (left + right) // 2 pivot_index = partition(left, right, pivot_index) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(left, pivot_index - 1, k) else: return quickselect(pivot_index + 1, right, k) quickselect(0, len(arr) - 1, k) return arr"},{"question":"You have a list of non-negative integers `nums` representing the amount of money of each house in a street. There are two robbers who will rob the houses, but they cannot rob two connected houses. Each robber wants to maximize their total amount of money robbed, with the condition that they cannot rob the same house. The robbers will alternate turns, starting with the first robber, to choose a house to rob until there are no more valid houses left to rob. Return the maximum amount of money the first robber can rob. Given the list `nums`, write a function that returns the maximum amount of money the first robber can rob.","solution":"def rob_alternating(nums): Returns the maximum amount of money the first robber can rob when robbing houses in a street alternatively with the second robber. n = len(nums) if n == 0: return 0 if n == 1: return nums[0] # Dynamic programming to maximize the money robbed with DP array dp = [0] * n # Initialize the dp array based on first and second house. dp[0] = nums[0] if n > 1: dp[1] = max(nums[0], nums[1]) # Fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) # The maximum amount of money first robber can rob return dp[n-1]"},{"question":"Given an integer array `nums`, return the smallest positive integer that is missing from the array. The array can contain duplicate numbers and negative numbers. Your algorithm should have a linear runtime complexity and use constant extra space.","solution":"def first_missing_positive(nums): Returns the smallest positive integer that is missing from the array. n = len(nums) # Mark elements out of scope by replacing them with n + 1 for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Use the index to place positive numbers in their \\"correct\\" positions for i in range(n): num = abs(nums[i]) if num <= n and nums[num - 1] > 0: nums[num - 1] = -nums[num - 1] # The first missing positive number is the first index that has a positive value for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"Given a list of `n` integers `height` representing the height of `n` buildings standing in a row, the rainwater trapped between the buildings can be calculated as follows: For each building, consider the maximum height of the buildings to the left and right of that building. The amount of water trapped on top of the building is determined by the smaller of these two heights minus the height of the building itself. Return the total amount of rainwater trapped. Consider buildings with height 0 as flat ground.","solution":"def trap(height): Calculate the total amount of rainwater trapped between the buildings. :param height: List of integers representing the heights of the buildings. :return: Total amount of trapped rainwater. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate water trapped using the precomputed arrays for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Design and implement a class `TwoSum` that supports an `add` and a `find` method. * `add(int number)` Adds the number to an internal data structure. * `find(int value)` Returns `true` if there exists any pair of numbers whose sum is equal to the value, otherwise returns `false`. The `find` method should maintain an optimal time complexity while ensuring the internal structure is updated efficiently with each `add` operation.","solution":"class TwoSum: def __init__(self): self.numbers = {} def add(self, number): Add the number to the internal data structure. if number in self.numbers: self.numbers[number] += 1 else: self.numbers[number] = 1 def find(self, value): Find if there are two numbers in the internal data structure such that their sum is equal to the given value. for num in self.numbers: complement = value - num if complement in self.numbers: if complement != num or self.numbers[num] > 1: return True return False"},{"question":"You are given a list of integers representing the heights of pillars standing in a row. Calculate the amount of water that would be trapped between the pillars if it were to rain. The gaps between the pillars can collect water, but the water is only trapped between two taller pillars. Write a function that takes a list `heights` of integer values as input and returns the total volume of water that can be trapped.","solution":"def trap_water(heights): Calculates the total amount of water trapped between pillars. :param heights: List[int] - list of heights of the pillars :return: int - total amount of trapped water if not heights: return 0 n = len(heights) # Arrays to store the maximum height to the left and right of each pillar left_max = [0] * n right_max = [0] * n # Fill the left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill the right_max array right_max[-1] = heights[-1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"Given an integer array `arr` of size `n`, return the length of the longest subsequence such that all elements of the subsequence are sorted in strictly increasing order and the elements of the subsequence differ by at most `d`. A subsequence is derived by deleting some or no elements of the array without changing the order of the remaining elements.","solution":"def longest_increasing_subsequence_with_diff(arr, d): Returns the length of the longest subsequence such that all elements of the subsequence are sorted in strictly increasing order and the elements of the subsequence differ by at most `d`. n = len(arr) if n == 0: return 0 # dp[i] will store the length of the longest subsequence ending at arr[i] dp = [1] * n # Iterate through the array for i in range(1, n): for j in range(i): if arr[i] > arr[j] and arr[i] - arr[j] <= d: dp[i] = max(dp[i], dp[j] + 1) # The longest subsequence will be the maximum value in dp array return max(dp)"},{"question":"You are given a string `s` consisting of lowercase letters and a dictionary of words `d`. Your task is to implement a function that returns the longest word in `d` that can be formed by deleting some characters of the given string `s`. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return an empty string. Implement the function `String findLongestWord(String s, List<String> d)` which will take a string `s` and a list of words `d`, and return the longest word from `d` that can be formed in accordance with the above rules.","solution":"def findLongestWord(s, d): Returns the longest word in d that can be formed by deleting some characters of the given string s. If there are more than one possible results, returns the longest word with the smallest lexicographical order. If there is no possible result, returns an empty string. :param s: A string consisting of lowercase letters. :param d: A list of words. :return: The longest word that can be formed or an empty string. def is_subsequence(x, y): it = iter(y) return all(char in it for char in x) # Sort the dictionary by the longest word first, then by lexicographical order d.sort(key=lambda word: (-len(word), word)) for word in d: if is_subsequence(word, s): return word return \\"\\""},{"question":"You are given an array of integers `nums` representing train arrival times at a single platform in minutes past midnight. Each train typically stays for exactly one minute. Given an integer `k`, which represents the required minimum gap (in minutes) between consecutive trains that can be accommodated on the platform, determine the maximum number of trains that can use the platform without violating the gap constraint. Return _the maximum number of trains_ that can be scheduled on the platform. --- Example: ```plaintext Input: nums = [1, 3, 3, 5, 7, 8], k = 2 Output: 4 Explanation: The trains can arrive at times 1, 3, 5, and 7. ```","solution":"def max_trains_on_platform(nums, k): Returns the maximum number of trains that can use the platform without violating the gap constraint. :param nums: List of integers representing train arrival times in minutes past midnight. :param k: Integer representing the required minimum gap between consecutive trains. :return: Integer representing the maximum number of trains that can use the platform. # Sort the arrival times nums.sort() n = len(nums) # To keep track of the count of trains count = 1 last_train_time = nums[0] for i in range(1, n): if nums[i] >= last_train_time + k: count += 1 last_train_time = nums[i] return count"},{"question":"Given a list of `n` unique integers, create a function to return all possible subsets (the power set) of the list. Each subset should be sorted in ascending order and the output list of subsets should be sorted lexicographically. You can return the solution in any order if the requirement to sort the subsets lexicographically is already met in your approach.","solution":"from itertools import chain, combinations def powerset(seq): Returns all possible subsets of the list, sorted. Each subset is sorted in ascending order, and the list of subsets is sorted lexicographically. seq_sorted = sorted(seq) all_subsets = list(chain.from_iterable(combinations(seq_sorted, r) for r in range(len(seq_sorted) + 1))) subsets_as_lists = [list(subset) for subset in all_subsets] return sorted(subsets_as_lists)"},{"question":"Given a collection of `tasks` where each task is represented as `(start_time, end_time)` indicating when a task starts and ends, your goal is to determine the maximum number of non-overlapping tasks you can complete. Two tasks are considered non-overlapping if their times do not intersect. Return the maximum number of tasks you can perform.","solution":"def max_non_overlapping_tasks(tasks): Determines the maximum number of non-overlapping tasks. :param tasks: List of tuples where each tuple is (start_time, end_time) :return: Maximum number of non-overlapping tasks # Sort the tasks based on the end time. tasks.sort(key=lambda x: x[1]) max_tasks = 0 last_end_time = float(\'-inf\') for start, end in tasks: if start >= last_end_time: max_tasks += 1 last_end_time = end return max_tasks"},{"question":"Design a function that takes in a list of integers, where each integer represents the height of a building in a row of buildings, and returns the amount of rainwater that can be trapped between the buildings after it rains. The walls of the buildings are represented by the integers, and water cannot leak through the walls. Each integer in the list represents the height of a building, and the width of each building (between their walls) is 1. You can assume the given list is non-empty and contains at least one building. To solve this problem, you need to evaluate the amount of water that can be held at each index by calculating the maximum height of the left and right walls for every index in the list, subtracting the current height from the minimum of these two maximum heights, and summing up the results for each index.","solution":"def trap_rainwater(heights): Calculate the amount of trapped rainwater given the height of buildings. :param heights: List[int] - A list of integers where each integer represents the height of a building. :return: int - The total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max from left to right left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max from right to left right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the amount of water trapped at each index for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"You are given a **0-indexed** integer array `arr` of length `n`. A **subarray** of `arr` is a contiguous non-empty sequence of elements within `arr`. You need to determine the sum of all possible subarrays of `arr`. Return the result as a single integer. For example, if `arr = [1, 2, 3]`, the sum of all possible subarrays would be `1 + 2 + 3 + (1+2) + (2+3) + (1+2+3) = 20`.","solution":"def sum_of_all_subarrays(arr): Returns the sum of all possible subarrays of the given array. Parameters: arr (List[int]): The input array. Returns: int: The sum of all possible subarrays. n = len(arr) total_sum = 0 for i in range(n): total_sum += arr[i] * (i + 1) * (n - i) return total_sum"},{"question":"Given a **0-indexed** integer array `nums`, return an array `answer` where `answer[i]` is the product of all the elements of `nums` except `nums[i]`. The product of any subset of elements in `nums` is guaranteed to be within the range of a 32-bit integer. Implement the solution with a time complexity of `O(n)` without using division.","solution":"def product_except_self(nums): Returns an array answer where answer[i] is the product of all the elements of nums except nums[i]. # Initialize the length of the input array nums length = len(nums) # Initialize the answer array where we will keep our results answer = [1] * length # Variable to store the product of elements to the left of current element left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] # Variable to store the product of elements to the right of current element right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"You are given an array of integers where each element appears twice except for one which appears once. Implement a function to find that single element. Your algorithm should have a linear runtime complexity and utilize only constant space. Write a function `int findSingle(int[] nums)` that returns the single element that appears only once.","solution":"def findSingle(nums): Returns the single element that appears only once in the array where every other element appears twice. result = 0 for num in nums: result ^= num return result"},{"question":"You are developing a library management system where users can borrow and return books. To simplify the process, you need to implement the `LibrarySystem` class: * `LibrarySystem(int numberOfBooks)` — Initializes the `LibrarySystem` object with a total number of books. Each book is initially available. * `bool borrowBook(int bookId)` — Checks if the book with the given `bookId` is available to borrow. If so, mark it as borrowed and return `true`. If the book is already borrowed, return `false`. * `void returnBook(int bookId)` — Marks the book with the given `bookId` as available again in the system. Ensure that `bookId` is always valid (i.e., between `1` and `numberOfBooks`, inclusive).","solution":"class LibrarySystem: def __init__(self, numberOfBooks): Initializes the LibrarySystem with a total number of books. Each book is initially available. self.books = [True] * numberOfBooks # True means the book is available def borrowBook(self, bookId): Checks if the book with the given bookId is available to borrow. If so, mark it as borrowed and return True. If the book is already borrowed, return False. if self.books[bookId - 1]: self.books[bookId - 1] = False return True else: return False def returnBook(self, bookId): Marks the book with the given bookId as available again in the system. self.books[bookId - 1] = True"},{"question":"You are given a 2D grid consisting of `\'0\'`s (water) and `\'1\'`s (land). An island is a group of contiguous `\'1\'`s connected vertically or horizontally. There is exactly one island in the grid. Calculate and return the perimeter of this island. Write a function `islandPerimeter` that accepts a 2D list `grid` and returns an integer representing the perimeter of the island in the grid. For example, given the `grid`: ``` [ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0] ] ``` The function `islandPerimeter(grid)` should return `16`.","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Each land cell starts with 4 sides perimeter += 4 # Subtract sides for adjacent land cells if r > 0 and grid[r - 1][c] == 1: # Check above perimeter -= 2 if c > 0 and grid[r][c - 1] == 1: # Check left perimeter -= 2 return perimeter"},{"question":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the result as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Implement the `ListNode` class to represent a node in a singly-linked list and use this class to create your solution.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 is not None or l2 is not None: x = l1.val if l1 is not None else 0 y = l2.val if l2 is not None else 0 total = carry + x + y carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next if carry > 0: current.next = ListNode(carry) return dummy_head.next"},{"question":"You are given a `m x n` grid filled with non-negative numbers, representing the number of coins in each cell. You have a robot starting at the top-left corner of the grid (i.e., grid[0][0]). The robot can move either down or right at any point in time. The robot\'s goal is to reach the bottom-right corner of the grid (i.e., grid[m-1][n-1]) while collecting the maximum number of coins possible. Return the maximum number of coins the robot can collect by the time it reaches the bottom-right corner.","solution":"def max_coins(grid): Returns the maximum number of coins the robot can collect in the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp table to store the maximum coins collected up to each cell dp = [[0] * n for _ in range(m)] # Initialize the dp table with the value of grid at the starting position dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the remaining cells (can come either from the left or above) for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given a list of integers `arr` sorted in non-decreasing order and a separate integer `target`. Your goal is to find the **starting** and **ending** position of a given `target` value in the list. If `target` is not present in the list, return `[-1, -1]`. Write a function that returns these positions as a list of two integers. Try to come up with an algorithm that runs in O(log n) time complexity, where `n` is the number of elements in `arr`.","solution":"def search_range(arr, target): Returns the starting and ending position of the target in the sorted list arr. If target is not present in the list, returns [-1, -1]. def find_leftmost(): low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] < target: low = mid + 1 else: high = mid - 1 return low def find_rightmost(): low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] <= target: low = mid + 1 else: high = mid - 1 return high left_index = find_leftmost() right_index = find_rightmost() if left_index <= right_index and right_index < len(arr) and arr[left_index] == target and arr[right_index] == target: return [left_index, right_index] else: return [-1, -1]"},{"question":"You are given a list of integers representing the heights of different buildings in a cityscape, where the position of each integer corresponds to the position of the building along a horizontal line. A building with height `h` can cast a shadow on all subsequent buildings with a height less than `h` until a taller or equal height building blocks the shadow. Return the total number of buildings that are cast in shadow. Example: Given the list of building heights `[3, 7, 8, 3, 6, 1]`, the buildings of heights `3`, `6`, and `1` are in the shadow of taller buildings. Thus, the result should be `3`.","solution":"def buildings_in_shadow(heights): Returns the total number of buildings that are cast in shadow. Parameters: heights (list of int): List of building heights. Returns: int: Number of buildings in shadow. shadow_count = 0 n = len(heights) for i in range(n): taller_found = False for j in range(i + 1, n): if heights[j] >= heights[i]: taller_found = True break if taller_found: shadow_count += 1 return shadow_count"},{"question":"Given a string `plaintext` and an integer `shift`, return the result of encrypting the `plaintext` using a Caesar Cipher with the provided `shift`. In a Caesar Cipher, each letter in the plaintext is \\"shifted\\" a certain number of places down the alphabet. For instance, with a shift of 1, \'A\' would be replaced by \'B\', \'B\' would become \'C\', and so on. Characters should wrap around if they are shifted past \'Z\' or \'z\'. Additionally, the case of each letter should be preserved, and non-alphabetical characters should remain unchanged. For example, with `shift = 2`, \\"Attack at dawn!\\" would transform to \\"Cvvcem cv fcyp!\\".","solution":"def caesar_cipher(plaintext, shift): Encrypt the plaintext using a Caesar Cipher with the given shift. Arguments: plaintext -- the input string to be encrypted shift -- the number of positions to shift each letter Returns: The encrypted string def shift_char(c): if \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) elif \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) else: return c return \'\'.join(shift_char(c) for c in plaintext)"},{"question":"Given a string `s` that consists of only two characters \'a\' and \'b\', find the length of the longest substring containing only one distinct character. For example, given the string `s = \\"aababba\\"`, the longest substring would be either \\"aaa\\" or \\"bbb\\", with a length of 3.","solution":"def longest_single_char_substring(s): Given a string s consisting of only two characters \'a\' and \'b\', find the length of the longest substring containing only one distinct character. if not s: return 0 max_len = 1 current_char = s[0] current_len = 1 for i in range(1, len(s)): if s[i] == current_char: current_len += 1 else: max_len = max(max_len, current_len) current_char = s[i] current_len = 1 return max(max_len, current_len)"},{"question":"You are given a list of non-negative integers representing the heights of a collection of blocks. Each block is 1 unit wide, and the heights of the blocks are integers. Suppose it will rain, and the water will be trapped between some blocks after raining. You need to compute how much water it is possible to trap after raining. Write a function `trapWater(heights: List[int]) -> int`: * `heights` is a list of integers, where `heights[i]` represents the height of the `i-th` block. * Return the total amount of water that will be trapped after raining. Your solution must have a time and space complexity of O(n).","solution":"def trapWater(heights): Calculate the amount of trapped water given heights of the blocks. Parameters: heights (list of int): The heights of the blocks. Returns: int: The total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"Write a function to perform a level-order traversal on a binary tree, returning a list of lists where each sublist contains the values of nodes at each level. Implement the `levelOrderTraversal` function, which takes the root of a binary tree as input and returns the desired list of lists. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: TreeNode) -> List[List[int]]: # Write your code here. ``` The function should handle the following scenarios: - If the binary tree is empty, return an empty list. - Nodes should be processed from left to right at each level. - Aim for a solution that executes in O(n) time complexity, where n is the number of nodes in the tree.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"You are given two sorted arrays, `nums1` and `nums2`, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. Merge `nums2` into `nums1` as one sorted array. The constraints are as follows: * You must do this in place without using extra space. * The merged array should maintain the order of the sorted elements. * `nums1` has a size of `m + n` and contains exactly `m` initial elements, followed by `n` zeros to accommodate the merged array. Return _the merged array_.","solution":"def merge(nums1, m, nums2, n): Merges nums2 into nums1 in-place. Parameters: nums1 (List[int]): The first sorted array with m elements followed by n zeros m (int): The number of elements in nums1 nums2 (List[int]): The second sorted array with n elements n (int): The number of elements in nums2 Returns: None: nums1 is modified in place to be the merged array # Start filling nums1 from the end p1, p2, p = m - 1, n - 1, m + n - 1 # Traverse both arrays from the ends while p1 >= 0 and p2 >= 0: if nums1[p1] > nums2[p2]: nums1[p] = nums1[p1] p1 -= 1 else: nums1[p] = nums2[p2] p2 -= 1 p -= 1 # If there are still elements in nums2 while p2 >= 0: nums1[p] = nums2[p2] p2 -= 1 p -= 1 return nums1 # Optional return for clarity in testing"},{"question":"You are given a string `time` in the format `HH:MM`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The string represents a valid 24-hour time. You are allowed to replace two digits in the `time` string with any other digit from `0` to `9`, to create the maximum possible valid time. For example, if `time = \\"12:34\\"`, you can replace it with \\"22:39\\", resulting in \\"22:39\\". Return the maximum possible valid time that can be obtained by replacing up to two digits in the given `time` string.","solution":"def maximum_time(time): Given a string `time` in the format `HH:MM`, returns the maximum possible time by replacing at most two characters of the string with any digit from 0 to 9. time = list(time) if time[0] == \'?\': time[0] = \'2\' if time[1] in (\'?\', \'0\', \'1\', \'2\', \'3\') else \'1\' if time[1] == \'?\': time[1] = \'3\' if time[0] == \'2\' else \'9\' if time[3] == \'?\': time[3] = \'5\' if time[4] == \'?\': time[4] = \'9\' return \'\'.join(time)"},{"question":"Implement a simple file system that allows you to create directories and files. The file system should support the following operations: - `mkdir` path - Creates a new directory at the specified path. This path always starts with `/` and multiple directories can be created in one command. If the directory already exists, do nothing. - `addContentToFile` filePath content - Creates a new file at the specified file path and adds content to it. If the file already exists, append the content to the current content. - `readContentFromFile` filePath - Reads the content from the specified file and returns it as a string. If the file does not exist, return an empty string. - `ls` path - Returns the list of files and subdirectories under the specified path. If the path is a file, return the list containing just this file name. Implement the `FileSystem` class: - `FileSystem()` Initializes the object. - `void mkdir(String path)` Creates a new directory at the specified path. - `void addContentToFile(String filePath, String content)` Creates a new file at the specified file path or appends the content if the file already exists. - `String readContentFromFile(String filePath)` Reads the content of the file at the specified file path. - `List<String> ls(String path)` Returns the list of files and subdirectories under the specified path. Your implementation should ensure that directories and files are managed properly and efficiently.","solution":"class FileSystem: def __init__(self): self.fs = {\'/\': {}} def mkdir(self, path: str) -> None: dirs = path.split(\'/\') current = self.fs[\'/\'] for dir in dirs[1:]: if dir not in current: current[dir] = {} current = current[dir] def addContentToFile(self, filePath: str, content: str) -> None: dirs = filePath.split(\'/\') current = self.fs[\'/\'] for dir in dirs[1:-1]: current = current[dir] if dirs[-1] not in current: current[dirs[-1]] = \'\' current[dirs[-1]] += content def readContentFromFile(self, filePath: str) -> str: dirs = filePath.split(\'/\') current = self.fs[\'/\'] for dir in dirs[1:-1]: current = current[dir] return current.get(dirs[-1], \'\') def ls(self, path: str) -> list: if path == \'/\': return sorted(self.fs[\'/\'].keys()) dirs = path.split(\'/\') current = self.fs[\'/\'] for dir in dirs[1:]: current = current[dir] if isinstance(current, str): return [dirs[-1]] else: return sorted(current.keys())"},{"question":"You are given a 2D grid of size `m x n` representing a map of a house, where `0` represents an empty cell and `1` represents an obstacle. You are also provided a starting point `(startRow, startCol)` and a destination point `(endRow, endCol)` on the grid. Your task is to find the shortest path from the starting point to the destination, moving only up, down, left, or right, avoiding obstacles. If there is no valid path, return `-1`. Implement a function that returns the minimum number of steps required to reach the destination.","solution":"from collections import deque def shortest_path(grid, startRow, startCol, endRow, endCol): if not grid or grid[startRow][startCol] == 1 or grid[endRow][endCol] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(startRow, startCol, 0)]) visited = set((startRow, startCol)) while queue: r, c, steps = queue.popleft() if (r, c) == (endRow, endCol): return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, steps + 1)) visited.add((nr, nc)) return -1"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. Merge `nums2` into `nums1` as one sorted array. The final sorted array should not be returned by the function, but instead be stored inside the array `nums1`. Modify `nums1` in-place. **Notes:** * You are provided with extra space at the end of `nums1` to accommodate all the elements of `nums2`. The number of elements in `nums1` is `m + n`. * You must do this in O(m + n) time complexity.","solution":"def merge(nums1, m, nums2, n): Merges nums2 into nums1 in-place. Args: nums1 : List[int] - The first sorted array with extra space at the end. m : int - The number of elements initially in nums1. nums2 : List[int] - The second sorted array to merge into nums1. n : int - The number of elements in nums2. # Start from the end of both arrays and merge while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[m + n - 1] = nums1[m - 1] m -= 1 else: nums1[m + n - 1] = nums2[n - 1] n -= 1 # If there are remaining elements in nums2, copy them while n > 0: nums1[m + n - 1] = nums2[n - 1] n -= 1"},{"question":"You are given an array of strings `events`, where each string `events[i]` represents an event in the form \\"event_type timestamp\\". An `event_type` can be either `\\"start\\"` or `\\"end\\"`, and the `timestamp` is an integer. Events are given in chronological order but may be incomplete; that is, for some `\\"start\\"` events, there may be no corresponding `\\"end\\"` event. Implement a function to process the `events` and return a list of tuples, where each tuple contains the `start` and `end` timestamps of valid events (i.e., events that have both a `start` and an `end` timestamp). If an event has a `start` but no `end`, it should be ignored. If there are multiple `start` events without corresponding `end` events, they should be ignored once another `start` event occurs without an intervening `end` event. For example, given the input ```python events = [\\"start 1\\", \\"start 2\\", \\"end 3\\", \\"start 4\\", \\"end 5\\", \\"end 6\\"] ``` The function should return ```python [(1, 3), (4, 5)] ``` Note that the second `\\"start 2\\"` event is ignored because of the immediate `\\"start 4\\"` event that follows without an intervening `\\"end\\"` event. Complete the function: ```python def process_events(events: List[str]) -> List[Tuple[int, int]]: pass ```","solution":"from typing import List, Tuple def process_events(events: List[str]) -> List[Tuple[int, int]]: result = [] start_timestamp = None for event in events: event_type, timestamp = event.split() timestamp = int(timestamp) if event_type == \\"start\\": if start_timestamp is None: start_timestamp = timestamp elif event_type == \\"end\\": if start_timestamp is not None: result.append((start_timestamp, timestamp)) start_timestamp = None return result"},{"question":"Given a directed acyclic graph (DAG) with `n` nodes numbered from `0` to `n - 1` and a list of `edges` where `edges[i] = [from, to]` indicates a directed edge from node `from` to node `to`, find the longest path in the DAG. The length of a path is represented by the number of edges in the path. Return the length of the longest path as an integer.","solution":"def longest_path_in_dag(n, edges): Finds the length of the longest path in a directed acyclic graph (DAG). Args: n (int): The number of nodes in the DAG. edges (List[List[int]]): The list of directed edges in the DAG. Returns: int: The length of the longest path. # Create adjacency list representation of the graph from collections import defaultdict, deque graph = defaultdict(list) indegree = [0] * n for u, v in edges: graph[u].append(v) indegree[v] += 1 # Identify all starting nodes with indegree 0 queue = deque([i for i in range(n) if indegree[i] == 0]) distance = [0] * n while queue: node = queue.popleft() for neighbor in graph[node]: if distance[neighbor] < distance[node] + 1: distance[neighbor] = distance[node] + 1 indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return max(distance)"},{"question":"Given a matrix of integers `grid` where each cell represents a block of height `grid[i][j]`, find the **maximum water** that can be trapped after raining. Water can only be trapped in a cell if there are higher blocks on all four sides of the cell. Return the total amount of trapped water. The grid is surrounded by blocks of zero height.","solution":"import heapq def max_trapped_water(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) visited = [[False] * m for _ in range(n)] heap = [] water = 0 # Push all the border cells into the heap for i in range(n): for j in range(m): if i == 0 or i == n-1 or j == 0 or j == m-1: heapq.heappush(heap, (grid[i][j], i, j)) visited[i][j] = True # 4 possible directions to move directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while heap: height, x, y = heapq.heappop(heap) # Traverse the adjacent cells for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water += max(0, height - grid[nx][ny]) heapq.heappush(heap, (max(height, grid[nx][ny]), nx, ny)) return water"},{"question":"You are given a `0-indexed` integer array `nums` and an integer `k`. A subarray of `nums` is called _nice_ if there are `k` odd numbers on it. Return _the minimum length_ of a _nice_ subarray. If there is no such subarray, return `-1`. Implement the `findNiceSubarrayLength` function: * `int findNiceSubarrayLength(int[] nums, int k)` - Given the integer array `nums` and the integer `k`, return the length of the smallest subarray containing `k` odd numbers, or `-1` if no such subarray exists.","solution":"def findNiceSubarrayLength(nums, k): left = 0 count = 0 min_length = float(\'inf\') for right in range(len(nums)): if nums[right] % 2 != 0: count += 1 while count == k: min_length = min(min_length, right - left + 1) if nums[left] % 2 != 0: count -= 1 left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a list of `n` integers `arr` representing the stock prices of a company in chronological order, your task is to find the maximum profit you can achieve. You can choose to buy one and only one share of the stock on one day and sell it on a different day in the future. Write a function that returns the maximum profit possible if you cannot perform any more transactions. If no profit is possible, return `0`. Example: ``` Input: arr = [7, 1, 5, 3, 6, 4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. ``` ``` Input: arr = [7, 6, 4, 3, 1] Output: 0 Explanation: In this case, no profit is possible, so we return 0. ```","solution":"def max_profit(arr): Returns the maximum profit that can be achieved by buying and selling one share of stock. Parameters: arr (List[int]): A list of integers representing stock prices. Returns: int: The maximum profit possible, or 0 if no profit is possible. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"You are given a string `s` and a string `t`. You want to determine if you can convert `s` into `t` by performing some number of operations. In one operation, you can select any substring of `s` and rearrange its characters in any order. Return `true` if you can convert `s` into `t` by performing the described operations, and `false` otherwise.","solution":"def can_convert_by_rearranging(s, t): Determines if string `s` can be converted into string `t` by rearranging any substrings of `s` any number of times. from collections import Counter return Counter(s) == Counter(t)"},{"question":"You are given two integer arrays `arr1` and `arr2`. Each array represents a set of integers. Your task is to find the intersection of these two arrays, which means the common elements that appear in both arrays. The result should only include unique elements and be returned in ascending order. Return the result as a list of integers.","solution":"def intersection(arr1, arr2): Returns the intersection of arr1 and arr2 in ascending order. # Convert both arrays to sets to find the intersection set1 = set(arr1) set2 = set(arr2) # Find intersection of both sets result_set = set1.intersection(set2) # Convert the result to a sorted list result_list = sorted(result_set) return result_list"},{"question":"Given a list of integers `nums` where some elements may appear twice, find all the elements that appear exactly twice in the list. Your solution should work in linear time and use only constant extra space, i.e., without using additional data structures except for a few variables. Return the elements in a list sorted in ascending order.","solution":"def find_duplicates(nums): Finds all elements that appear exactly twice in the list of integers `nums`. The solution works in linear time and uses constant extra space. :param nums: List of integers where some elements may appear twice. :return: List of integers that appear exactly twice, in ascending order. result = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: result.append(abs(num)) nums[index] = -nums[index] return sorted(result)"},{"question":"Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`. Initially, all next pointers are set to `NULL`. The tree is perfect binary tree (i.e., all leaves are at the same level, and every parent has two children). Return the modified tree.","solution":"class TreeLinkNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): if not root: return None # Start with the root node of the tree leftmost = root while leftmost.left: # Iterate through the nodes at the current level head = leftmost while head: # Establish the next pointers for the children of head head.left.next = head.right if head.next: head.right.next = head.next.left head = head.next # Move to the next level leftmost = leftmost.left return root"},{"question":"Given an array of integers `nums` and an integer `k`, rearrange the array in a way such that the difference between the highest and lowest numbers in each subarray of size `k` is minimized. Return the rearranged array. If there are multiple valid rearrangements, return any of them.","solution":"def minimize_highest_and_lowest_difference(nums, k): Rearranges the array such that the difference between the highest and lowest numbers in each subarray of size k is minimized. :param nums: List[int] - the input array of integers :param k: int - the size of each subarray :return: List[int] - the rearranged array if k > len(nums): return [] nums.sort() rearranged = [] subarrays = [nums[i:i + k] for i in range(0, len(nums), k)] for subarray in subarrays: rearranged += subarray return rearranged"},{"question":"You are given an array `people` representing the weight of each person standing in a queue. You are also given an integer `limit` which represents the maximum weight that a boat can carry. Each boat can carry at most two people at the same time provided their combined weight is at most `limit`. Return the minimum number of boats required to carry everyone across to the other side.","solution":"def numRescueBoats(people, limit): Returns the minimum number of boats required to carry everyone across to the other side. Parameters: people (list of int): Weights of the people. limit (int): Maximum weight that a boat can carry. Returns: int: Minimum number of boats required. people.sort() left, right = 0, len(people) - 1 boats = 0 while left <= right: if people[left] + people[right] <= limit: left += 1 right -= 1 boats += 1 return boats"},{"question":"Given an integer array `arr`, find the maximum product of two distinct elements in the array. Return the product of these two elements. Each element in the array is guaranteed to be a positive integer. Ensure the solution has a time complexity of `O(n)` and uses only constant extra space.","solution":"def max_product_of_two(arr): Returns the maximum product of two distinct elements in the array. if len(arr) < 2: raise ValueError(\\"Array must contain at least two elements.\\") max1 = max2 = 0 # Traverse the array to find the two largest elements for num in arr: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num return max1 * max2"},{"question":"You are given a 2D matrix `matrix` of integers where each row is sorted in ascending order, and each column is also sorted in ascending order. Implement an algorithm to search for a given target value in the matrix. Return `true` if the target value exists in the matrix, and `false` otherwise. You must write an efficient solution that performs the search in O(m + n) time complexity, where `m` is the number of rows and `n` is the number of columns in the matrix.","solution":"def search_matrix(matrix, target): Searches for the target value in a 2D matrix where each row and column is sorted in ascending order. Returns True if the target exists in the matrix, False otherwise. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given a string `s` consisting of lowercase letters, and an array of strings `words` where each string in `words` is a subsequence of `s`. A subsequence is derived from another string by deleting some or none of the characters without changing the order of the remaining characters. Return _the length of the **longest** string in_ `words` _that is a subsequence of_ `s`. If there is no subsequence found, return `0`.","solution":"def is_subsequence(sub, s): Helper function to determine if \'sub\' is a subsequence of \'s\'. it = iter(s) return all(char in it for char in sub) def longest_subsequence_length(s, words): Returns the length of the longest string in words that is a subsequence of s. max_length = 0 for word in words: if is_subsequence(word, s): max_length = max(max_length, len(word)) return max_length"},{"question":"Given an array of **unique** integers `arr` and an integer `k`, rotate the array to the right by `k` steps, where `k` is a non-negative integer. Return the final rotated array. # Note: - Ensure the rotation operates efficiently even for a large number of elements. - You are allowed to use only constant extra space.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. n = len(arr) k = k % n # ensure k is within the length of the array def reverse_subarray(start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Reverse the whole array reverse_subarray(0, n - 1) # Reverse the first k elements reverse_subarray(0, k - 1) # Reverse the rest of the array reverse_subarray(k, n - 1) return arr"},{"question":"In a project management system, tasks are linked to one another as dependencies, forming a directed acyclic graph (DAG). You are given `n` tasks labeled from `0` to `n-1` and a list of dependencies where dependencies[i] = [a, b] indicates that task `a` must be completed before task `b`. Write an algorithm to return the order in which the tasks should be completed. If there are multiple valid task orders, return any one of them. If it is impossible to complete all tasks due to cyclic dependencies, return an empty list.","solution":"from collections import defaultdict, deque def find_task_order(n, dependencies): Returns the order in which tasks should be completed, given the dependencies. Args: n (int): The number of tasks labeled from 0 to n-1. dependencies (List[List[int]]): The list of dependencies where dependencies[i] = [a, b] implies task `a` must be done before task `b`. Returns: List[int]: The order of task completion, or an empty list if it\'s impossible. # Create the graph and in-degree array graph = defaultdict(list) in_degree = [0] * n # Populate graph and in-degree array for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Queue for tasks with no incoming edges (in-degree 0) queue = deque([i for i in range(n) if in_degree[i] == 0]) order = [] while queue: task = queue.popleft() order.append(task) for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If order does not contain all tasks, there is a cycle if len(order) != n: return [] return order"},{"question":"You are given an array of integers `arr` representing the heights of people in a line. Each person wants to be taller than the person directly in front of them. Write a function that determines the minimum number of people that need to be removed from the line such that remaining heights are in strictly increasing order. Return the number of people that need to be removed.","solution":"def min_removals_to_increasing_heights(arr): Returns the minimum number of people that need to be removed to make the remaining heights in strictly increasing order. Parameters: arr (list): A list of integers representing heights of people in line. Returns: int: The minimum number of removals. if not arr: return 0 # Compute the length of the longest increasing subsequence (LIS) n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # The minimum removals required would be the total number of elements # minus the length of the longest increasing subsequence longest_increasing_subsequence_length = max(lis) return n - longest_increasing_subsequence_length"},{"question":"You are given a `0-indexed` integer array `days`, where `days[i]` represents the amount of money you earn on the `ith` day. If you choose to earn money on the `ith` day, you cannot earn money on days `i-1` and `i+1`. Your task is to determine the **maximum sum of money** you can earn without working on two consecutive days. Return _the maximum amount of money you can earn under this constraint_.","solution":"def max_earnings(days): Returns the maximum amount of money you can earn without working on two consecutive days. if not days: return 0 n = len(days) if n == 1: return days[0] dp = [0] * n dp[0] = days[0] dp[1] = max(days[0], days[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + days[i]) return dp[-1]"},{"question":"You are given two strings `word1` and `word2`. Write a function to determine if `word2` is an anagram of `word1`. An anagram is a word formed by rearranging the letters of a different word, typically using all the original letters exactly once. Return a boolean value `true` if `word2` is an anagram of `word1`, otherwise return `false`.","solution":"def is_anagram(word1, word2): Determines if word2 is an anagram of word1. Args: word1 (str): The first word. word2 (str): The second word. Returns: bool: True if word2 is an anagram of word1, False otherwise. # Check lengths first to short-circuit non-anagrams if len(word1) != len(word2): return False # Count characters in both words from collections import Counter return Counter(word1) == Counter(word2)"},{"question":"Given a binary tree, return _the sum of node values visible from the left side_. A node is considered visible if it can be seen when the tree is viewed from the left side.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def left_side_view_sum(root): Returns the sum of node values visible from the left side of a binary tree. :param root: TreeNode :return: int if not root: return 0 left_side_sum = 0 max_level = -1 def dfs(node, level): nonlocal left_side_sum, max_level if not node: return if level > max_level: left_side_sum += node.val max_level = level # Traverse left before right to ensure left-most node is counted first dfs(node.left, level + 1) dfs(node.right, level + 1) dfs(root, 0) return left_side_sum"},{"question":"You are given a string `s`, which consists of lowercase letters and is a palindrome. Determine the *minimum* number of characters you need to remove to make it a palindrome with only one character appearing an odd number of times, if possible. Return `-1` if it is not possible to do so.","solution":"def min_removals_to_make_valid_palindrome(s): Returns the minimum number of characters to remove to make the string a palindrome with only one character having an odd frequency count. Returns -1 if it\'s not possible. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # a valid palindrome can have at most one character with an odd count if odd_count > 1: return odd_count - 1 return 0"},{"question":"Given a string `s` containing only the characters \'a\' and \'b\', return the length of the longest substring that contains the same number of \'a\'s as \'b\'s.","solution":"def find_longest_substring(s): Returns the length of the longest substring that contains the same number of \'a\'s as \'b\'s. count_dict = {0: -1} # Dictionary to store the first occurrence of each count max_length = 0 count = 0 for i, char in enumerate(s): if char == \'a\': count += 1 else: # char == \'b\' count -= 1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length"},{"question":"You are given a directed graph where each edge has a weight of 1. The graph is represented as an adjacency list, where `graph[i]` is a list of all nodes that node `i` can reach directly. You are also provided two integers, `source` and `destination`, indicating the starting and ending nodes. Your task is to determine the length of the shortest path from the `source` node to the `destination` node. If there is no path from the `source` to the `destination`, return -1.","solution":"from collections import deque def shortest_path_length(graph, source, destination): Returns the length of the shortest path from source to destination in a directed graph. If there is no path, returns -1. Parameters: graph (list of list of int): The adjacency list representation of the graph. source (int): The starting node. destination (int): The ending node. Returns: int: The length of the shortest path, or -1 if there is no path. if source == destination: return 0 visited = set() queue = deque([(source, 0)]) # (current_node, current_distance) while queue: current_node, current_distance = queue.popleft() if current_node == destination: return current_distance if current_node not in visited: visited.add(current_node) for neighbor in graph[current_node]: if neighbor not in visited: queue.append((neighbor, current_distance + 1)) return -1"},{"question":"Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array. Each value in the array should represent the average of the nodes at that level in the tree. Implement the `TreeLevelAverages` class: * `TreeLevelAverages(TreeNode root)` Initializes the `TreeLevelAverages` object with the root node of the binary tree. * `List<Double> levelAverages()` Returns a list of doubles representing the average value of the nodes on each level of the binary tree. Use the following definition for the tree node: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } } ```","solution":"from collections import deque from typing import List class TreeNode: def __init__(self, val: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right class TreeLevelAverages: def __init__(self, root: TreeNode): self.root = root def levelAverages(self) -> List[float]: if not self.root: return [] result = [] queue = deque([self.root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum / level_length) return result"},{"question":"You are given a grid with `m` rows and `n` columns. Each cell in the grid contains either a 1 or a 0. A group of connected 1s (vertical or horizontal, but not diagonal) forms an island. Write a function to count the number of distinct islands. Two islands are considered distinct if and only if one island is not a translation of another (identical island shapes but in different positions count as distinct).","solution":"def numDistinctIslands(grid): def dfs(x, y, direction): if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0): return grid[x][y] = 0 path_signature.append(direction) dfs(x + 1, y, \'d\') dfs(x - 1, y, \'u\') dfs(x, y + 1, \'r\') dfs(x, y - 1, \'l\') path_signature.append(\'0\') distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path_signature = [] dfs(i, j, \'s\') distinct_islands.add(tuple(path_signature)) return len(distinct_islands)"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to split `nums` into `k` non-empty subarrays such that the sum of the minimum values of each subarray is maximized. Return the maximum possible sum of the minimum values of the `k` subarrays. * Example: `nums = [1, 3, 5, 1, 7, 3, 2]`, `k = 3` * Here, one possible way to split is `[1, 3, 5]`, `[1, 7]`, `[3, 2]`. The sum of the minimum values of these subarrays is `1 + 1 + 2 = 4`. * Example: `nums = [6, 2, 4, 5, 3]`, `k = 2` * Here, one possible way to split is `[6, 2]`, `[4, 5, 3]`. The sum of the minimum values of these subarrays is `2 + 3 = 5`. The function should handle the edge cases such as large arrays and large values of `k`. Return _the maximum possible sum of the minimum values of the `k` subarrays_.","solution":"def max_sum_of_mins(nums, k): # Sort the nums array sorted_nums = sorted(nums) # We need to pick the first k elements of the sorted array since they are the minimum return sum(sorted_nums[:k])"},{"question":"You are given an array of integers `arr` where each element appears an even number of times except for one element, which appears an odd number of times. Find and return the element that appears an odd number of times. For example, if `arr = [2, 3, 2, 3, 5, 4, 5]`, the only element that appears an odd number of times is `4`.","solution":"def find_odd_occurrence(arr): Finds the element that appears an odd number of times in the array. :param arr: List[int] :return: int result = 0 for num in arr: result ^= num return result"},{"question":"You are given an array of integers `nums` representing a list of numbers. Your task is to return an array `results` such that each element `results[i]` is the product of all the numbers in `nums` except `nums[i]`. **Note**: The result for each element should be computed without using division in O(n) time complexity.","solution":"def product_except_self(nums): Returns an array such that each element is the product of all the numbers in nums except the number at the position of the element. length = len(nums) results = [1] * length # initialize the results array with 1s # Calculate products of all elements to the left of each element left_product = 1 for i in range(length): results[i] = left_product left_product *= nums[i] # Calculate products of all elements to the right of each element and multiply with the previously calculated left product right_product = 1 for i in range(length-1, -1, -1): results[i] *= right_product right_product *= nums[i] return results"},{"question":"Given an array of integers `nums` and an integer `k`, your task is to determine the number of unique k-length subarrays in `nums` such that the sum of their elements is equal to a given integer `target`. Return _the count of such subarrays_. Note that subarrays are contiguous subsequences within the original array.","solution":"def count_k_length_subarrays_with_sum(nums, k, target): Returns the number of unique k-length subarrays whose sum is equal to target. Parameters: nums (list[int]): List of integers. k (int): Length of subarray. target (int): Target sum of subarray. Returns: int: count of k-length subarrays with sum equal to target. if k > len(nums): return 0 count = 0 current_sum = sum(nums[:k]) if current_sum == target: count += 1 for i in range(1, len(nums) - k + 1): current_sum = current_sum - nums[i - 1] + nums[i + k - 1] if current_sum == target: count += 1 return count"},{"question":"Given a string `s` which contains only lowercase letters, write a function to find and return all the **non-empty** substrings that do not contain any repeated characters. The function should return these substrings in lexicographical order. A substring is defined as a contiguous sequence of characters within the string.","solution":"def unique_substrings(s): Returns all non-empty substrings of s that do not contain any repeated characters, in lexicographical order. n = len(s) substrings = set() # Generate all possible substrings for i in range(n): seen = set() for j in range(i, n): if s[j] in seen: break seen.add(s[j]) substrings.add(s[i:j+1]) # Return the sorted list of substrings return sorted(substrings)"},{"question":"Given a string containing only lowercase alphabets, find the length of the longest substring without repeating characters. You may assume that the string length does not exceed 10^5 and it is always possible to find such a substring. Return the length of this longest substring.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: The input string containing only lowercase alphabets :type s: str :return: Length of the longest substring without repeating characters :rtype: int char_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an array `logs` where each `logs[i]` represents the entry and exit time of the `i-th` employee in format `logs[i] = [entryTimei, exitTimei]` on a single day. Each time is represented as the number of minutes past midnight, so a time value `time` corresponds to `time // 60` hours and `time % 60` minutes. The office has a specific break period `breakStart` and `breakEnd`, also represented in minutes past midnight. During the break period, the office is closed, and employees cannot be in the office. Determine the total working time spent by all employees inside the office, excluding any time overlapping with the break period. Return the total working time in minutes.","solution":"def total_working_time(logs, breakStart, breakEnd): total_time = 0 for log in logs: entry, exit = log # If the log period is entirely outside the break period if exit <= breakStart or entry >= breakEnd: total_time += exit - entry # If the log period spans the break period elif entry < breakStart and exit > breakEnd: total_time += (breakStart - entry) + (exit - breakEnd) # If the log period starts before the break and ends during the break elif entry < breakStart and exit <= breakEnd: total_time += breakStart - entry # If the log period starts during the break and ends after the break elif entry >= breakStart and exit > breakEnd: total_time += exit - breakEnd # If the log period is entirely within the break period else: total_time += 0 return total_time"},{"question":"You are given a rectangular grid of characters with \'0\'s representing empty spaces and \'1\'s representing walls. Your task is to find the shortest path from the top-left corner of the grid to the bottom-right corner, avoiding walls. You can move up, down, left, or right, but cannot move through walls. Return the length of the shortest path. If no such path exists, return -1. The input grid is guaranteed to have at least one cell, and the top-left and bottom-right corners will never be walls.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid, or -1 if no such path exists. :param grid: List[List[str]]: a rectangular grid with \'0\'s for empty spaces and \'1\'s for walls :return: int: the length of the shortest path or -1 if no path exists if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() if r == rows - 1 and c == cols - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == \'0\' and (nr, nc) not in visited: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"Given an array of integers `heights` representing the heights of buildings, where buildings are aligned in a row from left to right, you need to calculate how much water this structure will trap after raining. Return the total amount of trapped rainwater.","solution":"def trap(height): Computes the total amount of trapped rainwater given the heights of the buildings. :param height: List[int] - A list of integers representing the height of buildings. :return: int - The total amount of trapped rainwater. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given a `matrix` of integers with `m` rows and `n` columns. Write a function to find the maximum sum of any rectangular submatrix within the given `matrix`. A submatrix is any contiguous block within the matrix defined by its top-left and bottom-right coordinates. Return the maximum sum found. If the matrix contains only non-positive numbers, return the least negative number.","solution":"def max_sum_submatrix(matrix): Finds the maximum sum of any rectangular submatrix within the given matrix. Parameters: matrix (list of list of int): A 2D list with m rows and n columns representing the matrix. Returns: int: The maximum sum of a rectangular submatrix. if not matrix or not matrix[0]: return 0 def max_subarray_sum(arr): max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum m, n = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') for left in range(n): row_sums = [0] * m for right in range(left, n): for i in range(m): row_sums[i] += matrix[i][right] current_max_sum = max_subarray_sum(row_sums) max_sum = max(max_sum, current_max_sum) return max_sum"},{"question":"You are given two strings, `s1` and `s2`, both of which are non-empty. Your task is to determine whether you can transform `s1` into `s2` using the following operations any number of times: 1. Replace a character in `s1` with any other character. 2. Remove a character from `s1`. A move is not allowed to add characters to `s1`. In other words, `s1` can be transformed into `s2` only if `s2` is a subsequence of `s1`. Return `true` if you can transform `s1` to `s2`, otherwise return `false`.","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 using the allowed operations. Args: s1 (str): The source string. s2 (str): The target string. Returns: bool: True if s1 can be transformed into s2, otherwise False. def is_subsequence(s1, s2): # Helper function to check if s2 is a subsequence of s1 it = iter(s1) return all(char in it for char in s2) return is_subsequence(s1, s2)"},{"question":"You are given the head of a singly linked list and an integer `k`. Your task is to reverse the nodes of the linked list `k` at a time and return the modified list. Nodes that are left out because there are fewer than `k` nodes remaining should remain as is. Implement the following function: ```python def reverseKGroup(head: ListNode, k: int) -> ListNode: ``` The function should reverse the nodes of the linked list in groups of `k` and return the new head of the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: def reverseLinkedList(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"Design a Parking System where users can park their vehicles, retrieve them, and check availability. Implement the `ParkingSystem` class: * `ParkingSystem(int numSpaces)` Initializes a parking system with a fixed number of spaces. * `boolean parkVehicle(String vehicleType, String licensePlate)` Parks a vehicle of `vehicleType` (e.g., \\"car\\", \\"motorcycle\\") with the given `licensePlate`. Returns `true` if the vehicle was successfully parked and `false` if the parking is full. * `boolean retrieveVehicle(String licensePlate)` Retrieves the vehicle with the given `licensePlate` from the parking system. Returns `true` if the vehicle was successfully retrieved and `false` if the vehicle is not found. * `int getAvailableSpaces()` Returns the number of available parking spaces at any given time.","solution":"class ParkingSystem: def __init__(self, numSpaces): self.totalSpaces = numSpaces self.availableSpaces = numSpaces self.parkedVehicles = {} def parkVehicle(self, vehicleType, licensePlate): if self.availableSpaces > 0 and licensePlate not in self.parkedVehicles: self.parkedVehicles[licensePlate] = vehicleType self.availableSpaces -= 1 return True return False def retrieveVehicle(self, licensePlate): if licensePlate in self.parkedVehicles: del self.parkedVehicles[licensePlate] self.availableSpaces += 1 return True return False def getAvailableSpaces(self): return self.availableSpaces"},{"question":"Given a list of integers `nums`, find and return the maximum product of any three integers in the list. The integers in the list can be positive, negative, or zero, and the length of the list will be at least three. You should aim to find an efficient solution that runs in linear time or linearithmic time.","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three integers in the list. :param nums: List of integers :return: Maximum product of three integers nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"Design and implement a `ParkingSystem` class to simulate a parking lot with three different types of spots: big, medium, and small. * `ParkingSystem(int big, int medium, int small)` Initializes the parking system with the number of available spots for each parking type. * `boolean addCar(int carType)` Checks whether there is a slot available for the given car type. `carType` can be `1` for big cars, `2` for medium cars, and `3` for small cars. If there is an available slot, parks the car in that slot and returns `true`. Otherwise, returns `false`. Note: - You are not required to consider the problem of concurrent access to the `ParkingSystem`. Assume it will always be accessed by a single thread.","solution":"class ParkingSystem: def __init__(self, big, medium, small): self.spots = {1: big, 2: medium, 3: small} def addCar(self, carType): if self.spots[carType] > 0: self.spots[carType] -= 1 return True return False"},{"question":"You are given an integer array `nums` and a target integer `k`. Your task is to determine if there are two distinct indices `i` and `j` in the array such that `nums[i]` and `nums[j]` differ by exactly `k`. Write a function that takes in the array `nums` and the integer `k`, and returns `true` if such a pair exists, and `false` otherwise.","solution":"def contains_difference(nums, k): Returns True if there are two distinct indices i and j such that nums[i] and nums[j] differ by exactly k. seen = set() for num in nums: if (num + k) in seen or (num - k) in seen: return True seen.add(num) return False"},{"question":"Given an array of integers `nums` and an integer `target`, find two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] = target`. Return the indices `(i, j)` as a tuple. If no such indices exist, return `None`.","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, find two distinct indices (i, j) such that nums[i] + nums[j] = target. Return the indices (i, j) as a tuple. If no such indices exist, return None. Args: nums: List[int] - list of integers target: int - target sum Returns: Tuple[int, int] or None - indices of two numbers whose sum equals the target num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"Given an unsorted array `arr` of integers, return the length of the longest increasing subsequence. An increasing subsequence is a sequence of elements that are in increasing order, but not necessarily consecutive in the original array. # Example: - Input: `arr = [10, 9, 2, 5, 3, 7, 101, 18]` - Output: `4` - Explanation: The longest increasing subsequence is `[2, 3, 7, 101]`. # Note: - The algorithm should run in O(n^2) complexity or better.","solution":"def length_of_LIS(arr): Returns the length of the longest increasing subsequence in the given array. if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] represents the length of the longest increasing subsequence ending at index i for i in range(n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given an array `characters` of lowercase English letters and an integer `k`. Your task is to rearrange the characters in such a way that no two adjacent characters are the same. If it is not possible to rearrange the characters to meet the condition, return an empty string. Example: Input: characters = `[ \'a\', \'a\', \'b\', \'b\', \'c\', \'c\']`, k = `2` Output: \\"abcabc\\" Note: - If there are multiple valid solutions, return any of them.","solution":"from collections import Counter import heapq def rearrange_characters(characters, k): Rearrange characters such that no two adjacent characters are the same, and each character appears k times if possible. Return an empty string if not possible. :param characters: List of characters :param k: Int representing the required frequency of each character :return: A rearranged string meeting the condition or empty string if not possible if not characters: return \\"\\" counter = Counter(characters) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((freq + 1, char)) if len(wait_queue) >= k: freq, char = wait_queue.pop(0) if freq < 0: heapq.heappush(max_heap, (freq, char)) if len(result) == len(characters): return \\"\\".join(result) else: return \\"\\""},{"question":"You are given a `string` containing digits from `2-9` inclusive, representing every possible letter corresponding to a phone number digit on a traditional telephone keypad. Return _all possible letter combinations that the number could represent_. You can return the answer in any order. Note that `1` does not map to any letters. Example: Input: \\"23\\" Output: [\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"]","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent. if not digits: return [] digit_to_chars = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = digit_to_chars[digits[index]] for letter in possible_letters: backtrack(index + 1, path + [letter]) combinations = [] backtrack(0, []) return combinations"},{"question":"You are given a list of `n` integers representing the points where balloons are located along a horizontal axis. Each balloon can be burst by shooting an arrow directly vertically (i.e., along the `y` axis) at any `x` position and all balloons at that `x` position will be burst. Find the minimum number of arrows required to burst all the balloons. Return an integer representing the minimum number of arrows required.","solution":"def min_arrows_to_burst_balloons(points): Returns the minimum number of arrows required to burst all balloons. :param points: List of integers representing the x coordinates of balloons :return: Minimum number of arrows required if not points: return 0 # Sort the points (balloon positions) points.sort() # Initialize the count of arrows arrows = 1 current_arrow_position = points[0] for i in range(1, len(points)): if points[i] != current_arrow_position: arrows += 1 current_arrow_position = points[i] return arrows"},{"question":"You are given a string of opening and closing parentheses. Determine if the parentheses are balanced. The string can contain the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. A string is considered balanced if: - Every opening parenthesis has a corresponding closing parenthesis of the same type. - Parentheses are closed in the correct order. Return `true` if the string is balanced and `false` otherwise. The solution should use `O(n)` time where `n` is the length of the string.","solution":"def is_balanced_parentheses(s): Determine if the parentheses in the string are balanced. Args: s (str): input string containing \'(\', \')\', \'{\', \'}\', \'[\' and \']\' Returns: bool: True if the string is balanced, False otherwise stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses: if stack == [] or matching_parentheses[char] != stack.pop(): return False else: continue return stack == []"},{"question":"There are `n` houses located on a street, numbered from `0` to `n - 1`. Each house has a certain height, represented by an integer array `heights`, where `heights[i]` is the height of the house number `i`. A house can see the sunset if there are no taller houses to its right. In other words, a house can see the sunset if all the houses to its right have a height less than or equal to its own height. Return _a list of indices of the houses that can see the sunset, sorted in ascending order_.","solution":"def sunset_houses(heights): Returns the indices of the houses that can see the sunset, sorted in ascending order. :param heights: List[int] - The heights of the houses. :return: List[int] - The indices of the houses that can see the sunset. n = len(heights) result = [] max_height = -1 for i in range(n-1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return sorted(result)"},{"question":"A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child. You are given the root node of a binary tree. Implement the `DuplicateSubtrees` class: * `DuplicateSubtrees(TreeNode root)` Initializes the object with the root of the binary tree. * `List<TreeNode> findDuplicateSubtrees()` Returns all duplicate subtrees. For each kind of duplicated subtree, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with the same node values.","solution":"from typing import List, Optional, Tuple from collections import defaultdict class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right class DuplicateSubtrees: def __init__(self, root: TreeNode): self.root = root self.serial_map = defaultdict(list) def findDuplicateSubtrees(self) -> List[TreeNode]: def serialize(node: Optional[TreeNode]) -> str: if not node: return \\"#\\" serial = f\\"{node.val},{serialize(node.left)},{serialize(node.right)}\\" self.serial_map[serial].append(node) return serial serialize(self.root) result = [] for nodes in self.serial_map.values(): if len(nodes) > 1: result.append(nodes[0]) return result"},{"question":"You are given an array of `n` integers, `nums`, representing the amount of money of each house in a row of houses. Each house is either robbed or not, with the condition that adjacent houses cannot be robbed on the same night. Implement a function to determine the maximum amount of money you can rob tonight without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. if not nums: return 0 if len(nums) <= 2: return max(nums) prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"Given an integer array `arr` and an integer `k`, return _a list of the_ `k` _most frequent elements in the array_. In the case of a tie, return the elements in ascending order. You may assume that `k` is always valid (i.e., `1 <= k <= number of unique elements in the array`).","solution":"from collections import Counter def top_k_frequent(arr, k): Returns a list of the `k` most frequent elements in the array `arr`. Parameters: arr (list of int): The input array of integers. k (int): The number of most frequent elements to return. Returns: list of int: The `k` most frequent elements in the array sorted in ascending order in case of a tie. frequency = Counter(arr) # Get the list of elements sorted by frequency (descending) and then by value (ascending) sorted_elements = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Extract the top k elements return [element[0] for element in sorted_elements[:k]]"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, return _the sum of the elements that are present at even indices._ **Note:** The initial index is considered as even. Example 1: ``` nums = [1, 2, 3, 4, 5, 6] Output: 9 Explanation: The elements at even indices are 1, 3, and 5, and their sum is 9. ``` Example 2: ``` nums = [10, 11, 12, 13, 14, 15] Output: 36 Explanation: The elements at even indices are 10, 12, and 14, and their sum is 36. ```","solution":"def sum_even_indices(nums): Returns the sum of the elements that are present at even indices in the list. Parameters: nums (list): A list of integers. Returns: int: The sum of elements at even indices. return sum(nums[i] for i in range(0, len(nums), 2))"},{"question":"Given a **2D grid** of size `m x n` where each cell represents a **forest** or an **empty land**. An empty land is denoted by `0` and a forest by `1`. You are currently standing at the top-left corner of the grid and must reach the bottom-right corner. At each step, you can move to an adjacent cell to the north, south, east, or west, but you can only pass through cells that are empty land (`0`). The grid does not have any external boundaries, meaning you cannot go out of the grid\'s boundary. Each movement to an adjacent cell has a cost of `1`. Find and return _the **minimum cost** to travel from the top-left corner to the bottom-right corner_. If it is not possible to reach the bottom-right corner, return `-1`.","solution":"from collections import deque def min_cost_to_travel_through_grid(grid): Returns the minimum cost to travel from the top-left corner to the bottom-right corner of the grid. If it is not possible, return -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # north, south, west, east queue = deque([(0, 0, 0)]) # (x, y, cost) visited = set((0, 0)) while queue: x, y, cost = queue.popleft() if x == m-1 and y == n-1: return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, cost + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given an array of integers `nums` and a target integer `target`. Your task is to write a function `findTargetSumWays(nums, target)` that returns the number of different ways to add the elements of `nums` (using both addition and subtraction) to reach exactly `target`. For instance, if `nums = [1, 1, 1, 1, 1]` and `target = 3`, there are 5 ways to reach the target: `+1-1+1+1+1`, `-1+1-1+1+1`, `+1+1+1-1+1`, `+1+1+1+1-1`, and `-1+1+1+1+1`. The function should return `5` in this case. The elements of `nums` are non-negative integers and the length of `nums` will not exceed 20.","solution":"def findTargetSumWays(nums, target): Returns the number of ways to add the elements of nums (using both addition and subtraction) to reach exactly target. memo = {} def backtrack(i, current_sum): if i == len(nums): return 1 if current_sum == target else 0 if (i, current_sum) in memo: return memo[(i, current_sum)] # Choose the number with a plus sign add = backtrack(i + 1, current_sum + nums[i]) # Choose the number with a minus sign subtract = backtrack(i + 1, current_sum - nums[i]) memo[(i, current_sum)] = add + subtract return memo[(i, current_sum)] return backtrack(0, 0)"},{"question":"You are given a positive integer `n` representing the number of courses a student has to take. The courses are numbered from `0` to `n - 1` (inclusive). You are also given a 2D integer array `prerequisites`, where `prerequisites[i] = [coursei, prereqi]` denotes that you must complete course `prereqi` before taking course `coursei`. Determine if it is possible to finish all courses. If it is possible, return `true`; otherwise, return `false`.","solution":"from collections import defaultdict, deque def can_finish_courses(n, prerequisites): Determines if it is possible to finish all courses given the prerequisites. Parameters: - n (int): Number of courses. - prerequisites (List[List[int]]): List of pairs representing prerequisites. Returns: - bool: True if it is possible to finish all courses, False otherwise. # Create an adjacency list for the graph representation of the courses graph = defaultdict(list) # Create a list to track the number of prerequisites (in-degrees) for each course in_degree = [0] * n # Build the graph and fill the in-degree data for course, prereq in prerequisites: graph[prereq].append(course) in_degree[course] += 1 # Initialize a queue to track courses with no prerequisites (in-degree zero) queue = deque([course for course in range(n) if in_degree[course] == 0]) visited_courses = 0 while queue: current_course = queue.popleft() visited_courses += 1 for next_course in graph[current_course]: in_degree[next_course] -= 1 if in_degree[next_course] == 0: queue.append(next_course) return visited_courses == n"},{"question":"You are given a **0-indexed** integer array `scores` representing the scores of students in a class. Each student can be rewarded with a star if they have a higher score than both their immediate neighbors. A student `i` is eligible for a star if the following are true: - `0 < i < n - 1` - `scores[i] > scores[i - 1]` and `scores[i] > scores[i + 1]` Return _the number of students who can receive a star based on their scores._","solution":"def count_students_with_stars(scores): Counts the number of students who can receive a star based on their scores. A student `i` is eligible for a star if: - `0 < i < len(scores) - 1` - `scores[i] > scores[i - 1]` and `scores[i] > scores[i + 1]` :param scores: List[int], a list of scores :return: int, number of students who can receive a star n = len(scores) count = 0 for i in range(1, n - 1): if scores[i] > scores[i - 1] and scores[i] > scores[i + 1]: count += 1 return count"},{"question":"You are given a string `formula` that represents a chemical formula containing various chemical elements. Each element can have an optional positive integer `n` after it, indicating the number of atoms of that element in the molecule. Write a function `parseMolecule(formula: str) -> Dict[str, int]` that parses the chemical formula and returns a dictionary with elements as keys and their respective counts as values. The chemical elements are represented by one or two characters, where the first character is uppercase, and if there is a second character, it is lowercase. Parentheses `()` can be used to group parts of the formula, and multipliers can be applied to groups. Handle nested parentheses correctly.","solution":"import re from collections import defaultdict from typing import Dict def parseMolecule(formula: str) -> Dict[str, int]: def multiply_dict(d, factor): for key in d: d[key] *= factor return d def merge_dicts(a, b): for key in b: a[key] += b[key] return a def parse(formula): stack = [] i = 0 n = len(formula) current_dict = defaultdict(int) while i < n: if formula[i] == \'(\': stack.append(current_dict) current_dict = defaultdict(int) i += 1 elif formula[i] == \')\': i += 1 num_start = i while i < n and formula[i].isdigit(): i += 1 multiplier = int(formula[num_start:i] or 1) multiplied_dict = multiply_dict(current_dict, multiplier) current_dict = stack.pop() current_dict = merge_dicts(current_dict, multiplied_dict) else: element_start = i i += 1 if i < n and formula[i].islower(): i += 1 element = formula[element_start:i] num_start = i while i < n and formula[i].isdigit(): i += 1 count = int(formula[num_start:i] or 1) current_dict[element] += count return current_dict return dict(parse(formula))"},{"question":"You are given an integer array `nums` and an integer `threshold`. Your task is to find the smallest divisor `d` such that the result of `nums` divided by `d` is less than or equal to `threshold`. The result of `nums` divided by `d` is computed as the sum of `ceil(nums[i] / d)` for each element `nums[i]` in the array, where `ceil(x)` represents the ceiling function. Return _the smallest integer `d` which satisfies the condition._","solution":"from math import ceil def smallest_divisor(nums, threshold): Find the smallest divisor `d` such that the sum of ceil(nums[i] / d) for all i is less than or equal to `threshold`. def calculate_result(d): return sum(ceil(num / d) for num in nums) left, right = 1, max(nums) while left < right: mid = (left + right) // 2 if calculate_result(mid) > threshold: left = mid + 1 else: right = mid return left"},{"question":"Given a binary tree, populate each `next` pointer to point to its next right node. If there is no next right node, the `next` pointer should be set to `NULL`. Initially, all next pointers are set to `NULL`. Assume it is a perfect binary tree (i.e., all leaves are at the same level, and every parent has two children). Example: Input: ``` 1 / 2 3 / / 4 5 6 7 ``` Output: ``` 1 -> NULL / 2 -> 3 -> NULL / / 4->5->6->7 -> NULL ``` Return the root of the modified tree.","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): if not root: return None leftmost = root while leftmost.left: current = leftmost while current: current.left.next = current.right if current.next: current.right.next = current.next.left current = current.next leftmost = leftmost.left return root"},{"question":"You are given an array of integers `nums` representing the number of stars in each constellation and an integer `k` representing the maximum number of constellations that can be grouped together. Your task is to find the maximum number of stars that can be observed by selecting at most `k` constellations grouped consecutively. Return _the maximum number of stars observable from any combination of at most `k` consecutive constellations_. For example, given `nums = [1, 3, 2, 6, 7, 1]` and `k = 3`, the maximum number of stars observable by choosing at most `k` consecutive constellations would be `15` (by selecting the subarray `[6, 7, 1]`).","solution":"def max_stars_observed(nums, k): Returns the maximum number of stars observable by selecting at most `k` consecutive constellations. :param nums: List[int] - A list of integers representing the number of stars in each constellation :param k: int - The maximum number of consecutive constellations that can be grouped together :return: int - The maximum number of stars observable n = len(nums) max_stars = 0 current_sum = 0 for i in range(min(k, n)): current_sum += nums[i] max_stars = current_sum for i in range(min(k, n), n): current_sum += nums[i] - nums[i - k] max_stars = max(max_stars, current_sum) return max_stars"},{"question":"You are given a string `s` consisting of lowercase English letters, and you are also given an array `indices` of the same length as `s`. The array `indices` determines a new sequence of the characters in `s`. More specifically, the character at the ith position in the new sequence is the character `s[indices[i]]`. Return the new shuffled string.","solution":"def restore_string(s, indices): Returns the shuffled string based on the given indices. n = len(s) shuffled = [\'\'] * n for i, idx in enumerate(indices): shuffled[idx] = s[i] return \'\'.join(shuffled)"},{"question":"Given a string `s` that contains only lowercase alphabets, you are allowed to perform at most `k` operations on it. In one operation, you can select any character in the string and change it to any other lowercase alphabet. Your goal is to maximize the number of consecutive identical characters in the resulting string. Return _the length of the longest substring containing identical characters after performing at most `k` operations._","solution":"def max_consecutive_chars(s, k): Returns the length of the longest substring containing identical characters after performing at most k operations. from collections import Counter max_len = 0 left = 0 freq = Counter() for right in range(len(s)): freq[s[right]] += 1 while (right - left + 1) - max(freq.values()) > k: freq[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Design a class to perform basic arithmetic operations for a list of integers. Implement the `ArithmeticOperations` class: * `ArithmeticOperations(int[] nums)` initializes the object with a list of integers `nums`. * `int addRange(int left, int right)` returns the sum of the integers between indices `left` and `right` inclusive. * `double averageRange(int left, int right)` returns the average of the integers between indices `left` and `right` inclusive. * `int multiplyRange(int left, int right)` returns the product of the integers between indices `left` and `right` inclusive.","solution":"class ArithmeticOperations: def __init__(self, nums): self.nums = nums def addRange(self, left, right): return sum(self.nums[left:right + 1]) def averageRange(self, left, right): return sum(self.nums[left:right + 1]) / (right - left + 1) def multiplyRange(self, left, right): result = 1 for num in self.nums[left:right + 1]: result *= num return result"},{"question":"You are given an array of `n` integers. Your task is to determine whether it is possible to split the array into two non-empty subsets such that the sum of the elements in both subsets is the same. Return `true` if such a split is possible, otherwise return `false`.","solution":"def can_partition(nums): Determines if the input list can be partitioned into two subsets of equal sum. total_sum = sum(nums) # If total_sum is odd, it cannot be partitioned into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Use dynamic programming to check if a subset sum of \'target\' can be achieved dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"Four companies are bidding for a government contract, each submitting one written proposal. The written proposals are initially compared in pairs to determine superiority. For each pair of proposals, a head-to-head comparison is made, and the superior proposal is the one that exhibits more favorable attributes than the other for most criteria. You are given a 2D list `comparisons` where `comparisons[i] = [a, b, c]`. This means that proposal `c` is deemed better than proposal `a` when compared to `b`. Your task is to determine if there is one proposal that is superior to all others when compared head-to-head. Return _the id of the superior proposal, or_ `-1` _if no single proposal is superior to all others_. Example: ```python comparisons = [[0, 1, 0], [0, 2, 2], [0, 3, 0], [1, 2, 2], [1, 3, 3], [2, 3, 2]] find_superior_proposal(comparisons) ``` Output: ```python 2 ```","solution":"def find_superior_proposal(comparisons): Determines if there is one proposal that is superior to all others. Parameters: comparisons (List[List[int]]): A list of comparisons where each comparison is represented by a list [a, b, c]. Returns: int: The id of the superior proposal or -1 if no single proposal is superior to all others. from collections import defaultdict # Count how many times each proposal is superior in the comparison win_count = defaultdict(int) proposals = set() for a, b, c in comparisons: win_count[c] += 1 proposals.update([a, b]) total_proposals = len(proposals) for proposal, count in win_count.items(): if count == total_proposals - 1: return proposal return -1"},{"question":"You are given an array of strings `words` and a string `pattern`. Return _a list of all the strings in_ `words` _that match the given `pattern`_. A string is said to match a pattern if there is a **bijective** mapping between a letter in the pattern and a letter in the string. For example, given pattern `\\"abb\\"`, `\\"mee\\"` matches it because both `m` and `e` form a bijection with `a` and `b`, but `\\"abc\\"` does not match because `a`, `b`, and `c` each map to themselves, not following the bijection required by `\\"abb\\"`.","solution":"def find_and_replace_pattern(words, pattern): def is_match(word): if len(word) != len(pattern): return False w_to_p, p_to_w = {}, {} for w, p in zip(word, pattern): if w not in w_to_p: w_to_p[w] = p if p not in p_to_w: p_to_w[p] = w if w_to_p[w] != p or p_to_w[p] != w: return False return True return [word for word in words if is_match(word)]"},{"question":"Given a string consisting of lowercase letters and the minimum number of operations required to make all the characters of a given string same are to be calculated. In one operation, you can select one character of the string and change it to any other character. Return the minimum number of operations needed to make all the characters in the string the same.","solution":"def min_operations_to_make_same(s): Returns the minimum number of operations required to make all characters in the string the same. from collections import Counter # Count frequency of each character char_count = Counter(s) # Find the highest frequency max_freq = max(char_count.values()) # Calculate the number of characters to change return len(s) - max_freq"},{"question":"You are given an unsorted integer array `nums` and an integer `k`. Return the k-th largest element in the array. Note that it is the k-th largest element in sorted order, not the k-th distinct element. You must solve it in linear time complexity and with constant extra space.","solution":"def find_kth_largest(nums, k): Returns the k-th largest element in the given unsorted integer array nums. def quickselect(start, end, idx): pivot = nums[end] p = start for i in range(start, end): if nums[i] >= pivot: nums[i], nums[p] = nums[p], nums[i] p += 1 nums[p], nums[end] = nums[end], nums[p] if p == idx: return nums[p] elif p > idx: return quickselect(start, p - 1, idx) else: return quickselect(p + 1, end, idx) return quickselect(0, len(nums) - 1, k - 1)"},{"question":"Given a string `s`, find the length of the longest substring `t` that contains at most `k` distinct characters. * For example, given s = \\"eceba\\" and k = 2, the substring is \\"ece\\" which has length = 3. Implement a function `maxLengthSubstring(s: str, k: int) -> int` that returns the length of the longest substring with at most `k` distinct characters.","solution":"def maxLengthSubstring(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. Parameters: s (str): The input string. k (int): The maximum number of distinct characters. Returns: int: The length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 char_map = {} left = 0 max_len = 0 for right in range(len(s)): # Add current character to the map (or update its frequency). char_map[s[right]] = char_map.get(s[right], 0) + 1 # While there are more than k distinct characters in the current window. while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 # Update the maximum length found. max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an array of integers `nums`, you need to find two distinct indices `i` and `j` in the array such that the absolute difference between `nums[i]` and `nums[j]` is maximized. Return the maximum absolute difference. You can assume that the array contains at least two elements and that the integer values are within the range of `[-10^9, 10^9]`.","solution":"def max_abs_diff(nums): Returns the maximum absolute difference between two distinct elements in the array nums. min_val = min(nums) max_val = max(nums) return max_val - min_val"},{"question":"Given a string `s`, you want to split the string into the minimum number of substrings such that each substring is a palindrome. A **palindrome** is a string that reads the same forward and backward. Write a function that takes the string `s` as input and returns the minimum number of palindromic substrings that `s` can be split into. This problem helps you understand dynamic programming and string manipulation as you figure out the optimal way to break the string into palindromic parts while minimizing the number of substrings.","solution":"def min_cut_palindrome_substrings(s): Returns the minimum number of palindromic substrings that `s` can be split into. n = len(s) dp = [[False] * n for _ in range(n)] cuts = [0] * n for end in range(n): min_cut = end for start in range(end + 1): if s[start] == s[end] and (end - start <= 1 or dp[start + 1][end - 1]): dp[start][end] = True min_cut = 0 if start == 0 else min(min_cut, cuts[start - 1] + 1) cuts[end] = min_cut return cuts[-1] + 1"},{"question":"Given a **0-indexed** integer array `arr` of size `n`, return _the length of the largest subarray with an equal number of 0s and 1s_. For example, given `arr = [0, 1, 0]`, the longest subarray with equal number of 0s and 1s is `[0, 1]`, so you should return its length, which is 2.","solution":"def findMaxLength(arr): Returns the length of the largest subarray with an equal number of 0s and 1s. hash_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(arr): # Replace 0 with -1 if num == 0: count -= 1 else: count += 1 if count in hash_map: max_length = max(max_length, i - hash_map[count]) else: hash_map[count] = i return max_length"},{"question":"Given a string `s` and an array of strings `words`, find the length of the longest substring in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. Each word in `words` must be of the same length. Return the starting index of the longest substring. If there is no such substring, return -1.","solution":"def find_substring(s, words): if not s or not words: return -1 word_length = len(words[0]) total_words = len(words) substring_length = word_length * total_words word_count = {word: words.count(word) for word in words} def check(start): seen = {} for i in range(total_words): word_start = start + i * word_length word = s[word_start:word_start + word_length] if word not in word_count: return False seen[word] = seen.get(word, 0) + 1 if seen[word] > word_count[word]: return False return True for i in range(len(s) - substring_length + 1): if check(i): return i return -1"},{"question":"You are given a binary tree represented by a root node `root`. Determine the maximum sum of nodes in any root-to-leaf path in the tree. Each path must be from the root to a leaf where a leaf is a node with no children. Return the maximum sum achievable. Note: You may assume that the tree contains at least one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Given a binary tree, returns the maximum sum of nodes in any root-to-leaf path. if not root: return 0 def helper(node): if not node: return 0 if not node.left and not node.right: return node.val left_sum = helper(node.left) right_sum = helper(node.right) return node.val + max(left_sum, right_sum) return helper(root)"},{"question":"You are given a list of integers `nums` and an integer `k`. The integers in `nums` represent the heights of people in a queue. You are tasked with sorting the queue such that people are arranged in non-decreasing order of their heights. However, while sorting, each person can move to any position within a maximum distance of `k` positions from their original position. Return the list representing the sorted queue following the above conditions. If there are multiple valid sorted arrangements, return any one of them. Ensure your solution runs in `O(n log n)` time complexity where `n` is the length of the list `nums`.","solution":"import heapq def sort_queue_with_constraints(nums, k): Sorts the queue such that each person can move to any position within a maximum distance of `k` positions from their original position. Args: nums (list of int): List of integers representing people\'s heights. k (int): Maximum allowed movement range for each person. Returns: list of int: Sorted list of heights adhering to the movement constraint. if not nums or k <= 0: return nums n = len(nums) result = [] # Create a min-heap for the first k+1 elements min_heap = nums[:k+1] heapq.heapify(min_heap) # Process remaining elements for i in range(k+1, n): result.append(heapq.heappop(min_heap)) heapq.heappush(min_heap, nums[i]) # Extract remaining elements from the heap while min_heap: result.append(heapq.heappop(min_heap)) return result"},{"question":"Given a list of integers `nums` and an integer `target`, return _all unique pairs_ `(a, b)` such that `a + b = target`. Ensure that each pair is listed in ascending order of the first element, and if the first elements are the same, then by the second element of the pair. Duplicate pairs should not be included in the result.","solution":"def two_sum_pairs(nums, target): Returns all unique pairs (a, b) from the list nums such that a + b = target, sorted by the first element and then by the second element. Args: nums (list of int): List of integers. target (int): Target sum of pairs. Returns: list of tuple: Unique pairs (a, b) such that a + b = target. nums = sorted(nums) # Sort nums to ensure the pairs are in ascending order pairs = set() seen = {} for num in nums: complement = target - num if complement in seen: pairs.add((complement, num)) seen[num] = complement return sorted(list(pairs))"},{"question":"You are given two strings `s1` and `s2`. Your task is to determine if `s2` is an anagram of `s1`. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Return `true` if `s2` is an anagram of `s1`, and `false` otherwise.","solution":"def is_anagram(s1, s2): Checks if s2 is an anagram of s1. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s2 is an anagram of s1, False otherwise. # An anagram must have the same length and the same characters # Count the frequency of each character in both strings and compare return sorted(s1) == sorted(s2)"},{"question":"Given a 2D integer array `matrix`, where each row is sorted in non-decreasing order, implement a function to find the `k-th` smallest element in the matrix. The function should return the k-th smallest element while maintaining the sorting properties of each row.","solution":"import heapq def kth_smallest(matrix, k): Finds the k-th smallest element in a sorted 2D matrix. :param matrix: List[List[int]], 2D matrix where each row is sorted in non-decreasing order :param k: int, the k-th smallest element to find :return: int, the k-th smallest element in the matrix n = len(matrix) min_heap = [] for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) count = 0 while min_heap: element, r, c = heapq.heappop(min_heap) count += 1 if count == k: return element if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))"},{"question":"Given an integer `x`, return the largest number that is a power of two and less than or equal to `x`. A power of two is a number of the form `2^k` where `k` is a non-negative integer.","solution":"def largest_power_of_two(x): Returns the largest power of two less than or equal to x. if x < 1: return 0 power = 1 while power * 2 <= x: power *= 2 return power"},{"question":"Given a linked list, reverse the nodes of the list `k` at a time and return the modified list. `k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes should remain as-is. Implement the function `ListNode reverseKGroup(ListNode head, int k)` where: * `head` is the head of a singly linked list. * `k` is an integer representing the number of nodes to reverse at a time. # Example: Input: `head = [1,2,3,4,5]`, `k = 2` Output: `[2,1,4,3,5]` Input: `head = [1,2,3,4,5]`, `k = 3` Output: `[3,2,1,4,5]` **Note:** The linked list should be modified in-place without using extra memory for a different list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): new_head = None ptr = head while k > 0: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"The **string mirror** of a word is defined as the word followed by its reverse. For instance, the string mirror of the word `abc` is `abc` concatenated with `cba`, resulting in `abccba`. Given a string `s` consisting of lowercase English letters, return the **string mirror** of `s`. Ensure to handle cases where the string length and character variety might vary.","solution":"def string_mirror(s): Returns the string mirror of the input string s. return s + s[::-1]"},{"question":"You are given a list of integers `arr` and an integer `x`. Your task is to return the maximum product of any `x` consecutive elements in the list `arr`. If there are fewer than `x` elements in the list, return 0.","solution":"def max_product_of_consecutive_elements(arr, x): Returns the maximum product of any x consecutive elements in the list arr. If there are fewer than x elements in the list, returns 0. if len(arr) < x: return 0 max_product = float(\'-inf\') for i in range(len(arr) - x + 1): product = 1 for j in range(x): product *= arr[i + j] if product > max_product: max_product = product return max_product"},{"question":"You are given an array `arr` of integers and an integer `k`. A subarray is a contiguous part of an array. A subarray sum is the sum of elements in that subarray. Implement a function that returns the total number of subarrays whose sum equals to `k`. For example, given the input `arr = [1,1,1]` and `k = 2`, the function returns `2`, since there are two subarrays that sum to `2` ([1,1] starting at index 0 and [1,1] starting at index 1).","solution":"def subarray_sum(arr, k): Given an integer array `arr` and an integer `k`, this function returns the total number of subarrays whose sum equals to `k`. count = 0 current_sum = 0 sum_map = {0: 1} for num in arr: current_sum += num if current_sum - k in sum_map: count += sum_map[current_sum - k] if current_sum in sum_map: sum_map[current_sum] += 1 else: sum_map[current_sum] = 1 return count"},{"question":"You are given a string `sentence` that consists of words separated by spaces. Each word is a non-empty string of characters. Your task is to rearrange the words in the sentence in reverse order and return the resulting string. Words should be separated by a single space, and the resulting string should not contain any leading or trailing spaces.","solution":"def reverse_sentence(sentence): Reverses the words in the given sentence. Parameters: sentence (str): The sentence to be reversed. Returns: str: The sentence with the words in reverse order. words = sentence.split() reversed_words = \' \'.join(reversed(words)) return reversed_words"},{"question":"Given a list of non-negative integers representing the lengths of `n` rope pieces, you must connect all the ropes into one single rope. The cost of connecting two ropes is equal to the sum of their lengths. Implement a function to return the minimum cost to connect all the ropes.","solution":"import heapq def min_cost_to_connect_ropes(ropes): Returns the minimum cost to connect all ropes into one single rope. if not ropes: return 0 heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: first = heapq.heappop(ropes) second = heapq.heappop(ropes) cost = first + second total_cost += cost heapq.heappush(ropes, cost) return total_cost"},{"question":"Consider an array of integers `nums`, which can be positive, negative, or zero. Your task is to find the **minimum absolute difference** between any two elements in the array. Return the minimum absolute difference. Note that the array will have at least two elements.","solution":"def min_absolute_difference(nums): Returns the minimum absolute difference between any two elements in the array nums. nums.sort() min_diff = float(\'inf\') for i in range(1, len(nums)): min_diff = min(min_diff, abs(nums[i] - nums[i - 1])) return min_diff"},{"question":"Given a string `s`, return _the length of the longest substring without repeating characters_. For example: ```python # Example 1 s = \\"abcabcbb\\" Output: 3 Explanation: The answer is \\"abc\\", with the length of 3. # Example 2 s = \\"bbbbb\\" Output: 1 Explanation: The answer is \\"b\\", with the length of 1. # Example 3 s = \\"pwwkew\\" Output: 3 Explanation: The answer is \\"wke\\", with the length of 3. Notice that the answer must be a substring, \\"pwke\\" is a subsequence and not a substring.","solution":"def length_of_longest_substring(s): Given a string s, return the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"Given the `root` of a binary tree, return _the sum of values of the nodes with the **minimum depth** in the tree_. The **depth** of a node is the number of edges from the root to the node. A **minimum depth** is the shortest distance from the root node to any leaf node.","solution":"from collections import deque def min_depth_sum(root): Returns the sum of values of the nodes with the minimum depth in a binary tree. The minimum depth is the shortest distance from the root node to any leaf node. if not root: return 0 queue = deque([(root, 1)]) min_depth = float(\'inf\') min_depth_sum = 0 while queue: node, depth = queue.popleft() if not node.left and not node.right: if depth < min_depth: min_depth = depth min_depth_sum = node.val elif depth == min_depth: min_depth_sum += node.val else: if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return min_depth_sum # Definition for a binary tree node class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right"},{"question":"Given an integer array `nums`, return _the minimum difference between the largest and smallest values in any subtree_ of the binary tree formed by the elements of `nums` if inserted in the given order. A binary tree is constructed such that each element of the array becomes a node, and child nodes are added by following the order of elements. Complete the function to return a single integer that represents the minimum difference in values among all possible subtrees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root def construct_bst(nums): if not nums: return None root = TreeNode(nums[0]) for num in nums[1:]: insert_into_bst(root, num) return root def find_min_max_diff(root): if root is None: return float(\'inf\'), float(\'-inf\'), float(\'inf\') left_min, left_max, left_diff = find_min_max_diff(root.left) right_min, right_max, right_diff = find_min_max_diff(root.right) current_min = min(left_min, root.val) current_max = max(right_max, root.val) current_diff = current_max - current_min subtree_diff = min(left_diff, right_diff, current_diff) return current_min, current_max, subtree_diff def min_diff_in_subtree(nums): root = construct_bst(nums) return find_min_max_diff(root)[2]"},{"question":"A **string transformation** is performed by repeatedly removing all adjacent duplicate characters in the string. For example, the string `\\"abbaca\\"` would be transformed as `\\"abbaca\\" → \\"aaca\\" → \\"ca\\"`. Given a string `string`, return _the transformed string after performing the described transformation as many times as possible_. It is **guaranteed** that the input string contains only lowercase letters.","solution":"def remove_adjacent_duplicates(s): Transforms the string by repeatedly removing adjacent duplicate characters. :param s: Input string containing only lowercase letters. :return: Transformed string with no adjacent duplicates. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"Given an integer array `nums`, return _the sum of all **unique** elements in the array_. An element is considered **unique** if it appears exactly once in the array.","solution":"def sum_of_unique(nums): Returns the sum of all unique elements in the given integer array `nums`. An element is considered unique if it appears exactly once in the array. count = {} for num in nums: if num in count: count[num] += 1 else: count[num] = 1 unique_sum = sum(num for num, freq in count.items() if freq == 1) return unique_sum"},{"question":"You are given a list of **events** where each event is represented as a tuple `(type, timestamp)`. `type` can either be `\\"start\\"` or `\\"end\\"`, representing the start and end of an event interval, respectively. The `timestamp` is an integer representing when the event occurs. Write a function `findMaximumOverlap` that takes a list of such events and returns the maximum number of overlapping events at any point in time. Your function should have the following signature: ```python def findMaximumOverlap(events: List[Tuple[str, int]]) -> int ```","solution":"def findMaximumOverlap(events): Given a list of events represented as (type, timestamp), returns the maximum number of overlapping events at any point in time. from collections import defaultdict # Create a dictionary to count the changes in active events at each timestamp event_changes = defaultdict(int) for event_type, timestamp in events: if event_type == \\"start\\": event_changes[timestamp] += 1 elif event_type == \\"end\\": event_changes[timestamp] -= 1 max_overlap = 0 current_overlap = 0 # Sort the timestamps and calculate the overlap for key in sorted(event_changes): current_overlap += event_changes[key] if current_overlap > max_overlap: max_overlap = current_overlap return max_overlap"},{"question":"You are given a list of non-negative integers `nums` and an integer `target`. Your task is to determine whether there exist three distinct elements in `nums` whose sum is exactly `target`. If such a triplet exists, return _true_; otherwise, return _false_. For example, given `nums = [1, 2, 3, 4, 5]` and `target = 9`, you should return `true` because the triplet `(2, 3, 4)` sums up to `9`.","solution":"def three_sum(nums, target): Determine if there exist three distinct elements in `nums` whose sum is exactly `target`. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Given a list of positive integers `arr` and an integer `k`, your task is to find the maximum sum of `k` distinct elements from the list. Each element in `arr` can only be chosen once. Return the maximum sum of the `k` distinct elements. If there are fewer than `k` distinct elements in the array, return the sum of all its distinct elements.","solution":"def max_sum_k_distinct(arr, k): This function computes the maximum sum of \'k\' distinct elements from the list \'arr\'. Args: arr: List of positive integers k: Integer Returns: Integer: Maximum sum of \'k\' distinct elements or the sum of all distinct elements if there are fewer than \'k\' distinct elements. distinct_elements = list(set(arr)) # Get the distinct elements in the list distinct_elements.sort(reverse=True) # Sort them in descending order if k > len(distinct_elements): return sum(distinct_elements) else: return sum(distinct_elements[:k])"},{"question":"Given an integer `n`, return the `nth` Fibonacci number. The sequence starts with `0, 1` and each subsequent number is the sum of the previous two. You need to compute this value efficiently using matrix exponentiation. Return the `nth` Fibonacci number modulo `1000000007` to avoid large numbers.","solution":"def matrix_mult(A, B, mod): return [ [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % mod, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % mod], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % mod] ] def matrix_pow(matrix, n, mod): result = [[1, 0], [0, 1]] base = matrix while n > 0: if n % 2 == 1: result = matrix_mult(result, base, mod) base = matrix_mult(base, base, mod) n //= 2 return result def nth_fibonacci(n): if n == 0: return 0 elif n == 1: return 1 mod = 1000000007 F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n-1, mod) return result_matrix[0][0]"},{"question":"You are given an array of integers `arr` of length `n` and an integer `k`. A **K-pair** in the array is a pair of distinct indices `(i, j)` such that `arr[i] + arr[j] == k`. Your task is to write a function that returns the **number of K-pairs** in the array. Ensure your solution runs in `O(n log n)` time or better.","solution":"def count_k_pairs(arr, k): Returns the number of K-pairs in the array. Parameters: arr (list): A list of integers. k (int): An integer representing the sum of pairs. Returns: int: The number of K-pairs. element_count = {} count = 0 for number in arr: target = k - number if target in element_count: count += element_count[target] if number in element_count: element_count[number] += 1 else: element_count[number] = 1 return count"},{"question":"You are given a **0-indexed** integer array `nums` which represents the height of trees in a forest at different positions. You want to cut all the trees from the forest, but for some aesthetic reasons, you want to ensure that once a tree is cut, the heights of the remaining trees form a **strictly increasing** sequence when looked from left to right. Every time you cut a tree, its position in the array is permanently removed. Return _the minimum number of cuts_ required to achieve this.","solution":"def min_cuts_to_increasing_sequence(nums): Returns the minimum number of cuts required to ensure that the heights of the remaining trees form a strictly increasing sequence. n = len(nums) # Edge case for empty list or single element list. if n <= 1: return 0 # dp[i] will store the length of the longest increasing subsequence ending at index i. dp = [1] * n # Fill the dp array for i in range(n): for j in range(i): if nums[j] < nums[i]: dp[i] = max(dp[i], dp[j] + 1) # Find the length of the longest increasing subsequence. lis_length = max(dp) # The minimum number of cuts required is # total number of elements - length of the longest increasing subsequence. return n - lis_length"},{"question":"Given a list of `n` integers, each integer represents the time taken by a team member to complete their task. Your goal is to partition the team members into `k` non-empty groups such that the maximum time taken by any group is minimized. Write an algorithm to find the minimized maximum time. The time taken by a group is the sum of the individual times of the members in that group. Implement the function `int minimizeMaxGroupTime(int[] times, int k)` where: - `times` is a list of `n` integers representing the time taken by each team member. - `k` is an integer representing the number of groups to be formed. Return the minimized maximum time taken by any group after partitioning the team members.","solution":"def minimizeMaxGroupTime(times, k): def is_valid_partition(max_time): # Try to partition the array under the assumption that no group\'s time exceeds max_time current_sum = 0 groups_count = 1 for time in times: if current_sum + time > max_time: groups_count += 1 current_sum = time if groups_count > k: return False else: current_sum += time return True left, right = max(times), sum(times) while left < right: mid = left + (right - left) // 2 if is_valid_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"Given an integer array `heights` representing the heights of trees in a forest, you are tasked with finding the two trees that are the closest in height to each other. If there are multiple pairs with the same height difference, consider the pair with the smaller indices. The **difference in height** between two trees is the absolute difference between their heights. Return _a pair `(i, j)` representing the indices of the two trees with the smallest height difference, where_ `i < j`.","solution":"def find_closest_pair(heights): Finds the indices of the two trees with the smallest height difference. Parameters: heights (list of int): List of tree heights. Returns: tuple: A pair (i, j) representing the indices of the two trees with the smallest height difference. min_diff = float(\'inf\') closest_pair = (-1, -1) for i in range(len(heights) - 1): for j in range(i + 1, len(heights)): diff = abs(heights[i] - heights[j]) if diff < min_diff: min_diff = diff closest_pair = (i, j) return closest_pair"},{"question":"You are given two arrays `heights` and `widths` of positive integers where both arrays have a length of `n`. Each element in the `heights` array represents the height of a rectangle and the corresponding element in the `widths` array represents the width of the same rectangle. Write a function to determine the index of the rectangle (from `0` to `n-1`) that has the maximum area. Return the largest area formed by any rectangle from the given arrays. If there are multiple rectangles with the same maximum area, return the index of the first one.","solution":"def max_area_rectangle(heights, widths): This function calculates the area of rectangles and finds the index of the rectangle that has the maximum area. Parameters: heights (list of int): A list of heights of the rectangles. widths (list of int): A list of widths of the rectangles. Returns: int: The index of the rectangle with the maximum area. int: The maximum area formed by the rectangles. max_area = 0 max_index = 0 n = len(heights) for i in range(n): area = heights[i] * widths[i] if area > max_area: max_area = area max_index = i return max_index, max_area"},{"question":"Implement a function that simulates a simplified version of a text editor. The function should receive a series of operations to perform on an initially empty string. There are three types of operations: 1. `append(S)`: Append the string `S` to the end of the current string. 2. `delete(k)`: Delete the last `k` characters from the current string. 3. `get(k)`: Returns the k-th character of the current string (0-indexed). Return the results of all `get` operations in the order they were performed. Assume that the operations are valid, meaning that they will not attempt to delete or access characters that do not exist.","solution":"def text_editor(operations): Simulates a simplified version of a text editor. Parameters: operations (list of tuples): A list of operations to be performed on an initially empty string. Each operation is a tuple where the first element is a string representing one of the following operations: - \'append\' with the second element being the string to append - \'delete\' with the second element being the number of characters to delete - \'get\' with the second element being the index of the character to return Returns: list: A list of characters corresponding to the results of \'get\' operations. current_string = \\"\\" results = [] for op in operations: if op[0] == \'append\': current_string += op[1] elif op[0] == \'delete\': current_string = current_string[:-op[1]] elif op[0] == \'get\': results.append(current_string[op[1]]) return results"},{"question":"Given an integer array `arr` of length `n`, return the total count of subarrays whose sum is equal to a given integer `target`. A subarray is defined as a contiguous non-empty sequence of elements within an array. Provide the function signature (in Python): ```python def count_subarrays_with_sum(arr: List[int], target: int) -> int: pass ``` For example: * If `arr = [1, 1, 1]` and `target = 2`, the function should return `2` because there are two subarrays `[1, 1]` and `[1, 1]` that sum to `2`. * If `arr = [1, 2, 3]` and `target = 3`, the function should return `2` because there are two subarrays `[1, 2]` and `[3]` that sum to `3`. Focus on finding an efficient solution to the problem.","solution":"from typing import List def count_subarrays_with_sum(arr: List[int], target: int) -> int: from collections import defaultdict sum_count = defaultdict(int) sum_count[0] = 1 current_sum = 0 count = 0 for num in arr: current_sum += num count += sum_count.get(current_sum - target, 0) sum_count[current_sum] += 1 return count"},{"question":"Design a class named `RandomizedSet` that holds unique integers and allows insertion, deletion, and random element retrieval all in average constant time. Implement the class `RandomizedSet` with the following methods: * `RandomizedSet()` Initializes the `RandomizedSet` object. * `bool insert(int val)` Inserts an item `val` into the set if not already present. Returns `true` if the item was not present, `false` otherwise. * `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise. * `int getRandom()` Returns a random element from the current set of elements (it\'s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.","solution":"import random class RandomizedSet: def __init__(self): self.data = {} self.list = [] def insert(self, val): if val in self.data: return False self.data[val] = len(self.list) self.list.append(val) return True def remove(self, val): if val not in self.data: return False last_element = self.list[-1] index = self.data[val] self.list[index] = last_element self.data[last_element] = index self.list.pop() del self.data[val] return True def getRandom(self): return random.choice(self.list)"},{"question":"Given an integer `n`, generate a list of all balanced parentheses combinations that can be formed with exactly `n` pairs of parentheses. Return the list in any order. Python function signature: `def generateParenthesis(n: int) -> List[str]:`","solution":"def generateParenthesis(n): Generates all combinations of balanced parentheses with exactly n pairs. Args: n (int): Number of pairs of parentheses. Returns: List[str]: List of balanced parentheses combinations. def backtrack(S=\'\', left=0, right=0): if len(S) == 2 * n: result.append(S) return if left < n: backtrack(S + \'(\', left + 1, right) if right < left: backtrack(S + \')\', left, right + 1) result = [] backtrack() return result"},{"question":"You are given a **0-indexed** integer array `nums` representing a list of integers and an integer `k`. A partition of the array `nums` into subsets is valid if the maximum value in any subset minus the minimum value in that subset is at most `k`. Return _the minimum number of subsets in which the array `nums` can be partitioned such that each partition is valid according to the given condition_.","solution":"def min_partitions(nums, k): Returns the minimum number of subsets in which the array \'nums\' can be partitioned such that each partition is valid with the given condition. :param nums: List[int], the list of integers to be partitioned :param k: int, the maximum allowed difference between max and min values in any subset :return: int, the minimum number of subsets nums.sort() subsets = 0 i = 0 while i < len(nums): subsets += 1 start = nums[i] while i < len(nums) and nums[i] - start <= k: i += 1 return subsets"},{"question":"You are given a rectangular grid of dimension `m x n`. Each cell in the grid contains an integer representing the altitude at that cell. A water flow can start from any cell located on the boundary of the grid and water can only flow to neighboring cells (up, down, left, or right) with lower or equal altitude. Determine the coordinates of all cells where water can flow to both the Pacific and Atlantic oceans. The Pacific Ocean touches the left and top edges of the grid, and the Atlantic Ocean touches the right and bottom edges of the grid. Return the list of coordinates in any order.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) def bfs(starts): visited = set(starts) queue = list(starts) while queue: x, y = queue.pop(0) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and matrix[nx][ny] >= matrix[x][y]: visited.add((nx, ny)) queue.append((nx, ny)) return visited pacific_starts = [(i, 0) for i in range(m)] + [(0, j) for j in range(n)] atlantic_starts = [(i, n-1) for i in range(m)] + [(m-1, j) for j in range(n)] pacific_reachable = bfs(pacific_starts) atlantic_reachable = bfs(atlantic_starts) return list(pacific_reachable & atlantic_reachable)"},{"question":"Given a sorted array of distinct integers `arr`, and an integer `k`, find the `k`-th positive integer that is missing from this array. The elements of `arr` are sorted in strictly increasing order.","solution":"def find_kth_missing(arr, k): Find the k-th positive integer missing from the given sorted array. Args: arr (List[int]): A sorted array of distinct integers. k (int): The k-th missing positive integer to find. Returns: int: The k-th missing positive integer. # The number of missing positives before the current position missing = 0 current = 1 for num in arr: while current < num: missing += 1 if missing == k: return current current += 1 current += 1 # If the array is exhausted and k-th missing is still not found while missing < k: missing += 1 current += 1 return current - 1"},{"question":"You are given a string `s` and an integer `k`. A substring is considered **valid** if it contains at most `k` distinct characters. Write a function to return the length of the longest valid substring of `s`.","solution":"def longest_valid_substring(s, k): Returns the length of the longest substring containing at most k distinct characters. n = len(s) if k == 0 or n == 0: return 0 left = 0 right = 0 max_length = 0 char_map = {} while right < n: current_char = s[right] if current_char in char_map: char_map[current_char] += 1 else: char_map[current_char] = 1 while len(char_map) > k: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given a 2D array `grid` of size `m x n` representing an image where each cell has a value of `0` (white) or `1` (black). The image contains exactly one rectangle composed of black cells (`1`) which are connected horizontally or vertically. Return an array `[r1, c1, r2, c2]` which contains the coordinates of the rectangle, where `(r1, c1)` is the top-left corner, and `(r2, c2)` is the bottom-right corner of the rectangle. If no such rectangle exists, return an empty list.","solution":"def find_rectangle_coordinates(grid): Finds the top-left and bottom-right coordinates of the rectangle formed by \'1\'s in a 2D grid. :param grid: List of List of integers (0 or 1) :return: List of four integers [r1, c1, r2, c2] or empty list if no rectangle exists m, n = len(grid), len(grid[0]) top_left = None bottom_right = None for r in range(m): for c in range(n): if grid[r][c] == 1: if top_left is None: top_left = (r, c) bottom_right = (r, c) if top_left is None: return [] r1, c1 = top_left r2, c2 = bottom_right return [r1, c1, r2, c2]"},{"question":"Imagine you are given an array of integers representing the height of consecutive buildings on a street, where the width of each building is the same and equal to 1. You are tasked with finding out the maximum area of a rectangle that can be formed by selecting consecutive buildings. Implement the function `maxRectangleArea(int[] heights)` that takes an array of integers as input and returns an integer representing the maximum rectangular area that can be formed between consecutive buildings. Example: Suppose you have the height array `heights = [2, 1, 5, 6, 2, 3]`, the function should return `10`, which corresponds to the rectangle formed by the 3rd and 4th buildings with heights `5` and `6`. Your solution should efficiently calculate the maximum rectangle area, considering possible scenarios and edge cases.","solution":"def maxRectangleArea(heights): Returns the maximum rectangle area that can be formed between consecutive buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given an integer array `arr`, return _the length of the longest subarray with the maximum bitwise AND_.","solution":"def longest_subarray_with_max_bitwise_and(arr): Returns the length of the longest subarray with the maximum bitwise AND. if not arr: return 0 # Find the overall maximum value in the array max_value = max(arr) # Initialize variables for the longest subarray length and current subarray length longest_length = current_length = 0 for num in arr: if num == max_value: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 0 return longest_length"},{"question":"You are given an array `events` where `events[i] = [startDayi, endDayi, valuei]` represents an event that starts at `startDayi` and ends at `endDayi` with a value of `valuei`. You can attend an event i at any day `d` where `startDayi <= d <= endDayi`. Note that you can only attend one event at a time. Return _the maximum total value_ you can obtain by attending events.","solution":"def maxValue(events): events.sort(key=lambda x:(x[1], x[0])) dp = [0] * (len(events) + 1) def binary_search(events, end_day): lo, hi = 0, len(events) - 1 while lo <= hi: mid = (lo + hi) // 2 if events[mid][1] <= end_day: lo = mid + 1 else: hi = mid - 1 return lo for i in range(1, len(events) + 1): j = binary_search(events, events[i-1][0] - 1) dp[i] = max(dp[i-1], dp[j] + events[i-1][2]) return dp[-1]"},{"question":"You are given an unsorted array of unique integers `nums`. A \\"mountain array\\" is defined as an array where there exists some index `i` (0 < i < nums.length - 1) such that: - `nums[0] < nums[1] < ... < nums[i-1] < nums[i]` - `nums[i] > nums[i+1] > ... > nums[nums.length - 1]` Your task is to find the length of the longest contiguous subarray of `nums` that is a mountain. If there is no mountain subarray, return 0. [Question] 5:","solution":"def longest_mountain(nums): Finds the length of the longest contiguous subarray of nums that is a mountain. n = len(nums) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: left = i - 1 right = i + 1 while left > 0 and nums[left] > nums[left - 1]: left -= 1 while right < n - 1 and nums[right] > nums[right + 1]: right += 1 current_length = right - left + 1 longest = max(longest, current_length) return longest"},{"question":"You are given an array of integers `nums` and an integer `threshold`. Find the length of the longest subarray such that the sum of the absolute differences between consecutive elements is less than or equal to `threshold`. If no such subarray exists, return 0. Implement the function `int longestSubarray(int[] nums, int threshold)` that takes an array of integers `nums` and an integer `threshold` as arguments and returns the length of the longest subarray.","solution":"def longestSubarray(nums, threshold): Returns the length of the longest subarray such that the sum of the absolute differences between consecutive elements is less than or equal to threshold. n = len(nums) if n == 0: return 0 max_length = 0 current_sum = 0 start = 0 for end in range(1, n): current_sum += abs(nums[end] - nums[end - 1]) while current_sum > threshold and start < end: current_sum -= abs(nums[start + 1] - nums[start]) start += 1 max_length = max(max_length, end - start + 1) return max_length if max_length > 1 else 0"},{"question":"You are given a list of integers representing the heights of a set of buildings, where the width of each building is 1 unit. The buildings are lined up in a straight line, and you want to calculate how much water can be trapped between them after it rains. Write a function that takes in an array of integers `heights` and returns the total amount of water that can be trapped between the buildings. The function should consider the width of the buildings and make sure that it correctly accounts for the water trapped in the valleys between the buildings.","solution":"def trap_rain_water(heights): Calculate the total amount of water that can be trapped between the buildings. :param heights: List[int] - list of building heights. :return: int - total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(heights[i], left_max[i - 1]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(heights[i], right_max[i + 1]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"You are given an array of integers `nums` sorted in ascending order, and an integer `target`. Implement a function `int searchRange(int[] nums, int target)` that finds the starting and ending positions of a given `target` value. If `target` is not found in the array, return `[-1, -1]`. Your implementation should have a time complexity of `O(log n)` where `n` is the number of elements in `nums`. Use binary search to achieve this. The array is not modified, and you must handle cases where the array might be empty or the target value might not be present in the array. For example: - Given `nums = [5, 7, 7, 8, 8, 10]` and `target = 8`, return `[3, 4]`. - Given `nums = [5, 7, 7, 8, 8, 10]` and `target = 6`, return `[-1, -1]`. - Given `nums = []` and `target = 0`, return `[-1, -1]`. Implement the `SearchRange` class with the following methods: * `SearchRange(int[] nums)` Initializes the object with a sorted array of integers. * `int[] searchRange(int target)` Returns an array with two elements, where the first element is the starting position and the second element is the ending position of the `target` value. If the target is not found, return `[-1, -1]`.","solution":"class SearchRange: def __init__(self, nums): self.nums = nums def searchRange(self, target): start = self.binarySearch(target, True) end = self.binarySearch(target, False) if start != -1 else -1 return [start, end] def binarySearch(self, target, findFirst): start, end = 0, len(self.nums) - 1 index = -1 while start <= end: mid = (start + end) // 2 if self.nums[mid] == target: index = mid if findFirst: end = mid - 1 else: start = mid + 1 elif self.nums[mid] < target: start = mid + 1 else: end = mid - 1 return index"},{"question":"Given a `board` representing an `m x n` grid, where each cell is either a wall (\'#\'), an empty slot (\'.\'), a key (\'a\'-\'f\'), or a lock (\'A\'-\'F\'), design an algorithm to find the shortest path to collect all keys. A path is defined as the sequence of adjacent cells that must be traversed from the start to the end. You can move up, down, left, or right on the grid. You start at a given starting point denoted by \'@\'. The goal is to find the shortest path to collect all keys. The number of keys is between `1` and `6`, and each key has a corresponding lock. Implement a function `int shortestPathAllKeys(char[][] grid)` that returns the length of the shortest path to collect all keys. If it is impossible to collect all the keys, return `-1`.","solution":"from collections import deque def shortestPathAllKeys(grid): m, n = len(grid), len(grid[0]) start = None total_keys = 0 # Find the start position and number of keys for i in range(m): for j in range(n): if grid[i][j] == \'@\': start = (i, j) elif \'a\' <= grid[i][j] <= \'f\': total_keys += 1 # Direction vectors for moving up, down, left, right directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Queue will store tuples of (x, y, current_keys_bitmask) queue = deque([(start[0], start[1], 0)]) visited = set((start[0], start[1], 0)) steps = 0 all_keys_bitmask = (1 << total_keys) - 1 while queue: for _ in range(len(queue)): x, y, keys = queue.popleft() # If we\'ve collected all keys, return the number of steps if keys == all_keys_bitmask: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: cell = grid[nx][ny] if cell == \'#\': continue if \'A\' <= cell <= \'F\' and not (keys & (1 << (ord(cell) - ord(\'A\')))): continue new_keys = keys if \'a\' <= cell <= \'f\': new_keys |= (1 << (ord(cell) - ord(\'a\'))) if (nx, ny, new_keys) not in visited: visited.add((nx, ny, new_keys)) queue.append((nx, ny, new_keys)) steps += 1 return -1"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to return the level order traversal of the nodes\' values as a list of lists. Each list should contain all the values of a specific level from left to right. The binary tree is represented by its root node. Note: Level order traversal for a binary tree is also known as Breadth-First Search (BFS) traversal.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root): Perform level order traversal of a binary tree and return values in level order. Args: root (TreeNode): Root node of the binary tree. Returns: List[List[int]]: List of lists containing node values at each level. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"Given a string `s` representing a sequence of lowercase alphabets, you need to remove duplicate letters from this string such that every letter appears only once and the resulting string is in lexicographical order. Return _the smallest lexicographical string that can be obtained by removing duplicate letters from_ `s`.","solution":"def remove_duplicate_letters(s): Returns the smallest lexicographical string that can be obtained by removing duplicate letters from the input string `s`. stack = [] seen = set() last_occurrence = {char: index for index, char in enumerate(s)} for index, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and index < last_occurrence[stack[-1]]: seen.remove(stack.pop()) stack.append(char) seen.add(char) return \'\'.join(stack)"},{"question":"Given a `m x n` matrix filled with non-negative integers, find the maximum sum of a rectangle in the matrix such that the sum is no larger than a given integer `k`. Your task is to write a function that determines this maximum sum. The matrix can have a larger number of rows and columns, but the elements are assured to be non-negative. Note that the rectangle should be a submatrix that consists of contiguous rows and columns.","solution":"import bisect def maxSumSubmatrix(matrix, k): Find the maximum sum of a rectangle within the matrix such that the sum is no larger than k. def maxSumSubarray(arr, k): max_sum = float(\'-inf\') curr_sum = 0 sum_set = [0] for num in arr: curr_sum += num i = bisect.bisect_left(sum_set, curr_sum - k) if i < len(sum_set): max_sum = max(max_sum, curr_sum - sum_set[i]) bisect.insort(sum_set, curr_sum) return max_sum if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') for left in range(cols): row_sum = [0] * rows for right in range(left, cols): for r in range(rows): row_sum[r] += matrix[r][right] max_sum = max(max_sum, maxSumSubarray(row_sum, k)) return max_sum"},{"question":"You are given an array of integers `nums` and an integer target `k`. Your task is to determine if there exists a **subarray** (contiguous sequence of elements) whose sum is equal to `k`. If such a subarray exists, return true; otherwise, return false. A subarray is defined as a contiguous part of an array.","solution":"def subarray_sum(nums, k): Determine if there exists a subarray whose sum is equal to k. Args: nums: List of integers k: Integer target sum Returns: bool: True if such a subarray exists, False otherwise current_sum = 0 sum_map = {0: -1} # To handle the edge case where the subarray starts from the index 0 for i, num in enumerate(nums): current_sum += num if current_sum - k in sum_map: return True sum_map[current_sum] = i return False"},{"question":"You are given a string `s`, which consists of lowercase English letters and the \'#\' character. The \'#\' character in the string indicates a backspace, meaning the character before it should be removed. Your task is to return the string after all the backspaces have been applied. * For example, if `s = \\"abc#d\\"` it should be modified to `abd` because the \'c\' before the \'#\' gets removed. * If `s = \\"abc\\"`, it should be modified to `c` because the two backspaces \'#\' remove the \'b\' and then the \'a\'. Return _the final string after all backspaces have been processed_.","solution":"def process_backspaces(s): Processes a string `s` with backspaces indicated by \'#\' the backspace character removes the preceding character. :param s: str: Input string consisting of lowercase letters and \'#\'. :return: str: Processed string after applying backspaces. result = [] for char in s: if char == \'#\': if result: result.pop() else: result.append(char) return \'\'.join(result)"},{"question":"Given an array of integers `nums` and an integer `k`, determine whether there is a continuous subarray of size at least two whose elements sum up to a multiple of `k`. In other words, find if there exists a subarray of size at least `2` whose sum is divisible by `k`. A continuous subarray is defined as a sequence of elements from the original array where the order of elements is maintained. Return `true` if such a subarray exists, otherwise return `false`.","solution":"def check_subarray_sum(nums, k): Determines whether there is a continuous subarray of size at least two whose elements sum up to a multiple of k. Parameters: nums (List[int]): The input list of integers. k (int): The integer to check multiples of. Returns: bool: True if such a subarray exists, otherwise False. cumulative_sum = 0 sum_remainders = {0: -1} # Initialize with 0 remainder at index -1 for i, num in enumerate(nums): cumulative_sum += num if k != 0: remainder = cumulative_sum % k else: remainder = cumulative_sum if remainder in sum_remainders: if i - sum_remainders[remainder] > 1: return True else: sum_remainders[remainder] = i return False"},{"question":"You are given a binary tree in which each node contains an integer value. We define a path\'s \\"zigzag length\\" as the number of edges in the longest zigzag path in the tree. A zigzag path is a path that starts at one node and alternates between moving left and right (or vice versa) down the tree. One node might have a left child, that left child might have a right child, that right child might have a left child, and so forth. Return the length of the longest zigzag path in the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestZigZag(root): def dfs(node, direction, length): if not node: return length - 1 if direction == \\"left\\": left_result = dfs(node.left, \\"right\\", length + 1) right_result = dfs(node.right, \\"left\\", 1) else: left_result = dfs(node.left, \\"right\\", 1) right_result = dfs(node.right, \\"left\\", length + 1) return max(left_result, right_result) if not root: return 0 return max(dfs(root.left, \\"right\\", 1), dfs(root.right, \\"left\\", 1))"},{"question":"In a tree represented as an adjacency list where each node has a unique value, you are given a target value. Find and return the sum of all nodes in the subtree rooted at the node with the given target value. If the target value does not exist in the tree, return 0.","solution":"def sum_of_subtree(tree, target): Returns the sum of all nodes in the subtree rooted at the node with the given target value. If the target value does not exist in the tree, returns 0. :param tree: dict, adjacency list representing the tree :param target: int, value of the node to find the subtree for :return: int, the sum of all nodes in the subtree rooted at the target node if target not in tree: return 0 def dfs(node): total = node for child in tree.get(node, []): total += dfs(child) return total return dfs(target)"},{"question":"Given an integer array `arr`, write a function that filters the elements in `arr` to create a new array that contains only those elements that appear more than once. The returned array should be sorted in the same order in which elements first appear in `arr`. If no element in `arr` appears more than once, return an empty array.","solution":"def filter_duplicates(arr): Returns a list of elements that appear more than once in \'arr\', sorted in the order in which they first appear in \'arr\'. from collections import Counter # Count the occurrences of each element counts = Counter(arr) # Filter elements that appear more than once and preserve order result = [item for item in arr if counts[item] > 1] # To ensure only one instance of such elements (preserve the appearance order) seen = set() duplicates = [] for item in result: if item not in seen: duplicates.append(item) seen.add(item) return duplicates"},{"question":"A company requires a system to manage meetings in a single conference room. Each meeting has a start time and an end time, represented as integers, where the start time is less than the end time. Two meetings are considered compatible if they do not overlap, i.e., one meeting ends before the other starts. Given a list of `n` meetings, determine the maximum number of compatible meetings that can be scheduled in the conference room. Return _the maximum number of non-overlapping meetings that can be accommodated_ in the conference room.","solution":"def max_compatible_meetings(meetings): Determine the maximum number of non-overlapping meetings that can be accommodated in the conference room. Args: meetings (list of tuples): List where each tuple contains two integers, representing the start and end times of a meeting. Returns: int: The maximum number of non-overlapping meetings. # Sort meetings by end time sorted_meetings = sorted(meetings, key=lambda x: x[1]) count = 0 last_end_time = float(\'-inf\') for start, end in sorted_meetings: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"You are given a list of integers `nums` and an integer `k`. A **subarray** of `nums` is any contiguous subarray of `nums`. A subarray is considered **good** if the **sum of its elements** is divisible by `k`. Return the total number of **good subarrays** in `nums`. **Note**: The sum of an empty subarray is considered to be 0, which is divisible by every integer `k`.","solution":"def count_good_subarrays(nums, k): Returns the total number of good subarrays in nums such that the sum of its elements is divisible by k. Args: nums (list of int): List of integers. k (int): An integer divisor. Returns: int: Number of good subarrays. from collections import defaultdict remainder_count = defaultdict(int) remainder_count[0] = 1 # to handle subarrays which directly sum to a multiple of k current_sum = 0 good_subarray_count = 0 for num in nums: current_sum += num remainder = current_sum % k if remainder < 0: remainder += k good_subarray_count += remainder_count[remainder] remainder_count[remainder] += 1 return good_subarray_count"},{"question":"You are given a list of `n` integers and an integer `k`. Write a function to determine if there is a continuous subarray of size `k` that sums up to a given integer `target`. If one exists, return `true`; otherwise, return `false`. Note that the subarray must have exactly `k` elements and the elements must be contiguous in the original array.","solution":"def has_subarray_with_sum(arr, k, target): Returns True if there exists a continuous subarray of size `k` in `arr` that sums up to `target`. Otherwise, returns False. n = len(arr) # If k is larger than the length of the array, return False if k > n: return False # Calculate the sum of the first k elements current_sum = sum(arr[:k]) # Check if the sum of the first k elements is equal to target if current_sum == target: return True # Now slide the window for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum == target: return True return False"},{"question":"There are `n` courses you must take, labeled from 0 to `n-1`. Some courses may have prerequisites, meaning that in order to take a course, you must have first taken another specified course. Given a prerequisite list where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` before course `ai`, determine if it is possible to finish all courses. Return `true` if it is possible to finish all courses, otherwise return `false`. For instance, if there are 3 courses and the prerequisite list is `[[1, 0], [2, 1], [3, 2]]`, then you must take course 0 before course 1, course 1 before course 2, and course 2 before course 3, making it possible to finish all courses. However, if there is a cycle such as `[[1, 0], [0, 1]]`, it is impossible to finish all courses.","solution":"def canFinish(numCourses, prerequisites): from collections import defaultdict, deque # Initialize adjacency list for representing graph of courses course_dict = defaultdict(list) in_degree = {i: 0 for i in range(numCourses)} # Keeps track of the number of prerequisites # Build the graph and record in-degrees for dest, src in prerequisites: course_dict[src].append(dest) in_degree[dest] += 1 # Queue for courses with no prerequisites queue = deque([course for course in in_degree if in_degree[course] == 0]) # Number of courses that meet prerequisites count = 0 while queue: course = queue.popleft() count += 1 # Process neighbour nodes (courses that depend on the current course) for neighbor in course_dict[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If count equals numCourses, all courses can be completed return count == numCourses"},{"question":"You are given a **0-indexed** integer array `arr` containing `n` unique elements, and an integer `x`. A **shuffle** consists of arranging the elements of `arr` in any order. Your task is to find the lexicographically smallest shuffle of `arr` such that the **absolute difference** between the first element and `x` is minimized. If there are multiple shuffles that satisfy this condition, return the one with the smallest lexicographical order among them. Return the rearranged array as the result.","solution":"def minimize_difference_and_sort(arr, x): Returns the lexicographically smallest shuffle of `arr` such that the absolute difference between the first element and `x` is minimized. # Sort the array to find the lexicographically smallest order arr.sort() # Find the value in `arr` that minimizes the absolute difference with `x` min_diff = float(\'inf\') best_element = None for element in arr: diff = abs(element - x) if diff < min_diff: min_diff = diff best_element = element # Move the best_element to the front arr.remove(best_element) arr.insert(0, best_element) return arr"},{"question":"You are given a string `s` consisting of lowercase English letters, a string `p` also consisting of lowercase English letters, and an integer `k`. You need to determine if it is possible to convert `s` into a string that contains `p` as a substring after performing at most `k` operations. In one operation, you can replace any character in `s` with any other lowercase English letter. Return `true` if it is possible to make `p` a substring of `s` within `k` operations, otherwise return `false`.","solution":"def can_convert_to_contain_substring(s, p, k): Determine if it is possible to convert `s` into a string that contains `p` as a substring after performing at most `k` operations. :param s: The original string consisting of lowercase English letters. :param p: The substring to form by performing operations. :param k: The maximum number of operations allowed. :return: True if possible to form `p` as substring within `k` operations, otherwise False. n, m = len(s), len(p) # If `p` is longer than `s`, it is not possible if m > n: return False # Check each possible position in `s` to match `p` for i in range(n - m + 1): # Count mismatches for this position mismatch_count = sum(1 for j in range(m) if s[i + j] != p[j]) # If mismatches are within the allowed number of operations, return True if mismatch_count <= k: return True return False"},{"question":"Given a string `s` containing lowercase alphabetic characters, you need to replace each character with the next one in the English alphabet. The transformation should be cyclic, so the character \'z\' should be replaced with \'a\'. Return the transformed string. For example, given the input `s = \\"abcdz\\"`, the output should be `\\"bcdea\\"`.","solution":"def transform_string(s): Transforms a given string by replacing each character with the next one in the English alphabet. The transformation is cyclic, so \'z\' is replaced by \'a\'. Parameters: s (str): Input string containing lowercase alphabetic characters. Returns: str: The transformed string. transformed = \\"\\" for char in s: if char == \'z\': transformed += \'a\' else: transformed += chr(ord(char) + 1) return transformed"},{"question":"Given a **0-indexed** integer array `cards` of length `n` representing the value of each card, you are to arrange the cards into several groups. A group is defined as a sequence of two or more consecutive cards with the same value. Return the maximum number of groups you can form such that each card is used exactly once in some group. If it\'s not possible to use all cards in groups, return `-1`. Implement the function `int maxGroups(vector<int>& cards)` that takes the `cards` array and returns the maximum number of groups or `-1` if not all cards can be grouped.","solution":"def maxGroups(cards): Returns the maximum number of groups that can be formed from the cards array where each group consists of two or more consecutive cards with the same value. If it\'s not possible to use all cards in groups, returns -1. :param cards: List[int] - a 0-indexed integer array representing the value of each card :return: int - the maximum number of groups, or -1 if not all cards can be grouped from collections import Counter count = Counter(cards) # For each card value, we need at least two cards to form a group for value in count.values(): if value < 2: return -1 # The number of groups will depend on the most frequently occurring card value return sum(value // 2 for value in count.values())"},{"question":"Given an array of integers `nums`, you need to find all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` that sum up to a target value `target`. Notice that the solution set must not contain duplicate quadruplets. Write a function `vector<vector<int>> fourSum(vector<int>& nums, int target)` that finds all the unique quadruplets that add up to the given target and returns them as a list of arrays in any order. Example: Given an input array `nums = [1, 0, -1, 0, -2, 2]` and a target `target = 0`, the function should return `[[ -2, -1, 1, 2 ], [ -2, 0, 0, 2 ], [ -1, 0, 0, 1 ]]`. Note that the order of the quadruplets inside the result list does not matter, but there should be no repeated quadruplets. Implement the `fourSum` function.","solution":"def fourSum(nums, target): Finds all unique quadruplets in the list that add up to the target. nums.sort() res, quad = [], [] def kSum(k, start, target): if k != 2: for i in range(start, len(nums) - k + 1): if i > start and nums[i] == nums[i - 1]: continue quad.append(nums[i]) kSum(k - 1, i + 1, target - nums[i]) quad.pop() return # Two-pointer approach for 2-sum problem l, r = start, len(nums) - 1 while l < r: if nums[l] + nums[r] < target: l += 1 elif nums[l] + nums[r] > target: r -= 1 else: res.append(quad + [nums[l], nums[r]]) l += 1 while l < r and nums[l] == nums[l - 1]: l += 1 kSum(4, 0, target) return res"},{"question":"Given a list of non-negative integers `nums`, return the smallest positive integer that is not present in `nums`. You must solve this in linear time and using constant extra space.","solution":"def first_missing_positive(nums): Returns the smallest positive integer that is not present in nums. Uses a linear time algorithm with constant extra space. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"You are given a **binary search tree** (BST) with `n` nodes. Each node is uniquely assigned a value from `1` to `n`. You need to implement a function that returns a list of all the values in the BST that fall within a specified range `[low, high]` (inclusive). The values in the output list should be sorted in ascending order. You are provided with the `root` of the BST and two integers `low` and `high` representing the range. Write a function that finds and returns these values.","solution":"class TreeNode: Definition for a binary tree node. def __init__(self, x): self.val = x self.left = None self.right = None def rangeBST(root, low, high): Returns a list of all the values in the BST that fall within the range [low, high]. def inorder(node): if not node: return [] left_values = inorder(node.left) current_value = [node.val] if low <= node.val <= high else [] right_values = inorder(node.right) return left_values + current_value + right_values return inorder(root)"},{"question":"Given a binary tree, each node has a value that is either `0` or `1`. Return the sum of the values of all nodes lying on the paths from the root to the leaves where the path represents a binary number when read from top to bottom. Each path yields a binary number, and the sum should be the sum of these binary numbers. **Note**: * The tree will have at least one node and the values are restricted to `0` and `1` only.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): Returns the sum of the binary numbers represented by the paths from the root to the leaves. def dfs(node, current_number): if not node: return 0 current_number = current_number * 2 + node.val # If it\'s a leaf node, return the current_number. if not node.left and not node.right: return current_number # Continue DFS on left and right children. return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"You are given an array `arr` of positive integers and an integer `k`. Your task is to divide the array into `k` contiguous subarrays such that the difference between the maximum and minimum sums among these subarrays is minimized. Return _the minimized difference between the maximum and minimum sums of the `k` subarrays_. For example, given `arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]` and `k = 3`, the subarrays might be `[1, 2, 3, 4]`, `[5, 6]`, and `[7, 8, 9]`. The sums of these subarrays are `10`, `11`, and `24`, respectively, giving a difference of `24 - 10 = 14`.","solution":"def min_max_sum_diff(arr, k): Returns the minimized difference between the maximum and minimum sums of k contiguous subarrays from the given array. def canPartition(mid): current_sum, count = 0, 1 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > k: return False else: current_sum += num return True low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if canPartition(mid): high = mid else: low = mid + 1 return low"},{"question":"You are given a list of words and a string `pattern`. Each word can be transformed into another word by replacing each letter with a common letter. For example, \\"abc\\" can be transformed into \\"mno\\" by replacing \'a\' with \'m\', \'b\' with \'n\', and \'c\' with \'o\'. Determine which words in the list match the given pattern using this transformation method. Return the list of words that match the pattern.","solution":"def find_and_replace_pattern(words, pattern): Finds and returns the list of words that match the given pattern. A word matches the pattern if it can be transformed into the pattern by replacing each letter with a common letter. :param words: List[str], list of words to check :param pattern: Str, the pattern to match :return: List[str], list of words that match the pattern def matches(word, pattern): if len(word) != len(pattern): return False char_map = {} used_chars = set() for w_char, p_char in zip(word, pattern): if p_char in char_map: if char_map[p_char] != w_char: return False else: if w_char in used_chars: return False char_map[p_char] = w_char used_chars.add(w_char) return True return [word for word in words if matches(word, pattern)]"},{"question":"You are given a list of `n` video timestamps in the format `hours:minutes:seconds`, and a target duration `d` in seconds. Write a function to find pairs of timestamps where the absolute difference in their durations is less than or equal to `d` seconds. Return a list of tuples, where each tuple contains the indices of the two timestamps forming such a pair. Indices in the output list should be in ascending order, and the pairs themselves should be sorted lexicographically by the first index then the second index.","solution":"def timestamp_to_seconds(timestamp): hours, minutes, seconds = map(int, timestamp.split(\':\')) return hours * 3600 + minutes * 60 + seconds def find_timestamp_pairs(timestamps, d): Returns a list of tuples where each tuple contains the indices of two timestamps with durations that differ by less than or equal to `d` seconds. n = len(timestamps) seconds_list = [timestamp_to_seconds(t) for t in timestamps] result = [] for i in range(n): for j in range(i + 1, n): if abs(seconds_list[i] - seconds_list[j]) <= d: result.append((i, j)) return sorted(result)"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents a point on a 2D plane. Write a function to determine the maximum number of points that lie on the same straight line. Return the maximum number of collinear points.","solution":"from collections import defaultdict from math import gcd def max_points_on_a_line(points): def normalize(dx, dy): if dx == 0: return (0, 1) if dy == 0: return (1, 0) g = gcd(dx, dy) return (dx // g, dy // g) if dx > 0 else (-dx // g, -dy // g) if not points: return 0 max_points = 1 n = len(points) for i in range(n): slopes = defaultdict(int) duplicate_points = 0 for j in range(i + 1, n): dx = points[j][0] - points[i][0] dy = points[j][1] - points[i][1] if dx == 0 and dy == 0: duplicate_points += 1 continue slope = normalize(dx, dy) slopes[slope] += 1 max_points = max(max_points, (max(slopes.values()) if slopes else 0) + duplicate_points + 1) return max_points"},{"question":"Given two arrays of integers `arr1` and `arr2`, return the minimum number of operations required to make `arr1` and `arr2` identical. In one operation, you can either remove an integer from `arr1` or `arr2` or add an integer to `arr1` or `arr2`. It is guaranteed that the minimum number of operations needed will always be finite given the constraints. An operation may not change the order of elements within the arrays. The arrays may contain duplicate elements.","solution":"def min_operations_to_make_identical(arr1, arr2): Returns the minimum number of operations needed to make two arrays identical. Operations can be adding or removing elements. from collections import Counter counter1 = Counter(arr1) counter2 = Counter(arr2) diff1 = counter1 - counter2 diff2 = counter2 - counter1 total_operations = sum(diff1.values()) + sum(diff2.values()) return total_operations"},{"question":"Given a string `s` consisting of lowercase letters, reverse each word of the string while maintaining the word order and the same amount of spaces between the words. A **word** is defined as a sequence of non-space characters, and words are separated by a single space. Return the modified string.","solution":"def reverse_words(s): Reverses each word in the string while maintaining word order and spaces. words = s.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"You are given a string `s` consisting of characters \'a\' and \'b\' only. You are allowed to perform at most `k` operations on this string. In one operation, you can choose any character from the string and flip it (change \'a\' to \'b\' or vice versa). Your task is to determine the length of the longest substring containing only \'a\' or only \'b\' that can be obtained by performing up to `k` operations. Return _the length of the longest possible substring_.","solution":"def longest_substring(s, k): def max_length_with_char(s, k, char): max_len = 0 left = 0 count = 0 for right in range(len(s)): if s[right] != char: count += 1 while count > k: if s[left] != char: count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len return max(max_length_with_char(s, k, \'a\'), max_length_with_char(s, k, \'b\'))"},{"question":"You are given a list of integers `heights` which represents the height of a neighboring building. A building `i` is said to have an ocean view if every building to the right of it is shorter. Return the indices of buildings that have an ocean view in increasing order.","solution":"def findBuildingsWithOceanView(heights): Returns the indices of buildings that have an ocean view in increasing order. Args: heights (list): A list of integers representing building heights. Returns: list: A list of indices of buildings with an ocean view. n = len(heights) if n == 0: return [] result = [] max_height = float(\'-inf\') for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"You are given an undirected graph with `n` nodes and `edges`, where `edges[i] = [u, v]` indicates that there is an edge between the nodes `u` and `v`. You want to determine if the graph is **bipartite**. A graph is bipartite if the nodes can be divided into two groups such that no two nodes within the same group are adjacent. Implement a function `isBipartite` that takes `n` and `edges` as input and returns `true` if the graph is bipartite, and `false` otherwise.","solution":"def isBipartite(n, edges): Determine if the graph is bipartite. :param n: Number of nodes (int) :param edges: List of edges where each edge is a list [u, v] :return: Boolean value, True if the graph is bipartite, False otherwise from collections import deque, defaultdict # Create an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Array to store the color of each node, -1 means uncolored, 0 and 1 are the two colors color = [-1] * n # Iterate over all nodes to handle disconnected graphs for start in range(n): if color[start] == -1: # Not colored # Perform BFS queue = deque([start]) color[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: # Not colored # Color with opposite color color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # Same color as current node return False return True"},{"question":"Given two strings `s1` and `s2`, write a function that finds the **longest common subsequence** (LCS) of these two strings. A subsequence is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. Find the length of the LCS. Implement the function `int longestCommonSubsequence(String s1, String s2)` that returns the length of the LCS.","solution":"def longestCommonSubsequence(s1, s2): Returns the length of the longest common subsequence of s1 and s2. m = len(s1) n = len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given a **0-indexed** array of integers `arr` and a **target** integer `x`. You need to determine if there are any three distinct indices `i`, `j`, and `k` in the array such that the sum of the elements at these indices is equal to `x`. Return `true` if such a combination exists, otherwise return `false`.","solution":"def find_three_sum(arr, x): Determines if there are any three distinct indices i, j, and k in the array such that the sum of the elements at these indices is equal to x. n = len(arr) # Iterate through each element for i in range(n): # Use a set to track the seen values seen = set() # Iterate through the remaining elements starting from the next element of i for j in range(i + 1, n): required = x - arr[i] - arr[j] # Check if the required value exists in the seen set if required in seen: return True seen.add(arr[j]) return False"},{"question":"Given a **0-indexed** integer array `nums`, partition the array into two subarrays (possibly empty) such that their absolute differences are minimized. Return the _minimum possible absolute difference_ between the sum of the two subarrays.","solution":"def minimumDifference(nums): This function returns the minimum possible absolute difference between the sum of two subarrays partitioned from nums. total_sum = sum(nums) n = len(nums) dp = {0} for num in nums: new_dp = dp.copy() for t in dp: new_dp.add(t + num) dp = new_dp half_sum = total_sum / 2 min_diff = float(\'inf\') for s in dp: min_diff = min(min_diff, abs(total_sum - 2 * s)) return min_diff # Example usage # nums = [3,9,7,3] # minimumDifference(nums) should return 2"},{"question":"You need to design a data structure that supports adding new numbers and finding the median of all the numbers added so far. Implement the `MedianFinder` class: * `MedianFinder()` Initializes the MedianFinder object. * `void addNum(int num)` Adds the integer `num` to the data structure. * `double findMedian()` Returns the median of all elements so far. If the count of elements is even, the median is the average of the two middle elements, otherwise, it is the middle element itself.","solution":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder object. self.max_heap = [] # For the left half self.min_heap = [] # For the right half def addNum(self, num: int): Adds the integer num to the data structure. # Add to max_heap heapq.heappush(self.max_heap, -1 * num) # Balance the heaps if self.max_heap and self.min_heap and (-1 * self.max_heap[0]) > self.min_heap[0]: value = -1 * heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, value) if len(self.max_heap) > len(self.min_heap) + 1: value = -1 * heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, value) if len(self.min_heap) > len(self.max_heap): value = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -1 * value) def findMedian(self) -> float: Returns the median of all elements so far. if len(self.max_heap) > len(self.min_heap): return -1 * self.max_heap[0] return (-1 * self.max_heap[0] + self.min_heap[0]) / 2"},{"question":"You are given two integer arrays `members` and `projects` where `members[i]` is the number of members in the `i-th` project and `projects[i]` is the maximum number of projects the `i-th` member can handle. Each member can only be assigned to projects sequentially and not simultaneously. Your task is to assign each project to one or more members such that every project is completed while respecting the members\' project capacities. Return the minimum number of members required to complete all projects respecting the constraints.","solution":"def min_members_to_complete_projects(members, projects): # Sort the members capacities and project requirements members.sort() projects.sort() member_count = 0 i = 0 j = 0 while i < len(members) and j < len(projects): if members[i] >= projects[j]: j += 1 # This member takes the current project member_count += 1 i += 1 # If there are still projects left and no members, we can\'t fulfill the requirement. if j < len(projects): return -1 return member_count"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting of lowercase letters. You need to transform `s1` into `s2` using the minimum number of operations. In one operation, you can: 1. Select any character from `s1` and any character from `s2`. 2. Swap them if the selected character from `s1` is not already matched with the character at the same position in `s2`. Return the minimum number of operations required to transform `s1` into `s2`. Each character in `s1` and `s2` is guaranteed to appear exactly the same number of times.","solution":"def min_operations_to_transform(s1, s2): Returns the minimum number of operations required to transform s1 into s2. # Initialize the number of operations operations = 0 # List to store positions where s1 and s2 differ mismatch_positions = [] for i in range(len(s1)): if s1[i] != s2[i]: mismatch_positions.append(i) # Number of mismatches represents the number of operations needed operations = len(mismatch_positions) // 2 # Each swap fixes two positions return operations"},{"question":"You are given a string `s` consisting of only \'(\' and \')\'. A parenthesis string is considered **balanced** if for every opening parenthesis \'(\', there is a corresponding closing parenthesis \')\'. You are allowed to insert parentheses at any position in the string to make it balanced. Return the minimum number of insertions needed to make `s` a balanced string.","solution":"def minInsertions(s): Returns the minimum number of insertions needed to make the string balanced. left = 0 insertions_needed = 0 for char in s: if char == \'(\': left += 1 elif char == \')\': if left > 0: left -= 1 else: insertions_needed += 1 # After processing the string, any unmatched `(` will need to be closed insertions_needed += left return insertions_needed"},{"question":"You are given an array of integers and a target sum. Write a function to determine if there are three integers in the array whose sum is equal to the given target. If such a combination is found, return the triplet in the form of an array [num1, num2, num3]. If multiple triplets are found, return any one of them. If no such combinations exist, return an empty array.","solution":"def find_triplet_with_sum(nums, target): Finds a triplet in the array that sums up to the given target. :param nums: List of integers :param target: Target sum :return: List containing the triplet, or an empty list if no such triplet exists nums.sort() length = len(nums) for i in range(length-2): left, right = i+1, length-1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return [nums[i], nums[left], nums[right]] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"You are given a string `str` consisting of lowercase English letters. You have to make the string a palindrome by rearranging its characters. However, you are allowed to remove exactly one character from the string. Your task is to return whether it is possible to make the string a palindrome using the given operation. For example, if `str = \\"abccba\\"`: * Removing character `\'a\'` from the string results in `\\"bccba\\"`, which can be rearranged to form the palindrome `\\"bcbabc\\"`. * Removing character `\'b\'` from the string results in `\\"accba\\"`, which can be rearranged to form the palindrome `\\"abccba\\"`. Return `true` if you can rearrange the string into a palindrome after removing exactly one character, and `false` otherwise.","solution":"from collections import Counter def can_form_palindrome_after_one_removal(s): Check if it\'s possible to rearrange the string into a palindrome by removing exactly one character. def can_form_palindrome(s): odd_count = sum(1 for count in Counter(s).values() if count % 2 != 0) return odd_count <= 1 if len(s) <= 2: return True for i in range(len(s)): modified_string = s[:i] + s[i+1:] if can_form_palindrome(modified_string): return True return False"},{"question":"You have an array of integers `arr` and a target integer `x`. Your task is to modify the array such that the sum of its elements is equal to `x`. You can perform the following operation on the array any number of times: - Select any two adjacent elements and replace them with their sum. Determine if it is possible to modify the array to achieve the desired sum. Return `true` if it is possible to achieve the sum `x`, otherwise return `false`.","solution":"def can_achieve_sum(arr, x): Determines if it is possible to modify the array to achieve the sum x by repeatedly replacing any two adjacent elements with their sum. Parameters: arr (list of int): The array of integers. x (int): The target sum. Returns: bool: True if it is possible to modify the array to achieve the sum x, else False. return sum(arr) == x"},{"question":"You are given a list of strings `words` representing words in a text document. Create a class `WordFrequencyAnalyzer` that can analyze the frequency of words. Implement the following methods: * `WordFrequencyAnalyzer(List<String> words)` Initializes the `WordFrequencyAnalyzer` object with the given list of words. * `Map<String, Integer> getWordFrequencies()` Returns a map where the keys are words and the values are their corresponding frequencies. * `List<String> getTopKFrequentWords(int k)` Returns a list of the top `k` most frequently occurring words ordered by their frequency in descending order. If multiple words have the same frequency, they should be ordered by their appearance in the input list `words`. Ensure that the implementation efficiently handles a large number of words and multiple requests for the top `k` frequent words.","solution":"from collections import Counter from typing import List, Dict class WordFrequencyAnalyzer: def __init__(self, words: List[str]): self.words = words self.word_frequencies = Counter(words) def getWordFrequencies(self) -> Dict[str, int]: return dict(self.word_frequencies) def getTopKFrequentWords(self, k: int) -> List[str]: return [word for word, _ in self.word_frequencies.most_common(k)]"},{"question":"A conference is being organized, and the organizers need to schedule the talks such that attendees can maximize the number of talks they attend without any overlap. Each talk has a start time and an end time. Given a list `meetings` where `meetings[i] = [starti, endi]` indicates the start and end times of the `i-th` talk, determine the maximum number of non-overlapping talks one can attend. A talk `i` is considered non-overlapping with talk `j` if `endi` <= `startj` or `endj` <= `starti`. Implement a function `maxNonOverlappingMeetings(meetings)` that returns the maximum number of non-overlapping talks that can be attended.","solution":"def maxNonOverlappingMeetings(meetings): Given a list of meetings where each meeting is represented as a tuple (start, end), this function returns the maximum number of non-overlapping meetings one can attend. # Sort meetings by their end time meetings.sort(key=lambda x: x[1]) last_end_time = float(\'-inf\') count = 0 for meeting in meetings: start, end = meeting if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"You are given a 2D array `matrix` where each element is either `0` or `1`. Your task is to find the largest square (sub-matrix) containing only `1`s and return its area. The area of the square is defined as its side length squared. Write a function to determine this largest square area in the matrix.","solution":"def largest_square_area(matrix): Find the largest square containing only \'1\'s in a given 2D matrix and return its area. :param matrix: List[List[int]], 2D array with elements 0 or 1 :return: int, area of the largest square of 1\'s if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"Given a set of `n` unique integers, your task is to generate all possible subsets of these integers such that the elements within each subset are sorted in non-descending order. Return the list of all subsets sorted in non-descending order of their lengths, and each subset should be sorted lexicographically. For example, if the input set is `{1, 2, 3}`, the output should include the subsets `{}`, `{1}`, `{2}`, `{3}`, `{1, 2}`, `{1, 3}`, `{2, 3}`, and `{1, 2, 3}`. **Note:** - The subsets should be sorted first by their lengths and then lexicographically. - The empty set `{}` is considered as the subset of any set.","solution":"def generate_subsets(s): Generates all subsets of the given set of unique integers such that: - Elements within subsets are sorted in non-descending order. - Subsets are sorted in non-descending order of their lengths. - Subsets of the same length are sorted lexicographically. Args: s (set): A set of unique integers. Returns: List[List[int]]: A list of all possible subsets sorted according to the mentioned criteria. from itertools import combinations sorted_input = sorted(s) subsets = [] for r in range(len(sorted_input) + 1): for subset in combinations(sorted_input, r): subsets.append(list(subset)) return subsets"},{"question":"Given an undirected graph represented as an adjacency list, write a function that determines if the graph contains a cycle. A graph contains a cycle if there is a path of edges and vertices in which a vertex is reachable from itself.","solution":"def contains_cycle(graph): Determines if an undirected graph contains a cycle. Args: graph (dict): An adjacency list representing the graph. Returns: bool: True if the graph contains a cycle, False otherwise. visited = set() def dfs(v, parent): visited.add(v) for neighbor in graph.get(v, []): if neighbor not in visited: if dfs(neighbor, v): return True elif neighbor != parent: return True return False for vertex in graph: if vertex not in visited: if dfs(vertex, None): return True return False"},{"question":"Given an integer array `arr`, return _the length of the **shortest subarray** that, after sorting, makes the whole array `arr` sorted in non-decreasing order_. If the array is already non-decreasing, return `0`. For example, if the input array is `arr = [2, 6, 4, 8, 10, 9, 15]`, you can sort the subarray `[6, 4, 8, 10, 9]` to make the whole array sorted in non-decreasing order. Thus, the output should be `5`, as the length of this subarray is `5`.","solution":"def findUnsortedSubarray(arr): Given an integer array `arr`, this function returns the length of the shortest subarray that, after sorting, makes the whole array `arr` sorted in non-decreasing order. If the array is already non-decreasing, it returns `0`. n = len(arr) start, end = 0, -1 max_seen, min_seen = -float(\'inf\'), float(\'inf\') for i in range(n): if arr[i] < max_seen: end = i else: max_seen = arr[i] for i in range(n-1, -1, -1): if arr[i] > min_seen: start = i else: min_seen = arr[i] return end - start + 1"},{"question":"You are given an array of non-negative integers `arr` and an integer `sum`. Your task is to determine if there are three distinct elements in the array that add up to the given `sum`. Return `true` if such a triplet exists, and `false` otherwise. Example: Given the array `arr = [1, 4, 45, 6, 10, 8]` and `sum = 22`, the function should return `true` because the triplet (4, 10, 8) sums to 22.","solution":"def find_triplet(arr, target_sum): Determines if there are three distinct elements in the array `arr` that add up to the given `sum`. Parameters: arr : list of int : List of non-negative integers target_sum : int : Target sum Returns: bool : True if such a triplet exists, False otherwise arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target_sum: return True elif current_sum < target_sum: left += 1 else: right -= 1 return False"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of pillars in a row. You need to paint the pillars such that no two adjacent pillars have the same color. You are given an integer `k` representing the number of colors available. Return _the **minimum number of colors** required from the `k` available colors to paint all the pillars_, or `-1` if it is not possible to paint all the pillars under these conditions.","solution":"def min_colors_needed(heights, k): Returns the minimum number of colors required to paint all the pillars such that no two adjacent pillars have the same color. If it\'s not possible, returns -1. if k == 1: if len(heights) > 1: return -1 else: return 1 # With more than one color, we only need two colors for the alternating pattern return min(len(set(heights)), k)"},{"question":"You are given a binary tree where each node has exactly one or zero children. Each node is labeled either `0` or `1`. A \\"good path\\" in the binary tree is defined as a path from the root to a leaf node that never has two consecutive nodes labeled with the same value. Write a function that returns the number of good paths in the given binary tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_good_paths(root): Counts the number of good paths in a binary tree where no two consecutive nodes have the same value. def is_good_path(node, parent_value, count): if not node: return 0 current_count = count if node.value != parent_value: current_count += 1 if not node.left and not node.right: return 1 count_left = is_good_path(node.left, node.value, current_count) count_right = is_good_path(node.right, node.value, current_count) return count_left + count_right return 0 return is_good_path(root, -1, 0)"},{"question":"You are given a **0-indexed** integer array `arr` consisting of `n` elements. You need to rotate the array to the right by `k` steps, where `k` is a non-negative integer. A single right rotation means that the last element of the array moves to the first position, and every other element shifts one position to the right. **In-place** rotations are preferred, meaning you should try to achieve the result without using additional space for a new array. Return the **resultant array** after `k` rotations.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Args: arr: List[int] - The input array. k: int - The number of steps to rotate the array. Returns: List[int] - The rotated array. n = len(arr) k = k % n # In case k is larger than the length of the array arr[:] = arr[-k:] + arr[:-k] # Rotate in place return arr"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `n`. Your task is to shift each character in the string `s` by `n` positions forward in the alphabet, wrapping around to the beginning if necessary. For example, with `n = 2`, \'a\' becomes \'c\', \'y\' becomes \'a\', and so on. Return the resulting string after shifting all characters.","solution":"def shift_string(s, n): Shifts each character in the string s by n positions forward in the alphabet. Wraps around to the beginning of the alphabet if necessary. Parameters: s (str): Input string consisting of lowercase alphabets. n (int): Number of positions to shift each character. Returns: str: Resulting string after shifting characters. shifted_string = [] for char in s: shifted_char = chr((ord(char) - ord(\'a\') + n) % 26 + ord(\'a\')) shifted_string.append(shifted_char) return \'\'.join(shifted_string)"},{"question":"Given a binary string `s`, you can transform it by choosing a non-negative integer `d` (where 0 <= d < s.length) and toggling `s[d]` from \'0\' to \'1\' or from \'1\' to \'0\'. Your task is to determine the **minimum number of toggles** needed to make `s` an alternating binary string (i.e., no two adjacent characters are the same). Return the minimum number of toggles required. **Note**: - An alternating binary string either starts with \'0\' (e.g., \\"010101\\") or starts with \'1\' (e.g., \\"101010\\").","solution":"def min_toggles_to_alternating(s): Returns the minimum number of toggles required to make the binary string s an alternating binary string. n = len(s) # Count mismatches for pattern starting with \'0\' i.e., \\"010101...\\" count1 = sum(s[i] != \'0\' if i % 2 == 0 else s[i] != \'1\' for i in range(n)) # Count mismatches for pattern starting with \'1\' i.e., \\"101010...\\" count2 = sum(s[i] != \'1\' if i % 2 == 0 else s[i] != \'0\' for i in range(n)) # Minimum of the two counts is our answer return min(count1, count2)"},{"question":"You are given a list of integers representing the prices of different items in a store. You are also given a target sum `targetSum`. Write a function that determines whether you can select a subset of items from the list such that the sum of their prices is exactly equal to `targetSum`. Return `true` if such a subset exists, or `false` otherwise.","solution":"def can_sum_to_target(prices, targetSum): Determines if a subset of prices sums to targetSum. Parameters: prices (List[int]): The list of item prices. targetSum (int): The target sum to find in the subset. Returns: bool: True if a subset of prices sums to targetSum, else False. n = len(prices) dp = [False] * (targetSum + 1) dp[0] = True # Base case: There\'s always a subset with sum 0 (empty subset) for price in prices: for j in range(targetSum, price - 1, -1): dp[j] = dp[j] or dp[j - price] return dp[targetSum]"},{"question":"You are given a matrix `grid` representing a 2D grid where each cell contains a positive integer that denotes the cost of stepping into that cell. Suppose you are initially positioned at the top-left corner of the grid and you need to find a path to the bottom-right corner such that the sum of the costs along the path is minimized. You can only move either down or right at any point in time. Return _the minimum sum of the path from the top-left corner to the bottom-right corner_.","solution":"def min_path_sum(grid): Returns the minimum sum of the path from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"You are given an integer array `nums` of length `n` which is guaranteed to contain distinct integers. You need to perform the following operation exactly once: - Select any two indices `i` and `j` (0 ≤ `i`, `j` < `n` and `i` != `j`) and swap the elements at these indices. Return _the maximum possible value of the smallest element of the `nums` array after performing this operation_.","solution":"def max_min_after_swap(nums): Returns the maximum possible value of the smallest element of the nums array after performing exactly one swap. # Determine the two largest elements. max_first, max_second = float(\'-inf\'), float(\'-inf\') max_first_index, max_second_index = -1, -1 for i in range(len(nums)): if nums[i] > max_first: max_second = max_first max_second_index = max_first_index max_first = nums[i] max_first_index = i elif nums[i] > max_second: max_second = nums[i] max_second_index = i # Determine the two smallest elements. min_first, min_second = float(\'inf\'), float(\'inf\') min_first_index, min_second_index = -1, -1 for i in range(len(nums)): if nums[i] < min_first: min_second = min_first min_second_index = min_first_index min_first = nums[i] min_first_index = i elif nums[i] < min_second: min_second = nums[i] min_second_index = i # Check swapping the smallest with the largest swap_first = min(nums[min_first_index], max_first) # Check swapping the second smallest with the second largest swap_second = min(nums[min_second_index], max_second) # Return the better swap result return max(swap_first, swap_second)"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to determine if there exists a non-empty subsequence of `nums` such that the sum of its elements is equal to `target`. A subsequence is a sequence derived from the given list by deleting some or none of the elements without changing the order of the remaining elements. Return `true` if such a subsequence exists, otherwise return `false`.","solution":"def subsequence_sum_exists(nums, target): Determines if there exists a non-empty subsequence of nums such that the sum of its elements is equal to target. :param nums: List of integers :param target: Integer :return: Boolean indicating if such a subsequence exists n = len(nums) # Initialize a set to store the possible sums of any subsequences possible_sums = {0} for num in nums: # Create a new set containing the sums that can be made by including the current num new_sums = set() for sum_so_far in possible_sums: new_sum = sum_so_far + num new_sums.add(new_sum) if new_sum == target: return True # Update the possible sums with the new sums possible_sums.update(new_sums) # Check if the target sum is in the set of possible sums without counting the empty subsequence return target in possible_sums and target != 0"},{"question":"Given a `m x n` 2D grid that represents a maze where: - `0` represents a walkable path, - `1` represents a wall, and - `2` represents the start point, determine if there is a path from the start (`2`) to any `3` in the maze. You can move up, down, left, or right but not diagonally. Implement a method `boolean hasPath(int[][] maze)` which returns `true` if a path exists from any `2` to any `3`, otherwise returns `false`. If there is no start point or target, return `false`.","solution":"def hasPath(maze): Determines if there is a path from any \'2\' to any \'3\' in a given maze. :param maze: A 2D list representing the maze :return: True if a path exists, False otherwise if not maze or not maze[0]: return False rows, cols = len(maze), len(maze[0]) def find_start(): for r in range(rows): for c in range(cols): if maze[r][c] == 2: return (r, c) return None start = find_start() if not start: return False def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or maze[r][c] == 1: return False if maze[r][c] == 3: return True maze[r][c] = 1 # mark as visited # explore all four possible directions if dfs(r+1, c) or dfs(r-1, c) or dfs(r, c+1) or dfs(r, c-1): return True return False return dfs(start[0], start[1])"},{"question":"A social media platform wants to implement a friend recommendation system. Each user on the platform is represented by a unique ID from `0` to `n-1`. The friendship connections are described by an integer array `friends` where `friends[i]` contains a list of friends for user `i`. Two users are friends if they have at least one direct connection in the `friends` list. The platform wants to recommend new friends to each user based on the concept of mutual friends. A mutual friend between two users `u` and `v` is someone who is a direct friend of both `u` and `v`. The recommendation system should return a list of recommended friends for a given user `u` sorted by the number of mutual friends in descending order. If two recommended friends have the same number of mutual friends, the one with the smaller ID should come first. Implement the following class: * `class FriendRecommender`: Initializes the recommender system with the given friendship data. * `FriendRecommender(int n, List<List<Integer>> friends)`: Initializes the object with `n` users and their friendship connections. * `List<Integer> recommendFriends(int userId)`: Returns a list of recommended friends for the user `userId` sorted as described above. **Example:** Input: ```python n = 4 friends = [ [1, 2], [0, 2, 3], [0, 1, 3], [1, 2] ] userId = 0 ``` Output: ```python recommendFriends(0) -> [3] ```","solution":"class FriendRecommender: def __init__(self, n, friends): # Initialize the friend list for each user self.n = n self.friends = friends def recommendFriends(self, userId): # Get the current list of friends for userId user_friends = set(self.friends[userId]) mutual_counts = {} # Iterate through each friend of userId for friend in user_friends: # Get friends of the current friend friends_of_friend = self.friends[friend] for fof in friends_of_friend: # Ensure that who we consider as a recommendation is not already a friend or the user itself if fof != userId and fof not in user_friends: if fof not in mutual_counts: mutual_counts[fof] = 0 mutual_counts[fof] += 1 # Convert the mutual_counts dictionary into a sorted list of friend recommendations recommendations = sorted(mutual_counts.keys(), key=lambda x: (-mutual_counts[x], x)) return recommendations"},{"question":"Given an integer array `nums`, return the **third maximum** number in this array. If the third maximum does not exist, return the maximum number. The solution should have a linear runtime complexity.","solution":"def third_max(nums): Returns the third maximum number in the array. If the third maximum does not exist, returns the maximum number. max_nums = [float(\'-inf\'), float(\'-inf\'), float(\'-inf\')] for num in nums: if num not in max_nums: if num > max_nums[0]: max_nums = [num, max_nums[0], max_nums[1]] elif num > max_nums[1]: max_nums = [max_nums[0], num, max_nums[1]] elif num > max_nums[2]: max_nums = [max_nums[0], max_nums[1], num] return max_nums[2] if max_nums[2] != float(\'-inf\') else max_nums[0]"},{"question":"Given an array of integers `arr` and an integer `target`, determine if there exists a **subarray** (non-empty) whose sum equals `target`. Return `true` if such a subarray exists, otherwise return `false`.","solution":"def has_subarray_with_sum(arr, target): Determine if there exists a subarray (non-empty) whose sum equals target. Args: arr (list of int): List of integers. target (int): Target sum. Returns: bool: True if such a subarray exists, False otherwise. cumulative_sum = 0 cumulative_sum_set = set() for num in arr: cumulative_sum += num if cumulative_sum == target: return True if (cumulative_sum - target) in cumulative_sum_set: return True cumulative_sum_set.add(cumulative_sum) return False"},{"question":"Given a directed graph represented as an adjacency list, where each node has a unique integer value, write a function that returns the longest path that exists in the graph. The path should be represented as a list of node values in the order they are visited. If there are multiple longest paths, return any one of them. Note that the graph may contain cycles, so your solution must handle such cases appropriately. Your function should adhere to the following signature: ```python def longest_path(graph: Dict[int, List[int]]) -> List[int]: ``` Where `graph` is a dictionary with node values as keys and lists of node values as values, representing the directed edges. The function should traverse the graph to find the longest path and return it as a list of integers. **Example:** ```python graph = { 1: [2, 3], 2: [4], 3: [4], 4: [] } output = longest_path(graph) print(output) # Example output could be [1, 2, 4] or [1, 3, 4] ```","solution":"def longest_path(graph): def dfs(node, visited, path, longest): visited.add(node) path.append(node) if len(path) > len(longest[0]): longest[0] = list(path) for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor, visited, path, longest) path.pop() visited.remove(node) longest = [[]] for start in graph: visited = set() dfs(start, visited, [], longest) return longest[0]"},{"question":"You are given an integer array `arr` and an integer `k`. Implement the `WindowMax` class that maintains the maximum values of a sliding window of size `k` over the elements of `arr`. The class should support the following methods: - `WindowMax(int[] arr, int k)` Initializes the object with the integer array `arr` and window size `k`. - `int[] getMax()` Returns an array containing the maximum values of each sliding window of size `k` in the array `arr`. The `getMax()` method returns an array where each element corresponds to the maximum value of the respective sliding window of size `k` as it moves from the beginning to the end of `arr`. If `k` is greater than the length of `arr`, return an empty array.","solution":"from collections import deque class WindowMax: def __init__(self, arr, k): self.arr = arr self.k = k def getMax(self): if self.k > len(self.arr): return [] result = [] deq = deque() for i in range(len(self.arr)): # Ensure the deque\'s elements remain relevant within the window if deq and deq[0] == i - self.k: deq.popleft() # Maintain the decreasing order in deque for max value tracking while deq and self.arr[deq[-1]] < self.arr[i]: deq.pop() deq.append(i) # Append to result only when we have a complete window of size k if i >= self.k - 1: result.append(self.arr[deq[0]]) return result"},{"question":"You are given a **0-indexed** integer array `nums` and a **0-indexed** array of integer **ops** of length `m`, both of which describe `m` operations. The `ith` operation increments all elements of `nums` from index `0` to `ops[i]` (inclusive) by 1. Return _an array_ `result` _of length_ `n` _where_ `result[i]` _is the **final value** of the element at index_ `i` _in_ `nums` _after all the operations are performed._","solution":"def apply_operations(nums, ops): Increment elements of \'nums\' according to operations specified in \'ops\'. Args: nums : List[int] - List of integers to be incremented. ops : List[int] - List of indices specifying the range to increment. Returns: List[int] - Modified list after performing operations. for op in ops: for i in range(op + 1): nums[i] += 1 return nums"},{"question":"You are given a **positive** integer `n`, representing the number of elements in a sequence. You need to generate the sequence following these rules: 1. Start with `1`. 2. For each subsequent element, if the previous element is `1`, the next element should be `2`. Otherwise, if the previous element is even, the next element should be one-half of the previous element. If the previous element is odd and greater than `1`, the next element should be `3 * previous + 1`. Return a list of the first `n` elements in the sequence. For example: Input: `n = 10` Output: `[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]`","solution":"def generate_sequence(n): Generates a sequence of n elements where the next element is determined based on the current element. Args: n (int): The number of elements in the sequence. Returns: List[int]: The sequence of n elements. if n <= 0: return [] sequence = [1] for _ in range(1, n): prev = sequence[-1] if prev == 1: sequence.append(2) elif prev % 2 == 0: sequence.append(prev // 2) else: sequence.append(3 * prev + 1) return sequence"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to determine whether there exists a **subarray** of length `k` such that the sum of its elements is **strictly larger** than the sum of the elements of any other subarray of length `k`. Return `true` if such a subarray exists and `false` otherwise. A **subarray** is a contiguous part of an array.","solution":"def is_strictly_largest_sum_subarray(arr, k): Determines if there exists a subarray of length k whose sum is strictly larger than the sum of any other subarray of length k. Args: arr: List of integers. k: Integer, length of the subarray. Returns: bool: True if such a subarray exists, False otherwise n = len(arr) if k > n: return False max_sum = float(\'-inf\') max_sum_count = 0 current_sum = sum(arr[:k]) for i in range(n - k + 1): if i > 0: current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum > max_sum: max_sum = current_sum max_sum_count = 1 elif current_sum == max_sum: max_sum_count += 1 return max_sum_count == 1"},{"question":"Given a binary tree, implement a function `averageOfLevels` that returns the average value of the nodes on each level in the form of an array. Each element in the array corresponds to one level\'s average value, starting from the root level moving downwards. For example, given the following binary tree: ``` 3 / 9 20 / 15 7 ``` The function should return `[3.0, 14.5, 11.0]`. Write the `averageOfLevels` function to achieve this. You may assume that the binary tree is not empty and each node will have a non-negative value.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def averageOfLevels(root): if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum / level_length) return result"},{"question":"You are given an array `heights` representing the heights of columns standing next to each other. The width of each column is 1. Return the area of the largest rectangle that can be formed within the bounds of the histogram. Each column\'s height is the height of the histogram at that point.","solution":"def largest_rectangle_area(heights): Given an array heights representing the heights of columns, returns the area of the largest rectangle that can be formed within the bounds of the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar \'h\' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max area, if needed max_area = max(max_area, area) # Now pop the remaining bars from stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given an array of integers `arr` and an integer `m`, return _the length of the smallest contiguous subarray whose sum is greater than or equal to_ `m`. _If there isn\'t one, return_ `0`.","solution":"def min_subarray_len(arr, m): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to m. If there isn\'t one, return 0. n = len(arr) if n == 0: return 0 min_len = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= m: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != n + 1 else 0"},{"question":"You are given a binary tree with `n` nodes where each node contains an integer value. Implement a class `BinaryTree` with methods to perform the following operations: * `BinaryTree(int[] elements)` - Initializes the binary tree with the given integer elements. The elements array represents a level-order traversal of the tree. A value of `null` in the array indicates that the corresponding node is missing. * `void insert(int value)` - Inserts a new node with the given value into the binary tree while maintaining it as a proper binary tree. * `List<Integer> levelOrderTraversal()` - Returns the level order traversal of the binary tree as a list of integers. * `int findMaxDepth()` - Returns the maximum depth of the binary tree. The depth of the root node is 1. * `int sumOfLeafNodes()` - Returns the sum of all leaf nodes in the binary tree. A leaf node is a node with no children.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self, elements): if not elements: self.root = None return self.root = TreeNode(elements[0]) queue = [self.root] i = 1 while i < len(elements): current = queue.pop(0) if elements[i] is not None: current.left = TreeNode(elements[i]) queue.append(current.left) i += 1 if i < len(elements) and elements[i] is not None: current.right = TreeNode(elements[i]) queue.append(current.right) i += 1 def insert(self, value): if not self.root: self.root = TreeNode(value) return queue = [self.root] while queue: current = queue.pop(0) if not current.left: current.left = TreeNode(value) return else: queue.append(current.left) if not current.right: current.right = TreeNode(value) return else: queue.append(current.right) def levelOrderTraversal(self): if not self.root: return [] result = [] queue = [self.root] while queue: current = queue.pop(0) result.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result def findMaxDepth(self): def depth(node): if not node: return 0 return 1 + max(depth(node.left), depth(node.right)) return depth(self.root) def sumOfLeafNodes(self): if not self.root: return 0 sum_leaves = 0 queue = [self.root] while queue: current = queue.pop(0) if not current.left and not current.right: sum_leaves += current.value if current.left: queue.append(current.left) if current.right: queue.append(current.right) return sum_leaves"},{"question":"You are given an integer array `nums` and an integer `k`. You need to implement a method that finds and returns the length of the longest subarray whose sum equals `k`. If no such subarray exists, return 0. Implement the `Solution` class: * `Solution()` Initializes the class with any required parameters. * `int longestSubarraySumEqualsK(vector<int>& nums, int k)` This method takes an integer array `nums` and an integer `k`, and returns the length of the longest subarray whose sum equals `k`. If no such subarray exists, return 0.","solution":"class Solution: def longestSubarraySumEqualsK(self, nums, k): sum_map = {} current_sum = 0 max_length = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum == k: max_length = i + 1 if (current_sum - k) in sum_map: max_length = max(max_length, i - sum_map[current_sum - k]) if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"Given a string `s` containing only lowercase English letters, you need to find and return _the length of the longest substring with at most two different characters_. For example, given `s = \\"eceba\\"`, the substring is `\\"ece\\"` which has length 3. Another example, given `s = \\"ccaabbb\\"`, the substring is `\\"aabbb\\"` which has length 5.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two different characters. from collections import defaultdict n = len(s) if n < 3: return n left, right = 0, 0 hashmap = defaultdict() max_len = 2 while right < n: if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_index = min(hashmap.values()) del hashmap[s[del_index]] left = del_index + 1 max_len = max(max_len, right - left) return max_len"},{"question":"Given an integer array `arr` of length `n`, return the number of subarrays with an even sum. Since the answer may be very large, return it **modulo `10^9 + 7`**.","solution":"def count_even_sum_subarrays(arr): Returns the number of subarrays with an even sum in the given array `arr`. The result is modulo 10^9 + 7. MOD = 10**9 + 7 # Initialize counters for prefix sums current_prefix_sum = 0 count_even_prefix_sum = 1 # There\'s 1 even prefix sum at start (0) count_odd_prefix_sum = 0 result = 0 for num in arr: current_prefix_sum += num if current_prefix_sum % 2 == 0: result = (result + count_even_prefix_sum) % MOD count_even_prefix_sum += 1 else: result = (result + count_odd_prefix_sum) % MOD count_odd_prefix_sum += 1 return result"},{"question":"Given a 2D binary grid where `0` represents water and `1` represents land, you need to find the size of the largest island. You can change exactly one `0` to `1` to create a larger island that is connected 4-directionally (horizontal or vertical). An island is a maximal group of connected `1`s. Return the size of the largest possible island.","solution":"def largestIsland(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] island_id = 2 island_map = {} def dfs(r, c, island_id): stack = [(r, c)] island_size = 0 while stack: x, y = stack.pop() if 0 <= x < rows and 0 <= y < cols and grid[x][y] == 1: grid[x][y] = island_id island_size += 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: stack.append((nx, ny)) return island_size for r in range(rows): for c in range(cols): if grid[r][c] == 1: island_map[island_id] = dfs(r, c, island_id) island_id += 1 if not island_map: return 1 result = max(island_map.values()) for r in range(rows): for c in range(cols): if grid[r][c] == 0: seen = set() potential_size = 1 for dx, dy in directions: x, y = r + dx, c + dy if 0 <= x < rows and 0 <= y < cols and grid[x][y] > 1: if grid[x][y] not in seen: potential_size += island_map[grid[x][y]] seen.add(grid[x][y]) result = max(result, potential_size) return result"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped between buildings of different heights. Assuming the width of each bar is `1`, calculate how much water is trapped between the bars after raining. The list `heights` represents the height of each bar such that the `i-th` bar\'s height is `heights[i]`. Return the total units of rainwater trapped. For example, given `heights = [0,1,0,2,1,0,1,3,2,1,2,1]`, the output should be `6`.","solution":"def trap_rain_water(heights): Given a list of non-negative integers representing the height of buildings, calculates the amount of rainwater that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"You are given a list of `n` integers `arr` representing the heights of different buildings in a row, where the width of each building is `1`. Your task is to design a function that calculates the maximum area of a rectangle formed by any number of consecutive buildings, given that the rectangle\'s height is determined by the shortest building among the selected consecutive buildings. Return _the maximum rectangular area in the histogram_.","solution":"def largest_rectangle_area(heights): This function calculates the maximum rectangular area in a histogram. :param heights: List[int] heights of the buildings. :return: int, maximum rectangular area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given two strings `s1` and `s2`, and you are allowed to remove characters from both strings. Return _the length of the longest common subsequence (LCS) of `s1` and `s2` that can be obtained by deleting some characters from each string_.","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence (LCS) that can be obtained by deleting some characters from each string. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given a list of `n` strings `words`. Find the string with the maximum number of unique characters. If there are multiple such strings, return the one that appears first in the original list. Write a function that returns _the string with the highest number of unique characters_.","solution":"def string_with_max_unique_chars(words): Returns the string with the highest number of unique characters from the given list of words. If there are multiple such strings, return the one that appears first in the original list. # Initialize variables to keep track of the string with max unique characters and its count max_unique_chars = 0 result_string = \\"\\" for word in words: unique_chars_count = len(set(word)) if unique_chars_count > max_unique_chars: max_unique_chars = unique_chars_count result_string = word return result_string"},{"question":"**[Question 4]:** You are given an integer array `nums` and an integer `k`. Your task is to find the maximum number of unique integers in any subarray of length `k` of the `nums` array. Return _the maximum number of unique integers_ you can find. If the length of the array is less than `k`, return `-1`.","solution":"def max_unique_integers(nums, k): Finds the maximum number of unique integers in any subarray of length k. Parameters: - nums: List[int] - The list of integers. - k: int - The length of the subarray. Returns: - int - The maximum number of unique integers in any subarray of length k. if len(nums) < k: return -1 from collections import defaultdict current_window = defaultdict(int) max_unique = 0 for i in range(k): current_window[nums[i]] += 1 max_unique = len(current_window) for i in range(k, len(nums)): new_num = nums[i] old_num = nums[i - k] current_window[old_num] -= 1 if current_window[old_num] == 0: del current_window[old_num] current_window[new_num] += 1 max_unique = max(max_unique, len(current_window)) return max_unique"},{"question":"You are given an array representing the pre-order traversal of a binary search tree (BST). Your task is to construct the BST from this traversal and then return the in-order traversal of the constructed BST. Given an integer array `preorder` which is the pre-order traversal of a BST, implement the following: * `TreeNode constructBST(int[] preorder)`: This method constructs and returns the root of the BST constructed from the given pre-order traversal. * `List<Integer> inorderTraversal(TreeNode root)`: This method takes the root of a BST and returns a list of integers representing the in-order traversal of the tree. **Example:** ``` Input: preorder = [8, 5, 1, 7, 10, 12] Output: [1, 5, 7, 8, 10, 12] ``` In this example, the constructed BST would have the structure: ``` 8 / 5 10 / 1 7 12 ``` The in-order traversal of this tree is `[1, 5, 7, 8, 10, 12]`.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructBST(preorder: List[int]) -> Optional[TreeNode]: if not preorder: return None # Helper function to construct BST using bounds def construct(min_val, max_val): nonlocal idx if idx >= len(preorder) or not (min_val < preorder[idx] < max_val): return None root_val = preorder[idx] root = TreeNode(root_val) idx += 1 root.left = construct(min_val, root_val) root.right = construct(root_val, max_val) return root idx = 0 return construct(float(\'-inf\'), float(\'inf\')) def inorderTraversal(root: Optional[TreeNode]) -> List[int]: inorder = [] if root is None: return inorder stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() inorder.append(current.val) current = current.right return inorder"},{"question":"Given a string `s`, determine if it is a valid palindrome considering only alphanumeric characters and ignoring cases. For example, \\"A man, a plan, a canal: Panama\\" is a valid palindrome, while \\"race a car\\" is not. Write a function that returns `true` if `s` is a valid palindrome, and `false` otherwise. Implement your solution with a time complexity of `O(n)`, where `n` is the length of the string.","solution":"def is_palindrome(s): Returns true if the given string s is a valid palindrome, false otherwise. A valid palindrome considers only alphanumeric characters and ignores cases. # Filter only alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Compare the filtered list to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"You are given a list of `n` integers, `arr`, and a positive integer `k`. Your task is to find the `k` largest elements in the list and return them in ascending order. Note that the elements should be unique, and if there are fewer than `k` unique elements in the list, return all the unique elements sorted in ascending order. Write a function `find_k_largest_elements(arr, k)` that takes the list of integers `arr` and the integer `k` as inputs and returns a list of the `k` largest unique elements in ascending order.","solution":"def find_k_largest_elements(arr, k): Returns the k largest unique elements in ascending order. If there are fewer than k unique elements, return all unique elements sorted in ascending order. Parameters: arr (list): List of integers. k (int): Number of largest elements to retrieve. Returns: list: k largest unique elements in ascending order. unique_elements = list(set(arr)) unique_elements.sort(reverse=True) k_largest_elements = unique_elements[:k] k_largest_elements.sort() return k_largest_elements"},{"question":"You are given an integer array `nums` and an integer `target`. Implement a function `twoSum` that finds two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] == target`. Return the pair of indices `[i, j]`. If there are multiple solutions, you may return any of them. You may assume that each input would have exactly one solution. Use an efficient algorithm to achieve this in linear time.","solution":"def twoSum(nums, target): Returns indices of the two numbers such that they add up to target. :param nums: List[int], the input array :param target: int, the target sum :return: List[int], list of two indices num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"Design a function that takes a 2D integer grid representing a map of land (`1`) and water (`0`), and returns the size of the largest island. An island is a group of `1`s connected vertically or horizontally. You may assume all four edges of the grid are surrounded by water.","solution":"def max_area_of_island(grid): Returns the size of the largest island in the given 2D grid. An island is formed by group of `1`s connected vertically or horizontally. if not grid or not grid[0]: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # mark as visited area = 1 area += dfs(i+1, j) area += dfs(i-1, j) area += dfs(i, j+1) area += dfs(i, j-1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"Implement a class `CircularQueue` which provides the functionality of a fixed-size circular queue for integers. You must implement the following methods: * `CircularQueue(int k)` Initializes the queue with a maximum size of `k`. * `boolean enQueue(int value)` Adds an integer `value` to the circular queue. Return `true` if the operation is successful, otherwise `false`. * `boolean deQueue()` Deletes an integer from the circular queue. Return `true` if the operation is successful, otherwise `false`. * `int Front()` Retrieves the front item from the queue. Return `-1` if the queue is empty. * `int Rear()` Retrieves the last item from the queue. Return `-1` if the queue is empty. * `boolean isEmpty()` Checks whether the queue is empty. Return `true` if the queue is empty, otherwise `false`. * `boolean isFull()` Checks whether the queue is full. Return `true` if the queue is full, otherwise `false`. The operations should work in O(1) time complexity.","solution":"class CircularQueue: def __init__(self, k: int): self.size = k self.queue = [0] * k self.front = -1 self.rear = -1 def enQueue(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = 0 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value return True def deQueue(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = -1 self.rear = -1 else: self.front = (self.front + 1) % self.size return True def Front(self) -> int: if self.isEmpty(): return -1 return self.queue[self.front] def Rear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.rear] def isEmpty(self) -> bool: return self.front == -1 def isFull(self) -> bool: return (self.rear + 1) % self.size == self.front"},{"question":"Write a function that receives an array of integers `heights`, where `heights[i]` represents the height of a plant. Each day, any plant taller than the plant to its left dies. Given the array `heights`, return the number of days after which no plants die. In other words, return the number of iterations required until no plants in the array die anymore. Example: Input: `[6, 5, 8, 4, 7, 10, 9]` Output: `2`","solution":"def count_days_until_no_deaths(heights): Returns the number of days after which no plants die. Each day, any plant taller than the plant to its left dies. :param heights: List[int] - list of plant heights :return: int - number of days until no plants die days = 0 while True: deaths_today = [] for i in range(1, len(heights)): if heights[i] > heights[i - 1]: deaths_today.append(i) if not deaths_today: # No more plants die break for index in reversed(deaths_today): # Remove from end to avoid affecting subsequent indices heights.pop(index) days += 1 return days"},{"question":"You are given an integer array `nums` and two integers `x` and `y`. A subarray is valid if its minimum value is at least `x` and its maximum value is at most `y`. Return the total number of valid subarrays in `nums`.","solution":"def count_valid_subarrays(nums, x, y): Returns the total number of valid subarrays in nums. A subarray is valid if its minimum value is at least x and its maximum value is at most y. n = len(nums) valid_count = 0 for start in range(n): min_val = float(\'inf\') max_val = float(\'-inf\') for end in range(start, n): min_val = min(min_val, nums[end]) max_val = max(max_val, nums[end]) if min_val >= x and max_val <= y: valid_count += 1 # This subarray is valid return valid_count"},{"question":"Given a `0-indexed` integer array `nums`, you need to determine if it is possible to rearrange the elements of `nums` into a strictly increasing sequence by reversing at most one subarray from `nums`. Return `true` if it is possible, otherwise return `false`. A strictly increasing sequence means that for any two consecutive elements `nums[i]` and `nums[i+1]`, `nums[i] < nums[i+1]`.","solution":"def can_be_increasing_or_one_reverse(nums): Determine if it is possible to rearrange the elements of `nums` into a strictly increasing sequence by reversing at most one subarray from `nums`. Args: - nums (list): A list of integers. Returns: - bool: True if it is possible to rearrange and get strictly increasing order, otherwise False. for i in range(len(nums) - 1): if nums[i] >= nums[i + 1]: # Find the subarray to reverse j = i while j < len(nums) - 1 and nums[j] >= nums[j + 1]: j += 1 # Reverse the subarray reversed_subarray = nums[i:j + 1][::-1] new_nums = nums[:i] + reversed_subarray + nums[j + 1:] return new_nums == sorted(new_nums) and len(set(new_nums)) == len(new_nums) return True"},{"question":"You are given a string `text` containing a mix of uppercase and lowercase English letters. Your task is to rearrange the letters in such a way that no two adjacent characters are the same, while maintaining the relative order of their initial occurrence as much as possible. If it is not possible to rearrange `text` to satisfy the condition, return an empty string `\\"\\"`. If there are multiple possible rearrangements, return any one of them. For example, given `text = \\"aab\\"`, one possible rearrangement is `\\"aba\\"`. Given `text = \\"aaabbc\\"`, one possible rearrangement is `\\"abacab\\"`. Write a function that rearranges the letters according to the described rules.","solution":"from heapq import heappop, heappush from collections import Counter, deque def rearrange_string(text): Rearranges the letters in the text so that no two adjacent characters are the same. If it\'s not possible, return an empty string. if not text: return \\"\\" # Count frequency of each character freq = Counter(text) # Create a max heap from frequency counts max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) prev_count, prev_char = 0, \\"\\" result = [] while max_heap: count, char = heappop(max_heap) result.append(char) # If there was a previously used character that was put on hold, push it back now if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) # Prepare this character for next round with reduced count prev_count, prev_char = count + 1, char result = \'\'.join(result) # If the result string\'s length is not equal to the original string\'s length, it\'s impossible return result if len(result) == len(text) else \\"\\""},{"question":"You are given a **0-indexed** array `blocks` where `blocks[i]` represents the number of blocks present at the `i-th` position. You are also given an integer `m` which represents a bag that can carry a maximum of `m` blocks. The array `blocks` needs to be split into **one or more** contiguous subarrays such that the sum of the blocks in each subarray is less than or equal to `m`. Return _the minimum number of such subarrays required_.","solution":"def min_subarrays(blocks, m): Returns the minimum number of subarrays required such that the sum of each subarray is less than or equal to m. Parameters: blocks (list of int): The array representing the blocks at each position. m (int): The maximum number of blocks that the bag can carry. Returns: int: The minimum number of subarrays required. n = len(blocks) if not blocks: return 0 num_subarrays = 0 current_sum = 0 for block in blocks: if current_sum + block > m: num_subarrays += 1 current_sum = block else: current_sum += block if current_sum > 0: num_subarrays += 1 return num_subarrays"},{"question":"Given a singly-linked list `head` and an integer `k`, remove the `k-th` node from the end of the list and return the head of the modified list. Note that the linked list is 1-indexed, meaning the last node is the 1st node from the end.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head, k): Removes the k-th node from the end of the list and returns the head of the modified list. :param ListNode head: The head of the singly-linked list. :param int k: The 1-indexed position from the end to remove. :return: The head of the modified list. :rtype: ListNode dummy = ListNode(0) dummy.next = head first = second = dummy # Move first k+1 steps ahead for _ in range(k+1): first = first.next # Move both first and second pointers till first reaches the end while first: first = first.next second = second.next # Remove the k-th node from the end second.next = second.next.next return dummy.next"},{"question":"Given an unsorted integer array `nums` and an integer `target`, return _the number of unique pairs in the array that sum up to exactly the `target`_. Two pairs `(a, b)` and `(c, d)` are considered unique if and only if the sorted pairs `(min(a, b), max(a, b))` and `(min(c, d), max(c, d))` are different. You may assume that each input would have exactly one solution.","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs in the array that sum up to exactly `target`. nums_seen = set() pairs_seen = set() count = 0 for num in nums: complement = target - num if complement in nums_seen: pair = tuple(sorted((num, complement))) if pair not in pairs_seen: pairs_seen.add(pair) count += 1 nums_seen.add(num) return count"},{"question":"Given an array of integers `nums`, write a function that returns the length of the longest contiguous subarray with all elements equal. You need to implement an efficient algorithm that runs in O(n) time complexity.","solution":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray with all elements equal. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"You are given a string `s`, and your task is to determine if it is possible to partition the string into one or more substrings such that every substring is a palindrome. Return `True` if such a partitioning is possible, otherwise return `False`. For example, given the string `s = \\"aab\\"`, the output should be `True` since `s` can be partitioned into `[\\"aa\\", \\"b\\"]`, where both substrings are palindromes.","solution":"def is_palindrome(s: str) -> bool: Helper function to determine if a given string is a palindrome. return s == s[::-1] def can_partition_palindromes(s: str) -> bool: Determines if it is possible to partition the string `s` into one or more substrings each of which is a palindrome. n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and is_palindrome(s[j:i]): dp[i] = True break return dp[n]"},{"question":"You are given a string `log`, representing a sequence of log entries where each log entry is a line consisting of a **timestamp** and a **message**. Each log entry is formatted as `\\"YYYY-MM-DD HH:MM:SS message\\"`. Your task is to identify and return the **earliest** log entry based on the timestamp. If the log is empty, return an empty string `\\"\\"`. Write a function that parses the log and determines the earliest entry.","solution":"def earliest_log_entry(log): Returns the earliest log entry based on the timestamp from the given log string. log: string representing a sequence of log entries, each entry is formatted as \\"YYYY-MM-DD HH:MM:SS message\\" If the log is empty, returns an empty string. if not log.strip(): return \\"\\" entries = log.strip().split(\'n\') earliest_entry = entries[0] earliest_time = earliest_entry[:19] for entry in entries[1:]: current_time = entry[:19] if current_time < earliest_time: earliest_entry = entry earliest_time = current_time return earliest_entry"},{"question":"You are given two **binary trees** represented by root nodes `root1` and `root2`. Merge the two binary trees into a new binary tree. The merge rule is that if two nodes overlap, their values are added together, and the result becomes the value of the new node. Otherwise, the non-null node will be used as the node of the new tree. Return _the **root** of the new merged tree_. **Note**: * Binary trees are represented using level order traversal. * If both nodes are null, the result will be null.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(root1, root2): Merges two binary trees into a new binary tree. If two nodes overlap, their values are added together. Parameters: - root1 (TreeNode): The root of the first tree. - root2 (TreeNode): The root of the second tree. Returns: - TreeNode: The root of the new merged tree. if root1 is None and root2 is None: return None elif root1 is None: return root2 elif root2 is None: return root1 merged = TreeNode(root1.val + root2.val) merged.left = merge_trees(root1.left, root2.left) merged.right = merge_trees(root1.right, root2.right) return merged"},{"question":"Given a non-empty array `nums` containing **only positive integers**, find if the array can be partitioned into two subsets such that the **sum of elements** in both subsets is equal. Return **true** if you can partition the array into two subsets with equal sum, otherwise return **false**.","solution":"def canPartition(nums): Returns true if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. total_sum = sum(nums) # If total_sum is odd, it\'s not possible to split into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) dp = [False] * (target_sum + 1) dp[0] = True for num in nums: for j in range(target_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target_sum]"},{"question":"Given an array of integers `nums`, you are allowed to apply one of the following two operations any number of times: 1. Pick an index `i` and increment `nums[i]` by 1. 2. Pick two indices `i` and `j` (i ≠ j) and make `nums[i]` equal to `nums[j]`. Return _the minimum number of operations needed_ to make all elements in the array `nums` equal.","solution":"def min_operations_to_make_equal(nums): from collections import Counter # Step 1: Count frequency of each number frequency = Counter(nums) # Step 2: Find the maximum frequency max_freq = max(frequency.values()) # Step 3: Operations required to make all elements equal return len(nums) - max_freq"},{"question":"You are given a `2D` matrix of integers `mat` of size `m x n` and an integer `target`. Your goal is to find a submatrix (i.e., a matrix formed from some of the rows and columns of the original matrix) such that the sum of all elements in the submatrix is equal to `target`. Return _the number of such submatrices_.","solution":"def num_submatrix_sum_target(mat, target): Finds and returns the number of submatrices that sum to the target value. Parameters: mat (List[List[int]]): 2D list of integers representing the matrix target (int): the target sum Returns: int: the number of submatrices with the sum equal to the target from collections import defaultdict m, n = len(mat), len(mat[0]) result = 0 # Calculate the prefix sums for the matrix prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): prefix_sum[i + 1][j + 1] = mat[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] # Iterate over all submatrices for i1 in range(m): for i2 in range(i1, m): sum_counts = defaultdict(int) sum_counts[0] = 1 for j in range(n): matrix_sum = prefix_sum[i2 + 1][j + 1] - prefix_sum[i1][j + 1] if (matrix_sum - target) in sum_counts: result += sum_counts[matrix_sum - target] sum_counts[matrix_sum] += 1 return result"},{"question":"You are given a list of non-negative integers, `nums`, representing landmarks on a one-dimensional plane. A person starts at `0` and can travel to any landmark in `nums`. The person wants to visit exactly two landmarks such that the total distance travelled is minimized and returns to 0. Implement a function `minDistance(nums)` that returns the minimum distance the person needs to travel to visit exactly two landmarks and return to 0. For example, if `nums` is `[2, 4, 5, 9]`, the function should calculate the optimal route and return `11`, which corresponds to visiting the landmarks at `2` and `4` and then returning to 0 (distance 2 + 2 + 4 + 4 = 11).","solution":"def minDistance(nums): Returns the minimum distance the person needs to travel to visit exactly two landmarks and return to 0. # Sort the list of landmarks nums.sort() # Initialize the minimum distance to a large number min_distance = float(\'inf\') # Iterate through combinations of two different landmarks n = len(nums) for i in range(n): for j in range(i+1, n): distance = nums[i] + nums[i] + nums[j] + nums[j] # 2 * nums[i] + 2 * nums[j] if distance < min_distance: min_distance = distance return min_distance"},{"question":"A shopkeeper sells fruit that is delivered in boxes, and each box has its price. Given an integer array `prices` where `prices[i]` is the price of the `ith` box, the shopkeeper would like to find the minimum price he should sell to maximize his profit while adhering to the following rule: if he chooses to increase the price of a box `k` by `x`, he must reduce the price of the box `k+1` by the same amount `x`, such that the adjusted prices of the boxes maintain the original sum of prices. Return the minimum possible selling price that achieves this. For instance: If `prices = [4, 2, 6]`, the minimum possible selling price after increasing and decreasing prices appropriately could be computed in a way to maximize profit while maintaining the sum of prices.","solution":"def min_possible_price(prices): Returns the minimum price he should sell to maximize his profit while maintaining the total sum of prices by increasing and decreasing prices of consecutive boxes respectively. sum_prices = sum(prices) n = len(prices) if n == 0: return 0 min_price = float(\'inf\') # Let\'s assume the price of the ith box to find the minimum possible price across all boxes for price in prices: min_price = min(min_price, price) # This min_price ensures that no box is priced lower than this return min_price"},{"question":"You are given a **non-empty** 2D grid of integers representing a **map** where `1` represents land and `0` represents water. The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). An island is a maximal 4-directionally (horizontal or vertical) connected group of `1`s. Calculate the perimeter of this island. Implement a function: ```python def islandPerimeter(grid: List[List[int]]) -> int: ``` The function takes in a list of lists of integers representing the grid, and returns an integer representing the perimeter of the island.","solution":"def islandPerimeter(grid): Calculate the perimeter of the island in the grid. :param grid: List[List[int]], 2D list of integers representing the map :return: int, the perimeter of the island rows = len(grid) cols = len(grid[0]) perimeter = 0 def is_water(i, j): if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == 0: return True return False for i in range(rows): for j in range(cols): if grid[i][j] == 1: if is_water(i - 1, j): # Check upward perimeter += 1 if is_water(i + 1, j): # Check downward perimeter += 1 if is_water(i, j - 1): # Check left perimeter += 1 if is_water(i, j + 1): # Check right perimeter += 1 return perimeter"},{"question":"Given an array of strings `words`, a word `word`, and an integer `k`, return all possible substrings of `word` that are also present as whole elements in `words` and have a minimum length of `k`. The substrings in the output list should be sorted by their order of appearance in `word`. If no such substrings exist, return an empty list.","solution":"def find_substrings_in_words(words, word, k): Returns all substrings of `word` that are present as whole elements in `words` and have a minimum length of `k`. Parameters: words (list): A list of strings. word (str): The word to find substrings in. k (int): The minimum length of substrings. Returns: list: Sorted list of substrings found in `words`. result = [] len_word = len(word) word_set = set(words) for start in range(len_word): for end in range(start + k, len_word + 1): substring = word[start:end] if substring in word_set: result.append(substring) return result"},{"question":"You are given an array of integers `nums` and an integer `s`. You can perform the following operation any number of times: choose an index `i` and replace `nums[i]` with the sum `nums[i] + nums[j]` for any `j` where `0 <= j < nums.length` and `j != i`. Your goal is to maximize the minimum number in the array. Return the maximum possible value of the minimum number after performing any number of operations.","solution":"def maximize_min_num(nums: list, s: int) -> int: Returns the maximum possible value of the minimum number after performing the operation any number of times. total_sum = sum(nums) n = len(nums) return total_sum // n"},{"question":"You are given a linked list where each node contains a single digit. The digits are stored in reverse order, and each of their nodes contains a single digit. Add two such numbers represented as linked lists and return the sum as a linked list. The linked list node is defined as: ``` struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; ``` Write a function that takes two linked lists representing the numbers and returns the sum as a linked list in the same reverse order format.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def addTwoNumbers(l1, l2): Adds two numbers represented by linked lists in reverse order and returns the sum as a linked list. dummy = ListNode(0) current = dummy carry = 0 while l1 is not None or l2 is not None: x = l1.val if l1 is not None else 0 y = l2.val if l2 is not None else 0 total = carry + x + y carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next if carry > 0: current.next = ListNode(carry) return dummy.next"},{"question":"You are given an array of integers `arr` and an integer `k`. Write a function to determine whether there are two distinct indices `i` and `j` in the array such that `arr[i]` and `arr[j]` are both divisible by `k` and the absolute difference between `i` and `j` is at most `d`. Return `true` if such indices exist, and `false` otherwise.","solution":"def check_pair(arr, k, d): Determines if there are two distinct indices i and j in the array such that: - arr[i] and arr[j] are both divisible by k - The absolute difference between i and j is at most d divisible_indices = [i for i in range(len(arr)) if arr[i] % k == 0] for i in range(len(divisible_indices)): for j in range(i + 1, len(divisible_indices)): if abs(divisible_indices[i] - divisible_indices[j]) <= d: return True return False"},{"question":"Given an array of integers `nums` and an integer `target`, find pairs of integers in the array such that their sum is equal to `target`. Return a list of these pairs, with each pair represented as a tuple `(num1, num2)`. The pairs should be returned in any order and should not include duplicate pairs (i.e., if `(num1, num2)` is included, `(num2, num1)` should not be). If no such pairs exist, return an empty list.","solution":"def find_pairs(nums, target): Finds pairs of integers in the array such that their sum is equal to target. Parameters: nums (list of int): The array of integers. target (int): The target sum. Returns: list of tuple: A list of pairs (tuples) that sum up to the target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return list(pairs)"},{"question":"You are given a string `s` that consists of lowercase English letters. You can apply the following operation any number of times to transform the string: choose any two **consecutive** characters that are different and swap their positions. Your goal is to determine the lexicographically smallest string that can be obtained after performing the operations. Return _the lexicographically smallest string that can be achieved_.","solution":"def find_lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by repeatedly performing the allowed operations. return \'\'.join(sorted(s))"},{"question":"You are given an integer array `nums` and an integer `target`. You need to find two distinct indices `i` and `j` in the array such that `nums[i] + nums[j]` equals `target`. Return the indices `i` and `j` as a list `[i, j]`. If such indices do not exist, return an empty list. The solution should have a linear time complexity.","solution":"def two_sum(nums, target): Find two distinct indices such that nums[i] + nums[j] equals target. :param nums: List[int], list of integers :param target: int, target sum :return: List[int], indices of the two numbers such that they add up to target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"A collage artist is working on a project involving snippets of text. Given a string `s` and a word dictionary `wordDict`, return _whether `s` can be segmented into a space-separated sequence of one or more dictionary words_. Note that the same word in the dictionary may be reused multiple times in the segmentation. For example, given `s = \\"applepenapple\\"` and `wordDict = [\\"apple\\", \\"pen\\"]`, the output should be `true` because `s` can be segmented as \\"apple pen apple\\".","solution":"def word_break(s, wordDict): Returns whether the string \'s\' can be segmented into a space-separated sequence of one or more dictionary words. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # Empty substring can be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"You are given an integer array `arr` of length `n` representing the heights of skyscrapers in a city. The right side of each skyscraper can be seen if there are no taller skyscrapers to its right. Return an array representing the indices of the skyscrapers that have an unobstructed view to the right. The indices should be listed in ascending order.","solution":"def unobstructed_skyscrapers(arr): Returns an array representing the indices of the skyscrapers that have an unobstructed view to the right. n = len(arr) if n == 0: return [] result = [] max_height = -1 for i in range(n-1, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] result.reverse() return result"},{"question":"You are given a string `s` consisting of lowercase English letters. You can remove any number of characters from the string such that every letter appears an even number of times. Return _the minimum number of characters you need to remove to achieve this condition_.","solution":"def min_removals_to_even_frequency(s: str) -> int: Returns the minimum number of characters needed to be removed to ensure all letters appear an even number of times. from collections import Counter # Count the frequency of each character freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # Removing one character from each letter with an odd frequency will make all frequencies even return odd_count"},{"question":"A **valid palindrome** is a string that can be read the same way forward and backward by removing at most one character. Given a string `s`, return _true_ if `s` can be made into a **valid palindrome** by removing at most one character, and _false_ otherwise.","solution":"def valid_palindrome(s): Returns true if the input string can be made into a valid palindrome by removing at most one character. def is_palindrome(left, right, s): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try skipping either the left or the right character return is_palindrome(left + 1, right, s) or is_palindrome(left, right - 1, s) left += 1 right -= 1 return True"},{"question":": Given a string `s` consisting of lowercase English letters, return _the length of the shortest string that can be obtained by removing all occurrences of one character_. If the string contains only one unique character, return 0. For example, given the string \\"abac\\", the shortest string that can be obtained is \\"bc\\" with length 2, by removing all occurrences of \'a\'.","solution":"def length_of_shortest_string_after_removal(s): This function calculates the length of the shortest string that can be obtained by removing all occurrences of one character. If the string contains only one unique character, it returns 0. import collections counter = collections.Counter(s) # If there\'s only one unique character, the resulting length is 0 if len(counter) == 1: return 0 # Calculate the minimum string length after removing each unique character min_length = len(s) for char in counter: char_length = len(s) - counter[char] min_length = min(min_length, char_length) return min_length"},{"question":"You are given a `0-indexed` integer array `tasks` where `tasks[i]` represents the time taken to complete the `i-th` task. There are two workers available to complete these tasks. You want to assign tasks to the workers in such a way that the maximum time taken by either worker to complete their assigned tasks is minimized. Return _the minimum possible maximum time taken by either worker_ to complete all tasks. For example, if `tasks = [1, 3, 5, 2, 4, 6]`, one possible assignment is worker 1: [1, 5, 4] and worker 2: [3, 2, 6], which results in a maximum time of `11` for either worker. Complete the function `minimizedMaxTaskTime(tasks: List[int]) -> int` to determine the minimum possible maximum time for any task assignment.","solution":"from typing import List def canCompleteTasks(tasks: List[int], max_time: int, num_workers: int) -> bool: current_worker_time = 0 workers_used = 1 for task in tasks: if current_worker_time + task <= max_time: current_worker_time += task else: workers_used += 1 if workers_used > num_workers: return False current_worker_time = task if task > max_time: return False return True def minimizedMaxTaskTime(tasks: List[int]) -> int: # Sort the tasks to consider the heaviest tasks first for optimal distribution tasks.sort(reverse=True) left, right = max(tasks), sum(tasks) # Binary search boundaries while left < right: mid = (left + right) // 2 if canCompleteTasks(tasks, mid, 2): right = mid else: left = mid + 1 return left"},{"question":"A company has a fleet of trucks, and each truck has a maximum carrying capacity defined by an integer array `capacities` where `capacities[i]` is the capacity of the `i-th` truck. They need to transport a set of packages from a warehouse, and the weight of each package is given by an integer array `packages` where `packages[j]` is the weight of the `j-th` package. A truck can carry multiple packages as long as their total weight does not exceed the truck\'s capacity. Write an algorithm to find the minimum number of trucks needed to transport all the packages. If it is not possible to transport all the packages using the available trucks, return -1.","solution":"def min_trucks_needed(capacities, packages): Finds the minimum number of trucks needed to transport all packages. If it is not possible to transport all the packages with the available trucks, returns -1. :param capacities: List of integers representing the capacities of the trucks. :param packages: List of integers representing the weights of the packages. :return: Minimum number of trucks needed, or -1 if not possible. capacities.sort(reverse=True) packages.sort(reverse=True) truck_count = 0 package_index = 0 used_capacity = [0] * len(capacities) while package_index < len(packages): placed = False for i in range(len(capacities)): if used_capacity[i] + packages[package_index] <= capacities[i]: used_capacity[i] += packages[package_index] placed = True break if not placed: return -1 truck_count = max(truck_count, i + 1) package_index += 1 return truck_count"},{"question":"You are given a matrix `mat` of size `m x n` consisting of non-negative integers, where `mat[i][j]` represents the height of the terrain at cell `(i, j)`. You are also given an integer `water_level`. The water can only flow to neighboring cells directly connected in all 4 diagonal directions (up-left, up-right, down-left, down-right). Starting from any cell in the matrix, return the number of cells that will be flooded by the water if the `water_level` is raised to the specified height. A cell `(i, j)` is considered flooded if `mat[i][j] <= water_level`.","solution":"def count_flooded_cells(mat, water_level): Returns the number of cells that will be flooded by water if the water level is raised to the specified height. Parameters: mat (list of list of int): A 2D matrix representing the height of the terrain. water_level (int): The height to which the water level is raised. Returns: int: Number of cells that will be flooded. m = len(mat) n = len(mat[0]) if m > 0 else 0 flooded_count = 0 for i in range(m): for j in range(n): if mat[i][j] <= water_level: flooded_count += 1 return flooded_count"},{"question":"You are given a string `s` consisting only of characters `\'a\'`, `\'b\'`, and `\'c\'`. You want to partition the string into as many pieces as possible such that each piece is a substring consisting of exactly three characters `\'a\'`, `\'b\'`, and `\'c\'`. A substring is defined as a contiguous sequence of characters within the string. Return the maximum number of such substrings you can obtain.","solution":"def max_substrings(s): Returns the maximum number of substrings consisting of exactly one \'a\', one \'b\', and one \'c\'. count_a = count_b = count_c = 0 substrings_count = 0 for char in s: if char == \'a\': count_a += 1 elif char == \'b\': count_b += 1 elif char == \'c\': count_c += 1 # If we have at least one of each character, we can form a substring if count_a > 0 and count_b > 0 and count_c > 0: substrings_count += 1 count_a -= 1 count_b -= 1 count_c -= 1 return substrings_count"},{"question":"Given a list of non-negative integers, `nums`, representing the amount of water trapped between non-negative bars. Each element in the list represents the height of the bar. Your task is to return the total amount of water trapped. Example: - Input: `nums = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` - Output: `6`","solution":"def trap_water(nums): Given a list of non-negative integers, nums, representing the height of bars, return the total amount of water trapped between these bars. if not nums or len(nums) < 3: return 0 n = len(nums) left_max = [0] * n right_max = [0] * n # Fill left_max left_max[0] = nums[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], nums[i]) # Fill right_max right_max[n - 1] = nums[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], nums[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - nums[i] return trapped_water"},{"question":"Given a list of meetings represented by intervals `meetings` where `meetings[i] = [start_i, end_i]` for each meeting, return the maximum number of meetings that can be attended without overlapping. A meeting `[start_i, end_i]` overlaps with another meeting `[start_j, end_j]` if `start_i < end_j` and `start_j < end_i`. The meetings need to be attended from start to finish. You may assume that the intervals are sorted according to their start times.","solution":"def max_non_overlapping_meetings(meetings): Returns the maximum number of non-overlapping meetings that can be attended. :param meetings: List of meetings represented by intervals [start_i, end_i] :return: Maximum number of non-overlapping meetings if not meetings: return 0 meetings.sort(key=lambda x: x[1]) # Sort by end time max_meetings = 1 # First meeting can always be attended last_end_time = meetings[0][1] for i in range(1, len(meetings)): if meetings[i][0] >= last_end_time: max_meetings += 1 last_end_time = meetings[i][1] return max_meetings"},{"question":"**Question 4:** You are given a list of airline departure and arrival time intervals in a list of tuples, where each tuple represents the start and end times of a flight (as positive integers). Determine the minimum number of gates needed at the airport such that no two flights conflict. Two flights conflict if they are at the airport at the same time, including arrival and departure times. Write a function that, given the list of tuples containing the flight schedules, returns the minimum number of gates required. **Example: ** Input: `[(1, 4), (2, 5), (7, 9), (3, 6)]` Output: `3` **Note:** - The same gate cannot be used for another flight if a flight is using that gate until it departs.","solution":"def min_gates_required(flight_intervals): Returns the minimum number of gates required so that no two flights conflict. if not flight_intervals: return 0 # Create two lists of all start and end times start_times = sorted([interval[0] for interval in flight_intervals]) end_times = sorted([interval[1] for interval in flight_intervals]) max_gates_needed = 0 current_gates_needed = 0 i, j = 0, 0 # Traverse both the lists to find the overlap while i < len(start_times) and j < len(end_times): if start_times[i] < end_times[j]: current_gates_needed += 1 i += 1 max_gates_needed = max(max_gates_needed, current_gates_needed) else: current_gates_needed -= 1 j += 1 return max_gates_needed"},{"question":"Given an integer array `arr` of size `n`, you need to transform the array to a non-decreasing order but only by performing one operation at most once: choosing any two elements `arr[i]` and `arr[j]` and swapping them. Return _true_ if the array can be transformed to a non-decreasing order by performing this operation at most once, otherwise return _false_.","solution":"def can_be_non_decreasing(arr): Returns True if the array can be transformed to a non-decreasing order by swapping at most one pair of elements, otherwise returns False. n = len(arr) sorted_arr = sorted(arr) # If the array is already sorted, it doesn\'t need any swaps if arr == sorted_arr: return True # Find indices where the current array differs from the sorted one diffs = [i for i in range(n) if arr[i] != sorted_arr[i]] # If there are more than two such indices, more than one swap is required if len(diffs) != 2: return False # If swapping the two differing elements would sort the array, return True i, j = diffs arr[i], arr[j] = arr[j], arr[i] return arr == sorted_arr"},{"question":"A string is called a **Zigzag string** if, through reorganization of its characters, it can be arranged such that no two adjacent characters are the same. Given a string `s`, determine if it is possible to rearrange the string in such a way. Return `true` if it is possible, otherwise return `false`.","solution":"def can_reorganize(s): Returns True if the string can be reorganized such that no two adjacent characters are the same. Otherwise, returns False. from collections import Counter # Count frequency of each character count = Counter(s) max_freq = max(count.values()) # Check if the most frequent character can fit without adjacent duplicates return max_freq <= (len(s) + 1) // 2"},{"question":"You are given a list of integers `costs` where `costs[i]` is the cost of hiring the ith worker. You also have a list of integers `qualifications` where `qualifications[i]` is the qualification value of the ith worker. You are required to hire exactly `k` workers such that the total cost is minimized. The qualification level among the hired workers should be at least `min_qualification`. Return _the minimum total cost to hire_ `k` _workers meeting the qualification criteria_, or `-1` _if it is not possible to hire such a group_.","solution":"def min_cost_to_hire_k_workers(costs, qualifications, k, min_qualification): Returns the minimum cost to hire exactly k workers with qualification at least min_qualification. If it\'s not possible, return -1. qualified_workers = [ (cost, qualification) for cost, qualification in zip(costs, qualifications) if qualification >= min_qualification ] if len(qualified_workers) < k: return -1 # Sort the workers by their cost qualified_workers.sort(key=lambda x: x[0]) # Take the first k workers with the lowest costs total_cost = sum(cost for cost, qualification in qualified_workers[:k]) return total_cost"},{"question":"You are given a binary matrix `mat` of size `n x m` filled with 0\'s and 1\'s. Perform the following operations on the matrix: 1. Flip all the 0\'s to 1\'s and all the 1\'s to 0\'s. 2. Reverse the order of the elements in each row individually. Return the modified matrix after performing the above operations. For example, given `n = 2` and `m = 3`, and the matrix `mat`: ``` [[1, 0, 0], [0, 1, 1]] ``` After flipping and reversing, the result should be: ``` [[1, 1, 0], [0, 0, 1]] ```","solution":"def modify_matrix(mat): Given a binary matrix \'mat\', flip all the 0\'s to 1\'s and all the 1\'s to 0\'s. Then, reverse the order of the elements in each row individually. Parameters: mat (list of list of int): Binary matrix containing 0\'s and 1\'s Returns: list of list of int: Modified matrix after flipping and reversing # Flip the 0\'s to 1\'s and 1\'s to 0\'s. flipped_mat = [[1 - element for element in row] for row in mat] # Reverse the order of elements in each row. modified_mat = [row[::-1] for row in flipped_mat] return modified_mat"},{"question":"You are given a list of integers `heights` which represent the height of buildings along a street. Your task is to compute the **maximum number of distinct buildings** you can see when looking from the left (i.e., from index 0 to the end of the list). You can only see a building if all the previous buildings to the left are shorter than the building you are currently considering. Return _the **maximum** number of distinct buildings you can see from the left side of the street_.","solution":"def max_visible_buildings(heights): Returns the maximum number of distinct buildings you can see when looking from the left (i.e., from index 0 to the end of the list). max_height = 0 count = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"You are given an integer array `nums` of length `n`. Determine if there exists a non-empty subarray with a sum equal to zero. A subarray is any continuous segment of the array. Return `true` if such a subarray exists, and `false` otherwise. A subarray with a sum of zero is a continuous part of the array where the sum of all its elements is zero.","solution":"def has_zero_sum_subarray(nums): Determines if there exists a non-empty subarray with a sum equal to zero. cumulative_sum = 0 seen_sums = set() for num in nums: cumulative_sum += num # Check if cumulative sum is 0 or if it has been seen before if cumulative_sum == 0 or cumulative_sum in seen_sums: return True seen_sums.add(cumulative_sum) return False"},{"question":"You are given a list of integers representing the heights of buildings in a city skyline from left to right. You want to create a silhouette of the skyline when viewed from a distance. An integer array `silhouette` should represent the heights of the buildings as seen from a distance, where each element in the array corresponds to the maximum height of any building that covers that particular position in the skyline. Write a function that takes the list of building heights and returns the silhouette as an integer array. Example: ```python Input: heights = [3, 1, 4, 1, 5, 9, 2, 6, 5] Output: silhouette = [3, 3, 4, 4, 5, 9, 9, 9, 9] ``` In this example, the tallest buildings covering each position in the skyline when viewed from a distance are represented in the output array.","solution":"def silhouette(heights): Returns the silhouette of the skyline represented by the list of building heights. Args: heights (list): A list of integers representing the heights of buildings. Returns: list: A list of integers representing the silhouette of the skyline. if not heights: return [] silhouette = [heights[0]] for i in range(1, len(heights)): silhouette.append(max(silhouette[-1], heights[i])) return silhouette"},{"question":"You are given a string `s` and an array of integers `indices`. The string `s` is shuffled such that the character at the `i`th position of `s` was moved to `indices[i]` in the resulting string. Return the original string that matches the order given in `indices`.","solution":"def restore_string(s, indices): Restores the original string based on the given indices. Args: s (str): The shuffled string. indices (list): List of indices representing the original positions of the characters. Returns: str: The original string. # Initialize a list of the same length as s with placeholders restored = [\'\'] * len(s) # Place each character in its original position based on the indices array for char, idx in zip(s, indices): restored[idx] = char # Join the list into a single string and return return \'\'.join(restored)"},{"question":"Implement a `StreamChecker` class to solve the following problem: You are given a stream of lowercase letters. You need to check if a given set of words matches any suffix of the current stream. Implement the `StreamChecker` class: - `StreamChecker(String[] words)` Initializes the object with the strings array `words`. - `boolean query(char letter)` Returns `true` if the suffix formed by the stream of lowercase letters ends with any of the given words in `words`. Otherwise, returns `false`. The queries will be in the order they were inserted. Each query may update the stream by adding one letter to its end.","solution":"class StreamChecker: def __init__(self, words): self.words = set(words) self.stream = \\"\\" def query(self, letter): self.stream += letter for word in self.words: if self.stream.endswith(word): return True return False"},{"question":"You are given two arrays of integers, `nums1` and `nums2`, where not all elements of `nums2` are guaranteed to be in `nums1`, but each element in `nums1` is unique. Find the next greater number for each element in `nums1` by using the corresponding order from `nums2`. The next greater number of `x` in `nums1` is the first greater number to its right in `nums2`. If it does not exist, return `-1` for this number. Return your results as an array of integers.","solution":"def next_greater_element(nums1, nums2): Finds the next greater number for each element in nums1 by using the corresponding order from nums2. If no greater number exists, -1 is returned for that number. next_greater = {} stack = [] # Store the next greater element for each number in nums2 for num in nums2: while stack and stack[-1] < num: next_greater[stack.pop()] = num stack.append(num) # For all the remaining elements in the stack, there is no next greater element for num in stack: next_greater[num] = -1 # Prepare the result for nums1 based on computed next greater elements result = [next_greater.get(num, -1) for num in nums1] return result"},{"question":"You are given an array of integers `arr` and an integer `k`. Move the first `k` elements of the array to the end of the array without using extra space and maintaining the order of the elements. Return the modified array.","solution":"def move_elements_to_end(arr, k): Moves the first k elements of the array to the end, maintaining order and without using extra space. Args: arr (list of int): The input array of integers. k (int): The number of elements to move. Returns: list of int: The modified array with the first k elements moved to the end. if k <= 0 or k >= len(arr): return arr # No change if k is out of lower/upper bounds return arr[k:] + arr[:k]"},{"question":"You are given an array `arr` of `n` integers. You can perform the following operation on the array as many times as you want: * Choose any two adjacent elements `arr[i]` and `arr[i+1]` (0 <= i < n-1) and replace them with a single element that is their sum. Your task is to determine the minimum possible value of the resulting single element after performing any number of operations on the array. Return the minimum possible value.","solution":"def min_possible_value(arr): Returns the minimum possible value of the resulting single element after performing the specified operation on the array. Parameters: arr (list of int): The input array of integers. Returns: int: The minimum possible value of the resulting single element. return sum(arr)"},{"question":"You are given the head of a singly linked list and an integer k. Return the head of the linked list after **rotating the list to the right** by k places. For example, given the linked list `1 -> 2 -> 3 -> 4 -> 5` and `k = 2`, the resulting linked list after rotation should be `4 -> 5 -> 1 -> 2 -> 3`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Determine the length of the list and the last node length = 1 current = head while current.next: current = current.next length += 1 # Connect the last node with the head to make it circular current.next = head # Find the new head and the new tail k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"Given an array of integers `nums` and an integer `k`, split the array into exactly `k` non-empty contiguous subarrays such that the sum of the largest subarray sum among them is the minimum possible. Return _this minimum possible value_.","solution":"def split_array(nums, k): def can_split(max_sum): current_sum = 0 subarray_count = 1 for num in nums: if current_sum + num > max_sum: current_sum = num subarray_count += 1 if subarray_count > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are tasked with the design of an amusement park ride that can accommodate multiple groups of people. You have access to multiple rides, each with a limited capacity. You are given an array `rides` where `rides[i]` represents the maximum capacity of the i-th ride. Additionally, you are given an integer `k` representing the number of groups. Your goal is to distribute the groups among the available rides such that each group can enjoy a ride and the rides are filled up to their maximum capacities as much as possible. Return a boolean indicating whether it is possible to distribute the groups among the rides without exceeding the maximum capacities.","solution":"def can_accommodate_groups(rides, k): Determines if k groups can be accommodated within the provided rides. :param rides: List of integers representing the maximum capacities of each ride. :param k: Integer representing the number of groups. :return: Boolean indicating whether it is possible to accommodate all groups. total_capacity = sum(rides) return total_capacity >= k"},{"question":"You are given a list of non-negative integers `nums`. Each integer in the list represents the maximum number of steps you can jump forward from that position. Your task is to determine if you can reach the last index starting from the first index. Return `true` if you can reach the last index, otherwise return `false`.","solution":"def can_jump(nums): Determines if you can reach the last index starting from the first index in the nums list. :param nums: List of non-negative integers representing maximum jump lengths. :return: Boolean indicating whether the last index is reachable. max_reach = 0 n = len(nums) for i in range(n): if i > max_reach: return False max_reach = max(max_reach, i + nums[i]) if max_reach >= n - 1: return True return max_reach >= n - 1"},{"question":"You are given an array `nums` consisting of non-negative integers. A pair `(i, j)` is considered **special** if `nums[i]` is **less than or equal to** `nums[j]` and `i < j`. Return _the **number** of special pairs in_ `nums`.","solution":"def count_special_pairs(nums): Returns the number of special pairs (i, j) where nums[i] <= nums[j] and i < j. special_pairs_count = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] <= nums[j]: special_pairs_count += 1 return special_pairs_count"},{"question":"Given a list of integers `nums`, you are tasked to rearrange the integers in the list in such a way that the sum of the absolute differences between every two adjacent integers is minimized. Return the rearranged list of integers. **Example:** - Input: `nums = [4, 2, 1, 3]` - Output: `[1, 2, 3, 4]` Note: multiple valid solutions may exist, return any of them.","solution":"def minimized_adjacent_difference(nums): Returns a list of integers rearranged in such a way that the sum of the absolute differences between every two adjacent integers is minimized. return sorted(nums)"},{"question":"You are given a linked list where each node contains a positive integer. A linked list is considered \\"circular\\" if tail node\'s next pointer points back to the head of the list. Write a function `splitCircularList(head)` that takes the head of a circular linked list and splits it into two smaller circular linked lists of (almost) equal size: - If the original list has an even number of nodes, the two resulting lists should each contain half the number of nodes. - If the original list has an odd number of nodes, one list should contain one more node than the other. Return the heads of the two resulting circular linked lists. For example, given a circular linked list of nodes [1, 2, 3, 4, 5], split it into two lists: one with nodes [1, 2, 3] and another with nodes [4, 5]. Both lists should be circular.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def splitCircularList(head): if not head or head.next == head: # Handle edge cases where list is empty or only one node return head, None slow = fast = head # Find the middle point using slow and fast pointer approach while fast.next != head and fast.next.next != head: slow = slow.next fast = fast.next.next # If there are odd number of nodes, move fast pointer one step further if fast.next.next == head: fast = fast.next # head1 is the first part of the list head1 = head # head2 is the second part of the list head2 = slow.next # Break the list into two halves slow.next = head1 fast.next = head2 return head1, head2"},{"question":"You are given a list of integers `nums` where `nums[i]` is the number of elements in the `i`th bucket. A bucket is considered \\"valid\\" if it contains at least one ball. Write a function that returns the list of integers in `nums` after removing all values that correspond to empty buckets (i.e., values that are zero).","solution":"def remove_empty_buckets(nums): Returns a list of integers in nums after removing all values that correspond to empty buckets (i.e., values that are zero). Args: nums (list): A list of integers where nums[i] is the number of elements in the ith bucket. Returns: list: A list of integers with empty buckets removed. return [num for num in nums if num != 0]"},{"question":"Given an integer array `arr` of size `n`, where `arr[i]` represents the price of a stock on the `i`-th day, return the maximum profit you can achieve from making at most one transaction. A transaction consists of buying one stock on one day and selling it on another day. If no profit is possible, return 0.","solution":"def max_profit(prices): Returns the maximum profit from making at most one transaction of buying and selling a stock. :param prices: List[int] where prices[i] is the price of a stock on the i-th day. :return: Maximum profit achievable, or 0 if no profit is possible. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit"},{"question":"Given a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices. Please note here we are talking about the node indices, not the values in the nodes. You should try to do it in place. The program should run in O(n) time complexity and O(1) space complexity. The relative order inside both the even and odd groups should remain as it was in the input. Given the head of a singly linked list, return the restructured linked list\'s head.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): if not head: return head odd = head even = head.next even_head = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head"},{"question":"Given an undirected graph with `n` vertices labeled from `0` to `n-1`, represented by a 2D array `edges` where `edges[i] = [u, v, w]` denotes an edge between nodes `u` and `v` with weight `w`, find the weight of the second minimum spanning tree (SMST). A second minimum spanning tree (SMST) is a spanning tree that has the smallest weight greater than the weight of the minimum spanning tree (MST). If the graph does not have a second minimum spanning tree, return -1.","solution":"import heapq from collections import defaultdict def find_parent(parents, node): if parents[node] == node: return node parents[node] = find_parent(parents, parents[node]) return parents[node] def union(parents, ranks, node1, node2): root1 = find_parent(parents, node1) root2 = find_parent(parents, node2) if root1 != root2: if ranks[root1] > ranks[root2]: parents[root2] = root1 elif ranks[root1] < ranks[root2]: parents[root1] = root2 else: parents[root2] = root1 ranks[root1] += 1 def kruskal(n, edges, skip_edge_index=-1): parents = [i for i in range(n)] ranks = [0] * n mst_weight = 0 edge_count = 0 for i, (u, v, w) in enumerate(edges): if i == skip_edge_index: continue if find_parent(parents, u) != find_parent(parents, v): mst_weight += w union(parents, ranks, u, v) edge_count += 1 if edge_count == n - 1: return mst_weight else: return float(\'inf\') def second_minimum_spanning_tree(n, edges): edges.sort(key=lambda x: x[2]) mst_weight = kruskal(n, edges) if mst_weight == float(\'inf\'): return -1 smst_weight = float(\'inf\') for i in range(len(edges)): weight = kruskal(n, edges, skip_edge_index=i) if weight > mst_weight: smst_weight = min(smst_weight, weight) return smst_weight if smst_weight != float(\'inf\') else -1"},{"question":"You are given an array `values` where each `values[i]` represents the value of a unique item. You can combine any two **adjacent** items into a single item whose value is the sum of the two individual items, and this combination process costs the sum of the values of the items. Return _the **minimum cost** required to combine all the items into one_.","solution":"import heapq def min_cost_to_combine_items(values): Returns the minimum cost required to combine all items into one. Parameters: values (List[int]): List of item values. Returns: int: Minimum cost to combine all items. # Edge cases if not values: return 0 if len(values) == 1: return 0 # Using a min-heap to always combine the smallest two elements first heapq.heapify(values) total_cost = 0 while len(values) > 1: # Pop the two smallest items first_smallest = heapq.heappop(values) second_smallest = heapq.heappop(values) # Combine them combined_value = first_smallest + second_smallest total_cost += combined_value # Push the combined item back into the heap heapq.heappush(values, combined_value) return total_cost"},{"question":"You are given two sorted integer arrays `nums1` and `nums2`, each of size `m` and `n` respectively. Return the **median** of the two sorted arrays. The overall run-time complexity should be `O(log(min(m,n)))`. Note: The median of a sorted array of size `k` is defined as the middle element if `k` is odd, and the average of the two middle elements if `k` is even (`(a+b)/2` where `a` and `b` are the two middle elements).","solution":"def findMedianSortedArrays(nums1, nums2): def merge_arrays(arr1, arr2): merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 merged.extend(arr1[i:]) merged.extend(arr2[j:]) return merged # Merge the two sorted arrays merged_array = merge_arrays(nums1, nums2) length = len(merged_array) # Find the median if length % 2 == 1: return merged_array[length // 2] else: return (merged_array[length // 2 - 1] + merged_array[length // 2]) / 2"},{"question":"You are given a matrix `grid` consisting of `m` rows and `n` columns, where each cell has a non-negative integer. A ball is dropped from the top of the matrix and can move only to the cell directly below it, or diagonally to the cell below-left or below-right. The ball starts from the top row\'s cell, and the goal is to determine the maximum possible sum of numbers it can collect along its path until it reaches the bottom row. Return _the maximum sum that can be collected_.","solution":"def max_path_sum(grid): Given a matrix `grid`, returns the maximum sum that can be collected from top to bottom. The ball can move directly down, or diagonally down-left or down-right. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize dp array to store the max sum at each cell dp = [[0] * n for _ in range(m)] # Copy the first row as starting points for j in range(n): dp[0][j] = grid[0][j] for i in range(1, m): for j in range(n): max_score = dp[i-1][j] if j > 0: max_score = max(max_score, dp[i-1][j-1]) if j < n - 1: max_score = max(max_score, dp[i-1][j+1]) dp[i][j] = grid[i][j] + max_score return max(dp[-1])"},{"question":"Write a function `findDiagonalOrder` that takes a 2D integer array `matrix` and returns an array of all the elements of the given matrix in diagonal order. In a diagonal order, elements are collected from each diagonal going from the top-left to the bottom-right and then from bottom-left to the top-right, alternating for each diagonal. The algorithm should run in `O(m*n)` time where `m` is the number of rows and `n` is the number of columns.","solution":"def findDiagonalOrder(matrix): Returns the diagonal order traversal of the 2D integer array `matrix`. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result, intermediate = [], [] for d in range(m + n - 1): intermediate.clear() row = 0 if d < n else d - n + 1 col = d if d < n else n - 1 while row < m and col > -1: intermediate.append(matrix[row][col]) row += 1 col -= 1 if d % 2 == 0: result.extend(reversed(intermediate)) else: result.extend(intermediate) return result"},{"question":"You are given an integer array `nums` and an integer `k`. In one operation, you can move any element of the array to the end. Return the **maximum sum** of a contiguous subarray of length `k`. If `k` is greater than the length of the array, return 0.","solution":"def max_sum_subarray_of_length_k(nums, k): Returns the maximum sum of a contiguous subarray of length k. If k is greater than the length of the array, returns 0. n = len(nums) if k > n: return 0 # Calculate the sum of the first k elements max_sum = curr_sum = sum(nums[:k]) # Use a sliding window to find the maximum sum for subarrays of size k for i in range(k, n): curr_sum += nums[i] - nums[i - k] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"You are given an integer array `nums` where `nums[i]` represents the number of candies in the `i-th` candy jar. Each candy jar can be chosen at most once, and you can choose any number of jars as long as no two chosen jars are adjacent. Write a function to determine the maximum number of candies you can collect. Return _the maximum sum of candies_ that can be collected by following the above rules.","solution":"def max_candies(nums): Returns the maximum number of candies that can be collected from the given jars without selecting adjacent jars. if not nums: return 0 if len(nums) == 1: return nums[0] include = nums[0] exclude = 0 for i in range(1, len(nums)): new_exclude = max(include, exclude) include = exclude + nums[i] exclude = new_exclude return max(include, exclude)"},{"question":"Given a list of `n` distinct integers representing the list of participants in a dance competition, you need to form pairs of participants to dance together. You are given an integer `k` which indicates that the sum of the abilities of the two participants in a pair must be equal to `k`. Return the maximum number of such pairs you can form. Each participant can belong to at most one pair. Example: ``` Input: nums = [1, 2, 3, 4], k = 5 Output: 2 Explanation: The pairs are (1, 4) and (2, 3) ``` ``` Input: nums = [3, 4, 2, 5, 7, 8, 1, 9], k = 10 Output: 3 Explanation: The pairs are (1, 9), (2, 8), and (3, 7) ```","solution":"def max_number_of_pairs(nums, k): Given a list of `n` distinct integers representing participants\' abilities and an integer `k`, returns the maximum number of pairs such that the sum of the abilities in each pair is equal to `k`. num_counter = {} for num in nums: if num in num_counter: num_counter[num] += 1 else: num_counter[num] = 1 pairs = 0 for num in list(num_counter): complement = k - num if complement in num_counter and num_counter[num] > 0 and num_counter[complement] > 0: if num == complement: pairs += num_counter[num] // 2 num_counter[num] = 0 else: min_count = min(num_counter[num], num_counter[complement]) pairs += min_count num_counter[num] -= min_count num_counter[complement] -= min_count return pairs"},{"question":"You are given a 2D grid `grid` of size `m x n` consisting of non-negative integers. You are initially positioned at cell `(0, 0)` and must move to cell `(m-1, n-1)` while accumulating the maximum sum of values of the cells you visit. You can only move either right or down from a cell. Return the maximum sum of values you can accumulate by the time you reach the cell `(m-1, n-1)`.","solution":"def max_path_sum(grid): Returns the maximum path sum from top-left to bottom-right in a grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp array where dp[i][j] will store the maximum sum path to reach cell (i, j) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"You are given an array of integers `nums` where `nums[i]` could be either positive or negative. Find and return the maximum sum of any contiguous subarray of the array `nums`. A contiguous subarray is defined as a part of an array where consecutive elements of the original array are retained in order.","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray. Parameters: nums (List[int]): List of integers, either positive or negative. Returns: int: Maximum sum of any contiguous subarray. if not nums: return 0 max_so_far = nums[0] current_max = nums[0] for num in nums[1:]: current_max = max(num, current_max + num) max_so_far = max(max_so_far, current_max) return max_so_far"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to rearrange the string such that any two adjacent characters are different. Determine if it is possible to rearrange the string given the constraint `k`, which represents the minimum distance between any two occurrences of the same character. If it is possible, return any valid rearrangement of the string. If it is not possible, return an empty string. Write an algorithm that efficient processes the input and outputs the result.","solution":"from collections import Counter import heapq def rearrange_string(s, k): if k <= 1: return s # Count the frequency of each character counter = Counter(s) maxheap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(maxheap) queue = [] result = [] while maxheap: freq, char = heapq.heappop(maxheap) result.append(char) queue.append((char, freq + 1)) # decrease frequency if len(queue) >= k: front_char, front_freq = queue.pop(0) if front_freq < 0: heapq.heappush(maxheap, (front_freq, front_char)) if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"You are given a string `s` that consists of only digits. Your task is to minimize the string by performing a series of operations. In one operation, you can select two adjacent digits and replace them with the larger of the two. Return the minimum possible string you can achieve after applying any number of these operations. For example, if `s = \\"213\\"`, you can perform the following operations: - Replace \'2\' and \'1\' with \'2\', resulting in \\"23\\" - Replace \'2\' and \'3\' with \'3\', resulting in \\"3\\" Hence, the minimum possible string you can achieve is \\"3\\".","solution":"def minimize_string(s): Returns the minimum possible string after performing operations to replace adjacent digits with the larger of the two. # Iterate through the string and replace adjacent digits until no more replacements can be made while len(s) > 1: max_digit = \'0\' index = -1 for i in range(len(s) - 1): if max(s[i], s[i + 1]) > max_digit: max_digit = max(s[i], s[i + 1]) index = i s = s[:index] + max_digit + s[index+2:] return s"},{"question":"Given a list of unique words, find all pairs of distinct indices `(i, j)` in the given list such that the concatenation of the two words `words[i] + words[j]` is a palindrome. Implement the function `findPalindromePairs` that returns a list of all such pairs `[(i, j)]`. Each pair should be sorted in lexicographical order of the indices. The function takes a list of strings `words` as input and returns a list of tuples representing the valid pairs.","solution":"def is_palindrome(word): Helper function to check if a word is a palindrome. return word == word[::-1] def findPalindromePairs(words): Returns a list of all pairs of distinct indices (i, j) such that the concatenation of words[i] + words[j] is a palindrome. palindrome_pairs = [] for i in range(len(words)): for j in range(len(words)): if i != j and is_palindrome(words[i] + words[j]): palindrome_pairs.append((i, j)) return palindrome_pairs"},{"question":"You are given an integer array `nums` containing `n` unique elements, and an integer target `t`. Your task is to determine if there exists three distinct elements in `nums` whose sum is exactly equal to `t`. If such elements exist, return a vector containing these three numbers. If there are multiple valid triplets, return any one of them. If no such triplet exists, return an empty vector.","solution":"def find_three_sum(nums, target): Find three distinct elements in nums whose sum equals target. Returns a list containing these three numbers, or an empty list if no such numbers exist. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return [nums[i], nums[left], nums[right]] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"You are given a string `s` that represents a large integer, obtained by concatenating multiple smaller integers. Each integer in the string has leading zeroes removed. Your task is to count _the number of unique integers_ in the string. For example, if the input string `s` is \\"a123bc34d8ef34\\", the unique integers would be [123, 34, 8], so the output should be `3`. Return the count of unique integers present in the string.","solution":"import re def count_unique_integers(s): Returns the count of unique integers present in the string s. # Find all numbers in the string using regular expressions numbers = re.findall(r\'d+\', s) # Convert each number to an integer to remove leading zeros and find unique ones unique_numbers = set(map(int, numbers)) return len(unique_numbers)"},{"question":"Given a string `s` representing a list of words separated by spaces, return the length of the longest word. Be sure to account for multiple spaces between words and trailing or leading spaces. For example, given the input string `\\"The quick brown fox jumps over the lazy dog\\"`, the function should return `5` because the longest word is `\\"quick\\"` which has 5 characters.","solution":"def length_of_longest_word(s): Returns the length of the longest word in the string s. Args: s (str): The input string containing words separated by spaces. Returns: int: The length of the longest word. # Split the string by spaces and filter out empty strings caused by multiple spaces words = [word for word in s.split(\\" \\") if word] # Return the length of the longest word if words: return max(len(word) for word in words) return 0"},{"question":"You are given a string `s` and a list of words `dict`. Your task is to find all starting indices in the string `s` that are the starting points of substrings in `s` that can be rearranged to form words in `dict`. Each word must be matched exactly once, and a substring can cover multiple words from `dict`. The order of characters within each word can be rearranged, but the overall order of words in `s` must be maintained. Return a list of all starting indices. For example, given string `s = \\"catdogdogcat\\"`, and `dict = [\\"cat\\", \\"dog\\"]`, the function should return `[0, 6]` because both `\\"catdog\\"` and `\\"dogcat\\"` can be rearranged to form words in `dict`.","solution":"def find_substring_indices(s, words): from collections import Counter if not s or not words: return [] word_len = len(words[0]) num_words = len(words) sub_len = word_len * num_words word_count = Counter(words) def is_valid(start): seen = Counter() for i in range(start, start + sub_len, word_len): word = s[i:i + word_len] if word not in word_count: return False seen[word] += 1 if seen[word] > word_count[word]: return False return True return [i for i in range(len(s) - sub_len + 1) if is_valid(i)]"},{"question":"Given an integer array `arr` and an integer `x`, find and return the length of the longest subarray such that the absolute difference between any two elements in the subarray is less than or equal to `x`. A subarray is a contiguous subsequence of elements within the array.","solution":"def longest_subarray_with_diff(arr, x): Returns the length of the longest subarray such that the absolute difference between any two elements in the subarray is less than or equal to x. if not arr: return 0 max_length = 0 start = 0 for end in range(len(arr)): while max(arr[start:end+1]) - min(arr[start:end+1]) > x: start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a list of strings `emails`, where each email follows the format \\"local@domain\\", return _the total number of unique email addresses_. When considering uniqueness, treat email addresses as case-insensitive, and ignore any characters after a \'+\' in the local part (before the \'@\') as well as all periods \'.\' within the local part. For example, given `\\"test.email+alex@leetcode.com\\"`, `\\"test.e.mail+bob.cathy@leetcode.com\\"`, and `\\"testemail+david@lee.tcode.com\\"`, all three emails would be considered the same address.","solution":"def num_unique_emails(emails): Returns the total number of unique email addresses. :param emails: List of email addresses as strings :return: Integer count of unique email addresses unique_emails = set() for email in emails: local, domain = email.split(\'@\') local = local.split(\'+\')[0].replace(\'.\', \'\') unique_emails.add(local.lower() + \'@\' + domain.lower()) return len(unique_emails)"},{"question":"You are given an array of integers `nums` representing the number of coins in each pile, and an integer `k`. Your task is to divide all the coins into groups of exactly `k` coins each. If you can divide all the coins in this way, return _the maximum number of groups you can get_. Otherwise, return `-1`.","solution":"def max_coin_groups(nums, k): Returns the maximum number of groups of exactly \'k\' coins each that can be formed from the \'nums\' array. :param nums: List[int] - Array of integers representing the number of coins in each pile. :param k: int - The exact number of coins each group should have. :return: int - The maximum number of groups that can be formed, or -1 if it is not possible. total_coins = sum(nums) if total_coins % k != 0: return -1 return total_coins // k"},{"question":"Given an array of integers `height` representing the heights of a series of towers arranged in a row, return _the number of pairs of indices `(i, j)` such that `i < j` and `height[i] > height[j]`_.","solution":"def count_pairs(height): Returns the number of pairs (i, j) such that i < j and height[i] > height[j]. count = 0 n = len(height) for i in range(n): for j in range(i + 1, n): if height[i] > height[j]: count += 1 return count"},{"question":"You are given a **0-indexed** binary array `bits` of length `n`. A binary array contains only `0`s and `1`s. You are allowed to flip **at most one** bit from `0` to `1`. Return _the length of the longest contiguous subarray of `1`s that can be obtained by flipping at most one bit_.","solution":"def longest_ones(bits): Returns the length of the longest contiguous subarray of `1`s that can be obtained by flipping at most one bit from `0` to `1`. max_len = 0 left = 0 zero_count = 0 for right in range(len(bits)): if bits[right] == 0: zero_count += 1 while zero_count > 1: if bits[left] == 0: zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an input `root` of a binary tree, determine if the binary tree is **balanced**. A balanced binary tree is defined as a binary tree in which the depth of the two subtrees of **every** node never differs by more than one. Return `true` if the tree is balanced, and `false` otherwise. Note: * The input binary tree is represented using a TreeNode class. TreeNode class definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if a binary tree is balanced. A binary tree is balanced if the depth of the two subtrees of every node never differs by more than one. def check_balance(node): if not node: return 0, True left_depth, left_balanced = check_balance(node.left) right_depth, right_balanced = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_depth - right_depth) <= 1 return max(left_depth, right_depth) + 1, balanced _, is_bal = check_balance(root) return is_bal"},{"question":"Given a `root` of a binary tree, return an array of the inorder traversal of its nodes\' values. The left subtree is visited first, then the current node, and finally the right subtree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Perform an inorder traversal of a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: List[int]: The list of values in inorder traversal. result = [] def inorder(node): if node: inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result"},{"question":"Given two strings `s1` and `s2`, return _the minimum window substring_ of `s1` that contains all the characters from `s2`. If there is no such substring, return an empty string. If there is more than one minimum window substring, return the one with the smallest starting index. For example, if `s1 = \\"ADOBECODEBANC\\"` and `s2 = \\"ABC\\"`, the minimum window substring is \\"BANC\\".","solution":"from collections import Counter, defaultdict def min_window(s1, s2): if not s1 or not s2: return \\"\\" dict_s2 = Counter(s2) required = len(dict_s2) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None while r < len(s1): character = s1[r] window_counts[character] += 1 if character in dict_s2 and window_counts[character] == dict_s2[character]: formed += 1 while l <= r and formed == required: character = s1[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_s2 and window_counts[character] < dict_s2[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s1[ans[1]: ans[2] + 1]"},{"question":"You are given a 2D grid of characters `grid` representing a map of islands (`\'1\'`) and water (`\'0\'`). An island is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Find the number of distinct islands in the grid. Two islands are considered distinct if their shapes are different after rotations and reflections. Return the number of distinct islands.","solution":"def numDistinctIslands(grid): def dfs(x, y, direction, path): if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == \'1\': grid[x][y] = \'0\' path.append(direction) dfs(x + 1, y, \'d\', path) # down dfs(x - 1, y, \'u\', path) # up dfs(x, y + 1, \'r\', path) # right dfs(x, y - 1, \'l\', path) # left path.append(\'b\') # backtracking distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': path = [] dfs(i, j, \'o\', path) # start of DFS if path: distinct_islands.add(tuple(path)) return len(distinct_islands)"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` distinct integers. The array is described as a **mountain array** if and only if: - `n >= 3` - There exists an index `i` with `0 < i < n - 1` such that: * `nums[0] < nums[1] < ... < nums[i - 1] < nums[i]` * `nums[i] > nums[i + 1] > ... > nums[n - 1]` Given a mountain array `nums`, return _the index_ `i` _where the peak mountain exists_.","solution":"def peak_index_in_mountain_array(nums): Returns the index \'i\' where the peak of the mountain array exists. Args: nums (List[int]): A list of integers representing the mountain array. Returns: int: The index of the peak element. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Return an array of the squares of each number sorted in non-decreasing order. Implement the `sortedSquares` function that receives input: - `int[] nums` and returns - `int[]` representing the sorted squares of each number in `nums`. Your algorithm should run in O(n) time complexity where n is the length of the input array.","solution":"def sortedSquares(nums): Returns an array of the squares of each number sorted in non-decreasing order. n = len(nums) result = [0] * n left, right = 0, n - 1 position = n - 1 while left <= right: if abs(nums[left]) > abs(nums[right]): result[position] = nums[left] ** 2 left += 1 else: result[position] = nums[right] ** 2 right -= 1 position -= 1 return result"},{"question":"Given a non-negative integer `n`, generate the sequence of integers that form the triangular numbers up to and including `n`. The **triangular numbers** are defined by the formula `T(m) = m * (m + 1) / 2` for any non-negative integer `m`. Return the list of triangular numbers less than or equal to `n`. If no such numbers exist, return an empty list.","solution":"def triangular_numbers(n): Generate the sequence of triangular numbers up to and including `n`. Parameters: n (int): Non-negative integer up to which triangular numbers are to be found. Returns: List[int]: List of triangular numbers less than or equal to `n`. triangular_nums = [] m = 1 while True: T_m = m * (m + 1) // 2 if T_m > n: break triangular_nums.append(T_m) m += 1 return triangular_nums"},{"question":"You are given a list of integers representing the position of houses along a street, and you are to place `k` libraries along this street. Each library can cover (provide service to) all houses within a radius `r`. A house is considered covered if it is within distance `r` from at least one library. You need to determine the minimum radius `r` required so that every house is covered by at least one library. Return the minimum radius `r` necessary to cover all houses. Note: You can assume that it’s always possible to cover all houses with the given number of libraries.","solution":"def min_radius(houses, k): Determines the minimum radius r required to ensure all houses are covered by at least one of the k libraries. :param houses: List of integers representing the positions of houses :param k: Number of libraries to place :return: Minimum radius r def can_cover_with_radius(r): libraries_used = 0 last_library_position = -float(\'inf\') for house in houses: if house > last_library_position + r: libraries_used += 1 last_library_position = house if libraries_used > k: return False return True houses.sort() low, high = 0, houses[-1] - houses[0] while low < high: mid = (low + high) // 2 if can_cover_with_radius(mid): high = mid else: low = mid + 1 return low"},{"question":"You have a string containing lowercase letters. You can perform the following operation any number of times: choose any letter in the string and replace it with any other lowercase letter. Each operation has a cost associated with it. The cost of replacing a letter `a` with a letter `b` is `|a - b|`, where `|a - b|` represents the absolute difference between the ASCII values of `a` and `b`. Given a string `s` and an integer `k`, determine the minimum total cost required to make the string a palindrome using up to `k` operations. If it\'s not possible to make the string a palindrome within `k` operations, return `-1`.","solution":"def min_cost_to_palindrome(s, k): Determine the minimum total cost required to make the string a palindrome using up to k operations. If it\'s not possible, return -1. n = len(s) cost = 0 operations = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: diff = abs(ord(s[i]) - ord(s[n - 1 - i])) cost += diff operations += 1 if operations > k: return -1 else: return cost"},{"question":"Given a `matrix` of integers where each row is sorted in ascending order and each column is also sorted in ascending order, write a function to find an element `target` in the matrix. Return `true` if the element is found, and `false` otherwise. The function should aim to find the target in O(m + n) time, where `m` is the number of rows and `n` is the number of columns.","solution":"def search_matrix(matrix, target): Searches for a target value in a matrix where each row and column is sorted in ascending order. Returns True if the target is found, and False otherwise. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given two arrays of integers `arr1` and `arr2`, possibly of different lengths. Your task is to find the number of distinct elements in `arr1` which are not present in `arr2`. Return the count of such unique elements. Note that the elements of the arrays can only be integers within the range of `-1000` to `1000`.","solution":"def count_unique_elements(arr1, arr2): Returns the count of distinct elements in arr1 that are not present in arr2. set_arr2 = set(arr2) unique_elements = {element for element in arr1 if element not in set_arr2} return len(unique_elements)"},{"question":"Given an integer array `arr` and an integer `k`, return the largest sum of any continuous subarray of length `k` in the array. If the array is shorter than `k`, return `-1`.","solution":"def largest_sum_subarray_of_length_k(arr, k): Returns the largest sum of any continuous subarray of length k. If the array is shorter than k, returns -1. n = len(arr) # If the array is shorter than k, return -1 if n < k: return -1 # Find the initial subarray sum of length k max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window over the array and find the maximum sum for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `arr` where each element represents the height of a building. A building can receive sunlight if there are no taller buildings to its right. Return _an array of buildings (their indices) that receive sunlight_. Aim for an optimal solution with a time complexity better than O(n^2).","solution":"def buildings_with_sunlight(arr): Returns indices of buildings that receive sunlight. n = len(arr) result = [] max_height = float(\'-inf\') for i in range(n - 1, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] return result[::-1] # Reverse to maintain order from left to right"},{"question":"Given a matrix `mat` where each row is sorted in non-decreasing order, find the smallest common element in all rows. If there is no common element, return `-1`.","solution":"def smallestCommonElement(mat): Finds the smallest common element in all rows of a matrix. If no such element exists, returns -1. :param mat: List[List[int]] :return: int count = {} for row in mat: for num in set(row): # Convert each row to a set to avoid duplicate counts within the same row if num in count: count[num] += 1 else: count[num] = 1 rows = len(mat) for num in sorted(count.keys()): # Check the numbers in sorted order if count[num] == rows: return num return -1"},{"question":"You are given an array of integers `nums` representing the number of widgets produced by a machine on each day over a production period of `n` days. Your task is to find the maximum number of widgets produced on any consecutive subarray of a given length `k` (1 <= k <= n). Write a function that returns the maximum sum of widgets produced in any subarray of length `k`. Use the sliding window technique to solve this problem efficiently.","solution":"def max_widgets_in_subarray(nums, k): Returns the maximum number of widgets produced on any consecutive subarray of length k. Args: nums: List[int] - the list of integers representing the number of widgets produced each day. k: int - the length of the subarray. Returns: int - the maximum sum of any subarray of length k. if not nums or k <= 0 or k > len(nums): return 0 max_sum = current_sum = sum(nums[:k]) # Initial window sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] # Slide the window to the right max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an array of integers `nums`, where each element represents the price of a certain item. You are also given `k`, the number of items you can buy. Return the maximum possible sum of the prices of any `k` different items you can choose. For example, given the array `nums = [4, 7, 2, 9, 5]` and `k = 3`, you could choose the items with prices `[7, 9, 5]`, which sum up to `21`. Hence, the function would return `21`. If `k` is greater than the number of elements in `nums`, return the sum of all elements in `nums`.","solution":"def max_sum_of_k_items(nums, k): Returns the maximum possible sum of the prices of any k different items you can choose. If k is greater than the number of elements in nums, returns the sum of all elements in nums. Parameters: nums (list of int): List containing the prices of items. k (int): Number of items to choose. if not nums or k <= 0: return 0 nums_sorted = sorted(nums, reverse=True) return sum(nums_sorted[:min(k, len(nums))])"},{"question":"You are given a list of integers `arr` where each integer appears exactly twice, except for one integer which appears exactly once. Write a function that finds and returns the integer that appears only once.","solution":"def find_single_number(arr): Finds and returns the integer that appears exactly once in the list, where every other integer appears exactly twice. :param arr: List of integers where each integer appears twice except for one. :return: The integer that appears only once. unique_number = 0 for num in arr: unique_number ^= num return unique_number"},{"question":"You are given an array of integers `arr` where each element `arr[i]` represents the number of items at position `i`. You are also given an integer `k`. Your task is to find the maximum number of consecutive positions you can choose, starting from any index, such that the sum of items in those positions is less than or equal to `k`. Return the length of the longest such subarray. If no such subarray exists, return `0`.","solution":"def max_length_subarray(arr, k): Returns the maximum length of consecutive positions such that the sum of items in those positions is less than or equal to k. Args: arr : list of int List of integers representing the number of items at each position. k : int Maximum allowable sum for the subarray. Returns: int Length of the longest subarray with sum less than or equal to k. n = len(arr) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > k and start <= end: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":": Given a binary tree, return the values of its nodes in level order traversal. (i.e., from left to right, level by level). Each element in the return list should be a sub-list representing one level of the tree. For example, the following tree: ``` 3 / 9 20 / 15 7 ``` Should output: `[[3], [9, 20], [15, 7]]`","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Perform level order traversal on a binary tree and return values of nodes in level order. :param root: TreeNode, the root node of the binary tree :return: List[List[int]], a list of lists containing values of nodes at each level if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for i in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"Given a binary tree, write an algorithm to serialize and deserialize it. The serialization mechanism should convert the binary tree to a single string, and the deserialization mechanism should convert that string back to the original binary tree structure. * The serialization should output the string, and the deserialization should take the string as input and produce the binary tree. * The tree is represented as follows: each node contains an integer value, and two child pointers pointing to the left and right subtrees. * Ensure the algorithm can handle null pointers appropriately when serializing and deserializing. Implement the `BinaryTreeSerializer` class: - `String serialize(TreeNode root)`: Converts the binary tree rooted at `root` to a string. - `TreeNode deserialize(String data)`: Converts the serialized string `data` back to the original binary tree and returns the root of the tree. For example, given the following tree: ``` 1 / 2 3 / 4 5 ``` The serialization might result in a string like \\"1,2,null,null,3,4,null,null,5,null,null\\" and the deserialization process should recreate the same tree structure.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeSerializer: def serialize(self, root): Encodes a tree to a single string. def preorder_traversal(node): if not node: return \\"null,\\" return str(node.val) + \\",\\" + preorder_traversal(node.left) + preorder_traversal(node.right) return preorder_traversal(root) def deserialize(self, data): Decodes your encoded data to tree. def preorder_construction(data_list): if data_list[0] == \\"null\\": data_list.pop(0) return None root = TreeNode(int(data_list[0])) data_list.pop(0) root.left = preorder_construction(data_list) root.right = preorder_construction(data_list) return root data_list = data.split(\',\') return preorder_construction(data_list)"},{"question":"You are tasked with implementing a system that manages a collection of intervals. Your system should be able to add new intervals and merge any overlapping intervals automatically. Implement the `IntervalManager` class: * `IntervalManager()` Initializes the interval manager. * `void addInterval(int start, int end)` Adds a new interval `[start, end]` to the collection of intervals, merging any overlapping intervals if necessary. * `List<int[]> getIntervals()` Returns a list of merged intervals sorted by their start times. Provide a solution that ensures efficient merging and retrieval of intervals.","solution":"class IntervalManager: def __init__(self): self.intervals = [] def addInterval(self, start, end): new_interval = [start, end] self.intervals.append(new_interval) self.intervals.sort(key=lambda x: x[0]) merged_intervals = [] for interval in self.intervals: if not merged_intervals or merged_intervals[-1][1] < interval[0]: merged_intervals.append(interval) else: merged_intervals[-1][1] = max(merged_intervals[-1][1], interval[1]) self.intervals = merged_intervals def getIntervals(self): return self.intervals"},{"question":"You are given a **sorted** list of distinct integers `arr` and an integer target value `x`. Join all pairs of integers from `arr` that sum up to `x` with a \'+\'. Each integer can only be paired once. Return the list of these pairs as strings. If there are multiple pairs, return them in the order they appear in the array. If there are no pairs, return an empty list.","solution":"def find_pairs(arr, x): Returns a list of strings where each string is a pair of integers from arr that sum up to x. result = [] left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == x: result.append(f\\"{arr[left]}+{arr[right]}\\") left += 1 right -= 1 elif current_sum < x: left += 1 else: right -= 1 return result"},{"question":"You are given an array `nums` of integers, and an integer `k`. You need to divide the array into one or more subsequences such that the difference between the maximum and minimum values in each subsequence is at most `k`. Return the minimum number of subsequences you need to achieve this.","solution":"def min_subsequences(nums, k): Returns the minimum number of subsequences required such that the difference between the maximum and minimum values in each subsequence is at most k. if not nums: return 0 nums.sort() # Sort the array subsequences = 1 # Initialize the number of subsequences start = 0 # Start of the current subsequence for i in range(1, len(nums)): # If the difference between current element and the start of the subsequence is more than k if nums[i] - nums[start] > k: subsequences += 1 # Need a new subsequence start = i # Update the start of the new subsequence return subsequences"},{"question":"You are given a list of integers `nums`, which contains both positive and negative integers. Your task is to find the **subarray** (contiguous elements) which has the maximum sum among all subarrays. Return _the sum of this subarray_.","solution":"def max_subarray_sum(nums): This function returns the maximum sum of a contiguous subarray. :param nums: List[int] - a list of integers. :return: int - the maximum sum of a contiguous subarray. if not nums: return 0 max_current = max_global = nums[0] for number in nums[1:]: max_current = max(number, max_current + number) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. A subsequence of `nums` is called **unique** if it contains no duplicate elements. Return _the **maximum** possible length of a **unique** subsequence_ that can be formed by removing at most `k` elements from `nums`.","solution":"def max_unique_length(nums, k): Returns the maximum possible length of a unique subsequence that can be formed by removing at most k elements from nums. n = len(nums) if n == 0: return 0 # Count the frequency of each element in nums freq = {} for num in nums: if num in freq: freq[num] += 1 else: freq[num] = 1 # Count the number of unique elements unique_count = len(freq) # If the number of unique elements is greater or equal to n - k, # then we can obtain a unique subsequence by removing at most k elements if unique_count >= n - k: return unique_count # Otherwise, find how many more elements need to be removed to make the subsequence unique duplicated_count = n - unique_count return min(unique_count + k, n)"},{"question":"Given a 2D grid of characters and a list of words, return the list of words that can be found in the grid. A word can be formed by moving left, right, up, or down from a starting position, and each cell can be used only once per word. The same word can appear multiple times at different positions, but each occurrence must be a separate instance in the grid traversal. The board and words\' standard constraints apply.","solution":"def findWords(board, words): def backtrack(x, y, word): if not word: return True if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] != word[0]: return False temp = board[x][y] board[x][y] = \\"#\\" found = (backtrack(x+1, y, word[1:]) or backtrack(x-1, y, word[1:]) or backtrack(x, y+1, word[1:]) or backtrack(x, y-1, word[1:])) board[x][y] = temp return found found_words = set() for word in words: word_found = False for i in range(len(board)): for j in range(len(board[0])): if backtrack(i, j, word): found_words.add(word) word_found = True break if word_found: break return list(found_words)"},{"question":"Given a string `s` consisting of lowercase English letters, determine the minimum number of letters you need to remove from the string so that the remaining string does not contain any two identical consecutive letters. For example, if `s = \\"aaabbb\\"`, you need to remove at least 4 characters (`2 \'a\'s` and `2 \'b\'s`) to make the string \\"ab\\" which does not contain any two identical consecutive letters. Return the integer representing the minimum number of deletions needed.","solution":"def min_deletions_to_avoid_repeated_letters(s): Given a string `s`, determine the minimum number of letters to remove so that no two identical consecutive letters remain. Arguments: s: str - Input string consisting of lowercase English letters Returns: int - Minimum number of deletions needed deletions = 0 prev_char = \'\' for char in s: if char == prev_char: deletions += 1 else: prev_char = char return deletions"},{"question":"Given a list of integers `A`, find the length of the longest contiguous subarray such that the absolute difference between the maximum and minimum elements in this subarray is less than or equal to `K`. Return the length of this subarray. Note that the absolute difference of two numbers `a` and `b` is defined as `|a - b|`.","solution":"def longest_subarray(A, K): Given a list of integers A, find the length of the longest contiguous subarray such that the absolute difference between the maximum and minimum elements in this subarray is less than or equal to K. Parameters: A (list): List of integers. K (int): Maximum allowed absolute difference. Returns: int: Length of the longest contiguous subarray. if not A: return 0 max_len = 0 start = 0 min_queue, max_queue = [], [] for end in range(len(A)): while min_queue and A[min_queue[-1]] >= A[end]: min_queue.pop() while max_queue and A[max_queue[-1]] <= A[end]: max_queue.pop() min_queue.append(end) max_queue.append(end) while A[max_queue[0]] - A[min_queue[0]] > K: start += 1 if min_queue[0] < start: min_queue.pop(0) if max_queue[0] < start: max_queue.pop(0) max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given a string `s` containing only the characters \'a\' and \'b\', you are allowed to perform the following operation any number of times: choose two **adjacent** characters and replace them with their **lexicographically smallest character**. By performing this operation, find the **shortest possible** string that can be obtained. Return the result as a string.","solution":"def shorten_string(s): Given a string containing only characters \'a\' and \'b\', perform operations to replace two adjacent characters with their lexicographically smallest character to get the shortest possible string. stack = [] for char in s: if stack and char == stack[-1]: continue stack.append(char) return \'\'.join(stack)"},{"question":"Given an `n` x `n` grid consisting of non-negative integers, determine the minimum cost to traverse from the top-left corner to the bottom-right corner. You can move in four possible directions: up, down, left, and right. You need to ensure that you are always moving within the boundaries of the grid. Return the minimum cost to reach the bottom-right corner from the top-left corner.","solution":"import heapq def min_traverse_cost(grid): Determines the minimum cost to traverse from the top-left corner to the bottom-right corner of an n x n grid consisting of non-negative integers. Movement is restricted to up, down, left, and right. Args: grid (List[List[int]]): 2D list representing the grid. Returns: int: Minimum cost to reach the bottom-right corner from the top-left corner. n = len(grid) if n == 0 or len(grid[0]) == 0: return 0 # Directions for moving in four possible directions - right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Min-heap to store (cost, x, y) min_heap = [(grid[0][0], 0, 0)] costs = {(0, 0): grid[0][0]} while min_heap: current_cost, x, y = heapq.heappop(min_heap) # If we have reached the bottom-right corner if x == n-1 and y == n-1: return current_cost for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < n: new_cost = current_cost + grid[nx][ny] if (nx, ny) not in costs or new_cost < costs[(nx, ny)]: costs[(nx, ny)] = new_cost heapq.heappush(min_heap, (new_cost, nx, ny)) return -1 # Return -1 if there\'s no possible path (shouldn\'t happen with valid input)"},{"question":"You\'re given a two-dimensional list of integers called `grid` where each integer `grid[i][j]` represents the cost of stepping on the cell `(i, j)`. You can move to any adjacent cell directly above, below, left, or right of your current position. Starting from the top-left cell `(0, 0)`, return the minimum cost to reach the bottom-right cell `(m-1, n-1)`. For example, if `grid` is: ```plaintext [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ``` The minimum cost path would be `1 -> 3 -> 1 -> 1 -> 1`, totaling `7`.","solution":"def min_path_cost(grid): Returns the minimum cost to reach the bottom-right cell from the top-left cell. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1]"},{"question":"Given a string `s` containing only lowercase English letters and a separate character `c` that is guaranteed to be in the string, return _an array of integers_ representing the shortest distance from each character in the string to the character `c`. The distance between two indices `i` and `j` is `|i - j|`, where `|x|` denotes the absolute value of `x`.","solution":"def shortest_to_char(s, c): Returns an array of integers representing the shortest distance from each character in the string to the given character c. n = len(s) distances = [0] * n prev = float(\'-inf\') # Forward pass to find shortest distances from the left for i in range(n): if s[i] == c: prev = i distances[i] = i - prev prev = float(\'inf\') # Backward pass to find shortest distances from the right for i in range(n-1, -1, -1): if s[i] == c: prev = i distances[i] = min(distances[i], prev - i) return distances"},{"question":"You are given a string `s` consisting of lowercase English letters. A **duplicate removal operation** will be performed on `s`. In each duplicate removal operation, the longest contiguous subarray of identical characters will be removed from the string. You must repeatedly remove duplicates until no more operations can be performed. Return _the final string after all possible duplicate removals_. For example: - Input: `s = \\"abbaca\\"` - Output: `\\"ca\\"`","solution":"def removeDuplicates(s: str) -> str: Repeatedly removes the longest contiguous subarray of identical characters from s until no more operations can be performed and returns the final string. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given a rectangular cake represented as a 2D integer grid `cake` of size `h x w`. Each cell in the cake either contains a piece of chocolate (denoted by `1`) or is empty (denoted by `0`). You need to slice the cake into several rectangular pieces, such that each piece contains exactly one chocolate piece. You can only cut the cake along the lines between the cells (both horizontal and vertical cuts are allowed). Determine the minimum number of cuts needed to achieve this. If it is not possible to slice the cake in a way that each piece has exactly one chocolate, return -1.","solution":"def min_cuts(cake): h = len(cake) w = len(cake[0]) if h > 0 else 0 def is_feasible(): chocolate_count = sum(cake[i][j] for i in range(h) for j in range(w)) if chocolate_count == 0: return False for row in cake: if sum(row) > 1: return False for col in range(w): if sum(cake[row][col] for row in range(h)) > 1: return False return True if not is_feasible(): return -1 cuts = 0 # Horizontal cuts for i in range(h - 1): if sum(cake[i]) > 0 and sum(cake[i + 1]) > 0: cuts += 1 # Vertical cuts for j in range(w - 1): if sum(cake[i][j] for i in range(h)) > 0 and sum(cake[i][j + 1] for i in range(h)) > 0: cuts += 1 return cuts"},{"question":"You are given an **n x n** matrix containing integers, where each row and each column is sorted in **non-decreasing** order. Given a target integer, write a function to determine if the target exists in the matrix. You should return `true` if the target is found in the matrix, and `false` otherwise. Note: Try to design an efficient algorithm that minimizes the number of matrix elements accessed.","solution":"def search_matrix(matrix, target): Check if a target exists in an n x n matrix where each row and each column is sorted in non-decreasing order. Args: matrix (List[List[int]]): The n x n matrix target (int): The target value to search for Returns: bool: True if target is found, False otherwise if not matrix or not matrix[0]: return False # Start from the top-right corner of the matrix n = len(matrix) row, col = 0, n - 1 while row < n and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"Given an array of `n` integers `nums` representing the position of `n` coins placed on a number line, you need to choose two positions such that the absolute difference between the two positions is maximized while the sum of the coins at those positions is minimized. Return a tuple `(i, j)` where `0 <= i < j < n` representing the indices of the two chosen positions. Ensure the returned indices maximize the absolute difference between positions and have the smallest possible sum of the corresponding coins. If there are multiple such pairs, return the lexicographically smallest tuple.","solution":"def find_positions(nums): n = len(nums) if n < 2: raise ValueError(\\"The input array must contain at least two elements\\") min_sum = float(\'inf\') max_diff = 0 result = None for i in range(n): for j in range(i + 1, n): abs_diff = abs(nums[j] - nums[i]) current_sum = nums[i] + nums[j] if abs_diff > max_diff or (abs_diff == max_diff and current_sum < min_sum): max_diff = abs_diff min_sum = current_sum result = (i, j) return result"},{"question":"You are given a string `s` that consists of only digits. A valid encoding of `s` can be formed by mapping each digit from \'1\' to \'9\' to lowercase English letters \'a\' to \'i\' respectively. However, we can also map two consecutive digits (10 to 26) to lowercase English letters \'j\' to \'z\'. For example, the string \\"12\\" can be decoded as \\"ab\\" (1 -> \'a\', 2 -> \'b\') or \\"l\\" (12 -> \'l\'). Given a string `s`, return _the total number of ways to decode it_. Since the answer may be very large, return it **modulo** `10^9 + 7`.","solution":"MOD = 10**9 + 7 def num_decodings(s): Returns the number of ways to decode the string s. if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # Base case: an empty string has one way to decode it (doing nothing). for i in range(1, n + 1): if s[i - 1] != \'0\': dp[i] += dp[i - 1] if i > 1 and s[i - 2] == \'1\' or (s[i - 2] == \'2\' and s[i - 1] in \'0123456\'): dp[i] += dp[i - 2] dp[i] %= MOD return dp[n]"},{"question":"You are given an array of integers `heights` representing the heights of buildings aligned in a row. Each building is of unit width. The span of a building is the number of contiguous buildings (including itself) whose height is less than or equal to the height of that building. Write a function to return the spans of all the buildings. For example, given the input array `heights = [3, 2, 1, 4, 5]`, the output should be `[1, 1, 1, 4, 5]`. Note: The span of a building is the number of contiguous buildings up to and including that building, where each building in the span has a height less than or equal to the building being considered.","solution":"def calculate_spans(heights): Function to calculate the span of buildings based on their heights. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: list: A list of spans for each building. n = len(heights) spans = [1] * n # Initialize spans to 1 for each building for i in range(n): span = 1 while i - span >= 0 and heights[i - span] <= heights[i]: span += spans[i - span] spans[i] = span return spans"},{"question":"Given an integer array `arr` of `n` elements, write a function to find the **m** most frequently occurring elements. If there are multiple elements with the same frequency, prioritise the elements which appear first in `arr`. Return the elements in the order of their highest frequency. If `m` is greater than the number of unique elements in `arr`, return all unique elements.","solution":"from collections import Counter from heapq import nlargest def top_m_frequent_elements(arr, m): Returns the m most frequently occurring elements in arr. If there are elements with the same frequency, prioritize the ones which appear first. # Count the frequency of each element freq_counter = Counter(arr) # Create a list of elements with frequencies preserving the order of their first appearance unique_elements = list(dict.fromkeys(arr)) freq_list = [(elem, freq_counter[elem]) for elem in unique_elements] # Get the m elements with the highest frequency most_frequent_elements = nlargest(m, freq_list, key=lambda x: x[1]) # Extract and return the elements from the list of tuples return [elem[0] for elem in most_frequent_elements]"},{"question":"Given a list of non-negative integers `nums` and an integer `target`, implement a function that finds all unique combinations of elements in `nums` where the chosen numbers sum to `target`. The same repeated number may be chosen from `nums` an unlimited number of times. Return the list of all such unique combinations in any order. __Note__: - All numbers (including `target`) will be positive integers. - The solution set must not contain duplicate combinations. Example: ``` Input: nums = [2,3,6,7], target = 7 Output: [[7],[2,2,3]] ``` ``` Input: nums = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] ```","solution":"from typing import List def combinationSum(nums: List[int], target: int) -> List[List[int]]: def backtrack(remaining, combo, start): if remaining == 0: result.append(list(combo)) return elif remaining < 0: return for i in range(start, len(nums)): combo.append(nums[i]) backtrack(remaining - nums[i], combo, i) combo.pop() result = [] nums.sort() backtrack(target, [], 0) return result"},{"question":"Given a **0-indexed** integer array `nums` of size `n`, return an array of all the leaders in the array. An element is a leader if it is greater than all the elements to its right. The rightmost element is always a leader. For example: - Given nums = [16, 17, 4, 3, 5, 2], the leaders are [17, 5, 2]. - Given nums = [1, 2, 3, 4, 0], the leader is [4, 0]. Write a function: ```python def find_leaders(nums): # Your code goes here ```","solution":"def find_leaders(nums): Returns an array of all leaders in the given array A leader is an element that is greater than all the elements to its right. The rightmost element is always a leader. Parameters: nums (list): A list of integers Returns: list: A list of leader integers if not nums: # Handle empty list case return [] leaders = [] max_from_right = nums[-1] leaders.append(max_from_right) for i in reversed(range(len(nums) - 1)): if nums[i] > max_from_right: max_from_right = nums[i] leaders.append(max_from_right) return leaders[::-1] # Reversing to maintain the order from left to right in the original array"},{"question":"You are given an integer `n` representing the number of tasks and an array `tasks` of length `n`, where `tasks[i]` denotes the time required to complete the `i-th` task. Each task must be completed exactly once, and tasks can be worked on concurrently if they are executed by different workers. You have an infinite number of workers to assign the tasks to, and each worker can only work on one task at a time. Return the minimum time required to complete all the tasks.","solution":"def min_time_to_complete_tasks(tasks): Return the minimum time required to complete all the tasks. :param tasks: List[int] - list of integers where tasks[i] is the time required to complete the i-th task :return: int - minimum time required to complete all the tasks if not tasks: return 0 return max(tasks)"},{"question":"You are given a `nums` array representing ordered even numbers starting from 2 up to 2n, where `n` is the length of the array. Every number between 2 and 2n appears exactly once in the `nums` array. Your task is to find the median of this array. The median of an `n` element array sorted in ascending order is defined as: - If `n` is odd, the median is defined as the middle element, i.e., `nums[n//2]`. - If `n` is even, the median is the average of the two middle elements, i.e., `(nums[n//2 - 1] + nums[n//2]) / 2`. Return the median as an integer if it is whole, otherwise return it as a floating-point number rounded towards zero to one decimal place.","solution":"def find_median(nums): Returns the median of an ordered list of even numbers. Parameters: nums (list): List of even numbers Returns: float/int: The median of the list n = len(nums) if n % 2 == 1: # Odd length array return nums[n // 2] else: # Even length array, compute the median as the average of the two middle elements median = (nums[n // 2 - 1] + nums[n // 2]) / 2 # Return as integer if whole, otherwise return as floating-point number return int(median) if median.is_integer() else round(median, 1)"},{"question":"Given a string `s` containing only digits, return the number of ways to decode it. A valid decoding follows the rules similar to the A1Z26 cipher, where `1` maps to `\'A\'`, `2` maps to `\'B\'`, ..., `26` maps to `\'Z\'`. For example: - `\\"12\\"` can be decoded as `\\"AB\\"` (1 2) or `\\"L\\"` (12), therefore it has 2 ways to be decoded. Note: - The length of `s` will be in the range `[1, 100]`. - The input string does not contain any leading zeros. All input will be valid strings.","solution":"def num_decodings(s): Returns the number of ways to decode the string \'s\'. if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != \'0\': dp[i] += dp[i - 1] if i != 1 and \'10\' <= s[i-2:i] <= \'26\': dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given an n x n 2D matrix `grid` containing integer values. A path from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1) of the grid is defined as a series of moves in the right or down direction only, starting from the top-left corner. Each move has an associated cost equal to the integer value in the cell being moved to. Calculate the minimum cost to traverse from the top-left corner to the bottom-right corner. For example, if the grid is: ``` [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ``` The minimum cost path would be 1 → 3 → 1 → 1 → 1, with a total cost of 7. Return the minimum cost to reach the bottom-right corner of the grid.","solution":"def min_cost_path(grid): Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. grid: List[List[int]] - 2D matrix containing integer values. if not grid or not grid[0]: return 0 n = len(grid) # Initialize a 2D dp array with the same dimensions as grid dp = [[0] * n for _ in range(n)] # Start at the top-left corner dp[0][0] = grid[0][0] # Fill the first row for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] # Fill the first column for j in range(1, n): dp[j][0] = dp[j-1][0] + grid[j][0] # Fill in the rest of the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the minimum cost return dp[n-1][n-1]"},{"question":"You are given a list of `n` integers called `heights`, where `heights[i]` represents the height of the `i-th` building. A building has a \\"// rooftop garden\\" if the building is taller than the building immediately to its right. Return the number of buildings that have a rooftop garden.","solution":"def count_rooftop_gardens(heights): Returns the number of buildings that have a rooftop garden. A building has a rooftop garden if it is taller than the building immediately to its right. rooftop_count = 0 n = len(heights) for i in range(n - 1): if heights[i] > heights[i + 1]: rooftop_count += 1 return rooftop_count"},{"question":"Given a list of words, `words`, determine if the words can form a circle. A list of words forms a circle if the last character of a word is the same as the first character of the next word, and the last character of the last word is the same as the first character of the first word. Return `true` if such an arrangement exists, otherwise return `false`.","solution":"def can_form_circle(words): Returns True if the list of words can form a circle, otherwise False. Each word\'s last character must match the first character of the next word, and the last word\'s last character must match the first character of the first word. from collections import defaultdict, deque if not words: return False graph = defaultdict(list) start_counts = defaultdict(int) end_counts = defaultdict(int) for word in words: first_char = word[0] last_char = word[-1] graph[first_char].append(last_char) start_counts[first_char] += 1 end_counts[last_char] += 1 # Ensure that the number of words starting with and ending with each character is the same if start_counts != end_counts: return False def is_strongly_connected(start_node): visited = set() stack = [start_node] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(graph[node]) return len(visited) == len(graph) start_node = words[0][0] return is_strongly_connected(start_node)"},{"question":"You are given a list of words `words` and a target word `target`. The target word can be formed by concatenating words from the list `words`, where each word in `words` can be used multiple times. Return the minimum number of words required to form the target word. If it is not possible to form the target word, return `-1`. Note that all words, including the target, consist of lowercase English letters only.","solution":"def min_words_to_form_target(words, target): from collections import deque, defaultdict word_set = set(words) queue = deque([(target, 0)]) visited = set() while queue: current, steps = queue.popleft() if current == \\"\\": return steps for word in word_set: if current.startswith(word): new_target = current[len(word):] if new_target not in visited: visited.add(new_target) queue.append((new_target, steps + 1)) return -1"},{"question":"You are given a string `s` consisting of lowercase English letters. A transformation on the string involves picking any non-empty substring and replacing all of its characters with any single letter. The transformation cost is equal to the length of the substring being replaced. Your task is to determine the **minimum cost** required to transform the string `s` such that no two adjacent characters are the same.","solution":"def minimum_cost_to_transform(s): Determines the minimum cost required to transform the string `s` such that no two adjacent characters are the same. n = len(s) if n == 0: return 0 # The minimum cost is the number of adjacent identical characters. cost = 0 for i in range(1, n): if s[i] == s[i - 1]: cost += 1 return cost"},{"question":"You are given a list of `people` represented by their heights in centimeters. Each element in the list is a pair `(height, in_front)`, where `height` denotes the height of the person, and `in_front` is the number of people in front of this person who have a height greater than or equal to `height`. Reconstruct and return the list representing the queue sorted by their heights and positions such that the condition for each `in_front` is satisfied. Assemble the queue according to the given heights and in_front values. Return _the reconstructed queue as a list of pairs_.","solution":"def reconstruct_queue(people): # Sort people by height in descending order. If heights are equal, sort by in_front in ascending order. people.sort(key=lambda x: (-x[0], x[1])) result = [] # Insert each person into the result list at the index specified by in_front for person in people: result.insert(person[1], person) return result"},{"question":"You are given a list of `n` strings where each string represents a valid integer, but the ordering of these integers is scrambled. Your task is to sort these strings such that they represent a sequence of integers in non-decreasing order. The function should take a list of strings and return the sorted list of strings. Here is the function signature: ```python def sort_strings_as_integers(string_list: List[str]) -> List[str]: # Your code here ``` **Example:** ```python Input: [\\"10\\", \\"2\\", \\"3\\", \\"1\\"] Output: [\\"1\\", \\"2\\", \\"3\\", \\"10\\"] Input: [\\"21\\", \\"4\\", \\"20\\", \\"15\\"] Output: [\\"4\\", \\"15\\", \\"20\\", \\"21\\"] Input: [\\"5\\"] Output: [\\"5\\"] ``` **Note:** - The input list will have at least one string. - Each string represents a valid integer.","solution":"def sort_strings_as_integers(string_list): Sorts a list of strings where each string represents an integer. Returns the sorted list of strings. # Convert the list of strings to a list of integers for sorting int_list = [int(s) for s in string_list] # Sort the integers int_list.sort() # Convert the sorted list of integers back to strings sorted_string_list = [str(i) for i in int_list] return sorted_string_list"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. The goal is to construct a new string by rearranging the characters of `s` such that no two adjacent characters are the same. Additionally, if it is impossible to rearrange the characters satisfying this condition, return an empty string. If the rearrangement is possible, the new string should be returned. Implement a function that returns the rearranged string or an empty string based on the given conditions.","solution":"import heapq from collections import Counter def rearrange_string(s: str, k: int) -> str: Rearranges the string `s` such that no two adjacent characters are the same. If such an arrangement is not possible, returns an empty string. if k == 0: return s # if k is 0, no restriction on adjacent characters char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((count + 1, char)) if len(wait_queue) < k: continue front = wait_queue.pop(0) if front[0] < 0: heapq.heappush(max_heap, front) rearranged_string = \'\'.join(result) if len(rearranged_string) != len(s): return \\"\\" return rearranged_string"},{"question":"You are given a string `s` consisting of lowercase English letters and an array `indices` of the same length as `s`. The `indices` array is a permutation of `[0, 1, ..., len(s) - 1]`. Your task is to reorder the characters in `s` such that the `i-th` character moves to `indices[i]` in the resulting string. Implement the function `StringReorder` that takes in the string `s` and the array `indices` and returns the reordered string. * `StringReorder(String s, int[] indices)` - Reorders the characters in `s` according to `indices` and returns the new string.","solution":"def StringReorder(s, indices): Reorders the characters in s according to indices. Parameters: s (str): The input string. indices (list of int): The indices array representing the new order. Returns: str: The reordered string. # Initialize an empty list of the same length as the input string result = [\'\'] * len(s) # Populate the result list according to the indices array for i, index in enumerate(indices): result[index] = s[i] # Join and return the list as a string return \'\'.join(result)"},{"question":"Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. After removing the duplicates, return the length of the modified array. Do not allocate extra space for another array; you must do this by modifying the input array in-place with constant extra memory. Implement the function: ```python def removeDuplicates(nums: List[int]) -> int: # function implementation ``` **Example:** ``` Input: nums = [1, 1, 2, 2, 3, 4] Output: 4 Reason: The array is modified to be [1, 2, 3, 4, _, _]. The length of the modified array is 4. ``` **Note:** - Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory. - The problem should still work even if there are multiple duplicate numbers.","solution":"from typing import List def removeDuplicates(nums: List[int]) -> int: if not nums: return 0 # Initialize the write index to 1 write_index = 1 # Start from the second element of the array for i in range(1, len(nums)): # If the current element is not equal to the element before it, it is unique if nums[i] != nums[i - 1]: # Write the unique element at write_index and advance write_index nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"You are given two strings `s` and `t` of length `n` consisting of lowercase letters. You can perform the following operations on `s` any number of times: 1. Swap any two characters of `s`. 2. Choose any character of `s` and replace it with any other lowercase letter. Your goal is to transform `s` into `t` using the minimum number of operations. Return _the minimum number of operations required to make the strings equal_.","solution":"def min_operations_to_transform(s, t): Calculates the minimum number of operations required to transform string s into string t. Parameters: s (str): Source string. t (str): Target string. Returns: int: Minimum number of operations required to make the strings equal. # Initialize an array to count the frequency of each character (26 lowercase letters). freq_s = [0] * 26 freq_t = [0] * 26 # Calculate the frequency of each character in s and t. for i in range(len(s)): freq_s[ord(s[i]) - ord(\'a\')] += 1 freq_t[ord(t[i]) - ord(\'a\')] += 1 # Calculate the number of changes needed. operations = 0 for i in range(26): if freq_s[i] > freq_t[i]: operations += freq_s[i] - freq_t[i] return operations"},{"question":"You are given an array of integers `arr` of length `n` and an integer `k`. You must perform the following operation exactly `k` times: choose any subarray of `arr` and reverse it. After performing the operations, return the lexicographically smallest array possible. A subarray is a contiguous part of an array. An array `a` is lexicographically smaller than an array `b` if at the first position where `a` and `b` differ, array `a` has a smaller element than the corresponding element in array `b`.","solution":"def minimize_array_lexicographically(arr, k): Returns the lexicographically smallest array possible after exactly k reversals. n = len(arr) # Not enough operations, sort the whole array if k >= n: return sorted(arr) # If k is at least 2, we can sort the entire array # Explanation: We can achieve any possible permutation of the array by reversing subarrays twice if k >= 2: return sorted(arr) # With k = 1, we must identify optimal single reversal min_array = arr[:] for i in range(n): for j in range(i, n): reversed_subarray = arr[:i] + arr[i:j+1][::-1] + arr[j+1:] if reversed_subarray < min_array: min_array = reversed_subarray return min_array"},{"question":"You are given an array `nums` consisting of `n` positive integers and an integer `target`. You are allowed to reorder the elements of the array in any way you want. You need to find the minimum number of adjacent swaps required to make the sum of the array at least `target`. If it\'s not possible to achieve the target sum, return `-1`.","solution":"def min_adj_swaps_to_target(nums, target): Returns the minimum number of adjacent swaps required to make the sum of the array at least target. If it\'s not possible to achieve the target sum, return -1. current_sum = sum(nums) if current_sum < target: return -1 nums.sort(reverse=True) current_sum = 0 count = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum >= target: count = i + 1 break # Determining the minimum number of adjacent swaps swaps = sum(range(count)) return swaps"},{"question":"You are given a list of `n` integers `arr`, and an integer `k`. You need to determine if it\'s possible to make all the elements of the list equal through the following operation: in one operation, you can pick any subsequence of `k` elements from `arr` and increment each element of the subsequence by `1`. Return `true` if it\'s possible to make all elements equal, otherwise return `false`.","solution":"def can_make_elements_equal(arr, k): Determines if it\'s possible to make all elements of the list equal using the given operation. :param arr: List[int] - the list of integers :param k: int - the number of elements to increment in one operation :return: bool - True if possible to make all elements equal, otherwise False unique_elements = set(arr) # If all elements are already equal, return True if len(unique_elements) == 1: return True # If k is 1 and there are different elements, we can\'t make all equal if k == 1: return False sorted_elements = sorted(unique_elements) for i in range(1, len(sorted_elements)): if (sorted_elements[i] - sorted_elements[i-1]) % k != 0: return False return True"},{"question":"You are given a string `expression` containing digits and operations `+`, `-`, `*`, and `/`. The operations should follow the standard rules of arithmetic precedence. Implement the function `calculate` that evaluates the expression and returns its value. It is guaranteed that the given expression is valid and does not contain any spaces. Additionally, assume that division is integer division, hence fractions should be truncated towards zero.","solution":"def calculate(expression): Evaluate a given arithmetic expression string and return its integer result. Operations follow the standard rules of arithmetic precedence. Division is integer division. import re tokens = re.findall(r\'d+|[-+*/()]\', expression) precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} def shunting_yard(tokens): output = [] operators = [] for token in tokens: if token.isdigit(): output.append(int(token)) elif token in precedence: while (operators and operators[-1] != \'(\' and precedence[token] <= precedence[operators[-1]]): output.append(operators.pop()) operators.append(token) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': output.append(operators.pop()) operators.pop() while operators: output.append(operators.pop()) return output def eval_rpn(tokens): stack = [] for token in tokens: if isinstance(token, int): stack.append(token) else: b, a = stack.pop(), stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(float(a) / b)) # truncating towards zero return stack[0] rpn = shunting_yard(tokens) return eval_rpn(rpn)"},{"question":"You are given an integer `n` representing the total number of stones and an integer array `piles` of length `m`, where each element in `piles` represents the number of stones in that pile. You may choose any pile and take any positive number of stones from that pile. However, if you want to take stones from a pile, you need to take at least as many stones as there are in the smallest pile among the remaining piles. Return the **minimum** number of moves required to take all stones given these conditions. A move consists of taking stones from one pile.","solution":"def min_moves_to_take_all_stones(n, piles): # Sort the piles to simplify the process of finding the smallest remaining pile piles.sort() moves = 0 for i in range(len(piles)): # Since we\'re always taking stones from the smallest or larger remaining piles # the number of stones we take in each move is piles[i] moves += 1 # Remove piles[i] from all piles (since we took at least piles[i] stones from each of the remaining piles) piles = [p - piles[i] for p in piles[i+1:]] return moves"},{"question":"You are given an integer array `nums` sorted in non-decreasing order, and an integer `target`. Write a function that returns the indices of the two numbers such that they add up to `target`. Return the indices in a list `[i, j]` (where `i < j`). If such numbers do not exist, return `[-1, -1]`. Your solution should have a time complexity of `O(n)` and should utilize the fact that the array is sorted. Avoid using the same element twice.","solution":"def two_sum_sorted(nums, target): This function returns the indices of the two numbers such that they add up to the target. The input array nums is sorted in non-decreasing order. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 return [-1, -1]"},{"question":"Given a 2D grid of size `m x n` representing a map where `1` represents land and `0` represents water, count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You can assume all four edges of the grid are surrounded by water. Implement a function `numIslands(grid)` that returns the number of islands in the grid. **Note**: - You may assume that all four edges of the grid are surrounded by water. - An island is an area of connected land cells (1s) surrounded by water cells (0s). - You may use either depth-first search (DFS) or breadth-first search (BFS) to solve this problem.","solution":"def numIslands(grid): Return the number of islands in the given grid. if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == \'0\' or visited[x][y]: return visited[x][y] = True dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count"},{"question":"Given an array of integers `arr` and an integer `target`, return all unique pairs of elements (a, b) from the array such that a + b equals `target`. Each pair (a, b) and (b, a) should be considered the same and should not be duplicated. Return the pairs in any order.","solution":"def two_sum_pairs(arr, target): Returns a list of unique pairs (a, b) from the array such that a + b equals target. Each pair (a, b) and (b, a) should be considered the same and should not be duplicated. Args: arr (list of int): The input array of integers. target (int): The target sum. Returns: list of tuple of int: The list of unique pairs. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return list(pairs)"},{"question":"You are given an array `nums` of integers and an integer `k`. Your task is to count the number of **distinct** elements in the array that appear **exactly** `k` times. Return _the count of these distinct elements_. For example, given `nums = [1,2,2,3,3,3,4,4,4,4]` and `k = 2`, the function should return `1` since only the integer `2` appears exactly `k` times.","solution":"def count_elements_with_exactly_k_occurrences(nums, k): Returns the number of distinct elements in the array that appear exactly k times. from collections import Counter element_counts = Counter(nums) return sum(1 for count in element_counts.values() if count == k)"},{"question":"Given a non-negative integer `n`, calculate the number of distinct ways to climb a staircase with `n` steps. You can climb either 1 step, 2 steps, or 3 steps at a time. Return the number of distinct ways to reach the top.","solution":"def climb_stairs(n): Returns the number of distinct ways to climb a staircase with n steps, given that you can climb 1, 2, or 3 steps at a time. if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"Write a function `findLadders` that finds all **shortest transformation sequences** from `beginWord` to `endWord`, given a dictionary `wordList`. Each transformed word must exist in the word list. Note that `beginWord` is not a transformed word. Each transformation must change exactly one letter. For example, given: * beginWord = \\"hit\\" * endWord = \\"cog\\" * wordList = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"] The two shortest transformation sequences are: [ [\\"hit\\",\\"hot\\",\\"dot\\",\\"dog\\",\\"cog\\"], [\\"hit\\",\\"hot\\",\\"lot\\",\\"log\\",\\"cog\\"] ] Return a list of all such sequence lists of the shortest length. If there is no valid path from `beginWord` to `endWord`, return an empty list. You may assume that no duplicates exist in the `wordList`. Implement the `findLadders` function: * `List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList)` - returns a list of all the shortest transformation sequences from `beginWord` to `endWord`.","solution":"from collections import defaultdict, deque def findLadders(beginWord, endWord, wordList): if endWord not in wordList: return [] wordList = set(wordList) wordList.add(beginWord) # Create a map to store the graph neighbors = defaultdict(list) # Build the adjacency list def buildGraph(): for word in wordList: for i in range(len(word)): pattern = word[:i] + \'*\' + word[i+1:] neighbors[pattern].append(word) buildGraph() # BFS to find the shortest paths def bfs(): queue = deque([[beginWord]]) visited = set([beginWord]) found = False while queue and not found: local_visited = set() for _ in range(len(queue)): path = queue.popleft() word = path[-1] for i in range(len(word)): pattern = word[:i] + \'*\' + word[i+1:] for neighbor in neighbors[pattern]: if neighbor == endWord: found = True results.append(path + [endWord]) if neighbor not in visited: local_visited.add(neighbor) queue.append(path + [neighbor]) visited.update(local_visited) results = [] bfs() return results"},{"question":"You are given a list of integers `weights` where each integer represents the weight of a different box, and a limit `maxWeight` which represents the maximum weight that any single container can hold. Your task is to find out the minimum number of containers needed to transport all the boxes, such that the sum of weights in each container does not exceed `maxWeight`. A container can hold any number of boxes as long as their total weight is within the limit. Write a function `minContainers(weights: List[int], maxWeight: int) -> int` that returns the minimum number of containers required. **Example:** ``` weights = [1, 2, 3, 4, 5] maxWeight = 5 Output: 3 ``` In this example, the minimum number of containers required could be `3`: - Container 1: [1, 4] - Container 2: [2, 3] - Container 3: [5]","solution":"from typing import List def minContainers(weights: List[int], maxWeight: int) -> int: Returns the minimum number of containers required to transport all the boxes. # If there are no weights, no container is needed if not weights: return 0 # Sort weights in descending order for optimal packing weights.sort(reverse=True) containers = 0 while weights: current_weight = 0 i = 0 while i < len(weights): # Try to add the heaviest available weight that fits in the current container if current_weight + weights[i] <= maxWeight: current_weight += weights.pop(i) else: i += 1 containers += 1 return containers"},{"question":"Given a string `s` consisting of only lowercase alphabets, find the length of the longest substring that can be made by deleting at most `k` characters. The characters in the resulting substring can appear in any order, but they must not exceed the frequency of the original string. If the result is an empty string, return 0.","solution":"def longest_substring_with_k_deletions(s, k): This function finds the length of the longest substring that can be made by deleting at most k characters. :param s: The input string consisting of only lowercase alphabets :param k: The number of characters that can be deleted :return: The length of the longest possible substring from collections import defaultdict char_count = defaultdict(int) for char in s: char_count[char] += 1 sorted_chars = sorted(char_count.items(), key=lambda x: x[1], reverse=True) total_length = len(s) deletions = 0 for char, count in sorted_chars: if deletions + count <= k: deletions += count total_length -= count else: total_length -= (k - deletions) break return max(0, total_length)"},{"question":"Given a string `s` that contains parentheses and lowercase letters, return the minimum number of parentheses you need to add to make the parentheses balanced. Parentheses are considered balanced when: 1. Every opening parenthesis `(` has a corresponding closing parenthesis `)`. 2. `[()()]` is balanced, while `[(])` is not. For example: - Input: `s = \\"())\\"` - Output: `1` - Input: `s = \\"(((\\"` - Output: `3`","solution":"def min_add_to_make_valid(s): Returns the minimum number of parentheses needed to add to make the parentheses balanced in the given string s. open_needed = 0 close_needed = 0 for char in s: if char == \'(\': open_needed += 1 elif char == \')\': if open_needed > 0: open_needed -= 1 else: close_needed += 1 return open_needed + close_needed"},{"question":"You are given two strings `s` and `t` where `t` fits exactly into `s` (i.e., the lengths of `s` and `t` are the same). Your task is to determine if you can obtain string `t` by rotating string `s` in any direction (left or right) any number of times. Return a boolean value `true` if it is possible to obtain `t` by rotating `s`, otherwise return `false`.","solution":"def can_rotate_to_match(s, t): Determines if string `t` can be obtained by rotating string `s` in any direction. :param s: The source string. :param t: The target string that needs to be matched by rotation of `s`. :return: True if `t` can be obtained by rotating `s`, otherwise False. # Check if t is a substring of s + s return len(s) == len(t) and t in (s + s)"},{"question":"A **subtree** of a binary tree `T` is a tree consisting of a node in `T` and all of its descendants in `T`. Given the roots of two binary trees, `root` and `subRoot`, return _true if there is a subtree of_ `root` _with the same structure and node values as_ `subRoot` _and false otherwise_. A subtree of `root` is a tree that consists of a node in `root` and all of its descendants in `root`. The tree `root` could also be considered as a subtree of itself.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(s, t): if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) def is_subtree(root, subRoot): if not root: return False if is_same_tree(root, subRoot): return True return is_subtree(root.left, subRoot) or is_subtree(root.right, subRoot)"},{"question":"You are given a **linked list** where each node contains a positive integer value. Write a function `splitEvenOdd` that splits the linked list into two separate linked lists: one containing all the even-valued nodes and the other containing all the odd-valued nodes. The order of nodes in the two new linked lists should be the same as in the original linked list. Return the heads of the two new linked lists as a tuple. ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def splitEvenOdd(head: ListNode) -> Tuple[ListNode, ListNode]: # Implement your solution ``` For example, given the linked list `1 -> 2 -> 3 -> 4 -> 5`, the function should return two linked lists: - One containing the even values: `2 -> 4` - Another containing the odd values: `1 -> 3 -> 5`","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def splitEvenOdd(head: ListNode): if not head: return None, None even_dummy = ListNode() odd_dummy = ListNode() even_tail, odd_tail = even_dummy, odd_dummy current = head while current: if current.value % 2 == 0: even_tail.next = current even_tail = even_tail.next else: odd_tail.next = current odd_tail = odd_tail.next current = current.next # Terminate the new lists even_tail.next = None odd_tail.next = None return even_dummy.next, odd_dummy.next"},{"question":"You are given a list of `n` intervals where each interval represents booking requests. Each interval consists of a start and end time in the form of `[start_i, end_i]`. You need to determine the minimum number of conference rooms required to hold all the given booking requests. A booking request is represented by two integers `start_i` and `end_i`, where `0 <= start_i < end_i`. The number of intervals can be between `1` and `10^4` and the intervals can overlap.","solution":"def minConferenceRooms(intervals): Return the minimum number of conference rooms required to hold all booking requests. if not intervals: return 0 # Separate start and end times starts = sorted([interval[0] for interval in intervals]) ends = sorted([interval[1] for interval in intervals]) start_ptr, end_ptr = 0, 0 used_rooms = 0 max_rooms = 0 while start_ptr < len(starts): if starts[start_ptr] < ends[end_ptr]: used_rooms += 1 start_ptr += 1 else: used_rooms -= 1 end_ptr += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"You are given a list of `n` integers called `arr` and a target integer `x`. You need to determine if there exists a subsequence of `arr` whose sum is exactly `x`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return `true` if such a subsequence exists, otherwise return `false`.","solution":"def is_subsequence_sum(arr, x): Determines if there exists a subsequence of `arr` whose sum is exactly `x`. Parameters: arr (list of int): A list of integers. x (int): The target sum. Returns: bool: True if such a subsequence exists, otherwise False. n = len(arr) # Initialize a set containing the sum 0 (the empty subsequence sum) sums = {0} for num in arr: new_sums = set() for s in sums: new_sum = s + num if new_sum == x: return True new_sums.add(new_sum) sums.update(new_sums) # Check if x is in the final set of sums return x in sums"},{"question":"You are given an array of integers representing the heights of buildings situated in a straight line. Each building\'s height is non-negative. A building at position `i` can block the view of another building at position `j` if `i < j` and the height of the building at `i` is greater than or equal to the height of the building at `j`. Your task is to determine the number of buildings that have an unobstructed view to the right. An unobstructed view means that there is no building to the right which is taller or of the same height. Return the _number of buildings that have an unobstructed view to the right_.","solution":"def count_unobstructed_views(heights): Returns the count of buildings with unobstructed views to the right. :param heights: List[int], list of building heights :return: int, number of buildings with unobstructed views if not heights: return 0 buildings_with_view = 1 # The rightmost building always has an unobstructed view max_height = heights[-1] # Traverse the list from right to left for i in range(len(heights) - 2, -1, -1): if heights[i] > max_height: buildings_with_view += 1 max_height = heights[i] return buildings_with_view"},{"question":"You are given an array of integers `arr` representing the content of a circular queue. A circular queue works in a way such that the end of the queue is connected back to the front, forming a circle. Your task is to determine if there exists any index `i` in the array such that you can start from `arr[i]` and follow a sequence of `arr[arr[i]]` steps where each step moves you forward by the value at the current index, and eventually return to the starting index `i`. Return _true_ if such an index exists, otherwise return _false_.","solution":"def circular_array_loop_exists(arr): n = len(arr) def next_index(i): return (i + arr[i]) % n for i in range(n): # Using two pointers approach (slow and fast pointers) slow, fast = i, i while arr[slow] * arr[next_index(slow)] > 0 and arr[fast] * arr[next_index(fast)] > 0 and arr[next_index(fast)] * arr[next_index(next_index(fast))] > 0: slow = next_index(slow) fast = next_index(next_index(fast)) if slow == fast: # Check for cycle not consisting of a single element if slow == next_index(slow): break return True # Mark all the elements in the cycle as 0 slow = i while arr[slow] * arr[next_index(slow)] > 0: temp = slow slow = next_index(slow) arr[temp] = 0 return False"},{"question":"You are given an array `num` of positive integers where `num[i]` represents the i-th person\'s amount of money. Calculate the minimum number of moves required to make all the amounts of money equal, where a move is incrementing or decrementing any amount of money by 1. Return the number of moves needed to achieve this.","solution":"def min_moves_to_equalize(num): Calculate the minimum number of moves required to make all the amounts of money equal. A move is incrementing or decrementing any amount of money by 1. num.sort() median = num[len(num) // 2] moves = sum(abs(x - median) for x in num) return moves"},{"question":"You are given an integer array `nums`, and you need to determine if there exists a subset of `nums` that sums up to a given integer `target`. You should return `true` if such a subset exists and `false` otherwise. To accomplish this, you need to consider all the possible subsets of the array and check if any of them sums to the target value. * For example, given `nums = [1, 2, 3, 7]` and `target = 6`, one of the subsets that sum up to 6 is `[3, 3]`, so the result would be `true`. Return `true` if there exists a subset of `nums` that sums up to `target`, otherwise return `false`.","solution":"def subset_sum(nums, target): Determine if there\'s a subset of nums that sums up to target. :param nums: List of integers. :param target: Integer target sum. :return: True if a subset sums up to target, otherwise False. n = len(nums) # Create a 2D dp array where dp[i][j] will be True if there is a subset of # elements in the first i elements of nums that sum up to j. dp = [[False] * (target + 1) for _ in range(n + 1)] # There\'s always an empty subset that sum up to 0. for i in range(n + 1): dp[i][0] = True # Fill the dp array for i in range(1, n + 1): for j in range(1, target + 1): if nums[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] return dp[n][target]"},{"question":"You are given a `startWord` and a `targetWord`, both of which are strings. You may modify the `startWord` by changing exactly one of its characters to any other English letter. You need to determine if it is possible to transform the `startWord` into the `targetWord` by making this single operation. Implement a function `boolean canTransform(String startWord, String targetWord)` to achieve this: - `boolean canTransform(String startWord, String targetWord)`: returns `true` if `startWord` can be transformed into `targetWord` by changing exactly one character, otherwise returns `false`. Your code will be tested with various pairs of `startWord` and `targetWord`.","solution":"def can_transform(startWord, targetWord): Function to determine if `startWord` can be transformed into `targetWord` by changing exactly one character. Parameters: startWord (str): the starting word targetWord (str): the target word Returns: bool: True if transformation is possible, False otherwise. # If lengths are not equal, transformation is impossible if len(startWord) != len(targetWord): return False # Count the number of different characters diff_count = sum(1 for a, b in zip(startWord, targetWord) if a != b) # Exactly one character should differ return diff_count == 1"},{"question":"You are given a directed graph represented as a list of edges where `edges[i] = [ui, vi]` indicates a directed edge from node `ui` to node `vi`. The graph may contain cycles. Write an algorithm to check if the graph contains any cycles. If the graph has a cycle, return `true`; otherwise, return `false`. **Function Signature:** `def hasCycle(edges: List[List[int]]) -> bool:` **Input:** - `edges`: a list of lists, where each sub-list contains two integers representing a directed edge between two nodes. **Output:** - A boolean value indicating if the graph contains any cycle (`true` if there is a cycle, otherwise `false`).","solution":"from collections import defaultdict def hasCycle(edges): Determines if the graph has a cycle. :param edges: List of edges representing the graph :return: Boolean indicating if the graph has a cycle def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in adj_list[node]: if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False # Build the adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) visited = set() visiting = set() # Check all nodes, considering they can be disjoint all_nodes = set(adj_list.keys()).union(set([v for u, v in edges])) for node in all_nodes: if dfs(node): return True return False"},{"question":"You are given two arrays `arr1` and `arr2`, both of which consist of **non-negative integers**. The length of `arr1` is `m`, and the length of `arr2` is `n`. Given two integers `k1` and `k2`, merge the two arrays into one sorted array and return the `k1`-th smallest and the `k2`-th smallest elements from this merged array. Ensure that your solution is efficient and operates within reasonable time and space complexity constraints for large input sizes, as `m` and `n` can each be up to `10^5`. If `k1` or `k2` exceed the bounds of the merged array, handle the scenario accordingly.","solution":"def find_kth_elements(arr1, arr2, k1, k2): Merge two arrays, arr1 and arr2, into one sorted array and return the k1-th and k2-th smallest elements. Args: arr1 (list): First array of non-negative integers. arr2 (list): Second array of non-negative integers. k1 (int): The index (1-based) of the smallest element requested. k2 (int): The index (1-based) of the second smallest element requested. Returns: tuple: k1-th and k2-th smallest elements. If k1 or k2 are out of range, return (None, None). import heapq merged_length = len(arr1) + len(arr2) # Handle out of bounds indices if k1 > merged_length or k2 > merged_length: return None, None # use heapq to merge two sorted arrays efficiently merged = list(heapq.merge(arr1, arr2)) # Find the k1-th and k2-th smallest elements in the merged array kth_elements = (merged[k1 - 1], merged[k2 - 1]) return kth_elements"},{"question":"You are given a string `expression` that contains only digits (`0-9`) and the characters `\'+\'`, `\'-\'`, and `\'=\'`. The string represents a mathematical expression, where `\'=\'` indicates the result of the expression. For example, the string `\\"3+2-1=4\\"` represents the expression `3 + 2 - 1 = 4`. However, one digit in the expression is missing and replaced with a `\'?\'`. You need to determine the digit (`0-9`) that can replace `\'?\'` to make the expression correct. Return the missing digit as an integer. If no single digit can satisfy the equation, return `-1`. For instance, given `expression = \\"6+1?=10\\"`, the function should return 3, because replacing `\'?\'` with 3 gives `\\"6 + 13 = 19\\"`, which is true.","solution":"def find_missing_digit(expression): Finds the missing digit in an equation represented as a string, where the digit is replaced by \'?\'. left_expr, result = expression.split(\'=\') result = int(result) for digit in range(10): try_expr = left_expr.replace(\'?\', str(digit)) # Evaluate the left expression if eval(try_expr) == result: return digit return -1"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of trees in a forest. On each day, you can choose two distinct trees and remove the shorter tree. The cost of a removal operation is equal to the height of the removed tree. You are tasked with minimizing the total removal cost to achieve the forest containing only one tree. Return _the minimum total cost to achieve a forest with exactly one tree_.","solution":"def min_cost_to_one_tree(heights): Returns the minimum total cost to achieve a forest with exactly one tree. The cost of a removal operation is equal to the height of the removed tree. :param heights: List[int] - the heights of the trees :return: int - the minimum total cost # Sort the heights in ascending order heights.sort() # Initialize total cost total_cost = 0 # Add all heights excluding the largest one for height in heights[:-1]: total_cost += height return total_cost"},{"question":"You are given an array of strings `words` and an integer `k`. A string `s` is called k-odd symmetric if it reads the same backward when observed every k-th character starting from the first character. For example, given the string \\"abcdefg\\" and k=2, the k-odd symmetric view would be \\"aceg\\", which reads the same forward and backward. Your task is to identify all k-odd symmetric strings in the given `words` array and return a list of their indices. If no k-odd symmetric strings are found, return an empty list. The returned list should be in ascending order of the indices.","solution":"def is_k_odd_symmetric(s, k): Check if the string `s` is k-odd symmetric. k_odd_str = s[::k] return k_odd_str == k_odd_str[::-1] def find_k_odd_symmetric_indices(words, k): Identify and return indices of k-odd symmetric strings in the given `words` array. result = [] for i, word in enumerate(words): if is_k_odd_symmetric(word, k): result.append(i) return result"},{"question":"You are given an array of integers `tasks`, where `tasks[i]` represents the time in minutes needed to complete the `i`-th task. Each task falls into one of the following categories based on its time: - A **short** task which takes at most 10 minutes, - A **medium** task which takes more than 10 but at most 30 minutes, - A **long** task which takes more than 30 minutes. You want to arrange the tasks into groups where each group contains either only short tasks, only medium tasks, or only long tasks. Return the minimum number of groups needed to categorize all the tasks according to the aforementioned criteria. For example: - Input: `tasks = [5, 15, 12, 9, 45, 32, 12]` - Output: `4`","solution":"def min_groups(tasks): Returns the minimum number of groups needed to categorize all the tasks into short, medium, and long tasks. short_tasks = sum(1 for t in tasks if t <= 10) medium_tasks = sum(1 for t in tasks if 10 < t <= 30) long_tasks = sum(1 for t in tasks if t > 30) # Each group can only consist of short, medium, or long tasks return (1 if short_tasks > 0 else 0) + (1 if medium_tasks > 0 else 0) + (1 if long_tasks > 0 else 0)"},{"question":"You are given a binary tree in which each node contains an integer value. Design a method `findLevelSum` to calculate the sum of the values of all the nodes at a given level `k` of the binary tree. The root node is considered to be at level 1. If the level `k` does not exist in the tree, return 0. The tree is represented using the following class definition: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Implement the following function: ```python def findLevelSum(root: TreeNode, k: int) -> int: ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findLevelSum(root: TreeNode, k: int) -> int: if not root: return 0 if k == 1: return root.value level = 1 queue = [root] while queue: level_size = len(queue) if level == k: return sum(node.value for node in queue) for _ in range(level_size): current = queue.pop(0) if current.left: queue.append(current.left) if current.right: queue.append(current.right) level += 1 return 0"},{"question":"You are given an array of positive integers `heights` representing the heights of students standing in a row. Each student wants to see the board, but a taller student in front will block the view of shorter students behind. Return _the minimum number of students_ that need to be removed so that each student can see the board. Students are able to see the board if any student in front of them in the array has a height no greater than theirs.","solution":"def min_students_to_remove(heights): Returns the minimum number of students that need to be removed so that each student can see the board. if not heights: return 0 n = len(heights) dp = [1] * n # dp[i] will be the length of the longest non-decreasing subsequence ending at i for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) max_len = max(dp) return n - max_len"},{"question":"Given a **sorted** array of unique integers `arr` and an integer `target`, return a list of lists containing all pairs of integers from `arr` that sum up to `target`. Each pair in the list should be sorted in ascending order, and the list of pairs should also be sorted in ascending order based on the first element of the pair. If there are no such pairs, return an empty list.","solution":"def find_pairs_with_sum(arr, target): This function takes a sorted array of unique integers `arr` and an integer `target`. It returns a list of pairs from `arr` that sum up to `target`. pairs = [] left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: pairs.append([arr[left], arr[right]]) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return pairs"},{"question":"You are given an integer array `nums` and an integer `k`. The task is to find the maximum average value of any subarray with length exactly `k`. A subarray is a contiguous subsequence of the array. Return the maximum average value as a floating-point number. Note that answers within `10^-5` of the actual answer will be accepted.","solution":"def findMaxAverage(nums, k): Finds the maximum average value of any subarray with length exactly k. Parameters: nums (List[int]): List of integers. k (int): Length of the subarray. Returns: float: The maximum average value. n = len(nums) max_sum = current_sum = sum(nums[:k]) for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum / k"},{"question":"You are given a **0-indexed** array `nums` of length `n` consisting of distinct integers. Find and return the smallest missing positive integer greater than `n` that cannot be represented as a sum of any subset of the given array `nums`.","solution":"def smallest_missing_positive(nums): Returns the smallest missing positive integer greater than n that cannot be represented as a sum of any subset of the given array nums. nums.sort() sum_so_far = 0 for num in nums: if num > sum_so_far + 1: break sum_so_far += num return sum_so_far + 1"},{"question":"You are given a string `pattern` and a list of strings `words`. Implement a function that checks if `words` follow the same order as characters in `pattern`. Specifically, for every consecutive pair of characters in `pattern`, the corresponding words in `words` should have the same relative order. For example, if `pattern = \\"abba\\"` and `words = [\\"cat\\", \\"dog\\", \\"dog\\", \\"cat\\"]`, then the function should return `true` because the first and last characters of `pattern` are the same, corresponding to \\"cat\\" in `words`, and the middle characters are also the same, corresponding to \\"dog\\" in `words`. The function should return `false` if the order is not preserved. Consider edge cases like differing lengths of `pattern` and `words`, or empty inputs.","solution":"def follows_pattern(pattern, words): Checks if the list of words follows the same order as characters in the pattern. :param pattern: str, a string pattern :param words: list of str, a list of words :return: bool, True if words follow the pattern, False otherwise if len(pattern) != len(words): return False pattern_to_word = {} word_to_pattern = {} for p, w in zip(pattern, words): if p in pattern_to_word and pattern_to_word[p] != w: return False if w in word_to_pattern and word_to_pattern[w] != p: return False pattern_to_word[p] = w word_to_pattern[w] = p return True"},{"question":"Given an integer array `height` of length `n`, where `height[i]` represents the height of a tree at position `i`, return the maximum height difference between any two adjacent trees. The height difference is defined as the absolute difference between the heights of two adjacent trees. Write a function to find this maximum height difference.","solution":"def max_height_difference(height): Returns the maximum height difference between any two adjacent trees. :param height: List[int] - List of heights of the trees :return: int - Maximum height difference between any two adjacent trees if len(height) < 2: return 0 max_diff = 0 for i in range(1, len(height)): diff = abs(height[i] - height[i-1]) if diff > max_diff: max_diff = diff return max_diff"},{"question":"You are given a list of project completion times `projects`, where `projects[i]` is the time it takes to complete the `ith` project. Additionally, each project can only be worked on during a specific duration defined by `timeSlots`, a list of tuples where each tuple represents a different slot `(start, end)` indicating the inclusive starting and ending times within which a project can be worked on. Your task is to determine the **minimum number of time slots** required to complete all projects. If it is not possible to complete all the projects within the given time slots, return `-1`.","solution":"def min_time_slots(projects, timeSlots): Returns the minimum number of time slots required to complete all projects. If it is not possible to complete all the projects within the given time slots, return -1. # Sort projects and time slots by their durations projects.sort() sorted_time_slots = sorted(timeSlots, key=lambda x: x[1] - x[0]) slots_needed = 0 for project in projects: slot_found = False for i, timeSlot in enumerate(sorted_time_slots): if timeSlot[1] - timeSlot[0] + 1 >= project: slot_found = True sorted_time_slots.pop(i) break if not slot_found: return -1 slots_needed += 1 return slots_needed"},{"question":"You are given a grid consisting of 1s and 0s. A **block** is a contiguous group of 1s that are connected horizontally or vertically (not diagonally). Write a function that returns _the number of distinct blocks of 1s in the grid_. For example, in the following grid: ``` 1 0 0 1 1 1 0 0 0 0 1 0 0 1 1 1 ``` There are 3 distinct blocks of 1s.","solution":"def count_blocks(grid): Returns the number of distinct blocks of 1s in the grid. def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # mark the cell as visited moves = [(1, 0), (-1, 0), (0, 1), (0, -1)] for move in moves: dfs(grid, i + move[0], j + move[1]) if not grid: return 0 num_blocks = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(grid, i, j) num_blocks += 1 return num_blocks"},{"question":"Given an array of integers `nums`, you are tasked with implementing a data structure that supports the following operations: 1. `update(index, value)`: Update the value of the element at index `index` in `nums` to `value`. 2. `sumRange(left, right)`: Return the sum of the elements `nums[left] + nums[left+1] + ... + nums[right]`. You need to design a data structure that optimizes these operations. Implement the `NumArray` class: - `NumArray(int[] nums)` initializes the object with the integer array `nums`. - `void update(int index, int value)` updates the value of `nums[index]` to `value`. - `int sumRange(int left, int right)` returns the sum of the elements of `nums` between indices `left` and `right` inclusive (i.e., `sum(nums[left:right + 1])`). Your implementation should aim to achieve both `update` and `sumRange` operations in logarithmic time.","solution":"class NumArray: def __init__(self, nums): self.nums = nums self.n = len(nums) self.tree = [0] * (self.n + 1) for i in range(self.n): self._update_tree(i + 1, nums[i]) def _update_tree(self, index, value): while index <= self.n: self.tree[index] += value index += index & -index def update(self, index, val): old_val = self.nums[index] self.nums[index] = val self._update_tree(index + 1, val - old_val) def _query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def sumRange(self, left, right): return self._query(right + 1) - self._query(left)"},{"question":"You are given a list of non-negative integers `arr` and an integer `d`. We want to create a new list `newArr` where `newArr[i]` is the sum of `arr[i]` and all elements in `arr` that are within a distance `d` from `arr[i]`. Specifically, for each `i`, you need to add `arr[j]` to `newArr[i]` where `|i - j| <= d`. Write a function that takes this list and the integer `d` and returns the new list `newArr`. For example, if `arr = [1, 2, 3, 4]` and `d = 1`, then `newArr[0] = 1 + 2`, `newArr[1] = 1 + 2 + 3`, `newArr[2] = 2 + 3 + 4`, and `newArr[3] = 3 + 4`. The function should return: `[3, 6, 9, 7]`.","solution":"def create_new_arr(arr, d): Creates a new array where each element is the sum of arr[i] and all elements in arr that are within a distance d from arr[i]. Parameters: arr (list): List of non-negative integers d (int): Distance Returns: list: New list with the summed values n = len(arr) new_arr = [0] * n for i in range(n): for j in range(max(0, i - d), min(n, i + d + 1)): new_arr[i] += arr[j] return new_arr"},{"question":"You are given a binary string `s` consisting of only \'0\'s and \'1\'s. You can perform the following operation any number of times: select any substring of `s` that contains more \'1\'s than \'0\'s, and flip all the bits in this substring (change \'0\' to \'1\' and \'1\' to \'0\'). Return the minimum number of operations required to make the entire string contain only \'0\'s.","solution":"def min_operations_to_zero(s): Returns the minimum number of operations required to make the entire string contain only \'0\'s by selecting substrings that contain more \'1\'s than \'0\'s and flipping all the bits. # we count the number of 1s in the string ones_count = s.count(\'1\') # in the best case, each operation will flip a substring of form \'111...\', i.e., sequence of ones # so the minimum operations needed is the number of \'1\'s in the string return ones_count"},{"question":"Write a program that finds the **longest path** in a connected, undirected graph. The path you need to find should have the maximum number of vertices, and it should not form a cycle. The graph is represented by an integer `n` (the number of vertices) and a list of lists `edges`, where each inner list contains two integers representing an edge between two vertices. Implement a class `LongestPathInGraph` that provides the following methods: 1. `LongestPathInGraph(int n, List<List<Integer>> edges)`: Initializes the object with the number of vertices and the list of edges. 2. `List<Integer> findLongestPath()`: Returns the longest path as a list of vertices. If there are multiple longest paths, return any one of them. Ensure that you handle the edge cases, such as when the graph has only one vertex or it forms a single line without branching.","solution":"class LongestPathInGraph: def __init__(self, n, edges): self.n = n self.edges = edges self.graph = {i: [] for i in range(n)} for u, v in edges: self.graph[u].append(v) self.graph[v].append(u) self.visited = [False] * n self.longest_path = [] def findLongestPath(self): def dfs(node, path): self.visited[node] = True path.append(node) if len(path) > len(self.longest_path): self.longest_path = path[:] for neighbor in self.graph[node]: if not self.visited[neighbor]: dfs(neighbor, path) path.pop() self.visited[node] = False for i in range(self.n): dfs(i, []) return self.longest_path"},{"question":"You are given a list of `dailyTemperatures` representing the daily temperatures for `n` consecutive days. Write a function to find the number of days you would have to wait until a warmer temperature for each day. That is, given a list `dailyTemperatures`, for each day in the input, your function should output how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` instead. Implement the function `int[] dailyTemperatures(int[] temperatures)` where: - `temperatures` is an array of integers representing the daily temperatures. - Return an integer array answer such that answer[i] is the number of days you have to wait until a warmer temperature for day i. If there is no future day for which this is possible, return `0` for that day. The function should have a time complexity of O(n).","solution":"def dailyTemperatures(temperatures): Returns a list where each element signifies the number of days one needs to wait to encounter a warmer temperature. If a warmer temperature doesn\'t exist, it returns 0. Parameters: temperatures (list): A list of integers representing daily temperatures. Returns: list: A list where each element is the number of days to wait for a warmer temperature. n = len(temperatures) answer = [0] * n stack = [] # This will store indices of the temperatures list for i in range(n): # Compare current temperature with the temperatures pointed by indices in the stack while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"You are given a binary string `s` which contains only characters `\'0\'` and `\'1\'`. A binary string is considered **balanced** if the number of `\'0\'`s is equal to the number of `\'1\'`s in it. Find the maximum length of a **balanced** subarray within `s`. If no such subarray exists, return `0`.","solution":"def max_balanced_subarray_length(s): Returns the maximum length of a balanced subarray within the binary string s. A balanced subarray contains an equal number of \'0\'s and \'1\'s. count = 0 max_length = 0 index_map = {0: -1} # Maps net count of \'1\'s - \'0\'s to first occurrence index for i, char in enumerate(s): if char == \'1\': count += 1 else: count -= 1 if count in index_map: max_length = max(max_length, i - index_map[count]) else: index_map[count] = i return max_length"},{"question":"You are given a rectangular `grid` of size `m x n` initially filled with water. You are also given an array `coordinates` where each element is a pair representing the row and column indices of a point in the grid where land is added. Every time land is added, the newly formed island (a group of connected land cells) may connect with existing islands to form one bigger island. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You have to return an array of integers representing the number of islands after each addition of land. Implement the function `numIslands2(m: int, n: int, coordinates: List[List[int]]) -> List[int]` to solve the problem.","solution":"from typing import List def numIslands2(m: int, n: int, coordinates: List[List[int]]) -> List[int]: def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 if not coordinates: return [] parent = {} rank = {} grid = [[0 for _ in range(n)] for _ in range(m)] num_islands = 0 result = [] for x, y in coordinates: if grid[x][y] == 1: result.append(num_islands) continue grid[x][y] = 1 index = x * n + y parent[index] = index rank[index] = 0 num_islands += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: neighbor_index = nx * n + ny if find(parent, index) != find(parent, neighbor_index): union(parent, rank, index, neighbor_index) num_islands -= 1 result.append(num_islands) return result"},{"question":"You are given an array of integers `arr` and a positive integer `k`. Your task is to partition the array into `k` non-overlapping subarrays such that the maximum difference between the sum of any two subarrays is minimized. Return the minimum possible value of this maximum difference. Implement the `MinimizeDifference` class with the following functionality: - `MinimizeDifference(int[] arr, int k)` Initializes the object with the integer array `arr` and the integer `k`. - `int findMinimizedDifference()` Returns the minimized value of the maximum difference between the sums of any two subarrays resulting from the partition.","solution":"from typing import List class MinimizeDifference: def __init__(self, arr: List[int], k: int): self.arr = arr self.k = k def findMinimizedDifference(self) -> int: def canPartition(max_sum): current_sum, required_subarrays = 0, 1 for num in self.arr: if current_sum + num > max_sum: required_subarrays += 1 current_sum = num if required_subarrays > self.k: return False else: current_sum += num return True left, right = max(self.arr), sum(self.arr) while left < right: mid = (left + right) // 2 if canPartition(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an array `arr` of length `n` where `arr[i]` represents the height of a building at position `i`. A robot is initially placed at the start of this array (at position `0`). The robot can move to the right to the next building as long as the height of the next building is less than or equal to the height of the current building. Return _the **length of the longest path** the robot can take_ without violating this condition. Note that the robot can only move to the right.","solution":"def longest_path(arr): Returns the length of the longest path the robot can take. Args: arr (list): A list of integers where arr[i] represents the height of a building at position i. Returns: int: The length of the longest path the robot can take. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] <= arr[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Given a string `s`, your task is to reorder the string so that no two adjacent characters are the same. If it is possible to rearrange the string in this way, return any valid reordering. Otherwise, return an empty string. For example: - Input: `s = \\"aab\\"` - Output: `\\"aba\\"` - Input: `s = \\"aaab\\"` - Output: `\\"\\"` Your implementation should aim to create a function with the following signature (depending on the language you are using): - `string reorganizeString(string s)`","solution":"import heapq from collections import Counter def reorganizeString(s: str) -> str: Reorganize the string so that no two adjacent characters are the same. If it is not possible, return an empty string. counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, \'\' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char result_str = \'\'.join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"You are given a list of integers `heights` representing the height of trees in a forest. You are also given an integer `desired_height`. You are tasked with cutting trees such that the remaining heights of the trees are as close as possible to `desired_height`. If a tree\'s height is less than or equal to `desired_height`, you leave it unchanged. Otherwise, you reduce its height to `desired_height`. Return an integer array containing the heights of the trees after the cuts have been made.","solution":"def cut_trees_to_desired_height(heights, desired_height): Cuts trees to the desired height if they are taller than the desired height. Parameters: - heights: List[int], a list of integers representing the height of trees - desired_height: int, the target height to which taller trees should be cut Returns: - List[int]: a list of integers representing the heights of the trees after cutting return [min(height, desired_height) for height in heights]"},{"question":"You are given two strings `s1` and `s2` of the same length. You want to edit `s1` in such a way that it becomes a substring of `s2`. The allowed edit operation is changing any character of `s1` to any other character. You need to find the minimum number of edits required to turn `s1` into a substring of `s2`. Return the minimum number of edits required. If it\'s not possible, return -1.","solution":"def min_edits_to_substring(s1, s2): Returns the minimum number of edits required to turn s1 into a substring of s2. If it\'s not possible, returns -1. len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return -1 min_edits = float(\'inf\') for i in range(len_s2 - len_s1 + 1): current_edits = sum(1 for j in range(len_s1) if s1[j] != s2[i + j]) min_edits = min(min_edits, current_edits) return min_edits"},{"question":"You are given a `root` of a binary tree. The level of a node is defined as the distance from the root (who is at level 1). Return _the **maximum average** value of any level_ in the binary tree. The average value of a level is the sum of its nodes\' values divided by the number of nodes on that level.","solution":"from collections import deque, defaultdict class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maximum_average_level(root): if not root: return 0 queue = deque([(root, 1)]) level_sum = defaultdict(int) level_count = defaultdict(int) while queue: node, level = queue.popleft() level_sum[level] += node.val level_count[level] += 1 if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) max_average = float(\'-inf\') for level in level_sum: average = level_sum[level] / level_count[level] max_average = max(max_average, average) return max_average"},{"question":"You are given a `2D` list of integers `matrix` representing a grid of dimensions `m x n`. An island is a group of `1`s (representing land) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. The `perimeter` of an island is the total length of its boundary, defined as the length where the island is adjacent to the water or the grid\'s edge. Return _the perimeter of the largest island in the matrix_.","solution":"def island_perimeter(matrix): Returns the perimeter of the largest island in the matrix. def calculate_perimeter(x, y): if not (0 <= x < m and 0 <= y < n) or matrix[x][y] == 0: return 1 if matrix[x][y] == -1: return 0 matrix[x][y] = -1 perimeter = 0 perimeter += calculate_perimeter(x+1, y) perimeter += calculate_perimeter(x-1, y) perimeter += calculate_perimeter(x, y+1) perimeter += calculate_perimeter(x, y-1) return perimeter m, n = len(matrix), len(matrix[0]) max_perimeter = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: max_perimeter = max(max_perimeter, calculate_perimeter(i, j)) return max_perimeter"},{"question":"You are given an integer array `nums`. You need to modify the array in such a way that the **even** indexed elements (0, 2, 4, ...) should be sorted in **non-decreasing order** and the **odd** indexed elements (1, 3, 5, ...) should be sorted in **non-increasing order**. Finally, return the modified array. **Example:** If the array `nums` is `[3, 1, 4, 2, 5, 6]`, the modified array should be `[3, 6, 4, 2, 5, 1]`, where the elements at even indices `[0, 2, 4]` are sorted in non-decreasing order and the elements at odd indices `[1, 3, 5]` are sorted in non-increasing order.","solution":"def modify_array(nums): Modify the array such that the elements at even indices are sorted in non-decreasing order and the elements at odd indices are sorted in non-increasing order. even_indexed = sorted(nums[::2]) odd_indexed = sorted(nums[1::2], reverse=True) result = [] even_index, odd_index = 0, 0 for i in range(len(nums)): if i % 2 == 0: result.append(even_indexed[even_index]) even_index += 1 else: result.append(odd_indexed[odd_index]) odd_index += 1 return result"},{"question":"A **bitonic subsequence** of an array is a subsequence that first increases, then after reaching a peak, decreases. Given an array of integers `arr`, your task is to find the length of the longest bitonic subsequence. A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. For example, for the array `[1, 2, 5, 3, 2]`, the longest bitonic subsequence is `[1, 2, 5, 3, 2]` and its length is `5`. Return the length of the longest bitonic subsequence for the given array `arr`.","solution":"def longest_bitonic_subsequence(arr): n = len(arr) # Edge case when array is empty if n == 0: return 0 # Create two arrays to store the longest increasing subsequence inc = [1] * n # Length of LIS ending at each index dec = [1] * n # Length of LDS starting at each index # Calculate LIS values for i in range(1, n): for j in range(i): if arr[i] > arr[j] and inc[i] < inc[j] + 1: inc[i] = inc[j] + 1 # Calculate LDS values for i in range(n-2, -1, -1): for j in range(i+1, n): if arr[i] > arr[j] and dec[i] < dec[j] + 1: dec[i] = dec[j] + 1 # Calculate the maximum value of (inc[i] + dec[i] - 1) max_len = 0 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"Write a function that takes a list of integers `arr` and an integer `target`. Your task is to find all unique quadruplets `[arr[a], arr[b], arr[c], arr[d]]` in `arr` such that `a`, `b`, `c`, and `d` are distinct indices and `arr[a] + arr[b] + arr[c] + arr[d] == target`. Return the list of all such unique quadruplets. The quadruplets should be returned in a lexicographically sorted order, meaning that within the quadruplets, the integers should be sorted in ascending order, and the quadruplets themselves should be sorted in ascending order based on their first elements, then second elements, and so on.","solution":"def four_sum(arr, target): Finds all unique quadruplets [arr[a], arr[b], arr[c], arr[d]] in arr that sum up to the target. The quadruplets should be sorted in ascending order both internally and externally. :param arr: List of integers :param target: The target integer sum :return: List of unique quadruplets that sum up to target arr.sort() quadruplets = [] n = len(arr) for i in range(n - 3): # Avoid duplicates for the first number if i > 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, n - 2): # Avoid duplicates for the second number if j > i + 1 and arr[j] == arr[j - 1]: continue left, right = j + 1, n - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: quadruplets.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"Given an integer array `arr`, partition the array into two or more non-empty subarrays such that the sum of each subarray is at most `k`. Return the minimum number of subarrays you need to achieve this partition. If it\'s impossible to partition the array this way, return `-1`.","solution":"def partition_array(arr, k): Partitions the array into the minimum number of subarrays such that the sum of each subarray is at most k. Returns the minimum number of subarrays needed, or -1 if it\'s impossible to partition the array this way. if not arr: return -1 current_sum = 0 subarray_count = 0 for num in arr: if num > k: return -1 if current_sum + num > k: subarray_count += 1 current_sum = num else: current_sum += num subarray_count += 1 # Count the last subarray return subarray_count"},{"question":"You are given a list of n unique integers, where each integer is between 1 and n (inclusive). Your task is to sort the list in-place using a special sorting method called \\"Fixed Position Sort\\". In Fixed Position Sort, you can only swap an element with the element located at the position equal to its value. For example, if you have a list `[4, 3, 2, 1]`, you can only swap the first element (4) with the fourth element (1) and so on. Return the number of swaps required to sort the list in ascending order using this method.","solution":"def fixed_position_sort(arr): Sorts the list using Fixed Position Sort and returns the number of swaps required. Parameters: arr (list): List of n unique integers where each integer is between 1 and n (inclusive). Returns: int: Number of swaps required to sort the list. n = len(arr) swaps = 0 for i in range(n): while arr[i] != i + 1: index_to_swap = arr[i] - 1 arr[i], arr[index_to_swap] = arr[index_to_swap], arr[i] swaps += 1 return swaps"},{"question":"You are given a string `s` consisting only of lowercase English letters. You need to find the smallest lexicographical string that can be obtained by removing exactly one character from `s`. Return _the resulting string after removing the character_. If there are multiple such strings, return the lexicographically smallest one.","solution":"def smallest_lexicographical_after_removal(s): Returns the lexicographically smallest string that can be obtained by removing exactly one character from s. smallest_string = s[1:] # Initialize with the string after removing the first character # Iterate through the string and remove each character for i in range(1, len(s)): new_string = s[:i] + s[i+1:] # Update the smallest_string if the new_string is smaller lexicographically if new_string < smallest_string: smallest_string = new_string return smallest_string"},{"question":"Given an array of strings `words`, return an array of strings where each element is an anagram of the corresponding element in `words` but the characters in each anagram are sorted in non-descending order. An anagram of a word is a rearrangement of its letters. For example, the anagram of the word \\"cat\\" could be \\"act\\". The sorted anagram of \\"cat\\" would be \\"act\\".","solution":"def sort_anagrams(words): Given an array of strings `words`, return an array of strings where each element is an anagram of the corresponding element in `words` but the characters in each anagram are sorted in non-descending order. :param words: List of strings :return: List of sorted anagrams of the original strings return [\'\'.join(sorted(word)) for word in words]"},{"question":"You are given a list of integers `nums` representing the heights of a set of buildings. Each building `nums[i]` has a height `h`, which represents the number of units it occupies vertically. You are also given a list of integers `water` where `water[i]` represents additional water that can be added to the building at index `i` to increase its height. Each unit of `water` increases the height of the building by one unit. Your task is to write a function `max_height_after_water(nums, water)` that returns an integer denoting the maximum possible height of any building after adding the allowed units of water to any of the buildings. Efficiently determine how to distribute the water among the buildings to achieve the maximum possible height. # Example ```python # Example nums = [1, 3, 2, 4] water = [2, 1, 2, 1] print(max_height_after_water(nums, water)) # Output should be 5 ```","solution":"def max_height_after_water(nums, water): Returns the maximum possible height of any building after distributing the given water units to increase building heights. :param nums: List of integers representing the initial heights of the buildings. :param water: List of integers representing the water units that can be added to each building. :return: Integer representing the maximum possible building height. max_possible_heights = [initial_height + additional_water for initial_height, additional_water in zip(nums, water)] return max(max_possible_heights)"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. The array `arr` can be rotated to the right k times, which means that each element in the array is shifted to the right k positions, and the last element is moved to the front k times. **Define** a function that determines whether there is a way to rotate the array `k` times such that the resultant array is sorted in **strictly increasing** order. If there is such a rotation, return `true`; otherwise, return `false`.","solution":"def can_be_sorted_with_k_rotations(arr, k): Determines if there exists a way to rotate the array `k` times so that it becomes strictly sorted in increasing order. n = len(arr) # Function to check if the array is sorted in strictly increasing order def is_sorted(arr): return all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)) for i in range(n): rotated = arr[n-i:] + arr[:n-i] if is_sorted(rotated): return True return False"},{"question":"You are given an integer array `nums` of length `n` containing all unique elements, and an integer `k`. Your task is to rearrange the elements in `nums` such that the difference between the maximum and minimum values among any `k` consecutive elements is minimized. Return an array representing the rearranged `nums` which achieves this condition. If there are multiple solutions, return any of them.","solution":"def rearrange_min_max_diff(nums, k): Rearrange the array such that the difference between the maximum and minimum values among any k consecutive elements is minimized. :param nums: List[int] - list of unique integers :param k: int - size of the subarray for which the difference is minimized :return: List[int] - rearranged list # Sort the array to ensure that the elements are as close to each other as possible. nums.sort() return nums"},{"question":"You are given a string `s` consisting of digits and lowercase English letters. You need to organize the string in such a way that all the digits appear before all the letters, while preserving the relative order of both digits and letters. Return _the organized string_.","solution":"def organize_string(s): Organizes the input string such that all digits appear before all letters while preserving their relative order. Args: s (str): The input string consisting of digits and lowercase English letters. Returns: str: The organized string with all digits before letters. digits = \'\'.join([char for char in s if char.isdigit()]) letters = \'\'.join([char for char in s if char.isalpha()]) return digits + letters"},{"question":"You are given a list of integers `nums` and an integer `k`. Design a function that returns the minimum possible length of a contiguous subarray of `nums` whose sum is greater than or equal to `k`. If no such subarray exists, return `-1`. This problem should be solved with an optimal algorithm to ensure efficiency.","solution":"def min_subarray_len(nums, k): Returns the minimum possible length of a contiguous subarray of `nums` whose sum is greater than or equal to `k`. If no such subarray exists, returns -1. :param nums: List of integers :param k: Target sum integer :return: Minimum length of subarray with sum >= k, or -1 if such subarray does not exist n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a list of non-negative integers `nums`, you are tasked with finding the length of the longest contiguous subarray within which the absolute difference between any two elements is less than or equal to a given limit `k`. Return the length of such a subarray. If no such subarray exists, return 0. For example, given the array `nums = [1, 2, 2, 4, 3]` and `k = 1`, the longest contiguous subarray is `[1, 2, 2]` with length 3.","solution":"from collections import deque def longest_subarray_length(nums, k): Returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to k. if not nums: return 0 min_deque = deque() max_deque = deque() left = 0 max_length = 0 for right in range(len(nums)): while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `heights` representing the heights of buildings in a cityscape. A laser is installed on top of one building and must traverse horizontally through all the buildings from left to right. It must follow these rules: 1. It starts at height 0 (ground level). 2. It can only move to the same height or a higher height. 3. The laser cannot drop in height as it moves from one building to another. Write a function `reachable_height` that takes `heights` as its parameter and returns the final height the laser will reach after traversing all the buildings. If the laser cannot traverse all buildings according to the rules, return 0.","solution":"def reachable_height(heights): Returns the final height the laser will reach after traversing all the buildings. current_height = 0 for height in heights: if height >= current_height: current_height = height else: return 0 return current_height"},{"question":"You are given a string `s` consisting of only lowercase alphabetic characters. A substring of `s` is called **interesting** if it contains all 26 letters of the alphabet at least once. Return _the length of the **shortest** interesting substring of_ `s`. If no such substring exists, return `-1`.","solution":"def shortest_interesting_substring(s): from collections import defaultdict if len(s) < 26: return -1 required_chars = set(\\"abcdefghijklmnopqrstuvwxyz\\") char_count = defaultdict(int) unique_count = 0 left = 0 min_length = float(\\"inf\\") for right in range(len(s)): if s[right] in required_chars: if char_count[s[right]] == 0: unique_count += 1 char_count[s[right]] += 1 while unique_count == 26: min_length = min(min_length, right - left + 1) if s[left] in required_chars: if char_count[s[left]] == 1: unique_count -= 1 char_count[s[left]] -= 1 left += 1 return min_length if min_length != float(\\"inf\\") else -1"},{"question":"You are given a grid of integers representing a map of terrain heights. The grid is structured such that each cell contains an integer representing the height at that point. You may start at any cell on the top row and can move to the next cell in the row below if and only if the height of the destination cell is equal to or greater than the height of the current cell. Your goal is to determine the maximum possible height achieved when starting at any cell in the top row and moving to the bottom row. Return the maximum height that can be achieved from any starting cell in the top row. For example, given the grid: ``` [[2,1,3], [6,5,4], [7,8,9]] ``` You would return `9`.","solution":"def max_height(grid): Given a grid of integers representing terrain heights, return the maximum possible height achieved from any starting cell in the top row to the bottom row where moves are only allowed from a cell to the one directly below it. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize dp with the first row of the grid. dp = grid[0][:] # Process each row starting from the second one. for row in range(1, rows): # Initialize a new dp array for the current row. new_dp = [0] * cols for col in range(cols): # Consider the cell directly above it. best_from_above = dp[col] # If we are not on the first or last column, # check the left diagonal and right diagonal cells from the previous row. if col > 0: best_from_above = max(best_from_above, dp[col - 1]) if col < cols - 1: best_from_above = max(best_from_above, dp[col + 1]) # Update the current dp value. new_dp[col] = max(best_from_above, grid[row][col]) # Set dp to the newly computed dp array. dp = new_dp # The answer will be the maximum value in the last row of dp. return max(dp)"},{"question":"Given a string `s` and an array of integers `cost` where `cost[i]` represents the cost of deleting the character `s[i]` from `s`, return _the minimum cost to delete all consecutive duplicates in the string_. In other words, if two neighboring characters in the string are the same, one of them must be deleted, and the total cost should be minimized.","solution":"def min_cost_to_delete_duplicates(s, cost): Returns the minimum cost to delete all consecutive duplicates in the string. The function ensures that no two neighboring characters in the string are the same. :param s: A string :param cost: A list of integers where cost[i] is the cost to delete character s[i] :return: Minimum cost to delete consecutive duplicates total_cost = 0 n = len(s) if n == 0: return 0 for i in range(1, n): if s[i] == s[i - 1]: total_cost += min(cost[i], cost[i - 1]) if cost[i] > cost[i - 1]: cost[i - 1] = cost[i] # Carry forward the higher cost return total_cost"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to determine the minimum number of operations required to convert `s` into a string where no two adjacent characters are the same. In one operation, you can choose any character in the string and change it to any other lowercase English character. Return _the minimum number of operations required to achieve this_.","solution":"def min_operations_to_no_adjacent(s): Returns the minimum number of operations required to transform the given string s into a string where no two adjacent characters are the same. if not s: return 0 operations = 0 for i in range(1, len(s)): if s[i] == s[i-1]: operations += 1 return operations"},{"question":"You are given an array of integers `nums` where each integer represents the cost of a course you can take. You are also provided with an integer `k` representing the maximum points you can spend on one bundle of courses and an integer `n` representing the maximum number of courses in one bundle. Your task is to find the maximum number of courses you can take. Each course can only be taken once. Return _the maximum number of courses you can take without exceeding the cost limit `k` for any one bundle and adhering to the maximum course limit `n` for each bundle_.","solution":"def max_courses(nums, k, n): Returns the maximum number of courses that can be taken without exceeding the cost limit k for any one bundle and adhering to the maximum course limit n. nums.sort() count = 0 total_cost = 0 for cost in nums: if count < n and total_cost + cost <= k: total_cost += cost count += 1 else: break return count"},{"question":"You are given a list of non-negative integers representing quantities of each unique type of candy, where the integer at index `i` represents the number of candies of type `i`. You are also given an integer `k` that represents the number of different types of candies a child would like to eat. Your task is to determine the maximum number of candies a child can eat if they are allowed to choose exactly `k` different types of candies. Each type of candy chosen must be completely consumed. Return the maximum number of candies a child can eat under these conditions.","solution":"def max_candies(candies, k): Returns the maximum number of candies a child can eat if they are allowed to choose exactly k different types of candies where each type must be completely consumed. Parameters: - candies: list of non-negative integers representing quantities of each unique type of candy - k: integer representing the number of different types of candies a child can choose Returns: - integer representing the maximum number of candies a child can eat # Sort the candies list in descending order sorted_candies = sorted(candies, reverse=True) # Sum the first k elements to get the maximum candies that can be eaten return sum(sorted_candies[:k])"},{"question":"You are given an array of integers `nums` which may contain duplicates. Your task is to return the third distinct maximum number in this array. If the third distinct maximum does not exist, return the maximum number. Aim to achieve this in linear time complexity. For example, given an array `nums = [3, 2, 1]`, you should return `1` since it is the third distinct maximum. Given the array `nums = [1, 2]`, you should return `2` as the third distinct maximum does not exist, so the maximum number is returned. Finally, with the array `nums = [2, 2, 3, 1]`, you return `1` as it is the third distinct maximum number in the array.","solution":"def third_max(nums): Finds the third distinct maximum number in the array nums. If the third distinct maximum does not exist, returns the maximum number. distinct_nums = set(nums) if len(distinct_nums) < 3: return max(distinct_nums) distinct_nums.remove(max(distinct_nums)) distinct_nums.remove(max(distinct_nums)) return max(distinct_nums)"},{"question":"Given an array of integers `arr`, return an array where each element at index `i` is the **maximum** of all the elements in the subarray `arr[0]` to `arr[i-1]`. If there are no elements before index `i`, the value should be -1. Construct this new array following the described rule.","solution":"def max_of_previous(arr): Given an array of integers arr, return an array where each element at index i is the maximum of all the elements in the subarray arr[0] to arr[i-1]. If there are no elements before index i, the value should be -1. if not arr: return [] result = [-1] # First element is always -1 as per the problem statement max_so_far = arr[0] for i in range(1, len(arr)): result.append(max_so_far) if arr[i] > max_so_far: max_so_far = arr[i] return result"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `x`. You can perform at most `x` operations to transform `s`. In one operation, you can change any character in `s` to any other lowercase letter. Return the length of the longest substring that can be obtained which contains only one unique character after performing the operations.","solution":"def longest_single_char_substring(s, x): Returns the length of the longest substring with one unique character that can be obtained after performing at most x operations where each operation changes one character to another. from collections import Counter # Helper function to check if we can make a substring all the same character # within k replacements def can_make_substring(length, max_replace, counter): # Find the character with the highest frequency within the substring max_freq = 0 for char, freq in counter.items(): max_freq = max(max_freq, freq) # Calculate needed replacements needed_replacements = length - max_freq return needed_replacements <= max_replace max_len = 0 n = len(s) for target_char in range(26): target = chr(target_char + ord(\'a\')) left = 0 counter = Counter() for right in range(n): counter[s[right]] += 1 while not can_make_substring(right - left + 1, x, counter): counter[s[left]] -= 1 if counter[s[left]] == 0: del counter[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given `k` unique strings, each representing a city, and an integer `n` representing the total number of flights available between these cities. Each flight is represented as a tuple `(city1, city2, price)`, indicating a flight from `city1` to `city2` with a ticket price of `price`. Given a source city `src` and a destination city `dst`, return the **minimum cost** to travel from `src` to `dst` with a maximum of `m` stops. If there is no such route, return `-1`. A stop is defined as a change of planes in a city that is not the `src` or `dst`.","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(k, flights, src, dst, m): Finds the cheapest price to travel from src to dst with at most m stops. Parameters: k (int): Number of unique cities. flights (list of tuples): List of flights, each represented as (city1, city2, price). src (str): Source city. dst (str): Destination city. m (int): Maximum number of stops. Returns: int: Minimum cost to travel from src to dst with at most m stops, or -1 if there is no such route. # Build the adjacency list for the graph adj_list = defaultdict(list) for city1, city2, price in flights: adj_list[city1].append((city2, price)) # Min-heap to prioritize the minimum cost heap = [(0, src, 0)] # (current cost, current city, current stops) # Dictionary to track the minimum cost to a city with at most certain stops costs = defaultdict(lambda: defaultdict(lambda: float(\'inf\'))) costs[src][0] = 0 while heap: current_cost, current_city, current_stops = heapq.heappop(heap) # If we\'ve reached the destination with the allowed number of stops, return the cost if current_city == dst: return current_cost # If we haven\'t exceeded the maximum number of stops, continue with neighbors if current_stops <= m: for neighbor, price in adj_list[current_city]: new_cost = current_cost + price if new_cost < costs[neighbor][current_stops + 1]: costs[neighbor][current_stops + 1] = new_cost heapq.heappush(heap, (new_cost, neighbor, current_stops + 1)) return -1"},{"question":"You are given an array of strings `words`, and another string `chars`. A string is good if it can be formed by characters from `chars` (each character can only be used once). Return the sum of lengths of all good strings in `words`. Note that you should consider only the lowercase English letters. Implement the following method: `int countCharacters(String[] words, String chars)`, which will return the sum of lengths of all good strings in `words`.","solution":"def countCharacters(words, chars): Returns the sum of lengths of all the good strings in `words` that can be formed by characters from `chars`. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) for char in word_count: if word_count[char] > chars_count[char]: break else: total_length += len(word) return total_length"},{"question":"Given a m x n matrix `mat` of integers, find all possible diagonal orders and return them as a flat list. The diagonal order should start from the top-left corner of the matrix and move rightwards and downwards successively. If there are multiple diagonals that start from the same row or column, extend the diagonals from top to bottom.","solution":"def find_diagonal_order(mat): Given a m x n matrix mat of integers, return the elements in all possible diagonal orders. if not mat or not mat[0]: return [] m, n = len(mat), len(mat[0]) result = [] diagonals = {} # Collect elements of each diagonal for i in range(m): for j in range(n): if i + j not in diagonals: diagonals[i + j] = [] diagonals[i + j].append(mat[i][j]) # Traverse collected diagonals and add to result for key in sorted(diagonals.keys()): result.extend(diagonals[key]) return result"},{"question":"You are given an integer array `nums` containing `n` elements, where each element represents the length of a side of a polygon. Determine if it is possible to form a non-degenerate polygon (a polygon with positive area) using exactly three of these side lengths. A polygon is non-degenerate if for any three chosen side lengths `a`, `b`, and `c`, the sum of any two sides is greater than the third side, i.e., `a + b > c`, `a + c > b`, and `b + c > a`. Return `true` if such a triplet exists, otherwise return `false`.","solution":"def can_form_non_degenerate_polygon(nums): Determine if it is possible to form a non-degenerate polygon using exactly three of the provided side lengths. Parameters: nums (list of int): Array of integers representing the lengths of the sides. Returns: bool: True if such a triplet exists, False otherwise. # Sort the array nums.sort() # Check triplets such that a <= b <= c, and a + b > c for i in range(len(nums) - 2): if nums[i] + nums[i + 1] > nums[i + 2]: return True return False"},{"question":"Given two integer arrays `arr1` and `arr2` of lengths `m` and `n` respectively, return the **length** of their **longest common subsequence**. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_common_subsequence_length(arr1, arr2): Returns the length of the longest common subsequence of two integer arrays arr1 and arr2. m, n = len(arr1), len(arr2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): if arr1[i] == arr2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) return dp[m][n]"},{"question":"Given a list of non-negative integers representing the heights of buildings, each represented as an index in the list, and a ball with a fixed height `h` that is thrown straight at one end of the street. As the ball moves from one end to the other, it can hit the buildings if their height is greater than or equal to `h`. Return the maximum distance the ball travels before it hits a building. If the ball never hits a building, return the length of the street. The ball is thrown from the left side (index 0) and travels to the right end (last index of the list).","solution":"def max_distance_before_hit(buildings, h): Returns the maximum distance the ball travels before it hits a building with height >= h. Parameters: buildings (list): List of non-negative integers representing heights of buildings. h (int): Height of the ball. Returns: int: Maximum distance the ball travels before hitting a building with height >= h. for index, height in enumerate(buildings): if height >= h: return index return len(buildings)"},{"question":"You are given a list of integers `arr` which represents the power of each hero in a game. You need to form teams of exactly three heroes such that the sum of their powers is maximum possible. Return the sum of the maximum power of a team of three heroes. If it is not possible to form any team, return `-1`.","solution":"def max_team_power(arr): Returns the maximum sum of powers of a team of exactly three heroes. If it\'s not possible to form such a team, return -1. if len(arr) < 3: return -1 # Sort the array in descending order arr.sort(reverse=True) # The first three elements will form the team with the maximum power max_sum = arr[0] + arr[1] + arr[2] return max_sum"},{"question":"You are given two integer arrays `nums1` and `nums2`, both of length `n` and containing only non-negative integers. An operation consists of picking an index `i` (0 <= i < n) and swapping `nums1[i]` with `nums2[i]`. After performing any number of these operations, you need to find the maximum possible value of `min(sum(nums1), sum(nums2))`. Return _this maximum possible value_.","solution":"def max_min_sum(nums1, nums2): Returns the maximum possible value of min(sum(nums1), sum(nums2)) after any number of swaps between the elements of nums1 and nums2. total_sum = sum(nums1) + sum(nums2) return total_sum // 2"},{"question":"You are given an array of integers `heights` representing the heights of buildings, where the width of each building is `1`. Implement a method to return the maximum area of a rectangle formed using the buildings. These rectangles are formed by choosing two different buildings and considering the width between them and the height of the shorter building. For example, given `heights = [1, 8, 6, 2, 5, 4, 8, 3, 7]`, the largest rectangle that can be formed is between the buildings with heights `8` and `7` (the second and the last buildings), yielding an area of `7 * 7 = 49`. Your method should return this area.","solution":"def max_area(heights): Returns the maximum area of a rectangle formed between the buildings. max_area = 0 left = 0 right = len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given a list of flights, where each flight has a departure city, arrival city, and a positive integer representing the travel cost. Given a starting city and an ending city, find the least expensive route that goes from the starting city to the ending city, possibly with some intermediate stops. If no such route exists, return -1. Implement a class `FlightGraph` with the following methods: - `void addFlight(String departure, String arrival, int cost)`: Adds a flight to the graph. - `int findCheapestFlight(String start, String end)`: Returns the cost of the least expensive route from `start` to `end`, or -1 if no such route exists.","solution":"import heapq from collections import defaultdict, deque class FlightGraph: def __init__(self): self.graph = defaultdict(list) def addFlight(self, departure, arrival, cost): self.graph[departure].append((cost, arrival)) def findCheapestFlight(self, start, end): # Priority queue to hold the (cost, city) priority_queue = [(0, start)] # To track the minimum cost to reach each city min_cost = {start: 0} while priority_queue: current_cost, current_city = heapq.heappop(priority_queue) if current_city == end: return current_cost for cost, neighbor in self.graph[current_city]: new_cost = current_cost + cost if neighbor not in min_cost or new_cost < min_cost[neighbor]: min_cost[neighbor] = new_cost heapq.heappush(priority_queue, (new_cost, neighbor)) return -1"},{"question":"You are given a 2D grid of integers where each cell represents the elevation at that point. Write a function that finds the highest peak in the grid such that this peak is lower than at least one of its 8 neighboring cells (up, down, left, right, and the four diagonals). If there are multiple such peaks, return the coordinates of any one of them. If no such peak exists, return `(-1, -1)`.","solution":"def find_highest_peak(grid): Finds the highest peak in the grid such that this peak is lower than at least one of its 8 neighboring cells (up, down, left, right, and the four diagonals). :param grid: List of lists of integers representing the elevation grid. :return: Tuple of (row, col) coordinates of the peak or (-1, -1) if no such peak exists. if not grid or not grid[0]: return (-1, -1) rows = len(grid) cols = len(grid[0]) def is_peak(x, y): for dx in [-1, 0, 1]: for dy in [-1, 0, 1]: if dx == 0 and dy == 0: continue nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] > grid[x][y]: return True return False max_peak = -float(\'inf\') max_coords = (-1, -1) for r in range(rows): for c in range(cols): if is_peak(r, c) and grid[r][c] > max_peak: max_peak = grid[r][c] max_coords = (r, c) return max_coords"},{"question":"Write a function that, given a list of non-negative integers representing the amount of rainwater stored in each bar of a bar graph, calculates the total amount of trapped rainwater. The list represents the height of the bars where each bar has a width of 1. The function should return the total volume of water that is trapped between the bars after it rains.","solution":"def trap(height): Calculate the total amount of trapped rainwater given the heights of the bars. :param height: List[int] - A list of non-negative integers representing the height of bars. :return: int - The total amount of trapped rainwater. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, and an integer `x`. Find the pair `(a, b)`, where `a` is an element from `nums1` and `b` is an element from `nums2`, such that the sum `a + b` is closest to `x`. If there are multiple pairs with the same closest sum, return the pair with the smallest `a`, and if there are still multiple pairs, return the one with the smallest `b`. Return the pair as an array of size 2.","solution":"def find_closet_pair(nums1, nums2, x): Finds the pair (a, b), where a is an element from nums1 and b is an element from nums2, such that the sum a + b is closest to x. :param nums1: List[int] - The first sorted array :param nums2: List[int] - The second sorted array :param x: int - The target sum :return: List[int] - The pair [a, b] closest to x m, n = len(nums1), len(nums2) i, j = 0, n - 1 closest_pair = [] closest_diff = float(\'inf\') while i < m and j >= 0: a, b = nums1[i], nums2[j] current_sum = a + b current_diff = abs(current_sum - x) if current_diff < closest_diff: closest_diff = current_diff closest_pair = [a, b] elif current_diff == closest_diff: if a < closest_pair[0] or (a == closest_pair[0] and b < closest_pair[1]): closest_pair = [a, b] if current_sum < x: i += 1 else: j -= 1 return closest_pair"},{"question":"You are given a string `equation` representing a simple mathematical equation that consists of non-negative integers, the operators `+` and `-`, and exactly one `=` symbol, representing that the expressions on either side of it are equal. The given equation is always valid. Return the string representation of the possible values for the variable \'x\' that will satisfy the equation `equation`. If there is no solution, return \\"No solution\\". If there are infinite solutions, return \\"Infinite solutions\\".","solution":"def solve_equation(equation): Solve the given mathematical equation for x. Parameters: equation (str): The input equation as a string. Returns: str: The solution for x, \\"No solution\\", or \\"Infinite solutions\\". left, right = equation.split(\\"=\\") def parse(expression): terms = expression.replace(\\"-\\", \\"+-\\").split(\\"+\\") x_coefficient, constants = 0, 0 for term in terms: if \\"x\\" in term: if term == \\"x\\" or term == \\"+x\\": x_coefficient += 1 elif term == \\"-x\\": x_coefficient -= 1 else: x_coefficient += int(term[:-1]) elif term: constants += int(term) return x_coefficient, constants left_x_coefficient, left_constants = parse(left) right_x_coefficient, right_constants = parse(right) total_x_coefficient = left_x_coefficient - right_x_coefficient total_constants = right_constants - left_constants if total_x_coefficient == 0: if total_constants == 0: return \\"Infinite solutions\\" else: return \\"No solution\\" x_value = total_constants / total_x_coefficient return f\\"x={int(x_value)}\\""},{"question":"In a remote forest, there are `n` consecutive days of rainfall recorded. You are given an integer array `rainfall` where `rainfall[i]` denotes the amount of rainfall on the `i-th` day. For each day, starting from the first day to the `n-th` day, calculate the maximum amount of rainfall recorded in any single day up to and including that day. Return an integer array of length `n`, where each element represents the maximum rainfall up to that day.","solution":"def max_rainfall_up_to_each_day(rainfall): Given an integer array representing rainfall over n consecutive days, returns an array where each element is the maximum rainfall recorded in any single day up to and including that day. if not rainfall: return [] n = len(rainfall) max_rainfall = [0] * n max_rainfall[0] = rainfall[0] for i in range(1, n): max_rainfall[i] = max(max_rainfall[i - 1], rainfall[i]) return max_rainfall"},{"question":"You are given a binary tree where each node contains an integer value. Find the maximum sum you can obtain by summing up all the node values along any path from a root node to a leaf node. A leaf node is defined as a node with no children. The tree is not necessarily balanced and may have varying depths. Given the root of a binary tree, write a function to return the maximum sum of the values along any root-to-leaf path. Use the following TreeNode class definition: ``` class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_root_to_leaf_sum(root): Returns the maximum sum of the values along any root-to-leaf path. if not root: return 0 if not root.left and not root.right: # if the node is a leaf return root.val left_sum = max_root_to_leaf_sum(root.left) right_sum = max_root_to_leaf_sum(root.right) return root.val + max(left_sum, right_sum)"},{"question":"You are given a list of intervals `intervals` where each interval is represented as a pair `[start, end]`. An interval `[a, b]` is said to be nested within another interval `[c, d]` if `c <= a` and `b <= d`. Your task is to return the maximum number of intervals that can be nested within each other. Each interval must be completely inside another interval to be considered nested. **Example**: If the intervals are `[[1, 4], [2, 3], [3, 5], [6, 8]]`, the maximum number of nested intervals is `2`, because `[2, 3]` is nested within `[1, 4]`.","solution":"def max_nested_intervals(intervals): Returns the maximum number of nested intervals. Parameters: intervals (list): List of intervals, where each interval is represented by a pair [start, end]. Returns: int: The maximum number of nested intervals. if not intervals: return 0 # Sort the intervals first by the starting point and then by the ending point in descending order. intervals.sort(key=lambda x: (x[0], -x[1])) # Initialize the list to track the maximum length of nested intervals at each step. dp = [1] * len(intervals) for i in range(len(intervals)): for j in range(i): # Check if the current interval can nest the j-th interval. if intervals[j][0] < intervals[i][0] and intervals[j][1] > intervals[i][1]: # Update the dp value for the i-th interval. dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are managing a warehouse where you need to keep track of the inventory. You are provided with a list of integers, where each integer represents the quantity of a different item in the warehouse. Write a function that, given the list of integers, identifies and returns the second most frequent quantity in the list. If no such quantity exists (i.e., there is no second most frequent quantity), return `None`. **Note**: You may assume that there will always be at least two different quantities in the list.","solution":"from collections import Counter def second_most_frequent_quantity(quantities): Returns the second most frequent quantity in the list. If there is no second most frequent quantity, returns None. if len(set(quantities)) < 2: return None frequency_counter = Counter(quantities) most_common_quantities = frequency_counter.most_common() if len(most_common_quantities) < 2: return None return most_common_quantities[1][0] # Second element in the most_common list (the quantity itself)"},{"question":"Given an array of integers `arr` and an integer `k`, write a function to check if there exists a continuous subarray that sums up to `k`. The subarray must contain at least two elements. Return _`true` if such a subarray exists, otherwise return `false`_.","solution":"def subarray_sum_exists(arr, k): Checks if there exists a continuous subarray that sums up to k. Parameters: arr (list): List of integers. k (int): Target sum. Returns: bool: True if such a subarray exists, False otherwise. sum_map = {} curr_sum = 0 for i in range(len(arr)): curr_sum += arr[i] if i > 0 and curr_sum == k: return True if curr_sum - k in sum_map: if i - sum_map[curr_sum - k] > 1: # Ensure subarray has at least 2 elements return True if curr_sum not in sum_map: sum_map[curr_sum] = i return False"},{"question":"You are given an integer array `nums` where each integer appears exactly three times, except for one integer which appears exactly once. Find the single integer that appears only once. Implement an efficient algorithm to solve this problem. Return the single integer.","solution":"def single_number(nums): Finds the single number that appears only once in the array while each other integer appears exactly three times. once, twice = 0, 0 for num in nums: once = (once ^ num) & ~twice twice = (twice ^ num) & ~once return once"},{"question":"You are given an integer array `arr` and an integer `k`. Return _the length of the longest subsequence of `arr` such that the difference between adjacent elements is at most `k`_.","solution":"def longest_subsequence(arr, k): Returns the length of the longest subsequence such that the difference between adjacent elements is at most k. n = len(arr) if n == 0: return 0 dp = [1] * n for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) <= k: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a string `s` and an integer `k`, break the string into **substrings** of length `k`, and return a new string where each substring is reversed. If the string length is not a multiple of `k`, reverse the remaining characters as well.","solution":"def reverse_substrings(s, k): Break the string into substrings of length k, and return a new string where each substring is reversed. If the string length is not a multiple of k, reverse the remaining characters as well. Parameters: s (str): The input string k (int): The length of each substring Returns: str: The processed string with each substring reversed result = [] for i in range(0, len(s), k): substring = s[i:i + k] result.append(substring[::-1]) return \'\'.join(result)"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to replace each character in the string by 2 places forward in the alphabet (wrapping around if necessary). For example, \'a\' becomes \'c\', \'z\' becomes \'b\'. Return the resulting transformed string.","solution":"def shift_two_forward(s): Shifts each character in the string `s` two places forward in the alphabet. Wrapping around if necessary. result = [] for char in s: new_char = chr((ord(char) - ord(\'a\') + 2) % 26 + ord(\'a\')) result.append(new_char) return \\"\\".join(result)"},{"question":"You are given a string `s` consisting only of characters \'A\', \'B\', and \'C\'. You are allowed to replace exactly one character in the string with any other character (\'A\', \'B\', or \'C\'). Your task is to determine if it\'s possible to make the string alternating, where no two adjacent characters are the same, i.e., there are no consecutive \'A\'s, no consecutive \'B\'s, and no consecutive \'C\'s. Return `true` if it\'s possible to make the string alternating with one replacement, otherwise return `false`.","solution":"def can_be_made_alternating(s): Determines if the given string s can be made alternating with exactly one replacement. if len(s) < 2: return True # A string of length 1 is already alternating # Check all possible single replacements by modifying each character for i in range(len(s)): for replacement in \'ABC\': if s[i] != replacement: modified_s = s[:i] + replacement + s[i+1:] if is_alternating(modified_s): return True return False def is_alternating(s): Checks if the given string s is alternating (no two adjacent characters are the same). for i in range(1, len(s)): if s[i] == s[i-1]: return False return True"},{"question":"Given a string `s` consists of upper/lower-case alphabets and empty space characters `\' \'`, return the length of the last word in the string. If the last word does not exist, return 0. A word is defined as a character sequence consisting of non-space characters only.","solution":"def length_of_last_word(s): Returns the length of the last word in the string s. If there is no last word, returns 0. # Strip any trailing spaces s = s.rstrip() # Find the last word length last_word_length = 0 for i in range(len(s) - 1, -1, -1): if s[i] == \' \': break last_word_length += 1 return last_word_length"},{"question":"Write a function that takes an integer `n` and returns a string representing a Roman numeral corresponding to that integer. The integer `n` will be in the range from 1 to 3999.","solution":"def int_to_roman(n): Convert an integer to a Roman numeral. :param n: Integer value, 1 <= n <= 3999 :return: Roman numeral representation as a string val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while n > 0: for _ in range(n // val[i]): roman_num += syb[i] n -= val[i] i += 1 return roman_num"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. Return the modified list after the rotation. A rotation by `k` places means that each node of the list shifted to the right by `k` times, and nodes at the end of the list wrap around to the beginning.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # Determine the length of the list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Make the list circular tail.next = head # Find the new head after rotation k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circle new_tail.next = None return new_head"},{"question":"Given the root of a binary tree, return the maximum width of the tree. The width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), inclusive. If the answer is large, return it modulo (10^9 + 7).","solution":"from collections import deque def widthOfBinaryTree(root): Returns the maximum width of the binary tree rooted at \'root\'. if not root: return 0 max_width = 0 queue = deque([(root, 0)]) # node, index while queue: level_length = len(queue) _, first_index = queue[0] # index of leftmost node in this level for _ in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) _, last_index = queue[-1] if queue else (None, first_index) # index of rightmost node in this level max_width = max(max_width, last_index - first_index + 1) return max_width % (10**9 + 7)"},{"question":"Given a string `s`, write a function that determines if it can be broken down into exactly `k` non-overlapping substrings, each of which is a palindrome. Return `true` if such a partitioning is possible, and `false` otherwise.","solution":"def is_palindrome(s): return s == s[::-1] def can_partition_to_k_palindromes(s, k): def dfs(index, k): if index == len(s): return k == 0 if k == 0: return False for i in range(index + 1, len(s) + 1): if is_palindrome(s[index:i]): if dfs(i, k - 1): return True return False return dfs(0, k)"},{"question":"You are given an integer array `nums` and an integer `k`. Consider an operation in which you pick any element from the array and increment or decrement it by `1`. Your goal is to make the array constitute exactly `k` distinct integers with the minimum number of operations. Return _the minimum number of operations required to achieve this_.","solution":"def min_operations_to_k_distinct(nums, k): Returns the minimum number of operations required to make the array contain exactly k distinct integers. from collections import Counter current_distinct = len(set(nums)) if current_distinct == k: return 0 if current_distinct > k: # More distinct numbers than needed, reduce the number of distinct numbers counter = Counter(nums) freq_sorted = sorted(counter.values()) operations = 0 excess = current_distinct - k for freq in freq_sorted: if excess == 0: break operations += freq excess -= 1 return operations else: # Fewer distinct numbers than needed, increase the number of distinct numbers needed = k - current_distinct # Each new distinct number can be achieved with minimum one operation return needed"},{"question":"You are given a two-dimensional grid of integers `grid` with `m` rows and `n` columns representing a map where each cell can have either `0` (unoccupied) or `1` (occupied). Your goal is to find the largest rectangular area of unoccupied cells (`0`s) that can be formed in the `grid`. The rectangle must be entirely composed of `0`s. Return the area of the largest rectangle in the matrix.","solution":"def maximalRectangle(matrix): def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area if not matrix or not matrix[0]: return 0 max_area = 0 cols = len(matrix[0]) heights = [0] * cols for row in matrix: for j in range(cols): if row[j] == 0: heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, max_histogram_area(heights)) return max_area"},{"question":"Given a string `s`, you need to break it into words by inserting spaces such that each word is a valid word from the given dictionary `dict`. Return all possible sentences you can form by inserting spaces. You are given a list of valid words `dict` and a string `s`. Each word can be reused any number of times in the sentence. The order of the output does not matter, but you cannot just add spaces anywhere within a word in `dict`.","solution":"def word_break(s, word_dict): def dfs(s, memo={}): if s in memo: return memo[s] if not s: return [[]] res = [] for word in word_dict: if s.startswith(word): for r in dfs(s[len(word):]): res.append([word] + r) memo[s] = res return res sentences = dfs(s) return [\\" \\".join(words) for words in sentences]"},{"question":"Implement a function that takes an integer `n` and returns the number of unique binary search trees (BSTs) that can be built with `n` distinct nodes labeled from `1` to `n`. Ensure your solution has an efficient time complexity.","solution":"def num_trees(n): Returns the number of unique binary search trees that can be made using n distinct nodes. if n == 0 or n == 1: return 1 # Base cases: if there are no nodes or one node, there is only one BST possible. # Initialize a list to store the number of unique BSTs for each number of nodes from 0 to n. dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for nodes in range(2, n + 1): # Calculate the number of unique BSTs for nodes = 2 ... n for root in range(1, nodes + 1): # Consider each number from 1 to nodes as the root left = root - 1 # Number of nodes in the left subtree right = nodes - root # Number of nodes in the right subtree dp[nodes] += dp[left] * dp[right] # Combination of left and right subtrees forms the unique BSTs return dp[n] # Result is stored in dp[n]"},{"question":"In a town, there are `n` houses arranged in a straight line. Each house has its own amount of money stashed, represented by an integer array `money`. However, due to security systems, no two adjacent houses can be robbed on the same night. Given the array `money`, return the maximum amount of money that can be robbed without alerting the security system.","solution":"def rob(money): Returns the maximum amount of money that can be robbed without alerting the security system. :param money: List[int] - a list of integers representing the amount of money in each house :return: int - the maximum amount that can be robbed n = len(money) if n == 0: return 0 if n == 1: return money[0] dp = [0] * n dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + money[i]) return dp[-1]"},{"question":"Given a string `s` consisting of lowercase English letters, you need to return the number of substrings that start and end with the same character. Note that if there are overlapping substrings with the same starting and ending character, each overlapping occurrence should be counted separately. For example, given the string \\"abcabc\\", the substrings \\"a\\", \\"b\\", \\"c\\", \\"aba\\", \\"cbc\\", and so on, count as valid substrings.","solution":"def count_substrings_start_end_same(s): Returns the number of substrings that start and end with the same character. count = 0 length = len(s) for i in range(length): for j in range(i, length): if s[i] == s[j]: count += 1 return count"},{"question":"Write a function that takes a list of strings and returns the longest string that can be made by concatenating a subsequence of strings from the list such that no two consecutive strings in the sequence are anagrams of each other. If there are multiple valid results, return any one. If no valid string exists, return an empty string.","solution":"def are_anagrams(s1, s2): Helper function to check if two strings are anagrams. return sorted(s1) == sorted(s2) def concatenate_strings_without_anagrams(strings): Function that returns the longest string by concatenating a subsequence of strings from the list such that no two consecutive strings are anagrams. def dfs(current, remaining): Depth-first search helper to find the longest valid concatenation. max_result = current for i, word in enumerate(remaining): if not current or not are_anagrams(current[-len(word):], word): result = dfs(current + word, remaining[:i] + remaining[i+1:]) if len(result) > len(max_result): max_result = result return max_result return dfs(\\"\\", strings)"},{"question":"You are given an array of integers and an integer target value. Write a function to determine if there are two distinct elements in the array that add up to the target value. Return _a pair of indices_ of the two numbers such that they add up to the target, or `[-1, -1]` if no such pair exists. You may assume that each input would have exactly one solution.","solution":"def find_two_sum(nums, target): Determines if there are two distinct elements in the nums array that add up to the target value. Returns a pair of indices of the two numbers such that they add up to the target, or [-1, -1] if no such pair exists. :param nums: List[int] - A list of integers :param target: int - The target value :return: List[int] - A list containing the indices of the two numbers such that they add up to the target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [-1, -1]"},{"question":"A **binary matrix** is a matrix that consists only of `0`s and `1`s. You are given a binary matrix `mat` where each row is sorted in **non-decreasing** order. Create an algorithm to find the leftmost column index with at least a `1` in it. If such a column doesn\'t exist, return `-1`. The solution should have a time complexity better than `O(m * n)`, where `m` is the number of rows and `n` is the number of columns.","solution":"def leftmost_column_with_one(mat): Function to find the leftmost column index with at least a `1` in a binary matrix `mat` where each row is sorted in non-decreasing order. Parameters: mat (List[List[int]]): Binary matrix Returns: int: Index of the leftmost column with at least one `1`. If none exists, returns `-1`. if not mat or not mat[0]: return -1 rows = len(mat) cols = len(mat[0]) current_row = 0 current_col = cols - 1 leftmost_col = -1 while current_row < rows and current_col >= 0: if mat[current_row][current_col] == 1: leftmost_col = current_col current_col -= 1 else: current_row += 1 return leftmost_col"},{"question":"Given an array of integers `arr`, you are allowed to choose one element and replace it with any value. Return _the length of the longest possible increasing subsequence of `arr` after performing at most one such replacement_. An increasing subsequence is a subsequence where each element is strictly greater than the previous one.","solution":"def longest_increasing_subsequence_after_replacement(arr): Returns the length of the longest possible increasing subsequence in the array \'arr\' after performing at most one replacement. from bisect import bisect_left n = len(arr) if n <= 1: return n # Calculate LIS ending at each index without any replacements lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) best = max(lis) # Try to replace each element with values that could fit into the current LIS. for i in range(n): # Prior LIS values before replacing arr[i] prefix = lis[:i] suffix = lis[i + 1:] # Potential maximum LIS length if we replace arr[i] with arr[j] such that lis[j] is maximized for j in range(n): if i != j: candidate = arr[j] modified_arr = arr[:i] + [candidate] + arr[i + 1:] modified_lis = [1] * n for k in range(1, n): for m in range(k): if modified_arr[k] > modified_arr[m]: modified_lis[k] = max(modified_lis[k], modified_lis[m] + 1) best = max(best, max(modified_lis)) return best"},{"question":"You are given an array of integers `arr` and an integer `k`. A round is defined as selecting any `k` consecutive elements from `arr` and removing them, causing all other elements to shift left. Your task is to determine the minimum number of rounds needed to remove all elements from the array. If it is not possible to remove all elements from the array by performing these rounds, return -1.","solution":"def min_rounds_to_clear_array(arr, k): Returns the minimum number of rounds needed to remove all elements from the array by selecting any k consecutive elements from arr in each round. If it\'s not possible, returns -1. # If k is greater than the length of the array, it is not possible to remove k elements if k > len(arr): return -1 # If k is a divisor of the array length, then it is possible to remove all elements in rounds if len(arr) % k == 0: return len(arr) // k else: # If k is not a divisor, it is not possible to clear the array completely return -1"},{"question":"Given a matrix `grid` where each cell contains a number representing the height of the terrain at that point, you are situated at the top-left corner of the `grid` and need to reach the bottom-right corner. You can move up, down, left, or right, only to cells with a height difference of at most `1`. Return `true` if you can reach the bottom-right corner from the top-left corner, otherwise return `false`. The matrix `grid` guarantees that there is at least one row and one column.","solution":"from collections import deque def can_reach_bottom_right(grid): Returns True if you can reach the bottom-right corner from the top-left corner given the constraints on height differences, otherwise False. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up def is_valid(x, y, current_height): return 0 <= x < rows and 0 <= y < cols and abs(grid[x][y] - current_height) <= 1 queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows - 1, cols - 1): return True current_height = grid[x][y] for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, current_height) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"You are given an integer array `height` representing the heights of buildings. A building at index `i` can see the ocean if all the buildings to its right have a shorter height. Return an array of indices representing the buildings that can see the ocean. The buildings are considered in a straight line, and the ocean is to the right of the last building. Write a function to determine the indices in ascending order.","solution":"def buildings_with_ocean_view(height): Returns the indices of buildings that can see the ocean. Buildings can see the ocean if all buildings to their right are shorter. n = len(height) if n == 0: return [] result = [] max_height_so_far = -1 for i in range(n - 1, -1, -1): if height[i] > max_height_so_far: result.append(i) max_height_so_far = height[i] return result[::-1]"},{"question":"Given a non-empty string `str` and an integer `k`, rearrange the string such that there are no two adjacent characters are the same. You can assume that the input string contains only lowercase English letters. If it is not possible to rearrange the string to satisfy the condition, return an empty string. If there are multiple valid arrangements, return any one of them.","solution":"from collections import Counter import heapq def rearrange_string(str, k): if k == 0: return str freq_map = Counter(str) max_heap = [(-freq, char) for char, freq in freq_map.items()] heapq.heapify(max_heap) queue = [] res = [] while max_heap: freq, char = heapq.heappop(max_heap) res.append(char) queue.append((freq + 1, char)) # decrement the frequency if len(queue) >= k: front = queue.pop(0) if front[0] < 0: heapq.heappush(max_heap, front) if len(res) == len(str): return \'\'.join(res) else: return \'\'"},{"question":"You are given a list of **operations** to perform on an initially empty stack. The operations are as follows: - `push(x)` - Pushes integer `x` onto the stack. - `pop()` - Removes the element on the top of the stack. - `top()` - Returns the element on the top of the stack without removing it. - `getMinimum()` - Returns the minimum element currently in the stack. You need to implement the `MinStack` class: - `MinStack()` Initializes the stack object. - `void push(int x)` Pushes the integer `x` on the stack. - `void pop()` Removes the element on the top of the stack. - `int top()` Gets the integer on the top of the stack. - `int getMinimum()` Retruns the minimum integer currently in the stack. Implement the `MinStack` class that supports the above operations ensuring that each operation is performed in constant time.","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if self.stack: top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def getMinimum(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"You are given a list of flight bookings. Each booking is represented as a triplet `[first, last, seats]`, which means that `seats` seats were booked from flight `first` to flight `last` (inclusive). There are `n` flights in total, and you need to determine the number of seats booked for each flight. Return an array `answer` where `answer[i]` is the total number of seats booked for flight `i`. For example: ``` bookings = [[1, 2, 10], [2, 3, 20], [2, 2, 25]] n = 3 ``` The output should be: ``` [10, 55, 20] ```","solution":"def corpFlightBookings(bookings, n): Returns the number of seats booked for each flight. :param bookings: List[List[int]], each booking is represented as [first, last, seats] :param n: int, number of flights :return: List[int], the number of seats booked for each flight seats = [0] * (n + 1) # Use (n + 1) to accommodate 1-based indexing in bookings for first, last, booked_seats in bookings: seats[first - 1] += booked_seats if last < n: seats[last] -= booked_seats for i in range(1, n): seats[i] += seats[i - 1] return seats[:n]"},{"question":"You are given a list of non-negative integers representing the amount of money of each house, arranged in a circle. Write an algorithm to determine the maximum amount of money you can rob without alerting the police. **IMPORTANT**: Since the houses are arranged in a circle, the first house is the neighbor of the last house. This means two adjacent houses cannot be robbed together. Create a function `int rob(int[] nums)` that returns the maximum amount of money you can rob. (Note: The function should handle the edge cases such as an empty list and a list with only one house efficiently.)","solution":"def rob(nums): def rob_linear(houses): prev_max = 0 curr_max = 0 for money in houses: temp = curr_max curr_max = max(curr_max, prev_max + money) prev_max = temp return curr_max if not nums: return 0 if len(nums) == 1: return nums[0] # Compute the max money by either considering the array excluding the first house # or excluding the last house because of the circular nature. return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"You are given a string `s` and an array of strings `words` containing distinct strings. You need to find all unique words in `words` that are subsequences of `s`. Return _the list of all such unique words_. A subsequence of a string is a new string generated from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.","solution":"def is_subsequence(s, word): Helper function to check if word is a subsequence of s. it = iter(s) return all(char in it for char in word) def find_subsequences(s, words): Returns the list of all unique words in \'words\' that are subsequences of \'s\'. return [word for word in words if is_subsequence(s, word)]"},{"question":"Consider a matrix of integers `matrix` of size `m x n`. Each cell in the matrix contains either a 0 or a 1. A connected component of 1s is a group of 1s connected vertically or horizontally (but not diagonally). Your task is to find the largest connected component of 1s in the given matrix. Return the size of this largest connected component. Write a function that takes a 2D list `matrix` and returns an integer. The function should find all connected components of 1s and return the size of the largest one.","solution":"def largest_connected_component(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1 and not visited[i][j]: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of consecutive buildings. You can move from one building to another if the latter\'s height is either the **same** or **one unit greater** or **one unit lesser** than the former\'s height. You need to find the longest sequence of consecutive buildings you can visit starting from any building. Return _the length of the longest such sequence_.","solution":"def longest_building_sequence(heights): max_length = 1 current_length = 1 for i in range(1, len(heights)): if abs(heights[i] - heights[i - 1]) <= 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given a list of integers `heights` representing building heights and an integer `bricks`, where each element in `heights` represents the height of a building starting from the first building. You can modify the landscape by adding bricks to equalize the height difference between two consecutive buildings. However, you have a limited number of bricks. Write a function that determines the maximum number of buildings you can reach by using the given bricks to manage the height differences. Return the maximum number of buildings you can reach.","solution":"def max_buildings_reached(heights, bricks): Returns the maximum number of buildings that can be reached using the given number of bricks. n = len(heights) if n == 0: return 0 total_bricks = 0 building_count = 1 for i in range(1, n): diff = heights[i] - heights[i-1] if diff > 0: total_bricks += diff if total_bricks > bricks: break building_count += 1 return building_count"},{"question":"Given a directed graph represented as an adjacency list where each node has a unique value, and two nodes of the graph `u` and `v`, write a function to determine if there is a path from node `u` to node `v`. Return `true` if there is a path from `u` to `v`, and `false` otherwise. Ensure your solution is optimized to handle graphs with a large number of nodes and edges.","solution":"def has_path(graph, u, v): Returns True if there is a path from node u to node v in the directed graph, otherwise False. :param graph: dict, a dictionary representation of the adjacency list of the graph :param u: int, the starting node :param v: int, the target node :return: bool, True if there is a path from u to v, otherwise False visited = set() def dfs(node): if node in visited: return False visited.add(node) if node == v: return True for neighbor in graph.get(node, []): if dfs(neighbor): return True return False return dfs(u)"},{"question":"A warehouse manager is organizing boxes into stacks. The warehouse has `n` stacks, numbered from `0` to `n-1`. You are given a list of box placements `placements`, where `placements[i] = [stacki, weighti]` represents placing a box on stack `stacki` with weight `weighti`. A stack is identified as **balanced** if the sum of weights in that stack is a multiple of `k`, a given integer. Determine the minimum total weight that must be added to any of the stacks to ensure that all stacks are balanced. Return _an integer_ `min_weight`_, the minimum total weight that must be added to balance all stacks_.","solution":"def min_weight_to_balance_stacks(n, placements, k): Determine the minimum total weight that must be added to ensure that all stacks are balanced. Parameters: n : int : number of stacks placements : List[List] : list of box placements. Each placement is a list [stacki, weighti] k : int : the integer that the sum of weights in a stack must be multiple of to be considered balanced Returns: int : Minimum total weight to add to balance all stacks # Initialize a list to store the sum of weights in each stack stack_sums = [0] * n # Populate the stack_sums with the given placements for stack, weight in placements: stack_sums[stack] += weight # Calculate the total weight that must be added to balance each stack total_weight_to_add = 0 for current_sum in stack_sums: remainder = current_sum % k if remainder != 0: total_weight_to_add += k - remainder return total_weight_to_add"},{"question":"Given a string of lowercase letters, determine the length of the longest substring that contains at most two distinct characters. For example, given the string `\\"eceba\\"`, the longest substring containing at most two distinct characters is `\\"ece\\"`, which has a length of 3. Implement the function `int longestSubstring(String s)` which returns the length of the longest substring with at most two distinct characters. **Notes:** - You may assume the input string is non-empty. - The solution should focus on optimal performance with respect to time complexity.","solution":"def longestSubstring(s): Returns the length of the longest substring with at most two distinct characters. n = len(s) if n < 3: return n # sliding window left and right pointers left, right = 0, 0 # hashmap to store the rightmost positions of characters in the window hashmap = {} max_len = 2 while right < n: # when the slide window contains less than 3 characters hashmap[s[right]] = right right += 1 # slidewindow contains 3 characters if len(hashmap) == 3: # delete the leftmost character del_idx = min(hashmap.values()) del hashmap[s[del_idx]] # move left pointer of the slidewindow left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given two strings `s1` and `s2` of the same length n, consisting only of lowercase English letters. You can transform string `s1` into string `s2` using the following operation any number of times: choose an index `i` with `s1[i] != s2[i]` and swap the characters `s1[i]` and `s1[j]` for some `j` (0 <= j < n) such that `s1[j] == s2[i]`. Determine if it is possible to transform `s1` into `s2` using the allowed operations. Return `true` if it is possible, and `false` otherwise.","solution":"def can_transform(s1, s2): Determine if it is possible to transform string s1 into string s2 using the allowed operation. :param s1: String to be transformed :param s2: Target string :return: Boolean indicating if the transformation is possible # The frequency of each character in both strings must be the same from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"You are given a list of integers `prices` where each element represents the price of a stock on a given day. You are also given an integer `fee` that represents a transaction fee for each buy and sell operation. Your goal is to maximize the profit you can achieve by completing as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note that you must sell the stock before you buy again, and you need to pay the transaction fee for each transaction. Calculate the maximum profit you can achieve.","solution":"def maxProfit(prices, fee): Returns the maximum profit that can be achieved by buying and selling stocks with a transaction fee. :param prices: List[int] - List of stock prices :param fee: int - Transaction fee for each buy and sell :return: int - Maximum profit if not prices: return 0 n = len(prices) cash = 0 hold = -prices[0] - fee for i in range(1, n): cash = max(cash, hold + prices[i]) hold = max(hold, cash - prices[i] - fee) return cash"},{"question":"You are given a grid represented by a 2D integer array `grid` of size `m x n`. Each cell in the grid contains a non-negative integer which represents the number of coins in that cell. You start at the top-left cell `(0, 0)` and you need to reach the bottom-right cell `(m-1, n-1)`. From a cell, you can only move right or down to an adjacent cell. During the journey, you collect all the coins in the cells you visit. Return _the maximum number of coins you can collect by the time you reach the bottom-right cell._","solution":"def max_coins(grid): Returns the maximum number of coins collected from the top-left to the bottom-right of the grid. :param grid: List[List[int]] - the 2D grid of coin values :return: int - maximum number of coins that can be collected if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given a 2D matrix `grid` where each cell has an integer value. A path from one cell to another is defined as a sequence of adjacent cells (horizontally, vertically, or diagonally) with non-decreasing values, starting from a given cell `start` to a target cell `destination`. Write a function to determine if such a path exists from `start` to `destination`. If a path exists, return the path as a list of tuples representing the cells coordinates, otherwise return an empty list. The path should be the shortest one in terms of the number of cells traversed. You may assume all values in the grid are unique.","solution":"from collections import deque def find_path(grid, start, destination): directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def bfs(start, destination): queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: (x, y), path = queue.popleft() if (x, y) == destination: return path for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited and grid[nx][ny] >= grid[x][y]: visited.add((nx, ny)) queue.append(((nx, ny), path + [(nx, ny)])) return [] return bfs(start, destination)"},{"question":"You are given an array of integers `nums` representing the count of items of each type in a store\'s inventory. Each type of item has a different id from 0 to `nums.length - 1`. You are also given an array `queries` where `queries[i] = [start_i, end_i]` represents a query to compute the sum of items in the inventory from index `start_i` to `index end_i` inclusive. Return an array of answers to all the queries. Each answer should correspond to the sum of items of the respective query.","solution":"def sum_inventories(nums, queries): This function takes in an array of integers nums and an array of queries. It returns an array of sums of subarrays of nums based on the queries. result = [] for query in queries: start, end = query result.append(sum(nums[start:end + 1])) return result"},{"question":"You are given a list of integers `nums` and an integer `targetSum`. Find the number of different continuous subarrays within `nums` whose sum equals `targetSum`. Note that there might be overlapping subarrays that sum to `targetSum`, and each should be counted separately. Return the total count of such subarrays.","solution":"def count_subarrays_with_sum(nums, targetSum): Returns the number of continuous subarrays within nums whose sum equals targetSum. count = 0 current_sum = 0 sum_counts = {0: 1} # Initialize with 0 sum occurring once for the subarray starting at the beginning for num in nums: current_sum += num sum_needed = current_sum - targetSum if sum_needed in sum_counts: count += sum_counts[sum_needed] if current_sum in sum_counts: sum_counts[current_sum] += 1 else: sum_counts[current_sum] = 1 return count"},{"question":"Given two integer arrays `arr1` and `arr2`, each of length `n`, return _an array_ `result` _where_ `result[i]` _is the_ **maximum** _element of_ `arr1` _and_ `arr2` _at index_ `i` _for all valid_ `i`.","solution":"def max_elements(arr1, arr2): Given two integer arrays arr1 and arr2 of the same length n, return an array result where result[i] is the maximum element of arr1 and arr2 at index i for all valid i. return [max(arr1[i], arr2[i]) for i in range(len(arr1))]"},{"question":"You are given an array of `n` intervals, where each interval is represented as a two-element list `[start, end]` denoting the inclusive range. Your task is to determine the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Two intervals `[a, b]` and `[c, d]` are considered overlapping if they share at least one common point, i.e., `a <= d` and `c <= b`. Return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.","solution":"def eraseOverlapIntervals(intervals): Returns the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. # Sort intervals by end time intervals.sort(key=lambda x: x[1]) # Initialize variables end = float(\'-inf\') count = 0 for interval in intervals: # If the current interval starts after the previous end, do not overlap if interval[0] >= end: end = interval[1] else: # Overlap occurs, increase the count of removed intervals count += 1 return count"},{"question":"Given a list of strings `email_list` where each string is an email address, write a function to **filter** out all the valid email addresses. A valid email address follows these rules: - It has exactly one \'@\' symbol. - The local part (the part before the \'@\') does not start or end with a dot (\'.\') and also does not have two consecutive dots. - The domain part (the part after the \'@\') consists of at least one dot, and none of the dot-separated parts start or end with a dot and also do not have two consecutive dots. Return a list containing all the valid email addresses from the input list in the same order.","solution":"import re def is_valid_email(email): Helper function to check if an email address is valid based on the defined rules. # Regular expression pattern for validating an email pattern = re.compile(r\\"^(?!.*[.]{2})(?!.*[@]{2})[A-Za-z0-9]+([._A-Za-z0-9-])*[A-Za-z0-9]+@[A-Za-z0-9]+([._A-Za-z0-9-])*[A-Za-z0-9]+.[A-Za-z]{2,}\\") # Check if email matches the pattern return pattern.match(email) is not None def filter_valid_emails(email_list): Returns a list containing all the valid email addresses from the input list. return [email for email in email_list if is_valid_email(email)]"},{"question":"Given a binary tree, implement the `findDeepestNode` function to find the deepest node (the node that is farthest from the root) in the tree. The tree is represented by a class `TreeNode` which contains an integer value `val`, and left and right pointers to its child nodes. The function signature is as follows: `TreeNode* findDeepestNode(TreeNode* root)`. The function should return the deepest node. If there are multiple nodes at the same depth, return the leftmost one.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findDeepestNode(root): if not root: return None queue = [(root, 0)] # Each element is a tuple (node, depth) max_depth = -1 deepest_node = None while queue: current, depth = queue.pop(0) if depth > max_depth: max_depth = depth deepest_node = current if current.left: queue.append((current.left, depth + 1)) if current.right: queue.append((current.right, depth + 1)) return deepest_node"},{"question":"You are given an array of integers `nums` where the values represent the heights of vertical lines all starting from the same line on the x-axis. You want to draw water between the lines such that the most water is contained. Return the maximum amount of water that can be contained. The width between two lines is the difference in their indices. For example, given `nums = [1, 8, 6, 2, 5, 4, 8, 3, 7]`, the maximum amount of water that can be contained is 49 (between the lines at index 1 and index 8).","solution":"def max_area(nums): Given an array of integers representing heights of lines, this function calculates the maximum area of water that can be contained between the lines. Args: nums (List[int]): List of non-negative integers where each integer represents the height of a line. Returns: int: Maximum amount of water that can be contained max_area = 0 left = 0 right = len(nums) - 1 while left < right: width = right - left height = min(nums[left], nums[right]) area = width * height max_area = max(max_area, area) # Move the pointers if nums[left] < nums[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given a string `s` consisting of only lowercase English letters. A _character frequency string_ for `s` is a string where each character in `s` is followed by its frequency of occurrence in `s`. For example, if `s = \\"aabbcc\\"`, then its character frequency string is \\"a2b2c2\\". Different characters\' frequencies can appear in any order. Given a string `s`, return its character frequency string sorted lexicographically by characters.","solution":"def character_frequency_string(s): Returns the character frequency string sorted lexicographically by characters. Args: s (str): Input string consisting of only lowercase English letters. Returns: str: Character frequency string sorted lexicographically by characters. from collections import Counter frequency_counter = Counter(s) sorted_characters = sorted(frequency_counter.keys()) result = [] for char in sorted_characters: result.append(f\\"{char}{frequency_counter[char]}\\") return \'\'.join(result) # Example usage: # s = \\"aabbcc\\" # Output => \\"a2b2c2\\""},{"question":"Given a string `s` and an integer `k`, create a new string by rearranging the characters of `s` such that the same characters are at least `k` distance apart. If it is not possible to rearrange the string under the given conditions, return an empty string. For example, given `s = \\"aabbcc\\"` and `k = 3`, one possible rearrangement is `\\"abcabc\\"`. If `k = 4`, it is not possible to rearrange the string to satisfy the condition, so the function should return an empty string.","solution":"from collections import Counter import heapq def rearrange_string(s, k): Rearranges the string such that the same characters are at least k distance apart. If not possible, returns an empty string. if k == 0: return s counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((count + 1, char)) if len(wait_queue) >= k: freed_char = wait_queue.pop(0) if freed_char[0] < 0: heapq.heappush(max_heap, freed_char) return \'\'.join(result) if len(result) == len(s) else \'\'"},{"question":"You are given two arrays `nums1` and `nums2` of length `n`. Consider a valid operation where you choose an element from `nums1` and an element from `nums2` and swap them. The beauty of the arrays is defined as the maximum possible element-wise sum of the two arrays. More formally, if `nums1\'` and `nums2\'` are the resulting arrays after a series of swaps, the beauty is defined as the sum of the maximum values taken from the same indexes of the arrays. Given these two arrays, your task is to determine the maximum possible beauty after performing any number of valid operations. Return the maximum beauty of the arrays.","solution":"def maximum_beauty(nums1, nums2): Returns the maximum possible beauty of arrays nums1 and nums2 after performing any number of valid operations. The beauty is defined as the sum of the maximum values taken from the same indexes of the arrays. n = len(nums1) return sum(max(nums1[i], nums2[i]) for i in range(n))"},{"question":"You are given a list of strings `words` and a string `target`. Each string in `words` can be concatenated to form the `target` string exactly once. Return the minimum number of concatenations needed to form the `target` string. If it is impossible to form `target` using the strings in `words`, return `-1`. *Note: You can use each string in `words` as many times as needed.*","solution":"def min_concatenations(words, target): from collections import defaultdict, deque # Create a queue to track current strings and their concatenation counts queue = deque([(target, 0)]) visited = set() # to avoid re-processing the same substring while queue: current, count = queue.popleft() # If the current string is empty, we\'ve successfully formed the target if not current: return count # Try to match any word and create a new substring for word in words: if current.startswith(word): new_substring = current[len(word):] if new_substring not in visited: visited.add(new_substring) queue.append((new_substring, count + 1)) return -1 # Impossible to form the target string"},{"question":"Design a data structure called `MaxIntSet` that supports the following operations: - `MaxIntSet(int capacity)`: Initializes the set with a maximum capacity. - `void insert(int val)`: Inserts an integer `val` into the set. If the set exceeds its maximum capacity, the smallest integer should be removed to maintain the set\'s size. - `boolean contains(int val)`: Returns `true` if the integer `val` is present in the set, and `false` otherwise. - `int getMax()`: Returns the largest integer currently in the set. If the set is empty, return `-1`. The `MaxIntSet` should maintain optimal time complexity for each of the operations.","solution":"import heapq class MaxIntSet: def __init__(self, capacity): Initializes the set with a maximum capacity. self.capacity = capacity self.data_set = set() self.min_heap = [] def insert(self, val): Inserts an integer `val` into the set. If the set exceeds its maximum capacity, the smallest integer should be removed to maintain the set\'s size. if val in self.data_set: return if len(self.data_set) >= self.capacity: smallest_val = heapq.heappop(self.min_heap) self.data_set.remove(smallest_val) self.data_set.add(val) heapq.heappush(self.min_heap, val) def contains(self, val): Returns `true` if the integer `val` is present in the set, and `false` otherwise. return val in self.data_set def getMax(self): Returns the largest integer currently in the set. If the set is empty, return `-1`. if not self.data_set: return -1 return max(self.data_set)"},{"question":"You are given a 2D grid of size `m x n` and an integer `k`. Each cell in the grid contains an integer representing the number of apples in that cell. You are standing at the top-left cell and want to collect exactly `k` apples by moving right or down to cells. You can revisit cells if needed. Write a function that returns `true` if you can collect exactly `k` apples, otherwise return `false`.","solution":"def can_collect_k_apples(grid, k): Determines if you can collect exactly k apples from the top-left cell to any cell, moving only right or down, and revisiting cells if needed. :param grid: List[List[int]] - 2D grid of integers representing apples in each cell. :param k: int - Target number of apples to collect exactly. :return: bool - True if it\'s possible to collect exactly k apples, otherwise False. m, n = len(grid), len(grid[0]) # Helper function for DFS def dfs(i, j, current_sum, visited): # If out of bounds or already visited, return False if i < 0 or j < 0 or i >= m or j >= n or (i, j) in visited: return False # Add current cell to visited visited.add((i, j)) current_sum += grid[i][j] # If current_sum exceeds k, stop searching in this path if current_sum > k: visited.remove((i, j)) return False # If we found the exact k, return True if current_sum == k: return True # DFS in all four possible directions if (dfs(i+1, j, current_sum, visited) or dfs(i-1, j, current_sum, visited) or dfs(i, j+1, current_sum, visited) or dfs(i, j-1, current_sum, visited)): return True # Remove current cell from visited if none of the directions work visited.remove((i, j)) return False return dfs(0, 0, 0, set())"},{"question":"Given an array of integers `arr`, where each element represents the height of a building, and an integer `x`, you need to find the maximum number of buildings you can see if you stand at the beginning (index 0) of the array. A building can be seen if it is not completely obstructed by any taller or equally tall building before it. More formally, building `arr[i]` can be seen if `arr[i] > max(arr[0], arr[1], ..., arr[i-1])`. Return _the maximum number of buildings that can be seen_.","solution":"def max_visible_buildings(arr, x): Returns the maximum number of buildings that can be seen from the start of the array. Parameters: arr (list of int): A list where each element represents the height of a building. x (int): An integer parameter (not used in the function based on the description). Returns: int: The maximum number of buildings that can be seen from the start of the array. if not arr: return 0 max_height = arr[0] visible_count = 1 for height in arr[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"Given an array of integers `arr` and an integer `sum`, find all unique pairs in the array whose sum is equal to the given `sum`. Return a list of the pairs, with each pair being represented as a tuple (a, b) and a ≤ b. The pairs should be ordered in lexicographical order. For example, if `arr = [1, 5, 7, -1, 5]` and `sum = 6`, the unique pairs are `[(1, 5), (-1, 7)]`. Return a list of such pairs.","solution":"def find_pairs_with_sum(arr, target_sum): Finds all unique pairs in the array whose sum is equal to the given sum. Each pair is represented as a tuple (a, b) with a <= b. The pairs are returned in lexicographical order. seen = set() pairs = set() for num in arr: complement = target_sum - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(pairs)"},{"question":"You are given a list of words and a list of queries. Each query is a pair of integers representing positions in the list of words. For each query, return the length of the longest word in the list between the given positions (inclusive). Write a class `WordQuery` that implements the following methods: - `WordQuery(List<String> words)` This initializes the object with the given list of words. - `int query(int start, int end)` This returns the length of the longest word between the positions `start` and `end` (both inclusive). You should optimize the `query` method to handle multiple calls efficiently.","solution":"class WordQuery: def __init__(self, words): self.words = words self.precomputed_max_lengths = self._precompute_max_lengths(words) def _precompute_max_lengths(self, words): n = len(words) max_lengths = [[0] * n for _ in range(n)] for i in range(n): current_max = 0 for j in range(i, n): current_max = max(current_max, len(words[j])) max_lengths[i][j] = current_max return max_lengths def query(self, start, end): return self.precomputed_max_lengths[start][end]"},{"question":"You are given an array of `n` integers where each integer represents a building\'s height. Assume the buildings are standing side by side, and a certain amount of water is poured onto the entire set of buildings. The water will collect in the gaps between buildings as well as between the heights of the buildings. Write a function to compute the amount of water that can be trapped between the buildings after it rains. Hint: The array represents the height of each building and the width of each building is 1 unit. Return the total amount of water that can be trapped.","solution":"def trap(height): Returns the total amount of water that can be trapped between buildings represented by the height array. if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given an array of integers `nums`, find the **length of the longest subsequence** such that every element in the subsequence is either strictly greater or strictly less than its preceding element. Two consecutive elements must not be equal. Return the length of the longest such subsequence.","solution":"def longest_alternating_subsequence(nums): Returns the length of the longest subsequence such that every element in the subsequence is either strictly greater or strictly less than its preceding element. if not nums: return 0 n = len(nums) if n == 1: return 1 up, down = 1, 1 for i in range(1, n): if nums[i] > nums[i - 1]: up = down + 1 elif nums[i] < nums[i - 1]: down = up + 1 return max(up, down)"},{"question":"You are given a fixed-length array `arr` of integers, and a `target` value. Your task is to implement a function `findTargetIndex()` that searches for the `target` in the array `arr`. If `target` is found, return the index of its first occurrence. If `target` is not found, return `-1`. The function should aim to perform the search with a time complexity of O(log n). Note: You can assume that `arr` is sorted in non-decreasing order.","solution":"def findTargetIndex(arr, target): Returns the index of the first occurrence of target in the sorted array arr. If the target is not found, returns -1. Uses binary search for O(log n) time complexity. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: if mid == 0 or arr[mid-1] < target: return mid right = mid - 1 elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given an array of strings `words` where each string is either a positive decimal number consisting of digits and decimal points or a word consisting of alphabetic characters. You need to separate the words into two lists: `numbers` and `letters`. A string should be placed in `numbers` if it represents a number, otherwise it should be placed in `letters`. After separating, `numbers` should be sorted in ascending numeric order and `letters` should be sorted lexicographically. Return a tuple consisting of the sorted `numbers` list followed by the sorted `letters` list. For example: Given `words = [\\"banana\\", \\"2.5\\", \\"apple\\", \\"3.0\\", \\"1.2\\", \\"word\\"]`, the function should return `([\'1.2\', \'2.5\', \'3.0\'], [\'apple\', \'banana\', \'word\'])`.","solution":"def separate_and_sort(words): Separates an array of strings into `numbers` and `letters`. Numbers are sorted in ascending numeric order and letters in lexicographical order. Args: words (list): List of strings containing either decimal numbers or alphabetic words. Returns: tuple: Two lists, first with numbers sorted, second with letters sorted. numbers = [] letters = [] for word in words: try: float(word) # Attempt to convert to float to check if it\'s a number numbers.append(word) except ValueError: letters.append(word) numbers.sort(key=float) # Sort numbers in ascending numeric order letters.sort() # Sort letters lexicographically return (numbers, letters)"},{"question":"You are given a **0-indexed** integer array `energy` where `energy[i]` represents the amount of energy a player gains while passing through the `i-th` checkpoint. A player can start at any checkpoint and must choose one of two options at each checkpoint: move to the next checkpoint or skip one checkpoint and move to the following one. The player must finish their journey such that they maximize the total energy collected. Return the maximum energy a player can accumulate.","solution":"def max_energy_collected(energy): Returns the maximum energy a player can collect by starting at any checkpoint and either moving to the next checkpoint or skipping one checkpoint at each step. if not energy: return 0 n = len(energy) if n == 1: return energy[0] # Initialize dp arrays dp = [0] * n dp[0] = energy[0] if n > 1: dp[1] = max(energy[0], energy[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + energy[i]) return max(dp[-1], dp[-2])"},{"question":"Given a binary tree, return the **zigzag level order traversal** of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). You are given the `TreeNode` class as follows: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` Return _a list of lists containing the values of each level in zigzag order_.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root): if not root: return [] results = [] current_level = deque([root]) left_to_right = True while current_level: level_values = deque() for _ in range(len(current_level)): node = current_level.popleft() if left_to_right: level_values.append(node.val) else: level_values.appendleft(node.val) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) results.append(list(level_values)) left_to_right = not left_to_right return results"},{"question":"Given a **0-indexed** integer array `arr` of n integers, and an integer `k`, your task is to **rotate** the array to the right by `k` steps. **Note** that `k` can be greater than `n`. For example, if `arr = [1,2,3,4,5,6,7]` and `k = 3`, the resulting array will be `[5,6,7,1,2,3,4]`. If `k` is equal to 10, it will be effectively equivalent to rotating the array 3 steps since `k % n = 3`. Return _the rotated array_.","solution":"def rotate_array(arr, k): Rotates the given array to the right by k steps. Parameters: arr (list): The list of integers to be rotated. k (int): The number of steps to rotate the array. Returns: list: The rotated array. if not arr: # if arr is empty, return it as is return arr n = len(arr) k %= n # handle cases where k > n return arr[-k:] + arr[:-k]"},{"question":"You are given an n-ary tree, a tree in which each node can have up to `n` children. Each node is represented by a Node object containing an integer value and a list of child nodes. Implement a function to perform a **level order traversal** on the tree and return an array of arrays containing the values of the nodes at each level. Each inner array should correspond to a level of the tree, with the root node being at level `0`. For example, given the following tree: ``` 1 / | 3 2 4 / 5 6 ``` The level order traversal would be: ``` [ [1], [3, 2, 4], [5, 6] ] ```","solution":"from collections import deque class Node: def __init__(self, value, children=[]): self.value = value self.children = children def level_order_traversal(root): Perform a level order traversal on the tree and return an array of arrays containing the values of the nodes at each level. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.value) for child in node.children: queue.append(child) result.append(level) return result"},{"question":"You are given a string `s` that consists of only the characters \'a\', \'b\', and \'c\'. You can perform operations on `s` in which you select a non-empty substring and replace all occurrences of \'a\' with \'b\', \'b\' with \'c\', and \'c\' with \'a\'. Return the lexicographically smallest string you can obtain by performing this operation any number of times on `s`. **Notes:** * A string `x` is lexicographically smaller than a string `y` if `x` comes before `y` in dictionary order. * You do not need to replace all characters in your chosen substring; just replace the characters as per the operation described.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string possible by performing the described operations on the input string s any number of times. :param s: String consisting of characters \'a\', \'b\', and \'c\' :return: Lexicographically smallest string after operations smallest_string = [] for char in s: if char == \'a\': smallest_string.append(\'a\') elif char == \'b\': smallest_string.append(\'a\') elif char == \'c\': smallest_string.append(\'a\') return \'\'.join(smallest_string)"},{"question":"You are given an MxN matrix `grid` filled with non-negative integers. Your task is to find a path from the top-left corner to the bottom-right corner of the grid that minimizes the sum of the values along the path. You can only move either down or right at any point in time. Return the minimum sum of the values along such a path.","solution":"def min_path_sum(grid): Returns the minimum sum of the values along a path from the top-left to the bottom-right corner of the grid. Movement is restricted to right or down. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first row for i in range(1, n): grid[0][i] += grid[0][i - 1] # Initialize the first column for i in range(1, m): grid[i][0] += grid[i - 1][0] # Populate the rest of the grid for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"Given a matrix `grid` of size `m x n` filled with non-negative integers, you are tasked with finding the maximum sum of any rectangular subgrid. The sum of a subgrid is the sum of all elements present within that subgrid. Return the maximum sum of any rectangular subgrid within `grid`.","solution":"def max_sum_subgrid(grid): Returns the maximum sum of any rectangular subgrid in the given matrix \'grid\'. if not grid or not grid[0]: return 0 max_sum = float(\'-inf\') rows, cols = len(grid), len(grid[0]) # Use a modified version of Kadane\'s algorithm to find the max sum rectangle in the matrix for left in range(cols): temp = [0] * rows for right in range(left, cols): for i in range(rows): temp[i] += grid[i][right] # Find the max sum subarray in temp using Kadane\'s algorithm max_ending_here = max_so_far = temp[0] for k in range(1, len(temp)): max_ending_here = max(temp[k], max_ending_here + temp[k]) max_so_far = max(max_so_far, max_ending_here) max_sum = max(max_sum, max_so_far) return max_sum"},{"question":"You are given an integer array `arr` of length `n`, where each element in `arr` represents a different type of candy with some taste value. You are also provided with an integer `m` representing the number of friends who will each get exactly one piece of candy. Distribute the candies to friends such that the difference between the maximum and minimum taste values of the distributed candies is minimized. Return _the minimum possible difference between the maximum and minimum taste values of the distributed candies_.","solution":"def min_taste_difference(arr, m): Returns the minimum possible difference between the maximum and minimum taste values of the distributed candies. Parameters: arr (list of int): List of taste values of candies. m (int): Number of friends. Returns: int: Minimum possible difference between maximum and minimum taste values of the distributed candies. if m == 0 or m > len(arr): return 0 # Sort the array to easily find the minimum difference set arr.sort() # Initialize min_diff to a large number min_diff = float(\'inf\') # Iterate through the array to find the minimum difference for i in range(len(arr) - m + 1): diff = arr[i + m - 1] - arr[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"You are given a string consisting of lowercase English letters and integers. The string can repeat patterns, such as \\"3[a]2[bc]\\", where the integer represents how many times the enclosed sequence should be repeated. Concatenate the letters according to the specified repeats to produce a new string. For example, \\"3[a]2[bc]\\" would produce \\"aaabcbc\\". Given an encoded string, decode it and return the original string. Implement the function: ```python def decodeString(s: str) -> str: pass ``` **Example 1:** ```plaintext Input: s = \\"3[a]2[bc]\\" Output: \\"aaabcbc\\" ``` **Example 2:** ```plaintext Input: s = \\"3[a2[c]]\\" Output: \\"accaccacc\\" ``` **Example 3:** ```plaintext Input: s = \\"2[abc]3[cd]ef\\" Output: \\"abcabccdcdcdef\\" ```","solution":"def decodeString(s: str) -> str: Decodes an encoded string with patterns such as \\"3[a]2[bc]\\". The pattern num[letters] means the letters should be repeated num times. stack = [] current_num = 0 current_string = \'\' for c in s: if c.isdigit(): current_num = current_num * 10 + int(c) elif c == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif c == \']\': last_string, num = stack.pop() current_string = last_string + current_string * num else: current_string += c return current_string"},{"question":"Given an undirected graph with `n` nodes, labeled from `1` to `n`, you are provided with a list of edges where each edge is a tuple `(u, v)` indicating that there is an edge between nodes `u` and `v`. Determine if the graph is a valid tree. A valid tree is defined as one where: 1. The graph is fully connected. In other words, there is a path between any pair of nodes. 2. The graph contains no cycles. Return `true` if the given graph is a valid tree, and `false` otherwise. **Example input:** ```python n = 5 edges = [(1, 2), (1, 3), (2, 4), (3, 5)] ``` **Example output:** ```python True ```","solution":"def is_valid_tree(n, edges): Determines if the graph with n nodes and given edges is a valid tree. if len(edges) != n - 1: # A valid tree must have exactly n-1 edges. return False # Initialize adjacency list adj = {i: [] for i in range(1, n + 1)} for u, v in edges: adj[u].append(v) adj[v].append(u) # Use DFS to check if the graph is connected and acyclic visited = set() def dfs(node, parent): visited.add(node) for neighbor in adj[node]: if neighbor not in visited: if not dfs(neighbor, node): return False elif neighbor != parent: # Found a cycle return False return True if not dfs(1, -1): return False # Ensure all nodes are visited (fully connected) return len(visited) == n"},{"question":"A string is said to be a **valid parentheses string** (vps) if it meets one of the following: 1. It is an empty string, `\\"\\"`, or 2. It can be written as `AB` (A concatenated with B), where `A` and `B` are vps, or 3. It can be written as `(A)`, where `A` is a vps. You are given a string `s` containing only parentheses characters `\'(\'` and `\')\'`. Write a function `minimumInsertionsToBalance(String s)` that returns the minimum number of insertions needed to make `s` a valid parentheses string. For example, given `s = \\"(()\\"` the function should return 1 because inserting `)` at the end of the string makes it balanced. **Function signature:** ```python def minimumInsertionsToBalance(s: str) -> int: # Your code here ```","solution":"def minimumInsertionsToBalance(s: str) -> int: Returns the minimum number of insertions needed to make s a valid parentheses string. left_needed = 0 # To count the needed \'(\' insertions = 0 # To count the needed \')\' for char in s: if char == \'(\': left_needed += 1 elif char == \')\': if left_needed > 0: left_needed -= 1 else: insertions += 1 # Any remaining needed \'(\' will require a \')\' insertion return insertions + left_needed"},{"question":"You are given a list of flights represented as pairs of cities `[from, to]`. Build a string itinerary starting from \\"JFK\\" such that the itinerary visits all the given flights exactly once and in lexicographical order if there are multiple valid itineraries. For example, if the input is `[[\\"MUC\\", \\"LHR\\"], [\\"JFK\\", \\"MUC\\"], [\\"SFO\\", \\"SJC\\"], [\\"LHR\\", \\"SFO\\"]]`, then the output should be `[\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"]`.","solution":"def find_itinerary(flights): from collections import defaultdict itinerary_map = defaultdict(list) # Create an adjacency list representation of the flights for start, end in sorted(flights): itinerary_map[start].append(end) result = [] def visit(airport): while itinerary_map[airport]: next_airport = itinerary_map[airport].pop(0) visit(next_airport) result.append(airport) visit(\'JFK\') return result[::-1]"},{"question":"Given a string `s`, which consists of lowercase letters and underscores (`\'_\'`), you need to determine the maximum number of subsequences of `\\"abc\\"` that can be formed using characters of `s` in their original order. Each character of the string can only be used once. Return _the maximum number of such subsequences_. For example, given `s = \\"abcaabc\\"`, you can form 2 subsequences of `\\"abc\\"`: - The first subsequence uses the first `a`, the second `b`, and the first `c`. - The second subsequence uses the second `a`, the first `b`, and the second `c`. If there are no possible subsequences that can be formed, return `0`.","solution":"def max_subsequences_abc(s): Returns the maximum number of subsequences of \\"abc\\" that can be formed using characters of s. a_count = 0 b_count = 0 c_count = 0 for char in s: if char == \'a\': a_count += 1 elif char == \'b\': b_count += 1 elif char == \'c\': c_count += 1 return min(a_count, b_count, c_count)"},{"question":"You are given an `m x n` grid where each cell can have a value of `0` (representing an empty cell) or `1` (representing a wall). You can perform multiple operations, where in each operation, you can switch any `0` cell to `1` or vice versa. Your goal is to find the minimum number of operations required to transform the grid into a state where there are no more than `k` walls (cells with value `1`). Return the minimum number of operations needed to achieve this grid state.","solution":"def min_operations_to_no_more_than_k_walls(grid, k): Returns the minimum number of operations required to transform the grid into a state where there are no more than k walls (cells with value `1`). m, n = len(grid), len(grid[0]) num_walls = sum(grid[i][j] for i in range(m) for j in range(n)) if num_walls == k: return 0 if num_walls > k: return num_walls - k return k - num_walls"},{"question":"You are given two integer arrays `arr1` and `arr2` both of length `n`. Your task is to modify `arr1` using the elements of `arr2` under the following conditions: 1. Iterate through each element of `arr1` and add the corresponding element from `arr2` to it. 2. If the result of this addition is greater than 10, subtract 10 from it. Return a new array representing the modified `arr1`. Please implement the function with the following signature: ```python def modify_array(arr1: List[int], arr2: List[int]) -> List[int]: ```","solution":"def modify_array(arr1, arr2): Modifies arr1 using elements in arr2 by adding corresponding elements and adjusting values greater than 10. Parameters: arr1 (List[int]): First list of integers. arr2 (List[int]): Second list of integers to be added to first list. Returns: List[int]: A new list with modified elements. result = [] for a1, a2 in zip(arr1, arr2): modified_value = a1 + a2 if modified_value > 10: modified_value -= 10 result.append(modified_value) return result"},{"question":"Given a binary tree, implement a function to find the largest subtree sum. The largest subtree sum is defined as the maximum sum of all values of nodes in any subtree in the binary tree. You need to return the sum of the largest subtree. If the binary tree is empty, the sum is considered to be zero. The tree node could have a negative, zero, or positive integer value.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_largest_subtree_sum(root): Returns the largest sum of any subtree in the given binary tree. def helper(node): nonlocal max_sum if not node: return 0 left_sum = helper(node.left) right_sum = helper(node.right) total_sum = node.val + left_sum + right_sum max_sum = max(max_sum, total_sum) return total_sum if not root: return 0 max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"You are given a string `s` consisting of only characters \'a\', \'b\', and \'c\'. You can replace any character with another character. Return _the length of the longest substring containing exactly `k` distinct characters_. If it is not possible to create such a substring, return `-1`.","solution":"def longest_substring_with_k_distinct_characters(s, k): Returns the length of the longest substring with exactly k distinct characters. If it\'s not possible, returns -1. if k == 0 or not s: return -1 n = len(s) if k > 3: # more than 3 distinct characters not possible with \'a\', \'b\', \'c\' return -1 max_len = -1 char_count = {} start = 0 for end in range(n): char = s[end] char_count[char] = char_count.get(char, 0) + 1 while len(char_count) > k: start_char = s[start] char_count[start_char] -= 1 if char_count[start_char] == 0: del char_count[start_char] start += 1 if len(char_count) == k: max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are tasked with managing a warehouse that operates over a span of `D` days. Each day, a certain number of products are expected to be delivered, and you have to ensure that you have enough storage capacity each day to handle these deliveries. You are given an integer `D` representing the number of days, and an array `deliveries` of size `D` where `deliveries[i]` is the number of products expected to be delivered on the `i-th` day. Additionally, you have an integer `capacity` representing the maximum number of products your warehouse can store at any time. You can clear out the warehouse completely at any point in the day, but doing so takes an entire day off from handling deliveries. The goal is to determine the minimum number of days you need to clear out the warehouse to ensure you never exceed the storage capacity on any day. Return _the minimum number of days needed to clear out the warehouse_.","solution":"def min_clear_out_days(D, deliveries, capacity): Returns the minimum number of days needed to clear out the warehouse. Parameters: D (int): number of days deliveries (list of int): deliveries per day capacity (int): maximum storage capacity Returns: int: minimum number of clear-out days needed clear_out_days = 0 current_storage = 0 for i in range(D): current_storage += deliveries[i] if current_storage > capacity: clear_out_days += 1 # We need to clear out the warehouse current_storage = deliveries[i] # Start with today\'s delivery again return clear_out_days"},{"question":"You are given an encoded string `s` and a dictionary of words `dict`. The encoded string `s` contains digits and possibly more digits representing delimiters between words. A valid decoding of `s` is such that every word in the decoded string belongs to the dictionary `dict`. The delimiters are given as numbers in a separate array `delimiters`, and they represent the indices in the string `s` where splits can occur. Implement the `Decoder` class: - `Decoder(String s, List<String> dict, List<Integer> delimiters)` Initializes the object with the encoded string `s`, the dictionary of valid words `dict`, and the list of permissible delimiter indices `delimiters`. - `boolean isValidEncoding()` Returns `true` if the string `s` can be fully decoded into words from `dict` using the delimiters, otherwise returns `false`. Example: - `s = \\"123456\\"` - `dict = [\\"12\\", \\"34\\", \\"56\\", \\"1234\\", \\"56\\"]` - `delimiters = [2, 4]` In this example, a valid decoding would be [\\"12\\", \\"34\\", \\"56\\"], so the function should return `true`.","solution":"class Decoder: def __init__(self, s, dictionary, delimiters): Initializes the object with the encoded string s, the dictionary of valid words dictionary, and the list of permissible delimiter indices delimiters. self.s = s self.dictionary = set(dictionary) self.delimiters = sorted(delimiters) def isValidEncoding(self): Returns true if the string s can be fully decoded into words from the dictionary using the delimiters, otherwise returns false. n = len(self.s) # Helper method to check if a segment of s is in the dictionary def isValidSegment(start, end): return self.s[start:end] in self.dictionary # A dynamic programming approach to determine if the string can be segmented using the provided delimiters dp = [False] * (n + 1) dp[0] = True # Empty string is a valid encoding for i in range(1, n + 1): for delimiter in self.delimiters: if i - delimiter >= 0 and dp[i - delimiter] and isValidSegment(i - delimiter, i): dp[i] = True break return dp[n]"},{"question":"You are given a string `s` consisting only of digits. A replacement consists of removing any substring of consecutive identical digits and replacing it with a single occurrence of that digit. For example, replacing \\"111\\" with \\"1\\". The goal is to perform the operation repeatedly until no further replacement is possible. Return the resulting string after all replacements have been performed. For example: - If `s = \\"112233\\"`, after replacements it becomes \\"123\\". - If `s = \\"444223355\\"`, after replacements it becomes \\"4235\\".","solution":"def remove_consecutive_digits(s): Removes consecutive identical digits from the string `s`, replacing them with a single occurrence of that digit, until no further replacement is possible. Parameters: s (str): The input string consisting solely of digits. Returns: str: The resulting string after performing all replacements. if not s: return s result = [] prev_char = None for char in s: if prev_char != char: result.append(char) prev_char = char return \'\'.join(result)"},{"question":"You are given a list of `operations`, where each operation is represented by a string. The allowable operations are: * `\\"push x\\"`: Push the integer `x` onto the stack. * `\\"pop\\"`: Remove the element on the top of the stack. * `\\"inc k v\\"`: Increment the bottom `k` elements of the stack by the integer `v`. Initially, the stack is empty. Implement the function that processes the given operations and returns the configuration of the stack after performing all operations. If an operation is invalid or cannot be performed (e.g., pop from an empty stack), it should be ignored.","solution":"def process_operations(operations): Processes a list of operations and returns the stack configuration. Parameters: operations (list): List of operations as strings. Returns: list: The final stack configuration. stack = [] for operation in operations: parts = operation.split() if parts[0] == \\"push\\" and len(parts) == 2: try: x = int(parts[1]) stack.append(x) except ValueError: pass # ignore if not a valid integer elif parts[0] == \\"pop\\" and len(parts) == 1: if stack: stack.pop() elif parts[0] == \\"inc\\" and len(parts) == 3: try: k = int(parts[1]) v = int(parts[2]) for i in range(min(k, len(stack))): stack[i] += v except ValueError: pass # ignore if not valid integers return stack"},{"question":"You are given a list of words and a pattern. Return a list of words from the given list that match the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter `x` in the pattern with `p(x)`, we get the desired word. Implement the function `List<String> findAndReplacePattern(List<String> words, String pattern)` where: - `words` is a list of strings representing the list of words. - `pattern` is a string representing the pattern. Each word and the pattern will have the same length.","solution":"def match(word, pattern): Helper function to check if the word matches the pattern. mapping = {} reverse_mapping = {} for w_char, p_char in zip(word, pattern): if w_char in mapping: if mapping[w_char] != p_char: return False else: mapping[w_char] = p_char if p_char in reverse_mapping: if reverse_mapping[p_char] != w_char: return False else: reverse_mapping[p_char] = w_char return True def findAndReplacePattern(words, pattern): Find and return the list of words matching the given pattern. result = [] for word in words: if match(word, pattern): result.append(word) return result"},{"question":"You are given a list of `n` intervals, where each interval is represented as a tuple `(start, end)`. An interval `(start, end)` represents a continuous range of integers from `start` to `end` (both inclusive). Your goal is to insert a new interval `(new_start, new_end)` into the list of intervals and merge all overlapping intervals to produce a list of mutually exclusive intervals. Then return the modified list of intervals. Intervals are considered overlapping if there is at least one integer that is present in both intervals. Formally, two intervals `(start1, end1)` and `(start2, end2)` are overlapping if `start1 <= end2` and `start2 <= end1`. Return the list of merged intervals sorted by their starting points.","solution":"def merge_intervals(intervals, new_interval): Inserts a new interval into the list of intervals and merges all overlapping intervals. Parameters: intervals (list of tuples): List of existing intervals (start, end). new_interval (tuple): A new interval (new_start, new_end). Returns: list of tuples: The modified list of intervals after insertion and merging. intervals.append(new_interval) intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged"},{"question":"You are given a grid `grid` of size `m x n` consisting of non-negative integers. In one move, you can choose any cell and decrease any of its 4-connected neighbors by 1. A cell is 4-connected if it is directly adjacent to another cell horizontally or vertically. You want to make all values in the grid equal to zero. Return the **minimum number of moves** required to achieve this. *Note*: You are allowed to decrease a neighbor below zero, and the value of a cell can go negative without any restrictions.","solution":"def min_number_of_moves(grid): Returns the minimum number of moves to make all values in the grid equal to zero. return sum(sum(row) for row in grid)"},{"question":"You are given a string `s` and an integer `n`. Your task is to rotate the string `s` to the right by `n` positions. If `n` is greater than the length of the string, continue the rotation by counting the excess positions. Implement a function that performs this string rotation and returns the resulting string.","solution":"def rotate_string(s, n): Rotates the string to the right by n positions. If n is greater than the length of the string, it continues the rotation by counting the excess positions. Parameters: s (str): The string to be rotated. n (int): Number of positions to rotate to the right. Returns: str: The rotated string. if not s: return s n = n % len(s) return s[-n:] + s[:-n]"},{"question":"You are given a string `s` representing a sequence of brackets. The brackets are of four types: round `()`, square `[]`, curly `{}`, and angular `<>`. A bracket sequence is considered balanced if the following conditions are met: - An opening bracket must have a corresponding closing bracket of the same type. - Opening brackets must close in the correct order. For example, the strings `([])`, `{[()<>]}`, and `<{[]}>` are balanced, but the strings `][`, `({[}>)]`, and `[(<)]` are unbalanced. Write a function `isBalanced(s: str) -> bool` that returns `True` if the given string `s` is a balanced bracket sequence and `False` otherwise.","solution":"def isBalanced(s: str) -> bool: Returns True if the given string s is a balanced bracket sequence, else False. stack = [] opening_brackets = \\"([{<\\" closing_brackets = \\")]}>\\" matching_bracket = {\\")\\": \\"(\\", \\"]\\": \\"[\\", \\"}\\": \\"{\\", \\">\\": \\"<\\"} for char in s: if char in opening_brackets: stack.append(char) elif char in closing_brackets: if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return not stack"},{"question":"Given a binary tree, return the largest sum of any path that starts and ends at any node in the tree. A path is defined as a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can be included in the path only once, but it doesn\'t have to start at the root or end at a leaf. # Function Signature: ```python def maxPathSum(root: Optional[TreeNode]) -> int: ``` # Example: ```markdown Input: root = [-10,9,20,null,null,15,7] Output: 42 Explanation: The path with the maximum sum is [15,20,7], which has a sum of 42. ``` # Constraints: - The number of nodes in the tree is in the range [1, 3 * 10^4]. - -1000 <= Node.val <= 1000","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root: Optional[TreeNode]) -> int: def helper(node): nonlocal max_sum if not node: return 0 left = max(helper(node.left), 0) right = max(helper(node.right), 0) current_path_sum = node.val + left + right max_sum = max(max_sum, current_path_sum) return node.val + max(left, right) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"You are given a list of integers `nums` where each integer represents a position on a number line. You are also given an integer `d` which represents the maximum allowable distance between any two elements in a subset. Your task is to determine the size of the largest subset such that the absolute difference between any two elements in the subset is at most `d`. Return an integer representing the size of the largest valid subset.","solution":"def largest_subset(nums, d): Returns the size of the largest subset such that the absolute difference between any two elements in the subset is at most d. Args: - nums: List of integers - d: Integer representing the maximum allowable distance Returns: - Integer representing the size of the largest valid subset if not nums: return 0 nums.sort() max_count = 0 for i in range(len(nums)): count = 1 for j in range(i + 1, len(nums)): if nums[j] - nums[i] <= d: count += 1 else: break max_count = max(max_count, count) return max_count"},{"question":"You\'re working on an e-commerce platform where a product can have various reviews. Each review has a rating from `1` to `5` and a timestamp of when the review was submitted. Given a list of tuples `reviews` where each tuple contains the `rating` (an integer between 1 and 5) and the `timestamp` (a string in the format `\\"YYYY-MM-DD HH:MM\\"`) of a review, you need to implement a feature that returns the average rating of the product for a specific period. You are given two strings `startPeriod` and `endPeriod` representing the start and end of the period respectively in the format `\\"YYYY-MM-DD HH:MM\\"`. The average rating should be returned as a float rounded to two decimal places. If there are no reviews in the specified period, return `0.00`.","solution":"from datetime import datetime def average_rating(reviews, startPeriod, endPeriod): Returns the average rating of the product within the specified period. Parameters: reviews (list of tuples): A list where each tuple contains the rating (int) and timestamp (str). startPeriod (str): The start of the period in the format \\"YYYY-MM-DD HH:MM\\". endPeriod (str): The end of the period in the format \\"YYYY-MM-DD HH:MM\\". Returns: float: The average rating rounded to two decimal places, or 0.00 if there are no reviews in the period. start = datetime.strptime(startPeriod, \\"%Y-%m-%d %H:%M\\") end = datetime.strptime(endPeriod, \\"%Y-%m-%d %H:%M\\") relevant_ratings = [ rating for rating, timestamp in reviews if start <= datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M\\") <= end ] if not relevant_ratings: return 0.00 return round(sum(relevant_ratings) / len(relevant_ratings), 2)"},{"question":"Given a **0-indexed** 2D integer array `matrix` where `matrix[i][j]` represents the cost to travel from city `i` to city `j` for a business trip and an integer `k` representing the number of trips you need to plan, determine the minimum cost to complete exactly `k` trips starting from any city and returning to the same city. Implement the function `int minCostTrip(int[][] matrix, int k)` that returns the minimum cost. Note: You may assume that each trip consists of visiting an immediate neighboring city and you are allowed to visit the same city multiple times over the course of these `k` trips.","solution":"def minCostTrip(matrix, k): Returns the minimum cost to complete exactly k trips starting from any city and returning to the same city. n = len(matrix) if k == 0: return 0 min_cost = float(\'inf\') for city in range(n): # Base case: 1 trip, must return to the same city (so from city to city) cost_for_city = matrix[city][city] # Add (k-1) times cost of smallest loop from any other city min_neighbor_cost = min(matrix[city][neighbor] for neighbor in range(n) if neighbor != city) overall_city_cost = cost_for_city + (k-1) * min_neighbor_cost # Update the minimum found cost min_cost = min(min_cost, overall_city_cost) return min_cost"},{"question":"You are given an unordered list of unique integers `nums` representing the positions of stones in a river. The river is represented as an array where the positions of the stones are the indices of the array. A frog starts at the first stone (position 0) and can jump to the next stone in the list if and only if the distance of the jump is exactly `k`, where `k` is the length of the list of previous jumps (including the current jump). The frog initially can only jump to the first stone from position 0. Write a function to determine if the frog can cross the river by landing on the last stone. If the frog can cross, return `True`, otherwise, return `False`.","solution":"def can_cross_river(stones): Determine if the frog can cross the river by landing on the last stone. Args: stones (List[int]): List of unique integers representing the positions of stones. Returns: bool: True if the frog can cross the river, otherwise False. if not stones or stones[0] != 0: return False stone_positions = set(stones) last_stone = stones[-1] memo = {} def can_jump(curr_pos, jump_length): if (curr_pos, jump_length) in memo: return memo[(curr_pos, jump_length)] if curr_pos == last_stone: return True if curr_pos > last_stone or curr_pos < 0 or curr_pos not in stone_positions: return False for new_jump in [jump_length - 1, jump_length, jump_length + 1]: if new_jump > 0 and can_jump(curr_pos + new_jump, new_jump): memo[(curr_pos, jump_length)] = True return True memo[(curr_pos, jump_length)] = False return False return can_jump(0, 0)"},{"question":"You are given a 2D grid of size `m x n` representing a maze filled with `0`s (empty spaces) and `1`s (walls). You need to find the shortest path from the top-left corner of the maze (position `(0, 0)`) to the bottom-right corner (position `(m-1, n-1)`), while breaking at most one wall. You can move up, down, left, or right. Return _the length of the shortest path from the top-left corner to the bottom-right corner, or `-1` if such a path does not exist._","solution":"from collections import deque def shortest_path_with_one_wall_break(grid): Given a 2D grid representing a maze filled with `0`s (empty spaces) and `1`s (walls), returns the length of the shortest path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` while breaking at most one wall. m, n = len(grid), len(grid[0]) if not grid or grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0, 1)]) # (row, col, wall broken status, distance) visited = [[[False, False] for _ in range(n)] for _ in range(m)] visited[0][0][0] = True while queue: x, y, broken, dist = queue.popleft() if x == m-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == 0 and not visited[nx][ny][broken]: # Move to empty space visited[nx][ny][broken] = True queue.append((nx, ny, broken, dist + 1)) elif grid[nx][ny] == 1 and broken == 0 and not visited[nx][ny][1]: # Break a wall visited[nx][ny][1] = True queue.append((nx, ny, 1, dist + 1)) return -1"},{"question":"You are given an integer array `arr` of size `n`, which contains the distinct integers from `1` to `n` in random order. You need to sort this array in ascending order using only the following operation: select an index `i` and swap `arr[i]` with `arr[i+1]`. Return the minimum number of swaps required to sort the array in ascending order.","solution":"def min_swaps_to_sort(arr): Return the minimum number of swaps required to sort the array in ascending order. n = len(arr) arr_with_indices = [(val, idx) for idx, val in enumerate(arr)] # Sort the array by values while keeping the original indices arr_with_indices.sort(key=lambda x: x[0]) visited = [False] * n swaps = 0 for i in range(n): # If element is already visited or in the correct position if visited[i] or arr_with_indices[i][1] == i: continue # Find the size of the cycle cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_with_indices[j][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"Given a list of non-negative integers `nums` representing the number of stones in each pile, where each pile can have a different number of stones. In a single move, you can choose any two piles and remove one stone from each pile. The goal is to determine the maximum number of moves you can perform. A move is defined as choosing any two non-empty piles and removing one stone from each. The game ends when it is no longer possible to perform a move. Return the maximum number of moves you can perform.","solution":"def max_moves(nums): Returns the maximum number of moves where each move consists of picking two non-empty piles and removing one stone from each pile. Parameters: nums (list of int): A list of non-negative integers representing the number of stones in each pile. Returns: int: Maximum number of moves that can be performed. total_stones = sum(nums) max_stones_in_pile = max(nums) if max_stones_in_pile > total_stones - max_stones_in_pile: return total_stones - max_stones_in_pile else: return total_stones // 2"},{"question":"Given an array of integers `arr` of size `n` and an integer `d`, your task is to split the array into `d` contiguous subarrays such that the maximum sum of any subarray is minimized. Return _the minimized maximum sum of the subarrays_.","solution":"def split_array_max_sum(arr, d): Function to split an array into d contiguous subarrays such that the maximum sum of any subarray is minimized. Returns the minimized maximum sum of the subarrays. def valid(mid): # Helper function to determine if a given maximum sum `mid` can be achieved count, total = 1, 0 for num in arr: total += num if total > mid: total = num count += 1 if count > d: return False return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if valid(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of `n` integers `heights` representing the height of citizens in a town. Two citizens `i` and `j` can be friends if `|heights[i] - heights[j]| <= k` for a given integer `k`. The town\'s mayor wants to identify the maximum number of friends any citizen can have. Write a function that returns this maximum number of friends. For example, given the list `heights = [1, 3, 4, 5, 6]` and `k = 2`, the function should return `3`, since the citizen with height `4` can have friends with heights `3`, `4`, and `5`, which results in the maximum number of friends being `3`.","solution":"def max_friends(heights, k): Returns the maximum number of friends any citizen can have based on the given criterion. n = len(heights) heights.sort() max_friends = 0 for i in range(n): count = 1 for j in range(i+1, n): if abs(heights[j] - heights[i]) <= k: count += 1 else: break max_friends = max(max_friends, count) return max_friends"},{"question":"Given an array of integers `arr` and an integer `k`, modify the array such that it only contains distinct elements, and the sum of these elements is as large as possible. You are allowed to remove elements from the array, but not to add any new elements. Return the sum of the modified array.","solution":"def largest_sum_distinct(arr, k): Modify the array such that it only contains distinct elements, and the sum of these elements is as large as possible. The size of the array after modification should not exceed k. Parameters: arr : list of int : input array of integers k : int : maximum number of elements the modified array can have Returns: int : sum of the modified array with distinct elements and maximum sum # Remove duplicates and sort the array in descending order distinct_sorted = sorted(set(arr), reverse=True) # Consider only up to k elements for the sum result_sum = sum(distinct_sorted[:k]) return result_sum"},{"question":"You are given a directed graph represented by an adjacency list, where `graph[i]` is a list of all nodes `j` for which there is a directed edge from node `i` to node `j`. Each node represents a course, and each directed edge represents a prerequisite relationship. Determine if it is possible to complete all courses by returning _True_ if it is possible to finish all courses, or _False_ if it is not possible due to a circular dependency among courses.","solution":"def can_finish_courses(num_courses, prerequisites): Determines if it is possible to finish all courses given the prerequisites. Parameters: num_courses (int): The total number of courses. prerequisites (List[List[int]]): The list of prerequisite pairs, where each pair [a, b] indicates that course a depends on course b. Returns: bool: True if it is possible to finish all courses, False otherwise. # Create an adjacency list from the prerequisites graph = {i: [] for i in range(num_courses)} for dest, src in prerequisites: graph[src].append(dest) # Track visited nodes to detect cycles visiting = set() visited = set() def has_cycle(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph[node]: if has_cycle(neighbor): return True visiting.remove(node) visited.add(node) return False for course in range(num_courses): if has_cycle(course): return False return True"},{"question":"Given an integer array `nums`, find the largest integer `k` such that both `k` and `-k` exist in the array. If there is no such integer, return `0`. Each element in the array is unique. Example: If the input array is `[3, -3, 1, 2, -2, -1, -4]`, the output should be `3` because `3` and `-3` exist in the array and have the highest absolute value. If the input array is `[1, 2, 3, -4]`, the output should be `0` because no such pairs exist.","solution":"def find_largest_k(nums): Finds the largest integer k such that both k and -k exist in the array. Args: nums (list of int): The list of integers Returns: int: The largest integer k such that both k and -k exist in the array, or 0 if no such pair exists. num_set = set(nums) largest_k = 0 for num in nums: if num > 0 and -num in num_set: largest_k = max(largest_k, num) return largest_k"},{"question":"You are given a string `s` containing only lowercase English letters. Construct a new string by rearranging the letters of `s` so that no two adjacent characters are the same. If it is not possible to do so, return an empty string.","solution":"import heapq from collections import Counter def rearrange_string(s): Rearranges string s so that no two adjacent characters are the same. :param s: Input string containing only lowercase English letters :return: Rearranged string or empty string if not possible count = Counter(s) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) prev_char, prev_count = None, 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char is not None and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 result_string = \'\'.join(result) if len(result_string) != len(s): return \'\' return result_string"},{"question":"You are given an array of integers `arr` and an integer `targetSum`. Your task is to determine if there are three distinct elements in `arr` such that their sum is equal to `targetSum`. If such a triplet exists, return _the triplet as a list of integers in non-decreasing order_. If there are multiple valid triplets, return _any one of them_. If no such triplet exists, return an _empty list_.","solution":"def find_triplet(arr, targetSum): Returns a list of three distinct elements from the array `arr` whose sum is equal to `targetSum`. If no such triplet exists, returns an empty list. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == targetSum: return [arr[i], arr[left], arr[right]] elif total < targetSum: left += 1 else: right -= 1 return []"},{"question":"Given a string `s` containing only lowercase English letters and a list of `queries`, where each query is a list `[start, end, letter]`, return an array of answers. For each query, find the number of occurrences of `letter` in the substring of `s` ranging from index `start` to `end` (inclusive). Each substring\'s length will be at least 1.","solution":"def count_letter_occurrences(s, queries): Given a string s and a list of queries, return the number of occurrences of a specified letter in the given substring range for each query. :param s: str - the input string :param queries: list of [start, end, letter] - the list of queries :return: list of int - occurrences of specified letter for each query results = [] for query in queries: start, end, letter = query substring = s[start:end + 1] count = substring.count(letter) results.append(count) return results"},{"question":"You are given a list of `n` positive integers, representing the heights of buildings in a row. The goal is to find the leftmost building from which you can view the ocean. A building has an ocean view if it is not smaller than all the buildings to its right. Write a function that returns a list of indices of buildings that have an ocean view in increasing order. Note that the indices start from 0. For example, given the list `[4, 2, 3, 1]`, buildings at index 0, 2, and 3 can see the ocean because their heights are greater than or equal to any building to their right. Return a list of indices with ocean views.","solution":"def find_buildings_with_ocean_view(heights): Returns a list of indices of buildings that have an ocean view. :param heights: List of integers representing the heights of buildings :return: List of indices with ocean views n = len(heights) if n == 0: return [] ocean_view_indices = [] max_height_to_right = float(\'-inf\') for i in reversed(range(n)): if heights[i] >= max_height_to_right: ocean_view_indices.append(i) max_height_to_right = heights[i] return ocean_view_indices[::-1]"},{"question":"You are given a set of integers `nums` and an integer `target`. Your task is to determine if `target` can be written as the sum of any combination of elements from `nums`, where each element can be used multiple times. Write a function that returns `true` if `target` can be achieved, and `false` otherwise. **Note:** - The combination of elements does not need to be unique. - The same element can be used multiple times. - You may assume that all elements of `nums` and `target` are positive integers. **Example:** ```python nums = [2, 3, 7] target = 7 # Output: True # Explanation: 7 can be achieved by the combination [7] or using [2, 2, 3]. nums = [5, 3, 4] target = 7 # Output: True # Explanation: 7 can be achieved by the combination [3, 4]. nums = [4, 6] target = 5 # Output: False # Explanation: 5 cannot be achieved by any combination of elements from the set [4, 6]. ```","solution":"def can_sum(nums, target): Returns true if target can be achieved by the sum of any combination of elements from nums. Each element in nums can be used multiple times. # Boolean list to keep track of achievable sums up to target. dp = [False] * (target + 1) dp[0] = True for i in range(target + 1): if dp[i]: for num in nums: if i + num <= target: dp[i + num] = True return dp[target]"},{"question":"You are given a string `s` that contains only lowercase English letters and an integer `k`. You need to transform the string `s` into a string `t` such that `t` has no more than `k` distinct characters. To achieve this, you can perform the following operation any number of times: - Choose any character in the string `s` and change it to any other lowercase English letter. Return _the minimum number of operations required to transform_ `s` _into_ `t`_. If it is not possible, return_ `-1`_.","solution":"from collections import Counter def min_operations_to_k_distinct_chars(s, k): Returns the minimum number of operations required to transform the string `s` into a string `t` with no more than `k` distinct characters. if k == 0 and len(s) == 0: return 0 if k == 0 or k > 26: return -1 char_count = Counter(s) distinct_chars = len(char_count) if distinct_chars <= k: return 0 # Create a sorted list of character frequencies in descending order frequencies = sorted(char_count.values(), reverse=True) operations = 0 while distinct_chars > k: # Remove the least frequent character operations += frequencies.pop() distinct_chars -= 1 return operations"},{"question":"You are given two strings `s1` and `s2`. Your task is to determine if `s2` is a **subsequence** of `s1`. Return _`true` if `s2` is a subsequence of `s1`, and `false` otherwise_. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.","solution":"def is_subsequence(s1, s2): Determines if s2 is a subsequence of s1. Args: s1 (str): The original string. s2 (str): The string to check if it is a subsequence of s1. Returns: bool: True if s2 is a subsequence of s1, False otherwise. iter_s1 = iter(s1) return all(char in iter_s1 for char in s2)"},{"question":"You are given an **n-ary tree** with `n` nodes labeled from `0` to `n-1` and an integer array `parent` of length `n` where `parent[i]` is the parent of node `i`. The root node has no parent and its parent index will be given as `-1`. Implement a function to *determine the depth of the deepest leaf node* in the tree. The depth of a node is the number of edges from the root node to the node. Note that a tree with only one node has a depth of `0`. Return the depth of the deepest leaf node.","solution":"from collections import defaultdict, deque def deepest_leaf_depth(n, parent): Determines the depth of the deepest leaf node in the n-ary tree. Parameters: n (int): The number of nodes in the tree. parent (List[int]): The parent array where parent[i] is the parent of node i. Returns: int: The depth of the deepest leaf node. if n == 1: return 0 tree = defaultdict(list) root = None for i in range(n): if parent[i] == -1: root = i else: tree[parent[i]].append(i) # BFS to find the depth of the deepest leaf node queue = deque([(root, 0)]) max_depth = 0 while queue: node, depth = queue.popleft() if not tree[node]: # If no children, it\'s a leaf node max_depth = max(max_depth, depth) for child in tree[node]: queue.append((child, depth + 1)) return max_depth"},{"question":"Given an array of integers where each element appears exactly three times, except for one element which appears exactly once. Find the element that appears only once. Return that single element.","solution":"def single_number(nums): Given an array of integers where each element appears exactly three times except for one element which appears exactly once, find the element that appears only once and return it. ones, twos = 0, 0 for num in nums: # Update \'ones\' by including the bit that\'s not in \'twos\' ones = (ones ^ num) & ~twos # Update \'twos\' by including the current num bitwise operation twos = (twos ^ num) & ~ones return ones"},{"question":"Given an array of integers `arr`, return the length of the **longest** continuous subarray that contains only even numbers.","solution":"def longest_even_subarray(arr): Returns the length of the longest continuous subarray that contains only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"Given a string `s` which represents an expression. The valid expressions consist of numbers, `+`, `-`, `*`, `and` parentheses. 1. Add \' \' (a space character) around every operator and parenthesis in the string. 2. Remove any leading or trailing spaces. 3. Convert the resulting string into a list of strings and integers, where integers should not be split into individual characters (e.g., \\"12\\" should not be split into `[\\"1\\", \\"2\\"]`). For example: - Input: `\\"3+2*(7-5)\\"` - Output: ` [\\"3\\", \\"+\\", \\"2\\", \\"*\\", \\"(\\", \\"7\\", \\"-\\", \\"5\\", \\")\\"]` Return the final list of strings and integers representing the cleaned and split expression.","solution":"def parse_expression(s): Parses the input expression string, adding spaces around operators and parentheses, and then splitting into a list of strings and integers. Parameters: s (str): The input expression string. Returns: List[Union[int, str]]: The parsed list containing integers and operators. if not s: return [] operators = {\'+\', \'-\', \'*\', \'(\', \')\'} result = [] num = \'\' for char in s: if char in operators: if num: result.append(int(num)) num = \'\' result.append(char) else: num += char if num: result.append(int(num)) return result"},{"question":"Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the `WordDictionary` class: - `WordDictionary()` Initializes the object. - `void addWord(String word)` Adds `word` to the data structure, it can be matched later. - `boolean search(String word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `\'.\'` where a dot can replace any letter. Example: ``` Input [\\"WordDictionary\\", \\"addWord\\", \\"addWord\\", \\"addWord\\", \\"search\\", \\"search\\", \\"search\\", \\"search\\"] [[], [\\"bad\\"], [\\"dad\\"], [\\"mad\\"], [\\"pad\\"], [\\"bad\\"], [\\".ad\\"], [\\"b..\\"]] Output [null, null, null, null, false, true, true, true] Explanation WordDictionary wordDictionary = new WordDictionary(); wordDictionary.addWord(\\"bad\\"); wordDictionary.addWord(\\"dad\\"); wordDictionary.addWord(\\"mad\\"); wordDictionary.search(\\"pad\\"); // return False wordDictionary.search(\\"bad\\"); // return True wordDictionary.search(\\".ad\\"); // return True wordDictionary.search(\\"b..\\"); // return True ```","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str): self.words.append(word) def search(self, word: str) -> bool: import re for w in self.words: if re.fullmatch(word.replace(\'.\', \'[a-z]\'), w): return True return False"},{"question":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, `pos` is used to denote the index of the node that tail\'s next pointer is connected to. Note that `pos` is not passed as a parameter. **Custom Judge:** The judge will test your solution with the following code: ```python # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head: ListNode) -> Optional[ListNode]: # Calls your implementation of the algorithm # Returns the node if there is a cycle, otherwise returns None ``` To get accepted, you need to do the following things: - If there is no cycle in the list, return `None`. - If there is a cycle, return the node where the cycle begins. Note that `head` is the first node in the linked list.","solution":"from typing import Optional class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head: Optional[ListNode]) -> Optional[ListNode]: if not head or not head.next: return None slow = head fast = head # Detect if a cycle exists while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # No cycle # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given a grid of size `m x n` representing a room with a robot initially located at the position `(startRow, startColumn)`. The robot can move in four possible directions: up, down, left, right. Some cells in the grid may be obstacles, represented by `-1`, where the robot cannot pass. The robot aims to visit all reachable cells in the grid exactly once and return to the starting position. Implement the function `bool canCompleteCircuit(vector<vector<int>>& grid, int startRow, int startColumn)` that determines if the robot can complete the desired circuit, visiting all reachable cells exactly once before returning to the initial starting point. **Function Signature:** ```cpp bool canCompleteCircuit(vector<vector<int>>& grid, int startRow, int startColumn); ``` **Example:** ```cpp Input: grid = [ [0, 0, 0, -1], [0, -1, 0, 0], [0, 0, 0, 0] ] startRow = 0 startColumn = 0 Output: true ``` **Explanation:** The robot can successfully visit all reachable cells exactly once and return to the starting position following the path (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (1,2) -> (0,2) -> (0,1) -> (0,0). **Note:** - The grid cells can either be `0` (free space) or `-1` (obstacle). - The robot cannot go outside the boundaries of the grid.","solution":"def canCompleteCircuit(grid, startRow, startColumn): def is_within_bounds(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def dfs(x, y, visited, cells_to_visit): if not is_within_bounds(x, y) or grid[x][y] == -1: return False if (x, y) in visited: return False visited.add((x, y)) if len(visited) == cells_to_visit: return True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] results = [] for dx, dy in directions: nx, ny = x + dx, y + dy if dfs(nx, ny, visited, cells_to_visit): results.append(True) if any(results): return True visited.remove((x, y)) return False rows, cols = len(grid), len(grid[0]) cells_to_visit = sum(row.count(0) for row in grid) if grid[startRow][startColumn] == -1: return False return dfs(startRow, startColumn, set(), cells_to_visit)"},{"question":"Write an algorithm that takes as input a 2D grid of characters `board` and a string `word`. Return `true` if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. The input `board` and `word` will contain only lowercase and uppercase English letters. Note that the function signature should be `def exist(board: List[List[str]], word: str) -> bool`.","solution":"from typing import List def exist(board: List[List[str]], word: str) -> bool: if not board: return False rows, cols = len(board), len(board[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[index]: return False temp = board[r][c] board[r][c] = \'#\' found = (dfs(r + 1, c, index + 1) or dfs(r - 1, c, index + 1) or dfs(r, c + 1, index + 1) or dfs(r, c - 1, index + 1)) board[r][c] = temp return found for r in range(rows): for c in range(cols): if dfs(r, c, 0): return True return False"},{"question":"You are given an m x n integer matrix `mat`, where each cell contains either a 0 or 1. Your task is to find the number of islands in the matrix. An island is a group of connected 1\'s (horizontally, vertically, or diagonally), surrounded by 0\'s. Return the total number of islands in the matrix. **Example of matrix illustration**: - `1` represents land. - `0` represents water. The matrix: ``` 1 1 0 0 0 0 1 0 0 1 1 0 0 1 1 0 0 0 0 0 1 0 1 0 1 ``` contains 5 islands.","solution":"def num_islands(mat): Given an m x n integer matrix mat, returns the number of islands. An island is a group of connected 1\'s (horizontally, vertically, or diagonally), surrounded by 0\'s. if not mat: return 0 m, n = len(mat), len(mat[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1), (cx-1, cy-1), (cx+1, cy+1), (cx-1, cy+1), (cx+1, cy-1)]: if 0 <= nx < m and 0 <= ny < n and mat[nx][ny] == 1 and not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) island_count = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and not visited[i][j]: visited[i][j] = True dfs(i, j) island_count += 1 return island_count"},{"question":"Given a binary string `s`, return the length of the longest substring containing at most one distinct character. If the string is empty, return 0.","solution":"def longest_substring_with_one_distinct_char(s): Returns the length of the longest substring containing at most one distinct character. :param s: A binary string :return: Length of the longest substring with at most one distinct character if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"You are given an array of integers `heights` representing the heights of buildings at each row in a city skyline, such that `heights[i]` denotes the height of the `i-th` building. A new tower will be constructed according to the following conditions: - It must cover at least the maximum height of all buildings to its left in the array. - It must cover at least the maximum height of all buildings to its right in the array. Your task is to determine the minimum height required for the tower that meets these conditions. Return _the minimum height needed for the new tower to satisfy the conditions_.","solution":"def min_tower_height(heights): Returns the minimum height needed for the new tower to satisfy the conditions. if not heights: return 0 max_left = 0 max_right = 0 for height in heights: if height > max_left: max_left = height for height in reversed(heights): if height > max_right: max_right = height return max(max_left, max_right)"},{"question":"You are given a string `s` containing only digits. Your task is to find the highest numerical value of any contiguous subarray of length `k`. Return the maximum value as a string to preserve leading zeros, if any.","solution":"def find_max_subarray_value(s, k): Returns the highest numerical value of any contiguous subarray of length k as a string. max_value = \\"\\" for i in range(len(s) - k + 1): current_subarray = s[i:i+k] if max_value == \\"\\" or current_subarray > max_value: max_value = current_subarray return max_value"},{"question":"You are given a string `s` that consists of only digits. You can split `s` into any number of non-empty substrings such that each substring represents a valid binary string (i.e., without leading zeros except for \\"0\\"). Return the maximum number of substrings you can create from `s`. # Examples: 1. **Input:** `s = \\"101110\\"` **Output:** `4` **Explanation:** We can split the string into \\"1\\", \\"0\\", \\"11\\", \\"10\\". Each binary string is valid. 2. **Input:** `s = \\"000\\"` **Output:** `3` **Explanation:** We can split the string into \\"0\\", \\"0\\", \\"0\\". Each binary string is valid.","solution":"def max_valid_binary_substrings(s): Returns the maximum number of valid binary substrings from the given string s. A valid binary substring has no leading zeros unless the substring is \\"0\\". return len(s)"},{"question":"You are given a `0-indexed` integer array `arr` of length `n` and an integer `k`. You can select a subarray of length `k` and reverse it. Return _the minimal possible value of the sum of the first `k` elements of the array after reversing exactly one subarray of length `k`._ If it is impossible to reverse a subarray because `k` is greater than `n`, return the sum of the first `k` elements of the original array.","solution":"def min_k_sum(arr, k): Returns the minimal possible value of the sum of the first k elements of the array after reversing exactly one subarray of length k. If k is greater than the length of the array, return the sum of the first k elements. n = len(arr) if k > n: return sum(arr[:k]) min_sum = float(\'inf\') for i in range(n - k + 1): original_sum = sum(arr[:k]) subarray_sum = sum(arr[i:i + k]) new_arr = arr[:i] + arr[i:i + k][::-1] + arr[i + k:] reversed_sum = sum(new_arr[:k]) min_sum = min(min_sum, reversed_sum) return min_sum"},{"question":"You are given a string `s` of length `n` containing only digits (`0`-`9`). Your task is to determine the number of ways to decode this string into an alphabet sequence where `1` maps to `A`, `2` maps to `B`, ..., `26` maps to `Z`. Note that the string `s` may contain invalid patterns that cannot be decoded. Return the total number of valid decoding ways. If it\'s not possible to decode the string, return 0.","solution":"def num_decodings(s): Returns the number of ways to decode a string containing only digits. if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != \'0\': dp[i] += dp[i - 1] if i > 1 and s[i - 2:i] >= \'10\' and s[i - 2:i] <= \'26\': dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given an `n x n` grid, where each cell is either a 0 (empty) or a 1 (blocked). The grid represents a path-finding area for a robot. The robot starts at the top-left corner (0, 0) and aims to reach the bottom-right corner (n-1, n-1). The robot can only move **right**, **down**, **left**, or **up**, and it cannot move diagonally. You need to determine the **minimum number of moves** required for the robot to reach the bottom-right corner from the top-left corner. If there is no valid path, return -1. Implement the function `int shortestPath(int[][] grid)` that returns the minimum number of moves required to reach the target, or -1 if no such path exists.","solution":"from collections import deque def shortestPath(grid): Determines the minimum number of moves required for the robot to reach the bottom-right corner from the top-left corner in a grid. If there is no valid path, returns -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given a list of integers `arr` which represents the daily stock prices of a company. You can perform a single buy and sell operation to maximize your profit. Your task is to write a function that returns the maximum profit you can achieve. If it\'s not possible to achieve any profit, return `0`. Note that you must buy before you sell. Analyze the given list and determine the optimal buy and sell dates to maximize the profit and return the maximum profit.","solution":"def max_profit(arr): Returns the maximum profit from an array of stock prices. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"You are given an array of integers `nums` and an integer `target`. Find the total number of contiguous subarrays within the array which have a sum equal to `target`. Implement the function `int countSubarraysWithSum(int[] nums, int target)` which returns the count of such subarrays.","solution":"def countSubarraysWithSum(nums, target): Returns the total number of contiguous subarrays which sum to target. count = 0 current_sum = 0 prefix_sums = {0: 1} # to store the frequency of prefix sums for num in nums: current_sum += num if current_sum - target in prefix_sums: count += prefix_sums[current_sum - target] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"You are provided with a large integer array `nums` and an integer `k`. The array consists of both positive and negative integers. Your task is to implement a function that finds the maximum sum of any contiguous subarray of length `k`. The function should return the maximum sum as an integer. If the length of `nums` is less than `k`, return 0. Implement the function `maxSubarraySumOfLengthK`: * `maxSubarraySumOfLengthK(int[] nums, int k)` - This method takes an integer array `nums` and an integer `k` as parameters and returns an integer representing the maximum sum of any contiguous subarray of length `k`. If `nums` is shorter than `k`, return 0. A contiguous subarray is a sequential subset of `nums`, and the length of the subarray must be exactly `k`.","solution":"def maxSubarraySumOfLengthK(nums, k): Returns the maximum sum of any contiguous subarray of length k. If the length of nums is less than k, return 0. n = len(nums) if n < k: return 0 max_sum = float(\'-inf\') current_sum = 0 # Compute the sum of the first window of length k for i in range(k): current_sum += nums[i] max_sum = current_sum # Slide the window over the array and compute the sums for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a `k`-sorted array, which is an array where each element is at most `k` positions away from its sorted position, design an algorithm to sort the array efficiently. You need to implement the function `sortKSortedArray(arr, k)` that takes an array `arr` and an integer `k`, and returns the sorted array. The function should strive to minimize both time and space complexity.","solution":"import heapq def sortKSortedArray(arr, k): Sort a k-sorted array (where each element is at most k positions away from its sorted position) efficiently. Args: arr (list of int): The k-sorted array to sort. k (int): The maximum distance that any element is away from its sorted position. Returns: list of int: The sorted array. # Create a min-heap of the first k+1 elements heap = arr[:k + 1] heapq.heapify(heap) # Index for the next element in the sorted array target_index = 0 # Process the remaining elements in the array for i in range(k + 1, len(arr)): arr[target_index] = heapq.heappop(heap) heapq.heappush(heap, arr[i]) target_index += 1 # Extract the remaining elements from the heap while heap: arr[target_index] = heapq.heappop(heap) target_index += 1 return arr"},{"question":"You are given a 2D integer array `grid` representing a `map` of `land` (1) and `water` (0). An island is a group of `1s` (land) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the `grid` are surrounded by water. Count the number of distinct islands. An island is considered distinct if and only if one island cannot be translated (moved) to match another island in the grid. Implement the `Solution` class with the following methods: * `Solution(int[][] grid)` Initializes the object with the 2D integer `array` `grid`. * `int numDistinctIslands()` Returns the number of distinct islands in the grid. Note: * Two islands are considered the same if they have the same shape, or can be translated (moved without rotation) to match one another.","solution":"class Solution: def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) self.visited = set() def numDistinctIslands(self): self.visited = set() distinct_islands = set() for row in range(self.rows): for col in range(self.cols): if self.grid[row][col] == 1 and (row, col) not in self.visited: shape = [] self.dfs(row, col, row, col, shape) distinct_islands.add(tuple(shape)) return len(distinct_islands) def dfs(self, row, col, base_row, base_col, shape): if (row < 0 or row >= self.rows or col < 0 or col >= self.cols or self.grid[row][col] == 0 or (row, col) in self.visited): return self.visited.add((row, col)) shape.append((row - base_row, col - base_col)) # Explore 4-directionally self.dfs(row+1, col, base_row, base_col, shape) self.dfs(row-1, col, base_row, base_col, shape) self.dfs(row, col+1, base_row, base_col, shape) self.dfs(row, col-1, base_row, base_col, shape)"},{"question":"Determine whether a given integer `n` is a **happy number**. A **happy number** is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** that does not include 1. Those numbers for which this process ends in 1 are happy. Return `true` if `n` is a happy number, and `false` if not. Use Floyd\'s Cycle-Finding Algorithm to detect cycles in the process.","solution":"def is_happy(n): Determines if a number n is a happy number. def get_next(number): return sum(int(char) ** 2 for char in str(number)) slow = n fast = get_next(n) while fast != 1 and slow != fast: slow = get_next(slow) fast = get_next(get_next(fast)) return fast == 1"},{"question":"Given an integer array `nums`, handle multiple queries of the following type: 1. **Update** the value of an element in `nums`. 2. Calculate the **maximum** value in the subarray defined by its starting and ending indices. Implement the NumArray class: * `NumArray(int[] nums)` initializes the object with the integer array `nums`. * `void update(int index, int val)` updates the value of `nums[index]` to be `val`. * `int maxRange(int left, int right)` returns the maximum value in the subarray `nums[left:right+1]`.","solution":"class NumArray: def __init__(self, nums): Initializes the object with the integer array nums. self.nums = nums def update(self, index, val): Updates the value of nums[index] to be val. self.nums[index] = val def maxRange(self, left, right): Returns the maximum value in the subarray nums[left:right+1]. return max(self.nums[left:right + 1])"},{"question":"You are given a string `sentence` which consists of words separated by single spaces, with no leading or trailing spaces. Each word in the `sentence` has a unique length. Return the words of the `sentence` sorted in ascending order of their lengths. If two words have the same length, they should appear in the order they do in the `sentence`.","solution":"def sort_sentence_by_word_length(sentence): Returns the words of the sentence sorted in ascending order of their lengths. Parameters: sentence (str): A string consisting of words separated by single spaces. Returns: str: A string where the words are sorted by their lengths in ascending order. words = sentence.split() words.sort(key=len) return \' \'.join(words)"},{"question":"You are given two strings `s` and `t` of length `n` each. You can swap any characters in `s` and `t` (i.e., choose one character `s[i]` from `s` and one character `t[i]` from `t`, and swap them). Return _the **minimum number** of swaps required to make the two strings equal_ or return `-1` if it is impossible to make the strings equal. **Note**: You can only swap characters at the same index in both strings, and both strings contain only lowercase English letters.","solution":"def min_swaps_to_equal(s, t): Returns the minimum number of swaps required to make the two strings equal or returns -1 if it is impossible to make the strings equal. :param s: str : input string s :param t: str : input string t :return: int : minimum number of swaps or -1 if impossible n = len(s) # Check if both strings have the same characters if sorted(s) != sorted(t): return -1 swaps = 0 s_list = list(s) t_list = list(t) for i in range(n): if s_list[i] != t_list[i]: # To find the character in t_list which is equal to s_list[i] and swap for j in range(i + 1, n): if t_list[j] == s_list[i] and t_list[j] != s_list[j]: t_list[j], t_list[i] = t_list[i], t_list[j] swaps += 1 break return swaps"},{"question":"You are given a list of `n` integers, each representing a unique ID of a group or team. Two teams can be identified as complementary if their IDs are such that the sum of the two IDs equals a given integer `m`. Return _the number of all unique complementary pairs that can be formed from the list_. A **pair (x, y)** is considered unique if **x != y** and **(x, y)** is different from **(y, x)**.","solution":"def count_complementary_pairs(ids, m): Returns the number of unique complementary pairs that can be formed from the list of ids such that the sum of the pair equals m. Args: ids (list): List of integers representing unique IDs. m (int): The target sum for pairs. Returns: int: Number of unique complementary pairs. id_set = set(ids) complementary_count = 0 seen = set() for id in ids: comp_id = m - id if comp_id in id_set and id not in seen and comp_id not in seen and id != comp_id: complementary_count += 1 seen.add(id) seen.add(comp_id) return complementary_count"},{"question":"You are given an integer array `arr` where each element represents the height of a building. There are two teams tasked with taking a photograph lineup where each member stands in front of one building. Each team should be lined up such that all members of the team are positioned in non-decreasing order of the buildings\' heights, i.e., each team sees a skyline where no building is taller than the next. Determine if it is possible to split the array into exactly two non-empty subarrays where both subarrays allow for the two teams to line up as described. Return `true` if such a split is possible, otherwise return `false`.","solution":"def can_split_to_two_non_decreasing_subarrays(arr): Determine if it is possible to split the array into exactly two non-empty subarrays where both subarrays are non-decreasing. Parameters: arr (list of int): The array representing the height of buildings. Returns: bool: True if such a split is possible; False otherwise. n = len(arr) if n < 2: return False # Create arrays to check non-decreasing order from left and right left = [0] * n right = [0] * n left[0] = arr[0] for i in range(1, n): left[i] = max(left[i - 1], arr[i]) right[-1] = arr[-1] for i in range(n - 2, -1, -1): right[i] = min(right[i + 1], arr[i]) for i in range(1, n): if left[i - 1] <= right[i]: return True return False"},{"question":"You are given a matrix `grid` of size `m x n` consisting of integers. You can perform an operation where you select an integer in the matrix and increase or decrease it by 1. Return _the minimum number of operations needed to make all the elements in the matrix equal_. If it is not possible to make all elements equal through the given operation, return -1.","solution":"def min_operations_to_equal_elements(grid): Calculate the minimum number of operations to make all elements in a matrix equal, where each operation consists of incrementing or decrementing an element by 1. If it\'s not possible to make all elements equal, return -1. m, n = len(grid), len(grid[0]) elems = [grid[i][j] for i in range(m) for j in range(n)] elems.sort() median = elems[len(elems) // 2] total_operations = sum(abs(x - median) for x in elems) return total_operations def can_make_all_elements_equal(grid): Helper function to check if all elements can be made equal. first_elem_mod = grid[0][0] % 2 for row in grid: for elem in row: if elem % 2 != first_elem_mod: return False return True def min_operations(grid): if not can_make_all_elements_equal(grid): return -1 return min_operations_to_equal_elements(grid)"},{"question":"You have been given an array of integers `arr`. An integer is a **peak** if it is greater than its adjacent elements. Similarly, an integer is a **valley** if it is smaller than its adjacent elements. Write a function to sort the array such that it forms alternating peaks and valleys. In other words, `arr[0]` should be less than or equal to `arr[1]`, which should be greater than or equal to `arr[2]`, and so on. You may need to reorder the elements in any valid manner to achieve this. If there are multiple valid solutions, any of them will be accepted. For example, given the array `[5, 3, 1, 2, 3]`, one possible solution may be `[3, 5, 1, 3, 2]`.","solution":"def peaks_and_valleys(arr): Sorts the array such that it forms alternating peaks and valleys. :param arr: List of integers. :return: List of integers in alternating peak and valley form. arr.sort() for i in range(1, len(arr) - 1, 2): arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr"},{"question":"A binary tree is defined as a valid binary search tree (BST) if and only if the nodes store values in a way such that each node\'s value is greater than any node in its left subtree and less than any node in its right subtree. Given the `root` of a binary tree, return _true_ if the tree is a valid BST, and _false_ otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root, low=float(\'-inf\'), high=float(\'inf\')): Returns True if the tree is a valid binary search tree (BST), otherwise False. if root is None: return True if not (low < root.val < high): return False return (is_valid_bst(root.left, low, root.val) and is_valid_bst(root.right, root.val, high))"},{"question":"Given a string `s`, you need to remove the minimum number of characters to ensure there are no two identical characters adjacent to each other. Return the modified string after such removals. If there are multiple solutions, return the one that appears first in the input.","solution":"def remove_adjacent_duplicates(s): Remove the minimum number of characters to ensure there are no two identical characters adjacent to each other. Parameters: s (str): input string Returns: str: modified string after removals if not s: return s result = [] result.append(s[0]) for i in range(1, len(s)): if result and s[i] == result[-1]: continue result.append(s[i]) return \'\'.join(result)"},{"question":"Given an input string, create a function to evaluate whether the parentheses in the string are balanced. The string can include the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Your function should return `true` if the string is valid, and `false` otherwise. A string is considered valid if every opening bracket has a corresponding closing bracket of the same type and the brackets are correctly nested. Here are some examples of valid and invalid strings: - `\\"()\\"` is valid. - `\\"()[]{}\\"` is valid. - `\\"(]\\"` is invalid. - `\\"([)]\\"` is invalid. - `\\"{[]}\\"` is valid. Write a function to determine if the input string is valid.","solution":"def is_valid_parentheses(s): Returns True if the input string has balanced parentheses, False otherwise. stack = [] mapping = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in mapping: top_element = stack.pop() if stack else \'#\' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"You are given a binary tree. Design an algorithm to flatten the binary tree to a linked list in-place. The linked list should be in the same order as a pre-order traversal of the binary tree. Each node in the binary tree has the following structure: ``` public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` You must implement the following function: ``` void flatten(TreeNode root) ``` The function should modify the given binary tree to result in a single linked list where each node\'s left child points to `null` and the right child points to the next node in the traversal order. Do not use any additional space for another data structure.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def flatten(root): Flattens the binary tree to a linked list in pre-order traversal order in-place. if not root: return # Use a helper function to recursively flatten the tree def flatten_tree(node): # Base case - if the node is None, return if not node: return None # Recursively flatten the left and right subtrees left_tail = flatten_tree(node.left) right_tail = flatten_tree(node.right) # If there was a left subtree, we need to re-link the nodes if left_tail: left_tail.right = node.right node.right = node.left node.left = None # Return the rightmost node after flattening return right_tail if right_tail else left_tail if left_tail else node flatten_tree(root)"},{"question":"You are given a **0-indexed** integer array `nums` representing a list of numbers. A **triplet** is defined as three distinct indices `(i, j, k)` such that `nums[i] + nums[j] + nums[k] = target`. Find all unique triplets in the array which give the sum of `target`. Triplets are defined as `(nums[i], nums[j], nums[k])`. Return _a list of all unique triplets `[nums[i], nums[j], nums[k]]` that sum to `target`. The triplets should be returned in non-decreasing order. If there are no such triplets, return an empty list. Triplet pairs `(i, j, k)` and `(a, b, c)` are considered unique if and only if the sets `{i, j, k}` and `{a, b, c}` are distinct even if they might contain identical elements._","solution":"def find_unique_triplets(nums, target): Find all unique triplets in the array which sum to target. :param nums: List of integers :param target: Integer target sum :return: List of triplets that sum to target, in non-decreasing order nums.sort() triplets = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicate values for the first element left, right = i + 1, n - 1 while left < right: curr_sum = nums[i] + nums[left] + nums[right] if curr_sum == target: triplets.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 # Skip duplicates for the second and third elements while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif curr_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"Given a string `s` containing only lowercase letters, you want to perform operations to make all characters in the string the same. In one operation, you can select any character in the string and change it to any other character. The cost of changing a character `c1` to a different character `c2` is given by a function `cost(c1, c2)` which returns an integer value representing the cost. You are given a 2D integer array `costArray`, where `costArray[i][j]` represents the cost of changing the character that is `i`-th in lexicographical order (where `i = 0` corresponds to \'a\', `i = 1` corresponds to \'b\', and so on) to the character that is `j`-th in lexicographical order. Return the minimum total cost to make all characters in the string `s` the same.","solution":"def min_total_cost(s, costArray): Returns the minimum total cost to make all characters in the string \'s\' the same. :param s: A string containing only lowercase letters :param costArray: A 2D list where costArray[i][j] represents the cost of changing the i-th character in lexicographical order to the j-th character :return: The minimum total cost from collections import Counter # Count the frequencies of each character in the string frequency = Counter(s) n = len(costArray) # Number of different characters total_costs = [] # Calculate the cost to convert all characters to each possible target character for target in range(n): total_cost = 0 for char, freq in frequency.items(): char_index = ord(char) - ord(\'a\') total_cost += costArray[char_index][target] * freq total_costs.append(total_cost) # Return the minimum cost found return min(total_costs)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`, where `nums[i]` represents the number of candies of different flavors in the `i-th` box. We define a **candy path** to be a collection of boxes that meets the following criteria: * The boxes are contiguous. * Each box contains at least one type of candy that is not present in the other boxes of the path. Return the length of the longest candy path. If there are multiple paths of the same maximum length, return the length of any one of them. If no such path exists, return `0`.","solution":"def longest_candy_path(nums): Returns the length of the longest candy path that meets the criteria. n = len(nums) if n == 0: return 0 max_length = 0 for start in range(n): unique_candies = set() current_length = 0 for end in range(start, n): if nums[end] in unique_candies: break unique_candies.add(nums[end]) current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform the following operation any number of times: remove a character from the string only if it appears more than once consecutively. Your task is to find the minimum length of the string after performing the operation as many times as possible. Return the minimum length of the string after removing all possible consecutive duplicate characters.","solution":"def remove_consecutive_duplicates(s): Returns the minimum length of the string after removing all possible consecutive duplicate characters. if not s: return 0 stack = [] for char in s: if stack and stack[-1] == char: continue stack.append(char) return len(stack)"},{"question":"You are given an array of integers `nums`. You need to implement a data structure that supports the following operations: 1. `insert(int index, int val)`: Inserts `val` at the specified `index` in the array. 2. `erase(int index)`: Removes the element at the specified `index` from the array. 3. `get(int index)`: Retrieves the value at the specified `index` from the array. Implement the `CustomArray` class: * `CustomArray(int[] nums)` Initializes the `CustomArray` object with the integer array `nums`. * `void insert(int index, int val)` Inserts `val` at `index` in the array. * `void erase(int index)` Removes the element at `index` from the array. * `int get(int index)` Returns the element at `index` in the array.","solution":"class CustomArray: def __init__(self, nums): Initializes the CustomArray object with the given list of integers. :param nums: List[int] self.nums = nums def insert(self, index, val): Inserts val at the specified index in the array. :param index: int :param val: int self.nums.insert(index, val) def erase(self, index): Removes the element at the specified index from the array. :param index: int if index < len(self.nums): self.nums.pop(index) def get(self, index): Retrieves the value at the specified index in the array. :param index: int :return: int if 0 <= index < len(self.nums): return self.nums[index] return None"},{"question":"You are given a linked list where each node contains an integer value. Implement a function to reorganize the linked list so that all nodes with values less than a given `x` come before nodes with values greater than or equal to `x`. The original relative order of the nodes in each partition should be preserved. Your function should return the modified linked list. Define the ListNode class and implement the following method: * `ListNode* partition(ListNode* head, int x)` Rearranges the linked list based on the value `x` and returns the head of the modified list. **Example:** - Input: `head = [1, 4, 3, 2, 5, 2]`, `x = 3` - Output: `[1, 2, 2, 4, 3, 5]` Ensure that the definition of the ListNode class is provided for context.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, x): Rearranges the linked list based on the value x and returns the head of the modified list. before_head = ListNode(0) # Dummy head for the \'before\' list before = before_head after_head = ListNode(0) # Dummy head for the \'after\' list after = after_head while head: if head.val < x: before.next = head before = before.next else: after.next = head after = after.next head = head.next after.next = None # End the \'after\' list before.next = after_head.next # Connect \'before\' list to \'after\' list return before_head.next"},{"question":"Given a string `s` consisting of lowercase English letters, you are allowed to perform at most one operation where you can choose any character in the string and change it to any other lowercase English letter. Return the length of the longest palindromic subsequence that can be obtained after performing the allowed operation at most once. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. A **palindromic sequence** is one that reads the same backward as forward.","solution":"def longest_palindromic_subsequence_with_one_change(s): # Helper function to calculate longest # palindromic subsequence for given string def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1] max_len = longest_palindromic_subsequence(s) # Try all possible single character changes for i in range(len(s)): for ch in \'abcdefghijklmnopqrstuvwxyz\': if s[i] != ch: new_s = s[:i] + ch + s[i+1:] max_len = max(max_len, longest_palindromic_subsequence(new_s)) return max_len"},{"question":"# Additional Question for Coding Assessment: [Question 4]: Given an array of integers `nums`, a **132 pattern** is a subsequence of three integers `nums[i]`, `nums[j]`, and `nums[k]` such that `i < j < k` and `nums[i] < nums[k] < nums[j]`. Design an algorithm that determines whether there is a 132 pattern in `nums`. Return _`true` if there is a 132 pattern in `nums`, otherwise return `false`._","solution":"def find132pattern(nums): Determine if there is a 132 pattern in the given list of integers. if len(nums) < 3: return False min_i = nums[0] stack = [] for j in range(1, len(nums)): while stack and nums[j] >= stack[-1][1]: stack.pop() if stack and nums[j] > stack[-1][0]: return True stack.append((min_i, nums[j])) min_i = min(min_i, nums[j]) return False"},{"question":"You are given a binary matrix `mat` of size `m x n`, where each cell contains either a `0` or a `1`. A cell is said to be connected to another cell if they share a side. A connected component in the matrix is a set of `1`s that are connected to each other, either directly or indirectly. Your task is to find the size of the largest connected component of `1`s in the matrix. For example, consider the binary matrix: ``` mat = [ [1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 1], [1, 0, 1, 1] ] ``` In this case, the largest connected component of `1`s has a size of `4`.","solution":"def largest_connected_component(mat): Finds the size of the largest connected component of 1\'s in the given binary matrix. if not mat: return 0 m, n = len(mat), len(mat[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): if x < 0 or y < 0 or x >= m or y >= n or visited[x][y] or mat[x][y] == 0: return 0 visited[x][y] = True size = 1 # Current cell # Explore all 4 possible directions size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size max_size = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and not visited[i][j]: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` distinct numbers in the inclusive range [0, n]. Due to some error, one of the numbers in the range [0, n] is missing. Write a function to find and return that missing number.","solution":"def find_missing_number(nums): Finds and returns the missing number in the nums list. Args: nums (list of int): The input list of distinct integers. Returns: int: The missing number in the range [0, n]. n = len(nums) total_sum = n * (n + 1) / 2 # sum of first n natural numbers actual_sum = sum(nums) return int(total_sum - actual_sum)"},{"question":"You are given a list of `transactions` where each transaction is represented as an array of strings `[account_from, account_to, time, amount]`. Let\'s define a valid transaction list as a subset of transactions that meets the following criteria: - The time of any transaction in the list is strictly increasing. - The cumulative amount of money being transferred from any single `account_from` does not exceed a given limit `limit`. Determine the maximum number of valid transactions that can be obtained from the given list of transactions. Return an integer that represents the length of this list.","solution":"def max_valid_transactions(transactions, limit): Determine the maximum number of valid transactions based on time and amount criteria. Args: transactions (list of list of str): The transaction list where each transaction is formatted as [account_from, account_to, time, amount]. limit (int): The maximum allowed cumulative amount from any single account. Returns: int: The length of the maximum subset of valid transactions. # Step 1: Parse transactions and sort by time transactions = sorted(transactions, key=lambda x: x[2]) # Step 2: Initialize cumulative amounts and count cumulative_amounts = {} count = 0 for transaction in transactions: account_from = transaction[0] amount = int(transaction[3]) if account_from not in cumulative_amounts: cumulative_amounts[account_from] = 0 # Step 3: Check if adding this transaction remains within the limit if cumulative_amounts[account_from] + amount <= limit: cumulative_amounts[account_from] += amount count += 1 return count"},{"question":"Given an integer array `nums`, design a data structure that supports the following operations efficiently: * `void increment(int k, int val)` - Increment the first `k` elements of the array by `val`. If `k` exceeds the length of the array, increment all elements. * `int get(int index)` - Returns the value at the `index` position in the array. Implement the `IncrementArray` class: * `IncrementArray(int[] nums)` - Initializes the object with the integer array `nums`. * `void increment(int k, int val)` - See above. * `int get(int index)` - See above.","solution":"class IncrementArray: def __init__(self, nums): Initializes the object with the integer array nums. self.nums = nums def increment(self, k, val): Increment the first k elements of the array by val. If k exceeds the length of the array, increment all elements. length = len(self.nums) for i in range(min(k, length)): self.nums[i] += val def get(self, index): Returns the value at the index position in the array. return self.nums[index]"},{"question":"You are given an integer array `heights` representing the heights of columns situated in a row. You are also given an integer `bricks` which you can use to climb as many columns as possible. Each time you climb a column, you must use the amount of bricks equal to the height difference between the current column and the next column. If the next column is shorter or of equal height, no bricks are needed. You also have `ladders` that you can use to completely bypass climbing a higher column regardless of the height difference. Return _the maximum number of columns you can climb using the given_ `bricks` _and_ `ladders`.","solution":"import heapq def furthest_building(heights, bricks, ladders): Returns the maximum number of columns that can be climbed using the given bricks and ladders. :param heights: List[int] - A list of integers representing the heights of columns. :param bricks: int - Number of bricks available. :param ladders: int - Number of ladders available. :return: int - Index of the furthest column that can be reached. heap = [] for i in range(len(heights) - 1): diff = heights[i + 1] - heights[i] if diff > 0: heapq.heappush(heap, diff) if len(heap) > ladders: bricks -= heapq.heappop(heap) if bricks < 0: return i return len(heights) - 1"},{"question":"You are given a 2D grid of size `m x n`. Each cell represents a plot of land that can either be `water` or `land`. The grid\'s top-left corner is located at `(0, 0)` and the bottom-right corner is at `(m-1, n-1)`. Land cells are represented by `1` and water cells are represented by `0`. You can only move up, down, left, or right from a land cell to another land cell. Your task is to find the largest island in the grid. An island is a group of `1`s connected horizontally or vertically. Implement the `GridAnalyzer` class: * `GridAnalyzer()` Initializes the class object. * `int getMaxIslandSize(int[][] grid)` Returns the size of the largest island in the grid. If there is no land in the grid, return 0.","solution":"from typing import List class GridAnalyzer: def __init__(self): self.rows = 0 self.cols = 0 self.grid = [] self.visited = [] def getMaxIslandSize(self, grid: List[List[int]]) -> int: if not grid: return 0 self.rows = len(grid) self.cols = len(grid[0]) self.grid = grid self.visited = [[False] * self.cols for _ in range(self.rows)] max_island_size = 0 for r in range(self.rows): for c in range(self.cols): if self.grid[r][c] == 1 and not self.visited[r][c]: size = self.dfs(r, c) max_island_size = max(max_island_size, size) return max_island_size def dfs(self, r, c): if r < 0 or r >= self.rows or c < 0 or c >= self.cols or self.grid[r][c] == 0 or self.visited[r][c]: return 0 self.visited[r][c] = True size = 1 # Current cell # Explore all 4 directions size += self.dfs(r + 1, c) size += self.dfs(r - 1, c) size += self.dfs(r, c + 1) size += self.dfs(r, c - 1) return size"},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform the following operations on `s` any number of times: - Select any character in the string and remove it. - Select two consecutive characters that are the same and remove them. Return the length of the longest possible string you can obtain such that the string does not contain any consecutive identical characters.","solution":"def longest_possible_string(s): Returns the length of the longest possible string that does not contain any consecutive identical characters. if not s: return 0 # Initialize the result with the first character result = [s[0]] # Iterate through the string starting from the second character for char in s[1:]: if result and char != result[-1]: result.append(char) return len(result)"},{"question":"You are given a list `tasks` where each task is represented by an integer indicating the number of units of work required to complete it. Each day, you can work on one or more tasks but you can only complete tasks in the exact order they appear in the list. If you choose to work on a task, you must complete it before starting another task, and you can decide to work for any number of continuous days on the current task but you cannot switch tasks mid-day. Your goal is to minimize the number of days needed to complete all tasks. Return the minimum number of days needed to finish all tasks.","solution":"def min_days(tasks): Returns the minimum number of days needed to finish all tasks. Parameters: tasks (List[int]): List of integers representing tasks required units of work Returns: int: Minimum number of days needed to complete all tasks # The number of days needed is simply the number of tasks because # each task will be worked on one at a time in sequence. return len(tasks)"},{"question":"Write a function that takes a string `s` consisting of only lowercase English letters, and returns a new string with the characters in `s` sorted in **lexicographical order**. If the string is empty, return an empty string.","solution":"def sort_string(s): Returns a new string with the characters in s sorted in lexicographical order. If the string is empty, returns an empty string. return \\"\\".join(sorted(s))"},{"question":"**You are given a sorted integer array `arr` of length `n` and a target integer `x`. You need to find a pair of integers from the array whose sum is closest to `x`. If there are multiple pairs with the same closest sum, return the pair with the smallest integers. Return _an array containing the pair of integers whose sum is closest to_ `x`_.**","solution":"def closest_pair(arr, x): Returns a pair of integers whose sum is closest to x. If multiple pairs qualify, the pair with the smallest integers is returned. n = len(arr) if n < 2: return [] left, right = 0, n - 1 closest_pair = [arr[left], arr[right]] closest_diff = abs(arr[left] + arr[right] - x) while left < right: current_sum = arr[left] + arr[right] current_diff = abs(current_sum - x) if current_diff < closest_diff: closest_diff = current_diff closest_pair = [arr[left], arr[right]] elif current_diff == closest_diff: if arr[left] < closest_pair[0] or (arr[left] == closest_pair[0] and arr[right] < closest_pair[1]): closest_pair = [arr[left], arr[right]] if current_sum < x: left += 1 else: right -= 1 return closest_pair"},{"question":"You are given a list of integers called `nums` which represents the number of tasks in different queues. Your goal is to evenly distribute these tasks across queues such that the difference between the maximum number of tasks in any queue and the minimum number of tasks in any queue is minimized after redistribution. Write a function `balancedDistribution(nums: List[int], k: int) -> List[int]` that returns a list of integers representing the new task distribution. Here, `k` is the maximum number of tasks that can be moved from one queue to another in one operation. Perform the redistribution in the least number of moves possible. **Note:** The resulting list does not need to be sorted. For example, given `nums = [10, 5, 30]` and `k = 5`, an optimal distribution would be `[15, 15, 15]` with 5 moves.","solution":"from typing import List def balancedDistribution(nums: List[int], k: int) -> List[int]: total_tasks = sum(nums) n = len(nums) avg_tasks = total_tasks // n extra_tasks = total_tasks % n # Create the initial balanced distribution balanced = [avg_tasks] * n for i in range(extra_tasks): balanced[i] += 1 num_transfers = 0 for i in range(n): while nums[i] > balanced[i]: for j in range(n): if nums[i] > balanced[i]: if nums[j] < balanced[j]: move = min(nums[i] - balanced[i], balanced[j] - nums[j], k) nums[i] -= move nums[j] += move num_transfers += 1 return nums"},{"question":"Given a linked list, each node containing an integer value, determine whether the linked list is a palindrome. A palindrome is a sequence that reads the same backward as forward. Return `true` if the linked list is a palindrome, otherwise return `false`. The algorithm should use O(1) extra space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head): Determines if a singly linked list is a palindrome. :param head: ListNode, the head of a singly linked list :return: boolean, True if the linked list is a palindrome, False otherwise if head is None or head.next is None: return True # Find the middle of the linked list using fast and slow pointers slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list prev = None while slow: next_node = slow.next slow.next = prev prev = slow slow = next_node # Check palindrome by comparing the two halves left, right = head, prev while right: # Only need to compare till the end of the second half if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"You are given an array of strings `words` and a string `target`. Your task is to find the minimum number of `words` from the array that concatenates to form the `target` string. Each string in `words` can be used any number of times. If it is impossible to form the `target` string from the given array, return -1. Write a function to achieve this.","solution":"def min_words_to_form_target(words, target): Returns the minimum number of words that concatenate to form the target string. If it\'s impossible to form the target, returns -1. from collections import deque # Initialize the queue with a starting point (current string, number of words used) queue = deque([(target, 0)]) visited = set([target]) while queue: current, steps = queue.popleft() if current == \\"\\": return steps for word in words: if current.startswith(word): new_target = current[len(word):] if new_target not in visited: visited.add(new_target) queue.append((new_target, steps + 1)) return -1"},{"question":"Given a binary tree with `n` nodes, each node has a unique value from `1` to `n`. The binary tree is represented by a 2D integer array `tree` where each element `tree[i] = [parenti, childi, isLeft]` representing: - `parenti` is the value of the parent node, - `childi` is the value of the child node, and - `isLeft` is `1` if the child node is a left child and `0` if the child node is a right child. Reconstruct the binary tree and return the value of the node that has the maximum depth. In case of a tie, return the smallest value among the deepest nodes.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(tree): if not tree: return None nodes = {} for parent, child, isLeft in tree: if parent not in nodes: nodes[parent] = TreeNode(parent) if child not in nodes: nodes[child] = TreeNode(child) if isLeft == 1: nodes[parent].left = nodes[child] else: nodes[parent].right = nodes[child] # Find the root (a node that is never a child) children = set(child for _, child, _ in tree) root = next(node for node in nodes.values() if node.val not in children) return root def find_deepest_node(root): if not root: return None from collections import deque queue = deque([(root, 0)]) max_depth = -1 smallest_deepest_val = float(\'inf\') while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth smallest_deepest_val = node.val elif depth == max_depth: smallest_deepest_val = min(smallest_deepest_val, node.val) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return smallest_deepest_val def find_deepest_node_value(tree): root = build_tree(tree) return find_deepest_node(root)"},{"question":"You have a 2D grid of size `m` x `n` where you start at the top-left corner `(0, 0)` and can only move either down or right at any point in time. Your goal is to find the number of unique paths from the top-left corner to the bottom-right corner. Now consider if some obstacles are added to the grids. Each obstacle is denoted by a `1` and empty spaces are denoted by a `0`. How many unique paths would there be? The 2D grid is represented by an array `grid` of size `m x n`, and you need to return _the total number of unique paths from top-left to bottom-right that avoid all obstacles_. ```python def uniquePathsWithObstacles(grid: List[List[int]]) -> int: # Write your code here. ```","solution":"def uniquePathsWithObstacles(grid): Given a 2D grid of size m x n, return the number of unique paths from the top-left corner to the bottom-right corner where some cells might have obstacles. Obstacles are denoted by 1 and empty spaces are denoted by 0. :param grid: List[List[int]], the 2D grid with obstacles :return: int, the number of unique paths avoiding obstacles m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"You are given an array of positive integers `nums` and an integer `target`. You are allowed to insert the addition (`\'+\'`) or multiplication (`\'*\'`) operators between any pair of integers in `nums`. Determine if there is a way to insert the operators such that the resulting expression evaluates to `target`. Return `true` if it is possible, otherwise return `false`. Note that the order of integers in `nums` must remain the same when forming the expression.","solution":"def is_possible_expression(nums, target): Determines if it is possible to insert \'+\' or \'*\' between numbers in `nums` to reach `target`. def helper(index, current_sum): if index == len(nums): return current_sum == target # Try adding the current number add_result = helper(index + 1, current_sum + nums[index]) # Try multiplying by the current number multiply_result = helper(index + 1, current_sum * nums[index]) return add_result or multiply_result if not nums: return target == 0 return helper(1, nums[0])"},{"question":"Given a string `s` consisting of lowercase letters, you need to compress it using the following algorithm: Compress the string such that consecutive occurrences of the same character are replaced with the character followed by the number of occurrences. If the compressed string is not shorter than the original string, return the original string. For example, the string `aabcccccaaa` would be compressed to `a2b1c5a3`. Return the compressed string or the original string based on the described criteria.","solution":"def compress_string(s): Compress the string s such that consecutive occurrences of the same character are replaced with the character followed by the number of occurrences. Return the compressed string if it is shorter than the original string; otherwise, return the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"You are given an integer array `arr` and an integer `target`. Your task is to determine if there are three distinct elements in `arr` that add up to the `target`. Return `true` if such a triplet exists, and `false` otherwise. A triplet is considered distinct if all three elements have different indices in the array.","solution":"def three_sum(arr, target): Determines if there are three distinct elements in arr that add up to target. Parameters: arr (list): A list of integers. target (int): The target sum. Returns: bool: True if there exists such a triplet, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a ***0-indexed*** integer array `values` representing the number of values in each of several bins. You need to redistribute the values in such a way that the sum of the values in each bin becomes equal, if possible. You may only increment or decrement the value of any bin by exactly `1` in each move. Return the ***minimum*** number of moves required to achieve such equal distribution. If it is not possible to make all the bins equal, return `-1`.","solution":"def min_moves_to_equal(values): Returns the minimum number of moves required to make all bins have equal values or -1 if it\'s not possible. n = len(values) total = sum(values) if total % n != 0: return -1 target_value = total // n moves = 0 for value in values: moves += abs(value - target_value) return moves // 2"},{"question":"Given an integer array `nums` of size `n`, your task is to partition the array into **contiguous subarrays** such that each subarray has a unique sum. The goal is to determine the **minimum number of partitions** required to achieve this. Return the minimum number of partitions needed for `nums`.","solution":"def min_partitions(nums): Given an array of integers, partition the array into contiguous subarrays such that each subarray has a unique sum. Return the minimum number of partitions needed. n = len(nums) partitions = 0 i = 0 while i < n: current_set = set() current_sum = 0 while i < n and current_sum not in current_set: current_set.add(current_sum) current_sum += nums[i] i += 1 partitions += 1 return partitions"},{"question":"You are given a string `s` and an integer `t`. You need to delete exactly `t` characters from the string `s` so that the resulting string forms the lexicographically smallest string possible. Return the resulting string after deleting `t` characters. If the string cannot be formed, return an empty string.","solution":"def remove_characters(s, t): Removes exactly t characters from the string s to form the lexicographically smallest string possible. If the string cannot be formed, returns an empty string. if len(s) <= t: return \\"\\" stack = [] remaining = t for char in s: while stack and remaining and stack[-1] > char: stack.pop() remaining -= 1 stack.append(char) result = \\"\\".join(stack[:len(s) - t]) return result"},{"question":"You are given a list `students` where each element is a tuple `(name, grade)` representing the name and grade of a student. Your task is to find the names of the students who have the highest grade in the class. If there are multiple students with the same highest grade, return their names in alphabetical order. Write a function that takes in the list `students` and returns a list of names of the top students in alphabetical order.","solution":"def top_students(students): Returns a list of names of students with the highest grade in alphabetical order. Parameters: students (list): List of tuples where each tuple contains the name and grade of a student. Returns: list: List of names in alphabetical order who have the highest grade. if not students: return [] # Find the maximum grade among the students max_grade = max(students, key=lambda x: x[1])[1] # Collect names of students with the maximum grade top_students = [name for name, grade in students if grade == max_grade] # Sort names in alphabetical order top_students_sorted = sorted(top_students) return top_students_sorted"},{"question":"4. You are given a binary tree where each node contains an integer value. Write a function that rearranges the tree in place such that all nodes follow the properties of a **Binary Search Tree (BST)** while maintaining the original tree structure\'s shape (i.e., the node values are rearranged but the tree\'s physical structure is unchanged). Return the root of the modified tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_rearrange(root): def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node] + inorder_traversal(node.right) def assign_values_to_tree(nodes, values): for node, value in zip(nodes, values): node.val = value if not root: return None # Perform in-order traversal to get all nodes nodes_inorder = inorder_traversal(root) # Extract values and sort them values_inorder = [node.val for node in nodes_inorder] values_inorder.sort() # Assign sorted values to the tree nodes assign_values_to_tree(nodes_inorder, values_inorder) return root"},{"question":"You are given a 2D integer array `intervals` where each `intervals[i] = [start_i, end_i]` represents an interval. Check if a person could attend all meetings. Return _`true` if a person can attend all meetings, otherwise return `false`_.","solution":"def can_attend_all_meetings(intervals): Determines if a person can attend all given intervals (meetings). Args: intervals: List of [start, end] intervals. Returns: True if a person can attend all meetings, otherwise False. # Sort intervals by start time intervals.sort(key=lambda x: x[0]) # Check for overlapping intervals for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"Implement a **cache** system that adheres to the Least Recently Used (LRU) principle. The cache should provide the following functionalities: * `LRUCache(int capacity)` Initializes the cache with a positive size capacity. * `int get(int key)` Returns the value of the `key` if the `key` exists in the cache. Otherwise, return `-1`. * `void put(int key, int value)` Updates or inserts the value if the `key` is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. The cache should be efficient, with each operation running in constant time complexity.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 value = self.cache.pop(key) self.cache[key] = value # Mark it as most recently used return value def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # pop the first item (the least recently used) self.cache[key] = value"},{"question":"Given an integer array `arr`, find the contiguous subarray (containing at least one number) which has the largest product and return its product. A contiguous subarray is a subarray within an array that is continuous, meaning that the subarray elements are consecutive elements in the original array.","solution":"def max_product_subarray(arr): Returns the maximum product of a contiguous subarray. if not arr: return 0 max_product = min_product = global_max = arr[0] for num in arr[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) global_max = max(global_max, max_product) return global_max"},{"question":"You are given a string `s` and an integer `n`. You need to return a new string with the characters of `s` rotated to the right by `n` positions. A right rotation by 1 position moves the last character to the front of the string, rotating all other characters one position to the right. For example, right-rotating the string `abcde` by 1 results in the string `eabcd`. If `n` is greater than the length of the string, the function should handle it appropriately. Return _the string obtained by right-rotating `s` by `n` positions_.","solution":"def rotate_string_right(s, n): Returns the string obtained by right-rotating s by n positions. Parameters: s (str): The original string. n (int): The number of positions to rotate the string by. Returns: str: The rotated string. if len(s) == 0: return s # Ensure n is within the bounds of the string length n = n % len(s) return s[-n:] + s[:-n]"},{"question":"You are given a **0-indexed** integer array `nums` representing the number of stones in different piles. You are allowed to perform any number of moves, where a move consists of removing exactly `m` stones from a single pile. Each move can be only performed if the pile contains at least `m` stones. Your task is to maximize the number of moves that can be performed. Return _the **maximum number of moves** you can perform_.","solution":"def max_moves(nums, m): Returns the maximum number of moves that can be performed, where each move consists of removing exactly `m` stones from a single pile. total_moves = 0 for pile in nums: total_moves += pile // m return total_moves"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a line. A building is considered **good** if it is taller than or equal to all the buildings to its right. Return an array of integers representing the indices of all the **good** buildings. The indices should be listed in ascending order.","solution":"def good_buildings(heights): Returns the indices of the good buildings in ascending order. A building is considered a good building if it is taller than or equal to all the buildings to its right. :param heights: List of integers representing the heights of buildings. :return: List of integers representing the indices of good buildings. n = len(heights) # If no buildings or single building, return all indices since they are trivially good if n <= 1: return list(range(n)) good_buildings_indices = [] max_height_from_right = float(\'-inf\') for i in range(n-1, -1, -1): if heights[i] >= max_height_from_right: good_buildings_indices.append(i) max_height_from_right = max(max_height_from_right, heights[i]) return sorted(good_buildings_indices)"},{"question":"You are given a string `s` consisting of only characters `\'a\'`, `\'b\'`, and `\'c\'`. Each of these characters can be independently replaced by any string consisting only of characters `\'a\'`, `\'b\'`, and `\'c\'`. Write a function to find the minimum number of replacements needed to make the string `s` a palindrome. A palindrome is a string that reads the same backward as forward. Return _the minimum number of replacements needed_.","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of replacements needed to make the string `s` a palindrome. Parameters: s (str): The input string consisting of characters \'a\', \'b\', and \'c\'. Returns: int: The minimum number of replacements needed. n = len(s) replacements = 0 # Compare each character with its corresponding character from the end for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"Given a matrix of size `m x n` filled with non-negative integers, return the length of the **shortest path** from the top-left cell to the bottom-right cell, such that you can move only in the four cardinal directions (up, down, left, right), and the sum of all numbers along the path must be **even**. If there is no such path, return `-1`.","solution":"from collections import deque def is_valid(i, j, m, n): Check if the coordinates (i, j) are within the matrix bounds. return 0 <= i < m and 0 <= j < n def shortest_even_sum_path(matrix): Returns the length of the shortest path from the top-left to the bottom-right cell of the matrix such that the sum of all numbers along the path is even. if not matrix or not matrix[0]: return -1 m, n = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, matrix[0][0], 0)]) # (i, j, current_sum, path_length) visited = set((0, 0, matrix[0][0] % 2)) # (i, j, current_sum_parity) while queue: i, j, current_sum, path_length = queue.popleft() # Check if we\'ve reached the bottom-right cell with an even sum if (i, j) == (m - 1, n - 1) and current_sum % 2 == 0: return path_length for di, dj in directions: ni, nj = i + di, j + dj if is_valid(ni, nj, m, n): new_sum = current_sum + matrix[ni][nj] new_sum_parity = new_sum % 2 if (ni, nj, new_sum_parity) not in visited: visited.add((ni, nj, new_sum_parity)) queue.append((ni, nj, new_sum, path_length + 1)) return -1"},{"question":"You are given a string representing a mathematical expression containing integers and the operators `+` and `-`. The string expression does not contain any spaces. Your task is to evaluate the expression and return the result as an integer. For example, given the input string \\"3+2-4\\", the function should return 1, and for the input string \\"10-5+3\\" the function should return 8. Note: The input string will always be a valid mathematical expression, and the integers will be non-negative. The evaluation should be done from left to right, respecting the natural order of operation with `+` and `-`.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers and the operators `+` and `-`. index = 0 total = 0 current_number = 0 current_operator = \'+\' while index < len(expression): char = expression[index] if char.isdigit(): current_number = current_number * 10 + int(char) if char in \'+-\' or index == len(expression) - 1: if current_operator == \'+\': total += current_number elif current_operator == \'-\': total -= current_number current_number = 0 current_operator = char index += 1 return total"},{"question":"A binary string is a string containing only the characters \'0\' and \'1\'. Given a binary string `s`, you can change at most `k` characters from \'0\' to \'1\'. Return _the length of the longest contiguous substring containing only \'1\'s that can be obtained after performing the change operations_. Compute the maximum possible length of such a substring.","solution":"def longest_ones(s, k): Computes the length of the longest contiguous substring containing only \'1\'s after changing at most \'k\' characters from \'0\' to \'1\'. :param s: The binary string of \'0\'s and \'1\'s. :param k: The maximum number of \'0\'s that can be changed to \'1\'s. :return: The length of the longest contiguous substring containing only \'1\'s. left = 0 max_length = 0 zero_count = 0 for right in range(len(s)): if s[right] == \'0\': zero_count += 1 while zero_count > k: if s[left] == \'0\': zero_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array of `n` integers and an integer `k`. A \\"nice\\" subarray is a contiguous subsequence of the array where the number of distinct integers is less than or equal to `k`. Write a function to return the length of the longest \\"nice\\" subarray in the given array. Return 0 if no such subarray exists.","solution":"def longest_nice_subarray(arr, k): Returns the length of the longest \\"nice\\" subarray where the number of distinct integers <= k. Parameters: arr (List[int]): The input array of integers. k (int): The maximum number of distinct integers allowed in a \\"nice\\" subarray. Returns: int: Length of the longest \\"nice\\" subarray. from collections import defaultdict if k == 0: return 0 n = len(arr) left = 0 right = 0 max_length = 0 distinct_count = 0 freq = defaultdict(int) while right < n: if freq[arr[right]] == 0: distinct_count += 1 freq[arr[right]] += 1 while distinct_count > k: freq[arr[left]] -= 1 if freq[arr[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"Given an integer array `arr` and an integer `target`, return the indices of two distinct elements such that their sum is equal to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Your answer should be returned as an array `[index1, index2]` where `index1` and `index2` are the two indices in ascending order. If no such elements exist, return an empty array.","solution":"def two_sum(arr, target): Returns indices of two distinct elements such that their sum equals to the target. The indices should be returned in ascending order. :param arr: List[int] - list of integers :param target: int - the target sum :return: List[int] - list containing the indices of the elements whose sum equals to target seen = {} for i, num in enumerate(arr): complement = target - num if complement in seen: return [seen[complement], i] seen[num] = i return []"},{"question":"Given a string `s` consisting of characters \'a\', \'b\', and \'c\', you need to perform the following operation any number of times (including zero): choose any substring of `s` and replace all characters \'a\' in that substring with \'b\', all characters \'b\' with \'c\', and all characters \'c\' with \'a\'. Your task is to determine if it\'s possible to make the string contain only one unique character by performing the operation. Return `true` if you can make all characters in the string the same, otherwise return `false`.","solution":"def can_make_uniform(s): Determine if it\'s possible to make the string contain only one unique character. if not s: return True # Check for uniform string by comparing with the first character first_char = s[0] return all(char == first_char for char in s)"},{"question":"You are given a binary tree in the form of a list of values where `None` represents a missing node. Write a function that checks whether this binary tree is a valid Binary Search Tree (BST). A valid BST is defined as follows: 1. The left subtree of a node contains only nodes with keys **less than** the node\'s key. 2. The right subtree of a node contains only nodes with keys **greater than** the node\'s key. 3. Both the left and right subtrees must also be binary search trees. Implement the function `isValidBST(root: List[Optional[int]]) -> bool` which takes the root of a binary tree as a list and returns `True` if the tree is a valid BST and `False` otherwise. *Example*: Given `root = [2, 1, 3]`, the function should return `True` because: ``` 2 / 1 3 ``` The left subtree of node `2` contains `1` which is less than `2`, and the right subtree contains `3` which is greater than `2`. All subtrees also meet the properties of a BST. If `root = [5, 1, 4, None, None, 3, 6]`, the function should return `False` because: ``` 5 / 1 4 / 3 6 ``` The right node of `5` contains `4`, but `4` has a left child of `3` which is not greater than `5`.","solution":"from typing import List, Optional def isValidBST(root: List[Optional[int]]) -> bool: def validate(index: int, low: Optional[int], high: Optional[int]) -> bool: if index >= len(root) or root[index] is None: return True value = root[index] if (low is not None and value <= low) or (high is not None and value >= high): return False left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 return validate(left_child_index, low, value) and validate(right_child_index, value, high) return validate(0, None, None)"},{"question":"Given a string `str`, you need to compress it using the following algorithm: For a group of consecutive repeating characters in the string, replace it with the character followed by the number of its repetitions. If a character does not repeat consecutively, it should appear exactly once in the output. The compression should be only done if it reduces the string length. Return the compressed string if it is shorter than the original, otherwise return the original string. Example: - Input: `str = \\"aaabbccccd\\"` Output: \\"a3b2c4d\\" - Input: `str = \\"abcd\\"` Output: \\"abcd\\"","solution":"def compress_string(s): compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + (str(count) if count > 1 else \'\')) count = 1 compressed.append(s[-1] + (str(count) if count > 1 else \'\')) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"You are given a **0-indexed integer** array `nums` of length `n`. An operation on the array is defined as follows: * Choose any two different indices `i` and `j` (where `0 <= i, j < n`). * Swap the elements `nums[i]` and `nums[j]`. You are also given another integer array `target` of the same length `n`. Return `true` if it is possible to make the array `nums` equal to `target` by performing the given operation **exactly once**. Otherwise, return `false`.","solution":"def can_swap_to_match(nums, target): Check if it\'s possible to make the array nums equal to target by performing exactly one swap operation. if nums == target: return False diff_indices = [i for i in range(len(nums)) if nums[i] != target[i]] if len(diff_indices) != 2: return False i, j = diff_indices nums[i], nums[j] = nums[j], nums[i] return nums == target"},{"question":"Write a function that takes a string representing a serial number and checks if it is valid. A valid serial number must satisfy the following conditions: * It must be exactly 10 characters long. * It must start with three uppercase letters. * The next five characters must be digits. * The last two characters must be uppercase letters. * It should not contain any spaces or special characters. The function should return `true` if the serial number is valid, and `false` otherwise.","solution":"import re def is_valid_serial(serial: str) -> bool: Checks if the given serial number is valid. Parameters: - serial: a string representing the serial number. Returns: - True if the serial number is valid, False otherwise. if len(serial) != 10: return False if not re.match(r\'^[A-Z]{3}[0-9]{5}[A-Z]{2}\', serial): return False return True"},{"question":"You are given a string `s` which represents a valid mathematical expression containing operators `+`, `-`, `*`, `/` and non-negative integers. Operators and operands are separated by spaces. Execute the expression and return the result as an integer. Note that the division should truncate towards zero. The given expression is guaranteed to be valid, so there are no parentheses or invalid characters.","solution":"def evaluate_expression(s): Evaluate a mathematical expression in string format and return the result as an integer. tokens = s.split() stack = [] current = 0 operator = \'+\' for token in tokens + [\'+\']: if token.isdigit(): num = int(token) if operator == \'+\': stack.append(num) elif operator == \'-\': stack.append(-num) elif operator == \'*\': stack.append(stack.pop() * num) elif operator == \'/\': stack.append(int(stack.pop() / num)) else: operator = token return sum(stack)"},{"question":"You are given an array `tasks` where each element represents the amount of time required to complete a specific task, and an integer `k` representing the number of workers available. Each worker can be assigned to at most one task at a time, and the tasks must be completed sequentially. Return the minimum amount of total time required to complete all the tasks if the workload is distributed optimally among the `k` workers.","solution":"def min_time_to_complete_tasks(tasks, k): Returns the minimum total time required to complete all tasks optimally distributed among k workers. def can_complete_in_time(time_limit): workers_needed, current_time = 1, 0 for task in tasks: if current_time + task <= time_limit: current_time += task else: workers_needed += 1 current_time = task if workers_needed > k: return False return True left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_complete_in_time(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given two strings `s1` and `s2`. Determine the length of the longest substring that is a palindrome formed by merging the two strings. A substring is a contiguous sequence of characters within a string. To form a palindrome substring, you may take any part of `s1` and `s2` as long as they are in order. For example, if `s1 = \\"abac\\"` and `s2 = \\"cab\\"`, a valid palindrome substring could be `\\"aba\\"`. **Compute the length** of the longest possible palindromic substring formed by merging `s1` and `s2`.","solution":"def longest_palindrome_substring_length(s1, s2): Computes the length of the longest possible palindromic substring formed by merging s1 and s2. def lcs(X, Y): m = len(X) n = len(Y) # Initialize a table to store the length of LCS L = [[0] * (n + 1) for _ in range(m + 1)] # Build the L[m+1][n+1] table in bottom-up fashion for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i - 1] == Y[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: L[i][j] = max(L[i - 1][j], L[i][j - 1]) return L[m][n] s2_reversed = s2[::-1] return lcs(s1, s2_reversed)"},{"question":"Write a function to solve the **shortest path problem** in a graph using Dijkstra\'s algorithm. The function should take a directed graph, represented as an adjacency list, and two vertices, `start` and `end`. It should return the length of the shortest path from `start` to `end`. If there is no path, return -1. The input graph will have non-negative edge weights.","solution":"import heapq def dijkstra(graph, start, end): Function to find the shortest path from start to end vertices in a graph using Dijkstra\'s algorithm. :param graph: A dictionary where keys are vertices and values are lists of tuples (neighbor, weight). :param start: Starting vertex. :param end: Destination vertex. :return: Length of the shortest path from start to end. If no path exists, return -1. # Priority queue to store (distance, vertex) queue = [(0, start)] # Dictionary to store the minimum distance to reach each vertex distances = {vertex: float(\'inf\') for vertex in graph} distances[start] = 0 while queue: current_distance, current_vertex = heapq.heappop(queue) # If we reached the end vertex, return the distance if current_vertex == end: return current_distance # Proceed if the popped vertex distance is the minimum if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor)) # If the end vertex was never reached return -1"},{"question":"You are given a string `s` consisting of lowercase English letters. A new string is formed by removing exactly one character from `s` and that new string is a subsequence of `t`. Write a function to determine if the new string can be rearranged to form a palindrome. A string is a **subsequence** of another string if it can be derived by deleting some or none of the characters without changing the order of the remaining characters. Return `true` if it is possible to rearrange the new string to form a palindrome, otherwise return `false`.","solution":"def can_form_palindrome_after_removal(s, t): Determines if a new string formed by removing exactly one character from s can be rearranged to form a palindrome and is a subsequence of t. # Helper function to check if a string can be rearranged to form a palindrome def can_be_palindrome(s): freq = {} for ch in s: freq[ch] = freq.get(ch, 0) + 1 odd_count = sum(1 for count in freq.values() if count % 2 != 0) return odd_count <= 1 def is_subsequence(s, t): it = iter(t) return all(c in it for c in s) for i in range(len(s)): new_string = s[:i] + s[i + 1:] if is_subsequence(new_string, t) and can_be_palindrome(new_string): return True return False"},{"question":"You are given an integer array `nums` and an integer `target`. You are allowed to perform at most `k` operations, where in each operation you can increment or decrement an element of the array by `1`. Your task is to determine if it\'s possible to obtain a non-empty subarray whose sum is equal to `target` after performing the operations. A subarray is a contiguous part of an array. Return `true` if such a subarray exists, and `false` otherwise.","solution":"def can_obtain_target_sum(nums, target, k): def is_possible(start, end, required_ops): if required_ops <= k: return True else: return False n = len(nums) for i in range(n): for j in range(i, n): subarray = nums[i:j+1] current_sum = sum(subarray) difference = abs(target - current_sum) if is_possible(i, j, difference): return True return False"},{"question":"You are given an array of integers `arr` representing a series of `n` daily temperatures. Return an array `answer` such that `answer[i]` is the number of days you would have to wait after the `i-th` day to get a higher temperature. If there is no future day for which this is possible, keep `answer[i] = 0` instead. For example, given the array `arr = [73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`. Implement the function: ```python def dailyTemperatures(arr: List[int]) -> List[int]: ```","solution":"from typing import List def dailyTemperatures(arr: List[int]) -> List[int]: Returns a list where each element represents the number of days until a warmer temperature for each day in the input list. n = len(arr) answer = [0] * n stack = [] # This will store indices of the temperatures list for i in range(n): while stack and arr[i] > arr[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"A company has `n` departments, labeled from `0` to `n - 1`, each managing a set of projects. You are given a 2D integer array `projects`, where `projects[i]` contains a list of unique integers representing the project IDs managed by department `i`. Each project is managed by exactly one department. You are also given a list of project dependencies `dependencies`, where `dependencies[j] = [a, b]` means that project `b` cannot be started until project `a` is completed. These dependencies form a directed acyclic graph (DAG). You need to determine the minimum number of departments that need to coordinate simultaneously to complete all their projects, following the given dependencies. Return _the minimum number of departments required to be active at the same time to ensure completion of all projects_.","solution":"from collections import defaultdict, deque def min_active_departments(projects, dependencies): Returns the minimum number of departments that need to be active simultaneously to ensure completion of all projects. :param projects: List[List[int]] - 2D integer array where projects[i] contains project IDs managed by department i :param dependencies: List[List[int]] - List of dependencies where dependencies[j] = [a, b] means project b cannot start until project a is completed :return: int - minimum number of departments required to be active at the same time # Build project to department mapping project_to_dept = {} for dept, proj_list in enumerate(projects): for proj in proj_list: project_to_dept[proj] = dept # Graph construction indegree = defaultdict(int) graph = defaultdict(list) for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Topological sorting using Kahn\'s algorithm zero_indegree_queue = deque([proj for proj in project_to_dept if indegree[proj] == 0]) topo_order = [] active_depts = set() while zero_indegree_queue: current_proj = zero_indegree_queue.popleft() topo_order.append(current_proj) active_depts.add(project_to_dept[current_proj]) for neighbor in graph[current_proj]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # The size of active_depts set in the end will give the minimum departments required return len(active_depts)"},{"question":"A new fitness app measures users\' activities over a specific period. You are given an array `activities` where `activities[i]` indicates the type of activity done on the `i-th` day, and an integer `d` which represents the number of days required to form a complete cycle of the fitness program. An activity cycle is defined to be a period of `d` consecutive days. For example, if `d = 3`, then `[activity1, activity2, activity3]` forms a cycle. Given these details, your task is to find the maximum number of complete activity cycles present in the `activities` array. If it is not possible to form any complete cycle, return `0`. Note that overlapping cycles are not allowed.","solution":"def count_complete_cycles(activities, d): Returns the number of complete cycles of length d within the activities array. Parameters: activities (list): List of activities. d (int): Length of each cycle. Returns: int: Number of complete cycles. if d <= 0: return 0 return len(activities) // d"},{"question":"You are given a non-empty string `s` consisting of only lowercase English letters. Consider all the possible substrings of `s`. For each substring, find its longest palindromic prefix. Return _the length of the longest palindromic prefix among all the substrings_.","solution":"def longest_palindromic_prefix_length(s): def is_palindrome(substr): return substr == substr[::-1] max_length = 0 n = len(s) for i in range(n): for j in range(i, n): substring = s[i:j+1] for k in range(len(substring), 0, -1): if is_palindrome(substring[:k]): max_length = max(max_length, k) break return max_length"},{"question":"You are given a list of tasks represented by an array of integers `tasks`, where each integer represents the time required to complete a task. You are also given an integer `k` representing the number of workers available to complete these tasks. Each task can only be assigned to one worker, and each worker can only work on one task at a time. Implement a function `assignTasks(tasks, k)` that distributes the tasks among the workers such that the maximum time any worker has to work is minimized. The function should return the minimized maximum working time. - `assignTasks(List[int] tasks, int k) -> int`","solution":"from typing import List def canComplete(tasks: List[int], k: int, mid: int) -> bool: workers_needed = 1 current_worker_time = 0 for task in tasks: if current_worker_time + task <= mid: current_worker_time += task else: workers_needed += 1 current_worker_time = task if workers_needed > k: return False return True def assignTasks(tasks: List[int], k: int) -> int: left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if canComplete(tasks, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given two strings, `s1` and `s2`, both of which consist of lowercase English letters. Your task is to determine if you can transform `s1` into `s2` using the following operations: - Replace any character in `s1` with another character. - Insert any character into `s1`. - Delete any character from `s1`. You are allowed to perform an arbitrary number of these operations. Determine the minimum number of operations required to transform `s1` into `s2`. Return an integer representing the minimum number of operations needed. Example: ```python s1 = \\"horse\\" s2 = \\"ros\\" Output: 3 Explanation: horse -> rorse (replace \'h\' with \'r\') rorse -> rose (remove \'r\') rose -> ros (remove \'e\') Note: 0 <= len(s1), len(s2) <= 500 ```","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to transform s1 into s2. Operations allowed: replace, insert, delete. m, n = len(s1), len(s2) # Create a DP table to store the minimum edit distance dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for base cases for i in range(m + 1): dp[i][0] = i # s1 to empty string for j in range(n + 1): dp[0][j] = j # empty string to s2 # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match else: dp[i][j] = min( dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1] # Replace ) + 1 return dp[m][n]"}]'),A={name:"App",components:{PoemCard:Y},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},L={class:"card-container"},z={key:0,class:"empty-state"},S=["disabled"],D={key:0},C={key:1};function E(i,e,u,f,s,a){const c=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):l("",!0)]),t("div",L,[(n(!0),r(y,null,w(a.displayedPoems,(o,g)=>(n(),v(c,{key:g,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),r("div",z,' No results found for "'+h(s.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),r("span",C,"Loading...")):(n(),r("span",D,"See more"))],8,S)):l("",!0)])}const G=m(A,[["render",E],["__scopeId","data-v-d079e3ac"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/5.md","filePath":"library/5.md"}'),P={name:"library/5.md"},M=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{O as __pageData,M as default};
